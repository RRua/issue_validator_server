diff --git a/app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt b/app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt
index 7fc24d46..0ac5bf4c 100644
--- a/app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt
+++ b/app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt
@@ -22,20 +22,219 @@
 package ch.threema.app
 
 import ch.threema.app.managers.CoreServiceManager
-import ch.threema.app.multidevice.MultiDeviceManagerImpl
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.multidevice.linking.DeviceLinkingStatus
+import ch.threema.app.services.ContactService
+import ch.threema.app.services.UserService
+import ch.threema.app.stores.IdentityStore
 import ch.threema.app.stores.PreferenceStoreInterface
-import ch.threema.app.tasks.TaskArchiverImpl
-import ch.threema.app.utils.DeviceCookieManagerImpl
+import ch.threema.app.tasks.TaskCreator
+import ch.threema.base.crypto.HashedNonce
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.crypto.NonceStore
+import ch.threema.domain.helpers.TransactionAckTaskCodec
 import ch.threema.domain.models.AppVersion
+import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
+import ch.threema.domain.protocol.D2mProtocolDefines
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
+import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseListener
+import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
+import ch.threema.domain.protocol.connection.data.D2dMessage
+import ch.threema.domain.protocol.connection.data.D2mProtocolVersion
+import ch.threema.domain.protocol.connection.data.DeviceId
+import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
+import ch.threema.domain.protocol.multidevice.MultiDeviceProperties
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.QueueSendCompleteListener
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskArchiver
+import ch.threema.domain.taskmanager.TaskCodec
 import ch.threema.domain.taskmanager.TaskManager
 import ch.threema.storage.DatabaseServiceNew
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.channels.Channel
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.flowOf
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
 
 class TestCoreServiceManager(
     override val version: AppVersion,
     override val databaseService: DatabaseServiceNew,
     override val preferenceStore: PreferenceStoreInterface,
-    override val taskArchiver: TaskArchiverImpl,
-    override val deviceCookieManager: DeviceCookieManagerImpl,
-    override val taskManager: TaskManager,
-    override val multiDeviceManager: MultiDeviceManagerImpl,
-): CoreServiceManager
+    override val taskArchiver: TaskArchiver = TestTaskArchiver(),
+    override val deviceCookieManager: DeviceCookieManager = TestDeviceCookieManager(),
+    override val taskManager: TaskManager = TestTaskManager(TransactionAckTaskCodec()),
+    override val multiDeviceManager: MultiDeviceManager = TestMultiDeviceManager(),
+    override val identityStore: IdentityStore = IdentityStore(preferenceStore),
+    override val nonceFactory: NonceFactory = NonceFactory(TestNonceStore()),
+) : CoreServiceManager
+
+class TestTaskArchiver(initialTasks: List<Task<*, TaskCodec>> = emptyList()) : TaskArchiver {
+    private val archivedTasks: MutableList<Task<*, TaskCodec>> = initialTasks.toMutableList()
+
+    override fun addTask(task: Task<*, TaskCodec>) {
+        archivedTasks.add(task)
+    }
+
+    override fun removeTask(task: Task<*, TaskCodec>) {
+        val index = archivedTasks.indexOf(task)
+        if (index < 0) {
+            return
+        }
+
+        if (index == 0) {
+            archivedTasks.removeAt(index)
+        } else {
+            throw AssertionError("Task $index is removed, but it is not the oldest task")
+        }
+    }
+
+    override fun loadAllTasks(): List<Task<*, TaskCodec>> {
+        return archivedTasks
+    }
+}
+
+class TestDeviceCookieManager : DeviceCookieManager {
+    override fun obtainDeviceCookie() = ByteArray(16)
+    override fun changeIndicationReceived() {
+        // Nothing to do
+    }
+
+    override fun deleteDeviceCookie() {
+        // Nothing to do
+    }
+}
+
+class TestTaskManager(
+    val taskCodec: TaskCodec
+) : TaskManager {
+    private val taskQueue = Channel<QueueElement<Any>>()
+
+    private data class QueueElement<T>(
+        val task: Task<T, TaskCodec>,
+        val deferred: CompletableDeferred<T>,
+    )
+
+    init {
+        CoroutineScope(Dispatchers.Default).launch {
+            while (true) {
+                val (task, deferred) = taskQueue.receive()
+                try {
+                    deferred.complete(task.invoke(taskCodec))
+                } catch (e: Throwable) {
+                    deferred.completeExceptionally(e)
+                }
+            }
+        }
+    }
+
+    override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> {
+        val deferred = CompletableDeferred<R>()
+        runBlocking {
+            @Suppress("UNCHECKED_CAST")
+            taskQueue.send(QueueElement(task, deferred) as QueueElement<Any>)
+        }
+        return deferred
+    }
+
+    override fun hasPendingTasks() = false
+
+    override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+        // Nothing to do
+    }
+
+    override fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+        // Nothing to do
+    }
+}
+
+class TestMultiDeviceManager(
+    override val isMdDisabledOrSupportsFs: Boolean = true,
+    override val isMultiDeviceActive: Boolean = false,
+    override val propertiesProvider: MultiDevicePropertyProvider = TestMultiDevicePropertyProvider,
+    override val socketCloseListener: D2mSocketCloseListener = D2mSocketCloseListener { },
+    override val latestSocketCloseReason: Flow<D2mSocketCloseReason?> = flowOf(),
+) : MultiDeviceManager {
+    override suspend fun activate(
+        deviceLabel: String,
+        contactService: ContactService,
+        userService: UserService,
+        fsMessageProcessor: ForwardSecurityMessageProcessor,
+        taskCreator: TaskCreator,
+    ) {
+        throw AssertionError("Not supported")
+    }
+
+    override suspend fun deactivate(
+        userService: UserService,
+        fsMessageProcessor: ForwardSecurityMessageProcessor,
+        taskCreator: TaskCreator,
+    ) {
+        throw AssertionError("Not supported")
+    }
+
+    override suspend fun setDeviceLabel(deviceLabel: String) {
+        throw AssertionError("Not supported")
+    }
+
+    override suspend fun linkDevice(
+        deviceJoinOfferUri: String,
+        taskCreator: TaskCreator,
+    ): Flow<DeviceLinkingStatus> {
+        throw AssertionError("Not supported")
+    }
+
+    override suspend fun purge(taskCreator: TaskCreator) {
+        throw AssertionError("Not supported")
+    }
+
+    override suspend fun loadLinkedDevicesInfo(taskCreator: TaskCreator): List<String> {
+        throw AssertionError("Not supported")
+    }
+}
+
+class TestNonceStore : NonceStore {
+    override fun exists(scope: NonceScope, nonce: Nonce) = false
+
+    override fun store(scope: NonceScope, nonce: Nonce) = true
+
+    override fun getCount(scope: NonceScope) = 0L
+
+    override fun getAllHashedNonces(scope: NonceScope): List<HashedNonce> = emptyList()
+
+    override fun addHashedNoncesChunk(
+        scope: NonceScope,
+        chunkSize: Int,
+        offset: Int,
+        nonces: MutableList<HashedNonce>,
+    ) {
+        // Nothing to do
+    }
+
+    override fun insertHashedNonces(scope: NonceScope, nonces: List<HashedNonce>) = true
+
+}
+
+object TestMultiDevicePropertyProvider : MultiDevicePropertyProvider {
+    override fun get() =
+        MultiDeviceProperties(
+            0u,
+            DeviceId(0u),
+            DeviceId(0u),
+            MultiDeviceKeys(ByteArray(D2mProtocolDefines.DGK_LENGTH_BYTES)),
+            D2dMessage.DeviceInfo(
+                D2dMessage.DeviceInfo.Platform.ANDROID,
+                "",
+                "",
+                ""
+            ),
+            D2mProtocolVersion(UInt.MIN_VALUE, UInt.MAX_VALUE)
+        ) { }
+}
diff --git a/app/src/androidTest/java/ch/threema/app/backuprestore/csv/BackupServiceTest.java b/app/src/androidTest/java/ch/threema/app/backuprestore/csv/BackupServiceTest.java
index 0dc64c7f..2a2e1a3a 100644
--- a/app/src/androidTest/java/ch/threema/app/backuprestore/csv/BackupServiceTest.java
+++ b/app/src/androidTest/java/ch/threema/app/backuprestore/csv/BackupServiceTest.java
@@ -48,15 +48,18 @@ import java.util.List;
 import java.util.Objects;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.WorkerThread;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 import androidx.test.filters.LargeTest;
 import androidx.test.rule.GrantPermissionRule;
 import ch.threema.app.DangerousTest;
-import ch.threema.app.testutils.TestHelpers;
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.DeleteAllContactsBackgroundTask;
+import ch.threema.app.asynctasks.DeleteContactServices;
 import ch.threema.app.backuprestore.BackupRestoreDataConfig;
-import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.ConversationService;
@@ -65,9 +68,14 @@ import ch.threema.app.services.FileService;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.MessageService;
 import ch.threema.app.services.ballot.BallotService;
+import ch.threema.app.testutils.TestHelpers;
 import ch.threema.app.utils.CSVReader;
 import ch.threema.app.utils.CSVRow;
+import ch.threema.app.utils.executor.BackgroundExecutor;
+import ch.threema.base.ThreemaException;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.identitybackup.IdentityBackupDecoder;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.data.status.VoipStatusDataModel;
 import java8.util.stream.StreamSupport;
@@ -86,6 +94,7 @@ public class BackupServiceTest {
 	private static @NonNull String TEST_IDENTITY;
 
 	// Services
+	private @NonNull ServiceManager serviceManager;
 	private @NonNull FileService fileService;
     private @NonNull MessageService messageService;
     private @NonNull ConversationService conversationService;
@@ -93,6 +102,10 @@ public class BackupServiceTest {
     private @NonNull ContactService contactService;
     private @NonNull DistributionListService distributionListService;
     private @NonNull BallotService ballotService;
+	private @NonNull APIConnector apiConnector;
+	private @NonNull ContactModelRepository contactModelRepository;
+
+	private final @NonNull BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
 
 	@Rule
 	public GrantPermissionRule permissionRule = getReadWriteExternalStoragePermissionRule();
@@ -112,7 +125,7 @@ public class BackupServiceTest {
 	 */
 	@Before
 	public void loadServices() throws Exception {
-		final ServiceManager serviceManager = Objects.requireNonNull(ThreemaApplication.getServiceManager());
+		this.serviceManager = Objects.requireNonNull(ThreemaApplication.getServiceManager());
 		this.fileService = serviceManager.getFileService();
 		this.messageService = serviceManager.getMessageService();
 		this.conversationService = serviceManager.getConversationService();
@@ -120,12 +133,14 @@ public class BackupServiceTest {
 		this.contactService = serviceManager.getContactService();
 		this.distributionListService = serviceManager.getDistributionListService();
 		this.ballotService = serviceManager.getBallotService();
+		this.apiConnector = serviceManager.getAPIConnector();
+		this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
 	}
 
 	/**
 	 * Return the list of backups for the TEST_IDENTITY identity.
 	 */
-	private @NonNull List<File> getUserBackups(@NonNull File backupPath) throws FileSystemNotPresentException {
+	private @NonNull List<File> getUserBackups(@NonNull File backupPath) {
 		if (backupPath.exists() && backupPath.isDirectory()) {
 			final File[] files = backupPath.listFiles(
 				(dir, name) -> name.startsWith("threema-backup_" + TEST_IDENTITY)
@@ -139,7 +154,7 @@ public class BackupServiceTest {
 	/**
 	 * Helper method: Create a backup with the specified config, return backup file.
 	 */
-	private @NonNull File doBackup(BackupRestoreDataConfig config) throws Exception {
+	private @NonNull File doBackup(BackupRestoreDataConfig config) {
 		// List old backups
 		final File backupPath = this.fileService.getBackupPath();
 		final List<File> initialBackupFiles = this.getUserBackups(backupPath);
@@ -250,18 +265,18 @@ public class BackupServiceTest {
         this.messageService.removeAll();
         this.conversationService.reset();
         this.groupService.removeAll();
-        this.contactService.removeAll();
+        this.backgroundExecutor.execute(getContactDeleteTask());
         this.distributionListService.removeAll();
         this.ballotService.removeAll();
 
         // Insert test data:
 	    // Contacts
-	    final ContactModel contact1 = this.contactService.createContactByIdentity("CDXVZ5E4", true);
+	    final ContactModel contact1 = createContact("CDXVZ5E4");
 	    contact1.setFirstName("Fritzli");
 	    contact1.setLastName("Bühler");
 	    this.contactService.save(contact1);
-	    final ContactModel contact2 = this.contactService.createContactByIdentity("DRMWZP3H", true);
-	    this.contactService.createContactByIdentity("ECHOECHO", true);
+	    final ContactModel contact2 = createContact("DRMWZP3H");
+	    createContact("ECHOECHO");
 	    // Messages contact 1
 	    this.messageService.sendText("Bonjour!", this.contactService.createReceiver(contact1));
 	    this.messageService.sendText("Phở?", this.contactService.createReceiver(contact1));
@@ -330,5 +345,47 @@ public class BackupServiceTest {
         }
     }
 
+	@NonNull
+	@WorkerThread
+	private ContactModel createContact(@NonNull String identity) {
+		new BasicAddOrUpdateContactBackgroundTask(
+			identity,
+			ContactModel.AcquaintanceLevel.DIRECT,
+			TEST_IDENTITY,
+			apiConnector,
+			contactModelRepository,
+			AddContactRestrictionPolicy.CHECK,
+			ApplicationProvider.getApplicationContext(),
+			null
+		).runSynchronously();
+
+		ContactModel contactModel = contactService.getByIdentity(identity);
+		if (contactModel == null) {
+			throw new IllegalStateException("Contact is null after creating it");
+		}
+		return contactModel;
+	}
+
+	@NonNull
+	private DeleteAllContactsBackgroundTask getContactDeleteTask() throws ThreemaException {
+		return new DeleteAllContactsBackgroundTask(
+			serviceManager.getModelRepositories().getContacts(),
+			new DeleteContactServices(
+				serviceManager.getUserService(),
+				serviceManager.getContactService(),
+				serviceManager.getConversationService(),
+				serviceManager.getRingtoneService(),
+				serviceManager.getMutedChatsListService(),
+				serviceManager.getHiddenChatsListService(),
+				serviceManager.getProfilePicRecipientsService(),
+				serviceManager.getWallpaperService(),
+				serviceManager.getFileService(),
+				serviceManager.getExcludedSyncIdentitiesService(),
+				serviceManager.getDHSessionStore(),
+				serviceManager.getNotificationService(),
+				serviceManager.getDatabaseServiceNew()
+			)
+		);
+	}
 
 }
diff --git a/app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt b/app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt
index 73675bda..c4ad2e43 100644
--- a/app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt
@@ -21,15 +21,21 @@
 
 package ch.threema.app.contacts
 
+import android.os.Looper
+import ch.threema.app.TestCoreServiceManager
 import ch.threema.app.ThreemaApplication
 import ch.threema.app.asynctasks.AddContactRestrictionPolicy
 import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask
 import ch.threema.app.asynctasks.AlreadyVerified
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask
+import ch.threema.app.asynctasks.ContactCreated
 import ch.threema.app.asynctasks.ContactExists
-import ch.threema.app.asynctasks.Failed
-import ch.threema.app.asynctasks.ContactAddResult
 import ch.threema.app.asynctasks.ContactModified
-import ch.threema.app.asynctasks.Success
+import ch.threema.app.asynctasks.ContactResult
+import ch.threema.app.asynctasks.InvalidThreemaId
+import ch.threema.app.asynctasks.RemotePublicKeyMismatch
+import ch.threema.app.asynctasks.UserIdentity
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.executor.BackgroundExecutor
 import ch.threema.data.TestDatabaseService
@@ -42,7 +48,6 @@ import ch.threema.domain.protocol.SSLSocketFactoryFactory
 import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.domain.protocol.api.APIConnector.FetchIdentityResult
 import ch.threema.domain.protocol.api.APIConnector.HttpConnectionException
-import ch.threema.storage.models.ContactModel
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel
 import com.neilalexander.jnacl.NaCl
 import kotlinx.coroutines.runBlocking
@@ -51,20 +56,28 @@ import org.junit.Before
 import java.net.HttpURLConnection
 import kotlin.test.Test
 import kotlin.test.assertEquals
-import kotlin.test.assertTrue
 import kotlin.test.assertFalse
+import kotlin.test.assertNotEquals
+import kotlin.test.assertTrue
 import kotlin.test.fail
 
 class AddOrUpdateContactBackgroundTaskTest {
 
     private val backgroundExecutor = BackgroundExecutor()
     private lateinit var databaseService: TestDatabaseService
+    private lateinit var coreServiceManager: CoreServiceManager
     private lateinit var contactModelRepository: ContactModelRepository
 
     @Before
     fun before() {
         databaseService = TestDatabaseService()
-        contactModelRepository = ModelRepositories(databaseService).contacts
+        val serviceManager = ThreemaApplication.requireServiceManager()
+        coreServiceManager = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseService,
+            preferenceStore = serviceManager.preferenceStore,
+        )
+        contactModelRepository = ModelRepositories(coreServiceManager).contacts
     }
 
     @Test
@@ -78,19 +91,50 @@ class AddOrUpdateContactBackgroundTaskTest {
                     it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                     it.featureMask = 12
                     it.type = 0
-                    it.state = IdentityState.ACTIVE
+                    it.state = IdentityState.ACTIVE.value
                 }
             },
             {
-                assertTrue(it is Success)
+                assertTrue(it is ContactCreated)
+                assertEquals(newIdentity, it.contactModel.identity)
+                val data = it.contactModel.data.value!!
+                assertEquals(newIdentity, data.identity)
+                assertArrayEquals(ByteArray(NaCl.PUBLICKEYBYTES), data.publicKey)
+                assertEquals(12u, data.featureMask)
+                assertEquals(IdentityType.NORMAL, data.identityType)
+                assertEquals(IdentityState.ACTIVE, data.activityState)
+                assertEquals(VerificationLevel.UNVERIFIED, data.verificationLevel)
+                assertEquals(AcquaintanceLevel.DIRECT, data.acquaintanceLevel)
+            }
+        )
+    }
+
+    @Test
+    fun testAddGroupContactSuccessful() {
+        val newIdentity = "01234567"
+
+        testAddingContact(
+            fetchIdentity = { identity ->
+                FetchIdentityResult().also {
+                    it.identity = identity
+                    it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
+                    it.featureMask = 12
+                    it.type = 0
+                    it.state = IdentityState.ACTIVE.value
+                }
+            },
+            acquaintanceLevel = AcquaintanceLevel.GROUP,
+            runOnFinished = {
+                assertTrue(it is ContactCreated)
                 assertEquals(newIdentity, it.contactModel.identity)
                 val data = it.contactModel.data.value!!
                 assertEquals(newIdentity, data.identity)
                 assertArrayEquals(ByteArray(NaCl.PUBLICKEYBYTES), data.publicKey)
                 assertEquals(12u, data.featureMask)
                 assertEquals(IdentityType.NORMAL, data.identityType)
-                assertEquals(ContactModel.State.ACTIVE, data.activityState)
+                assertEquals(IdentityState.ACTIVE, data.activityState)
                 assertEquals(VerificationLevel.UNVERIFIED, data.verificationLevel)
+                assertEquals(AcquaintanceLevel.GROUP, data.acquaintanceLevel)
             }
         )
     }
@@ -106,19 +150,20 @@ class AddOrUpdateContactBackgroundTaskTest {
                     it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                     it.featureMask = 127
                     it.type = 1
-                    it.state = IdentityState.INACTIVE
+                    it.state = IdentityState.INACTIVE.value
                 }
             },
             {
-                assertTrue(it is Success)
+                assertTrue(it is ContactCreated)
                 assertEquals(newIdentity, it.contactModel.identity)
                 val data = it.contactModel.data.value!!
                 assertEquals(newIdentity, data.identity)
                 assertArrayEquals(ByteArray(NaCl.PUBLICKEYBYTES), data.publicKey)
                 assertEquals(127u, data.featureMask)
                 assertEquals(IdentityType.WORK, data.identityType)
-                assertEquals(ContactModel.State.INACTIVE, data.activityState)
+                assertEquals(IdentityState.INACTIVE, data.activityState)
                 assertEquals(VerificationLevel.FULLY_VERIFIED, data.verificationLevel)
+                assertEquals(AcquaintanceLevel.DIRECT, data.acquaintanceLevel)
             },
             publicKey = ByteArray(NaCl.PUBLICKEYBYTES),
         )
@@ -134,11 +179,11 @@ class AddOrUpdateContactBackgroundTaskTest {
                     it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                     it.featureMask = 127
                     it.type = 1
-                    it.state = IdentityState.INACTIVE
+                    it.state = IdentityState.INACTIVE.value
                 }
             },
             {
-                assertTrue(it is Failed)
+                assertTrue(it is UserIdentity)
             },
             newIdentity = myIdentity,
             myIdentity = myIdentity,
@@ -154,11 +199,11 @@ class AddOrUpdateContactBackgroundTaskTest {
                     it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                     it.featureMask = 12
                     it.type = 0
-                    it.state = IdentityState.ACTIVE
+                    it.state = IdentityState.ACTIVE.value
                 }
             },
             {
-                assertTrue(it is Failed)
+                assertTrue(it is RemotePublicKeyMismatch)
             },
             publicKey = ByteArray(NaCl.PUBLICKEYBYTES).also { it.fill(1) }
         )
@@ -171,7 +216,7 @@ class AddOrUpdateContactBackgroundTaskTest {
                 throw HttpConnectionException(HttpURLConnection.HTTP_NOT_FOUND, Exception())
             },
             {
-                assertTrue(it is Failed)
+                assertTrue(it is InvalidThreemaId)
             }
         )
     }
@@ -184,7 +229,7 @@ class AddOrUpdateContactBackgroundTaskTest {
                 it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                 it.featureMask = 12
                 it.type = 0
-                it.state = IdentityState.ACTIVE
+                it.state = IdentityState.ACTIVE.value
             }
         }
 
@@ -192,7 +237,7 @@ class AddOrUpdateContactBackgroundTaskTest {
         testAddingContact(
             apiConnectorResult,
             {
-                assertTrue(it is Success)
+                assertTrue(it is ContactCreated)
             }
         )
 
@@ -215,7 +260,7 @@ class AddOrUpdateContactBackgroundTaskTest {
                 it.publicKey = publicKey
                 it.featureMask = 12
                 it.type = 0
-                it.state = IdentityState.ACTIVE
+                it.state = IdentityState.ACTIVE.value
             }
         }
 
@@ -223,7 +268,7 @@ class AddOrUpdateContactBackgroundTaskTest {
         testAddingContact(
             apiConnectorResult,
             {
-                assertTrue(it is Success)
+                assertTrue(it is ContactCreated)
             },
             publicKey = publicKey,
         )
@@ -239,7 +284,7 @@ class AddOrUpdateContactBackgroundTaskTest {
     }
 
     @Test
-    fun testAddGroupContact() {
+    fun testUpgradeGroupContact() {
         val newIdentity = "01234567"
 
         val apiConnectorResult: (identity: String) -> FetchIdentityResult = { identity ->
@@ -248,7 +293,7 @@ class AddOrUpdateContactBackgroundTaskTest {
                 it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                 it.featureMask = 12
                 it.type = 0
-                it.state = IdentityState.ACTIVE
+                it.state = IdentityState.ACTIVE.value
             }
         }
 
@@ -256,7 +301,7 @@ class AddOrUpdateContactBackgroundTaskTest {
         testAddingContact(
             apiConnectorResult,
             {
-                assertTrue(it is Success)
+                assertTrue(it is ContactCreated)
             },
             newIdentity = newIdentity
         )
@@ -292,7 +337,7 @@ class AddOrUpdateContactBackgroundTaskTest {
                 it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                 it.featureMask = 12
                 it.type = 0
-                it.state = IdentityState.ACTIVE
+                it.state = IdentityState.ACTIVE.value
             }
         }
 
@@ -300,7 +345,7 @@ class AddOrUpdateContactBackgroundTaskTest {
         testAddingContact(
             apiConnectorResult,
             {
-                assertTrue(it is Success)
+                assertTrue(it is ContactCreated)
             },
             newIdentity = newIdentity
         )
@@ -310,14 +355,17 @@ class AddOrUpdateContactBackgroundTaskTest {
         // Assert that the verification level is unverified
         assertEquals(VerificationLevel.UNVERIFIED, contactModel.data.value!!.verificationLevel)
 
-        // When adding the contact again, it should be converted back to a direct contact
+        // When adding the contact again, it should be fully verified
         testAddingContact(
             apiConnectorResult,
             {
                 assertTrue(it is ContactModified)
                 assertTrue(it.verificationLevelChanged)
                 assertFalse(it.acquaintanceLevelChanged)
-                assertEquals(VerificationLevel.FULLY_VERIFIED, contactModel.data.value!!.verificationLevel)
+                assertEquals(
+                    VerificationLevel.FULLY_VERIFIED,
+                    contactModel.data.value!!.verificationLevel
+                )
             },
             newIdentity = newIdentity,
             publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
@@ -334,7 +382,7 @@ class AddOrUpdateContactBackgroundTaskTest {
                 it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
                 it.featureMask = 12
                 it.type = 0
-                it.state = IdentityState.ACTIVE
+                it.state = IdentityState.ACTIVE.value
             }
         }
 
@@ -342,7 +390,7 @@ class AddOrUpdateContactBackgroundTaskTest {
         testAddingContact(
             apiConnectorResult,
             {
-                assertTrue(it is Success)
+                assertTrue(it is ContactCreated)
             },
             newIdentity = newIdentity
         )
@@ -371,10 +419,70 @@ class AddOrUpdateContactBackgroundTaskTest {
         )
     }
 
+    @Test
+    fun testThreadUsage() {
+        val identity = "01234567"
+        val myIdentity = "00000000"
+
+        testAddingContact(
+            {
+                FetchIdentityResult().also {
+                    it.identity = identity
+                    it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
+                    it.featureMask = 12
+                    it.type = 0
+                    it.state = IdentityState.ACTIVE.value
+                }
+            },
+            {},
+            newIdentity = identity,
+            myIdentity = myIdentity,
+            publicKey = null,
+        )
+
+        val unusedAPIConnector = getTestApiConnector {
+            throw AssertionError("This must not be executed for this test")
+        }
+
+        val testThreadId = Thread.currentThread().id
+
+        val addTask = object : AddOrUpdateContactBackgroundTask<Boolean>(
+            identity = identity,
+            AcquaintanceLevel.DIRECT,
+            myIdentity = myIdentity,
+            unusedAPIConnector,
+            contactModelRepository,
+            AddContactRestrictionPolicy.CHECK,
+            ThreemaApplication.getAppContext(),
+            null,
+        ) {
+            override fun onBefore() {
+                assertEquals(testThreadId, Thread.currentThread().id)
+            }
+
+            override fun onContactAdded(result: ContactResult): Boolean {
+                assertTrue(result is ContactExists)
+                assertNotEquals(testThreadId, Thread.currentThread().id)
+                assertNotEquals(Looper.getMainLooper(), Looper.myLooper())
+                return true
+            }
+
+            override fun onFinished(result: Boolean) {
+                assertTrue(result)
+                assertEquals(Looper.getMainLooper(), Looper.myLooper())
+            }
+        }
+
+        runBlocking {
+            assertTrue(backgroundExecutor.executeDeferred(addTask).await())
+        }
+    }
+
     private fun testAddingContact(
         fetchIdentity: (identity: String) -> FetchIdentityResult,
-        runOnFinished: (result: ContactAddResult) -> Unit,
+        runOnFinished: (result: ContactResult) -> Unit,
         newIdentity: String = "01234567",
+        acquaintanceLevel: AcquaintanceLevel = AcquaintanceLevel.DIRECT,
         myIdentity: String = "00000000",
         publicKey: ByteArray? = null,
     ) {
@@ -386,19 +494,21 @@ class AddOrUpdateContactBackgroundTaskTest {
             fetchIdentity(it)
         }
 
-        val contactAdded = backgroundExecutor.executeDeferred(object : AddOrUpdateContactBackgroundTask(
-            newIdentity,
-            myIdentity,
-            apiConnector,
-            contactModelRepository,
-            AddContactRestrictionPolicy.CHECK,
-            ThreemaApplication.getAppContext(),
-            publicKey,
-        ) {
-            override fun onFinished(result: ContactAddResult) {
-                runOnFinished(result)
-            }
-        })
+        val contactAdded =
+            backgroundExecutor.executeDeferred(object : BasicAddOrUpdateContactBackgroundTask(
+                newIdentity,
+                acquaintanceLevel,
+                myIdentity,
+                apiConnector,
+                contactModelRepository,
+                AddContactRestrictionPolicy.CHECK,
+                ThreemaApplication.getAppContext(),
+                publicKey,
+            ) {
+                override fun onFinished(result: ContactResult) {
+                    runOnFinished(result)
+                }
+            })
 
         // Assert that the test is not stopped before running the background task completely
         runBlocking {
diff --git a/app/src/androidTest/java/ch/threema/app/contacts/MarkContactAsDeletedBackgroundTaskTest.kt b/app/src/androidTest/java/ch/threema/app/contacts/MarkContactAsDeletedBackgroundTaskTest.kt
new file mode 100644
index 00000000..ebffb62d
--- /dev/null
+++ b/app/src/androidTest/java/ch/threema/app/contacts/MarkContactAsDeletedBackgroundTaskTest.kt
@@ -0,0 +1,286 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.contacts
+
+import ch.threema.app.DangerousTest
+import ch.threema.app.TestCoreServiceManager
+import ch.threema.app.TestMultiDevicePropertyProvider
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy
+import ch.threema.app.asynctasks.ContactSyncPolicy
+import ch.threema.app.asynctasks.MarkContactAsDeletedBackgroundTask
+import ch.threema.app.asynctasks.DeleteContactServices
+import ch.threema.app.managers.CoreServiceManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.multidevice.linking.DeviceLinkingStatus
+import ch.threema.app.services.ContactService
+import ch.threema.app.services.UserService
+import ch.threema.app.tasks.ReflectContactSyncUpdateTask
+import ch.threema.app.tasks.TaskCreator
+import ch.threema.app.utils.executor.BackgroundExecutor
+import ch.threema.data.TestDatabaseService
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.data.repositories.ModelRepositories
+import ch.threema.domain.helpers.TransactionAckTaskCodec
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseListener
+import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
+import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
+import ch.threema.domain.taskmanager.QueueSendCompleteListener
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.TaskManager
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+import ch.threema.testhelpers.MUST_NOT_BE_CALLED
+import com.neilalexander.jnacl.NaCl
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.flowOf
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import java.util.Date
+import kotlin.test.Test
+import kotlin.test.assertEquals
+import kotlin.test.assertIs
+import kotlin.test.assertNotNull
+import kotlin.test.assertTrue
+
+@DangerousTest
+class MarkContactAsDeletedBackgroundTaskTest {
+
+    private val backgroundExecutor = BackgroundExecutor()
+    private lateinit var testTaskCodec: TransactionAckTaskCodec
+    private val testTaskManager = object : TaskManager {
+        val taskQueue: MutableList<Task<*, TaskCodec>> = mutableListOf()
+
+        override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> {
+            taskQueue.add(task)
+            return CompletableDeferred()
+        }
+
+        override fun hasPendingTasks(): Boolean {
+            return taskQueue.isNotEmpty()
+        }
+
+        override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+            // Nothing to do
+        }
+
+        override fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+            // Nothing to do
+        }
+
+    }
+    private lateinit var databaseService: TestDatabaseService
+    private val multiDeviceManager = object : MultiDeviceManager {
+        var multiDeviceEnabled = false
+
+        override val isMdDisabledOrSupportsFs: Boolean
+            get() = !multiDeviceEnabled
+        override val isMultiDeviceActive: Boolean
+            get() = multiDeviceEnabled
+        override val propertiesProvider = TestMultiDevicePropertyProvider
+        override val socketCloseListener: D2mSocketCloseListener = D2mSocketCloseListener { }
+        override val latestSocketCloseReason: Flow<D2mSocketCloseReason?> = flowOf()
+
+        override suspend fun activate(
+            deviceLabel: String,
+            contactService: ContactService,
+            userService: UserService,
+            fsMessageProcessor: ForwardSecurityMessageProcessor,
+            taskCreator: TaskCreator,
+        ) {
+            MUST_NOT_BE_CALLED()
+        }
+
+        override suspend fun deactivate(
+            userService: UserService,
+            fsMessageProcessor: ForwardSecurityMessageProcessor,
+            taskCreator: TaskCreator,
+        ) {
+            MUST_NOT_BE_CALLED()
+        }
+
+        override suspend fun setDeviceLabel(deviceLabel: String) {
+            MUST_NOT_BE_CALLED()
+        }
+
+        override suspend fun linkDevice(
+            deviceJoinOfferUri: String,
+            taskCreator: TaskCreator,
+        ): Flow<DeviceLinkingStatus> {
+            MUST_NOT_BE_CALLED()
+        }
+
+        override suspend fun purge(taskCreator: TaskCreator) {
+            MUST_NOT_BE_CALLED()
+        }
+
+        override suspend fun loadLinkedDevicesInfo(taskCreator: TaskCreator): List<String> {
+            MUST_NOT_BE_CALLED()
+        }
+
+    }
+    private lateinit var coreServiceManager: CoreServiceManager
+    private lateinit var contactModelRepository: ContactModelRepository
+    private lateinit var deleteContactServices: DeleteContactServices
+    private val testContactModelData = ContactModelData(
+        identity = "12345678",
+        publicKey = ByteArray(NaCl.PUBLICKEYBYTES),
+        createdAt = Date(),
+        firstName = "1234",
+        lastName = "5678",
+        nickname = null,
+        verificationLevel = VerificationLevel.FULLY_VERIFIED,
+        workVerificationLevel = WorkVerificationLevel.NONE,
+        identityType = IdentityType.NORMAL,
+        acquaintanceLevel = AcquaintanceLevel.DIRECT,
+        activityState = IdentityState.ACTIVE,
+        syncState = ContactSyncState.INITIAL,
+        featureMask = 0u,
+        readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+        typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+        androidContactLookupKey = null,
+        localAvatarExpires = null,
+        isRestored = false,
+        profilePictureBlobId = null,
+        jobTitle = null,
+        department = null,
+    )
+
+    @Before
+    fun before() {
+        databaseService = TestDatabaseService()
+        val serviceManager = ThreemaApplication.requireServiceManager()
+        testTaskCodec = TransactionAckTaskCodec()
+        coreServiceManager = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseService,
+            preferenceStore = serviceManager.preferenceStore,
+            multiDeviceManager = multiDeviceManager,
+            taskManager = testTaskManager,
+        )
+        deleteContactServices = DeleteContactServices(
+            serviceManager.userService,
+            serviceManager.contactService,
+            serviceManager.conversationService,
+            serviceManager.ringtoneService,
+            serviceManager.mutedChatsListService,
+            serviceManager.hiddenChatsListService,
+            serviceManager.profilePicRecipientsService,
+            serviceManager.wallpaperService,
+            serviceManager.fileService,
+            serviceManager.excludedSyncIdentitiesService,
+            serviceManager.dhSessionStore,
+            serviceManager.notificationService,
+            serviceManager.databaseServiceNew,
+        )
+        contactModelRepository = ModelRepositories(coreServiceManager).contacts
+
+        // Add a contact "from sync". This has no side effects and does not reflect the contact.
+        contactModelRepository.createFromSync(testContactModelData)
+    }
+
+    @Test
+    fun testAcquaintanceLevelChange() = runTest {
+        val contactModel = contactModelRepository.getByIdentity(testContactModelData.identity)
+        // Assert that the contact exists as "direct" contact
+        assertNotNull(contactModel)
+        assertEquals(AcquaintanceLevel.DIRECT, contactModel.data.value?.acquaintanceLevel)
+
+        // Remove the contact
+        backgroundExecutor.executeDeferred(
+            MarkContactAsDeletedBackgroundTask(
+                setOf(testContactModelData.identity),
+                contactModelRepository,
+                deleteContactServices,
+                ContactSyncPolicy.INCLUDE,
+                AndroidContactLinkPolicy.REMOVE_LINK,
+            )
+        ).await()
+
+        // Assert that the contact's acquaintance level is "group" now
+        assertEquals(AcquaintanceLevel.GROUP, contactModel.data.value?.acquaintanceLevel)
+    }
+
+    @Test
+    fun testNoReflection() = runTest {
+        // Disable multi device
+        multiDeviceManager.multiDeviceEnabled = false
+
+        val contactModel = contactModelRepository.getByIdentity(testContactModelData.identity)
+        // Assert that the contact exists as "direct" contact
+        assertNotNull(contactModel)
+        assertEquals(AcquaintanceLevel.DIRECT, contactModel.data.value?.acquaintanceLevel)
+
+        // Remove the contact
+        backgroundExecutor.executeDeferred(
+            MarkContactAsDeletedBackgroundTask(
+                setOf(testContactModelData.identity),
+                contactModelRepository,
+                deleteContactServices,
+                ContactSyncPolicy.INCLUDE,
+                AndroidContactLinkPolicy.REMOVE_LINK,
+            )
+        ).await()
+
+        // Assert that the there was no task scheduled
+        assertTrue(testTaskManager.taskQueue.isEmpty())
+    }
+
+    @Test
+    fun testReflection() = runTest {
+        // Enable multi device
+        multiDeviceManager.multiDeviceEnabled = true
+
+        val contactModel = contactModelRepository.getByIdentity(testContactModelData.identity)
+        // Assert that the contact exists as "direct" contact
+        assertNotNull(contactModel)
+        assertEquals(AcquaintanceLevel.DIRECT, contactModel.data.value?.acquaintanceLevel)
+
+        // Mark the contact as deleted
+        backgroundExecutor.executeDeferred(
+            MarkContactAsDeletedBackgroundTask(
+                setOf(testContactModelData.identity),
+                contactModelRepository,
+                deleteContactServices,
+                ContactSyncPolicy.INCLUDE,
+                AndroidContactLinkPolicy.REMOVE_LINK,
+            )
+        ).await()
+
+        // Assert that a reflection task has been scheduled
+        val task = testTaskManager.taskQueue.removeFirstOrNull()
+        assertIs<ReflectContactSyncUpdateTask>(task)
+
+        // Assert that no other tasks have been scheduled
+        assertTrue(testTaskManager.taskQueue.isEmpty())
+    }
+}
diff --git a/app/src/androidTest/java/ch/threema/app/contacts/ReflectedContactSyncTaskTest.kt b/app/src/androidTest/java/ch/threema/app/contacts/ReflectedContactSyncTaskTest.kt
new file mode 100644
index 00000000..137687c0
--- /dev/null
+++ b/app/src/androidTest/java/ch/threema/app/contacts/ReflectedContactSyncTaskTest.kt
@@ -0,0 +1,334 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.contacts
+
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import ch.threema.app.TestCoreServiceManager
+import ch.threema.app.TestMultiDeviceManager
+import ch.threema.app.TestTaskManager
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.processors.reflectedd2dsync.ReflectedContactSyncTask
+import ch.threema.data.TestDatabaseService
+import ch.threema.data.models.ContactModel
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.models.ContactModelData.Companion.getIdColorIndex
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.data.repositories.ModelRepositories
+import ch.threema.domain.helpers.TransactionAckTaskCodec
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.protobuf.d2d.ContactSyncKt.create
+import ch.threema.protobuf.d2d.ContactSyncKt.update
+import ch.threema.protobuf.d2d.contactSync
+import ch.threema.protobuf.d2d.sync.ContactKt.notificationSoundPolicyOverride
+import ch.threema.protobuf.d2d.sync.ContactKt.readReceiptPolicyOverride
+import ch.threema.protobuf.d2d.sync.ContactKt.typingIndicatorPolicyOverride
+import ch.threema.protobuf.d2d.sync.MdD2DSync
+import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.ActivityState
+import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.ReadReceiptPolicyOverride
+import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.TypingIndicatorPolicyOverride
+import ch.threema.protobuf.d2d.sync.contact
+import ch.threema.protobuf.unit
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+import com.google.protobuf.kotlin.toByteString
+import com.neilalexander.jnacl.NaCl
+import kotlinx.coroutines.runBlocking
+import org.junit.Before
+import org.junit.runner.RunWith
+import java.util.Date
+import kotlin.test.Test
+import kotlin.test.assertContentEquals
+import kotlin.test.assertEquals
+import kotlin.test.assertNull
+import kotlin.test.assertTrue
+import kotlin.test.fail
+
+@RunWith(AndroidJUnit4::class)
+class ReflectedContactSyncTaskTest {
+
+    private lateinit var databaseService: TestDatabaseService
+    private lateinit var taskCodec: TransactionAckTaskCodec
+    private lateinit var coreServiceManager: TestCoreServiceManager
+    private lateinit var contactModelRepository: ContactModelRepository
+
+    private val initialContactModelData = ContactModelData(
+        identity = "01234567",
+        publicKey = ByteArray(32),
+        createdAt = Date(),
+        firstName = "",
+        lastName = "",
+        nickname = "Nick",
+        colorIndex = getIdColorIndex("01234567"),
+        verificationLevel = VerificationLevel.UNVERIFIED,
+        workVerificationLevel = WorkVerificationLevel.NONE,
+        identityType = IdentityType.NORMAL,
+        acquaintanceLevel = AcquaintanceLevel.DIRECT,
+        activityState = IdentityState.ACTIVE,
+        syncState = ContactSyncState.INITIAL,
+        featureMask = 511u,
+        readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+        typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+        androidContactLookupKey = null,
+        localAvatarExpires = null,
+        isRestored = false,
+        profilePictureBlobId = null,
+        jobTitle = null,
+        department = null,
+    )
+
+    @Before
+    fun before() {
+        databaseService = TestDatabaseService()
+        taskCodec = TransactionAckTaskCodec()
+        coreServiceManager = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseService,
+            preferenceStore = ThreemaApplication.requireServiceManager().preferenceStore,
+            multiDeviceManager = TestMultiDeviceManager(
+                isMultiDeviceActive = true,
+                isMdDisabledOrSupportsFs = false,
+            ),
+            taskManager = TestTaskManager(taskCodec),
+        )
+        contactModelRepository = ModelRepositories(coreServiceManager).contacts
+    }
+
+    @Test
+    fun testNewReflectedContact() {
+        val contact = contact {
+            identity = "01234567"
+            publicKey = ByteArray(NaCl.PUBLICKEYBYTES) { it.toByte() }.toByteString()
+            createdAt = Date().time
+            firstName = "0123"
+            // No last name provided
+            nickname = "nick"
+            verificationLevel = MdD2DSync.Contact.VerificationLevel.FULLY_VERIFIED
+            workVerificationLevel = MdD2DSync.Contact.WorkVerificationLevel.NONE
+            identityType = MdD2DSync.Contact.IdentityType.WORK
+            acquaintanceLevel = MdD2DSync.Contact.AcquaintanceLevel.DIRECT
+            activityState = ActivityState.INACTIVE
+            featureMask = 123
+            syncState = MdD2DSync.Contact.SyncState.IMPORTED
+            readReceiptPolicyOverride = readReceiptPolicyOverride {
+                default = unit {}
+            }
+            typingIndicatorPolicyOverride = typingIndicatorPolicyOverride {
+                policy = MdD2DSync.TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR
+            }
+            notificationTriggerPolicyOverride =
+                MdD2DSync.Contact.NotificationTriggerPolicyOverride.getDefaultInstance()
+            notificationSoundPolicyOverride = notificationSoundPolicyOverride {
+                policy = MdD2DSync.NotificationSoundPolicy.MUTED
+            }
+            conversationCategory = MdD2DSync.ConversationCategory.DEFAULT
+            conversationVisibility = MdD2DSync.ConversationVisibility.NORMAL
+        }
+
+        testReflectedContactCreate(contact) { contactModel ->
+            val data = contactModel.data.value!!
+            assertEquals(contact.identity, data.identity)
+            assertContentEquals(ByteArray(NaCl.PUBLICKEYBYTES) { it.toByte() }, data.publicKey)
+            assertEquals(contact.createdAt, data.createdAt.time)
+            assertEquals(contact.firstName, data.firstName)
+            assertEquals("", data.lastName)
+            assertEquals(contact.nickname, data.nickname)
+            assertEquals(contact.verificationLevel.convert(), data.verificationLevel)
+            assertEquals(contact.workVerificationLevel.convert(), data.workVerificationLevel)
+            assertEquals(contact.identityType.convert(), data.identityType)
+            assertEquals(contact.acquaintanceLevel.convert(), data.acquaintanceLevel)
+            assertEquals(contact.activityState.convert(), data.activityState)
+            assertEquals(contact.featureMask, data.featureMask.toLong())
+            assertEquals(contact.syncState.convert(), data.syncState)
+            assertEquals(contact.readReceiptPolicyOverride.convert(), data.readReceiptPolicy)
+            assertEquals(contact.typingIndicatorPolicyOverride.convert(), data.typingIndicatorPolicy)
+        }
+    }
+
+    @Test
+    fun testReflectedNicknameChange() {
+        val newNickname = "new nickname"
+        testReflectedContactUpdate(
+            contact {
+                identity = "01234567"
+                nickname = newNickname
+            }
+        ) { contactModel ->
+            assertEquals(newNickname, contactModel.data.value?.nickname)
+        }
+    }
+
+    private fun testReflectedContactCreate(
+        contact: MdD2DSync.Contact,
+        assertContactCreated: (contactModel: ContactModel) -> Unit,
+    ) {
+        assertNull(contactModelRepository.getByIdentity(contact.identity))
+
+        ReflectedContactSyncTask(
+            contact.toContactSyncCreate(),
+            contactModelRepository,
+            ThreemaApplication.requireServiceManager(),
+        ).run()
+
+        // Assert that no transaction have been executed
+        assertZeroTransactionCount()
+
+        // Assert that no messages have been sent
+        assertNoMessagesSent()
+
+        // Assert that the create has been applied
+        val contactModel = contactModelRepository.getByIdentity(contact.identity)!!
+        assertContactCreated(contactModel)
+    }
+
+    private fun testReflectedContactUpdate(
+        contact: MdD2DSync.Contact,
+        assertUpdateApplied: (contactModel: ContactModel) -> Unit,
+    ) {
+        createContact(initialContactModelData.copy(identity = contact.identity))
+
+        ReflectedContactSyncTask(
+            contact.toContactSyncUpdate(),
+            contactModelRepository,
+            ThreemaApplication.requireServiceManager(),
+        ).run()
+
+        // Assert that no transaction have been executed
+        assertZeroTransactionCount()
+
+        // Assert that no messages have been sent
+        assertNoMessagesSent()
+
+        // Assert that update has been applied
+        val contactModel = contactModelRepository.getByIdentity(contact.identity)!!
+        assertUpdateApplied(contactModel)
+    }
+
+    private fun createContact(contactModelData: ContactModelData) {
+        runBlocking {
+            contactModelRepository.createFromLocal(contactModelData)
+        }
+        assertAndClearOneTransactionCount()
+    }
+
+    private fun assertAndClearOneTransactionCount() {
+        assertEquals(1, taskCodec.transactionBeginCount)
+        assertEquals(1, taskCodec.transactionCommitCount)
+
+        taskCodec.transactionBeginCount = 0
+        taskCodec.transactionCommitCount = 0
+    }
+
+    private fun assertZeroTransactionCount() {
+        assertEquals(0, taskCodec.transactionBeginCount)
+        assertEquals(0, taskCodec.transactionCommitCount)
+    }
+
+    private fun assertNoMessagesSent() {
+        assertTrue { taskCodec.outboundMessages.isEmpty() }
+    }
+
+    private fun MdD2DSync.Contact.toContactSyncCreate() = contactSync {
+        create = create {
+            contact = this@toContactSyncCreate
+        }
+    }
+
+    private fun MdD2DSync.Contact.toContactSyncUpdate() = contactSync {
+        update = update {
+            contact = this@toContactSyncUpdate
+        }
+    }
+
+    private fun MdD2DSync.Contact.VerificationLevel.convert(): VerificationLevel = when (this) {
+        MdD2DSync.Contact.VerificationLevel.FULLY_VERIFIED -> VerificationLevel.FULLY_VERIFIED
+        MdD2DSync.Contact.VerificationLevel.SERVER_VERIFIED -> VerificationLevel.SERVER_VERIFIED
+        MdD2DSync.Contact.VerificationLevel.UNVERIFIED -> VerificationLevel.UNVERIFIED
+        MdD2DSync.Contact.VerificationLevel.UNRECOGNIZED -> fail("Verification level is unrecognized")
+    }
+
+    private fun MdD2DSync.Contact.WorkVerificationLevel.convert(): WorkVerificationLevel =
+        when (this) {
+            MdD2DSync.Contact.WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED -> WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+            MdD2DSync.Contact.WorkVerificationLevel.NONE -> WorkVerificationLevel.NONE
+            MdD2DSync.Contact.WorkVerificationLevel.UNRECOGNIZED -> fail("Work verification level is unrecognized")
+        }
+
+    private fun MdD2DSync.Contact.IdentityType.convert(): IdentityType = when (this) {
+        MdD2DSync.Contact.IdentityType.REGULAR -> IdentityType.NORMAL
+        MdD2DSync.Contact.IdentityType.WORK -> IdentityType.WORK
+        MdD2DSync.Contact.IdentityType.UNRECOGNIZED -> fail("Identity type is unrecognized")
+    }
+
+    private fun MdD2DSync.Contact.AcquaintanceLevel.convert(): AcquaintanceLevel =
+        when (this) {
+            MdD2DSync.Contact.AcquaintanceLevel.DIRECT -> AcquaintanceLevel.DIRECT
+            MdD2DSync.Contact.AcquaintanceLevel.GROUP -> AcquaintanceLevel.GROUP
+            MdD2DSync.Contact.AcquaintanceLevel.UNRECOGNIZED -> fail("Acquaintance level is unrecognized")
+        }
+
+    private fun ActivityState.convert(): IdentityState = when (this) {
+        ActivityState.ACTIVE -> IdentityState.ACTIVE
+        ActivityState.INACTIVE -> IdentityState.INACTIVE
+        ActivityState.INVALID -> IdentityState.INVALID
+        ActivityState.UNRECOGNIZED -> fail("Activity state is unrecognized")
+    }
+
+    private fun MdD2DSync.Contact.SyncState.convert(): ContactSyncState = when (this) {
+        MdD2DSync.Contact.SyncState.INITIAL -> ContactSyncState.INITIAL
+        MdD2DSync.Contact.SyncState.IMPORTED -> ContactSyncState.IMPORTED
+        MdD2DSync.Contact.SyncState.CUSTOM -> ContactSyncState.CUSTOM
+        MdD2DSync.Contact.SyncState.UNRECOGNIZED -> fail("Sync state is unrecognized")
+    }
+
+    private fun ReadReceiptPolicyOverride.convert(): ReadReceiptPolicy = when (overrideCase) {
+        ReadReceiptPolicyOverride.OverrideCase.DEFAULT -> ReadReceiptPolicy.DEFAULT
+        ReadReceiptPolicyOverride.OverrideCase.POLICY -> when (policy) {
+            MdD2DSync.ReadReceiptPolicy.SEND_READ_RECEIPT -> ReadReceiptPolicy.SEND
+            MdD2DSync.ReadReceiptPolicy.DONT_SEND_READ_RECEIPT -> ReadReceiptPolicy.DONT_SEND
+            MdD2DSync.ReadReceiptPolicy.UNRECOGNIZED -> fail("Read receipt policy is unrecognized")
+            null -> fail("Read receipt policy is null")
+        }
+
+        ReadReceiptPolicyOverride.OverrideCase.OVERRIDE_NOT_SET -> fail("Read receipt policy override not set")
+        null -> fail("Read receipt policy override is null")
+    }
+
+    private fun TypingIndicatorPolicyOverride.convert(): TypingIndicatorPolicy =
+        when (overrideCase) {
+            TypingIndicatorPolicyOverride.OverrideCase.DEFAULT -> TypingIndicatorPolicy.DEFAULT
+            TypingIndicatorPolicyOverride.OverrideCase.POLICY -> when (policy) {
+                MdD2DSync.TypingIndicatorPolicy.SEND_TYPING_INDICATOR -> TypingIndicatorPolicy.SEND
+                MdD2DSync.TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR -> TypingIndicatorPolicy.DONT_SEND
+                MdD2DSync.TypingIndicatorPolicy.UNRECOGNIZED -> fail("Typing indicator policy is unrecognized")
+                null -> fail("Typing indicator policy is null")
+            }
+
+            TypingIndicatorPolicyOverride.OverrideCase.OVERRIDE_NOT_SET -> fail("Typing indicator policy override not set")
+            null -> fail("Typing indicator policy override is null")
+        }
+
+}
diff --git a/app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt b/app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt
index 031dbcc7..1b63279e 100644
--- a/app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt
@@ -26,11 +26,17 @@ import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.filters.LargeTest
 import ch.threema.app.DangerousTest
 import ch.threema.app.activities.HomeActivity
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy
+import ch.threema.app.asynctasks.ContactSyncPolicy
+import ch.threema.app.asynctasks.DeleteContactServices
 import ch.threema.app.asynctasks.EmptyOrDeleteConversationsAsyncTask
+import ch.threema.app.asynctasks.MarkContactAsDeletedBackgroundTask
 import ch.threema.app.processors.MessageProcessorProvider
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.GroupService
 import ch.threema.app.services.MessageService
+import ch.threema.app.utils.executor.BackgroundExecutor
+import ch.threema.data.repositories.ContactModelRepository
 import ch.threema.data.storage.EditHistoryDao
 import ch.threema.data.storage.EditHistoryDaoImpl
 import ch.threema.domain.models.MessageId
@@ -42,6 +48,7 @@ import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
 import ch.threema.domain.protocol.csp.messages.GroupEditMessage
 import ch.threema.domain.protocol.csp.messages.GroupTextMessage
 import ch.threema.domain.protocol.csp.messages.TextMessage
+import ch.threema.storage.DatabaseServiceNew
 import ch.threema.storage.factories.GroupMessageModelFactory
 import ch.threema.storage.factories.MessageModelFactory
 import ch.threema.storage.models.AbstractMessageModel
@@ -62,9 +69,28 @@ class EditHistoryTest : MessageProcessorProvider() {
     private val messageService: MessageService by lazy { serviceManager.messageService }
     private val contactService: ContactService by lazy { serviceManager.contactService }
     private val groupService: GroupService by lazy { serviceManager.groupService }
-    private val messageModelFactory: MessageModelFactory by lazy { serviceManager.databaseServiceNew.messageModelFactory }
-    private val groupMessageModelFactory: GroupMessageModelFactory by lazy { serviceManager.databaseServiceNew.groupMessageModelFactory }
-    private val editHistoryDao: EditHistoryDao by lazy { EditHistoryDaoImpl(serviceManager.databaseServiceNew) }
+    private val databaseService: DatabaseServiceNew by lazy { serviceManager.databaseServiceNew }
+    private val messageModelFactory: MessageModelFactory by lazy { databaseService.messageModelFactory }
+    private val groupMessageModelFactory: GroupMessageModelFactory by lazy { databaseService.groupMessageModelFactory }
+    private val editHistoryDao: EditHistoryDao by lazy { EditHistoryDaoImpl(databaseService) }
+    private val contactModelRepository: ContactModelRepository by lazy { serviceManager.modelRepositories.contacts }
+    private val deleteContactServices: DeleteContactServices by lazy {
+        DeleteContactServices(
+            serviceManager.userService,
+            contactService,
+            serviceManager.conversationService,
+            serviceManager.ringtoneService,
+            serviceManager.mutedChatsListService,
+            serviceManager.hiddenChatsListService,
+            serviceManager.profilePicRecipientsService,
+            serviceManager.wallpaperService,
+            serviceManager.fileService,
+            serviceManager.excludedSyncIdentitiesService,
+            serviceManager.dhSessionStore,
+            serviceManager.notificationService,
+            databaseService,
+        )
+    }
 
     @Test
     fun testHistoryDeletedOnContactMessageDelete() = runTest {
@@ -248,7 +274,15 @@ class EditHistoryTest : MessageProcessorProvider() {
 
         messageModel.assertHistorySize(1)
 
-        contactService.remove(contactA.contactModel)
+        BackgroundExecutor().executeDeferred(
+            MarkContactAsDeletedBackgroundTask(
+                setOf(messageModel.identity),
+                contactModelRepository,
+                deleteContactServices,
+                ContactSyncPolicy.INCLUDE,
+                AndroidContactLinkPolicy.KEEP,
+            )
+        ).await()
 
         messageModel.assertHistorySize(0)
     }
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt
index 40bfa7ac..c206333d 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt
@@ -155,14 +155,19 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
         // The common group receive steps are not executed for group leave messages
     }
 
-    private suspend fun assertSuccessfulLeave(group: TestGroup, contact: TestContact, expectStateChange: Boolean = false) {
+    private suspend fun assertSuccessfulLeave(
+        group: TestGroup,
+        contact: TestContact,
+        expectStateChange: Boolean = false,
+    ) {
         launchActivity<HomeActivity>()
 
         serviceManager.groupService.resetCache(group.groupModel.id)
 
         assertEquals(
             group.members.map { it.identity },
-            serviceManager.groupService.getGroupMemberModels(group.groupModel).map { it.identity })
+            serviceManager.groupService.getGroupIdentities(group.groupModel).toList()
+        )
 
         val leaveTracker = GroupLeaveTracker(group, contact.identity, expectStateChange)
             .apply { start() }
@@ -182,7 +187,8 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
         )
         assertEquals(
             group.members.map { it.identity }.filter { it != contact.identity },
-            serviceManager.groupService.getGroupMemberModels(group.groupModel).map { it.identity })
+            serviceManager.groupService.getGroupIdentities(group.groupModel).toList()
+        )
 
         // Assert that no message has been sent as a response to a group leave
         assertEquals(0, sentMessagesInsideTask.size)
@@ -200,9 +206,8 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
 
         serviceManager.groupService.resetCache(group.groupModel.id)
 
-        assertEquals(
-            expectedMemberList,
-            serviceManager.groupService.getGroupMemberModels(group.groupModel).map { it.identity })
+        assertGroupIdentities(expectedMemberList, group)
+        assertMemberCount(expectedMemberList.size, group)
 
         val leaveTracker = GroupLeaveTracker(group, contact.identity).apply { start() }
 
@@ -215,13 +220,8 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
 
         serviceManager.groupService.resetCache(group.groupModel.id)
 
-        assertEquals(
-            expectedMemberList,
-            serviceManager.groupService.getGroupMemberModels(group.groupModel).map { it.identity })
-        assertEquals(
-            expectedMemberList.size,
-            serviceManager.groupService.countMembers(group.groupModel)
-        )
+        assertGroupIdentities(expectedMemberList, group)
+        assertMemberCount(expectedMemberList.size, group)
 
         if (shouldSendSyncRequest) {
             // Should send sync request to the group creator
@@ -245,6 +245,37 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
             toIdentity = myContact.identity
         }
 
+    private fun assertGroupIdentities(expectedMemberList: List<String>, group: TestGroup) {
+        if (serviceManager.groupService.getByApiGroupIdAndCreator(
+                group.apiGroupId, group.groupCreator.identity
+            ) != null
+        ) {
+            // We check the expected members if the group is available in the database. If there is
+            // no such group, we do not need to perform this check as we would not be able to
+            // retrieve a group model.
+            assertEquals(
+                expectedMemberList,
+                serviceManager.groupService.getGroupIdentities(group.groupModel).toList()
+            )
+        }
+    }
+
+    private fun assertMemberCount(expectedMemberCount: Int, group: TestGroup) {
+        if (serviceManager.groupService.getByApiGroupIdAndCreator(
+                group.apiGroupId,
+                group.groupCreator.identity
+            ) != null
+        ) {
+            // We only check the expected members if the group is available in the database.
+            // Otherwise the check does not make sense as we would not be able to retrieve a group
+            // model.
+            assertEquals(
+                expectedMemberCount,
+                serviceManager.groupService.countMembers(group.groupModel)
+            )
+        }
+    }
+
     private class GroupLeaveTracker(
         private val group: TestGroup?,
         private val leavingIdentity: String?,
@@ -264,13 +295,11 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
             override fun onNewMember(
                 group: GroupModel?,
                 newIdentity: String?,
-                previousMemberCount: Int
             ) = fail()
 
             override fun onMemberLeave(
                 groupModel: GroupModel?,
                 identity: String?,
-                previousMemberCount: Int
             ) {
                 assertFalse(memberHasLeft)
                 group?.let {
@@ -284,7 +313,6 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
             override fun onMemberKicked(
                 group: GroupModel?,
                 identity: String?,
-                previousMemberCount: Int
             ) = fail()
 
             override fun onUpdate(groupModel: GroupModel?) = fail()
@@ -294,7 +322,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
             override fun onGroupStateChanged(
                 groupModel: GroupModel?,
                 oldState: Int,
-                newState: Int
+                newState: Int,
             ) {
                 if (!expectStateChange) {
                     fail()
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt
index fd339db3..d2080123 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt
@@ -67,7 +67,7 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
 
         // Create group rename message
         val groupARenamed =
-            TestGroup(groupA.apiGroupId, groupA.groupCreator, groupA.members, "GroupARenamed")
+            TestGroup(groupA.apiGroupId, groupA.groupCreator, groupA.members, "GroupARenamed", myContact.identity)
 
         val renameTracker = GroupRenameTracker(groupARenamed).apply { start() }
 
@@ -103,7 +103,7 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
 
         // Create group rename message (from wrong sender)
         val groupARenamed =
-            TestGroup(groupA.apiGroupId, groupA.groupCreator, groupA.members, "GroupARenamed")
+            TestGroup(groupA.apiGroupId, groupA.groupCreator, groupA.members, "GroupARenamed", myContact.identity)
 
         val renameTracker = GroupRenameTracker(null).apply { start() }
 
@@ -215,7 +215,6 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
             override fun onNewMember(
                 group: GroupModel?,
                 newIdentity: String?,
-                previousMemberCount: Int
             ) {
                 fail()
             }
@@ -223,7 +222,6 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
             override fun onMemberLeave(
                 group: GroupModel?,
                 identity: String?,
-                previousMemberCount: Int
             ) {
                 fail()
             }
@@ -231,7 +229,6 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
             override fun onMemberKicked(
                 group: GroupModel?,
                 identity: String?,
-                previousMemberCount: Int
             ) {
                 fail()
             }
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt
index 5381b658..6a00f007 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt
@@ -38,6 +38,7 @@ import org.junit.After
 import org.junit.Assert
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNotNull
 import org.junit.Assert.assertTrue
 import org.junit.Assert.fail
 import org.junit.Test
@@ -200,6 +201,12 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         // Assert initial group conversations
         assertGroupConversations(scenario, initialGroups)
 
+        // Assert that the user is a member of groupAB
+        val beforeKicked = serviceManager.groupService.getById(groupAB.groupModel.id)
+        assertNotNull(beforeKicked)
+        assertEquals(GroupModel.UserState.MEMBER, beforeKicked!!.userState)
+        assertTrue(serviceManager.groupService.isGroupMember(beforeKicked))
+
         val setupTracker = GroupSetupTracker(
             groupAB,
             myContact.identity,
@@ -217,6 +224,12 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         // Create message box from contact A (group creator)
         processMessage(message, groupAB.groupCreator.identityStore)
 
+        // Assert that the user state has been changed to 'kicked'
+        val afterKicked = serviceManager.groupService.getById(groupAB.groupModel.id)
+        assertNotNull(afterKicked)
+        assertEquals(GroupModel.UserState.KICKED, afterKicked!!.userState)
+        assertFalse(serviceManager.groupService.isGroupMember(afterKicked))
+
         // Assert that group conversations did not appear, disappear, or change their name
         assertGroupConversations(scenario, initialGroups)
 
@@ -287,7 +300,8 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
             newAGroup.members,
             // Note that this will be the group name because we only test the group setup message
             // that is not followed by a group rename
-            "12345678, Me, ABCDEFGH",
+            "Me, 12345678, ABCDEFGH",
+            myContact.identity,
         )
 
         val setupTracker = GroupSetupTracker(
@@ -316,6 +330,22 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         setupTracker.assertAllKickedMembersRemoved()
         setupTracker.assertCreateLeave()
         setupTracker.stop()
+
+        // Assert that the group has the correct members
+        val group = serviceManager.groupService.getByApiGroupIdAndCreator(newGroup.apiGroupId, newGroup.groupCreator.identity)
+        assertNotNull(group!!)
+        val expectedMemberCount = newGroup.members.size
+        // Assert that there is one more member than member models (as the user is not stored into
+        // the database).
+        assertEquals(expectedMemberCount, serviceManager.databaseServiceNew.groupMemberModelFactory.getByGroupId(group.id).size + 1)
+        assertEquals(expectedMemberCount, serviceManager.databaseServiceNew.groupMemberModelFactory.countMembersWithoutUser(group.id).toInt() + 1)
+
+        // Assert that the group service returns the member lists including the user
+        assertEquals(expectedMemberCount, serviceManager.groupService.getMembers(group).size)
+        assertEquals(expectedMemberCount, serviceManager.groupService.getGroupIdentities(group).size)
+        assertEquals(expectedMemberCount, serviceManager.groupService.getMembersWithoutUser(group).size + 1)
+        assertEquals(expectedMemberCount, serviceManager.groupService.countMembers(group))
+        assertEquals(expectedMemberCount, serviceManager.groupService.countMembersWithoutUser(group) + 1)
     }
 
     /**
@@ -380,7 +410,8 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
             newAGroup.members + TestContact(invalidMemberId), // Note that this ID is not valid
             // Note that this will be the group name because we only test the group setup message
             // that is not followed by a group rename
-            "12345678, Me, ABCDEFGH",
+            "Me, 12345678, ABCDEFGH",
+            myContact.identity,
         )
 
         val setupTracker = GroupSetupTracker(
@@ -459,7 +490,6 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
             override fun onNewMember(
                 group: GroupModel?,
                 newIdentity: String?,
-                previousMemberCount: Int
             ) {
                 assertTrue("Did not expect member $newIdentity", newMembers.contains(newIdentity))
                 newMembersAdded.add(newIdentity!!)
@@ -468,13 +498,11 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
             override fun onMemberLeave(
                 group: GroupModel?,
                 identity: String?,
-                previousMemberCount: Int
             ) = fail()
 
             override fun onMemberKicked(
                 group: GroupModel?,
                 identity: String?,
-                previousMemberCount: Int
             ) {
                 assertTrue(kickedMembers.contains(identity))
                 kickedMembersRemoved.add(identity!!)
diff --git a/app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt b/app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt
index a037721e..1a2a9331 100644
--- a/app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt
@@ -43,14 +43,12 @@ import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage
 import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage
 import junit.framework.TestCase.assertEquals
 import junit.framework.TestCase.assertTrue
-import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.test.runTest
 import org.junit.Assert.assertArrayEquals
 import org.junit.Assert.fail
 import org.junit.Test
 import java.util.Date
 
-@OptIn(ExperimentalCoroutinesApi::class)
 @DangerousTest
 class IncomingMessageProcessorTest : MessageProcessorProvider() {
 
@@ -93,9 +91,9 @@ class IncomingMessageProcessorTest : MessageProcessorProvider() {
         }
 
         val pollSetupMessage = PollSetupMessage().also {
-            it.ballotCreator = ballotCreator
+            it.ballotCreatorIdentity = ballotCreator
             it.ballotId = ballotId
-            it.data = ballotData
+            it.ballotData = ballotData
         }.enrich()
 
         // Test a valid ballot setup message that opens a poll
@@ -103,12 +101,9 @@ class IncomingMessageProcessorTest : MessageProcessorProvider() {
 
         val pollVoteMessage = PollVoteMessage().also { voteMessage ->
             voteMessage.ballotId = ballotId
-            voteMessage.ballotCreator = ballotCreator
-            voteMessage.ballotVotes.addAll(List(5) { index ->
-                BallotVote().also {
-                    it.id = index
-                    it.value = 0
-                }
+            voteMessage.ballotCreatorIdentity = ballotCreator
+            voteMessage.votes.addAll(List(5) { index ->
+                BallotVote(index, 0)
             })
         }.enrich()
 
diff --git a/app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt b/app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt
index 9b85350e..b62b2e30 100644
--- a/app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt
+++ b/app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt
@@ -28,6 +28,7 @@ import androidx.test.platform.app.InstrumentationRegistry
 import androidx.test.rule.GrantPermissionRule
 import ch.threema.app.TestCoreServiceManager
 import ch.threema.app.ThreemaApplication
+import ch.threema.app.managers.ListenerManager
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.multidevice.MultiDeviceManagerImpl
 import ch.threema.app.services.FileService
@@ -36,18 +37,25 @@ import ch.threema.app.tasks.TaskArchiverImpl
 import ch.threema.app.testutils.TestHelpers
 import ch.threema.app.testutils.TestHelpers.TestContact
 import ch.threema.app.testutils.TestHelpers.TestGroup
-import ch.threema.app.utils.DeviceCookieManagerImpl
+import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.ForwardSecurityStatusSender
+import ch.threema.base.crypto.HashedNonce
+import ch.threema.base.crypto.Nonce
 import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceScope
 import ch.threema.base.crypto.NonceStore
 import ch.threema.domain.fs.DHSession
 import ch.threema.domain.helpers.DecryptTaskCodec
 import ch.threema.domain.helpers.InMemoryContactStore
 import ch.threema.domain.helpers.InMemoryDHSessionStore
 import ch.threema.domain.helpers.InMemoryNonceStore
+import ch.threema.domain.models.BasicContact
 import ch.threema.domain.models.Contact
 import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
 import ch.threema.domain.protocol.ThreemaFeature
+import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.domain.protocol.connection.ConnectionState
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.domain.protocol.csp.coders.MessageBox
@@ -59,7 +67,7 @@ import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataInit
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
 import ch.threema.domain.stores.ContactStore
 import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.ActiveTask
 import ch.threema.domain.taskmanager.QueueSendCompleteListener
 import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
@@ -87,31 +95,32 @@ open class MessageProcessorProvider {
     protected val contactB = TestContact("ABCDEFGH")
     protected val contactC = TestContact("TESTTEST")
 
-    protected val myGroup = TestGroup(GroupId(0), myContact, listOf(myContact, contactA, contactB), "MyGroup")
+    protected val myGroup = TestGroup(GroupId(0), myContact, listOf(myContact, contactA, contactB), "MyGroup", myContact.identity)
     protected val myGroupWithProfilePicture =
         TestGroup(
             GroupId(1),
             myContact,
             listOf(myContact, contactA),
             "MyGroupWithPicture",
-            byteArrayOf(0, 1, 2, 3)
+            byteArrayOf(0, 1, 2, 3),
+            myContact.identity
         )
     protected val groupA =
-        TestGroup(GroupId(2), contactA, listOf(myContact, contactA), "GroupA")
+        TestGroup(GroupId(2), contactA, listOf(myContact, contactA), "GroupA", myContact.identity)
     protected val groupB =
-        TestGroup(GroupId(3), contactB, listOf(myContact, contactB), "GroupB")
+        TestGroup(GroupId(3), contactB, listOf(myContact, contactB), "GroupB", myContact.identity)
     protected val groupAB =
-        TestGroup(GroupId(4), contactA, listOf(myContact, contactA, contactB), "GroupAB")
+        TestGroup(GroupId(4), contactA, listOf(myContact, contactA, contactB), "GroupAB", myContact.identity)
     protected val groupAUnknown =
-        TestGroup(GroupId(5), contactA, listOf(myContact, contactA, contactB), "GroupAUnknown")
+        TestGroup(GroupId(5), contactA, listOf(myContact, contactA, contactB), "GroupAUnknown", myContact.identity)
     protected val groupALeft =
-        TestGroup(GroupId(6), contactA, listOf(contactA, contactB), "GroupALeft")
+        TestGroup(GroupId(6), contactA, listOf(contactA, contactB), "GroupALeft", myContact.identity)
     protected val myUnknownGroup =
-        TestGroup(GroupId(7), myContact, listOf(myContact, contactA), "MyUnknownGroup")
+        TestGroup(GroupId(7), myContact, listOf(myContact, contactA), "MyUnknownGroup", myContact.identity)
     protected val myLeftGroup =
-        TestGroup(GroupId(8), myContact, listOf(contactA), "MyLeftGroup")
+        TestGroup(GroupId(8), myContact, listOf(contactA), "MyLeftGroup", myContact.identity)
     protected val newAGroup =
-        TestGroup(GroupId(9), contactA, listOf(myContact, contactA, contactB), "NewAGroup")
+        TestGroup(GroupId(9), contactA, listOf(myContact, contactA, contactB), "NewAGroup", myContact.identity)
 
     protected val serviceManager: ServiceManager = ThreemaApplication.requireServiceManager()
     private val contactStore: ContactStore = InMemoryContactStore().apply {
@@ -128,11 +137,21 @@ open class MessageProcessorProvider {
         contactC.identity to contactC.identityStore,
     ).toMap()
 
-    private val forwardSecurityStatusListener = object : ForwardSecurityStatusSender(serviceManager.contactService, serviceManager.messageService, null) {
+    private val forwardSecurityStatusListener = object : ForwardSecurityStatusSender(
+        serviceManager.contactService,
+        serviceManager.messageService,
+        APIConnector(
+            false,
+            null,
+            false
+        ) { host -> ConfigUtils.getSSLSocketFactory(host) },
+        serviceManager.userService,
+        serviceManager.modelRepositories.contacts,
+    ) {
         override fun messageWithoutFSReceived(
             contact: Contact,
             session: DHSession,
-            message: AbstractMessage
+            message: AbstractMessage,
         ) {
             throw AssertionError("We do not accept messages without forward security")
         }
@@ -244,12 +263,6 @@ open class MessageProcessorProvider {
 
             override fun hasPendingTasks(): Boolean = false
 
-            @Deprecated(
-                "We should only be able to send and receive messages from within tasks.",
-                replaceWith = ReplaceWith("TaskManager#schedule")
-            )
-            override fun getMigrationTaskHandle(): ActiveTaskCodec = globalTaskCodec
-
             override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
                 // Nothing to do
             }
@@ -280,20 +293,29 @@ open class MessageProcessorProvider {
             // encapsulated message as we only want to initiate a new fs session. Therefore we just
             // need to send the first message, which is the init.
             val result =
-                myForwardSecurityMessageProcessor.makeMessage(it.contact, textMessage, globalTaskCodec)
+                myForwardSecurityMessageProcessor.runFsEncapsulationSteps(
+                    it.toBasicContact(),
+                    textMessage,
+                    nonceFactory.next(NonceScope.CSP),
+                    nonceFactory,
+                    globalTaskCodec,
+                )
 
             // Commit the dh session state
             myForwardSecurityMessageProcessor.commitSessionState(result)
 
             // Process the init message
-            val initCspMessage = result
-                .outgoingMessages
-                .first()
-                .apply { toIdentity = it.contact.identity }
-                .toCspMessage(myContact.identityStore, contactStore, nonceFactory, nonceFactory.next(false))
+            val (initMessage, initNonce) = result.outgoingMessages.first()
+
+            initMessage.toIdentity = it.contact.identity
+            val initCspMessage =
+                initMessage.toCspMessage(myContact.identityStore, contactStore, initNonce)
 
             val initMessageBox = MessageBox.parseBinary(initCspMessage.toOutgoingMessageData().data)
-            val init = MessageCoder(contactStore, it.identityStore).decode(initMessageBox) as ForwardSecurityEnvelopeMessage
+            val init = MessageCoder(
+                contactStore,
+                it.identityStore
+            ).decode(initMessageBox) as ForwardSecurityEnvelopeMessage
             runBlocking {
                 forwardSecurityMessageProcessorMap[it.identity]!!.processInit(
                     myContact.contact,
@@ -390,9 +412,11 @@ open class MessageProcessorProvider {
             serviceManager.databaseServiceNew,
             serviceManager.preferenceStore,
             TaskArchiverImpl(serviceManager.databaseServiceNew.taskArchiveFactory),
-            serviceManager.deviceCookieManager as DeviceCookieManagerImpl,
+            serviceManager.deviceCookieManager,
             taskManager,
-            serviceManager.multiDeviceManager as MultiDeviceManagerImpl
+            serviceManager.multiDeviceManager as MultiDeviceManagerImpl,
+            serviceManager.identityStore,
+            serviceManager.nonceFactory,
         )
 
         val field = ServiceManager::class.java.getDeclaredField("coreServiceManager")
@@ -427,7 +451,14 @@ open class MessageProcessorProvider {
         val contactStore = serviceManager.contactStore
         val fileService = serviceManager.fileService
 
-        initialContacts.forEach { addContactToDatabase(it, databaseService, contactStore, AcquaintanceLevel.GROUP) }
+        initialContacts.forEach {
+            addContactToDatabase(
+                it,
+                databaseService,
+                contactStore,
+                AcquaintanceLevel.GROUP
+            )
+        }
 
         initialGroups.forEach { addGroupToDatabase(it, databaseService, fileService) }
     }
@@ -443,7 +474,10 @@ open class MessageProcessorProvider {
                 .setFeatureMask(ThreemaFeature.FORWARD_SECURITY)
         )
 
-        contactStore.addCachedContact(testContact.contact)
+        contactStore.addCachedContact(testContact.toBasicContact())
+
+        // We trigger the listeners to invalidate the cache of the new contact model.
+        ListenerManager.contactListeners.handle { it.onModified(testContact.identity) }
     }
 
     private fun addGroupToDatabase(
@@ -454,7 +488,7 @@ open class MessageProcessorProvider {
         val groupModel = testGroup.groupModel
         databaseService.groupModelFactory.createOrUpdate(groupModel)
         testGroup.setLocalGroupId(groupModel.id)
-        testGroup.members.forEach { member ->
+        testGroup.members.filter { it.identity != myContact.identity }.forEach { member ->
             val memberModel = GroupMemberModel()
                 .setGroupId(groupModel.id)
                 .setIdentity(member.identity)
@@ -479,20 +513,9 @@ open class MessageProcessorProvider {
         )
 
         // Process the group message
-        val messageProcessor = serviceManager.let {
-            IncomingMessageProcessorImpl(
-                it.messageService,
-                it.nonceFactory,
-                it.forwardSecurityMessageProcessor,
-                it.contactService,
-                it.contactStore,
-                it.identityStore,
-                it.blockedContactsService,
-                it.preferenceService,
-                it
-            )
-        }
-        messageProcessor.processIncomingMessage(messageBox, localTaskCodec)
+        val messageProcessor = IncomingMessageProcessorImpl(serviceManager)
+
+        messageProcessor.processIncomingCspMessage(messageBox, localTaskCodec)
 
         // Assert that this message has been acked towards the server
         assertEquals(
@@ -505,6 +528,13 @@ open class MessageProcessorProvider {
         }
     }
 
+    /**
+     * Run a task with the local task codec.
+     */
+    protected fun <T> runTask(task: ActiveTask<T>): T = runBlocking {
+        task.invoke(localTaskCodec)
+    }
+
     /**
      * Create a message box from a user with the given identity store.
      */
@@ -514,19 +544,45 @@ open class MessageProcessorProvider {
         forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
     ): MessageBox {
         val nonceFactory = NonceFactory(object : NonceStore {
-            override fun exists(nonce: ByteArray) = false
-            override fun store(nonce: ByteArray) = true
-            override fun getAllHashedNonces() = listOf<ByteArray>()
+            override fun exists(scope: NonceScope, nonce: Nonce) = false
+            override fun store(scope: NonceScope, nonce: Nonce) = true
+            override fun getAllHashedNonces(scope: NonceScope) = listOf<HashedNonce>()
+            override fun getCount(scope: NonceScope) = 0L
+            override fun addHashedNoncesChunk(scope: NonceScope, chunkSize: Int, offset: Int, nonces: MutableList<HashedNonce>) {}
+            override fun insertHashedNonces(scope: NonceScope, nonces: List<HashedNonce>) = true
         })
 
-        val encapsulated = forwardSecurityMessageProcessor.makeMessage(
+        val encapsulated = forwardSecurityMessageProcessor.runFsEncapsulationSteps(
             contactStore.getContactForIdentityIncludingCache(
                 msg.toIdentity
-            )!!, msg, globalTaskCodec
-        ).outgoingMessages.last()
+            )!!.enhanceToBasicContact(),
+            msg,
+            nonceFactory.next(NonceScope.CSP),
+            nonceFactory,
+            globalTaskCodec
+        ).outgoingMessages.last().first
 
         val messageCoder = MessageCoder(contactStore, identityStore)
-        return messageCoder.encode(encapsulated, nonceFactory.next(false), nonceFactory)
+        return messageCoder.encode(encapsulated, nonceFactory.next(NonceScope.CSP).bytes)
     }
 
+    private fun Contact.enhanceToBasicContact() = BasicContact(
+        identity,
+        publicKey,
+        ThreemaFeature.Builder()
+            .audio(true)
+            .group(true)
+            .ballot(true)
+            .file(true)
+            .voip(true)
+            .videocalls(true)
+            .forwardSecurity(true)
+            .groupCalls(true)
+            .editMessages(true)
+            .deleteMessages(true)
+            .build().toULong(),
+        IdentityState.ACTIVE,
+        IdentityType.NORMAL,
+    )
+
 }
diff --git a/app/src/androidTest/java/ch/threema/app/protocol/IdentityBlockedStepsTest.kt b/app/src/androidTest/java/ch/threema/app/protocol/IdentityBlockedStepsTest.kt
new file mode 100644
index 00000000..8ddc6350
--- /dev/null
+++ b/app/src/androidTest/java/ch/threema/app/protocol/IdentityBlockedStepsTest.kt
@@ -0,0 +1,364 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.protocol
+
+import ch.threema.app.DangerousTest
+import ch.threema.app.TestCoreServiceManager
+import ch.threema.app.TestTaskManager
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.services.GroupService
+import ch.threema.app.services.IdListService
+import ch.threema.app.services.PreferenceService
+import ch.threema.app.services.PreferenceServiceImpl
+import ch.threema.app.testutils.TestHelpers
+import ch.threema.app.testutils.TestHelpers.TestContact
+import ch.threema.data.TestDatabaseService
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.data.repositories.ModelRepositories
+import ch.threema.domain.helpers.UnusedTaskCodec
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.stores.ContactStore
+import ch.threema.storage.DatabaseServiceNew
+import ch.threema.storage.models.ContactModel
+import ch.threema.storage.models.GroupMemberModel
+import ch.threema.storage.models.GroupModel
+import kotlinx.coroutines.runBlocking
+import org.junit.Before
+import org.junit.Test
+import java.util.Date
+import kotlin.test.assertEquals
+
+@DangerousTest
+class IdentityBlockedStepsTest {
+
+    private lateinit var contactModelRepository: ContactModelRepository
+    private lateinit var contactStore: ContactStore
+    private lateinit var groupService: GroupService
+    private lateinit var blockUnknownPreferenceService: PreferenceService
+    private lateinit var noBlockPreferenceService: PreferenceService
+    private lateinit var blockedContactsService: IdListService
+
+    private val myContact = TestHelpers.TEST_CONTACT
+    private val knownContact = TestContact("12345678")
+    private val unknownContact = TestContact("TESTTEST")
+    private val specialContact = TestContact("*3MAPUSH")
+    private val explicitlyBlockedContact = TestContact("23456789")
+    private val inGroup = TestContact("ABCDEFGH")
+    private val inNoGroup = TestContact("********")
+    private val inLeftGroup = TestContact("--------")
+
+    @Before
+    fun setup() {
+        assert(myContact.identity == TestHelpers.ensureIdentity(ThreemaApplication.requireServiceManager()))
+
+        val serviceManager = ThreemaApplication.requireServiceManager()
+        val databaseService = TestDatabaseService()
+        val coreServiceManager = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseService,
+            preferenceStore = serviceManager.preferenceStore,
+            taskManager = TestTaskManager(UnusedTaskCodec())
+        )
+        contactModelRepository = ModelRepositories(coreServiceManager).contacts
+        contactStore = serviceManager.contactStore
+        groupService = serviceManager.groupService
+        blockedContactsService = serviceManager.blockedContactsService
+        blockedContactsService.add(explicitlyBlockedContact.identity)
+
+        blockUnknownPreferenceService = object : PreferenceServiceImpl(
+            ThreemaApplication.getAppContext(),
+            serviceManager.preferenceStore,
+        ) {
+            override fun isBlockUnknown(): Boolean {
+                return true
+            }
+        }
+
+        noBlockPreferenceService = object : PreferenceServiceImpl(
+            ThreemaApplication.getAppContext(),
+            serviceManager.preferenceStore,
+        ) {
+            override fun isBlockUnknown(): Boolean {
+                return false
+            }
+        }
+
+        addKnownContacts()
+        addGroups(serviceManager.databaseServiceNew)
+    }
+
+    @Test
+    fun testExplicitlyBlockedContact() {
+        assertEquals(
+            BlockState.EXPLICITLY_BLOCKED,
+            runIdentityBlockedSteps(explicitlyBlockedContact.identity, noBlockPreferenceService)
+        )
+        assertEquals(
+            BlockState.EXPLICITLY_BLOCKED,
+            runIdentityBlockedSteps(explicitlyBlockedContact.identity, blockUnknownPreferenceService)
+        )
+    }
+
+    @Test
+    fun testImplicitlyBlockedContact() {
+        assertEquals(
+            BlockState.IMPLICITLY_BLOCKED,
+            runIdentityBlockedSteps(unknownContact.identity, blockUnknownPreferenceService)
+        )
+    }
+
+    @Test
+    fun testImplicitlyBlockedSpecialContact() {
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(specialContact.identity, blockUnknownPreferenceService)
+        )
+    }
+
+    @Test
+    fun testGroupContactWithGroup() {
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(inGroup.identity, blockUnknownPreferenceService)
+        )
+    }
+
+    @Test
+    fun testGroupContactWithoutGroup() {
+        assertEquals(
+            BlockState.IMPLICITLY_BLOCKED,
+            runIdentityBlockedSteps(inNoGroup.identity, blockUnknownPreferenceService)
+        )
+    }
+
+    @Test
+    fun testGroupContactWithLeftGroup() {
+        assertEquals(
+            BlockState.IMPLICITLY_BLOCKED,
+            runIdentityBlockedSteps(inLeftGroup.identity, blockUnknownPreferenceService)
+        )
+    }
+
+    @Test
+    fun testKnownContact() {
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(knownContact.identity, blockUnknownPreferenceService),
+        )
+    }
+
+    @Test
+    fun testWithoutBlockingUnknown() {
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(knownContact.identity, noBlockPreferenceService),
+        )
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(unknownContact.identity, noBlockPreferenceService),
+        )
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(specialContact.identity, noBlockPreferenceService),
+        )
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(inGroup.identity, noBlockPreferenceService)
+        )
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(inNoGroup.identity, noBlockPreferenceService)
+        )
+        assertEquals(
+            BlockState.NOT_BLOCKED,
+            runIdentityBlockedSteps(inLeftGroup.identity, noBlockPreferenceService)
+        )
+
+    }
+
+    private fun runIdentityBlockedSteps(
+        identity: String,
+        preferenceService: PreferenceService,
+    ) = runIdentityBlockedSteps(
+        identity,
+        contactModelRepository,
+        contactStore,
+        groupService,
+        blockedContactsService,
+        preferenceService,
+    )
+
+    private fun addKnownContacts() = runBlocking {
+        contactModelRepository.createFromLocal(
+            ContactModelData(
+                knownContact.identity,
+                knownContact.publicKey,
+                Date(),
+                "",
+                "",
+                "",
+                0u,
+                VerificationLevel.UNVERIFIED,
+                WorkVerificationLevel.NONE,
+                IdentityType.NORMAL,
+                ContactModel.AcquaintanceLevel.DIRECT,
+                IdentityState.ACTIVE,
+                ContactSyncState.INITIAL,
+                0u,
+                ReadReceiptPolicy.DEFAULT,
+                TypingIndicatorPolicy.DEFAULT,
+                null,
+                null,
+                false,
+                null,
+                null,
+                null,
+            )
+        )
+        contactModelRepository.createFromLocal(
+            ContactModelData(
+                inGroup.identity,
+                inGroup.publicKey,
+                Date(),
+                "",
+                "",
+                "",
+                0u,
+                VerificationLevel.UNVERIFIED,
+                WorkVerificationLevel.NONE,
+                IdentityType.NORMAL,
+                ContactModel.AcquaintanceLevel.GROUP,
+                IdentityState.ACTIVE,
+                ContactSyncState.INITIAL,
+                0u,
+                ReadReceiptPolicy.DEFAULT,
+                TypingIndicatorPolicy.DEFAULT,
+                null,
+                null,
+                false,
+                null,
+                null,
+                null,
+            )
+        )
+        contactModelRepository.createFromLocal(
+            ContactModelData(
+                inNoGroup.identity,
+                inNoGroup.publicKey,
+                Date(),
+                "",
+                "",
+                "",
+                0u,
+                VerificationLevel.UNVERIFIED,
+                WorkVerificationLevel.NONE,
+                IdentityType.NORMAL,
+                ContactModel.AcquaintanceLevel.GROUP,
+                IdentityState.ACTIVE,
+                ContactSyncState.INITIAL,
+                0u,
+                ReadReceiptPolicy.DEFAULT,
+                TypingIndicatorPolicy.DEFAULT,
+                null,
+                null,
+                false,
+                null,
+                null,
+                null,
+            )
+        )
+        contactModelRepository.createFromLocal(
+            ContactModelData(
+                inLeftGroup.identity,
+                inLeftGroup.publicKey,
+                Date(),
+                "",
+                "",
+                "",
+                0u,
+                VerificationLevel.UNVERIFIED,
+                WorkVerificationLevel.NONE,
+                IdentityType.NORMAL,
+                ContactModel.AcquaintanceLevel.GROUP,
+                IdentityState.ACTIVE,
+                ContactSyncState.INITIAL,
+                0u,
+                ReadReceiptPolicy.DEFAULT,
+                TypingIndicatorPolicy.DEFAULT,
+                null,
+                null,
+                false,
+                null,
+                null,
+                null,
+            )
+        )
+    }
+
+    private fun addGroups(databaseService: DatabaseServiceNew) = runBlocking {
+        databaseService.groupModelFactory.apply {
+            create(
+                GroupModel()
+                    .setApiGroupId(GroupId(0))
+                    .setCreatorIdentity(myContact.identity)
+                    .setUserState(GroupModel.UserState.MEMBER)
+                    .setCreatedAt(Date())
+            )
+            create(
+                GroupModel()
+                    .setApiGroupId(GroupId(1))
+                    .setCreatorIdentity(myContact.identity)
+                    .setUserState(GroupModel.UserState.LEFT)
+                    .setCreatedAt(Date())
+            )
+        }
+        val memberGroup = databaseService.groupModelFactory.getByApiGroupIdAndCreator(
+            GroupId(0).toString(),
+            myContact.identity
+        )
+        val leftGroup = databaseService.groupModelFactory.getByApiGroupIdAndCreator(
+            GroupId(1).toString(),
+            myContact.identity
+        )
+        databaseService.groupMemberModelFactory.apply {
+            create(
+                GroupMemberModel()
+                    .setGroupId(memberGroup.id)
+                    .setIdentity(inGroup.identity)
+            )
+            create(
+                GroupMemberModel()
+                    .setGroupId(leftGroup.id)
+                    .setIdentity(inLeftGroup.identity)
+            )
+        }
+    }
+
+}
diff --git a/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java b/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java
index f7d9723a..72d78c00 100644
--- a/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java
+++ b/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java
@@ -29,13 +29,16 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
+import java.io.File;
 import java.io.IOException;
 import java.util.Date;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
+import ch.threema.app.services.ContactService;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.services.group.GroupInviteService;
@@ -43,6 +46,7 @@ import ch.threema.app.services.group.GroupInviteServiceImpl;
 import ch.threema.app.services.license.LicenseService;
 import ch.threema.domain.protocol.csp.messages.group.GroupInviteData;
 import ch.threema.domain.protocol.csp.messages.group.GroupInviteToken;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.protobuf.url_payloads.GroupInvite;
 import ch.threema.storage.DatabaseServiceNew;
@@ -96,7 +100,34 @@ public class GroupInviteServiceTest {
 
 			}
 
-			@Override
+            @Nullable
+            @Override
+            public byte[] getUserProfilePicture() {
+                return null;
+            }
+
+            @Override
+            public boolean setUserProfilePicture(@NonNull File userProfilePicture, @NonNull TriggerSource triggerSource) {
+                return false;
+            }
+
+            @Override
+            public boolean setUserProfilePicture(@NonNull byte[] userProfilePicture, @NonNull TriggerSource triggerSource) {
+                return false;
+            }
+
+            @Override
+            public void removeUserProfilePicture(@NonNull TriggerSource triggerSource) {
+
+            }
+
+            @NonNull
+            @Override
+            public ContactService.ProfilePictureUploadData uploadUserProfilePictureOrGetPreviousUploadData() {
+                return null;
+            }
+
+            @Override
 			public Account getAccount() {
 				return null;
 			}
@@ -228,7 +259,7 @@ public class GroupInviteServiceTest {
 
 			@Nullable
 			@Override
-			public String setPublicNickname(String publicNickname) {
+			public String setPublicNickname(String publicNickname, @NonNull TriggerSource triggerSource) {
 				return null;
 			}
 
diff --git a/app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt b/app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt
index de2d2841..c46e3366 100644
--- a/app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt
@@ -22,15 +22,25 @@
 package ch.threema.app.tasks
 
 import ch.threema.app.ThreemaApplication
-import ch.threema.domain.models.Contact
+import ch.threema.data.models.ContactModelData
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
 import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.storage.models.ContactModel
 import com.neilalexander.jnacl.NaCl
 import junit.framework.TestCase.assertEquals
 import junit.framework.TestCase.assertNotNull
 import junit.framework.TestCase.fail
+import kotlinx.coroutines.runBlocking
 import kotlinx.serialization.json.Json
 import org.junit.Test
+import java.util.Date
 
 /**
  * These tests are useful to detect when a task cannot be created out of a persisted representation
@@ -187,8 +197,8 @@ class PersistableTasksTest {
 
     @Test
     fun testDeleteAndTerminateFSSessionsTask() {
-        // Add the contact '01234567' so that restoring the tasks works
-        serviceManager.contactStore.addCachedContact(Contact("01234567", ByteArray(NaCl.PUBLICKEYBYTES)))
+        // Add the contact '01234567' so that creating the tasks works
+        addTestIdentity()
 
         assertValidEncoding(
             DeleteAndTerminateFSSessionsTask::class.java,
@@ -225,10 +235,18 @@ class PersistableTasksTest {
     }
 
     @Test
-    fun testOutgoingDropDeviceTask() {
+    fun testOutboundIncomingContactMessageUpdateReadTask() {
         assertValidEncoding(
-            OutgoingDropDeviceTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingDropDeviceTask.OutgoingDropDeviceData\",\"deviceId\":0}"
+            OutboundIncomingContactMessageUpdateReadTask::class.java,
+            "{\"type\":\"ch.threema.app.tasks.OutboundIncomingContactMessageUpdateReadTask.OutboundIncomingContactMessageUpdateReadData\",\"messageIds\":[[0,-1,2,3,4,5,6,7]],\"timestamp\":1704067200000,\"recipientIdentity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testOutboundIncomingGroupMessageUpdateReadTask() {
+        assertValidEncoding(
+            OutboundIncomingGroupMessageUpdateReadTask::class.java,
+            "{\"type\":\"ch.threema.app.tasks.OutboundIncomingGroupMessageUpdateReadTask.OutboundIncomingGroupMessageUpdateReadData\",\"messageIds\":[[0,-1,2,3,4,5,6,7]],\"timestamp\":1704067200000,\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\"}"
         )
     }
 
@@ -264,6 +282,215 @@ class PersistableTasksTest {
         )
     }
 
+    @Test
+    fun testReflectUserProfileNicknameSyncTask() {
+        assertValidEncoding(
+            ReflectUserProfileNicknameSyncTask::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectUserProfileNicknameSyncTask.ReflectUserProfileNicknameSyncTaskData\",\"newNickname\":\"nick\"}"
+        )
+    }
+
+    @Test
+    fun testReflectUserProfilePictureSyncTask() {
+        assertValidEncoding(
+            ReflectUserProfilePictureSyncTask::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectUserProfilePictureSyncTask.ReflectUserProfilePictureSyncTaskData\"}"
+        )
+    }
+
+    @Test
+    fun testReflectUserProfileShareWithPolicySyncTask() {
+        assertValidEncoding(
+            ReflectUserProfileShareWithPolicySyncTask::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectUserProfileShareWithPolicySyncTask.ReflectUserProfileShareWithPolicySyncTaskData\",\"newPolicy\":\"NOBODY\"}"
+        )
+    }
+
+    @Test
+    fun testReflectUserProfileShareWithAllowListSyncTask() {
+        assertValidEncoding(
+            ReflectUserProfileShareWithAllowListSyncTask::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectUserProfileShareWithAllowListSyncTask.ReflectUserProfileShareWithAllowListSyncTaskData\",\"allowedIdentities\":[\"01234567\", \"01234568\"]}"
+        )
+    }
+
+    @Test
+    fun testReflectNameUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectNameUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectNameUpdate.ReflectNameUpdateData\",\"firstName\":\"A\",\"lastName\":\"B\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectNameUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectNameUpdate.ReflectNameUpdateData\",\"firstName\":\"A\",\"lastName\":\"\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectNameUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectNameUpdate.ReflectNameUpdateData\",\"firstName\":\"\",\"lastName\":\"B\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testReflectReadReceiptPolicyUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate.ReflectReadReceiptPolicyUpdateData\",\"readReceiptPolicy\":\"DEFAULT\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate.ReflectReadReceiptPolicyUpdateData\",\"readReceiptPolicy\":\"SEND\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate.ReflectReadReceiptPolicyUpdateData\",\"readReceiptPolicy\":\"DONT_SEND\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testReflectTypingIndicatorPolicyUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate.ReflectTypingIndicatorPolicyUpdateData\",\"typingIndicatorPolicy\":\"DEFAULT\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate.ReflectTypingIndicatorPolicyUpdateData\",\"typingIndicatorPolicy\":\"SEND\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate.ReflectTypingIndicatorPolicyUpdateData\",\"typingIndicatorPolicy\":\"DONT_SEND\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testReflectActivityStateUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectActivityStateUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectActivityStateUpdate.ReflectActivityStateUpdateData\",\"identityState\":\"ACTIVE\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectActivityStateUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectActivityStateUpdate.ReflectActivityStateUpdateData\",\"identityState\":\"INACTIVE\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectActivityStateUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectActivityStateUpdate.ReflectActivityStateUpdateData\",\"identityState\":\"INVALID\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testReflectFeatureMaskUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectFeatureMaskUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectFeatureMaskUpdate.ReflectFeatureMaskUpdateData\",\"featureMask\":12345,\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testVerificationLevelUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate.ReflectVerificationLevelUpdateData\",\"verificationLevel\":\"UNVERIFIED\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate.ReflectVerificationLevelUpdateData\",\"verificationLevel\":\"SERVER_VERIFIED\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate.ReflectVerificationLevelUpdateData\",\"verificationLevel\":\"FULLY_VERIFIED\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testWorkVerificationLevelUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectWorkVerificationLevelUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectWorkVerificationLevelUpdate.ReflectWorkVerificationLevelUpdateData\",\"workVerificationLevel\":\"NONE\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectWorkVerificationLevelUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectWorkVerificationLevelUpdate.ReflectWorkVerificationLevelUpdateData\",\"workVerificationLevel\":\"WORK_SUBSCRIPTION_VERIFIED\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testIdentityTypeUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectIdentityTypeUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectIdentityTypeUpdate.ReflectIdentityTypeUpdateData\",\"identityType\":\"NORMAL\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectIdentityTypeUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectIdentityTypeUpdate.ReflectIdentityTypeUpdateData\",\"identityType\":\"WORK\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testAcquaintanceLevelUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectAcquaintanceLevelUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectAcquaintanceLevelUpdate.ReflectAcquaintanceLevelUpdateData\",\"acquaintanceLevel\":\"DIRECT\",\"identity\":\"01234567\"}"
+        )
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectAcquaintanceLevelUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectAcquaintanceLevelUpdate.ReflectAcquaintanceLevelUpdateData\",\"acquaintanceLevel\":\"GROUP\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    @Test
+    fun testUserDefinedProfilePictureUpdate() {
+        assertValidEncoding(
+            ReflectContactSyncUpdateTask.ReflectUserDefinedProfilePictureUpdate::class.java,
+            "{\"type\":\"ch.threema.app.tasks.ReflectContactSyncUpdateTask.ReflectUserDefinedProfilePictureUpdate.ReflectUserDefinedProfilePictureUpdateData\",\"identity\":\"0BZYE2H9\"}"
+        )
+    }
+
+    @Test
+    fun testOnFSFeatureMaskDowngradedTask() {
+        // Add the contact '01234567' so that creating the tasks works
+        addTestIdentity()
+
+        assertValidEncoding(
+            OnFSFeatureMaskDowngradedTask::class.java,
+            "{\"type\":\"ch.threema.app.tasks.OnFSFeatureMaskDowngradedTask.OnFSFeatureMaskDowngradedData\",\"identity\":\"01234567\"}"
+        )
+    }
+
+    private fun addTestIdentity() = runBlocking {
+        val identity = "01234567"
+        if (serviceManager.modelRepositories.contacts.getByIdentity(identity) != null) {
+            // If the contact already exists, we do not add it again
+            return@runBlocking
+        }
+
+        serviceManager.modelRepositories.contacts.createFromLocal(
+            ContactModelData(
+                identity = identity,
+                publicKey = ByteArray(NaCl.PUBLICKEYBYTES),
+                createdAt = Date(42),
+                firstName = "0123",
+                lastName = "4567",
+                nickname = "01",
+                verificationLevel = VerificationLevel.SERVER_VERIFIED,
+                workVerificationLevel = WorkVerificationLevel.NONE,
+                identityType = IdentityType.NORMAL,
+                acquaintanceLevel = ContactModel.AcquaintanceLevel.DIRECT,
+                activityState = IdentityState.ACTIVE,
+                syncState = ContactSyncState.INITIAL,
+                featureMask = 0u,
+                typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+                readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+                androidContactLookupKey = null,
+                localAvatarExpires = null,
+                isRestored = false,
+                profilePictureBlobId = null,
+                jobTitle = null,
+                department = null,
+            )
+        )
+    }
+
     private fun <T> assertValidEncoding(expectedTaskClass: Class<T>, encodedTask: String) {
         val decodedTask = encodedTask.decodeToTask()
         assertNotNull(decodedTask)
diff --git a/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java b/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java
index 390ae900..1dc87fa3 100644
--- a/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java
+++ b/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java
@@ -45,8 +45,12 @@ import ch.threema.app.services.UserService;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.helpers.InMemoryIdentityStore;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.models.GroupId;
+import ch.threema.domain.models.IdentityState;
+import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
@@ -103,6 +107,28 @@ public class TestHelpers {
 				null
 			);
 		}
+
+		@NonNull
+		public BasicContact toBasicContact() {
+			return BasicContact.javaCreate(
+				identity,
+				publicKey,
+				new ThreemaFeature.Builder()
+					.audio(true)
+					.group(true)
+					.ballot(true)
+					.file(true)
+					.voip(true)
+					.videocalls(true)
+					.forwardSecurity(true)
+					.groupCalls(true)
+					.editMessages(true)
+					.deleteMessages(true)
+					.build(),
+				IdentityState.ACTIVE,
+				IdentityType.NORMAL
+			);
+		}
 	}
 
 	public static final class TestGroup {
@@ -123,13 +149,20 @@ public class TestHelpers {
 		@Nullable
 		public final byte[] profilePicture;
 
+		/**
+		 * Note that the user identity is used to set the correct group user state.
+		 */
+		@NonNull
+		public final String userIdentity;
+
 		public TestGroup(
 			@NonNull GroupId apiGroupId,
 			@NonNull TestContact groupCreator,
 			@NonNull List<TestContact> members,
-			@NonNull String groupName
+			@NonNull String groupName,
+			@NonNull String userIdentity
 		) {
-			this(apiGroupId, groupCreator, members, groupName, null);
+			this(apiGroupId, groupCreator, members, groupName, null, userIdentity);
 		}
 
 		public TestGroup(
@@ -137,23 +170,38 @@ public class TestHelpers {
 			@NonNull TestContact groupCreator,
 			@NonNull List<TestContact> members,
 			@NonNull String groupName,
-			@Nullable byte[] profilePicture
+			@Nullable byte[] profilePicture,
+			@NonNull String userIdentity
 		) {
 			this.apiGroupId = apiGroupId;
 			this.groupCreator = groupCreator;
 			this.members = members;
 			this.groupName = groupName;
 			this.profilePicture = profilePicture;
+			this.userIdentity = userIdentity;
 		}
 
 		@NonNull
 		public GroupModel getGroupModel() {
+			boolean isMember = false;
+			for (TestContact member : members) {
+				if (member.identity.equals(userIdentity)) {
+					isMember = true;
+					break;
+				}
+			}
+			return getGroupModel(isMember ? GroupModel.UserState.MEMBER : GroupModel.UserState.LEFT);
+		}
+
+		@NonNull
+		private GroupModel getGroupModel(@NonNull GroupModel.UserState userState) {
 			return new GroupModel()
 				.setApiGroupId(apiGroupId)
 				.setCreatedAt(new Date())
 				.setName(this.groupName)
 				.setCreatorIdentity(this.groupCreator.identity)
-				.setId(localGroupId);
+				.setId(localGroupId)
+				.setUserState(userState);
 		}
 
 		public void setLocalGroupId(int localGroupId) {
diff --git a/app/src/androidTest/java/ch/threema/app/utils/BundledMessagesSendStepsTest.kt b/app/src/androidTest/java/ch/threema/app/utils/BundledMessagesSendStepsTest.kt
new file mode 100644
index 00000000..65d20f87
--- /dev/null
+++ b/app/src/androidTest/java/ch/threema/app/utils/BundledMessagesSendStepsTest.kt
@@ -0,0 +1,233 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.utils
+
+import ch.threema.app.processors.MessageProcessorProvider
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.GroupTextMessage
+import ch.threema.domain.protocol.csp.messages.TextMessage
+import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import org.junit.Before
+import java.util.Date
+import kotlin.test.Test
+import kotlin.test.assertEquals
+import kotlin.test.assertTrue
+
+class BundledMessagesSendStepsTest : MessageProcessorProvider() {
+
+    private lateinit var outgoingCspMessageServices: OutgoingCspMessageServices
+
+    @Before
+    fun initialize() {
+        outgoingCspMessageServices = OutgoingCspMessageServices(
+            serviceManager.forwardSecurityMessageProcessor,
+            myContact.identityStore,
+            serviceManager.userService,
+            serviceManager.contactStore,
+            serviceManager.contactService,
+            serviceManager.modelRepositories.contacts,
+            serviceManager.groupService,
+            serviceManager.nonceFactory,
+            serviceManager.blockedContactsService,
+            serviceManager.preferenceService,
+            serviceManager.multiDeviceManager,
+        )
+    }
+
+    @Test
+    fun testContactMessage() {
+        runInsideOfATask { handle ->
+            val messageId = MessageId()
+            val createdAt = Date()
+            var hasBeenMarkedAsSent = false
+            var forwardSecurityModes: Map<String, ForwardSecurityMode>? = null
+            val outgoingCspMessageHandle = OutgoingCspMessageHandle(
+                contactA.toBasicContact(),
+                OutgoingCspContactMessageCreator(
+                    messageId,
+                    createdAt,
+                    contactA.identity,
+                ) { TextMessage().apply { text = "Test" } },
+                { hasBeenMarkedAsSent = true },
+                { stateMap -> forwardSecurityModes = stateMap },
+            )
+
+            handle.runBundledMessagesSendSteps(
+                outgoingCspMessageHandle,
+                outgoingCspMessageServices,
+            )
+            assertMessageHandleSent(outgoingCspMessageHandle) { message ->
+                message as TextMessage
+                assertEquals("Test", message.text)
+            }
+            assertTrue(sentMessagesInsideTask.isEmpty())
+            assertTrue(sentMessagesNewTask.isEmpty())
+
+            assertTrue(hasBeenMarkedAsSent)
+            assertEquals(1, forwardSecurityModes!!.keys.size)
+            forwardSecurityModes!!.values.forEach {
+                assertEquals(ForwardSecurityMode.FOURDH, it)
+            }
+        }
+    }
+
+    @Test
+    fun testGroupMessage() {
+        runInsideOfATask { handle ->
+            val messageId = MessageId()
+            val createdAt = Date()
+            val group = groupAB
+            var hasBeenMarkedAsSent = false
+            var forwardSecurityModes: Map<String, ForwardSecurityMode>? = null
+            val outgoingCspMessageHandle = OutgoingCspMessageHandle(
+                group.members.map { it.toBasicContact() }.toSet(),
+                OutgoingCspGroupMessageCreator(
+                    messageId,
+                    createdAt,
+                    group.groupModel,
+                ) { GroupTextMessage().apply { text = "Test" } },
+                { hasBeenMarkedAsSent = true },
+                { stateMap -> forwardSecurityModes = stateMap},
+            )
+
+            handle.runBundledMessagesSendSteps(
+                outgoingCspMessageHandle,
+                outgoingCspMessageServices,
+            )
+
+            assertMessageHandleSent(outgoingCspMessageHandle) { message ->
+                message as GroupTextMessage
+                assertEquals("Test", message.text)
+            }
+            assertTrue(sentMessagesInsideTask.isEmpty())
+            assertTrue(sentMessagesNewTask.isEmpty())
+
+            assertTrue(hasBeenMarkedAsSent)
+            assertEquals(group.members.size - 1, forwardSecurityModes!!.keys.size)
+            forwardSecurityModes!!.values.forEach {
+                assertEquals(ForwardSecurityMode.FOURDH, it)
+            }
+        }
+    }
+
+    @Test
+    fun testMultipleMessages() = runInsideOfATask { handle ->
+        val sentDates = mutableListOf<ULong>()
+        val handles = listOf(
+            OutgoingCspMessageHandle(
+                contactA.toBasicContact(),
+                OutgoingCspContactMessageCreator(
+                    MessageId(),
+                    Date(),
+                    contactA.identity,
+                ) {
+                    TextMessage().apply { text = "Test" }
+                },
+                { sentAt -> sentDates.add(sentAt) },
+            ),
+            OutgoingCspMessageHandle(
+                contactB.toBasicContact(),
+                OutgoingCspContactMessageCreator(
+                    MessageId(),
+                    Date(),
+                    contactA.identity,
+                ) {
+                    TextMessage().apply { text = "Test" }
+                },
+                { sentAt -> sentDates.add(sentAt) },
+            ),
+            OutgoingCspMessageHandle(
+                groupAB.members.map { it.toBasicContact() }.toSet(),
+                OutgoingCspGroupMessageCreator(
+                    MessageId(),
+                    Date(),
+                    groupAB.groupModel,
+                ) {
+                    GroupTextMessage().apply { text = "Test" }
+                },
+                { sentAt -> sentDates.add(sentAt) },
+            ),
+        )
+
+        handle.runBundledMessagesSendSteps(
+            handles,
+            outgoingCspMessageServices,
+        )
+
+        assertMessageHandleSent(handles[0]) { message ->
+            message as TextMessage
+            assertEquals("Test", message.text)
+        }
+        assertMessageHandleSent(handles[1]) { message ->
+            message as TextMessage
+            assertEquals("Test", message.text)
+        }
+        assertMessageHandleSent(handles[2]) { message ->
+            message as GroupTextMessage
+            assertEquals("Test", message.text)
+        }
+
+        assertTrue(sentMessagesInsideTask.isEmpty())
+        assertTrue(sentMessagesNewTask.isEmpty())
+
+        assertEquals(handles.size, sentDates.size)
+        // We use the same sent at timestamp for all bundled messages
+        assertEquals(1, sentDates.toSet().size)
+    }
+
+    private fun assertMessageHandleSent(messageHandle: OutgoingCspMessageHandle, assertMessage: (AbstractMessage) -> Unit) {
+        val expectedReceivers = messageHandle.receivers
+            .map { it.identity }
+            .filter { it != myContact.identity }
+            .sorted()
+
+
+        val actualReceivers = sentMessagesInsideTask
+            .asSequence()
+            .take(expectedReceivers.size)
+            .sortedBy { it.toIdentity }
+            .onEach {
+                assertMessage(it)
+                assertEquals(messageHandle.messageCreator.messageId.messageIdLong, it.messageId.messageIdLong)
+                assertEquals(messageHandle.messageCreator.createdAt.time, it.date.time)
+            }
+            .map { it.toIdentity }
+            .toList()
+
+        assertEquals(expectedReceivers, actualReceivers)
+
+        repeat(expectedReceivers.size) {
+            sentMessagesInsideTask.remove()
+        }
+    }
+
+    private fun <T> runInsideOfATask(runnable: suspend (handle: ActiveTaskCodec) -> T): T =
+        runTask(object : ActiveTask<T> {
+            override val type = "TestTask"
+
+            override suspend fun invoke(handle: ActiveTaskCodec) = runnable(handle)
+        })
+
+}
diff --git a/app/src/androidTest/java/ch/threema/app/webclient/converter/MessageTest.java b/app/src/androidTest/java/ch/threema/app/webclient/converter/MessageTest.java
index 4a6baa67..fca7dcbe 100644
--- a/app/src/androidTest/java/ch/threema/app/webclient/converter/MessageTest.java
+++ b/app/src/androidTest/java/ch/threema/app/webclient/converter/MessageTest.java
@@ -80,7 +80,7 @@ public class MessageTest {
 			new HashMap<>()
 		);
 		final AbstractMessageModel messageModel = new MessageModel();
-		messageModel.setFileData(fileDataModel);
+		messageModel.setFileDataModel(fileDataModel);
 		messageModel.setCreatedAt(createdAt);
 		messageModel.setApiMessageId(messageId);
 		Message.maybePutFile(builder, "file", messageModel, fileDataModel);
diff --git a/app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt b/app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt
index d60f81ac..6a89bab1 100644
--- a/app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt
+++ b/app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt
@@ -21,10 +21,17 @@
 
 package ch.threema.data.repositories
 
-import androidx.test.ext.junit.runners.AndroidJUnit4
+import ch.threema.app.TestCoreServiceManager
+import ch.threema.app.TestMultiDeviceManager
+import ch.threema.app.TestTaskManager
+import ch.threema.app.ThreemaApplication
 import ch.threema.data.TestDatabaseService
-import ch.threema.data.models.ModelDeletedException
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.models.ContactModelData.Companion.getIdColorIndex
+import ch.threema.domain.helpers.TransactionAckTaskCodec
+import ch.threema.domain.helpers.UnusedTaskCodec
 import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.models.ReadReceiptPolicy
 import ch.threema.domain.models.TypingIndicatorPolicy
@@ -32,84 +39,186 @@ import ch.threema.domain.models.VerificationLevel
 import ch.threema.domain.models.WorkVerificationLevel
 import ch.threema.storage.models.ContactModel
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
 import ch.threema.testhelpers.nonSecureRandomArray
 import ch.threema.testhelpers.randomIdentity
 import com.neilalexander.jnacl.NaCl
-import junit.framework.TestCase.assertNotNull
 import kotlinx.coroutines.runBlocking
-import org.junit.Assert.assertArrayEquals
 import org.junit.Assert.assertThrows
 import org.junit.Before
 import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
 import java.util.Date
 import kotlin.test.Test
 import kotlin.test.assertContentEquals
 import kotlin.test.assertEquals
-import kotlin.test.assertFailsWith
-import kotlin.test.assertFalse
 import kotlin.test.assertNull
 import kotlin.test.assertTrue
+import kotlin.test.fail
 
-@RunWith(AndroidJUnit4::class)
-class ContactModelRepositoryTest {
+@RunWith(value = Parameterized::class)
+class ContactModelRepositoryTest(private val contactModelData: ContactModelData) {
+    // Services where MD is disabled
     private lateinit var databaseService: TestDatabaseService
+    private lateinit var coreServiceManager: TestCoreServiceManager
     private lateinit var contactModelRepository: ContactModelRepository
 
+    // Services where MD is enabled
+    private lateinit var databaseServiceMd: TestDatabaseService
+    private lateinit var taskCodecMd: TransactionAckTaskCodec
+    private lateinit var coreServiceManagerMd: TestCoreServiceManager
+    private lateinit var contactModelRepositoryMd: ContactModelRepository
+
     private enum class TestTriggerSource {
         FROM_LOCAL,
         FROM_REMOTE,
     }
 
-    private val initialValuesSet = setOf(
-        InitialValues(),
-        InitialValues(publicKey = ByteArray(NaCl.PUBLICKEYBYTES) { it.toByte() }),
-        InitialValues(date = Date(42)),
-        InitialValues(identityType = IdentityType.WORK),
-        InitialValues(acquaintanceLevel = AcquaintanceLevel.GROUP),
-        InitialValues(activityState = State.INACTIVE),
-        InitialValues(featureMask = 64.toULong()),
-    )
+    companion object {
+        @JvmStatic
+        @Parameterized.Parameters()
+        fun initialValuesSet() = setOf(
+            getInitialContactModelData(),
+            getInitialContactModelData(publicKey = ByteArray(NaCl.PUBLICKEYBYTES) { it.toByte() }),
+            getInitialContactModelData(createdAt = Date(42)),
+            getInitialContactModelData(identityType = IdentityType.WORK),
+            getInitialContactModelData(acquaintanceLevel = AcquaintanceLevel.GROUP),
+            getInitialContactModelData(activityState = IdentityState.INACTIVE),
+            getInitialContactModelData(featureMask = 64.toULong()),
+        )
+
+        private fun getInitialContactModelData(
+            identity: String = "ABCDEFGH",
+            publicKey: ByteArray = ByteArray(NaCl.PUBLICKEYBYTES),
+            createdAt: Date = Date(),
+            firstName: String = "",
+            lastName: String = "",
+            nickname: String? = null,
+            verificationLevel: VerificationLevel = VerificationLevel.UNVERIFIED,
+            workVerificationLevel: WorkVerificationLevel = WorkVerificationLevel.NONE,
+            identityType: IdentityType = IdentityType.NORMAL,
+            acquaintanceLevel: AcquaintanceLevel = AcquaintanceLevel.DIRECT,
+            activityState: IdentityState = IdentityState.ACTIVE,
+            syncState: ContactSyncState = ContactSyncState.INITIAL,
+            featureMask: ULong = 0u,
+            readReceiptPolicy: ReadReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+            typingIndicatorPolicy: TypingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+            androidContactLookupKey: String? = null,
+            localAvatarExpires: Date? = null,
+            isRestored: Boolean = false,
+            profilePictureBlobId: ByteArray? = null,
+            jobTitle: String? = null,
+            department: String? = null,
+        ) = ContactModelData(
+            identity = identity,
+            publicKey = publicKey,
+            createdAt = createdAt,
+            firstName = firstName,
+            lastName = lastName,
+            nickname = nickname,
+            colorIndex = getIdColorIndex(identity),
+            verificationLevel = verificationLevel,
+            workVerificationLevel = workVerificationLevel,
+            identityType = identityType,
+            acquaintanceLevel = acquaintanceLevel,
+            activityState = activityState,
+            syncState = syncState,
+            featureMask = featureMask,
+            readReceiptPolicy = readReceiptPolicy,
+            typingIndicatorPolicy = typingIndicatorPolicy,
+            androidContactLookupKey = androidContactLookupKey,
+            localAvatarExpires = localAvatarExpires,
+            isRestored = isRestored,
+            profilePictureBlobId = profilePictureBlobId,
+            jobTitle = jobTitle,
+            department = department,
+        )
+    }
 
     @Before
     fun before() {
+        // Instantiate services where MD is disabled
         this.databaseService = TestDatabaseService()
-        this.contactModelRepository = ModelRepositories(databaseService).contacts
+        this.coreServiceManager = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseService,
+            preferenceStore = ThreemaApplication.requireServiceManager().preferenceStore,
+            taskManager = TestTaskManager(UnusedTaskCodec())
+        )
+        this.contactModelRepository = ModelRepositories(coreServiceManager).contacts
+
+        // Instantiate services where MD is enabled
+        this.databaseServiceMd = TestDatabaseService()
+        this.taskCodecMd = TransactionAckTaskCodec()
+        this.coreServiceManagerMd = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseServiceMd,
+            preferenceStore = ThreemaApplication.requireServiceManager().preferenceStore,
+            multiDeviceManager = TestMultiDeviceManager(
+                isMultiDeviceActive = true,
+                isMdDisabledOrSupportsFs = false,
+            ),
+            taskManager = TestTaskManager(taskCodecMd)
+        )
+        this.contactModelRepositoryMd = ModelRepositories(coreServiceManagerMd).contacts
     }
 
+    /**
+     * Test creation of a new contact from local.
+     */
     @Test
     fun createFromLocal() {
-        initialValuesSet.forEach { testCreateFromLocalOrRemote(it, TestTriggerSource.FROM_LOCAL) }
+        testCreateFromLocalOrRemote(contactModelData, TestTriggerSource.FROM_LOCAL)
     }
 
+    /**
+     * Test creation of a new contact from remote.
+     */
     @Test
     fun createFromRemote() {
-        initialValuesSet.forEach { testCreateFromLocalOrRemote(it, TestTriggerSource.FROM_REMOTE) }
+        testCreateFromLocalOrRemote(contactModelData, TestTriggerSource.FROM_REMOTE)
+    }
+
+    /**
+     * Test creation of a new contact from sync.
+     */
+    @Test
+    fun createFromSync() {
+        testCreateFromSync(contactModelData)
     }
 
+    /**
+     * Test creation of a new contact from local twice. The first time a new contact should be
+     * created. The second time a [ContactStoreException] should be thrown.
+     */
     @Test
     fun createFromLocalTwice() {
-        initialValuesSet.forEach {
-            testCreateFromLocalOrRemoteTwice(it, TestTriggerSource.FROM_LOCAL)
-        }
+        testCreateFromLocalOrRemoteTwice(contactModelData, TestTriggerSource.FROM_LOCAL)
     }
 
+    /**
+     * Test creation of a new contact from remote twice. The first time a new contact should be
+     * created. The second time a [ContactStoreException] should be thrown.
+     */
     @Test
     fun createFromRemoteTwice() {
-        initialValuesSet.forEach {
-            testCreateFromLocalOrRemoteTwice(it, TestTriggerSource.FROM_REMOTE)
-        }
+        testCreateFromLocalOrRemoteTwice(contactModelData, TestTriggerSource.FROM_REMOTE)
     }
 
+    /**
+     * Test creation of a new contact from sync twice. The first time a new contact should be
+     * created. The second time a [ContactStoreException] should be thrown.
+     */
     @Test
-    fun createFromSync() {
-        // TODO(ANDR-2835): Create contact from sync
+    fun createFromSyncTwice() {
+        testCreateFromSyncTwice(contactModelData)
     }
 
     @Test
     fun getByIdentityNotFound() {
         val model = contactModelRepository.getByIdentity("ABCDEFGH")
         assertNull(model)
+        val modelMd = contactModelRepositoryMd.getByIdentity("ABCDEFGH")
+        assertNull(modelMd)
     }
 
     @Test
@@ -119,219 +228,219 @@ class ContactModelRepositoryTest {
 
         // Create contact using "old model"
         databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, publicKey))
+        databaseServiceMd.contactModelFactory.createOrUpdate(ContactModel(identity, publicKey))
 
         // Fetch contact using "new model"
-        val model = contactModelRepository.getByIdentity(identity)
-        assertNotNull(model!!)
+        val model = contactModelRepository.getByIdentity(identity)!!
+        val modelMd = contactModelRepositoryMd.getByIdentity(identity)!!
+        assertEquals(model.identity, modelMd.identity)
+        assertContentEquals(model.data.value, modelMd.data.value)
         assertTrue { model.identity == identity }
         assertTrue { model.data.value?.identity == identity }
         assertContentEquals(publicKey, model.data.value?.publicKey)
     }
 
-    @Test
-    fun deleteByIdentityNonExisting() {
-        // If model does not exist, no exception is thrown
-        contactModelRepository.deleteByIdentity("ABCDEFGH")
-        contactModelRepository.deleteByIdentity("ABCDEFGH")
-    }
-
-    @Test
-    fun deleteByIdentityExistingNotCached() {
-        // Create contact using "old model"
-        val identity = randomIdentity()
-        databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, nonSecureRandomArray(32)))
-
-        // Delete through repository
-        contactModelRepository.deleteByIdentity(identity)
-
-        // Ensure that contact is gone
-        val model = contactModelRepository.getByIdentity(identity)
-        assertNull(model)
-    }
-
-    @Test
-    fun deleteByIdentityExistingCached() {
-        // Create contact using "old model"
-        val identity = randomIdentity()
-        databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, nonSecureRandomArray(32)))
-
-        // Fetch model to ensure it's cached
-        val modelBeforeDeletion = contactModelRepository.getByIdentity(identity)
-        assertNotNull(modelBeforeDeletion)
-
-        // Delete through repository
-        contactModelRepository.deleteByIdentity(identity)
-
-        // Ensure that contact is gone
-        val modelAfterDeletion = contactModelRepository.getByIdentity(identity)
-        assertNull(modelAfterDeletion)
-    }
-
-    @Test
-    fun deleteExisting() {
-        // Create contact using "old model"
-        val identity = randomIdentity()
-        databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, nonSecureRandomArray(32)))
-
-        // Fetch model
-        val model = contactModelRepository.getByIdentity(identity)
-        assertNotNull(model!!)
-
-        // Data is present, mutating model is possible
-        assertNotNull(model.data.value)
-        model.setNicknameFromSync("testnick")
-
-        // Delete through repository
-        contactModelRepository.delete(model)
-
-        // Data is gone, mutating model throws exception
-        assertNull(model.data.value)
-        assertFailsWith(ModelDeletedException::class) {
-            model.setNicknameFromSync("testnick")
-        }
-
-        // Ensure that contact is not cached anymore
-        val modelAfterDeletion = contactModelRepository.getByIdentity(identity)
-        assertNull(modelAfterDeletion)
-    }
-
     private fun testCreateFromLocalOrRemote(
-        initialValues: InitialValues,
+        contactModelData: ContactModelData,
         triggerSource: TestTriggerSource,
     ) {
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
+        assertNull(contactModelRepository.getByIdentity(contactModelData.identity))
+        assertNull(contactModelRepositoryMd.getByIdentity(contactModelData.identity))
 
-        val newModel = runBlocking {
+        val (newModel, newModelMd) = runBlocking {
             when (triggerSource) {
-                TestTriggerSource.FROM_LOCAL -> contactModelRepository.createFromLocal(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
-
-                TestTriggerSource.FROM_REMOTE -> contactModelRepository.createFromRemote(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
-
+                TestTriggerSource.FROM_LOCAL -> {
+                    contactModelRepository.createFromLocal(contactModelData) to
+                        contactModelRepositoryMd.createFromLocal(contactModelData)
+                }
+
+                TestTriggerSource.FROM_REMOTE -> {
+                    contactModelRepository.createFromRemote(
+                        contactModelData = contactModelData,
+                        handle = UnusedTaskCodec(),
+                    ) to
+                        contactModelRepositoryMd.createFromRemote(
+                            contactModelData = contactModelData,
+                            handle = taskCodecMd,
+                        )
+                }
             }
         }
 
-        // TODO(ANDR-3003): Test that transaction has been executed
+        // Assert that a transaction has been executed in the MD context
+        assertEquals(1, taskCodecMd.transactionBeginCount)
+        assertEquals(1, taskCodecMd.transactionCommitCount)
 
-        val queriedModel = contactModelRepository.getByIdentity(initialValues.identity)
+        val queriedModel = contactModelRepository.getByIdentity(contactModelData.identity)
         assertEquals(newModel, queriedModel)
 
-        assertDefaultValues(newModel, initialValues)
+        val queriedModelMd = contactModelRepositoryMd.getByIdentity(contactModelData.identity)
+        assertEquals(newModelMd, queriedModelMd)
 
-        contactModelRepository.deleteByIdentity(initialValues.identity)
+        assertContentEquals(contactModelData, newModel.data.value)
+        assertContentEquals(contactModelData, newModelMd.data.value)
 
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
+        // Reset transaction count in case this test is run several times
+        taskCodecMd.transactionBeginCount = 0
+        taskCodecMd.transactionCommitCount = 0
     }
 
+    /**
+     * Insert the given [contactModelData] twice (from local or remote; depending on the given
+     * [triggerSource]): The first time this should create a new contact, the second time it should
+     * throw a [ContactStoreException].
+     */
     private fun testCreateFromLocalOrRemoteTwice(
-        initialValues: InitialValues,
+        contactModelData: ContactModelData,
         triggerSource: TestTriggerSource,
     ) {
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
-
-        val runCreation = when (triggerSource) {
-            TestTriggerSource.FROM_LOCAL -> suspend {
-                contactModelRepository.createFromLocal(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
+        assertNull(contactModelRepository.getByIdentity(contactModelData.identity))
+        assertNull(contactModelRepositoryMd.getByIdentity(contactModelData.identity))
+
+        val (runCreation, runCreationMd) = when (triggerSource) {
+            TestTriggerSource.FROM_LOCAL -> {
+                suspend {
+                    contactModelRepository.createFromLocal(contactModelData)
+                } to
+                    suspend {
+                        contactModelRepositoryMd.createFromLocal(contactModelData)
+                    }
             }
 
-            TestTriggerSource.FROM_REMOTE -> suspend {
-                contactModelRepository.createFromRemote(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
+            TestTriggerSource.FROM_REMOTE -> {
+                suspend {
+                    contactModelRepository.createFromRemote(
+                        contactModelData = contactModelData,
+                        handle = UnusedTaskCodec(),
+                    )
+                } to
+                    suspend {
+                        contactModelRepositoryMd.createFromRemote(
+                            contactModelData = contactModelData,
+                            handle = taskCodecMd,
+                        )
+                    }
             }
 
         }
 
         // Insert it for the first time
-        val newModel = runBlocking {
-            runCreation()
+        val (newModel, newModelMd) = runBlocking {
+            runCreation() to runCreationMd()
         }
 
-        // TODO(ANDR-3003): Test that transaction has been executed
+        // Assert that a transaction has been executed in the MD context
+        assertEquals(1, taskCodecMd.transactionBeginCount)
+        assertEquals(1, taskCodecMd.transactionCommitCount)
 
-        val queriedModel = contactModelRepository.getByIdentity(initialValues.identity)
+        val queriedModel = contactModelRepository.getByIdentity(contactModelData.identity)
         assertEquals(newModel, queriedModel)
 
-        assertDefaultValues(newModel, initialValues)
+        val queriedModelMd = contactModelRepositoryMd.getByIdentity(contactModelData.identity)
+        assertEquals(newModelMd, queriedModelMd)
+
+        assertContentEquals(contactModelData, newModel.data.value)
+        assertContentEquals(contactModelData, newModelMd.data.value)
 
         // Insert for the second time and assert that an exception is thrown
-        assertThrows(ContactCreateException::class.java) { runBlocking { runCreation() } }
+        assertThrows(ContactStoreException::class.java) { runBlocking { runCreation() } }
+        assertThrows(ContactReflectException::class.java) { runBlocking { runCreationMd() } }
 
-        contactModelRepository.deleteByIdentity(initialValues.identity)
+        // Assert that there is still only one transaction and therefore the transaction has not
+        // been executed again (due to precondition failure)
+        assertEquals(1, taskCodecMd.transactionBeginCount)
+        assertEquals(1, taskCodecMd.transactionCommitCount)
 
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
+        // Reset transaction count in case this test is run several times
+        taskCodecMd.transactionBeginCount = 0
+        taskCodecMd.transactionCommitCount = 0
     }
 
-    private data class InitialValues(
-        val identity: String = "ABCDEFGH",
-        val publicKey: ByteArray = ByteArray(NaCl.PUBLICKEYBYTES),
-        val date: Date = Date(),
-        val identityType: IdentityType = IdentityType.NORMAL,
-        val acquaintanceLevel: AcquaintanceLevel = AcquaintanceLevel.DIRECT,
-        val activityState: State = State.ACTIVE,
-        val featureMask: ULong = 4.toULong(),
-    )
-
-    private fun assertDefaultValues(
-        contactModel: ch.threema.data.models.ContactModel,
-        initialValues: InitialValues,
-    ) {
-        assertEquals(initialValues.identity, contactModel.identity)
-        val data = contactModel.data.value!!
-
-        // Assert that the given properties match
-        assertArrayEquals(initialValues.publicKey, data.publicKey)
-        assertEquals(initialValues.date.time, data.createdAt.time)
-        assertEquals(initialValues.identityType, data.identityType)
-        assertEquals(initialValues.acquaintanceLevel, data.acquaintanceLevel)
-        assertEquals(initialValues.activityState, data.activityState)
-        assertEquals(initialValues.featureMask, data.featureMask)
-
-        // Assert that the rest is set to the default values
-        assertEquals("", data.firstName)
-        assertEquals("", data.lastName)
-        assertNull(data.nickname)
-        assertEquals(VerificationLevel.UNVERIFIED, data.verificationLevel)
-        assertEquals(WorkVerificationLevel.NONE, data.workVerificationLevel)
-        assertEquals(ContactSyncState.INITIAL, data.syncState)
-        assertEquals(ReadReceiptPolicy.DEFAULT, data.readReceiptPolicy)
-        assertEquals(TypingIndicatorPolicy.DEFAULT, data.typingIndicatorPolicy)
-        assertNull(data.androidContactLookupKey)
-        assertNull(data.localAvatarExpires)
-        assertFalse(data.isRestored)
-        assertNull(data.profilePictureBlobId)
-        assertEquals(
-            ContactModel(data.identity, data.publicKey).idColorIndex.toUByte(),
-            data.colorIndex
-        )
+    private fun testCreateFromSync(contactModelData: ContactModelData) {
+        // Assert that the contact does not exist yet
+        assertNull(contactModelRepositoryMd.getByIdentity(contactModelData.identity))
+
+        // Create the contact
+        val contactModel = contactModelRepositoryMd.createFromSync(contactModelData)
+
+        // Assert that no transactions were created and no messages were sent
+        assertEquals(0, taskCodecMd.transactionBeginCount)
+        assertEquals(0, taskCodecMd.transactionCommitCount)
+        assertTrue(taskCodecMd.outboundMessages.isEmpty())
+
+        // Assert that the contact data has been inserted correctly
+        val addedData = contactModel.data.value!!
+        assertContentEquals(contactModelData, addedData)
+
+        // Reset transaction count in case this test is run several times
+        taskCodecMd.transactionBeginCount = 0
+        taskCodecMd.transactionCommitCount = 0
+    }
+
+    /**
+     * Insert the given [contactModelData] twice from sync: The first time this should create a new
+     * contact, the second time it should throw a [ContactStoreException].
+     */
+    private fun testCreateFromSyncTwice(contactModelData: ContactModelData) {
+        // Assert that the contact does not exist yet
+        assertNull(contactModelRepositoryMd.getByIdentity(contactModelData.identity))
+
+        // Create the contact
+        val contactModel = contactModelRepositoryMd.createFromSync(contactModelData)
+
+        // Assert that no transactions were created and no messages were sent
+        assertEquals(0, taskCodecMd.transactionBeginCount)
+        assertEquals(0, taskCodecMd.transactionCommitCount)
+        assertTrue(taskCodecMd.outboundMessages.isEmpty())
+
+        // Assert that the contact data has been inserted correctly
+        val addedData = contactModel.data.value!!
+        assertContentEquals(contactModelData, addedData)
+
+        // Assert that the contact data cannot be inserted again (as it already exists)
+        assertThrows(ContactStoreException::class.java) {
+            contactModelRepositoryMd.createFromSync(contactModelData)
+        }
+
+        // Reset transaction count in case this test is run several times
+        taskCodecMd.transactionBeginCount = 0
+        taskCodecMd.transactionCommitCount = 0
+    }
+
+    private fun assertContentEquals(expected: ContactModelData?, actual: ContactModelData?) {
+        if (expected == null && actual == null) {
+            return
+        }
+
+        if (expected == null) {
+            fail("Actual data expected to be null")
+        }
+
+        if (actual == null) {
+            fail("Actual data expected to be non null")
+        }
+
+        assertEquals(expected.identity, actual.identity)
+        assertContentEquals(expected.publicKey, actual.publicKey)
+        assertEquals(expected.createdAt, actual.createdAt)
+        assertEquals(expected.firstName, actual.firstName)
+        assertEquals(expected.lastName, actual.lastName)
+        assertEquals(expected.nickname, actual.nickname)
+        assertEquals(expected.colorIndex, actual.colorIndex)
+        assertEquals(expected.verificationLevel, actual.verificationLevel)
+        assertEquals(expected.workVerificationLevel, actual.workVerificationLevel)
+        assertEquals(expected.identityType, actual.identityType)
+        assertEquals(expected.acquaintanceLevel, actual.acquaintanceLevel)
+        assertEquals(expected.activityState, actual.activityState)
+        assertEquals(expected.syncState, actual.syncState)
+        assertEquals(expected.featureMask, actual.featureMask)
+        assertEquals(expected.readReceiptPolicy, actual.readReceiptPolicy)
+        assertEquals(expected.typingIndicatorPolicy, actual.typingIndicatorPolicy)
+        // TODO(ANDR-2998): Assert that notification trigger and sound policy override are set
+        //  correctly
+        assertEquals(expected.androidContactLookupKey, actual.androidContactLookupKey)
+
+        // Just in case there are new fields added that are not explicitly compared here
+        assertEquals(expected, actual)
     }
 }
diff --git a/app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt b/app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt
index 0249f491..6d275855 100644
--- a/app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt
+++ b/app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt
@@ -21,9 +21,13 @@
 
 package ch.threema.data.repositories
 
+import ch.threema.app.TestCoreServiceManager
+import ch.threema.app.TestTaskManager
+import ch.threema.app.ThreemaApplication
 import ch.threema.data.TestDatabaseService
 import ch.threema.data.storage.EditHistoryDao
 import ch.threema.data.storage.EditHistoryDaoImpl
+import ch.threema.domain.helpers.UnusedTaskCodec
 import ch.threema.storage.models.AbstractMessageModel
 import ch.threema.storage.models.GroupMessageModel
 import ch.threema.storage.models.MessageModel
@@ -41,7 +45,13 @@ class EditHistoryRepositoryTest {
     @Before
     fun before() {
         databaseService = TestDatabaseService()
-        editHistoryRepository = ModelRepositories(databaseService).editHistory
+        val testCoreServiceManager = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseService,
+            preferenceStore = ThreemaApplication.requireServiceManager().preferenceStore,
+            taskManager = TestTaskManager(UnusedTaskCodec())
+        )
+        editHistoryRepository = ModelRepositories(testCoreServiceManager).editHistory
         editHistoryDao = EditHistoryDaoImpl(databaseService)
     }
 
diff --git a/app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt b/app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt
index 773a7acc..26a450fa 100644
--- a/app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt
+++ b/app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt
@@ -22,11 +22,15 @@
 package ch.threema.data.repositories
 
 import ch.threema.data.TestDatabaseService
+import ch.threema.app.TestCoreServiceManager
+import ch.threema.app.TestTaskManager
+import ch.threema.app.ThreemaApplication
 import ch.threema.data.models.GroupIdentity
 import ch.threema.data.models.GroupModelDataFactory
 import ch.threema.data.storage.DatabaseBackend
 import ch.threema.data.storage.DbGroup
 import ch.threema.data.storage.SqliteDatabaseBackend
+import ch.threema.domain.helpers.UnusedTaskCodec
 import ch.threema.domain.models.GroupId
 import ch.threema.storage.models.GroupModel
 import org.junit.Assert
@@ -40,6 +44,7 @@ import kotlin.test.assertTrue
 class GroupModelRepositoryTest {
     private lateinit var databaseService: TestDatabaseService
     private lateinit var databaseBackend: DatabaseBackend
+    private lateinit var coreServiceManager: TestCoreServiceManager
     private lateinit var groupModelRepository: GroupModelRepository
 
     private fun createTestDbGroup(groupIdentity: GroupIdentity): DbGroup {
@@ -56,6 +61,7 @@ class GroupModelRepositoryTest {
             "Description",
             Date(),
             setOf("AAAAAAAA", "BBBBBBBB"),
+            GroupModel.UserState.MEMBER,
         )
     }
 
@@ -63,7 +69,13 @@ class GroupModelRepositoryTest {
     fun before() {
         this.databaseService = TestDatabaseService()
         this.databaseBackend = SqliteDatabaseBackend(databaseService)
-        this.groupModelRepository = ModelRepositories(databaseService).groups
+        this.coreServiceManager = TestCoreServiceManager(
+            version = ThreemaApplication.getAppVersion(),
+            databaseService = databaseService,
+            preferenceStore = ThreemaApplication.requireServiceManager().preferenceStore,
+            taskManager = TestTaskManager(UnusedTaskCodec())
+        )
+        this.groupModelRepository = ModelRepositories(coreServiceManager).groups
     }
 
     @Test
diff --git a/app/src/androidTest/java/ch/threema/storage/DatabaseNonceStoreTest.kt b/app/src/androidTest/java/ch/threema/storage/DatabaseNonceStoreTest.kt
new file mode 100644
index 00000000..f0be3a0f
--- /dev/null
+++ b/app/src/androidTest/java/ch/threema/storage/DatabaseNonceStoreTest.kt
@@ -0,0 +1,254 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.storage
+
+import androidx.test.core.app.ApplicationProvider
+import ch.threema.app.ThreemaApplication
+import ch.threema.base.crypto.HashedNonce
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.crypto.NonceStore
+import ch.threema.domain.stores.IdentityStoreInterface
+import org.junit.After
+import org.junit.Assert.*
+import org.junit.Before
+import org.junit.Test
+import javax.crypto.Mac
+import javax.crypto.spec.SecretKeySpec
+
+class DatabaseNonceStoreTest {
+    private lateinit var tempDbFileName: String
+
+    private var _store: DatabaseNonceStore? = null
+    private val store: NonceStore
+        get() = _store!!
+
+    @Before
+    fun setup() {
+
+        tempDbFileName = "threema-nonce-test-${System.currentTimeMillis()}.db"
+        val identityStore = TestIdentityStore()
+        _store = DatabaseNonceStore(
+            ApplicationProvider.getApplicationContext(),
+            identityStore,
+            tempDbFileName
+        )
+    }
+
+    @After
+    fun teardown() {
+        _store!!.close()
+        _store = null
+        ApplicationProvider
+            .getApplicationContext<ThreemaApplication>()
+            .deleteDatabase(tempDbFileName)
+    }
+
+    @Test
+    fun testSameNonceWithDifferentScope() {
+        assertStoreEmpty()
+
+        val nonces = createNonces()
+
+        // Assert the nonces do not exist in the store
+        nonces.forEach {
+            // Assert that nonce does not exist in store
+            assertFalse(store.exists(NonceScope.CSP, it))
+            assertFalse(store.exists(NonceScope.D2D, it))
+        }
+
+        // Assert that storing the nonces succeeds
+        nonces.forEach {
+            assertTrue(store.store(NonceScope.CSP, it))
+            assertTrue(store.store(NonceScope.D2D, it))
+        }
+
+        // Assert the nonces exist after the insert
+        nonces.forEach {
+            assertTrue(store.exists(NonceScope.CSP, it))
+            assertTrue(store.exists(NonceScope.D2D, it))
+        }
+    }
+
+    @Test
+    fun testExistsWithExistingNonce() {
+        assertStoreEmpty()
+
+        val nonces = createNonces()
+
+        // Assert that storing the nonces succeeds
+        nonces.forEach {
+            // Assert that storing a nonce succeeds
+            assertTrue(store.store(NonceScope.CSP, it))
+            assertTrue(store.store(NonceScope.D2D, it))
+        }
+
+
+        // Assert the nonces exist after the insert
+        nonces.forEach {
+            assertTrue(store.exists(NonceScope.CSP, it))
+            assertTrue(store.exists(NonceScope.D2D, it))
+        }
+    }
+
+    @Test
+    fun testStoreWithExistingNonce() {
+        assertStoreEmpty()
+
+        val nonces = createNonces()
+
+        // Assert the nonces do not exist in the store
+        nonces.forEach {
+            // Assert that nonce does not exist in store
+            assertFalse(store.exists(NonceScope.CSP, it))
+            assertFalse(store.exists(NonceScope.D2D, it))
+        }
+
+        // Assert that storing the nonces succeeds
+        nonces.forEach {
+            assertTrue(store.store(NonceScope.CSP, it))
+            assertTrue(store.store(NonceScope.D2D, it))
+        }
+
+        // Assert that storing the nonces again fails
+        nonces.forEach {
+            assertFalse(store.store(NonceScope.CSP, it))
+            assertFalse(store.store(NonceScope.D2D, it))
+        }
+    }
+
+    @Test
+    fun testBulkExport() {
+        assertStoreEmpty()
+
+        val nonces = createNonces()
+        val expectedHashedNonces = nonces.map { hashNonce(it) }
+
+        // Assert that storing the nonces succeeds
+        nonces.forEach {
+            assertTrue(store.store(NonceScope.CSP, it))
+            assertTrue(store.store(NonceScope.D2D, it))
+        }
+
+        assertSameHashedNonces(expectedHashedNonces, store.getAllHashedNonces(NonceScope.CSP))
+        assertSameHashedNonces(expectedHashedNonces, store.getAllHashedNonces(NonceScope.D2D))
+    }
+
+    @Test
+    fun testBulkImportNotHashed() {
+        assertStoreEmpty()
+
+        val nonces = createNonces()
+        val pseudoHashedNonces = nonces.map { HashedNonce(it.bytes) }
+
+        // Insert the unhashed nonces. As they are inserted as if they were already hashed,
+        // the store must not hash them again.
+        assertTrue(store.insertHashedNonces(NonceScope.CSP, pseudoHashedNonces))
+        assertTrue(store.insertHashedNonces(NonceScope.D2D, pseudoHashedNonces))
+
+        nonces.forEach {
+            // Assert that the nonce as inserted should exist
+            assertTrue(store.exists(NonceScope.CSP, it))
+            assertTrue(store.exists(NonceScope.D2D, it))
+        }
+    }
+
+    @Test
+    fun testBulkImportHashed() {
+        assertStoreEmpty()
+
+        val nonces = createNonces()
+        val hashedNonces = nonces.map { hashNonce(it) }
+
+        // Insert the hashed nonces. As they are inserted as if they were already hashed,
+        // the store must not hash them again.
+        assertTrue(store.insertHashedNonces(NonceScope.CSP, hashedNonces))
+        assertTrue(store.insertHashedNonces(NonceScope.D2D, hashedNonces))
+
+        // Assert that all unhashed nonces exist in the store
+        nonces.forEach {
+            // Assert that the nonce as inserted should exist
+            assertTrue(store.exists(NonceScope.CSP, it))
+            assertTrue(store.exists(NonceScope.D2D, it))
+        }
+    }
+
+    private fun assertSameHashedNonces(expected: Collection<HashedNonce>, actual: Collection<HashedNonce>) {
+        assertEquals(expected.size, actual.size)
+        expected.forEach { expectedNonce ->
+            // If `actual.contains(expectedNonce)` is used only referential equality is checked
+            // which will fail.
+            assertTrue(actual.find { it.bytes.contentEquals(expectedNonce.bytes) } != null)
+        }
+    }
+
+    private fun assertStoreEmpty() {
+        assertEquals(0, store.getCount(NonceScope.CSP))
+        assertEquals(0, store.getCount(NonceScope.D2D))
+    }
+
+    /**
+     * Create 256 sequential nonces, where the LSB acts as a counter.
+     */
+    private fun createNonces(): List<Nonce> {
+        return (0..255)
+            .map { ByteArray(23) + byteArrayOf(it.toByte()) }
+            .map { Nonce(it) }
+    }
+}
+
+fun hashNonce(nonce: Nonce): HashedNonce {
+    val mac = Mac.getInstance("HmacSHA256")
+    mac.init(SecretKeySpec(USER_IDENTITY.encodeToByteArray(), "HmacSHA256"))
+    return HashedNonce(mac.doFinal(nonce.bytes))
+}
+
+const val USER_IDENTITY = "01234567"
+
+private class TestIdentityStore : IdentityStoreInterface {
+    override fun getIdentity(): String = USER_IDENTITY
+
+    override fun encryptData(plaintext: ByteArray, nonce: ByteArray, receiverPublicKey: ByteArray): ByteArray
+        = throw UnsupportedOperationException()
+
+    override fun decryptData(ciphertext: ByteArray, nonce: ByteArray, senderPublicKey: ByteArray): ByteArray
+        = throw UnsupportedOperationException()
+
+    override fun calcSharedSecret(publicKey: ByteArray): ByteArray
+        = throw UnsupportedOperationException()
+
+    override fun getServerGroup(): String
+        = throw UnsupportedOperationException()
+
+    override fun getPublicKey(): ByteArray
+        = throw UnsupportedOperationException()
+
+    override fun getPrivateKey(): ByteArray
+        = throw UnsupportedOperationException()
+
+    override fun getPublicNickname(): String
+        = throw UnsupportedOperationException()
+
+    override fun storeIdentity(identity: String, serverGroup: String, publicKey: ByteArray, privateKey: ByteArray)
+        = throw UnsupportedOperationException()
+
+}
diff --git a/app/src/main/java/ch/threema/app/ThreemaApplication.java b/app/src/main/java/ch/threema/app/ThreemaApplication.java
index fc5f77b6..063bbad9 100644
--- a/app/src/main/java/ch/threema/app/ThreemaApplication.java
+++ b/app/src/main/java/ch/threema/app/ThreemaApplication.java
@@ -21,10 +21,6 @@
 
 package ch.threema.app;
 
-import static android.app.NotificationManager.ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED;
-import static android.app.NotificationManager.EXTRA_BLOCKED_STATE;
-import static android.app.NotificationManager.EXTRA_NOTIFICATION_CHANNEL_GROUP_ID;
-
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
@@ -49,25 +45,6 @@ import android.provider.ContactsContract;
 import android.text.format.DateUtils;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.WorkerThread;
-import androidx.appcompat.app.AppCompatDelegate;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.ContextCompat;
-import androidx.lifecycle.DefaultLifecycleObserver;
-import androidx.lifecycle.LifecycleOwner;
-import androidx.lifecycle.ProcessLifecycleOwner;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import androidx.preference.PreferenceManager;
-import androidx.work.Constraints;
-import androidx.work.ExistingPeriodicWorkPolicy;
-import androidx.work.ExistingWorkPolicy;
-import androidx.work.NetworkType;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.PeriodicWorkRequest;
-import androidx.work.WorkManager;
-
 import com.datatheorem.android.trustkit.TrustKit;
 import com.datatheorem.android.trustkit.reporting.BackgroundReporter;
 import com.google.android.material.color.DynamicColors;
@@ -92,21 +69,34 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
+import androidx.appcompat.app.AppCompatDelegate;
+import androidx.core.app.NotificationManagerCompat;
+import androidx.core.content.ContextCompat;
+import androidx.lifecycle.DefaultLifecycleObserver;
+import androidx.lifecycle.LifecycleOwner;
+import androidx.lifecycle.ProcessLifecycleOwner;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import androidx.preference.PreferenceManager;
+import androidx.work.Constraints;
+import androidx.work.ExistingPeriodicWorkPolicy;
+import androidx.work.NetworkType;
+import androidx.work.PeriodicWorkRequest;
+import androidx.work.WorkManager;
 import ch.threema.app.backuprestore.csv.BackupService;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.grouplinks.IncomingGroupJoinRequestListener;
 import ch.threema.app.listeners.BallotVoteListener;
 import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.listeners.ContactSettingsListener;
-import ch.threema.app.listeners.ContactTypingListener;
 import ch.threema.app.listeners.ConversationListener;
 import ch.threema.app.listeners.DistributionListListener;
 import ch.threema.app.listeners.GroupListener;
 import ch.threema.app.listeners.MessageListener;
-import ch.threema.app.listeners.NewSyncedContactsListener;
 import ch.threema.app.listeners.ServerMessageListener;
 import ch.threema.app.listeners.SynchronizeContactsListener;
-import ch.threema.app.managers.CoreServiceManager;
 import ch.threema.app.managers.CoreServiceManagerImpl;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
@@ -123,10 +113,8 @@ import ch.threema.app.services.AvatarCacheService;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.ConversationService;
 import ch.threema.app.services.DeadlineListService;
-import ch.threema.app.services.FileService;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.MessageService;
-import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SynchronizeContactsService;
 import ch.threema.app.services.ThreemaPushService;
@@ -134,16 +122,18 @@ import ch.threema.app.services.UpdateSystemService;
 import ch.threema.app.services.UpdateSystemServiceImpl;
 import ch.threema.app.services.UserService;
 import ch.threema.app.services.ballot.BallotService;
+import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.stores.IdentityStore;
 import ch.threema.app.stores.PreferenceStore;
 import ch.threema.app.tasks.MessageQueueMigrationTask;
+import ch.threema.app.utils.ApplicationExitInfoUtil;
+import ch.threema.app.utils.BallotUtil;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ConnectionIndicatorUtil;
 import ch.threema.app.utils.ConversationNotificationUtil;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.LinuxSecureRandom;
 import ch.threema.app.utils.LoggingUEH;
-import ch.threema.app.utils.ApplicationExitInfoUtil;
 import ch.threema.app.utils.PushUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShortcutUtil;
@@ -155,7 +145,6 @@ import ch.threema.app.voip.Config;
 import ch.threema.app.voip.listeners.VoipCallEventListener;
 import ch.threema.app.voip.managers.VoipListenerManager;
 import ch.threema.app.webclient.listeners.WebClientServiceListener;
-import ch.threema.app.webclient.listeners.WebClientWakeUpListener;
 import ch.threema.app.webclient.manager.WebClientListenerManager;
 import ch.threema.app.webclient.services.SessionAndroidService;
 import ch.threema.app.webclient.services.SessionWakeUpServiceImpl;
@@ -166,15 +155,19 @@ import ch.threema.app.workers.ContactUpdateWorker;
 import ch.threema.app.workers.ShareTargetUpdateWorker;
 import ch.threema.app.workers.WorkSyncWorker;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.data.repositories.ModelRepositories;
 import ch.threema.domain.models.AppVersion;
-import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.protocol.connection.ConnectionState;
+import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.stores.DHSessionStoreInterface;
+import ch.threema.libthreema.LibthreemaKt;
+import ch.threema.libthreema.LogLevel;
 import ch.threema.localcrypto.MasterKey;
 import ch.threema.localcrypto.MasterKeyLockedException;
+import ch.threema.logging.LibthreemaLogger;
 import ch.threema.logging.backend.DebugLogFileBackend;
 import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
@@ -195,170 +188,174 @@ import ch.threema.storage.models.data.status.GroupStatusDataModel;
 import ch.threema.storage.models.data.status.VoipStatusDataModel;
 import ch.threema.storage.models.group.IncomingGroupJoinRequestModel;
 
-public class ThreemaApplication extends Application implements DefaultLifecycleObserver {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("ThreemaApplication");
-
-	public static final String INTENT_DATA_CONTACT = "identity";
-	public static final String INTENT_DATA_CONTACT_READONLY = "readonly";
-	public static final String INTENT_DATA_TEXT = "text";
-	public static final String INTENT_DATA_ID_BACKUP = "idbackup";
-	public static final String INTENT_DATA_ID_BACKUP_PW = "idbackuppw";
-	public static final String INTENT_DATA_PASSPHRASE_CHECK = "check";
-	public static final String INTENT_DATA_IS_FORWARD = "is_forward";
-	public static final String INTENT_DATA_TIMESTAMP = "timestamp";
-	public static final String INTENT_DATA_EDITFOCUS = "editfocus";
-	public static final String INTENT_DATA_GROUP = "group";
-	public static final String INTENT_DATA_GROUP_API = "group_api";
-	public static final String INTENT_DATA_GROUP_LINK = "group_link";
-	public static final String INTENT_DATA_DISTRIBUTION_LIST = "distribution_list";
-	public static final String INTENT_DATA_ARCHIVE_FILTER = "archiveFilter";
-	public static final String INTENT_DATA_QRCODE = "qrcodestring";
-	public static final String INTENT_DATA_QRCODE_TYPE_OK = "qrcodetypeok";
-	public static final String INTENT_DATA_MESSAGE_ID = "messageid";
-	public static final String INTENT_DATA_INCOMING_GROUP_REQUEST = "groupRequest";
-	public static final String INTENT_DATA_GROUP_REQUEST_NOTIFICATION_ID = "groupRequestNotificationId";
-	public static final String EXTRA_VOICE_REPLY = "voicereply";
-	public static final String EXTRA_OUTPUT_FILE = "output";
-	public static final String EXTRA_ORIENTATION = "rotate";
-	public static final String EXTRA_FLIP = "flip";
-	public static final String INTENT_DATA_CHECK_ONLY = "check";
-	public static final String INTENT_DATA_ANIM_CENTER = "itemPos";
-	public static final String INTENT_DATA_PICK_FROM_CAMERA = "useCam";
-	public static final String INTENT_PUSH_REGISTRATION_COMPLETE = "registrationComplete";
-	public static final String INTENT_DATA_PIN = "ppin";
-	public static final String INTENT_DATA_HIDE_RECENTS = "hiderec";
-	public static final String INTENT_ACTION_FORWARD = "ch.threema.app.intent.FORWARD";
-	public static final String INTENT_ACTION_SHORTCUT_ADDED = BuildConfig.APPLICATION_ID + ".intent.SHORTCUT_ADDED";
-
-	public static final String CONFIRM_TAG_CLOSE_BALLOT = "cb";
-
-	// Notification IDs
-	public static final int PASSPHRASE_SERVICE_NOTIFICATION_ID = 587;
-	public static final int NEW_MESSAGE_NOTIFICATION_ID = 723;
-	public static final int MASTER_KEY_LOCKED_NOTIFICATION_ID = 724;
-	public static final int NEW_MESSAGE_LOCKED_NOTIFICATION_ID = 725;
-	public static final int NEW_MESSAGE_PIN_LOCKED_NOTIFICATION_ID = 726;
-	public static final int SAFE_FAILED_NOTIFICATION_ID = 727;
-	public static final int SERVER_MESSAGE_NOTIFICATION_ID = 730;
-	public static final int UNSENT_MESSAGE_NOTIFICATION_ID = 732;
-	public static final int WORK_SYNC_NOTIFICATION_ID = 735;
-	public static final int NEW_SYNCED_CONTACTS_NOTIFICATION_ID = 736;
-	public static final int WEB_RESUME_FAILED_NOTIFICATION_ID = 737;
-	public static final int VOICE_MSG_PLAYER_NOTIFICATION_ID = 749;
-	public static final int INCOMING_CALL_NOTIFICATION_ID = 800;
-	public static final int INCOMING_GROUP_CALL_NOTIFICATION_ID = 803;
-
-	private static final String THREEMA_APPLICATION_LISTENER_TAG = "al";
-	public static final String AES_KEY_FILE = "key.dat";
-	public static final String ECHO_USER_IDENTITY = "ECHOECHO";
-	public static final String PHONE_LINKED_PLACEHOLDER = "***";
-	public static final String EMAIL_LINKED_PLACEHOLDER = "***@***";
-
-	public static final String ACTIVITY_CONNECTION_TAG = "threemaApplication";
-	private static final long ACTIVITY_CONNECTION_LIFETIME = 60000;
-
-	public static final int MAX_BLOB_SIZE_MB = 100;
-	public static final int MAX_BLOB_SIZE = MAX_BLOB_SIZE_MB * 1024 * 1024;
-	public static final int MIN_PIN_LENGTH = 4;
-	public static final int MAX_PIN_LENGTH = 8;
-	public static final int MIN_GROUP_MEMBERS_COUNT = 1;
-	public static final int MIN_PW_LENGTH_BACKUP = 8;
-	public static final int MAX_PW_LENGTH_BACKUP = 256;
-	public static final int MIN_PW_LENGTH_ID_EXPORT_LEGACY = 4; // extremely ancient versions of the app on some platform accepted four-letter passwords when generating ID exports
-
-	@Deprecated // Use WORKER_CONTACT_UPDATE_PERIODIC_NAME instead.
-	private static final String WORKER_IDENTITY_STATES_PERIODIC_NAME = "IdentityStates";
-	private static final String WORKER_CONTACT_UPDATE_PERIODIC_NAME = "PeriodicContactUpdate";
-	public static final String WORKER_SHARE_TARGET_UPDATE = "ShareTargetUpdate";
-	public static final String WORKER_WORK_SYNC = "WorkSync";
-	public static final String WORKER_PERIODIC_WORK_SYNC = "PeriodicWorkSync";
-	public static final String WORKER_THREEMA_SAFE_UPLOAD = "SafeUpload";
-	public static final String WORKER_PERIODIC_THREEMA_SAFE_UPLOAD = "PeriodicSafeUpload";
-	public static final String WORKER_CONNECTIVITY_CHANGE = "ConnectivityChange";
-	public static final String WORKER_AUTO_DELETE = "AutoDelete";
-	public static final String WORKER_AUTOSTART = "Autostart";
-
-	public static final Lock onAndroidContactChangeLock = new ReentrantLock();
-
-	private static final String EXIT_REASON_LOGGING_TIMESTAMP = "exit_reason_timestamp";
-
-	private static Context context;
-
-	private static volatile ServiceManager serviceManager;
-	private static volatile AppVersion appVersion;
-	private static volatile MasterKey masterKey;
-
-	private static Date lastLoggedIn;
-	private static boolean isDeviceIdle;
-	public static boolean isResumed = false;
-
-	private static HashMap<String, String> messageDrafts = new HashMap<>();
-	private static HashMap<String, String> quoteDrafts = new HashMap<>();
-
-	public static final ExecutorService sendMessageExecutorService = Executors.newFixedThreadPool(4);
-	public static final ExecutorService sendMessageSingleThreadExecutorService = Executors.newSingleThreadExecutor();
-	public static final ExecutorService voiceMessageThumbnailExecutorService = Executors.newFixedThreadPool(4);
-
-	private static boolean checkAppReplacingState(Context context) {
-		// workaround https://code.google.com/p/android/issues/detail?id=56296
-		if (context.getResources() == null) {
-			logger.debug("App is currently installing. Killing it.");
-			android.os.Process.killProcess(android.os.Process.myPid());
-
-			return false;
-		}
-
-		return true;
-	}
-
-	private void logStackTrace(StackTraceElement[] stackTraceElements) {
-		for (int i = 1; i < stackTraceElements.length; i++) {
-			logger.info("\tat " + stackTraceElements[i]);
-		}
-	}
-
-	private static void showNotesGroupNotice(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
-		if (oldState != newState) {
-			try {
-				GroupService groupService = serviceManager.getGroupService();
-				MessageService messageService = serviceManager.getMessageService();
-				GroupStatusDataModel.GroupStatusType type = null;
-
-				if (newState == GroupService.NOTES) {
-					type = GroupStatusDataModel.GroupStatusType.IS_NOTES_GROUP;
-				} else if (newState == GroupService.PEOPLE && oldState != GroupService.UNDEFINED) {
-					type = GroupStatusDataModel.GroupStatusType.IS_PEOPLE_GROUP;
-				}
-
-				if (type != null) {
-					messageService.createGroupStatus(
-						groupService.createReceiver(groupModel),
-						type,
-						null,
-						null,
-						null
-					);
-				}
-			} catch (ThreemaException e) {
-				logger.error("Exception", e);
-			}
-		}
-	}
+import static android.app.NotificationManager.ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED;
+import static android.app.NotificationManager.EXTRA_BLOCKED_STATE;
+import static android.app.NotificationManager.EXTRA_NOTIFICATION_CHANNEL_GROUP_ID;
 
-	@Override
-	public void onCreate() {
-		long startupTime = System.currentTimeMillis();
+public class ThreemaApplication extends Application implements DefaultLifecycleObserver {
+    private static final Logger logger = LoggingUtil.getThreemaLogger("ThreemaApplication");
+
+    public static final String INTENT_DATA_CONTACT = "identity";
+    public static final String INTENT_DATA_CONTACT_READONLY = "readonly";
+    public static final String INTENT_DATA_TEXT = "text";
+    public static final String INTENT_DATA_ID_BACKUP = "idbackup";
+    public static final String INTENT_DATA_ID_BACKUP_PW = "idbackuppw";
+    public static final String INTENT_DATA_PASSPHRASE_CHECK = "check";
+    public static final String INTENT_DATA_IS_FORWARD = "is_forward";
+    public static final String INTENT_DATA_TIMESTAMP = "timestamp";
+    public static final String INTENT_DATA_EDITFOCUS = "editfocus";
+    public static final String INTENT_DATA_GROUP = "group";
+    public static final String INTENT_DATA_GROUP_API = "group_api";
+    public static final String INTENT_DATA_GROUP_LINK = "group_link";
+    public static final String INTENT_DATA_DISTRIBUTION_LIST = "distribution_list";
+    public static final String INTENT_DATA_ARCHIVE_FILTER = "archiveFilter";
+    public static final String INTENT_DATA_QRCODE = "qrcodestring";
+    public static final String INTENT_DATA_QRCODE_TYPE_OK = "qrcodetypeok";
+    public static final String INTENT_DATA_MESSAGE_ID = "messageid";
+    public static final String INTENT_DATA_INCOMING_GROUP_REQUEST = "groupRequest";
+    public static final String INTENT_DATA_GROUP_REQUEST_NOTIFICATION_ID = "groupRequestNotificationId";
+    public static final String EXTRA_VOICE_REPLY = "voicereply";
+    public static final String EXTRA_OUTPUT_FILE = "output";
+    public static final String EXTRA_ORIENTATION = "rotate";
+    public static final String EXTRA_FLIP = "flip";
+    public static final String INTENT_DATA_CHECK_ONLY = "check";
+    public static final String INTENT_DATA_ANIM_CENTER = "itemPos";
+    public static final String INTENT_DATA_PICK_FROM_CAMERA = "useCam";
+    public static final String INTENT_PUSH_REGISTRATION_COMPLETE = "registrationComplete";
+    public static final String INTENT_DATA_PIN = "ppin";
+    public static final String INTENT_DATA_HIDE_RECENTS = "hiderec";
+    public static final String INTENT_ACTION_FORWARD = "ch.threema.app.intent.FORWARD";
+    public static final String INTENT_ACTION_SHORTCUT_ADDED = BuildConfig.APPLICATION_ID + ".intent.SHORTCUT_ADDED";
+
+    public static final String CONFIRM_TAG_CLOSE_BALLOT = "cb";
+
+    // Notification IDs
+    public static final int PASSPHRASE_SERVICE_NOTIFICATION_ID = 587;
+    public static final int NEW_MESSAGE_NOTIFICATION_ID = 723;
+    public static final int MASTER_KEY_LOCKED_NOTIFICATION_ID = 724;
+    public static final int NEW_MESSAGE_LOCKED_NOTIFICATION_ID = 725;
+    public static final int NEW_MESSAGE_PIN_LOCKED_NOTIFICATION_ID = 726;
+    public static final int SAFE_FAILED_NOTIFICATION_ID = 727;
+    public static final int SERVER_MESSAGE_NOTIFICATION_ID = 730;
+    public static final int UNSENT_MESSAGE_NOTIFICATION_ID = 732;
+    public static final int WORK_SYNC_NOTIFICATION_ID = 735;
+    public static final int NEW_SYNCED_CONTACTS_NOTIFICATION_ID = 736;
+    public static final int WEB_RESUME_FAILED_NOTIFICATION_ID = 737;
+    public static final int VOICE_MSG_PLAYER_NOTIFICATION_ID = 749;
+    public static final int INCOMING_CALL_NOTIFICATION_ID = 800;
+    public static final int INCOMING_GROUP_CALL_NOTIFICATION_ID = 803;
+
+    private static final String THREEMA_APPLICATION_LISTENER_TAG = "al";
+    public static final String AES_KEY_FILE = "key.dat";
+    public static final String ECHO_USER_IDENTITY = "ECHOECHO";
+    public static final String PHONE_LINKED_PLACEHOLDER = "***";
+    public static final String EMAIL_LINKED_PLACEHOLDER = "***@***";
+
+    public static final String ACTIVITY_CONNECTION_TAG = "threemaApplication";
+    private static final long ACTIVITY_CONNECTION_LIFETIME = 60000;
+
+    public static final int MAX_BLOB_SIZE_MB = 100;
+    public static final int MAX_BLOB_SIZE = MAX_BLOB_SIZE_MB * 1024 * 1024;
+    public static final int MIN_PIN_LENGTH = 4;
+    public static final int MAX_PIN_LENGTH = 8;
+    public static final int MIN_GROUP_MEMBERS_COUNT = 1;
+    public static final int MIN_PW_LENGTH_BACKUP = 8;
+    public static final int MAX_PW_LENGTH_BACKUP = 256;
+    public static final int MIN_PW_LENGTH_ID_EXPORT_LEGACY = 4; // extremely ancient versions of the app on some platform accepted four-letter passwords when generating ID exports
+
+    @Deprecated // Use WORKER_CONTACT_UPDATE_PERIODIC_NAME instead.
+    public static final String WORKER_IDENTITY_STATES_PERIODIC_NAME = "IdentityStates";
+    public static final String WORKER_CONTACT_UPDATE_PERIODIC_NAME = "PeriodicContactUpdate";
+    public static final String WORKER_SHARE_TARGET_UPDATE = "ShareTargetUpdate";
+    public static final String WORKER_WORK_SYNC = "WorkSync";
+    public static final String WORKER_PERIODIC_WORK_SYNC = "PeriodicWorkSync";
+    public static final String WORKER_THREEMA_SAFE_UPLOAD = "SafeUpload";
+    public static final String WORKER_PERIODIC_THREEMA_SAFE_UPLOAD = "PeriodicSafeUpload";
+    public static final String WORKER_CONNECTIVITY_CHANGE = "ConnectivityChange";
+    public static final String WORKER_AUTO_DELETE = "AutoDelete";
+    public static final String WORKER_AUTOSTART = "Autostart";
+
+    public static final Lock onAndroidContactChangeLock = new ReentrantLock();
+
+    private static final String EXIT_REASON_LOGGING_TIMESTAMP = "exit_reason_timestamp";
+
+    private static Context context;
+
+    private static volatile ServiceManager serviceManager;
+    private static volatile AppVersion appVersion;
+    private static volatile MasterKey masterKey;
+
+    private static Date lastLoggedIn;
+    private static boolean isDeviceIdle;
+    public static boolean isResumed = false;
+
+    private static HashMap<String, String> messageDrafts = new HashMap<>();
+    private static HashMap<String, String> quoteDrafts = new HashMap<>();
+
+    public static final ExecutorService sendMessageExecutorService = Executors.newFixedThreadPool(4);
+    public static final ExecutorService sendMessageSingleThreadExecutorService = Executors.newSingleThreadExecutor();
+    public static final ExecutorService voiceMessageThumbnailExecutorService = Executors.newFixedThreadPool(4);
+
+    private static boolean checkAppReplacingState(Context context) {
+        // workaround https://code.google.com/p/android/issues/detail?id=56296
+        if (context.getResources() == null) {
+            logger.debug("App is currently installing. Killing it.");
+            android.os.Process.killProcess(android.os.Process.myPid());
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void logStackTrace(StackTraceElement[] stackTraceElements) {
+        for (int i = 1; i < stackTraceElements.length; i++) {
+            logger.info("\tat " + stackTraceElements[i]);
+        }
+    }
+
+    private static void showNotesGroupNotice(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
+        if (oldState != newState) {
+            try {
+                GroupService groupService = serviceManager.getGroupService();
+                MessageService messageService = serviceManager.getMessageService();
+                GroupStatusDataModel.GroupStatusType type = null;
+
+                if (newState == GroupService.NOTES) {
+                    type = GroupStatusDataModel.GroupStatusType.IS_NOTES_GROUP;
+                } else if (newState == GroupService.PEOPLE && oldState != GroupService.UNDEFINED) {
+                    type = GroupStatusDataModel.GroupStatusType.IS_PEOPLE_GROUP;
+                }
 
-		if (BuildConfig.DEBUG && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
-			StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
-				.detectLeakedSqlLiteObjects()
-				.detectLeakedClosableObjects()
-				.penaltyLog()
-				.penaltyListener(Executors.newSingleThreadExecutor(), v -> {
-					logger.info("STRICTMODE VMPolicy: " + v.getCause());
-					logStackTrace(v.getStackTrace());
-				})
-				.build());
+                if (type != null) {
+                    messageService.createGroupStatus(
+                        groupService.createReceiver(groupModel),
+                        type,
+                        null,
+                        null,
+                        null
+                    );
+                }
+            } catch (ThreemaException e) {
+                logger.error("Exception", e);
+            }
+        }
+    }
+
+    @Override
+    public void onCreate() {
+        long startupTime = System.currentTimeMillis();
+
+        if (BuildConfig.DEBUG && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+                .detectLeakedSqlLiteObjects()
+                .detectLeakedClosableObjects()
+                .penaltyLog()
+                .penaltyListener(Executors.newSingleThreadExecutor(), v -> {
+                    logger.info("STRICTMODE VMPolicy: " + v.getCause());
+                    logStackTrace(v.getStackTrace());
+                })
+                .build());
 /*
 			StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
 				.detectAll()   // or .detectAll() for all detectable problems
@@ -368,526 +365,537 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 					logStackTrace(v.getStackTrace());
 				})
 				.build());
-*/		}
+*/
+        }
+
+        super.onCreate();
 
-		super.onCreate();
+        applyDynamicColorsIfEnabled();
 
-		applyDynamicColorsIfEnabled();
+        // always log database migration
+        setupLogging(null);
 
-		// always log database migration
-		setupLogging(null);
+        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM);
 
-		AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM);
+        context = getApplicationContext();
 
-		context = getApplicationContext();
+		LibthreemaKt.init(LogLevel.TRACE, new LibthreemaLogger());
 
 		if (!checkAppReplacingState(context)) {
 			return;
 		}
 
-		// Initialize TrustKit for CA pinning
-		if (!ConfigUtils.isOnPremBuild()) {
-			TrustKit.initializeWithNetworkSecurityConfiguration(this);
-		}
-
-		// Set unhandled exception logger
-		Thread.setDefaultUncaughtExceptionHandler(new LoggingUEH());
+        // Initialize TrustKit for CA pinning
+        if (!ConfigUtils.isOnPremBuild()) {
+            TrustKit.initializeWithNetworkSecurityConfiguration(this);
+        }
 
-		ProcessLifecycleOwner.get().getLifecycle().addObserver(this);
+        // Set unhandled exception logger
+        Thread.setDefaultUncaughtExceptionHandler(new LoggingUEH());
 
-		// Instantiate our own SecureRandom implementation to make sure this gets used everywhere
-		new LinuxSecureRandom();
+        ProcessLifecycleOwner.get().getLifecycle().addObserver(this);
 
-		// Prepare app version object
-		appVersion = new AppVersion(
-				ConfigUtils.getAppVersion(),
-				"A",
-				Locale.getDefault().getLanguage(),
-				Locale.getDefault().getCountry(),
-				Build.MODEL,
-				Build.VERSION.RELEASE
-		);
+        // Instantiate our own SecureRandom implementation to make sure this gets used everywhere
+        new LinuxSecureRandom();
 
-		// Create master key
-		File filesDir = getAppContext().getFilesDir();
-		if (filesDir != null) {
-			filesDir.mkdirs();
+        // Prepare app version object
+        appVersion = new AppVersion(
+            ConfigUtils.getAppVersion(),
+            "A",
+            Locale.getDefault().getLanguage(),
+            Locale.getDefault().getCountry(),
+            Build.MODEL,
+            Build.VERSION.RELEASE
+        );
 
-			if (filesDir.exists() && filesDir.isDirectory()) {
-				File masterKeyFile = new File(filesDir, AES_KEY_FILE);
+        // Create master key
+        File filesDir = getAppContext().getFilesDir();
+        if (filesDir != null) {
+            filesDir.mkdirs();
 
-				try {
-					boolean reset = !masterKeyFile.exists();
-
-					if (reset) {
-						/*
-						 *
-						 * IMPORTANT
-						 *
-						 * If the MasterKey file does not exists, remove every file that is encrypted with this
-						 * non-existing MasterKey file
-						 *
-						 * 1. Database
-						 * 2. Settings
-						 * 3. Message Queue
-						 *
-						 * TODO: move this into a separate method/file
-						 *
-						 */
-						//remove database, its encrypted with the wrong master key
-
-						logger.info("master key is missing or does not match. rename database files.");
-
-						File databaseFile = getAppContext().getDatabasePath(DatabaseServiceNew.DEFAULT_DATABASE_NAME_V4);
-						if (databaseFile.exists()) {
-							File databaseBackup = new File(databaseFile.getPath() + ".backup");
-							if (!databaseFile.renameTo(databaseBackup)) {
-								FileUtil.deleteFileOrWarn(databaseFile, "threema4 database", logger);
-							}
-						}
+            if (filesDir.exists() && filesDir.isDirectory()) {
+                File masterKeyFile = new File(filesDir, AES_KEY_FILE);
 
-						databaseFile = getAppContext().getDatabasePath(DatabaseNonceStore.DATABASE_NAME_V4);
-						if (databaseFile.exists()) {
-							FileUtil.deleteFileOrWarn(databaseFile, "nonce4 database", logger);
-						}
+                try {
+                    boolean reset = !masterKeyFile.exists();
+
+                    if (reset) {
+                        /*
+                         *
+                         * IMPORTANT
+                         *
+                         * If the MasterKey file does not exists, remove every file that is encrypted with this
+                         * non-existing MasterKey file
+                         *
+                         * 1. Database
+                         * 2. Settings
+                         * 3. Message Queue
+                         *
+                         * TODO(ANDR-XXXX): move this into a separate method/file
+                         *
+                         */
+                        //remove database, its encrypted with the wrong master key
+
+                        logger.info("master key is missing or does not match. rename database files.");
+
+                        File databaseFile = getAppContext().getDatabasePath(DatabaseServiceNew.DEFAULT_DATABASE_NAME_V4);
+                        if (databaseFile.exists()) {
+                            File databaseBackup = new File(databaseFile.getPath() + ".backup");
+                            if (!databaseFile.renameTo(databaseBackup)) {
+                                FileUtil.deleteFileOrWarn(databaseFile, "threema4 database", logger);
+                            }
+                        }
 
-						databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
-						if (databaseFile.exists()) {
-							FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
-						}
+                        databaseFile = getAppContext().getDatabasePath(DatabaseNonceStore.DATABASE_NAME_V4);
+                        if (databaseFile.exists()) {
+                            FileUtil.deleteFileOrWarn(databaseFile, "nonce4 database", logger);
+                        }
 
-						//remove all settings!
-						logger.info("initialize: remove preferences");
-						PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
-						preferenceStore.clear();
-					} else {
-						logger.info("OK, masterKeyFile exists");
-					}
+                        databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
+                        if (databaseFile.exists()) {
+                            FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
+                        }
 
-					masterKey = new MasterKey(masterKeyFile, null, true);
+                        //remove all settings!
+                        logger.info("initialize: remove preferences");
+                        PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
+                        preferenceStore.clear();
+                    } else {
+                        logger.info("OK, masterKeyFile exists");
+                    }
 
-					if (!masterKey.isLocked()) {
-						reset();
-					} else {
-						setupDayNightMode();
-					}
-				} catch (IOException e) {
-					logger.error("IOException", e);
-				}
+                    masterKey = new MasterKey(masterKeyFile, null, true);
 
-				// Register "Connectivity Action" broadcast receiver.
-				// This is called when a change in network connectivity has occurred.
-				// Note: This is deprecated on API 28+!
-				getAppContext().registerReceiver(
-					new ConnectivityChangeReceiver(),
-					new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)
-				);
+                    if (!masterKey.isLocked()) {
+                        reset();
+                    } else {
+                        setupDayNightMode();
+                    }
+                } catch (IOException e) {
+                    logger.error("IOException", e);
+                }
 
-				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-					// Register "Device Idle Mode Changed" broadcast receiver.
-					// This is called when the state of isDeviceIdleMode() changes. This broadcast
-					// is only sent to registered receivers.
-					getAppContext().registerReceiver(new BroadcastReceiver() {
-						@TargetApi(Build.VERSION_CODES.M)
-						@Override
-						public void onReceive(Context context, Intent intent) {
-							final PowerManager powerManager = (PowerManager) context
-								.getApplicationContext()
-								.getSystemService(Context.POWER_SERVICE);
-							if (powerManager != null && powerManager.isDeviceIdleMode()) {
-								logger.info("*** Device going to deep sleep");
-
-								isDeviceIdle = true;
-
-								try {
-									// Pause connection
-									serviceManager.getLifetimeService().pause();
-								} catch (Exception e) {
-									logger.error("Exception while pausing connection", e);
-								}
-
-								if (BackupService.isRunning()) {
-									context.stopService(new Intent(context, BackupService.class));
-								}
-							} else {
-								logger.info("*** Device waking up");
-								if (serviceManager != null) {
-									new Thread(() -> {
-										try {
-											serviceManager.getLifetimeService().unpause();
-										} catch (Exception e) {
-											logger.error("Exception while unpausing connection", e);
-										}
-									}, "device_wakup").start();
-									isDeviceIdle = false;
-								} else {
-									logger.info("Service manager unavailable");
-									if (masterKey != null && !masterKey.isLocked()) {
-										reset();
-									}
-								}
-							}
-						}
-					}, new IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
-				}
+                // Register "Connectivity Action" broadcast receiver.
+                // This is called when a change in network connectivity has occurred.
+                // Note: This is deprecated on API 28+!
+                getAppContext().registerReceiver(
+                    new ConnectivityChangeReceiver(),
+                    new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)
+                );
+
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                    // Register "Device Idle Mode Changed" broadcast receiver.
+                    // This is called when the state of isDeviceIdleMode() changes. This broadcast
+                    // is only sent to registered receivers.
+                    getAppContext().registerReceiver(new BroadcastReceiver() {
+                        @TargetApi(Build.VERSION_CODES.M)
+                        @Override
+                        public void onReceive(Context context, Intent intent) {
+                            final PowerManager powerManager = (PowerManager) context
+                                .getApplicationContext()
+                                .getSystemService(Context.POWER_SERVICE);
+                            if (powerManager != null && powerManager.isDeviceIdleMode()) {
+                                logger.info("*** Device going to deep sleep");
+
+                                isDeviceIdle = true;
+
+                                try {
+                                    // Pause connection
+                                    serviceManager.getLifetimeService().pause();
+                                } catch (Exception e) {
+                                    logger.error("Exception while pausing connection", e);
+                                }
+
+                                if (BackupService.isRunning()) {
+                                    context.stopService(new Intent(context, BackupService.class));
+                                }
+                            } else {
+                                logger.info("*** Device waking up");
+                                if (serviceManager != null) {
+                                    new Thread(() -> {
+                                        try {
+                                            serviceManager.getLifetimeService().unpause();
+                                        } catch (Exception e) {
+                                            logger.error("Exception while unpausing connection", e);
+                                        }
+                                    }, "device_wakup").start();
+                                    isDeviceIdle = false;
+                                } else {
+                                    logger.info("Service manager unavailable");
+                                    if (masterKey != null && !masterKey.isLocked()) {
+                                        reset();
+                                    }
+                                }
+                            }
+                        }
+                    }, new IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
+                }
 
-				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
-					// Register "Notification Channel Group Block State Changed" broadcast receiver.
-					// This is called when a NotificationChannelGroup is blocked or unblocked.
-					// This broadcast is only sent to the app that owns the channel group that has changed.
-					getAppContext().registerReceiver(new BroadcastReceiver() {
-						@Override
-						public void onReceive(Context context, Intent intent) {
-							try {
-								boolean blockedState = intent.getBooleanExtra(EXTRA_BLOCKED_STATE, false);
-								String groupName = intent.getStringExtra(EXTRA_NOTIFICATION_CHANNEL_GROUP_ID);
-								logger.info(
-									"*** Channel group {} blocked: {}",
-									groupName != null ? groupName : "<not specified>",
-									blockedState
-								);
-							} catch (Exception e) {
-								logger.error("Could not get data from intent", e);
-							}
-						}
-					}, new IntentFilter(ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED));
-				}
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+                    // Register "Notification Channel Group Block State Changed" broadcast receiver.
+                    // This is called when a NotificationChannelGroup is blocked or unblocked.
+                    // This broadcast is only sent to the app that owns the channel group that has changed.
+                    getAppContext().registerReceiver(new BroadcastReceiver() {
+                        @Override
+                        public void onReceive(Context context, Intent intent) {
+                            try {
+                                boolean blockedState = intent.getBooleanExtra(EXTRA_BLOCKED_STATE, false);
+                                String groupName = intent.getStringExtra(EXTRA_NOTIFICATION_CHANNEL_GROUP_ID);
+                                logger.info(
+                                    "*** Channel group {} blocked: {}",
+                                    groupName != null ? groupName : "<not specified>",
+                                    blockedState
+                                );
+                            } catch (Exception e) {
+                                logger.error("Could not get data from intent", e);
+                            }
+                        }
+                    }, new IntentFilter(ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED));
+                }
 
-				// Add a local broadcast receiver to receive PinningFailureReports
-				PinningFailureReportBroadcastReceiver receiver = new PinningFailureReportBroadcastReceiver();
-				LocalBroadcastManager.getInstance(context).registerReceiver(receiver, new IntentFilter(BackgroundReporter.REPORT_VALIDATION_EVENT));
+                // Add a local broadcast receiver to receive PinningFailureReports
+                PinningFailureReportBroadcastReceiver receiver = new PinningFailureReportBroadcastReceiver();
+                LocalBroadcastManager.getInstance(context).registerReceiver(receiver, new IntentFilter(BackgroundReporter.REPORT_VALIDATION_EVENT));
 
-				// Register a broadcast receiver for changes in app restrictions
-				if (ConfigUtils.isWorkRestricted()) {
-					getAppContext().registerReceiver(new BroadcastReceiver() {
-						@Override
-						public void onReceive(Context context, Intent intent) {
-							logger.info("Restrictions have changed. Updating workers");
+                // Register a broadcast receiver for changes in app restrictions
+                if (ConfigUtils.isWorkRestricted()) {
+                    getAppContext().registerReceiver(new BroadcastReceiver() {
+                        @Override
+                        public void onReceive(Context context, Intent intent) {
+                            logger.info("Restrictions have changed. Updating workers");
 
 							AppRestrictionService.getInstance().reload();
 							try {
-								OneTimeWorkRequest workRequest = WorkSyncWorker.Companion.buildOneTimeWorkRequest(true, true, null);
-								WorkManager.getInstance(ThreemaApplication.getAppContext()).enqueueUniqueWork(WORKER_WORK_SYNC, ExistingWorkPolicy.REPLACE, workRequest);
+								WorkSyncWorker.Companion.performOneTimeWorkSync(
+									ThreemaApplication.getAppContext(),
+									true,
+									true,
+									null
+								);
 							} catch (IllegalStateException e) {
 								logger.error("Unable to schedule work sync one time work", e);
 							}
-
-							if (!AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext())) {
-								AutoDeleteWorker.Companion.cancelAutoDelete(getAppContext());
-							}
+							AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext());
 						}
 					}, new IntentFilter(Intent.ACTION_APPLICATION_RESTRICTIONS_CHANGED));
 				}
 
-				// register a receiver for shortcuts that have been added to the launcher
-				ContextCompat.registerReceiver(this, new ShortcutAddedReceiver(), new IntentFilter(INTENT_ACTION_SHORTCUT_ADDED), ContextCompat.RECEIVER_NOT_EXPORTED);
+                // register a receiver for shortcuts that have been added to the launcher
+                ContextCompat.registerReceiver(this, new ShortcutAddedReceiver(), new IntentFilter(INTENT_ACTION_SHORTCUT_ADDED), ContextCompat.RECEIVER_NOT_EXPORTED);
 
-				// Start the Threema Push Service (if enabled in config)
-				ThreemaPushService.tryStart(logger, getAppContext());
-			}
-		}
+                // Start the Threema Push Service (if enabled in config)
+                ThreemaPushService.tryStart(logger, getAppContext());
+            }
+        }
 
-		logger.info("Startup time {}s", (System.currentTimeMillis() - startupTime) / DateUtils.SECOND_IN_MILLIS);
-	}
+        logger.info("Startup time {}s", (System.currentTimeMillis() - startupTime) / DateUtils.SECOND_IN_MILLIS);
+    }
 
 	private void applyDynamicColorsIfEnabled() {
 		if (DynamicColors.isDynamicColorAvailable()) {
 			SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
 			if (sharedPreferences != null && sharedPreferences.getBoolean("pref_dynamic_color", false)) {
-				DynamicColorsOptions dynamicColorsOptions = new DynamicColorsOptions.Builder().setPrecondition(new DynamicColors.Precondition() {
-					@Override
-					public boolean shouldApplyDynamicColors(@NonNull Activity activity, int theme) {
-						SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext());
-						return sharedPreferences != null && sharedPreferences.getBoolean("pref_dynamic_color", false);
-					}
+				DynamicColorsOptions dynamicColorsOptions = new DynamicColorsOptions.Builder().setPrecondition((activity, theme) -> {
+					SharedPreferences sharedPreferences1 = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext());
+					return sharedPreferences1 != null && sharedPreferences1.getBoolean("pref_dynamic_color", false);
 				}).build();
 
-				DynamicColors.applyToActivitiesIfAvailable(this, dynamicColorsOptions);
-			}
-		}
-	}
-
-	@Override
-	public void onStart(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now visible");
-	}
-
-	@Override
-	public void onStop(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now stopped");
-	}
-
-	@Override
-	public void onCreate(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now created");
-	}
-
-	@Override
-	public void onResume(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now resumed");
-		isResumed = true;
-
-		if (serviceManager != null) {
-			serviceManager.getLifetimeService().acquireConnection(ACTIVITY_CONNECTION_TAG);
-			logger.info("Connection now acquired");
-		} else {
-			logger.info("Service manager is null");
-		}
-	}
-
-	@Override
-	public void onPause(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now paused");
-		isResumed = false;
-
-		if (serviceManager != null) {
-			serviceManager.getLifetimeService().releaseConnectionLinger(ACTIVITY_CONNECTION_TAG, ACTIVITY_CONNECTION_LIFETIME);
-		}
-	}
-
-	@Override
-	public void onDestroy(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now destroyed");
-	}
-
-	@Override
-	public void onLowMemory() {
-		logger.info("*** App is low on memory");
-
-		super.onLowMemory();
-		try {
-			if (serviceManager != null) {
-				serviceManager.getAvatarCacheService().clear();
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	@SuppressLint("SwitchIntDef")
-	@Override
-	public void onTrimMemory(int level) {
-		logger.info("onTrimMemory (level={})", level);
-
-		super.onTrimMemory(level);
-
-		/* save our master key now if necessary, as we may get killed and if the user was still in the
-	     * initial setup procedure, this can lead to trouble as the database may already be there
-	     * but we may no longer be able to access it due to missing master key
-		 */
-		try {
-			if (getMasterKey() != null && !getMasterKey().isProtected()) {
-				if (serviceManager != null && serviceManager.getPreferenceService().getWizardRunning()) {
-					getMasterKey().setPassphrase(null);
-				}
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	@Nullable
-	public static ServiceManager getServiceManager() {
-		return serviceManager;
-	}
-
-	@NonNull
-	public static ServiceManager requireServiceManager() throws NullPointerException {
-		return Objects.requireNonNull(serviceManager);
-	}
-
-	public static MasterKey getMasterKey() {
-		return masterKey;
-	}
-
-	public static void putMessageDraft(String chatId, CharSequence value, @Nullable AbstractMessageModel quotedMessageModel) {
-		if (value == null || value.toString().trim().length() < 1) {
-			messageDrafts.remove(chatId);
-			quoteDrafts.remove(chatId);
-		} else {
-			messageDrafts.put(chatId, value.toString());
-			if (quotedMessageModel != null) {
-				quoteDrafts.put(chatId, quotedMessageModel.getApiMessageId());
-			} else {
-				quoteDrafts.remove(chatId);
-			}
-		}
-		try {
-			PreferenceService preferenceService = requireServiceManager().getPreferenceService();
-			preferenceService.setMessageDrafts(messageDrafts);
-			preferenceService.setQuoteDrafts(quoteDrafts);
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	public static String getMessageDraft(String chatId) {
-		if (messageDrafts.containsKey(chatId)) {
-			return messageDrafts.get(chatId);
-		}
-		return null;
-	}
-
-	public static String getQuoteDraft(String chatId) {
-		if (quoteDrafts.containsKey(chatId)) {
-			return quoteDrafts.get(chatId);
-		}
-		return null;
-	}
-
-	private static void retrieveMessageDraftsFromStorage() {
-		try {
-			messageDrafts = getServiceManager().getPreferenceService().getMessageDrafts();
-			quoteDrafts = getServiceManager().getPreferenceService().getQuoteDrafts();
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	@SuppressLint("ApplySharedPref")
-	private static void resetPreferences(SharedPreferences prefs) {
-		// Fix master key preference state if necessary (could be wrong if user kills app
-		// while disabling master key passphrase).
-		if (masterKey.isProtected() && prefs != null && !prefs.getBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), false)) {
-			logger.debug("Master key is protected, but switch preference is disabled - fixing");
-			prefs.edit().putBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), true).commit();
-		}
-
-		// If device is in AEC exclusion list and the user did not choose a preference yet,
-		// update the shared preference.
-		if (prefs != null && prefs.getString(getAppContext().getString(R.string.preferences__voip_echocancel), "none").equals("none")) {
-			// Determine whether device is excluded from hardware AEC
-			final String modelInfo = Build.MANUFACTURER + ";" + Build.MODEL;
-			boolean exclude = !Config.allowHardwareAec();
-
-			// Set default preference
-			final SharedPreferences.Editor editor = prefs.edit();
-			if (exclude) {
-				logger.debug("Device {} is on AEC exclusion list, switching to software echo cancellation", modelInfo);
-				editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "sw");
-			} else {
-				logger.debug("Device {} is not on AEC exclusion list", modelInfo);
-				editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "hw");
-			}
-			editor.commit();
-		}
-
-		try {
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_chat, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_privacy, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_appearance, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_notifications, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_media, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_calls, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_advanced_options, true);
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-
-		setupDayNightMode();
-	}
-
-	/**
-	 * Setup day / night theme for application depending on preferences
-	 */
-	private static void setupDayNightMode() {
-		AppCompatDelegate.setDefaultNightMode(ConfigUtils.getAppThemePrefs());
-	}
-
-	private static void setupLogging(PreferenceStore preferenceStore) {
-		// check if a THREEMA_MESSAGE_LOG exist on the
-		final File forceMessageLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_MESSAGE_LOG");
-		final File forceDebugLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_DEBUG_LOG");
-
-		// enable message logging if necessary
-		if (preferenceStore == null || preferenceStore.getBoolean(getAppContext().getString(R.string.preferences__message_log_switch))
-			|| forceMessageLog.exists() || forceDebugLog.exists()) {
-			DebugLogFileBackend.setEnabled(true);
-		} else {
-			DebugLogFileBackend.setEnabled(false);
-		}
+                DynamicColors.applyToActivitiesIfAvailable(this, dynamicColorsOptions);
+            }
+        }
+    }
+
+    @Override
+    public void onStart(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now visible");
+    }
+
+    @Override
+    public void onStop(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now stopped");
+    }
+
+    @Override
+    public void onCreate(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now created");
+    }
+
+    @Override
+    public void onResume(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now resumed");
+        isResumed = true;
+
+        if (serviceManager != null) {
+            serviceManager.getLifetimeService().acquireConnection(ACTIVITY_CONNECTION_TAG);
+            logger.info("Connection now acquired");
+        } else {
+            logger.info("Service manager is null");
+        }
+    }
+
+    @Override
+    public void onPause(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now paused");
+        isResumed = false;
+
+        if (serviceManager != null) {
+            serviceManager.getLifetimeService().releaseConnectionLinger(ACTIVITY_CONNECTION_TAG, ACTIVITY_CONNECTION_LIFETIME);
+        }
+    }
+
+    @Override
+    public void onDestroy(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now destroyed");
+    }
+
+    @Override
+    public void onLowMemory() {
+        logger.info("*** App is low on memory");
+
+        super.onLowMemory();
+        try {
+            if (serviceManager != null) {
+                serviceManager.getAvatarCacheService().clear();
+            }
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    @SuppressLint("SwitchIntDef")
+    @Override
+    public void onTrimMemory(int level) {
+        logger.info("onTrimMemory (level={})", level);
+
+        super.onTrimMemory(level);
+
+        /* save our master key now if necessary, as we may get killed and if the user was still in the
+         * initial setup procedure, this can lead to trouble as the database may already be there
+         * but we may no longer be able to access it due to missing master key
+         */
+        try {
+            if (getMasterKey() != null && !getMasterKey().isProtected()) {
+                if (serviceManager != null && serviceManager.getPreferenceService().getWizardRunning()) {
+                    getMasterKey().setPassphrase(null);
+                }
+            }
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    @Nullable
+    public static ServiceManager getServiceManager() {
+        return serviceManager;
+    }
+
+    @NonNull
+    public static ServiceManager requireServiceManager() throws NullPointerException {
+        return Objects.requireNonNull(serviceManager);
+    }
+
+    public static MasterKey getMasterKey() {
+        return masterKey;
+    }
+
+    public static void putMessageDraft(String chatId, CharSequence value, @Nullable AbstractMessageModel quotedMessageModel) {
+        if (value == null || value.toString().trim().length() < 1) {
+            messageDrafts.remove(chatId);
+            quoteDrafts.remove(chatId);
+        } else {
+            messageDrafts.put(chatId, value.toString());
+            if (quotedMessageModel != null) {
+                quoteDrafts.put(chatId, quotedMessageModel.getApiMessageId());
+            } else {
+                quoteDrafts.remove(chatId);
+            }
+        }
+        try {
+            PreferenceService preferenceService = requireServiceManager().getPreferenceService();
+            preferenceService.setMessageDrafts(messageDrafts);
+            preferenceService.setQuoteDrafts(quoteDrafts);
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    public static String getMessageDraft(String chatId) {
+        if (messageDrafts.containsKey(chatId)) {
+            return messageDrafts.get(chatId);
+        }
+        return null;
+    }
+
+    public static String getQuoteDraft(String chatId) {
+        if (quoteDrafts.containsKey(chatId)) {
+            return quoteDrafts.get(chatId);
+        }
+        return null;
+    }
+
+    private static void retrieveMessageDraftsFromStorage() {
+        try {
+            messageDrafts = getServiceManager().getPreferenceService().getMessageDrafts();
+            quoteDrafts = getServiceManager().getPreferenceService().getQuoteDrafts();
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    @SuppressLint("ApplySharedPref")
+    private static void resetPreferences(SharedPreferences prefs) {
+        // Fix master key preference state if necessary (could be wrong if user kills app
+        // while disabling master key passphrase).
+        if (masterKey.isProtected() && prefs != null && !prefs.getBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), false)) {
+            logger.debug("Master key is protected, but switch preference is disabled - fixing");
+            prefs.edit().putBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), true).commit();
+        }
+
+        // If device is in AEC exclusion list and the user did not choose a preference yet,
+        // update the shared preference.
+        if (prefs != null && prefs.getString(getAppContext().getString(R.string.preferences__voip_echocancel), "none").equals("none")) {
+            // Determine whether device is excluded from hardware AEC
+            final String modelInfo = Build.MANUFACTURER + ";" + Build.MODEL;
+            boolean exclude = !Config.allowHardwareAec();
+
+            // Set default preference
+            final SharedPreferences.Editor editor = prefs.edit();
+            if (exclude) {
+                logger.debug("Device {} is on AEC exclusion list, switching to software echo cancellation", modelInfo);
+                editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "sw");
+            } else {
+                logger.debug("Device {} is not on AEC exclusion list", modelInfo);
+                editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "hw");
+            }
+            editor.commit();
+        }
+
+        try {
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_chat, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_privacy, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_appearance, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_notifications, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_media, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_calls, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_advanced_options, true);
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+
+        setupDayNightMode();
+    }
+
+    /**
+     * Setup day / night theme for application depending on preferences
+     */
+    private static void setupDayNightMode() {
+        AppCompatDelegate.setDefaultNightMode(ConfigUtils.getAppThemePrefs());
+    }
+
+    private static void setupLogging(PreferenceStore preferenceStore) {
+        // check if a THREEMA_MESSAGE_LOG exist on the
+        final File forceMessageLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_MESSAGE_LOG");
+        final File forceDebugLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_DEBUG_LOG");
+
+        // enable message logging if necessary
+        if (preferenceStore == null || preferenceStore.getBoolean(getAppContext().getString(R.string.preferences__message_log_switch))
+            || forceMessageLog.exists() || forceDebugLog.exists()) {
+            DebugLogFileBackend.setEnabled(true);
+        } else {
+            DebugLogFileBackend.setEnabled(false);
+        }
+
+        // temporary - testing native crash in CompletableFuture while loading emojis
+        if (preferenceStore != null) {
+            final File forceAndroidEmojis = new File(Environment.getExternalStorageDirectory() + "/FORCE_SYSTEM_EMOJIS");
+            if (forceAndroidEmojis.exists()) {
+                preferenceStore.save(getAppContext().getString(R.string.preferences__emoji_style), "1");
+            }
+        }
+    }
 
-		// temporary - testing native crash in CompletableFuture while loading emojis
-		if (preferenceStore != null) {
-			final File forceAndroidEmojis = new File(Environment.getExternalStorageDirectory() + "/FORCE_SYSTEM_EMOJIS");
-			if (forceAndroidEmojis.exists()) {
-				preferenceStore.save(getAppContext().getString(R.string.preferences__emoji_style), "1");
-			}
-		}
-	}
+    public static synchronized void reset() {
 
-	public static synchronized void reset() {
+        //set default preferences
+        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getAppContext());
+        resetPreferences(sharedPreferences);
 
-		//set default preferences
-		SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getAppContext());
-		resetPreferences(sharedPreferences);
+        // init state bitmap cache singleton
+        StateBitmapUtil.init(getAppContext());
 
-		// init state bitmap cache singleton
-		StateBitmapUtil.init(getAppContext());
+        // init connection state colors
+        ConnectionIndicatorUtil.init(getAppContext());
 
-		// init connection state colors
-		ConnectionIndicatorUtil.init(getAppContext());
+        try {
+            // Load preference store
+            PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
 
-		try {
-			// Load preference store
-			PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
+            // Set logging to "always on"
+            setupLogging(null);
 
-			// Set logging to "always on"
-			setupLogging(null);
+            // Make database key from master key
+            String databaseKey = "x\"" + Utils.byteArrayToHexString(masterKey.getKey()) + "\"";
 
-			// Make database key from master key
-			String databaseKey = "x\"" + Utils.byteArrayToHexString(masterKey.getKey()) + "\"";
+            UpdateSystemService updateSystemService = new UpdateSystemServiceImpl();
 
-			UpdateSystemService updateSystemService = new UpdateSystemServiceImpl();
+            // Instantiate database service
+            System.loadLibrary("sqlcipher");
+            DatabaseServiceNew databaseServiceNew = new DatabaseServiceNew(getAppContext(), databaseKey, updateSystemService);
+            databaseServiceNew.executeNull();
 
-			// Instantiate database service
-			System.loadLibrary("sqlcipher");
-			DatabaseServiceNew databaseServiceNew = new DatabaseServiceNew(getAppContext(), databaseKey, updateSystemService);
-			databaseServiceNew.executeNull();
+            // We create the DH session store here and execute a null operation on it to prevent
+            // the app from being launched when the database is downgraded.
+            DHSessionStoreInterface dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
+            try {
+                dhSessionStore.executeNull();
+            } catch (Exception e) {
+                logger.error("Could not execute a statement on the database", e);
+                // The database file seems to be corrupt, therefore we delete the file
+                File databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
+                if (databaseFile.exists()) {
+                    FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
+                }
+                dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
+            }
 
-			// We create the DH session store here and execute a null operation on it to prevent
-			// the app from being launched when the database is downgraded.
-			DHSessionStoreInterface dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
-			try {
-				dhSessionStore.executeNull();
-			} catch (Exception e) {
-				logger.error("Could not execute a statement on the database", e);
-				// The database file seems to be corrupt, therefore we delete the file
-				File databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
-				if (databaseFile.exists()) {
-					FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
-				}
-				dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
-			}
+			IdentityStore identityStore = new IdentityStore(preferenceStore);
 
 			// Instantiate core service manager. Note that the task manager should only be used to
 			// schedule tasks once the service manager is set.
-			final CoreServiceManager coreServiceManager = new CoreServiceManagerImpl(
+			final CoreServiceManagerImpl coreServiceManager = new CoreServiceManagerImpl(
 				appVersion,
 				databaseServiceNew,
-				preferenceStore
+				preferenceStore,
+				identityStore,
+					() -> {
+						DatabaseNonceStore databaseNonceStore = new DatabaseNonceStore(getAppContext(), identityStore);
+						databaseNonceStore.executeNull();
+						logger.info("Nonce count (csp): {}", databaseNonceStore.getCount(NonceScope.CSP));
+						logger.info("Nonce count (d2d): {}", databaseNonceStore.getCount(NonceScope.D2D));
+						return databaseNonceStore;
+					}
 			);
 
 			// Instantiate model repositories
-			final ModelRepositories modelRepositories = new ModelRepositories(databaseServiceNew);
+			final ModelRepositories modelRepositories = new ModelRepositories(coreServiceManager);
 
-			logger.info("*** App launched");
-			logVersion();
+            logger.info("*** App launched");
+            logVersion();
 
-			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
-				ActivityManager activityManager = (ActivityManager) getAppContext().getSystemService(Context.ACTIVITY_SERVICE);
-				try {
-					List<ApplicationExitInfo> applicationExitInfos = activityManager.getHistoricalProcessExitReasons(null, 0, 0);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
+                ActivityManager activityManager = (ActivityManager) getAppContext().getSystemService(Context.ACTIVITY_SERVICE);
+                try {
+                    List<ApplicationExitInfo> applicationExitInfos = activityManager.getHistoricalProcessExitReasons(null, 0, 0);
 
-					if (applicationExitInfos.size() > 0) {
-						for (ApplicationExitInfo exitInfo : applicationExitInfos) {
-							long timestampOfLastLog = 0L;
-							if (sharedPreferences != null) {
-								timestampOfLastLog = sharedPreferences.getLong(EXIT_REASON_LOGGING_TIMESTAMP, timestampOfLastLog);
-							}
+                    if (applicationExitInfos.size() > 0) {
+                        for (ApplicationExitInfo exitInfo : applicationExitInfos) {
+                            long timestampOfLastLog = 0L;
+                            if (sharedPreferences != null) {
+                                timestampOfLastLog = sharedPreferences.getLong(EXIT_REASON_LOGGING_TIMESTAMP, timestampOfLastLog);
+                            }
 
-							if (exitInfo.getTimestamp() > timestampOfLastLog) {
-								SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm:ss.SSS", Locale.US);
+                            if (exitInfo.getTimestamp() > timestampOfLastLog) {
+                                SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm:ss.SSS", Locale.US);
                                 logger.info(
                                     "*** App last exited at {} with reason: {}, description: {}, status: {}",
                                     simpleDateFormat.format(exitInfo.getTimestamp()),
@@ -895,44 +903,41 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
                                     exitInfo.getDescription(),
                                     ApplicationExitInfoUtil.getStatusText(exitInfo)
                                 );
-								if (exitInfo.getReason() == ApplicationExitInfo.REASON_ANR) {
-									try {
-										InputStream traceInputStream = exitInfo.getTraceInputStream();
-										if (traceInputStream != null) {
-											BufferedReader r = new BufferedReader(new InputStreamReader(traceInputStream));
-											StringBuilder s = new StringBuilder();
-											for (String line; (line = r.readLine()) != null; ) {
-												s.append(line).append('\n');
-											}
-											logger.info(s.toString());
-										}
-									} catch (IOException e) {
-										logger.error("Error getting ANR trace", e);
-									}
-								}
-							}
-						}
-
-						if (sharedPreferences != null) {
-							sharedPreferences.edit().putLong(EXIT_REASON_LOGGING_TIMESTAMP, System.currentTimeMillis()).apply();
-						}
-					}
-				} catch (IllegalArgumentException e) {
-					logger.error("Unable to get reason of last exit", e);
-				}
-			}
+                                if (exitInfo.getReason() == ApplicationExitInfo.REASON_ANR) {
+                                    try {
+                                        InputStream traceInputStream = exitInfo.getTraceInputStream();
+                                        if (traceInputStream != null) {
+                                            BufferedReader r = new BufferedReader(new InputStreamReader(traceInputStream));
+                                            StringBuilder s = new StringBuilder();
+                                            for (String line; (line = r.readLine()) != null; ) {
+                                                s.append(line).append('\n');
+                                            }
+                                            logger.info(s.toString());
+                                        }
+                                    } catch (IOException e) {
+                                        logger.error("Error getting ANR trace", e);
+                                    }
+                                }
+                            }
+                        }
 
-			// Set up logging
-			setupLogging(preferenceStore);
+                        if (sharedPreferences != null) {
+                            sharedPreferences.edit().putLong(EXIT_REASON_LOGGING_TIMESTAMP, System.currentTimeMillis()).apply();
+                        }
+                    }
+                } catch (IllegalArgumentException e) {
+                    logger.error("Unable to get reason of last exit", e);
+                }
+            }
 
-			IdentityStore identityStore = new IdentityStore(preferenceStore);
+            // Set up logging
+            setupLogging(preferenceStore);
 
 			try {
 				// Instantiate service manager
 				serviceManager = new ServiceManager(
 					modelRepositories,
 					dhSessionStore,
-					identityStore,
 					masterKey,
 					coreServiceManager,
 					updateSystemService
@@ -942,97 +947,97 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 				return;
 			}
 
-			serviceManager.getTaskManager().schedule(new MessageQueueMigrationTask(
-					context,
-					identityStore.getIdentity(),
-					serviceManager.getMessageService(),
-					serviceManager.getGroupService(),
-					serviceManager.getDatabaseServiceNew().getMessageModelFactory(),
-					serviceManager.getDatabaseServiceNew().getGroupMessageModelFactory()
-				)
-			);
-
-			ServerConnection connection = serviceManager.getConnection();
-
-			// Whenever the connection is established, check whether the
-			// push token needs to be updated.
-			connection.addConnectionStateListener((newConnectionState) -> {
-				if (newConnectionState == ConnectionState.LOGGEDIN) {
-					final Context appContext = getAppContext();
-					if (PushService.servicesInstalled(appContext)) {
-						if (PushUtil.isPushEnabled(appContext)) {
-							if (PushUtil.pushTokenNeedsRefresh(appContext)) {
-								PushUtil.enqueuePushTokenUpdate(appContext, false, false);
-							} else {
-								logger.debug("Push token is still fresh. No update needed");
-							}
-						}
-					}
-				}
-			});
+            serviceManager.getTaskManager().schedule(new MessageQueueMigrationTask(
+                    context,
+                    identityStore.getIdentity(),
+                    serviceManager.getMessageService(),
+                    serviceManager.getGroupService(),
+                    serviceManager.getDatabaseServiceNew().getMessageModelFactory(),
+                    serviceManager.getDatabaseServiceNew().getGroupMessageModelFactory()
+                )
+            );
+
+            ServerConnection connection = serviceManager.getConnection();
+
+            // Whenever the connection is established, check whether the
+            // push token needs to be updated.
+            connection.addConnectionStateListener((newConnectionState) -> {
+                if (newConnectionState == ConnectionState.LOGGEDIN) {
+                    final Context appContext = getAppContext();
+                    if (PushService.servicesInstalled(appContext)) {
+                        if (PushUtil.isPushEnabled(appContext)) {
+                            if (PushUtil.pushTokenNeedsRefresh(appContext)) {
+                                PushUtil.enqueuePushTokenUpdate(appContext, false, false);
+                            } else {
+                                logger.debug("Push token is still fresh. No update needed");
+                            }
+                        }
+                    }
+                }
+            });
 
-			// get application restrictions
-			if (ConfigUtils.isWorkBuild()) {
-				AppRestrictionService.getInstance()
-					.reload();
-			}
+            // get application restrictions
+            if (ConfigUtils.isWorkBuild()) {
+                AppRestrictionService.getInstance()
+                    .reload();
+            }
 
-			connection.addConnectionStateListener(connectionState -> {
-				logger.info("ServerConnection state changed: {}", connectionState);
+            connection.addConnectionStateListener(connectionState -> {
+                logger.info("ServerConnection state changed: {}", connectionState);
 
-				if (connectionState == ConnectionState.LOGGEDIN) {
-					lastLoggedIn = new Date();
-				}
-			});
+                if (connectionState == ConnectionState.LOGGEDIN) {
+                    lastLoggedIn = new Date();
+                }
+            });
 
-			/* cancel any "new message" notification */
-			NotificationManagerCompat.from(getAppContext()).cancel(NEW_MESSAGE_LOCKED_NOTIFICATION_ID);
+            /* cancel any "new message" notification */
+            NotificationManagerCompat.from(getAppContext()).cancel(NEW_MESSAGE_LOCKED_NOTIFICATION_ID);
 
 			/* trigger a connection now, just to be sure we're up-to-date and any broken connection
 			   (e.g. from before a reboot) is preempted.
 			 */
-			serviceManager.getLifetimeService().acquireConnection("resetConnection");
-			serviceManager.getLifetimeService().releaseConnectionLinger("resetConnection", ACTIVITY_CONNECTION_LIFETIME);
-			configureListeners();
+            serviceManager.getLifetimeService().acquireConnection("resetConnection");
+            serviceManager.getLifetimeService().releaseConnectionLinger("resetConnection", ACTIVITY_CONNECTION_LIFETIME);
+            configureListeners();
 
-			// Mark all file messages with state 'uploading' as failed. This is because the file
-			// upload is not continued after app restarts. When the state has been changed to
-			// failed, a resend button is displayed on the message. We only need to do this in the
-			// uploading state as in sending state a persistent task is already scheduled and the
-			// message will be sent when a connection is available.
-			databaseServiceNew
-					.getMessageModelFactory()
-					.markUnscheduledFileMessagesAsFailed();
+            // Mark all file messages with state 'uploading' as failed. This is because the file
+            // upload is not continued after app restarts. When the state has been changed to
+            // failed, a resend button is displayed on the message. We only need to do this in the
+            // uploading state as in sending state a persistent task is already scheduled and the
+            // message will be sent when a connection is available.
+            databaseServiceNew
+                .getMessageModelFactory()
+                .markUnscheduledFileMessagesAsFailed();
 
-			databaseServiceNew
-					.getGroupMessageModelFactory()
-					.markUnscheduledFileMessagesAsFailed();
+            databaseServiceNew
+                .getGroupMessageModelFactory()
+                .markUnscheduledFileMessagesAsFailed();
 
-			databaseServiceNew
-					.getDistributionListMessageModelFactory()
-					.markUnscheduledFileMessagesAsFailed();
+            databaseServiceNew
+                .getDistributionListMessageModelFactory()
+                .markUnscheduledFileMessagesAsFailed();
 
-			retrieveMessageDraftsFromStorage();
+            retrieveMessageDraftsFromStorage();
 
-			// process webclient wakeups
-			SessionWakeUpServiceImpl.getInstance().processPendingWakeupsAsync();
+            // process webclient wakeups
+            SessionWakeUpServiceImpl.getInstance().processPendingWakeupsAsync();
 
-			// start threema safe scheduler
-			serviceManager.getThreemaSafeService().schedulePeriodicUpload();
+            // start threema safe scheduler
+            serviceManager.getThreemaSafeService().schedulePeriodicUpload();
+
+			PreferenceService preferenceService = serviceManager.getPreferenceService();
 
 			new Thread(() -> {
 				// schedule work synchronization
-				scheduleWorkSync(preferenceStore);
+				WorkSyncWorker.Companion.schedulePeriodicWorkSync(getAppContext(), preferenceService);
 				// schedule identity states / feature masks etc.
-				scheduleContactUpdateSync(preferenceStore);
+				ContactUpdateWorker.schedulePeriodicSync(getAppContext(), preferenceService);
 				// schedule shortcut update
 				if (preferenceStore.getBoolean(getAppContext().getString(R.string.preferences__direct_share))) {
 					scheduleShareTargetShortcutUpdate();
 				}
 				// schedule auto delete
-				if (!AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext())) {
-					AutoDeleteWorker.Companion.cancelAutoDelete(getAppContext());
-				}
+				AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext());
 			}, "scheduleSync").start();
 		} catch (MasterKeyLockedException | SQLiteException e) {
 			logger.error("Exception opening database", e);
@@ -1042,408 +1047,334 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 		}
 	}
 
-	public static void logVersion() {
-		String commitHash = BuildConfig.DEBUG
-			? ", Commit: " + BuildConfig.GIT_HASH
-			: "";
-		logger.info(
-			"*** App Version. Device/Android Version/Flavor: {} Version: {} Build: {}{}",
-			ConfigUtils.getDeviceInfo(false),
-			BuildConfig.VERSION_NAME,
-			ConfigUtils.getBuildNumber(getAppContext()),
-			commitHash
-		);
-	}
-
-	private static long getSchedulePeriodMs(PreferenceStore preferenceStore, int key) {
-		Integer schedulePeriod = preferenceStore.getInt(getAppContext().getString(key));
-		if (schedulePeriod == null || schedulePeriod == 0) {
-			schedulePeriod = (int) DateUtils.DAY_IN_MILLIS;
-		} else {
-			schedulePeriod *= (int) DateUtils.SECOND_IN_MILLIS;
-		}
-		return (long) schedulePeriod;
-	}
-
-	@WorkerThread
-	private static boolean scheduleContactUpdateSync(PreferenceStore preferenceStore) {
-		long schedulePeriod = getSchedulePeriodMs(preferenceStore, R.string.preferences__identity_states_check_interval);
-
-		logger.info("Initializing contact update sync. Requested schedule period: {} ms", schedulePeriod);
-
-		try {
-			WorkManager workManager = WorkManager.getInstance(context);
-
-			if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(
-				workManager,
-				WORKER_CONTACT_UPDATE_PERIODIC_NAME,
-				schedulePeriod
-			)) {
-				logger.debug("Scheduling new job");
-
-				// Cancel the work with the old name as the IdentityStatesWorker class does not
-				// exist anymore.
-				workManager.cancelUniqueWork(WORKER_IDENTITY_STATES_PERIODIC_NAME);
-
-				// schedule the start of the service according to schedule period
-				Constraints constraints = new Constraints.Builder()
-					.setRequiredNetworkType(NetworkType.CONNECTED)
-					.build();
-
-				PeriodicWorkRequest workRequest = new PeriodicWorkRequest.Builder(ContactUpdateWorker.class, schedulePeriod, TimeUnit.MILLISECONDS)
-					.setConstraints(constraints)
-					.addTag(String.valueOf(schedulePeriod))
-					.setInitialDelay(1000, TimeUnit.MILLISECONDS)
-					.build();
-
-				workManager.enqueueUniquePeriodicWork(WORKER_CONTACT_UPDATE_PERIODIC_NAME, ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE, workRequest);
-				return true;
-			}
-		} catch (IllegalStateException e) {
-			logger.error("Unable to initialize WorkManager", e);
-		}
-		return false;
-	}
-
-	private static boolean scheduleWorkSync(PreferenceStore preferenceStore) {
-		if (!ConfigUtils.isWorkBuild()) {
-			return false;
-		}
-
-		long schedulePeriodMs = getSchedulePeriodMs(preferenceStore, R.string.preferences__work_sync_check_interval);
-		logger.info("Scheduling periodic work sync. Schedule period: {}", schedulePeriodMs);
-
-		try {
-			WorkManager workManager = WorkManager.getInstance(context);
-			ExistingPeriodicWorkPolicy policy = WorkManagerUtil.shouldScheduleNewWorkManagerInstance(workManager, WORKER_PERIODIC_WORK_SYNC, schedulePeriodMs) ?
-				ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE :
-				ExistingPeriodicWorkPolicy.KEEP;
-			logger.info("{}: {} existing periodic work", WORKER_PERIODIC_WORK_SYNC, policy);
-			PeriodicWorkRequest workRequest = WorkSyncWorker.Companion.buildPeriodicWorkRequest(schedulePeriodMs);
-			workManager.enqueueUniquePeriodicWork(WORKER_PERIODIC_WORK_SYNC, policy, workRequest);
-		} catch (IllegalStateException e) {
-			logger.error("Unable to schedule periodic work sync work", e);
-			return false;
-		}
-
-		return true;
-	}
+    public static void logVersion() {
+        String commitHash = BuildConfig.DEBUG
+            ? ", Commit: " + BuildConfig.GIT_HASH
+            : "";
+        logger.info(
+            "*** App Version. Device/Android Version/Flavor: {} Version: {} Build: {}{}",
+            ConfigUtils.getDeviceInfo(false),
+            BuildConfig.VERSION_NAME,
+            ConfigUtils.getBuildNumber(getAppContext()),
+            commitHash
+        );
+    }
 
 	@WorkerThread
 	public static boolean scheduleShareTargetShortcutUpdate() {
 		logger.info("Scheduling share target shortcut update work");
 
-		long schedulePeriod = DateUtils.MINUTE_IN_MILLIS * 15;
+        long schedulePeriod = DateUtils.MINUTE_IN_MILLIS * 15;
 
-		try {
-			WorkManager workManager = WorkManager.getInstance(context);
+        try {
+            WorkManager workManager = WorkManager.getInstance(context);
 
-			if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(
-				workManager,
-				WORKER_SHARE_TARGET_UPDATE,
-				schedulePeriod
-			)) {
-				logger.debug("Create new worker");
+            if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(
+                workManager,
+                WORKER_SHARE_TARGET_UPDATE,
+                schedulePeriod
+            )) {
+                logger.debug("Create new worker");
 
-				// schedule the start of the service according to schedule period
-				Constraints constraints = new Constraints.Builder()
-					.setRequiredNetworkType(NetworkType.CONNECTED)
-					.build();
+                // schedule the start of the service according to schedule period
+                Constraints constraints = new Constraints.Builder()
+                    .setRequiredNetworkType(NetworkType.CONNECTED)
+                    .build();
 
-				PeriodicWorkRequest workRequest = new PeriodicWorkRequest.Builder(ShareTargetUpdateWorker.class, schedulePeriod, TimeUnit.MILLISECONDS)
-					.setConstraints(constraints)
-					.addTag(String.valueOf(schedulePeriod))
-					.setInitialDelay(3, TimeUnit.MINUTES)
-					.build();
+                PeriodicWorkRequest workRequest = new PeriodicWorkRequest.Builder(ShareTargetUpdateWorker.class, schedulePeriod, TimeUnit.MILLISECONDS)
+                    .setConstraints(constraints)
+                    .addTag(String.valueOf(schedulePeriod))
+                    .setInitialDelay(3, TimeUnit.MINUTES)
+                    .build();
 
-				workManager.enqueueUniquePeriodicWork(WORKER_SHARE_TARGET_UPDATE, ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE, workRequest);
-			} else {
-				logger.debug("Reusing existing worker");
-			}
-		} catch (IllegalStateException e) {
-			logger.error("Unable to schedule share target update work", e);
-			return false;
-		}
+                workManager.enqueueUniquePeriodicWork(WORKER_SHARE_TARGET_UPDATE, ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE, workRequest);
+            } else {
+                logger.debug("Reusing existing worker");
+            }
+        } catch (IllegalStateException e) {
+            logger.error("Unable to schedule share target update work", e);
+            return false;
+        }
 
-		return true;
-	}
+        return true;
+    }
 
-	private static void showConversationNotification(AbstractMessageModel newMessage, boolean updateExisting) {
-		try {
+    private static void showConversationNotification(AbstractMessageModel newMessage, boolean updateExisting) {
+        try {
             if (!newMessage.isOutbox()
                 && !newMessage.isStatusMessage()
                 && !newMessage.isRead()) {
 
-				NotificationService notificationService = serviceManager.getNotificationService();
-				ContactService contactService = serviceManager.getContactService();
-				GroupService groupService = serviceManager.getGroupService();
-				DeadlineListService hiddenChatsListService = serviceManager.getHiddenChatsListService();
-
-				if (TestUtil.required(notificationService, contactService, groupService)) {
-					if (newMessage.getType() != MessageType.GROUP_CALL_STATUS) {
-						notificationService.showConversationNotification(ConversationNotificationUtil.convert(
-								getAppContext(),
-								newMessage,
-								contactService,
-								groupService,
-								hiddenChatsListService),
-							updateExisting);
-					}
+                NotificationService notificationService = serviceManager.getNotificationService();
+                ContactService contactService = serviceManager.getContactService();
+                GroupService groupService = serviceManager.getGroupService();
+                DeadlineListService hiddenChatsListService = serviceManager.getHiddenChatsListService();
+
+                if (TestUtil.required(notificationService, contactService, groupService)) {
+                    if (newMessage.getType() != MessageType.GROUP_CALL_STATUS) {
+                        notificationService.showConversationNotification(ConversationNotificationUtil.convert(
+                                getAppContext(),
+                                newMessage,
+                                contactService,
+                                groupService,
+                                hiddenChatsListService),
+                            updateExisting);
+                    }
 
-					// update widget on incoming message
-					WidgetUtil.updateWidgets(serviceManager.getContext());
-				}
-			}
-		} catch (ThreemaException e) {
-			logger.error("Exception", e);
-		}
-	}
+                    // update widget on incoming message
+                    WidgetUtil.updateWidgets(serviceManager.getContext());
+                }
+            }
+        } catch (ThreemaException e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    private static void configureListeners() {
+        ListenerManager.groupListeners.add(new GroupListener() {
+            @Override
+            public void onCreate(GroupModel newGroupModel) {
+                try {
+                    serviceManager.getConversationService().refresh(newGroupModel);
+                    serviceManager.getMessageService().createGroupStatus(
+                        serviceManager.getGroupService().createReceiver(newGroupModel),
+                        GroupStatusDataModel.GroupStatusType.CREATED,
+                        null,
+                        null,
+                        null
+                    );
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-	private static void configureListeners() {
-		ListenerManager.groupListeners.add(new GroupListener() {
-			@Override
-			public void onCreate(GroupModel newGroupModel) {
-				try {
-					serviceManager.getConversationService().refresh(newGroupModel);
-					serviceManager.getMessageService().createGroupStatus(
-						serviceManager.getGroupService().createReceiver(newGroupModel),
-						GroupStatusDataModel.GroupStatusType.CREATED,
-						null,
-						null,
-						null
-					);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
-
-			@Override
-			public void onRename(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
-						serviceManager.getConversationService().refresh(groupModel);
-						String groupName = groupModel.getName();
-						if (groupName == null) {
-							groupName = "";
-						}
-						serviceManager.getMessageService().createGroupStatus(
-							messageReceiver,
-							GroupStatusDataModel.GroupStatusType.RENAMED,
-							null,
-							null,
-							groupName
-						);
-						ShortcutUtil.updatePinnedShortcut(messageReceiver);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onRename(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
+                        serviceManager.getConversationService().refresh(groupModel);
+                        String groupName = groupModel.getName();
+                        if (groupName == null) {
+                            groupName = "";
+                        }
+                        serviceManager.getMessageService().createGroupStatus(
+                            messageReceiver,
+                            GroupStatusDataModel.GroupStatusType.RENAMED,
+                            null,
+                            null,
+                            groupName
+                        );
+                        ShortcutUtil.updatePinnedShortcut(messageReceiver);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
-			@Override
-			public void onUpdatePhoto(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
-						serviceManager.getConversationService().refresh(groupModel);
-						serviceManager.getMessageService().createGroupStatus(
-							messageReceiver,
-							GroupStatusDataModel.GroupStatusType.PROFILE_PICTURE_UPDATED,
-							null,
-							null,
-							null
-						);
-						ShortcutUtil.updatePinnedShortcut(messageReceiver);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onUpdatePhoto(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
+                        serviceManager.getConversationService().refresh(groupModel);
+                        serviceManager.getMessageService().createGroupStatus(
+                            messageReceiver,
+                            GroupStatusDataModel.GroupStatusType.PROFILE_PICTURE_UPDATED,
+                            null,
+                            null,
+                            null
+                        );
+                        ShortcutUtil.updatePinnedShortcut(messageReceiver);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
-			@Override
-			public void onRemove(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						final MessageReceiver receiver = serviceManager.getGroupService().createReceiver(groupModel);
-						serviceManager.getBallotService().remove(receiver);
-						serviceManager.getConversationService().empty(groupModel);
-						serviceManager.getNotificationService().cancel(new GroupMessageReceiver(groupModel, null, null, serviceManager));
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onRemove(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        final MessageReceiver receiver = serviceManager.getGroupService().createReceiver(groupModel);
+                        serviceManager.getBallotService().remove(receiver);
+                        serviceManager.getConversationService().empty(groupModel);
+                        serviceManager.getNotificationService().cancel(new GroupMessageReceiver(groupModel, null, null, serviceManager));
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
 			@Override
-			public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+			public void onNewMember(GroupModel group, String newIdentity) {
 				try {
 					final GroupMessageReceiver receiver = serviceManager.getGroupService().createReceiver(group);
 					final String myIdentity = serviceManager.getUserService().getIdentity();
 
-					if (!TestUtil.isEmptyOrNull(myIdentity)) {
-						serviceManager.getMessageService().createGroupStatus(
-							receiver,
-							GroupStatusDataModel.GroupStatusType.MEMBER_ADDED,
-							newIdentity,
-							null,
-							null
-						);
-					}
-				} catch (ThreemaException x) {
-					logger.error("Could not create group state after new member was added", x);
-				}
+                    if (!TestUtil.isEmptyOrNull(myIdentity)) {
+                        serviceManager.getMessageService().createGroupStatus(
+                            receiver,
+                            GroupStatusDataModel.GroupStatusType.MEMBER_ADDED,
+                            newIdentity,
+                            null,
+                            null
+                        );
+                    }
+                } catch (ThreemaException x) {
+                    logger.error("Could not create group state after new member was added", x);
+                }
 
-				//reset avatar to recreate it!
-				try {
-					serviceManager.getAvatarCacheService()
-							.reset(group);
-				} catch (FileSystemNotPresentException e) {
-					logger.error("Could not reset avatar cache", e);
-				}
-			}
+                //reset avatar to recreate it!
+                try {
+                    serviceManager.getAvatarCacheService()
+                        .reset(group);
+                } catch (FileSystemNotPresentException e) {
+                    logger.error("Could not reset avatar cache", e);
+                }
+            }
 
 			@Override
-			public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+			public void onMemberLeave(GroupModel group, String identity) {
 				try {
 					GroupService groupService = serviceManager.getGroupService();
 					final GroupMessageReceiver receiver = groupService.createReceiver(group);
 
-					serviceManager.getMessageService().createGroupStatus(
-						receiver,
-						GroupStatusDataModel.GroupStatusType.MEMBER_LEFT,
-						identity,
-						null,
-						null
-					);
-
-					BallotService ballotService = serviceManager.getBallotService();
-					ballotService.removeVotes(receiver, identity);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+                    serviceManager.getMessageService().createGroupStatus(
+                        receiver,
+                        GroupStatusDataModel.GroupStatusType.MEMBER_LEFT,
+                        identity,
+                        null,
+                        null
+                    );
+
+                    BallotService ballotService = serviceManager.getBallotService();
+                    ballotService.removeVotes(receiver, identity);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
 			@Override
-			public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+			public void onMemberKicked(GroupModel group, String identity) {
 				final String myIdentity = serviceManager.getUserService().getIdentity();
 
-				if (myIdentity != null && myIdentity.equals(identity)) {
-					// my own member status has changed
-					try {
-						serviceManager.getNotificationService().cancelGroupCallNotification(group.getId());
-						serviceManager.getConversationService().refresh(group);
-					} catch (Exception e) {
-						logger.error("Exception", e);
-					}
-				}
-				try {
-					final GroupMessageReceiver receiver = serviceManager.getGroupService().createReceiver(group);
-
-					serviceManager.getMessageService().createGroupStatus(
-						receiver,
-						GroupStatusDataModel.GroupStatusType.MEMBER_KICKED,
-						identity,
-						null,
-						null
-					);
-
-					BallotService ballotService = serviceManager.getBallotService();
-					ballotService.removeVotes(receiver, identity);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+                if (myIdentity != null && myIdentity.equals(identity)) {
+                    // my own member status has changed
+                    try {
+                        serviceManager.getNotificationService().cancelGroupCallNotification(group.getId());
+                        serviceManager.getConversationService().refresh(group);
+                    } catch (Exception e) {
+                        logger.error("Exception", e);
+                    }
+                }
+                try {
+                    final GroupMessageReceiver receiver = serviceManager.getGroupService().createReceiver(group);
+
+                    serviceManager.getMessageService().createGroupStatus(
+                        receiver,
+                        GroupStatusDataModel.GroupStatusType.MEMBER_KICKED,
+                        identity,
+                        null,
+                        null
+                    );
+
+                    BallotService ballotService = serviceManager.getBallotService();
+                    ballotService.removeVotes(receiver, identity);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-			@Override
-			public void onUpdate(GroupModel groupModel) {
-				try {
-					serviceManager.getConversationService().refresh(groupModel);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+            @Override
+            public void onUpdate(GroupModel groupModel) {
+                try {
+                    serviceManager.getConversationService().refresh(groupModel);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-			@Override
-			public void onLeave(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						serviceManager.getConversationService().refresh(groupModel);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onLeave(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        serviceManager.getConversationService().refresh(groupModel);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
-			@Override
-			public void onGroupStateChanged(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
-				logger.debug("onGroupStateChanged: {} -> {}", oldState, newState);
+            @Override
+            public void onGroupStateChanged(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
+                logger.debug("onGroupStateChanged: {} -> {}", oldState, newState);
 
-				showNotesGroupNotice(groupModel, oldState, newState);
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+                showNotesGroupNotice(groupModel, oldState, newState);
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.distributionListListeners.add(new DistributionListListener() {
-			@Override
-			public void onCreate(DistributionListModel distributionListModel) {
-				try {
-					serviceManager.getConversationService().refresh(distributionListModel);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+        ListenerManager.distributionListListeners.add(new DistributionListListener() {
+            @Override
+            public void onCreate(DistributionListModel distributionListModel) {
+                try {
+                    serviceManager.getConversationService().refresh(distributionListModel);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-			@Override
-			public void onModify(DistributionListModel distributionListModel) {
-				new Thread(() -> {
-					try {
-						serviceManager.getConversationService().refresh(distributionListModel);
-						ShortcutUtil.updatePinnedShortcut(serviceManager.getDistributionListService().createReceiver(distributionListModel));
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onModify(DistributionListModel distributionListModel) {
+                new Thread(() -> {
+                    try {
+                        serviceManager.getConversationService().refresh(distributionListModel);
+                        ShortcutUtil.updatePinnedShortcut(serviceManager.getDistributionListService().createReceiver(distributionListModel));
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
 
-			@Override
-			public void onRemove(DistributionListModel distributionListModel) {
-				new Thread(() -> {
-					try {
-						serviceManager.getConversationService().empty(distributionListModel);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onRemove(DistributionListModel distributionListModel) {
+                new Thread(() -> {
+                    try {
+                        serviceManager.getConversationService().empty(distributionListModel);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.messageListeners.add(new MessageListener() {
-			@Override
-			public void onNew(AbstractMessageModel newMessage) {
-				logger.debug("MessageListener.onNewMessage");
+        ListenerManager.messageListeners.add(new MessageListener() {
+            @Override
+            public void onNew(AbstractMessageModel newMessage) {
+                logger.debug("MessageListener.onNewMessage");
                 ConversationService conversationService;
                 try {
-                     conversationService = serviceManager.getConversationService();
+                    conversationService = serviceManager.getConversationService();
                 } catch (ThreemaException e) {
                     logger.error("Could not get conversation service", e);
                     return;
                 }
-				if (!newMessage.isStatusMessage()) {
+                if (!newMessage.isStatusMessage()) {
                     ConversationModel conversationModel = conversationService.refresh(newMessage);
                     if (conversationModel != null) {
                         // Show notification only if there is a conversation
                         showConversationNotification(newMessage, false);
                     }
-				} else if (newMessage.getType() == MessageType.GROUP_CALL_STATUS) {
+                } else if (newMessage.getType() == MessageType.GROUP_CALL_STATUS) {
                     conversationService.refresh(newMessage);
                 }
-			}
+            }
 
-			@Override
-			public void onModified(List<AbstractMessageModel> modifiedMessageModels) {
-				logger.debug("MessageListener.onModified");
-				for (final AbstractMessageModel modifiedMessageModel : modifiedMessageModels) {
+            @Override
+            public void onModified(List<AbstractMessageModel> modifiedMessageModels) {
+                logger.debug("MessageListener.onModified");
+                for (final AbstractMessageModel modifiedMessageModel : modifiedMessageModels) {
                     if (modifiedMessageModel.isStatusMessage()) {
                         continue;
                     }
@@ -1461,47 +1392,47 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
                         logger.error("Exception", e);
                     }
                 }
-			}
+            }
 
-			@Override
-			public void onRemoved(AbstractMessageModel removedMessageModel) {
-				logger.debug("MessageListener.onRemoved");
-				if (!removedMessageModel.isStatusMessage()) {
-					try {
-						serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}
-			}
+            @Override
+            public void onRemoved(AbstractMessageModel removedMessageModel) {
+                logger.debug("MessageListener.onRemoved");
+                if (!removedMessageModel.isStatusMessage()) {
+                    try {
+                        serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }
+            }
 
-			@Override
-			public void onRemoved(List<AbstractMessageModel> removedMessageModels) {
-				logger.debug("MessageListener.onRemoved multi");
-				for (final AbstractMessageModel removedMessageModel : removedMessageModels) {
-					if (!removedMessageModel.isStatusMessage()) {
-						try {
-							serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
-						} catch (ThreemaException e) {
-							logger.error("Exception", e);
-						}
-					}
-				}
-			}
+            @Override
+            public void onRemoved(List<AbstractMessageModel> removedMessageModels) {
+                logger.debug("MessageListener.onRemoved multi");
+                for (final AbstractMessageModel removedMessageModel : removedMessageModels) {
+                    if (!removedMessageModel.isStatusMessage()) {
+                        try {
+                            serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
+                        } catch (ThreemaException e) {
+                            logger.error("Exception", e);
+                        }
+                    }
+                }
+            }
 
-			@Override
-			public void onProgressChanged(AbstractMessageModel messageModel, int newProgress) {
-				// Ignore
-			}
+            @Override
+            public void onProgressChanged(AbstractMessageModel messageModel, int newProgress) {
+                // Ignore
+            }
 
-			@Override
-			public void onResendDismissed(@NonNull AbstractMessageModel messageModel) {
-				// Ignore
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onResendDismissed(@NonNull AbstractMessageModel messageModel) {
+                // Ignore
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.editMessageListener.add(message -> showConversationNotification(message, true));
-		ListenerManager.messageDeletedForAllListener.add(message -> showConversationNotification(message, true));
+        ListenerManager.editMessageListener.add(message -> showConversationNotification(message, true));
+        ListenerManager.messageDeletedForAllListener.add(message -> showConversationNotification(message, true));
 
         ListenerManager.groupJoinResponseListener.add((outgoingGroupJoinRequestModel, status) ->
             serviceManager.getNotificationService()
@@ -1510,32 +1441,32 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
                 ));
 
 
-		ListenerManager.incomingGroupJoinRequestListener.add(new IncomingGroupJoinRequestListener() {
-			@Override
-			public void onReceived(IncomingGroupJoinRequestModel incomingGroupJoinRequestModel, GroupModel groupModel) {
-				NotificationService notificationService = serviceManager.getNotificationService();
+        ListenerManager.incomingGroupJoinRequestListener.add(new IncomingGroupJoinRequestListener() {
+            @Override
+            public void onReceived(IncomingGroupJoinRequestModel incomingGroupJoinRequestModel, GroupModel groupModel) {
+                NotificationService notificationService = serviceManager.getNotificationService();
                 notificationService.showGroupJoinRequestNotification(incomingGroupJoinRequestModel, groupModel);
             }
 
-			@Override
-			public void onRespond() {
-				// don't bother here
-			}
-		});
+            @Override
+            public void onRespond() {
+                // don't bother here
+            }
+        });
 
-		ListenerManager.serverMessageListeners.add(new ServerMessageListener() {
-			@Override
-			public void onAlert(ServerMessageModel serverMessage) {
-				NotificationService notificationService = serviceManager.getNotificationService();
+        ListenerManager.serverMessageListeners.add(new ServerMessageListener() {
+            @Override
+            public void onAlert(ServerMessageModel serverMessage) {
+                NotificationService notificationService = serviceManager.getNotificationService();
                 notificationService.showServerMessage(serverMessage);
             }
 
-			@Override
-			public void onError(ServerMessageModel serverMessage) {
-				NotificationService notificationService = serviceManager.getNotificationService();
+            @Override
+            public void onError(ServerMessageModel serverMessage) {
+                NotificationService notificationService = serviceManager.getNotificationService();
                 notificationService.showServerMessage(serverMessage);
             }
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
 		ListenerManager.contactListeners.add(new ContactListener() {
 			@Override
@@ -1544,252 +1475,240 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 				if (modifiedContactModel == null) {
 					return;
 				}
-				if (modifiedContactModel.getAcquaintanceLevel() == ContactModel.AcquaintanceLevel.GROUP) {
-					this.onRemoved(modifiedContactModel.getIdentity());
-					return;
-				}
 				new Thread(() -> {
 					try {
 						final ConversationService conversationService = serviceManager.getConversationService();
 						final ContactService contactService = serviceManager.getContactService();
 
-						// Remove contact from cache
-						contactService.removeFromCache(identity);
+                        // Remove contact from cache
+                        contactService.removeFromCache(identity);
 
-						// Refresh conversation cache
-						conversationService.updateContactConversation(modifiedContactModel);
-						conversationService.refresh(modifiedContactModel);
+                        // Refresh conversation cache
+                        conversationService.updateContactConversation(modifiedContactModel);
+                        conversationService.refresh(modifiedContactModel);
 
-						ShortcutUtil.updatePinnedShortcut(contactService.createReceiver(modifiedContactModel));
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+                        ShortcutUtil.updatePinnedShortcut(contactService.createReceiver(modifiedContactModel));
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
 			@Override
-			public void onAvatarChanged(ContactModel contactModel) {
+			public void onAvatarChanged(final @NonNull String identity) {
 				new Thread(() -> {
 					try {
-						ShortcutUtil.updatePinnedShortcut(serviceManager.getContactService().createReceiver(contactModel));
+                        ContactService contactService = serviceManager.getContactService();
+                        ContactModel contactModel = contactService.getByIdentity(identity);
+                        if (contactModel != null) {
+                            ShortcutUtil.updatePinnedShortcut(contactService.createReceiver(contactModel));
+                        }
 					} catch (ThreemaException e) {
 						logger.error("Exception", e);
 					}
 				}).start();
 			}
-
-			@Override
-			public void onRemoved(@NonNull final String identity) {
-				new Thread(() -> {
-					try {
-						// Remove stale contact model from contact service cache
-						serviceManager.getContactService().removeFromCache(identity);
-
-						// Empty and delete associated conversation
-						serviceManager.getConversationService().delete(identity);
-
-						// Cancel notifications
-						serviceManager.getNotificationService().cancel(identity);
-
-						// Remove custom avatar (ANDR-353)
-						FileService f = serviceManager.getFileService();
-						f.removeContactAvatar(identity);
-						f.removeContactPhoto(identity);
-					} catch (ThreemaException e) {
-						logger.error("Error while handling removed contact", e);
-					}
-				}).start();
-			}
 		}, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.contactSettingsListeners.add(new ContactSettingsListener() {
-			@Override
-			public void onSortingChanged() {
-				//do nothing!
-			}
+        ListenerManager.contactSettingsListeners.add(new ContactSettingsListener() {
+            @Override
+            public void onSortingChanged() {
+                //do nothing!
+            }
 
-			@Override
-			public void onNameFormatChanged() {
-				//do nothing
-			}
+            @Override
+            public void onNameFormatChanged() {
+                //do nothing
+            }
 
 			@Override
 			public void onAvatarSettingChanged() {
 				//reset the avatar cache!
 				if (serviceManager != null) {
 					try {
-						AvatarCacheService avatarCacheService = null;
-						avatarCacheService = serviceManager.getAvatarCacheService();
-                        avatarCacheService.clear();
-                    } catch (FileSystemNotPresentException e) {
+						AvatarCacheService s = serviceManager.getAvatarCacheService();
+						s.clear();
+					} catch (FileSystemNotPresentException e) {
 						logger.error("Exception", e);
 					}
 				}
 			}
 
-			@Override
-			public void onInactiveContactsSettingChanged() {
+            @Override
+            public void onInactiveContactsSettingChanged() {
 
-			}
+            }
 
-			@Override
-			public void onNotificationSettingChanged(String uid) {
+            @Override
+            public void onNotificationSettingChanged(String uid) {
 
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.conversationListeners.add(new ConversationListener() {
-			@Override
-			public void onNew(ConversationModel conversationModel) {}
+        ListenerManager.conversationListeners.add(new ConversationListener() {
+            @Override
+            public void onNew(ConversationModel conversationModel) {
+            }
 
-			@Override
-			public void onModified(ConversationModel modifiedConversationModel, Integer oldPosition) {}
+            @Override
+            public void onModified(ConversationModel modifiedConversationModel, Integer oldPosition) {
+            }
 
 			@Override
 			public void onRemoved(ConversationModel conversationModel) {
 				//remove notification!
 				NotificationService notificationService = serviceManager.getNotificationService();
-                notificationService.cancel(conversationModel);
-            }
+				notificationService.cancel(conversationModel);
+			}
 
-			@Override
-			public void onModifiedAll() {}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onModifiedAll() {
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.ballotVoteListeners.add(new BallotVoteListener() {
-			@Override
-			public void onSelfVote(BallotModel ballotModel) { }
+        ListenerManager.ballotVoteListeners.add(new BallotVoteListener() {
+            @Override
+            public void onSelfVote(BallotModel ballotModel) {
+            }
 
-			@Override
-			public void onVoteChanged(BallotModel ballotModel, String votingIdentity, boolean isFirstVote) {
-				//add group state
+            @Override
+            public void onVoteChanged(BallotModel ballotModel, String votingIdentity, boolean isFirstVote) {
+                //add group state
 
-				//DISABLED
-				ServiceManager s = ThreemaApplication.getServiceManager();
-				if(s != null) {
-					try {
-						BallotService ballotService = s.getBallotService();
-						ContactService contactService = s.getContactService();
-						GroupService groupService = s.getGroupService();
-						MessageService messageService = s.getMessageService();
-						UserService userService = s.getUserService();
-
-						if(TestUtil.required(ballotModel, contactService, groupService, messageService, userService)
-								//disabled, show status message at every participant
-								/*&& BallotUtil.isMine(ballotModel, userService)*/) {
-							LinkBallotModel b = ballotService.getLinkedBallotModel(ballotModel);
-							if(b != null) {
-								GroupStatusDataModel.GroupStatusType type = null;
-								MessageReceiver<? extends AbstractMessageModel> receiver = null;
-								if (b instanceof GroupBallotModel) {
-									GroupModel groupModel = groupService.getById(((GroupBallotModel) b).getGroupId());
-
-									//its a group ballot,write status
-									receiver = groupService.createReceiver(groupModel);
-									// reset archived status
-									groupService.setIsArchived(groupModel, false);
-
-								} else if (b instanceof IdentityBallotModel) {
-									String identity = ((IdentityBallotModel) b).getIdentity();
-
-									//not implemented
-									receiver = contactService.createReceiver(contactService.getByIdentity(identity));
-									// reset archived status
-									contactService.setIsArchived(identity, false);
-								}
-
-								if (ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE) {
-									// Only show status message for first vote from a voter on private voting
-									if (isFirstVote) {
-										// On private voting, only show default update msg!
-										type = GroupStatusDataModel.GroupStatusType.RECEIVED_VOTE;
-									}
-								} else if (receiver != null) {
-									if (isFirstVote) {
-										type = GroupStatusDataModel.GroupStatusType.FIRST_VOTE;
-									} else {
-										type = GroupStatusDataModel.GroupStatusType.MODIFIED_VOTE;
-									}
-								}
-
-								if (type != null && receiver instanceof GroupMessageReceiver) {
-									messageService.createGroupStatus(
-										(GroupMessageReceiver) receiver,
-										type,
-										votingIdentity,
-										ballotModel.getName(),
-										null
-									);
-								}
-
-								//now check if every participant has voted
-								if (isFirstVote
-									&& ballotService.getPendingParticipants(ballotModel.getId()).isEmpty()
-									&& receiver instanceof GroupMessageReceiver
-								) {
-									messageService.createGroupStatus(
-										(GroupMessageReceiver) receiver,
-										GroupStatusDataModel.GroupStatusType.VOTES_COMPLETE,
-										null,
-										ballotModel.getName(),
-										null
-									);
-								}
-							}
-						}
-					} catch (ThreemaException x) {
-						logger.error("Exception", x);
-					}
-				}
-			}
+                //DISABLED
+                ServiceManager s = ThreemaApplication.getServiceManager();
+                if (s != null) {
+                    try {
+                        BallotService ballotService = s.getBallotService();
+                        ContactService contactService = s.getContactService();
+                        GroupService groupService = s.getGroupService();
+                        MessageService messageService = s.getMessageService();
+                        UserService userService = s.getUserService();
+
+                        if (TestUtil.required(ballotModel, contactService, groupService, messageService, userService)) {
+                            LinkBallotModel linkBallotModel = ballotService.getLinkedBallotModel(ballotModel);
+                            if (linkBallotModel != null) {
+                                GroupStatusDataModel.GroupStatusType type = null;
+                                MessageReceiver<? extends AbstractMessageModel> receiver = null;
+                                if (linkBallotModel instanceof GroupBallotModel) {
+                                    GroupModel groupModel = groupService.getById(((GroupBallotModel) linkBallotModel).getGroupId());
+
+                                    // its a group ballot,write status
+                                    receiver = groupService.createReceiver(groupModel);
+                                    // reset archived status
+                                    groupService.setIsArchived(groupModel, false);
+
+                                } else if (linkBallotModel instanceof IdentityBallotModel) {
+                                    String identity = ((IdentityBallotModel) linkBallotModel).getIdentity();
+
+                                    // not implemented
+                                    receiver = contactService.createReceiver(contactService.getByIdentity(identity));
+                                    // reset archived status
+                                    contactService.setIsArchived(identity, false);
+                                }
+
+                                if (ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE) {
+                                    // Only show status message for first vote from a voter on private voting
+                                    if (isFirstVote) {
+                                        // On private voting, only show default update msg!
+                                        type = GroupStatusDataModel.GroupStatusType.RECEIVED_VOTE;
+                                    }
+                                } else if (receiver != null) {
+                                    if (isFirstVote) {
+                                        type = GroupStatusDataModel.GroupStatusType.FIRST_VOTE;
+                                    } else {
+                                        type = GroupStatusDataModel.GroupStatusType.MODIFIED_VOTE;
+                                    }
+                                }
+
+                                if (
+                                    linkBallotModel instanceof GroupBallotModel
+                                        && (type == GroupStatusDataModel.GroupStatusType.FIRST_VOTE
+                                        || type == GroupStatusDataModel.GroupStatusType.MODIFIED_VOTE)
+                                        && !BallotUtil.isMine(ballotModel, userService)
+                                ) {
+                                    // Only show votes (and vote changes) to the creator of the ballot in a group
+                                    return;
+                                }
+
+                                if (type != null && receiver instanceof GroupMessageReceiver) {
+                                    messageService.createGroupStatus(
+                                        (GroupMessageReceiver) receiver,
+                                        type,
+                                        votingIdentity,
+                                        ballotModel.getName(),
+                                        null
+                                    );
+                                }
+
+                                // now check if every participant has voted
+                                if (isFirstVote
+                                    && ballotService.getPendingParticipants(ballotModel.getId()).isEmpty()
+                                    && receiver instanceof GroupMessageReceiver
+                                ) {
+                                    messageService.createGroupStatus(
+                                        (GroupMessageReceiver) receiver,
+                                        GroupStatusDataModel.GroupStatusType.VOTES_COMPLETE,
+                                        null,
+                                        ballotModel.getName(),
+                                        null
+                                    );
+                                }
+                            }
+                        }
+                    } catch (ThreemaException x) {
+                        logger.error("Exception", x);
+                    }
+                }
+            }
 
-			@Override
-			public void onVoteRemoved(BallotModel ballotModel, String votingIdentity) {
-				//ignore
-			}
+            @Override
+            public void onVoteRemoved(BallotModel ballotModel, String votingIdentity) {
+                //ignore
+            }
 
-			@Override
-			public boolean handle(BallotModel ballotModel) {
-				//handle all
-				return true;
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public boolean handle(BallotModel ballotModel) {
+                //handle all
+                return true;
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		final ContentObserver contentObserverChangeContactNames = new ContentObserver(null) {
-			private boolean isRunning = false;
+        final ContentObserver contentObserverChangeContactNames = new ContentObserver(null) {
+            private boolean isRunning = false;
 
-			@Override
-			public boolean deliverSelfNotifications() {
-				return super.deliverSelfNotifications();
-			}
+            @Override
+            public boolean deliverSelfNotifications() {
+                return super.deliverSelfNotifications();
+            }
 
-			@Override
-			public void onChange(boolean selfChange) {
-				super.onChange(selfChange);
+            @Override
+            public void onChange(boolean selfChange) {
+                super.onChange(selfChange);
 
-				if (!selfChange && serviceManager != null && !isRunning) {
-					this.isRunning = true;
-					onAndroidContactChangeLock.lock();
+                if (!selfChange && serviceManager != null && !isRunning) {
+                    this.isRunning = true;
+                    onAndroidContactChangeLock.lock();
 
-					boolean cont;
-					//check if a sync is in progress.. wait!
-					try {
-						SynchronizeContactsService synchronizeContactService = serviceManager.getSynchronizeContactsService();
-						cont = !synchronizeContactService.isSynchronizationInProgress();
-					} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
-						logger.error("Exception", e);
-						//do nothing
-						cont = false;
-					}
+                    boolean cont;
+                    //check if a sync is in progress.. wait!
+                    try {
+                        SynchronizeContactsService synchronizeContactService = serviceManager.getSynchronizeContactsService();
+                        cont = !synchronizeContactService.isSynchronizationInProgress();
+                    } catch (MasterKeyLockedException | FileSystemNotPresentException e) {
+                        logger.error("Exception", e);
+                        //do nothing
+                        cont = false;
+                    }
 
 					if (cont) {
 						PreferenceService preferencesService = serviceManager.getPreferenceService();
 						if (preferencesService.isSyncContacts()) {
 							try {
 								ContactService c = serviceManager.getContactService();
-                                //update contact names if changed!
-                                c.updateAllContactNamesFromAndroidContacts();
-                            } catch (MasterKeyLockedException | FileSystemNotPresentException e) {
+								//update contact names if changed!
+								c.updateAllContactNamesFromAndroidContacts();
+							} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
 								logger.error("Exception", e);
 							}
 						}
@@ -1800,288 +1719,277 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 			}
 		};
 
-		ListenerManager.synchronizeContactsListeners.add(new SynchronizeContactsListener() {
-			@Override
-			public void onStarted(SynchronizeContactsRoutine startedRoutine) {
-				//disable contact observer
-				serviceManager.getContext().getContentResolver().unregisterContentObserver(contentObserverChangeContactNames);
-			}
+        ListenerManager.synchronizeContactsListeners.add(new SynchronizeContactsListener() {
+            @Override
+            public void onStarted(SynchronizeContactsRoutine startedRoutine) {
+                //disable contact observer
+                serviceManager.getContext().getContentResolver().unregisterContentObserver(contentObserverChangeContactNames);
+            }
 
-			@Override
-			public void onFinished(SynchronizeContactsRoutine finishedRoutine) {
-				//enable contact observer
-				serviceManager.getContext().getContentResolver().registerContentObserver(
-						ContactsContract.Contacts.CONTENT_URI,
-						false,
-						contentObserverChangeContactNames);
-			}
+            @Override
+            public void onFinished(SynchronizeContactsRoutine finishedRoutine) {
+                //enable contact observer
+                serviceManager.getContext().getContentResolver().registerContentObserver(
+                    ContactsContract.Contacts.CONTENT_URI,
+                    false,
+                    contentObserverChangeContactNames);
+            }
 
-			@Override
-			public void onError(SynchronizeContactsRoutine finishedRoutine) {
-				//enable contact observer
-				serviceManager.getContext().getContentResolver().registerContentObserver(
-						ContactsContract.Contacts.CONTENT_URI,
-						false,
-						contentObserverChangeContactNames);
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onError(SynchronizeContactsRoutine finishedRoutine) {
+                //enable contact observer
+                serviceManager.getContext().getContentResolver().registerContentObserver(
+                    ContactsContract.Contacts.CONTENT_URI,
+                    false,
+                    contentObserverChangeContactNames);
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.contactTypingListeners.add(new ContactTypingListener() {
-			@Override
-			public void onContactIsTyping(ContactModel fromContact, boolean isTyping) {
-				//update the conversations
-				try {
-					serviceManager.getConversationService()
-							.setIsTyping(fromContact, isTyping);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
+		ListenerManager.contactTypingListeners.add((fromContact, isTyping) -> {
+			//update the conversations
+			try {
+				serviceManager.getConversationService()
+						.setIsTyping(fromContact, isTyping);
+			} catch (ThreemaException e) {
+				logger.error("Exception", e);
 			}
 		});
 
-		ListenerManager.newSyncedContactListener.add(new NewSyncedContactsListener() {
-			@Override
-			public void onNew(List<ContactModel> contactModels) {
-				NotificationService notificationService = serviceManager.getNotificationService();
-				notificationService.showNewSyncedContactsNotification(contactModels);
-			}
+		ListenerManager.newSyncedContactListener.add(contactModels -> {
+			NotificationService notificationService = serviceManager.getNotificationService();
+			notificationService.showNewSyncedContactsNotification(contactModels);
 		});
 
-		WebClientListenerManager.serviceListener.add(new WebClientServiceListener() {
-			@Override
-			public void onEnabled() {
-				SessionWakeUpServiceImpl.getInstance()
-					.processPendingWakeupsAsync();
-			}
+        WebClientListenerManager.serviceListener.add(new WebClientServiceListener() {
+            @Override
+            public void onEnabled() {
+                SessionWakeUpServiceImpl.getInstance()
+                    .processPendingWakeupsAsync();
+            }
 
-			@Override
-			public void onStarted(
-				@NonNull final WebClientSessionModel model,
-				@NonNull final byte[] permanentKey,
-				@NonNull final String browser
-			) {
-				logger.info( "WebClientListenerManager: onStarted", true);
-
-				RuntimeUtil.runOnUiThread(() -> {
-					String toastText = getAppContext().getString(R.string.webclient_new_connection_toast);
-					if(model.getLabel() != null) {
-						toastText += " (" + model.getLabel() +")";
-					}
-					Toast.makeText(getAppContext(), toastText, Toast.LENGTH_LONG).show();
-
-					final Intent intent = new Intent(context, SessionAndroidService.class);
-
-					if (SessionAndroidService.isRunning()) {
-						intent.setAction(SessionAndroidService.ACTION_UPDATE);
-						logger.info( "sending ACTION_UPDATE to SessionAndroidService");
-						context.startService(intent);
-					} else {
-						logger.info( "SessionAndroidService not running...starting");
-						intent.setAction(SessionAndroidService.ACTION_START);
-						logger.info( "sending ACTION_START to SessionAndroidService");
-						if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
-							// Starting on version S, foreground services cannot be started from the background.
-							// When battery optimizations are disabled (recommended for Threema Web), then no
-							// exception is thrown. Otherwise we just log it.
-							try {
-								ContextCompat.startForegroundService(context, intent);
-							} catch (ForegroundServiceStartNotAllowedException exception) {
-								logger.error("Couldn't start foreground service", exception);
-							}
-						} else {
-							ContextCompat.startForegroundService(context, intent);
-						}
-					}
-				});
-			}
+            @Override
+            public void onStarted(
+                @NonNull final WebClientSessionModel model,
+                @NonNull final byte[] permanentKey,
+                @NonNull final String browser
+            ) {
+                logger.info("WebClientListenerManager: onStarted", true);
+
+                RuntimeUtil.runOnUiThread(() -> {
+                    String toastText = getAppContext().getString(R.string.webclient_new_connection_toast);
+                    if (model.getLabel() != null) {
+                        toastText += " (" + model.getLabel() + ")";
+                    }
+                    Toast.makeText(getAppContext(), toastText, Toast.LENGTH_LONG).show();
+
+                    final Intent intent = new Intent(context, SessionAndroidService.class);
+
+                    if (SessionAndroidService.isRunning()) {
+                        intent.setAction(SessionAndroidService.ACTION_UPDATE);
+                        logger.info("sending ACTION_UPDATE to SessionAndroidService");
+                        context.startService(intent);
+                    } else {
+                        logger.info("SessionAndroidService not running...starting");
+                        intent.setAction(SessionAndroidService.ACTION_START);
+                        logger.info("sending ACTION_START to SessionAndroidService");
+                        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
+                            // Starting on version S, foreground services cannot be started from the background.
+                            // When battery optimizations are disabled (recommended for Threema Web), then no
+                            // exception is thrown. Otherwise we just log it.
+                            try {
+                                ContextCompat.startForegroundService(context, intent);
+                            } catch (ForegroundServiceStartNotAllowedException exception) {
+                                logger.error("Couldn't start foreground service", exception);
+                            }
+                        } else {
+                            ContextCompat.startForegroundService(context, intent);
+                        }
+                    }
+                });
+            }
 
-			@Override
-			public void onStateChanged(
-				@NonNull final WebClientSessionModel model,
-				@NonNull final WebClientSessionState oldState,
-				@NonNull final WebClientSessionState newState
-			) {
-				logger.info( "WebClientListenerManager: onStateChanged");
-
-				if (newState == WebClientSessionState.DISCONNECTED) {
-					RuntimeUtil.runOnUiThread(() -> {
-						logger.info("updating SessionAndroidService");
-						if (SessionAndroidService.isRunning()) {
-							final Intent intent = new Intent(context, SessionAndroidService.class);
-							intent.setAction(SessionAndroidService.ACTION_UPDATE);
-							logger.info("sending ACTION_UPDATE to SessionAndroidService");
-							context.startService(intent);
-						} else {
-							logger.info("SessionAndroidService not running...not updating");
-						}
-					});
-				}
-			}
+            @Override
+            public void onStateChanged(
+                @NonNull final WebClientSessionModel model,
+                @NonNull final WebClientSessionState oldState,
+                @NonNull final WebClientSessionState newState
+            ) {
+                logger.info("WebClientListenerManager: onStateChanged");
+
+                if (newState == WebClientSessionState.DISCONNECTED) {
+                    RuntimeUtil.runOnUiThread(() -> {
+                        logger.info("updating SessionAndroidService");
+                        if (SessionAndroidService.isRunning()) {
+                            final Intent intent = new Intent(context, SessionAndroidService.class);
+                            intent.setAction(SessionAndroidService.ACTION_UPDATE);
+                            logger.info("sending ACTION_UPDATE to SessionAndroidService");
+                            context.startService(intent);
+                        } else {
+                            logger.info("SessionAndroidService not running...not updating");
+                        }
+                    });
+                }
+            }
 
-			@Override
-			public void onStopped(@NonNull final WebClientSessionModel model, @NonNull final DisconnectContext reason) {
-				logger.info( "WebClientListenerManager: onStopped");
-
-				RuntimeUtil.runOnUiThread(() -> {
-					if (SessionAndroidService.isRunning()) {
-						final Intent intent = new Intent(context, SessionAndroidService.class);
-						intent.setAction(SessionAndroidService.ACTION_STOP);
-						logger.info( "sending ACTION_STOP to SessionAndroidService");
-						context.startService(intent);
-					} else {
-						logger.info( "SessionAndroidService not running...not stopping");
-					}
-				});
-			}
-		});
+            @Override
+            public void onStopped(@NonNull final WebClientSessionModel model, @NonNull final DisconnectContext reason) {
+                logger.info("WebClientListenerManager: onStopped");
+
+                RuntimeUtil.runOnUiThread(() -> {
+                    if (SessionAndroidService.isRunning()) {
+                        final Intent intent = new Intent(context, SessionAndroidService.class);
+                        intent.setAction(SessionAndroidService.ACTION_STOP);
+                        logger.info("sending ACTION_STOP to SessionAndroidService");
+                        context.startService(intent);
+                    } else {
+                        logger.info("SessionAndroidService not running...not stopping");
+                    }
+                });
+            }
+        });
 
 		//called if a fcm message with a newer session received
-		WebClientListenerManager.wakeUpListener.add(new WebClientWakeUpListener() {
-			@Override
-			public void onProtocolError() {
-				RuntimeUtil.runOnUiThread(
-					() -> Toast.makeText(getAppContext(), R.string.webclient_protocol_version_to_old, Toast.LENGTH_LONG).show()
-				);
-			}
-		});
-
-		VoipListenerManager.callEventListener.add(new VoipCallEventListener() {
-			private final Logger logger = LoggingUtil.getThreemaLogger("VoipCallEventListener");
-
-			@Override
-			public void onRinging(String peerIdentity) {
-				this.logger.debug("onRinging {}", peerIdentity);
-			}
-
-			@Override
-			public void onStarted(String peerIdentity, boolean outgoing) {
-				final String direction = outgoing ? "to" : "from";
-				this.logger.info("Call {} {} started", direction, peerIdentity);
-			}
-
-			@Override
-			public void onFinished(long callId, @NonNull String peerIdentity, boolean outgoing, int duration) {
-				final String direction = outgoing ? "to" : "from";
-				this.logger.info("Call {} {} finished", direction, peerIdentity);
-				this.saveStatus(peerIdentity,
-						outgoing,
-						VoipStatusDataModel.createFinished(callId, duration),
-						true);
-			}
-
-			@Override
-			public void onRejected(long callId, String peerIdentity, boolean outgoing, byte reason) {
-				final String direction = outgoing ? "to" : "from";
-				this.logger.info("Call {} {} rejected (reason {})", direction, peerIdentity, reason);
-				this.saveStatus(peerIdentity,
-						// on rejected incoming, the outgoing was rejected!
-						!outgoing,
-						VoipStatusDataModel.createRejected(callId, reason),
-						true);
-			}
-
-			@Override
-			public void onMissed(long callId, String peerIdentity, boolean accepted, @Nullable Date date) {
-				this.logger.info("Call from {} missed", peerIdentity);
-				this.saveStatus(peerIdentity,
-						false,
-						VoipStatusDataModel.createMissed(callId, date),
-						accepted);
-			}
+		WebClientListenerManager.wakeUpListener.add(() -> RuntimeUtil.runOnUiThread(
+			() -> Toast.makeText(getAppContext(), R.string.webclient_protocol_version_to_old, Toast.LENGTH_LONG).show()
+		));
 
-			@Override
-			public void onAborted(long callId, String peerIdentity) {
-				this.logger.info("Call to {} aborted", peerIdentity);
-				this.saveStatus(peerIdentity,
-						true,
-						VoipStatusDataModel.createAborted(callId),
-						true);
-			}
+        VoipListenerManager.callEventListener.add(new VoipCallEventListener() {
+            private final Logger logger = LoggingUtil.getThreemaLogger("VoipCallEventListener");
 
-			private void saveStatus(
-				@NonNull String identity,
-				boolean isOutbox,
-				@NonNull VoipStatusDataModel status,
-				boolean isRead
-			) {
-				try {
-					// Services
-					if (serviceManager == null) {
-						this.logger.error("Could not save voip status, servicemanager is null");
-						return;
-					}
-					final IdentityStore identityStore = serviceManager.getIdentityStore();
-					final ContactService contactService = serviceManager.getContactService();
-					final MessageService messageService = serviceManager.getMessageService();
-
-					// If an incoming status message is not targeted at our own identity, something's wrong
-					final String appIdentity = identityStore.getIdentity();
-					if (TestUtil.compare(identity, appIdentity) && !isOutbox) {
-						this.logger.error("Could not save voip status (identity={}, appIdentity={}, outbox={})", identity, appIdentity, isOutbox);
-						return;
-					}
-
-					// Create status message
-					final ContactModel contactModel = contactService.getByIdentity(identity);
-					final ContactMessageReceiver receiver = contactService.createReceiver(contactModel);
-					messageService.createVoipStatus(status, receiver, isOutbox, isRead);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
-
-		if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.M || ContextCompat.checkSelfPermission(serviceManager.getContext(), android.Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) {
-			serviceManager.getContext().getContentResolver()
-					.registerContentObserver(ContactsContract.Contacts.CONTENT_URI,
-							false,
-							contentObserverChangeContactNames);
-		}
-	}
-
-	public static boolean activityResumed(Activity currentActivity) {
-		logger.debug("*** App ActivityResumed");
-		if (serviceManager != null) {
-			serviceManager.getActivityService().resume(currentActivity);
-			return true;
-		}
-		return false;
-	}
+            @Override
+            public void onRinging(String peerIdentity) {
+                this.logger.debug("onRinging {}", peerIdentity);
+            }
 
-	public static void activityPaused(Activity pausedActivity) {
-		logger.debug("*** App ActivityPaused");
-		if (serviceManager != null) {
-			serviceManager.getActivityService().pause(pausedActivity);
-		}
-	}
+            @Override
+            public void onStarted(String peerIdentity, boolean outgoing) {
+                final String direction = outgoing ? "to" : "from";
+                this.logger.info("Call {} {} started", direction, peerIdentity);
+            }
 
-	public static void activityDestroyed(Activity destroyedActivity) {
-		logger.debug("*** App ActivityDestroyed");
-		if (serviceManager != null) {
-			serviceManager.getActivityService().destroy(destroyedActivity);
-		}
-	}
+            @Override
+            public void onFinished(long callId, @NonNull String peerIdentity, boolean outgoing, int duration) {
+                final String direction = outgoing ? "to" : "from";
+                this.logger.info("Call {} {} finished", direction, peerIdentity);
+                this.saveStatus(peerIdentity,
+                    outgoing,
+                    VoipStatusDataModel.createFinished(callId, duration),
+                    true);
+            }
 
-	public static boolean activityUserInteract(Activity interactedActivity) {
-		if (serviceManager != null) {
-			serviceManager.getActivityService().userInteract(interactedActivity);
-		}
-		return true;
-	}
+            @Override
+            public void onRejected(long callId, String peerIdentity, boolean outgoing, byte reason) {
+                final String direction = outgoing ? "to" : "from";
+                this.logger.info("Call {} {} rejected (reason {})", direction, peerIdentity, reason);
+                this.saveStatus(peerIdentity,
+                    // on rejected incoming, the outgoing was rejected!
+                    !outgoing,
+                    VoipStatusDataModel.createRejected(callId, reason),
+                    true);
+            }
 
-	public static Date getLastLoggedIn() {
-		return lastLoggedIn;
-	}
+            @Override
+            public void onMissed(long callId, String peerIdentity, boolean accepted, @Nullable Date date) {
+                this.logger.info("Call from {} missed", peerIdentity);
+                this.saveStatus(peerIdentity,
+                    false,
+                    VoipStatusDataModel.createMissed(callId, date),
+                    accepted);
+            }
 
-	public static boolean isIsDeviceIdle() {
-		return isDeviceIdle;
-	}
+            @Override
+            public void onAborted(long callId, String peerIdentity) {
+                this.logger.info("Call to {} aborted", peerIdentity);
+                this.saveStatus(peerIdentity,
+                    true,
+                    VoipStatusDataModel.createAborted(callId),
+                    true);
+            }
 
-	public static AppVersion getAppVersion() {
-		return appVersion;
-	}
+            private void saveStatus(
+                @NonNull String identity,
+                boolean isOutbox,
+                @NonNull VoipStatusDataModel status,
+                boolean isRead
+            ) {
+                try {
+                    // Services
+                    if (serviceManager == null) {
+                        this.logger.error("Could not save voip status, servicemanager is null");
+                        return;
+                    }
+                    final IdentityStore identityStore = serviceManager.getIdentityStore();
+                    final ContactService contactService = serviceManager.getContactService();
+                    final MessageService messageService = serviceManager.getMessageService();
+
+                    // If an incoming status message is not targeted at our own identity, something's wrong
+                    final String appIdentity = identityStore.getIdentity();
+                    if (TestUtil.compare(identity, appIdentity) && !isOutbox) {
+                        this.logger.error("Could not save voip status (identity={}, appIdentity={}, outbox={})", identity, appIdentity, isOutbox);
+                        return;
+                    }
 
-	public static Context getAppContext() {
-		return ThreemaApplication.context;
-	}
+                    // Create status message
+                    final ContactModel contactModel = contactService.getByIdentity(identity);
+                    final ContactMessageReceiver receiver = contactService.createReceiver(contactModel);
+                    messageService.createVoipStatus(status, receiver, isOutbox, isRead);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
+
+        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.M || ContextCompat.checkSelfPermission(serviceManager.getContext(), android.Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) {
+            serviceManager.getContext().getContentResolver()
+                .registerContentObserver(ContactsContract.Contacts.CONTENT_URI,
+                    false,
+                    contentObserverChangeContactNames);
+        }
+    }
+
+    public static boolean activityResumed(Activity currentActivity) {
+        logger.debug("*** App ActivityResumed");
+        if (serviceManager != null) {
+            serviceManager.getActivityService().resume(currentActivity);
+            return true;
+        }
+        return false;
+    }
+
+    public static void activityPaused(Activity pausedActivity) {
+        logger.debug("*** App ActivityPaused");
+        if (serviceManager != null) {
+            serviceManager.getActivityService().pause(pausedActivity);
+        }
+    }
+
+    public static void activityDestroyed(Activity destroyedActivity) {
+        logger.debug("*** App ActivityDestroyed");
+        if (serviceManager != null) {
+            serviceManager.getActivityService().destroy(destroyedActivity);
+        }
+    }
+
+    public static boolean activityUserInteract(Activity interactedActivity) {
+        if (serviceManager != null) {
+            serviceManager.getActivityService().userInteract(interactedActivity);
+        }
+        return true;
+    }
+
+    public static Date getLastLoggedIn() {
+        return lastLoggedIn;
+    }
+
+    public static boolean isIsDeviceIdle() {
+        return isDeviceIdle;
+    }
+
+    public static AppVersion getAppVersion() {
+        return appVersion;
+    }
+
+    public static Context getAppContext() {
+        return ThreemaApplication.context;
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/activities/AddContactActivity.java b/app/src/main/java/ch/threema/app/activities/AddContactActivity.java
index eeed431c..eba8b54d 100644
--- a/app/src/main/java/ch/threema/app/activities/AddContactActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/AddContactActivity.java
@@ -48,14 +48,14 @@ import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
-import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask;
 import ch.threema.app.asynctasks.AlreadyVerified;
-import ch.threema.app.asynctasks.ContactAddResult;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactCreated;
 import ch.threema.app.asynctasks.ContactExists;
 import ch.threema.app.asynctasks.ContactModified;
 import ch.threema.app.asynctasks.Failed;
 import ch.threema.app.asynctasks.PolicyViolation;
-import ch.threema.app.asynctasks.Success;
 import ch.threema.app.dialogs.GenericAlertDialog;
 import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.NewContactDialog;
@@ -74,6 +74,7 @@ import ch.threema.base.utils.Base64;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.api.APIConnector;
+import ch.threema.storage.models.ContactModel;
 
 import static ch.threema.app.services.QRCodeServiceImpl.QR_TYPE_ID;
 import static ch.threema.domain.protocol.csp.ProtocolDefines.IDENTITY_LEN;
@@ -237,8 +238,9 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 			return;
 		}
 
-		backgroundExecutor.execute(new AddOrUpdateContactBackgroundTask(
+		backgroundExecutor.execute(new BasicAddOrUpdateContactBackgroundTask(
 			identity,
+			ContactModel.AcquaintanceLevel.DIRECT,
 			getMyIdentity(),
 			apiConnector,
 			contactModelRepository,
@@ -252,14 +254,14 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 			}
 
 			@Override
-			public void onFinished(@NonNull ContactAddResult result) {
+			public void onFinished(@NonNull ContactResult result) {
 				if (isDestroyed()) {
 					return;
 				}
 
 				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_ADD_PROGRESS, true);
 
-				if (result instanceof Success) {
+				if (result instanceof ContactCreated) {
 					showContactAndFinish(identity, R.string.creating_contact_successful);
 				} else if (result instanceof ContactModified) {
 					if (((ContactModified) result).getAcquaintanceLevelChanged()) {
@@ -271,6 +273,9 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 					showContactAndFinish(identity, R.string.scan_duplicate);
 				} else if (result instanceof ContactExists) {
 					showContactAndFinish(identity, R.string.identity_already_exists);
+				} else if (result instanceof PolicyViolation) {
+					Toast.makeText(AddContactActivity.this, R.string.disabled_by_policy_short, Toast.LENGTH_SHORT).show();
+					finish();
 				} else if (result instanceof Failed) {
 					GenericAlertDialog.newInstance(
 						ConfigUtils.isOnPremBuild() ?
@@ -280,9 +285,6 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 						R.string.close,
 						0
 					).show(getSupportFragmentManager(), DIALOG_TAG_ADD_ERROR);
-				} else if (result instanceof PolicyViolation) {
-					Toast.makeText(AddContactActivity.this, R.string.disabled_by_policy_short, Toast.LENGTH_SHORT).show();
-					finish();
 				}
 			}
 		});
diff --git a/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java b/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java
index e001b244..c7cd61d1 100644
--- a/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java
@@ -28,20 +28,32 @@ import android.widget.Toast;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
-import ch.threema.app.asynctasks.AddContactAsyncTask;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.grouplinks.OutgoingGroupRequestActivity;
 import ch.threema.app.services.LockAppService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.HiddenChatUtil;
+import ch.threema.app.utils.LazyProperty;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
+import ch.threema.storage.models.ContactModel;
 
 public class AppLinksActivity extends ThreemaToolbarActivity {
+	private final static Logger logger = LoggingUtil.getThreemaLogger("AppLinksActivity");
 
-    private static final Logger logger = LoggingUtil.getThreemaLogger("AppLinksActivity");
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -91,40 +103,23 @@ public class AppLinksActivity extends ThreemaToolbarActivity {
         finish();
     }
 
-    private void handleContactUrl(String appLinkAction, Uri appLinkData) {
-        logger.info("Handle contact url");
-        final String threemaId = appLinkData.getLastPathSegment();
-        if (threemaId != null) {
-            if (threemaId.equalsIgnoreCase("compose")) {
-                Intent intent = new Intent(this, RecipientListActivity.class);
-                intent.setAction(appLinkAction);
-                intent.setData(appLinkData);
-                startActivity(intent);
-            } else if (threemaId.length() == ProtocolDefines.IDENTITY_LEN) {
-                new AddContactAsyncTask(null, null, threemaId, false, () -> {
-                    String text = appLinkData.getQueryParameter("text");
-
-                    Intent intent = new Intent(this, text != null ?
-                        ComposeMessageActivity.class :
-                        ContactDetailActivity.class);
-                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-                    intent.putExtra(ThreemaApplication.INTENT_DATA_CONTACT, threemaId);
-                    intent.putExtra(ThreemaApplication.INTENT_DATA_EDITFOCUS, Boolean.TRUE);
-
-                    if (text != null) {
-                        text = text.trim();
-                        intent.putExtra(ThreemaApplication.INTENT_DATA_TEXT, text);
-                    }
-
-                    startActivity(intent);
-                }).execute();
-            } else {
-                Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
-            }
-        } else {
-            Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
-        }
-    }
+	private void handleContactUrl(String appLinkAction, Uri appLinkData) {
+		final String threemaId = appLinkData.getLastPathSegment();
+		if (threemaId != null) {
+			if (threemaId.equalsIgnoreCase("compose")) {
+				Intent intent = new Intent(this, RecipientListActivity.class);
+				intent.setAction(appLinkAction);
+				intent.setData(appLinkData);
+				startActivity(intent);
+			} else if (threemaId.length() == ProtocolDefines.IDENTITY_LEN) {
+				addNewContactAndOpenChat(threemaId, appLinkData);
+			} else {
+				Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
+			}
+		} else {
+			Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
+		}
+	}
 
     private void handleGroupLinkUrl(Uri appLinkData) {
         logger.info("Handle group link url");
@@ -139,27 +134,70 @@ public class AppLinksActivity extends ThreemaToolbarActivity {
         overridePendingTransition(0, 0);
     }
 
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        switch (requestCode) {
-            case ThreemaActivity.ACTIVITY_ID_CHECK_LOCK:
-                if (resultCode == RESULT_OK) {
-                    lockAppService.unlock(null);
-                    handleIntent();
-                } else {
-                    Toast.makeText(this, getString(R.string.pin_locked_cannot_send), Toast.LENGTH_LONG).show();
-                    finish();
-                }
-                break;
-            case ThreemaActivity.ACTIVITY_ID_UNLOCK_MASTER_KEY:
-                if (ThreemaApplication.getMasterKey().isLocked()) {
-                    finish();
-                } else {
-                    ConfigUtils.recreateActivity(this, AppLinksActivity.class, getIntent().getExtras());
-                }
-                break;
-            default:
-                super.onActivityResult(requestCode, resultCode, data);
-        }
-    }
+	@Override
+	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+		switch (requestCode) {
+			case ThreemaActivity.ACTIVITY_ID_CHECK_LOCK:
+				if (resultCode == RESULT_OK) {
+					lockAppService.unlock(null);
+					handleIntent();
+				} else {
+					Toast.makeText(this, getString(R.string.pin_locked_cannot_send), Toast.LENGTH_LONG).show();
+					finish();
+				}
+				break;
+			case ThreemaActivity.ACTIVITY_ID_UNLOCK_MASTER_KEY:
+				if (ThreemaApplication.getMasterKey().isLocked()) {
+					finish();
+				} else {
+					ConfigUtils.recreateActivity(this, AppLinksActivity.class, getIntent().getExtras());
+				}
+				break;
+			default:
+				super.onActivityResult(requestCode, resultCode, data);
+		}
+	}
+
+	private void addNewContactAndOpenChat(@NonNull String identity, @NonNull Uri appLinkData) {
+		UserService userService = serviceManager.getUserService();
+		APIConnector apiConnector = serviceManager.getAPIConnector();
+		ContactModelRepository contactModelRepository = serviceManager.getModelRepositories().getContacts();
+
+		backgroundExecutor.get().execute(
+			new BasicAddOrUpdateContactBackgroundTask(
+				identity,
+				ContactModel.AcquaintanceLevel.DIRECT,
+				userService.getIdentity(),
+				apiConnector,
+				contactModelRepository,
+				AddContactRestrictionPolicy.CHECK,
+				AppLinksActivity.this,
+				null
+			) {
+				@Override
+				public void onFinished(ContactResult result) {
+					if (!(result instanceof ContactAvailable)) {
+						logger.error("Could not add contact");
+						return;
+					}
+
+					String text = appLinkData.getQueryParameter("text");
+
+					Intent intent = new Intent(AppLinksActivity.this, text != null ?
+						ComposeMessageActivity.class :
+						ContactDetailActivity.class);
+					intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+					intent.putExtra(ThreemaApplication.INTENT_DATA_CONTACT, identity);
+					intent.putExtra(ThreemaApplication.INTENT_DATA_EDITFOCUS, Boolean.TRUE);
+
+					if (text != null) {
+						text = text.trim();
+						intent.putExtra(ThreemaApplication.INTENT_DATA_TEXT, text);
+					}
+
+					startActivity(intent);
+				}
+			}
+		);
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java b/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java
index faca71ca..1f424826 100644
--- a/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java
@@ -28,7 +28,6 @@ import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.graphics.Color;
 import android.graphics.PorterDuff;
-import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
@@ -46,9 +45,11 @@ import com.google.android.material.floatingactionbutton.FloatingActionButton;
 import org.slf4j.Logger;
 
 import java.io.File;
+import java.lang.ref.WeakReference;
 import java.util.Date;
 import java.util.List;
 import java.util.Objects;
+import java.util.Set;
 
 import androidx.annotation.ColorInt;
 import androidx.annotation.NonNull;
@@ -64,9 +65,19 @@ import androidx.recyclerview.widget.RecyclerView;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.adapters.ContactDetailAdapter;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.AlreadyVerified;
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy;
+import ch.threema.app.asynctasks.ContactModified;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactSyncPolicy;
+import ch.threema.app.asynctasks.DeleteContactServices;
+import ch.threema.app.asynctasks.DialogMarkContactAsDeletedBackgroundTask;
+import ch.threema.app.asynctasks.Failed;
+import ch.threema.app.asynctasks.LocalPublicKeyMismatch;
 import ch.threema.app.dialogs.ContactEditDialog;
 import ch.threema.app.dialogs.GenericAlertDialog;
-import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.SimpleStringAlertDialog;
 import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.listeners.ContactSettingsListener;
@@ -87,7 +98,7 @@ import ch.threema.app.utils.AndroidContactUtil;
 import ch.threema.app.utils.AppRestrictionUtil;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ContactUtil;
-import ch.threema.app.utils.DialogUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.LogUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.QRScannerUtil;
@@ -95,11 +106,13 @@ import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShareUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.ViewUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.services.VoipStateService;
 import ch.threema.app.voip.util.VoipUtil;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.data.repositories.ModelRepositories;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.storage.models.ContactModel;
@@ -116,7 +129,6 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	private static final String DIALOG_TAG_EDIT = "cedit";
 	private static final String DIALOG_TAG_DELETE_CONTACT = "deleteContact";
 	private static final String DIALOG_TAG_EXCLUDE_CONTACT = "excludeContact";
-	private static final String DIALOG_TAG_DELETING_CONTACT = "dliC";
 	private static final String DIALOG_TAG_ADD_CONTACT = "dac";
 	private static final String DIALOG_TAG_CONFIRM_BLOCK = "block";
 
@@ -129,15 +141,20 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 
 	// Services
 	private ContactService contactService;
+	private ContactModelRepository contactModelRepository;
 	private GroupService groupService;
 	private IdListService blockedContactsService, profilePicRecipientsService;
 	private DeadlineListService hiddenChatsListService;
 	private VoipStateService voipStateService;
+	private DeleteContactServices deleteContactServices;
+
+	private final @NonNull LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
 	// Data and state holders
 	private String identity;
 	@Deprecated
 	private ContactModel contact;
+	private ch.threema.data.models.ContactModel contactModel;
 	private @Nullable ContactDetailViewModel viewModel; // Initially null, until initialized
 	private List<GroupModel> groupList;
 	private boolean isReadonly;
@@ -153,7 +170,15 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	private View workIcon;
 
 	private void refreshAdapter() {
-		contactDetailRecyclerView.setAdapter(setupAdapter());
+		if (viewModel == null) {
+			logger.error("View model is null. Cannot refresh adapter.");
+			return;
+		}
+
+		ContactModelData fetchedData = viewModel.getContact().getValue();
+		if (fetchedData != null) {
+			contactDetailRecyclerView.setAdapter(setupAdapter(fetchedData));
+		}
 	}
 
 	private final ResumePauseHandler.RunIfActive runIfActiveUpdate = new ResumePauseHandler.RunIfActive() {
@@ -201,8 +226,8 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			if (!this.shouldHandleChange(contactModel.getIdentity())) {
+		public void onAvatarChanged(final @NonNull String identity) {
+			if (!this.shouldHandleChange(identity)) {
 				return;
 			}
 			RuntimeUtil.runOnUiThread(() -> updateProfilepicMenu());
@@ -237,21 +262,21 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			if (newIdentity.equals(identity)) {
 				resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD_GROUP, runIfActiveGroupUpdate);
 			}
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String leftIdentity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String leftIdentity) {
 			if (leftIdentity.equals(identity)) {
 				resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD_GROUP, runIfActiveGroupUpdate);
 			}
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String kickedIdentity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String kickedIdentity) {
 			if (kickedIdentity.equals(identity)) {
 				resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD_GROUP, runIfActiveGroupUpdate);
 			}
@@ -302,11 +327,27 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		try {
 			this.contactService = serviceManager.getContactService();
 			modelRepositories = serviceManager.getModelRepositories();
+			contactModelRepository = modelRepositories.getContacts();
 			this.blockedContactsService = serviceManager.getBlockedContactsService();
 			this.profilePicRecipientsService = serviceManager.getProfilePicRecipientsService();
 			this.groupService = serviceManager.getGroupService();
 			this.hiddenChatsListService = serviceManager.getHiddenChatsListService();
 			this.voipStateService = serviceManager.getVoipStateService();
+			this.deleteContactServices = new DeleteContactServices(
+				serviceManager.getUserService(),
+				contactService,
+				serviceManager.getConversationService(),
+				serviceManager.getRingtoneService(),
+				serviceManager.getMutedChatsListService(),
+				hiddenChatsListService,
+				profilePicRecipientsService,
+				serviceManager.getWallpaperService(),
+				serviceManager.getFileService(),
+				serviceManager.getExcludedSyncIdentitiesService(),
+				serviceManager.getDHSessionStore(),
+				serviceManager.getNotificationService(),
+				serviceManager.getDatabaseServiceNew()
+			);
 		} catch (Exception e) {
 			LogUtil.exception(e, this);
 			this.finish();
@@ -315,7 +356,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 
 		// Look up contact data
 		this.contact = this.contactService.getByIdentity(this.identity);
-		final ch.threema.data.models.ContactModel contactModel = modelRepositories.getContacts().getByIdentity(this.identity);
+		contactModel = modelRepositories.getContacts().getByIdentity(this.identity);
 		if (this.contact == null || contactModel == null) {
 			Toast.makeText(this, R.string.contact_not_found, Toast.LENGTH_LONG).show();
 			this.finish();
@@ -371,7 +412,6 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 
 		// Set up contact detail recycler view
 		this.contactDetailRecyclerView.setLayoutManager(new LinearLayoutManager(this));
-		this.contactDetailRecyclerView.setAdapter(setupAdapter());
 
 		// Set description for badge
 		this.workIcon.setContentDescription(
@@ -480,16 +520,17 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	}
 
 	@UiThread
-	private ContactDetailAdapter setupAdapter() {
-		// By the time `setupAdapter` is called for the first time, the viewmodel should
-		// already be initialized.
-		final ContactDetailViewModel viewModel = Objects.requireNonNull(this.viewModel);
-		final ContactModelData contactModelData = Objects.requireNonNull(viewModel.getContact().getValue());
+	@Nullable
+	private ContactDetailAdapter setupAdapter(@NonNull ContactModelData contactModelData) {
+		if (viewModel == null) {
+			logger.error("View model is null");
+			return null;
+		}
 
 		final ContactDetailAdapter contactDetailAdapter = new ContactDetailAdapter(
 			this,
 			this.groupList,
-			contact,
+			viewModel.getContactModel(),
 			contactModelData,
 			Glide.with(this)
 		);
@@ -565,37 +606,25 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		dialogFragment.show(getSupportFragmentManager(), DIALOG_TAG_DELETE_CONTACT);
 	}
 
-	private void removeContactConfirmed(final boolean addToExcludeList, final ContactModel contactModel) {
-		new AsyncTask<Void, Void, Boolean>() {
-			@Override
-			protected void onPreExecute() {
-				GenericProgressDialog.newInstance(R.string.deleting_contact, R.string.please_wait).show(getSupportFragmentManager(), DIALOG_TAG_DELETING_CONTACT);
-			}
-
-
-			@Override
-			protected Boolean doInBackground(Void... params) {
-				if (addToExcludeList) {
-					IdListService excludeFromSyncListService = ContactDetailActivity.this
-							.serviceManager.getExcludedSyncIdentitiesService();
-
-					if (excludeFromSyncListService != null) {
-						excludeFromSyncListService.add(contactModel.getIdentity());
-					}
-				}
-				return contactService.remove(contactModel);
-			}
-
-			@Override
-			protected void onPostExecute(Boolean success) {
-				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_DELETING_CONTACT, true);
-				if (!success) {
-					Toast.makeText(ContactDetailActivity.this, "Failed to remove contact", Toast.LENGTH_SHORT).show();
-				} else {
+	private void removeContactConfirmed(final boolean addToExcludeList) {
+		backgroundExecutor.get().execute(
+			new DialogMarkContactAsDeletedBackgroundTask(
+				getSupportFragmentManager(),
+				new WeakReference<>(this),
+				Set.of(identity),
+				contactModelRepository,
+				deleteContactServices,
+				addToExcludeList ? ContactSyncPolicy.EXCLUDE : ContactSyncPolicy.INCLUDE,
+				AndroidContactLinkPolicy.REMOVE_LINK
+			) {
+				@Override
+				protected void onFinished() {
+					// TODO(ANDR-3051): Do not leave contact detail activity if contact could not be
+					//  deleted.
 					finishAndGoHome();
 				}
 			}
-		}.execute();
+		);
 	}
 
 	private void editName() {
@@ -658,7 +687,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		updateVoipCallMenuItem(null);
 
 		MenuItem galleryMenuItem = menu.findItem(R.id.menu_gallery);
-		if (hiddenChatsListService.has(contactService.getUniqueIdString(contact))) {
+		if (hiddenChatsListService.has(ContactUtil.getUniqueIdString(identity))) {
 			galleryMenuItem.setVisible(false);
 		}
 
@@ -709,7 +738,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		} else if (id == R.id.action_share_contact) {
 			ShareUtil.shareContact(this, contact);
 		} else if (id == R.id.menu_gallery) {
-			if (!hiddenChatsListService.has(contactService.getUniqueIdString(contact))) {
+			if (!hiddenChatsListService.has(ContactUtil.getUniqueIdString(identity))) {
 				Intent mediaGalleryIntent = new Intent(this, MediaGalleryActivity.class);
 				mediaGalleryIntent.putExtra(ThreemaApplication.INTENT_DATA_CONTACT, identity);
 				startActivity(mediaGalleryIntent);
@@ -763,7 +792,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 					this.profilePicItem.setVisible(false);
 					this.profilePicSendItem.setVisible(!ContactUtil.isEchoEchoOrGatewayContact(contact));
 					break;
-				case PreferenceService.PROFILEPIC_RELEASE_SOME:
+				case PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST:
 					if (!ContactUtil.isEchoEchoOrGatewayContact(contact)) {
 						if (profilePicRecipientsService != null && profilePicRecipientsService.has(this.identity)) {
 							profilePicItem.setTitle(R.string.menu_send_profilpic_off);
@@ -819,42 +848,15 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 								this.serviceManager.getQRCodeService());
 
 				if (qrRes != null) {
-					if (qrRes.getExpirationDate() != null && qrRes.getExpirationDate().before(new Date())) {
-						SimpleStringAlertDialog.newInstance(R.string.title_adduser, getString(R.string.expired_barcode)).show(getSupportFragmentManager(), "expiredId");
-						return;
-					}
-
-					if(!TestUtil.compare(identity, qrRes.getIdentity())) {
-						SimpleStringAlertDialog.newInstance(
-								R.string.scan_id_mismatch_title,
-								getString(R.string.scan_id_mismatch_message)).show(getSupportFragmentManager(), "scanId");
-						return;
-					}
-					int contactVerification = this.contactService.updateContactVerification(identity, qrRes.getPublicKey());
-
-					//update the view
-					// this.updateVerificationLevelImage(this.verificationLevelImageView);
-
-					int txt;
-					switch (contactVerification) {
-						case ContactService.ContactVerificationResult_ALREADY_VERIFIED:
-							txt = R.string.scan_duplicate;
-							break;
-						case ContactService.ContactVerificationResult_VERIFIED:
-							txt = R.string.scan_successful;
-							break;
-						default:
-							txt = R.string.id_mismatch;
-					}
-					SimpleStringAlertDialog.newInstance(R.string.id_scanned, getString(txt)).show(getSupportFragmentManager(), "scanId");
+					applyQRCodeResult(qrRes);
 				}
 				break;
 			case REQUEST_CODE_CONTACT_EDITOR:
 				try {
-					AndroidContactUtil.getInstance().updateNameByAndroidContact(contact);
-					AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contact);
+					AndroidContactUtil.getInstance().updateNameByAndroidContact(contactModel);
+					AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contactModel);
 					this.avatarEditView.setContactModel(contact);
-				} catch (ThreemaException e) {
+				} catch (ThreemaException|SecurityException e) {
 					logger.info("Unable to update contact name or avatar after returning from ContactEditor");
 				}
 				break;
@@ -881,15 +883,67 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 			dialogFragment.setData(contact);
 			dialogFragment.show(getSupportFragmentManager(), DIALOG_TAG_EXCLUDE_CONTACT);
 		} else {
-			removeContactConfirmed(false, contactModel);
+			removeContactConfirmed(false);
 		}
 	}
 
 	void unhideContact(ContactModel contactModel) {
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		onCreateLocal();
 	}
 
+	private void applyQRCodeResult(@NonNull QRCodeService.QRCodeContentResult qrRes) {
+		if (qrRes.getExpirationDate() != null && qrRes.getExpirationDate().before(new Date())) {
+			SimpleStringAlertDialog.newInstance(R.string.title_adduser, getString(R.string.expired_barcode)).show(getSupportFragmentManager(), "expiredId");
+			return;
+		}
+
+		if(!TestUtil.compare(identity, qrRes.getIdentity())) {
+			SimpleStringAlertDialog.newInstance(
+				R.string.scan_id_mismatch_title,
+				getString(R.string.scan_id_mismatch_message)).show(getSupportFragmentManager(), "scanId");
+			return;
+		}
+
+		AddOrUpdateContactBackgroundTask<String> task = new AddOrUpdateContactBackgroundTask<>(
+			identity,
+			ContactModel.AcquaintanceLevel.DIRECT,
+			contactService.getMe().getIdentity(),
+			serviceManager.getAPIConnector(),
+			contactModelRepository,
+			AddContactRestrictionPolicy.CHECK,
+			this,
+			qrRes.getPublicKey()
+		) {
+			@Override
+			public String onContactAdded(@NonNull ContactResult result) {
+				if (result instanceof AlreadyVerified) {
+					return getString(R.string.scan_duplicate);
+				} else if (result instanceof ContactModified) {
+					if (((ContactModified) result).getVerificationLevelChanged()) {
+						return getString(R.string.scan_successful);
+					} else if (((ContactModified) result).getAcquaintanceLevelChanged()) {
+						logger.warn("Acquaintance level has changed instead of verification level");
+					}
+				} else if (result instanceof LocalPublicKeyMismatch) {
+					return getString(R.string.id_mismatch);
+				} else if (result instanceof Failed) {
+					return ((Failed) result).getMessage();
+				}
+				return null;
+			}
+
+			@Override
+			public void onFinished(@Nullable String result) {
+				if (result != null) {
+					SimpleStringAlertDialog.newInstance(R.string.id_scanned, result).show(getSupportFragmentManager(), "scanId");
+				}
+			}
+		};
+
+		backgroundExecutor.get().execute(task);
+	}
+
 	@Override
 	public void onYes(String tag, Object data) {
 		switch (tag) {
@@ -898,7 +952,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 				deleteContact(contactModel);
 				break;
 			case DIALOG_TAG_EXCLUDE_CONTACT:
-				removeContactConfirmed(true, (ContactModel) data);
+				removeContactConfirmed(true);
 				break;
 			case DIALOG_TAG_ADD_CONTACT:
 				unhideContact(this.contact);
@@ -915,7 +969,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	public void onNo(String tag, Object data) {
 		switch (tag) {
 			case DIALOG_TAG_EXCLUDE_CONTACT:
-				removeContactConfirmed(false, (ContactModel) data);
+				removeContactConfirmed(false);
 				break;
 			case DIALOG_TAG_ADD_CONTACT:
 				finish();
diff --git a/app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt b/app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt
index 406108ce..496d227e 100644
--- a/app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt
+++ b/app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt
@@ -29,7 +29,7 @@ import androidx.lifecycle.viewmodel.viewModelFactory
 import ch.threema.app.ThreemaApplication
 import ch.threema.data.models.ContactModel
 
-class ContactDetailViewModel(private val contactModel: ContactModel) : ViewModel() {
+class ContactDetailViewModel(val contactModel: ContactModel) : ViewModel() {
     val contact = contactModel.liveData()
 
     /**
diff --git a/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java b/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java
index 5ec03735..86c88d2c 100644
--- a/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java
@@ -25,25 +25,25 @@ import android.os.Bundle;
 import android.view.View;
 
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.storage.models.ContactModel;
 
 public class ContactNotificationsActivity extends NotificationsActivity {
-	private String identity;
 	private ContactModel contactModel;
 
 	@Override
 	public void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
 
-		this.identity = getIntent().getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
-		if (TestUtil.isEmptyOrNull(this.identity)) {
+		String identity = getIntent().getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
+		if (TestUtil.isEmptyOrNull(identity)) {
 			finish();
 			return;
 		}
 
 		this.contactModel = contactService.getByIdentity(identity);
-		this.uid = contactService.getUniqueIdString(contactModel);
+		this.uid = ContactUtil.getUniqueIdString(identity);
 
 		refreshSettings();
 	}
diff --git a/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java b/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java
index 34afecb6..7743700e 100644
--- a/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.activities;
 
-import static ch.threema.app.ui.DirectoryDataSource.MIN_SEARCH_STRING_LENGTH;
-
 import android.animation.LayoutTransition;
 import android.annotation.SuppressLint;
 import android.content.Intent;
@@ -38,18 +36,6 @@ import android.view.View;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import androidx.annotation.ColorInt;
-import androidx.annotation.IntDef;
-import androidx.annotation.MainThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-import androidx.lifecycle.LiveData;
-import androidx.paging.LivePagedListBuilder;
-import androidx.paging.PagedList;
-import androidx.recyclerview.widget.DefaultItemAnimator;
-import androidx.recyclerview.widget.LinearLayoutManager;
-
 import com.google.android.material.chip.Chip;
 import com.google.android.material.chip.ChipGroup;
 import com.google.android.material.progressindicator.LinearProgressIndicator;
@@ -62,24 +48,41 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 
+import androidx.annotation.ColorInt;
+import androidx.annotation.IntDef;
+import androidx.annotation.MainThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
+import androidx.lifecycle.LiveData;
+import androidx.paging.LivePagedListBuilder;
+import androidx.paging.PagedList;
+import androidx.recyclerview.widget.DefaultItemAnimator;
+import androidx.recyclerview.widget.LinearLayoutManager;
 import ch.threema.app.R;
 import ch.threema.app.adapters.DirectoryAdapter;
-import ch.threema.app.asynctasks.AddContactAsyncTask;
+import ch.threema.app.asynctasks.AddOrUpdateWorkContactBackgroundTask;
 import ch.threema.app.dialogs.MultiChoiceSelectorDialog;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.ui.DirectoryDataSourceFactory;
 import ch.threema.app.ui.DirectoryHeaderItemDecoration;
 import ch.threema.app.ui.EmptyRecyclerView;
 import ch.threema.app.ui.ThreemaSearchView;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.IntentDataUtil;
-import ch.threema.app.utils.LogUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.api.work.WorkDirectoryCategory;
 import ch.threema.domain.protocol.api.work.WorkDirectoryContact;
 import ch.threema.domain.protocol.api.work.WorkOrganization;
 
+import static ch.threema.app.ui.DirectoryDataSource.MIN_SEARCH_STRING_LENGTH;
+
 public class DirectoryActivity extends ThreemaToolbarActivity implements ThreemaSearchView.OnQueryTextListener, MultiChoiceSelectorDialog.SelectorDialogClickListener {
     private static final Logger logger = LoggingUtil.getThreemaLogger("DirectoryActivity");
 
@@ -95,8 +98,13 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
     private static final int EMPTY_STATE_SEARCHING = 1;
     private static final int EMPTY_STATE_RESULTS = 2;
 
-    private ContactService contactService;
-    private boolean sortByFirstName;
+	private ContactService contactService;
+	private UserService userService;
+	private ContactModelRepository contactModelRepository;
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
+
+	private boolean sortByFirstName;
 
     private DirectoryAdapter directoryAdapter;
     private DirectoryDataSourceFactory directoryDataSourceFactory;
@@ -176,12 +184,14 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
             updateToolbarTitle(getString(R.string.directory_title));
         }
 
-        try {
-            this.contactService = serviceManager.getContactService();
-        } catch (Exception e) {
-            LogUtil.exception(e, this);
-            return false;
-        }
+		try {
+			this.contactService = serviceManager.getContactService();
+		} catch (Exception e) {
+			logger.error("Could not get contact service", e);
+			return false;
+		}
+		this.userService = serviceManager.getUserService();
+		this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
 
         if (preferenceService == null) {
             return false;
@@ -229,11 +239,11 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
                 launchContact(workDirectoryContact, position);
             }
 
-            @Override
-            public void onAdd(WorkDirectoryContact workDirectoryContact, final int position) {
-                addContact(workDirectoryContact, () -> directoryAdapter.notifyItemChanged(position));
-            }
-        });
+			@Override
+			public void onAdd(WorkDirectoryContact workDirectoryContact, final int position) {
+				addContact(workDirectoryContact, () -> directoryAdapter.notifyItemChanged(position));
+			}
+		});
 
         // initial page size
         PagedList.Config config = new PagedList.Config.Builder().setPageSize(API_DIRECTORY_PAGE_SIZE).build();
@@ -348,32 +358,38 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
         startActivity(intent);
     }
 
-    private void launchContact(final WorkDirectoryContact workDirectoryContact, final int position) {
-        if (workDirectoryContact.threemaId != null) {
-            if (contactService.getByIdentity(workDirectoryContact.threemaId) == null) {
-                addContact(workDirectoryContact, () -> {
-                    openContact(workDirectoryContact.threemaId);
-                    directoryAdapter.notifyItemChanged(position);
-                });
-            } else if (workDirectoryContact.threemaId.equalsIgnoreCase(contactService.getMe().getIdentity())) {
-                Toast.makeText(this, R.string.me_myself_and_i, Toast.LENGTH_LONG).show();
-            } else {
-                openContact(workDirectoryContact.threemaId);
-            }
-        } else {
-            Toast.makeText(this, R.string.contact_not_found, Toast.LENGTH_LONG).show();
-        }
-    }
-
-    private void addContact(final WorkDirectoryContact workDirectoryContact, Runnable runAfter) {
+	private void launchContact(final WorkDirectoryContact workDirectoryContact, final int position) {
+		if (workDirectoryContact.threemaId != null) {
+			if (contactService.getByIdentity(workDirectoryContact.threemaId) == null) {
+				addContact(workDirectoryContact, () -> {
+					openContact(workDirectoryContact.threemaId);
+					directoryAdapter.notifyItemChanged(position);
+				});
+			} else if (workDirectoryContact.threemaId.equalsIgnoreCase(contactService.getMe().getIdentity())) {
+				Toast.makeText(this, R.string.me_myself_and_i, Toast.LENGTH_LONG).show();
+			} else {
+				openContact(workDirectoryContact.threemaId);
+			}
+		} else {
+			Toast.makeText(this, R.string.contact_not_found, Toast.LENGTH_LONG).show();
+		}
+	}
+
+	private void addContact(final WorkDirectoryContact workDirectoryContact, Runnable runAfter) {
         logger.info("Add new work contact");
-        new AddContactAsyncTask(
-            workDirectoryContact.firstName,
-            workDirectoryContact.lastName,
-            workDirectoryContact.threemaId,
-            true,
-            runAfter).execute();
-    }
+		backgroundExecutor.get().execute(
+			new AddOrUpdateWorkContactBackgroundTask(
+				workDirectoryContact,
+				userService.getIdentity(),
+				contactModelRepository
+			) {
+				@Override
+				public void runAfter(ContactModel contactModel) {
+					runAfter.run();
+				}
+			}
+		);
+	}
 
     private DirectoryHeaderItemDecoration.HeaderCallback getSectionCallback() {
         return new DirectoryHeaderItemDecoration.HeaderCallback() {
diff --git a/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java b/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java
index 4c80f1da..0e53a24c 100644
--- a/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java
@@ -230,9 +230,9 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			if (this.shouldHandleChange(contactModel.getIdentity())) {
-				this.onModified(contactModel.getIdentity());
+		public void onAvatarChanged(final @NonNull String identity) {
+			if (this.shouldHandleChange(identity)) {
+				this.onModified(identity);
 			}
 		}
 
@@ -263,12 +263,12 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD, runIfActiveUpdate);
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String identity) {
 			if (identity.equals(myIdentity)) {
 				finish();
 			} else {
@@ -277,7 +277,7 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String identity) {
 			if (identity.equals(myIdentity)) {
 				finish();
 			} else {
@@ -482,7 +482,7 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 
 	private void setupAdapter() throws MasterKeyLockedException, FileSystemNotPresentException {
 		Runnable onCloneGroupRunnable = null;
-		if (groupService.isOrphanedGroup(groupModel) && groupService.getOtherMemberCount(groupModel) > 0) {
+		if (groupService.isOrphanedGroup(groupModel) && groupService.countMembersWithoutUser(groupModel) > 0) {
 			onCloneGroupRunnable = this::showCloneDialog;
 		}
 
@@ -597,7 +597,7 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 
 			boolean isMember = groupService.isGroupMember(groupModel);
 			boolean isCreator = groupService.isGroupCreator(groupModel);
-			boolean hasOtherMembers = groupService.getOtherMemberCount(groupModel) > 0;
+			boolean hasOtherMembers = groupService.countMembersWithoutUser(groupModel) > 0;
 
 			// The clone menu only makes sense if at least one other member is present
 			cloneMenu.setVisible(hasOtherMembers);
diff --git a/app/src/main/java/ch/threema/app/activities/HomeActivity.java b/app/src/main/java/ch/threema/app/activities/HomeActivity.java
index 4e3d8ae5..ff8ab415 100644
--- a/app/src/main/java/ch/threema/app/activities/HomeActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/HomeActivity.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.activities;
 
-import static ch.threema.app.services.ConversationTagServiceImpl.FIXED_TAG_UNREAD;
-
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.BroadcastReceiver;
@@ -52,21 +50,6 @@ import android.view.Window;
 import android.widget.ImageView;
 import android.widget.Toast;
 
-import androidx.activity.result.ActivityResultLauncher;
-import androidx.activity.result.contract.ActivityResultContracts;
-import androidx.annotation.AnyThread;
-import androidx.annotation.ColorInt;
-import androidx.annotation.IdRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-import androidx.appcompat.widget.AppCompatImageView;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentTransaction;
-import androidx.lifecycle.LifecycleOwner;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-
 import com.google.android.material.appbar.MaterialToolbar;
 import com.google.android.material.badge.BadgeDrawable;
 import com.google.android.material.badge.ExperimentalBadgeUtils;
@@ -87,12 +70,31 @@ import java.util.Set;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.stream.Collectors;
 
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
+import androidx.annotation.AnyThread;
+import androidx.annotation.ColorInt;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
+import androidx.appcompat.widget.AppCompatImageView;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentTransaction;
+import androidx.lifecycle.LifecycleOwner;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
 import ch.threema.app.BuildFlavor;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.wizard.WizardBaseActivity;
 import ch.threema.app.activities.wizard.WizardStartActivity;
 import ch.threema.app.archive.ArchiveActivity;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactCreated;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.backuprestore.csv.BackupService;
 import ch.threema.app.backuprestore.csv.RestoreService;
 import ch.threema.app.dialogs.GenericAlertDialog;
@@ -100,7 +102,6 @@ import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.SMSVerificationDialog;
 import ch.threema.app.dialogs.ShowOnceDialog;
 import ch.threema.app.dialogs.SimpleStringAlertDialog;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.fragments.ContactsSectionFragment;
 import ch.threema.app.fragments.MessageSectionFragment;
@@ -124,19 +125,20 @@ import ch.threema.app.push.PushService;
 import ch.threema.app.qrscanner.activity.BaseQrScannerActivity;
 import ch.threema.app.routines.CheckLicenseRoutine;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.ContactServiceImpl;
 import ch.threema.app.services.ConversationService;
 import ch.threema.app.services.ConversationTagService;
 import ch.threema.app.services.DeviceService;
 import ch.threema.app.services.FileService;
 import ch.threema.app.services.LockAppService;
 import ch.threema.app.services.MessageService;
-import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.services.PassphraseService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.ThreemaPushService;
 import ch.threema.app.services.UpdateSystemService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.services.license.LicenseService;
+import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.tasks.ApplicationUpdateStepsTask;
 import ch.threema.app.threemasafe.ThreemaSafeMDMConfig;
 import ch.threema.app.threemasafe.ThreemaSafeService;
@@ -150,9 +152,11 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ConnectionIndicatorUtil;
 import ch.threema.app.utils.DialogUtil;
 import ch.threema.app.utils.IntentDataUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.PowermanagerUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.groupcall.GroupCallDescription;
 import ch.threema.app.voip.groupcall.GroupCallManager;
 import ch.threema.app.voip.groupcall.GroupCallObserver;
@@ -160,10 +164,12 @@ import ch.threema.app.voip.groupcall.sfu.GroupCallController;
 import ch.threema.app.voip.services.VoipCallService;
 import ch.threema.app.webclient.activities.SessionsActivity;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.api.LinkMobileNoException;
-import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.protocol.connection.ConnectionState;
 import ch.threema.domain.protocol.connection.ConnectionStateListener;
+import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.localcrypto.MasterKey;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.models.AbstractMessageModel;
@@ -172,6 +178,8 @@ import ch.threema.storage.models.ConversationModel;
 import ch.threema.storage.models.MessageState;
 import ch.threema.storage.models.TagModel;
 
+import static ch.threema.app.services.ConversationTagServiceImpl.FIXED_TAG_UNREAD;
+
 public class HomeActivity extends ThreemaAppCompatActivity implements
 	SMSVerificationDialog.SMSVerificationDialogCallback,
 	GenericAlertDialog.DialogClickListener,
@@ -218,6 +226,8 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 	private NotificationService notificationService;
 	private UserService userService;
 	private ContactService contactService;
+	private ContactModelRepository contactModelRepository;
+	private APIConnector apiConnector;
 	private LockAppService lockAppService;
 	private PreferenceService preferenceService;
 	private ConversationService conversationService;
@@ -225,6 +235,9 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 
     private @Nullable IdentityPopup identityPopup = null;
 
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
+
 	private enum UnsentMessageAction {
 		ADD,
 		REMOVE,
@@ -778,7 +791,7 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 	}
 
 	private void showWhatsNew() {
-		final boolean skipWhatsNew = false; // set this to false if you want to show a What's New screen
+		final boolean skipWhatsNew = true; // set this to false if you want to show a What's New screen
 
 		if (preferenceService != null) {
 			if (!preferenceService.isLatestVersion(this)) {
@@ -1058,6 +1071,8 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 			} catch (Exception e) {
 				//
 			}
+			this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+			this.apiConnector = serviceManager.getAPIConnector();
 
 			if (preferenceService == null || notificationService == null || userService == null) {
 				finish();
@@ -1949,56 +1964,66 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 			return;
 		}
 
-		new AsyncTask<Void, Void, Exception>() {
-			ContactModel newContactModel;
-
-			@Override
-			protected void onPreExecute() {
-				GenericProgressDialog.newInstance(R.string.threema_channel, R.string.please_wait).show(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY);
-			}
-
-			@Override
-			protected Exception doInBackground(Void... params) {
-				try {
-					newContactModel = contactService.createContactByIdentity(THREEMA_CHANNEL_IDENTITY, true);
-				} catch (Exception e) {
-					return e;
+		backgroundExecutor.get().execute(
+			new BasicAddOrUpdateContactBackgroundTask(
+				THREEMA_CHANNEL_IDENTITY,
+				ContactModel.AcquaintanceLevel.DIRECT,
+				userService.getIdentity(),
+				apiConnector,
+				contactModelRepository,
+				AddContactRestrictionPolicy.IGNORE,
+				this,
+				ContactServiceImpl.THREEMA_PUBLIC_KEY
+			) {
+				@Override
+				public void onBefore() {
+					GenericProgressDialog.newInstance(R.string.threema_channel, R.string.please_wait).show(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY);
 				}
-				return null;
-			}
 
-			@Override
-			protected void onPostExecute(Exception exception) {
-				DialogUtil.dismissDialog(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY, true);
-
-				if (exception == null || exception instanceof EntryAlreadyExistsException) {
-					launchThreemaChannelChat();
+				@Override
+				public void onFinished(@NonNull ContactResult result) {
+					DialogUtil.dismissDialog(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY, true);
+
+					if (result instanceof ContactAvailable) {
+						// In case the contact has been successfully created or it has been
+						// modified, already verified, or already exists, the threema channel chat
+						// is launched.
+						launchThreemaChannelChat();
+
+						// Send initial messages to threema channel only if the threema channel has
+						// been newly created as a contact and did not exist before.
+						if (result instanceof ContactCreated) {
+							new Thread(() -> {
+								try {
+									ContactModel threemaChannelModel = contactService.getByIdentity(THREEMA_CHANNEL_IDENTITY);
+									if (threemaChannelModel == null) {
+										logger.error("Threema channel model is null after adding it");
+										return;
+									}
 
-					if (exception == null) {
-						new Thread(() -> {
-							try {
-								MessageReceiver receiver = contactService.createReceiver(newContactModel);
-								if (!getResources().getConfiguration().locale.getLanguage().startsWith("de") && !getResources().getConfiguration().locale.getLanguage().startsWith("gsw")) {
+									MessageReceiver<?> receiver = contactService.createReceiver(threemaChannelModel);
+									if (!getResources().getConfiguration().locale.getLanguage().startsWith("de") && !getResources().getConfiguration().locale.getLanguage().startsWith("gsw")) {
+										Thread.sleep(1000);
+										messageService.sendText("en", receiver);
+										Thread.sleep(500);
+									}
 									Thread.sleep(1000);
-									messageService.sendText("en", receiver);
-									Thread.sleep(500);
+									messageService.sendText(THREEMA_CHANNEL_START_NEWS_COMMAND, receiver);
+									Thread.sleep(1500);
+									messageService.sendText(ConfigUtils.isWorkBuild() ? THREEMA_CHANNEL_WORK_COMMAND : THREEMA_CHANNEL_START_ANDROID_COMMAND, receiver);
+									Thread.sleep(1500);
+									messageService.sendText(THREEMA_CHANNEL_INFO_COMMAND, receiver);
+								} catch (Exception e) {
+									//
 								}
-								Thread.sleep(1000);
-								messageService.sendText(THREEMA_CHANNEL_START_NEWS_COMMAND, receiver);
-								Thread.sleep(1500);
-								messageService.sendText(ConfigUtils.isWorkBuild() ? THREEMA_CHANNEL_WORK_COMMAND : THREEMA_CHANNEL_START_ANDROID_COMMAND, receiver);
-								Thread.sleep(1500);
-								messageService.sendText(THREEMA_CHANNEL_INFO_COMMAND, receiver);
-							} catch (Exception e) {
-								//
-							}
-						}).start();
+							}).start();
+						}
+					} else {
+						Toast.makeText(HomeActivity.this, R.string.internet_connection_required, Toast.LENGTH_LONG).show();
 					}
-				} else {
-					Toast.makeText(HomeActivity.this, R.string.internet_connection_required, Toast.LENGTH_LONG).show();
 				}
 			}
-		}.execute();
+		);
 	}
 
 	private void launchThreemaChannelChat() {
diff --git a/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java b/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java
index ccf87e3b..0531ac39 100644
--- a/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java
@@ -903,7 +903,7 @@ public class ImagePaintActivity extends ThreemaToolbarActivity implements Generi
 
 			@Override
 			protected void onPostExecute(List<FaceItem> faceItemList) {
-				if (faceItemList != null && faceItemList.size() > 0) {
+				if (faceItemList != null && !faceItemList.isEmpty()) {
 					motionView.post(() -> {
 						for (FaceItem faceItem : faceItemList) {
 							Layer layer = new Layer();
@@ -1703,9 +1703,6 @@ public class ImagePaintActivity extends ThreemaToolbarActivity implements Generi
 		finishWithoutChanges();
 	}
 
-	@Override
-	public void onNo(String tag, Object data) {}
-
 	/**
 	 * Finish activity with changes (result ok)
 	 */
diff --git a/app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt b/app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt
index faeff5dd..2e56da88 100644
--- a/app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt
+++ b/app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt
@@ -40,7 +40,6 @@ import androidx.compose.ui.platform.ViewCompositionStrategy.DisposeOnViewTreeLif
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.lifecycle.viewmodel.compose.viewModel
-import androidx.preference.PreferenceManager
 import ch.threema.app.BuildConfig
 import ch.threema.app.R
 import ch.threema.app.ThreemaApplication
@@ -171,16 +170,12 @@ class MessageDetailsActivity : ThreemaToolbarActivity(), DialogClickListener {
     }
 
     private fun initScreenContent() {
-        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext())
-        val shouldUseDynamicColors = sharedPreferences.getBoolean("pref_dynamic_color", false)
 
         val editHistoryComposeView = findViewById<ComposeView>(R.id.message_details_compose_view)
         editHistoryComposeView.setViewCompositionStrategy(DisposeOnViewTreeLifecycleDestroyed)
 
         editHistoryComposeView.setContent {
-            ThreemaTheme(
-                dynamicColor = shouldUseDynamicColors
-            ) {
+            ThreemaTheme {
                 val uiState: ChatMessageDetailsUiState by viewModel.uiState.collectAsStateWithLifecycle()
                 val messageModel: MessageUiModel = uiState.message
                 val editHistoryViewModel: EditHistoryViewModel = viewModel(
diff --git a/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.java b/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.java
deleted file mode 100644
index f41d1f33..00000000
--- a/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities;
-
-import android.os.Bundle;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import ch.threema.app.R;
-import ch.threema.app.services.IdListService;
-import ch.threema.app.utils.LogUtil;
-import ch.threema.storage.models.ContactModel;
-
-public class ProfilePicRecipientsActivity extends MemberChooseActivity {
-	private IdListService profilePicRecipientsService;
-
-	@Override
-	public void onCreate(final Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-	}
-
-	@Override
-	protected boolean initActivity(Bundle savedInstanceState) {
-		if (!super.initActivity(savedInstanceState)) {
-			return false;
-		}
-
-		try {
-			this.profilePicRecipientsService = serviceManager.getProfilePicRecipientsService();
-		} catch (Exception e) {
-			LogUtil.exception(e, this);
-			return false;
-		}
-
-		initData(savedInstanceState);
-
-		return true;
-	}
-
-	@Override
-	protected int getNotice() {
-		return R.string.prefs_sum_receive_profilepics_recipients_list;
-	}
-
-	@Override
-	protected int getMode() {
-		return MODE_PROFILE_PIC_RECIPIENTS;
-	}
-
-	@Override
-	protected void initData(Bundle savedInstanceState) {
-		if (savedInstanceState == null) {
-			String[] ids = profilePicRecipientsService.getAll();
-
-			if (ids != null && ids.length > 0) {
-				preselectedIdentities = new ArrayList<>(Arrays.asList(ids));
-			}
-		}
-
-		updateToolbarTitle(R.string.profile_picture, R.string.title_choose_recipient);
-
-		initList();
-	}
-
-	@Override
-	protected void menuNext(List<ContactModel> selectedContacts) {
-		if (selectedContacts.size() > 0) {
-			List<String> ids = new ArrayList<>(selectedContacts.size());
-
-			for (ContactModel contactModel : selectedContacts) {
-				if (contactModel != null) {
-					ids.add(contactModel.getIdentity());
-				}
-			}
-
-			if (ids.size() > 0) {
-				profilePicRecipientsService.addAll(ids.toArray(new String[ids.size()]));
-				finish();
-				return;
-			}
-		}
-		profilePicRecipientsService.removeAll();
-		finish();
-	}
-
-	@Override
-	protected boolean enableOnBackPressedCallback() {
-		return true;
-	}
-
-	@Override
-	protected void handleOnBackPressed() {
-		this.menuNext(getSelectedContacts());
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.kt b/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.kt
new file mode 100644
index 00000000..9ea31ce5
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.kt
@@ -0,0 +1,99 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2014-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.activities
+
+import android.os.Bundle
+import ch.threema.app.R
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.services.IdListService
+import ch.threema.app.tasks.ReflectUserProfileShareWithAllowListSyncTask
+import ch.threema.app.utils.LogUtil
+import ch.threema.app.utils.equalsIgnoreOrder
+import ch.threema.domain.taskmanager.TaskManager
+import ch.threema.storage.models.ContactModel
+
+class ProfilePicRecipientsActivity : MemberChooseActivity() {
+
+    private lateinit var profilePicRecipientsService: IdListService
+    private lateinit var taskManager: TaskManager
+
+    public override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+    }
+
+    override fun initActivity(savedInstanceState: Bundle?): Boolean {
+        if (!super.initActivity(savedInstanceState)) {
+            return false
+        }
+
+        try {
+            this.profilePicRecipientsService = serviceManager.profilePicRecipientsService
+            this.taskManager = serviceManager.taskManager
+        } catch (exception: Exception) {
+            LogUtil.exception(exception, this)
+            return false
+        }
+
+        initData(savedInstanceState)
+
+        return true
+    }
+
+    override fun initData(savedInstanceState: Bundle?) {
+        if (savedInstanceState == null) {
+            val selectedIdentities: Array<String>? = profilePicRecipientsService.all
+            if (!selectedIdentities.isNullOrEmpty()) {
+                preselectedIdentities = ArrayList(listOf(*selectedIdentities))
+            }
+        }
+        updateToolbarTitle(R.string.profile_picture, R.string.title_choose_recipient)
+        initList()
+    }
+
+    override fun menuNext(selectedContacts: List<ContactModel?>) {
+        val oldAllowedIdentities: Array<String> = profilePicRecipientsService.all
+        val newAllowedIdentities: Array<String> = selectedContacts.mapNotNull { contactModel -> contactModel?.identity }.toTypedArray<String>()
+        profilePicRecipientsService.replaceAll(newAllowedIdentities)
+
+        // If data changed:
+        // sync new policy setting with newly set allow list values into device group (if md is active)
+        if (!oldAllowedIdentities.equalsIgnoreOrder(newAllowedIdentities)) {
+            taskManager.schedule(
+                ReflectUserProfileShareWithAllowListSyncTask(
+                    allowedIdentities = newAllowedIdentities.toList(),
+                    serviceManager = ThreemaApplication.requireServiceManager()
+                )
+            )
+        }
+        finish()
+    }
+
+    override fun getNotice(): Int = R.string.prefs_sum_receive_profilepics_recipients_list
+
+    override fun getMode(): Int = MODE_PROFILE_PIC_RECIPIENTS
+
+    override fun enableOnBackPressedCallback(): Boolean = true
+
+    override fun handleOnBackPressed() {
+        this.menuNext(selectedContacts)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java b/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java
index 76a431a9..f0bf10d1 100644
--- a/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java
@@ -21,12 +21,6 @@
 
 package ch.threema.app.activities;
 
-import static ch.threema.app.activities.SendMediaActivity.MAX_EDITABLE_FILES;
-import static ch.threema.app.fragments.ComposeMessageFragment.MAX_FORWARDABLE_ITEMS;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
-import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
-import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
-
 import android.Manifest;
 import android.annotation.SuppressLint;
 import android.content.ClipData;
@@ -55,22 +49,6 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Toast;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.annotation.WorkerThread;
-import androidx.appcompat.app.ActionBar;
-import androidx.appcompat.widget.SearchView;
-import androidx.core.app.ActivityCompat;
-import androidx.core.app.TaskStackBuilder;
-import androidx.core.content.ContextCompat;
-import androidx.core.content.pm.ShortcutManagerCompat;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentManager;
-import androidx.fragment.app.FragmentPagerAdapter;
-import androidx.viewpager.widget.ViewPager;
-
 import com.google.android.material.progressindicator.CircularProgressIndicator;
 import com.google.android.material.search.SearchBar;
 import com.google.android.material.snackbar.Snackbar;
@@ -87,6 +65,21 @@ import java.util.List;
 import java.util.concurrent.Executors;
 import java.util.stream.Collectors;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.annotation.WorkerThread;
+import androidx.appcompat.app.ActionBar;
+import androidx.appcompat.widget.SearchView;
+import androidx.core.app.ActivityCompat;
+import androidx.core.app.TaskStackBuilder;
+import androidx.core.content.ContextCompat;
+import androidx.core.content.pm.ShortcutManagerCompat;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentPagerAdapter;
+import androidx.viewpager.widget.ViewPager;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
@@ -94,6 +87,9 @@ import ch.threema.app.actions.LocationMessageSendAction;
 import ch.threema.app.actions.SendAction;
 import ch.threema.app.actions.TextMessageSendAction;
 import ch.threema.app.adapters.FilterableListAdapter;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.dialogs.CancelableHorizontalProgressDialog;
 import ch.threema.app.dialogs.ExpandableTextEntryDialog;
 import ch.threema.app.dialogs.GenericProgressDialog;
@@ -106,6 +102,7 @@ import ch.threema.app.fragments.RecipientListFragment;
 import ch.threema.app.fragments.UserListFragment;
 import ch.threema.app.fragments.WorkUserListFragment;
 import ch.threema.app.messagereceiver.MessageReceiver;
+import ch.threema.app.messagereceiver.SendingPermissionValidationResult;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.ConversationService;
 import ch.threema.app.services.DistributionListService;
@@ -124,14 +121,17 @@ import ch.threema.app.utils.DialogUtil;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.GeoLocationUtil;
 import ch.threema.app.utils.IntentDataUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.NavigationUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShortcutUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.app.messagereceiver.SendingPermissionValidationResult;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.file.FileData;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -142,6 +142,12 @@ import ch.threema.storage.models.data.LocationDataModel;
 import ch.threema.storage.models.data.MessageContentsType;
 import java8.util.concurrent.CompletableFuture;
 
+import static ch.threema.app.activities.SendMediaActivity.MAX_EDITABLE_FILES;
+import static ch.threema.app.fragments.ComposeMessageFragment.MAX_FORWARDABLE_ITEMS;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
+import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
+import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
+
 public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
     CancelableHorizontalProgressDialog.ProgressDialogClickListener,
     ExpandableTextEntryDialog.ExpandableTextEntryDialogClickListener,
@@ -181,12 +187,18 @@ public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
     private final List<Integer> tabs = new ArrayList<>(NUM_FRAGMENTS);
     private boolean isInternallyForwardingMediaFiles = false;
 
-    private GroupService groupService;
-    private ContactService contactService;
-    private ConversationService conversationService;
-    private DistributionListService distributionListService;
-    private MessageService messageService;
-    private FileService fileService;
+	private GroupService groupService;
+	private ContactService contactService;
+	private ConversationService conversationService;
+	private DistributionListService distributionListService;
+	private MessageService messageService;
+	private FileService fileService;
+	private UserService userService;
+	private APIConnector apiConnector;
+	private ContactModelRepository contactModelRepository;
+
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
     private final Runnable copyExternalFilesRunnable = new Runnable() {
         @Override
@@ -276,6 +288,8 @@ public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
             this.distributionListService = serviceManager.getDistributionListService();
             this.messageService = serviceManager.getMessageService();
             this.fileService = serviceManager.getFileService();
+            this.apiConnector = serviceManager.getAPIConnector();
+            this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
             userService = serviceManager.getUserService();
         } catch (Exception e) {
             logger.error("Exception", e);
@@ -838,36 +852,35 @@ public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
         if (contactModel == null) {
             GenericProgressDialog.newInstance(R.string.creating_contact, R.string.please_wait).show(getSupportFragmentManager(), "pro");
 
-            new AsyncTask<Void, Void, Void>() {
-                boolean fail = false;
-                ContactModel newContactModel = null;
-
-                @Override
-                protected Void doInBackground(Void... params) {
-                    try {
-                        newContactModel = contactService.createContactByIdentity(identity, false);
-                    } catch (Exception e) {
-                        fail = true;
-                    }
-                    return null;
-                }
-
-                @Override
-                protected void onPostExecute(Void result) {
-                    DialogUtil.dismissDialog(getSupportFragmentManager(), "pro", true);
-
-                    if (fail) {
-                        View rootView = getWindow().getDecorView().findViewById(android.R.id.content);
-                        Snackbar.make(rootView, R.string.contact_not_found, Snackbar.LENGTH_LONG).show();
-                    } else {
-                        prepareComposeIntent(new ArrayList<>(Collections.singletonList(newContactModel)), false);
-                    }
-                }
-            }.execute();
-        } else {
-            prepareComposeIntent(new ArrayList<>(Collections.singletonList(contactModel)), false);
-        }
-    }
+			backgroundExecutor.get().execute(
+				new BasicAddOrUpdateContactBackgroundTask(
+					identity,
+					ContactModel.AcquaintanceLevel.DIRECT,
+					userService.getIdentity(),
+					apiConnector,
+					contactModelRepository,
+					AddContactRestrictionPolicy.CHECK,
+					RecipientListBaseActivity.this,
+					null
+				) {
+					@Override
+					public void onFinished(ContactResult result) {
+						DialogUtil.dismissDialog(getSupportFragmentManager(), "pro", true);
+
+						ContactModel newContactModel = contactService.getByIdentity(identity);
+						if (newContactModel == null) {
+							View rootView = getWindow().getDecorView().findViewById(android.R.id.content);
+							Snackbar.make(rootView, R.string.contact_not_found, Snackbar.LENGTH_LONG).show();
+						} else {
+							prepareComposeIntent(new ArrayList<>(Collections.singletonList(newContactModel)), false);
+						}
+					}
+				}
+			);
+		} else {
+			prepareComposeIntent(new ArrayList<>(Collections.singletonList(contactModel)), false);
+		}
+	}
 
     @Override
     public boolean onCreateOptionsMenu(Menu menu) {
diff --git a/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java b/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java
index e6684d10..d173bd60 100644
--- a/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java
@@ -21,9 +21,6 @@
 
 package ch.threema.app.activities.wizard;
 
-import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
-import static ch.threema.app.protocol.ApplicationSetupStepsKt.runApplicationSetupSteps;
-
 import android.Manifest;
 import android.accounts.Account;
 import android.annotation.SuppressLint;
@@ -39,13 +36,6 @@ import android.view.View;
 import android.widget.Button;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentManager;
-import androidx.fragment.app.FragmentStatePagerAdapter;
-import androidx.lifecycle.LifecycleOwner;
-import androidx.viewpager.widget.ViewPager;
-
 import com.google.android.material.button.MaterialButton;
 import com.google.i18n.phonenumbers.NumberParseException;
 import com.google.i18n.phonenumbers.PhoneNumberUtil;
@@ -53,17 +43,23 @@ import com.google.i18n.phonenumbers.Phonenumber;
 
 import org.slf4j.Logger;
 
-import java.util.List;
-
+import androidx.annotation.NonNull;
+import androidx.annotation.WorkerThread;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentStatePagerAdapter;
+import androidx.lifecycle.LifecycleOwner;
+import androidx.viewpager.widget.ViewPager;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.ThreemaAppCompatActivity;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
 import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.WizardDialog;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.fragments.wizard.WizardFragment0;
 import ch.threema.app.fragments.wizard.WizardFragment1;
 import ch.threema.app.fragments.wizard.WizardFragment2;
@@ -91,1028 +87,1023 @@ import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.utils.executor.BackgroundTask;
 import ch.threema.app.workers.WorkSyncWorker;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.api.LinkEmailException;
 import ch.threema.domain.protocol.api.LinkMobileNoException;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
+
+import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
+import static ch.threema.app.protocol.ApplicationSetupStepsKt.runApplicationSetupSteps;
 
 public class WizardBaseActivity extends ThreemaAppCompatActivity implements
-		LifecycleOwner,
-		ViewPager.OnPageChangeListener,
-		View.OnClickListener,
-		WizardFragment1.OnSettingsChangedListener,
-		WizardFragment2.OnSettingsChangedListener,
-		WizardFragment3.OnSettingsChangedListener,
-		WizardFragment4.SettingsInterface,
-		WizardDialog.WizardDialogCallback {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("WizardBaseActivity");
-
-	public static final String EXTRA_NEW_IDENTITY_CREATED = "newIdentity";
-	private static final String DIALOG_TAG_USE_ID_AS_NICKNAME = "nd";
-	private static final String DIALOG_TAG_INVALID_ENTRY = "ie";
-	private static final String DIALOG_TAG_USE_ANONYMOUSLY = "ano";
-	private static final String DIALOG_TAG_THREEMA_SAFE = "sd";
-	private static final String DIALOG_TAG_PASSWORD_BAD = "pwb";
-	private static final String DIALOG_TAG_SYNC_CONTACTS_ENABLE = "scen";
-	private static final String DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE = "scmer";
-	private static final String DIALOG_TAG_APPLICATION_SETUP_RETRY = "app-setup-retry";
-
-	private static final int PERMISSION_REQUEST_READ_CONTACTS = 2;
-	private static final int NUM_PAGES = 5;
-	private static final long FINISH_DELAY = 3 * 1000;
-	private static final long DIALOG_DELAY = 200;
-
-	public static final boolean DEFAULT_SYNC_CONTACTS = false;
-	private static final String DIALOG_TAG_WORK_SYNC = "workSync";
-	private static final String DIALOG_TAG_PASSWORD_PRESET_CONFIRM = "pwPreset";
-
-	private static int lastPage = 0;
-	private ParallaxViewPager viewPager;
-	private MaterialButton prevButton, nextButton;
-	private Button finishButton;
-	private StepPagerStrip stepPagerStrip;
-	private String nickname, email, number, prefix, presetMobile, presetEmail, safePassword;
-	private ThreemaSafeServerInfo safeServerInfo = new ThreemaSafeServerInfo();
-	private boolean isSyncContacts = DEFAULT_SYNC_CONTACTS, userCannotChangeContactSync = false, skipWizard = false, readOnlyProfile = false;
-	private ThreemaSafeMDMConfig safeConfig;
-	private ServiceManager serviceManager;
-	private UserService userService;
-	private LocaleService localeService;
-	private PreferenceService preferenceService;
-	private ThreemaSafeService threemaSafeService;
-	private boolean errorRaised = false, isNewIdentity = false;
-	private WizardFragment4 fragment4;
-	private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
-
-	private final Handler finishHandler = new Handler();
-	private final Handler dialogHandler = new Handler();
-
-	private final Runnable finishTask = new Runnable() {
-		@Override
-		public void run() {
-		 	RuntimeUtil.runOnUiThread(new Runnable() {
-				@Override
-				public void run() {
-					fragment4.setContactsSyncInProgress(false, null);
-					prepareThreemaSafe();
-				}
-			});
-		}
-	};
-
-	private Runnable showDialogDelayedTask(final int current, final int previous) {
-		return () -> {
-			RuntimeUtil.runOnUiThread(() -> {
-				if (current == WizardFragment2.PAGE_ID && previous == WizardFragment1.PAGE_ID && TestUtil.isEmptyOrNull(getSafePassword())) {
-					if (safeConfig.isBackupForced()) {
-						setPage(WizardFragment1.PAGE_ID);
-					} else if (!isReadOnlyProfile()) {
-						WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_disable_confirm, R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
-						wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_THREEMA_SAFE);
-					}
-				}
-
-				if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
-					if (!isReadOnlyProfile()) {
-						if ((!TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(presetMobile) && !localeService.validatePhoneNumber(getPhone())) ||
-								((!TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(presetEmail) && !Patterns.EMAIL_ADDRESS.matcher(email).matches()))) {
-							WizardDialog wizardDialog = WizardDialog.newInstance(ConfigUtils.isWorkBuild() ?
-									R.string.new_wizard_phone_email_invalid :
-									R.string.new_wizard_phone_invalid,
-									R.string.ok);
-							wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_INVALID_ENTRY);
-						}
-					}
-				}
-
-				if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
-					if (!isReadOnlyProfile()) {
-						boolean needConfirm;
-						if (ConfigUtils.isWorkBuild()) {
-							needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(getPresetEmail()) && TestUtil.isEmptyOrNull(getPresetPhone());
-						} else {
-							if (ConfigUtils.isOnPremBuild()) {
-								needConfirm = false;
-							} else {
-								needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(getPresetPhone());
-							}
-						}
-						if (needConfirm) {
-							WizardDialog wizardDialog = WizardDialog.newInstance(
-									ConfigUtils.isWorkBuild() ?
-											R.string.new_wizard_anonymous_confirm :
-											R.string.new_wizard_anonymous_confirm_phone_only,
-									R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
-							wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_USE_ANONYMOUSLY);
-						}
-					}
-				}
-			});
-		};
-	}
-
-	@Override
-	protected void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		try {
-			serviceManager = ThreemaApplication.getServiceManager();
-			if (serviceManager != null) {
-				userService = serviceManager.getUserService();
-				localeService = serviceManager.getLocaleService();
-				preferenceService = serviceManager.getPreferenceService();
-				threemaSafeService = serviceManager.getThreemaSafeService();
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-			finish();
-			return;
-		}
-		if (userService == null || localeService == null || preferenceService == null) {
-			logger.error("Required services not available.");
-			finish();
-			return;
-		}
-
-		setContentView(R.layout.activity_wizard);
-
-		nextButton = findViewById(R.id.next_page_button);
-		nextButton.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View v) {
-				nextPage();
-			}
-		});
-
-		prevButton = findViewById(R.id.prev_page_button);
-		prevButton.setVisibility(View.GONE);
-		prevButton.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View v) {
-				prevPage();
-			}
-		});
-
-		stepPagerStrip = findViewById(R.id.strip);
-		stepPagerStrip.setPageCount(NUM_PAGES);
-		stepPagerStrip.setCurrentPage(WizardFragment0.PAGE_ID);
-
-		viewPager = findViewById(R.id.pager);
-		viewPager.addLayer(findViewById(R.id.layer0));
-		viewPager.addLayer(findViewById(R.id.layer1));
-
-		Intent intent = getIntent();
-		if (intent != null) {
-			isNewIdentity = intent.getBooleanExtra(EXTRA_NEW_IDENTITY_CREATED, false);
-		}
-
-		if (ConfigUtils.isWorkBuild()) {
-			performWorkSync();
-		} else {
-			setupConfig();
-		}
-	}
-
-	private void setupConfig() {
-		safeConfig = ThreemaSafeMDMConfig.getInstance();
-
-		viewPager.setAdapter(new ScreenSlidePagerAdapter(getSupportFragmentManager()));
-		viewPager.addOnPageChangeListener(this);
-
-		if (ConfigUtils.isWorkRestricted()) {
-			if (isSafeEnabled()) {
-				if (isSafeForced()) {
-					safePassword = safeConfig.getPassword();
-				}
-				safeServerInfo = safeConfig.getServerInfo();
-			}
-
-			String stringPreset;
-			Boolean booleanPreset;
-
-			stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_email));
-			if (stringPreset != null) {
-				email = stringPreset;
-			}
-			stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_phone));
-			if (stringPreset != null) {
-				splitMobile(stringPreset);
-			}
-			stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__nickname));
-			if (stringPreset != null) {
-				nickname = stringPreset;
-			} else {
-				nickname = userService.getIdentity();
-			}
-			booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__contact_sync));
-			if (booleanPreset != null) {
-				isSyncContacts = booleanPreset;
-				userCannotChangeContactSync = true;
-			}
-			booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__readonly_profile));
-			if (booleanPreset != null) {
-				readOnlyProfile = booleanPreset;
-			}
-			booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__skip_wizard));
-			if (booleanPreset != null) {
-				if (booleanPreset) {
-					skipWizard = true;
-					viewPager.post(() -> viewPager.setCurrentItem(WizardFragment4.PAGE_ID));
-				}
-			}
-		} else {
-			// ignore backup presets in restricted mode
-			if (!TestUtil.isEmptyOrNull(presetMobile)) {
-				splitMobile(presetMobile);
-			}
-			if (!TestUtil.isEmptyOrNull(presetEmail)) {
-				email = presetEmail;
-			}
-
-		}
-
-		// if the app is running in a restricted user profile, it s not possible to add accounts
-		if (SynchronizeContactsUtil.isRestrictedProfile(this)) {
-			userCannotChangeContactSync = true;
-			isSyncContacts = false;
-		}
-
-		presetMobile = this.userService.getLinkedMobile();
-		presetEmail = this.userService.getLinkedEmail();
-
-		if (ConfigUtils.isWorkRestricted()) {
-			// confirm the use of a managed password
-			if (!safeConfig.isBackupDisabled() && safeConfig.isBackupPasswordPreset()) {
-				WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_managed_password_confirm, R.string.accept, R.string.real_not_now, WizardDialog.Highlight.NONE);
-				wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_PRESET_CONFIRM);
-			}
-		}
-	}
-
-	/**
-	 * Perform an early synchronous fetch2. In case of failure due to rate-limiting, do not allow user to continue
-	 */
-	private void performWorkSync() {
-		GenericProgressDialog.newInstance(R.string.work_data_sync_desc,
-			R.string.please_wait).show(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC);
-
-		WorkSyncWorker.Companion.performOneTimeWorkSync(
-			this,
-			() -> {
-				// On success
-				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
-				setupConfig();
-			},
-			() -> {
-				// On fail
-				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
-				RuntimeUtil.runOnUiThread(() -> Toast.makeText(WizardBaseActivity.this, R.string.unable_to_fetch_configuration, Toast.LENGTH_LONG).show());
-				logger.info("Unable to post work request for fetch2");
-				try {
-					userService.removeIdentity();
-				} catch (Exception e) {
-					logger.error("Unable to remove identity", e);
-				}
-				finishAndRemoveTask();
-			});
-	}
-
-	private void splitMobile(String phoneNumber) {
-		if (PHONE_LINKED_PLACEHOLDER.equals(phoneNumber)) {
-			prefix = "";
-			number = PHONE_LINKED_PLACEHOLDER;
-		} else {
-			try {
-				PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();
-				Phonenumber.PhoneNumber numberProto = null;
-
-				numberProto = phoneNumberUtil.parse(phoneNumber, "");
-				prefix = "+" + numberProto.getCountryCode();
-				number = String.valueOf(numberProto.getNationalNumber());
-			} catch (NumberParseException e) {
-				logger.error("Exception", e);
-			}
-		}
-	}
-
-	@Override
-	protected void onDestroy() {
-		viewPager.removeOnPageChangeListener(this);
-
-		super.onDestroy();
-	}
-
-	/**
-	 * This method will be invoked when the current page is scrolled, either as part
-	 * of a programmatically initiated smooth scroll or a user initiated touch scroll.
-	 *
-	 * @param position             Position index of the first page currently being displayed.
-	 *                             Page position+1 will be visible if positionOffset is nonzero.
-	 * @param positionOffset       Value from [0, 1) indicating the offset from the page at position.
-	 * @param positionOffsetPixels Value in pixels indicating the offset from position.
-	 */
-	@Override
-	public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-
-	}
-
-	/**
-	 * This method will be invoked when a new page becomes selected. Animation is not
-	 * necessarily complete.
-	 *
-	 * @param position Position index of the new selected page.
-	 */
-	@SuppressLint("StaticFieldLeak")
-	@Override
-	public void onPageSelected(int position) {
-		prevButton.setVisibility(position == WizardFragment0.PAGE_ID ? View.GONE : View.VISIBLE);
-		nextButton.setVisibility(position == NUM_PAGES - 1 ? View.GONE : View.VISIBLE);
-
-		stepPagerStrip.setCurrentPage(position);
-
-		if (position == WizardFragment1.PAGE_ID && safeConfig.isSkipBackupPasswordEntry()) {
-			if (lastPage == WizardFragment0.PAGE_ID) {
-				nextPage();
-			} else {
-				prevPage();
-			}
-			return;
-		}
-
-		if (position == WizardFragment2.PAGE_ID && lastPage == WizardFragment1.PAGE_ID) {
-			if (!TextUtils.isEmpty(safePassword)) {
-				new AsyncTask<Void, Void, Boolean>() {
-					@Override
-					protected Boolean doInBackground(Void... voids) {
-						return TextUtil.checkBadPassword(getApplicationContext(), safePassword);
-					}
-
-					@Override
-					protected void onPostExecute(Boolean isBad) {
-						if (isBad) {
-							Context context = WizardBaseActivity.this;
-							if (AppRestrictionUtil.isSafePasswordPatternSet(context)) {
-								WizardDialog wizardDialog = WizardDialog.newInstance(AppRestrictionUtil.getSafePasswordMessage(context), R.string.try_again);
-								wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD);
-							} else {
-								WizardDialog wizardDialog = WizardDialog.newInstance(R.string.password_bad_explain, R.string.continue_anyway, R.string.try_again, WizardDialog.Highlight.NEGATIVE);
-								wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD);
-							}
-						}
-					}
-				}.execute();
-			}
-		}
-
-		if (position > lastPage && position >= WizardFragment2.PAGE_ID && position <= WizardFragment4.PAGE_ID) {
-			// we delay dialogs for a few milliseconds to prevent stuttering of the page change animation
-			dialogHandler.removeCallbacks(showDialogDelayedTask(position, lastPage));
-			dialogHandler.postDelayed(showDialogDelayedTask(position, lastPage), DIALOG_DELAY);
-		}
-
-		lastPage = position;
-	}
-
-	/**
-	 * Called when the scroll state changes. Useful for discovering when the user
-	 * begins dragging, when the pager is automatically settling to the current page,
-	 * or when it is fully stopped/idle.
-	 *
-	 * @param state The new scroll state.
-	 * @see ViewPager#SCROLL_STATE_IDLE
-	 * @see ViewPager#SCROLL_STATE_DRAGGING
-	 * @see ViewPager#SCROLL_STATE_SETTLING
-	 */
-	@Override
-	public void onPageScrollStateChanged(int state) { }
-
-	/**
-	 * Called when a view has been clicked.
-	 *
-	 * @param v The view that was clicked.
-	 */
-	@Override
-	public void onClick(View v) {
-		if (v.equals(nextButton)) {
-			nextPage();
-		} else if (v.equals(prevButton)) {
-			prevPage();
-		}
-	}
-
-	@Override
-	public void onWizardFinished(WizardFragment4 fragment, Button finishButton) {
-		errorRaised = false;
-		fragment4 = fragment;
-
-		viewPager.lock(true);
-		this.finishButton = finishButton;
-
-		prevButton.setVisibility(View.GONE);
-		if (finishButton != null) {
-			finishButton.setEnabled(false);
-		}
-
-		userService.setPublicNickname(this.nickname);
-
-		askUserForContactSync();
-	}
-
-	private void askUserForContactSync() {
-		/* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
-		serviceManager.getLifetimeService().ensureConnection();
-
-		if (this.userCannotChangeContactSync) {
-			if (this.isSyncContacts) {
-				if (ConfigUtils.isPermissionGranted(this, Manifest.permission.READ_CONTACTS)) {
-					// Permission already granted, therefore continue by linking the phone
-					linkPhone();
-				} else {
-					// If permission is not yet granted, show a dialog to inform that contact sync
-					// has been force enabled by the administrator
-					WizardDialog wizardDialog = WizardDialog.newInstance(R.string.contact_sync_mdm_rationale, R.string.ok);
-					wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE);
-				}
-			} else {
-				linkPhone();
-			}
-		} else {
-			if (this.skipWizard) {
-				isSyncContacts = false;
-				this.serviceManager.getPreferenceService().setSyncContacts(false);
-				linkPhone();
-			} else {
-				WizardDialog wizardDialog = WizardDialog.newInstance(R.string.new_wizard_info_sync_contacts_dialog, R.string.yes, R.string.no, null);
-				wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_ENABLE);
-			}
-		}
-	}
-
-	private void requestContactSyncPermission() {
-		if (ConfigUtils.requestContactPermissions(this, null, PERMISSION_REQUEST_READ_CONTACTS)) {
-			// permission is already granted
-			this.isSyncContacts = true;
-			preferenceService.setSyncContacts(this.isSyncContacts);
-			linkPhone();
-		}
-		// continue to onRequestPermissionsResult
-	}
-
-	@Override
-	public void onNicknameSet(String nickname) {
-		this.nickname = nickname;
-	}
-
-	@Override
-	public void onPhoneSet(String phoneNumber) {
-		this.number = phoneNumber;
-	}
-
-	@Override
-	public void onPrefixSet(String prefix) {
-		this.prefix = prefix;
-	}
-
-	@Override
-	public void onEmailSet(String email) {
-		this.email = email;
-	}
-
-	@Override
-	public void onSafePasswordSet(final String password) {
-		safePassword = password;
-	}
-
-	@Override
-	public void onSafeServerInfoSet(ThreemaSafeServerInfo safeServerInfo) {
-		this.safeServerInfo = safeServerInfo;
-	}
-
-	@Override
-	public String getNickname() {
-		return this.nickname;
-	}
-
-	@Override
-	public String getPhone() {
-		if (PHONE_LINKED_PLACEHOLDER.equals(this.number)) {
-			return this.number;
-		}
-
-		String phone = this.prefix + this.number;
-
-		if (localeService.validatePhoneNumber(phone)) {
-			return serviceManager.getLocaleService().getNormalizedPhoneNumber(phone);
-		}
-		return "";
-	}
-
-	@Override
-	public String getNumber() {
-		return this.number;
-	}
-
-	@Override
-	public String getPrefix() {
-		return this.prefix;
-	}
-
-	@Override
-	public String getEmail() {
-		return (this.email != null && this.email.length() > 4) ? this.email : "";
-	}
-
-	@Override
-	public String getPresetPhone() {
-		return this.presetMobile;
-	}
-
-	@Override
-	public String getPresetEmail() {
-		return this.presetEmail;
-	}
-
-	@Override
-	public boolean getSafeForcePasswordEntry() {
-		return safeConfig.isBackupForced();
-	}
-
-	@Override
-	public boolean getSafeSkipBackupPasswordEntry() {
-		return safeConfig.isSkipBackupPasswordEntry();
-	}
-
-	@Override
-	public boolean isSafeEnabled() {
-		return !safeConfig.isBackupDisabled();
-	}
-
-	@Override
-	public boolean isSafeForced() {
-		return safeConfig.isBackupForced();
-	}
-
-	@Override
-	public String getSafePassword() {
-		return this.safePassword;
-	}
-
-	@Override
-	public ThreemaSafeServerInfo getSafeServerInfo() {
-		return this.safeServerInfo;
-	}
-
-	@Override
-	public boolean getSyncContacts() {
-		return this.isSyncContacts;
-	}
-
-	@Override
-	public boolean isReadOnlyProfile() {
-		return this.readOnlyProfile;
-	}
-
-	@Override
-	public boolean isSkipWizard() {
-		return this.skipWizard;
-	}
-
-	/**
-	 * Return whether the identity was just created
-	 * @return true if it's a new identity, false if the identity was restored
-	 */
-	public boolean isNewIdentity() {
-		return isNewIdentity;
-	}
-
-	@Override
-	public void onYes(String tag, Object data) {
-		switch (tag) {
-			case DIALOG_TAG_USE_ID_AS_NICKNAME:
-				this.nickname = this.userService.getIdentity();
-				break;
-			case DIALOG_TAG_INVALID_ENTRY:
-			case DIALOG_TAG_PASSWORD_BAD:
-				prevPage();
-				break;
-			case DIALOG_TAG_THREEMA_SAFE:
-			case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
-				break;
-			case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
-			case DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE:
-				requestContactSyncPermission();
-				break;
-			case DIALOG_TAG_APPLICATION_SETUP_RETRY:
-				runApplicationSetupStepsAndRestart();
-				break;
-		}
-	}
-
-	@Override
-	public void onNo(String tag) {
-		switch (tag) {
-			case DIALOG_TAG_USE_ID_AS_NICKNAME:
-				prevPage();
-				break;
-			case DIALOG_TAG_USE_ANONYMOUSLY:
-				setPage(WizardFragment3.PAGE_ID);
-				break;
-			case DIALOG_TAG_THREEMA_SAFE:
-				prevPage();
-				break;
-			case DIALOG_TAG_PASSWORD_BAD:
-				setPage(WizardFragment1.PAGE_ID);
-				break;
-			case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
-				isSyncContacts = false;
-				this.serviceManager.getPreferenceService().setSyncContacts(false);
-				linkPhone();
-				break;
-			case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
-				finish();
-				System.exit(0);
-				break;
-		}
-	}
-
-	@Override
-	protected boolean enableOnBackPressedCallback() {
-		return true;
-	}
-
-	@Override
-	protected void handleOnBackPressed() {
-		if (prevButton != null && prevButton.getVisibility() == View.VISIBLE) {
-			prevPage();
-		}
-	}
-
-	private class ScreenSlidePagerAdapter extends FragmentStatePagerAdapter {
-		public ScreenSlidePagerAdapter(FragmentManager fm) {
-			super(fm, FragmentStatePagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
-		}
-
-		@Override
-		public Fragment getItem(int position) {
-			switch (position) {
-				case WizardFragment0.PAGE_ID:
-					return new WizardFragment0();
-				case WizardFragment1.PAGE_ID:
-					return new WizardFragment1();
-				case WizardFragment2.PAGE_ID:
-					return new WizardFragment2();
-				case WizardFragment3.PAGE_ID:
-					return new WizardFragment3();
-				case WizardFragment4.PAGE_ID:
-					return new WizardFragment4();
-				default:
-					break;
-			}
-			return null;
-		}
-
-		@Override
-		public int getCount() {
-			return NUM_PAGES;
-		}
-	}
-
-	public void nextPage() {
-		int currentItem = viewPager.getCurrentItem() + 1;
-		if (currentItem < NUM_PAGES) {
-			viewPager.setCurrentItem(currentItem);
-		}
-	}
-
-	public void prevPage() {
-		int currentItem = viewPager.getCurrentItem();
-		if (currentItem != 0) {
-			viewPager.setCurrentItem(currentItem - 1);
-		}
-	}
-
-	public void setPage(int page) {
-		viewPager.setCurrentItem(page);
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void linkEmail(final WizardFragment4 fragment) {
-		final String newEmail = getEmail();
-		if (TestUtil.isEmptyOrNull(newEmail)) {
-			initSyncAndFinish();
-			return;
-		}
-
-		boolean isNewEmail = (!(presetEmail != null && presetEmail.equals(newEmail)));
-
-		if ((userService.getEmailLinkingState() != UserService.LinkingState_LINKED) && isNewEmail) {
-			new AsyncTask<Void, Void, String>() {
-				@Override
-				protected void onPreExecute() {
-					fragment.setEmailLinkingInProgress(true);
-				}
-
-				@Override
-				protected String doInBackground(Void... params) {
-					try {
-						userService.linkWithEmail(email);
-					} catch (LinkEmailException e) {
-						logger.error("Exception", e);
-						return e.getMessage();
-					} catch (Exception e) {
-						logger.error("Exception", e);
-						return getString(R.string.internet_connection_required);
-					}
-					return null;
-				}
-
-				@Override
-				protected void onPostExecute(String result) {
-					if (result != null) {
-						fragment.setEmailLinkingAlert(result);
-						errorRaised = true;
-					} else {
-						fragment.setEmailLinkingInProgress(false);
-					}
-					initSyncAndFinish();
-				}
-			}.execute();
-		} else {
-			initSyncAndFinish();
-		}
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void linkPhone() {
-		final String phone = getPhone();
-		if (TestUtil.isEmptyOrNull(phone)) {
-			linkEmail(fragment4);
-			return;
-		}
-
-		boolean isNewPhoneNumber = (presetMobile == null || !presetMobile.equals(phone));
-
-		// start linking activity only if not already linked
-		if ((userService.getMobileLinkingState() != UserService.LinkingState_LINKED) && isNewPhoneNumber) {
-			new AsyncTask<Void, Void, String>() {
-				@Override
-				protected void onPreExecute() {
-					fragment4.setMobileLinkingInProgress(true);
-				}
-
-				@Override
-				protected String doInBackground(Void... params) {
-					try {
-						userService.linkWithMobileNumber(phone);
-					} catch (LinkMobileNoException e) {
-						logger.error("Exception", e);
-						return e.getMessage();
-					} catch (Exception e) {
-						logger.error("Exception", e);
-						return getString(R.string.internet_connection_required);
-					}
-					return null;
-				}
-
-				@Override
-				protected void onPostExecute(String result) {
-					if (result != null) {
-						fragment4.setMobileLinkingAlert(result);
-						errorRaised = true;
-					} else {
-						fragment4.setMobileLinkingInProgress(false);
-					}
-					linkEmail(fragment4);
-				}
-			}.execute();
-		} else {
-			linkEmail(fragment4);
-		}
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void addUser(final String id, final String first, final String last) {
-		new AsyncTask<Void, Void, Void>() {
-
-			@Override
-			protected Void doInBackground(Void... params) {
-				try {
-					ContactModel newUser = serviceManager.getContactService()
-							.createContactByIdentity(id, true);
-
-					if (newUser != null) {
-						newUser.setFirstName(first);
-						newUser.setLastName(last);
-						serviceManager.getContactService().save(newUser);
-					}
-
-				} catch (InvalidEntryException | MasterKeyLockedException | FileSystemNotPresentException e) {
-					logger.error("Exception", e);
-					//should not happen, ignore
-				} catch (EntryAlreadyExistsException | PolicyViolationException e) {
-					//ok, id already exists or adding IDs is prohibited, do nothing
-				}
-				return null;
-			}
-		}.execute();
-	}
-
-	private void runApplicationSetupStepsAndRestart() {
-		backgroundExecutor.execute(new BackgroundTask<Boolean>() {
-			@Override
-			public void runBefore() {
-				// Nothing to do
-			}
-
-			@Override
-			public Boolean runInBackground() {
-				return runApplicationSetupSteps(serviceManager, WizardBaseActivity.this);
-			}
-
-			@Override
-			public void runAfter(Boolean result) {
-				if (!Boolean.TRUE.equals(result)) {
-					WizardDialog.newInstance(R.string.application_setup_steps_failed, R.string.retry)
-						.show(getSupportFragmentManager(), DIALOG_TAG_APPLICATION_SETUP_RETRY);
-					return;
-				}
-
-				preferenceService.setWizardRunning(false);
-				preferenceService.setLatestVersion(WizardBaseActivity.this);
-
-				addUser(ThreemaApplication.ECHO_USER_IDENTITY, "Echo", "Test");
-
-				// Flush conversation cache (after a restore) to ensure that the conversation list
-				// will be loaded from the database to prevent the list being incomplete.
-				try {
-					serviceManager.getConversationService().reset();
-				} catch (Exception e) {
-					logger.error("Exception", e);
-				}
-
-				ConfigUtils.recreateActivity(WizardBaseActivity.this);
-			}
-		});
-	}
-
-	private void ensureMasterKeyWrite() {
-		// Write master key now if no passphrase has been set - don't leave it up to the MainActivity
-		if (!ThreemaApplication.getMasterKey().isProtected()) {
-			try {
-				ThreemaApplication.getMasterKey().setPassphrase(null);
-			} catch (Exception e) {
-				// better die if something went wrong as the master key may not have been saved
-				throw new RuntimeException(e);
-			}
-		}
-	}
-
-	@SuppressLint({"StaticFieldLeak", "MissingPermission"})
-	private void reallySyncContactsAndFinish() {
-		ensureMasterKeyWrite();
-
-		if (preferenceService.isSyncContacts()) {
-			new AsyncTask<Void, Void, Void>() {
-				@Override
-				protected void onPreExecute() {
-					fragment4.setContactsSyncInProgress(true, getString(R.string.wizard1_sync_contacts));
-				}
-
-				@SuppressLint("MissingPermission")
-				@Override
-				protected Void doInBackground(Void... params) {
-					try {
-						final Account account = userService.getAccount(true);
-						//disable
-						userService.enableAccountAutoSync(false);
-
-						SynchronizeContactsService synchronizeContactsService = serviceManager.getSynchronizeContactsService();
-						SynchronizeContactsRoutine routine = synchronizeContactsService.instantiateSynchronization(account);
-
-						routine.setOnStatusUpdate(new SynchronizeContactsRoutine.OnStatusUpdate() {
-							@Override
-							public void newStatus(final long percent, final String message) {
-							 	RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(true, message));
-							}
-
-							@Override
-							public void error(final Exception x) {
-							 	RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(false, x.getMessage()));
-							}
-						});
-
-						//on finished, close the dialog
-						routine.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
-							@Override
-							public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
-								userService.enableAccountAutoSync(true);
-							}
-						});
-
-						routine.run();
-					} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
-						logger.error("Exception", e);
-					}
-					return null;
-				}
-
-				@Override
-				protected void onPostExecute(Void result) {
-					finishHandler.removeCallbacks(finishTask);
-					finishHandler.postDelayed(finishTask, FINISH_DELAY);
-				}
-			}.execute();
-		} else {
-			userService.removeAccount();
-			prepareThreemaSafe();
-		}
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void prepareThreemaSafe() {
-		if (!TestUtil.isEmptyOrNull(getSafePassword())) {
-			new AsyncTask<Void, Void, byte[]>() {
-				@Override
-				protected void onPreExecute() {
-					fragment4.setThreemaSafeInProgress(true, getString(R.string.preparing_threema_safe));
-				}
-
-				@Override
-				protected byte[] doInBackground(Void... voids) {
-					return threemaSafeService.deriveMasterKey(getSafePassword(), userService.getIdentity());
-				}
-
-				@Override
-				protected void onPostExecute(byte[] masterkey) {
-					fragment4.setThreemaSafeInProgress(false, getString(R.string.menu_done));
-
-					if (masterkey != null) {
-						threemaSafeService.storeMasterKey(masterkey);
-						preferenceService.setThreemaSafeServerInfo(safeServerInfo);
-						threemaSafeService.setEnabled(true);
-						threemaSafeService.uploadNow(true);
-					} else {
-						Toast.makeText(WizardBaseActivity.this, R.string.safe_error_preparing, Toast.LENGTH_LONG).show();
-					}
-
-					runApplicationSetupStepsAndRestart();
-				}
-			}.execute();
-		} else {
-			// no password was set
-			// do not save mdm settings if backup is forced and no password was set - this will cause a password prompt later
-			if (!(ConfigUtils.isWorkRestricted() && ThreemaSafeMDMConfig.getInstance().isBackupForced())) {
-				threemaSafeService.storeMasterKey(new byte[0]);
-			}
-			runApplicationSetupStepsAndRestart();
-		}
-	}
-
-	private void initSyncAndFinish() {
-		if (!errorRaised || ConfigUtils.isWorkRestricted()) {
-			syncContactsAndFinish();
-		} else {
-			resetUi();
-		}
-	}
-
-	private void resetUi() {
-		// unlock UI to try again
-		viewPager.lock(false);
-		prevButton.setVisibility(View.VISIBLE);
-		if (finishButton != null) {
-			finishButton.setEnabled(true);
-		}
-	}
-
-	private void syncContactsAndFinish() {
-		/* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
-		serviceManager.getLifetimeService().ensureConnection();
-
-		if (this.isSyncContacts) {
-			preferenceService.setSyncContacts(true);
-			reallySyncContactsAndFinish();
-		} else {
-			preferenceService.setSyncContacts(false);
-			prepareThreemaSafe();
-		}
-	}
-
-	@Override
-	public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-		super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-		if (requestCode == PERMISSION_REQUEST_READ_CONTACTS) {
-			if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-				this.isSyncContacts = true;
-				linkPhone();
-			} else if (userCannotChangeContactSync) {
-				ConfigUtils.showPermissionRationale(this, (View) viewPager.getParent(), R.string.permission_contacts_sync_required);
-				resetUi();
-			} else {
-				this.isSyncContacts = false;
-				linkPhone();
-			}
-		}
-	}
+    LifecycleOwner,
+    ViewPager.OnPageChangeListener,
+    View.OnClickListener,
+    WizardFragment1.OnSettingsChangedListener,
+    WizardFragment2.OnSettingsChangedListener,
+    WizardFragment3.OnSettingsChangedListener,
+    WizardFragment4.SettingsInterface,
+    WizardDialog.WizardDialogCallback {
+
+    private static final Logger logger = LoggingUtil.getThreemaLogger("WizardBaseActivity");
+
+    public static final String EXTRA_NEW_IDENTITY_CREATED = "newIdentity";
+    private static final String DIALOG_TAG_USE_ID_AS_NICKNAME = "nd";
+    private static final String DIALOG_TAG_INVALID_ENTRY = "ie";
+    private static final String DIALOG_TAG_USE_ANONYMOUSLY = "ano";
+    private static final String DIALOG_TAG_THREEMA_SAFE = "sd";
+    private static final String DIALOG_TAG_PASSWORD_BAD = "pwb";
+    private static final String DIALOG_TAG_PASSWORD_BAD_WORK = "pwbw";
+    private static final String DIALOG_TAG_SYNC_CONTACTS_ENABLE = "scen";
+    private static final String DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE = "scmer";
+    private static final String DIALOG_TAG_APPLICATION_SETUP_RETRY = "app-setup-retry";
+
+    private static final int PERMISSION_REQUEST_READ_CONTACTS = 2;
+    private static final int NUM_PAGES = 5;
+    private static final long FINISH_DELAY = 3 * 1000;
+    private static final long DIALOG_DELAY = 200;
+
+    public static final boolean DEFAULT_SYNC_CONTACTS = false;
+    private static final String DIALOG_TAG_WORK_SYNC = "workSync";
+    private static final String DIALOG_TAG_PASSWORD_PRESET_CONFIRM = "pwPreset";
+
+    private static int lastPage = 0;
+    private ParallaxViewPager viewPager;
+    private MaterialButton prevButton, nextButton;
+    private Button finishButton;
+    private StepPagerStrip stepPagerStrip;
+    private String nickname, email, number, prefix, presetMobile, presetEmail, safePassword;
+    private ThreemaSafeServerInfo safeServerInfo = new ThreemaSafeServerInfo();
+    private boolean isSyncContacts = DEFAULT_SYNC_CONTACTS, userCannotChangeContactSync = false, skipWizard = false, readOnlyProfile = false;
+    private ThreemaSafeMDMConfig safeConfig;
+    private ServiceManager serviceManager;
+    private UserService userService;
+    private LocaleService localeService;
+    private PreferenceService preferenceService;
+    private ThreemaSafeService threemaSafeService;
+    private APIConnector apiConnector;
+    private ContactModelRepository contactModelRepository;
+    private boolean errorRaised = false, isNewIdentity = false;
+    private WizardFragment4 fragment4;
+    private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
+
+    private final Handler finishHandler = new Handler();
+    private final Handler dialogHandler = new Handler();
+
+    private final Runnable finishTask = new Runnable() {
+        @Override
+        public void run() {
+            RuntimeUtil.runOnUiThread(() -> {
+                fragment4.setContactsSyncInProgress(false, null);
+                prepareThreemaSafe();
+            });
+        }
+    };
+
+    private Runnable showDialogDelayedTask(final int current, final int previous) {
+        return () -> RuntimeUtil.runOnUiThread(() -> {
+            if (current == WizardFragment2.PAGE_ID && previous == WizardFragment1.PAGE_ID && TestUtil.isEmptyOrNull(getSafePassword())) {
+                if (safeConfig.isBackupForced()) {
+                    setPage(WizardFragment1.PAGE_ID);
+                } else if (!isReadOnlyProfile()) {
+                    WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_disable_confirm, R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
+                    wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_THREEMA_SAFE);
+                }
+            }
+
+            if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
+                if (!isReadOnlyProfile()) {
+                    if ((!TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(presetMobile) && !localeService.validatePhoneNumber(getPhone())) ||
+                        ((!TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(presetEmail) && !Patterns.EMAIL_ADDRESS.matcher(email).matches()))) {
+                        WizardDialog wizardDialog = WizardDialog.newInstance(ConfigUtils.isWorkBuild() ?
+                                R.string.new_wizard_phone_email_invalid :
+                                R.string.new_wizard_phone_invalid,
+                            R.string.ok);
+                        wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_INVALID_ENTRY);
+                    }
+                }
+            }
+
+            if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
+                if (!isReadOnlyProfile()) {
+                    boolean needConfirm;
+                    if (ConfigUtils.isWorkBuild()) {
+                        needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(getPresetEmail()) && TestUtil.isEmptyOrNull(getPresetPhone());
+                    } else {
+                        if (ConfigUtils.isOnPremBuild()) {
+                            needConfirm = false;
+                        } else {
+                            needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(getPresetPhone());
+                        }
+                    }
+                    if (needConfirm) {
+                        WizardDialog wizardDialog = WizardDialog.newInstance(
+                            ConfigUtils.isWorkBuild() ?
+                                R.string.new_wizard_anonymous_confirm :
+                                R.string.new_wizard_anonymous_confirm_phone_only,
+                            R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
+                        wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_USE_ANONYMOUSLY);
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        try {
+            serviceManager = ThreemaApplication.getServiceManager();
+            if (serviceManager != null) {
+                userService = serviceManager.getUserService();
+                localeService = serviceManager.getLocaleService();
+                preferenceService = serviceManager.getPreferenceService();
+                threemaSafeService = serviceManager.getThreemaSafeService();
+                apiConnector = serviceManager.getAPIConnector();
+                contactModelRepository = serviceManager.getModelRepositories().getContacts();
+            }
+        } catch (Exception e) {
+            logger.error("Exception", e);
+            finish();
+            return;
+        }
+        if (userService == null || localeService == null || preferenceService == null) {
+            logger.error("Required services not available.");
+            finish();
+            return;
+        }
+
+        setContentView(R.layout.activity_wizard);
+
+        nextButton = findViewById(R.id.next_page_button);
+        nextButton.setOnClickListener(v -> nextPage());
+
+        prevButton = findViewById(R.id.prev_page_button);
+        prevButton.setVisibility(View.GONE);
+        prevButton.setOnClickListener(v -> prevPage());
+
+        stepPagerStrip = findViewById(R.id.strip);
+        stepPagerStrip.setPageCount(NUM_PAGES);
+        stepPagerStrip.setCurrentPage(WizardFragment0.PAGE_ID);
+
+        viewPager = findViewById(R.id.pager);
+        viewPager.addLayer(findViewById(R.id.layer0));
+        viewPager.addLayer(findViewById(R.id.layer1));
+
+        Intent intent = getIntent();
+        if (intent != null) {
+            isNewIdentity = intent.getBooleanExtra(EXTRA_NEW_IDENTITY_CREATED, false);
+        }
+
+        if (ConfigUtils.isWorkBuild()) {
+            performWorkSync();
+        } else {
+            setupConfig();
+        }
+    }
+
+    private void setupConfig() {
+        safeConfig = ThreemaSafeMDMConfig.getInstance();
+
+        viewPager.setAdapter(new ScreenSlidePagerAdapter(getSupportFragmentManager()));
+        viewPager.addOnPageChangeListener(this);
+
+        if (ConfigUtils.isWorkRestricted()) {
+            if (isSafeEnabled()) {
+                if (isSafeForced()) {
+                    safePassword = safeConfig.getPassword();
+                }
+                safeServerInfo = safeConfig.getServerInfo();
+            }
+
+            String stringPreset;
+            Boolean booleanPreset;
+
+            stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_email));
+            if (stringPreset != null) {
+                email = stringPreset;
+            }
+            stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_phone));
+            if (stringPreset != null) {
+                splitMobile(stringPreset);
+            }
+            stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__nickname));
+            if (stringPreset != null) {
+                nickname = stringPreset;
+            } else {
+                nickname = userService.getIdentity();
+            }
+            booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__contact_sync));
+            if (booleanPreset != null) {
+                isSyncContacts = booleanPreset;
+                userCannotChangeContactSync = true;
+            }
+            booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__readonly_profile));
+            if (booleanPreset != null) {
+                readOnlyProfile = booleanPreset;
+            }
+            booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__skip_wizard));
+            if (booleanPreset != null) {
+                if (booleanPreset) {
+                    skipWizard = true;
+                    viewPager.post(() -> viewPager.setCurrentItem(WizardFragment4.PAGE_ID));
+                }
+            }
+        } else {
+            // ignore backup presets in restricted mode
+            if (!TestUtil.isEmptyOrNull(presetMobile)) {
+                splitMobile(presetMobile);
+            }
+            if (!TestUtil.isEmptyOrNull(presetEmail)) {
+                email = presetEmail;
+            }
+
+        }
+
+        // if the app is running in a restricted user profile, it s not possible to add accounts
+        if (SynchronizeContactsUtil.isRestrictedProfile(this)) {
+            userCannotChangeContactSync = true;
+            isSyncContacts = false;
+        }
+
+        presetMobile = this.userService.getLinkedMobile();
+        presetEmail = this.userService.getLinkedEmail();
+
+        if (ConfigUtils.isWorkRestricted()) {
+            // confirm the use of a managed password
+            if (!safeConfig.isBackupDisabled() && safeConfig.isBackupPasswordPreset()) {
+                WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_managed_password_confirm, R.string.accept, R.string.real_not_now, WizardDialog.Highlight.NONE);
+                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_PRESET_CONFIRM);
+            }
+        }
+    }
+
+    /**
+     * Perform an early synchronous fetch2. In case of failure due to rate-limiting, do not allow user to continue
+     */
+    private void performWorkSync() {
+        GenericProgressDialog.newInstance(R.string.work_data_sync_desc,
+            R.string.please_wait).show(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC);
+
+        WorkSyncWorker.Companion.performOneTimeWorkSync(
+            this,
+            () -> {
+                // On success
+                DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
+                setupConfig();
+            },
+            () -> {
+                // On fail
+                DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
+                RuntimeUtil.runOnUiThread(() -> Toast.makeText(WizardBaseActivity.this, R.string.unable_to_fetch_configuration, Toast.LENGTH_LONG).show());
+                logger.info("Unable to post work request for fetch2");
+                try {
+                    userService.removeIdentity();
+                } catch (Exception e) {
+                    logger.error("Unable to remove identity", e);
+                }
+                finishAndRemoveTask();
+            });
+    }
+
+    private void splitMobile(String phoneNumber) {
+        if (PHONE_LINKED_PLACEHOLDER.equals(phoneNumber)) {
+            prefix = "";
+            number = PHONE_LINKED_PLACEHOLDER;
+        } else {
+            try {
+                PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();
+                Phonenumber.PhoneNumber numberProto = phoneNumberUtil.parse(phoneNumber, "");
+                prefix = "+" + numberProto.getCountryCode();
+                number = String.valueOf(numberProto.getNationalNumber());
+            } catch (NumberParseException e) {
+                logger.error("Exception", e);
+            }
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        viewPager.removeOnPageChangeListener(this);
+
+        super.onDestroy();
+    }
+
+    /**
+     * This method will be invoked when the current page is scrolled, either as part
+     * of a programmatically initiated smooth scroll or a user initiated touch scroll.
+     *
+     * @param position             Position index of the first page currently being displayed.
+     *                             Page position+1 will be visible if positionOffset is nonzero.
+     * @param positionOffset       Value from [0, 1) indicating the offset from the page at position.
+     * @param positionOffsetPixels Value in pixels indicating the offset from position.
+     */
+    @Override
+    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+
+    }
+
+    /**
+     * This method will be invoked when a new page becomes selected. Animation is not
+     * necessarily complete.
+     *
+     * @param position Position index of the new selected page.
+     */
+    @SuppressLint("StaticFieldLeak")
+    @Override
+    public void onPageSelected(int position) {
+        prevButton.setVisibility(position == WizardFragment0.PAGE_ID ? View.GONE : View.VISIBLE);
+        nextButton.setVisibility(position == NUM_PAGES - 1 ? View.GONE : View.VISIBLE);
+
+        stepPagerStrip.setCurrentPage(position);
+
+        if (position == WizardFragment1.PAGE_ID && safeConfig.isSkipBackupPasswordEntry()) {
+            if (lastPage == WizardFragment0.PAGE_ID) {
+                nextPage();
+            } else {
+                prevPage();
+            }
+            return;
+        }
+
+        if (position == WizardFragment2.PAGE_ID && lastPage == WizardFragment1.PAGE_ID) {
+            if (!TextUtils.isEmpty(safePassword)) {
+                new AsyncTask<Void, Void, Boolean>() {
+                    @Override
+                    protected Boolean doInBackground(Void... voids) {
+                        return TextUtil.checkBadPassword(getApplicationContext(), safePassword);
+                    }
+
+                    @Override
+                    protected void onPostExecute(Boolean isBad) {
+                        if (isBad) {
+                            Context context = WizardBaseActivity.this;
+                            if (AppRestrictionUtil.isSafePasswordPatternSet(context)) {
+                                WizardDialog wizardDialog = WizardDialog.newInstance(AppRestrictionUtil.getSafePasswordMessage(context), R.string.try_again);
+                                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD_WORK);
+                            } else {
+                                WizardDialog wizardDialog = WizardDialog.newInstance(R.string.password_bad_explain, R.string.continue_anyway, R.string.try_again, WizardDialog.Highlight.NEGATIVE);
+                                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD);
+                            }
+                        }
+                    }
+                }.execute();
+            }
+        }
+
+        if (position > lastPage && position >= WizardFragment2.PAGE_ID && position <= WizardFragment4.PAGE_ID) {
+            // we delay dialogs for a few milliseconds to prevent stuttering of the page change animation
+            dialogHandler.removeCallbacks(showDialogDelayedTask(position, lastPage));
+            dialogHandler.postDelayed(showDialogDelayedTask(position, lastPage), DIALOG_DELAY);
+        }
+
+        lastPage = position;
+    }
+
+    /**
+     * Called when the scroll state changes. Useful for discovering when the user
+     * begins dragging, when the pager is automatically settling to the current page,
+     * or when it is fully stopped/idle.
+     *
+     * @param state The new scroll state.
+     * @see ViewPager#SCROLL_STATE_IDLE
+     * @see ViewPager#SCROLL_STATE_DRAGGING
+     * @see ViewPager#SCROLL_STATE_SETTLING
+     */
+    @Override
+    public void onPageScrollStateChanged(int state) {
+    }
+
+    /**
+     * Called when a view has been clicked.
+     *
+     * @param v The view that was clicked.
+     */
+    @Override
+    public void onClick(View v) {
+        if (v.equals(nextButton)) {
+            nextPage();
+        } else if (v.equals(prevButton)) {
+            prevPage();
+        }
+    }
+
+    @Override
+    public void onWizardFinished(WizardFragment4 fragment, Button finishButton) {
+        errorRaised = false;
+        fragment4 = fragment;
+
+        viewPager.lock(true);
+        this.finishButton = finishButton;
+
+        prevButton.setVisibility(View.GONE);
+        if (finishButton != null) {
+            finishButton.setEnabled(false);
+        }
+
+        userService.setPublicNickname(this.nickname, TriggerSource.LOCAL);
+
+        askUserForContactSync();
+    }
+
+    private void askUserForContactSync() {
+        /* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
+        serviceManager.getLifetimeService().ensureConnection();
+
+        if (this.userCannotChangeContactSync) {
+            if (this.isSyncContacts) {
+                if (ConfigUtils.isPermissionGranted(this, Manifest.permission.READ_CONTACTS)) {
+                    // Permission already granted, therefore continue by linking the phone
+                    linkPhone();
+                } else {
+                    // If permission is not yet granted, show a dialog to inform that contact sync
+                    // has been force enabled by the administrator
+                    WizardDialog wizardDialog = WizardDialog.newInstance(R.string.contact_sync_mdm_rationale, R.string.ok);
+                    wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE);
+                }
+            } else {
+                linkPhone();
+            }
+        } else {
+            if (this.skipWizard) {
+                isSyncContacts = false;
+                this.serviceManager.getPreferenceService().setSyncContacts(false);
+                linkPhone();
+            } else {
+                WizardDialog wizardDialog = WizardDialog.newInstance(R.string.new_wizard_info_sync_contacts_dialog, R.string.yes, R.string.no, null);
+                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_ENABLE);
+            }
+        }
+    }
+
+    private void requestContactSyncPermission() {
+        if (ConfigUtils.requestContactPermissions(this, null, PERMISSION_REQUEST_READ_CONTACTS)) {
+            // permission is already granted
+            this.isSyncContacts = true;
+            preferenceService.setSyncContacts(this.isSyncContacts);
+            linkPhone();
+        }
+        // continue to onRequestPermissionsResult
+    }
+
+    @Override
+    public void onNicknameSet(String nickname) {
+        this.nickname = nickname;
+    }
+
+    @Override
+    public void onPhoneSet(String phoneNumber) {
+        this.number = phoneNumber;
+    }
+
+    @Override
+    public void onPrefixSet(String prefix) {
+        this.prefix = prefix;
+    }
+
+    @Override
+    public void onEmailSet(String email) {
+        this.email = email;
+    }
+
+    @Override
+    public void onSafePasswordSet(final String password) {
+        safePassword = password;
+    }
+
+    @Override
+    public void onSafeServerInfoSet(ThreemaSafeServerInfo safeServerInfo) {
+        this.safeServerInfo = safeServerInfo;
+    }
+
+    @Override
+    public String getNickname() {
+        return this.nickname;
+    }
+
+    @Override
+    public String getPhone() {
+        if (PHONE_LINKED_PLACEHOLDER.equals(this.number)) {
+            return this.number;
+        }
+
+        String phone = this.prefix + this.number;
+
+        if (localeService.validatePhoneNumber(phone)) {
+            return serviceManager.getLocaleService().getNormalizedPhoneNumber(phone);
+        }
+        return "";
+    }
+
+    @Override
+    public String getNumber() {
+        return this.number;
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.prefix;
+    }
+
+    @Override
+    public String getEmail() {
+        return (this.email != null && this.email.length() > 4) ? this.email : "";
+    }
+
+    @Override
+    public String getPresetPhone() {
+        return this.presetMobile;
+    }
+
+    @Override
+    public String getPresetEmail() {
+        return this.presetEmail;
+    }
+
+    @Override
+    public boolean getSafeForcePasswordEntry() {
+        return safeConfig.isBackupForced();
+    }
+
+    @Override
+    public boolean getSafeSkipBackupPasswordEntry() {
+        return safeConfig.isSkipBackupPasswordEntry();
+    }
+
+    @Override
+    public boolean isSafeEnabled() {
+        return !safeConfig.isBackupDisabled();
+    }
+
+    @Override
+    public boolean isSafeForced() {
+        return safeConfig.isBackupForced();
+    }
+
+    @Override
+    public String getSafePassword() {
+        return this.safePassword;
+    }
+
+    @Override
+    public ThreemaSafeServerInfo getSafeServerInfo() {
+        return this.safeServerInfo;
+    }
+
+    @Override
+    public boolean getSyncContacts() {
+        return this.isSyncContacts;
+    }
+
+    @Override
+    public boolean isReadOnlyProfile() {
+        return this.readOnlyProfile;
+    }
+
+    @Override
+    public boolean isSkipWizard() {
+        return this.skipWizard;
+    }
+
+    /**
+     * Return whether the identity was just created
+     *
+     * @return true if it's a new identity, false if the identity was restored
+     */
+    public boolean isNewIdentity() {
+        return isNewIdentity;
+    }
+
+    @Override
+    public void onYes(String tag, Object data) {
+        switch (tag) {
+            case DIALOG_TAG_USE_ID_AS_NICKNAME:
+                this.nickname = this.userService.getIdentity();
+                break;
+            case DIALOG_TAG_PASSWORD_BAD_WORK:
+            case DIALOG_TAG_INVALID_ENTRY:
+                prevPage();
+                break;
+            case DIALOG_TAG_PASSWORD_BAD:
+            case DIALOG_TAG_THREEMA_SAFE:
+            case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
+                break;
+            case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
+            case DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE:
+                requestContactSyncPermission();
+                break;
+            case DIALOG_TAG_APPLICATION_SETUP_RETRY:
+                runApplicationSetupStepsAndRestart();
+                break;
+        }
+    }
+
+    @Override
+    public void onNo(String tag) {
+        switch (tag) {
+            case DIALOG_TAG_USE_ID_AS_NICKNAME:
+                prevPage();
+                break;
+            case DIALOG_TAG_USE_ANONYMOUSLY:
+                setPage(WizardFragment3.PAGE_ID);
+                break;
+            case DIALOG_TAG_THREEMA_SAFE:
+                prevPage();
+                break;
+            case DIALOG_TAG_PASSWORD_BAD:
+                setPage(WizardFragment1.PAGE_ID);
+                break;
+            case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
+                isSyncContacts = false;
+                this.serviceManager.getPreferenceService().setSyncContacts(false);
+                linkPhone();
+                break;
+            case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
+                finish();
+                System.exit(0);
+                break;
+        }
+    }
+
+    @Override
+    protected boolean enableOnBackPressedCallback() {
+        return true;
+    }
+
+    @Override
+    protected void handleOnBackPressed() {
+        if (prevButton != null && prevButton.getVisibility() == View.VISIBLE) {
+            prevPage();
+        }
+    }
+
+    private static class ScreenSlidePagerAdapter extends FragmentStatePagerAdapter {
+        public ScreenSlidePagerAdapter(FragmentManager fm) {
+            super(fm, FragmentStatePagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
+        }
+
+        @Override
+        public Fragment getItem(int position) {
+            switch (position) {
+                case WizardFragment0.PAGE_ID:
+                    return new WizardFragment0();
+                case WizardFragment1.PAGE_ID:
+                    return new WizardFragment1();
+                case WizardFragment2.PAGE_ID:
+                    return new WizardFragment2();
+                case WizardFragment3.PAGE_ID:
+                    return new WizardFragment3();
+                case WizardFragment4.PAGE_ID:
+                    return new WizardFragment4();
+                default:
+                    break;
+            }
+            return null;
+        }
+
+        @Override
+        public int getCount() {
+            return NUM_PAGES;
+        }
+    }
+
+    public void nextPage() {
+        int currentItem = viewPager.getCurrentItem() + 1;
+        if (currentItem < NUM_PAGES) {
+            viewPager.setCurrentItem(currentItem);
+        }
+    }
+
+    public void prevPage() {
+        int currentItem = viewPager.getCurrentItem();
+        if (currentItem != 0) {
+            viewPager.setCurrentItem(currentItem - 1);
+        }
+    }
+
+    public void setPage(int page) {
+        viewPager.setCurrentItem(page);
+    }
+
+    @SuppressLint("StaticFieldLeak")
+    private void linkEmail(final WizardFragment4 fragment) {
+        final String newEmail = getEmail();
+        if (TestUtil.isEmptyOrNull(newEmail)) {
+            initSyncAndFinish();
+            return;
+        }
+
+        boolean isNewEmail = (!(presetEmail != null && presetEmail.equals(newEmail)));
+
+        if ((userService.getEmailLinkingState() != UserService.LinkingState_LINKED) && isNewEmail) {
+            new AsyncTask<Void, Void, String>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment.setEmailLinkingInProgress(true);
+                }
+
+                @Override
+                protected String doInBackground(Void... params) {
+                    try {
+                        userService.linkWithEmail(email);
+                    } catch (LinkEmailException e) {
+                        logger.error("Exception", e);
+                        return e.getMessage();
+                    } catch (Exception e) {
+                        logger.error("Exception", e);
+                        return getString(R.string.internet_connection_required);
+                    }
+                    return null;
+                }
+
+                @Override
+                protected void onPostExecute(String result) {
+                    if (result != null) {
+                        fragment.setEmailLinkingAlert(result);
+                        errorRaised = true;
+                    } else {
+                        fragment.setEmailLinkingInProgress(false);
+                    }
+                    initSyncAndFinish();
+                }
+            }.execute();
+        } else {
+            initSyncAndFinish();
+        }
+    }
+
+    @SuppressLint("StaticFieldLeak")
+    private void linkPhone() {
+        final String phone = getPhone();
+        if (TestUtil.isEmptyOrNull(phone)) {
+            linkEmail(fragment4);
+            return;
+        }
+
+        boolean isNewPhoneNumber = (presetMobile == null || !presetMobile.equals(phone));
+
+        // start linking activity only if not already linked
+        if ((userService.getMobileLinkingState() != UserService.LinkingState_LINKED) && isNewPhoneNumber) {
+            new AsyncTask<Void, Void, String>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment4.setMobileLinkingInProgress(true);
+                }
+
+                @Override
+                protected String doInBackground(Void... params) {
+                    try {
+                        userService.linkWithMobileNumber(phone);
+                    } catch (LinkMobileNoException e) {
+                        logger.error("Exception", e);
+                        return e.getMessage();
+                    } catch (Exception e) {
+                        logger.error("Exception", e);
+                        return getString(R.string.internet_connection_required);
+                    }
+                    return null;
+                }
+
+                @Override
+                protected void onPostExecute(String result) {
+                    if (result != null) {
+                        fragment4.setMobileLinkingAlert(result);
+                        errorRaised = true;
+                    } else {
+                        fragment4.setMobileLinkingInProgress(false);
+                    }
+                    linkEmail(fragment4);
+                }
+            }.execute();
+        } else {
+            linkEmail(fragment4);
+        }
+    }
+
+    @WorkerThread
+    private void addContact(final String identity, final String first, final String last) {
+        new BasicAddOrUpdateContactBackgroundTask(
+            identity,
+            ch.threema.storage.models.ContactModel.AcquaintanceLevel.DIRECT,
+            userService.getIdentity(),
+            apiConnector,
+            contactModelRepository,
+            AddContactRestrictionPolicy.IGNORE,
+            WizardBaseActivity.this,
+            null
+        ) {
+            @Override
+            public void onFinished(ContactResult result) {
+                ContactModel contactModel;
+                if (result instanceof ContactAvailable) {
+                    contactModel = ((ContactAvailable) result).getContactModel();
+                } else {
+                    contactModel = null;
+                }
+
+                if (contactModel != null) {
+                    contactModel.setNameFromLocal(first, last);
+                }
+            }
+        }.runSynchronously();
+    }
+
+    private void runApplicationSetupStepsAndRestart() {
+        backgroundExecutor.execute(new BackgroundTask<Boolean>() {
+            @Override
+            public void runBefore() {
+                // Nothing to do
+            }
+
+            @Override
+            public Boolean runInBackground() {
+                Boolean applicationSetupResult = runApplicationSetupSteps(serviceManager);
+
+                addContact(ThreemaApplication.ECHO_USER_IDENTITY, "Echo", "Test");
+
+                return applicationSetupResult;
+            }
+
+            @Override
+            public void runAfter(Boolean result) {
+                if (!Boolean.TRUE.equals(result)) {
+                    WizardDialog.newInstance(R.string.application_setup_steps_failed, R.string.retry)
+                        .show(getSupportFragmentManager(), DIALOG_TAG_APPLICATION_SETUP_RETRY);
+                    return;
+                }
+
+                preferenceService.setWizardRunning(false);
+                preferenceService.setLatestVersion(WizardBaseActivity.this);
+
+                // Flush conversation cache (after a restore) to ensure that the conversation list
+                // will be loaded from the database to prevent the list being incomplete.
+                try {
+                    serviceManager.getConversationService().reset();
+                } catch (Exception e) {
+                    logger.error("Exception", e);
+                }
+
+                ConfigUtils.recreateActivity(WizardBaseActivity.this);
+            }
+        });
+    }
+
+    private void ensureMasterKeyWrite() {
+        // Write master key now if no passphrase has been set - don't leave it up to the MainActivity
+        if (!ThreemaApplication.getMasterKey().isProtected()) {
+            try {
+                ThreemaApplication.getMasterKey().setPassphrase(null);
+            } catch (Exception e) {
+                // better die if something went wrong as the master key may not have been saved
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    @SuppressLint({"StaticFieldLeak", "MissingPermission"})
+    private void reallySyncContactsAndFinish() {
+        ensureMasterKeyWrite();
+
+        if (preferenceService.isSyncContacts()) {
+            new AsyncTask<Void, Void, Void>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment4.setContactsSyncInProgress(true, getString(R.string.wizard1_sync_contacts));
+                }
+
+                @SuppressLint("MissingPermission")
+                @Override
+                protected Void doInBackground(Void... params) {
+                    try {
+                        final Account account = userService.getAccount(true);
+                        //disable
+                        userService.enableAccountAutoSync(false);
+
+                        SynchronizeContactsService synchronizeContactsService = serviceManager.getSynchronizeContactsService();
+                        SynchronizeContactsRoutine routine = synchronizeContactsService.instantiateSynchronization(account);
+
+                        routine.setOnStatusUpdate(new SynchronizeContactsRoutine.OnStatusUpdate() {
+                            @Override
+                            public void newStatus(final long percent, final String message) {
+                                RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(true, message));
+                            }
+
+                            @Override
+                            public void error(final Exception x) {
+                                RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(false, x.getMessage()));
+                            }
+                        });
+
+                        //on finished, close the dialog
+                        routine.addOnFinished((success, modifiedAccounts, createdContacts, deletedAccounts) -> userService.enableAccountAutoSync(true));
+
+                        routine.run();
+                    } catch (MasterKeyLockedException | FileSystemNotPresentException e) {
+                        logger.error("Exception", e);
+                    }
+                    return null;
+                }
+
+                @Override
+                protected void onPostExecute(Void result) {
+                    finishHandler.removeCallbacks(finishTask);
+                    finishHandler.postDelayed(finishTask, FINISH_DELAY);
+                }
+            }.execute();
+        } else {
+            userService.removeAccount();
+            prepareThreemaSafe();
+        }
+    }
+
+    @SuppressLint("StaticFieldLeak")
+    private void prepareThreemaSafe() {
+        if (!TestUtil.isEmptyOrNull(getSafePassword())) {
+            new AsyncTask<Void, Void, byte[]>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment4.setThreemaSafeInProgress(true, getString(R.string.preparing_threema_safe));
+                }
+
+                @Override
+                protected byte[] doInBackground(Void... voids) {
+                    return threemaSafeService.deriveMasterKey(getSafePassword(), userService.getIdentity());
+                }
+
+                @Override
+                protected void onPostExecute(byte[] masterkey) {
+                    fragment4.setThreemaSafeInProgress(false, getString(R.string.menu_done));
+
+                    if (masterkey != null) {
+                        threemaSafeService.storeMasterKey(masterkey);
+                        preferenceService.setThreemaSafeServerInfo(safeServerInfo);
+                        threemaSafeService.setEnabled(true);
+                        threemaSafeService.uploadNow(true);
+                    } else {
+                        Toast.makeText(WizardBaseActivity.this, R.string.safe_error_preparing, Toast.LENGTH_LONG).show();
+                    }
+
+                    runApplicationSetupStepsAndRestart();
+                }
+            }.execute();
+        } else {
+            // no password was set
+            // do not save mdm settings if backup is forced and no password was set - this will cause a password prompt later
+            if (!(ConfigUtils.isWorkRestricted() && ThreemaSafeMDMConfig.getInstance().isBackupForced())) {
+                threemaSafeService.storeMasterKey(new byte[0]);
+            }
+            runApplicationSetupStepsAndRestart();
+        }
+    }
+
+    private void initSyncAndFinish() {
+        if (!errorRaised || ConfigUtils.isWorkRestricted()) {
+            syncContactsAndFinish();
+        } else {
+            resetUi();
+        }
+    }
+
+    private void resetUi() {
+        // unlock UI to try again
+        viewPager.lock(false);
+        prevButton.setVisibility(View.VISIBLE);
+        if (finishButton != null) {
+            finishButton.setEnabled(true);
+        }
+    }
+
+    private void syncContactsAndFinish() {
+        /* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
+        serviceManager.getLifetimeService().ensureConnection();
+
+        if (this.isSyncContacts) {
+            preferenceService.setSyncContacts(true);
+            reallySyncContactsAndFinish();
+        } else {
+            preferenceService.setSyncContacts(false);
+            prepareThreemaSafe();
+        }
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if (requestCode == PERMISSION_REQUEST_READ_CONTACTS) {
+            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+                this.isSyncContacts = true;
+                linkPhone();
+            } else if (userCannotChangeContactSync) {
+                ConfigUtils.showPermissionRationale(this, (View) viewPager.getParent(), R.string.permission_contacts_sync_required);
+                resetUi();
+            } else {
+                this.isSyncContacts = false;
+                linkPhone();
+            }
+        }
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java b/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java
index e1aeaccd..bcc8d654 100644
--- a/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java
@@ -297,7 +297,7 @@ public class WizardSafeRestoreActivity extends WizardBackgroundActivity implemen
 
 			@Override
 			public Boolean runInBackground() {
-				return runApplicationSetupSteps(serviceManager, WizardSafeRestoreActivity.this);
+				return runApplicationSetupSteps(serviceManager);
 			}
 
 			@Override
diff --git a/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java b/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java
index 759f139c..c6332f68 100644
--- a/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java
@@ -42,7 +42,7 @@ import static ch.threema.app.backuprestore.csv.RestoreService.RESTORE_COMPLETION
 
 public class WizardStartActivity extends WizardBackgroundActivity {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("WizardStartActivity");
-	boolean doFinish = false;
+	boolean nextActivityLaunched = false;
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
@@ -98,7 +98,12 @@ public class WizardStartActivity extends WizardBackgroundActivity {
 		return frameAnimation;
 	}
 
-	private void launchNextActivity(ActivityOptionsCompat options) {
+	private synchronized void launchNextActivity(ActivityOptionsCompat options) {
+        if (nextActivityLaunched) {
+            // If the next activity already has been launched, we can just return here.
+            return;
+        }
+
 		Intent intent;
 
 		if (userService != null && userService.hasIdentity()) {
@@ -122,13 +127,14 @@ public class WizardStartActivity extends WizardBackgroundActivity {
 			startActivity(intent);
 			overridePendingTransition(R.anim.abc_fade_in, R.anim.abc_fade_out);
 		}
-		doFinish = true;
+		nextActivityLaunched = true;
 	}
 
 	@Override
 	public void onStop() {
 		super.onStop();
-		if (doFinish)
-			finish();
+		if (nextActivityLaunched) {
+            finish();
+        }
 	}
 }
diff --git a/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java b/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java
index d898d07b..cef488b1 100644
--- a/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java
@@ -66,6 +66,9 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ViewUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.domain.models.ReadReceiptPolicy;
+import ch.threema.domain.models.TypingIndicatorPolicy;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.protobuf.csp.e2e.fs.Terminate;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
@@ -87,18 +90,17 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
     private static final int TYPE_HEADER = 0;
     private static final int TYPE_ITEM = 1;
 
-    private final Context context;
-    private ContactService contactService;
-    private GroupService groupService;
-    private PreferenceService preferenceService;
-    private IdListService excludeFromSyncListService;
-    private IdListService blockedContactsService;
-    @Deprecated
-    private final ContactModel contactModel;
-    private final @NonNull ContactModelData contactModelData;
-    private final List<GroupModel> values;
-    private OnClickListener onClickListener;
-    private final @NonNull RequestManager requestManager;
+	private final Context context;
+	private ContactService contactService;
+	private GroupService groupService;
+	private PreferenceService preferenceService;
+	private IdListService excludeFromSyncListService;
+	private IdListService blockedContactsService;
+	private final @NonNull ch.threema.data.models.ContactModel contactModel;
+	private final @NonNull ContactModelData contactModelData;
+	private final List<GroupModel> values;
+	private OnClickListener onClickListener;
+	private final @NonNull RequestManager requestManager;
 
     public static class ItemHolder extends RecyclerView.ViewHolder {
         public final @NonNull View view;
@@ -163,28 +165,34 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
                 return true;
             });
 
-            // When clicking ten times on the Threema ID, the clear forward security session button
-            // becomes visible.
-            threemaIdView.setOnClickListener(v -> {
-                onThreemaIDClickCount++;
-                if (onThreemaIDClickCount >= 10) {
-                    onThreemaIDClickCount = 0;
-                    clearForwardSecuritySection.setVisibility(View.VISIBLE);
-                    clearForwardSecurityButton.setOnClickListener(clearButton -> {
-                        try {
-                            ThreemaApplication.requireServiceManager()
-                                .getTaskCreator()
-                                .scheduleDeleteAndTerminateFSSessionsTaskAsync(
-                                    contactModel,
-                                    Terminate.Cause.RESET
-                                );
-                            Toast.makeText(clearButton.getContext(), R.string.forward_security_cleared, Toast.LENGTH_LONG).show();
-                        } catch (Exception e) {
-                            Toast.makeText(clearButton.getContext(), e.getMessage(), Toast.LENGTH_LONG).show();
-                        }
-                    });
-                }
-            });
+			// When clicking ten times on the Threema ID, the clear forward security session button
+			// becomes visible.
+			threemaIdView.setOnClickListener(v -> {
+				onThreemaIDClickCount++;
+				if (onThreemaIDClickCount >= 10) {
+					onThreemaIDClickCount = 0;
+					clearForwardSecuritySection.setVisibility(View.VISIBLE);
+					clearForwardSecurityButton.setOnClickListener(clearButton -> {
+						ContactModel contactModel = contactService.getByIdentity(contactModelData.identity);
+						if (contactModel == null) {
+							logger.error("Contact model is null. Cannot schedule fs session deletion task.");
+							return;
+						}
+
+						try {
+							ThreemaApplication.requireServiceManager()
+								.getTaskCreator()
+								.scheduleDeleteAndTerminateFSSessionsTaskAsync(
+									contactModel,
+									Terminate.Cause.RESET
+								);
+							Toast.makeText(clearButton.getContext(), R.string.forward_security_cleared, Toast.LENGTH_LONG).show();
+						} catch (Exception e) {
+							Toast.makeText(clearButton.getContext(), e.getMessage(), Toast.LENGTH_LONG).show();
+						}
+					});
+				}
+			});
 
             publicNickNameView.setOnLongClickListener(ignored -> {
                 copyTextToClipboard(contactModelData.nickname, R.string.contact_details_nickname_copied);
@@ -209,19 +217,19 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
         }
     }
 
-    @UiThread
-    public ContactDetailAdapter(
-        Context context,
-        List<GroupModel> values,
-        ContactModel contactModel,
-        @NonNull ContactModelData contactModelData,
-        @NonNull RequestManager requestManager
-    ) {
-        this.context = context;
-        this.values = values;
-        this.contactModel = contactModel;
-        this.contactModelData = contactModelData;
-        this.requestManager = requestManager;
+	@UiThread
+	public ContactDetailAdapter(
+		Context context,
+		List<GroupModel>values,
+		@NonNull ch.threema.data.models.ContactModel contactModel,
+		@NonNull ContactModelData contactModelData,
+		@NonNull RequestManager requestManager
+	) {
+		this.context = context;
+		this.values = values;
+		this.contactModel = contactModel;
+		this.contactModelData = contactModelData;
+		this.requestManager = requestManager;
 
         try {
             ServiceManager serviceManager = ThreemaApplication.requireServiceManager();
@@ -280,40 +288,45 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
         } else {
             HeaderHolder headerHolder = (HeaderHolder) holder;
 
-            String identityAdditional = null;
-            switch (this.contactModelData.activityState) {
-                case ACTIVE:
-                    if (blockedContactsService.has(contactModelData.identity)) {
-                        identityAdditional = context.getString(R.string.blocked);
-                    }
-                    break;
-                case INACTIVE:
-                    identityAdditional = context.getString(R.string.contact_state_inactive);
-                    break;
-                case INVALID:
-                    identityAdditional = context.getString(R.string.contact_state_invalid);
-                    break;
-            }
-
-            final boolean shouldShowJobTitle = contactModel.isWork() && contactModelData.jobTitle != null && !contactModelData.jobTitle.isBlank();
+			String identityAdditional = null;
+			switch (this.contactModelData.activityState) {
+				case ACTIVE:
+					if (blockedContactsService.has(contactModelData.identity)) {
+						identityAdditional = context.getString(R.string.blocked);
+					}
+					break;
+				case INACTIVE:
+					identityAdditional = context.getString(R.string.contact_state_inactive);
+					break;
+				case INVALID:
+					identityAdditional = context.getString(R.string.contact_state_invalid);
+					break;
+			}
+
+            final boolean shouldShowJobTitle = contactModelData.workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+                && contactModelData.jobTitle != null && !contactModelData.jobTitle.isBlank();
             ViewUtil.show(headerHolder.jobTitleHeaderView, shouldShowJobTitle);
             ViewUtil.show(headerHolder.jobTitleTextView, shouldShowJobTitle);
             if (shouldShowJobTitle) {
                 headerHolder.jobTitleTextView.setText(contactModelData.jobTitle);
             }
 
-            final boolean shouldShowDepartment = contactModel.isWork() && contactModelData.department != null && !contactModelData.department.isBlank();
+            final boolean shouldShowDepartment = contactModelData.workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+                && contactModelData.department != null && !contactModelData.department.isBlank();
             ViewUtil.show(headerHolder.departmentHeaderView, shouldShowDepartment);
             ViewUtil.show(headerHolder.departmentTextView, shouldShowDepartment);
             if (shouldShowDepartment) {
                 headerHolder.departmentTextView.setText(contactModelData.department);
             }
 
-            headerHolder.threemaIdView.setText(
-                contactModelData.identity + (identityAdditional != null ? " (" + identityAdditional + ")" : "")
-            );
-            headerHolder.verificationLevelImageView.setContactModel(contactModel);
-            headerHolder.verificationLevelImageView.setVisibility(View.VISIBLE);
+			headerHolder.threemaIdView.setText(
+				contactModelData.identity + (identityAdditional != null ? " (" + identityAdditional + ")" : "")
+			);
+			headerHolder.verificationLevelImageView.setVerificationLevel(
+				contactModelData.verificationLevel,
+				contactModelData.workVerificationLevel
+			);
+			headerHolder.verificationLevelImageView.setVisibility(View.VISIBLE);
 
             boolean isSyncExcluded = excludeFromSyncListService.has(contactModelData.identity);
 
@@ -323,18 +336,18 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
             ) {
                 headerHolder.synchronizeContainer.setVisibility(View.VISIBLE);
 
-                Drawable icon = null;
-                try {
-                    icon = AndroidContactUtil.getInstance().getAccountIcon(contactModel);
-                } catch (SecurityException e) {
-                    logger.error("Could not access android account icon", e);
-                }
-                if (icon != null) {
-                    headerHolder.syncSourceIcon.setImageDrawable(icon);
-                    headerHolder.syncSourceIcon.setVisibility(View.VISIBLE);
-                } else {
-                    headerHolder.syncSourceIcon.setVisibility(View.GONE);
-                }
+				Drawable icon = null;
+				try {
+					icon = AndroidContactUtil.getInstance().getAccountIcon(contactModelData.androidContactLookupKey);
+				} catch (SecurityException e) {
+					logger.error("Could not access android account icon", e);
+				}
+				if (icon != null) {
+					headerHolder.syncSourceIcon.setImageDrawable(icon);
+					headerHolder.syncSourceIcon.setVisibility(View.VISIBLE);
+				} else {
+					headerHolder.syncSourceIcon.setVisibility(View.GONE);
+				}
 
                 headerHolder.synchronize.setChecked(isSyncExcluded);
                 headerHolder.synchronize.setOnCheckedChangeListener((buttonView, isChecked) -> {
@@ -361,31 +374,10 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
                 headerHolder.groupMembershipTitle.setVisibility(View.GONE);
             }
 
-            final String[] choices = context.getResources().getStringArray(R.array.receipts_override_choices);
-            choices[0] = context.getString(R.string.receipts_override_choice_default,
-                choices[preferenceService.isReadReceipts() ? 1 : 2]);
-
-            ArrayAdapter<String> readReceiptsAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, choices);
-            headerHolder.readReceiptsSpinner.setAdapter(readReceiptsAdapter);
-            headerHolder.readReceiptsSpinner.setText(choices[contactModel.getReadReceipts()], false);
-            headerHolder.readReceiptsSpinner.setOnItemClickListener((parent, view, position1, id) -> {
-                contactModel.setReadReceipts(position1);
-                contactService.save(contactModel);
-            });
-
-            final String[] typingChoices = context.getResources().getStringArray(R.array.receipts_override_choices);
-            typingChoices[0] = context.getString(R.string.receipts_override_choice_default,
-                typingChoices[preferenceService.isTypingIndicator() ? 1 : 2]);
-
-            ArrayAdapter<String> typingIndicatorAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, typingChoices);
-            headerHolder.typingIndicatorsSpinner.setAdapter(typingIndicatorAdapter);
-            headerHolder.typingIndicatorsSpinner.setText(typingChoices[contactModel.getTypingIndicators()], false);
-            headerHolder.typingIndicatorsSpinner.setOnItemClickListener((parent, view, position12, id) -> {
-                contactModel.setTypingIndicators(position12);
-                contactService.save(contactModel);
-            });
-        }
-    }
+			initializeReadReceiptsSpinner(headerHolder);
+			initializeTypingIndicatorSpinner(headerHolder);
+		}
+	}
 
     @Override
     public int getItemCount() {
@@ -418,4 +410,83 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
         void onVerificationInfoClick(View v);
     }
 
+	private void initializeReadReceiptsSpinner(@NonNull HeaderHolder headerHolder) {
+		final String[] choices = context.getResources().getStringArray(R.array.receipts_override_choices);
+		choices[0] = context.getString(R.string.receipts_override_choice_default,
+			choices[preferenceService.isReadReceipts() ? 1 : 2]);
+
+		int initialReadReceiptPosition;
+		switch (contactModelData.readReceiptPolicy) {
+			case SEND:
+				initialReadReceiptPosition = 1;
+				break;
+			case DONT_SEND:
+				initialReadReceiptPosition = 2;
+				break;
+			case DEFAULT:
+			default:
+				initialReadReceiptPosition = 0;
+				break;
+		}
+		ArrayAdapter<String> readReceiptsAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, choices);
+		headerHolder.readReceiptsSpinner.setAdapter(readReceiptsAdapter);
+		headerHolder.readReceiptsSpinner.setText(choices[initialReadReceiptPosition], false);
+		headerHolder.readReceiptsSpinner.setOnItemClickListener((parent, view, readReceiptPosition, id) -> {
+			switch (readReceiptPosition) {
+				case 0:
+					contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.DEFAULT);
+					break;
+				case 1:
+					contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.SEND);
+					break;
+				case 2:
+					contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.DONT_SEND);
+					break;
+				default:
+					logger.warn("Invalid position for read receipt policy: {}", readReceiptPosition);
+					break;
+			}
+		});
+	}
+
+	private void initializeTypingIndicatorSpinner(@NonNull HeaderHolder headerHolder) {
+		final String[] typingChoices = context.getResources().getStringArray(R.array.receipts_override_choices);
+		typingChoices[0] = context.getString(R.string.receipts_override_choice_default,
+			typingChoices[preferenceService.isTypingIndicator() ? 1 : 2]);
+
+		int initialTypingIndicatorPosition;
+		switch (contactModelData.typingIndicatorPolicy) {
+			case SEND:
+				initialTypingIndicatorPosition = 1;
+				break;
+			case DONT_SEND:
+				initialTypingIndicatorPosition = 2;
+				break;
+			case DEFAULT:
+			default:
+				initialTypingIndicatorPosition = 0;
+				break;
+		}
+
+		ArrayAdapter<String> typingIndicatorAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, typingChoices);
+		headerHolder.typingIndicatorsSpinner.setAdapter(typingIndicatorAdapter);
+		headerHolder.typingIndicatorsSpinner.setText(typingChoices[initialTypingIndicatorPosition], false);
+		headerHolder.typingIndicatorsSpinner.setOnItemClickListener((parent, view, typingIndicatorPosition, id) -> {
+			switch (typingIndicatorPosition) {
+				case 0:
+					contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.DEFAULT);
+					break;
+				case 1:
+					contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.SEND);
+					break;
+				case 2:
+					contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.DONT_SEND);
+					break;
+				default:
+					logger.warn("Invalid position for typing indicator policy: {}", typingIndicatorPosition);
+					break;
+			}
+		});
+	}
+
 }
diff --git a/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java b/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java
index e4f0496f..1c41a0bc 100644
--- a/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java
@@ -398,9 +398,12 @@ public class ContactListAdapter extends FilterableListAdapter implements Section
         );
         AdapterUtil.styleContact(holder.contactTextBottomRight, contactModel);
 
-        if (holder.verificationLevelView != null) {
-            holder.verificationLevelView.setContactModel(contactModel);
-        }
+		if (holder.verificationLevelView != null) {
+			holder.verificationLevelView.setVerificationLevel(
+				contactModel.verificationLevel,
+				contactModel.getWorkVerificationLevel()
+			);
+		}
 
         ViewUtil.show(
             holder.blockedContactView,
diff --git a/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java b/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java
index 531e7079..057a8c9d 100644
--- a/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java
@@ -30,12 +30,9 @@ import android.os.Bundle;
 
 import org.slf4j.Logger;
 
-import java.util.List;
-
 import androidx.localbroadcastmanager.content.LocalBroadcastManager;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
-import ch.threema.app.listeners.NewSyncedContactsListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.routines.SynchronizeContactsRoutine;
@@ -43,19 +40,34 @@ import ch.threema.app.services.SynchronizeContactsService;
 import ch.threema.app.utils.IntentDataUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
 
 public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("ContactsSyncAdapter");
 
+	private boolean isSyncEnabled = true;
+
 	public ContactsSyncAdapter(Context context, boolean autoInitialize) {
 		super(context, autoInitialize);
 	}
 
+	public void setSyncEnabled(boolean enabled) {
+		isSyncEnabled = enabled;
+	}
+
 	@Override
 	public void onPerformSync(Account account, Bundle extras, String authority, ContentProviderClient provider, SyncResult syncResult) {
 		logger.info("onPerformSync");
 
+		if (!isSyncEnabled) {
+			logger.info("Contact sync is disabled; retry later.");
+			// Workaround to trigger a soft error to retry the sync at a later moment
+			// See
+			//  - https://developer.android.com/reference/android/content/SyncResult#hasSoftError()
+			//  - https://developer.android.com/reference/android/content/SyncResult#SyncResult()
+			syncResult.stats.numIoExceptions++;
+			return;
+		}
+
 		try {
 			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
 
@@ -66,10 +78,7 @@ public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 			if (serviceManager.getPreferenceService().isSyncContacts()) {
 				logger.info("Start sync adapter run");
 				SynchronizeContactsService synchronizeContactsService = serviceManager.getSynchronizeContactsService();
-				if (synchronizeContactsService == null) {
-					return;
 
-				}
 				if (synchronizeContactsService.isFullSyncInProgress()) {
 					logger.info("A full sync is already running");
 					syncResult.stats.numUpdates = 0;
@@ -82,29 +91,21 @@ public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 				SynchronizeContactsRoutine routine = synchronizeContactsService.instantiateSynchronization(account);
 				//update stats on finished to resolve the "every minute sync" bug
 
-				routine.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
-					@Override
-					public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
-						// let user know that contact was added
-						ListenerManager.newSyncedContactListener.handle(new ListenerManager.HandleListener<NewSyncedContactsListener>() {
-							@Override
-							public void handle(NewSyncedContactsListener listener) {
-								listener.onNew(createdContacts);
-							}
-						});
-
-						//hack to not schedule the next sync!
-						syncResult.stats.numUpdates = 0;//modifiedAccounts;
-						syncResult.stats.numInserts = 0;//createdAccounts;
-						syncResult.stats.numDeletes = 0;//deletedAccounts;
-						syncResult.stats.numEntries = 0;//createdAccounts;
-
-						//send a broadcast to let others know that the list has changed
-						LocalBroadcastManager.getInstance(ThreemaApplication.getAppContext()).sendBroadcast(IntentDataUtil.createActionIntentContactsChanged());
-					}
+				routine.addOnFinished((success, modifiedAccounts, createdContacts, deletedAccounts) -> {
+					// let user know that contact was added
+					ListenerManager.newSyncedContactListener.handle(listener -> listener.onNew(createdContacts));
+
+					//hack to not schedule the next sync!
+					syncResult.stats.numUpdates = 0;//modifiedAccounts;
+					syncResult.stats.numInserts = 0;//createdAccounts;
+					syncResult.stats.numDeletes = 0;//deletedAccounts;
+					syncResult.stats.numEntries = 0;//createdAccounts;
+
+					//send a broadcast to let others know that the list has changed
+					LocalBroadcastManager.getInstance(ThreemaApplication.getAppContext()).sendBroadcast(IntentDataUtil.createActionIntentContactsChanged());
 				});
 
-				//not in a thread!
+				// not in a thread: `onPerformSync` is already called in a background thread
 				routine.run();
 			}
 		}
@@ -115,10 +116,13 @@ public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 			logger.debug("MasterKeyLockedException [" + e.getMessage() + "]");
 
 		}finally{
-			logger.debug("sync finished Sync [numEntries=" + String.valueOf(syncResult.stats.numEntries) +
-				", updates=" + String.valueOf(syncResult.stats.numUpdates) +
-				", inserts=" + String.valueOf(syncResult.stats.numInserts) +
-				", deletes=" + String.valueOf(syncResult.stats.numDeletes) + "]");
+			logger.debug(
+				"sync finished Sync [numEntries={}, updates={}, inserts={}, deletes={}",
+				syncResult.stats.numEntries,
+				syncResult.stats.numUpdates,
+				syncResult.stats.numInserts,
+				syncResult.stats.numDeletes
+			);
 		}
 	}
 
diff --git a/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java b/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java
index 96c86953..7d80e9ee 100644
--- a/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java
@@ -164,7 +164,7 @@ public class GroupDetailAdapter extends RecyclerView.Adapter<RecyclerView.ViewHo
 			boolean isOrphanedGroup = groupService.isOrphanedGroup(groupModel);
 			boolean isCreator = groupService.isGroupCreator(groupModel);
 			boolean isMember = groupService.isGroupMember(groupModel);
-			boolean hasOtherMembers = groupService.getOtherMemberCount(groupModel) > 0;
+			boolean hasOtherMembers = groupService.countMembersWithoutUser(groupModel) > 0;
 
 			if (isOrphanedGroup) {
 				// Show orphaned group notice
diff --git a/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java b/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java
index 17084df1..da79640c 100644
--- a/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java
@@ -171,7 +171,10 @@ public class UserListAdapter extends FilterableListAdapter {
 				blockedContactsService != null && blockedContactsService.has(contactModel.getIdentity())
 		);
 
-		holder.verificationLevelView.setContactModel(contactModel);
+		holder.verificationLevelView.setVerificationLevel(
+			contactModel.verificationLevel,
+			contactModel.getWorkVerificationLevel()
+		);
 
 		String lastMessageDateString = null;
 		MessageReceiver messageReceiver = this.contactService.createReceiver(contactModel);
diff --git a/app/src/main/java/ch/threema/app/asynctasks/AddContactAsyncTask.java b/app/src/main/java/ch/threema/app/asynctasks/AddContactAsyncTask.java
deleted file mode 100644
index 67cc550d..00000000
--- a/app/src/main/java/ch/threema/app/asynctasks/AddContactAsyncTask.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.asynctasks;
-
-import android.os.AsyncTask;
-import android.widget.Toast;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.NonNull;
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.utils.ConfigUtils;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.models.IdentityType;
-import ch.threema.domain.models.VerificationLevel;
-import ch.threema.storage.models.ContactModel;
-
-public class AddContactAsyncTask extends AsyncTask<Void, Void, Boolean> {
-    private static final Logger logger = LoggingUtil.getThreemaLogger("AddContactAsyncTask");
-
-    private final Runnable runOnCompletion;
-    private final String firstName, lastName, threemaId;
-    private final boolean markAsWorkVerified;
-
-    public AddContactAsyncTask(String firstname, String lastname, String identity, boolean markAsWorkVerified, Runnable runOnCompletion) {
-        this.firstName = firstname;
-        this.lastName = lastname;
-        this.threemaId = identity.toUpperCase();
-        this.runOnCompletion = runOnCompletion;
-        this.markAsWorkVerified = markAsWorkVerified;
-    }
-
-    @Override
-    protected Boolean doInBackground(Void... params) {
-        try {
-            return addContact(ThreemaApplication.requireServiceManager().getContactService());
-        } catch (Exception e) {
-            logger.error("Could not add contact", e);
-            return null;
-        }
-    }
-
-    @Override
-    protected void onPostExecute(Boolean added) {
-        if (added != null) {
-            if (added) {
-                Toast.makeText(ThreemaApplication.getAppContext(), R.string.creating_contact_successful, Toast.LENGTH_SHORT).show();
-            }
-
-            if (runOnCompletion != null) {
-                runOnCompletion.run();
-            }
-        } else {
-            Toast.makeText(ThreemaApplication.getAppContext(), R.string.add_contact_failed, Toast.LENGTH_SHORT).show();
-        }
-    }
-
-    private boolean addContact(@NonNull ContactService contactService) throws InvalidEntryException, PolicyViolationException, EntryAlreadyExistsException {
-        if (contactService.getByIdentity(this.threemaId) != null) {
-            logger.info("Contact already exists");
-            return false;
-        }
-
-        boolean force = (ConfigUtils.isOnPremBuild() || ConfigUtils.isWorkBuild()) && markAsWorkVerified;
-
-        ContactModel contactModel = contactService.createContactByIdentity(this.threemaId, force);
-
-        if (this.firstName != null && this.lastName != null) {
-            contactModel.setFirstName(this.firstName);
-            contactModel.setLastName(this.lastName);
-            contactService.save(contactModel);
-        }
-
-        if (contactModel.getIdentityType() == IdentityType.WORK || markAsWorkVerified) {
-            contactModel.setIsWork(true);
-
-            if(contactModel.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-                contactModel.verificationLevel = VerificationLevel.SERVER_VERIFIED;
-            }
-            contactService.save(contactModel);
-        }
-        return true;
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/AddContactBackgroundTask.kt b/app/src/main/java/ch/threema/app/asynctasks/AddContactBackgroundTask.kt
new file mode 100644
index 00000000..c5836912
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/asynctasks/AddContactBackgroundTask.kt
@@ -0,0 +1,79 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.asynctasks
+
+import androidx.annotation.WorkerThread
+import ch.threema.app.utils.executor.BackgroundExecutor
+import ch.threema.app.utils.executor.BackgroundTask
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModel
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.repositories.ContactCreateException
+import ch.threema.data.repositories.ContactModelRepository
+import kotlinx.coroutines.runBlocking
+
+private val logger = LoggingUtil.getThreemaLogger("AddContactBackgroundTask")
+
+/**
+ * This task simply adds the given contact model data if the contact does not exist. If there is a
+ * contact with the same identity already, adding the new data is aborted.
+ */
+class AddContactBackgroundTask(
+    private val contactModelData: ContactModelData,
+    private val contactModelRepository: ContactModelRepository,
+) : BackgroundTask<ContactModel?> {
+
+    /**
+     * Add the contact model data if the contact does not exist.
+     *
+     * @return the newly inserted contact model or null if it could not be inserted
+     */
+    @WorkerThread
+    fun runSynchronously(): ContactModel? {
+        runBefore()
+
+        runInBackground().let {
+            runAfter(it)
+            return it
+        }
+    }
+
+    /**
+     * Do not call this method directly. Use [runSynchronously] or run this task using a
+     * [BackgroundExecutor].
+     */
+    override fun runInBackground(): ContactModel? {
+        if (contactModelRepository.getByIdentity(contactModelData.identity) != null) {
+            logger.warn("Contact already exists")
+            return null
+        }
+
+        return try {
+            runBlocking {
+                contactModelRepository.createFromLocal(contactModelData)
+            }
+        } catch (e: ContactCreateException) {
+            logger.error("Contact could not be created", e)
+            null
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt b/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt
index e80b4a04..e73a6d9f 100644
--- a/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt
+++ b/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt
@@ -22,6 +22,8 @@
 package ch.threema.app.asynctasks
 
 import android.content.Context
+import androidx.annotation.StringRes
+import androidx.annotation.WorkerThread
 import ch.threema.app.R
 import ch.threema.app.utils.AppRestrictionUtil
 import ch.threema.app.utils.executor.BackgroundTask
@@ -29,11 +31,16 @@ import ch.threema.base.ThreemaException
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.data.models.ContactModel
 import ch.threema.data.models.ContactModelData
+import ch.threema.data.models.ContactModelData.Companion.getIdColorIndex
 import ch.threema.data.repositories.ContactCreateException
 import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.models.ContactSyncState
 import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
 import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
 import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.domain.protocol.api.APIConnector.FetchIdentityResult
 import ch.threema.domain.protocol.api.APIConnector.HttpConnectionException
@@ -43,7 +50,7 @@ import kotlinx.coroutines.runBlocking
 import java.net.HttpURLConnection
 import java.util.Date
 
-private val logger = LoggingUtil.getThreemaLogger("AddContactBackgroundTask")
+private val logger = LoggingUtil.getThreemaLogger("AddOrUpdateContactBackgroundTask")
 
 /**
  * This background task should be used if a new identity should be added to the contacts. The task
@@ -54,28 +61,84 @@ private val logger = LoggingUtil.getThreemaLogger("AddContactBackgroundTask")
  * returns [Failed] if it doesn't match.
  *
  * This task also updates the contact if it already exists. This includes changing the acquaintance
- * level from group to direct or changing the verification level to fully verified.
+ * level to [acquaintanceLevel] and the verification level to fully verified (if [expectedPublicKey]
+ * is provided and matches).
  *
- * Note that this task can be overridden and the behavior can be adjusted by overwriting [onBefore]
- * and [onFinished].
+ * Note that this task can be overridden and the behavior can be adjusted by overwriting [onBefore],
+ * [onContactAdded], and [onFinished]. For tasks that do not need to perform any additional
+ * background work, the [BasicAddOrUpdateContactBackgroundTask] can be used.
  */
-open class AddOrUpdateContactBackgroundTask(
+abstract class AddOrUpdateContactBackgroundTask<T>(
     protected val identity: String,
+    protected val acquaintanceLevel: AcquaintanceLevel,
     private val myIdentity: String,
     private val apiConnector: APIConnector,
     private val contactModelRepository: ContactModelRepository,
     private val addContactRestrictionPolicy: AddContactRestrictionPolicy,
     private val context: Context,
     private val expectedPublicKey: ByteArray? = null,
-) : BackgroundTask<ContactAddResult> {
+) : BackgroundTask<T> {
 
+    /**
+     * Run this task synchronously on the same thread. Note that this performs network communication
+     * and must not be run on the main thread.
+     */
+    @WorkerThread
+    fun runSynchronously(): T {
+        runBefore()
+
+        val result = runInBackground()
+
+        runAfter(result)
+
+        return result
+    }
+
+    /**
+     * Do not call this method directly. This should only be called by the background executor.
+     */
     final override fun runBefore() {
         onBefore()
     }
 
-    final override fun runInBackground(): ContactAddResult {
+    /**
+     * Do not call this method directly. This should only be called by the background executor. If
+     * the task should be run on the same thread, use [runSynchronously].
+     */
+    final override fun runInBackground(): T {
+        val result = checkAndAddNewContact()
+
+        return onContactAdded(result)
+    }
+
+    /**
+     * Do not call this method directly. This should only be called by the background executor.
+     */
+    final override fun runAfter(result: T) {
+        onFinished(result)
+    }
+
+    /**
+     * This will be run before the contact is being fetched from the server.
+     */
+    open fun onBefore() = Unit
+
+    /**
+     * As soon as the contact has been added or an error occurred, this method is run with the
+     * provided result. Note that this method is run on the executor's background thread. The result
+     * of it will be passed to [onFinished].
+     */
+    abstract fun onContactAdded(result: ContactResult): T
+
+    /**
+     * This method is run on the UI thread after [onContactAdded] has been executed. Override this
+     * method for making UI changes after the contact has been added and processed.
+     */
+    open fun onFinished(result: T) = Unit
+
+    private fun checkAndAddNewContact(): ContactResult {
         if (identity == myIdentity) {
-            return failed(R.string.identity_already_exists)
+            return UserIdentity(context)
         }
 
         // Update contact if it exists
@@ -91,7 +154,7 @@ open class AddOrUpdateContactBackgroundTask(
         if (addContactRestrictionPolicy == AddContactRestrictionPolicy.CHECK
             && AppRestrictionUtil.isAddContactDisabled(context)
         ) {
-            return PolicyViolation
+            return PolicyViolation(context)
         }
 
         // Fetch the identity
@@ -102,15 +165,15 @@ open class AddOrUpdateContactBackgroundTask(
 
             when (e) {
                 is HttpConnectionException -> {
-                    if (e.errorCode == HttpURLConnection.HTTP_NOT_FOUND) {
-                        return failed(R.string.invalid_threema_id)
+                    return if (e.errorCode == HttpURLConnection.HTTP_NOT_FOUND) {
+                        InvalidThreemaId(context)
                     } else {
-                        return failed(R.string.connection_error)
+                        ConnectionError(context)
                     }
                 }
 
                 is NetworkException, is ThreemaException -> {
-                    return failed(R.string.connection_error)
+                    return ConnectionError(context)
                 }
 
                 else -> {
@@ -123,94 +186,86 @@ open class AddOrUpdateContactBackgroundTask(
         return addNewContact(result, expectedPublicKey)
     }
 
-    final override fun runAfter(result: ContactAddResult) {
-        onFinished(result)
-    }
-
-    /**
-     * This will be run before the contact is being fetched from the server.
-     */
-    open fun onBefore() {}
-
-    /**
-     * As soon as the contact has been added or an error occurred, this method is run with the
-     * provided result.
-     */
-    open fun onFinished(result: ContactAddResult) {}
-
     private fun addNewContact(
         result: FetchIdentityResult,
         expectedPublicKey: ByteArray?,
-    ): ContactAddResult {
+    ): ContactResult {
         val verificationLevel = if (expectedPublicKey != null) {
             if (expectedPublicKey.contentEquals(result.publicKey)) {
                 VerificationLevel.FULLY_VERIFIED
             } else {
-                return failed(R.string.id_mismatch)
+                return RemotePublicKeyMismatch(context)
             }
         } else {
             VerificationLevel.UNVERIFIED
         }
 
-        val identityType = when (result.type) {
-            0 -> IdentityType.NORMAL
-            1 -> IdentityType.WORK
-            else -> {
-                logger.warn("Identity fetch returned invalid identity type: {}", result.type)
-                IdentityType.NORMAL
-            }
-        }
-
-        val activityState = when (result.state) {
-            IdentityState.ACTIVE -> ch.threema.storage.models.ContactModel.State.ACTIVE
-            IdentityState.INACTIVE -> ch.threema.storage.models.ContactModel.State.INACTIVE
-            IdentityState.INVALID -> ch.threema.storage.models.ContactModel.State.INVALID
-            else -> {
-                logger.warn("Identity fetch returned invalid identity state: {}", result.state)
-                ch.threema.storage.models.ContactModel.State.ACTIVE
-            }
-        }
-
         return runBlocking {
             try {
                 val contactModel = contactModelRepository.createFromLocal(
-                    result.identity,
-                    result.publicKey,
-                    Date(),
-                    identityType,
-                    AcquaintanceLevel.DIRECT,
-                    activityState,
-                    result.featureMask.toULong(),
-                    verificationLevel,
+                    ContactModelData(
+                        identity = result.identity,
+                        publicKey = result.publicKey,
+                        createdAt = Date(),
+                        firstName = "",
+                        lastName = "",
+                        nickname = null,
+                        colorIndex = getIdColorIndex(result.identity),
+                        verificationLevel = verificationLevel,
+                        workVerificationLevel = WorkVerificationLevel.NONE,
+                        identityType = result.getIdentityType(),
+                        acquaintanceLevel = acquaintanceLevel,
+                        activityState = result.getIdentityState(),
+                        syncState = ContactSyncState.INITIAL,
+                        featureMask = result.featureMask.toULong(),
+                        readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+                        typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+                        androidContactLookupKey = null,
+                        localAvatarExpires = null,
+                        isRestored = false,
+                        profilePictureBlobId = null,
+                        jobTitle = null,
+                        department = null,
+                    )
                 )
-                Success(contactModel)
+                ContactCreated(contactModel)
             } catch (e: ContactCreateException) {
                 logger.error("Could not insert new contact", e)
-                failed(R.string.add_contact_failed)
+
+                val existingContact = contactModelRepository.getByIdentity(identity)
+                if (existingContact != null) {
+                    ContactExists(existingContact)
+                } else {
+                    GenericFailure(context)
+                }
             }
         }
     }
 
-    private fun updateContact(contactModel: ContactModel, data: ContactModelData, expectedPublicKey: ByteArray?): ContactAddResult {
+    private fun updateContact(
+        contactModel: ContactModel,
+        currentData: ContactModelData,
+        expectedPublicKey: ByteArray?,
+    ): ContactResult {
         var verificationLevelChanged = false
         var contactVerifiedAgain = false
         var acquaintanceLevelChanged = false
 
         if (expectedPublicKey != null) {
-            if (expectedPublicKey.contentEquals(data.publicKey)) {
-                if (data.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
+            if (expectedPublicKey.contentEquals(currentData.publicKey)) {
+                if (currentData.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
                     contactModel.setVerificationLevelFromLocal(VerificationLevel.FULLY_VERIFIED)
                     verificationLevelChanged = true
                 } else {
                     contactVerifiedAgain = true
                 }
             } else {
-                return failed(R.string.id_mismatch)
+                return LocalPublicKeyMismatch(contactModel, context)
             }
         }
 
-        if (data.acquaintanceLevel == AcquaintanceLevel.GROUP) {
-            contactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.DIRECT)
+        if (currentData.acquaintanceLevel != acquaintanceLevel) {
+            contactModel.setAcquaintanceLevelFromLocal(acquaintanceLevel)
             acquaintanceLevelChanged = true
         }
 
@@ -223,8 +278,52 @@ open class AddOrUpdateContactBackgroundTask(
             else -> ContactExists(contactModel)
         }
     }
+}
+
+fun FetchIdentityResult.getIdentityType(): IdentityType = when (type) {
+    0 -> IdentityType.NORMAL
+    1 -> IdentityType.WORK
+    else -> {
+        logger.warn("Identity fetch returned invalid identity type: {}", type)
+        IdentityType.NORMAL
+    }
+}
+
+fun FetchIdentityResult.getIdentityState(): IdentityState = when (state) {
+    IdentityState.ACTIVE.value -> IdentityState.ACTIVE
+    IdentityState.INACTIVE.value -> IdentityState.INACTIVE
+    IdentityState.INVALID.value -> IdentityState.INVALID
+    else -> {
+        logger.warn("Identity fetch returned invalid identity state: {}", state)
+        IdentityState.ACTIVE
+    }
+}
 
-    private fun failed(stringId: Int) = Failed(context.getString(stringId))
+/**
+ * Use this task for creating a new contact when no additional background work is required after the
+ * contact has been created. The [ContactResult] is directly passed to [onFinished]. See
+ * [AddOrUpdateContactBackgroundTask] for more information about contact creation.
+ */
+open class BasicAddOrUpdateContactBackgroundTask(
+    identity: String,
+    acquaintanceLevel: AcquaintanceLevel,
+    myIdentity: String,
+    apiConnector: APIConnector,
+    contactModelRepository: ContactModelRepository,
+    addContactRestrictionPolicy: AddContactRestrictionPolicy,
+    context: Context,
+    expectedPublicKey: ByteArray? = null,
+) : AddOrUpdateContactBackgroundTask<ContactResult>(
+    identity,
+    acquaintanceLevel,
+    myIdentity,
+    apiConnector,
+    contactModelRepository,
+    addContactRestrictionPolicy,
+    context,
+    expectedPublicKey
+) {
+    final override fun onContactAdded(result: ContactResult): ContactResult = result
 }
 
 /**
@@ -246,14 +345,34 @@ enum class AddContactRestrictionPolicy {
 }
 
 /**
- * The result type of adding a contact.
+ * The result type of adding or updating a contact. The result is either [ContactAvailable] or
+ * [Failed] or both.
+ */
+sealed interface ContactResult
+
+/**
+ * The contact is now available. This is the case when the contact has successfully been added or if
+ * the contact already existed.
+ */
+sealed interface ContactAvailable : ContactResult {
+    val contactModel: ContactModel
+}
+
+/**
+ * Adding or updating the contact failed. Note that this does not necessarily mean that the contact
+ * does not exist. E.g., this result can indicate that the provided public key does not match.
  */
-sealed interface ContactAddResult
+sealed class Failed(context: Context, @StringRes resId: Int) : ContactResult {
+    /**
+     * A translated error message that can be shown to the user.
+     */
+    val message: String = context.getString(resId)
+}
 
 /**
- * The contact has been added successfully. The new contact is provided.
+ * The contact has been newly created. The new contact is provided.
  */
-data class Success(val contactModel: ContactModel) : ContactAddResult
+data class ContactCreated(override val contactModel: ContactModel) : ContactAvailable
 
 /**
  * The contact already existed and has now been updated.
@@ -262,42 +381,65 @@ data class ContactModified(
     /**
      * The updated contact model.
      */
-    val contactModel: ContactModel,
+    override val contactModel: ContactModel,
     /**
-     * If true, the acquaintance level changed from [AcquaintanceLevel.GROUP] to
-     * [AcquaintanceLevel.DIRECT].
+     * If true, the acquaintance level changed.
      */
     val acquaintanceLevelChanged: Boolean,
     /**
      * If true, the verification level has changed to [VerificationLevel.FULLY_VERIFIED].
      */
     val verificationLevelChanged: Boolean,
-) : ContactAddResult
-
-/**
- * The result type when adding the contact has failed.
- */
-interface Error : ContactAddResult
+) : ContactAvailable
 
 /**
  * The contact already exists. This is only returned, if no expected public key is given and the
  * contact already exists. This means, that neither the verification level nor the acquaintance
  * level did change.
  */
-data class ContactExists(val contactModel: ContactModel) : Error
+data class ContactExists(override val contactModel: ContactModel) : ContactAvailable
 
 /**
  * The contact already exists and has been fully verified before.
  */
-data class AlreadyVerified(val contactModel: ContactModel) : Error
+data class AlreadyVerified(override val contactModel: ContactModel) : ContactAvailable
+
+/**
+ * The locally stored public key of the contact does not match the provided public key.
+ */
+class LocalPublicKeyMismatch(
+    override val contactModel: ContactModel,
+    context: Context,
+) : Failed(context, R.string.id_mismatch), ContactAvailable
+
+/**
+ * The contact did not exist locally and the fetched public key from the threema server does not
+ * match the provided public key. This also means, that the contact is not available locally.
+ */
+class RemotePublicKeyMismatch(context: Context) : Failed(context, R.string.id_mismatch)
+
+/**
+ * The provided identity is invalid and the contact could not be added.
+ */
+class InvalidThreemaId(context: Context) : Failed(context, R.string.invalid_threema_id)
+
+/**
+ * The provided identity is the same as the user's identity and therefore the contact could not be
+ * added.
+ */
+class UserIdentity(context: Context) : Failed(context, R.string.identity_already_exists)
+
+/**
+ * The contact could not be added due to a connection error.
+ */
+class ConnectionError(context: Context) : Failed(context, R.string.connection_error)
 
 /**
- * Adding the contact failed. The [message] contains a (translated) error message that can be shown
- * to the user.
+ * A general error occurred while adding the contact.
  */
-data class Failed(val message: String) : Error
+class GenericFailure(context: Context) : Failed(context, R.string.add_contact_failed)
 
 /**
  * The contact could not be added since adding contacts is restricted.
  */
-object PolicyViolation : Error
+class PolicyViolation(context: Context) : Failed(context, R.string.disabled_by_policy_short)
diff --git a/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateWorkContactBackgroundTask.kt b/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateWorkContactBackgroundTask.kt
new file mode 100644
index 00000000..de707d86
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateWorkContactBackgroundTask.kt
@@ -0,0 +1,244 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.asynctasks
+
+import androidx.annotation.WorkerThread
+import ch.threema.app.services.license.LicenseService
+import ch.threema.app.services.license.UserCredentials
+import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.executor.BackgroundTask
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModel
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.models.ContactModelData.Companion.getIdColorIndex
+import ch.threema.data.repositories.ContactCreateException
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.api.APIConnector
+import ch.threema.domain.protocol.api.work.WorkContact
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+import com.neilalexander.jnacl.NaCl
+import kotlinx.coroutines.runBlocking
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("AddOrUpdateWorkContactBackgroundTask")
+
+/**
+ * Creates the provided contact if it does not exist. If it already exists, then it is updated in
+ * case it wasn't a direct work contact that is at least server verified.
+ *
+ * This task does not do anything if it isn't a work build.
+ */
+open class AddOrUpdateWorkContactBackgroundTask(
+    /**
+     * The work contact information of the contact that will be added or updated.
+     */
+    private val workContact: WorkContact,
+    /**
+     * The user's identity.
+     */
+    private val myIdentity: String,
+    /**
+     * The contact model repository.
+     */
+    private val contactModelRepository: ContactModelRepository,
+) : BackgroundTask<ContactModel?> {
+
+    /**
+     * Add the work contact if the identity belongs to a work contact.
+     *
+     * @return the newly inserted contact model or null if it could not be inserted
+     */
+    @WorkerThread
+    fun runSynchronously(): ContactModel? {
+        runBefore()
+
+        runInBackground().let {
+            runAfter(it)
+            return it
+        }
+    }
+
+    @WorkerThread
+    override fun runInBackground(): ContactModel? {
+        if (!ConfigUtils.isWorkBuild()) {
+            return null
+        }
+
+        if (workContact.publicKey.size != NaCl.PUBLICKEYBYTES) {
+            // Ignore work contact with invalid public key
+            logger.warn(
+                "Work contact has invalid public key of size {}",
+                workContact.publicKey.size
+            )
+            return null
+        }
+
+        if (workContact.threemaId == myIdentity) {
+            // Do not add our own ID as a contact
+            logger.warn("Cannot add the user's identity as work contact")
+            return null
+        }
+
+        val contactModel = contactModelRepository.getByIdentity(workContact.threemaId)
+
+        return if (contactModel != null) {
+            updateContact(contactModel)
+            contactModel
+        } else {
+            createContact()
+        }
+    }
+
+    @WorkerThread
+    private fun createContact(): ContactModel? {
+        return runBlocking {
+            try {
+                contactModelRepository.createFromLocal(
+                    ContactModelData(
+                        identity = workContact.threemaId,
+                        publicKey = workContact.publicKey,
+                        createdAt = Date(),
+                        firstName = workContact.firstName ?: "",
+                        lastName = workContact.lastName ?: "",
+                        nickname = null,
+                        colorIndex = getIdColorIndex(workContact.threemaId),
+                        verificationLevel = VerificationLevel.SERVER_VERIFIED,
+                        workVerificationLevel = WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
+                        identityType = IdentityType.WORK, // TODO(ANDR-3159): Fetch identity type
+                        acquaintanceLevel = AcquaintanceLevel.DIRECT,
+                        activityState = IdentityState.ACTIVE, // TODO(ANDR-3159): Fetch identity state
+                        syncState = ContactSyncState.INITIAL,
+                        featureMask = 0u, // TODO(ANDR-3159): Fetch feature mask
+                        readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+                        typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+                        androidContactLookupKey = null,
+                        localAvatarExpires = null,
+                        isRestored = false,
+                        profilePictureBlobId = null,
+                        jobTitle = workContact.jobTitle,
+                        department = workContact.department,
+                    )
+                )
+            } catch (e: ContactCreateException) {
+                logger.error("Could not create work contact", e)
+                null
+            }
+        }
+    }
+
+    private fun updateContact(contactModel: ContactModel) {
+        val data = contactModel.data.value ?: run {
+            logger.error("Contact has already been deleted")
+            return
+        }
+
+        // Update first and last name if the contact is not synchronized
+        if (
+            data.androidContactLookupKey == null
+            && (workContact.firstName != null || workContact.lastName != null)
+        ) {
+            contactModel.setNameFromLocal(workContact.firstName ?: "", workContact.lastName ?: "")
+        }
+
+        // Update work verification level
+        contactModel.setWorkVerificationLevelFromLocal(WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED)
+
+        // Update acquaintance level
+        contactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.DIRECT)
+
+        // Update verification level (except it would be a downgrade)
+        if (data.verificationLevel == VerificationLevel.UNVERIFIED) {
+            contactModel.setVerificationLevelFromLocal(VerificationLevel.SERVER_VERIFIED)
+        }
+    }
+}
+
+/**
+ * This task fetches the information whether the given identity is a work identity. If it is, then
+ * a new work contact is created or the existing contact is updated.
+ *
+ * This task does not do anything if it is not a work build.
+ */
+class AddOrUpdateWorkIdentityBackgroundTask(
+    private val identity: String,
+    private val myIdentity: String,
+    private val licenseService: LicenseService<*>,
+    private val apiConnector: APIConnector,
+    private val contactModelRepository: ContactModelRepository,
+) : BackgroundTask<ContactModel?> {
+
+    /**
+     * Add the work contact if the identity belongs to a work contact.
+     *
+     * @return the newly inserted contact model or null if it could not be inserted
+     */
+    @WorkerThread
+    fun runSynchronously(): ContactModel? {
+        runBefore()
+
+        runInBackground().let {
+            runAfter(it)
+            return it
+        }
+    }
+
+    @WorkerThread
+    override fun runInBackground(): ContactModel? {
+        if (!ConfigUtils.isWorkBuild()) {
+            return null
+        }
+
+        val credentials = licenseService.loadCredentials()
+
+        if (credentials !is UserCredentials) {
+            logger.error("No user credentials available")
+            return null
+        }
+
+        val workContact = apiConnector.fetchWorkContacts(
+            credentials.username,
+            credentials.password,
+            arrayOf(identity),
+        ).firstOrNull() ?: run {
+            logger.info("Identity {} is not a work contact", identity)
+            return null
+        }
+
+        if (workContact.threemaId != identity) {
+            logger.error("Received different identity from server: {} instead of {}", workContact.threemaId, identity)
+            return null
+        }
+
+        return AddOrUpdateWorkContactBackgroundTask(
+            workContact,
+            myIdentity,
+            contactModelRepository,
+        ).runSynchronously()
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/DeleteContactAsyncTask.java b/app/src/main/java/ch/threema/app/asynctasks/DeleteContactAsyncTask.java
deleted file mode 100644
index 778c5fe8..00000000
--- a/app/src/main/java/ch/threema/app/asynctasks/DeleteContactAsyncTask.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.asynctasks;
-
-import android.os.AsyncTask;
-
-import java.util.Iterator;
-import java.util.Set;
-
-import androidx.fragment.app.FragmentManager;
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.dialogs.CancelableHorizontalProgressDialog;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.utils.DialogUtil;
-import ch.threema.storage.models.ContactModel;
-
-public class DeleteContactAsyncTask extends AsyncTask<Void, Integer, Integer> {
-	private static final String DIALOG_TAG_DELETE_CONTACT = "dc";
-
-	private final Set<ContactModel> contacts;
-	private final ContactService contactService;
-	private final FragmentManager fragmentManager;
-	private final DeleteContactsPostRunnable runOnCompletion;
-	private boolean cancelled = false;
-
-	public static class DeleteContactsPostRunnable implements Runnable {
-		protected Integer failed;
-
-		protected void setFailed(Integer failed) {
-			this.failed = failed;
-		}
-
-		@Override
-		public void run() {}
-	}
-
-	public DeleteContactAsyncTask(FragmentManager fragmentManager,
-	                              Set<ContactModel> contacts,
-	                              ContactService contactService,
-	                              DeleteContactsPostRunnable runOnCompletion) {
-
-		this.contacts = contacts;
-		this.contactService = contactService;
-		this.fragmentManager = fragmentManager;
-		this.runOnCompletion = runOnCompletion;
-	}
-
-	@Override
-	protected void onPreExecute() {
-		CancelableHorizontalProgressDialog dialog = CancelableHorizontalProgressDialog.newInstance(R.string.deleting_contact, R.string.cancel, contacts.size());
-		dialog.setOnCancelListener((dialog1, which) -> cancelled = true);
-		dialog.show(fragmentManager, DIALOG_TAG_DELETE_CONTACT);
-
-		ThreemaApplication.onAndroidContactChangeLock.lock();
-	}
-
-	@Override
-	protected Integer doInBackground(Void... params) {
-		int failed = 0, i = 0;
-		Iterator<ContactModel> checkedItemsIterator = contacts.iterator();
-		while (checkedItemsIterator.hasNext() && !cancelled) {
-			publishProgress(i++);
-
-			ContactModel contact = checkedItemsIterator.next();
-
-			if (contact == null || !contactService.remove(contact)) {
-				failed++;
-			}
-		}
-		return failed;
-	}
-
-	@Override
-	protected void onProgressUpdate(Integer... index) {
-		DialogUtil.updateProgress(fragmentManager, DIALOG_TAG_DELETE_CONTACT, index[0] + 1);
-	}
-
-	@Override
-	protected void onPostExecute(Integer failed) {
-		DialogUtil.dismissDialog(fragmentManager, DIALOG_TAG_DELETE_CONTACT, true);
-
-		// note: ContactListener.onRemoved() will be triggered by ContactStore.removeContact()
-
-		if (runOnCompletion != null) {
-			runOnCompletion.setFailed(failed);
-			runOnCompletion.run();
-		}
-
-		ThreemaApplication.onAndroidContactChangeLock.unlock();
-	}
-
-	@Override
-	protected void onCancelled(Integer integer) {
-		super.onCancelled(integer);
-
-		// Release the lock just in case this async task was cancelled
-		ThreemaApplication.onAndroidContactChangeLock.unlock();
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java b/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java
index 9c26d0c4..cb5ab8a2 100644
--- a/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java
+++ b/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java
@@ -29,6 +29,7 @@ import org.slf4j.Logger;
 import java.io.File;
 import java.io.IOException;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.fragment.app.FragmentManager;
 import ch.threema.app.R;
@@ -40,11 +41,13 @@ import ch.threema.app.services.PassphraseService;
 import ch.threema.app.utils.DialogUtil;
 import ch.threema.app.utils.SecureDeleteUtil;
 import ch.threema.app.utils.ShortcutUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.webclient.services.SessionWakeUpServiceImpl;
 import ch.threema.app.webclient.services.instance.DisconnectContext;
+import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.DatabaseNonceStore;
+import ch.threema.storage.DatabaseServiceNew;
 
 public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("DeleteIdentityAsyncTask");
@@ -54,6 +57,7 @@ public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 	private final ServiceManager serviceManager;
 	private final FragmentManager fragmentManager;
 	private final Runnable runOnCompletion;
+	private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
 
 	public DeleteIdentityAsyncTask(@Nullable FragmentManager fragmentManager,
 	                               @Nullable Runnable runOnCompletion) {
@@ -80,7 +84,7 @@ public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 			serviceManager.getMessageService().removeAll();
 			serviceManager.getConversationService().reset();
 			serviceManager.getGroupService().removeAll();
-			serviceManager.getContactService().removeAll();
+			backgroundExecutor.execute(getDeleteAllContactsTask());
 			try {
 				serviceManager.getUserService().removeIdentity();
 			} catch (Exception ignored) {}
@@ -157,6 +161,28 @@ public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 		}
 	}
 
+	@NonNull
+	private DeleteAllContactsBackgroundTask getDeleteAllContactsTask() throws ThreemaException {
+		return new DeleteAllContactsBackgroundTask(
+			serviceManager.getModelRepositories().getContacts(),
+			new DeleteContactServices(
+				serviceManager.getUserService(),
+				serviceManager.getContactService(),
+				serviceManager.getConversationService(),
+				serviceManager.getRingtoneService(),
+				serviceManager.getMutedChatsListService(),
+				serviceManager.getHiddenChatsListService(),
+				serviceManager.getProfilePicRecipientsService(),
+				serviceManager.getWallpaperService(),
+				serviceManager.getFileService(),
+				serviceManager.getExcludedSyncIdentitiesService(),
+				serviceManager.getDHSessionStore(),
+				serviceManager.getNotificationService(),
+				serviceManager.getDatabaseServiceNew()
+			)
+		);
+	}
+
 	private void secureDelete(File file) {
 		try {
 			SecureDeleteUtil.secureDelete(file);
diff --git a/app/src/main/java/ch/threema/app/asynctasks/MarkContactAsDeletedBackgroundTask.kt b/app/src/main/java/ch/threema/app/asynctasks/MarkContactAsDeletedBackgroundTask.kt
new file mode 100644
index 00000000..4bf57e25
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/asynctasks/MarkContactAsDeletedBackgroundTask.kt
@@ -0,0 +1,368 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.asynctasks
+
+import android.content.Context
+import android.widget.Toast
+import androidx.annotation.CallSuper
+import androidx.fragment.app.FragmentManager
+import ch.threema.app.R
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy.KEEP
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy.REMOVE_LINK
+import ch.threema.app.asynctasks.ContactSyncPolicy.EXCLUDE
+import ch.threema.app.asynctasks.ContactSyncPolicy.INCLUDE
+import ch.threema.app.dialogs.CancelableHorizontalProgressDialog
+import ch.threema.app.services.ContactService
+import ch.threema.app.services.ConversationService
+import ch.threema.app.services.DeadlineListService
+import ch.threema.app.services.FileService
+import ch.threema.app.services.IdListService
+import ch.threema.app.services.RingtoneService
+import ch.threema.app.services.UserService
+import ch.threema.app.services.WallpaperService
+import ch.threema.app.services.notification.NotificationService
+import ch.threema.app.utils.AndroidContactUtil
+import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.ContactUtil
+import ch.threema.app.utils.DialogUtil
+import ch.threema.app.utils.RuntimeUtil
+import ch.threema.app.utils.ShortcutUtil
+import ch.threema.app.utils.executor.BackgroundTask
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.stores.DHSessionStoreException
+import ch.threema.domain.stores.DHSessionStoreInterface
+import ch.threema.storage.DatabaseServiceNew
+import ch.threema.storage.models.ContactModel
+import java.lang.ref.WeakReference
+
+private const val DIALOG_TAG_DELETE_CONTACT = "dc"
+
+private val logger = LoggingUtil.getThreemaLogger("DeleteContactBackgroundTask")
+
+/**
+ * The collection of required services to delete a contact.
+ */
+data class DeleteContactServices(
+    val userService: UserService,
+    val contactService: ContactService,
+    val conversationService: ConversationService,
+    val ringtoneService: RingtoneService,
+    val mutedChatsListService: DeadlineListService,
+    val hiddenChatsListService: DeadlineListService,
+    val profilePicRecipientsService: IdListService,
+    val wallpaperService: WallpaperService,
+    val fileService: FileService,
+    val excludeService: IdListService,
+    val dhSessionStore: DHSessionStoreInterface,
+    val notificationService: NotificationService,
+    val databaseService: DatabaseServiceNew,
+)
+
+/**
+ * The policy whether to exclude the contact from future contact syncs.
+ */
+enum class ContactSyncPolicy {
+    /**
+     * The contact won't be excluded from contact sync and may therefore re-appear the next time
+     * contact synchronization is executed.
+     */
+    INCLUDE,
+
+    /**
+     * The contact will be excluded from contact sync and won't re-appear by synchronizing the
+     * contacts.
+     */
+    EXCLUDE,
+}
+
+/**
+ * The policy whether to remove the link to Threema in android contacts (raw contact). Note that
+ * modifying the android contacts may be rate limited. Therefore, we should be sparing with android
+ * contact modifications.
+ */
+enum class AndroidContactLinkPolicy {
+    /**
+     * We keep the contact linked to Threema. Note that when deleting individual contacts, we should
+     * not keep them linked. Use this option primarily when the Threema 'account' is deleted anyway.
+     */
+    KEEP,
+
+    /**
+     * The link to Threema will be removed.
+     */
+    REMOVE_LINK,
+}
+
+/**
+ * This background task should be used to delete a contact from local. Note that this just sets the
+ * acquaintance level to group, removes the conversation, and still shown notifications.
+ */
+open class MarkContactAsDeletedBackgroundTask(
+    protected val contacts: Set<String>,
+    private val contactModelRepository: ContactModelRepository,
+    protected val deleteContactServices: DeleteContactServices,
+    private val syncPolicy: ContactSyncPolicy,
+    private val androidLinkPolicy: AndroidContactLinkPolicy,
+) : BackgroundTask<Set<String>>, CancelableHorizontalProgressDialog.ProgressDialogClickListener {
+    private var cancelled = false
+
+    @CallSuper
+    override fun runBefore() {
+        // Note that we need to lock the android contact change lock on the UI thread in order to be
+        // able to unlock it again. The reason is that the runAfter method is run on the UI thread.
+        // TODO(ANDR-2327): This is a hack that may be removed when we have implemented contact
+        //  import.
+        RuntimeUtil.runOnUiThread {
+            ThreemaApplication.onAndroidContactChangeLock.lock()
+        }
+    }
+
+    override fun runInBackground(): Set<String> {
+        val deletedIdentities = mutableSetOf<String>()
+        for ((index, identity) in contacts.withIndex()) {
+            try {
+                if (cancelled) {
+                    return deletedIdentities
+                }
+                try {
+                    updateProgress(index)
+                } catch (e: Exception) {
+                    logger.error("Could not update progress", e)
+                }
+
+                val success = markContactAsDeleted(identity)
+
+                when (androidLinkPolicy) {
+                    REMOVE_LINK -> AndroidContactUtil.getInstance()
+                        .deleteThreemaRawContact(identity)
+
+                    KEEP -> Unit
+                }
+
+                if (success) {
+                    deletedIdentities.add(identity)
+                }
+            } catch (e: Exception) {
+                logger.error("Could not delete contact {}", identity, e)
+            }
+        }
+
+        return deletedIdentities
+    }
+
+    @CallSuper
+    override fun runAfter(result: Set<String>) {
+        ThreemaApplication.onAndroidContactChangeLock.unlock()
+
+        when (syncPolicy) {
+            EXCLUDE -> {
+                for (deletedIdentity in result) {
+                    deleteContactServices.excludeService.add(deletedIdentity)
+                }
+            }
+
+            INCLUDE -> Unit
+        }
+
+        onFinished()
+    }
+
+    /**
+     * This method is run after the contacts have been deleted. Note that it is run independent of
+     * how many of them could be deleted.
+     */
+    protected open fun onFinished() = Unit
+
+    override fun onCancel(tag: String?, `object`: Any?) {
+        cancelled = true
+    }
+
+    private fun markContactAsDeleted(identity: String): Boolean {
+        val contactModel = contactModelRepository.getByIdentity(identity) ?: return false
+
+        // Note that the conversation needs to be deleted before the downgrade due to the old model
+        // that may still be cached and will be stored as the last update flag will be reset.
+        deleteContactServices.conversationService.delete(identity)
+
+        // Remove the old contact model from the cache to reduce the risk to it being stored to the
+        // database.
+        deleteContactServices.contactService.removeFromCache(identity)
+
+        // Cancel notifications
+        deleteContactServices.notificationService.cancel(identity)
+
+        contactModel.setAcquaintanceLevelFromLocal(ContactModel.AcquaintanceLevel.GROUP)
+
+        return true
+    }
+
+    /**
+     * This method is run before the deletion of a contact. Note that this is also called if the
+     * contact could not be deleted.
+     */
+    protected open fun updateProgress(progress: Int) {
+        // Nothing to do here
+    }
+}
+
+/**
+ * Use this task when all contacts should be deleted. Note that this does not remove the contact
+ * links as they may be rate limited. Therefore, this task should only be used when the account is
+ * deleted afterwards anyways. Otherwise some links in the android contacts may remain.
+ *
+ * Note: This must only be called if the app is being completely erased. If this task is executed
+ * while MD is enabled, this will lead to a de-sync.
+ */
+open class DeleteAllContactsBackgroundTask(
+    contactModelRepository: ContactModelRepository,
+    deleteContactServices: DeleteContactServices,
+) : MarkContactAsDeletedBackgroundTask(
+    deleteContactServices.contactService.all.map(ContactModel::identity).toSet(),
+    contactModelRepository,
+    deleteContactServices,
+    INCLUDE,
+    KEEP
+) {
+    override fun runAfter(result: Set<String>) {
+        if (contacts.size != result.size) {
+            logger.warn("Deleted {} contacts instead of {}.", result.size, contacts.size)
+        }
+
+        // Delete all contacts
+        deleteContactServices.databaseService.contactModelFactory.deleteAll()
+        contacts.forEach(::cleanContactLeftovers)
+
+        super.runAfter(result)
+    }
+
+    /**
+     * This cleans leftovers from a removed contact. This includes:
+     * - Contact Service Cache
+     * - Conversation
+     * - Custom ringtone setting
+     * - Mute preference
+     * - Hidden chat preference
+     * - Profile picture receive preference
+     * - Custom wallpaper
+     * - Android contact avatar
+     * - Contact avatar
+     * - Contact photo
+     * - Cancel notifications
+     * - Share target shortcut
+     * - Pinned shortcut
+     * - FS sessions
+     *
+     * This should only be called after the contact was successfully removed from the database.
+     */
+    private fun cleanContactLeftovers(identity: String) {
+        deleteContactServices.contactService.removeFromCache(identity)
+        deleteContactServices.conversationService.delete(identity)
+
+        val uniqueIdString = ContactUtil.getUniqueIdString(identity)
+
+        deleteContactServices.ringtoneService.removeCustomRingtone(uniqueIdString)
+        deleteContactServices.mutedChatsListService.remove(uniqueIdString)
+        deleteContactServices.hiddenChatsListService.remove(uniqueIdString)
+        deleteContactServices.profilePicRecipientsService.remove(identity)
+        deleteContactServices.wallpaperService.removeWallpaper(uniqueIdString)
+        deleteContactServices.fileService.removeAndroidDefinedProfilePicture(identity)
+        deleteContactServices.fileService.removeUserDefinedProfilePicture(identity)
+        deleteContactServices.fileService.removeContactDefinedProfilePicture(identity)
+        deleteContactServices.notificationService.cancel(identity)
+        ShortcutUtil.deleteShareTargetShortcut(uniqueIdString)
+        ShortcutUtil.deletePinnedShortcut(uniqueIdString)
+
+        val myIdentity = deleteContactServices.userService.identity
+        try {
+            deleteContactServices.dhSessionStore.deleteAllDHSessions(myIdentity, identity)
+        } catch (e: DHSessionStoreException) {
+            logger.error("Could not delete all DH sessions with {}", identity, e)
+        }
+    }
+}
+
+open class DialogMarkContactAsDeletedBackgroundTask(
+    private val fragmentManager: FragmentManager,
+    private val contextRef: WeakReference<Context>,
+    contacts: Set<String>,
+    contactModelRepository: ContactModelRepository,
+    deleteContactServices: DeleteContactServices,
+    syncPolicy: ContactSyncPolicy,
+    linkPolicy: AndroidContactLinkPolicy,
+) : MarkContactAsDeletedBackgroundTask(
+    contacts,
+    contactModelRepository,
+    deleteContactServices,
+    syncPolicy,
+    linkPolicy,
+) {
+    override fun runBefore() {
+        val dialog: CancelableHorizontalProgressDialog =
+            CancelableHorizontalProgressDialog.newInstance(
+                R.string.deleting_contact,
+                contacts.size
+            )
+        dialog.show(fragmentManager, DIALOG_TAG_DELETE_CONTACT)
+
+        super.runBefore()
+    }
+
+    override fun runAfter(result: Set<String>) {
+        super.runAfter(result)
+
+        DialogUtil.dismissDialog(
+            fragmentManager,
+            DIALOG_TAG_DELETE_CONTACT,
+            true
+        )
+
+        val context = contextRef.get() ?: return
+
+        val failed = contacts.size - result.size
+        if (failed > 0) {
+            Toast.makeText(
+                context,
+                ConfigUtils.getSafeQuantityString(
+                    ThreemaApplication.getAppContext(),
+                    R.plurals.some_contacts_not_deleted,
+                    failed,
+                    failed
+                ),
+                Toast.LENGTH_LONG
+            ).show()
+        } else {
+            if (result.size > 1) {
+                Toast.makeText(context, R.string.contacts_deleted, Toast.LENGTH_LONG).show()
+            } else {
+                Toast.makeText(context, R.string.contact_deleted, Toast.LENGTH_LONG).show()
+            }
+        }
+    }
+
+    override fun updateProgress(progress: Int) {
+        RuntimeUtil.runOnUiThread {
+            DialogUtil.updateProgress(fragmentManager, DIALOG_TAG_DELETE_CONTACT, progress)
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/SendToSupportBackgroundTask.kt b/app/src/main/java/ch/threema/app/asynctasks/SendToSupportBackgroundTask.kt
new file mode 100644
index 00000000..da5f176d
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/asynctasks/SendToSupportBackgroundTask.kt
@@ -0,0 +1,71 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.asynctasks
+
+import android.content.Context
+import ch.threema.app.preference.SettingsAdvancedOptionsFragment.THREEMA_SUPPORT_IDENTITY
+import ch.threema.app.services.ContactServiceImpl
+import ch.threema.data.models.ContactModel
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.protocol.api.APIConnector
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+
+/**
+ * The result of sending some messages to the support.
+ */
+enum class SendToSupportResult {
+    SUCCESS,
+    FAILED,
+}
+
+/**
+ * This class can be used to send messages to the support. It creates the support contact if not
+ * already available.
+ */
+abstract class SendToSupportBackgroundTask(
+    myIdentity: String,
+    apiConnector: APIConnector,
+    contactModelRepository: ContactModelRepository,
+    context: Context,
+) : AddOrUpdateContactBackgroundTask<SendToSupportResult>(
+    THREEMA_SUPPORT_IDENTITY,
+    AcquaintanceLevel.DIRECT,
+    myIdentity,
+    apiConnector,
+    contactModelRepository,
+    AddContactRestrictionPolicy.IGNORE,
+    context,
+    ContactServiceImpl.SUPPORT_PUBLIC_KEY,
+) {
+    final override fun onContactAdded(result: ContactResult): SendToSupportResult {
+        return when (result) {
+            is ContactAvailable -> onSupportAvailable(result.contactModel)
+            else -> SendToSupportResult.FAILED
+        }
+    }
+
+    /**
+     * This method is called when the support contact is available. It is run on a background
+     * thread.
+     */
+    abstract fun onSupportAvailable(contactModel: ContactModel): SendToSupportResult
+}
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java b/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java
index f9b00bee..2d7f3f94 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java
@@ -97,10 +97,12 @@ import ch.threema.app.utils.StringConversionUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.ZipUtil;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.HashedNonce;
+import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.identitybackup.IdentityBackupGenerator;
-import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -133,6 +135,7 @@ public class BackupService extends Service {
 	private static final int MEDIA_STEP_FACTOR_VIDEOS_AND_FILES = 12;
 	private static final int MEDIA_STEP_FACTOR_THUMBNAILS = 3;
 	private static final int NONCES_PER_STEP = 50;
+	private static final int NONCES_CHUNK_SIZE = 2500;
 
 	private static final String EXTRA_ID_CANCEL = "cnc";
 	public static final String EXTRA_BACKUP_RESTORE_DATA_CONFIG = "ebrdc";
@@ -163,7 +166,7 @@ public class BackupService extends Service {
 	private PreferenceService preferenceService;
 	private PowerManager.WakeLock wakeLock;
 	private NotificationManagerCompat notificationManagerCompat;
-	private DatabaseNonceStore databaseNonceStore;
+	private NonceFactory nonceFactory;
 
 	private NotificationCompat.Builder notificationBuilder;
 
@@ -310,6 +313,7 @@ public class BackupService extends Service {
 			userService = serviceManager.getUserService();
 			ballotService = serviceManager.getBallotService();
 			preferenceService = serviceManager.getPreferenceService();
+			nonceFactory = serviceManager.getNonceFactory();
 		} catch (Exception e) {
 			logger.error("Exception", e);
 			safeStopSelf();
@@ -317,7 +321,6 @@ public class BackupService extends Service {
 		}
 
 		notificationManagerCompat = NotificationManagerCompat.from(this);
-		databaseNonceStore = new DatabaseNonceStore(this, serviceManager.getIdentityStore());
 	}
 
 	@Override
@@ -411,7 +414,7 @@ public class BackupService extends Service {
 
 			if (this.config.backupNonces()) {
 				progress += 1;
-				long nonceCount = this.databaseNonceStore.getCount();
+				long nonceCount = nonceFactory.getCount(NonceScope.CSP) + nonceFactory.getCount(NonceScope.D2D);
 				long nonceProgress = (long) Math.ceil((double) nonceCount / NONCES_PER_STEP);
 				progress += nonceProgress;
 			}
@@ -484,8 +487,9 @@ public class BackupService extends Service {
 		return this.next(subject, 1);
 	}
 
-	private boolean next(String subject, int factor) {
-		this.currentProgressStep += (this.currentProgressStep < this.processSteps ? factor : 0);
+	private boolean next(String subject, int increment) {
+		logger.debug("step [{}]", subject);
+		this.currentProgressStep += (this.currentProgressStep < this.processSteps ? increment : 0);
 		this.handleProgress();
 		return !isCanceled;
 	}
@@ -545,7 +549,7 @@ public class BackupService extends Service {
 			try {
 				ZipUtil.addZipStream(
 					zipOutputStream,
-					this.fileService.getContactAvatarStream(contactService.getMe().getIdentity()),
+					this.fileService.getUserDefinedProfilePictureStream(contactService.getMe().getIdentity()),
 					Tags.CONTACT_AVATAR_FILE_PREFIX + Tags.CONTACT_AVATAR_FILE_SUFFIX_ME,
 					false
 				);
@@ -621,7 +625,7 @@ public class BackupService extends Service {
 							if (!userService.getIdentity().equals(contactModel.getIdentity())) {
 								ZipUtil.addZipStream(
 									zipOutputStream,
-									this.fileService.getContactAvatarStream(contactModel.getIdentity()),
+									this.fileService.getUserDefinedProfilePictureStream(contactModel.getIdentity()),
 									Tags.CONTACT_AVATAR_FILE_PREFIX + identityId,
 									false
 								);
@@ -634,7 +638,7 @@ public class BackupService extends Service {
 						try {
 							ZipUtil.addZipStream(
 								zipOutputStream,
-								this.fileService.getContactPhotoStream(contactModel.getIdentity()),
+								this.fileService.getContactDefinedProfilePictureStream(contactModel.getIdentity()),
 								Tags.CONTACT_PROFILE_PIC_FILE_PREFIX + identityId,
 								false
 							);
@@ -732,6 +736,7 @@ public class BackupService extends Service {
 			Tags.TAG_GROUP_DESC,
 			Tags.TAG_GROUP_DESC_TIMESTAMP,
 			Tags.TAG_GROUP_UID,
+			Tags.TAG_GROUP_USER_STATE,
 		};
 		final String[] groupMessageCsvHeader = {
 			Tags.TAG_MESSAGE_API_MESSAGE_ID,
@@ -807,6 +812,7 @@ public class BackupService extends Service {
 						.write(Tags.TAG_GROUP_DESC, groupModel.getGroupDesc())
 						.write(Tags.TAG_GROUP_DESC_TIMESTAMP, groupModel.getGroupDescTimestamp())
 						.write(Tags.TAG_GROUP_UID, groupUid)
+						.write(Tags.TAG_GROUP_USER_STATE, groupModel.getUserState() != null ? groupModel.getUserState().value : 0)
 						.write();
 
 					//check if the group have a photo
@@ -1091,15 +1097,24 @@ public class BackupService extends Service {
 			return false;
 		}
 
-		try (ByteArrayOutputStream outputStreamBuffer = new ByteArrayOutputStream()) {
-			writeNonces(outputStreamBuffer);
-			// Write nonces to zip *after* the CSVWriter has been closed (and therefore flushed)
-			ZipUtil.addZipStream(
-				zipOutputStream,
-				new ByteArrayInputStream(outputStreamBuffer.toByteArray()),
-				Tags.NONCE_FILE_NAME + Tags.CSV_FILE_POSTFIX,
-				true
+		try {
+			int nonceCountCsp = writeNoncesToBackup(
+				NonceScope.CSP,
+				Tags.NONCE_FILE_NAME_CSP + Tags.CSV_FILE_POSTFIX,
+				zipOutputStream
+			);
+
+			int nonceCountD2d = writeNoncesToBackup(
+				NonceScope.D2D,
+				Tags.NONCE_FILE_NAME_D2D + Tags.CSV_FILE_POSTFIX,
+				zipOutputStream
 			);
+
+			writeNonceCounts(nonceCountCsp, nonceCountD2d, zipOutputStream);
+
+			int remainingCsp = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountCsp);
+			int remainingD2d = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountD2d);
+			next("Backup nonce", (int) Math.ceil(((double) remainingCsp + remainingD2d) / NONCES_PER_STEP));
 			logger.info("Nonce backup completed");
 		} catch (IOException | ThreemaException e) {
 			logger.error("Error with byte array output stream", e);
@@ -1109,36 +1124,91 @@ public class BackupService extends Service {
 		return true;
 	}
 
-	private void writeNonces(
+	private void writeNonceCounts(
+		int nonceCountCsp,
+		int nonceCountD2d,
+		@NonNull ZipOutputStream zipOutputStream
+	) throws IOException, ThreemaException {
+		logger.info("Write nonce counts to backup (CSP: {}, D2D: {})", nonceCountCsp, nonceCountD2d);
+		final String[] nonceCountHeader = new String[]{ Tags.TAG_NONCE_COUNT_CSP, Tags.TAG_NONCE_COUNT_D2D };
+		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
+			try (
+				OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
+				CSVWriter csvWriter = new CSVWriter(outputStreamWriter, nonceCountHeader)
+			) {
+				csvWriter.createRow()
+					.write(Tags.TAG_NONCE_COUNT_CSP, nonceCountCsp)
+					.write(Tags.TAG_NONCE_COUNT_D2D, nonceCountD2d)
+					.write();
+			}
+			ZipUtil.addZipStream(
+				zipOutputStream,
+				new ByteArrayInputStream(outputStream.toByteArray()),
+				Tags.NONCE_COUNTS_FILE + Tags.CSV_FILE_POSTFIX,
+				false
+			);
+		}
+	}
+
+	private int writeNoncesToBackup(
+		@NonNull NonceScope scope,
+		@NonNull String fileName,
+		@NonNull ZipOutputStream zipOutputStream
+	) throws ThreemaException, IOException {
+		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
+			int count = writeNonces(scope, outputStream);
+			// Write nonces to zip *after* the CSVWriter has been closed (and therefore flushed)
+			ZipUtil.addZipStream(
+				zipOutputStream,
+				new ByteArrayInputStream(outputStream.toByteArray()),
+				fileName,
+				true
+			);
+			return count;
+		}
+	}
+
+	private int writeNonces(
+		@NonNull NonceScope scope,
 		@NonNull ByteArrayOutputStream outputStream
 	) throws ThreemaException, IOException {
+		logger.info("Backup {} nonces", scope);
 		final String[] nonceHeader = new String[]{Tags.TAG_NONCES};
+		int backedUpNonceCount = 0;
 		try (
 			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
 			CSVWriter csvWriter = new CSVWriter(outputStreamWriter, nonceHeader)
 		) {
 			long start = System.currentTimeMillis();
-			long nonceCount = databaseNonceStore.getCount();
-			long numChunks = (long) Math.ceil((double) nonceCount / NONCES_PER_STEP);
-			List<byte[]> nonces = new ArrayList<>(NONCES_PER_STEP);
+			long nonceCount = nonceFactory.getCount(scope);
+			long numChunks = (long) Math.ceil((double) nonceCount / NONCES_CHUNK_SIZE);
+			List<HashedNonce> nonces = new ArrayList<>(NONCES_CHUNK_SIZE);
 			for (int i = 0; i < numChunks; i++) {
-				databaseNonceStore.addHashedNonceChunk(NONCES_PER_STEP, NONCES_PER_STEP * i, nonces);
-				for (byte[] nonceBytes : nonces) {
-					String nonce = Utils.byteArrayToHexString(nonceBytes);
+				nonceFactory.addHashedNoncesChunk(
+					scope,
+					NONCES_CHUNK_SIZE,
+					NONCES_CHUNK_SIZE * i,
+					nonces
+				);
+				for (HashedNonce hashedNonce : nonces) {
+					String nonce = Utils.byteArrayToHexString(hashedNonce.getBytes());
 					csvWriter.createRow().write(Tags.TAG_NONCES, nonce).write();
 				}
+				int increment = nonces.size() / NONCES_PER_STEP;
+				backedUpNonceCount += nonces.size();
 				nonces.clear();
-				if (!next("Backup nonce")) {
-					return;
+				if (!next("Backup nonce", increment)) {
+					return backedUpNonceCount;
 				}
 				// Periodically log nonce backup progress for debugging purposes
-				if ((i & 2047) == 0) {
+				if ((i % 10) == 0 || i == numChunks) {
 					logger.info("Nonce backup progress: {} of {} chunks backed up", i, numChunks);
 				}
 			}
 			long end = System.currentTimeMillis();
-			logger.info("Created row for all nonces in {} ms", end - start);
+			logger.info("Created backup for all {} nonces in {} ms", scope, end - start);
 		}
+		return backedUpNonceCount;
 	}
 
 	/**
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java
index 57f389d9..45179655 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java
@@ -87,13 +87,14 @@ import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.StringConversionUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.ContactModelFactory;
 import ch.threema.storage.models.AbstractMessageModel;
@@ -105,6 +106,7 @@ import ch.threema.storage.models.DistributionListModel;
 import ch.threema.storage.models.GroupMemberModel;
 import ch.threema.storage.models.GroupMessageModel;
 import ch.threema.storage.models.GroupModel;
+import ch.threema.storage.models.GroupModel.UserState;
 import ch.threema.storage.models.MessageModel;
 import ch.threema.storage.models.MessageState;
 import ch.threema.storage.models.MessageType;
@@ -120,6 +122,8 @@ import ch.threema.storage.models.data.media.FileDataModel;
 
 import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC;
 import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
+import static ch.threema.storage.models.GroupModel.UserState.LEFT;
+import static ch.threema.storage.models.GroupModel.UserState.MEMBER;
 
 public class RestoreService extends Service {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("RestoreService");
@@ -145,7 +149,7 @@ public class RestoreService extends Service {
 	private PreferenceService preferenceService;
 	private PowerManager.WakeLock wakeLock;
 	private NotificationManagerCompat notificationManagerCompat;
-	private DatabaseNonceStore databaseNonceStore;
+	private NonceFactory nonceFactory;
 
 	private NotificationCompat.Builder notificationBuilder;
 
@@ -174,6 +178,7 @@ public class RestoreService extends Service {
 	private static final int STEP_SIZE_GROUP_AVATARS = 50;
 	private static final int STEP_SIZE_MEDIA = 25; // per media file
 	private static final int NONCES_PER_STEP = 50;
+	private static final int NONCES_CHUNK_SIZE = 10_000;
 
 	private long stepSizeTotal = (long) STEP_SIZE_PREPARE + STEP_SIZE_IDENTITY + STEP_SIZE_MAIN_FILES + STEP_SIZE_GROUP_AVATARS;
 
@@ -295,7 +300,7 @@ public class RestoreService extends Service {
 			conversationService = serviceManager.getConversationService();
 			userService = serviceManager.getUserService();
 			preferenceService = serviceManager.getPreferenceService();
-			databaseNonceStore = new DatabaseNonceStore(this, serviceManager.getIdentityStore());
+			nonceFactory = serviceManager.getNonceFactory();
 		} catch (Exception e) {
 			logger.error("Could not instantiate all required services", e);
 			stopSelf();
@@ -504,10 +509,6 @@ public class RestoreService extends Service {
 				// Restore nonces
 				logger.info("Restoring nonces");
 				int nonceCount = restoreNonces(fileHeaders);
-				if (nonceCount < 0) {
-					logger.error("Restoring nonces failed ({})", nonceCount);
-					//continue anyway!
-				}
 
 				//contacts, groups and distribution lists
 				logger.info("Restoring main files (contacts, groups, distribution lists)");
@@ -602,7 +603,7 @@ public class RestoreService extends Service {
 		try (
 			InputStream is = zipFile.getInputStream(settingsHeader);
 			InputStreamReader inputStreamReader = new InputStreamReader(is);
-			CSVReader csvReader = new CSVReader(inputStreamReader)
+			CSVReader csvReader = new CSVReader(inputStreamReader, false)
 		) {
 			RestoreSettings settings = new RestoreSettings();
 			settings.parse(csvReader.readAll());
@@ -659,28 +660,112 @@ public class RestoreService extends Service {
 		return true;
 	}
 
+	/**
+	 * Attempt to restore the nonces. If restoring of nonces fails for some reason 0 is returned.
+	 * Since we continue anyway, there is no need to distinguish between zero restored nonces and
+	 * a failure.
+	 */
 	private int restoreNonces(List<FileHeader> fileHeaders) throws IOException, RestoreCanceledException {
-		FileHeader nonceFileHeader = null;
+		if (!writeToDb) {
+			// If not writing to the database only the count of nonces is required.
+			// Try to read optional nonces count file if present in backup.
+			logger.info("Get nonce counts");
+			int nonceCount = readNonceCounts(fileHeaders);
+			if (nonceCount >= 0) {
+				// If the nonce count is available return it and skip reading the whole nonces file.
+				logger.info("{} nonces in backup", nonceCount);
+				return nonceCount;
+			} else {
+				logger.info("Count nonces in backup.");
+			}
+		}
+
+		int nonceCountCsp = restoreNonces(
+			NonceScope.CSP,
+			Tags.NONCE_FILE_NAME_CSP + Tags.CSV_FILE_POSTFIX,
+			fileHeaders
+		);
+
+		int nonceCountD2d = restoreNonces(
+			NonceScope.D2D,
+			Tags.NONCE_FILE_NAME_D2D + Tags.CSV_FILE_POSTFIX,
+			fileHeaders
+		);
+
+		int remainingCsp = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountCsp);
+		int remainingD2d = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountD2d);
+		int remainingNonceProgress = remainingCsp + remainingD2d;
+		logger.debug("Remaining nonce progress: {}", remainingNonceProgress);
+		updateProgress((long) Math.ceil((double) remainingNonceProgress / NONCES_PER_STEP));
+
+		return nonceCountCsp + nonceCountD2d;
+	}
+
+	/**
+	 * Read the counts from the nonce counts file if available.
+	 *
+	 * @return the count, or -1 if the count could not be read from some reason.
+	 */
+	private int readNonceCounts(List<FileHeader> fileHeaders) throws IOException {
+		FileHeader nonceCountFileHeader = getFileHeader(Tags.NONCE_COUNTS_FILE + Tags.CSV_FILE_POSTFIX, fileHeaders);
+		if (nonceCountFileHeader == null) {
+			logger.info("No nonce count file available in backup");
+			return -1;
+		}
+		try (ZipInputStream inputStream = this.zipFile.getInputStream(nonceCountFileHeader);
+		     InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
+		     CSVReader csvReader = new CSVReader(inputStreamReader, true)
+		) {
+			CSVRow row = csvReader.readNextRow();
+			if (row == null) {
+				logger.warn("Could not read nonce count. File is empty.");
+				return -1;
+			}
+			return row.getInteger(Tags.TAG_NONCE_COUNT_CSP) + row.getInteger(Tags.TAG_NONCE_COUNT_D2D);
+		} catch (ThreemaException | NumberFormatException e) {
+			logger.warn("Could not read nonce count", e);
+			return -1;
+		}
+	}
+
+	/**
+	 * Get the file header where the file name matches the provided exactFileName.
+	 *
+	 * @param exactFileName The file name that is matched against
+	 * @param fileHeaders The file headers that are scanned
+	 * @return The first matching file header or null if none matches
+	 */
+	@Nullable
+	private FileHeader getFileHeader(@NonNull String exactFileName, List<FileHeader> fileHeaders) {
 		for (FileHeader fileHeader : fileHeaders) {
-			String fileName = fileHeader.getFileName();
-			if (fileName != null && fileName.startsWith(Tags.NONCE_FILE_NAME)) {
-				nonceFileHeader = fileHeader;
-				break;
+			if (exactFileName.equals(fileHeader.getFileName())) {
+				return fileHeader;
 			}
 		}
+		logger.info("No file header for '{}' found", exactFileName);
+		return null;
+	}
+
+	private int restoreNonces(
+		@NonNull NonceScope scope,
+		@NonNull String nonceBackupFile,
+		@NonNull List<FileHeader> fileHeaders
+	) throws IOException, RestoreCanceledException {
+		logger.info("Restore {} nonces", scope);
+		final FileHeader nonceFileHeader = getFileHeader(nonceBackupFile, fileHeaders);
 		if (nonceFileHeader == null) {
 			logger.info("Nonce file header is null");
-			return -1;
+			return 0;
 		}
 
 		try (ZipInputStream inputStream = this.zipFile.getInputStream(nonceFileHeader);
 		     InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
-		     CSVReader csvReader = new CSVReader(inputStreamReader, false)
+		     CSVReader csvReader = new CSVReader(inputStreamReader, true)
 		) {
-			int nonceProgressCount = 0;
 			int nonceCount = 0;
 			boolean success = true;
 			CSVRow row;
+			List<byte[]> nonceBytes = new ArrayList<>(NONCES_CHUNK_SIZE);
 			while ((row = csvReader.readNextRow()) != null) {
 				try {
 					// Note that currently there is only one nonce per row, and therefore we do
@@ -689,27 +774,42 @@ public class RestoreService extends Service {
 					String[] nonces = row.getStrings(Tags.TAG_NONCES);
 					nonceCount += nonces.length;
 					if (writeToDb) {
-						success &= databaseNonceStore.insertHashedNonces(nonces);
-						nonceProgressCount += nonces.length;
-						if (nonceProgressCount >= NONCES_PER_STEP) {
-							long increment = nonceProgressCount / NONCES_PER_STEP;
-							updateProgress(increment);
-							nonceProgressCount -= increment * NONCES_PER_STEP;
+						for (String nonce : nonces) {
+							nonceBytes.add(Utils.hexStringToByteArray(nonce));
+							if (nonceBytes.size() >= NONCES_CHUNK_SIZE) {
+								success &= insertNonces(scope, nonceBytes);
+								nonceBytes.clear();
+							}
 						}
 					}
 				} catch (ThreemaException e) {
-					logger.error("Could not insert nonces");
-					return -1;
+					logger.error("Could not insert nonces", e);
+					return 0;
 				}
 			}
+			if (!nonceBytes.isEmpty()) {
+				success &= insertNonces(scope, nonceBytes);
+			}
 			if (success) {
+				logger.info("Restored {} {} nonces", nonceCount, scope);
 				return nonceCount;
 			} else {
-				return -1;
+				logger.warn("Restoring {} nonces was not successfull", scope);
+				return 0;
 			}
 		}
 	}
 
+	private boolean insertNonces(
+		@NonNull NonceScope scope,
+		@NonNull List<byte[]> nonces
+	) throws RestoreCanceledException {
+		logger.debug("Write {} nonces to database", nonces.size());
+		boolean success = nonceFactory.insertHashedNoncesJava(scope, nonces);
+		updateProgress(nonces.size() / NONCES_PER_STEP);
+		return success;
+	}
+
 	/**
 	 * restore all avatars and profile pics
 	 */
@@ -972,7 +1072,7 @@ public class RestoreService extends Service {
 
 		// Set contact avatar
 		try (ZipInputStream inputStream = zipFile.getInputStream(fileHeader)) {
-			return fileService.writeContactAvatar(
+			return fileService.writeUserDefinedProfilePicture(
 				contactModel.getIdentity(),
 				IOUtils.toByteArray(inputStream)
 			);
@@ -1001,7 +1101,7 @@ public class RestoreService extends Service {
 
 		// Set contact profile picture
 		try (ZipInputStream inputStream = zipFile.getInputStream(fileHeader)) {
-			return fileService.writeContactPhoto(
+			return fileService.writeContactDefinedProfilePicture(
 				contactModel.getIdentity(),
 				IOUtils.toByteArray(inputStream));
 		} catch (Exception e) {
@@ -1029,10 +1129,24 @@ public class RestoreService extends Service {
 					restoreResult.incContactSuccess();
 				}
 
-				List<GroupMemberModel> groupMemberModels = createGroupMembers(row, groupModel.getId());
 				if (writeToDb) {
+					String myIdentity = userService.getIdentity();
+					boolean isInMemberList = false;
+
+					List<GroupMemberModel> groupMemberModels = createGroupMembers(row, groupModel.getId());
+
 					for (GroupMemberModel groupMemberModel : groupMemberModels) {
-						databaseServiceNew.getGroupMemberModelFactory().create(groupMemberModel);
+						if (!myIdentity.equals(groupMemberModel.getIdentity())) {
+							databaseServiceNew.getGroupMemberModelFactory().create(groupMemberModel);
+						} else {
+							isInMemberList = true;
+						}
+					}
+					if (restoreSettings.getVersion() < 25) {
+						// In this case the group user state is not included in the backup and we
+						// need to determine the state based on the group member list.
+						groupModel.setUserState(isInMemberList ? MEMBER : LEFT);
+						databaseServiceNew.getGroupModelFactory().update(groupModel);
 					}
 				}
 			} catch (Exception x) {
@@ -1179,6 +1293,10 @@ public class RestoreService extends Service {
 			groupModel.setLastUpdate(row.getDate(Tags.TAG_GROUP_LAST_UPDATE));
 		}
 
+		if (restoreSettings.getVersion() >= 25) {
+			groupModel.setUserState(UserState.valueOf(row.getInteger(Tags.TAG_GROUP_USER_STATE)));
+		}
+
 		return groupModel;
 	}
 
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java
index 92efccdf..e13bbfb8 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java
@@ -44,8 +44,9 @@ public class RestoreSettings {
 	 * 22: add lastUpdate and remove isQueued flag
 	 * 23: add editedAt
 	 * 24: add deletedAt
+	 * 25: add group user state
 	 */
-	public static final int CURRENT_VERSION = 24;
+	public static final int CURRENT_VERSION = 25;
 	private int version;
 
 	public RestoreSettings(int version) {
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java b/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java
index 5d923381..53ce6524 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java
@@ -36,7 +36,10 @@ public abstract class Tags {
 	public static final String CONTACT_AVATAR_FILE_PREFIX = "contact_avatar_";
 	public static final String CONTACT_AVATAR_FILE_SUFFIX_ME = "me";
 	public static final String CONTACT_PROFILE_PIC_FILE_PREFIX = "contact_profile_pic_";
-	public static final String NONCE_FILE_NAME = "nonces";
+	// do not rename csp nonces file to preserve backwards compatibility
+	public static final String NONCE_FILE_NAME_CSP = "nonces";
+	public static final String NONCE_FILE_NAME_D2D = "nonces_d2d";
+	public static final String NONCE_COUNTS_FILE = "nonce_counts";
 
 	public static final String DISTRIBUTION_LIST_MESSAGE_MEDIA_FILE_PREFIX = "distribution_list_message_media_";
 	public static final String DISTRIBUTION_LIST_MESSAGE_MEDIA_THUMBNAIL_FILE_PREFIX = "distribution_list_thumbnail_";
@@ -51,6 +54,8 @@ public abstract class Tags {
 	public static final String TAG_INFO_VERSION = "version";
 
 	public static final String TAG_NONCES = "nonces";
+	public static final String TAG_NONCE_COUNT_CSP = "csp";
+	public static final String TAG_NONCE_COUNT_D2D = "d2d";
 
 	public static final String TAG_CONTACT_IDENTITY = "identity";
 	public static final String TAG_CONTACT_FIRST_NAME = "firstname";
@@ -75,6 +80,7 @@ public abstract class Tags {
 	public static final String TAG_GROUP_DESC = "groupDesc";
 	public static final String TAG_GROUP_DESC_TIMESTAMP = "groupDescTimestamp";
 	public static final String TAG_GROUP_UID = "group_uid";
+	public static final String TAG_GROUP_USER_STATE = "user_state";
 
 	public static final String TAG_MESSAGE_UID = "uid";
 	public static final String TAG_MESSAGE_IDENTITY = "identity";
diff --git a/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt b/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt
index fe1c9178..7a0a6343 100644
--- a/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt
+++ b/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt
@@ -80,7 +80,7 @@ class QRCodeAnalyzer(private val onDecodeQRCode: (decodeQRCodeState: DecodeQRCod
                     try {
                         decode(imageProxy, data)
                     } catch (e: Exception) {
-                        logger.info("Decode error for inverted QR Code")
+                        logger.debug("Decode error for inverted QR Code")
                     }
                 } catch (e: Exception) {
                     logger.error("Scanning error", e)
diff --git a/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt b/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt
index 035dbc08..3939a722 100644
--- a/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt
+++ b/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt
@@ -33,7 +33,12 @@ import android.view.WindowManager
 import android.widget.ImageView
 import android.widget.TextView
 import android.widget.Toast
-import androidx.camera.core.*
+import androidx.camera.core.Camera
+import androidx.camera.core.CameraSelector
+import androidx.camera.core.FocusMeteringAction
+import androidx.camera.core.ImageAnalysis
+import androidx.camera.core.ImageCapture
+import androidx.camera.core.Preview
 import androidx.camera.lifecycle.ProcessCameraProvider
 import androidx.camera.view.PreviewView
 import androidx.core.content.ContextCompat
@@ -42,7 +47,6 @@ import ch.threema.app.ThreemaApplication
 import ch.threema.app.activities.ThreemaActivity
 import ch.threema.app.services.QRCodeServiceImpl.QRCodeColor
 import ch.threema.app.services.QRCodeServiceImpl.QR_TYPE_ANY
-import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.SoundUtil
 import ch.threema.base.utils.LoggingUtil
 import java.util.concurrent.ExecutorService
@@ -98,11 +102,19 @@ class QRScannerActivity : ThreemaActivity() {
                 getString(R.string.msg_default_status)
             }
         }
-        findViewById<TextView>(R.id.hint_view).text = hint
-        if (qrColor == QR_TYPE_ANY) {
-            findViewById<ImageView>(R.id.camera_viewfinder).visibility = View.GONE
-        } else {
-            findViewById<ImageView>(R.id.camera_viewfinder).setColorFilter(qrColor)
+
+        // set hint text
+        findViewById<TextView>(R.id.hint_view)?.let {
+            it.text = hint
+        }
+
+        // set viewfinder color
+        findViewById<ImageView>(R.id.camera_viewfinder)?.let {
+            if (qrColor == QR_TYPE_ANY) {
+                it.visibility = View.GONE
+            } else {
+                it.setColorFilter(qrColor)
+            }
         }
 
         // Wait for the views to be properly laid out
diff --git a/app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt b/app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt
index 170270d0..09d9289a 100644
--- a/app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt
+++ b/app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt
@@ -22,8 +22,6 @@
 package ch.threema.app.compose.common.interop
 
 import androidx.compose.ui.platform.ComposeView
-import androidx.preference.PreferenceManager
-import ch.threema.app.ThreemaApplication
 import ch.threema.app.activities.MessageDetailsUiModel
 import ch.threema.app.activities.MessageTimestampsUiModel
 import ch.threema.app.activities.toUiModel
@@ -40,7 +38,7 @@ object ComposeJavaBridge {
         messageDetailsUiModel: MessageDetailsUiModel,
     ) {
         composeView.setContent {
-            ThreemaTheme(dynamicColor = shouldUseDynamicColors()) {
+            ThreemaTheme {
                 CombinedMessageDetailsList(
                     messageTimestampsUiModel,
                     messageDetailsUiModel
@@ -56,7 +54,7 @@ object ComposeJavaBridge {
     ) {
         val messageBubbleUiState = model.toUiModel(myIdentity)
         composeView.setContent {
-            ThreemaTheme(dynamicColor = shouldUseDynamicColors()) {
+            ThreemaTheme {
                 MessageBubble(
                     text = messageBubbleUiState.text,
                     isOutbox = messageBubbleUiState.isOutbox,
@@ -64,9 +62,4 @@ object ComposeJavaBridge {
             }
         }
     }
-
-    private fun shouldUseDynamicColors(): Boolean {
-        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext())
-        return sharedPreferences.getBoolean("pref_dynamic_color", false)
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt b/app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt
index 14bd0c1c..8684b91d 100644
--- a/app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt
+++ b/app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt
@@ -33,10 +33,13 @@ import androidx.compose.runtime.Composable
 import androidx.compose.runtime.CompositionLocalProvider
 import androidx.compose.runtime.ReadOnlyComposable
 import androidx.compose.runtime.SideEffect
+import androidx.compose.runtime.remember
 import androidx.compose.ui.graphics.toArgb
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.LocalView
 import androidx.core.view.WindowCompat
+import androidx.preference.PreferenceManager
+import ch.threema.app.ThreemaApplication
 import ch.threema.app.compose.theme.color.ColorsDark
 import ch.threema.app.compose.theme.color.ColorsLight
 import ch.threema.app.compose.theme.color.CustomColor
@@ -46,17 +49,19 @@ import ch.threema.app.compose.theme.color.LocalCustomColor
 
 val AppTypography = Typography() // system default
 
-/**
- *  @param dynamicColor available on Android 12+
- */
 @Composable
 fun ThreemaTheme(
     isDarkTheme: Boolean = isSystemInDarkTheme(),
-    dynamicColor: Boolean = true,
     content: @Composable () -> Unit
 ) {
+
+    val shouldUseDynamicColors: Boolean = remember {
+        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext())
+        sharedPreferences.getBoolean("pref_dynamic_color", false)
+    }
+
     val materialColorScheme: ColorScheme = when {
-        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
+        shouldUseDynamicColors && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
             val context = LocalContext.current
             if (isDarkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
         }
diff --git a/app/src/main/java/ch/threema/app/debug/PatternLibraryActivity.kt b/app/src/main/java/ch/threema/app/debug/PatternLibraryActivity.kt
new file mode 100644
index 00000000..33f7bf1b
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/debug/PatternLibraryActivity.kt
@@ -0,0 +1,375 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.debug
+
+import android.content.res.Configuration.UI_MODE_NIGHT_NO
+import android.content.res.Configuration.UI_MODE_NIGHT_YES
+import android.os.Bundle
+import androidx.activity.compose.setContent
+import androidx.activity.enableEdgeToEdge
+import androidx.appcompat.app.AppCompatActivity
+import androidx.compose.foundation.BorderStroke
+import androidx.compose.foundation.ExperimentalFoundationApi
+import androidx.compose.foundation.background
+import androidx.compose.foundation.border
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.layout.width
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.foundation.text.selection.SelectionContainer
+import androidx.compose.material3.ExperimentalMaterial3Api
+import androidx.compose.material3.Icon
+import androidx.compose.material3.IconButton
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Scaffold
+import androidx.compose.material3.Text
+import androidx.compose.material3.TopAppBar
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.draw.shadow
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.res.painterResource
+import androidx.compose.ui.text.font.FontStyle
+import androidx.compose.ui.text.intl.Locale
+import androidx.compose.ui.text.toUpperCase
+import androidx.compose.ui.tooling.preview.Preview
+import androidx.compose.ui.unit.dp
+import ch.threema.app.R
+import ch.threema.app.compose.theme.ThreemaTheme
+import ch.threema.app.compose.theme.customColorScheme
+
+@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class)
+class PatternLibraryActivity : AppCompatActivity() {
+    override fun onCreate(savedInstanceState: Bundle?) {
+        enableEdgeToEdge()
+        super.onCreate(savedInstanceState)
+        setContent {
+            ThreemaTheme {
+                Scaffold(
+                    topBar = {
+                        TopAppBar(
+                            modifier = Modifier.shadow(elevation = 8.dp),
+                            title = {
+                                Text("Pattern Library")
+                            },
+                            navigationIcon = {
+                                IconButton(
+                                    onClick = { finish() }
+                                ) {
+                                    Icon(
+                                        painter = painterResource(R.drawable.ic_arrow_back_24),
+                                        contentDescription = null
+                                    )
+                                }
+                            },
+                        )
+                    }
+                ) { padding ->
+
+                    val colorCategories: List<ColorSection> = listOf(
+                        ColorSection(
+                            "Brand",
+                            listOf(
+                                MaterialTheme.colorScheme.primary to "primary",
+                                MaterialTheme.colorScheme.onPrimary to "onPrimary",
+                                MaterialTheme.colorScheme.secondary to "secondary",
+                                MaterialTheme.colorScheme.onSecondary to "onSecondary",
+                                MaterialTheme.colorScheme.tertiary to "tertiary",
+                                MaterialTheme.colorScheme.onTertiary to "onTertiary",
+                                MaterialTheme.colorScheme.inversePrimary to "inversePrimary",
+                            )
+                        ),
+                        ColorSection(
+                            "Background",
+                            listOf(
+                                MaterialTheme.colorScheme.background to "background",
+                                MaterialTheme.colorScheme.onBackground to "onBackground",
+                            )
+                        ),
+                        ColorSection(
+                            "Container",
+                            listOf(
+                                MaterialTheme.colorScheme.primaryContainer to "primaryContainer",
+                                MaterialTheme.colorScheme.onPrimaryContainer to "onPrimaryContainer",
+                                MaterialTheme.colorScheme.secondaryContainer to "secondaryContainer",
+                                MaterialTheme.colorScheme.onSecondaryContainer to "onSecondaryContainer",
+                                MaterialTheme.colorScheme.tertiaryContainer to "tertiaryContainer",
+                                MaterialTheme.colorScheme.onTertiaryContainer to "onTertiaryContainer",
+                            )
+                        ),
+                        ColorSection(
+                            "Surface",
+                            listOf(
+                                MaterialTheme.colorScheme.surface to "surface",
+                                MaterialTheme.colorScheme.surfaceDim to "surfaceDim",
+                                MaterialTheme.colorScheme.surfaceBright to "surfaceBright",
+                                MaterialTheme.colorScheme.onSurface to "onSurface",
+                            )
+                        ),
+                        ColorSection(
+                            "Surface Container",
+                            listOf(
+                                MaterialTheme.colorScheme.surfaceContainerLowest to "surfaceContainerLowest",
+                                MaterialTheme.colorScheme.surfaceContainerLow to "surfaceContainerLow",
+                                MaterialTheme.colorScheme.surfaceContainer to "surfaceContainer",
+                                MaterialTheme.colorScheme.surfaceContainerHigh to "surfaceContainerHigh",
+                                MaterialTheme.colorScheme.surfaceContainerHighest to "surfaceContainerHighest",
+                                MaterialTheme.colorScheme.onSurfaceVariant to "onSurfaceVariant",
+                            )
+                        ),
+                        ColorSection(
+                            "Inverse",
+                            listOf(
+                                MaterialTheme.colorScheme.inverseSurface to "inverseSurface",
+                                MaterialTheme.colorScheme.inverseOnSurface to "inverseOnSurface",
+                            )
+                        ),
+                        ColorSection(
+                            "Outline",
+                            listOf(
+                                MaterialTheme.colorScheme.outline to "outline",
+                                MaterialTheme.colorScheme.outlineVariant to "outlineVariant",
+                            )
+                        ),
+                        ColorSection(
+                            "Error",
+                            listOf(
+                                MaterialTheme.colorScheme.error to "error",
+                                MaterialTheme.colorScheme.onError to "onError",
+                                MaterialTheme.colorScheme.errorContainer to "errorContainer",
+                                MaterialTheme.colorScheme.onErrorContainer to "onErrorContainer"
+                            )
+                        ),
+                        ColorSection(
+                            "Custom",
+                            listOf(
+                                MaterialTheme.customColorScheme.messageBubbleContainerReceive to "messageBubbleContainerReceive",
+                                MaterialTheme.customColorScheme.ackTint to "ackTint",
+                                MaterialTheme.customColorScheme.decTint to "decTint"
+                            )
+                        ),
+                    )
+
+                    LazyColumn(
+                        modifier = Modifier.padding(padding),
+                    ) {
+                        item {
+                            TopLevelSectionHeader(name = "Color Scheme")
+                        }
+
+                        colorCategories.forEach { colorSection ->
+
+                            stickyHeader {
+                                Box(
+                                    modifier = Modifier
+                                        .fillMaxWidth()
+                                        .background(MaterialTheme.colorScheme.surfaceContainer)
+                                ) {
+                                    Text(
+                                        modifier = Modifier.padding(vertical = 12.dp, horizontal = 16.dp),
+                                        color = MaterialTheme.colorScheme.onSurface,
+                                        text = colorSection.name,
+                                        style = MaterialTheme.typography.bodyLarge
+                                    )
+                                }
+                            }
+                            items(colorSection.colors.size) { index ->
+                                ColorSpot(
+                                    modifier = Modifier.padding(vertical = 4.dp, horizontal = 12.dp),
+                                    color = colorSection.colors[index].first,
+                                    colorName = colorSection.colors[index].second
+                                )
+                            }
+                        }
+
+                        item {
+                            Column {
+                                Spacer(modifier = Modifier.height(24.dp))
+                                TopLevelSectionHeader(name = "Typography")
+                            }
+                        }
+
+                        item {
+                            Text(
+                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 16.dp),
+                                text = "Not yet implemented",
+                                style = MaterialTheme.typography.bodyMedium.copy(
+                                    fontStyle = FontStyle.Italic
+                                )
+                            )
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Composable
+    private fun TopLevelSectionHeader(
+        modifier: Modifier = Modifier,
+        name: String
+    ) {
+        Text(
+            modifier = modifier
+                .fillMaxWidth()
+                .background(MaterialTheme.colorScheme.surfaceContainer)
+                .padding(vertical = 24.dp, horizontal = 16.dp),
+            text = name,
+            style = MaterialTheme.typography.headlineSmall
+        )
+    }
+
+
+    private data class ColorSection(
+        val name: String,
+        val colors: List<Pair<Color, String>>
+    )
+}
+
+private fun Color.toHexCode(): String {
+    val red = this.red * 255
+    val green = this.green * 255
+    val blue = this.blue * 255
+    return String.format("#%02x%02x%02x", red.toInt(), green.toInt(), blue.toInt())
+}
+
+@Composable
+private fun ColorSpot(
+    modifier: Modifier = Modifier,
+    color: Color,
+    colorName: String
+) {
+    Row(
+        modifier = modifier,
+        verticalAlignment = Alignment.CenterVertically
+    ) {
+
+        val tearShape = RoundedCornerShape(topStartPercent = 5, topEndPercent = 50, bottomEndPercent = 50, bottomStartPercent = 50)
+        val contentColor = MaterialTheme.colorScheme.onSurface
+
+        Box(
+            modifier = Modifier
+                .padding(all = 8.dp)
+                .size(size = 100.dp)
+                .shadow(
+                    elevation = 4.dp,
+                    shape = tearShape
+                )
+                .clip(tearShape)
+                .border(
+                    border = BorderStroke(
+                        width = 1.dp,
+                        color = contentColor
+                    ),
+                    shape = tearShape
+                )
+                .background(color)
+        ) { }
+
+        Spacer(modifier = Modifier.width(24.dp))
+
+        Column(
+            modifier = Modifier.fillMaxWidth()
+        ) {
+            Text(
+                text = colorName,
+                color = contentColor
+            )
+            Spacer(modifier = Modifier.height(2.dp))
+            SelectionContainer {
+                Text(
+                    text = color.toHexCode().toUpperCase(Locale.current),
+                    color = contentColor
+                )
+            }
+        }
+    }
+}
+
+@Preview(
+    showBackground = true,
+    uiMode = UI_MODE_NIGHT_NO,
+    group = "ColorSpot",
+)
+@Composable
+private fun ColorSpot_Preview() {
+    ThreemaTheme {
+        ColorSpot(
+            color = MaterialTheme.colorScheme.primary,
+            colorName = "primary"
+        )
+    }
+}
+
+@Preview(
+    showBackground = true,
+    uiMode = UI_MODE_NIGHT_NO,
+    group = "ColorSpot",
+)
+@Composable
+private fun ColorSpot_Preview_Surface() {
+    ThreemaTheme {
+        ColorSpot(
+            color = MaterialTheme.colorScheme.surface,
+            colorName = "surface"
+        )
+    }
+}
+
+@Preview(
+    showBackground = true,
+    uiMode = UI_MODE_NIGHT_YES,
+    group = "ColorSpot"
+)
+@Composable
+private fun ColorSpot_Preview_Night() {
+    ThreemaTheme {
+        ColorSpot(
+            color = MaterialTheme.colorScheme.primary,
+            colorName = "primary"
+        )
+    }
+}
+
+@Preview(
+    showBackground = true,
+    uiMode = UI_MODE_NIGHT_YES,
+    group = "ColorSpot"
+)
+@Composable
+private fun ColorSpot_Preview_Night_Surface() {
+    ThreemaTheme {
+        ColorSpot(
+            color = MaterialTheme.colorScheme.surface,
+            colorName = "surface"
+        )
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java b/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java
index 9a901612..e5c65edb 100644
--- a/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java
+++ b/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java
@@ -57,7 +57,7 @@ public class CancelableHorizontalProgressDialog extends ThreemaDialogFragment {
 	 * @param title title of dialog
 	 * @param button label of cancel button
 	 * @param total maximum allowed progress value.
-	 * @return nothing
+	 * @return the dialog
 	 */
 	public static CancelableHorizontalProgressDialog newInstance(@StringRes int title, @StringRes int button, int total) {
 		CancelableHorizontalProgressDialog dialog = new CancelableHorizontalProgressDialog();
@@ -70,12 +70,31 @@ public class CancelableHorizontalProgressDialog extends ThreemaDialogFragment {
 		return dialog;
 	}
 
+	/**
+	 * Creates a DialogFragment with a horizontal progress bar and a percentage display below.
+	 * Mimics deprecated system ProgressDialog behavior.
+	 * Note that when using this constructor, no cancel button is shown.
+	 *
+	 * @param title title of dialog
+	 * @param total maximum allowed progress value.
+	 * @return the dialog
+	 */
+	public static CancelableHorizontalProgressDialog newInstance(@StringRes int title, int total) {
+		CancelableHorizontalProgressDialog dialog = new CancelableHorizontalProgressDialog();
+		Bundle args = new Bundle();
+		args.putInt("title", title);
+		args.putInt("total", total);
+
+		dialog.setArguments(args);
+		return dialog;
+	}
+
 	/**
 	 * Creates a DialogFragment with a horizontal progress bar and a percentage display below. Mimics deprecated system ProgressDialog behavior
 	 * @param title title of dialog
 	 * @param button label of cancel button
 	 * @param total maximum allowed progress value.
-	 * @return nothing
+	 * @return the dialog
 	 */
 	public static CancelableHorizontalProgressDialog newInstance(@NonNull String title, @NonNull String button, int total) {
 		CancelableHorizontalProgressDialog dialog = new CancelableHorizontalProgressDialog();
diff --git a/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java b/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java
index 6aa21290..d0b90c8a 100644
--- a/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java
@@ -762,17 +762,17 @@ public class ComposeMessageFragment extends Fragment implements
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			updateToolBarTitleInUIThread();
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String identity) {
 			updateToolBarTitleInUIThread();
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String identity) {
 			updateToolBarTitleInUIThread();
 
 			if (userService.isMe(identity)) {
@@ -821,7 +821,7 @@ public class ComposeMessageFragment extends Fragment implements
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
 			updateToolBarTitleInUIThread();
 		}
 
@@ -3112,7 +3112,7 @@ public class ComposeMessageFragment extends Fragment implements
 								// If there is no rejected recipient, we can just update the message
 								// state as the rejected recipient is not longer a group member.
 								// Note that this should never happen.
-								messageService.updateMessageState(messageModel, MessageState.SENT, null);
+								messageService.updateOutgoingMessageState(messageModel, MessageState.SENT, new Date());
 								logger.warn("Resend for group members requested, although no member rejected it");
 								return;
 							}
@@ -4086,13 +4086,16 @@ public class ComposeMessageFragment extends Fragment implements
 			setAvatarContentDescription(R.string.distribution_list);
 		} else {
 			if (contactModel != null) {
-				this.actionBarSubtitleImageView.setContactModel(contactModel);
+				this.actionBarSubtitleImageView.setVerificationLevel(
+					contactModel.verificationLevel,
+					contactModel.getWorkVerificationLevel()
+				);
 				this.actionBarSubtitleImageView.setVisibility(View.VISIBLE);
 				if (actionBarAvatarView.getAvatarView().isAttachedToWindow()) {
 					contactService.loadAvatarIntoImage(
 						contactModel,
 						this.actionBarAvatarView.getAvatarView(),
-						AvatarOptions.PRESET_RESPECT_SETTINGS,
+						AvatarOptions.PRESET_DEFAULT_FALLBACK,
 						Glide.with(requireActivity())
 					);
 				}
@@ -5594,7 +5597,7 @@ public class ComposeMessageFragment extends Fragment implements
 	@Override
 	public void onReportSpamClicked(@NonNull final ContactModel spammerContactModel, boolean block) {
 		contactService.reportSpam(
-			spammerContactModel,
+			spammerContactModel.getIdentity(),
 			unused -> {
 				if (isAdded()) {
 					LongToast.makeText(getContext(), R.string.spam_successfully_reported, Toast.LENGTH_LONG).show();
diff --git a/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java b/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java
index 8c9f39c7..fd0cd71d 100644
--- a/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java
@@ -24,7 +24,8 @@ package ch.threema.app.fragments;
 import static android.view.MenuItem.SHOW_AS_ACTION_ALWAYS;
 import static android.view.MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW;
 import static android.view.MenuItem.SHOW_AS_ACTION_NEVER;
-import static ch.threema.app.ThreemaApplication.WORKER_WORK_SYNC;
+import static ch.threema.app.asynctasks.ContactSyncPolicy.EXCLUDE;
+import static ch.threema.app.asynctasks.ContactSyncPolicy.INCLUDE;
 
 import android.Manifest;
 import android.annotation.SuppressLint;
@@ -61,9 +62,6 @@ import androidx.core.util.Pair;
 import androidx.core.view.MenuItemCompat;
 import androidx.localbroadcastmanager.content.LocalBroadcastManager;
 import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;
-import androidx.work.ExistingWorkPolicy;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.WorkManager;
 
 import com.bumptech.glide.Glide;
 import com.google.android.material.button.MaterialButton;
@@ -72,12 +70,13 @@ import com.google.android.material.tabs.TabLayout;
 
 import org.slf4j.Logger;
 
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
@@ -86,7 +85,10 @@ import ch.threema.app.activities.ComposeMessageActivity;
 import ch.threema.app.activities.ContactDetailActivity;
 import ch.threema.app.activities.ThreemaActivity;
 import ch.threema.app.adapters.ContactListAdapter;
-import ch.threema.app.asynctasks.DeleteContactAsyncTask;
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy;
+import ch.threema.app.asynctasks.ContactSyncPolicy;
+import ch.threema.app.asynctasks.DeleteContactServices;
+import ch.threema.app.asynctasks.DialogMarkContactAsDeletedBackgroundTask;
 import ch.threema.app.asynctasks.EmptyOrDeleteConversationsAsyncTask;
 import ch.threema.app.dialogs.BottomSheetAbstractDialog;
 import ch.threema.app.dialogs.BottomSheetGridDialog;
@@ -107,7 +109,6 @@ import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.routines.SynchronizeContactsRoutine;
 import ch.threema.app.services.AvatarCacheService;
 import ch.threema.app.services.ContactService;
-import ch.threema.app.services.IdListService;
 import ch.threema.app.services.LockAppService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SynchronizeContactsService;
@@ -126,10 +127,12 @@ import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShareUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.workers.ContactUpdateWorker;
 import ch.threema.app.workers.WorkSyncWorker;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.models.ContactModel;
@@ -192,6 +195,8 @@ public class ContactsSectionFragment
 	private PreferenceService preferenceService;
 	private LockAppService lockAppService;
 
+	private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
+
 	private String filterQuery;
 	@SuppressLint("StaticFieldLeak")
 	private final TabLayout.OnTabSelectedListener onTabSelectedListener = new TabLayout.OnTabSelectedListener() {
@@ -258,11 +263,8 @@ public class ContactsSectionFragment
 		}
 	}
 
-	private final ResumePauseHandler.RunIfActive runIfActiveShowLoading = new ResumePauseHandler.RunIfActive() {
-		@Override
-		public void runOnUiThread() {
-			// do nothing
-		}
+	private final ResumePauseHandler.RunIfActive runIfActiveShowLoading = () -> {
+		// do nothing
 	};
 
 	private final ResumePauseHandler.RunIfActive runIfActiveClearCacheAndRefresh = new ResumePauseHandler.RunIfActive() {
@@ -275,10 +277,8 @@ public class ContactsSectionFragment
 				if (serviceManager != null) {
 					try {
 						AvatarCacheService avatarCacheService = serviceManager.getAvatarCacheService();
-						if (avatarCacheService != null) {
-							//clear the cache
-							avatarCacheService.clear();
-						}
+						//clear the cache
+						avatarCacheService.clear();
 					} catch (FileSystemNotPresentException e) {
 						logger.error("Exception", e);
 					}
@@ -306,12 +306,7 @@ public class ContactsSectionFragment
 		}
 	};
 
-	private final ResumePauseHandler.RunIfActive runIfActiveCreateList = new ResumePauseHandler.RunIfActive() {
-		@Override
-		public void runOnUiThread() {
-			createListAdapter(null);
-		}
-	};
+	private final ResumePauseHandler.RunIfActive runIfActiveCreateList = () -> createListAdapter(null);
 
 	private final SynchronizeContactsListener synchronizeContactsListener = new SynchronizeContactsListener() {
 		@Override
@@ -381,8 +376,8 @@ public class ContactsSectionFragment
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			this.onModified(contactModel.getIdentity());
+		public void onAvatarChanged(final @NonNull String identity) {
+			this.onModified(identity);
 		}
 
 		@Override
@@ -513,9 +508,7 @@ public class ContactsSectionFragment
 
 		this.resumePauseHandler = ResumePauseHandler.getByActivity(this, this.getActivity());
 
-		if (this.resumePauseHandler != null) {
-			this.resumePauseHandler.runOnActive(RUN_ON_ACTIVE_REFRESH_PULL_TO_REFRESH, runIfActiveUpdatePullToRefresh);
-		}
+		this.resumePauseHandler.runOnActive(RUN_ON_ACTIVE_REFRESH_PULL_TO_REFRESH, runIfActiveUpdatePullToRefresh);
 	}
 
 	@Override
@@ -573,7 +566,7 @@ public class ContactsSectionFragment
 	}
 
 	@Override
-	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+	public void onCreateOptionsMenu(Menu menu, @NonNull MenuInflater inflater) {
 		logger.debug("onCreateOptionsMenu");
 		searchMenuItem = menu.findItem(R.id.menu_search_contacts);
 
@@ -588,12 +581,9 @@ public class ContactsSectionFragment
 					if (!TestUtil.isEmptyOrNull(filterQuery)) {
 						// restore filter
 						MenuItemCompat.expandActionView(searchMenuItem);
-						this.searchView.post(new Runnable() {
-							@Override
-							public void run() {
-								searchView.setQuery(filterQuery, true);
-								searchView.clearFocus();
-							}
+						this.searchView.post(() -> {
+							searchView.setQuery(filterQuery, true);
+							searchView.clearFocus();
 						});
 					}
 					this.searchView.setQueryHint(getString(R.string.hint_filter_list));
@@ -607,7 +597,7 @@ public class ContactsSectionFragment
 	final SearchView.OnQueryTextListener queryTextListener = new SearchView.OnQueryTextListener() {
 		@Override
 		public boolean onQueryTextChange(String query) {
-			if (contactListAdapter != null && contactListAdapter.getFilter() != null) {
+			if (contactListAdapter != null) {
 				filterQuery = query;
 				contactListAdapter.getFilter().filter(query);
 			}
@@ -812,7 +802,7 @@ public class ContactsSectionFragment
 	}
 
 	@Override
-	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 		View headerView, fragmentView = getView();
 
 		logger.debug("onCreateView");
@@ -893,12 +883,7 @@ public class ContactsSectionFragment
 				this.contactsCounterButton = footerView.findViewById(R.id.contact_counter_text);
 				listView.addFooterView(footerView, null, false);
 
-				headerView.findViewById(R.id.share_container).setOnClickListener(new View.OnClickListener() {
-					@Override
-					public void onClick(View v) {
-						shareInvite();
-					}
-				});
+				headerView.findViewById(R.id.share_container).setOnClickListener(v -> shareInvite());
 			} else {
 				workTabLayout = fragmentView.findViewById(R.id.work_contacts_tab_layout);
 				workTabLayout.addOnTabSelectedListener(onTabSelectedListener);
@@ -912,12 +897,7 @@ public class ContactsSectionFragment
 			this.swipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);
 
 			this.floatingButtonView = fragmentView.findViewById(R.id.floating);
-			this.floatingButtonView.setOnClickListener(new View.OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					onFABClicked(v);
-				}
-			});
+			this.floatingButtonView.setOnClickListener(this::onFABClicked);
 		}
 		return fragmentView;
 	}
@@ -1064,6 +1044,10 @@ public class ContactsSectionFragment
 
 		new Handler(Looper.getMainLooper()).postDelayed(this::stopSwipeRefresh, 2000);
 
+		try {
+			ContactUpdateWorker.performOneTimeSync(requireContext());
+		} catch (IllegalStateException ignored) {}
+
 		if (this.preferenceService.isSyncContacts() && ConfigUtils.requestContactPermissions(getActivity(), this, PERMISSION_REQUEST_REFRESH_CONTACTS)) {
 			if (this.synchronizeContactsService != null) {
 				// we force a contact sync even if the grace time has not yet been reached
@@ -1074,16 +1058,16 @@ public class ContactsSectionFragment
 
 		if (ConfigUtils.isWorkBuild()) {
 			try {
-				OneTimeWorkRequest workRequest = WorkSyncWorker.Companion.buildOneTimeWorkRequest(false, true, "WorkContactSync");
-				WorkManager.getInstance(ThreemaApplication.getAppContext()).enqueueUniqueWork(WORKER_WORK_SYNC, ExistingWorkPolicy.REPLACE, workRequest);
+				WorkSyncWorker.Companion.performOneTimeWorkSync(
+					ThreemaApplication.getAppContext(),
+					false,
+					true,
+					"WorkContactSync"
+				);
 			} catch (IllegalStateException e) {
 				logger.error("Unable to schedule work sync one time work", e);
 			}
 		}
-		try {
-			OneTimeWorkRequest contactUpdateRequest = new OneTimeWorkRequest.Builder(ContactUpdateWorker.class).build();
-			WorkManager.getInstance(requireContext()).enqueue(contactUpdateRequest);
-		} catch (IllegalStateException ignored) {}
 	}
 
 	private void openConversationForIdentity(@Nullable View v, String identity) {
@@ -1189,7 +1173,7 @@ public class ContactsSectionFragment
 					contactModel.verificationLevel == VerificationLevel.UNVERIFIED
 				) {
 					MessageReceiver messageReceiver = contactService.createReceiver(contactModel);
-					if (messageReceiver != null && messageReceiver.getMessagesCount() > 0) {
+					if (messageReceiver.getMessagesCount() > 0) {
 						items.add(new SelectorDialogItem(getString(R.string.spam_report), R.drawable.ic_outline_report_24));
 						tags.add(SELECTOR_TAG_REPORT_SPAM);
 					}
@@ -1285,43 +1269,57 @@ public class ContactsSectionFragment
 		dialog.show(getFragmentManager(), DIALOG_TAG_REALLY_DELETE_CONTACTS);
 	}
 
-	@SuppressLint("StaticFieldLeak")
-	private void reallyDeleteContacts(@NonNull Set<ContactModel> contactModels, boolean excludeFromSync) {
-		new DeleteContactAsyncTask(getParentFragmentManager(), contactModels, contactService, new DeleteContactAsyncTask.DeleteContactsPostRunnable() {
-			@Override
-			public void run() {
-				if (isAdded()) {
-					if (failed > 0) {
-						Toast.makeText(getActivity(), ConfigUtils.getSafeQuantityString(ThreemaApplication.getAppContext(), R.plurals.some_contacts_not_deleted, failed, failed), Toast.LENGTH_LONG).show();
-					} else {
-						if (contactModels.size() > 1) {
-							Toast.makeText(getActivity(), R.string.contacts_deleted, Toast.LENGTH_LONG).show();
-						} else {
-							Toast.makeText(getActivity(), R.string.contact_deleted, Toast.LENGTH_LONG).show();
-						}
+	private void reallyDeleteContacts(@NonNull Set<ContactModel> contactModels, boolean excludeFromSync) throws ThreemaException {
+		Set<String> identities = contactModels.stream()
+			.map(Contact::getIdentity)
+			.collect(Collectors.toSet());
 
-						if (excludeFromSync) {
-							excludeContactsFromSync(contactModels);
-						}
-					}
-				}
+		ContactSyncPolicy syncPolicy = excludeFromSync ? EXCLUDE : INCLUDE;
 
-				if (actionMode != null) {
-					actionMode.finish();
-				}
-			}
-		}).execute();
+		DialogMarkContactAsDeletedBackgroundTask task = getDialogDeleteContactBackgroundTask(
+			identities, syncPolicy
+		);
+
+		backgroundExecutor.execute(task);
 	}
 
-	private void excludeContactsFromSync(@NonNull Collection<ContactModel> contactModels) {
-		IdListService excludedService = serviceManager.getExcludedSyncIdentitiesService();
-		if (excludedService != null) {
-			for (ContactModel contactModel : contactModels) {
-				if (contactModel.isLinkedToAndroidContact()) {
-					excludedService.add(contactModel.getIdentity());
+	@NonNull
+	private DialogMarkContactAsDeletedBackgroundTask getDialogDeleteContactBackgroundTask(
+		@NonNull Set<String> identities,
+		@NonNull ContactSyncPolicy syncPolicy
+	) throws ThreemaException {
+		DeleteContactServices deleteServices = new DeleteContactServices(
+			serviceManager.getUserService(),
+			contactService,
+			serviceManager.getConversationService(),
+			serviceManager.getRingtoneService(),
+			serviceManager.getMutedChatsListService(),
+			serviceManager.getHiddenChatsListService(),
+			serviceManager.getProfilePicRecipientsService(),
+			serviceManager.getWallpaperService(),
+			serviceManager.getFileService(),
+			serviceManager.getExcludedSyncIdentitiesService(),
+			serviceManager.getDHSessionStore(),
+			serviceManager.getNotificationService(),
+			serviceManager.getDatabaseServiceNew()
+		);
+
+		return new DialogMarkContactAsDeletedBackgroundTask(
+			getParentFragmentManager(),
+			new WeakReference<>(getContext()),
+			identities,
+			serviceManager.getModelRepositories().getContacts(),
+			deleteServices,
+			syncPolicy,
+			AndroidContactLinkPolicy.REMOVE_LINK
+		) {
+			@Override
+			protected void onFinished() {
+				if (actionMode != null) {
+					actionMode.finish();
 				}
 			}
-		}
+		};
 	}
 
 	@Override
@@ -1448,12 +1446,16 @@ public class ContactsSectionFragment
 	public void onYes(String tag, Object data, boolean checked) {
 		switch(tag) {
 			case DIALOG_TAG_REALLY_DELETE_CONTACTS:
-				reallyDeleteContacts((Set<ContactModel>) data, checked);
+				try {
+					reallyDeleteContacts((Set<ContactModel>) data, checked);
+				} catch (ThreemaException e) {
+					logger.error("Could not delete contacts", e);
+				}
 				break;
 			case DIALOG_TAG_REPORT_SPAM:
 				ContactModel contactModel = (ContactModel) data;
 
-				contactService.reportSpam(contactModel,
+				contactService.reportSpam(contactModel.getIdentity(),
 					unused -> {
 						if (isAdded()) {
 							Toast.makeText(getContext(), R.string.spam_successfully_reported, Toast.LENGTH_LONG).show();
@@ -1503,7 +1505,11 @@ public class ContactsSectionFragment
 	public void onYes(String tag, Object data) {
 		switch(tag) {
 			case DIALOG_TAG_REALLY_DELETE_CONTACTS:
-				reallyDeleteContacts((Set<ContactModel>) data, false);
+				try {
+					reallyDeleteContacts((Set<ContactModel>) data, false);
+				} catch (ThreemaException e) {
+					logger.error("Could not delete contacts", e);
+				}
 				break;
 			default:
 				break;
diff --git a/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java b/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java
index 00a92329..10fccbd8 100644
--- a/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java
@@ -149,7 +149,6 @@ import ch.threema.app.voip.groupcall.GroupCallManager;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.ConversationModel;
 import ch.threema.storage.models.DistributionListModel;
 import ch.threema.storage.models.GroupModel;
@@ -221,6 +220,7 @@ public class MessageSectionFragment extends MainFragment
 
 	private Activity activity;
 	private File tempMessagesFile;
+    @Nullable
 	private MessageListAdapter messageListAdapter;
 	private EmptyRecyclerView recyclerView;
 	private View loadingView;
@@ -333,7 +333,7 @@ public class MessageSectionFragment extends MainFragment
 
 	private final GroupListener groupListener = new GroupListener() {
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			// If this user is added to an existing group
 			if (groupService != null && myIdentity != null && myIdentity.equals(newIdentity)) {
 				fireReceiverUpdate(groupService.createReceiver(group));
@@ -390,7 +390,7 @@ public class MessageSectionFragment extends MainFragment
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
 			this.handleChange();
 		}
 
@@ -599,8 +599,10 @@ public class MessageSectionFragment extends MainFragment
 		@Override
 		public boolean onQueryTextChange(String query) {
 			filterQuery = query;
-			messageListAdapter.setFilterQuery(query);
-			updateList(0, null, null);
+            if (messageListAdapter != null) {
+                messageListAdapter.setFilterQuery(query);
+                updateList(0, null, null);
+            }
 			return true;
 		}
 
@@ -691,14 +693,16 @@ public class MessageSectionFragment extends MainFragment
 	private void doUnhideChat(@NonNull ConversationModel conversationModel) {
 		MessageReceiver<?> receiver = conversationModel.getReceiver();
 		if (receiver != null && hiddenChatsListService.has(receiver.getUniqueIdString())) {
-			hiddenChatsListService.remove(receiver.getUniqueIdString());
+            hiddenChatsListService.remove(receiver.getUniqueIdString());
 
-			if (getView() != null) {
-				Snackbar.make(getView(), R.string.chat_visible, Snackbar.LENGTH_SHORT).show();
-			}
+            if (getView() != null) {
+                Snackbar.make(getView(), R.string.chat_visible, Snackbar.LENGTH_SHORT).show();
+            }
 
-			this.fireReceiverUpdate(receiver);
-			messageListAdapter.clearSelections();
+            this.fireReceiverUpdate(receiver);
+            if (messageListAdapter != null) {
+                messageListAdapter.clearSelections();
+            }
 		}
 	}
 
@@ -759,6 +763,9 @@ public class MessageSectionFragment extends MainFragment
 			@Override
 			protected void onPostExecute(Boolean success) {
 				if (success) {
+                    if (messageListAdapter == null) {
+                        return;
+                    }
 					messageListAdapter.clearSelections();
 					if (getView() != null) {
 						Snackbar.make(getView(), R.string.chat_hidden, Snackbar.LENGTH_SHORT).show();
@@ -894,6 +901,10 @@ public class MessageSectionFragment extends MainFragment
 
 				@Override
 				public void onSwiped(@NonNull RecyclerView.ViewHolder viewHolder, int direction) {
+                    if (messageListAdapter == null) {
+                        return;
+                    }
+
 					// swipe has ended successfully
 
 					// required to clear swipe layout
@@ -1153,7 +1164,7 @@ public class MessageSectionFragment extends MainFragment
 
 	@Override
 	public boolean onItemLongClick(View view, int position, ConversationModel conversationModel) {
-		if (!isMultiPaneEnabled(activity)) {
+		if (!isMultiPaneEnabled(activity) && messageListAdapter != null) {
 			messageListAdapter.toggleItemChecked(conversationModel, position);
 			showSelector();
 			return true;
@@ -1220,7 +1231,9 @@ public class MessageSectionFragment extends MainFragment
 		}
 		updateHiddenMenuVisibility();
 
-		messageListAdapter.updateDateView();
+        if (messageListAdapter != null) {
+            messageListAdapter.updateDateView();
+        }
 
 		super.onResume();
 	}
@@ -1245,7 +1258,7 @@ public class MessageSectionFragment extends MainFragment
 		ArrayList<SelectorDialogItem> labels = new ArrayList<>();
 		ArrayList<Integer> tags = new ArrayList<>();
 
-		if (messageListAdapter.getCheckedItemCount() != 1) {
+		if (messageListAdapter == null || messageListAdapter.getCheckedItemCount() != 1) {
 			return;
 		}
 
@@ -1311,7 +1324,7 @@ public class MessageSectionFragment extends MainFragment
 			}
 			boolean isCreator = groupService.isGroupCreator(group);
 			boolean isMember = groupService.isGroupMember(group);
-			boolean hasOtherMembers = groupService.getOtherMemberCount(group) > 0;
+			boolean hasOtherMembers = groupService.countMembersWithoutUser(group) > 0;
 			// Check also if the user is a group member, because orphaned groups should not be
 			// editable.
 			if (isCreator && isMember) {
@@ -1350,7 +1363,9 @@ public class MessageSectionFragment extends MainFragment
 	public void onClick(String tag, int which, Object data) {
 		GenericAlertDialog dialog;
 
-		messageListAdapter.clearSelections();
+        if (messageListAdapter != null) {
+            messageListAdapter.clearSelections();
+        }
 
 		final ConversationModel conversationModel = (ConversationModel) data;
 
@@ -1468,12 +1483,14 @@ public class MessageSectionFragment extends MainFragment
 
 	@Override
 	public void onCancel(String tag) {
+        if (messageListAdapter != null) {
 		messageListAdapter.clearSelections();
+        }
 	}
 
 	@Override
 	public void onNo(String tag) {
-		if (DIALOG_TAG_SELECT_DELETE_ACTION.equals(tag)) {
+		if (messageListAdapter != null && DIALOG_TAG_SELECT_DELETE_ACTION.equals(tag)) {
 			messageListAdapter.clearSelections();
 		}
 	}
diff --git a/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java b/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java
index 0c47c8de..af20d9e7 100644
--- a/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java
@@ -51,6 +51,7 @@ import com.google.android.material.textfield.MaterialAutoCompleteTextView;
 
 import org.slf4j.Logger;
 
+import java.util.Arrays;
 import java.util.Date;
 
 import ch.threema.app.R;
@@ -73,11 +74,15 @@ import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.routines.CheckIdentityRoutine;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.ContactService.ProfilePictureSharePolicy;
 import ch.threema.app.services.FileService;
+import ch.threema.app.services.IdListService;
 import ch.threema.app.services.LocaleService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.QRCodeServiceImpl;
 import ch.threema.app.services.UserService;
+import ch.threema.app.tasks.ReflectUserProfileShareWithAllowListSyncTask;
+import ch.threema.app.tasks.ReflectUserProfileShareWithPolicySyncTask;
 import ch.threema.app.ui.AvatarEditView;
 import ch.threema.app.ui.QRCodePopup;
 import ch.threema.app.utils.AppRestrictionUtil;
@@ -93,6 +98,8 @@ import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.api.LinkMobileNoException;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
+import ch.threema.domain.taskmanager.TaskManager;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.localcrypto.MasterKeyLockedException;
 
 /**
@@ -117,6 +124,9 @@ public class MyIDFragment extends MainFragment
 	private LocaleService localeService;
 	private ContactService contactService;
 	private FileService fileService;
+    private IdListService profilePicRecipientsService;
+	private TaskManager taskManager;
+
 	private AvatarEditView avatarView;
 	private EmojiTextView nicknameTextView;
 	private boolean hidden = false;
@@ -237,7 +247,7 @@ public class MyIDFragment extends MainFragment
 
 			final MaterialButton picReleaseConfImageView = fragmentView.findViewById(R.id.picrelease_config);
 			picReleaseConfImageView.setOnClickListener(this);
-			picReleaseConfImageView.setVisibility(preferenceService.getProfilePicRelease() == PreferenceService.PROFILEPIC_RELEASE_SOME ? View.VISIBLE : View.GONE);
+			picReleaseConfImageView.setVisibility(preferenceService.getProfilePicRelease() == PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST ? View.VISIBLE : View.GONE);
 
 			configureEditWithButton(fragmentView.findViewById(R.id.linked_email_layout), fragmentView.findViewById(R.id.change_email), isReadonlyProfile);
 			configureEditWithButton(fragmentView.findViewById(R.id.linked_mobile_layout), fragmentView.findViewById(R.id.change_mobile), isReadonlyProfile);
@@ -300,21 +310,57 @@ public class MyIDFragment extends MainFragment
 		if (fragmentView != null && preferenceService != null) {
 			MaterialAutoCompleteTextView spinner = fragmentView.findViewById(R.id.picrelease_spinner);
 			if (spinner != null) {
-				ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(getContext(), R.array.picrelease_choices, android.R.layout.simple_spinner_dropdown_item);
+				ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(
+                    requireContext(),
+                    R.array.picrelease_choices,
+                    android.R.layout.simple_spinner_dropdown_item
+                );
 				spinner.setAdapter(adapter);
 				spinner.setText(adapter.getItem(preferenceService.getProfilePicRelease()), false);
-				spinner.setOnItemClickListener((parent, view, position, id) -> {
-					int oldPosition = preferenceService.getProfilePicRelease();
-					preferenceService.setProfilePicRelease(position);
-					fragmentView.findViewById(R.id.picrelease_config).setVisibility(position == PreferenceService.PROFILEPIC_RELEASE_SOME ? View.VISIBLE : View.GONE);
-					if (position == PreferenceService.PROFILEPIC_RELEASE_SOME && position != oldPosition) {
-						launchProfilePictureRecipientsSelector(view);
-					}
-				});
+				spinner.setOnItemClickListener((parent, view, position, id) -> onPicReleaseSpinnerItemClicked(view, position));
 			}
 		}
 	}
 
+    private void onPicReleaseSpinnerItemClicked(View view, int position){
+
+        final @Nullable ProfilePictureSharePolicy.Policy sharePolicy = ProfilePictureSharePolicy.Policy.fromIntOrNull(position);
+        if (sharePolicy == null) {
+            logger.error("Failed to get concrete enum value of type ProfilePictureSharePolicy.Policy for ordinal value {}", position);
+            return;
+        }
+
+        final int oldPosition = preferenceService.getProfilePicRelease();
+        preferenceService.setProfilePicRelease(position);
+
+        fragmentView.findViewById(R.id.picrelease_config)
+            .setVisibility(position == PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST ? View.VISIBLE : View.GONE);
+
+        // Only continue of the value actually changes from before
+        if (position == oldPosition) {
+            return;
+        }
+
+        if (sharePolicy == ProfilePictureSharePolicy.Policy.ALLOW_LIST) {
+            launchProfilePictureRecipientsSelector(view);
+            // sync new policy setting with currently set allow list values into device group (if md is active)
+            taskManager.schedule(
+                new ReflectUserProfileShareWithAllowListSyncTask(
+                    Arrays.asList(profilePicRecipientsService.getAll()),
+                    this.serviceManager
+                )
+            );
+        } else {
+            // sync new policy setting to device group (if md is active)
+            taskManager.schedule(
+                new ReflectUserProfileShareWithPolicySyncTask(
+                    sharePolicy,
+                    this.serviceManager
+                )
+            );
+        }
+    }
+
 	@Override
 	public void onStart() {
 		super.onStart();
@@ -737,7 +783,7 @@ public class MyIDFragment extends MainFragment
 				// Update public nickname
 				String newNickname = text.trim();
 				if (!newNickname.equals(userService.getPublicNickname())) {
-					userService.setPublicNickname(newNickname);
+					userService.setPublicNickname(newNickname, TriggerSource.LOCAL);
 				}
 				reloadNickname();
 				break;
@@ -805,6 +851,8 @@ public class MyIDFragment extends MainFragment
 				this.fileService = this.serviceManager.getFileService();
 				this.preferenceService = this.serviceManager.getPreferenceService();
 				this.localeService = this.serviceManager.getLocaleService();
+				this.taskManager = this.serviceManager.getTaskManager();
+				this.profilePicRecipientsService = this.serviceManager.getProfilePicRecipientsService();
 			} catch (MasterKeyLockedException e) {
 				logger.debug("Master Key locked!");
 			} catch (ThreemaException e) {
diff --git a/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java b/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java
index 7a2f012c..f71ade1f 100644
--- a/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java
@@ -37,6 +37,7 @@ import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.storage.models.ContactModel;
 
@@ -61,21 +62,21 @@ public class UserMemberListFragment extends MemberListFragment {
 				List<ContactModel> contactModels;
 
 				if (groups) {
-					final ContactModel.State[] contactStates;
+					final IdentityState[] contactStates;
 					if (preferenceService.showInactiveContacts()) {
-						contactStates = new ContactModel.State[]{
-							ContactModel.State.ACTIVE,
-							ContactModel.State.INACTIVE
+						contactStates = new IdentityState[]{
+							IdentityState.ACTIVE,
+							IdentityState.INACTIVE
 						};
 					} else {
-						contactStates = new ContactModel.State[]{
-							ContactModel.State.ACTIVE
+						contactStates = new IdentityState[]{
+							IdentityState.ACTIVE
 						};
 					}
 
 					contactModels = contactService.find(new ContactService.Filter() {
 						@Override
-						public ContactModel.State[] states() {
+						public IdentityState[] states() {
 							return contactStates;
 						}
 
diff --git a/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java b/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java
index e134fd6b..05af4b85 100644
--- a/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java
@@ -48,6 +48,7 @@ import ch.threema.app.collections.IPredicateNonNull;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.storage.models.ContactModel;
 
 public class WorkUserListFragment extends RecipientListFragment {
@@ -115,21 +116,21 @@ public class WorkUserListFragment extends RecipientListFragment {
 		new AsyncTask<Void, Void, List<ContactModel>>() {
 			@Override
 			protected List<ContactModel> doInBackground(Void... voids) {
-				final ContactModel.State[] contactStates;
+				final IdentityState[] contactStates;
 				if (preferenceService.showInactiveContacts()) {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE,
-						ContactModel.State.INACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE,
+						IdentityState.INACTIVE
 					};
 				} else {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE
 					};
 				}
 
 				return Functional.filter(contactService.find(new ContactService.Filter() {
 					@Override
-					public ContactModel.State[] states() {
+					public IdentityState[] states() {
 						return contactStates;
 					}
 
diff --git a/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java b/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java
index 2a35e0ce..4284f2ab 100644
--- a/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java
@@ -39,6 +39,7 @@ import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.ContactUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.storage.models.ContactModel;
 
@@ -60,21 +61,21 @@ public class WorkUserMemberListFragment extends MemberListFragment {
 		new AsyncTask<Void, Void, List<ContactModel>>() {
 			@Override
 			protected List<ContactModel> doInBackground(Void... voids) {
-				final ContactModel.State[] contactStates;
+				final IdentityState[] contactStates;
 				if (preferenceService.showInactiveContacts()) {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE,
-						ContactModel.State.INACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE,
+						IdentityState.INACTIVE
 					};
 				} else {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE
 					};
 				}
 
 				List<ContactModel> contactModels = Functional.filter(contactService.find(new ContactService.Filter() {
 					@Override
-					public ContactModel.State[] states() {
+					public IdentityState[] states() {
 						return contactStates;
 					}
 
diff --git a/app/src/main/java/ch/threema/app/glide/AvatarOptions.java b/app/src/main/java/ch/threema/app/glide/AvatarOptions.java
index 1a930459..5b15fc55 100644
--- a/app/src/main/java/ch/threema/app/glide/AvatarOptions.java
+++ b/app/src/main/java/ch/threema/app/glide/AvatarOptions.java
@@ -34,38 +34,29 @@ public class AvatarOptions {
 	 */
 	public enum DefaultAvatarPolicy {
 		/**
-		 * Try to load the custom avatar. If no custom avatar available, then return the default avatar instead of null.
+		 * Try to load the custom avatar. If no custom avatar available, then return the default
+         * avatar instead of null.
 		 */
 		DEFAULT_FALLBACK,
 		/**
-		 * Load the custom avatar. If no custom avatar is set, then return null.
+		 * Load the custom avatar. If no custom avatar is set, then return null. Note that a custom
+         * avatar can either be a contact or user defined profile picture.
 		 */
 		CUSTOM_AVATAR,
 		/**
 		 * Load the default avatar even if a custom avatar would be available.
 		 */
 		DEFAULT_AVATAR,
-		/**
-		 * Load the custom avatar if not prevented by settings. Otherwise returns the default avatar.
-		 */
-		RESPECT_SETTINGS
 	}
 
 	/**
-	 * Load the avatar in low resolution. If no avatar is found, load the default avatar.
+	 * Load the avatar in low resolution. If no avatar is found, load the default avatar. This
+     * respects the setting where the user defined profile picture should not be shown.
 	 */
 	public static final AvatarOptions PRESET_DEFAULT_FALLBACK = new Builder()
 		.setReturnPolicy(DefaultAvatarPolicy.DEFAULT_FALLBACK)
 		.toOptions();
 
-	/**
-	 * Load the avatar in low resolution. If no avatar is found, or custom avatars are disabled in settings,
-	 * load the default avatar.
-	 */
-	public static final AvatarOptions PRESET_RESPECT_SETTINGS = new Builder()
-		.setReturnPolicy(DefaultAvatarPolicy.RESPECT_SETTINGS)
-		.toOptions();
-
 	/**
 	 * Load the avatar with default fallback and do not cache it.
 	 */
@@ -146,7 +137,7 @@ public class AvatarOptions {
 	 */
 	public static class Builder {
 		private boolean highRes = false;
-		private @NonNull DefaultAvatarPolicy defaultAvatarPolicy = DefaultAvatarPolicy.RESPECT_SETTINGS;
+		private @NonNull DefaultAvatarPolicy defaultAvatarPolicy = DefaultAvatarPolicy.DEFAULT_AVATAR;
 		private boolean disableCache = false;
 		private boolean darkerBackground = false;
 
diff --git a/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt b/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt
index 090ac23b..a75cc455 100644
--- a/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt
+++ b/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt
@@ -60,7 +60,7 @@ class ContactAvatarFetcher(
         val returnDefaultIfNone: Boolean
         when (contactAvatarConfig.options.defaultAvatarPolicy) {
             AvatarOptions.DefaultAvatarPolicy.DEFAULT_FALLBACK -> {
-                profilePicReceive = true
+                profilePicReceive = preferenceService?.profilePicReceive == true
                 defaultAvatar = false
                 returnDefaultIfNone = true
             }
@@ -74,11 +74,6 @@ class ContactAvatarFetcher(
                 defaultAvatar = true
                 returnDefaultIfNone = true
             }
-            AvatarOptions.DefaultAvatarPolicy.RESPECT_SETTINGS -> {
-                profilePicReceive = preferenceService?.profilePicReceive == true
-                defaultAvatar = false
-                returnDefaultIfNone = true
-            }
         }
         val backgroundColor = getBackgroundColor(contactAvatarConfig.options)
 
@@ -96,29 +91,29 @@ class ContactAvatarFetcher(
             return buildDefaultAvatar(null, highRes, backgroundColor)
         }
 
-        // try profile picture
+        // Try the contact defined profile picture
         if (profilePicReceive) {
-            getProfilePicture(contactModel, highRes)?.let {
+            getContactDefinedProfilePicture(contactModel, highRes)?.let {
                 return it
             }
         }
 
-        // try local saved avatar
-        getLocallySavedAvatar(contactModel, highRes)?.let {
+        // Try the user defined profile picture
+        getUserDefinedProfilePicture(contactModel, highRes)?.let {
             return it
         }
 
-        // try android contact picture
-        getAndroidContactAvatar(contactModel, highRes)?.let {
+        // Try the android defined profile picture
+        getAndroidDefinedProfilePicture(contactModel, highRes)?.let {
             return it
         }
 
         return if (returnDefaultIfNone) buildDefaultAvatar(contactModel, highRes, backgroundColor) else null
     }
 
-    private fun getProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
+    private fun getContactDefinedProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
         try {
-            val result = fileService?.getContactPhoto(contactModel.identity)
+            val result = fileService?.getContactDefinedProfilePicture(contactModel.identity)
             if (result != null && !highRes) {
                 return AvatarConverterUtil.convert(this.context.resources, result)
             }
@@ -128,9 +123,9 @@ class ContactAvatarFetcher(
         }
     }
 
-    private fun getLocallySavedAvatar(contactModel: ContactModel, highRes: Boolean): Bitmap? {
+    private fun getUserDefinedProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
         return try {
-            var result = fileService?.getContactAvatar(contactModel.identity)
+            var result = fileService?.getUserDefinedProfilePicture(contactModel.identity)
             if (result != null && !highRes) {
                 result = AvatarConverterUtil.convert(this.context.resources, result)
             }
@@ -140,13 +135,13 @@ class ContactAvatarFetcher(
         }
     }
 
-    private fun getAndroidContactAvatar(contactModel: ContactModel, highRes: Boolean): Bitmap? {
+    private fun getAndroidDefinedProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
         if (ContactUtil.isGatewayContact(contactModel) || AndroidContactUtil.getInstance().getAndroidContactUri(contactModel) == null) {
             return null
         }
         // regular contacts
         return try {
-            var result = fileService?.getAndroidContactAvatar(contactModel)
+            var result = fileService?.getAndroidDefinedProfilePicture(contactModel)
             if (result != null && !highRes) {
                 result = AvatarConverterUtil.convert(this.context.resources, result)
             }
diff --git a/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt b/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt
index 5083405e..d1032283 100644
--- a/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt
+++ b/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt
@@ -64,10 +64,6 @@ class GroupAvatarFetcher(
                 defaultAvatar = true
                 defaultAvatarIfNone = true
             }
-            AvatarOptions.DefaultAvatarPolicy.RESPECT_SETTINGS -> {
-                defaultAvatar = preferenceService?.profilePicReceive == false
-                defaultAvatarIfNone = true
-            }
         }
         val backgroundColor = getBackgroundColor(config.options)
 
diff --git a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt
index 990692ee..d434c30b 100644
--- a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt
+++ b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt
@@ -53,6 +53,7 @@ import ch.threema.app.ui.EmptyRecyclerView
 import ch.threema.app.ui.EmptyView
 import ch.threema.app.ui.ThreemaSearchView
 import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.ContactUtil
 import ch.threema.app.utils.IntentDataUtil
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.storage.models.AbstractMessageModel
@@ -196,7 +197,7 @@ class GlobalSearchActivity : ThreemaToolbarActivity(), SearchView.OnQueryTextLis
                     val deadlineListIdentifier: String = if (messageModel is GroupMessageModel) {
                         groupService.getUniqueIdString(messageModel.groupId)
                     } else {
-                        contactService.getUniqueIdString(messageModel.identity)
+                        ContactUtil.getUniqueIdString(messageModel.identity)
                     }
                     hiddenChatsListService.has(deadlineListIdentifier)
                 }
diff --git a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java
index d498e059..d4a067a5 100644
--- a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java
+++ b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java
@@ -69,6 +69,7 @@ import ch.threema.app.ui.CheckableRelativeLayout;
 import ch.threema.app.ui.listitemholder.AvatarListItemHolder;
 import ch.threema.app.utils.ColorUtil;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.IconUtil;
 import ch.threema.app.utils.LocaleUtil;
 import ch.threema.app.utils.MimeUtil;
@@ -197,7 +198,7 @@ public class GlobalSearchAdapter extends RecyclerView.Adapter<RecyclerView.ViewH
 
             final @NonNull String uid = messageModel instanceof GroupMessageModel
                 ? groupService.getUniqueIdString(((GroupMessageModel) messageModel).getGroupId())
-                : contactService.getUniqueIdString(messageModel.getIdentity());
+                : ContactUtil.getUniqueIdString(messageModel.getIdentity());
             if (hiddenChatsListService.has(uid)) {
                 viewHolder.dateView.setText("");
                 viewHolder.thumbnailView.setVisibility(View.GONE);
diff --git a/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java b/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java
index d7dfb661..0c7ad23f 100644
--- a/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java
+++ b/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java
@@ -23,13 +23,18 @@ package ch.threema.app.grouplinks;
 
 import android.content.Intent;
 import android.net.Uri;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 
+import org.slf4j.Logger;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
 import androidx.annotation.NonNull;
 import androidx.appcompat.app.ActionBar;
 import androidx.appcompat.view.ActionMode;
@@ -38,17 +43,14 @@ import androidx.lifecycle.Observer;
 import androidx.lifecycle.ViewModelProvider;
 import androidx.recyclerview.widget.DefaultItemAnimator;
 import androidx.recyclerview.widget.LinearLayoutManager;
-
-import org.slf4j.Logger;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.ComposeMessageActivity;
 import ch.threema.app.activities.ThreemaToolbarActivity;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
 import ch.threema.app.dialogs.GenericAlertDialog;
 import ch.threema.app.dialogs.SelectorDialog;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
@@ -62,16 +64,21 @@ import ch.threema.app.ui.EmptyRecyclerView;
 import ch.threema.app.ui.EmptyView;
 import ch.threema.app.ui.SelectorDialogItem;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.LogUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.RuntimeUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.group.GroupInviteData;
 import ch.threema.domain.protocol.csp.messages.group.GroupInviteToken;
 import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.protobuf.url_payloads.GroupInvite;
 import ch.threema.storage.DatabaseServiceNew;
+import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
 import ch.threema.storage.models.group.GroupInviteModel;
 import ch.threema.storage.models.group.OutgoingGroupJoinRequestModel;
@@ -98,6 +105,11 @@ public class OutgoingGroupRequestActivity extends ThreemaToolbarActivity impleme
 	private GroupService groupService;
 	private ContactService contactService;
 	private DatabaseServiceNew databaseService;
+	private APIConnector apiConnector;
+	private ContactModelRepository contactModelRepository;
+
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
 	private OutgoingGroupRequestViewModel viewModel;
 	private GroupInviteData groupInvite;
@@ -169,6 +181,8 @@ public class OutgoingGroupRequestActivity extends ThreemaToolbarActivity impleme
 			this.userService = serviceManager.getUserService();
 			this.groupService = serviceManager.getGroupService();
 			this.databaseService = serviceManager.getDatabaseServiceNew();
+			this.apiConnector = serviceManager.getAPIConnector();
+			this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
 		} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
 			logger.error("Exception, services not available... finishing");
 			finish();
@@ -412,36 +426,32 @@ public class OutgoingGroupRequestActivity extends ThreemaToolbarActivity impleme
 			if (this.resendRequestReference == null) {
 				// first add contact and fetch public key to be able to send a request
 				if (contactService.getByIdentity(groupInvite.getAdminIdentity()) == null) {
-					new AsyncTask<Void, Void, Exception>() {
-						@Override
-						protected void onPreExecute() {
-							// no preparation steps needed
-						}
-
-						@Override
-						protected Exception doInBackground(Void... params) {
-							try {
-								contactService.createContactByIdentity(groupInvite.getAdminIdentity(), true);
-								return null;
-							} catch (Exception e) {
-								return e;
-							}
-						}
-
-						@Override
-						protected void onPostExecute(Exception exception) {
-							if (isDestroyed()) {
-								return;
-							}
-							try {
-								outgoingGroupJoinRequestService.send(
-									groupInvite,
-									message);
-							} catch (Exception e) {
-								LogUtil.error("Exception, sending request after adding contact failed" + e, OutgoingGroupRequestActivity.this);
+					backgroundExecutor.get().execute(
+						new BasicAddOrUpdateContactBackgroundTask(
+							groupInvite.getAdminIdentity(),
+							ContactModel.AcquaintanceLevel.DIRECT,
+							userService.getIdentity(),
+							apiConnector,
+							contactModelRepository,
+							AddContactRestrictionPolicy.CHECK,
+							this,
+							null
+						) {
+							@Override
+							public void onFinished(ContactResult result) {
+								if (result instanceof ContactAvailable) {
+									if (isDestroyed()) {
+										return;
+									}
+									try {
+										outgoingGroupJoinRequestService.send(groupInvite, message);
+									} catch (Exception e) {
+										logger.error("Sending request after adding contact failed", e);
+									}
+								}
 							}
 						}
-					}.execute();
+					);
 				} else {
 					outgoingGroupJoinRequestService.send(
 						groupInvite,
diff --git a/app/src/main/java/ch/threema/app/listeners/ContactListener.java b/app/src/main/java/ch/threema/app/listeners/ContactListener.java
index 5da9d2b4..40f30aac 100644
--- a/app/src/main/java/ch/threema/app/listeners/ContactListener.java
+++ b/app/src/main/java/ch/threema/app/listeners/ContactListener.java
@@ -39,7 +39,7 @@ public interface ContactListener {
 	/**
 	 * Called when the contact avatar was changed.
 	 */
-	@AnyThread default void onAvatarChanged(final ContactModel contactModel) { }
+	@AnyThread default void onAvatarChanged(final @NonNull String identity) { }
 
 	/**
 	 * The contact was removed.
diff --git a/app/src/main/java/ch/threema/app/listeners/GroupListener.java b/app/src/main/java/ch/threema/app/listeners/GroupListener.java
index f5c3a457..2a7dd764 100644
--- a/app/src/main/java/ch/threema/app/listeners/GroupListener.java
+++ b/app/src/main/java/ch/threema/app/listeners/GroupListener.java
@@ -31,9 +31,9 @@ public interface GroupListener {
 	@AnyThread default void onUpdatePhoto(GroupModel groupModel) { }
 	@AnyThread default void onRemove(GroupModel groupModel) { }
 
-	@AnyThread default void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) { }
-	@AnyThread default void onMemberLeave(GroupModel group, String identity, int previousMemberCount) { }
-	@AnyThread default void onMemberKicked(GroupModel group, String identity, int previousMemberCount) { }
+	@AnyThread default void onNewMember(GroupModel group, String newIdentity) { }
+	@AnyThread default void onMemberLeave(GroupModel group, String identity) { }
+	@AnyThread default void onMemberKicked(GroupModel group, String identity) { }
 
 	/**
 	 * Group was updated.
diff --git a/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java b/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java
index a07e3e1c..6e1f8df0 100644
--- a/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java
+++ b/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java
@@ -24,7 +24,7 @@ package ch.threema.app.listeners;
 import java.util.List;
 
 import androidx.annotation.AnyThread;
-import ch.threema.storage.models.ContactModel;
+import ch.threema.data.models.ContactModel;
 
 /**
  * Listen for new contacts added via sync.
diff --git a/app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt b/app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt
index 1a9fe5b0..ad13da73 100644
--- a/app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt
+++ b/app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt
@@ -21,11 +21,13 @@
 
 package ch.threema.app.managers
 
-import ch.threema.app.multidevice.MultiDeviceManagerImpl
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.stores.IdentityStore
 import ch.threema.app.stores.PreferenceStoreInterface
-import ch.threema.app.tasks.TaskArchiverImpl
-import ch.threema.app.utils.DeviceCookieManagerImpl
+import ch.threema.base.crypto.NonceFactory
 import ch.threema.domain.models.AppVersion
+import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
+import ch.threema.domain.taskmanager.TaskArchiver
 import ch.threema.domain.taskmanager.TaskManager
 import ch.threema.storage.DatabaseServiceNew
 
@@ -55,13 +57,13 @@ interface CoreServiceManager {
      * The task archiver. Note that this must only be used to load the persisted tasks when the
      * service manager has been set.
      */
-    val taskArchiver: TaskArchiverImpl
+    val taskArchiver: TaskArchiver
 
     /**
      * The device cookie manager. Note that this must only be used when the notification service is
      * passed to it.
      */
-    val deviceCookieManager: DeviceCookieManagerImpl
+    val deviceCookieManager: DeviceCookieManager
 
     /**
      * The task manager. Note that this must only be used to schedule tasks when the task archiver
@@ -72,6 +74,16 @@ interface CoreServiceManager {
     /**
      * The multi device manager.
      */
-    val multiDeviceManager: MultiDeviceManagerImpl
+    val multiDeviceManager: MultiDeviceManager
+
+    /**
+     * The identity store.
+     */
+    val identityStore: IdentityStore
+
+    /**
+     * The nonce factory.
+     */
+    val nonceFactory: NonceFactory
 
 }
diff --git a/app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt b/app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt
index 3a354a08..daf69e9e 100644
--- a/app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt
+++ b/app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt
@@ -24,14 +24,17 @@ package ch.threema.app.managers
 import ch.threema.app.multidevice.MultiDeviceManagerImpl
 import ch.threema.app.services.ServerMessageService
 import ch.threema.app.services.ServerMessageServiceImpl
+import ch.threema.app.stores.IdentityStore
 import ch.threema.app.stores.PreferenceStoreInterface
 import ch.threema.app.tasks.TaskArchiverImpl
 import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.DeviceCookieManagerImpl
+import ch.threema.base.crypto.NonceFactory
 import ch.threema.domain.models.AppVersion
 import ch.threema.domain.taskmanager.TaskManager
 import ch.threema.domain.taskmanager.TaskManagerConfiguration
 import ch.threema.domain.taskmanager.TaskManagerProvider
+import ch.threema.storage.DatabaseNonceStore
 import ch.threema.storage.DatabaseServiceNew
 
 /**
@@ -43,6 +46,8 @@ class CoreServiceManagerImpl(
     override val version: AppVersion,
     override val databaseService: DatabaseServiceNew,
     override val preferenceStore: PreferenceStoreInterface,
+    override val identityStore: IdentityStore,
+    private val nonceDatabaseStoreProvider: () -> DatabaseNonceStore,
 ) : CoreServiceManager {
 
     /**
@@ -94,4 +99,8 @@ class CoreServiceManagerImpl(
         )
     }
 
+    /**
+     * The nonce factory.
+     */
+    override val nonceFactory: NonceFactory by lazy { NonceFactory(nonceDatabaseStoreProvider()) }
 }
diff --git a/app/src/main/java/ch/threema/app/managers/ServiceManager.java b/app/src/main/java/ch/threema/app/managers/ServiceManager.java
index 539565d3..37450c93 100644
--- a/app/src/main/java/ch/threema/app/managers/ServiceManager.java
+++ b/app/src/main/java/ch/threema/app/managers/ServiceManager.java
@@ -22,6 +22,9 @@
 package ch.threema.app.managers;
 
 import android.content.Context;
+import android.os.Build;
+
+import com.datatheorem.android.trustkit.pinning.OkHttp3Helper;
 
 import org.slf4j.Logger;
 
@@ -45,7 +48,6 @@ import ch.threema.app.emojis.search.EmojiSearchIndex;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.exceptions.NoIdentityException;
 import ch.threema.app.multidevice.MultiDeviceManager;
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector;
 import ch.threema.app.processors.IncomingMessageProcessorImpl;
 import ch.threema.app.services.ActivityService;
 import ch.threema.app.services.ApiService;
@@ -150,1101 +152,1078 @@ import ch.threema.domain.protocol.connection.csp.DeviceCookieManager;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor;
 import ch.threema.domain.stores.DHSessionStoreInterface;
-import ch.threema.domain.taskmanager.ActiveTaskCodec;
 import ch.threema.domain.taskmanager.IncomingMessageProcessor;
 import ch.threema.domain.taskmanager.TaskManager;
 import ch.threema.localcrypto.MasterKey;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
 import java8.util.function.Supplier;
 import okhttp3.OkHttpClient;
 
 public class ServiceManager {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("ServiceManager");
-
-	@NonNull
-	private final CoreServiceManager coreServiceManager;
-	@NonNull
-	private final Supplier<Boolean> isIpv6Preferred;
-	@NonNull
-	private final IdentityStore identityStore;
-	@NonNull
-	private final MasterKey masterKey;
-	@NonNull
-	private final UpdateSystemService updateSystemService;
-	@NonNull
-	private final CacheService cacheService;
-	@Nullable
-	private DatabaseContactStore contactStore;
-	@Nullable
-	private APIConnector apiConnector;
-	@Nullable
-	private ContactService contactService;
-	@Nullable
-	private UserService userService;
-	@Nullable
-	private MessageService messageService;
-	@Nullable
-	private QRCodeService qrCodeService;
-	@Nullable
-	private FileService fileService;
-	@Nullable
-	private PreferenceService preferencesService;
-	@Nullable
-	private LocaleService localeService;
-	@Nullable
-	private DeviceService deviceService;
-	@Nullable
-	private LifetimeService lifetimeService;
-	@Nullable
-	private AvatarCacheService avatarCacheService;
-	@Nullable
-	private LicenseService licenseService;
-	@Nullable
-	private BackupRestoreDataService backupRestoreDataService;
-	@Nullable
-	private GroupService groupService;
-	@Nullable
-	private GroupInviteService groupInviteService;
-	@Nullable
-	private GroupJoinResponseService groupJoinResponseService;
-	@Nullable
-	private IncomingGroupJoinRequestService incomingGroupJoinRequestService;
-	@Nullable
-	private OutgoingGroupJoinRequestService outgoingGroupJoinRequestService;
-	@Nullable
-	private LockAppService lockAppService;
-	@Nullable
-	private ActivityService activityService;
-	@Nullable
-	private ApiService apiService;
-	@Nullable
-	private ConversationService conversationService;
-	@Nullable
-	private NotificationService notificationService;
-	@Nullable
-	private SynchronizeContactsService synchronizeContactsService;
-	@Nullable
-	private SystemScreenLockService systemScreenLockService;
-
-	@Nullable
-	private IdListService blockedContactsService, excludedSyncIdentitiesService, profilePicRecipientsService;
-	@Nullable
-	private DeadlineListService mutedChatsListService, hiddenChatListService, mentionOnlyChatsListService;
-	@Nullable
-	private DistributionListService distributionListService;
-	@Nullable
-	private IncomingMessageProcessor incomingMessageProcessor;
-	@Nullable
-	private MessagePlayerService messagePlayerService = null;
-	@Nullable
-	private DownloadServiceImpl downloadService;
-	@Nullable
-	private BallotService ballotService;
-	@Nullable
-	private WallpaperService wallpaperService;
-	@Nullable
-	private ThreemaSafeService threemaSafeService;
-	@Nullable
-	private RingtoneService ringtoneService;
-	@Nullable
-	private BackupChatService backupChatService;
-	@NonNull
-	private final DatabaseServiceNew databaseServiceNew;
-	@NonNull
-	private final ModelRepositories modelRepositories;
-	@Nullable
-	private SensorService sensorService;
-	@Nullable
-	private VoipStateService voipStateService;
-	@Nullable
-	private GroupCallManager groupCallManager;
-	@Nullable
-	private SfuConnection sfuConnection;
-	@Nullable
-	private BrowserDetectionService browserDetectionService;
-	@Nullable
-	private ConversationTagServiceImpl conversationTagService;
-	@Nullable
-	private ServerAddressProviderService serverAddressProviderService;
-	@Nullable
-	private WebClientServiceManager webClientServiceManager;
-
-	@NonNull
-	private final DHSessionStoreInterface dhSessionStore;
-
-	@Nullable
-	private ForwardSecurityMessageProcessor forwardSecurityMessageProcessor;
-
-	@Nullable
-	private SymmetricEncryptionService symmetricEncryptionService;
-
-	@Nullable
-	private EmojiService emojiService;
-
-	@Nullable
-	private NonceFactory nonceFactory;
-
-	@Nullable
-	private TaskCreator taskCreator;
-
-	@Nullable
-	private DeviceJoinDataCollector deviceJoinDataCollector;
-
-	@NonNull
-	private final ConvertibleServerConnection connection;
-	@NonNull
-	private final LazyProperty<OkHttpClient> okHttpClient = new LazyProperty<>(this::createOkHttpClient);
-
-	public ServiceManager(
-		@NonNull ModelRepositories modelRepositories,
-		@NonNull DHSessionStoreInterface dhSessionStore,
-		@NonNull IdentityStore identityStore,
-		@NonNull MasterKey masterKey,
-		@NonNull CoreServiceManager coreServiceManager,
-		@NonNull UpdateSystemService updateSystemService
-	) throws ThreemaException {
-		this.cacheService = new CacheService();
-		this.coreServiceManager = coreServiceManager;
-		this.isIpv6Preferred = new LazyProperty<>(() -> getPreferenceService().isIpv6Preferred());
-		this.identityStore = identityStore;
-		this.masterKey = masterKey;
-		this.databaseServiceNew = coreServiceManager.getDatabaseService();
-		this.modelRepositories = modelRepositories;
-		this.dhSessionStore = dhSessionStore;
-		this.updateSystemService = updateSystemService;
-		// Finalize initialization of task archiver and device cookie manager before the connection
-		// is created.
-		coreServiceManager.getTaskArchiver().setServiceManager(this);
-		coreServiceManager.getDeviceCookieManager().setNotificationService(getNotificationService());
-		this.connection = createServerConnection();
-		coreServiceManager.getMultiDeviceManager().setReconnectHandle(connection);
-	}
-
-	@NonNull
-	public DatabaseContactStore getContactStore() {
-		if (this.contactStore == null) {
-			this.contactStore = new DatabaseContactStore(
-					this.getIdentityStore(),
-					this.getDHSessionStore(),
-					this.databaseServiceNew,
-					this.getServerAddressProviderService().getServerAddressProvider()
-			);
-		}
-
-		return this.contactStore;
-	}
-
-	@NonNull
-	public APIConnector getAPIConnector() {
-		if (this.apiConnector == null) {
-			try {
-				this.apiConnector = new APIConnector(
-					isIpv6Preferred.get(),
-					this.getServerAddressProviderService().getServerAddressProvider(),
-					ConfigUtils.isWorkBuild(),
-					ConfigUtils::getSSLSocketFactory
-				);
-				this.apiConnector.setVersion(ThreemaApplication.getAppVersion());
-				this.apiConnector.setLanguage(Locale.getDefault().getLanguage());
-
-				if (BuildFlavor.getCurrent().getLicenseType() == BuildFlavor.LicenseType.ONPREM) {
-					// On Premise always requires Basic authentication
-					PreferenceService preferenceService = this.getPreferenceService();
-					this.apiConnector.setAuthenticator(urlConnection -> {
-						if (preferenceService.getLicenseUsername() != null) {
-							String auth = preferenceService.getLicenseUsername() + ":" + preferenceService.getLicensePassword();
-							urlConnection.setRequestProperty("Authorization", "Basic " + Base64.encodeBytes(auth.getBytes(StandardCharsets.UTF_8)));
-						}
-					});
-				}
-			} catch (Exception e) {
-				logger.error("Exception", e);
-			}
-		}
-
-		return this.apiConnector;
-	}
-
-	/**
-	 * Start the server connection. Do not call this directly; use the LifetimeService!
-	 */
-	public void startConnection() throws ThreemaException {
-		logger.trace("startConnection");
-
-		String currentIdentity = this.identityStore.getIdentity();
-		if (currentIdentity == null || currentIdentity.isEmpty()) {
-			throw new NoIdentityException();
-		}
-
-		if(this.masterKey.isLocked()) {
-			throw new MasterKeyLockedException("master key is locked");
-		}
-
-		logger.info("Starting connection");
-		this.connection.start();
-	}
-
-	@NonNull
-	public PreferenceStoreInterface getPreferenceStore() {
-		return coreServiceManager.getPreferenceStore();
-	}
-
-	/**
-	 * Stop the connection. Do not call this directly; use the LifetimeService!
-	 */
-	public void stopConnection() throws InterruptedException {
-		logger.info("Stopping connection");
-		InterruptedException interrupted = null;
-		try {
-			this.connection.stop();
-		} catch (InterruptedException e) {
-			logger.error("Interrupted while stopping connection");
-			interrupted = e;
-		}
-
-		// Re-set interrupted flag
-		if (interrupted != null) {
-			Thread.currentThread().interrupt();
-			throw interrupted;
-		}
-	}
-
-	@WorkerThread
-	private void reconnectConnection() throws InterruptedException {
-		connection.reconnect();
-	}
-
-	@NonNull
-	public UserService getUserService() {
-		if (this.userService == null) {
-			try {
-				this.userService = new UserServiceImpl(
-						this.getContext(),
-						this.coreServiceManager.getPreferenceStore(),
-						this.getLocaleService(),
-						this.getAPIConnector(),
-						this.getIdentityStore(),
-						this.getPreferenceService());
-				// TODO(ANDR-2519): Remove when md allows fs
-				this.userService.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
-			} catch (Exception e) {
-				logger.error("Exception", e);
-			}
-		}
-
-		return this.userService;
-	}
-
-	public @NonNull ContactService getContactService() throws MasterKeyLockedException, FileSystemNotPresentException {
-		if (this.contactService == null) {
-			if(this.masterKey.isLocked()) {
-				throw new MasterKeyLockedException("master key is locked");
-			}
-			this.contactService = new ContactServiceImpl(
-				this.getContext(),
-				this.getContactStore(),
-				this.getAvatarCacheService(),
-				this.databaseServiceNew,
-				this.getDeviceService(),
-				this.getUserService(),
-				this.getIdentityStore(),
-				this.getPreferenceService(),
-				this.getBlockedContactsService(),
-				this.getProfilePicRecipientsService(),
-				this.getRingtoneService(),
-				this.getMutedChatsListService(),
-				this.getHiddenChatsListService(),
-				this.getFileService(),
-				this.cacheService,
-				this.getApiService(),
-				this.getWallpaperService(),
-				this.getLicenseService(),
-				this.getAPIConnector(),
-				this.getModelRepositories().getContacts()
-			);
-		}
-
-		return this.contactService;
-	}
-
-	@NonNull
-	public MessageService getMessageService() throws ThreemaException {
-		if (this.messageService == null) {
-			this.messageService = new MessageServiceImpl(
-					this.getContext(),
-					this.cacheService,
-					this.databaseServiceNew,
-					this.getContactService(),
-					this.getFileService(),
-					this.getIdentityStore(),
-					this.getSymmetricEncryptionService(),
-					this.getPreferenceService(),
-					this.getLockAppService(),
-					this.getBallotService(),
-					this.getGroupService(),
-					this.getApiService(),
-					this.getDownloadService(),
-					this.getHiddenChatsListService(),
-					this.getBlockedContactsService(),
-                    this.getModelRepositories().getEditHistory()
-			);
-		}
-
-		return this.messageService;
-	}
-
-	@NonNull
-	public PreferenceService getPreferenceService() {
-		if (this.preferencesService == null) {
-			this.preferencesService = new PreferenceServiceImpl(
-					this.getContext(),
-					this.coreServiceManager.getPreferenceStore()
-			);
-		}
-		return this.preferencesService;
-	}
-
-	@NonNull
-	public QRCodeService getQRCodeService() {
-		if (this.qrCodeService == null) {
-			this.qrCodeService = new QRCodeServiceImpl(this.getUserService());
-		}
-
-		return this.qrCodeService;
-	}
-
-	@NonNull
-	public FileService getFileService() throws FileSystemNotPresentException {
-		if (this.fileService == null) {
-			this.fileService = new FileServiceImpl(
-					this.getContext(),
-					this.masterKey,
-					this.getPreferenceService()
-			);
-		}
-
-		return this.fileService;
-	}
-
-	@NonNull
-	public LocaleService getLocaleService() {
-		if (this.localeService == null) {
-			this.localeService = new LocaleServiceImpl(this.getContext());
-		}
-
-		return this.localeService;
-	}
-
-	@NonNull
-	public ServerConnection getConnection() {
-		return this.connection;
-	}
-
-	@NonNull
-	public DeviceService getDeviceService() {
-		if(this.deviceService == null) {
-			this.deviceService = new DeviceServiceImpl(this.getContext());
-		}
-
-		return this.deviceService;
-	}
-
-	@NonNull
-	public LifetimeService getLifetimeService() {
-		if(this.lifetimeService == null) {
-			this.lifetimeService = new LifetimeServiceImpl(this.getContext());
-		}
-
-		return this.lifetimeService;
-	}
-
-	@NonNull
-	public AvatarCacheService getAvatarCacheService() throws FileSystemNotPresentException {
-		if(this.avatarCacheService == null) {
-			this.avatarCacheService = new AvatarCacheServiceImpl(this.getContext());
-		}
-
-		return this.avatarCacheService;
-	}
-
-	/**
-	 * @return service to backup or restore data (conversations and contacts)
-	 */
-	public @NonNull BackupRestoreDataService getBackupRestoreDataService() throws FileSystemNotPresentException {
-		if(this.backupRestoreDataService == null) {
-			this.backupRestoreDataService = new BackupRestoreDataServiceImpl(this.getFileService());
-		}
-
-		return this.backupRestoreDataService;
-	}
-
-	@NonNull
-	public LicenseService getLicenseService() throws FileSystemNotPresentException {
-		if(this.licenseService == null) {
-			switch(BuildFlavor.getCurrent().getLicenseType()) {
-				case SERIAL:
-					this.licenseService = new LicenseServiceSerial(
-							this.getAPIConnector(),
-							this.getPreferenceService(),
-							DeviceIdUtil.getDeviceId(getContext()));
-					break;
-				case GOOGLE_WORK:
-				case HMS_WORK:
-				case ONPREM:
-					this.licenseService = new LicenseServiceUser(
-						this.getAPIConnector(),
-						this.getPreferenceService(),
-						DeviceIdUtil.getDeviceId(getContext()));
-					break;
-				default:
-					this.licenseService = new LicenseService() {
-						@Override
-						public String validate(Credentials credentials) {
-							return null;
-						}
-
-						@Override
-						public String validate(boolean allowException) {
-							return null;
-						}
-						@Override
-						public boolean hasCredentials() {
-							return false;
-						}
-
-						@Override
-						public boolean isLicensed() {
-							return true;
-						}
-
-						@Override
-						public Credentials loadCredentials() {
-							return null;
-						}
-					};
-			}
-
-		}
-
-		return this.licenseService;
-	}
-
-	@NonNull
-	public LockAppService getLockAppService() {
-		if(null == this.lockAppService) {
-			this.lockAppService = new PinLockService(
-					this.getContext(),
-					this.getPreferenceService(),
-					this.getUserService()
-			);
-		}
-
-		return this.lockAppService;
-	}
-
-	@NonNull
-	public ActivityService getActivityService() {
-		if(null == this.activityService) {
-			this.activityService = new ActivityService(
-					this.getContext(),
-					this.getLockAppService(),
-					this.getPreferenceService());
-		}
-		return this.activityService;
-	}
-
-	@NonNull
-	public GroupService getGroupService() throws MasterKeyLockedException, FileSystemNotPresentException {
-		if (null == this.groupService) {
-			this.groupService = new GroupServiceImpl(
-				this.getContext(),
-				this.cacheService,
-				this.getUserService(),
-				this.getContactService(),
-				this.databaseServiceNew,
-				this.getAvatarCacheService(),
-				this.getFileService(),
-				this.getWallpaperService(),
-				this.getMutedChatsListService(),
-				this.getHiddenChatsListService(),
-				this.getRingtoneService(),
-				this.getConversationTagService(),
-				this
-			);
-		}
-		return this.groupService;
-	}
-
-	@NonNull
-	public GroupInviteService getGroupInviteService() throws FileSystemNotPresentException, MasterKeyLockedException {
-		if (this.groupInviteService == null) {
-			this.groupInviteService = new GroupInviteServiceImpl(
-				this.getUserService(),
-				this.getGroupService(),
-				this.getDatabaseServiceNew()
-			);
-		}
-		return this.groupInviteService;
-	}
-
-	@NonNull
-	public GroupJoinResponseService getGroupJoinResponseService() {
-		if (this.groupJoinResponseService == null) {
-			this.groupJoinResponseService = new GroupJoinResponseServiceImpl(
-				this.getDatabaseServiceNew()
-			);
-		}
-		return this.groupJoinResponseService;
-	}
-
-	@NonNull
-	public IncomingGroupJoinRequestService getIncomingGroupJoinRequestService() throws FileSystemNotPresentException, MasterKeyLockedException {
-		if (this.incomingGroupJoinRequestService == null) {
-			this.incomingGroupJoinRequestService = new IncomingGroupJoinRequestServiceImpl(
-				this.getGroupJoinResponseService(),
-				this.getGroupService(),
-				this.getUserService(),
-				this.databaseServiceNew
-			);
-		}
-		return this.incomingGroupJoinRequestService;
-	}
-
-	@NonNull
-	public OutgoingGroupJoinRequestService getOutgoingGroupJoinRequestService() {
-		if (this.outgoingGroupJoinRequestService == null) {
-			this.outgoingGroupJoinRequestService = new OutgoingGroupJoinRequestServiceImpl(
-				this.getDatabaseServiceNew()
-			);
-		}
-		return this.outgoingGroupJoinRequestService;
-	}
-
-	@NonNull
-	public ApiService getApiService() {
-		if(null == this.apiService) {
-			this.apiService = new ApiServiceImpl(
-				ThreemaApplication.getAppVersion(),
-				isIpv6Preferred.get(),
-				this.getAPIConnector(),
-				new AuthTokenStore(),
-				this.getServerAddressProviderService().getServerAddressProvider()
-			);
-		}
-		return this.apiService;
-	}
-
-	@NonNull
-	public DistributionListService getDistributionListService() throws MasterKeyLockedException, NoIdentityException, FileSystemNotPresentException {
-		if(null == this.distributionListService) {
-			this.distributionListService = new DistributionListServiceImpl(
-				this.getContext(),
-				this.getAvatarCacheService(),
-				this.databaseServiceNew,
-				this.getContactService(),
-				this.getConversationTagService()
-			);
-		}
-
-		return this.distributionListService;
-	}
-
-	@NonNull
-	public ConversationTagService getConversationTagService() {
-		if (this.conversationTagService == null) {
-			this.conversationTagService = new ConversationTagServiceImpl(this.databaseServiceNew);
-		}
-
-		return this.conversationTagService;
-	}
-
-	@NonNull
-	public ConversationService getConversationService() throws ThreemaException {
-		if(null == this.conversationService) {
-			this.conversationService = new ConversationServiceImpl(
-				this.getContext(),
-				this.cacheService,
-				this.databaseServiceNew,
-				this.getContactService(),
-				this.getGroupService(),
-				this.getDistributionListService(),
-				this.getMessageService(),
-				this.getHiddenChatsListService(),
-				this.getBlockedContactsService(),
-				this.getConversationTagService()
-			);
-		}
-
-		return this.conversationService;
-	}
-
-	@NonNull
-	public ServerAddressProviderService getServerAddressProviderService() {
-		if(null == this.serverAddressProviderService) {
-			this.serverAddressProviderService = new ServerAddressProviderServiceImpl(this.getPreferenceService());
-		}
-
-		return this.serverAddressProviderService;
-	}
-
-	@NonNull
-	public NotificationService getNotificationService() {
-		if(this.notificationService == null) {
-			this.notificationService = new NotificationServiceImpl(
-					this.getContext(),
-					this.getLockAppService(),
-					this.getHiddenChatsListService(),
-					this.getPreferenceService(),
-					this.getRingtoneService()
-			);
-		}
-		return this.notificationService;
-	}
-
-	@NonNull
-	public SynchronizeContactsService getSynchronizeContactsService() throws MasterKeyLockedException, FileSystemNotPresentException {
-		if(this.synchronizeContactsService == null) {
-			this.synchronizeContactsService = new SynchronizeContactsServiceImpl(
-				this.getContext(),
-				this.getAPIConnector(),
-				this.getContactService(),
-				this.getModelRepositories().getContacts(),
-				this.getUserService(),
-				this.getLocaleService(),
-				this.getExcludedSyncIdentitiesService(),
-				this.getPreferenceService(),
-				this.getDeviceService(),
-				this.getFileService(),
-				this.getIdentityStore(),
-				this.getBlockedContactsService(),
-				this.getApiService()
-			);
-		}
-
-		return this.synchronizeContactsService;
-	}
-
-	@NonNull
-	public IdListService getBlockedContactsService() {
-		if(this.blockedContactsService == null) {
+    private static final Logger logger = LoggingUtil.getThreemaLogger("ServiceManager");
+
+    @NonNull
+    private final CoreServiceManager coreServiceManager;
+    @NonNull
+    private final Supplier<Boolean> isIpv6Preferred;
+    @NonNull
+    private final MasterKey masterKey;
+    @NonNull
+    private final UpdateSystemService updateSystemService;
+    @NonNull
+    private final CacheService cacheService;
+    @Nullable
+    private DatabaseContactStore contactStore;
+    @Nullable
+    private APIConnector apiConnector;
+    @Nullable
+    private ContactService contactService;
+    @Nullable
+    private UserService userService;
+    @Nullable
+    private MessageService messageService;
+    @Nullable
+    private QRCodeService qrCodeService;
+    @Nullable
+    private FileService fileService;
+    @Nullable
+    private PreferenceService preferencesService;
+    @Nullable
+    private LocaleService localeService;
+    @Nullable
+    private DeviceService deviceService;
+    @Nullable
+    private LifetimeService lifetimeService;
+    @Nullable
+    private AvatarCacheService avatarCacheService;
+    @Nullable
+    private LicenseService licenseService;
+    @Nullable
+    private BackupRestoreDataService backupRestoreDataService;
+    @Nullable
+    private GroupService groupService;
+    @Nullable
+    private GroupInviteService groupInviteService;
+    @Nullable
+    private GroupJoinResponseService groupJoinResponseService;
+    @Nullable
+    private IncomingGroupJoinRequestService incomingGroupJoinRequestService;
+    @Nullable
+    private OutgoingGroupJoinRequestService outgoingGroupJoinRequestService;
+    @Nullable
+    private LockAppService lockAppService;
+    @Nullable
+    private ActivityService activityService;
+    @Nullable
+    private ApiService apiService;
+    @Nullable
+    private ConversationService conversationService;
+    @Nullable
+    private NotificationService notificationService;
+    @Nullable
+    private SynchronizeContactsService synchronizeContactsService;
+    @Nullable
+    private SystemScreenLockService systemScreenLockService;
+
+    @Nullable
+    private IdListService blockedContactsService, excludedSyncIdentitiesService, profilePicRecipientsService;
+    @Nullable
+    private DeadlineListService mutedChatsListService, hiddenChatListService, mentionOnlyChatsListService;
+    @Nullable
+    private DistributionListService distributionListService;
+    @Nullable
+    private IncomingMessageProcessor incomingMessageProcessor;
+    @Nullable
+    private MessagePlayerService messagePlayerService = null;
+    @Nullable
+    private DownloadServiceImpl downloadService;
+    @Nullable
+    private BallotService ballotService;
+    @Nullable
+    private WallpaperService wallpaperService;
+    @Nullable
+    private ThreemaSafeService threemaSafeService;
+    @Nullable
+    private RingtoneService ringtoneService;
+    @Nullable
+    private BackupChatService backupChatService;
+    @NonNull
+    private final DatabaseServiceNew databaseServiceNew;
+    @NonNull
+    private final ModelRepositories modelRepositories;
+    @Nullable
+    private SensorService sensorService;
+    @Nullable
+    private VoipStateService voipStateService;
+    @Nullable
+    private GroupCallManager groupCallManager;
+    @Nullable
+    private SfuConnection sfuConnection;
+    @Nullable
+    private BrowserDetectionService browserDetectionService;
+    @Nullable
+    private ConversationTagServiceImpl conversationTagService;
+    @Nullable
+    private ServerAddressProviderService serverAddressProviderService;
+    @Nullable
+    private WebClientServiceManager webClientServiceManager;
+
+    @NonNull
+    private final DHSessionStoreInterface dhSessionStore;
+
+    @Nullable
+    private ForwardSecurityMessageProcessor forwardSecurityMessageProcessor;
+
+    @Nullable
+    private SymmetricEncryptionService symmetricEncryptionService;
+
+    @Nullable
+    private EmojiService emojiService;
+
+    @Nullable
+    private TaskCreator taskCreator;
+
+    @NonNull
+    private final ConvertibleServerConnection connection;
+
+    @NonNull
+    private final LazyProperty<OkHttpClient> okHttpClient = new LazyProperty<>(this::createOkHttpClient);
+
+    public ServiceManager(
+        @NonNull ModelRepositories modelRepositories,
+        @NonNull DHSessionStoreInterface dhSessionStore,
+        @NonNull MasterKey masterKey,
+        @NonNull CoreServiceManagerImpl coreServiceManager,
+        @NonNull UpdateSystemService updateSystemService
+    ) throws ThreemaException {
+        this.cacheService = new CacheService();
+        this.coreServiceManager = coreServiceManager;
+        this.isIpv6Preferred = new LazyProperty<>(() -> getPreferenceService().isIpv6Preferred());
+        this.masterKey = masterKey;
+        this.databaseServiceNew = coreServiceManager.getDatabaseService();
+        this.modelRepositories = modelRepositories;
+        this.dhSessionStore = dhSessionStore;
+        this.updateSystemService = updateSystemService;
+        // Finalize initialization of task archiver and device cookie manager before the connection
+        // is created.
+        coreServiceManager.getTaskArchiver().setServiceManager(this);
+        coreServiceManager.getDeviceCookieManager().setNotificationService(getNotificationService());
+        this.connection = createServerConnection();
+        coreServiceManager.getMultiDeviceManager().setReconnectHandle(connection);
+    }
+
+    @NonNull
+    public DatabaseContactStore getContactStore() {
+        if (this.contactStore == null) {
+            this.contactStore = new DatabaseContactStore(
+                this.databaseServiceNew,
+                this.getServerAddressProviderService().getServerAddressProvider()
+            );
+        }
+
+        return this.contactStore;
+    }
+
+    @NonNull
+    public APIConnector getAPIConnector() {
+        if (this.apiConnector == null) {
+            try {
+                this.apiConnector = new APIConnector(
+                    isIpv6Preferred.get(),
+                    this.getServerAddressProviderService().getServerAddressProvider(),
+                    ConfigUtils.isWorkBuild(),
+                    ConfigUtils::getSSLSocketFactory
+                );
+                this.apiConnector.setVersion(ThreemaApplication.getAppVersion());
+                this.apiConnector.setLanguage(Locale.getDefault().getLanguage());
+
+                if (BuildFlavor.getCurrent().getLicenseType() == BuildFlavor.LicenseType.ONPREM) {
+                    // On Premise always requires Basic authentication
+                    PreferenceService preferenceService = this.getPreferenceService();
+                    this.apiConnector.setAuthenticator(urlConnection -> {
+                        if (preferenceService.getLicenseUsername() != null) {
+                            String auth = preferenceService.getLicenseUsername() + ":" + preferenceService.getLicensePassword();
+                            urlConnection.setRequestProperty("Authorization", "Basic " + Base64.encodeBytes(auth.getBytes(StandardCharsets.UTF_8)));
+                        }
+                    });
+                }
+            } catch (Exception e) {
+                logger.error("Exception", e);
+            }
+        }
+
+        return this.apiConnector;
+    }
+
+    /**
+     * Start the server connection. Do not call this directly; use the LifetimeService!
+     */
+    public void startConnection() throws ThreemaException {
+        logger.trace("startConnection");
+
+        String currentIdentity = this.coreServiceManager.getIdentityStore().getIdentity();
+        if (currentIdentity == null || currentIdentity.isEmpty()) {
+            throw new NoIdentityException();
+        }
+
+        if (this.masterKey.isLocked()) {
+            throw new MasterKeyLockedException("master key is locked");
+        }
+
+        logger.info("Starting connection");
+        this.connection.start();
+    }
+
+    @NonNull
+    public PreferenceStoreInterface getPreferenceStore() {
+        return coreServiceManager.getPreferenceStore();
+    }
+
+    /**
+     * Stop the connection. Do not call this directly; use the LifetimeService!
+     */
+    public void stopConnection() throws InterruptedException {
+        logger.info("Stopping connection");
+        InterruptedException interrupted = null;
+        try {
+            this.connection.stop();
+        } catch (InterruptedException e) {
+            logger.error("Interrupted while stopping connection");
+            interrupted = e;
+        }
+
+        // Re-set interrupted flag
+        if (interrupted != null) {
+            Thread.currentThread().interrupt();
+            throw interrupted;
+        }
+    }
+
+    @WorkerThread
+    private void reconnectConnection() throws InterruptedException {
+        connection.reconnect();
+    }
+
+    @NonNull
+    public UserService getUserService() {
+        if (this.userService == null) {
+            try {
+                this.userService = new UserServiceImpl(
+                    this.getContext(),
+                    this.coreServiceManager.getPreferenceStore(),
+                    this.getLocaleService(),
+                    this.getAPIConnector(),
+                    this.getApiService(),
+                    this.getFileService(),
+                    this.getIdentityStore(),
+                    this.getPreferenceService(),
+                    this.getTaskManager(),
+                    this.getTaskCreator(),
+                    this.getMultiDeviceManager()
+                );
+                // TODO(ANDR-2519): Remove when md allows fs
+                this.userService.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
+            } catch (Exception e) {
+                logger.error("Exception", e);
+            }
+        }
+
+        return this.userService;
+    }
+
+    public @NonNull ContactService getContactService() throws MasterKeyLockedException, FileSystemNotPresentException {
+        if (this.contactService == null) {
+            if (this.masterKey.isLocked()) {
+                throw new MasterKeyLockedException("master key is locked");
+            }
+            this.contactService = new ContactServiceImpl(
+                this.getContext(),
+                this.getContactStore(),
+                this.getAvatarCacheService(),
+                this.databaseServiceNew,
+                this.getUserService(),
+                this.getIdentityStore(),
+                this.getPreferenceService(),
+                this.getBlockedContactsService(),
+                this.getProfilePicRecipientsService(),
+                this.getFileService(),
+                this.cacheService,
+                this.getApiService(),
+                this.getLicenseService(),
+                this.getAPIConnector(),
+                this.getModelRepositories().getContacts(),
+                this.getTaskCreator(),
+                this.getMultiDeviceManager()
+            );
+        }
+
+        return this.contactService;
+    }
+
+    @NonNull
+    public MessageService getMessageService() throws ThreemaException {
+        if (this.messageService == null) {
+            this.messageService = new MessageServiceImpl(
+                this.getContext(),
+                this.cacheService,
+                this.databaseServiceNew,
+                this.getContactService(),
+                this.getFileService(),
+                this.getIdentityStore(),
+                this.getSymmetricEncryptionService(),
+                this.getPreferenceService(),
+                this.getLockAppService(),
+                this.getBallotService(),
+                this.getGroupService(),
+                this.getApiService(),
+                this.getDownloadService(),
+                this.getHiddenChatsListService(),
+                this.getBlockedContactsService(),
+                this.getModelRepositories().getEditHistory(),
+                this.getMultiDeviceManager()
+            );
+        }
+
+        return this.messageService;
+    }
+
+    @NonNull
+    public PreferenceService getPreferenceService() {
+        if (this.preferencesService == null) {
+            this.preferencesService = new PreferenceServiceImpl(
+                this.getContext(),
+                this.coreServiceManager.getPreferenceStore()
+            );
+        }
+        return this.preferencesService;
+    }
+
+    @NonNull
+    public QRCodeService getQRCodeService() {
+        if (this.qrCodeService == null) {
+            this.qrCodeService = new QRCodeServiceImpl(this.getUserService());
+        }
+
+        return this.qrCodeService;
+    }
+
+    @NonNull
+    public FileService getFileService() throws FileSystemNotPresentException {
+        if (this.fileService == null) {
+            this.fileService = new FileServiceImpl(
+                this.getContext(),
+                this.masterKey,
+                this.getPreferenceService(),
+                this.getAvatarCacheService()
+            );
+        }
+
+        return this.fileService;
+    }
+
+    @NonNull
+    public LocaleService getLocaleService() {
+        if (this.localeService == null) {
+            this.localeService = new LocaleServiceImpl(this.getContext());
+        }
+
+        return this.localeService;
+    }
+
+    @NonNull
+    public ServerConnection getConnection() {
+        return this.connection;
+    }
+
+    @NonNull
+    public DeviceService getDeviceService() {
+        if (this.deviceService == null) {
+            this.deviceService = new DeviceServiceImpl(this.getContext());
+        }
+
+        return this.deviceService;
+    }
+
+    @NonNull
+    public LifetimeService getLifetimeService() {
+        if (this.lifetimeService == null) {
+            this.lifetimeService = new LifetimeServiceImpl(this.getContext());
+        }
+
+        return this.lifetimeService;
+    }
+
+    @NonNull
+    public AvatarCacheService getAvatarCacheService() throws FileSystemNotPresentException {
+        if (this.avatarCacheService == null) {
+            this.avatarCacheService = new AvatarCacheServiceImpl(this.getContext());
+        }
+
+        return this.avatarCacheService;
+    }
+
+    /**
+     * @return service to backup or restore data (conversations and contacts)
+     */
+    public @NonNull BackupRestoreDataService getBackupRestoreDataService() throws FileSystemNotPresentException {
+        if (this.backupRestoreDataService == null) {
+            this.backupRestoreDataService = new BackupRestoreDataServiceImpl(this.getFileService());
+        }
+
+        return this.backupRestoreDataService;
+    }
+
+    @NonNull
+    public LicenseService getLicenseService() throws FileSystemNotPresentException {
+        if (this.licenseService == null) {
+            switch (BuildFlavor.getCurrent().getLicenseType()) {
+                case SERIAL:
+                    this.licenseService = new LicenseServiceSerial(
+                        this.getAPIConnector(),
+                        this.getPreferenceService(),
+                        DeviceIdUtil.getDeviceId(getContext()));
+                    break;
+                case GOOGLE_WORK:
+                case HMS_WORK:
+                case ONPREM:
+                    this.licenseService = new LicenseServiceUser(
+                        this.getAPIConnector(),
+                        this.getPreferenceService(),
+                        DeviceIdUtil.getDeviceId(getContext()));
+                    break;
+                default:
+                    this.licenseService = new LicenseService() {
+                        @Override
+                        public String validate(Credentials credentials) {
+                            return null;
+                        }
+
+                        @Override
+                        public String validate(boolean allowException) {
+                            return null;
+                        }
+
+                        @Override
+                        public boolean hasCredentials() {
+                            return false;
+                        }
+
+                        @Override
+                        public boolean isLicensed() {
+                            return true;
+                        }
+
+                        @Override
+                        public Credentials loadCredentials() {
+                            return null;
+                        }
+                    };
+            }
+
+        }
+
+        return this.licenseService;
+    }
+
+    @NonNull
+    public LockAppService getLockAppService() {
+        if (null == this.lockAppService) {
+            this.lockAppService = new PinLockService(
+                this.getContext(),
+                this.getPreferenceService(),
+                this.getUserService()
+            );
+        }
+
+        return this.lockAppService;
+    }
+
+    @NonNull
+    public ActivityService getActivityService() {
+        if (null == this.activityService) {
+            this.activityService = new ActivityService(
+                this.getContext(),
+                this.getLockAppService(),
+                this.getPreferenceService());
+        }
+        return this.activityService;
+    }
+
+    @NonNull
+    public GroupService getGroupService() throws MasterKeyLockedException, FileSystemNotPresentException {
+        if (null == this.groupService) {
+            this.groupService = new GroupServiceImpl(
+                this.getContext(),
+                this.cacheService,
+                this.getUserService(),
+                this.getContactService(),
+                this.databaseServiceNew,
+                this.getAvatarCacheService(),
+                this.getFileService(),
+                this.getWallpaperService(),
+                this.getMutedChatsListService(),
+                this.getHiddenChatsListService(),
+                this.getRingtoneService(),
+                this.getConversationTagService(),
+                this
+            );
+        }
+        return this.groupService;
+    }
+
+    @NonNull
+    public GroupInviteService getGroupInviteService() throws FileSystemNotPresentException, MasterKeyLockedException {
+        if (this.groupInviteService == null) {
+            this.groupInviteService = new GroupInviteServiceImpl(
+                this.getUserService(),
+                this.getGroupService(),
+                this.getDatabaseServiceNew()
+            );
+        }
+        return this.groupInviteService;
+    }
+
+    @NonNull
+    public GroupJoinResponseService getGroupJoinResponseService() {
+        if (this.groupJoinResponseService == null) {
+            this.groupJoinResponseService = new GroupJoinResponseServiceImpl(
+                this.getDatabaseServiceNew()
+            );
+        }
+        return this.groupJoinResponseService;
+    }
+
+    @NonNull
+    public IncomingGroupJoinRequestService getIncomingGroupJoinRequestService() throws FileSystemNotPresentException, MasterKeyLockedException {
+        if (this.incomingGroupJoinRequestService == null) {
+            this.incomingGroupJoinRequestService = new IncomingGroupJoinRequestServiceImpl(
+                this.getGroupJoinResponseService(),
+                this.getGroupService(),
+                this.getUserService(),
+                this.databaseServiceNew
+            );
+        }
+        return this.incomingGroupJoinRequestService;
+    }
+
+    @NonNull
+    public OutgoingGroupJoinRequestService getOutgoingGroupJoinRequestService() {
+        if (this.outgoingGroupJoinRequestService == null) {
+            this.outgoingGroupJoinRequestService = new OutgoingGroupJoinRequestServiceImpl(
+                this.getDatabaseServiceNew()
+            );
+        }
+        return this.outgoingGroupJoinRequestService;
+    }
+
+    @NonNull
+    public ApiService getApiService() {
+        if (null == this.apiService) {
+            this.apiService = new ApiServiceImpl(
+                ThreemaApplication.getAppVersion(),
+                isIpv6Preferred.get(),
+                this.getAPIConnector(),
+                new AuthTokenStore(),
+                this.getServerAddressProviderService().getServerAddressProvider(),
+                this.getMultiDeviceManager(),
+                this.getOkHttpClient()
+            );
+        }
+        return this.apiService;
+    }
+
+    @NonNull
+    public DistributionListService getDistributionListService() throws MasterKeyLockedException, NoIdentityException, FileSystemNotPresentException {
+        if (null == this.distributionListService) {
+            this.distributionListService = new DistributionListServiceImpl(
+                this.getContext(),
+                this.getAvatarCacheService(),
+                this.databaseServiceNew,
+                this.getContactService(),
+                this.getConversationTagService()
+            );
+        }
+
+        return this.distributionListService;
+    }
+
+    @NonNull
+    public ConversationTagService getConversationTagService() {
+        if (this.conversationTagService == null) {
+            this.conversationTagService = new ConversationTagServiceImpl(this.databaseServiceNew);
+        }
+
+        return this.conversationTagService;
+    }
+
+    @NonNull
+    public ConversationService getConversationService() throws ThreemaException {
+        if (null == this.conversationService) {
+            this.conversationService = new ConversationServiceImpl(
+                this.getContext(),
+                this.cacheService,
+                this.databaseServiceNew,
+                this.getContactService(),
+                this.getGroupService(),
+                this.getDistributionListService(),
+                this.getMessageService(),
+                this.getHiddenChatsListService(),
+                this.getBlockedContactsService(),
+                this.getConversationTagService()
+            );
+        }
+
+        return this.conversationService;
+    }
+
+    @NonNull
+    public ServerAddressProviderService getServerAddressProviderService() {
+        if (null == this.serverAddressProviderService) {
+            this.serverAddressProviderService = new ServerAddressProviderServiceImpl(this.getPreferenceService());
+        }
+
+        return this.serverAddressProviderService;
+    }
+
+    @NonNull
+    public NotificationService getNotificationService() {
+        if (this.notificationService == null) {
+            this.notificationService = new NotificationServiceImpl(
+                this.getContext(),
+                this.getLockAppService(),
+                this.getHiddenChatsListService(),
+                this.getPreferenceService(),
+                this.getRingtoneService()
+            );
+        }
+        return this.notificationService;
+    }
+
+    @NonNull
+    public SynchronizeContactsService getSynchronizeContactsService() throws MasterKeyLockedException, FileSystemNotPresentException {
+        if (this.synchronizeContactsService == null) {
+            this.synchronizeContactsService = new SynchronizeContactsServiceImpl(
+                this.getContext(),
+                this.getAPIConnector(),
+                this.getContactService(),
+                this.getModelRepositories().getContacts(),
+                this.getUserService(),
+                this.getLocaleService(),
+                this.getExcludedSyncIdentitiesService(),
+                this.getPreferenceService(),
+                this.getDeviceService(),
+                this.getFileService(),
+                this.getIdentityStore(),
+                this.getBlockedContactsService(),
+                this.getApiService()
+            );
+        }
+
+        return this.synchronizeContactsService;
+    }
+
+    @NonNull
+    public IdListService getBlockedContactsService() {
+        if (this.blockedContactsService == null) {
             // Keep the uniqueListName `identity_list_blacklist` to avoid a migration of the key in the preferences
-			this.blockedContactsService = new IdListServiceImpl("identity_list_blacklist", this.getPreferenceService());
-		}
-		return this.blockedContactsService;
-	}
-
-	@NonNull
-	public DeadlineListService getMutedChatsListService() {
-		if(this.mutedChatsListService == null) {
-			this.mutedChatsListService = new DeadlineListServiceImpl("list_muted_chats", this.getPreferenceService());
-		}
-		return this.mutedChatsListService;
-	}
-
-	@NonNull
-	public DeadlineListService getHiddenChatsListService() {
-		if(this.hiddenChatListService == null) {
-			this.hiddenChatListService = new DeadlineListServiceImpl("list_hidden_chats", this.getPreferenceService());
-		}
-		return this.hiddenChatListService;
-	}
-
-	@NonNull
-	public DeadlineListService getMentionOnlyChatsListService() {
-		if(this.mentionOnlyChatsListService == null) {
-			this.mentionOnlyChatsListService = new DeadlineListServiceImpl("list_mention_only", this.getPreferenceService());
-		}
-		return this.mentionOnlyChatsListService;
-	}
-
-	@NonNull
-	public IdListService getExcludedSyncIdentitiesService() {
-		if(this.excludedSyncIdentitiesService == null) {
-			this.excludedSyncIdentitiesService = new IdListServiceImpl("identity_list_sync_excluded", this.getPreferenceService());
-		}
-		return this.excludedSyncIdentitiesService;
-	}
-
-	@NonNull
-	public UpdateSystemService getUpdateSystemService() {
-		return this.updateSystemService;
-	}
-
-	@NonNull
-	public MessagePlayerService getMessagePlayerService() throws ThreemaException {
-		if(this.messagePlayerService == null) {
-			this.messagePlayerService = new MessagePlayerServiceImpl(
-					getContext(),
-					this.getMessageService(),
-					this.getFileService(),
-					this.getPreferenceService(),
-					this.getHiddenChatsListService()
-			);
-		}
-		return this.messagePlayerService;
-	}
-
-	@NonNull
-	public DownloadService getDownloadService() throws FileSystemNotPresentException {
-		if (this.downloadService == null) {
-			this.downloadService = new DownloadServiceImpl(
-					this.getContext(),
-					this.getFileService(),
-					this.getApiService()
-			);
-		}
-		return this.downloadService;
-	}
-
-	@NonNull
-	public BallotService getBallotService() throws NoIdentityException, MasterKeyLockedException, FileSystemNotPresentException {
-		if(this.ballotService == null) {
-			this.ballotService = new BallotServiceImpl(
-					this.cacheService.getBallotModelCache(),
-					this.cacheService.getLinkBallotModelCache(),
-					this.databaseServiceNew,
-					this.getUserService(),
-					this.getGroupService(),
-					this.getContactService(),
-					this);
-		}
-		return this.ballotService;
-	}
-
-	@NonNull
-	public WallpaperService getWallpaperService() throws FileSystemNotPresentException {
-		if(this.wallpaperService == null) {
-			this.wallpaperService = new WallpaperServiceImpl(this.getContext(),
-					this.getFileService(),
-					this.getPreferenceService(),
-					this.masterKey
-			);
-		}
-
-		return this.wallpaperService;
-	}
-
-	public @NonNull ThreemaSafeService getThreemaSafeService() throws FileSystemNotPresentException, MasterKeyLockedException, NoIdentityException {
-		if (this.threemaSafeService == null) {
-			this.threemaSafeService = new ThreemaSafeServiceImpl(
-				this.getContext(),
-				this.getPreferenceService(),
-				this.getUserService(),
-				this.getContactService(),
-				this.getGroupService(),
-				this.getDistributionListService(),
-				this.getLocaleService(),
-				this.getFileService(),
-				this.getBlockedContactsService(),
-				this.getExcludedSyncIdentitiesService(),
-				this.getProfilePicRecipientsService(),
-				this.getDatabaseServiceNew(),
-				this.getIdentityStore(),
-				this.getApiService(),
-				this.getAPIConnector(),
-				this.getHiddenChatsListService(),
-				this.getServerAddressProviderService().getServerAddressProvider(),
-				this.getPreferenceStore()
-			);
-		}
-		return this.threemaSafeService;
-	}
-
-	@NonNull
-	public Context getContext() {
-		return ThreemaApplication.getAppContext();
-	}
-
-	@NonNull
-	public IdentityStore getIdentityStore() {
-		return this.identityStore;
-	}
-
-	@NonNull
-	public RingtoneService getRingtoneService() {
-		if(this.ringtoneService == null) {
-			this.ringtoneService = new RingtoneServiceImpl(this.getPreferenceService());
-		}
-
-		return this.ringtoneService;
-	}
-
-	@NonNull
-	public BackupChatService getBackupChatService() throws ThreemaException {
-		if (this.backupChatService == null) {
-			this.backupChatService = new BackupChatServiceImpl(
-					this.getContext(),
-					this.getFileService(),
-					this.getMessageService(),
-					this.getContactService()
-			);
-		}
-
-		return this.backupChatService;
-	}
-
-	@NonNull
-	public SystemScreenLockService getScreenLockService() {
-		if(this.systemScreenLockService == null) {
-			this.systemScreenLockService = new SystemScreenLockServiceImpl(
-					this.getContext(),
-					this.getLockAppService(),
-					this.getPreferenceService()
-			);
-		}
-		return this.systemScreenLockService;
-	}
-
-	@NonNull
-	public SensorService getSensorService() {
-		if (this.sensorService == null) {
-			this.sensorService = new SensorServiceImpl(this.getContext());
-		}
-		return this.sensorService;
-	}
-
-	@NonNull
-	public WebClientServiceManager getWebClientServiceManager() throws ThreemaException {
-		if (this.webClientServiceManager == null) {
-			this.webClientServiceManager = new WebClientServiceManager(new ServicesContainer(
-				this.getContext().getApplicationContext(),
-				this.getLifetimeService(),
-				this.getContactService(),
-				this.getGroupService(),
-				this.getDistributionListService(),
-				this.getConversationService(),
-				this.getConversationTagService(),
-				this.getMessageService(),
-				this.getNotificationService(),
-				this.databaseServiceNew,
-				this.getBlockedContactsService(),
-				this.getPreferenceService(),
-				this.getUserService(),
-				this.getHiddenChatsListService(),
-				this.getFileService(),
-				this.getSynchronizeContactsService(),
-				this.getLicenseService()
-			));
-		}
-		return this.webClientServiceManager;
-	}
-
-	@NonNull
-	public BrowserDetectionService getBrowserDetectionService() {
-		if (this.browserDetectionService == null) {
-			this.browserDetectionService = new BrowserDetectionServiceImpl();
-		}
-		return this.browserDetectionService;
-	}
-
-	@NonNull
-	public IdListService getProfilePicRecipientsService() {
-		if(this.profilePicRecipientsService == null) {
-			this.profilePicRecipientsService = new IdListServiceImpl("identity_list_profilepics", this.getPreferenceService());
-		}
-		return this.profilePicRecipientsService;
-	}
-
-	@NonNull
-	public VoipStateService getVoipStateService() throws ThreemaException {
-		if (this.voipStateService == null) {
-			this.voipStateService = new VoipStateService(
-					this.getContactService(),
-					this.getRingtoneService(),
-					this.getPreferenceService(),
-					this.getLifetimeService(),
-					this.getContext()
-			);
-		}
-		return this.voipStateService;
-	}
-
-	@NonNull
-	public DatabaseServiceNew getDatabaseServiceNew() {
-		return this.databaseServiceNew;
-	}
-
-	@NonNull
-	public ModelRepositories getModelRepositories() {
-		return this.modelRepositories;
-	}
-
-	@NonNull
-	public DHSessionStoreInterface getDHSessionStore() {
-		return this.dhSessionStore;
-	}
-
-	@NonNull
-	public ForwardSecurityMessageProcessor getForwardSecurityMessageProcessor() throws ThreemaException {
-		if (this.forwardSecurityMessageProcessor == null) {
-			this.forwardSecurityMessageProcessor = new ForwardSecurityMessageProcessor(
-				this.getDHSessionStore(),
-				this.getContactStore(),
-				this.getIdentityStore(),
-				this.getNonceFactory(),
-				new ForwardSecurityStatusSender(
-					this.getContactService(),
-					this.getMessageService(),
-					this.getAPIConnector()
-				)
-			);
-			// TODO(ANDR-2519): Remove when md allows fs
-			forwardSecurityMessageProcessor.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
-		}
-		return this.forwardSecurityMessageProcessor;
-	}
-
-	@NonNull
-	public SymmetricEncryptionService getSymmetricEncryptionService() {
-		if (symmetricEncryptionService == null) {
-			symmetricEncryptionService = new SymmetricEncryptionService();
-		}
-		return symmetricEncryptionService;
-	}
-
-	@NonNull
-	public EmojiService getEmojiService() {
-		if (emojiService == null) {
-			EmojiSearchIndex searchIndex = new EmojiSearchIndex(
-				getContext().getApplicationContext(),
-				getPreferenceService()
-			);
-			emojiService = new EmojiService(
-				getPreferenceService(),
-				searchIndex,
-				new EmojiRecent(getPreferenceService())
-			);
-		}
-		return emojiService;
-	}
-
-	@NonNull
-	public GroupCallManager getGroupCallManager() throws ThreemaException {
-		if (groupCallManager == null) {
-			groupCallManager = new GroupCallManagerImpl(
-				getContext().getApplicationContext(),
-				this,
-				getDatabaseServiceNew(),
-				getGroupService(),
-				getContactService(),
-				getPreferenceService(),
-				getMessageService(),
-				getNotificationService(),
-				getSfuConnection()
-			);
-		}
-		return groupCallManager;
-	}
-
-	@NonNull
-	public SfuConnection getSfuConnection() {
-		if (sfuConnection == null) {
-			sfuConnection = new SfuConnectionImpl(
-				getAPIConnector(),
-				getIdentityStore(),
-				ThreemaApplication.getAppVersion()
-			);
-		}
-		return sfuConnection;
-	}
-
-	public @NonNull NonceFactory getNonceFactory() {
-		if (nonceFactory == null) {
-			DatabaseNonceStore databaseNonceStore = new DatabaseNonceStore(getContext(), identityStore);
-			databaseNonceStore.executeNull();
-			logger.info("Nonce count: " + databaseNonceStore.getCount());
-			nonceFactory = new NonceFactory(databaseNonceStore);
-		}
-		return nonceFactory;
-	}
-
-	private @NonNull IncomingMessageProcessor getIncomingMessageProcessor() throws ThreemaException {
-		if (this.incomingMessageProcessor == null) {
-			this.incomingMessageProcessor = new IncomingMessageProcessorImpl(
-				getMessageService(),
-				getNonceFactory(),
-				getForwardSecurityMessageProcessor(),
-				getContactService(),
-				getContactStore(),
-				getIdentityStore(),
-				getBlockedContactsService(),
-				getPreferenceService(),
-				this
-			);
-		}
-		return this.incomingMessageProcessor;
-	}
-
-	public @NonNull TaskManager getTaskManager() {
-		return this.coreServiceManager.getTaskManager();
-	}
-
-	public @NonNull TaskCreator getTaskCreator() {
-		if (this.taskCreator == null) {
-			this.taskCreator = new TaskCreator(this);
-		}
-		return this.taskCreator;
-	}
-
-	@NonNull
-	public MultiDeviceManager getMultiDeviceManager() {
-		return this.coreServiceManager.getMultiDeviceManager();
-	}
-
-	@NonNull
-	public DeviceJoinDataCollector getDeviceJoinDataCollector() {
-		if (deviceJoinDataCollector == null) {
-			deviceJoinDataCollector = new DeviceJoinDataCollector(this);
-			return deviceJoinDataCollector;
-		}
-		return deviceJoinDataCollector;
-	}
-
-	/**
-	 * Get a task handle. This task handle can be used to send messages.
-	 *
-	 * @deprecated Note that we should only be able to send messages inside a task (where we have
-	 * the task handle anyway). This task handle is only available in the migration phase until we
-	 * have switched completely to tasks.
-	 *
-	 * @return the task handle during the migration phase
-	 */
-	@Deprecated
-	public @NonNull ActiveTaskCodec getMigrationTaskHandle() {
-		return getTaskManager().getMigrationTaskHandle();
-	}
-
-	@NonNull
-	private ConvertibleServerConnection createServerConnection() throws ThreemaException {
-		Supplier<ServerConnection> connectionSupplier = new CspD2mDualConnectionSupplier(
-			getMultiDeviceManager(),
-			getIncomingMessageProcessor(),
-			getTaskManager(),
-			getDeviceCookieManager(),
-			getServerAddressProviderService(),
-			getIdentityStore(),
-			coreServiceManager.getVersion(),
-			isIpv6Preferred.get(),
-			okHttpClient,
-			ConfigUtils.isDevBuild()
-		);
-		return new ConvertibleServerConnection(connectionSupplier);
-	}
-
-	@NonNull
-	public DeviceCookieManager getDeviceCookieManager() {
-		return coreServiceManager.getDeviceCookieManager();
-	}
-
-	@NonNull
-	private OkHttpClient createOkHttpClient() {
-		logger.debug("Create OkHttpClient");
-		return new OkHttpClient.Builder()
-			.connectTimeout(ProtocolDefines.CONNECT_TIMEOUT, TimeUnit.SECONDS)
-			.writeTimeout(ProtocolDefines.WRITE_TIMEOUT, TimeUnit.SECONDS)
-			.readTimeout(ProtocolDefines.READ_TIMEOUT, TimeUnit.SECONDS)
-			.build();
-	}
+            this.blockedContactsService = new IdListServiceImpl("identity_list_blacklist", this.getPreferenceService());
+        }
+        return this.blockedContactsService;
+    }
+
+    @NonNull
+    public DeadlineListService getMutedChatsListService() {
+        if (this.mutedChatsListService == null) {
+            this.mutedChatsListService = new DeadlineListServiceImpl("list_muted_chats", this.getPreferenceService());
+        }
+        return this.mutedChatsListService;
+    }
+
+    @NonNull
+    public DeadlineListService getHiddenChatsListService() {
+        if (this.hiddenChatListService == null) {
+            this.hiddenChatListService = new DeadlineListServiceImpl("list_hidden_chats", this.getPreferenceService());
+        }
+        return this.hiddenChatListService;
+    }
+
+    @NonNull
+    public DeadlineListService getMentionOnlyChatsListService() {
+        if (this.mentionOnlyChatsListService == null) {
+            this.mentionOnlyChatsListService = new DeadlineListServiceImpl("list_mention_only", this.getPreferenceService());
+        }
+        return this.mentionOnlyChatsListService;
+    }
+
+    @NonNull
+    public IdListService getExcludedSyncIdentitiesService() {
+        if (this.excludedSyncIdentitiesService == null) {
+            this.excludedSyncIdentitiesService = new IdListServiceImpl("identity_list_sync_excluded", this.getPreferenceService());
+        }
+        return this.excludedSyncIdentitiesService;
+    }
+
+    @NonNull
+    public UpdateSystemService getUpdateSystemService() {
+        return this.updateSystemService;
+    }
+
+    @NonNull
+    public MessagePlayerService getMessagePlayerService() throws ThreemaException {
+        if (this.messagePlayerService == null) {
+            this.messagePlayerService = new MessagePlayerServiceImpl(
+                getContext(),
+                this.getMessageService(),
+                this.getFileService(),
+                this.getPreferenceService(),
+                this.getHiddenChatsListService()
+            );
+        }
+        return this.messagePlayerService;
+    }
+
+    @NonNull
+    public DownloadService getDownloadService() throws FileSystemNotPresentException {
+        if (this.downloadService == null) {
+            this.downloadService = new DownloadServiceImpl(
+                this.getContext(),
+                this.getFileService(),
+                this.getApiService()
+            );
+        }
+        return this.downloadService;
+    }
+
+    @NonNull
+    public BallotService getBallotService() throws NoIdentityException, MasterKeyLockedException, FileSystemNotPresentException {
+        if (this.ballotService == null) {
+            this.ballotService = new BallotServiceImpl(
+                this.cacheService.getBallotModelCache(),
+                this.cacheService.getLinkBallotModelCache(),
+                this.databaseServiceNew,
+                this.getUserService(),
+                this.getGroupService(),
+                this.getContactService(),
+                this);
+        }
+        return this.ballotService;
+    }
+
+    @NonNull
+    public WallpaperService getWallpaperService() throws FileSystemNotPresentException {
+        if (this.wallpaperService == null) {
+            this.wallpaperService = new WallpaperServiceImpl(this.getContext(),
+                this.getFileService(),
+                this.getPreferenceService(),
+                this.masterKey
+            );
+        }
+
+        return this.wallpaperService;
+    }
+
+    public @NonNull ThreemaSafeService getThreemaSafeService() throws FileSystemNotPresentException, MasterKeyLockedException, NoIdentityException {
+        if (this.threemaSafeService == null) {
+            this.threemaSafeService = new ThreemaSafeServiceImpl(
+                this.getContext(),
+                this.getPreferenceService(),
+                this.getUserService(),
+                this.getContactService(),
+                this.getGroupService(),
+                this.getDistributionListService(),
+                this.getLocaleService(),
+                this.getFileService(),
+                this.getBlockedContactsService(),
+                this.getExcludedSyncIdentitiesService(),
+                this.getProfilePicRecipientsService(),
+                this.getDatabaseServiceNew(),
+                this.getIdentityStore(),
+                this.getApiService(),
+                this.getAPIConnector(),
+                this.getHiddenChatsListService(),
+                this.getServerAddressProviderService().getServerAddressProvider(),
+                this.getPreferenceStore(),
+                this.getModelRepositories().getContacts()
+            );
+        }
+        return this.threemaSafeService;
+    }
+
+    @NonNull
+    public Context getContext() {
+        return ThreemaApplication.getAppContext();
+    }
+
+    @NonNull
+    public IdentityStore getIdentityStore() {
+        return this.coreServiceManager.getIdentityStore();
+    }
+
+    @NonNull
+    public RingtoneService getRingtoneService() {
+        if (this.ringtoneService == null) {
+            this.ringtoneService = new RingtoneServiceImpl(this.getPreferenceService());
+        }
+
+        return this.ringtoneService;
+    }
+
+    @NonNull
+    public BackupChatService getBackupChatService() throws ThreemaException {
+        if (this.backupChatService == null) {
+            this.backupChatService = new BackupChatServiceImpl(
+                this.getContext(),
+                this.getFileService(),
+                this.getMessageService(),
+                this.getContactService()
+            );
+        }
+
+        return this.backupChatService;
+    }
+
+    @NonNull
+    public SystemScreenLockService getScreenLockService() {
+        if (this.systemScreenLockService == null) {
+            this.systemScreenLockService = new SystemScreenLockServiceImpl(
+                this.getContext(),
+                this.getLockAppService(),
+                this.getPreferenceService()
+            );
+        }
+        return this.systemScreenLockService;
+    }
+
+    @NonNull
+    public SensorService getSensorService() {
+        if (this.sensorService == null) {
+            this.sensorService = new SensorServiceImpl(this.getContext());
+        }
+        return this.sensorService;
+    }
+
+    @NonNull
+    public WebClientServiceManager getWebClientServiceManager() throws ThreemaException {
+        if (this.webClientServiceManager == null) {
+            this.webClientServiceManager = new WebClientServiceManager(new ServicesContainer(
+                this.getContext().getApplicationContext(),
+                this.getLifetimeService(),
+                this.getContactService(),
+                this.getGroupService(),
+                this.getDistributionListService(),
+                this.getConversationService(),
+                this.getConversationTagService(),
+                this.getMessageService(),
+                this.getNotificationService(),
+                this.databaseServiceNew,
+                this.getBlockedContactsService(),
+                this.getPreferenceService(),
+                this.getUserService(),
+                this.getHiddenChatsListService(),
+                this.getFileService(),
+                this.getSynchronizeContactsService(),
+                this.getLicenseService(),
+                this.getAPIConnector(),
+                this.getModelRepositories().getContacts()
+            ));
+        }
+        return this.webClientServiceManager;
+    }
+
+    @NonNull
+    public BrowserDetectionService getBrowserDetectionService() {
+        if (this.browserDetectionService == null) {
+            this.browserDetectionService = new BrowserDetectionServiceImpl();
+        }
+        return this.browserDetectionService;
+    }
+
+    @NonNull
+    public IdListService getProfilePicRecipientsService() {
+        if (this.profilePicRecipientsService == null) {
+            this.profilePicRecipientsService = new IdListServiceImpl("identity_list_profilepics", this.getPreferenceService());
+        }
+        return this.profilePicRecipientsService;
+    }
+
+    @NonNull
+    public VoipStateService getVoipStateService() throws ThreemaException {
+        if (this.voipStateService == null) {
+            this.voipStateService = new VoipStateService(
+                this.getContactService(),
+                this.getRingtoneService(),
+                this.getPreferenceService(),
+                this.getLifetimeService(),
+                this.getContext()
+            );
+        }
+        return this.voipStateService;
+    }
+
+    @NonNull
+    public DatabaseServiceNew getDatabaseServiceNew() {
+        return this.databaseServiceNew;
+    }
+
+    @NonNull
+    public ModelRepositories getModelRepositories() {
+        return this.modelRepositories;
+    }
+
+    @NonNull
+    public DHSessionStoreInterface getDHSessionStore() {
+        return this.dhSessionStore;
+    }
+
+    @NonNull
+    public ForwardSecurityMessageProcessor getForwardSecurityMessageProcessor() throws ThreemaException {
+        if (this.forwardSecurityMessageProcessor == null) {
+            this.forwardSecurityMessageProcessor = new ForwardSecurityMessageProcessor(
+                this.getDHSessionStore(),
+                this.getContactStore(),
+                this.getIdentityStore(),
+                this.getNonceFactory(),
+                new ForwardSecurityStatusSender(
+                    this.getContactService(),
+                    this.getMessageService(),
+                    this.getAPIConnector(),
+                    this.getUserService(),
+                    this.getModelRepositories().getContacts()
+                )
+            );
+            // TODO(ANDR-2519): Remove when md allows fs
+            forwardSecurityMessageProcessor.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
+        }
+        return this.forwardSecurityMessageProcessor;
+    }
+
+    @NonNull
+    public SymmetricEncryptionService getSymmetricEncryptionService() {
+        if (symmetricEncryptionService == null) {
+            symmetricEncryptionService = new SymmetricEncryptionService();
+        }
+        return symmetricEncryptionService;
+    }
+
+    @NonNull
+    public EmojiService getEmojiService() {
+        if (emojiService == null) {
+            EmojiSearchIndex searchIndex = new EmojiSearchIndex(
+                getContext().getApplicationContext(),
+                getPreferenceService()
+            );
+            emojiService = new EmojiService(
+                getPreferenceService(),
+                searchIndex,
+                new EmojiRecent(getPreferenceService())
+            );
+        }
+        return emojiService;
+    }
+
+    @NonNull
+    public GroupCallManager getGroupCallManager() throws ThreemaException {
+        if (groupCallManager == null) {
+            groupCallManager = new GroupCallManagerImpl(
+                getContext().getApplicationContext(),
+                this,
+                getDatabaseServiceNew(),
+                getGroupService(),
+                getContactService(),
+                getPreferenceService(),
+                getMessageService(),
+                getNotificationService(),
+                getSfuConnection()
+            );
+        }
+        return groupCallManager;
+    }
+
+    @NonNull
+    public SfuConnection getSfuConnection() {
+        if (sfuConnection == null) {
+            sfuConnection = new SfuConnectionImpl(
+                getAPIConnector(),
+                getIdentityStore(),
+                ThreemaApplication.getAppVersion()
+            );
+        }
+        return sfuConnection;
+    }
+
+    public @NonNull NonceFactory getNonceFactory() {
+        return coreServiceManager.getNonceFactory();
+    }
+
+    private @NonNull IncomingMessageProcessor getIncomingMessageProcessor() {
+        if (this.incomingMessageProcessor == null) {
+            this.incomingMessageProcessor = new IncomingMessageProcessorImpl(this);
+        }
+        return this.incomingMessageProcessor;
+    }
+
+    public @NonNull TaskManager getTaskManager() {
+        return this.coreServiceManager.getTaskManager();
+    }
+
+    public @NonNull TaskCreator getTaskCreator() {
+        if (this.taskCreator == null) {
+            this.taskCreator = new TaskCreator(this);
+        }
+        return this.taskCreator;
+    }
+
+    @NonNull
+    public MultiDeviceManager getMultiDeviceManager() {
+        return this.coreServiceManager.getMultiDeviceManager();
+    }
+
+    @NonNull
+    public OkHttpClient getOkHttpClient() {
+        return okHttpClient.get();
+    }
+
+    @NonNull
+    private ConvertibleServerConnection createServerConnection() throws ThreemaException {
+        Supplier<ServerConnection> connectionSupplier = new CspD2mDualConnectionSupplier(
+            getMultiDeviceManager(),
+            getIncomingMessageProcessor(),
+            getTaskManager(),
+            getDeviceCookieManager(),
+            getServerAddressProviderService(),
+            getIdentityStore(),
+            coreServiceManager.getVersion(),
+            isIpv6Preferred.get(),
+            okHttpClient,
+            ConfigUtils.isDevBuild()
+        );
+        return new ConvertibleServerConnection(connectionSupplier);
+    }
+
+    @NonNull
+    public DeviceCookieManager getDeviceCookieManager() {
+        return coreServiceManager.getDeviceCookieManager();
+    }
+
+    @NonNull
+    private OkHttpClient createOkHttpClient() {
+        logger.debug("Create OkHttpClient");
+        OkHttpClient.Builder builder = new OkHttpClient.Builder()
+            .connectTimeout(ProtocolDefines.CONNECT_TIMEOUT, TimeUnit.SECONDS)
+            .writeTimeout(ProtocolDefines.WRITE_TIMEOUT, TimeUnit.SECONDS)
+            .readTimeout(ProtocolDefines.READ_TIMEOUT, TimeUnit.SECONDS);
+
+        /*
+         * For android versions < 7.0 we have to explicitly configure the okhttp client
+         * to use certificate pinning via TrustKit.
+         * In on-prem builds we never pin.
+         */
+        if (!ConfigUtils.isOnPremBuild() && Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
+            builder.sslSocketFactory(OkHttp3Helper.getSSLSocketFactory(), OkHttp3Helper.getTrustManager());
+            builder.addInterceptor(OkHttp3Helper.getPinningInterceptor());
+        }
+
+        return builder.build();
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java b/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java
index 1c19716e..0f1d3d7d 100644
--- a/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java
+++ b/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java
@@ -36,17 +36,19 @@ import androidx.annotation.Nullable;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ServiceManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.IdListService;
 import ch.threema.app.services.MessageService;
 import ch.threema.app.stores.IdentityStore;
+import ch.threema.app.tasks.OutboundIncomingContactMessageUpdateReadTask;
+import ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask;
 import ch.threema.app.tasks.OutgoingContactDeleteMessageTask;
 import ch.threema.app.tasks.OutgoingContactEditMessageTask;
-import ch.threema.app.tasks.OutgoingPollSetupMessageTask;
-import ch.threema.app.tasks.OutgoingPollVoteContactMessageTask;
-import ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask;
 import ch.threema.app.tasks.OutgoingFileMessageTask;
 import ch.threema.app.tasks.OutgoingLocationMessageTask;
+import ch.threema.app.tasks.OutgoingPollSetupMessageTask;
+import ch.threema.app.tasks.OutgoingPollVoteContactMessageTask;
 import ch.threema.app.tasks.OutgoingTextMessageTask;
 import ch.threema.app.tasks.OutgoingTypingIndicatorMessageTask;
 import ch.threema.app.tasks.OutgoingVoipCallAnswerMessageTask;
@@ -54,6 +56,7 @@ import ch.threema.app.tasks.OutgoingVoipCallHangupMessageTask;
 import ch.threema.app.tasks.OutgoingVoipCallOfferMessageTask;
 import ch.threema.app.tasks.OutgoingVoipCallRingingMessageTask;
 import ch.threema.app.tasks.OutgoingVoipICECandidateMessageTask;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
@@ -83,20 +86,21 @@ import ch.threema.storage.models.data.media.FileDataModel;
 public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	private final ContactModel contactModel;
 	private final ContactService contactService;
-	private Bitmap avatar = null;
 	@NonNull
 	private final ServiceManager serviceManager;
 	private final DatabaseServiceNew databaseServiceNew;
 	private final IdentityStore identityStore;
 	private final IdListService blockedContactsService;
 	private final @NonNull TaskManager taskManager;
+	private final @NonNull MultiDeviceManager multiDeviceManager;
 
 	public ContactMessageReceiver(ContactModel contactModel,
 	                              ContactService contactService,
 	                              @NonNull ServiceManager serviceManager,
 	                              DatabaseServiceNew databaseServiceNew,
 	                              IdentityStore identityStore,
-	                              IdListService blockedContactsService) {
+	                              IdListService blockedContactsService
+	) {
 		this.contactModel = contactModel;
 		this.contactService = contactService;
 		this.serviceManager = serviceManager;
@@ -104,6 +108,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		this.identityStore = identityStore;
 		this.blockedContactsService = blockedContactsService;
 		this.taskManager = serviceManager.getTaskManager();
+		this.multiDeviceManager = serviceManager.getMultiDeviceManager();
 	}
 
 	protected ContactMessageReceiver(ContactMessageReceiver contactMessageReceiver) {
@@ -115,7 +120,6 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 			contactMessageReceiver.identityStore,
 			contactMessageReceiver.blockedContactsService
 		);
-		avatar = contactMessageReceiver.avatar;
 	}
 
 	@Override
@@ -163,7 +167,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		saveLocalModel(messageModel);
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		bumpLastUpdate();
@@ -178,7 +182,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	}
 
 	public void resendTextMessage(@NonNull MessageModel messageModel) {
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		scheduleTask(new OutgoingTextMessageTask(
@@ -196,7 +200,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		saveLocalModel(messageModel);
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		bumpLastUpdate();
@@ -212,7 +216,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 
 	public void resendLocationMessage(@NonNull MessageModel messageModel) {
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		// Schedule outgoing text message task
@@ -242,14 +246,14 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 
 		// Set file data model again explicitly to enforce that the body of the message is rewritten
 		// and therefore updated.
-		messageModel.setFileData(modelFileData);
+		messageModel.setFileDataModel(modelFileData);
 
 		// Create a new message id if the given message id is null
 		messageModel.setApiMessageId(messageId != null ? messageId.toString() : new MessageId().toString());
 		saveLocalModel(messageModel);
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		// Note that lastUpdate lastUpdate was bumped when the file message was created
@@ -279,7 +283,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		final BallotId ballotId = new BallotId(Utils.hexStringToByteArray(ballotModel.getApiBallotId()));
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		bumpLastUpdate();
@@ -310,7 +314,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		}
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		// Schedule outgoing text message task
@@ -340,14 +344,33 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	 * @param receiptType the type of the delivery receipt
 	 * @param messageIds  the message ids
 	 */
-	public void sendDeliveryReceipt(int receiptType, @NonNull MessageId[] messageIds) {
+	public void sendDeliveryReceipt(int receiptType, @NonNull MessageId[] messageIds, long time) {
 		scheduleTask(
 			new OutgoingContactDeliveryReceiptMessageTask(
-				receiptType, messageIds, new Date().getTime(), contactModel.getIdentity(), serviceManager
+				receiptType, messageIds, time, contactModel.getIdentity(), serviceManager
 			)
 		);
 	}
 
+	/**
+	 * Send an incoming message update to mark the message as read. Note that this is the
+	 * alternative of {@link ContactMessageReceiver#sendDeliveryReceipt(int, MessageId[], long)}
+	 * when no delivery receipt should be sent. This method only schedules the outgoing message
+	 * update if multi device is activated.
+	 */
+	public void sendIncomingMessageUpdateRead(@NonNull Set<MessageId> messageIds, long timestamp) {
+		if (multiDeviceManager.isMultiDeviceActive()) {
+			scheduleTask(
+				new OutboundIncomingContactMessageUpdateReadTask(
+					messageIds,
+					timestamp,
+					contactModel.getIdentity(),
+					serviceManager
+				)
+			);
+		}
+	}
+
 	/**
 	 * Send a voip call offer message to the receiver.
 	 *
@@ -506,30 +529,28 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	@Override
 	@Nullable
 	public Bitmap getNotificationAvatar() {
-		if (avatar == null && contactService != null) {
-			avatar = contactService.getAvatar(contactModel, false);
-		}
-		return avatar;
+		return contactService.getAvatar(contactModel, false);
 	}
 
 	@Override
 	@Nullable
 	public Bitmap getAvatar() {
-		if (avatar == null && contactService != null) {
-			avatar = contactService.getAvatar(contactModel, true, true);
-		}
-		return avatar;
+		return contactService.getAvatar(contactModel, true, true);
 	}
 
 	@Deprecated
 	@Override
 	public int getUniqueId() {
-		return contactService.getUniqueId(contactModel);
+		return contactModel != null
+			? ContactUtil.getUniqueId(contactModel.getIdentity())
+			: 0;
 	}
 
 	@Override
 	public String getUniqueIdString() {
-		return contactService.getUniqueIdString(contactModel);
+		return contactModel != null
+			? ContactUtil.getUniqueIdString(contactModel.getIdentity())
+		    : "";
 	}
 
 	@Override
diff --git a/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java b/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java
index ca7bed75..125726d0 100644
--- a/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java
+++ b/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java
@@ -36,8 +36,10 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ServiceManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.tasks.OutboundIncomingGroupMessageUpdateReadTask;
 import ch.threema.app.tasks.OutgoingFileMessageTask;
 import ch.threema.app.tasks.OutgoingGroupDeleteMessageTask;
 import ch.threema.app.tasks.OutgoingGroupEditMessageTask;
@@ -71,10 +73,10 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	private final GroupModel group;
 	private final GroupService groupService;
-	private Bitmap avatar = null;
 	private final DatabaseServiceNew databaseServiceNew;
 	private final @NonNull ServiceManager serviceManager;
 	private final TaskManager taskManager;
+	private final MultiDeviceManager multiDeviceManager;
 
 	public GroupMessageReceiver(
 		GroupModel group,
@@ -87,6 +89,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 		this.databaseServiceNew = databaseServiceNew;
 		this.serviceManager = serviceManager;
 		this.taskManager = serviceManager.getTaskManager();
+		this.multiDeviceManager = serviceManager.getMultiDeviceManager();
 	}
 
 	@Override
@@ -126,7 +129,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public void createAndSendTextMessage(@NonNull GroupMessageModel messageModel) {
-		Set<String> otherMembers = groupService.getOtherMembers(group);
+		Set<String> otherMembers = groupService.getMembersWithoutUser(group);
 
 		if (otherMembers.isEmpty()) {
 			// In case the recipients set is empty, we are sending the message in a notes group. In
@@ -161,7 +164,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public void createAndSendLocationMessage(@NonNull GroupMessageModel messageModel) {
-		Set<String> otherMembers = groupService.getOtherMembers(group);
+		Set<String> otherMembers = groupService.getMembersWithoutUser(group);
 
 		if (otherMembers.isEmpty()) {
 			// In case the recipients set is empty, we are sending the message in a notes group. In
@@ -216,7 +219,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 		// Set file data model again explicitly to enforce that the body of the message is rewritten
 		// and therefore updated.
-		messageModel.setFileData(modelFileData);
+		messageModel.setFileDataModel(modelFileData);
 
 		// Create a new message id if the given message id is null
 		messageModel.setApiMessageId(messageId != null ? messageId.toString() : new MessageId().toString());
@@ -282,6 +285,24 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 		));
 	}
 
+	/**
+	 * Send an incoming message update to mark the message as read. This method only schedules the
+	 * outgoing group message update if multi device is activated.
+	 */
+	public void sendIncomingMessageUpdateRead(@NonNull Set<MessageId> messageIds, long timestamp) {
+		if (multiDeviceManager.isMultiDeviceActive()) {
+			taskManager.schedule(
+				new OutboundIncomingGroupMessageUpdateReadTask(
+					messageIds,
+					timestamp,
+					group.getApiGroupId(),
+					group.getCreatorIdentity(),
+					serviceManager
+				)
+			);
+		}
+	}
+
 	public void sendEditMessage(int messageModelId, @NonNull String body, @NonNull Date editedAt) {
 		taskManager.schedule(
 			new OutgoingGroupEditMessageTask(
@@ -362,18 +383,12 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public Bitmap getNotificationAvatar() {
-		if (avatar == null && groupService != null) {
-			avatar = groupService.getAvatar(group, false);
-		}
-		return avatar;
+		return groupService.getAvatar(group, false);
 	}
 
 	@Override
 	public Bitmap getAvatar() {
-		if (avatar == null && groupService != null) {
-			avatar = groupService.getAvatar(group, true, true);
-		}
-		return avatar;
+		return groupService.getAvatar(group, true, true);
 	}
 
 	@Override
@@ -401,6 +416,12 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public boolean sendMediaData() {
+        if (multiDeviceManager.isMultiDeviceActive()) {
+            // We need to upload the media in any case (also for notes groups) if multi device is
+            // active. In this case the upload is needed as the message is reflected.
+            return true;
+        }
+
 		// don't really send off group media if user is the only group member left - keep it local
 		String[] groupIdentities = groupService.getGroupIdentities(group);
 		return groupIdentities.length != 1 || !groupService.isGroupMember(group);
diff --git a/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java b/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java
index b778f8ad..f440e26c 100644
--- a/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java
+++ b/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java
@@ -24,10 +24,6 @@ package ch.threema.app.messagereceiver;
 import android.content.Intent;
 import android.graphics.Bitmap;
 
-import androidx.annotation.IntDef;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.sql.SQLException;
@@ -35,6 +31,9 @@ import java.util.Collection;
 import java.util.Date;
 import java.util.List;
 
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.services.MessageService;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.SymmetricEncryptionResult;
diff --git a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt b/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt
index e37ff078..2810f630 100644
--- a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt
+++ b/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt
@@ -23,11 +23,14 @@ package ch.threema.app.multidevice
 
 import android.Manifest
 import android.annotation.TargetApi
+import android.app.Activity
+import android.content.Intent
 import android.content.pm.PackageManager
 import android.os.Build
 import android.os.Bundle
 import android.view.View
 import android.widget.TextView
+import androidx.activity.result.contract.ActivityResultContracts
 import androidx.activity.viewModels
 import androidx.lifecycle.Lifecycle
 import androidx.lifecycle.lifecycleScope
@@ -37,11 +40,10 @@ import androidx.recyclerview.widget.LinearLayoutManager
 import androidx.recyclerview.widget.RecyclerView
 import ch.threema.app.R
 import ch.threema.app.activities.ThreemaToolbarActivity
-import ch.threema.app.services.QRCodeServiceImpl
+import ch.threema.app.multidevice.wizard.LinkNewDeviceWizardActivity
 import ch.threema.app.ui.EmptyRecyclerView
 import ch.threema.app.ui.SilentSwitchCompat
 import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.QRScannerUtil
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
 import com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
@@ -56,19 +58,26 @@ class LinkedDevicesActivity : ThreemaToolbarActivity() {
 
     private val viewModel: LinkedDevicesViewModel by viewModels()
 
-    private val qrScanner = QRScannerUtil.prepareScanner(this) {
-        if (it?.isNotEmpty() == true) {
-            logger.debug("Got device link data: {}", it)
-            viewModel.linkDevice(it, serviceManager.deviceJoinDataCollector)
-        }
-    }
-
     private lateinit var devicesList: EmptyRecyclerView
     private lateinit var devicesAdapter: LinkedDevicesAdapter
 
     private lateinit var onOffButton: SilentSwitchCompat
     private lateinit var linkDeviceButton: ExtendedFloatingActionButton
 
+    private var wizardLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
+        if (result.resultCode == Activity.RESULT_OK) {
+            logger.debug("Device linking success")
+            viewModel.refreshLinkedDevices()
+        } else {
+            // TODO(ANDR-2758): proper error handling
+            if (result.data?.getStringExtra(LinkNewDeviceWizardActivity.ACTIVITY_RESULT_EXTRA_FAILURE_REASON) != null) {
+                logger.debug("Device linking failed")
+            } else {
+                logger.debug("Device linking cancelled (not started)")
+            }
+        }
+    }
+
     override fun getLayoutResource(): Int = R.layout.activity_linked_devices
 
     override fun onCreate(savedInstanceState: Bundle?) {
@@ -93,6 +102,11 @@ class LinkedDevicesActivity : ThreemaToolbarActivity() {
 
         linkDeviceButton = findViewById(R.id.link_device_button)
         linkDeviceButton.setOnClickListener { initiateLinking() }
+        // TODO(ANDR-2717): Remove
+        linkDeviceButton.setOnLongClickListener {
+            viewModel.dropOtherDevices()
+            true
+        }
 
         initDevicesList()
 
@@ -104,7 +118,7 @@ class LinkedDevicesActivity : ThreemaToolbarActivity() {
         super.onRequestPermissionsResult(requestCode, permissions, grantResults)
         if (requestCode == PERMISSION_REQUEST_CAMERA) {
             if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-                scanQr()
+                startLinkingWizard()
             } else if (!this.shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
                 ConfigUtils.showPermissionRationale(this, findViewById(R.id.parent_layout), R.string.permission_camera_qr_required)
             }
@@ -139,16 +153,13 @@ class LinkedDevicesActivity : ThreemaToolbarActivity() {
     private fun initiateLinking() {
         logger.debug("Initiate linking")
         if (ConfigUtils.requestCameraPermissions(this, null, PERMISSION_REQUEST_CAMERA)) {
-            scanQr()
+            startLinkingWizard()
         }
     }
 
-    private fun scanQr() {
-        logger.info("Scan Qr Code")
-        qrScanner.scan(
-            getString(R.string.md_link_device_qr_scan_message),
-            QRCodeServiceImpl.QR_TYPE_ANY
-        )
+    private fun startLinkingWizard() {
+        logger.info("Start linking wizard")
+        wizardLauncher.launch(Intent(this, LinkNewDeviceWizardActivity::class.java))
     }
 
     private fun startObservers() {
diff --git a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt b/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt
index 3b3e052a..f82261a3 100644
--- a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt
+++ b/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt
@@ -25,10 +25,12 @@ import androidx.annotation.AnyThread
 import androidx.lifecycle.ViewModel
 import androidx.lifecycle.viewModelScope
 import ch.threema.app.ThreemaApplication.requireServiceManager
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector
+import ch.threema.app.tasks.TaskCreator
+import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.delay
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.MutableSharedFlow
 import kotlinx.coroutines.flow.MutableStateFlow
@@ -37,6 +39,8 @@ import kotlinx.coroutines.flow.asStateFlow
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.withContext
 
+private val logger = LoggingUtil.getThreemaLogger("LinkedDevicesViewModel")
+
 class LinkedDevicesViewModel : ViewModel() {
 
     private val _isMdActive = MutableStateFlow(false)
@@ -51,15 +55,24 @@ class LinkedDevicesViewModel : ViewModel() {
 
     private val mdManager: MultiDeviceManager by lazy { requireServiceManager().multiDeviceManager }
 
+    private val taskCreator: TaskCreator by lazy { requireServiceManager().taskCreator }
+
     init {
         emitStates()
         collectLatestCloseReason()
     }
 
-    @AnyThread
-    fun linkDevice(deviceJoinOfferUri: String, deviceJoinDataCollector: DeviceJoinDataCollector) {
+    fun refreshLinkedDevices() {
+        logger.info("Refresh linked devices")
+        emitLinkedDevices()
+    }
+
+    // TODO(ANDR-2717): Remove, as this is only used for development purposes
+    fun dropOtherDevices() {
+        logger.warn("Drop all other devices")
         CoroutineScope(Dispatchers.Default).launch {
-            mdManager.linkDevice(deviceJoinOfferUri, deviceJoinDataCollector)
+            mdManager.purge(taskCreator)
+            delay(500)
             emitStates()
         }
     }
@@ -75,14 +88,15 @@ class LinkedDevicesViewModel : ViewModel() {
 
     @AnyThread
     private fun activateMultiDevice() {
+        logger.info("Activate multi device")
         CoroutineScope(Dispatchers.Default).launch {
             val serviceManager = requireServiceManager()
             mdManager.activate(
                 "Android Client", // TODO(ANDR-2487): Should be userselectable (and updateable)
-                serviceManager.taskManager,
                 serviceManager.contactService,
                 serviceManager.userService,
-                serviceManager.forwardSecurityMessageProcessor
+                serviceManager.forwardSecurityMessageProcessor,
+                taskCreator,
             )
             emitStates()
         }
@@ -92,11 +106,10 @@ class LinkedDevicesViewModel : ViewModel() {
     private fun deactivateMultiDevice() {
         CoroutineScope(Dispatchers.Default).launch {
             val serviceManager = requireServiceManager()
-            // TODO(ANDR-2603): Maybe show a spinner while we are waiting for deactivation to complete
             mdManager.deactivate(
-                serviceManager.taskManager,
                 serviceManager.userService,
-                serviceManager.forwardSecurityMessageProcessor
+                serviceManager.forwardSecurityMessageProcessor,
+                taskCreator,
             )
             emitStates()
         }
@@ -118,7 +131,7 @@ class LinkedDevicesViewModel : ViewModel() {
     @AnyThread
     private fun emitLinkedDevices() {
         viewModelScope.launch {
-            _linkedDevices.emit(withContext(Dispatchers.Default) { mdManager.linkedDevices })
+            _linkedDevices.emit(mdManager.loadLinkedDevicesInfo(taskCreator))
         }
     }
 
diff --git a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt b/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt
index f046539b..ae229d0c 100644
--- a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt
+++ b/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt
@@ -24,14 +24,15 @@ package ch.threema.app.multidevice
 
 import androidx.annotation.AnyThread
 import androidx.annotation.WorkerThread
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector
+import ch.threema.app.multidevice.linking.DeviceLinkingDataCollector
+import ch.threema.app.multidevice.linking.DeviceLinkingStatus
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.UserService
+import ch.threema.app.tasks.TaskCreator
 import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
 import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseListener
 import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.taskmanager.TaskManager
 import kotlinx.coroutines.flow.Flow
 
 interface MultiDeviceManager {
@@ -40,8 +41,6 @@ interface MultiDeviceManager {
 
     val isMultiDeviceActive: Boolean
 
-    val linkedDevices: List<String>
-
     val propertiesProvider: MultiDevicePropertyProvider
 
     val socketCloseListener: D2mSocketCloseListener
@@ -52,25 +51,50 @@ interface MultiDeviceManager {
     @WorkerThread
     suspend fun activate(
         deviceLabel: String,
-        taskManager: TaskManager, // TODO(ANDR-2519): Remove
         contactService: ContactService, // TODO(ANDR-2519): remove
         userService: UserService, // TODO(ANDR-2519): remove
         fsMessageProcessor: ForwardSecurityMessageProcessor, // TODO(ANDR-2519): remove
+        taskCreator: TaskCreator,
     )
 
+    /**
+     * Deactivate multi device:
+     * - drop all (including own) devices from device group
+     * - delete dgk
+     * - reconnect to chat server
+     * - reactivate fs TODO(ANDR-2519): Remove fs part
+     *
+     * NOTE: This method should not be invoked from within a task as the mediator will close the
+     * connection when the own device is dropped. This might lead to unexpected behaviour.
+     */
     @WorkerThread
     suspend fun deactivate(
-        taskManager: TaskManager,
         userService: UserService, // TODO(ANDR-2519): remove
-        fsMessageProcessor: ForwardSecurityMessageProcessor // TODO(ANDR-2519): remove
+        fsMessageProcessor: ForwardSecurityMessageProcessor, // TODO(ANDR-2519): remove
+        taskCreator: TaskCreator,
     )
 
     @WorkerThread
     suspend fun setDeviceLabel(deviceLabel: String)
 
-    @AnyThread
+    /**
+     * Start linking of a new device with a device join offer uri.
+     * The returned flow emits the current status of the linking process.
+     * To abort the linking process, the coroutine performing the linking
+     * should be cancelled.
+     */
+    @WorkerThread
     suspend fun linkDevice(
         deviceJoinOfferUri: String,
-        deviceJoinDataCollector: DeviceJoinDataCollector,
-    )
+        taskCreator: TaskCreator,
+    ): Flow<DeviceLinkingStatus>
+
+    /**
+     * Remove all _other_ devices from the device group
+     * TODO(ANDR-2717): Remove, as it is only used for development
+     */
+    suspend fun purge(taskCreator: TaskCreator)
+
+    @AnyThread
+    suspend fun loadLinkedDevicesInfo(taskCreator: TaskCreator): List<String>
 }
diff --git a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt b/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt
index 2781b268..4980c6c5 100644
--- a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt
+++ b/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt
@@ -25,15 +25,15 @@ import android.os.Build
 import androidx.annotation.AnyThread
 import androidx.annotation.WorkerThread
 import ch.threema.app.BuildConfig
-import ch.threema.app.multidevice.linking.DeviceJoinData
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector
+import ch.threema.app.multidevice.linking.DeviceLinkingCancelledException
+import ch.threema.app.multidevice.linking.DeviceLinkingStatus
+import ch.threema.app.multidevice.linking.Failed
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.ServerMessageService
 import ch.threema.app.services.UserService
 import ch.threema.app.stores.PreferenceStore
 import ch.threema.app.stores.PreferenceStoreInterface
-import ch.threema.app.tasks.DeleteAndTerminateFSSessionsTask
-import ch.threema.app.tasks.OutgoingDropDeviceTask
+import ch.threema.app.tasks.TaskCreator
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.base.utils.SecureRandomUtil.generateRandomBytes
 import ch.threema.base.utils.SecureRandomUtil.generateRandomU64
@@ -53,19 +53,22 @@ import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
 import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
 import ch.threema.domain.protocol.multidevice.MultiDeviceProperties
-import ch.threema.domain.taskmanager.TaskManager
 import ch.threema.protobuf.csp.e2e.fs.Terminate
 import ch.threema.storage.models.ServerMessageModel
+import kotlinx.coroutines.CancellationException
+import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.awaitAll
 import kotlinx.coroutines.channels.BufferOverflow
+import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.MutableSharedFlow
+import kotlinx.coroutines.flow.channelFlow
+import kotlinx.coroutines.flow.filterNotNull
 import kotlinx.coroutines.flow.first
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.runBlocking
 import kotlinx.coroutines.withContext
-import org.saltyrtc.client.exceptions.InvalidStateException
 import java.util.Date
 
 private val logger = LoggingUtil.getThreemaLogger("MultiDeviceManagerImpl")
@@ -74,13 +77,13 @@ private val logger = LoggingUtil.getThreemaLogger("MultiDeviceManagerImpl")
  * NOTE: If set to `false` the backup version should be incremented, as
  * `ForwardSecurityStatusType.FORWARD_SECURITY_DISABLED` cannot be restored on older versions.
  */
-private const val IS_FS_SUPPORTED_WITH_MD = true // TODO(ANDR-2519): Remove when md supports fs
+private const val IS_FS_SUPPORTED_WITH_MD = false // TODO(ANDR-2519): Remove when md supports fs
 
 class MultiDeviceManagerImpl(
     private val preferenceStore: PreferenceStoreInterface,
     private val serverMessageService: ServerMessageService,
     private val version: Version,
-) : MultiDeviceManager {
+    ) : MultiDeviceManager {
 
     private var reconnectHandle: ReconnectableServerConnection? = null
 
@@ -129,23 +132,17 @@ class MultiDeviceManagerImpl(
     override val isMultiDeviceActive: Boolean
         get() = properties != null
 
-    private val _linkedDevices = mutableListOf<String>()
-    override val linkedDevices: List<String>
-        get() = _linkedDevices // TODO(ANDR-2484): persist linked devices
-
     override val latestSocketCloseReason = MutableSharedFlow<D2mSocketCloseReason?>(1, 0, BufferOverflow.DROP_OLDEST)
 
     private var serverInfo: InboundD2mMessage.ServerInfo? = null
 
-    private var deactivationOngoing = false
-
     @AnyThread
     override suspend fun activate(
         deviceLabel: String,
-        taskManager: TaskManager,
         contactService: ContactService,
         userService: UserService,
         fsMessageProcessor: ForwardSecurityMessageProcessor,
+        taskCreator: TaskCreator,
     ) {
         logger.info("Activate multi device")
         if (!BuildConfig.MD_ENABLED) {
@@ -162,7 +159,7 @@ class MultiDeviceManagerImpl(
 
         // TODO(ANDR-2519): Remove when md allows fs by default `activate` could then be non-suspending
         if (!IS_FS_SUPPORTED_WITH_MD) {
-            disableForwardSecurity(taskManager, contactService, userService, fsMessageProcessor)
+            disableForwardSecurity(contactService, userService, fsMessageProcessor, taskCreator)
         }
         latestSocketCloseReason.tryEmit(null)
         reconnect()
@@ -170,82 +167,118 @@ class MultiDeviceManagerImpl(
 
     @AnyThread
     override suspend fun deactivate(
-        taskManager: TaskManager,
         userService: UserService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor
+        fsMessageProcessor: ForwardSecurityMessageProcessor,
+        taskCreator: TaskCreator,
     ) {
-        logger.debug("Deactivate multi device")
+        logger.info("Deactivate multi device")
+
+        // 1. Delete device group
+        logger.info("Delete device group")
+        taskCreator.scheduleDeleteDeviceGroupTask().await()
 
-        val mdProperties = properties ?: throw MultiDeviceException("Multi device properties are missing")
+        // 2. Delete dgk
+        logger.info("Delete multi device properties")
+        persistedProperties = null
 
         // TODO(ANDR-2519): Remove when md allows fs by default
+        // 3. Enable FS
         if (!IS_FS_SUPPORTED_WITH_MD) {
             enableForwardSecurity(userService, fsMessageProcessor)
         }
 
+        // 4. Cleanup
         serverInfo = null
-        _linkedDevices.clear()
-
-        deactivationOngoing = true
-
-        taskManager.schedule(OutgoingDropDeviceTask(mdProperties.mediatorDeviceId)).await()
-
-        // TODO(ANDR-2603): Unlink all linked devices (including own device id):
-        //  Ensure all linked devices are removed, then kick own device. When the connection is closed by the mediator with
-        //  a close code "kicked from group" the dgk can be deleted an md deactivated. It
-        //  would be even nicer if we can wait for the drop device ack of the own device
-        //  and then complete the task without being cancelled. This should be possible if the code
-        //  executed after the drop device ack is not cancellable.
-        //  Will it be possible to trigger a reconnect from the task?
-        //  There should probably be a dedicated task, that ensures that _all_ other devices are dropped and only then
-        //  drops the own device. If we are sure every other device is dropped and no device could be linked in the meantime
-        //  the task could still trigger deletion of the properties if connection to the mediator is not possible anymore because
-        //  the own device has already been dropped.
-        //   oh no -> if no connection is possible, no tasks will be executed...
+
+        // 5. Reconnect
+        reconnect()
     }
 
     override suspend fun setDeviceLabel(deviceLabel: String) {
         persistedProperties = persistedProperties!!.withDeviceLabel(deviceLabel)
     }
 
-    @AnyThread
+    @WorkerThread
     override suspend fun linkDevice(
         deviceJoinOfferUri: String,
-        deviceJoinDataCollector: DeviceJoinDataCollector,
-    ) {
+        taskCreator: TaskCreator,
+    ): Flow<DeviceLinkingStatus> {
         logger.debug("Link device: {}", deviceJoinOfferUri)
 
-        _linkedDevices.add(deviceJoinOfferUri)
-        // TODO(ANDR-2484): Actual device linking
+        return channelFlow {
+            try {
+                val linkingCancelledSignal = CompletableDeferred<Unit>()
 
-        return try {
-            val deviceJoinData = withContext(Dispatchers.Default) {
-                collectDeviceJoinData(deviceJoinDataCollector)
-            }
-            deviceJoinData.essentialData.toString().lines().forEach {
-                logger.debug("Essential data: {}", it)
+                val (controller, linkingCompleted) = taskCreator.scheduleDeviceLinkingTask(deviceJoinOfferUri, linkingCancelledSignal)
+
+                launch {
+                    controller.linkingStatus.collect { send(it) }
+                }
+
+                val result = try {
+                    linkingCompleted.await()
+                } catch (e: CancellationException) {
+                    linkingCancelledSignal.complete(Unit)
+                    Result.failure(DeviceLinkingCancelledException())
+                }
+                if (result.isFailure) {
+                    // Cause could for example be a MasterKeyLockedException since the data collector
+                    // initialises some dependencies when data is collected (e.g. ContactService)
+                    // or any other exception that can occur during device join 😉
+                    logger.error("Linking failed due to an exception")
+                    send(Failed(result.exceptionOrNull()))
+                }
+            } catch (e: Exception) {
+                send(Failed(e))
             }
-        } catch (e: Exception) {
-            // This could for example be a MasterKeyLockedException since the data collector
-            // initialises some dependencies when data is collected (e.g. ContactService)
-            logger.error("Linking failed due to an exception", e)
-            // TODO(ANDR-2484): rethrow (dedicated type?) and abort linking
-            // TODO(ANDR-2487): show a message to users that linking failed
         }
     }
 
-    @WorkerThread
-    private fun collectDeviceJoinData(deviceJoinDataCollector: DeviceJoinDataCollector): DeviceJoinData {
-        // TODO(ANDR-2484): Make sure the state of the data cannot change during collection:
-        //  - disconnect from server
-        //  - do not perform any api calls?
-        //  - disconnect web clients
-        //  - stop workers..?
-        //  --> how is this done during a backup?
+    // TODO(ANDR-2717): Remove
+    override suspend fun purge(taskCreator: TaskCreator) {
+        val myDeviceId = (properties ?: throw MultiDeviceException("Multi device properties are missing")).mediatorDeviceId
+        loadLinkedDevicesMediatorIds(taskCreator)
+            .filter { it != myDeviceId }
+            .forEach {
+                taskCreator.scheduleDropDeviceTask(it).await()
+            }
+    }
 
-        val dgk = properties?.keys?.dgk ?: throw InvalidStateException("Multi device is not active")
+    // TODO(ANDR-2717): Use a Proper model (probably `List<DeviceInfo>`) `List<String>` is only used
+    //  for the sake of simplicity during development
+    @AnyThread
+    override suspend fun loadLinkedDevicesInfo(taskCreator: TaskCreator): List<String> {
+        if (!isMultiDeviceActive) {
+            return listOf()
+        }
+        val keys = _properties.filterNotNull().first().keys
+        return withContext(Dispatchers.Default) {
+            val devicesInfo = taskCreator.scheduleGetDevicesInfoTask().await()
+            devicesInfo.augmentedDeviceInfo.values.map { augmentedDeviceInfo ->
+                val deviceInfo = try {
+                    keys.decryptDeviceInfo(augmentedDeviceInfo.encryptedDeviceInfo)
+                } catch (e: Exception) {
+                    logger.error("Could not decrypt device info", e)
+                    // TODO(ANDR-2717): Display as invalid device in devices list
+                    D2dMessage.DeviceInfo.INVALID_DEVICE_INFO
+                }
+                val activityInfo = augmentedDeviceInfo.connectedSince?.let { "Connected since ${Date(it.toLong())}" }
+                    ?: augmentedDeviceInfo.lastDisconnectAt?.let { "Last disconnect: ${Date(it.toLong())}" }
+                listOfNotNull(
+                    deviceInfo.label,
+                    deviceInfo.platform,
+                    "${deviceInfo.platformDetails} (${deviceInfo.appVersion})",
+                    activityInfo
+                ).joinToString("\n")
+            }
+        }
+    }
 
-        return deviceJoinDataCollector.collectData(dgk)
+    @AnyThread
+    private suspend fun loadLinkedDevicesMediatorIds(taskCreator: TaskCreator): Set<DeviceId> {
+        return withContext(Dispatchers.Default) {
+            taskCreator.scheduleGetDevicesInfoTask().await().augmentedDeviceInfo.keys
+        }
     }
 
     private fun onSocketClosed(reason: ServerSocketCloseReason) {
@@ -281,43 +314,15 @@ class MultiDeviceManagerImpl(
     }
 
     private fun handleDeviceDropped() {
-        if (deactivationOngoing) {
-            logger.debug("Device dropped during ongoing md deactivation. Delete properties.")
-            // complete deactivation: delete dgk etc.
-            persistedProperties = null
-            deactivationOngoing = false
-            reconnect()
-        } else {
-            displayConnectionError("Device was dropped")
-        }
+        // TODO(ANDR-2604): The dialog should offer the possibility to use threema without server connection
+        //  (no messages can be sent or received) or to reset the App (see SE-137)
+        displayConnectionError("Device was dropped")
     }
 
     private fun handleDeviceSlotMismatch() {
+        // TODO(ANDR-2604): The dialog should offer the possibility to use threema without server connection
+        //  (no messages can be sent or received) or to reset the App (see SE-137)
         displayConnectionError("Device slot mismatch")
-
-        // TODO(ANDR-2603): Remove
-        deleteMdPropertiesAfterSlotMismatch()
-    }
-
-    private fun deleteMdPropertiesAfterSlotMismatch() {
-        // TODO(ANDR-2603): Remove this, as it is just a temporary workaround for an unsuccessful
-        //  md deactivation.
-        //  If deactivation of md has not been properly completed the client might already be dropped,
-        //  but the properties are not yet deleted.
-        //  In that state it is not possible to login on the server (expected slot mismatch) and therefore
-        //  a drop device cannot be sent (and actually does not have to, since the device has already
-        //  been dropped).
-        //  How to handle that case? How does iOS handle this situation?
-        //  Only if we are sure there are no other remaining devices in the device group md should be deactivated.
-        //  --> could lead to many "Another connection ..." server errors
-        logger.warn("Delete md properties after device slot mismatch")
-        deactivationOngoing = false
-        persistedProperties = null
-
-        // We do not reconnect automatically. After a restart of the app the csp connection will be used
-        // which should work. This way we could display an error to the user which will allow to react somehow
-        // before the connection is changed. Or there might even be a button "reconnect without md" in the
-        // shown dialog
     }
 
     /**
@@ -326,7 +331,7 @@ class MultiDeviceManagerImpl(
     private fun displayConnectionError(msg: String) {
         // TODO(ANDR-2604): Show actual dialog to user
         // TODO(ANDR-2604): Use string resources instead of string
-        // TODO(ANDR-2604): Only show error if a reconnect ist not allowed (see `D2mCloseCode#isReconnectAllowed()`)
+        // TODO(ANDR-2604): Only show error if a reconnect is not allowed (see `D2mCloseCode#isReconnectAllowed()`)
         logger.warn("Reconnect is not allowed: {}", msg)
 
         val message = ServerMessageModel(msg, ServerMessageModel.TYPE_ERROR)
@@ -335,6 +340,7 @@ class MultiDeviceManagerImpl(
 
     private fun reconnect() {
         CoroutineScope(Dispatchers.Default).launch {
+            logger.info("Reconnect server connection")
             reconnectHandle?.reconnect() ?: logger.error("Reconnect handle is null")
         }
     }
@@ -342,18 +348,14 @@ class MultiDeviceManagerImpl(
     // TODO(ANDR-2519): Remove when md allows fs
     @AnyThread
     private suspend fun disableForwardSecurity(
-        taskManager: TaskManager,
         contactService: ContactService,
         userService: UserService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor
+        fsMessageProcessor: ForwardSecurityMessageProcessor,
+        taskCreator: TaskCreator,
     ) {
         withContext(Dispatchers.IO) {
             updateFeatureMask(userService, false)
-            terminateAllForwardSecuritySessions(
-                taskManager,
-                contactService,
-                fsMessageProcessor
-            )
+            terminateAllForwardSecuritySessions(contactService, taskCreator)
             fsMessageProcessor.setForwardSecurityEnabled(false)
         }
     }
@@ -377,15 +379,12 @@ class MultiDeviceManagerImpl(
     // TODO(ANDR-2519): Remove when md allows fs
     @WorkerThread
     private suspend fun terminateAllForwardSecuritySessions(
-        taskManager: TaskManager,
         contactService: ContactService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor
+        taskCreator: TaskCreator,
     ) {
         contactService.all.map {
-            taskManager.schedule(
-                DeleteAndTerminateFSSessionsTask(
-                    fsMessageProcessor, it, Terminate.Cause.DISABLED_BY_LOCAL
-                )
+            taskCreator.scheduleDeleteAndTerminateFSSessionsTaskAsync(
+                it, Terminate.Cause.DISABLED_BY_LOCAL
             )
         }.awaitAll()
     }
@@ -433,7 +432,7 @@ class MultiDeviceManagerImpl(
         return D2dMessage.DeviceInfo(
             D2dMessage.DeviceInfo.Platform.ANDROID,
             platformDetails,
-            version.version,
+            version.versionNumber,
             deviceLabel
         ).also { logger.trace("Device info created: {}", it) }
     }
diff --git a/app/src/main/java/ch/threema/app/multidevice/linking/DeviceJoinDataCollector.kt b/app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingDataCollector.kt
similarity index 88%
rename from app/src/main/java/ch/threema/app/multidevice/linking/DeviceJoinDataCollector.kt
rename to app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingDataCollector.kt
index 19cb441c..caffab51 100644
--- a/app/src/main/java/ch/threema/app/multidevice/linking/DeviceJoinDataCollector.kt
+++ b/app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingDataCollector.kt
@@ -23,14 +23,18 @@ package ch.threema.app.multidevice.linking
 
 import android.graphics.Bitmap
 import androidx.annotation.WorkerThread
+import ch.threema.app.BuildConfig
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.DeadlineListService
 import ch.threema.app.services.license.LicenseServiceUser
 import ch.threema.app.utils.BitmapUtil
 import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.ContactUtil
 import ch.threema.app.utils.ConversationUtil.getConversationUid
+import ch.threema.base.crypto.NonceScope
 import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.protobuf.Common.BlobData
@@ -85,9 +89,9 @@ import ch.threema.storage.models.GroupModel
 import com.google.protobuf.ByteString
 import java.nio.ByteBuffer
 
-private val logger = LoggingUtil.getThreemaLogger("DeviceJoinDataCollector")
+private val logger = LoggingUtil.getThreemaLogger("DeviceLinkingDataCollector")
 
-data class DeviceJoinData(val blobs: Sequence<BlobData>, val essentialData: EssentialData)
+data class DeviceLinkingData(val blobs: Sequence<BlobData>, val essentialData: EssentialData)
 
 class BlobDataProvider (private val blobId: ByteArray?, private val dataProvider: () -> ByteArray?) {
     /**
@@ -110,7 +114,7 @@ class BlobDataProvider (private val blobId: ByteArray?, private val dataProvider
     }
 }
 
-class DeviceJoinDataCollector(
+class DeviceLinkingDataCollector(
     serviceManager: ServiceManager
 ) {
     private val identityStore by lazy { serviceManager.identityStore }
@@ -132,7 +136,7 @@ class DeviceJoinDataCollector(
     private val licenseService by lazy { serviceManager.licenseService }
 
     @WorkerThread
-    fun collectData(dgk: ByteArray): DeviceJoinData {
+    fun collectData(dgk: ByteArray): DeviceLinkingData {
         val blobDataProviders = mutableListOf<BlobDataProvider>()
 
         val data = essentialData {
@@ -146,7 +150,9 @@ class DeviceJoinDataCollector(
 
             logger.trace("Collect user profile")
             val (userProfileBlobProvider, userProfileData) = collectUserProfile()
-            blobDataProviders.add(userProfileBlobProvider)
+            userProfileBlobProvider?.let {
+                blobDataProviders.add(it)
+            }
             this.userProfile = userProfileData
 
             logger.trace("Collect settings")
@@ -166,15 +172,19 @@ class DeviceJoinDataCollector(
                 this.groups += group
             }
 
-            logger.trace("Collect distribution lists")
-            this.distributionLists += collectDistributionLists(conversationsStats)
+            if (BuildConfig.MD_SYNC_DISTRIBUTION_LISTS) {
+                logger.trace("Collect distribution lists")
+                this.distributionLists += collectDistributionLists(conversationsStats)
+            } else {
+                logger.trace("Skip collection of distribution lists")
+                this.distributionLists.clear()
+            }
 
             logger.trace("Collect csp nonce hashes")
             this.cspHashedNonces += collectCspNonceHashes()
 
-
-            // TODO(ANDR-2632): At the moment we do not store any d2d nonces
-            this.d2DHashedNonces.clear()
+            logger.trace("Collect d2d nonce hashes")
+            this.d2DHashedNonces += collectD2dNonceHashes()
 
             // work
             if (ConfigUtils.isWorkBuild()) {
@@ -192,7 +202,7 @@ class DeviceJoinDataCollector(
             .asSequence()
             .mapNotNull { it.get() }
 
-        return DeviceJoinData(blobsSequence, data)
+        return DeviceLinkingData(blobsSequence, data)
     }
 
     private fun collectIdentityData(): IdentityData {
@@ -204,24 +214,26 @@ class DeviceJoinDataCollector(
         }
     }
 
-    private fun collectUserProfile(): Pair<BlobDataProvider, MdD2DSync.UserProfile> {
-        return collectUserProfilePicture().let { (blobDataProvider, avatar) ->
-            blobDataProvider to userProfile {
+    private fun collectUserProfile(): Pair<BlobDataProvider?, MdD2DSync.UserProfile> {
+        return collectUserProfilePicture().let { profilePictureData ->
+            profilePictureData?.first to userProfile {
                 nickname = identityStore.publicNickname
-                profilePicture = avatar
+                profilePictureData?.second?.let {
+                    profilePicture = it
+                }
                 profilePictureShareWith = collectProfilePictureShareWith()
                 identityLinks = collectIdentityLinks()
             }
         }
     }
 
-    private fun collectUserProfilePicture(): Pair<BlobDataProvider, DeltaImage> {
-        val profilePictureData = contactService.updatedProfilePictureUploadData
+    private fun collectUserProfilePicture(): Pair<BlobDataProvider, DeltaImage>? {
+        val profilePictureData = userService.uploadUserProfilePictureOrGetPreviousUploadData()
 
         val hasProfilePicture = profilePictureData.blobId != null
             && !profilePictureData.blobId.contentEquals(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)
 
-        val profilePicture = if (hasProfilePicture) {
+        return if (hasProfilePicture) {
             val blobMeta = blob {
                 id = profilePictureData.blobId.toByteString()
                 nonce = ProtocolDefines.CONTACT_PHOTO_NONCE.toByteString()
@@ -229,19 +241,19 @@ class DeviceJoinDataCollector(
                 uploadedAt = profilePictureData.uploadedAt
             }
 
-            deltaImage { updated = image {
+            val profilePicture = deltaImage { updated = image {
                 type = Image.Type.JPEG
                 blob = blobMeta
             } }
-        } else {
-            deltaImage { removed = unit {} }
-        }
 
-        val blobDataProvider = BlobDataProvider(profilePictureData.blobId) {
-            profilePictureData.bitmapArray
-        }
+            val blobDataProvider = BlobDataProvider(profilePictureData.blobId) {
+                profilePictureData.bitmapArray
+            }
 
-        return blobDataProvider to profilePicture
+            blobDataProvider to profilePicture
+        } else {
+            null
+        }
     }
 
     private fun collectProfilePictureShareWith(): ProfilePictureShareWith {
@@ -251,7 +263,7 @@ class DeviceJoinDataCollector(
             when (policy.policy) {
                 ContactService.ProfilePictureSharePolicy.Policy.NOBODY -> nobody = unit {}
                 ContactService.ProfilePictureSharePolicy.Policy.EVERYONE -> everyone = unit {}
-                ContactService.ProfilePictureSharePolicy.Policy.SOME -> {
+                ContactService.ProfilePictureSharePolicy.Policy.ALLOW_LIST -> {
                     allowList = identities { identities += policy.allowedIdentities }
                 }
             }
@@ -341,18 +353,16 @@ class DeviceJoinDataCollector(
     private data class ConversationStats(
         val isArchived: Boolean,
         val isPinned: Boolean,
-        val lastMessageCreatedAt: Long?
     )
 
     private fun collectConversationsStats(): Map<String, ConversationStats> {
         val notArchived = conversationService.getAll(true).associate {
-            it.uid to ConversationStats(false, it.isPinTagged, it.latestMessage?.createdAt?.time)
+            it.uid to ConversationStats(false, it.isPinTagged)
         }
         val archived = conversationService.getArchived(null).associate {
             it.uid to ConversationStats(
                 isArchived = true,
-                isPinned = false,
-                lastMessageCreatedAt = it.latestMessage?.createdAt?.time)
+                isPinned = false)
         }
         return notArchived + archived
     }
@@ -390,9 +400,9 @@ class DeviceJoinDataCollector(
                 ContactModel.AcquaintanceLevel.DIRECT -> Contact.AcquaintanceLevel.DIRECT
             }
             activityState = when (contactModel.state) {
-                ContactModel.State.ACTIVE -> Contact.ActivityState.ACTIVE
-                ContactModel.State.INACTIVE -> Contact.ActivityState.INACTIVE
-                ContactModel.State.INVALID -> Contact.ActivityState.INVALID
+                IdentityState.ACTIVE -> Contact.ActivityState.ACTIVE
+                IdentityState.INACTIVE -> Contact.ActivityState.INACTIVE
+                IdentityState.INVALID -> Contact.ActivityState.INVALID
                 else -> throw IllegalStateException("Contact ${contactModel.identity} has missing state")
             }
             featureMask = contactModel.featureMask
@@ -449,9 +459,7 @@ class DeviceJoinDataCollector(
 
         val augmentedContact = augmentedContact {
             this.contact = contact
-            conversationStats?.lastMessageCreatedAt?.let {
-                this.lastUpdateAt = it
-            }
+            contactModel.lastUpdate?.let { this.lastUpdateAt = it.time }
         }
 
         return blobDataProviders to augmentedContact
@@ -497,20 +505,20 @@ class DeviceJoinDataCollector(
     }
 
     private fun ContactModel.getUniqueId(): String {
-        return contactService.getUniqueIdString(this)
+        return ContactUtil.getUniqueIdString(identity)
     }
 
     private fun collectContactDefinedProfilePicture(contactModel: ContactModel): Pair<BlobDataProvider, DeltaImage>? {
-        return if (fileService.hasContactPhotoFile(contactModel.identity)) {
-            createJpegBlobAssets { fileService.getContactPhoto(contactModel.identity) }
+        return if (fileService.hasContactDefinedProfilePicture(contactModel.identity)) {
+            createJpegBlobAssets { fileService.getContactDefinedProfilePicture(contactModel.identity) }
         } else {
             null
         }
     }
 
     private fun collectUserDefinedProfilePicture(contactModel: ContactModel): Pair<BlobDataProvider, DeltaImage>? {
-        return if (fileService.hasContactAvatarFile(contactModel.identity)) {
-            createJpegBlobAssets { fileService.getContactAvatar(contactModel.identity) }
+        return if (fileService.hasUserDefinedProfilePicture(contactModel.identity)) {
+            createJpegBlobAssets { fileService.getUserDefinedProfilePicture(contactModel.identity) }
         } else {
             null
         }
@@ -541,9 +549,10 @@ class DeviceJoinDataCollector(
     }
 
     private fun collectGroups(conversationsStats: Map<String, ConversationStats>): List<Pair<List<BlobDataProvider>, AugmentedGroup>> {
-        return groupService.all.map {
-            mapToAugmentedGroup(it, conversationsStats)
-        }.also { logger.trace("{} groups", it.size) }
+        return groupService.all
+            .filter { !it.isDeleted }
+            .map { mapToAugmentedGroup(it, conversationsStats) }
+            .also { logger.trace("{} groups", it.size) }
     }
 
     private fun mapToAugmentedGroup(groupModel: GroupModel, conversationsStats: Map<String, ConversationStats>): Pair<List<BlobDataProvider>, AugmentedGroup> {
@@ -558,13 +567,7 @@ class DeviceJoinDataCollector(
             }
             name = groupModel.name ?: ""
             createdAt = groupModel.createdAt.time
-            userState = if (groupService.isGroupMember(groupModel)) {
-                UserState.MEMBER
-            } else {
-                // TODO(ANDR-2676)
-                //  at the moment we cannot distinguish between KICKED and LEFT
-                UserState.KICKED
-            }
+            userState = collectUserState(groupModel)
             notificationTriggerPolicyOverride = collectGroupNotificationTriggerPolicyOverride(groupModel)
             notificationSoundPolicyOverride = collectGroupNotificationSoundPolicyOverride(groupModel)
             collectGroupAvatar(groupModel)?.let { (groupAvatarBlobDataProvider, image) ->
@@ -588,8 +591,9 @@ class DeviceJoinDataCollector(
 
         val augmentedGroup = augmentedGroup {
             this.group = group
-            this.lastUpdateAt = conversationStats?.lastMessageCreatedAt
-                ?: groupModel.createdAt.time
+            groupModel.lastUpdate?.let {
+                this.lastUpdateAt = it.time
+            }
         }
         return blobDataProviders to augmentedGroup
     }
@@ -602,6 +606,16 @@ class DeviceJoinDataCollector(
         }
     }
 
+    private fun collectUserState(groupModel: GroupModel) = when (groupModel.userState) {
+        GroupModel.UserState.MEMBER -> UserState.MEMBER
+        GroupModel.UserState.KICKED -> UserState.KICKED
+        GroupModel.UserState.LEFT -> UserState.LEFT
+        null -> {
+            logger.warn("User state of group model is null; using member as default")
+            UserState.MEMBER
+        }
+    }
+
     /**
      * @return The provided group's member identities NOT including the user itself
      */
@@ -695,8 +709,9 @@ class DeviceJoinDataCollector(
         }?.let {
             augmentedDistributionList {
                 this.distributionList = it
-                this.lastUpdateAt = conversationStats?.lastMessageCreatedAt
-                    ?: distributionListModel.createdAt.time
+                distributionListModel.lastUpdate?.let {
+                    this.lastUpdateAt = it.time
+                }
             }
         }
     }
@@ -718,11 +733,17 @@ class DeviceJoinDataCollector(
     }
 
     private fun collectCspNonceHashes(): Set<ByteString> {
-        return nonceFactory.allHashedNonces.map { it.toByteString() }
+        return nonceFactory.getAllHashedNonces(NonceScope.CSP).map { it.bytes.toByteString() }
             .toSet()
             .also { logger.trace("{} csp nonce hashes", it.size) }
     }
 
+    private fun collectD2dNonceHashes(): Set<ByteString> {
+        return nonceFactory.getAllHashedNonces(NonceScope.D2D).map { it.bytes.toByteString() }
+            .toSet()
+            .also { logger.trace("{} d2d nonce hashes", it.size) }
+    }
+
     private fun collectWorkCredentials(): MdD2DSync.ThreemaWorkCredentials? {
         val credentials = licenseService.let {
             if (it is LicenseServiceUser) {
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingCspMessageSubTask.kt b/app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingException.kt
similarity index 71%
rename from app/src/main/java/ch/threema/app/processors/IncomingCspMessageSubTask.kt
rename to app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingException.kt
index 4af08ba6..e75c81e1 100644
--- a/app/src/main/java/ch/threema/app/processors/IncomingCspMessageSubTask.kt
+++ b/app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingException.kt
@@ -19,16 +19,13 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors
+package ch.threema.app.multidevice.linking
 
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.tasks.ActiveComposableTask
+import ch.threema.base.ThreemaException
 
-abstract class IncomingCspMessageSubTask(protected val serviceManager: ServiceManager) :
-    ActiveComposableTask<ReceiveStepsResult> {
+class DeviceLinkingException: ThreemaException {
+    constructor(msg: String) : super(msg)
+    constructor(msg: String, throwable: Throwable) : super(msg, throwable)
 }
 
-enum class ReceiveStepsResult {
-    SUCCESS,
-    DISCARD,
-}
+class DeviceLinkingCancelledException : ThreemaException("Linking cancelled")
diff --git a/app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingStatus.kt b/app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingStatus.kt
new file mode 100644
index 00000000..d54779ee
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingStatus.kt
@@ -0,0 +1,56 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.linking
+
+import ch.threema.base.utils.toHexString
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
+
+sealed interface DeviceLinkingStatus
+
+class Connected(
+    private val rph: ByteArray
+) : DeviceLinkingStatus {
+    private val _rphConfirmedSignal = CompletableDeferred<Unit>()
+    val rendezvousPathConfirmedSignal: Deferred<Unit> = _rphConfirmedSignal
+
+    val emojiIndices: Triple<Int, Int, Int> by lazy { Triple(
+        (rph[0].toUByte() % 128U).toInt(),
+        (rph[1].toUByte() % 128U).toInt(),
+        (rph[2].toUByte() % 128U).toInt()
+    ) }
+
+    fun confirmRendezvousPath() {
+        _rphConfirmedSignal.complete(Unit)
+    }
+
+    // TODO(ANDR-2487): Remove if not needed
+    fun declineRendezvousPath() {
+        _rphConfirmedSignal.completeExceptionally(
+            DeviceLinkingException("Rendezvous path declined (rph=${rph.toHexString()})")
+        )
+    }
+}
+
+data class Failed(val t: Throwable?) : DeviceLinkingStatus
+
+class Completed : DeviceLinkingStatus
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.java b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceConnectingFragment.kt
similarity index 52%
rename from domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.java
rename to app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceConnectingFragment.kt
index f86e0caa..9521e244 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.java
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceConnectingFragment.kt
@@ -4,7 +4,7 @@
  *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
  *
  * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
+ * Copyright (c) 2023-2024 Threema GmbH
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Affero General Public License, version 3,
@@ -19,32 +19,27 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.domain.protocol.csp.messages.voip;
+package ch.threema.app.multidevice.wizard
 
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import ch.threema.app.R
 
-public abstract class VoipMessage extends AbstractMessage {
+class LinkNewDeviceConnectingFragment: LinkNewDeviceFragment() {
 
-	public VoipMessage() {
-		super();
-	}
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View? {
+        return inflater.inflate(R.layout.fragment_link_new_device_progress, container, false)
+    }
 
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
 
-	@Override
-	public boolean flagShortLivedServerQueuing() {
-		// Should be set for all VoIP messages except for the hangup message
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
+        viewModel.linkDevice()
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceEmojiSelectionView.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceEmojiSelectionView.kt
new file mode 100644
index 00000000..c11d8659
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceEmojiSelectionView.kt
@@ -0,0 +1,112 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.content.res.ColorStateList
+import android.util.AttributeSet
+import android.view.LayoutInflater
+import android.widget.ImageView
+import ch.threema.app.R
+import ch.threema.app.utils.ConfigUtils
+import ch.threema.base.utils.LoggingUtil
+import com.google.android.material.card.MaterialCardView
+
+private val logger = LoggingUtil.getThreemaLogger("LinkNewDeviceEmojiSelectionView")
+
+/**
+ * A button-like view that displays a sequence of three rendezvous emojis
+ */
+class LinkNewDeviceEmojiSelectionView: MaterialCardView {
+
+    constructor(context: Context) : super(context)
+
+    constructor(context: Context, attrs: AttributeSet) : super(context, attrs)
+
+    constructor(context: Context, attrs: AttributeSet, defStyleAttr: Int) : super(context, attrs, defStyleAttr)
+
+    private val emojiViews = arrayOfNulls<ImageView>(3)
+    private val rendezvousEmojis = RendezvousEmojis()
+
+    init {
+        LayoutInflater.from(context).inflate(R.layout.view_emoji_selection, this, true)
+
+        setCardBackgroundColor(ColorStateList.valueOf(
+            ConfigUtils.getColorFromAttribute(
+                context, R.attr.colorPrimaryContainer
+            )
+        ))
+        strokeWidth = 0
+        cardElevation = 0F
+
+        emojiViews[0] = findViewById(R.id.emoji1)
+        emojiViews[1] = findViewById(R.id.emoji2)
+        emojiViews[2] = findViewById(R.id.emoji3)
+    }
+
+    /**
+     * Display the provided emojis in this view.
+     */
+    fun setEmojis(emojiIndexes: IntArray) {
+        if (emojiIndexes.size == emojiViews.size) {
+            repeat(emojiViews.size) { i ->
+                fillEmojiViewContents(emojiViews[i], emojiIndexes[i])
+            }
+        } else {
+            logger.debug("Invalid number of emoji indexes")
+        }
+    }
+
+    /**
+     * Display a set of random emojis in this view. The emojis are not unique so the sequence may contain duplicates
+     */
+    fun setRandomEmojis() {
+        repeat(emojiViews.size) { i ->
+            val emojiIndex = (0 until rendezvousEmojis.emojiList.size).random()
+            fillEmojiViewContents(emojiViews[i], emojiIndex)
+        }
+    }
+
+    private fun fillEmojiViewContents(emojiView : ImageView?, emojiIndex: Int) {
+        emojiView?.let {
+            it.setImageResource(getEmojiResourceID(emojiIndex))
+            it.contentDescription = resources.getString(getEmojiStringID(emojiIndex))
+        }
+    }
+
+    @SuppressLint("DiscouragedApi")
+    fun getEmojiResourceID(emojiIndex: Int) : Int {
+        return resources.getIdentifier(
+            "ic_emoji_" + rendezvousEmojis.emojiList[emojiIndex].lowercase(),
+            "drawable",
+            context.packageName)
+    }
+
+    @SuppressLint("DiscouragedApi")
+    fun getEmojiStringID(emojiIndex: Int) : Int {
+        return resources.getIdentifier(
+            "rendezvous_emoji_" + rendezvousEmojis.emojiList[emojiIndex],
+            "string",
+            context.packageName)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFailureFragment.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFailureFragment.kt
new file mode 100644
index 00000000..26fda45b
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFailureFragment.kt
@@ -0,0 +1,44 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.os.Bundle
+import android.view.View
+import android.widget.ImageView
+import android.widget.TextView
+import ch.threema.app.R
+import com.google.android.material.button.MaterialButton
+
+class LinkNewDeviceFailureFragment: LinkNewDeviceMessageFragment() {
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+
+        view.findViewById<ImageView>(R.id.emoji).setImageResource(R.drawable.ic_error)
+        view.findViewById<ImageView>(R.id.emoji).setColorFilter(resources.getColor(R.color.material_red))
+        view.findViewById<TextView>(R.id.title).text = getString(R.string.device_linking_failed)
+        view.findViewById<TextView>(R.id.body).text = getString(R.string.device_linking_failed_explain, viewModel.failureReason)
+        view.findViewById<MaterialButton>(R.id.button).text = getString(R.string.close)
+        view.findViewById<MaterialButton>(R.id.button).setOnClickListener {
+            viewModel.switchToFragment(null)
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFragment.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFragment.kt
new file mode 100644
index 00000000..25650e18
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFragment.kt
@@ -0,0 +1,36 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.os.Bundle
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.activityViewModels
+
+open class LinkNewDeviceFragment : Fragment() {
+    val viewModel: LinkNewDeviceWizardViewModel by activityViewModels()
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        viewModel.setCurrentFragment(this)
+
+        super.onCreate(savedInstanceState)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceLinkingProgressFragment.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceLinkingProgressFragment.kt
new file mode 100644
index 00000000..9fb3f367
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceLinkingProgressFragment.kt
@@ -0,0 +1,55 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.animation.LayoutTransition
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.LinearLayout
+import android.widget.TextView
+import ch.threema.app.R
+
+class LinkNewDeviceLinkingProgressFragment: LinkNewDeviceFragment() {
+
+    private lateinit var bodyTextView : TextView
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View? {
+        return inflater.inflate(R.layout.fragment_link_new_device_progress, container, false)
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+
+        bodyTextView = view.findViewById(R.id.body)
+        view.findViewById<LinearLayout>(R.id.explain_layout).layoutTransition.enableTransitionType(LayoutTransition.CHANGING)
+
+        viewModel.linkingProgressStringRes.observe(viewLifecycleOwner) { stringRes ->
+            bodyTextView.text = getString(stringRes)
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceMessageFragment.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceMessageFragment.kt
new file mode 100644
index 00000000..6589c4e6
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceMessageFragment.kt
@@ -0,0 +1,38 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import ch.threema.app.R
+
+abstract class LinkNewDeviceMessageFragment: LinkNewDeviceFragment() {
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View? {
+        return inflater.inflate(R.layout.fragment_link_new_device_message, container, false)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceScanQrFragment.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceScanQrFragment.kt
new file mode 100644
index 00000000..92955614
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceScanQrFragment.kt
@@ -0,0 +1,224 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.annotation.SuppressLint
+import android.os.Bundle
+import android.util.Size
+import android.view.LayoutInflater
+import android.view.MotionEvent
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import android.widget.Toast
+import androidx.annotation.UiThread
+import androidx.camera.core.Camera
+import androidx.camera.core.CameraSelector
+import androidx.camera.core.FocusMeteringAction
+import androidx.camera.core.ImageAnalysis
+import androidx.camera.core.ImageCapture
+import androidx.camera.core.Preview
+import androidx.camera.core.resolutionselector.ResolutionSelector
+import androidx.camera.core.resolutionselector.ResolutionStrategy
+import androidx.camera.lifecycle.ProcessCameraProvider
+import androidx.camera.view.PreviewView
+import androidx.core.content.ContextCompat
+import ch.threema.app.R
+import ch.threema.app.camera.DecodeQRCodeState
+import ch.threema.app.camera.QRCodeAnalyzer
+import ch.threema.app.ui.LongToast
+import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.RuntimeUtil
+import ch.threema.app.utils.SoundUtil
+import ch.threema.base.utils.LoggingUtil
+import com.google.android.material.elevation.ElevationOverlayProvider
+import java.util.concurrent.ExecutorService
+import java.util.concurrent.Executors
+
+private val logger = LoggingUtil.getThreemaLogger("LinkNewDeviceScanQrFragment")
+
+class LinkNewDeviceScanQrFragment: LinkNewDeviceFragment() {
+    private lateinit var cameraExecutor: ExecutorService
+
+    private lateinit var cameraPreview: PreviewView
+    private lateinit var cameraPreviewContainer: View
+
+    private var camera: Camera? = null
+    private var preview: Preview? = null
+    private var imageCapture: ImageCapture? = null
+    private var imageAnalyzer: ImageAnalysis? = null
+    private var cameraProvider: ProcessCameraProvider? = null
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View? {
+        return inflater.inflate(R.layout.fragment_link_new_device_scan_qr, container, false)
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+
+        cameraExecutor = Executors.newSingleThreadExecutor()
+        cameraPreview = view.findViewById(R.id.camera_preview)
+        cameraPreviewContainer = view.findViewById(R.id.camera_preview_container)
+
+        // tint viewfinder frame manually as regular views do not support elevation
+        val elevationOverlayProvider = ElevationOverlayProvider(requireContext())
+        val backgroundColor = elevationOverlayProvider.compositeOverlayIfNeeded(
+            ConfigUtils.getColorFromAttribute(activity, R.attr.colorSurface),
+            resources.getDimension(R.dimen.bottomsheet_elevation)
+        )
+        view.findViewById<View>(R.id.border_frame_top).setBackgroundColor(backgroundColor)
+        view.findViewById<View>(R.id.border_frame_bottom).setBackgroundColor(backgroundColor)
+        view.findViewById<View>(R.id.border_frame_left).setBackgroundColor(backgroundColor)
+        view.findViewById<View>(R.id.border_frame_right).setBackgroundColor(backgroundColor)
+
+        view.findViewById<TextView>(R.id.body)?.text = getString(R.string.scan_qr_code_explain, getString(R.string.app_name))
+
+        // Wait for the views to be properly laid out
+        cameraPreview.post {
+            setUpCamera()
+        }
+    }
+
+    private fun setUpCamera() {
+        val cameraProviderFuture = ProcessCameraProvider.getInstance(requireContext())
+        cameraProviderFuture.addListener({
+            cameraProvider = cameraProviderFuture.get()
+            // Build and bind the camera use cases
+            bindCameraUseCases()
+        }, ContextCompat.getMainExecutor(requireContext()))
+    }
+
+    @SuppressLint("ClickableViewAccessibility")
+    private fun bindCameraUseCases() {
+        val lensFacing = if (cameraProvider?.hasCamera(CameraSelector.DEFAULT_BACK_CAMERA) == true) CameraSelector.LENS_FACING_BACK else
+            (if (cameraProvider?.hasCamera(CameraSelector.DEFAULT_FRONT_CAMERA) == true) CameraSelector.LENS_FACING_FRONT else CameraSelector.LENS_FACING_UNKNOWN)
+
+        if (lensFacing == CameraSelector.LENS_FACING_UNKNOWN) {
+            LongToast.makeText(requireContext(), R.string.no_camera_installed, Toast.LENGTH_SHORT).show()
+            logger.info("Back and front camera are unavailable")
+            viewModel.switchToFragment(null)
+            return
+        }
+
+        val cameraSelector = CameraSelector.Builder().requireLensFacing(lensFacing).build()
+        val rotation = cameraPreview.display?.rotation ?: 0
+        val resolution = Size(720, 1280)
+        val resolutionSelector = ResolutionSelector.Builder()
+            .setResolutionStrategy(ResolutionStrategy(resolution, ResolutionStrategy.FALLBACK_RULE_CLOSEST_HIGHER_THEN_LOWER))
+            .build()
+        val cameraProvider = cameraProvider
+            ?: throw IllegalStateException("Camera initialization failed.")
+
+        preview = Preview.Builder()
+            .setResolutionSelector(resolutionSelector)
+            .setTargetRotation(rotation)
+            .build()
+
+        imageCapture = ImageCapture.Builder()
+            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
+            .setResolutionSelector(resolutionSelector)
+            .setTargetRotation(rotation)
+            .build()
+
+        imageAnalyzer = ImageAnalysis.Builder()
+            .setResolutionSelector(resolutionSelector)
+            .setTargetRotation(rotation)
+            .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
+            .build()
+            .also {
+                it.setAnalyzer(cameraExecutor, QRCodeAnalyzer { decodeQRCodeState: DecodeQRCodeState ->
+                    when (decodeQRCodeState) {
+                        is DecodeQRCodeState.SUCCESS -> {
+                            logger.debug("Decoder Success")
+                            val qrCodeData = decodeQRCodeState.qrCode
+                            it.clearAnalyzer()
+                            RuntimeUtil.runOnUiThread {
+                                returnData(qrCodeData, true)
+                            }
+                        }
+
+                        else -> {
+                            logger.debug("Decoder Error")
+                            it.clearAnalyzer()
+                            RuntimeUtil.runOnUiThread {
+                                viewModel.failureReason = "Decoder error"
+                                returnData(null, false)
+                            }
+                        }
+                    }
+                })
+            }
+
+        try {
+            // Must unbind the use-cases before rebinding them
+            cameraProvider.unbindAll()
+
+            camera = cameraProvider.bindToLifecycle(
+                this, cameraSelector, preview, imageCapture, imageAnalyzer)
+
+            // Attach the viewfinder's surface provider to preview use case
+            preview?.setSurfaceProvider(cameraPreview.surfaceProvider)
+
+            val point = cameraPreview.meteringPointFactory.createPoint(
+                cameraPreviewContainer.left + cameraPreviewContainer.width / 2.0f,
+                cameraPreviewContainer.top + cameraPreviewContainer.height / 2.0f)
+            camera?.cameraControl?.startFocusAndMetering(FocusMeteringAction.Builder(point).build())
+        } catch (e: Exception) {
+            logger.error("Use case binding failed", e)
+            returnData(null, false)
+        }
+
+        cameraPreviewContainer.setOnTouchListener { _: View, motionEvent: MotionEvent ->
+            when (motionEvent.action) {
+                MotionEvent.ACTION_DOWN -> true
+                MotionEvent.ACTION_UP -> {
+                    camera?.cameraControl?.startFocusAndMetering(
+                        FocusMeteringAction.Builder(
+                            cameraPreview.meteringPointFactory.createPoint(
+                                motionEvent.x, motionEvent.y
+                            )
+                        ).build()
+                    )
+                    true
+                }
+                else -> false
+            }
+        }
+    }
+
+    @UiThread
+    private fun returnData(qrCodeData: String?, success: Boolean) {
+        cameraProvider?.unbindAll()
+
+        if (success && qrCodeData != null) {
+            SoundUtil.play(R.raw.qrscanner_beep)
+            viewModel.qrScanResult = qrCodeData
+            viewModel.switchToFragment(LinkNewDeviceConnectingFragment::class.java)
+        } else {
+            viewModel.showFailure(getString(R.string.qr_code_scan_error))
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceSuccessFragment.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceSuccessFragment.kt
new file mode 100644
index 00000000..95390e81
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceSuccessFragment.kt
@@ -0,0 +1,43 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.os.Bundle
+import android.view.View
+import android.widget.ImageView
+import android.widget.TextView
+import ch.threema.app.R
+import com.google.android.material.button.MaterialButton
+
+class LinkNewDeviceSuccessFragment: LinkNewDeviceMessageFragment() {
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+
+        view.findViewById<ImageView>(R.id.emoji).setImageResource(R.drawable.emoji_party_popper)
+        view.findViewById<TextView>(R.id.title).text = getString(R.string.device_linked_successfully)
+        view.findViewById<TextView>(R.id.body).text = getString(R.string.device_linked_successfully_explain, getString(R.string.app_name))
+        view.findViewById<MaterialButton>(R.id.button).text = getString(R.string.label_continue)
+        view.findViewById<MaterialButton>(R.id.button).setOnClickListener {
+            viewModel.switchToFragment(null)
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceVerifyFragment.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceVerifyFragment.kt
new file mode 100644
index 00000000..c054b649
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceVerifyFragment.kt
@@ -0,0 +1,106 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.animation.LayoutTransition
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import ch.threema.app.R
+import com.google.android.material.button.MaterialButton
+
+class LinkNewDeviceVerifyFragment: LinkNewDeviceFragment() {
+    private val emojiSelectionViews = arrayOfNulls<LinkNewDeviceEmojiSelectionView>(3)
+
+    private val onValidSelectionListener = View.OnClickListener {
+        returnData(true)
+    }
+
+    private val onInvalidSelectionListener = View.OnClickListener {
+        setupEmojiSelectionViews()
+    }
+
+    private val onNoMatchListener = View.OnClickListener {
+        returnData(false)
+    }
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View? {
+        return inflater.inflate(R.layout.fragment_link_new_device_verify, container, false)
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+
+        view.findViewById<TextView>(R.id.info_text).text = getString(R.string.trust_new_device_info, getString(R.string.app_name))
+
+        emojiSelectionViews[0] = view.findViewById(R.id.emoji_selection1)
+        emojiSelectionViews[1] = view.findViewById(R.id.emoji_selection2)
+        emojiSelectionViews[2] = view.findViewById(R.id.emoji_selection3)
+
+        emojiSelectionViews[0]?.layoutTransition?.enableTransitionType(LayoutTransition.CHANGING)
+        emojiSelectionViews[1]?.layoutTransition?.enableTransitionType(LayoutTransition.CHANGING)
+        emojiSelectionViews[2]?.layoutTransition?.enableTransitionType(LayoutTransition.CHANGING)
+
+        view.findViewById<MaterialButton>(R.id.no_match_button).setOnClickListener(onNoMatchListener)
+
+        setupEmojiSelectionViews()
+    }
+
+    private fun setupEmojiSelectionViews() {
+        val validViewIndex = (emojiSelectionViews.indices).random()
+
+        repeat(emojiSelectionViews.size) { i ->
+            emojiSelectionViews[i]?.let {
+                if (i == validViewIndex) {
+                    it.setEmojis(intArrayOf(
+                        viewModel.connected.emojiIndices.first,
+                        viewModel.connected.emojiIndices.second,
+                        viewModel.connected.emojiIndices.third))
+                    it.setOnClickListener(onValidSelectionListener)
+                } else {
+                    it.setRandomEmojis()
+                    it.setOnClickListener(onInvalidSelectionListener)
+                }
+            }
+        }
+    }
+
+    private fun returnData(success: Boolean) {
+        try {
+            if (success) {
+                viewModel.connected.confirmRendezvousPath()
+                viewModel.showLinkingProgress()
+            } else {
+                viewModel.connected.declineRendezvousPath()
+                viewModel.showFailure(getString(R.string.verification_failed))
+            }
+        } catch (e: Exception) {
+            viewModel.showFailure("Error confirming or declining rendezvous path")
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardActivity.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardActivity.kt
new file mode 100644
index 00000000..1f6d82e7
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardActivity.kt
@@ -0,0 +1,175 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import android.animation.Animator
+import android.animation.ObjectAnimator
+import android.app.Activity
+import android.content.Intent
+import android.graphics.drawable.Drawable
+import android.os.Bundle
+import android.view.View
+import androidx.activity.viewModels
+import androidx.annotation.UiThread
+import androidx.constraintlayout.widget.ConstraintLayout
+import androidx.fragment.app.Fragment
+import ch.threema.app.R
+import ch.threema.app.activities.ThreemaActivity
+import ch.threema.app.utils.ConfigUtils
+import ch.threema.base.utils.LoggingUtil
+import com.google.android.material.bottomsheet.BottomSheetBehavior
+import com.google.android.material.bottomsheet.BottomSheetBehavior.BottomSheetCallback
+import com.google.android.material.shape.MaterialShapeDrawable
+
+private val logger = LoggingUtil.getThreemaLogger("LinkNewDeviceWizardActivity")
+
+class LinkNewDeviceWizardActivity : ThreemaActivity() {
+    companion object {
+        const val ACTIVITY_RESULT_EXTRA_FAILURE_REASON: String = "activityResultFailureReason"
+    }
+
+    private var currentFragment: Fragment? = null
+    private val viewModel: LinkNewDeviceWizardViewModel by viewModels()
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+
+        viewModel.currentFragment.observe(this) { fragment ->
+            currentFragment = fragment
+        }
+
+        viewModel.nextFragment.observe(this) { newFragmentClass ->
+            switchFragment(currentFragment, newFragmentClass)
+        }
+
+        setContentView(R.layout.activity_link_new_device_bottom_sheet)
+
+        window.statusBarColor = resources.getColor(R.color.attach_status_bar_color_collapsed)
+
+        val bottomSheetLayout = findViewById<ConstraintLayout?>(R.id.bottom_sheet)
+        if (bottomSheetLayout != null) {
+            val bottomSheetBehavior = BottomSheetBehavior.from(bottomSheetLayout)
+            val targetPeekHeight =
+                resources.displayMetrics.heightPixels - ConfigUtils.getActionBarSize(this)
+            ObjectAnimator.ofInt(bottomSheetBehavior, "peekHeight", targetPeekHeight)
+                .apply {
+                    duration = 200
+                    addListener(object : Animator.AnimatorListener {
+                        override fun onAnimationStart(animation: Animator) {}
+                        override fun onAnimationEnd(animation: Animator) {
+                            if (savedInstanceState == null) {
+                                // start with qr scanner
+                                switchFragment(null, LinkNewDeviceScanQrFragment::class.java)
+                            }
+                        }
+                        override fun onAnimationCancel(animation: Animator) {}
+                        override fun onAnimationRepeat(animation: Animator) {}
+                    }
+                    )
+                    start()
+                }
+            bottomSheetBehavior.addBottomSheetCallback(object : BottomSheetCallback() {
+                override fun onStateChanged(bottomSheet: View, newState: Int) {
+                    when (newState) {
+                        BottomSheetBehavior.STATE_HIDDEN -> finishWithResult()
+
+                        BottomSheetBehavior.STATE_EXPANDED -> {
+                            findViewById<View>(R.id.drag_handle).visibility = View.INVISIBLE
+                            val background: Drawable = bottomSheetLayout.background
+                            if (background is MaterialShapeDrawable) {
+                                window.statusBarColor =
+                                    background.resolvedTintColor
+                            } else {
+                                window.statusBarColor =
+                                    resources.getColor(R.color.attach_status_bar_color_expanded)
+                            }
+                        }
+
+                        BottomSheetBehavior.STATE_SETTLING -> findViewById<View>(R.id.drag_handle).visibility =
+                            View.VISIBLE
+
+                        BottomSheetBehavior.STATE_DRAGGING -> window.statusBarColor =
+                            resources.getColor(R.color.attach_status_bar_color_collapsed)
+
+                        else -> {}
+                    }
+                }
+
+                override fun onSlide(bottomSheet: View, slideOffset: Float) {
+                    // we don't care about sliding events
+                }
+            })
+        }
+    }
+
+    /**
+     * Remove previous fragment and show next fragment with animation
+     * If there is no more fragment to show, finish the activity signalling success
+     */
+    @UiThread
+    private fun switchFragment(previousFragment: Fragment?, nextFragmentClass: Class<out Fragment>?) {
+        if (previousFragment == null) {
+            supportFragmentManager.beginTransaction()
+                .setCustomAnimations(
+                    R.anim.fast_fade_in,
+                    R.anim.fast_fade_out,
+                    R.anim.fast_fade_in,
+                    R.anim.fast_fade_out
+                )
+                .add(R.id.fragment_container, LinkNewDeviceScanQrFragment::class.java, null, null)
+                .commit()
+        } else if (nextFragmentClass == null) {
+            // no more fragment to show - quit activity
+            finishWithResult()
+        } else {
+            supportFragmentManager.beginTransaction()
+                .setCustomAnimations(
+                    R.anim.slide_in_right_short,
+                    R.anim.slide_out_left_short,
+                    R.anim.slide_in_left_short,
+                    R.anim.slide_out_right_short
+                )
+                .remove(previousFragment)
+                .add(R.id.fragment_container, nextFragmentClass, null, null)
+                .commitNow()
+        }
+    }
+
+    private fun finishWithResult() {
+        if (viewModel.success) {
+            logger.debug("Finishing after successful linking")
+            setResult(Activity.RESULT_OK)
+        } else {
+            logger.debug("Finishing after cancel or linking error. Reason = {}", viewModel.failureReason ?: "user canceled")
+            val resultIntent = Intent().putExtra(ACTIVITY_RESULT_EXTRA_FAILURE_REASON, viewModel.failureReason)
+            setResult(Activity.RESULT_CANCELED, resultIntent)
+        }
+        finish()
+    }
+
+    override fun finish() {
+        viewModel.cancelAllJobs()
+
+        super.finish()
+        overridePendingTransition(R.anim.fast_fade_in, R.anim.fast_fade_out)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardViewModel.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardViewModel.kt
new file mode 100644
index 00000000..505d07e2
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardViewModel.kt
@@ -0,0 +1,156 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+import androidx.annotation.UiThread
+import androidx.fragment.app.Fragment
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.MutableLiveData
+import androidx.lifecycle.ViewModel
+import ch.threema.app.R
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.multidevice.linking.Completed
+import ch.threema.app.multidevice.linking.Connected
+import ch.threema.app.multidevice.linking.DeviceLinkingStatus
+import ch.threema.app.multidevice.linking.Failed
+import ch.threema.app.tasks.TaskCreator
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.withContext
+
+class LinkNewDeviceWizardViewModel : ViewModel() {
+    private val multiDeviceManager: MultiDeviceManager by lazy { ThreemaApplication.requireServiceManager().multiDeviceManager }
+    private val taskCreator: TaskCreator by lazy { ThreemaApplication.requireServiceManager().taskCreator }
+
+    private var linkingJob: Job? = null
+    private var sendDataJob: Job? = null
+    private var continueOnNewDeviceJob: Job? = null
+
+    private val mutableCurrentFragment = MutableLiveData<Fragment>()
+    private val mutableNextFragment = MutableLiveData<Class<out Fragment>?>()
+    private val mutableSendingDataText = MutableLiveData<Int>()
+
+    val linkingProgressStringRes: LiveData<Int> get() = mutableSendingDataText
+    val currentFragment: LiveData<Fragment> get() = mutableCurrentFragment
+    val nextFragment: LiveData<Class<out Fragment>?> get() = mutableNextFragment
+
+    var qrScanResult: String? = null
+    var failureReason: String? = null
+    var success: Boolean = false
+    lateinit var connected: Connected
+
+    fun setCurrentFragment(fragment: Fragment) {
+        mutableCurrentFragment.value = fragment
+    }
+
+    fun switchToFragment(newFragmentClass : Class<out Fragment>?) {
+        mutableNextFragment.value = newFragmentClass
+    }
+
+    fun linkDevice() {
+        linkingJob = CoroutineScope(Dispatchers.Default).launch {
+            multiDeviceManager.linkDevice(qrScanResult!!, taskCreator).collect {
+                handleLinkingStatus(it)
+            }
+        }
+    }
+
+    private suspend fun handleLinkingStatus(deviceLinkingStatus: DeviceLinkingStatus) {
+        withContext(Dispatchers.Main) {
+            try {
+                when (deviceLinkingStatus) {
+                    is Connected -> {
+                        connected = deviceLinkingStatus
+                        try {
+                            switchToFragment(LinkNewDeviceVerifyFragment::class.java)
+                        } catch (e: Exception) {
+                            showFailure("Unable to show challenge")
+                        }
+                    }
+
+                    is Completed -> {
+                        showSuccess()
+                    }
+
+                    is Failed -> {
+                        showFailure(ThreemaApplication.getAppContext().getString(R.string.connection_error))
+                    }
+                }
+            } catch (e: Exception) {
+                showFailure("Exception while linking device: " + e.message)
+            }
+        }
+    }
+
+    fun cancelAllJobs() {
+        linkingJob?.cancel()
+        sendDataJob?.cancel()
+        continueOnNewDeviceJob?.cancel()
+    }
+
+
+    /**
+     * Show linking progress
+     */
+    @UiThread
+    fun showLinkingProgress() {
+        switchToFragment(LinkNewDeviceLinkingProgressFragment::class.java)
+
+        sendDataJob = CoroutineScope(Dispatchers.IO).launch {
+            delay(5000)
+            withContext(Dispatchers.Main) {
+                mutableSendingDataText.value = R.string.sending_data
+                continueOnNewDevice()
+            }
+        }
+    }
+
+    private fun continueOnNewDevice() {
+        continueOnNewDeviceJob = CoroutineScope(Dispatchers.IO).launch {
+            delay(10000)
+            withContext(Dispatchers.Main) {
+                mutableSendingDataText.value = R.string.continue_on_new_device
+            }
+        }
+    }
+
+    /**
+     * Show success screen
+     */
+    private fun showSuccess() {
+        cancelAllJobs()
+        success = true
+        switchToFragment(LinkNewDeviceSuccessFragment::class.java)
+    }
+
+    /**
+     * Show failure screen
+     */
+    fun showFailure(reason: String?) {
+        failureReason = reason
+        switchToFragment(LinkNewDeviceFailureFragment::class.java)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/multidevice/wizard/RendezvousEmojis.kt b/app/src/main/java/ch/threema/app/multidevice/wizard/RendezvousEmojis.kt
new file mode 100644
index 00000000..77efe157
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/multidevice/wizard/RendezvousEmojis.kt
@@ -0,0 +1,155 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.multidevice.wizard
+
+class RendezvousEmojis {
+    val emojiList = arrayOf(
+        "1F435",
+        "1F436",
+        "1F429",
+        "1F98A",
+        "1F408_200D_2B1B",
+        "1F434",
+        "1F9AC",
+        "1F42E",
+        "1F437",
+        "1F42A",
+        "1F992",
+        "1F418",
+        "1F42D",
+        "1F430",
+        "1F43F_FE0F",
+        "1F43C",
+        "1F998",
+        "1F414",
+        "1F54A_FE0F",
+        "1F986",
+        "1F9A2",
+        "1F989",
+        "1F9A4",
+        "1FAB6",
+        "1F9A9",
+        "1F438",
+        "1F40B",
+        "1F42C",
+        "1F9AD",
+        "1F41F",
+        "1F41A",
+        "1FAB2",
+        "1F578_FE0F",
+        "1F3F5_FE0F",
+        "1F33B",
+        "1F332",
+        "1F33F",
+        "2618_FE0F",
+        "1F349",
+        "1F34B",
+        "1F34E",
+        "1F352",
+        "1F353",
+        "1FAD0",
+        "1F345",
+        "1F951",
+        "1F955",
+        "1F966",
+        "1F344",
+        "1FAD8",
+        "1F9C2",
+        "1F36A",
+        "1F36B",
+        "2615",
+        "1F9CA",
+        "1F962",
+        "1F5FA_FE0F",
+        "1F30B",
+        "1F3D5_FE0F",
+        "1F3DD_FE0F",
+        "1F3DB_FE0F",
+        "1F682",
+        "1F69A",
+        "1F69C",
+        "1F6E4_FE0F",
+        "2693",
+        "1F6F0_FE0F",
+        "1F680",
+        "1F319",
+        "2600_FE0F",
+        "2B50",
+        "1F308",
+        "2602_FE0F",
+        "2744_FE0F",
+        "2603_FE0F",
+        "1F525",
+        "1F4A7",
+        "2728",
+        "1F388",
+        "1F380",
+        "1F947",
+        "1F3C0",
+        "1F3D0",
+        "1F3B3",
+        "1F3D3",
+        "26F3",
+        "1F3AF",
+        "1F579_FE0F",
+        "1F9E9",
+        "1F9F8",
+        "2660_FE0F",
+        "2665_FE0F",
+        "1F457",
+        "1F451",
+        "1F514",
+        "1F3B7",
+        "1F3B8",
+        "1F5A8_FE0F",
+        "1F4F8",
+        "1F56F_FE0F",
+        "1F4D6",
+        "1F4E6",
+        "1F4EE",
+        "1F4DD",
+        "1F4BC",
+        "1F4CB",
+        "1F512",
+        "1F511",
+        "2692_FE0F",
+        "1FA83",
+        "2696_FE0F",
+        "1F517",
+        "1FA9D",
+        "1F52C",
+        "1FA91",
+        "1F6BD",
+        "1F9F9",
+        "1FAA3",
+        "1FAE7",
+        "26AB",
+        "1F7E8",
+        "25B6_FE0F",
+        "1F4F6",
+        "1F4A5",
+        "1F4AC",
+        "1F4AB",
+        "1F440",
+        "1F463"
+    )
+}
diff --git a/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java b/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java
index 29089f41..1c73a0de 100644
--- a/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java
+++ b/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java
@@ -21,9 +21,6 @@
 
 package ch.threema.app.preference;
 
-import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_AUTOSTART;
-import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_POWERMANAGER;
-
 import android.Manifest;
 import android.annotation.SuppressLint;
 import android.app.Activity;
@@ -34,7 +31,6 @@ import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.content.pm.PackageManager;
 import android.net.Uri;
-import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
@@ -42,9 +38,21 @@ import android.text.TextUtils;
 import android.view.View;
 import android.widget.Toast;
 
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+
+import org.slf4j.Logger;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 import androidx.activity.result.ActivityResultLauncher;
 import androidx.activity.result.contract.ActivityResultContracts;
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.core.content.ContextCompat;
 import androidx.core.content.IntentCompat;
 import androidx.core.content.PackageManagerCompat;
@@ -56,23 +64,13 @@ import androidx.preference.Preference.SummaryProvider;
 import androidx.preference.PreferenceCategory;
 import androidx.preference.PreferenceScreen;
 import androidx.preference.TwoStatePreference;
-
-import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-
-import org.slf4j.Logger;
-
-import java.io.File;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 import ch.threema.app.BuildConfig;
 import ch.threema.app.BuildFlavor;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.DisableBatteryOptimizationsActivity;
+import ch.threema.app.asynctasks.SendToSupportBackgroundTask;
+import ch.threema.app.asynctasks.SendToSupportResult;
 import ch.threema.app.dialogs.CancelableHorizontalProgressDialog;
 import ch.threema.app.dialogs.GenericAlertDialog;
 import ch.threema.app.dialogs.GenericProgressDialog;
@@ -81,7 +79,7 @@ import ch.threema.app.dialogs.TextEntryDialog;
 import ch.threema.app.listeners.ConversationListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
-import ch.threema.app.messagereceiver.MessageReceiver;
+import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.push.PushService;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeadlineListService;
@@ -105,11 +103,17 @@ import ch.threema.app.utils.PushUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShareUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.activities.WebRTCDebugActivity;
 import ch.threema.app.webclient.activities.WebDiagnosticsActivity;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.logging.backend.DebugLogFileBackend;
-import ch.threema.storage.models.ContactModel;
+
+import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_AUTOSTART;
+import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_POWERMANAGER;
 
 public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment implements GenericAlertDialog.DialogClickListener, SharedPreferences.OnSharedPreferenceChangeListener, TextEntryDialog.TextEntryDialogClickListener, CancelableHorizontalProgressDialog.ProgressDialogClickListener {
     private static final Logger logger = LoggingUtil.getThreemaLogger("SettingsAdvancedOptionsFragment");
@@ -135,22 +139,26 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
     private TwoStatePreference threemaPushTwoStatePreference;
     private TwoStatePreference messageLogPreference, ipv6Preferences;
 
-    private WallpaperService wallpaperService;
-    private SharedPreferences sharedPreferences;
-    private PreferenceService preferenceService;
-    private RingtoneService ringtoneService;
-    private NotificationService notificationService;
-    private FileService fileService;
-    private UserService userService;
-    private LifetimeService lifetimeService;
-    private DeadlineListService mutedChatsListService, mentionOnlyChatsListService;
-    private MessageService messageService;
-    private ContactService contactService;
-    private View fragmentView;
+	private WallpaperService wallpaperService;
+	private SharedPreferences sharedPreferences;
+	private PreferenceService preferenceService;
+	private RingtoneService ringtoneService;
+	private NotificationService notificationService;
+	private FileService fileService;
+	private UserService userService;
+	private LifetimeService lifetimeService;
+	private DeadlineListService mutedChatsListService, mentionOnlyChatsListService;
+	private MessageService messageService;
+	private ContactService contactService;
+	private APIConnector apiConnector;
+	private ContactModelRepository contactModelRepository;
+	private View fragmentView;
 
     private BroadcastReceiver pushTokenResetBroadcastReceiver;
 
-    private boolean pushServicesInstalled;
+	private @Nullable BackgroundExecutor backgroundExecutor;
+
+	private boolean pushServicesInstalled;
 
     /**
      * This activity result launcher is needed to open the settings to disable hibernation.
@@ -566,40 +574,44 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
         return this.checkInstances();
     }
 
-    protected boolean checkInstances() {
-        return TestUtil.required(
-            this.wallpaperService,
-            this.lifetimeService,
-            this.preferenceService,
-            this.fileService,
-            this.userService,
-            this.ringtoneService,
-            this.mutedChatsListService,
-            this.messageService,
-            this.contactService
-        );
-    }
-
-    protected void instantiate() {
-        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-        if (serviceManager != null) {
-            try {
-                this.wallpaperService = serviceManager.getWallpaperService();
-                this.lifetimeService = serviceManager.getLifetimeService();
-                this.preferenceService = serviceManager.getPreferenceService();
-                this.fileService = serviceManager.getFileService();
-                this.userService = serviceManager.getUserService();
-                this.ringtoneService = serviceManager.getRingtoneService();
-                this.mutedChatsListService = serviceManager.getMutedChatsListService();
-                this.mentionOnlyChatsListService = serviceManager.getMentionOnlyChatsListService();
-                this.messageService = serviceManager.getMessageService();
-                this.contactService = serviceManager.getContactService();
-                this.notificationService = serviceManager.getNotificationService();
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        }
-    }
+	protected boolean checkInstances() {
+		return TestUtil.required(
+			this.wallpaperService,
+			this.lifetimeService,
+			this.preferenceService,
+			this.fileService,
+			this.userService,
+			this.ringtoneService,
+			this.mutedChatsListService,
+			this.messageService,
+			this.contactService,
+			this.apiConnector,
+			this.contactModelRepository
+		);
+	}
+
+	protected void instantiate() {
+		ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+		if (serviceManager != null) {
+			try {
+				this.wallpaperService = serviceManager.getWallpaperService();
+				this.lifetimeService = serviceManager.getLifetimeService();
+				this.preferenceService = serviceManager.getPreferenceService();
+				this.fileService = serviceManager.getFileService();
+				this.userService = serviceManager.getUserService();
+				this.ringtoneService = serviceManager.getRingtoneService();
+				this.mutedChatsListService = serviceManager.getMutedChatsListService();
+				this.mentionOnlyChatsListService = serviceManager.getMentionOnlyChatsListService();
+				this.messageService = serviceManager.getMessageService();
+				this.contactService = serviceManager.getContactService();
+				this.notificationService = serviceManager.getNotificationService();
+				this.apiConnector = serviceManager.getAPIConnector();
+				this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+			} catch (Exception e) {
+				logger.error("Exception", e);
+			}
+		}
+	}
 
     @Override
     public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
@@ -723,24 +735,32 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
     }
 
 
-    @SuppressLint("StaticFieldLeak")
-    public void sendLogFileToSupport(final String caption) {
-        new AsyncTask<Void, Void, Exception>() {
-
-            @Override
-            protected void onPreExecute() {
-                GenericProgressDialog.newInstance(R.string.preparing_messages, R.string.please_wait).show(getParentFragmentManager(), DIALOG_TAG_SENDLOG);
-            }
-
-            @Override
-            protected Exception doInBackground(Void... params) {
-                File zipFile = DebugLogFileBackend.getZipFile(fileService);
-
-                try {
-                    final ContactModel contactModel = contactService.getOrCreateByIdentity(
-                        THREEMA_SUPPORT_IDENTITY, true);
-
-                    MessageReceiver receiver = contactService.createReceiver(contactModel);
+	@SuppressLint("StaticFieldLeak")
+	public void sendLogFileToSupport(final String caption) {
+		final Context context = getContext();
+		if (context == null) {
+			logger.warn("Cannot send logfile as the context is null");
+			return;
+		}
+
+		SendToSupportBackgroundTask sendLogFileTask = new SendToSupportBackgroundTask(
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			context
+		) {
+			@Override
+			public void onBefore() {
+				GenericProgressDialog.newInstance(R.string.preparing_messages, R.string.please_wait).show(getParentFragmentManager(), DIALOG_TAG_SENDLOG);
+			}
+
+			@NonNull
+			@Override
+			public SendToSupportResult onSupportAvailable(@NonNull ContactModel contactModel) {
+				File zipFile = DebugLogFileBackend.getZipFile(fileService);
+
+				try {
+					ContactMessageReceiver receiver = contactService.createReceiver(contactModel);
 
                     messageService.sendText(caption +
                         "\n-- \n" +
@@ -759,31 +779,39 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
                                 RuntimeUtil.runOnUiThread(() -> Toast.makeText(getContext(), R.string.an_error_occurred_during_send, Toast.LENGTH_LONG).show());
                             }
 
-                            @Override
-                            public void onCompleted() {
-                                RuntimeUtil.runOnUiThread(() -> Toast.makeText(getContext(), R.string.message_sent, Toast.LENGTH_LONG).show());
-                            }
-                        });
-                } catch (Exception e) {
-                    return e;
-                }
-                return null;
-            }
-
-            @Override
-            protected void onPostExecute(Exception exception) {
-                if (isAdded()) {
-                    DialogUtil.dismissDialog(getParentFragmentManager(), DIALOG_TAG_SENDLOG, true);
-
-                    if (exception != null) {
-                        Toast.makeText(requireActivity().getApplicationContext(), R.string.an_error_occurred, Toast.LENGTH_LONG).show();
-                    } else {
-                        Toast.makeText(requireActivity().getApplicationContext(), R.string.message_sent, Toast.LENGTH_LONG).show();
-                    }
-                }
-            }
-        }.execute();
-    }
+							@Override
+							public void onCompleted() {
+								RuntimeUtil.runOnUiThread(() -> Toast.makeText(getContext(), R.string.message_sent, Toast.LENGTH_LONG).show());
+							}
+						});
+				} catch (Exception e) {
+					logger.error("Could not send log file");
+					return SendToSupportResult.FAILED;
+				}
+
+				return SendToSupportResult.SUCCESS;
+			}
+
+			@Override
+			public void onFinished(@NonNull SendToSupportResult result) {
+				if (isAdded()) {
+					DialogUtil.dismissDialog(getParentFragmentManager(), DIALOG_TAG_SENDLOG, true);
+
+					if (result == SendToSupportResult.SUCCESS) {
+						Toast.makeText(requireActivity().getApplicationContext(), R.string.message_sent, Toast.LENGTH_LONG).show();
+					} else {
+						Toast.makeText(requireActivity().getApplicationContext(), R.string.an_error_occurred, Toast.LENGTH_LONG).show();
+					}
+				}
+			}
+		};
+
+		if (backgroundExecutor == null) {
+			backgroundExecutor = new BackgroundExecutor();
+		}
+
+		backgroundExecutor.execute(sendLogFileTask);
+	}
 
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
diff --git a/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java b/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java
index b41b12a0..aeb1f2d9 100644
--- a/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java
+++ b/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java
@@ -23,6 +23,7 @@ package ch.threema.app.preference;
 
 import android.annotation.SuppressLint;
 import android.app.Activity;
+import android.content.Intent;
 import android.os.AsyncTask;
 import android.widget.Toast;
 
@@ -38,7 +39,12 @@ import androidx.preference.Preference;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.PolicyViolation;
+import ch.threema.app.debug.PatternLibraryActivity;
 import ch.threema.app.exceptions.InvalidEntryException;
 import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.managers.ServiceManager;
@@ -50,7 +56,9 @@ import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.models.MessageId;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.TextMessage;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData;
 import ch.threema.storage.DatabaseServiceNew;
@@ -61,265 +69,296 @@ import static ch.threema.storage.models.data.status.VoipStatusDataModel.NO_CALL_
 
 @SuppressWarnings("unused")
 public class SettingsDeveloperFragment extends ThreemaPreferenceFragment {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("SettingsDeveloperFragment");
-
-	// Test identities.
-	private static final String TEST_IDENTITY_1 = "ADDRTCNX";
-	private static final String TEST_IDENTITY_2 = "H6AXSHKC";
-
-	private PreferenceService preferenceService;
-	private DatabaseServiceNew databaseService;
-	private ContactService contactService;
-	private MessageService messageService;
-	private UserService userService;
-	private MultiDeviceManager multiDeviceManager;
-
-	@Override
-	public void initializePreferences() {
-		if (!requiredInstances()) {
-			return;
-		}
-
-		initMdSetting();
-		initConversationSetting();
-
-		// Generate VoIP messages
-		final Preference generateVoipPreference = getPref(getResources().getString(R.string.preferences__generate_voip_messages));
-		generateVoipPreference.setSummary("Create the test identity " + TEST_IDENTITY_1
-			+ " and add all possible VoIP messages to that conversation.");
-		generateVoipPreference.setOnPreferenceClickListener(this::generateVoipMessages);
-
-		// Generate test quotes
-		final Preference generateRecursiveQuote = getPref(getResources().getString(R.string.preferences__generate_test_quotes));
-		generateRecursiveQuote.setSummary("Create the test identities " + TEST_IDENTITY_1 + " and "
-			+ TEST_IDENTITY_2 + " and add some test quotes.");
-		generateRecursiveQuote.setOnPreferenceClickListener(this::generateTestQuotes);
-
-		// Remove developer menu
-		final Preference removeMenuPreference = getPref(getResources().getString(R.string.preferences__remove_menu));
-		removeMenuPreference.setSummary("Hide the developer menu from the settings.");
-		removeMenuPreference.setOnPreferenceClickListener(this::hideDeveloperMenu);
-	}
-
-	@UiThread
-	private void showOk(CharSequence msg) {
-		Toast.makeText(this.getContext(), msg, Toast.LENGTH_LONG).show();
-	}
-
-	@UiThread
-	private void showError(Exception e) {
-		logger.error("Exception", e);
-		Toast.makeText(this.getContext(), e.toString(), Toast.LENGTH_LONG).show();
-	}
-
-	@WorkerThread
-	private ContactModel createTestContact(
-		String identity,
-		String firstName,
-		String lastName
-	) throws EntryAlreadyExistsException, InvalidEntryException, PolicyViolationException {
-		ContactModel contact = contactService.getByIdentity(identity);
-		if (contact == null) {
-			contact = contactService.createContactByIdentity(identity, true);
-		}
-		contact.setName(firstName, lastName);
-		databaseService.getContactModelFactory().createOrUpdate(contact);
-		return contact;
-	}
-
-	@UiThread
-	@SuppressLint("StaticFieldLeak")
-	private boolean generateVoipMessages(Preference preference) {
-
-		// Pojo for holding test data.
-		class VoipMessage {
-			final VoipStatusDataModel dataModel;
-			final String description;
-			VoipMessage(VoipStatusDataModel dataModel, String description) {
-				this.dataModel = dataModel;
-				this.description = description;
-			}
-		}
-
-		// Test messages
-		final VoipMessage[] testMessages = new VoipMessage[]{
-			new VoipMessage(VoipStatusDataModel.createMissed(NO_CALL_ID, null), "missed"),
-			new VoipMessage(VoipStatusDataModel.createFinished(NO_CALL_ID,42), "finished"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.UNKNOWN), "rejected (unknown)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.BUSY), "rejected (busy)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.TIMEOUT), "rejected (timeout)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.REJECTED), "rejected (rejected)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.DISABLED), "rejected (disabled)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, (byte) 99), "rejected (invalid reason code)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID,null), "rejected (null reason code)"),
-			new VoipMessage(VoipStatusDataModel.createAborted(NO_CALL_ID), "aborted"),
-		};
-
-		new AsyncTask<Void, Void, Exception>() {
-			@Override
-			@Nullable protected Exception doInBackground(Void... voids) {
-				try {
-					// Create test identity
-					final ContactModel contact = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
-
-					// Create test messages
-					final ContactMessageReceiver receiver = contactService.createReceiver(contact);
-					messageService.createStatusMessage("Creating test messages...", receiver);
-					for (boolean isOutbox : new boolean[]{true, false}) {
-						for (VoipMessage msg : testMessages) {
-							final String text = (isOutbox ? "Outgoing " : "Incoming ") + msg.description;
-							messageService.createStatusMessage(text, receiver);
-							messageService.createVoipStatus(msg.dataModel, receiver, isOutbox, true);
-						}
-					}
-
-					return null;
-				} catch (Exception e) {
-					return e;
-				}
-			}
-
-			@Override
-			protected void onPostExecute(@Nullable Exception e) {
-				if (e == null) {
-					showOk("Test messages created!");
-				} else {
-					showError(e);
-				}
-			}
-		}.execute();
-		return true;
-	}
-
-	@UiThread
-	@SuppressLint("StaticFieldLeak")
-	private boolean generateTestQuotes(Preference preference) {
-		new AsyncTask<Void, Void, Exception>() {
-			@Override
-			@Nullable protected Exception doInBackground(Void... voids) {
-				try {
-					// Create test identity
-					final ContactModel contact1 = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
-					final ContactMessageReceiver receiver1 = contactService.createReceiver(contact1);
-					final ContactModel contact2 = createTestContact(TEST_IDENTITY_2, "Another Developer", "Testcontact");
-					final ContactMessageReceiver receiver2 = contactService.createReceiver(contact2);
-
-					messageService.createStatusMessage("Creating test quotes...", receiver1);
-
-					// Create recursive quote
-					final MessageId messageIdRecursive = new MessageId();
-					TextMessage messageRecursive = new TextMessage();
-					messageRecursive.setFromIdentity(contact1.getIdentity());
-					messageRecursive.setToIdentity(userService.getIdentity());
-					messageRecursive.setDate(new Date());
-					messageRecursive.setMessageId(messageIdRecursive);
-					messageRecursive.setText("> quote #" + messageIdRecursive.toString() + "\n\na quote that references itself");
-					messageService.processIncomingContactMessage(messageRecursive);
-
-					// Create cross-chat quote
-					final MessageId messageIdCrossChat1 = new MessageId();
-					final MessageId messageIdCrossChat2 = new MessageId();
-					TextMessage messageChat2 = new TextMessage();
-					messageChat2.setFromIdentity(contact2.getIdentity());
-					messageChat2.setToIdentity(userService.getIdentity());
-					messageChat2.setDate(new Date());
-					messageChat2.setMessageId(messageIdCrossChat2);
-					messageChat2.setText("hello, this is a secret message");
-					messageService.processIncomingContactMessage(messageChat2);
-					TextMessage messageChat1 = new TextMessage();
-					messageChat1.setFromIdentity(contact1.getIdentity());
-					messageChat1.setToIdentity(userService.getIdentity());
-					messageChat1.setDate(new Date());
-					messageChat1.setMessageId(messageIdCrossChat1);
-					messageChat1.setText("> quote #" + messageIdCrossChat2.toString() + "\n\nOMG!");
-					messageService.processIncomingContactMessage(messageChat1);
-
-					messageService.createStatusMessage("Done creating test quotes", receiver1);
-
-					return null;
-				} catch (Exception e) {
-					return e;
-				}
-			}
-
-			@Override
-			protected void onPostExecute(@Nullable Exception e) {
-				if (e == null) {
-					showOk("Test quotes created!");
-				} else {
-					showError(e);
-				}
-			}
-		}.execute();
-		return true;
-	}
-
-	@UiThread
-	@SuppressLint("StaticFieldLeak")
-	private boolean hideDeveloperMenu(Preference preference) {
-		this.preferenceService.setShowDeveloperMenu(false);
-		this.showOk("Not everybody can be a craaazy developer!");
-		final Activity activity = this.getActivity();
-		if (activity != null) {
-			activity.finish();
-		}
-		return true;
-	}
-
-	private void initMdSetting() {
-		CheckBoxPreference preference = getPref(R.string.preferences__md_unlocked);
-		preference.setEnabled(multiDeviceManager.isMultiDeviceActive() || preferenceService.isMdUnlocked() || BuildConfig.MD_ENABLED);
-		preference.setOnPreferenceChangeListener((p, v) -> {
-			p.setEnabled((boolean)v || BuildConfig.MD_ENABLED);
-			return true;
-		});
-	}
-
-	private void initConversationSetting() {
-		CheckBoxPreference preference = getPref(R.string.preferences__show_last_update_prefix);
-	}
-
-	final protected boolean requiredInstances() {
-		if (!this.checkInstances()) {
-			this.instantiate();
-		}
-		return this.checkInstances();
-	}
-
-	protected boolean checkInstances() {
-		return TestUtil.required(
-			this.preferenceService,
-			this.databaseService,
-			this.contactService,
-			this.messageService,
-			this.userService,
-			this.multiDeviceManager
-		);
-	}
-
-	protected void instantiate() {
-		ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-		if (serviceManager != null) {
-			try {
-				this.preferenceService = serviceManager.getPreferenceService();
-				this.databaseService = serviceManager.getDatabaseServiceNew();
-				this.contactService = serviceManager.getContactService();
-				this.messageService = serviceManager.getMessageService();
-				this.userService = serviceManager.getUserService();
-				this.multiDeviceManager = serviceManager.getMultiDeviceManager();
-			} catch (Exception e) {
-				logger.error("Exception", e);
-			}
-		}
-	}
-
-	@Override
-	public int getPreferenceTitleResource() {
-		return R.string.prefs_developers;
-	}
-
-	@Override
-	public int getPreferenceResource() {
-		return R.xml.preference_developers;
-	}
+    private static final Logger logger = LoggingUtil.getThreemaLogger("SettingsDeveloperFragment");
+
+    // Test identities.
+    private static final String TEST_IDENTITY_1 = "ADDRTCNX";
+    private static final String TEST_IDENTITY_2 = "H6AXSHKC";
+
+    private PreferenceService preferenceService;
+    private DatabaseServiceNew databaseService;
+    private ContactService contactService;
+    private MessageService messageService;
+    private UserService userService;
+    private MultiDeviceManager multiDeviceManager;
+    private APIConnector apiConnector;
+    private ContactModelRepository contactModelRepository;
+
+    @Override
+    public void initializePreferences() {
+        if (!requiredInstances()) {
+            return;
+        }
+
+        initMdSetting();
+        initConversationSetting();
+
+        // Generate VoIP messages
+        final Preference generateVoipPreference = getPref(getResources().getString(R.string.preferences__generate_voip_messages));
+        generateVoipPreference.setSummary("Create the test identity " + TEST_IDENTITY_1
+            + " and add all possible VoIP messages to that conversation.");
+        generateVoipPreference.setOnPreferenceClickListener(this::generateVoipMessages);
+
+        // Generate test quotes
+        final Preference generateRecursiveQuote = getPref(getResources().getString(R.string.preferences__generate_test_quotes));
+        generateRecursiveQuote.setSummary("Create the test identities " + TEST_IDENTITY_1 + " and "
+            + TEST_IDENTITY_2 + " and add some test quotes.");
+        generateRecursiveQuote.setOnPreferenceClickListener(this::generateTestQuotes);
+
+        // Theming
+        final Preference openPatternLibraryPreference = getPref(getResources().getString(R.string.preferences__open_pattern_library));
+        openPatternLibraryPreference.setOnPreferenceClickListener((preference) -> {
+            startActivity(new Intent(getContext(), PatternLibraryActivity.class));
+            return true;
+        });
+
+        // Remove developer menu
+        final Preference removeMenuPreference = getPref(getResources().getString(R.string.preferences__remove_menu));
+        removeMenuPreference.setSummary("Hide the developer menu from the settings.");
+        removeMenuPreference.setOnPreferenceClickListener(this::hideDeveloperMenu);
+    }
+
+    @UiThread
+    private void showOk(CharSequence msg) {
+        Toast.makeText(this.getContext(), msg, Toast.LENGTH_LONG).show();
+    }
+
+    @UiThread
+    private void showError(Exception e) {
+        logger.error("Exception", e);
+        Toast.makeText(this.getContext(), e.toString(), Toast.LENGTH_LONG).show();
+    }
+
+    @WorkerThread
+    private ContactModel createTestContact(
+        String identity,
+        String firstName,
+        String lastName
+    ) throws InvalidEntryException, PolicyViolationException {
+        ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+            identity,
+            ContactModel.AcquaintanceLevel.DIRECT,
+            userService.getIdentity(),
+            apiConnector,
+            contactModelRepository,
+            AddContactRestrictionPolicy.CHECK,
+            ThreemaApplication.getAppContext(),
+            null
+        ).runSynchronously();
+
+        if (result instanceof ContactAvailable) {
+            ((ContactAvailable) result).getContactModel().setNameFromLocal(firstName, lastName);
+
+            ContactModel contactModel = contactService.getByIdentity(identity);
+            if (contactModel == null) {
+                throw new IllegalStateException("Contact model is null after adding it");
+            }
+            return contactModel;
+        } else if (result instanceof PolicyViolation) {
+            throw new PolicyViolationException();
+        } else {
+            throw new InvalidEntryException(R.string.invalid_threema_id);
+        }
+    }
+
+    @UiThread
+    @SuppressLint("StaticFieldLeak")
+    private boolean generateVoipMessages(Preference preference) {
+
+        // Pojo for holding test data.
+        class VoipMessage {
+            final VoipStatusDataModel dataModel;
+            final String description;
+
+            VoipMessage(VoipStatusDataModel dataModel, String description) {
+                this.dataModel = dataModel;
+                this.description = description;
+            }
+        }
+
+        // Test messages
+        final VoipMessage[] testMessages = new VoipMessage[]{
+            new VoipMessage(VoipStatusDataModel.createMissed(NO_CALL_ID, null), "missed"),
+            new VoipMessage(VoipStatusDataModel.createFinished(NO_CALL_ID, 42), "finished"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.UNKNOWN), "rejected (unknown)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.BUSY), "rejected (busy)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.TIMEOUT), "rejected (timeout)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.REJECTED), "rejected (rejected)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.DISABLED), "rejected (disabled)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, (byte) 99), "rejected (invalid reason code)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, null), "rejected (null reason code)"),
+            new VoipMessage(VoipStatusDataModel.createAborted(NO_CALL_ID), "aborted"),
+        };
+
+        new AsyncTask<Void, Void, Exception>() {
+            @Override
+            @Nullable
+            protected Exception doInBackground(Void... voids) {
+                try {
+                    // Create test identity
+                    final ContactModel contact = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
+
+                    // Create test messages
+                    final ContactMessageReceiver receiver = contactService.createReceiver(contact);
+                    messageService.createStatusMessage("Creating test messages...", receiver);
+                    for (boolean isOutbox : new boolean[]{true, false}) {
+                        for (VoipMessage msg : testMessages) {
+                            final String text = (isOutbox ? "Outgoing " : "Incoming ") + msg.description;
+                            messageService.createStatusMessage(text, receiver);
+                            messageService.createVoipStatus(msg.dataModel, receiver, isOutbox, true);
+                        }
+                    }
+
+                    return null;
+                } catch (Exception e) {
+                    return e;
+                }
+            }
+
+            @Override
+            protected void onPostExecute(@Nullable Exception e) {
+                if (e == null) {
+                    showOk("Test messages created!");
+                } else {
+                    showError(e);
+                }
+            }
+        }.execute();
+        return true;
+    }
+
+    @UiThread
+    @SuppressLint("StaticFieldLeak")
+    private boolean generateTestQuotes(Preference preference) {
+        new AsyncTask<Void, Void, Exception>() {
+            @Override
+            @Nullable
+            protected Exception doInBackground(Void... voids) {
+                try {
+                    // Create test identity
+                    final ContactModel contact1 = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
+                    final ContactMessageReceiver receiver1 = contactService.createReceiver(contact1);
+                    final ContactModel contact2 = createTestContact(TEST_IDENTITY_2, "Another Developer", "Testcontact");
+                    final ContactMessageReceiver receiver2 = contactService.createReceiver(contact2);
+
+                    messageService.createStatusMessage("Creating test quotes...", receiver1);
+
+                    // Create recursive quote
+                    final MessageId messageIdRecursive = new MessageId();
+                    TextMessage messageRecursive = new TextMessage();
+                    messageRecursive.setFromIdentity(contact1.getIdentity());
+                    messageRecursive.setToIdentity(userService.getIdentity());
+                    messageRecursive.setDate(new Date());
+                    messageRecursive.setMessageId(messageIdRecursive);
+                    messageRecursive.setText("> quote #" + messageIdRecursive.toString() + "\n\na quote that references itself");
+                    messageService.processIncomingContactMessage(messageRecursive);
+
+                    // Create cross-chat quote
+                    final MessageId messageIdCrossChat1 = new MessageId();
+                    final MessageId messageIdCrossChat2 = new MessageId();
+                    TextMessage messageChat2 = new TextMessage();
+                    messageChat2.setFromIdentity(contact2.getIdentity());
+                    messageChat2.setToIdentity(userService.getIdentity());
+                    messageChat2.setDate(new Date());
+                    messageChat2.setMessageId(messageIdCrossChat2);
+                    messageChat2.setText("hello, this is a secret message");
+                    messageService.processIncomingContactMessage(messageChat2);
+                    TextMessage messageChat1 = new TextMessage();
+                    messageChat1.setFromIdentity(contact1.getIdentity());
+                    messageChat1.setToIdentity(userService.getIdentity());
+                    messageChat1.setDate(new Date());
+                    messageChat1.setMessageId(messageIdCrossChat1);
+                    messageChat1.setText("> quote #" + messageIdCrossChat2.toString() + "\n\nOMG!");
+                    messageService.processIncomingContactMessage(messageChat1);
+
+                    messageService.createStatusMessage("Done creating test quotes", receiver1);
+
+                    return null;
+                } catch (Exception e) {
+                    return e;
+                }
+            }
+
+            @Override
+            protected void onPostExecute(@Nullable Exception e) {
+                if (e == null) {
+                    showOk("Test quotes created!");
+                } else {
+                    showError(e);
+                }
+            }
+        }.execute();
+        return true;
+    }
+
+    @UiThread
+    @SuppressLint("StaticFieldLeak")
+    private boolean hideDeveloperMenu(Preference preference) {
+        this.preferenceService.setShowDeveloperMenu(false);
+        this.showOk("Not everybody can be a craaazy developer!");
+        final Activity activity = this.getActivity();
+        if (activity != null) {
+            activity.finish();
+        }
+        return true;
+    }
+
+    private void initMdSetting() {
+        CheckBoxPreference preference = getPref(R.string.preferences__md_unlocked);
+        preference.setEnabled(multiDeviceManager.isMultiDeviceActive() || preferenceService.isMdUnlocked() || BuildConfig.MD_ENABLED);
+        preference.setOnPreferenceChangeListener((p, v) -> {
+            p.setEnabled((boolean) v || BuildConfig.MD_ENABLED);
+            return true;
+        });
+    }
+
+    private void initConversationSetting() {
+        CheckBoxPreference preference = getPref(R.string.preferences__show_last_update_prefix);
+    }
+
+    final protected boolean requiredInstances() {
+        if (!this.checkInstances()) {
+            this.instantiate();
+        }
+        return this.checkInstances();
+    }
+
+    protected boolean checkInstances() {
+        return TestUtil.required(
+            this.preferenceService,
+            this.databaseService,
+            this.contactService,
+            this.messageService,
+            this.userService,
+            this.multiDeviceManager
+        );
+    }
+
+    protected void instantiate() {
+        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+        if (serviceManager != null) {
+            try {
+                this.preferenceService = serviceManager.getPreferenceService();
+                this.databaseService = serviceManager.getDatabaseServiceNew();
+                this.contactService = serviceManager.getContactService();
+                this.messageService = serviceManager.getMessageService();
+                this.userService = serviceManager.getUserService();
+                this.multiDeviceManager = serviceManager.getMultiDeviceManager();
+                this.apiConnector = serviceManager.getAPIConnector();
+                this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+            } catch (Exception e) {
+                logger.error("Exception", e);
+            }
+        }
+    }
+
+    @Override
+    public int getPreferenceTitleResource() {
+        return R.string.prefs_developers;
+    }
+
+    @Override
+    public int getPreferenceResource() {
+        return R.xml.preference_developers;
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt b/app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt
index 723ccd5f..ef0760ad 100644
--- a/app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt
+++ b/app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt
@@ -22,11 +22,11 @@
 package ch.threema.app.processors
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.fs.IncomingForwardSecurityAcceptTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityInitTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityMessageTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityRejectTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityTerminateTask
+import ch.threema.app.processors.incomingcspmessage.fs.IncomingForwardSecurityAcceptTask
+import ch.threema.app.processors.incomingcspmessage.fs.IncomingForwardSecurityInitTask
+import ch.threema.app.processors.incomingcspmessage.fs.IncomingForwardSecurityMessageTask
+import ch.threema.app.processors.incomingcspmessage.fs.IncomingForwardSecurityRejectTask
+import ch.threema.app.processors.incomingcspmessage.fs.IncomingForwardSecurityTerminateTask
 import ch.threema.base.ThreemaException
 import ch.threema.domain.models.Contact
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt b/app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt
index 1651d6db..4bdbbc4e 100644
--- a/app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt
+++ b/app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt
@@ -22,135 +22,32 @@
 package ch.threema.app.processors
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.calls.IncomingCallAnswerTask
-import ch.threema.app.processors.calls.IncomingCallHangupTask
-import ch.threema.app.processors.calls.IncomingCallIceCandidateTask
-import ch.threema.app.processors.calls.IncomingCallOfferTask
-import ch.threema.app.processors.calls.IncomingCallRingingTask
-import ch.threema.app.processors.contactcontrol.IncomingContactRequestProfilePictureTask
-import ch.threema.app.processors.contactcontrol.IncomingDeleteProfilePictureTask
-import ch.threema.app.processors.contactcontrol.IncomingSetProfilePictureTask
-import ch.threema.app.processors.conversation.IncomingBallotVoteTask
-import ch.threema.app.processors.conversation.IncomingContactConversationMessageTask
-import ch.threema.app.processors.conversation.IncomingContactDeleteMessageTask
-import ch.threema.app.processors.conversation.IncomingContactEditMessageTask
-import ch.threema.app.processors.conversation.IncomingGroupConversationMessageTask
-import ch.threema.app.processors.conversation.IncomingGroupDeleteMessageTask
-import ch.threema.app.processors.conversation.IncomingGroupEditMessageTask
-import ch.threema.app.processors.fs.IncomingEmptyTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupCallControlTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupDeleteProfilePictureTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupJoinRequestTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupJoinResponseMessage
-import ch.threema.app.processors.groupcontrol.IncomingGroupLeaveTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupNameTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupSetProfilePictureTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupSetupTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupSyncRequestTask
-import ch.threema.app.processors.push.IncomingWebSessionResumeMessageTask
-import ch.threema.app.processors.statusupdates.IncomingDeliveryReceiptTask
-import ch.threema.app.processors.statusupdates.IncomingGroupDeliveryReceiptTask
-import ch.threema.app.processors.statusupdates.IncomingTypingIndicatorTask
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.IdListService
-import ch.threema.app.services.MessageService
-import ch.threema.app.services.PreferenceService
-import ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask
-import ch.threema.base.crypto.NonceFactory
 import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.Utils
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.api.APIConnector
-import ch.threema.domain.protocol.api.APIConnector.HttpConnectionException
 import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
 import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.protocol.csp.coders.MessageCoder
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.fs.PeerRatchetIdentifier
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.BadMessageException
-import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.DeleteMessage
-import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
-import ch.threema.domain.protocol.csp.messages.EditMessage
-import ch.threema.domain.protocol.csp.messages.EmptyMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeleteProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
-import ch.threema.domain.protocol.csp.messages.GroupEditMessage
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupNameMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
-import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException
-import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
-import ch.threema.domain.protocol.csp.messages.WebSessionResumeMessage
-import ch.threema.domain.protocol.csp.messages.ballot.BallotVoteInterface
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestMessage
-import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseMessage
-import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallControlMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
-import ch.threema.domain.stores.ContactStore
-import ch.threema.domain.stores.IdentityStoreInterface
 import ch.threema.domain.taskmanager.ActiveTaskCodec
 import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.NetworkException
-import ch.threema.domain.taskmanager.ProtocolException
-import ch.threema.domain.taskmanager.catchAllExceptNetworkException
-import ch.threema.domain.taskmanager.catchExceptNetworkException
 import ch.threema.storage.models.ServerMessageModel
-import java.util.Date
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingMessageProcessorImpl")
 
-class IncomingMessageProcessorImpl(
-    private val messageService: MessageService,
-    private val nonceFactory: NonceFactory,
-    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    private val contactService: ContactService,
-    private val contactStore: ContactStore,
-    private val identityStore: IdentityStoreInterface,
-    private val blockedContactsService: IdListService,
-    private val preferenceService: PreferenceService,
-    private val serviceManager: ServiceManager,
-) : IncomingMessageProcessor {
-    private val incomingForwardSecurityProcessor = IncomingForwardSecurityProcessor(serviceManager)
+class IncomingMessageProcessorImpl(private val serviceManager: ServiceManager) :
+    IncomingMessageProcessor {
+    private val messageService by lazy { serviceManager.messageService }
 
-    override suspend fun processIncomingMessage(messageBox: MessageBox, handle: ActiveTaskCodec) {
-        suspend {
-            processMessage(messageBox, handle)
-        }.catchAllExceptNetworkException { e ->
-            val messageId = messageBox.messageId
-            val fromIdentity = messageBox.fromIdentity
-
-            logger.error("Processing message {} from {} failed", messageId, fromIdentity, e)
-
-            // If we catch a network related exception, we throw a protocol exception to trigger a
-            // reconnect by the task manager.
-            if (e is HttpConnectionException || e is APIConnector.NetworkException) {
-                val errorMsg = "Could not process message $messageId from $fromIdentity"
-                logger.error(errorMsg, e)
-                throw ProtocolException(e.message ?: errorMsg)
-            }
+    override suspend fun processIncomingCspMessage(
+        messageBox: MessageBox,
+        handle: ActiveTaskCodec,
+    ) {
+        IncomingMessageTask(messageBox, serviceManager).run(handle)
+    }
 
-            // For every other exception, we acknowledge the failed message. Due to forward
-            // security, it would not make sense to process a message later on. Note that when a
-            // NetworkException is thrown, we do not need to acknowledge the message as the task
-            // manager will be stopped before the next message can be processed. On the next
-            // reconnect, we will receive the non-acked messages.
-            // Note that we do not protect messages that could not be decoded against replay
-            acknowledgeMessage(messageBox, false, null, handle)
-        }
+    override suspend fun processIncomingD2mMessage(
+        message: InboundD2mMessage.Reflected,
+        handle: ActiveTaskCodec,
+    ) {
+        IncomingReflectedMessageTask(message, serviceManager).run(handle)
     }
 
     override fun processIncomingServerAlert(alertData: CspMessage.ServerAlertData) {
@@ -169,305 +66,4 @@ class IncomingMessageProcessorImpl(
         }
     }
 
-    private suspend fun processMessage(messageBox: MessageBox, handle: ActiveTaskCodec) {
-        logger.info(
-            "Incoming message from {} with ID {}",
-            messageBox.fromIdentity,
-            messageBox.messageId
-        )
-
-        val (message, peerRatchetIdentifier) = suspend {
-            decryptMessage(messageBox, handle)
-        }.catchExceptNetworkException { e: DiscardMessageException ->
-            logger.warn("Discard message {}", messageBox.messageId)
-            // If the message could be decrypted, then check if it should be protected against
-            // replay. Otherwise we do not protect it against replay.
-            val protectAgainstReplay = e.discardedMessage?.protectAgainstReplay() ?: false
-            acknowledgeMessage(messageBox, protectAgainstReplay, e.peerRatchetIdentifier, handle)
-            return
-        }
-
-        if (message == null) {
-            // Note that if the message is null, it is an fs control message or an invalid message
-            // that does not need any further processing. Therefore we just acknowledge the message.
-            // Note that we need to protect fs control message against replay.
-            acknowledgeMessage(messageBox, true, peerRatchetIdentifier, handle)
-            return
-        }
-
-        suspend {
-            processMessage(message, handle)
-        }.catchExceptNetworkException { _: DiscardMessageException ->
-            logger.warn("Discard message {}", messageBox.messageId)
-            acknowledgeMessage(
-                messageBox,
-                message.protectAgainstReplay(),
-                peerRatchetIdentifier,
-                handle
-            )
-            return
-        }
-
-        // Acknowledge the message
-        acknowledgeMessage(messageBox, message.protectAgainstReplay(), peerRatchetIdentifier, handle)
-
-        // If the message type requires automatic delivery receipts and the message does not contain
-        // the no delivery receipt flag, send a delivery receipt
-        if (message.sendAutomaticDeliveryReceipt()
-            && !message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_DELIVERY_RECEIPTS)
-        ) {
-            OutgoingContactDeliveryReceiptMessageTask(
-                ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED,
-                arrayOf(message.messageId),
-                Date().time,
-                message.fromIdentity,
-                serviceManager
-            ).invoke(handle)
-            logger.info(
-                "Sent delivery receipt (delivered) message for message ID {} from {}",
-                message.messageId, message.fromIdentity
-            )
-        }
-    }
-
-    private suspend fun decryptMessage(
-        messageBox: MessageBox,
-        handle: ActiveTaskCodec,
-    ): Pair<AbstractMessage?, PeerRatchetIdentifier?> {
-        // If the nonce has already been used, acknowledge and discard the message
-        if (nonceFactory.exists(messageBox.nonce)) {
-            logger.warn(
-                "Skipped processing message {} as its nonce has already been used",
-                messageBox.messageId
-            )
-            throw DiscardMessageException()
-        }
-
-        // First, we need to ensure we have the public key of the sender
-        contactService.fetchAndCacheContact(messageBox.fromIdentity)
-
-        // Try to decode the message. At this point we have the public key of the sender either
-        // stored or cached in the contact store.
-        val messageCoder = MessageCoder(this.contactStore, this.identityStore)
-        val encapsulatedMessage = try {
-            messageCoder.decode(messageBox)
-        } catch (e: BadMessageException) {
-            logger.warn("Could not decode message: {}", e.message)
-            throw DiscardMessageException()
-        }
-
-        logger.info(
-            "Incoming message {} from {} to {} (type {})",
-            messageBox.messageId,
-            messageBox.fromIdentity,
-            messageBox.toIdentity,
-            Utils.byteToHex(encapsulatedMessage.type.toByte(), true, true)
-        )
-
-        // Decapsulate fs message if it is an fs envelope message
-        val (message, peerRatchetIdentifier) = decapsulateMessage(encapsulatedMessage, handle)
-
-        // In case there is no decapsulated message, it was an fs control message or an invalid
-        // message that does not need any further processing
-        if (message == null) {
-            return null to peerRatchetIdentifier
-        }
-
-        logger.info(
-            "Processing decrypted message {} from {} to {} (type {})",
-            message.messageId,
-            message.fromIdentity,
-            message.toIdentity,
-            Utils.byteToHex(message.type.toByte(), true, true)
-        )
-
-        if (isBlocked(message.fromIdentity) && !message.exemptFromBlocking()) {
-            logger.info(
-                "Message {} from {} will be discarded: Contact is implicitly or explicitly blocked.",
-                message.messageId,
-                message.fromIdentity
-            )
-            throw DiscardMessageException(message, peerRatchetIdentifier)
-        }
-
-        return Pair(message, peerRatchetIdentifier)
-    }
-
-    private suspend fun decapsulateMessage(
-        encapsulated: AbstractMessage,
-        handle: ActiveTaskCodec,
-    ): Pair<AbstractMessage?, PeerRatchetIdentifier?> {
-        // If the message is not a fs encapsulated message, warn the user depending on the fs
-        // session and return the already decapsulated message.
-        if (encapsulated !is ForwardSecurityEnvelopeMessage) {
-            forwardSecurityMessageProcessor.warnIfMessageWithoutForwardSecurityReceived(
-                encapsulated,
-                handle
-            )
-            return Pair(encapsulated, null)
-        }
-
-        val contact = contactStore.getContactForIdentityIncludingCache(encapsulated.fromIdentity)
-            ?: throw MissingPublicKeyException("Missing public key for ID ${encapsulated.fromIdentity}")
-
-        val fsDecryptionResult = incomingForwardSecurityProcessor
-            .processEnvelopeMessage(contact, encapsulated, handle)
-
-        return Pair(fsDecryptionResult.message, fsDecryptionResult.peerRatchetIdentifier)
-    }
-
-    private suspend fun processMessage(message: AbstractMessage, handle: ActiveTaskCodec) {
-        if (message.fromIdentity == ProtocolDefines.SPECIAL_CONTACT_PUSH) {
-            when (message) {
-                is WebSessionResumeMessage -> IncomingWebSessionResumeMessageTask(
-                    message,
-                    serviceManager,
-                )
-
-                else -> throw DiscardMessageException(message)
-            }.run(handle)
-
-            return
-        }
-
-        // Create implicit direct contact depending on the message type and if not already exists
-        if (message.createImplicitlyDirectContact() && contactService.getByIdentity(message.fromIdentity) == null) {
-            contactService.createContactByIdentity(message.fromIdentity, true)
-        }
-
-        // Update the nickname and set contact as active (if contact exists)
-        contactService.updatePublicNickName(message)
-        contactService.setActive(message.fromIdentity)
-
-        // Determine the message type and get its corresponding receive steps. Note that the order
-        // of checking the types is important. For instance, an abstract group message must first be
-        // checked for a group control message before processing it as a group conversation message.
-        val subtask = when (message) {
-            // Check if message is a status update
-            is TypingIndicatorMessage -> IncomingTypingIndicatorTask(message, serviceManager)
-            is DeliveryReceiptMessage -> IncomingDeliveryReceiptTask(message, serviceManager)
-            is GroupDeliveryReceiptMessage -> IncomingGroupDeliveryReceiptTask(
-                message,
-                serviceManager
-            )
-
-            // Check if message is a group control message
-            is GroupSetupMessage -> IncomingGroupSetupTask(message, serviceManager)
-            is GroupNameMessage -> IncomingGroupNameTask(message, serviceManager)
-            is GroupSetProfilePictureMessage -> IncomingGroupSetProfilePictureTask(
-                message,
-                serviceManager
-            )
-            is GroupDeleteProfilePictureMessage -> IncomingGroupDeleteProfilePictureTask(
-                message,
-                serviceManager
-            )
-            is GroupLeaveMessage -> IncomingGroupLeaveTask(message, serviceManager)
-            is GroupSyncRequestMessage -> IncomingGroupSyncRequestTask(message, serviceManager)
-            is GroupCallControlMessage -> IncomingGroupCallControlTask(message, serviceManager)
-
-            // Check if message is a contact control message
-            is SetProfilePictureMessage -> IncomingSetProfilePictureTask(message, serviceManager)
-            is DeleteProfilePictureMessage -> IncomingDeleteProfilePictureTask(
-                message,
-                serviceManager
-            )
-            is ContactRequestProfilePictureMessage -> IncomingContactRequestProfilePictureTask(
-                message,
-                serviceManager
-            )
-
-            // Check if message is a ballot or group join message
-            is BallotVoteInterface -> IncomingBallotVoteTask(message, serviceManager)
-            is GroupJoinRequestMessage -> IncomingGroupJoinRequestTask(message, serviceManager)
-            is GroupJoinResponseMessage -> IncomingGroupJoinResponseMessage(message, serviceManager)
-
-            // Check if message is a call message
-            is VoipCallOfferMessage -> IncomingCallOfferTask(message, serviceManager)
-            is VoipCallAnswerMessage -> IncomingCallAnswerTask(message, serviceManager)
-            is VoipICECandidatesMessage -> IncomingCallIceCandidateTask(message, serviceManager)
-            is VoipCallRingingMessage -> IncomingCallRingingTask(message, serviceManager)
-            is VoipCallHangupMessage -> IncomingCallHangupTask(message, serviceManager)
-
-            // Check if message is an edit message
-            is EditMessage -> IncomingContactEditMessageTask(message, serviceManager)
-            is GroupEditMessage -> IncomingGroupEditMessageTask(message, serviceManager)
-
-            // Check if message is a delete message
-            is DeleteMessage -> IncomingContactDeleteMessageTask(message, serviceManager)
-            is GroupDeleteMessage -> IncomingGroupDeleteMessageTask(message, serviceManager)
-
-            // If it is a group message, process it as a group conversation message
-            is AbstractGroupMessage -> IncomingGroupConversationMessageTask(message, serviceManager)
-
-            // Process the empty message in its corresponding task
-            is EmptyMessage -> IncomingEmptyTask(message, serviceManager)
-
-            // Otherwise it must be a contact conversation message
-            else -> IncomingContactConversationMessageTask(message, serviceManager)
-        }
-
-        val result = try {
-            subtask.run(handle)
-        } catch (e: Exception) {
-            when (e) {
-                // If a network exception is thrown, we cancel processing the message to start over
-                // when the connection has been restarted.
-                is NetworkException -> throw e
-                // Any other exception should never be thrown. If there is one, we discard the
-                // message. Note that we also acknowledge discarded messages towards the server.
-                else -> {
-                    logger.error("Error while processing incoming message", e)
-                    throw DiscardMessageException(message)
-                }
-            }
-        }
-
-        if (result == ReceiveStepsResult.DISCARD) {
-            throw DiscardMessageException(message)
-        }
-    }
-
-    private suspend fun acknowledgeMessage(
-        messageBox: MessageBox,
-        protectAgainstReplay: Boolean,
-        peerRatchetIdentifier: PeerRatchetIdentifier?,
-        handle: ActiveTaskCodec,
-    ) {
-        // If the no-server-ack message flag is not set, send a message-ack to the server
-        if ((messageBox.flags and ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK) == 0) {
-            sendAck(messageBox.messageId, messageBox.fromIdentity, handle)
-        }
-
-        // If the message should be protected against replay, store the nonce
-        if (protectAgainstReplay) {
-            nonceFactory.store(messageBox.nonce)
-        }
-
-        // If there is a peer ratchet identifier known, then turn the peer ratchet
-        peerRatchetIdentifier?.let {
-            forwardSecurityMessageProcessor.commitPeerRatchet(it, handle)
-        }
-    }
-
-    private suspend fun sendAck(messageId: MessageId, identity: String, handle: ActiveTaskCodec) {
-        logger.debug("Sending ack for message ID {} from {}", messageId, identity)
-
-        val data = identity.encodeToByteArray() + messageId.messageId
-
-        handle.write(CspMessage(ProtocolDefines.PLTYPE_INCOMING_MESSAGE_ACK.toUByte(), data))
-    }
-
-    private fun isBlocked(identity: String): Boolean =
-        blockedContactsService.has(identity) || contactService.getByIdentity(identity) == null && preferenceService.isBlockUnknown
-
-    private class DiscardMessageException(
-        val discardedMessage: AbstractMessage?,
-        val peerRatchetIdentifier: PeerRatchetIdentifier?,
-    ) : Exception() {
-        constructor() : this(null, null)
-
-        constructor(discardedMessage: AbstractMessage?) : this(discardedMessage, null)
-
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingMessageTask.kt b/app/src/main/java/ch/threema/app/processors/IncomingMessageTask.kt
new file mode 100644
index 00000000..64b522c4
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/IncomingMessageTask.kt
@@ -0,0 +1,523 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.getSubTaskFromMessage
+import ch.threema.app.processors.push.IncomingWebSessionResumeMessageTask
+import ch.threema.app.protocol.runIdentityBlockedSteps
+import ch.threema.app.services.ContactServiceImpl
+import ch.threema.app.tasks.ActiveComposableTask
+import ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.Utils
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.models.ContactModelData.Companion.getIdColorIndex
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.data.models.ModelDeletedException
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.api.APIConnector
+import ch.threema.domain.protocol.connection.data.CspMessage
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.coders.MessageBox
+import ch.threema.domain.protocol.csp.coders.MessageCoder
+import ch.threema.domain.protocol.csp.fs.PeerRatchetIdentifier
+import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException
+import ch.threema.domain.protocol.csp.messages.WebSessionResumeMessage
+import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.NetworkException
+import ch.threema.domain.taskmanager.ProtocolException
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.domain.taskmanager.catchAllExceptNetworkException
+import ch.threema.domain.taskmanager.catchExceptNetworkException
+import ch.threema.domain.taskmanager.getEncryptedIncomingMessageEnvelope
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingMessageTask")
+
+class IncomingMessageTask(
+    private val messageBox: MessageBox,
+    private val serviceManager: ServiceManager,
+) : ActiveComposableTask<Unit> {
+    private val contactService by lazy { serviceManager.contactService }
+    private val contactModelRepository by lazy { serviceManager.modelRepositories.contacts }
+    private val contactStore by lazy { serviceManager.contactStore }
+    private val identityStore by lazy { serviceManager.identityStore }
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+    private val messageService by lazy { serviceManager.messageService }
+    private val blockedContactsService by lazy { serviceManager.blockedContactsService }
+    private val preferenceService by lazy { serviceManager.preferenceService }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
+    private val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
+    private val incomingForwardSecurityPreProcessor by lazy {IncomingForwardSecurityProcessor(serviceManager) }
+
+    override suspend fun run(handle: ActiveTaskCodec) {
+        suspend {
+            processMessage(handle)
+        }.catchAllExceptNetworkException { e ->
+            val messageId = messageBox.messageId
+            val fromIdentity = messageBox.fromIdentity
+
+            logger.error("Processing message {} from {} failed", messageId, fromIdentity, e)
+
+            // If we catch a network related exception, we throw a protocol exception to trigger a
+            // reconnect by the task manager.
+            if (e is APIConnector.HttpConnectionException || e is APIConnector.NetworkException) {
+                logger.error("Could not process message {} from {}}", messageId, fromIdentity, e)
+                throw ProtocolException(e.message ?: "")
+            }
+
+            // For every other exception, we acknowledge the failed message. Due to forward
+            // security, it would not make sense to process a message later on. Note that when a
+            // NetworkException is thrown, we do not need to acknowledge the message as the task
+            // manager will be stopped before the next message can be processed. On the next
+            // reconnect, we will receive the non-acked messages.
+            // Note that we do not protect messages that could not be decoded against replay
+            acknowledgeMessage(messageBox, false, null, handle)
+        }
+    }
+
+    private suspend fun processMessage(handle: ActiveTaskCodec) {
+        logger.info(
+            "Incoming message from {} with ID {}",
+            messageBox.fromIdentity,
+            messageBox.messageId
+        )
+
+        val (message, peerRatchetIdentifier) = suspend {
+            decryptMessage(messageBox, handle)
+        }.catchExceptNetworkException { e: DiscardMessageException ->
+            logger.warn("Discard message {}", messageBox.messageId)
+            // If the message could be decrypted, then check if it should be protected against
+            // replay. Otherwise we do not protect it against replay.
+            val protectAgainstReplay = e.discardedMessage?.protectAgainstReplay() ?: false
+            acknowledgeMessage(messageBox, protectAgainstReplay, e.peerRatchetIdentifier, handle)
+            return
+        }
+
+        if (message == null) {
+            // Note that if the message is null, it is an fs control message or an invalid message
+            // that does not need any further processing. Therefore we just acknowledge the message.
+            // Note that we need to protect fs control message against replay.
+            acknowledgeMessage(messageBox, true, peerRatchetIdentifier, handle)
+            return
+        }
+
+        suspend {
+            if (!message.exemptFromBlocking()) {
+                val blockState = runIdentityBlockedSteps(
+                    message.fromIdentity,
+                    contactModelRepository,
+                    contactStore,
+                    serviceManager.groupService,
+                    blockedContactsService,
+                    preferenceService,
+                )
+                if (blockState.isBlocked()) {
+                    logger.info(
+                        "Message {} from {} will be discarded: Contact is implicitly or explicitly blocked.",
+                        message.messageId,
+                        message.fromIdentity
+                    )
+                    throw DiscardMessageException(
+                        message,
+                        peerRatchetIdentifier
+                    )
+                }
+            }
+
+            if (message.fromIdentity == ProtocolDefines.SPECIAL_CONTACT_PUSH) {
+                // Handle messages from special contact
+                when (message) {
+                    is WebSessionResumeMessage -> IncomingWebSessionResumeMessageTask(
+                        message,
+                        TriggerSource.REMOTE,
+                        serviceManager,
+                    )
+
+                    else -> {
+                        logger.warn("Received unexpected message {} from {}",
+                            Utils.byteToHex(message.type.toByte(), true, true),
+                            ProtocolDefines.SPECIAL_CONTACT_PUSH
+                        )
+                        throw DiscardMessageException(message)
+                    }
+                }.run(handle)
+            } else {
+                // Handle message from other contact
+
+                // Extract the nickname from the message
+                val nickname = message.nickname?.trim()
+
+                // Create contact if message allows it and contact does not exists yet
+                if (message.createImplicitlyDirectContact()
+                    && contactModelRepository.getByIdentity(message.fromIdentity)
+                        ?.data?.value?.acquaintanceLevel != AcquaintanceLevel.DIRECT
+                ) {
+                    createDirectContactIfNotExists(message.fromIdentity, nickname, handle)
+                }
+
+                // Update the nickname if it changed (and if contact exists)
+                if (nickname != null) {
+                    updateNicknameIfChanged(message.fromIdentity, nickname, handle)
+                }
+
+                // Set the contact as active
+                setIdentityStateToActive(message.fromIdentity)
+
+                executeMessageSteps(message, handle)
+            }
+        }.catchExceptNetworkException { _: DiscardMessageException ->
+            logger.warn("Discard message {}", messageBox.messageId)
+            acknowledgeMessage(
+                messageBox,
+                message.protectAgainstReplay(),
+                peerRatchetIdentifier,
+                handle
+            )
+            return
+        }
+
+        val receivedTimestamp =
+            if (multiDeviceManager.isMultiDeviceActive && message.reflectIncoming()) {
+                logger.info("Reflecting incoming message {}", message.messageId)
+                reflectMessage(message, messageBox.nonce, handle)
+            } else {
+                Date().time.toULong()
+            }
+
+        updateReceivedTimestamp(message, receivedTimestamp ?: Date().time.toULong())
+
+        // Acknowledge the message
+        acknowledgeMessage(messageBox, message.protectAgainstReplay(), peerRatchetIdentifier, handle)
+
+        // If the message type requires automatic delivery receipts and the message does not contain
+        // the no delivery receipt flag, send a delivery receipt
+        if (message.sendAutomaticDeliveryReceipt()
+            && !message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_DELIVERY_RECEIPTS)
+        ) {
+            OutgoingContactDeliveryReceiptMessageTask(
+                ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED,
+                arrayOf(message.messageId),
+                Date().time,
+                message.fromIdentity,
+                serviceManager
+            ).invoke(handle)
+            logger.info(
+                "Sent delivery receipt (delivered) message for message ID {} from {}",
+                message.messageId, message.fromIdentity
+            )
+        }
+    }
+
+    private suspend fun decryptMessage(
+        messageBox: MessageBox,
+        handle: ActiveTaskCodec,
+    ): Pair<AbstractMessage?, PeerRatchetIdentifier?> {
+        // If the nonce has already been used, acknowledge and discard the message
+        if (nonceFactory.exists(NonceScope.CSP, Nonce(messageBox.nonce))) {
+            logger.warn(
+                "Skipped processing message {} as its nonce has already been used",
+                messageBox.messageId
+            )
+            throw DiscardMessageException()
+        }
+
+        // First, we need to ensure we have the public key of the sender
+        contactService.fetchAndCacheContact(messageBox.fromIdentity)
+
+        // Try to decode the message. At this point we have the public key of the sender either
+        // stored or cached in the contact store.
+        val messageCoder = MessageCoder(this.contactStore, this.identityStore)
+        val encapsulatedMessage = try {
+            messageCoder.decode(messageBox)
+        } catch (e: BadMessageException) {
+            logger.warn("Could not decode message: {}", e.message)
+            throw DiscardMessageException()
+        }
+
+        logger.info(
+            "Incoming message {} from {} to {} (type {})",
+            messageBox.messageId,
+            messageBox.fromIdentity,
+            messageBox.toIdentity,
+            Utils.byteToHex(encapsulatedMessage.type.toByte(), true, true)
+        )
+
+        // Decapsulate fs message if it is an fs envelope message
+        val (message, peerRatchetIdentifier) = decapsulateMessage(encapsulatedMessage, handle)
+
+        // In case there is no decapsulated message, it was an fs control message that does not need
+        // further processing
+        if (message == null) {
+            return null to peerRatchetIdentifier
+        }
+
+        logger.info(
+            "Processing decrypted message {} from {} to {} (type {})",
+            message.messageId,
+            message.fromIdentity,
+            message.toIdentity,
+            Utils.byteToHex(message.type.toByte(), true, true)
+        )
+
+        return Pair(message, peerRatchetIdentifier)
+    }
+
+    private suspend fun decapsulateMessage(
+        encapsulated: AbstractMessage,
+        handle: ActiveTaskCodec,
+    ): Pair<AbstractMessage?, PeerRatchetIdentifier?> {
+        // If the message is not a fs encapsulated message, warn the user depending on the fs
+        // session and return the already decapsulated message.
+        if (encapsulated !is ForwardSecurityEnvelopeMessage) {
+            forwardSecurityMessageProcessor.warnIfMessageWithoutForwardSecurityReceived(
+                encapsulated,
+                handle
+            )
+            return Pair(encapsulated, null)
+        }
+
+        val contact = contactStore.getContactForIdentityIncludingCache(encapsulated.fromIdentity)
+            ?: throw MissingPublicKeyException("Missing public key for ID ${encapsulated.fromIdentity}")
+
+        val fsDecryptionResult = incomingForwardSecurityPreProcessor
+            .processEnvelopeMessage(contact, encapsulated, handle)
+
+        return Pair(fsDecryptionResult.message, fsDecryptionResult.peerRatchetIdentifier)
+    }
+
+    private suspend fun acknowledgeMessage(
+        messageBox: MessageBox,
+        protectAgainstReplay: Boolean,
+        peerRatchetIdentifier: PeerRatchetIdentifier?,
+        handle: ActiveTaskCodec,
+    ) {
+        // If the no-server-ack message flag is not set, send a message-ack to the server
+        if ((messageBox.flags and ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK) == 0) {
+            sendAck(messageBox.messageId, messageBox.fromIdentity, handle)
+        }
+
+        // If the message should be protected against replay, store the nonce
+        if (protectAgainstReplay) {
+            nonceFactory.store(NonceScope.CSP, Nonce(messageBox.nonce))
+        }
+
+        // If there is a peer ratchet identifier known, then turn the peer ratchet
+        peerRatchetIdentifier?.let {
+            forwardSecurityMessageProcessor.commitPeerRatchet(it, handle)
+        }
+    }
+
+    private suspend fun sendAck(messageId: MessageId, identity: String, handle: ActiveTaskCodec) {
+        logger.debug("Sending ack for message ID {} from {}", messageId, identity)
+
+        val data = identity.encodeToByteArray() + messageId.messageId
+
+        handle.write(CspMessage(ProtocolDefines.PLTYPE_INCOMING_MESSAGE_ACK.toUByte(), data))
+    }
+
+    private suspend fun reflectMessage(
+        message: AbstractMessage,
+        cspNonce: ByteArray,
+        handle: ActiveTaskCodec,
+    ): ULong? {
+        val multiDeviceProperties = multiDeviceManager.propertiesProvider.get()
+        val encryptedEnvelopeResult = getEncryptedIncomingMessageEnvelope(
+            message,
+            cspNonce,
+            multiDeviceProperties.mediatorDeviceId,
+            multiDeviceProperties.keys
+        )
+
+        if (encryptedEnvelopeResult == null) {
+            logger.error("Cannot reflect message")
+            return null
+        }
+
+        return handle.reflectAndAwaitAck(
+            encryptedEnvelopeResult = encryptedEnvelopeResult,
+            storeD2dNonce = message.protectAgainstReplay(),
+            nonceFactory = nonceFactory
+        )
+    }
+
+    private fun setIdentityStateToActive(identity: String) {
+        val contactModel = contactModelRepository.getByIdentity(identity)
+        try {
+            // Note: Actually, this change is triggered by remote and not by local. However, this is
+            // not a change that should prevent the message from being further processed. Therefore,
+            // we use 'from local' as this just schedules a persistent task that will reflect the
+            // change after the message has been processed completely.
+            contactModel?.setActivityStateFromLocal(IdentityState.ACTIVE)
+        } catch (e: ModelDeletedException) {
+            logger.warn("The model has been deleted", e)
+        }
+    }
+
+    private suspend fun updateNicknameIfChanged(
+        fromIdentity: String,
+        nickname: String,
+        handle: ActiveTaskCodec,
+    ) {
+        val contactModel = contactModelRepository.getByIdentity(fromIdentity)
+        val data = contactModel?.data?.value
+            ?: run {
+                // This can happen for example if a group message is received from a member that is
+                // not in the group anymore and has been deleted.
+                logger.warn("Contact data is null. Nickname cannot be updated.")
+                return
+            }
+
+        val nicknameChanged = nickname != data.nickname
+
+        contactModel.setNicknameFromRemote(nickname, handle)
+
+        if (nicknameChanged) {
+            // This is a hack: As the last update flag may be bumped soon this can lead to the
+            // cached model with the old nickname to be saved in the database after updating the
+            // nickname.
+            contactService.removeFromCache(fromIdentity)
+        }
+    }
+
+    private suspend fun createDirectContactIfNotExists(
+        identity: String,
+        nickname: String?,
+        handle: ActiveTaskCodec,
+    )  {
+        val contactModel = contactModelRepository.getByIdentity(identity)
+        val data = contactModel?.data?.value
+        if (data != null && data.acquaintanceLevel == AcquaintanceLevel.GROUP) {
+            // Update acquaintance level from local
+            contactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.DIRECT)
+            // This is a hack: As the conversation may be updated soon, the conversation service
+            // will fetch the old contact model which may not be fresh and therefore may contain the
+            // old acquaintance level. This would prevent this conversation to be shown.
+            contactService.removeFromCache(identity)
+        } else if (data == null) {
+            val fetchedContact = contactStore.getCachedContact(identity)
+                ?: run {
+                    logger.error("No cached contact for identity {}. Cannot add contact.", identity)
+                    return
+                }
+
+            val verificationLevel =
+                if (ContactServiceImpl.TRUSTED_PUBLIC_KEYS.contains(fetchedContact.publicKey)) {
+                    VerificationLevel.FULLY_VERIFIED
+                } else {
+                    VerificationLevel.UNVERIFIED
+                }
+
+            // Create new contact
+            contactModelRepository.createFromRemote(
+                ContactModelData(
+                    identity = fetchedContact.identity,
+                    publicKey = fetchedContact.publicKey,
+                    createdAt = Date(),
+                    firstName = "",
+                    lastName = "",
+                    nickname = nickname,
+                    colorIndex = getIdColorIndex(fetchedContact.identity),
+                    verificationLevel = verificationLevel,
+                    workVerificationLevel = WorkVerificationLevel.NONE,
+                    identityType = fetchedContact.identityType,
+                    acquaintanceLevel = AcquaintanceLevel.DIRECT,
+                    activityState = fetchedContact.identityState,
+                    syncState = ContactSyncState.INITIAL,
+                    featureMask = fetchedContact.featureMask,
+                    readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+                    typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+                    androidContactLookupKey = null,
+                    localAvatarExpires = null,
+                    isRestored = false,
+                    profilePictureBlobId = null,
+                    jobTitle = null,
+                    department = null,
+                ),
+                handle,
+            )
+        }
+    }
+
+    private suspend fun executeMessageSteps(
+        message: AbstractMessage,
+        handle: ActiveTaskCodec,
+    ) {
+        val result = try {
+            getSubTaskFromMessage(message, TriggerSource.REMOTE, serviceManager).run(handle)
+        } catch (e: Exception) {
+            when (e) {
+                // If a network exception is thrown, we cancel processing the message to start over
+                // when the connection has been restarted.
+                is NetworkException -> throw e
+                // Any other exception should never be thrown. If there is one, we discard the
+                // message. Note that we also acknowledge discarded messages towards the server.
+                else -> {
+                    logger.error("Error while processing incoming message", e)
+                    throw DiscardMessageException(message)
+                }
+            }
+        }
+
+        if (result == ReceiveStepsResult.DISCARD) {
+            throw DiscardMessageException(message)
+        }
+    }
+
+    private fun updateReceivedTimestamp(message: AbstractMessage, receivedTimestamp: ULong) {
+        if (message is AbstractGroupMessage) {
+            messageService.getGroupMessageModel(
+                message.messageId,
+                message.groupCreator,
+                message.apiGroupId
+            )
+        } else {
+            messageService.getContactMessageModel(message.messageId, message.fromIdentity)
+        }?.let {
+            // Note that for incoming messages the received timestamp is stored in 'createdAt'
+            it.createdAt = Date(receivedTimestamp.toLong())
+            messageService.save(it)
+        }
+    }
+
+    private class DiscardMessageException(
+        val discardedMessage: AbstractMessage?,
+        val peerRatchetIdentifier: PeerRatchetIdentifier?,
+    ) : Exception() {
+        constructor() : this(null, null)
+        constructor(discardedMessage: AbstractMessage?) : this(discardedMessage, null)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingReflectedMessageTask.kt b/app/src/main/java/ch/threema/app/processors/IncomingReflectedMessageTask.kt
new file mode 100644
index 00000000..39386e67
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/IncomingReflectedMessageTask.kt
@@ -0,0 +1,256 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.getSubTaskFromMessage
+import ch.threema.app.processors.reflectedd2dsync.ReflectedContactSyncTask
+import ch.threema.app.processors.reflectedmessageupdate.ReflectedIncomingMessageUpdateTask
+import ch.threema.app.processors.reflectedmessageupdate.ReflectedOutgoingMessageUpdateTask
+import ch.threema.app.processors.reflectedoutgoingmessage.getReflectedOutgoingMessageTask
+import ch.threema.app.tasks.ActiveComposableTask
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.toHexString
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
+import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
+import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
+import ch.threema.domain.protocol.csp.messages.GroupTextMessage
+import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.TextMessage
+import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage
+import ch.threema.domain.protocol.csp.messages.ballot.GroupPollVoteMessage
+import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage
+import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage
+import ch.threema.domain.protocol.csp.messages.file.FileMessage
+import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage
+import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.domain.taskmanager.catchAllExceptNetworkException
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D.ContactSync
+import ch.threema.protobuf.d2d.MdD2D.DistributionListSync
+import ch.threema.protobuf.d2d.MdD2D.Envelope
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.CONTACT_SYNC
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.DISTRIBUTION_LIST_SYNC
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.GROUP_SYNC
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.INCOMING_MESSAGE
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.INCOMING_MESSAGE_UPDATE
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.MDM_PARAMETER_SYNC
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.OUTGOING_MESSAGE
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.OUTGOING_MESSAGE_UPDATE
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.SETTINGS_SYNC
+import ch.threema.protobuf.d2d.MdD2D.Envelope.ContentCase.USER_PROFILE_SYNC
+import ch.threema.protobuf.d2d.MdD2D.GroupSync
+import ch.threema.protobuf.d2d.MdD2D.IncomingMessage
+import ch.threema.protobuf.d2d.MdD2D.IncomingMessageUpdate
+import ch.threema.protobuf.d2d.MdD2D.MdmParameterSync
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessageUpdate
+import ch.threema.protobuf.d2d.MdD2D.SettingsSync
+import ch.threema.protobuf.d2d.MdD2D.UserProfileSync
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingReflectedMessageTask")
+
+class IncomingReflectedMessageTask(
+    private val message: InboundD2mMessage.Reflected,
+    private val serviceManager: ServiceManager,
+) : ActiveComposableTask<Unit> {
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
+
+    override suspend fun run(handle: ActiveTaskCodec) {
+        val multiDeviceProperties = multiDeviceManager.propertiesProvider.get()
+
+        val (nonce, envelope) = multiDeviceProperties.keys.decryptEnvelope(message.envelope)
+
+        logger.debug("Process reflected message: {} at {}", envelope, message.timestamp)
+
+        suspend {
+            if (!nonceFactory.exists(NonceScope.D2D, nonce)) {
+                processEnvelope(envelope, handle)
+            } else {
+                logger.warn("Skipped processing of reflected message {} as its nonce has already been used", message.reflectedId)
+            }
+        }.catchAllExceptNetworkException {
+            logger.error("Could not process reflected envelope", it)
+            // TODO(ANDR-2706): Handle these exceptions
+        }
+
+        // Finally send a reflected ack and store the nonce
+        handle.write(OutboundD2mMessage.ReflectedAck(message.reflectedId))
+        // Note that the existence of the nonce is checked again before storing it to avoid logging
+        // an exception
+        // TODO(ANDR-2983): Only store the nonce if it has to be stored according to protocol
+        if (!nonceFactory.exists(NonceScope.D2D, nonce)) {
+            nonceFactory.store(NonceScope.D2D, nonce)
+        }
+    }
+
+    private suspend fun processEnvelope(envelope: Envelope, handle: ActiveTaskCodec) {
+        when (envelope.contentCase) {
+            OUTGOING_MESSAGE -> {
+                processOutgoingMessage(envelope.outgoingMessage)
+            }
+
+            OUTGOING_MESSAGE_UPDATE -> {
+                processOutgoingMessageUpdate(envelope.outgoingMessageUpdate)
+            }
+
+            INCOMING_MESSAGE -> {
+                processIncomingMessage(envelope.incomingMessage, handle)
+            }
+
+            INCOMING_MESSAGE_UPDATE -> {
+                processIncomingMessageUpdate(envelope.incomingMessageUpdate)
+            }
+
+            USER_PROFILE_SYNC -> {
+                processUserProfileSync(envelope.userProfileSync)
+            }
+
+            CONTACT_SYNC -> {
+                processContactSync(envelope.contactSync)
+            }
+
+            GROUP_SYNC -> {
+                processGroupSync(envelope.groupSync)
+            }
+
+            DISTRIBUTION_LIST_SYNC -> {
+                processDistributionListSync(envelope.distributionListSync)
+            }
+
+            SETTINGS_SYNC -> {
+                processSettingsSync(envelope.settingsSync)
+            }
+
+            MDM_PARAMETER_SYNC -> {
+                processMdmParameterSync(envelope.mdmParameterSync)
+            }
+
+            else -> logger.error("Reflected message with unknown content type {} received", envelope.contentCase)
+        }
+    }
+
+    private fun processOutgoingMessage(outgoingMessage: OutgoingMessage) {
+        outgoingMessage.getReflectedOutgoingMessageTask(serviceManager)
+            .executeReflectedOutgoingMessageSteps()
+    }
+
+    private fun processOutgoingMessageUpdate(outgoingMessageUpdate: OutgoingMessageUpdate) {
+        ReflectedOutgoingMessageUpdateTask(outgoingMessageUpdate, message.timestamp, serviceManager).run()
+    }
+
+    private suspend fun processIncomingMessage(
+        incomingMessage: IncomingMessage,
+        handle: ActiveTaskCodec,
+    ) {
+        when (incomingMessage.type) {
+            Common.CspE2eMessageType.TEXT -> TextMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.FILE -> FileMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.GROUP_FILE -> GroupFileMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.DELIVERY_RECEIPT -> DeliveryReceiptMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.GROUP_DELIVERY_RECEIPT -> GroupDeliveryReceiptMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.GROUP_TEXT -> GroupTextMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.POLL_SETUP -> PollSetupMessage.fromReflected(incomingMessage, incomingMessage.senderIdentity)
+            Common.CspE2eMessageType.POLL_VOTE -> PollVoteMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.GROUP_POLL_SETUP -> GroupPollSetupMessage.fromReflected(incomingMessage, incomingMessage.senderIdentity)
+            Common.CspE2eMessageType.GROUP_POLL_VOTE -> GroupPollVoteMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CALL_OFFER -> VoipCallOfferMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CALL_ICE_CANDIDATE -> VoipICECandidatesMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CALL_RINGING -> VoipCallRingingMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CALL_ANSWER -> VoipCallAnswerMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CALL_HANGUP -> VoipCallHangupMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.GROUP_CALL_START -> GroupCallStartMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CONTACT_REQUEST_PROFILE_PICTURE -> ContactRequestProfilePictureMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CONTACT_SET_PROFILE_PICTURE -> SetProfilePictureMessage.fromReflected(incomingMessage)
+            Common.CspE2eMessageType.CONTACT_DELETE_PROFILE_PICTURE -> DeleteProfilePictureMessage.fromReflected(incomingMessage)
+
+            else -> {
+                logger.warn("Reflected incoming message of type {} is not yet supported", incomingMessage.type)
+                null
+            }
+        }?.let { message: AbstractMessage ->
+            if (message.protectAgainstReplay()) {
+                val nonce = Nonce(incomingMessage.nonce.toByteArray())
+                if (nonceFactory.exists(NonceScope.CSP, nonce)) {
+                    logger.info("Skip adding preexisting CSP nonce {}", nonce.bytes.toHexString())
+                } else if (!nonceFactory.store(NonceScope.CSP, nonce)) {
+                    logger.warn("CSP nonce {} of outgoing message could not be stored", nonce.bytes.toHexString())
+                }
+            } else {
+                logger.debug("Do not store nonces for message of type {}", incomingMessage.type)
+            }
+            getSubTaskFromMessage(message, TriggerSource.SYNC, serviceManager).run(handle)
+        }
+    }
+
+    private fun processIncomingMessageUpdate(incomingMessageUpdate: IncomingMessageUpdate) {
+        ReflectedIncomingMessageUpdateTask(incomingMessageUpdate, serviceManager).run()
+    }
+
+    private fun processUserProfileSync(userProfileSync: UserProfileSync) {
+        // TODO(ANDR-2840)
+        logger.warn("User profile sync is not yet supported")
+    }
+
+    private fun processContactSync(contactSync: ContactSync) {
+        ReflectedContactSyncTask(
+            contactSync,
+            serviceManager.modelRepositories.contacts,
+            serviceManager,
+        ).run()
+    }
+
+    private fun processGroupSync(groupSync: GroupSync) {
+        // TODO(ANDR-2741)
+        logger.warn("Group sync is not yet supported")
+    }
+
+    private fun processDistributionListSync(distributionListSync: DistributionListSync) {
+        // TODO(ANDR-2718)
+        logger.warn("Distribution sync is not yet supported")
+    }
+
+    private fun processSettingsSync(settingsSync: SettingsSync) {
+        // TODO(ANDR-2839)
+        logger.warn("Settings sync is not yet supported")
+    }
+
+    private fun processMdmParameterSync(mdmParameterSync: MdmParameterSync) {
+        // TODO(ANDR-2670)
+        logger.warn("Mdm parameter sync is not yet supported")
+    }
+
+}
diff --git a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingDeleteProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingDeleteProfilePictureTask.kt
deleted file mode 100644
index 80e4e76e..00000000
--- a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingDeleteProfilePictureTask.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.contactcontrol
-
-import ch.threema.app.listeners.ContactListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.ContactModel
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingDeleteProfilePictureTask")
-
-class IncomingDeleteProfilePictureTask(
-    private val message: DeleteProfilePictureMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val contactService by lazy { serviceManager.contactService }
-    private val fileService by lazy { serviceManager.fileService }
-    private val avatarCacheService by lazy { serviceManager.avatarCacheService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val contactModel: ContactModel = contactService.getByIdentity(message.fromIdentity) ?: run {
-            logger.warn("Delete profile picture message received from unknown contact")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        fileService.removeContactPhoto(contactModel.identity)
-        this.avatarCacheService.reset(contactModel)
-        ListenerManager.contactListeners.handle { listener: ContactListener ->
-            listener.onAvatarChanged(contactModel)
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingSetProfilePictureTask.kt
deleted file mode 100644
index b2bd8006..00000000
--- a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingSetProfilePictureTask.kt
+++ /dev/null
@@ -1,78 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.contactcontrol
-
-import ch.threema.app.listeners.ContactListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.blob.BlobLoader
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.catchAllExceptNetworkException
-import com.neilalexander.jnacl.NaCl
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingSetProfilePictureTask")
-
-class IncomingSetProfilePictureTask(
-    private val message: SetProfilePictureMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val contactService by lazy { serviceManager.contactService }
-    private val apiService by lazy { serviceManager.apiService }
-    private val fileService by lazy { serviceManager.fileService }
-    private val avatarCacheService by lazy { serviceManager.avatarCacheService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val contactModel = contactService.getByIdentity(message.fromIdentity) ?: run {
-            logger.warn("Received profile picture from unknown contact")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val blobLoader: BlobLoader = this.apiService.createLoader(message.blobId)
-
-        // Download blob and throw exception if there is no blob
-        val encryptedBlob = {
-            blobLoader.load(false)
-        }.catchAllExceptNetworkException {
-            logger.error("Could not download profile picture", it)
-            // TODO(ANDR-2869): We should act differently depending on the cause of the failure
-            throw it
-        } ?: throw IllegalStateException("Profile picture blob is null")
-
-        NaCl.symmetricDecryptDataInplace(
-            encryptedBlob,
-            message.encryptionKey,
-            ProtocolDefines.CONTACT_PHOTO_NONCE
-        )
-        this.fileService.writeContactPhoto(contactModel.identity, encryptedBlob)
-        this.avatarCacheService.reset(contactModel)
-        ListenerManager.contactListeners.handle { listener: ContactListener ->
-            listener.onAvatarChanged(contactModel)
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupEditMessageTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupEditMessageTask.kt
deleted file mode 100644
index 816f06b4..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupEditMessageTask.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.app.tasks.runCommonEditMessageReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.GroupEditMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import org.slf4j.Logger
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingGroupEditMessageTask")
-
-class IncomingGroupEditMessageTask(
-        private val editMessage: GroupEditMessage,
-        serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-
-    private val messageService by lazy { serviceManager.messageService }
-    private val groupService by lazy { serviceManager.groupService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingGroupEditMessageTask id: ${editMessage.data.messageId}")
-
-        val groupModel = runCommonGroupReceiveSteps(editMessage, handle, serviceManager)
-                ?: return ReceiveStepsResult.DISCARD
-
-        val receiver = groupService.createReceiver(groupModel)
-        val message = runCommonEditMessageReceiveSteps(editMessage, receiver, messageService)
-            ?: return ReceiveStepsResult.DISCARD
-
-        messageService.saveEditedMessageText(message, editMessage.data.text, editMessage.date)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetupTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetupTask.kt
deleted file mode 100644
index 1ad23c20..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetupTask.kt
+++ /dev/null
@@ -1,231 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.filterValid
-import ch.threema.app.utils.sendMessageToReceivers
-import ch.threema.app.utils.toContactModels
-import ch.threema.app.voip.groupcall.localGroupId
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.GroupModel
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupSetupTask")
-
-class IncomingGroupSetupTask(
-    private val groupSetupMessage: GroupSetupMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val userService = serviceManager.userService
-    private val contactService = serviceManager.contactService
-    private val groupService = serviceManager.groupService
-    private val blockedContactsService = serviceManager.blockedContactsService
-    private val groupCallManager = serviceManager.groupCallManager
-    private val databaseService = serviceManager.databaseServiceNew
-    private val contactStore = serviceManager.contactStore
-    private val identityStore = serviceManager.identityStore
-    private val nonceFactory = serviceManager.nonceFactory
-    private val apiConnector by lazy { serviceManager.apiConnector }
-    private val taskCreator by lazy { serviceManager.taskCreator }
-    private val preferenceService = serviceManager.preferenceService
-    private val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        // 1. Let members be the given member list. Remove all duplicate entries from members.
-        // Remove the sender from members if present.
-        val sender = groupSetupMessage.fromIdentity
-        val members = groupSetupMessage.members.filter { it != sender }.toSet()
-        val myIdentity = userService.identity
-
-        // 2. Look up the group
-        var group = groupService.getByGroupMessage(groupSetupMessage)
-        val previousMemberCount = if (group != null) {
-            groupService.countMembers(group)
-        } else {
-            0
-        }
-
-        val newGroup = group == null
-
-        // 3. If the group could not be found:
-        if (group == null) {
-            // 3.1 If the user is not present in members, abort these steps
-            if (!members.contains(myIdentity)) {
-                logger.info("Dismissing group setup message for unknown group without the user as member")
-                return ReceiveStepsResult.DISCARD
-            }
-            // 3.2 If the sender is blocked, send a group-leave message to the sender and all
-            // provided members (including those who are blocked) and abort these steps.
-            if (isBlocked(sender)) {
-                logger.info("Sending a leave message to the creator of a new group that is blocked")
-                sendLeave(handle, groupSetupMessage.apiGroupId, sender, members)
-                return ReceiveStepsResult.SUCCESS
-            }
-        }
-
-        // 4. If the group could be found and members is empty or does not include the user:
-        if (group != null && !members.contains(myIdentity)) {
-            // 4.1 If the user is currently participating in a group call of this group, trigger
-            // leaving the call.
-            if (groupCallManager.hasJoinedCall(group.localGroupId)) {
-                logger.info("Group call is running in a group where the user just has been kicked")
-                groupCallManager.abortCurrentCall()
-            }
-
-            // If we are not a member anyway, we do not have to do anything. Especially, we should
-            // not call the listener as this would trigger a status message each time.
-            if (!groupService.isGroupMember(group)) {
-                return ReceiveStepsResult.SUCCESS
-            }
-
-            // 4.2 Mark the group as left and abort these steps.
-            groupService.removeMemberFromGroup(group, myIdentity)
-
-            ListenerManager.groupListeners.handle {
-                it.onMemberKicked(
-                    group,
-                    myIdentity,
-                    previousMemberCount,
-                )
-            }
-
-            return ReceiveStepsResult.SUCCESS
-        }
-
-        // 5. For each member of members, create a contact with acquaintance level group
-        // if not already present in the contact list.
-        val unknownContacts = members.filter { contactService.getByIdentity(it) == null }
-        contactService.createGroupContactsByIdentities(unknownContacts)
-
-        // 6. Create or update the group with the given members plus the sender (creator).
-        val now = Date()
-        if (group == null) {
-            group = GroupModel().apply {
-                apiGroupId = groupSetupMessage.apiGroupId
-                creatorIdentity = groupSetupMessage.groupCreator
-                createdAt = now
-                lastUpdate = now
-            }
-            databaseService.groupModelFactory.create(group)
-        } else if (group.isDeleted || !groupService.isGroupMember(group)) {
-            group.isDeleted = false
-            group.lastUpdate = now
-            databaseService.groupModelFactory.update(group)
-        }
-        updateMembers(group, members, previousMemberCount)
-
-        // If the group is new, then fire the listener.
-        if (newGroup) {
-            ListenerManager.groupListeners.handle { it.onCreate(group) }
-        }
-
-        // 7. If the group was previously marked as left, remove the left mark.
-        // Note that this step is already handled in step 6, because a group is defined to be left,
-        // if the user is not part of the members.
-
-        // 8. Run the rejected messages refresh steps for the group
-        groupService.runRejectedMessagesRefreshSteps(group)
-
-        // 9. If the user is currently participating in a group call of this group and there are
-        // group call participants that are no longer members of the group, remove these
-        // participants from the group call (handle them as if they left the call).
-        groupCallManager.updateAllowedCallParticipants(group)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-
-    private suspend fun sendLeave(
-        handle: ActiveTaskCodec,
-        apiGroupId: GroupId,
-        creatorIdentity: String,
-        members: Set<String>,
-    ) {
-        val messageId = MessageId()
-        val myIdentity = userService.identity
-
-        val recipients = (members + creatorIdentity - myIdentity)
-            .toContactModels(contactService, apiConnector)
-            .filterValid()
-            .toSet()
-
-        handle.sendMessageToReceivers(
-            OutgoingCspGroupMessageCreator(messageId, apiGroupId, creatorIdentity) { GroupLeaveMessage() },
-            recipients,
-            forwardSecurityMessageProcessor,
-            identityStore,
-            contactStore,
-            nonceFactory,
-            blockedContactsService,
-            taskCreator
-        )
-    }
-
-    private fun updateMembers(group: GroupModel, members: Set<String>, previousMemberCount: Int) {
-        // Delete all local group members that are not a member of the updated group. Don't delete
-        // the group creator.
-        val localMembersToDelete = groupService.getGroupMemberModels(group)
-            .filter { group.creatorIdentity != it.identity && !members.contains(it.identity) }
-
-        localMembersToDelete.forEach { memberModel ->
-            // Remove member from group
-            groupService.removeMemberFromGroup(group, memberModel.identity)
-
-            // Notify listeners that the member has been removed
-            ListenerManager.groupListeners.handle {
-                it.onMemberKicked(
-                    group,
-                    memberModel.identity,
-                    previousMemberCount
-                )
-            }
-        }
-
-        // All members that are already added (including the group creator)
-        val addedMembers = groupService.getGroupMemberModels(group).map { it.identity }
-
-        // All members including the creator that should be part of the group
-        val allMembers = (listOf(group.creatorIdentity) + members).toSet()
-
-        // Add all members to the group that are not already in the group
-        allMembers.filter { !addedMembers.contains(it) }.forEach { memberIdentity ->
-            if (groupService.addMemberToGroup(group, memberIdentity)) {
-                ListenerManager.groupListeners.handle {
-                    it.onNewMember(group, memberIdentity, previousMemberCount)
-                }
-            }
-        }
-    }
-
-    private fun isBlocked(identity: String): Boolean =
-        blockedContactsService.has(identity) ||
-                (contactService.getByIdentity(identity) == null && preferenceService.isBlockUnknown)
-}
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/IncomingCspMessageSubTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/IncomingCspMessageSubTask.kt
new file mode 100644
index 00000000..510732c2
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/IncomingCspMessageSubTask.kt
@@ -0,0 +1,211 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.calls.IncomingCallAnswerTask
+import ch.threema.app.processors.incomingcspmessage.calls.IncomingCallHangupTask
+import ch.threema.app.processors.incomingcspmessage.calls.IncomingCallIceCandidateTask
+import ch.threema.app.processors.incomingcspmessage.calls.IncomingCallOfferTask
+import ch.threema.app.processors.incomingcspmessage.calls.IncomingCallRingingTask
+import ch.threema.app.processors.incomingcspmessage.contactcontrol.IncomingContactRequestProfilePictureTask
+import ch.threema.app.processors.incomingcspmessage.contactcontrol.IncomingDeleteProfilePictureTask
+import ch.threema.app.processors.incomingcspmessage.contactcontrol.IncomingSetProfilePictureTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingContactConversationMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingContactDeleteMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingContactEditMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingContactFileMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingContactPollSetupTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingContactPollVoteTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingGroupConversationMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingGroupDeleteMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingGroupEditMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingGroupFileMessageTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingGroupPollSetupTask
+import ch.threema.app.processors.incomingcspmessage.conversation.IncomingGroupPollVoteTask
+import ch.threema.app.processors.incomingcspmessage.fs.IncomingEmptyTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupCallControlTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupDeleteProfilePictureTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupJoinRequestTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupJoinResponseMessage
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupLeaveTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupNameTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupSetProfilePictureTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupSetupTask
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupSyncRequestTask
+import ch.threema.app.processors.incomingcspmessage.statusupdates.IncomingDeliveryReceiptTask
+import ch.threema.app.processors.incomingcspmessage.statusupdates.IncomingGroupDeliveryReceiptTask
+import ch.threema.app.processors.incomingcspmessage.statusupdates.IncomingTypingIndicatorTask
+import ch.threema.app.tasks.ActiveComposableTask
+import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.DeleteMessage
+import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
+import ch.threema.domain.protocol.csp.messages.EditMessage
+import ch.threema.domain.protocol.csp.messages.EmptyMessage
+import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
+import ch.threema.domain.protocol.csp.messages.GroupDeleteProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
+import ch.threema.domain.protocol.csp.messages.GroupEditMessage
+import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
+import ch.threema.domain.protocol.csp.messages.GroupNameMessage
+import ch.threema.domain.protocol.csp.messages.GroupSetProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
+import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
+import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
+import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage
+import ch.threema.domain.protocol.csp.messages.ballot.GroupPollVoteMessage
+import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage
+import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage
+import ch.threema.domain.protocol.csp.messages.file.FileMessage
+import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage
+import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestMessage
+import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseMessage
+import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallControlMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
+import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+import okhttp3.internal.toHexString
+
+abstract class IncomingCspMessageSubTask<T : AbstractMessage?>(
+    protected val message: T,
+    protected val triggerSource: TriggerSource,
+    protected val serviceManager: ServiceManager,
+) : ActiveComposableTask<ReceiveStepsResult> {
+    init {
+        // Check that the trigger source is not local as an incoming message can only be triggered
+        // by remote or by sync.
+        if (triggerSource == TriggerSource.LOCAL) {
+            throw IllegalStateException("An incoming csp message can never be locally created")
+        }
+    }
+
+    final override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+        // Check that the message and the trigger source is a valid combination
+        if (message != null && !message.reflectIncoming() && triggerSource == TriggerSource.SYNC) {
+            throw IllegalStateException("An incoming message of type ${message.type.toHexString()} has been received as reflected that should not have been reflected")
+        }
+
+        // Choose the right message steps depending on the trigger source
+        return when (triggerSource) {
+            TriggerSource.REMOTE -> executeMessageStepsFromRemote(handle)
+            TriggerSource.SYNC -> executeMessageStepsFromSync()
+            TriggerSource.LOCAL -> throw IllegalStateException("Cannot process an incoming message from local")
+        }
+    }
+
+    /**
+     * Execute the message receive steps for the given message type. Note that this must only be
+     * called when the message is coming from the chat server (from remote) and not when it has been
+     * reflected (from sync).
+     */
+    protected abstract suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult
+
+    /**
+     * Execute the message receive steps for the given message type. Note that this must be called
+     * when the message has been received from sync (reflected).
+     */
+    protected abstract suspend fun executeMessageStepsFromSync(): ReceiveStepsResult
+}
+
+enum class ReceiveStepsResult {
+    SUCCESS,
+    DISCARD,
+}
+
+fun getSubTaskFromMessage(
+    message: AbstractMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+): IncomingCspMessageSubTask<*> = when (message) {
+    // Determine the message type and get its corresponding receive steps. Note that the order
+    // of checking the types is important. For instance, an abstract group message must first be
+    // checked for a group control message to prevent processing it as a group conversation
+    // message.
+
+    // Check if message is a status update
+    is TypingIndicatorMessage -> IncomingTypingIndicatorTask(message, triggerSource, serviceManager)
+    is DeliveryReceiptMessage -> IncomingDeliveryReceiptTask(message, triggerSource, serviceManager)
+    is GroupDeliveryReceiptMessage -> IncomingGroupDeliveryReceiptTask(message, triggerSource, serviceManager)
+
+    // Check if message is a group control message
+    is GroupSetupMessage -> IncomingGroupSetupTask(message, triggerSource, serviceManager)
+    is GroupNameMessage -> IncomingGroupNameTask(message, triggerSource, serviceManager)
+    is GroupSetProfilePictureMessage -> IncomingGroupSetProfilePictureTask(message, triggerSource, serviceManager)
+
+    is GroupDeleteProfilePictureMessage -> IncomingGroupDeleteProfilePictureTask(message, triggerSource, serviceManager)
+
+    is GroupLeaveMessage -> IncomingGroupLeaveTask(message, triggerSource, serviceManager)
+    is GroupSyncRequestMessage -> IncomingGroupSyncRequestTask(message, triggerSource, serviceManager)
+    is GroupCallControlMessage -> IncomingGroupCallControlTask(message, triggerSource, serviceManager)
+
+    // Check if message is a contact control message
+    is SetProfilePictureMessage -> IncomingSetProfilePictureTask(message, triggerSource, serviceManager)
+    is DeleteProfilePictureMessage -> IncomingDeleteProfilePictureTask(message, triggerSource, serviceManager)
+
+    is ContactRequestProfilePictureMessage -> IncomingContactRequestProfilePictureTask(message, triggerSource, serviceManager)
+
+    // Check if message is a ballot message
+    is PollSetupMessage -> IncomingContactPollSetupTask(message, triggerSource, serviceManager)
+    is PollVoteMessage -> IncomingContactPollVoteTask(message, triggerSource, serviceManager)
+    is GroupPollSetupMessage -> IncomingGroupPollSetupTask(message, triggerSource, serviceManager)
+    is GroupPollVoteMessage -> IncomingGroupPollVoteTask(message, triggerSource, serviceManager)
+
+    // Check if message is a group join message
+    is GroupJoinRequestMessage -> IncomingGroupJoinRequestTask(message, triggerSource, serviceManager)
+    is GroupJoinResponseMessage -> IncomingGroupJoinResponseMessage(message, triggerSource, serviceManager)
+
+    // Check if message is a call message
+    is VoipCallOfferMessage -> IncomingCallOfferTask(message, triggerSource, serviceManager)
+    is VoipCallAnswerMessage -> IncomingCallAnswerTask(message, triggerSource, serviceManager)
+    is VoipICECandidatesMessage -> IncomingCallIceCandidateTask(message, triggerSource, serviceManager)
+    is VoipCallRingingMessage -> IncomingCallRingingTask(message, triggerSource, serviceManager)
+    is VoipCallHangupMessage -> IncomingCallHangupTask(message, triggerSource, serviceManager)
+
+    // Check if message is an edit message
+    is EditMessage -> IncomingContactEditMessageTask(message, triggerSource, serviceManager)
+    is GroupEditMessage -> IncomingGroupEditMessageTask(message, triggerSource, serviceManager)
+
+    // Check if message is a delete message
+    is DeleteMessage -> IncomingContactDeleteMessageTask(message, triggerSource, serviceManager)
+    is GroupDeleteMessage -> IncomingGroupDeleteMessageTask(message, triggerSource, serviceManager)
+
+    // Check if message is a file message
+    is FileMessage -> IncomingContactFileMessageTask(message, triggerSource, serviceManager)
+    is GroupFileMessage -> IncomingGroupFileMessageTask(message, triggerSource, serviceManager)
+
+    // If it is a group message, process it as a group conversation message
+    is AbstractGroupMessage -> IncomingGroupConversationMessageTask(message, triggerSource, serviceManager)
+
+    // Process the empty message in its corresponding task
+    is EmptyMessage -> IncomingEmptyTask(message, triggerSource, serviceManager)
+
+    // Otherwise it must be a contact conversation message
+    else -> IncomingContactConversationMessageTask(message, triggerSource, serviceManager)
+}
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallAnswerTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallAnswerTask.kt
similarity index 62%
rename from app/src/main/java/ch/threema/app/processors/calls/IncomingCallAnswerTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallAnswerTask.kt
index 8fc1e4f2..38faea5b 100644
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallAnswerTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallAnswerTask.kt
@@ -19,25 +19,30 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.calls
+package ch.threema.app.processors.incomingcspmessage.calls
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingCallAnswerTask(
-    private val message: VoipCallAnswerMessage,
+    message: VoipCallAnswerMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<VoipCallAnswerMessage>(message, triggerSource, serviceManager) {
     private val voipStateService = serviceManager.voipStateService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleCallAnswer(message)) {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult = processCallAnswer()
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processCallAnswer()
+
+    private fun processCallAnswer() =
+        if (voipStateService.handleCallAnswer(message)) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
         }
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallHangupTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallHangupTask.kt
similarity index 62%
rename from app/src/main/java/ch/threema/app/processors/calls/IncomingCallHangupTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallHangupTask.kt
index 7a00d0a0..b6a24ec7 100644
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallHangupTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallHangupTask.kt
@@ -19,25 +19,30 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.calls
+package ch.threema.app.processors.incomingcspmessage.calls
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingCallHangupTask(
-    private val message: VoipCallHangupMessage,
+    message: VoipCallHangupMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<VoipCallHangupMessage>(message, triggerSource, serviceManager) {
     private val voipStateService = serviceManager.voipStateService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleRemoteCallHangup(message)) {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult = processCallHangup()
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processCallHangup()
+
+    private fun processCallHangup() =
+        if (voipStateService.handleRemoteCallHangup(message)) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
         }
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallIceCandidateTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallIceCandidateTask.kt
similarity index 61%
rename from app/src/main/java/ch/threema/app/processors/calls/IncomingCallIceCandidateTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallIceCandidateTask.kt
index 384ff8f2..8c685b69 100644
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallIceCandidateTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallIceCandidateTask.kt
@@ -19,25 +19,30 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.calls
+package ch.threema.app.processors.incomingcspmessage.calls
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingCallIceCandidateTask(
-    private val message: VoipICECandidatesMessage,
+    message: VoipICECandidatesMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<VoipICECandidatesMessage>(message, triggerSource, serviceManager) {
     private val voipStateService = serviceManager.voipStateService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleICECandidates(message)) {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult = processICECandidate()
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processICECandidate()
+
+    private fun processICECandidate() =
+        if (voipStateService.handleICECandidates(message)) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
         }
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallOfferTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallOfferTask.kt
similarity index 61%
rename from app/src/main/java/ch/threema/app/processors/calls/IncomingCallOfferTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallOfferTask.kt
index 0be3b12c..bbf73b74 100644
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallOfferTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallOfferTask.kt
@@ -19,25 +19,30 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.calls
+package ch.threema.app.processors.incomingcspmessage.calls
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingCallOfferTask(
-    private val message: VoipCallOfferMessage,
+    message: VoipCallOfferMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<VoipCallOfferMessage>(message, triggerSource, serviceManager) {
     private val voipStateService = serviceManager.voipStateService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleCallOffer(message)) {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult = processCallOffer()
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processCallOffer()
+
+    private fun processCallOffer(): ReceiveStepsResult =
+        if (voipStateService.handleCallOffer(message)) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
         }
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallRingingTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallRingingTask.kt
similarity index 62%
rename from app/src/main/java/ch/threema/app/processors/calls/IncomingCallRingingTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallRingingTask.kt
index 3a57354c..792d7913 100644
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallRingingTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallRingingTask.kt
@@ -19,25 +19,30 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.calls
+package ch.threema.app.processors.incomingcspmessage.calls
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingCallRingingTask(
-    private val message: VoipCallRingingMessage,
+    message: VoipCallRingingMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<VoipCallRingingMessage>(message, triggerSource, serviceManager) {
     private val voipStateService = serviceManager.voipStateService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleCallRinging(message)) {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult = processCallRinging()
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processCallRinging()
+
+    private fun processCallRinging() =
+        if (voipStateService.handleCallRinging(message)) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
         }
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingContactRequestProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingContactRequestProfilePictureTask.kt
similarity index 56%
rename from app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingContactRequestProfilePictureTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingContactRequestProfilePictureTask.kt
index 7a59a06b..6c973711 100644
--- a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingContactRequestProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingContactRequestProfilePictureTask.kt
@@ -19,31 +19,42 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.contactcontrol
+package ch.threema.app.processors.incomingcspmessage.contactcontrol
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingContactRequestProfilePictureTask")
 
 class IncomingContactRequestProfilePictureTask(
-    private val message: ContactRequestProfilePictureMessage,
+    message: ContactRequestProfilePictureMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val contactService = serviceManager.contactService
+) : IncomingCspMessageSubTask<ContactRequestProfilePictureMessage>(message, triggerSource, serviceManager) {
+    private val contactModelRepository by lazy { serviceManager.modelRepositories.contacts }
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val contactModel = contactService.getByIdentity(message.fromIdentity)
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        return processIncomingContactRequestProfilePictureMessage()
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        return processIncomingContactRequestProfilePictureMessage()
+    }
+
+    private fun processIncomingContactRequestProfilePictureMessage(): ReceiveStepsResult {
+        val contactModel = contactModelRepository.getByIdentity(message.fromIdentity)
         if (contactModel == null) {
             logger.warn("Received incoming contact request profile picture message from unknown contact")
             return ReceiveStepsResult.DISCARD
         }
 
-        contactService.resetContactPhotoSentState(contactModel)
+        contactModel.setProfilePictureBlobId(null)
+
         return ReceiveStepsResult.SUCCESS
     }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingDeleteProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingDeleteProfilePictureTask.kt
new file mode 100644
index 00000000..905279fb
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingDeleteProfilePictureTask.kt
@@ -0,0 +1,91 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.contactcontrol
+
+import ch.threema.app.listeners.ContactListener
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.tasks.ReflectContactSyncUpdateImmediateTask.ReflectContactProfilePicture
+import ch.threema.app.utils.ShortcutUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingDeleteProfilePictureTask")
+
+class IncomingDeleteProfilePictureTask(
+    message: DeleteProfilePictureMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<DeleteProfilePictureMessage>(message, triggerSource, serviceManager) {
+    private val fileService by lazy { serviceManager.fileService }
+    private val contactService by lazy { serviceManager.contactService }
+    private val contactModelRepository by lazy { serviceManager.modelRepositories.contacts }
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
+
+    private val identity = message.fromIdentity
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        val contactModel = contactModelRepository.getByIdentity(identity) ?: run {
+            logger.warn("Delete profile picture message received from unknown contact")
+            return ReceiveStepsResult.DISCARD
+        }
+
+        reflectProfilePictureRemoved(handle)
+
+        fileService.removeContactDefinedProfilePicture(identity)
+        ListenerManager.contactListeners.handle { listener: ContactListener ->
+            listener.onAvatarChanged(identity)
+        }
+
+        ShortcutUtil.updateShareTargetShortcut(contactService.createReceiver(contactModel))
+
+        contactModel.setIsRestored(false)
+
+        return ReceiveStepsResult.SUCCESS
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        val contactModel = contactModelRepository.getByIdentity(identity) ?: run {
+            logger.error("Reflected delete profile picture message received from unknown contact")
+            return ReceiveStepsResult.DISCARD
+        }
+        contactModel.setIsRestored(false)
+        return ReceiveStepsResult.SUCCESS
+    }
+
+    private suspend fun reflectProfilePictureRemoved(handle: ActiveTaskCodec) {
+        if (multiDeviceManager.isMultiDeviceActive) {
+            ReflectContactProfilePicture(
+                contactIdentity = identity,
+                profilePictureUpdate = ReflectContactProfilePicture.RemovedProfilePicture,
+                contactModelRepository = contactModelRepository,
+                multiDeviceManager = multiDeviceManager,
+                nonceFactory = nonceFactory,
+            ).reflect(handle)
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingSetProfilePictureTask.kt
new file mode 100644
index 00000000..be4dcbca
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingSetProfilePictureTask.kt
@@ -0,0 +1,130 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.contactcontrol
+
+import ch.threema.app.listeners.ContactListener
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.tasks.ReflectContactSyncUpdateImmediateTask.ReflectContactProfilePicture
+import ch.threema.app.utils.ShortcutUtil
+import ch.threema.app.utils.contentEquals
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.blob.BlobLoader
+import ch.threema.domain.protocol.blob.BlobScope
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.domain.taskmanager.catchAllExceptNetworkException
+import com.neilalexander.jnacl.NaCl
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingSetProfilePictureTask")
+
+class IncomingSetProfilePictureTask(
+    message: SetProfilePictureMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<SetProfilePictureMessage>(message, triggerSource, serviceManager) {
+    private val apiService by lazy { serviceManager.apiService }
+    private val fileService by lazy { serviceManager.fileService }
+    private val contactService by lazy { serviceManager.contactService }
+    private val contactModelRepository by lazy { serviceManager.modelRepositories.contacts }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+
+    private val identity by lazy { message.fromIdentity }
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        val contactModel = contactModelRepository.getByIdentity(identity) ?: run {
+            logger.warn("Received profile picture from unknown contact")
+            return ReceiveStepsResult.DISCARD
+        }
+
+        contactModel.setIsRestored(false)
+
+        val identity = message.fromIdentity
+
+        val blobLoader: BlobLoader = this.apiService.createLoader(message.blobId)
+
+        // Download blob and throw exception if there is no blob
+        val encryptedBlob: ByteArray = {
+            blobLoader.load(
+                BlobScope.Public // since its an incoming message, always use the public scope
+            )
+        }.catchAllExceptNetworkException {
+            logger.error("Could not download profile picture", it)
+            // TODO(ANDR-2869): We should act differently depending on the cause of the failure
+            throw it
+        } ?: throw IllegalStateException("Profile picture blob is null")
+
+        NaCl.symmetricDecryptDataInplace(
+            encryptedBlob,
+            message.encryptionKey,
+            ProtocolDefines.CONTACT_PHOTO_NONCE
+        )
+
+        // Note that we do reflect the profile picture even if it did not change. This allows the
+        // other devices to remove the blob from the blob mirror.
+        reflectProfilePicture(handle)
+
+        if (fileService.getContactDefinedProfilePictureStream(identity).contentEquals(encryptedBlob)) {
+            logger.info("Profile picture did not change")
+            return ReceiveStepsResult.SUCCESS
+        }
+
+        this.fileService.writeContactDefinedProfilePicture(identity, encryptedBlob)
+        ListenerManager.contactListeners.handle { listener: ContactListener ->
+            listener.onAvatarChanged(identity)
+        }
+
+        ShortcutUtil.updateShareTargetShortcut(contactService.createReceiver(contactModel))
+
+        return ReceiveStepsResult.SUCCESS
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        val contactModel = contactModelRepository.getByIdentity(identity) ?: run {
+            logger.error("Reflected set profile picture message received from unknown contact")
+            return ReceiveStepsResult.DISCARD
+        }
+        contactModel.setIsRestored(false)
+        return ReceiveStepsResult.SUCCESS
+    }
+
+    private suspend fun reflectProfilePicture(handle: ActiveTaskCodec) {
+        if (multiDeviceManager.isMultiDeviceActive) {
+            ReflectContactProfilePicture(
+                contactIdentity = identity,
+                profilePictureUpdate = ReflectContactProfilePicture.UpdatedProfilePicture(
+                    blobId = message.blobId,
+                    nonce = ProtocolDefines.CONTACT_PHOTO_NONCE,
+                    encryptionKey = message.encryptionKey,
+                ),
+                contactModelRepository = contactModelRepository,
+                multiDeviceManager = multiDeviceManager,
+                nonceFactory = nonceFactory,
+            ).reflect(handle)
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactConversationMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactConversationMessageTask.kt
similarity index 64%
rename from app/src/main/java/ch/threema/app/processors/conversation/IncomingContactConversationMessageTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactConversationMessageTask.kt
index 020f0d2b..2186a334 100644
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactConversationMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactConversationMessageTask.kt
@@ -19,21 +19,28 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.conversation
+package ch.threema.app.processors.incomingcspmessage.conversation
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.AbstractMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingContactConversationMessageTask(
-    private val message: AbstractMessage,
+    message: AbstractMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<AbstractMessage>(message, triggerSource, serviceManager) {
     private val messageService = serviceManager.messageService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec) =
+        processIncomingMessage(message)
+
+    override suspend fun executeMessageStepsFromSync() = processIncomingMessage(message)
+
+    private fun processIncomingMessage(message: AbstractMessage): ReceiveStepsResult {
         return if (messageService.processIncomingContactMessage(message)) {
             ReceiveStepsResult.SUCCESS
         } else {
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactDeleteMessageTask.kt
similarity index 66%
rename from app/src/main/java/ch/threema/app/processors/conversation/IncomingContactDeleteMessageTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactDeleteMessageTask.kt
index 84515f0f..3de5606b 100644
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactDeleteMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactDeleteMessageTask.kt
@@ -19,41 +19,48 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.conversation
+package ch.threema.app.processors.incomingcspmessage.conversation
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.app.tasks.runCommonDeleteMessageReceiveSteps
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.DeleteMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 import org.slf4j.Logger
 
 private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingContactDeleteMessageTask")
 
 class IncomingContactDeleteMessageTask(
-    private val deleteMessage: DeleteMessage,
+    message: DeleteMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<DeleteMessage>(message, triggerSource, serviceManager) {
 
     private val messageService by lazy { serviceManager.messageService }
     private val contactService by lazy { serviceManager.contactService }
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingContactDeleteMessageTask id: {}", deleteMessage.data.messageId)
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec) =
+        processContactDeleteMessage()
 
-        val contactModel = contactService.getByIdentity(deleteMessage.fromIdentity)
+    override suspend fun executeMessageStepsFromSync() = processContactDeleteMessage()
+
+    private fun processContactDeleteMessage(): ReceiveStepsResult {
+        logger.debug("IncomingContactDeleteMessageTask id: {}", message.data.messageId)
+
+        val contactModel = contactService.getByIdentity(message.fromIdentity)
         if (contactModel == null) {
-            logger.warn("Incoming Delete Message: No contact found for {}", deleteMessage.fromIdentity)
+            logger.warn("Incoming Delete Message: No contact found for {}", message.fromIdentity)
             return ReceiveStepsResult.DISCARD
         }
 
         val receiver = contactService.createReceiver(contactModel)
-        val message = runCommonDeleteMessageReceiveSteps(deleteMessage, receiver, messageService)
+        val messageModel = runCommonDeleteMessageReceiveSteps(message, receiver, messageService)
             ?: return ReceiveStepsResult.DISCARD
 
-        messageService.deleteMessageContentsAndEditHistory(message, deleteMessage.date)
+        messageService.deleteMessageContentsAndEditHistory(messageModel, message.date)
 
         return ReceiveStepsResult.SUCCESS
     }
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactEditMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactEditMessageTask.kt
similarity index 59%
rename from app/src/main/java/ch/threema/app/processors/conversation/IncomingContactEditMessageTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactEditMessageTask.kt
index ba6aa02e..856997bf 100644
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactEditMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactEditMessageTask.kt
@@ -19,41 +19,51 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.conversation
+package ch.threema.app.processors.incomingcspmessage.conversation
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.app.tasks.runCommonEditMessageReceiveSteps
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.EditMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 import org.slf4j.Logger
 
 private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingContactEditMessageTask")
 
 class IncomingContactEditMessageTask(
-        private val editMessage: EditMessage,
-        serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+    editMessage: EditMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<EditMessage>(editMessage, triggerSource, serviceManager) {
 
     private val messageService by lazy { serviceManager.messageService }
     private val contactService by lazy { serviceManager.contactService }
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingContactEditMessageTask id: ${editMessage.data.messageId}")
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        return applyEdit()
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        return applyEdit()
+    }
+
+    private fun applyEdit(): ReceiveStepsResult {
+        logger.debug("IncomingContactEditMessageTask id: {}", message.data.messageId)
 
-        val contactModel = contactService.getByIdentity(editMessage.fromIdentity)
+        val contactModel = contactService.getByIdentity(message.fromIdentity)
         if (contactModel == null) {
-            logger.warn("Incoming Edit Message: No contact found for ${editMessage.fromIdentity}")
+            logger.warn("Incoming Edit Message: No contact found for ${message.fromIdentity}")
             return ReceiveStepsResult.DISCARD
         }
 
         val receiver = contactService.createReceiver(contactModel)
-        val message = runCommonEditMessageReceiveSteps(editMessage, receiver, messageService)
+        val editedMessage = runCommonEditMessageReceiveSteps(message, receiver, messageService)
             ?: return ReceiveStepsResult.DISCARD
 
-        messageService.saveEditedMessageText(message, editMessage.data.text, editMessage.date)
+        messageService.saveEditedMessageText(editedMessage, message.data.text, message.date)
 
         return ReceiveStepsResult.SUCCESS
     }
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactFileMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactFileMessageTask.kt
new file mode 100644
index 00000000..2ccaa949
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactFileMessageTask.kt
@@ -0,0 +1,176 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.conversation
+
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.utils.MimeUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.file.FileData
+import ch.threema.domain.protocol.csp.messages.file.FileMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.storage.models.ContactModel
+import ch.threema.storage.models.MessageModel
+import ch.threema.storage.models.MessageType
+import ch.threema.storage.models.data.media.FileDataModel
+import org.slf4j.Logger
+import java.util.Date
+import java.util.UUID
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingContactFileMessageTask")
+
+class IncomingContactFileMessageTask(
+    fileMessage: FileMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<FileMessage>(
+    fileMessage,
+    triggerSource,
+    serviceManager
+) {
+    private val messageService = serviceManager.messageService
+    private val contactService = serviceManager.contactService
+    private val contactRepository = serviceManager.modelRepositories.contacts
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec) = processIncomingMessage(
+        triggerSource = TriggerSource.REMOTE
+    )
+
+    override suspend fun executeMessageStepsFromSync() = processIncomingMessage(
+        triggerSource = TriggerSource.SYNC
+    )
+
+    private fun processIncomingMessage(triggerSource: TriggerSource): ReceiveStepsResult {
+
+        // 0: Contact must exist locally at this point
+        if (!contactRepository.existsByIdentity(message.fromIdentity)) {
+            logger.error("Discarding message ${message.messageId}: Sender contact with identity ${message.fromIdentity} does not exist locally.")
+            return ReceiveStepsResult.DISCARD
+        }
+
+        // 1: Check if the message already exists locally (from previous run(s) of this task).
+        //    If so, cancel and accept that the download for the content(s) might not be complete.
+        messageService.getContactMessageModel(
+            message.messageId,
+            message.fromIdentity
+        )?.run { return ReceiveStepsResult.DISCARD }
+
+        val fileData: FileData = message.fileData ?: run {
+            logger.error("Discarding message ${message.messageId}: Missing file data")
+            return ReceiveStepsResult.DISCARD
+        }
+
+        // 2. Map the FileData object to a FileDataModel instance (field "downloaded" is false)
+        val fileDataModel: FileDataModel = FileDataModel.fromIncomingFileData(fileData)
+
+        // 3. Create the actual AbstractMessageModel containing the file and sender information
+        val messageModel: MessageModel = createMessageModelFromFileMessage(
+            fileMessage = message,
+            fileDataModel = fileDataModel,
+            fileData = fileData
+        )
+
+        // 4. Un-archive the contact and set the the acquaintance level to "direct" because it is a 1:1 chat now
+        if (triggerSource == TriggerSource.REMOTE) {
+            contactService.setIsArchived(message.fromIdentity, false)
+            contactService.setAcquaintanceLevel(message.fromIdentity, ContactModel.AcquaintanceLevel.DIRECT)
+        }
+
+        // 5. Bump last updated timestamp if necessary to move conversation up in list
+        if (message.bumpLastUpdate()) {
+            contactService.bumpLastUpdate(message.fromIdentity)
+        }
+
+        // 6. Save message model and inform listeners about new message
+        messageService.save(messageModel)
+        ListenerManager.messageListeners.handle { messageListener -> messageListener.onNew(messageModel) }
+
+        // 7. Download thumbnail and content blob (if auto download enabled)
+        //    We still return SUCCESS even if the blobs could net be downloaded
+        processMediaContent(fileData, messageModel)
+
+        return ReceiveStepsResult.SUCCESS
+    }
+
+    /**
+     *  @return A new instance of `AbstractMessageModel` with type [MessageType.FILE] containing
+     *  the `body` and `dataObject` from the passed file information.
+     */
+    private fun createMessageModelFromFileMessage(
+        fileMessage: FileMessage,
+        fileDataModel: FileDataModel,
+        fileData: FileData
+    ): MessageModel {
+        return MessageModel().apply {
+
+            setUid(UUID.randomUUID().toString())
+            setApiMessageId(message.messageId.toString())
+
+            setIdentity(fileMessage.fromIdentity)
+
+            setType(MessageType.FILE)
+            setMessageContentsType(MimeUtil.getContentTypeFromFileData(fileDataModel))
+
+            setPostedAt(message.date)
+            setCreatedAt(Date())
+
+            setMessageFlags(message.messageFlags)
+
+            setOutbox(false)
+            setSaved(true)
+
+            setCorrelationId(fileData.correlationId)
+            setForwardSecurityMode(message.forwardSecurityMode)
+
+            setFileDataModel(fileDataModel)
+        }
+    }
+
+    /**
+     *  **Synchronously**
+     *
+     *  Attempt to download the thumbnail and the actual media content. Even if
+     *  the thumbnail download failed, we try to download the actual blob contents.
+     */
+    private fun processMediaContent(fileData: FileData, messageModel: MessageModel) {
+        runCatching {
+            messageService.downloadThumbnailIfPresent(fileData, messageModel)
+        }.onSuccess { thumbnailWasDownloaded: Boolean ->
+            if (thumbnailWasDownloaded) {
+                ListenerManager.messageListeners.handle { messageListener -> messageListener.onModified(listOf(messageModel)) }
+            }
+        }.onFailure { throwable ->
+            logger.error("Unable to download thumbnail blob", throwable)
+        }
+        if (messageService.shouldAutoDownload(messageModel)) {
+            runCatching {
+                messageService.downloadMediaMessage(messageModel, null)
+            }.onFailure { throwable ->
+                // a failed blob auto-download should not be considered a failure as the user can try again manually
+                logger.error("Unable to auto-download blob", throwable)
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollSetupTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollSetupTask.kt
new file mode 100644
index 00000000..221b8049
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollSetupTask.kt
@@ -0,0 +1,50 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.conversation
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+
+class IncomingContactPollSetupTask(
+    private val pollSetupMessage: PollSetupMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<Nothing?>(null, triggerSource, serviceManager) {
+    private val messageService = serviceManager.messageService
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult = processPollSetupMessage()
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processPollSetupMessage()
+
+    private fun processPollSetupMessage(): ReceiveStepsResult {
+        val successfullyProcessed = messageService.processIncomingContactMessage(pollSetupMessage)
+        return if (successfullyProcessed) {
+            ReceiveStepsResult.SUCCESS
+        } else {
+            ReceiveStepsResult.DISCARD
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingBallotVoteTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollVoteTask.kt
similarity index 52%
rename from app/src/main/java/ch/threema/app/processors/conversation/IncomingBallotVoteTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollVoteTask.kt
index 0b3e1a9a..5caecd5b 100644
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingBallotVoteTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollVoteTask.kt
@@ -19,29 +19,30 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.conversation
+package ch.threema.app.processors.incomingcspmessage.conversation
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.ballot.BallotVoteInterface
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.services.ballot.BallotVoteResult
+import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
-class IncomingBallotVoteTask(
-    private val message: BallotVoteInterface,
+class IncomingContactPollVoteTask(
+    private val pollVoteMessage: PollVoteMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<Nothing?>(null, triggerSource, serviceManager) {
     private val ballotService = serviceManager.ballotService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        if (message is AbstractGroupMessage && runCommonGroupReceiveSteps(message, handle, serviceManager) == null) {
-            return ReceiveStepsResult.DISCARD
-        }
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult = processPollVoteMessage()
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processPollVoteMessage()
 
-        val result = this.ballotService.vote(message)
-        return if (result != null && result.isSuccess) {
+    private fun processPollVoteMessage(): ReceiveStepsResult {
+        val ballotVoteResult: BallotVoteResult? = this.ballotService.vote(pollVoteMessage)
+        return if (ballotVoteResult?.isSuccess == true) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupConversationMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupConversationMessageTask.kt
similarity index 62%
rename from app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupConversationMessageTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupConversationMessageTask.kt
index d0a1ef4b..51f17b80 100644
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupConversationMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupConversationMessageTask.kt
@@ -19,22 +19,24 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.conversation
+package ch.threema.app.processors.incomingcspmessage.conversation
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingGroupConversationMessageTask(
-    private val message: AbstractGroupMessage,
+    message: AbstractGroupMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<AbstractGroupMessage>(message, triggerSource, serviceManager) {
     private val messageService = serviceManager.messageService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         if (runCommonGroupReceiveSteps(message, handle, serviceManager) == null) {
             return ReceiveStepsResult.DISCARD
         }
@@ -45,4 +47,12 @@ class IncomingGroupConversationMessageTask(
             ReceiveStepsResult.DISCARD
         }
     }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        return if (messageService.processIncomingGroupMessage(message)) {
+            ReceiveStepsResult.SUCCESS
+        } else {
+            ReceiveStepsResult.DISCARD
+        }
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupDeleteMessageTask.kt
similarity index 54%
rename from app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupDeleteMessageTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupDeleteMessageTask.kt
index bd52c739..4eb503f0 100644
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupDeleteMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupDeleteMessageTask.kt
@@ -19,39 +19,52 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.conversation
+package ch.threema.app.processors.incomingcspmessage.conversation
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
 import ch.threema.app.tasks.runCommonDeleteMessageReceiveSteps
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 import org.slf4j.Logger
 
 private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingGroupDeleteMessageTask")
 
 class IncomingGroupDeleteMessageTask(
-    private val deleteMessage: GroupDeleteMessage,
+    message: GroupDeleteMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<GroupDeleteMessage>(message, triggerSource, serviceManager) {
 
     private val messageService = serviceManager.messageService
     private val groupService = serviceManager.groupService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingGroupDeleteMessageTask id: {}", deleteMessage.data.messageId)
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        if (runCommonGroupReceiveSteps(message, handle, serviceManager) == null) {
+            logger.info("Could not find group for delete message")
+            return ReceiveStepsResult.DISCARD
+        }
 
-        val groupModel = runCommonGroupReceiveSteps(deleteMessage, handle, serviceManager)
-            ?: return ReceiveStepsResult.DISCARD
+        return processGroupDeleteMessage()
+    }
+
+    override suspend fun executeMessageStepsFromSync() = processGroupDeleteMessage()
+
+    private fun processGroupDeleteMessage(): ReceiveStepsResult {
+        logger.debug("IncomingGroupDeleteMessageTask id: {}", message.data.messageId)
+
+        val groupModel =
+            groupService.getByGroupMessage(message) ?: return ReceiveStepsResult.DISCARD
 
         val receiver = groupService.createReceiver(groupModel)
-        val message = runCommonDeleteMessageReceiveSteps(deleteMessage, receiver, messageService)
+        val messageModel = runCommonDeleteMessageReceiveSteps(message, receiver, messageService)
             ?: return ReceiveStepsResult.DISCARD
 
-        messageService.deleteMessageContentsAndEditHistory(message, deleteMessage.date)
+        messageService.deleteMessageContentsAndEditHistory(messageModel, message.date)
 
         return ReceiveStepsResult.SUCCESS
     }
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupEditMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupEditMessageTask.kt
new file mode 100644
index 00000000..ccac5b29
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupEditMessageTask.kt
@@ -0,0 +1,78 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.conversation
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.app.tasks.runCommonEditMessageReceiveSteps
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.GroupEditMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.storage.models.GroupModel
+import org.slf4j.Logger
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingGroupEditMessageTask")
+
+class IncomingGroupEditMessageTask(
+    editMessage: GroupEditMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<GroupEditMessage>(editMessage, triggerSource, serviceManager) {
+
+    private val messageService by lazy { serviceManager.messageService }
+    private val groupService by lazy { serviceManager.groupService }
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        logger.debug("IncomingGroupEditMessageTask id: {}", message.data.messageId)
+
+        val groupModel = runCommonGroupReceiveSteps(message, handle, serviceManager)
+            ?: return ReceiveStepsResult.DISCARD
+
+        return applyEdit(groupModel)
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        logger.debug("IncomingGroupEditMessageTask id: {}", message.data.messageId)
+
+        val groupModel = groupService.getByGroupMessage(message)
+
+        if (groupModel == null) {
+            logger.error("Received a reflected group edit message in an unknown group")
+            return ReceiveStepsResult.DISCARD
+        }
+
+        return applyEdit(groupModel)
+    }
+
+    private fun applyEdit(groupModel: GroupModel): ReceiveStepsResult {
+        val receiver = groupService.createReceiver(groupModel)
+        val editedMessage = runCommonEditMessageReceiveSteps(message, receiver, messageService)
+            ?: return ReceiveStepsResult.DISCARD
+
+        messageService.saveEditedMessageText(editedMessage, message.data.text, message.date)
+
+        return ReceiveStepsResult.SUCCESS
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupFileMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupFileMessageTask.kt
new file mode 100644
index 00000000..8d85ec11
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupFileMessageTask.kt
@@ -0,0 +1,195 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.conversation
+
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.app.utils.MimeUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.file.FileData
+import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.storage.models.GroupMessageModel
+import ch.threema.storage.models.GroupModel
+import ch.threema.storage.models.MessageType
+import ch.threema.storage.models.data.media.FileDataModel
+import org.slf4j.Logger
+import java.util.Date
+import java.util.UUID
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingGroupFileMessageTask")
+
+class IncomingGroupFileMessageTask(
+    groupFileMessage: GroupFileMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<GroupFileMessage>(
+    groupFileMessage,
+    triggerSource,
+    serviceManager
+) {
+    private val messageService = serviceManager.messageService
+    private val groupService = serviceManager.groupService
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        val groupModel: GroupModel = runCommonGroupReceiveSteps(message, handle, serviceManager)
+            ?: run {
+                logger.warn("Discarding message ${message.messageId}: Could not find group for incoming group file message")
+                return ReceiveStepsResult.DISCARD
+            }
+        return processIncomingMessage(
+            preCheckedGroupModel = groupModel,
+            triggerSource = TriggerSource.REMOTE
+        )
+    }
+
+    override suspend fun executeMessageStepsFromSync() = processIncomingMessage(
+        preCheckedGroupModel = null,
+        triggerSource = TriggerSource.SYNC
+    )
+
+    private fun processIncomingMessage(
+        preCheckedGroupModel: GroupModel?,
+        triggerSource: TriggerSource
+    ): ReceiveStepsResult {
+
+        // 0: Group model must exist locally at this point
+        val groupModel: GroupModel = preCheckedGroupModel
+            ?: groupService.getByApiGroupIdAndCreator(
+                message.apiGroupId,
+                message.groupCreator
+            ) ?: run {
+                logger.error("Discarding message ${message.messageId}: Could not find group model with api id ${message.apiGroupId}")
+                return ReceiveStepsResult.DISCARD
+            }
+
+        // 1: Check if the group message already exists locally (from previous run(s) of this task).
+        //    If so, cancel and accept that the download for the content(s) might not be complete.
+        messageService.getGroupMessageModel(
+            message.messageId,
+            message.groupCreator,
+            message.apiGroupId
+        )?.run { return ReceiveStepsResult.DISCARD }
+
+        val fileData: FileData = message.fileData ?: run {
+            logger.error("Discarding message ${message.messageId}: Missing file data")
+            return ReceiveStepsResult.DISCARD
+        }
+
+        // 2. Map the FileData object to a FileDataModel instance (field "downloaded" is false)
+        val fileDataModel: FileDataModel = FileDataModel.fromIncomingFileData(fileData)
+
+        // 3. Create the actual AbstractMessageModel containing the file and sender information
+        val messageModel: GroupMessageModel = createGroupMessageModelFromFileMessage(
+            groupFileMessage = message,
+            fileDataModel = fileDataModel,
+            fileData = fileData,
+            groupModel = groupModel
+        )
+
+        // 4. Un-archive group if currently archived
+        if (triggerSource == TriggerSource.REMOTE) {
+            groupService.setIsArchived(groupModel, false)
+        }
+
+        // 5. Bump last updated timestamp if necessary to move conversation up in list
+        if (message.bumpLastUpdate()) {
+            groupService.bumpLastUpdate(groupModel)
+        }
+
+        // 6. Save message model and inform listeners about new message
+        messageService.save(messageModel)
+        ListenerManager.messageListeners.handle { messageListener -> messageListener.onNew(messageModel) }
+
+        // 7. Download thumbnail and content blob (if auto download enabled)
+        //    We still return SUCCESS even if the blobs could net be downloaded
+        processMediaContent(fileData, messageModel)
+
+        return ReceiveStepsResult.SUCCESS
+    }
+
+    /**
+     *  @return A new instance of `AbstractMessageModel` with type [MessageType.FILE] containing
+     *  the `body` and `dataObject` from the passed file information.
+     */
+    private fun createGroupMessageModelFromFileMessage(
+        groupFileMessage: GroupFileMessage,
+        fileDataModel: FileDataModel,
+        fileData: FileData,
+        groupModel: GroupModel
+    ): GroupMessageModel {
+        return GroupMessageModel().apply {
+
+            setUid(UUID.randomUUID().toString())
+            setApiMessageId(message.messageId.toString())
+
+            setIdentity(groupFileMessage.fromIdentity)
+            groupId = groupModel.id
+
+            setType(MessageType.FILE)
+            setMessageContentsType(MimeUtil.getContentTypeFromFileData(fileDataModel))
+
+            setPostedAt(message.date)
+            setCreatedAt(Date())
+
+            setMessageFlags(message.messageFlags)
+
+            setOutbox(false)
+            setSaved(true)
+
+            setCorrelationId(fileData.correlationId)
+            setForwardSecurityMode(message.forwardSecurityMode)
+
+            setFileDataModel(fileDataModel)
+        }
+    }
+
+    /**
+     *  **Synchronously**
+     *
+     *  Attempt to download the thumbnail and the actual media content. Even if
+     *  the thumbnail download failed, we try to download the actual blob contents.
+     */
+    private fun processMediaContent(fileData: FileData, messageModel: GroupMessageModel) {
+        runCatching {
+            messageService.downloadThumbnailIfPresent(fileData, messageModel)
+        }.onSuccess { thumbnailWasDownloaded: Boolean ->
+            if (thumbnailWasDownloaded) {
+                ListenerManager.messageListeners.handle { messageListener -> messageListener.onModified(listOf(messageModel)) }
+            }
+        }.onFailure { throwable ->
+            logger.error("Unable to download thumbnail blob", throwable)
+        }
+        if (messageService.shouldAutoDownload(messageModel)) {
+            runCatching {
+                messageService.downloadMediaMessage(messageModel, null)
+            }.onFailure { throwable ->
+                // a failed blob auto-download should not be considered a failure as the user can try again manually
+                logger.error("Unable to auto-download blob", throwable)
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollSetupTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollSetupTask.kt
new file mode 100644
index 00000000..15683562
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollSetupTask.kt
@@ -0,0 +1,56 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.conversation
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+
+class IncomingGroupPollSetupTask(
+    private val groupPollSetupMessage: GroupPollSetupMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<Nothing?>(null, triggerSource, serviceManager) {
+    private val messageService = serviceManager.messageService
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        if (runCommonGroupReceiveSteps(groupPollSetupMessage, handle, serviceManager) == null) {
+            return ReceiveStepsResult.DISCARD
+        }
+        return processPollSetupMessage()
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processPollSetupMessage()
+
+    private fun processPollSetupMessage(): ReceiveStepsResult {
+        val successfullyProcessed = messageService.processIncomingGroupMessage(groupPollSetupMessage)
+        return if (successfullyProcessed) {
+            ReceiveStepsResult.SUCCESS
+        } else {
+            ReceiveStepsResult.DISCARD
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollVoteTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollVoteTask.kt
new file mode 100644
index 00000000..c5e8081d
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollVoteTask.kt
@@ -0,0 +1,57 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.conversation
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.app.services.ballot.BallotVoteResult
+import ch.threema.domain.protocol.csp.messages.ballot.GroupPollVoteMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+
+class IncomingGroupPollVoteTask(
+    private val groupPollVoteMessage: GroupPollVoteMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<Nothing?>(null, triggerSource, serviceManager) {
+    private val ballotService = serviceManager.ballotService
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        if (runCommonGroupReceiveSteps(groupPollVoteMessage, handle, serviceManager) == null) {
+            return ReceiveStepsResult.DISCARD
+        }
+        return processPollVoteMessage()
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processPollVoteMessage()
+
+    private fun processPollVoteMessage(): ReceiveStepsResult {
+        val ballotVoteResult: BallotVoteResult? = ballotService.vote(groupPollVoteMessage)
+        return if (ballotVoteResult?.isSuccess == true) {
+            ReceiveStepsResult.SUCCESS
+        } else {
+            ReceiveStepsResult.DISCARD
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingEmptyTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingEmptyTask.kt
similarity index 57%
rename from app/src/main/java/ch/threema/app/processors/fs/IncomingEmptyTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingEmptyTask.kt
index c48c15d6..34f94376 100644
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingEmptyTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingEmptyTask.kt
@@ -19,25 +19,32 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.fs
+package ch.threema.app.processors.incomingcspmessage.fs
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.EmptyMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingEmptyTask")
 
 class IncomingEmptyTask(
-    private val emptyMessage: EmptyMessage,
-    serviceManager: ServiceManager
-) : IncomingCspMessageSubTask(serviceManager) {
+    emptyMessage: EmptyMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<EmptyMessage>(emptyMessage, triggerSource, serviceManager) {
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.info("Processed incoming empty message {}", emptyMessage.messageId)
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        logger.info("Processed incoming empty message {}", message.messageId)
         return ReceiveStepsResult.SUCCESS
     }
 
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        logger.warn("Received empty message from sync with message id {}", message.messageId)
+        return ReceiveStepsResult.DISCARD
+    }
+
 }
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityAcceptTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityAcceptTask.kt
similarity index 97%
rename from app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityAcceptTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityAcceptTask.kt
index 6b006f98..f829cc35 100644
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityAcceptTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityAcceptTask.kt
@@ -19,7 +19,7 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.fs
+package ch.threema.app.processors.incomingcspmessage.fs
 
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.Contact
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityEnvelopeTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityEnvelopeTask.kt
similarity index 94%
rename from app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityEnvelopeTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityEnvelopeTask.kt
index 92b026a6..3f66fd7b 100644
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityEnvelopeTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityEnvelopeTask.kt
@@ -19,7 +19,7 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.fs
+package ch.threema.app.processors.incomingcspmessage.fs
 
 import ch.threema.app.tasks.ActiveComposableTask
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityInitTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityInitTask.kt
similarity index 97%
rename from app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityInitTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityInitTask.kt
index 5e3a021d..b6d722da 100644
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityInitTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityInitTask.kt
@@ -19,7 +19,7 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.fs
+package ch.threema.app.processors.incomingcspmessage.fs
 
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.Contact
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityMessageTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityMessageTask.kt
similarity index 97%
rename from app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityMessageTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityMessageTask.kt
index 76a02d03..91588ffe 100644
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityMessageTask.kt
@@ -19,7 +19,7 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.fs
+package ch.threema.app.processors.incomingcspmessage.fs
 
 import ch.threema.domain.models.Contact
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityRejectTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityRejectTask.kt
similarity index 96%
rename from app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityRejectTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityRejectTask.kt
index b7848552..1f0e25c9 100644
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityRejectTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityRejectTask.kt
@@ -19,11 +19,11 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.fs
+package ch.threema.app.processors.incomingcspmessage.fs
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.groupcontrol.handleIncomingGroupSyncRequest
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.handleIncomingGroupSyncRequest
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.Contact
 import ch.threema.domain.models.GroupId
@@ -182,9 +182,8 @@ class IncomingForwardSecurityRejectTask(
             -> {
                 // Mark the message with 're-send requested'. Note that we use the fs key mismatch
                 // state to represent the 're-send requested'-mark.
-                messageService.updateContactMessageState(
-                    data.rejectedApiMessageId,
-                    sender.identity,
+                messageService.updateOutgoingMessageState(
+                    messageModel,
                     MessageState.FS_KEY_MISMATCH,
                     Date()
                 )
@@ -222,7 +221,7 @@ class IncomingForwardSecurityRejectTask(
             -> {
                 // Mark the message with 're-send requested'. Note that we use the fs key mismatch
                 // state to represent the 're-send requested'-mark.
-                messageService.updateMessageState(
+                messageService.updateOutgoingMessageState(
                     messageModel,
                     MessageState.FS_KEY_MISMATCH,
                     Date()
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityTerminateTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityTerminateTask.kt
similarity index 97%
rename from app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityTerminateTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityTerminateTask.kt
index 26d98f3a..ff2d35e6 100644
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityTerminateTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityTerminateTask.kt
@@ -19,7 +19,7 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.fs
+package ch.threema.app.processors.incomingcspmessage.fs
 
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.Contact
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupCallControlTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupCallControlTask.kt
similarity index 55%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupCallControlTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupCallControlTask.kt
index bf1890e0..583bb9ac 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupCallControlTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupCallControlTask.kt
@@ -19,32 +19,38 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
 import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallControlMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingGroupCallControlTask(
-    private val message: GroupCallControlMessage,
+    private val groupCallControlMessage: GroupCallControlMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<Nothing?>(null, triggerSource, serviceManager) {
     private val groupCallManager = serviceManager.groupCallManager
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (runCommonGroupReceiveSteps(
-                message as AbstractGroupMessage,
-                handle,
-                serviceManager
-            ) != null
-        ) {
-            groupCallManager.handleControlMessage(message)
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        runCommonGroupReceiveSteps(
+            message = groupCallControlMessage as AbstractGroupMessage,
+            handle = handle,
+            serviceManager = serviceManager
+        ) ?: return ReceiveStepsResult.DISCARD
+        return processGroupCallControl()
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = processGroupCallControl()
+
+    private fun processGroupCallControl() =
+        if (groupCallManager.handleControlMessage(groupCallControlMessage)) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
         }
-    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
similarity index 61%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
index de29c359..d6865ba8 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
@@ -19,29 +19,33 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.managers.ListenerManager
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.utils.ShortcutUtil
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.GroupDeleteProfilePictureMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingGroupDeleteProfilePictureTask")
 
 class IncomingGroupDeleteProfilePictureTask(
-    private val deleteProfilePictureMessage: GroupDeleteProfilePictureMessage,
+    message: GroupDeleteProfilePictureMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val fileService = serviceManager.fileService
-    private val avatarCacheService = serviceManager.avatarCacheService
+) : IncomingCspMessageSubTask<GroupDeleteProfilePictureMessage>(message, triggerSource, serviceManager) {
+    private val fileService by lazy { serviceManager.fileService }
+    private val avatarCacheService by lazy { serviceManager.avatarCacheService }
+    private val groupService by lazy { serviceManager.groupService }
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         // 1. Run the common group receive steps
         val groupModel =
-            runCommonGroupReceiveSteps(deleteProfilePictureMessage, handle, serviceManager)
+            runCommonGroupReceiveSteps(message, handle, serviceManager)
         if (groupModel == null) {
             logger.warn("Discarding group delete profile picture message because group could not be found")
             return ReceiveStepsResult.DISCARD
@@ -54,8 +58,15 @@ class IncomingGroupDeleteProfilePictureTask(
             avatarCacheService.reset(groupModel)
 
             ListenerManager.groupListeners.handle { it.onUpdatePhoto(groupModel) }
+
+            ShortcutUtil.updateShareTargetShortcut(groupService.createReceiver(groupModel))
         }
 
         return ReceiveStepsResult.SUCCESS
     }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinRequestTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinRequestTask.kt
similarity index 65%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinRequestTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinRequestTask.kt
index b7398ed9..1d72a11b 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinRequestTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinRequestTask.kt
@@ -19,25 +19,32 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingGroupJoinRequestTask(
-    private val message: GroupJoinRequestMessage,
+    message: GroupJoinRequestMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<GroupJoinRequestMessage>(message, triggerSource, serviceManager) {
     private val incomingGroupJoinRequestService = serviceManager.incomingGroupJoinRequestService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         return if (incomingGroupJoinRequestService.process(message)) {
             ReceiveStepsResult.SUCCESS
         } else {
             ReceiveStepsResult.DISCARD
         }
     }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinResponseMessage.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinResponseMessage.kt
similarity index 84%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinResponseMessage.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinResponseMessage.kt
index b572a234..7413a163 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinResponseMessage.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinResponseMessage.kt
@@ -19,30 +19,32 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.grouplinks.GroupJoinResponseListener
 import ch.threema.app.managers.ListenerManager
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.GroupId
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseData
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 import ch.threema.storage.models.group.OutgoingGroupJoinRequestModel
 import java8.util.Optional
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingGroupJoinResponseMessage")
 
 class IncomingGroupJoinResponseMessage(
-    private val message: GroupJoinResponseMessage,
+    message: GroupJoinResponseMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<GroupJoinResponseMessage>(message, triggerSource, serviceManager) {
     private val outgoingGroupJoinRequestModelFactory = serviceManager.databaseServiceNew.outgoingGroupJoinRequestModelFactory
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         val responseData: GroupJoinResponseData = message.data
         val token = responseData.token
 
@@ -100,4 +102,9 @@ class IncomingGroupJoinResponseMessage(
 
         return ReceiveStepsResult.SUCCESS
     }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupLeaveTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupLeaveTask.kt
similarity index 79%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupLeaveTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupLeaveTask.kt
index 25df4c53..2197b2a0 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupLeaveTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupLeaveTask.kt
@@ -19,31 +19,33 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.managers.ListenerManager
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.app.services.GroupService
 import ch.threema.app.tasks.OutgoingGroupSyncRequestTask
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingGroupLeaveTask")
 
 class IncomingGroupLeaveTask(
-    private val groupLeaveMessage: GroupLeaveMessage,
+    message: GroupLeaveMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<GroupLeaveMessage>(message, triggerSource, serviceManager) {
     private val groupService = serviceManager.groupService
     private val userService = serviceManager.userService
     private val groupCallManager = serviceManager.groupCallManager
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val creator = groupLeaveMessage.groupCreator
-        val sender = groupLeaveMessage.fromIdentity
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        val creator = message.groupCreator
+        val sender = message.fromIdentity
 
         // 1. If the sender is the creator of the group, abort these steps
         if (sender == creator) {
@@ -52,7 +54,7 @@ class IncomingGroupLeaveTask(
         }
 
         // 2. Look up the group
-        val group = groupService.getByGroupMessage(groupLeaveMessage)
+        val group = groupService.getByGroupMessage(message)
 
         // 3. If the group could not be found or is marked as left
         if (group == null || !groupService.isGroupMember(group)) {
@@ -62,7 +64,7 @@ class IncomingGroupLeaveTask(
             }
             // 3.2 Send a group-sync-request to the group creator and abort these steps
             OutgoingGroupSyncRequestTask(
-                groupLeaveMessage.apiGroupId,
+                message.apiGroupId,
                 creator,
                 null,
                 serviceManager
@@ -73,9 +75,8 @@ class IncomingGroupLeaveTask(
         @GroupService.GroupState val oldGroupState = groupService.getGroupState(group)
 
         // 4. Remove the member from the local group
-        val previousCount = groupService.countMembers(group)
         if (groupService.removeMemberFromGroup(group, sender)) {
-            ListenerManager.groupListeners.handle { it.onMemberLeave(group, sender, previousCount) }
+            ListenerManager.groupListeners.handle { it.onMemberLeave(group, sender) }
         }
         // Reset the cache
         groupService.resetCache(group.id)
@@ -98,4 +99,9 @@ class IncomingGroupLeaveTask(
 
         return ReceiveStepsResult.SUCCESS
     }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupMessageUtils.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupMessageUtils.kt
similarity index 98%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupMessageUtils.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupMessageUtils.kt
index 9a964f6d..01b2d7b7 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupMessageUtils.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupMessageUtils.kt
@@ -19,7 +19,7 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.tasks.OutgoingGroupLeaveTask
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupNameTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupNameTask.kt
similarity index 70%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupNameTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupNameTask.kt
index 05776be4..f06ba7b6 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupNameTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupNameTask.kt
@@ -19,16 +19,17 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.listeners.GroupListener
 import ch.threema.app.managers.ListenerManager
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.GroupNameMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingGroupNameTask")
 
@@ -36,20 +37,21 @@ private val logger = LoggingUtil.getThreemaLogger("IncomingGroupNameTask")
  * The task to run the required steps when a group rename message has been received.
  */
 class IncomingGroupNameTask(
-    private val groupNameMessage: GroupNameMessage,
+    message: GroupNameMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val databaseService = serviceManager.databaseServiceNew
+) : IncomingCspMessageSubTask<GroupNameMessage>(message, triggerSource, serviceManager) {
+    private val databaseService by lazy { serviceManager.databaseServiceNew }
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         // 1. Run the common group receive steps
-        val groupModel = runCommonGroupReceiveSteps(groupNameMessage, handle, serviceManager)
+        val groupModel = runCommonGroupReceiveSteps(message, handle, serviceManager)
         if (groupModel == null) {
             logger.warn("Discarding group name message because group could not be found")
             return ReceiveStepsResult.DISCARD
         }
 
-        val newGroupName = groupNameMessage.groupName ?: ""
+        val newGroupName = message.groupName ?: ""
         val oldGroupName = groupModel.name ?: ""
 
         // 2. Update the group with the given name (only if the new name is different)
@@ -68,4 +70,9 @@ class IncomingGroupNameTask(
 
         return ReceiveStepsResult.SUCCESS
     }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetProfilePictureTask.kt
similarity index 58%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetProfilePictureTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetProfilePictureTask.kt
index b66b5474..c6e15a16 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetProfilePictureTask.kt
@@ -19,45 +19,52 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import ch.threema.app.managers.ListenerManager
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.utils.ShortcutUtil
+import ch.threema.app.utils.contentEquals
 import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.blob.BlobScope
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.domain.protocol.csp.messages.GroupSetProfilePictureMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 import ch.threema.storage.models.GroupModel
 import com.neilalexander.jnacl.NaCl
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingGroupSetProfilePictureTask")
 
 class IncomingGroupSetProfilePictureTask(
-    private val setProfilePictureMessage: GroupSetProfilePictureMessage,
+    message: GroupSetProfilePictureMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val fileService = serviceManager.fileService
-    private val apiService = serviceManager.apiService
-    private val avatarCacheService = serviceManager.avatarCacheService
+) : IncomingCspMessageSubTask<GroupSetProfilePictureMessage>(message, triggerSource, serviceManager) {
+    private val fileService by lazy { serviceManager.fileService }
+    private val apiService by lazy { serviceManager.apiService }
+    private val avatarCacheService by lazy { serviceManager.avatarCacheService }
+    private val groupService by lazy { serviceManager.groupService }
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         // 1. Run the common group receive steps
-        val group = runCommonGroupReceiveSteps(setProfilePictureMessage, handle, serviceManager)
+        val group = runCommonGroupReceiveSteps(message, handle, serviceManager)
         if (group == null) {
             logger.warn("Discarding group set profile picture message because group could not be found")
             return ReceiveStepsResult.DISCARD
         }
 
         // 2. Download the picture from the blob server but do not request the blob to be removed
-        val blobLoader = apiService.createLoader(setProfilePictureMessage.blobId)
+        val blobLoader = apiService.createLoader(message.blobId)
         // TODO(ANDR-2869): Correctly handle blob server faults
-        val blob = blobLoader.load(false)
-            ?: throw IllegalStateException("Profile picture blob is null")
+        val blob = blobLoader.load(
+            BlobScope.Public // since its an incoming message, always use the public scope
+        ) ?: throw IllegalStateException("Profile picture blob is null")
         NaCl.symmetricDecryptDataInplace(
             blob,
-            setProfilePictureMessage.encryptionKey,
+            message.encryptionKey,
             ProtocolDefines.GROUP_PHOTO_NONCE
         )
 
@@ -68,27 +75,19 @@ class IncomingGroupSetProfilePictureTask(
             this.avatarCacheService.reset(group)
 
             ListenerManager.groupListeners.handle { it.onUpdatePhoto(group) }
+
+            ShortcutUtil.updateShareTargetShortcut(groupService.createReceiver(group))
         }
 
         return ReceiveStepsResult.SUCCESS
     }
 
     private fun hasDifferentGroupPhoto(group: GroupModel, newGroupPhoto: ByteArray?): Boolean {
-        var differentGroupPhoto = true
-        fileService.getGroupAvatarStream(group).use { existingAvatar ->
-            if (newGroupPhoto != null && existingAvatar != null) {
-                var index = 0
-                var next: Int
-                while (existingAvatar.read().also { next = it } != -1) {
-                    if (next.toByte() != newGroupPhoto[index]) {
-                        break
-                    }
-                    index++
-                }
-                differentGroupPhoto = index != newGroupPhoto.size
-            }
-        }
-        return differentGroupPhoto
+        return !fileService.getGroupAvatarStream(group).contentEquals(newGroupPhoto)
     }
 
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetupTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetupTask.kt
new file mode 100644
index 00000000..7b82cb31
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetupTask.kt
@@ -0,0 +1,317 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
+
+import ch.threema.app.asynctasks.getIdentityState
+import ch.threema.app.asynctasks.getIdentityType
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.utils.OutgoingCspGroupMessageCreator
+import ch.threema.app.utils.OutgoingCspMessageHandle
+import ch.threema.app.utils.OutgoingCspMessageServices.Companion.getOutgoingCspMessageServices
+import ch.threema.app.utils.runBundledMessagesSendSteps
+import ch.threema.app.utils.toBasicContacts
+import ch.threema.app.voip.groupcall.localGroupId
+import ch.threema.base.ThreemaException
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.models.ContactModelData.Companion.getIdColorIndex
+import ch.threema.data.repositories.ContactCreateException
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
+import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.NetworkException
+import ch.threema.domain.taskmanager.ProtocolException
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.storage.models.ContactModel
+import ch.threema.storage.models.GroupModel
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingGroupSetupTask")
+
+class IncomingGroupSetupTask(
+    message: GroupSetupMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<GroupSetupMessage>(message, triggerSource, serviceManager) {
+    private val userService by lazy { serviceManager.userService }
+    private val contactService by lazy { serviceManager.contactService }
+    private val contactModelRepository by lazy { serviceManager.modelRepositories.contacts }
+    private val groupService by lazy { serviceManager.groupService }
+    private val blockedContactsService by lazy { serviceManager.blockedContactsService }
+    private val groupCallManager by lazy { serviceManager.groupCallManager }
+    private val databaseService by lazy { serviceManager.databaseServiceNew }
+    private val contactStore by lazy { serviceManager.contactStore }
+    private val apiConnector by lazy { serviceManager.apiConnector }
+    private val preferenceService by lazy { serviceManager.preferenceService }
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
+        // 1. Let members be the given member list. Remove all duplicate entries from members.
+        // Remove the sender from members if present.
+        val sender = message.fromIdentity
+        val members = message.members.filter { it != sender }.toSet()
+        val myIdentity = userService.identity
+
+        // 2. Look up the group
+        var group = groupService.getByGroupMessage(message)
+
+        val newGroup = group == null
+
+        // 3. If the group could not be found:
+        if (group == null) {
+            // 3.1 If the user is not present in members, abort these steps
+            if (!members.contains(myIdentity)) {
+                logger.info("Dismissing group setup message for unknown group without the user as member")
+                return ReceiveStepsResult.DISCARD
+            }
+            // 3.2 If the sender is blocked, send a group-leave message to the sender and all
+            // provided members (including those who are blocked) and abort these steps.
+            if (isBlocked(sender)) {
+                logger.info("Sending a leave message to the creator of a new group that is blocked")
+                sendLeave(handle, message.apiGroupId, sender, members)
+                return ReceiveStepsResult.SUCCESS
+            }
+        }
+
+        // 4. If the group could be found and members is empty or does not include the user:
+        if (group != null && !members.contains(myIdentity)) {
+            // 4.1 If the user is currently participating in a group call of this group, trigger
+            // leaving the call.
+            if (groupCallManager.hasJoinedCall(group.localGroupId)) {
+                logger.info("Group call is running in a group where the user just has been kicked")
+                groupCallManager.abortCurrentCall()
+            }
+
+            // If we are not a member anyway, we do not have to do anything. Especially, we should
+            // not call the listener as this would trigger a status message each time.
+            if (!groupService.isGroupMember(group)) {
+                return ReceiveStepsResult.SUCCESS
+            }
+
+            // 4.2 Mark the group as left and abort these steps.
+            // Note that we just set the user state to kicked as the user is not stored as a member
+            // in the database.
+            if (group.userState == GroupModel.UserState.MEMBER) {
+                group.userState = GroupModel.UserState.KICKED
+                groupService.save(group)
+            }
+
+            ListenerManager.groupListeners.handle {
+                it.onMemberKicked(group, myIdentity)
+            }
+
+            return ReceiveStepsResult.SUCCESS
+        }
+
+        // 5. For each member of members, create a contact with acquaintance level group
+        // if not already present in the contact list.
+        val unknownContacts = members
+            .filter { contactModelRepository.getByIdentity(it) == null }
+            .filter { it != myIdentity }
+        createGroupMemberContacts(unknownContacts, handle)
+
+        // 6. Create or update the group with the given members plus the sender (creator).
+        val now = Date()
+        if (group == null) {
+            group = GroupModel().apply {
+                apiGroupId = message.apiGroupId
+                creatorIdentity = message.groupCreator
+                createdAt = now
+                lastUpdate = now
+            }
+            databaseService.groupModelFactory.create(group)
+        } else if (group.isDeleted || !groupService.isGroupMember(group)) {
+            group.isDeleted = false
+            group.lastUpdate = now
+            databaseService.groupModelFactory.update(group)
+        }
+        updateMembers(group, members)
+
+        // If the group is new, then fire the listener.
+        if (newGroup) {
+            ListenerManager.groupListeners.handle { it.onCreate(group) }
+        }
+
+        // 7. If the group was previously marked as left, remove the left mark.
+        if (group.userState != GroupModel.UserState.MEMBER) {
+            group.userState = GroupModel.UserState.MEMBER
+            databaseService.groupModelFactory.update(group)
+            ListenerManager.groupListeners.handle { it.onNewMember(group, myIdentity) }
+        }
+
+        // 8. Run the rejected messages refresh steps for the group
+        groupService.runRejectedMessagesRefreshSteps(group)
+
+        // 9. If the user is currently participating in a group call of this group and there are
+        // group call participants that are no longer members of the group, remove these
+        // participants from the group call (handle them as if they left the call).
+        groupCallManager.updateAllowedCallParticipants(group)
+
+        return ReceiveStepsResult.SUCCESS
+    }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
+
+    private suspend fun sendLeave(
+        handle: ActiveTaskCodec,
+        apiGroupId: GroupId,
+        creatorIdentity: String,
+        members: Set<String>,
+    ) {
+        val messageId = MessageId()
+        val myIdentity = userService.identity
+
+        val recipients = (members + creatorIdentity - myIdentity)
+            .toBasicContacts(contactModelRepository, contactStore, apiConnector)
+            .toSet()
+
+        val messageCreator = OutgoingCspGroupMessageCreator(
+            messageId,
+            Date(),
+            apiGroupId,
+            creatorIdentity
+        ) { GroupLeaveMessage() }
+
+        val outgoingCspMessageHandle = OutgoingCspMessageHandle(
+            recipients,
+            messageCreator,
+        )
+
+        handle.runBundledMessagesSendSteps(
+            outgoingCspMessageHandle,
+            serviceManager.getOutgoingCspMessageServices(),
+        )
+    }
+
+    private suspend fun createGroupMemberContacts(
+        unknownIdentities: List<String>,
+        handle: ActiveTaskCodec,
+    ) {
+        if (unknownIdentities.isEmpty()) {
+            return
+        }
+
+        val date = Date()
+        val fetchResults = try {
+            apiConnector.fetchIdentities(unknownIdentities)
+        } catch (e: Exception) {
+            when (e) {
+                is NetworkException -> throw ProtocolException(
+                    e.message ?: "Could not fetch identities"
+                )
+
+                is ThreemaException -> throw ProtocolException(
+                    e.message ?: "Could not fetch server url"
+                )
+
+                else -> throw e
+            }
+        }
+        fetchResults.forEach { fetchResult ->
+            try {
+                contactModelRepository.createFromRemote(
+                    ContactModelData(
+                        identity = fetchResult.identity,
+                        publicKey = fetchResult.publicKey,
+                        createdAt = date,
+                        firstName = "",
+                        lastName = "",
+                        nickname = null,
+                        colorIndex = getIdColorIndex(fetchResult.identity),
+                        verificationLevel = VerificationLevel.UNVERIFIED,
+                        workVerificationLevel = WorkVerificationLevel.NONE,
+                        identityType = fetchResult.getIdentityType(),
+                        acquaintanceLevel = ContactModel.AcquaintanceLevel.GROUP,
+                        activityState = fetchResult.getIdentityState(),
+                        syncState = ContactSyncState.INITIAL,
+                        featureMask = fetchResult.featureMask.toULong(),
+                        readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
+                        typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
+                        androidContactLookupKey = null,
+                        localAvatarExpires = null,
+                        isRestored = false,
+                        profilePictureBlobId = null,
+                        jobTitle = null,
+                        department = null,
+                    ),
+                    handle
+                )
+            } catch (e: ContactCreateException) {
+                logger.error("Could not create contact {}", fetchResult.identity)
+                // In case the contact could not be created because it already exists, we just
+                // continue. Otherwise, we throw a protocol exception to restart processing the
+                // incoming group setup message.
+                if (contactModelRepository.getByIdentity(fetchResult.identity) == null) {
+                    throw ProtocolException("Could not create contact ${fetchResult.identity}")
+                }
+            }
+        }
+    }
+
+    private fun updateMembers(group: GroupModel, members: Set<String>) {
+        // Delete all local group members that are not a member of the updated group. Don't delete
+        // the group creator.
+        val localMembersToDelete = groupService.getGroupIdentities(group)
+            .filter { group.creatorIdentity != it && !members.contains(it) }
+
+        localMembersToDelete.forEach { identity ->
+            // Remove member from group
+            groupService.removeMemberFromGroup(group, identity)
+
+            // Notify listeners that the member has been removed
+            ListenerManager.groupListeners.handle {
+                it.onMemberKicked(group, identity)
+            }
+        }
+
+        // All members that are already added (including the group creator and user)
+        val addedMembers = groupService.getGroupIdentities(group)
+
+        // All members including the creator that should be part of the group
+        val allMembers = (listOf(group.creatorIdentity) + members).toSet()
+
+        // Add all members to the group that are not already in the group
+        allMembers.filter { !addedMembers.contains(it) }.forEach { memberIdentity ->
+            if (groupService.addMemberToGroup(group, memberIdentity)) {
+                ListenerManager.groupListeners.handle {
+                    it.onNewMember(group, memberIdentity)
+                }
+            }
+        }
+    }
+
+    private fun isBlocked(identity: String): Boolean =
+        blockedContactsService.has(identity) ||
+            (contactService.getByIdentity(identity) == null && preferenceService.isBlockUnknown)
+}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSyncRequestTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSyncRequestTask.kt
similarity index 81%
rename from app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSyncRequestTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSyncRequestTask.kt
index 9b541ad6..83d71fcc 100644
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSyncRequestTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSyncRequestTask.kt
@@ -19,30 +19,31 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.groupcontrol
+package ch.threema.app.processors.incomingcspmessage.groupcontrol
 
 import android.text.format.DateUtils
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.services.GroupService
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.app.tasks.OutgoingGroupSyncTask
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 import ch.threema.storage.models.GroupModel
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingGroupSyncRequestTask")
 
 class IncomingGroupSyncRequestTask(
-    private val groupSyncRequestMessage: GroupSyncRequestMessage,
+    message: GroupSyncRequestMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<GroupSyncRequestMessage>(message, triggerSource, serviceManager) {
     private val groupService by lazy { serviceManager.groupService }
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         // 1. Look up the group. If the group could not be found, abort these steps
-        val group = groupService.getByGroupMessage(groupSyncRequestMessage)
+        val group = groupService.getByGroupMessage(message)
         if (group == null) {
             logger.warn("Discarding group sync request message because group could not be found")
             return ReceiveStepsResult.DISCARD
@@ -55,11 +56,16 @@ class IncomingGroupSyncRequestTask(
 
         return handleIncomingGroupSyncRequest(
             group,
-            groupSyncRequestMessage.fromIdentity,
+            message.fromIdentity,
             handle,
             serviceManager
         )
     }
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+        // TODO(ANDR-2741): Support group synchronization
+        return ReceiveStepsResult.DISCARD
+    }
 }
 
 suspend fun handleIncomingGroupSyncRequest(
@@ -89,7 +95,7 @@ suspend fun handleIncomingGroupSyncRequest(
 
     // 3. If the group is marked as left or the sender is not a member of the group, send a
     //    group-setup with an empty members list back to the sender and abort these steps.
-    if (groupService.isLeftGroup(group) || !groupService.isSenderGroupMember(group, sender)) {
+    if (!groupService.isGroupMember(group) || !groupService.isGroupMember(group, sender)) {
         sendEmptyGroupSetup(group, sender, handle, serviceManager)
         return ReceiveStepsResult.DISCARD
     }
@@ -109,8 +115,3 @@ suspend fun handleIncomingGroupSyncRequest(
 
     return ReceiveStepsResult.SUCCESS
 }
-
-private fun GroupService.isLeftGroup(group: GroupModel): Boolean = !isGroupMember(group)
-
-private fun GroupService.isSenderGroupMember(group: GroupModel, sender: String) =
-    getMembers(group).map { it.identity }.contains(sender)
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingDeliveryReceiptTask.kt
new file mode 100644
index 00000000..4e952d14
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingDeliveryReceiptTask.kt
@@ -0,0 +1,88 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.statusupdates
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.utils.MessageUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingDeliveryReceiptTask")
+
+class IncomingDeliveryReceiptTask(
+    message: DeliveryReceiptMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<DeliveryReceiptMessage>(message, triggerSource, serviceManager) {
+    private val messageService = serviceManager.messageService
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec) =
+        processIncomingDeliveryReceipt()
+
+    override suspend fun executeMessageStepsFromSync() = processIncomingDeliveryReceipt()
+
+    private fun processIncomingDeliveryReceipt(): ReceiveStepsResult {
+        val state = MessageUtil.receiptTypeToMessageState(message.receiptType)
+
+        if (state == null) {
+            logger.warn(
+                "Message {} error: unknown delivery receipt type: {}",
+                message.messageId,
+                message.receiptType
+            )
+            return ReceiveStepsResult.DISCARD
+        }
+
+        message.receiptMessageIds.forEach {
+            logger.info(
+                "Processing message {}: delivery receipt for {} (state = {})",
+                message.messageId,
+                it,
+                state
+            )
+        }
+
+        message.receiptMessageIds.mapNotNull { receiptMessageId ->
+            messageService.getContactMessageModel(receiptMessageId, message.fromIdentity)
+        }.forEach { messageModel ->
+            if (MessageUtil.isReaction(state)) {
+                messageService.addMessageReaction(
+                    messageModel,
+                    state,
+                    message.fromIdentity,
+                    message.date
+                )
+            } else {
+                messageService.updateOutgoingMessageState(
+                    messageModel,
+                    state,
+                    message.date
+                )
+            }
+        }
+        return ReceiveStepsResult.SUCCESS
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingGroupDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingGroupDeliveryReceiptTask.kt
new file mode 100644
index 00000000..99bb9a18
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingGroupDeliveryReceiptTask.kt
@@ -0,0 +1,102 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.incomingcspmessage.statusupdates
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.runCommonGroupReceiveSteps
+import ch.threema.app.utils.MessageUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+import ch.threema.storage.models.GroupMessageModel
+import ch.threema.storage.models.GroupModel
+import ch.threema.storage.models.MessageState
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingGroupDeliveryReceiptTask")
+
+class IncomingGroupDeliveryReceiptTask(
+    message: GroupDeliveryReceiptMessage,
+    triggerSource: TriggerSource,
+    serviceManager: ServiceManager,
+) : IncomingCspMessageSubTask<GroupDeliveryReceiptMessage>(message, triggerSource, serviceManager) {
+    private val messageService = serviceManager.messageService
+
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult =
+        executeMessageSteps(
+            runCommonGroupReceiveSteps = {
+                runCommonGroupReceiveSteps(message, handle, serviceManager)
+            }
+        )
+
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult = executeMessageSteps()
+
+    private suspend fun executeMessageSteps(
+        runCommonGroupReceiveSteps: (suspend () -> GroupModel?)? = null
+    ): ReceiveStepsResult {
+        logger.info("Processing message {}: incoming group delivery receipt", message.messageId)
+
+        val messageState: MessageState? = MessageUtil.receiptTypeToMessageState(message.receiptType)
+        if (messageState == null || !MessageUtil.isReaction(messageState)) {
+            logger.warn(
+                "Message {} error: unknown or unsupported delivery receipt type: {}",
+                message.messageId,
+                message.receiptType
+            )
+            return ReceiveStepsResult.DISCARD
+        }
+
+        if (runCommonGroupReceiveSteps != null) {
+            // If the common group receive steps did not succeed (null is returned), ignore this delivery receipt
+            runCommonGroupReceiveSteps() ?: return ReceiveStepsResult.DISCARD
+        }
+
+        for (receiptMessageId: MessageId in message.receiptMessageIds) {
+            logger.info(
+                "Processing message {}: group delivery receipt for {} (state = {})",
+                message.messageId,
+                receiptMessageId,
+                messageState
+            )
+            val groupMessageModel: GroupMessageModel? = messageService.getGroupMessageModel(
+                receiptMessageId,
+                message.groupCreator,
+                message.apiGroupId
+            )
+            if (groupMessageModel == null) {
+                logger.warn("Group message model ({}) for incoming group delivery receipt is null", receiptMessageId)
+                continue
+            }
+            messageService.addMessageReaction(
+                groupMessageModel,
+                messageState,
+                message.fromIdentity,
+                message.date
+            )
+        }
+
+        return ReceiveStepsResult.SUCCESS
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingTypingIndicatorTask.kt b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingTypingIndicatorTask.kt
similarity index 65%
rename from app/src/main/java/ch/threema/app/processors/statusupdates/IncomingTypingIndicatorTask.kt
rename to app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingTypingIndicatorTask.kt
index 3742b12d..fd911476 100644
--- a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingTypingIndicatorTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingTypingIndicatorTask.kt
@@ -19,26 +19,32 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.app.processors.statusupdates
+package ch.threema.app.processors.incomingcspmessage.statusupdates
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
 
 class IncomingTypingIndicatorTask(
-    private val message: TypingIndicatorMessage,
+    message: TypingIndicatorMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<TypingIndicatorMessage>(message, triggerSource, serviceManager) {
     private val contactService = serviceManager.contactService
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec) =
+        processIncomingTypingIndicator()
+
+    override suspend fun executeMessageStepsFromSync() = processIncomingTypingIndicator()
+
+    private fun processIncomingTypingIndicator(): ReceiveStepsResult {
         if (contactService.getByIdentity(message.fromIdentity) != null) {
             contactService.setIsTyping(message.fromIdentity, message.isTyping)
             return ReceiveStepsResult.SUCCESS
         }
         return ReceiveStepsResult.DISCARD
     }
-
 }
diff --git a/app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt b/app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt
index 89a80f44..a37ea1b3 100644
--- a/app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt
@@ -22,21 +22,31 @@
 package ch.threema.app.processors.push
 
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
+import ch.threema.app.processors.incomingcspmessage.IncomingCspMessageSubTask
+import ch.threema.app.processors.incomingcspmessage.ReceiveStepsResult
 import ch.threema.app.utils.PushUtil
+import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.messages.WebSessionResumeMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TriggerSource
+
+private val logger = LoggingUtil.getThreemaLogger("IncomingWebSessionResumeMessageTask")
 
 class IncomingWebSessionResumeMessageTask(
-    private val message: WebSessionResumeMessage,
+    message: WebSessionResumeMessage,
+    triggerSource: TriggerSource,
     serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
+) : IncomingCspMessageSubTask<WebSessionResumeMessage>(message, triggerSource, serviceManager) {
 
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
+    override suspend fun executeMessageStepsFromRemote(handle: ActiveTaskCodec): ReceiveStepsResult {
         PushUtil.processRemoteMessage(message.getData())
 
         return ReceiveStepsResult.SUCCESS
     }
 
+    override suspend fun executeMessageStepsFromSync(): ReceiveStepsResult {
+
+
+        return ReceiveStepsResult.DISCARD
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedd2dsync/ReflectedContactSyncTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedd2dsync/ReflectedContactSyncTask.kt
new file mode 100644
index 00000000..5961baf0
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedd2dsync/ReflectedContactSyncTask.kt
@@ -0,0 +1,703 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedd2dsync
+
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.services.ConversationTagServiceImpl
+import ch.threema.app.services.DeadlineListService
+import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.ContactUtil
+import ch.threema.app.utils.ShortcutUtil
+import ch.threema.app.utils.contentEquals
+import ch.threema.base.ThreemaException
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModel
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.repositories.ContactCreateException
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.blob.BlobLoader
+import ch.threema.domain.protocol.blob.BlobScope
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.taskmanager.catchAllExceptNetworkException
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.Common.Blob
+import ch.threema.protobuf.d2d.MdD2D.ContactSync
+import ch.threema.protobuf.d2d.MdD2D.ContactSync.Create
+import ch.threema.protobuf.d2d.MdD2D.ContactSync.Update
+import ch.threema.protobuf.d2d.sync.MdD2DSync
+import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact
+import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy
+import ch.threema.protobuf.d2d.sync.MdD2DSync.NotificationSoundPolicy
+import ch.threema.protobuf.d2d.sync.contactDefinedProfilePictureOrNull
+import ch.threema.protobuf.d2d.sync.userDefinedProfilePictureOrNull
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+import ch.threema.storage.models.ConversationModel
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedContactSyncTask")
+
+class ReflectedContactSyncTask(
+    private val contactSync: ContactSync,
+    private val contactModelRepository: ContactModelRepository,
+    private val serviceManager: ServiceManager,
+) {
+    private val hiddenChatListService by lazy { serviceManager.hiddenChatsListService }
+    private val mutedChatsService by lazy { serviceManager.mutedChatsListService }
+    private val ringtoneService by lazy { serviceManager.ringtoneService }
+    private val symmetricEncryptionService by lazy { serviceManager.symmetricEncryptionService }
+    private val fileService by lazy { serviceManager.fileService }
+    private val contactService by lazy { serviceManager.contactService }
+
+    private val multiDeviceProperties by lazy { serviceManager.multiDeviceManager.propertiesProvider }
+
+    // Used when chats are pinned
+    private val conversationTagService by lazy { serviceManager.conversationTagService }
+    private val conversationService by lazy { serviceManager.conversationService }
+
+    fun run() {
+        when (contactSync.actionCase) {
+            ContactSync.ActionCase.CREATE -> handleContactCreate(contactSync.create)
+            ContactSync.ActionCase.UPDATE -> handleContactUpdate(contactSync.update)
+            ContactSync.ActionCase.DELETE -> logger.error("Cannot receive contact sync delete")
+            ContactSync.ActionCase.ACTION_NOT_SET -> logger.warn("No action set for contact sync")
+            null -> logger.warn("Action is null for contact sync")
+        }
+    }
+
+    private fun handleContactCreate(contactCreate: Create) {
+        logger.info("Processing reflected contact create")
+
+        if (!contactCreate.hasContact()) {
+            logger.warn("No contact provided in reflected contact create")
+            return
+        }
+
+        // Check whether this contact already exists
+        if (contactModelRepository.getByIdentity(contactCreate.contact.identity) != null) {
+            logger.error(
+                "Discarding 'create' message, contact {} already exists.",
+                contactCreate.contact.identity
+            )
+            return
+        }
+
+        // Build contact model data based on the reflected data
+        val contactModelData = try {
+            contactCreate.contact.toNewContactModelData()
+        } catch (e: MissingPropertyException) {
+            logger.error(
+                "Property {} is missing for a new contact. Discarding contact sync create message.",
+                e.propertyName
+            )
+            return
+        }
+
+        // Create new contact
+        try {
+            contactModelRepository.createFromSync(contactModelData)
+        } catch (e: ContactCreateException) {
+            logger.error("Could not create contact", e)
+            return
+        }
+
+        applyProfilePictures(contactCreate.contact)
+
+        logger.info("New contact {} successfully created from sync", contactCreate.contact.identity)
+    }
+
+    private fun handleContactUpdate(contactUpdate: Update) {
+        logger.info("Processing reflected contact update")
+
+        val identity = contactUpdate.contact.identity
+
+        val contactModel = contactModelRepository.getByIdentity(identity)
+        if (contactModel != null) {
+            applyContactModelUpdate(contactModel, contactUpdate.contact)
+        } else {
+            logger.error("Got a contact update for an unknown contact: {}", identity)
+        }
+    }
+
+    private fun applyContactModelUpdate(contactModel: ContactModel, contact: Contact) {
+        applyNames(contactModel, contact)
+
+        applyVerificationLevel(contactModel, contact)
+
+        applyIdentityType(contactModel, contact)
+
+        applyAcquaintanceLevel(contactModel, contact)
+
+        applyActivityState(contactModel, contact)
+
+        applyFeatureMask(contactModel, contact)
+
+        applySyncState(contactModel, contact)
+
+        applyReadReceiptPolicyOverride(contactModel, contact)
+
+        applyTypingIndicatorPolicyOverride(contactModel, contact)
+
+        applyNotificationTriggerPolicy(contact)
+
+        applyNotificationSoundPolicy(contact)
+
+        applyProfilePictures(contact)
+
+        applyConversationCategory(contact)
+
+        applyConversationVisibility(contact)
+    }
+
+    private fun applyNames(contactModel: ContactModel, contact: Contact) {
+        contact.getFirstNameOrNull()?.let {
+            contactModel.setFirstNameFromSync(it)
+        }
+        contact.getLastNameOrNull()?.let {
+            contactModel.setLastNameFromSync(it)
+        }
+        contact.getNicknameOrNull()?.let {
+            contactModel.setNicknameFromSync(it)
+        }
+    }
+
+    private fun applyVerificationLevel(contactModel: ContactModel, contact: Contact) {
+        contact.getVerificationLevelOrNull()?.let {
+            contactModel.setVerificationLevelFromSync(it)
+        }
+        contact.getWorkVerificationLevelOrNull()?.let {
+            contactModel.setWorkVerificationLevelFromSync(it)
+        }
+    }
+
+    private fun applyIdentityType(contactModel: ContactModel, contact: Contact) {
+        contact.getIdentityTypeOrNull()?.let {
+            contactModel.setIdentityTypeFromSync(it)
+        }
+    }
+
+    private fun applyAcquaintanceLevel(contactModel: ContactModel, contact: Contact) {
+        contact.getAcquaintanceLevelOrNull()?.let {
+            contactModel.setAcquaintanceLevelFromSync(it)
+        }
+    }
+
+    private fun applyActivityState(contactModel: ContactModel, contact: Contact) {
+        contact.getActivityStateOrNull()?.let {
+            contactModel.setActivityStateFromSync(it)
+        }
+    }
+
+    private fun applyFeatureMask(contactModel: ContactModel, contact: Contact) {
+        contact.getFeatureMaskOrNull()?.let {
+            contactModel.setFeatureMaskFromSync(it)
+        }
+    }
+
+    private fun applySyncState(contactModel: ContactModel, contact: Contact) {
+        contact.getSyncStateOrNull()?.let {
+            contactModel.setSyncStateFromSync(it)
+        }
+    }
+
+    private fun applyReadReceiptPolicyOverride(contactModel: ContactModel, contact: Contact) {
+        contact.getReadReceiptPolicyOrNull()?.let {
+            contactModel.setReadReceiptPolicyFromSync(it)
+        }
+    }
+
+    private fun applyTypingIndicatorPolicyOverride(contactModel: ContactModel, contact: Contact) {
+        contact.getTypingIndicatorPolicyOrNull()?.let {
+            contactModel.setTypingIndicatorPolicyFromSync(it)
+        }
+    }
+
+    private fun applyConversationCategory(contact: Contact) {
+        if (contact.hasConversationCategory()) {
+            when (contact.conversationCategory) {
+                MdD2DSync.ConversationCategory.DEFAULT -> false
+                MdD2DSync.ConversationCategory.PROTECTED -> true
+                MdD2DSync.ConversationCategory.UNRECOGNIZED -> unrecognizedValue("conversation category")
+                null -> nullValue("conversation category")
+            }?.let { isPrivateChat ->
+                val uid = ContactUtil.getUniqueIdString(contact.identity)
+                val hiddenChatListContainsUid = hiddenChatListService.has(uid)
+                if (isPrivateChat) {
+                    if (!hiddenChatListContainsUid) {
+                        hiddenChatListService.add(uid, DeadlineListService.DEADLINE_INDEFINITE)
+                    }
+                } else {
+                    if (hiddenChatListContainsUid) {
+                        hiddenChatListService.remove(uid)
+                    }
+                }
+            }
+        }
+    }
+
+    private fun applyNotificationTriggerPolicy(contact: Contact) {
+        val uid = ContactUtil.getUniqueIdString(contact.identity)
+
+        if (contact.hasNotificationTriggerPolicyOverride()) {
+            if (contact.notificationTriggerPolicyOverride.hasDefault()) {
+                mutedChatsService.remove(uid)
+            } else if (contact.notificationTriggerPolicyOverride.hasPolicy()) {
+                val policy = contact.notificationTriggerPolicyOverride.policy
+                val expiresAt = if (policy.hasExpiresAt()) {
+                    policy.expiresAt
+                } else {
+                    DeadlineListService.DEADLINE_INDEFINITE
+                }
+                when (policy.policy) {
+                    NotificationTriggerPolicy.NEVER -> mutedChatsService.add(uid, expiresAt)
+                    NotificationTriggerPolicy.UNRECOGNIZED -> unrecognizedValue("notification trigger policy")
+                    null -> nullValue("notification trigger policy")
+                }
+            } else {
+                logger.warn("Notification trigger policy does not contain default or policy")
+            }
+        }
+    }
+
+    private fun applyNotificationSoundPolicy(contact: Contact) {
+        val uid = ContactUtil.getUniqueIdString(contact.identity)
+
+        if (contact.hasNotificationSoundPolicyOverride()) {
+            if (contact.notificationSoundPolicyOverride.hasDefault()) {
+                if (ringtoneService.isSilent(uid, false)) {
+                    ringtoneService.setRingtone(uid, ringtoneService.defaultContactRingtone)
+                }
+            } else if (contact.notificationSoundPolicyOverride.hasPolicy()) {
+                when (contact.notificationSoundPolicyOverride.policy) {
+                    NotificationSoundPolicy.MUTED -> ringtoneService.setRingtone(uid, null)
+                    NotificationSoundPolicy.UNRECOGNIZED -> unrecognizedValue("notification sound policy")
+                    null -> nullValue("notification sound policy")
+                }
+            } else {
+                logger.warn("Notification sound policy does not contain default or policy")
+            }
+        }
+    }
+
+    private fun applyProfilePictures(contact: Contact) {
+        applyContactDefinedProfilePicture(contact)
+        applyUserDefinedProfilePicture(contact)
+    }
+
+    private fun applyContactDefinedProfilePicture(contact: Contact) {
+        when (contact.contactDefinedProfilePictureOrNull?.imageCase) {
+            Common.DeltaImage.ImageCase.UPDATED -> {
+                contact.contactDefinedProfilePicture.updated.blob.downloadBlob { blob ->
+                    if (!fileService.getContactDefinedProfilePictureStream(contact.identity).contentEquals(blob)) {
+                        logger.info("Setting contact defined profile picture from sync")
+                        fileService.writeContactDefinedProfilePicture(contact.identity, blob)
+                        onAvatarChanged(contact.identity)
+                    }
+                }
+            }
+
+            Common.DeltaImage.ImageCase.REMOVED -> {
+                if (fileService.hasContactDefinedProfilePicture(contact.identity)) {
+                    logger.info("Removing contact defined profile picture from sync")
+                    fileService.removeContactDefinedProfilePicture(contact.identity)
+                    onAvatarChanged(contact.identity)
+                }
+            }
+
+            Common.DeltaImage.ImageCase.IMAGE_NOT_SET -> logger.warn("Contact defined profile picture is not set")
+            null -> Unit
+        }
+    }
+
+    private fun applyUserDefinedProfilePicture(contact: Contact) {
+        when (contact.userDefinedProfilePictureOrNull?.imageCase) {
+            Common.DeltaImage.ImageCase.UPDATED -> {
+                contact.userDefinedProfilePicture.updated.blob.downloadBlob { blob ->
+                    if (!fileService.getUserDefinedProfilePictureStream(contact.identity).contentEquals(blob)) {
+                        logger.info("Setting user defined profile picture from sync")
+                        fileService.writeUserDefinedProfilePicture(contact.identity, blob)
+                        onAvatarChanged(contact.identity)
+                    }
+                }
+            }
+
+            Common.DeltaImage.ImageCase.REMOVED -> {
+                if (fileService.hasUserDefinedProfilePicture(contact.identity)) {
+                    logger.info("Removing user defined profile picture from sync")
+                    fileService.removeUserDefinedProfilePicture(contact.identity)
+                    onAvatarChanged(contact.identity)
+                }
+            }
+
+            Common.DeltaImage.ImageCase.IMAGE_NOT_SET -> logger.warn("User defined profile picture is not set")
+            null -> Unit
+        }
+    }
+
+    private fun onAvatarChanged(identity: String) {
+        ListenerManager.contactListeners.handle { it.onAvatarChanged(identity) }
+        ShortcutUtil.updateShareTargetShortcut(contactService.createReceiver(identity))
+    }
+
+    private fun Blob.downloadBlob(persistBlob: (blob: ByteArray) -> Unit) {
+        val blobLoader = getBlobLoader()
+        val encryptedBlob = {
+            blobLoader.load(BlobScope.Local)
+        }.catchAllExceptNetworkException { e ->
+            logger.error("Could not download blob", e)
+            return
+        }
+
+        val decryptedBlob = {
+            symmetricEncryptionService.decrypt(
+                encryptedBlob,
+                key.toByteArray(),
+                nonce.toByteArray().let { nonceBytes ->
+                    if (nonceBytes.isEmpty()) {
+                        ProtocolDefines.CONTACT_PHOTO_NONCE
+                    } else {
+                        nonceBytes
+                    }
+                }
+            )
+        }.catchAllExceptNetworkException { e ->
+            logger.error("Could not decrypt blob", e)
+            return
+        }
+
+        if (decryptedBlob == null) {
+            logger.warn("Decrypted blob is null")
+            blobLoader.markAsDone(id.toByteArray(), BlobScope.Local)
+            return
+        }
+
+        persistBlob(decryptedBlob)
+
+        blobLoader.markAsDone(id.toByteArray(), BlobScope.Local)
+    }
+
+    private fun Blob.getBlobLoader() = BlobLoader.mirror(
+        baseOkHttpClient = serviceManager.okHttpClient,
+        blobId = id.toByteArray(),
+        version = ThreemaApplication.getAppVersion(),
+        shouldLogHttp = ConfigUtils.isDevBuild(),
+        serverAddressProvider = serviceManager.serverAddressProviderService.serverAddressProvider,
+        progressListener = null,
+        multiDevicePropertyProvider = multiDeviceProperties,
+    )
+
+    private fun applyConversationVisibility(contact: Contact) {
+        if (contact.hasConversationVisibility()) {
+            when (contact.conversationVisibility) {
+                MdD2DSync.ConversationVisibility.NORMAL -> {
+                    // TODO(ANDR-3010): Use new conversation model
+                    val archivedConversationModel = getArchivedConversationModel(contact.identity)
+                    if (archivedConversationModel != null) {
+                        conversationService.unarchive(listOf(archivedConversationModel))
+                    } else {
+                        unPinConversation(contact.identity)
+                    }
+                }
+
+                MdD2DSync.ConversationVisibility.ARCHIVED -> {
+                    getConversationModel(contact.identity)?.let {
+                        conversationService.archive(it)
+                    }
+                }
+
+                MdD2DSync.ConversationVisibility.PINNED -> {
+                    getArchivedConversationModel(contact.identity)?.let {
+                        conversationService.unarchive(listOf(it))
+                    }
+                    pinConversation(contact.identity)
+                }
+
+                MdD2DSync.ConversationVisibility.UNRECOGNIZED -> unrecognizedValue("conversation visibility")
+
+                null -> nullValue("conversation visibility")
+            }
+        }
+    }
+
+    private fun pinConversation(identity: String) {
+        // TODO(ANDR-3010): Use new conversation model
+        val conversationModel = getConversationModel(identity) ?: return
+        val tagModel = conversationTagService.getTagModel(ConversationTagServiceImpl.FIXED_TAG_PIN)
+        conversationTagService.addTagAndNotify(conversationModel, tagModel)
+        conversationModel.setIsPinTagged(true)
+    }
+
+    private fun unPinConversation(identity: String) {
+        // TODO(ANDR-3010): Use new conversation model
+        val conversationModel = getConversationModel(identity) ?: return
+        val tagModel = conversationTagService.getTagModel(ConversationTagServiceImpl.FIXED_TAG_PIN)
+        conversationTagService.removeTagAndNotify(conversationModel, tagModel)
+        conversationModel.setIsPinTagged(false)
+    }
+
+    private fun getConversationModel(identity: String): ConversationModel? {
+        return conversationService.getAll(false)
+            .find { it.contact?.identity == identity }.also {
+                if (it == null) {
+                    logger.warn("Could not find conversation model for contact {}", identity)
+                }
+            }
+    }
+
+    private fun getArchivedConversationModel(identity: String): ConversationModel? {
+        return conversationService.getArchived("")
+            .find { it.contact?.identity == identity }.also {
+                if (it == null) {
+                    logger.warn(
+                        "Could not find archived conversation model for contact {}",
+                        identity
+                    )
+                }
+            }
+    }
+
+    private fun unrecognizedValue(valueName: String): Nothing? {
+        logger.warn("Unrecognized {}", valueName)
+        return null
+    }
+
+    private fun nullValue(valueName: String): Nothing? {
+        logger.warn("Value {} is null", valueName)
+        return null
+    }
+
+    private fun Contact.getFirstNameOrNull(): String? {
+        return if (hasFirstName()) {
+            firstName
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getLastNameOrNull(): String? {
+        return if (hasLastName()) {
+            lastName
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getNicknameOrNull(): String? {
+        return if (hasNickname()) {
+            nickname
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getVerificationLevelOrNull(): VerificationLevel? {
+        return if (hasVerificationLevel()) {
+            when (verificationLevel) {
+                Contact.VerificationLevel.FULLY_VERIFIED -> VerificationLevel.FULLY_VERIFIED
+                Contact.VerificationLevel.SERVER_VERIFIED -> VerificationLevel.SERVER_VERIFIED
+                Contact.VerificationLevel.UNVERIFIED -> VerificationLevel.UNVERIFIED
+                Contact.VerificationLevel.UNRECOGNIZED -> unrecognizedValue("verification level")
+                null -> nullValue("verification level")
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getWorkVerificationLevelOrNull(): WorkVerificationLevel? {
+        return if (hasWorkVerificationLevel()) {
+            when (workVerificationLevel) {
+                Contact.WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED -> WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+                Contact.WorkVerificationLevel.NONE -> WorkVerificationLevel.NONE
+                Contact.WorkVerificationLevel.UNRECOGNIZED -> unrecognizedValue("work verification level")
+                null -> nullValue("work verification level")
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getIdentityTypeOrNull(): IdentityType? {
+        return if (hasIdentityType()) {
+            when (identityType) {
+                Contact.IdentityType.REGULAR -> IdentityType.NORMAL
+                Contact.IdentityType.WORK -> IdentityType.WORK
+                Contact.IdentityType.UNRECOGNIZED -> unrecognizedValue("identity type")
+                null -> nullValue("identity type")
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getAcquaintanceLevelOrNull(): AcquaintanceLevel? {
+        return if (hasAcquaintanceLevel()) {
+            when (acquaintanceLevel) {
+                Contact.AcquaintanceLevel.DIRECT -> AcquaintanceLevel.DIRECT
+                Contact.AcquaintanceLevel.GROUP -> AcquaintanceLevel.GROUP
+                Contact.AcquaintanceLevel.UNRECOGNIZED -> unrecognizedValue("acquaintance level")
+                null -> nullValue("acquaintance level")
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getActivityStateOrNull(): IdentityState? {
+        return if (hasActivityState()) {
+            when (activityState) {
+                Contact.ActivityState.ACTIVE -> IdentityState.ACTIVE
+                Contact.ActivityState.INACTIVE -> IdentityState.INACTIVE
+                Contact.ActivityState.INVALID -> IdentityState.INVALID
+                Contact.ActivityState.UNRECOGNIZED -> unrecognizedValue("activity state")
+                null -> nullValue("activity state")
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getFeatureMaskOrNull(): ULong? {
+        return if (hasFeatureMask()) {
+            featureMask.toULong()
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getSyncStateOrNull(): ContactSyncState? {
+        return if (hasSyncState()) {
+            when (syncState) {
+                Contact.SyncState.INITIAL -> ContactSyncState.INITIAL
+                Contact.SyncState.IMPORTED -> ContactSyncState.IMPORTED
+                Contact.SyncState.CUSTOM -> ContactSyncState.CUSTOM
+                Contact.SyncState.UNRECOGNIZED -> unrecognizedValue("sync state")
+                null -> nullValue("sync state")
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getReadReceiptPolicyOrNull(): ReadReceiptPolicy? {
+        return if (hasReadReceiptPolicyOverride()) {
+            when {
+                readReceiptPolicyOverride.hasDefault() -> ReadReceiptPolicy.DEFAULT
+                readReceiptPolicyOverride.hasPolicy() -> when (readReceiptPolicyOverride.policy) {
+                    MdD2DSync.ReadReceiptPolicy.SEND_READ_RECEIPT -> ReadReceiptPolicy.SEND
+                    MdD2DSync.ReadReceiptPolicy.DONT_SEND_READ_RECEIPT -> ReadReceiptPolicy.DONT_SEND
+                    MdD2DSync.ReadReceiptPolicy.UNRECOGNIZED -> unrecognizedValue("read receipt policy override")
+                    null -> nullValue("read receipt policy override")
+                }
+
+                else -> {
+                    logger.warn("Read receipt policy override does not have default nor policy")
+                    null
+                }
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getTypingIndicatorPolicyOrNull(): TypingIndicatorPolicy? {
+        return if (hasTypingIndicatorPolicyOverride()) {
+            when {
+                typingIndicatorPolicyOverride.hasDefault() -> TypingIndicatorPolicy.DEFAULT
+                typingIndicatorPolicyOverride.hasPolicy() -> when (typingIndicatorPolicyOverride.policy) {
+                    MdD2DSync.TypingIndicatorPolicy.SEND_TYPING_INDICATOR -> TypingIndicatorPolicy.SEND
+                    MdD2DSync.TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR -> TypingIndicatorPolicy.DONT_SEND
+                    MdD2DSync.TypingIndicatorPolicy.UNRECOGNIZED -> unrecognizedValue("typing indicator policy")
+                    null -> nullValue("typing indicator policy")
+                }
+
+                else -> {
+                    logger.warn("Typing indicator policy override does not have default nor policy")
+                    null
+                }
+            }
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getPublicKeyOrNull(): ByteArray? {
+        return if (hasPublicKey()) {
+            publicKey.toByteArray()
+        } else {
+            null
+        }
+    }
+
+    private fun Contact.getCreatedAtOrNull(): Date? {
+        return if (hasCreatedAt()) {
+            return Date(createdAt)
+        } else {
+            null
+        }
+    }
+
+    /**
+     * Get the contact model data for the synced contact. Note that this expects a new contact and
+     * therefore requires all mandatory properties to be set according to the protocol. If an
+     * optional property is not set, default values are used.
+     *
+     * @throws MissingPropertyException if a required property for a new contact is missing
+     */
+    private fun Contact.toNewContactModelData() = ContactModelData(
+        identity = identity,
+        publicKey = getPublicKeyOrNull() ?: missingProperty("publicKey"),
+        createdAt = getCreatedAtOrNull() ?: missingProperty("createdAt"),
+        firstName = getFirstNameOrNull() ?: "",
+        lastName = getLastNameOrNull() ?: "",
+        nickname = getNicknameOrNull(),
+        verificationLevel = getVerificationLevelOrNull() ?: VerificationLevel.UNVERIFIED,
+        workVerificationLevel = getWorkVerificationLevelOrNull() ?: WorkVerificationLevel.NONE,
+        identityType = getIdentityTypeOrNull() ?: IdentityType.NORMAL,
+        acquaintanceLevel = getAcquaintanceLevelOrNull() ?: AcquaintanceLevel.DIRECT,
+        activityState = getActivityStateOrNull() ?: IdentityState.ACTIVE,
+        syncState = getSyncStateOrNull() ?: ContactSyncState.INITIAL,
+        featureMask = getFeatureMaskOrNull() ?: missingProperty("featureMask"),
+        readReceiptPolicy = getReadReceiptPolicyOrNull() ?: ReadReceiptPolicy.DEFAULT,
+        typingIndicatorPolicy = getTypingIndicatorPolicyOrNull() ?: TypingIndicatorPolicy.DEFAULT,
+        androidContactLookupKey = null,
+        localAvatarExpires = null,
+        isRestored = false,
+        profilePictureBlobId = null,
+        jobTitle = null,
+        department = null,
+    )
+
+    private fun missingProperty(propertyName: String): Nothing =
+        throw MissingPropertyException(propertyName)
+
+    private class MissingPropertyException(val propertyName: String) :
+        ThreemaException("Missing property '")
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedIncomingMessageUpdateTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedIncomingMessageUpdateTask.kt
new file mode 100644
index 00000000..863ad3bf
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedIncomingMessageUpdateTask.kt
@@ -0,0 +1,130 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedmessageupdate
+
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.utils.ConversationNotificationUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.protobuf.Common.GroupIdentity
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.CONTACT
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.DISTRIBUTION_LIST
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.GROUP
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.ID_NOT_SET
+import ch.threema.protobuf.d2d.MdD2D.IncomingMessageUpdate
+import ch.threema.protobuf.d2d.MdD2D.IncomingMessageUpdate.Update.UpdateCase.READ
+import ch.threema.storage.models.AbstractMessageModel
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedIncomingMessageUpdateTask")
+
+class ReflectedIncomingMessageUpdateTask(
+    private val incomingMessageUpdate: IncomingMessageUpdate,
+    serviceManager: ServiceManager,
+) {
+    private val messageService by lazy { serviceManager.messageService }
+    private val notificationService by lazy { serviceManager.notificationService }
+
+    fun run() {
+        logger.info("Processing reflected incoming message update")
+
+        incomingMessageUpdate.updatesList.forEach { update ->
+            when (update.updateCase) {
+                READ -> applyReadUpdate(update)
+                else -> logger.error("Received an unknown incoming message update '${update.updateCase}'")
+            }
+        }
+    }
+
+    private fun applyReadUpdate(update: IncomingMessageUpdate.Update) {
+        val conversation = update.conversation
+        val messageId = MessageId(update.messageId)
+        val readAt = update.read.at
+        when (conversation.idCase) {
+            CONTACT -> applyContactMessageReadUpdate(messageId, conversation.contact, readAt)
+
+            GROUP -> applyGroupMessageReadUpdate(messageId, conversation.group, readAt)
+
+            DISTRIBUTION_LIST -> throw IllegalStateException(
+                "Received incoming message update for a distribution list"
+            )
+
+            ID_NOT_SET -> logger.warn("Received incoming message update where id is not set")
+
+            null -> logger.warn("Received incoming message update where id is null")
+        }
+    }
+
+    private fun applyContactMessageReadUpdate(
+        messageId: MessageId,
+        senderIdentity: String,
+        readAt: Long,
+    ) {
+        val messageModel = messageService.getContactMessageModel(messageId, senderIdentity)
+        if (messageModel == null) {
+            logger.warn("Message model for message {} of {} not found", messageId, senderIdentity)
+            return
+        }
+
+        markMessageModelAsRead(messageModel, readAt)
+    }
+
+    private fun applyGroupMessageReadUpdate(
+        messageId: MessageId,
+        groupIdentity: GroupIdentity,
+        readAt: Long,
+    ) {
+        val messageModel = messageService.getGroupMessageModel(
+            messageId,
+            groupIdentity.creatorIdentity,
+            GroupId(groupIdentity.groupId)
+        )
+
+        if (messageModel == null) {
+            logger.warn("Group message model for message {} not found", messageId)
+            return
+        }
+
+        markMessageModelAsRead(messageModel, readAt)
+    }
+
+    private fun markMessageModelAsRead(messageModel: AbstractMessageModel, readAt: Long) {
+        messageModel.setRead(true)
+        Date(readAt).let {
+            messageModel.setReadAt(it)
+            messageModel.setModifiedAt(it)
+        }
+        messageService.save(messageModel)
+        ListenerManager.messageListeners.handle { l -> l.onModified(listOf(messageModel)) }
+        cancelNotification(messageModel)
+    }
+
+    private fun cancelNotification(messageModel: AbstractMessageModel) {
+        // Get notification UIDs of the messages that have just been marked as read
+        val notificationUid = ConversationNotificationUtil.getUid(messageModel)
+
+        // Cancel notification
+        notificationService.cancelConversationNotification(notificationUid)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedOutgoingMessageUpdateTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedOutgoingMessageUpdateTask.kt
new file mode 100644
index 00000000..390e4c6d
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedOutgoingMessageUpdateTask.kt
@@ -0,0 +1,131 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedmessageupdate
+
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.CONTACT
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.DISTRIBUTION_LIST
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.GROUP
+import ch.threema.protobuf.d2d.MdD2D.ConversationId.IdCase.ID_NOT_SET
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessageUpdate.Update
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessageUpdate.Update.UpdateCase.SENT
+import ch.threema.storage.models.AbstractMessageModel
+import ch.threema.storage.models.MessageState
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingMessageUpdateTask")
+
+class ReflectedOutgoingMessageUpdateTask(
+    private val outgoingMessageUpdate: MdD2D.OutgoingMessageUpdate,
+    private val timestamp: ULong,
+    serviceManager: ServiceManager,
+) {
+    private val messageService by lazy { serviceManager.messageService }
+
+    fun run() {
+        outgoingMessageUpdate.updatesList.forEach { update ->
+            when (update.updateCase) {
+                SENT -> applySentUpdate(update)
+                else -> logger.error("Received an unknown outgoing message update '${update.updateCase}'")
+            }
+        }
+    }
+
+    private fun applySentUpdate(update: Update) {
+        val conversation = update.conversation
+        val messageId = MessageId(update.messageId)
+        when (conversation.idCase) {
+            CONTACT -> applyContactMessageSentUpdate(messageId, conversation.contact)
+
+            GROUP -> applyGroupMessageSentUpdate(messageId, conversation.group)
+
+            DISTRIBUTION_LIST -> updateDistributionListMessageState(
+                messageId,
+                conversation.distributionList
+            )
+
+            ID_NOT_SET -> logger.warn("Received outgoing message update where id is not set")
+
+            null -> logger.warn("Received outgoing message update where id is null")
+        }
+    }
+
+    private fun applyContactMessageSentUpdate(
+        messageId: MessageId,
+        recipientIdentity: String,
+    ) {
+        val messageModel = messageService.getContactMessageModel(messageId, recipientIdentity)
+
+        if (messageModel == null) {
+            logger.warn(
+                "Message model for message {} to {} not found",
+                messageId,
+                recipientIdentity
+            )
+            return
+        }
+
+        updateMessageModelSentState(messageModel)
+    }
+
+    private fun applyGroupMessageSentUpdate(
+        messageId: MessageId,
+        groupIdentity: Common.GroupIdentity,
+    ) {
+        val messageModel = messageService.getGroupMessageModel(
+            messageId,
+            groupIdentity.creatorIdentity,
+            GroupId(groupIdentity.groupId)
+        )
+
+        if (messageModel == null) {
+            logger.warn("Group message model for message {} not found", messageId)
+            return
+        }
+
+        updateMessageModelSentState(messageModel)
+    }
+
+    private fun updateDistributionListMessageState(
+        messageId: MessageId,
+        distributionList: Long,
+    ) {
+        // TODO(ANDR-2718)
+    }
+
+    private fun updateMessageModelSentState(messageModel: AbstractMessageModel) {
+        messageService.updateOutgoingMessageState(
+            messageModel,
+            MessageState.SENT,
+            Date(timestamp.toLong())
+        )
+        ListenerManager.messageListeners.handle {
+            it.onModified(listOf(messageModel))
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactRequestProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactRequestProfilePictureTask.kt
new file mode 100644
index 00000000..e4933dfe
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactRequestProfilePictureTask.kt
@@ -0,0 +1,60 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingContactRequestProfilePictureTask")
+
+/**
+ * Note that currently outgoing contact request profile picture messages are not reflected.
+ * Therefore this task is currently never executed.
+ */
+internal class ReflectedOutgoingContactRequestProfilePictureTask(
+    message: OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingContactMessageTask(
+    message,
+    Common.CspE2eMessageType.CONTACT_REQUEST_PROFILE_PICTURE,
+    serviceManager,
+) {
+
+    private val requestProfilePictureMessage by lazy {
+        ContactRequestProfilePictureMessage.fromReflected(message)
+    }
+
+    override val shouldBumpLastUpdate: Boolean = requestProfilePictureMessage.bumpLastUpdate()
+
+    override val storeNonces: Boolean = requestProfilePictureMessage.protectAgainstReplay()
+
+    override fun processOutgoingMessage() {
+        val identity = messageReceiver.contact.identity
+        contactModelRepository.getByIdentity(identity)
+            ?.setIsRestored(false)
+            ?: logger.error("Received outgoing message for unknown contact {}", identity)
+    }
+
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactSetProfilePictureTask.kt
new file mode 100644
index 00000000..3594449c
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactSetProfilePictureTask.kt
@@ -0,0 +1,51 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingContactSetProfilePictureTask")
+
+internal class ReflectedOutgoingContactSetProfilePictureTask(message: OutgoingMessage, serviceManager: ServiceManager) : ReflectedOutgoingContactMessageTask(
+    message,
+    Common.CspE2eMessageType.CONTACT_SET_PROFILE_PICTURE,
+    serviceManager,
+) {
+    private val setProfilePictureMessage by lazy {
+        SetProfilePictureMessage.fromReflected(message)
+    }
+
+    override val shouldBumpLastUpdate: Boolean = setProfilePictureMessage.bumpLastUpdate()
+
+    override val storeNonces: Boolean = setProfilePictureMessage.protectAgainstReplay()
+
+    override fun processOutgoingMessage() {
+        val identity = messageReceiver.contact.identity
+        contactModelRepository.getByIdentity(identity)
+            ?.setProfilePictureBlobId(setProfilePictureMessage.blobId)
+            ?: logger.error("Received reflected outgoing message to unknown contact {}", identity)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeleteProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeleteProfilePictureTask.kt
new file mode 100644
index 00000000..24bca723
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeleteProfilePictureTask.kt
@@ -0,0 +1,55 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+import ch.threema.storage.models.ContactModel
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingDeleteProfilePictureTask")
+
+internal class ReflectedOutgoingDeleteProfilePictureTask(
+    message: OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingContactMessageTask(
+    message,
+    Common.CspE2eMessageType.CONTACT_DELETE_PROFILE_PICTURE,
+    serviceManager,
+) {
+    private val deleteProfilePictureMessage by lazy {
+        DeleteProfilePictureMessage.fromReflected(message)
+    }
+
+    override val shouldBumpLastUpdate: Boolean = deleteProfilePictureMessage.bumpLastUpdate()
+
+    override val storeNonces: Boolean = deleteProfilePictureMessage.protectAgainstReplay()
+
+    override fun processOutgoingMessage() {
+        val identity = messageReceiver.contact.identity
+        contactModelRepository.getByIdentity(identity)
+            ?.setProfilePictureBlobId(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)
+            ?: logger.error("Received reflected outgoing message for unknown contact {}", identity)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeliveryReceiptTask.kt
new file mode 100644
index 00000000..bd750df5
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeliveryReceiptTask.kt
@@ -0,0 +1,129 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.utils.ConversationNotificationUtil
+import ch.threema.app.utils.MessageUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+import ch.threema.storage.models.AbstractMessageModel
+import ch.threema.storage.models.MessageState
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingDeliveryReceiptTask")
+
+internal class ReflectedOutgoingDeliveryReceiptTask(
+    message: OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingContactMessageTask(
+    message,
+    Common.CspE2eMessageType.DELIVERY_RECEIPT,
+    serviceManager
+) {
+    private val messageService by lazy { serviceManager.messageService }
+    private val notificationService by lazy { serviceManager.notificationService }
+    private val myIdentity by lazy { serviceManager.identityStore.identity }
+
+    private val deliveryReceiptMessage by lazy { DeliveryReceiptMessage.fromReflected(message) }
+
+    override val shouldBumpLastUpdate: Boolean = false
+
+    override val storeNonces: Boolean
+        get() = deliveryReceiptMessage.protectAgainstReplay()
+
+    override fun processOutgoingMessage() {
+        logger.info("Processing reflected outgoing delivery receipt")
+
+        val deliveryReceiptMessage = DeliveryReceiptMessage.fromReflected(message)
+        val state = MessageUtil.receiptTypeToMessageState(deliveryReceiptMessage.receiptType)
+
+        if (state == null) {
+            logger.warn("Message {} error: unknown delivery receipt type", message.messageId)
+            return
+        }
+
+        val identity = message.conversation.contact
+
+        for (messageId in deliveryReceiptMessage.receiptMessageIds) {
+            val messageModel = messageService.getContactMessageModel(messageId, identity)
+            if (messageModel == null) {
+                logger.warn(
+                    "Message model ({}) for reflected outgoing delivery receipt is null",
+                    messageId
+                )
+                continue
+            }
+
+            updateMessage(messageModel, state)
+
+            if (state == MessageState.READ) {
+                cancelNotification(messageModel)
+            }
+        }
+    }
+
+    private fun updateMessage(messageModel: AbstractMessageModel, state: MessageState) {
+
+        if (MessageUtil.isReaction(state)) {
+            messageService.addMessageReaction(
+                messageModel,
+                state,
+                myIdentity, // the identity that reacted (this is us => reflected outgoing message)
+                Date(message.createdAt)
+            )
+        } else {
+            when (state) {
+                MessageState.DELIVERED -> {
+                    val date = Date(message.createdAt)
+                    // The delivered at date is stored in created at for incoming messages
+                    messageModel.createdAt = date
+                    messageModel.modifiedAt = date
+                    messageService.save(messageModel)
+                    ListenerManager.messageListeners.handle { l -> l.onModified(listOf(messageModel)) }
+                }
+
+                MessageState.READ -> {
+                    val date = Date(message.createdAt)
+                    messageModel.readAt = date
+                    messageModel.modifiedAt = date
+                    messageModel.setRead(true)
+                    messageService.save(messageModel)
+                    ListenerManager.messageListeners.handle { l -> l.onModified(listOf(messageModel)) }
+                }
+
+                else -> logger.error("Unsupported delivery receipt reflected of state {}", state)
+            }
+        }
+    }
+
+    private fun cancelNotification(messageModel: AbstractMessageModel) {
+        // Get notification UIDs of the messages that have just been marked as read
+        val notificationUid = ConversationNotificationUtil.getUid(messageModel)
+
+        // Cancel notification
+        notificationService.cancelConversationNotification(notificationUid)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingFileTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingFileTask.kt
new file mode 100644
index 00000000..637078cd
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingFileTask.kt
@@ -0,0 +1,134 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.services.MessageServiceImpl
+import ch.threema.app.utils.MimeUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.file.FileData
+import ch.threema.domain.protocol.csp.messages.file.FileMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.storage.models.MessageModel
+import ch.threema.storage.models.MessageState
+import ch.threema.storage.models.MessageType
+import ch.threema.storage.models.data.media.FileDataModel
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingFileTask")
+
+internal class ReflectedOutgoingFileTask(
+    message: MdD2D.OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingContactMessageTask(message, Common.CspE2eMessageType.FILE, serviceManager) {
+
+    private val messageService by lazy { serviceManager.messageService }
+
+    private val fileMessage: FileMessage by lazy { FileMessage.fromByteArray(message.body.toByteArray()) }
+
+    override val storeNonces: Boolean
+        get() = fileMessage.protectAgainstReplay()
+
+    override val shouldBumpLastUpdate: Boolean = true
+
+    override fun processOutgoingMessage() {
+
+        // 1: Check if the group message already exists locally (from previous run(s) of this task).
+        //    If so, cancel and accept that the download for the content(s) might not be complete.
+        messageService.getContactMessageModel(
+            fileMessage.messageId,
+            messageReceiver.contact.identity
+        )?.run { return }
+
+        val fileData: FileData = fileMessage.fileData ?: run {
+            logger.warn("Message {} error: missing file data", message.messageId)
+            return
+        }
+
+        // 2. Map the FileData object to a FileDataModel instance (field "downloaded" is false)
+        val fileDataModel: FileDataModel = FileDataModel.fromIncomingFileData(fileData)
+
+        // 3. Create the actual AbstractMessageModel containing the file and receiver information
+        val messageModel: MessageModel = createMessageModelFromFileMessage(
+            fileMessage = fileMessage,
+            fileDataModel = fileDataModel,
+            fileData = fileData
+        )
+
+        // 4. Save group message model and inform listeners about new message
+        messageService.save(messageModel)
+        ListenerManager.messageListeners.handle { messageListener -> messageListener.onNew(messageModel) }
+
+        // 5. Download thumbnail and content blob (if auto download enabled)
+        processMediaContent(fileData, messageModel)
+    }
+
+    /**
+     *  @return A new instance of `AbstractMessageModel` with type [MessageType.FILE] containing
+     *  the `body` and `dataObject` from the passed file information.
+     *  The messages receiver information is set according to the [messageReceiver].
+     *  State will be [MessageState.SENT].
+     */
+    private fun createMessageModelFromFileMessage(
+        fileMessage: FileMessage,
+        fileDataModel: FileDataModel,
+        fileData: FileData
+    ): MessageModel {
+        val messageModel: MessageModel = messageReceiver.createLocalModel(
+            /* type = */ MessageType.FILE,
+            /* contentsType = */ MimeUtil.getContentTypeFromFileData(fileDataModel),
+            /* postedAt = */ Date(message.createdAt)
+        )
+        initializeMessageModelsCommonFields(messageModel)
+        return messageModel.apply {
+            setFileDataModel(fileDataModel)
+            setMessageFlags(fileMessage.messageFlags)
+            setCorrelationId(fileData.correlationId)
+            setForwardSecurityMode(fileMessage.forwardSecurityMode)
+            state = MessageState.SENT
+        }
+    }
+
+    /**
+     *  **Synchronously**
+     *
+     *  Attempt to download the thumbnail and the actual media content. Even if
+     *  the thumbnail download failed, we try to download the actual blob contents.
+     */
+    private fun processMediaContent(fileData: FileData, messageModel: MessageModel) {
+        runCatching {
+            messageService.downloadThumbnailIfPresent(fileData, messageModel)
+        }.onFailure { throwable ->
+            logger.error("Unable to download thumbnail blob", throwable)
+        }
+        if (messageService.shouldAutoDownload(messageModel)) {
+            runCatching {
+                messageService.downloadMediaMessage(messageModel, null)
+            }.onFailure { throwable ->
+                // a failed blob auto-download should not be considered a failure as the user can try again manually
+                logger.error("Unable to auto-download blob", throwable)
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupDeliveryReceiptTask.kt
new file mode 100644
index 00000000..e697e62c
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupDeliveryReceiptTask.kt
@@ -0,0 +1,92 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.utils.MessageUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.storage.models.GroupMessageModel
+import ch.threema.storage.models.MessageState
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingGroupDeliveryReceiptTask")
+
+internal class ReflectedOutgoingGroupDeliveryReceiptTask(
+    message: MdD2D.OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingContactMessageTask(
+    message,
+    Common.CspE2eMessageType.GROUP_DELIVERY_RECEIPT,
+    serviceManager
+) {
+    private val messageService by lazy { serviceManager.messageService }
+    private val myIdentity by lazy { serviceManager.identityStore.identity }
+
+    private val groupDeliveryReceiptMessage by lazy { GroupDeliveryReceiptMessage.fromReflected(message) }
+
+    override val shouldBumpLastUpdate: Boolean = false
+
+    override val storeNonces: Boolean
+        get() = groupDeliveryReceiptMessage.protectAgainstReplay()
+
+    override fun processOutgoingMessage() {
+        logger.info("Processing message {}: reflected outgoing group delivery receipt", message.messageId)
+
+        val messageState: MessageState? = MessageUtil.receiptTypeToMessageState(groupDeliveryReceiptMessage.receiptType)
+        if (messageState == null || !MessageUtil.isReaction(messageState)) {
+            logger.warn(
+                "Message {} error: unknown or unsupported delivery receipt type: {}",
+                groupDeliveryReceiptMessage.messageId,
+                groupDeliveryReceiptMessage.receiptType
+            )
+            return
+        }
+
+        for (receiptMessageId: MessageId in groupDeliveryReceiptMessage.receiptMessageIds) {
+            logger.info(
+                "Processing message {}: group delivery receipt for {} (state = {})",
+                message.messageId,
+                receiptMessageId,
+                messageState
+            )
+            val groupMessageModel: GroupMessageModel? = messageService.getGroupMessageModel(
+                receiptMessageId,
+                groupDeliveryReceiptMessage.groupCreator,
+                groupDeliveryReceiptMessage.apiGroupId
+            )
+            if (groupMessageModel == null) {
+                logger.warn("Group message model ({}) for reflected outgoing group delivery receipt is null", receiptMessageId)
+                continue
+            }
+            messageService.addMessageReaction(
+                groupMessageModel,
+                messageState,
+                myIdentity, // the identity that reacted (this is us => reflected outgoing message)
+                Date(message.createdAt)
+            )
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupFileTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupFileTask.kt
new file mode 100644
index 00000000..db27a905
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupFileTask.kt
@@ -0,0 +1,142 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.utils.MimeUtil
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.messages.file.FileData
+import ch.threema.domain.protocol.csp.messages.file.FileMessage
+import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.storage.models.GroupMessageModel
+import ch.threema.storage.models.MessageModel
+import ch.threema.storage.models.MessageState
+import ch.threema.storage.models.MessageType
+import ch.threema.storage.models.data.media.FileDataModel
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingGroupFileTask")
+
+internal class ReflectedOutgoingGroupFileTask(
+    message: MdD2D.OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingGroupMessageTask(
+    message,
+    Common.CspE2eMessageType.GROUP_FILE,
+    serviceManager
+) {
+
+    private val messageService by lazy { serviceManager.messageService }
+
+    private val groupFileMessage: GroupFileMessage by lazy { GroupFileMessage.fromByteArray(message.body.toByteArray()) }
+
+    override val storeNonces: Boolean
+        get() = groupFileMessage.protectAgainstReplay()
+
+    override val shouldBumpLastUpdate: Boolean = true
+
+    override fun processOutgoingMessage() {
+
+        // 1: Check if the group message already exists locally (from previous run(s) of this task).
+        //    If so, cancel and accept that the download for the content(s) might not be complete.
+        messageService.getGroupMessageModel(
+            groupFileMessage.messageId,
+            messageReceiver.group.creatorIdentity,
+            messageReceiver.group.apiGroupId
+        )?.run { return }
+
+        val fileData: FileData = groupFileMessage.fileData ?: run {
+            logger.warn("Message {} error: missing file data", message.messageId)
+            return
+        }
+
+        // 2. Map the FileData object to a FileDataModel instance (field "downloaded" is false)
+        val fileDataModel: FileDataModel = FileDataModel.fromIncomingFileData(fileData)
+
+        // 3. Create the actual AbstractMessageModel containing the file and receiver information
+        val groupMessageModel: GroupMessageModel = createMessageModelFromFileMessage(
+            groupFileMessage = groupFileMessage,
+            fileDataModel = fileDataModel,
+            fileData = fileData
+        )
+
+        // 4. Save group message model and inform listeners about new message
+        messageService.save(groupMessageModel)
+        ListenerManager.messageListeners.handle { messageListener -> messageListener.onNew(groupMessageModel) }
+
+        // 5. Download thumbnail and content blob (if auto download enabled)
+        processMediaContent(fileData, groupMessageModel)
+    }
+
+    /**
+     *  @return A new instance of `AbstractMessageModel` with type [MessageType.FILE] containing
+     *  the `body` and `dataObject` from the passed file information.
+     *  The messages receiver information is set according to the [messageReceiver].
+     *  State will be [MessageState.SENT].
+     */
+    private fun createMessageModelFromFileMessage(
+        groupFileMessage: GroupFileMessage,
+        fileDataModel: FileDataModel,
+        fileData: FileData
+    ): GroupMessageModel {
+        val messageModel: GroupMessageModel = messageReceiver.createLocalModel(
+            /* type = */ MessageType.FILE,
+            /* messageContentsType = */ MimeUtil.getContentTypeFromFileData(fileDataModel),
+            /* postedAt = */ Date(message.createdAt)
+        )
+        initializeMessageModelsCommonFields(messageModel)
+        return messageModel.apply {
+            setFileDataModel(fileDataModel)
+            setMessageFlags(groupFileMessage.messageFlags)
+            setCorrelationId(fileData.correlationId)
+            setForwardSecurityMode(groupFileMessage.forwardSecurityMode)
+            state = MessageState.SENT
+        }
+    }
+
+    /**
+     *  **Synchronously**
+     *
+     *  Attempt to download the thumbnail and the actual media content. Even if
+     *  the thumbnail download failed, we try to download the actual blob contents.
+     *
+     *  Catches **all** exceptions.
+     */
+    private fun processMediaContent(fileData: FileData, groupMessageModel: GroupMessageModel) {
+        runCatching {
+            messageService.downloadThumbnailIfPresent(fileData, groupMessageModel)
+        }.onFailure { throwable ->
+            logger.error("Unable to download thumbnail blob", throwable)
+        }
+        if (messageService.shouldAutoDownload(groupMessageModel)) {
+            runCatching {
+                messageService.downloadMediaMessage(groupMessageModel, null)
+            }.onFailure { throwable ->
+                // a failed blob auto-download should not be considered a failure as the user can try again manually
+                logger.error("Unable to auto-download blob", throwable)
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupTextTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupTextTask.kt
new file mode 100644
index 00000000..d3dd2b70
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupTextTask.kt
@@ -0,0 +1,73 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import androidx.core.util.component1
+import androidx.core.util.component2
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.utils.QuoteUtil
+import ch.threema.domain.protocol.csp.messages.GroupTextMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+import ch.threema.storage.models.MessageState
+import ch.threema.storage.models.MessageType
+import ch.threema.storage.models.data.MessageContentsType
+import java.util.Date
+
+internal class ReflectedOutgoingGroupTextTask(
+    message: OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingGroupMessageTask(
+    message,
+    Common.CspE2eMessageType.GROUP_TEXT,
+    serviceManager
+) {
+    private val messageService by lazy { serviceManager.messageService }
+
+    private val groupTextMessage by lazy { GroupTextMessage.fromByteArray(message.body.toByteArray()) }
+
+    override val storeNonces: Boolean
+        get() = groupTextMessage.protectAgainstReplay()
+
+    override val shouldBumpLastUpdate: Boolean = true
+
+    override fun processOutgoingMessage() {
+        if (!message.conversation.hasGroup()) {
+            throw IllegalStateException("The message does not have a group identity set")
+        }
+
+        val messageModel = messageReceiver.createLocalModel(
+            MessageType.TEXT,
+            MessageContentsType.TEXT,
+            Date(message.createdAt)
+        )
+        initializeMessageModelsCommonFields(messageModel)
+
+        val (body, messageId) = QuoteUtil.getBodyAndQuotedMessageId(groupTextMessage.text)
+        messageModel.body = body
+        messageModel.quotedMessageId = messageId
+        messageModel.state = MessageState.SENT
+        messageService.save(messageModel)
+        ListenerManager.messageListeners.handle { it.onNew(messageModel) }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingMessageTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingMessageTask.kt
new file mode 100644
index 00000000..b3bd506d
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingMessageTask.kt
@@ -0,0 +1,159 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.messagereceiver.ContactMessageReceiver
+import ch.threema.app.messagereceiver.GroupMessageReceiver
+import ch.threema.app.messagereceiver.MessageReceiver
+import ch.threema.app.processors.reflectedoutgoingmessage.groupcall.ReflectedOutgoingGroupCallStartTask
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.toHexString
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.protobuf.Common.CspE2eMessageType
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+import ch.threema.storage.models.AbstractMessageModel
+import ch.threema.storage.models.MessageState
+import java.util.Date
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingMessageTask")
+
+interface ReflectedOutgoingMessageTask {
+    fun executeReflectedOutgoingMessageSteps()
+}
+
+internal sealed class ReflectedOutgoingBaseMessageTask<M : MessageReceiver<*>>(
+    protected val message: OutgoingMessage,
+    type: CspE2eMessageType,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingMessageTask {
+    protected abstract val shouldBumpLastUpdate: Boolean
+
+    protected abstract val messageReceiver: M
+
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+
+    protected abstract val storeNonces: Boolean
+
+    init {
+        if (message.type != type) {
+            throw IllegalArgumentException("Incompatible types: ${message.type} - $type")
+        }
+    }
+
+    override fun executeReflectedOutgoingMessageSteps() {
+        if (storeNonces) {
+            message.noncesList.forEach {
+                val nonce = Nonce(it.toByteArray())
+                if (nonceFactory.exists(NonceScope.CSP, nonce)) {
+                    logger.info("Skip adding preexisting CSP nonce {}", nonce.bytes.toHexString())
+                } else if (!nonceFactory.store(NonceScope.CSP, nonce)) {
+                    logger.warn("CSP nonce {} of outgoing message could not be stored", nonce.bytes.toHexString())
+                }
+            }
+        } else {
+            logger.debug("Do not store nonces for message of type {}", message.type)
+        }
+
+        processOutgoingMessage()
+
+        if (shouldBumpLastUpdate) {
+            messageReceiver.bumpLastUpdate()
+        }
+    }
+
+    protected abstract fun processOutgoingMessage()
+
+    protected fun initializeMessageModelsCommonFields(messageModel: AbstractMessageModel) {
+        messageModel.apiMessageId = MessageId(message.messageId).toString()
+        messageModel.isSaved = true
+        messageModel.isOutbox = true
+        messageModel.state = MessageState.SENDING
+        messageModel.createdAt = Date(message.createdAt)
+    }
+}
+
+internal abstract class ReflectedOutgoingContactMessageTask(
+    message: OutgoingMessage,
+    type: CspE2eMessageType,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingBaseMessageTask<ContactMessageReceiver>(message, type, serviceManager) {
+    protected val contactService by lazy { serviceManager.contactService }
+    protected val contactModelRepository by lazy { serviceManager.modelRepositories.contacts }
+
+    override val messageReceiver: ContactMessageReceiver by lazy {
+        val contact = contactService.getByIdentity(message.conversation.contact)
+            ?: throw IllegalStateException("The contact of a reflected outgoing message must be known")
+        contactService.createReceiver(contact)
+    }
+}
+
+internal abstract class ReflectedOutgoingGroupMessageTask(
+    message: OutgoingMessage,
+    type: CspE2eMessageType,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingBaseMessageTask<GroupMessageReceiver>(message, type, serviceManager) {
+    protected val groupService by lazy { serviceManager.groupService }
+
+    override val messageReceiver: GroupMessageReceiver by lazy {
+        val groupIdentity = message.conversation.group
+        val group = groupService.getByApiGroupIdAndCreator(
+            GroupId(groupIdentity.groupId),
+            groupIdentity.creatorIdentity
+        ) ?: throw IllegalStateException("The group of a reflected outgoing message must be known")
+        groupService.createReceiver(group)
+    }
+}
+
+fun OutgoingMessage.getReflectedOutgoingMessageTask(
+    serviceManager: ServiceManager,
+): ReflectedOutgoingMessageTask = when (type) {
+    CspE2eMessageType.TEXT -> ReflectedOutgoingTextTask(this, serviceManager)
+    CspE2eMessageType.GROUP_TEXT -> ReflectedOutgoingGroupTextTask(this, serviceManager)
+    CspE2eMessageType.DELIVERY_RECEIPT -> ReflectedOutgoingDeliveryReceiptTask(this, serviceManager)
+    CspE2eMessageType.GROUP_DELIVERY_RECEIPT -> ReflectedOutgoingGroupDeliveryReceiptTask(this, serviceManager)
+    CspE2eMessageType.FILE -> ReflectedOutgoingFileTask(this, serviceManager)
+    CspE2eMessageType.GROUP_FILE -> ReflectedOutgoingGroupFileTask(this, serviceManager)
+    CspE2eMessageType.POLL_SETUP -> throw IllegalStateException("Message type POLL_SETUP for reflected outgoing messages is not implemented yet") // TODO(ANDR-3465)
+    CspE2eMessageType.POLL_VOTE -> throw IllegalStateException("Message type POLL_VOTE for reflected outgoing messages is not implemented yet") // TODO(ANDR-3465)
+    CspE2eMessageType.GROUP_POLL_SETUP -> throw IllegalStateException("Message type GROUP_POLL_SETUP for reflected outgoing messages is not implemented yet") // TODO(ANDR-3465)
+    CspE2eMessageType.GROUP_POLL_VOTE -> throw IllegalStateException("Message type GROUP_POLL_VOTE for reflected outgoing messages is not implemented yet") // TODO(ANDR-3465)
+    CspE2eMessageType.GROUP_CALL_START -> ReflectedOutgoingGroupCallStartTask(this, serviceManager)
+    CspE2eMessageType.CALL_OFFER,
+    CspE2eMessageType.CALL_RINGING,
+    CspE2eMessageType.CALL_ANSWER,
+    CspE2eMessageType.CALL_HANGUP -> ReflectedOutgoingPlaceholderTask(
+        message = this,
+        serviceManager = serviceManager,
+        logMessage = "Reflected message of type ${type.name} was received as outgoing"
+    )
+
+    CspE2eMessageType.CALL_ICE_CANDIDATE -> throw IllegalStateException("Reflected message of type ${type.name} should never be received as outgoing")
+    CspE2eMessageType.CONTACT_REQUEST_PROFILE_PICTURE -> ReflectedOutgoingContactRequestProfilePictureTask(this, serviceManager)
+    CspE2eMessageType.CONTACT_SET_PROFILE_PICTURE -> ReflectedOutgoingContactSetProfilePictureTask(this, serviceManager)
+    CspE2eMessageType.CONTACT_DELETE_PROFILE_PICTURE -> ReflectedOutgoingDeleteProfilePictureTask(this, serviceManager)
+
+    else -> throw IllegalStateException("Unknown message type $type")
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingPlaceholderTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingPlaceholderTask.kt
new file mode 100644
index 00000000..ff19b496
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingPlaceholderTask.kt
@@ -0,0 +1,43 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.protobuf.d2d.MdD2D
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectedOutgoingPlaceholderTask")
+
+internal class ReflectedOutgoingPlaceholderTask(
+    message: MdD2D.OutgoingMessage,
+    serviceManager: ServiceManager,
+    private val logMessage: String? = null
+) : ReflectedOutgoingContactMessageTask(message, message.type, serviceManager) {
+
+    override val storeNonces: Boolean = false
+
+    override val shouldBumpLastUpdate: Boolean = false
+
+    override fun processOutgoingMessage() {
+        logMessage?.let(logger::warn)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingTextTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingTextTask.kt
new file mode 100644
index 00000000..5188e74f
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingTextTask.kt
@@ -0,0 +1,65 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage
+
+import androidx.core.util.component1
+import androidx.core.util.component2
+import ch.threema.app.managers.ListenerManager
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.utils.QuoteUtil
+import ch.threema.domain.protocol.csp.messages.TextMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D.OutgoingMessage
+import ch.threema.storage.models.MessageModel
+import ch.threema.storage.models.MessageState
+import ch.threema.storage.models.MessageType
+import ch.threema.storage.models.data.MessageContentsType
+import java.util.Date
+
+internal class ReflectedOutgoingTextTask(
+    message: OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingContactMessageTask(message, Common.CspE2eMessageType.TEXT, serviceManager) {
+    private val messageService by lazy { serviceManager.messageService }
+
+    private val textMessage: TextMessage by lazy { TextMessage.fromByteArray(message.body.toByteArray()) }
+
+    override val storeNonces: Boolean
+        get() = textMessage.protectAgainstReplay()
+
+    override val shouldBumpLastUpdate: Boolean = true
+
+    override fun processOutgoingMessage() {
+        val messageModel: MessageModel = messageReceiver.createLocalModel(
+            MessageType.TEXT,
+            MessageContentsType.TEXT,
+            Date(message.createdAt)
+        )
+        initializeMessageModelsCommonFields(messageModel)
+        val (body, messageId) = QuoteUtil.getBodyAndQuotedMessageId(textMessage.text)
+        messageModel.body = body
+        messageModel.quotedMessageId = messageId
+        messageModel.state = MessageState.SENT
+        messageService.save(messageModel)
+        ListenerManager.messageListeners.handle { it.onNew(messageModel) }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/groupcall/ReflectedOutgoingGroupCallStartTask.kt b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/groupcall/ReflectedOutgoingGroupCallStartTask.kt
new file mode 100644
index 00000000..52d27c04
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/groupcall/ReflectedOutgoingGroupCallStartTask.kt
@@ -0,0 +1,51 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.processors.reflectedoutgoingmessage.groupcall
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.processors.reflectedoutgoingmessage.ReflectedOutgoingGroupMessageTask
+import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartMessage
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.MdD2D
+
+internal class ReflectedOutgoingGroupCallStartTask(
+    message: MdD2D.OutgoingMessage,
+    serviceManager: ServiceManager,
+) : ReflectedOutgoingGroupMessageTask(message, Common.CspE2eMessageType.GROUP_CALL_START, serviceManager) {
+
+    private val groupCallManager = serviceManager.groupCallManager
+
+    private val identityStore = serviceManager.identityStore
+
+    private val groupCallStartMessage = GroupCallStartMessage.fromReflected(
+        message = message,
+        ownIdentity = identityStore.identity
+    )
+
+    override val storeNonces: Boolean = groupCallStartMessage.protectAgainstReplay()
+
+    override val shouldBumpLastUpdate: Boolean = groupCallStartMessage.bumpLastUpdate()
+
+    override fun processOutgoingMessage() {
+        groupCallManager.handleControlMessage(groupCallStartMessage)
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingDeliveryReceiptTask.kt
deleted file mode 100644
index 7a79a0b4..00000000
--- a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingDeliveryReceiptTask.kt
+++ /dev/null
@@ -1,63 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.statusupdates
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.MessageState
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingDeliveryReceiptTask")
-
-class IncomingDeliveryReceiptTask(
-    private val message: DeliveryReceiptMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val messageService = serviceManager.messageService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val state: MessageState = when (message.receiptType) {
-            ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED -> MessageState.DELIVERED
-            ProtocolDefines.DELIVERYRECEIPT_MSGREAD -> MessageState.READ
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERACK -> MessageState.USERACK
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERDEC -> MessageState.USERDEC
-            else -> {
-                logger.warn("Message {} error: unknown delivery receipt type", message.messageId)
-                return ReceiveStepsResult.DISCARD
-            }
-        }
-        for (msgId in message.receiptMessageIds) {
-            logger.info(
-                "Message {}: delivery receipt for {} (state = {})",
-                message.messageId,
-                msgId,
-                state
-            )
-            this.messageService.updateMessageState(msgId, state, message)
-        }
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingGroupDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingGroupDeliveryReceiptTask.kt
deleted file mode 100644
index 190f280c..00000000
--- a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingGroupDeliveryReceiptTask.kt
+++ /dev/null
@@ -1,70 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.statusupdates
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.MessageState
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupDeliveryReceiptTask")
-
-class IncomingGroupDeliveryReceiptTask(
-    private val message: GroupDeliveryReceiptMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val messageService = serviceManager.messageService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val state: MessageState = when (message.receiptType) {
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERACK -> MessageState.USERACK
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERDEC -> MessageState.USERDEC
-            else -> {
-                logger.warn(
-                    "Message {} error: unknown or unsupported delivery receipt type",
-                    message.messageId
-                )
-                return ReceiveStepsResult.DISCARD
-            }
-        }
-        if (runCommonGroupReceiveSteps(message, handle, serviceManager) == null) {
-            // If the common group receive steps did not succeed, ignore this delivery receipt
-            return ReceiveStepsResult.DISCARD
-        }
-        for (messageId in message.receiptMessageIds) {
-            logger.info(
-                "Message {}: group delivery receipt for {} (state = {})",
-                messageId.messageId,
-                messageId,
-                state
-            )
-            messageService.updateGroupMessageState(messageId, state, message)
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt b/app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt
index d8115d76..54008091 100644
--- a/app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt
+++ b/app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt
@@ -21,14 +21,13 @@
 
 package ch.threema.app.protocol
 
-import android.content.Context
 import androidx.annotation.WorkerThread
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.tasks.FSRefreshStepsTask
 import ch.threema.app.tasks.OutgoingContactRequestProfilePictureTask
 import ch.threema.app.workers.ContactUpdateWorker
 import ch.threema.base.utils.LoggingUtil
-import ch.threema.storage.models.ContactModel
+import ch.threema.domain.models.IdentityState
 
 private val logger = LoggingUtil.getThreemaLogger("ApplicationSetupSteps")
 
@@ -36,14 +35,14 @@ private val logger = LoggingUtil.getThreemaLogger("ApplicationSetupSteps")
  * Run the _Application Setup Steps_ as defined in the protocol.
  */
 @WorkerThread
-fun runApplicationSetupSteps(serviceManager: ServiceManager, context: Context): Boolean {
+fun runApplicationSetupSteps(serviceManager: ServiceManager): Boolean {
     logger.info("Running application setup steps")
 
     val groupService = serviceManager.groupService
 
     // Send the feature mask to the server and update the contacts. It is important that the feature
     // masks of the contacts are updated to check whether the contacts support FS or not.
-    if (!ContactUpdateWorker.sendFeatureMaskAndUpdateContacts(serviceManager, context)) {
+    if (!ContactUpdateWorker.sendFeatureMaskAndUpdateContacts(serviceManager)) {
         logger.warn("Aborting application setup steps as identity state update did not work")
         return false
     }
@@ -65,7 +64,7 @@ fun runApplicationSetupSteps(serviceManager: ServiceManager, context: Context):
     // Determine the solicited contacts defined by group contacts and conversation contacts and
     // remove invalid contacts
     val solicitedContacts = (groupContacts + contactsWithConversation)
-        .filter { it.state != ContactModel.State.INVALID }
+        .filter { it.state != IdentityState.INVALID }
         .filter { it.identity != myIdentity }
         .toSet()
 
diff --git a/app/src/main/java/ch/threema/app/protocol/IdentityBlockedSteps.kt b/app/src/main/java/ch/threema/app/protocol/IdentityBlockedSteps.kt
new file mode 100644
index 00000000..6767bb5a
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/protocol/IdentityBlockedSteps.kt
@@ -0,0 +1,93 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.protocol
+
+import ch.threema.app.services.GroupService
+import ch.threema.app.services.IdListService
+import ch.threema.app.services.PreferenceService
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.stores.ContactStore
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+
+/**
+ * The block state of an identity.
+ */
+enum class BlockState(private val isBlocked: Boolean) {
+    /**
+     * The state of an identity that has been explicitly blocked by the user.
+     */
+    EXPLICITLY_BLOCKED(true),
+
+    /**
+     * The state of an identity that is unknown.
+     *
+     * An identity is considered unknown if it is not stored locally or it has
+     * [AcquaintanceLevel.GROUP] and all common groups are marked as left.
+     *
+     * Note that this state is only used when unknown contacts are blocked.
+     */
+    IMPLICITLY_BLOCKED(true),
+
+    /**
+     * The identity is not blocked.
+     */
+    NOT_BLOCKED(false);
+
+    /**
+     * Returns true if it is either [EXPLICITLY_BLOCKED] or [IMPLICITLY_BLOCKED].
+     */
+    fun isBlocked(): Boolean = isBlocked
+}
+
+fun runIdentityBlockedSteps(
+    identity: String,
+    contactModelRepository: ContactModelRepository,
+    contactStore: ContactStore,
+    groupService: GroupService,
+    blockedContactsService: IdListService,
+    preferenceService: PreferenceService,
+): BlockState {
+    if (contactStore.isSpecialContact(identity)) {
+        return BlockState.NOT_BLOCKED
+    }
+
+    if (blockedContactsService.has(identity)) {
+        return BlockState.EXPLICITLY_BLOCKED
+    }
+
+    if (!preferenceService.isBlockUnknown) {
+        return BlockState.NOT_BLOCKED
+    }
+
+    val contactModel = contactModelRepository.getByIdentity(identity)
+        ?: return BlockState.IMPLICITLY_BLOCKED
+
+    if (contactModel.data.value?.acquaintanceLevel == AcquaintanceLevel.DIRECT) {
+        return BlockState.NOT_BLOCKED
+    }
+
+    if (groupService.getGroupsByIdentity(identity).any { groupService.isGroupMember(it) }) {
+        return BlockState.NOT_BLOCKED
+    }
+
+    return BlockState.IMPLICITLY_BLOCKED
+}
diff --git a/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java b/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java
index ea22bc7b..572cf55b 100644
--- a/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java
+++ b/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java
@@ -25,6 +25,7 @@ import android.content.BroadcastReceiver;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.services.ContactService;
@@ -34,7 +35,10 @@ import ch.threema.app.services.LifetimeService;
 import ch.threema.app.services.MessageService;
 import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 
 public abstract class ActionBroadcastReceiver extends BroadcastReceiver {
 	protected static final String TAG = "ActionBroadcastReceiver";
@@ -48,6 +52,11 @@ public abstract class ActionBroadcastReceiver extends BroadcastReceiver {
 	protected ContactService contactService;
 	protected DistributionListService distributionListService;
 	protected GroupService groupService;
+	protected ContactModelRepository contactModelRepository;
+	protected APIConnector apiConnector;
+
+	@NonNull
+	protected BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
 
 	public ActionBroadcastReceiver() {
 		this.instantiate();
@@ -81,6 +90,8 @@ public abstract class ActionBroadcastReceiver extends BroadcastReceiver {
 				this.contactService = serviceManager.getContactService();
 				this.distributionListService = serviceManager.getDistributionListService();
 				this.groupService = serviceManager.getGroupService();
+				this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+				this.apiConnector = serviceManager.getAPIConnector();
 			} catch (Exception e) {
 				logger.error("Exception", e);
 			}
diff --git a/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java b/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java
index 599345a8..08edf45e 100644
--- a/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java
+++ b/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java
@@ -24,14 +24,19 @@ package ch.threema.app.receivers;
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.Intent;
-import android.os.AsyncTask;
 import android.widget.Toast;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import androidx.core.app.NotificationManagerCompat;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.Failed;
+import ch.threema.app.asynctasks.PolicyViolation;
 import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.notifications.BackgroundErrorNotification;
 import ch.threema.base.utils.LoggingUtil;
@@ -58,40 +63,65 @@ public class SendTextToContactBroadcastReceiver extends ActionBroadcastReceiver
 
 			final PendingResult pendingResult = goAsync();
 
-			new AsyncTask<Void, Void, Boolean>() {
+			String identity = intent.getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
+			if (identity == null) {
+				logger.error("Identity is null");
+				return;
+			}
+
+			AddOrUpdateContactBackgroundTask<Boolean> sendMessageTask = new AddOrUpdateContactBackgroundTask<>(
+				identity,
+				ContactModel.AcquaintanceLevel.DIRECT,
+				contactService.getMe().getIdentity(),
+				apiConnector,
+				contactModelRepository,
+				AddContactRestrictionPolicy.CHECK,
+				context,
+				null
+			) {
 				@Override
-				protected Boolean doInBackground(Void... params) {
-					try {
-						// we need to make sure there's a connection during delivery
-						lifetimeService.acquireConnection(TAG);
+				public void onBefore() {
+					// We need to make sure there's a connection during delivery
+					lifetimeService.acquireConnection(TAG);
+				}
 
-						String identity = intent.getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
-						if (identity != null) {
-							final ContactModel contactModel = contactService.getOrCreateByIdentity(identity, true);
-							MessageReceiver messageReceiver = contactService.createReceiver(contactModel);
-							if (messageReceiver != null) {
-								messageService.sendText(text, messageReceiver);
-								messageService.markConversationAsRead(messageReceiver, notificationService);
-								logger.debug("Message sent to: " + messageReceiver.getShortName());
-								return true;
-							}
+				@Override
+				@NonNull
+				public Boolean onContactAdded(@NonNull ContactResult result) {
+					if (result instanceof Failed) {
+						logger.error("Could not add contact: {}", ((Failed) result).getMessage());
+						return false;
+					} else if (result instanceof PolicyViolation) {
+						logger.error("Could not add contact because of a policy violation");
+						return false;
+					}
+
+					try {
+						final ContactModel contactModel = contactService.getByIdentity(identity);
+						if (contactModel == null) {
+							return false;
 						}
+						MessageReceiver<?> messageReceiver = contactService.createReceiver(contactModel);
+						messageService.sendText(text, messageReceiver);
+						messageService.markConversationAsRead(messageReceiver, notificationService);
+						logger.debug("Message sent to: " + messageReceiver.getShortName());
+						return true;
 					} catch (Exception e) {
 						logger.error("Exception", e);
+						return false;
 					} finally {
 						lifetimeService.releaseConnectionLinger(TAG, WEARABLE_CONNECTION_LINGER);
 					}
-					return false;
 				}
 
 				@Override
-				protected void onPostExecute(Boolean success) {
-					if (success != null) {
-						Toast.makeText(context, success ? R.string.message_sent : R.string.verify_failed, Toast.LENGTH_LONG).show();
-					}
+				public void onFinished(@NonNull Boolean success) {
+					Toast.makeText(context, success ? R.string.message_sent : R.string.verify_failed, Toast.LENGTH_LONG).show();
 					pendingResult.finish();
 				}
-			}.execute();
+			};
+
+			backgroundExecutor.execute(sendMessageTask);
 		}
 	}
 }
diff --git a/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java b/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java
index d1b99981..363e90de 100644
--- a/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java
+++ b/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java
@@ -29,18 +29,21 @@ import android.database.Cursor;
 import android.provider.ContactsContract;
 import android.text.format.DateUtils;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.RequiresPermission;
 
 import com.google.common.collect.ListMultimap;
 
 import org.slf4j.Logger;
 
+import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import ch.threema.app.asynctasks.AddContactBackgroundTask;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeviceService;
 import ch.threema.app.services.IdListService;
@@ -54,10 +57,18 @@ import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.models.ContactModelData;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.models.ContactSyncState;
+import ch.threema.domain.models.IdentityState;
+import ch.threema.domain.models.IdentityType;
+import ch.threema.domain.models.ReadReceiptPolicy;
+import ch.threema.domain.models.TypingIndicatorPolicy;
 import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.stores.IdentityStoreInterface;
-import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
 
 public class SynchronizeContactsRoutine implements Runnable {
@@ -67,6 +78,7 @@ public class SynchronizeContactsRoutine implements Runnable {
 	private final Context context;
 	private final APIConnector apiConnector;
 	private final ContactService contactService;
+	private final ContactModelRepository contactModelRepository;
 	private final LocaleService localeService;
 	private final ContentResolver contentResolver;
 	private final IdListService excludedSyncList;
@@ -97,23 +109,23 @@ public class SynchronizeContactsRoutine implements Runnable {
 		void started(boolean fullSync);
 	}
 
-    public SynchronizeContactsRoutine(
-        Context context,
-        APIConnector apiConnector,
-        ContactService contactService,
-        UserService userService,
-        LocaleService localeService,
-        ContentResolver contentResolver,
-        IdListService excludedSyncList,
-        DeviceService deviceService,
-        PreferenceService preferenceService,
-        IdentityStoreInterface identityStore,
-        IdListService blockedContactsService
-    ) {
+	public SynchronizeContactsRoutine(Context context,
+	                                  APIConnector apiConnector,
+	                                  ContactService contactService,
+									  @NonNull ContactModelRepository contactModelRepository,
+	                                  UserService userService,
+	                                  LocaleService localeService,
+	                                  ContentResolver contentResolver,
+	                                  IdListService excludedSyncList,
+	                                  DeviceService deviceService,
+	                                  PreferenceService preferenceService,
+	                                  IdentityStoreInterface identityStore,
+	                                  IdListService blockedContactsService) {
 		this.context = context;
 		this.apiConnector = apiConnector;
 		this.userService = userService;
 		this.contactService = contactService;
+		this.contactModelRepository = contactModelRepository;
 		this.localeService = localeService;
 		this.contentResolver = contentResolver;
 		this.excludedSyncList = excludedSyncList;
@@ -241,7 +253,7 @@ public class SynchronizeContactsRoutine implements Runnable {
 					continue;
 				}
 
-				if(!this.processingIdentities.isEmpty() && !this.processingIdentities.contains(id.getKey())) {
+				if (!this.processingIdentities.isEmpty() && !this.processingIdentities.contains(id.getKey())) {
 					continue;
 				}
 
@@ -265,19 +277,57 @@ public class SynchronizeContactsRoutine implements Runnable {
 				}
 
 				//try to get the contact
-				ContactModel contact = this.contactService.getByIdentity(id.getKey());
+				ContactModel contact = contactModelRepository.getByIdentity(
+					id.getKey()
+				);
+				ContactModelData data = contact != null ? contact.getData().getValue() : null;
 				//contact does not exist, create a new one
-				if (contact == null) {
-					contact = new ContactModel(id.getKey(), id.getValue().publicKey);
-					contact.verificationLevel = VerificationLevel.SERVER_VERIFIED;
-					contact.setDateCreated(new Date());
+				if (contact == null || data == null) {
+					APIConnector.MatchIdentityResult result = id.getValue();
+					ContactModelData contactModelData = ContactModelData.javaCreate(
+						id.getKey(),
+						result.publicKey,
+						new Date(),
+						"",
+						"",
+						null,
+						ContactModelData.getIdColorIndexInt(id.getKey()),
+						VerificationLevel.SERVER_VERIFIED,
+						WorkVerificationLevel.NONE,
+						IdentityType.NORMAL,   // TODO(ANDR-3044): Fetch identity type
+						AcquaintanceLevel.DIRECT,
+						IdentityState.ACTIVE,  // TODO(ANDR-3044): Fetch identity state
+						BigInteger.valueOf(0), // TODO(ANDR-3044): Fetch feature mask
+						ContactSyncState.IMPORTED,
+						ReadReceiptPolicy.DEFAULT,
+						TypingIndicatorPolicy.DEFAULT,
+						null,
+						null,
+						false,
+						null,
+                        null,
+                        null
+					);
+					contact = new AddContactBackgroundTask(contactModelData, contactModelRepository)
+						.runSynchronously();
+
+					if (contact == null) {
+						logger.error("Could not create contact with identity {}", id.getKey());
+						continue;
+					}
+
+					data = contact.getData().getValue();
+					if (data == null) {
+						logger.error("Contact data is null");
+						continue;
+					}
+
 					insertedContacts.add(contact);
 
 					isNewContact = true;
 					logger.info("Inserting new Threema contact {}", id.getKey());
 				}
-
-				contact.setAndroidContactLookupKey(lookupKey + "/" + contactId); // It can optionally also have a "/" and last known contact ID appended after that. This "complete" format is an important optimization and is highly recommended.
+				contact.setAndroidLookupKey(lookupKey + "/" + contactId);
 
 				try {
 					boolean createNewRawContact;
@@ -285,9 +335,9 @@ public class SynchronizeContactsRoutine implements Runnable {
 					AndroidContactUtil.getInstance().updateNameByAndroidContact(contact); // throws an exception if no name can be determined
 					AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contact);
 
-					contact.setAcquaintanceLevel(AcquaintanceLevel.DIRECT);
-					if (contact.verificationLevel == VerificationLevel.UNVERIFIED) {
-						contact.verificationLevel = VerificationLevel.SERVER_VERIFIED;
+					contact.setAcquaintanceLevelFromLocal(AcquaintanceLevel.DIRECT);
+					if (data.verificationLevel == VerificationLevel.UNVERIFIED) {
+						contact.setVerificationLevelFromLocal(VerificationLevel.SERVER_VERIFIED);
 					}
 
 					List<AndroidContactUtil.RawContactInfo> rawContactInfos = existingRawContacts.get(contact.getIdentity());
@@ -313,7 +363,7 @@ public class SynchronizeContactsRoutine implements Runnable {
 					}
 
 					if (createNewRawContact) {
-						boolean supportsVoiceCalls = ContactUtil.canReceiveVoipMessages(contact, this.blockedContactsService)
+						boolean supportsVoiceCalls = ContactUtil.canReceiveVoipMessages(contact.getIdentity(), this.blockedContactsService)
 							&& ConfigUtils.isCallsEnabled();
 
 						// create a raw contact for our stuff and aggregate it
@@ -322,19 +372,14 @@ public class SynchronizeContactsRoutine implements Runnable {
 							matchKeyEmail != null ?
 								matchKeyEmail.rawContactId :
 								matchKeyPhone.rawContactId,
-							contact,
+							contact.getIdentity(),
 							supportsVoiceCalls);
 					}
-
-					this.contactService.save(contact);
 				} catch (ThreemaException e) {
 					if (isNewContact) {
 						// probably not a valid contact
 						insertedContacts.remove(contact);
 						logger.info("Ignore Threema contact {} due to missing name", id.getKey());
-					} else {
-						// save the contact only if it was updated
-						this.contactService.save(contact);
 					}
 					logger.error("Contact lookup Exception", e);
 				}
@@ -361,14 +406,12 @@ public class SynchronizeContactsRoutine implements Runnable {
 				if (!preSynchronizedIdentities.isEmpty()) {
 					logger.info("Found {} synchronized contacts that are no longer synchronized", preSynchronizedIdentities.size());
 
-					List<ContactModel> contactModels = this.contactService.getByIdentities(preSynchronizedIdentities);
-					this.contactService.save(
-						contactModels,
-						contactModel -> {
-							contactModel.setAndroidContactLookupKey(null);
-							return true;
+					for (String identity : preSynchronizedIdentities) {
+						ContactModel contactModel = contactModelRepository.getByIdentity(identity);
+						if (contactModel != null) {
+							contactModel.removeAndroidContactLink();
 						}
-					);
+					}
 				}
 			}
 			success = true;
diff --git a/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java b/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java
index 1521b289..74d58564 100644
--- a/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java
+++ b/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java
@@ -45,6 +45,7 @@ import ch.threema.app.utils.FileUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModel;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.domain.taskmanager.TriggerSource;
 
 import static android.provider.MediaStore.MEDIA_IGNORE_FILENAME;
 
@@ -120,14 +121,16 @@ public class UpdateBusinessAvatarRoutine implements Runnable {
 				if (responseCode != HttpsURLConnection.HTTP_OK) {
 					if (responseCode == HttpsURLConnection.HTTP_NOT_FOUND) {
 						logger.debug("Avatar not found");
-						//remove existing avatar
-						this.fileService.removeContactAvatar(contactModel.getIdentity());
+						// Remove existing avatar
+                        // Note that the profile picture of a gateway id is stored as user defined
+                        // profile picture on purpose. This prevents that it is overwritten if the
+                        // gateway would suddenly start distributing its own profile picture via csp
+                        // messages.
+						this.fileService.removeUserDefinedProfilePicture(contactModel.getIdentity());
 
 						//ok, no avatar set
 						//add expires date = now + 1day
 						this.contactModel.setLocalAvatarExpires(tomorrow);
-
-						this.contactService.clearAvatarCache(contactModel.getIdentity());
 					} else if (responseCode == HttpsURLConnection.HTTP_UNAUTHORIZED) {
 						 logger.warn("Unauthorized access to avatar server");
 						 if (ConfigUtils.isOnPremBuild()) {
@@ -163,12 +166,15 @@ public class UpdateBusinessAvatarRoutine implements Runnable {
 
 						logger.debug("Avatar downloaded");
 
-						//define avatar
-						this.contactService.setAvatar(contactModel.getIdentity(), temporaryFile);
+						// Store profile picture
+                        // Note that the profile picture of a gateway id is stored as user defined
+                        // profile picture on purpose. This prevents that it is overwritten if the
+                        // gateway would suddenly start distributing its own profile picture via csp
+                        // messages.
+						this.contactService.setUserDefinedProfilePicture(contactModel.getIdentity(), temporaryFile, TriggerSource.LOCAL);
 
 						//set expires header
 						this.contactModel.setLocalAvatarExpires(expires);
-						this.contactService.clearAvatarCache(contactModel.getIdentity());
 
 						//remove temporary file
 						FileUtil.deleteFileOrWarn(temporaryFile, "temporaryFile", logger);
diff --git a/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java b/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java
index cf63500d..20338175 100644
--- a/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java
+++ b/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java
@@ -23,85 +23,60 @@ package ch.threema.app.routines;
 
 import org.slf4j.Logger;
 
-import java.util.ArrayList;
 import java.util.Calendar;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Collectors;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
-import ch.threema.app.collections.Functional;
-import ch.threema.app.collections.IPredicateNonNull;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.utils.TestUtil;
+import ch.threema.app.services.UserService;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ModelDeletedException;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.api.APIConnector;
-import ch.threema.storage.models.ContactModel;
+import ch.threema.data.models.ContactModel;
 
 public class UpdateFeatureLevelRoutine implements Runnable {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("UpdateFeatureLevelRoutine");
 
 	private static final Map<String, Long> checkedIdentities = new HashMap<>();
 
-	public static void removeTimeCache(String identity) {
+	public static void removeTimeCache(@Nullable String identity) {
 		synchronized (checkedIdentities) {
 			checkedIdentities.remove(identity);
 		}
 	}
 
-	public static void removeTimeCache(ContactModel contactModel) {
-		if (contactModel != null) {
-			removeTimeCache(contactModel.getIdentity());
-		}
-	}
-	public interface StatusResult {
-		void onFinished(List<ContactModel> handledContacts);
-		void onAbort();
-		void onError(Exception x);
-	}
-
-	public interface Request {
-		boolean requestToServer(long featureLevel);
-	}
-
-	private final ContactService contactService;
+	@NonNull
+	private final UserService userService;
+	@NonNull
 	private final APIConnector apiConnector;
-	private String[] identities = null;
-	private List<ContactModel> contactModels = null;
-	private Request request = null;
-	private final List<StatusResult> statusResults = new ArrayList<StatusResult>();
-	private boolean abortOnCheckIdentitiesFailed = true;
-
-	public UpdateFeatureLevelRoutine(@NonNull ContactService contactService,
-									 @NonNull APIConnector apiConnector,
-									 String[] identities,
-									 Request request) {
-		this.contactService = contactService;
+	@NonNull
+	private List<ContactModel> contactModels;
+
+	public UpdateFeatureLevelRoutine(
+		@NonNull ContactModelRepository contactModelRepository,
+		@NonNull UserService userService,
+		@NonNull APIConnector apiConnector,
+		@Nullable List<String> identities
+	) {
+		this.userService = userService;
 		this.apiConnector = apiConnector;
-		this.identities = identities;
-		this.request = request;
-	}
-
-
-	public UpdateFeatureLevelRoutine(@NonNull ContactService contactService,
-									 @NonNull APIConnector apiConnector,
-									 @Nullable List<ContactModel> contactModels) {
-		this.contactService = contactService;
-		this.apiConnector = apiConnector;
-		this.contactModels = contactModels;
-	}
-
-	public UpdateFeatureLevelRoutine abortOnCheckIdentitiesFailed(boolean abort) {
-		this.abortOnCheckIdentitiesFailed = abort;
-		return this;
-	}
-
-	public UpdateFeatureLevelRoutine addStatusResult(StatusResult result) {
-		this.statusResults.add(result);
-		return this;
+		if (identities != null) {
+			this.contactModels = identities
+				.stream()
+				.map(contactModelRepository::getByIdentity)
+				.filter(Objects::nonNull)
+				.collect(Collectors.toList());
+		} else {
+			contactModels = Collections.emptyList();
+		}
 	}
 
 	@Override
@@ -110,28 +85,10 @@ public class UpdateFeatureLevelRoutine implements Runnable {
 		logger.info("Running...");
 
 		try {
-			//get all identities
-			if(this.contactModels == null) {
-				if(this.request != null ) {
-					this.contactModels = Functional.filter(this.contactService.getByIdentities(this.identities), new IPredicateNonNull<ContactModel>() {
-						@Override
-						public boolean apply(@NonNull ContactModel type) {
-							return request.requestToServer(type.getFeatureMask());
-						}
-					});
-				}
-				else {
-					this.contactModels = this.contactService.getByIdentities(identities);
-				}
-			}
-
 			//remove "me" from list
-			this.contactModels = Functional.filter(this.contactModels, new IPredicateNonNull<ContactModel>() {
-				@Override
-				public boolean apply(@NonNull ContactModel c) {
-					return !TestUtil.compare(c, contactService.getMe());
-				}
-			});
+			this.contactModels = this.contactModels.stream()
+				.filter(c -> !userService.getIdentity().equals(c.getIdentity()))
+				.collect(Collectors.toList());
 
 			//remove already checked identities
 			final Calendar calendar = Calendar.getInstance();
@@ -142,22 +99,17 @@ public class UpdateFeatureLevelRoutine implements Runnable {
 			final long validTimestamp = calendar.getTimeInMillis();
 
 			synchronized (checkedIdentities) {
-				//leave only identities that have not been checked in the last hour
-
-				List<ContactModel> filteredList = Functional.filter(this.contactModels, new IPredicateNonNull<ContactModel>() {
-					@Override
-					public boolean apply(@NonNull ContactModel contactModel) {
-						if(checkedIdentities.containsKey(contactModel.getIdentity())
-								&& checkedIdentities.get(contactModel.getIdentity()) >= validTimestamp) {
-							return false;
+				// Leave only identities that have not been checked in the last hour
+				List<ContactModel> filteredList = this.contactModels.stream()
+					.filter(contactModel -> {
+							Long checkedAt = checkedIdentities.get(contactModel.getIdentity());
+							return checkedAt == null || checkedAt < validTimestamp;
 						}
-						return true;
-					}
-				});
+					).collect(Collectors.toList());
 
 				logger.info("Running for {} entries", filteredList.size());
 
-				if(filteredList.size() > 0) {
+				if (!filteredList.isEmpty()) {
 					String[] identities = new String[filteredList.size()];
 
 					for (int n = 0; n < filteredList.size(); n++) {
@@ -175,43 +127,21 @@ public class UpdateFeatureLevelRoutine implements Runnable {
 							}
 
 							ContactModel model = filteredList.get(n);
-							if (model != null && model.getFeatureMask() != featureMask) {
-								final String identity = model.getIdentity();
-
-								model.setFeatureMask(featureMask);
-								this.contactService.save(model);
-
-								//update checked identities cache
-								checkedIdentities.put(identity, nowTimestamp);
-							}
+							model.setFeatureMaskFromLocal(featureMask);
+							// Update checked identities cache
+							checkedIdentities.put(model.getIdentity(), nowTimestamp);
 						}
+					} catch (ModelDeletedException e) {
+						logger.warn("Model has been deleted", e);
 					} catch (Exception x) {
-						//connection error
-						if(this.abortOnCheckIdentitiesFailed) {
-							for (StatusResult result : statusResults) {
-								result.onAbort();
-							}
-						}
+						// Connection error
 						logger.error("Error while setting feature mask", x);
 					}
-
-					for (StatusResult result : statusResults) {
-						result.onFinished(this.contactModels);
-					}
-				}
-				else {
-					for (StatusResult result : statusResults) {
-						result.onFinished(this.contactModels);
-					}
 				}
 			}
 
 		} catch (Exception e) {
 			logger.error("Error in run()", e);
-
-			for(StatusResult result: statusResults) {
-				result.onError(e);
-			}
 		}
 
 		logger.info("Done");
diff --git a/app/src/main/java/ch/threema/app/services/ApiService.java b/app/src/main/java/ch/threema/app/services/ApiService.java
deleted file mode 100644
index 1f8f3533..00000000
--- a/app/src/main/java/ch/threema/app/services/ApiService.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services;
-
-import java.io.IOException;
-
-import javax.net.ssl.HttpsURLConnection;
-
-import ch.threema.base.ThreemaException;
-import ch.threema.domain.protocol.blob.BlobLoader;
-import ch.threema.domain.protocol.blob.BlobUploader;
-
-public interface ApiService {
-	BlobUploader createUploader(byte[] data) throws ThreemaException;
-	BlobLoader createLoader(byte[] blobId);
-	String getAuthToken() throws ThreemaException;
-
-	/**
-	 * Invalidate the auth token (only used for onprem). This forces a new fetch of the auth token
-	 * the next time the token is obtained with {@link #getAuthToken()}.
-	 */
-	void invalidateAuthToken();
-	HttpsURLConnection createAvatarURLConnection(String identity) throws ThreemaException, IOException;
-}
diff --git a/app/src/main/java/ch/threema/app/services/ApiService.kt b/app/src/main/java/ch/threema/app/services/ApiService.kt
new file mode 100644
index 00000000..128df6e1
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/services/ApiService.kt
@@ -0,0 +1,53 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2014-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.services
+
+import ch.threema.base.ThreemaException
+import ch.threema.domain.protocol.blob.BlobLoader
+import ch.threema.domain.protocol.blob.BlobScope
+import ch.threema.domain.protocol.blob.BlobUploader
+import java.io.IOException
+import javax.net.ssl.HttpsURLConnection
+
+interface ApiService {
+
+    /**
+     * @param shouldPersist Will have no effect if the loader targets the blob mirror server if multi-device is currently active
+     * @param blobScope Will only have an effect if multi-device is currently active
+     */
+    @Throws(ThreemaException::class)
+    fun createUploader(data: ByteArray, shouldPersist: Boolean, blobScope: BlobScope): BlobUploader
+
+    fun createLoader(blobId: ByteArray): BlobLoader
+
+    @Throws(ThreemaException::class)
+    fun getAuthToken(): String?
+
+    /**
+     * Invalidate the auth token (only used for onprem). This forces a new fetch of the auth token
+     * the next time the token is obtained with [.getAuthToken].
+     */
+    fun invalidateAuthToken()
+
+    @Throws(ThreemaException::class, IOException::class)
+    fun createAvatarURLConnection(identity: String?): HttpsURLConnection?
+}
diff --git a/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java b/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java
index 58e62690..40916cde 100644
--- a/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java
@@ -28,70 +28,132 @@ import java.net.URL;
 
 import javax.net.ssl.HttpsURLConnection;
 
+import androidx.annotation.NonNull;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.models.AppVersion;
 import ch.threema.domain.protocol.ServerAddressProvider;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.blob.BlobLoader;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.blob.BlobUploader;
-import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.domain.stores.TokenStoreInterface;
+import okhttp3.OkHttpClient;
 
 public class ApiServiceImpl implements ApiService {
-	private final AppVersion appVersion;
-	private final boolean ipv6;
-	private final APIConnector apiConnector;
-	private final TokenStoreInterface authTokenStore;
-	private final ServerAddressProvider serverAddressProvider;
+    private final AppVersion appVersion;
+    private final boolean useIpv6;
+    private final APIConnector apiConnector;
+    private final TokenStoreInterface authTokenStore;
+    private final ServerAddressProvider serverAddressProvider;
+    private final MultiDeviceManager multiDeviceManager;
+    private final OkHttpClient baseOkHttpClient;
 
-	public ApiServiceImpl(AppVersion appVersion, boolean ipv6, APIConnector apiConnector, TokenStoreInterface authTokenStore, ServerAddressProvider serverAddressProvider) {
-		this.appVersion = appVersion;
-		this.ipv6 = ipv6;
-		this.apiConnector = apiConnector;
-		this.authTokenStore = authTokenStore;
-		this.serverAddressProvider = serverAddressProvider;
-	}
+    public ApiServiceImpl(
+        AppVersion appVersion,
+        boolean useIpv6,
+        APIConnector apiConnector,
+        TokenStoreInterface authTokenStore,
+        ServerAddressProvider serverAddressProvider,
+        MultiDeviceManager multiDeviceManager,
+        OkHttpClient baseOkHttpClient
+    ) {
+        this.appVersion = appVersion;
+        this.useIpv6 = useIpv6;
+        this.apiConnector = apiConnector;
+        this.authTokenStore = authTokenStore;
+        this.serverAddressProvider = serverAddressProvider;
+        this.multiDeviceManager = multiDeviceManager;
+        this.baseOkHttpClient = baseOkHttpClient;
+    }
 
-	@Override
-	public BlobUploader createUploader(byte[] data) throws ThreemaException {
-		BlobUploader uploader = new BlobUploader(ConfigUtils::getSSLSocketFactory, data, ipv6, serverAddressProvider, null);
-		uploader.setVersion(this.appVersion);
-		if (ConfigUtils.isOnPremBuild()) {
-			uploader.setAuthToken(getAuthToken());
-		}
-		return uploader;
-	}
+    @NonNull
+    @Override
+    public BlobUploader createUploader(
+        @NonNull byte[] blobData,
+        boolean shouldPersist,
+        @NonNull BlobScope blobScope
+    ) throws ThreemaException {
+        final BlobUploader blobUploader;
+        if (multiDeviceManager.isMultiDeviceActive()) {
+            blobUploader = BlobUploader.mirror(
+                baseOkHttpClient,
+                ConfigUtils.isOnPremBuild() ? getAuthToken() : null,
+                blobData,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                multiDeviceManager.getPropertiesProvider(),
+                blobScope
+            );
+        } else {
+            blobUploader = BlobUploader.usual(
+                baseOkHttpClient,
+                ConfigUtils.isOnPremBuild() ? getAuthToken() : null,
+                blobData,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                useIpv6,
+                shouldPersist
+            );
+        }
+        return blobUploader;
+    }
 
-	@Override
-	public BlobLoader createLoader(byte[] blobId) {
-		BlobLoader loader = new BlobLoader(ConfigUtils::getSSLSocketFactory, blobId, ipv6, serverAddressProvider, null);
-		loader.setVersion(this.appVersion);
-		return loader;
-	}
+    @NonNull
+    @Override
+    public BlobLoader createLoader(@NonNull byte[] blobId) {
+        BlobLoader loader;
+        if (multiDeviceManager.isMultiDeviceActive()) {
+            loader = BlobLoader.mirror(
+                baseOkHttpClient,
+                blobId,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                multiDeviceManager.getPropertiesProvider()
+            );
+        } else {
+            loader = BlobLoader.usual(
+                baseOkHttpClient,
+                blobId,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                useIpv6
+            );
+        }
+        return loader;
+    }
 
-	@Override
-	public String getAuthToken() throws ThreemaException {
-		try {
-			return apiConnector.obtainAuthToken(authTokenStore, false);
-		} catch (IOException | JSONException e) {
-			throw new ThreemaException("Cannot obtain authentication token", e);
-		}
-	}
+    @Override
+    public String getAuthToken() throws ThreemaException {
+        try {
+            return apiConnector.obtainAuthToken(authTokenStore, false);
+        } catch (IOException | JSONException e) {
+            throw new ThreemaException("Cannot obtain authentication token", e);
+        }
+    }
 
-	@Override
-	public void invalidateAuthToken() {
-		this.authTokenStore.storeToken(null);
-	}
+    @Override
+    public void invalidateAuthToken() {
+        this.authTokenStore.storeToken(null);
+    }
 
-	@Override
-	public HttpsURLConnection createAvatarURLConnection(String identity) throws ThreemaException, IOException {
-		URL url = new URL(serverAddressProvider.getAvatarServerUrl(false) + identity);
-		HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
-		connection.setSSLSocketFactory(ConfigUtils.getSSLSocketFactory(url.getHost()));
-		if (ConfigUtils.isOnPremBuild()) {
-			connection.setRequestProperty("Authorization", "Token " + getAuthToken());
-		}
-		return connection;
-	}
+    @Override
+    public HttpsURLConnection createAvatarURLConnection(String identity) throws ThreemaException, IOException {
+        URL url = new URL(serverAddressProvider.getAvatarServerUrl(false) + identity);
+        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
+        connection.setSSLSocketFactory(ConfigUtils.getSSLSocketFactory(url.getHost()));
+        if (ConfigUtils.isOnPremBuild()) {
+            connection.setRequestProperty("Authorization", "Token " + getAuthToken());
+        }
+        return connection;
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/AvatarCacheService.java b/app/src/main/java/ch/threema/app/services/AvatarCacheService.java
index a19feba2..5b08c6a5 100644
--- a/app/src/main/java/ch/threema/app/services/AvatarCacheService.java
+++ b/app/src/main/java/ch/threema/app/services/AvatarCacheService.java
@@ -137,7 +137,13 @@ public interface AvatarCacheService {
 	@AnyThread
 	void reset(@NonNull ContactModel contactModel);
 
-	/**
+    /**
+     * Clears the cache of the contact with the given identity.
+     */
+    @AnyThread
+    void reset(@NonNull String identity);
+
+    /**
 	 * Clears the cache of the given group model.
 	 */
 	@AnyThread
diff --git a/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java b/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java
index 11d3b48b..a9bd4bbd 100644
--- a/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java
@@ -169,12 +169,17 @@ final public class AvatarCacheServiceImpl implements AvatarCacheService {
 	@AnyThread
 	@Override
 	public void reset(@NonNull ContactModel contactModel) {
-		synchronized (this.contactAvatarStates) {
-			this.contactAvatarStates.put(contactModel.getIdentity(), System.currentTimeMillis());
-		}
+        reset(contactModel.getIdentity());
 	}
 
-	@AnyThread
+    @Override
+    public void reset(@NonNull String identity) {
+        synchronized (this.contactAvatarStates) {
+            this.contactAvatarStates.put(identity, System.currentTimeMillis());
+        }
+    }
+
+    @AnyThread
 	@Override
 	public void reset(@NonNull GroupModel groupModel) {
 		synchronized (this.groupAvatarStates) {
diff --git a/app/src/main/java/ch/threema/app/services/AvatarService.java b/app/src/main/java/ch/threema/app/services/AvatarService.java
index 0bd2ba90..bcae54c9 100644
--- a/app/src/main/java/ch/threema/app/services/AvatarService.java
+++ b/app/src/main/java/ch/threema/app/services/AvatarService.java
@@ -145,11 +145,6 @@ public interface AvatarService<M extends ReceiverModel> {
 		return getAvatar(null, options != null ? options : AvatarOptions.PRESET_DEFAULT_AVATAR_NO_CACHE);
 	}
 
-	/**
-	 * Delete the cache of the given model
-	 */
-	void clearAvatarCache(@NonNull M model);
-
 	/**
 	 * Get the color of the avatar. This method considers the "isDefaultContactPictureColored" setting.
 	 *
diff --git a/app/src/main/java/ch/threema/app/services/ContactService.java b/app/src/main/java/ch/threema/app/services/ContactService.java
index 8d194f07..e9db6517 100644
--- a/app/src/main/java/ch/threema/app/services/ContactService.java
+++ b/app/src/main/java/ch/threema/app/services/ContactService.java
@@ -21,35 +21,29 @@
 
 package ch.threema.app.services;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.WorkerThread;
-
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
 
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.data.models.ContactModelData;
 import ch.threema.domain.fs.DHSession;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.api.APIConnector;
-import ch.threema.domain.protocol.api.work.WorkContact;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 import ch.threema.domain.taskmanager.ActiveTaskCodec;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.access.AccessModel;
 import java8.util.function.Consumer;
 
 public interface ContactService extends AvatarService<ContactModel> {
 
-	int ContactVerificationResult_NO_MATCH = 0;
-	int ContactVerificationResult_ALREADY_VERIFIED = 1;
-	int ContactVerificationResult_VERIFIED = 2;
-
 	String ALL_USERS_PLACEHOLDER_ID = "@@@@@@@@";
 
     interface ContactProcessor {
@@ -65,10 +59,31 @@ public interface ContactService extends AvatarService<ContactModel> {
 	}
 
 	class ProfilePictureSharePolicy {
-		public enum Policy { NOBODY, EVERYONE, SOME }
+
+        // Do NOT change the order of these values, as features rely on the `ordinal` value to stay the same
+		public enum Policy {
+            NOBODY,
+            EVERYONE,
+            ALLOW_LIST;
+
+            @Nullable
+            public static Policy fromIntOrNull(final int value) {
+                switch (value) {
+                    case PreferenceService.PROFILEPIC_RELEASE_NOBODY:
+                        return Policy.NOBODY;
+                    case PreferenceService.PROFILEPIC_RELEASE_EVERYONE:
+                        return Policy.EVERYONE;
+                    case PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST:
+                        return Policy.ALLOW_LIST;
+                    default:
+                        return null;
+                }
+            }
+        }
 
 		@NonNull
 		private final Policy policy;
+
 		@NonNull
 		private final List<String> allowedIdentities;
 
@@ -166,7 +181,7 @@ public interface ContactService extends AvatarService<ContactModel> {
 		/**
 		 * States filter
 		 */
-		ContactModel.State[] states();
+		IdentityState[] states();
 
 		/**
 		 * @return feature int
@@ -197,6 +212,7 @@ public interface ContactService extends AvatarService<ContactModel> {
 		Boolean onlyWithReceiptSettings();
 	}
 
+	@NonNull
 	ContactModel getMe();
 
 	/**
@@ -260,14 +276,6 @@ public interface ContactService extends AvatarService<ContactModel> {
 	@Nullable
 	ContactModel getByIdentity(@Nullable String identity);
 
-	/**
-	 * Return the contact model for the specified identity. If the contact does not exist yet, create it.
-	 *
-	 * @param identity The identity string
-	 * @param force Force the creation of the contact, even if adding new contacts has been disabled
-	 */
-	@NonNull
-	ContactModel getOrCreateByIdentity(String identity, boolean force) throws EntryAlreadyExistsException, InvalidEntryException, PolicyViolationException;
 	List<ContactModel> getByIdentities(String[] identities);
 	List<ContactModel> getByIdentities(List<String> identities);
 
@@ -308,8 +316,16 @@ public interface ContactService extends AvatarService<ContactModel> {
 	@Nullable
 	ContactModel getByPublicKey(byte[] publicKey);
 
-	void setIsHidden(String identity, boolean hidden);
-	boolean getIsHidden(String identity);
+	/**
+	 * Update the acquaintance level of the given identity if it exists as a contact.
+	 *
+	 * @param identity the identity of the contact
+	 * @param acquaintanceLevel the new acquaintance level
+	 */
+	void setAcquaintanceLevel(
+		@NonNull String identity,
+		@NonNull ContactModel.AcquaintanceLevel acquaintanceLevel
+	);
 
 	void setIsArchived(String identity, boolean archived);
 
@@ -329,16 +345,17 @@ public interface ContactService extends AvatarService<ContactModel> {
 	 */
 	void clearLastUpdate(@NonNull String identity);
 
+    /**
+     * Save the given contact model.
+     *
+     * @deprecated This method should not be used anymore as it may override the database with old
+     * data from the model. To perform changes on a contact, the contact model repository should be
+     * used.
+     */
+    @Deprecated
 	void save(@NonNull ContactModel model);
 
-	/**
-	 * save contacts after processing and returning true
-	 */
-	int save(List<ContactModel> contactModels, ContactProcessor contactProcessor);
-
-	boolean remove(ContactModel model);
-	boolean remove(ContactModel model, boolean removeLink);
-	AccessModel getAccess(ContactModel model);
+	AccessModel getAccess(@Nullable String identity);
 
 	void setIsTyping(String identity, boolean isTyping) ;
 	boolean isTyping(String identity);
@@ -351,106 +368,91 @@ public interface ContactService extends AvatarService<ContactModel> {
 	 */
 	void sendTypingIndicator(String toIdentity, boolean isTyping);
 
-	void setActive(@Nullable String identity);
-
-	int updateContactVerification(String identity, byte[] publicKey);
-
-	/**
-	 * Create a contact with the specified identity.
-	 *
-	 * @param identity The identity string
-	 * @param force Force the creation of the contact, even if adding new contacts has been disabled
-	 */
-	@NonNull
-	ContactModel createContactByIdentity(@NonNull String identity, boolean force) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException;
-
-	/**
-	 * Create a contact with the specified identity.
-	 *
-	 * @param identity The identity string
-	 * @param force Force the creation of the contact, even if adding new contacts has been disabled
-	 * @param acquaintanceLevel The acquaintance level of the new contact
-	 */
-	@NonNull ContactModel createContactByIdentity(@NonNull String identity, boolean force, @NonNull ContactModel.AcquaintanceLevel acquaintanceLevel) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException;
-
-	/**
-	 * Create (optionally hidden) contacts for all provided identities. Note that contacts are also created when block
-	 * unknown is active or th_disable_add_contact is set to true.
-	 * Contacts are added with acquaintance level 'group'.
-	 * There is no contact created for an identity if
-	 *  - it is the user's identity
-	 *  - there is already a contact for that identity
-	 *  - the identity public key cannot be fetched (404)
-	 */
-	void createGroupContactsByIdentities(@NonNull List<String> identities);
-
-	VerificationLevel getInitialVerificationLevel(ContactModel contactModel);
-
-	void removeAll();
-
 	/**
 	 * Create a new message receiver for the specified contact model.
 	 */
 	@NonNull ContactMessageReceiver createReceiver(ContactModel contact);
 
 	/**
-	 * @param msg latest message with the "newest" public nickname
+	 * Create a new message receiver for the specified contact model. Note that the return value is
+	 * null, if the old contact model does not exist with the identity of the given model.
 	 */
-	void updatePublicNickName(@NonNull AbstractMessage msg);
+	@Nullable ContactMessageReceiver createReceiver(@NonNull ch.threema.data.models.ContactModel contact);
+
+    /**
+     * Create a new message receiver for the given identity. Note that the return value is null if
+     * there is no contact with the provided identity.
+     */
+    @Nullable ContactMessageReceiver createReceiver(@NonNull String identity);
 
 	boolean updateAllContactNamesFromAndroidContacts();
 
 	void removeAllSystemContactLinks();
 
-	@Deprecated
-	int getUniqueId(@Nullable ContactModel contactModel);
-	@Deprecated
-	int getUniqueId(@NonNull String identity);
-	String getUniqueIdString(ContactModel contactModel);
-
-	String getUniqueIdString(String identity);
-
-	boolean setAvatar(@Nullable ContactModel contactModel, @Nullable File temporaryAvatarFile) throws Exception;
-	boolean setAvatar(@NonNull String identity, @Nullable File temporaryAvatarFile) throws Exception;
-	boolean setAvatar(ContactModel contactModel, byte[] avatar) throws Exception;
-	boolean removeAvatar(ContactModel contactModel);
-	void clearAvatarCache(@NonNull String identity);
+    /**
+     * Set the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if storing the profile picture succeeded
+     */
+    boolean setUserDefinedProfilePicture(
+        @Nullable ContactModel contactModel,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    );
+
+    /**
+     * Set the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if storing the profile picture succeeded
+     */
+    boolean setUserDefinedProfilePicture(
+        @NonNull String identity,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    );
+
+    /**
+     * Set the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if storing the profile picture succeeded
+     * @throws IOException when the byte array cannot be written to the file
+     * @throws MasterKeyLockedException when the master key is locked
+     */
+    boolean setUserDefinedProfilePicture(
+        @Nullable ContactModel contactModel,
+        @Nullable byte[] avatar,
+        @NonNull TriggerSource triggerSource
+    ) throws IOException, MasterKeyLockedException;
+
+    /**
+     * Remove the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if the removal succeeded
+     */
+    boolean removeUserDefinedProfilePicture(
+        @Nullable ContactModel contactModel,
+        @NonNull TriggerSource triggerSource
+    );
 
 	@NonNull
 	ProfilePictureSharePolicy getProfilePictureSharePolicy();
 
 	/**
-	 * Check whether the app settings allow the profile picture to be sent to the contact. Note that
+	 * Check whether the app settings allow the profile picture to be sent to the identity. Note that
 	 * this method does <b>not</b> check whether the contact is a gateway ID or ECHOECHO.
 	 *
 	 * @return {@code true} if the profile picture could be sent, {@code false} otherwise
 	 */
-	boolean isContactAllowedToReceiveProfilePicture(@NonNull ContactModel contactModel);
-
-	/**
-	 * Upload the current profile picture if it hasn't been uploaded recently and get the most
-	 * recent contact profile picture upload data.
-	 *
-	 * @return the most recent profile picture upload data. If the upload failed or the last stored
-	 * data could not be read, the returned data contains null as blob ID. If there is no profile
-	 * picture set, the blob ID is {@link ContactModel#NO_PROFILE_PICTURE_BLOB_ID}.
-	 */
-	@NonNull
-	@WorkerThread
-	ProfilePictureUploadData getUpdatedProfilePictureUploadData();
-
-	/**
-	 * Reset the date of the last profile picture distribution date of the given contact.
-	 */
-	void resetContactPhotoSentState(@NonNull ContactModel contactModel);
-
-	ContactModel createContactModelByIdentity(String identity) throws InvalidEntryException;
+	boolean isContactAllowedToReceiveProfilePicture(@NonNull String identity);
 
 	boolean showBadge(@Nullable ContactModel contactModel);
 	boolean showBadge(@NonNull ContactModelData contactModelData);
 
 	String getAndroidContactLookupUriString(ContactModel contactModel);
-	@Nullable ContactModel addWorkContact(@NonNull WorkContact workContact, @Nullable List<ContactModel> existingWorkContacts);
 
 	/**
 	 * Remove the specified contact from the contact cache.
@@ -484,8 +486,8 @@ public interface ContactService extends AvatarService<ContactModel> {
 	void fetchAndCacheContact(@NonNull String identity) throws APIConnector.HttpConnectionException, APIConnector.NetworkException, MissingPublicKeyException;
 
 	@WorkerThread
-	boolean resetReceiptsSettings();
-	void reportSpam(@NonNull ContactModel spammerContactModel, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure);
+	void resetReceiptsSettings();
+	void reportSpam(@NonNull String identity, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure);
 
 	/**
 	 * Get the forward security state of a given contact.
diff --git a/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java b/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java
index 510e06e4..15b39bb2 100644
--- a/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java
@@ -41,8 +41,6 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.HttpURLConnection;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -51,8 +49,10 @@ import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Timer;
 import java.util.TimerTask;
+import java.util.stream.Collectors;
 
 import androidx.annotation.AnyThread;
 import androidx.annotation.ColorInt;
@@ -63,25 +63,23 @@ import androidx.annotation.WorkerThread;
 import androidx.core.content.ContextCompat;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.asynctasks.AddOrUpdateWorkIdentityBackgroundTask;
 import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.glide.AvatarOptions;
 import ch.threema.app.listeners.ContactTypingListener;
 import ch.threema.app.listeners.ProfileListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.routines.UpdateBusinessAvatarRoutine;
 import ch.threema.app.routines.UpdateFeatureLevelRoutine;
 import ch.threema.app.services.license.LicenseService;
-import ch.threema.app.services.license.UserCredentials;
 import ch.threema.app.stores.DatabaseContactStore;
 import ch.threema.app.stores.IdentityStore;
+import ch.threema.app.tasks.TaskCreator;
 import ch.threema.app.utils.AndroidContactUtil;
-import ch.threema.app.utils.AppRestrictionUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ColorUtil;
 import ch.threema.app.utils.ConfigUtils;
@@ -89,27 +87,28 @@ import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShortcutUtil;
 import ch.threema.app.utils.SynchronizeContactsUtil;
-import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.Base32;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.data.models.ModelDeletedException;
 import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.fs.DHSession;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
+import ch.threema.domain.models.ReadReceiptPolicy;
+import ch.threema.domain.models.TypingIndicatorPolicy;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.api.APIConnector;
-import ch.threema.domain.protocol.api.work.WorkContact;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.blob.BlobUploader;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
-import ch.threema.domain.stores.DHSessionStoreException;
-import ch.threema.domain.stores.DHSessionStoreInterface;
 import ch.threema.domain.taskmanager.ActiveTaskCodec;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.DatabaseUtil;
 import ch.threema.storage.QueryBuilder;
@@ -119,8 +118,6 @@ import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
 import ch.threema.storage.models.ValidationMessage;
 import ch.threema.storage.models.access.AccessModel;
 import java8.util.function.Consumer;
-import java8.util.stream.Collectors;
-import java8.util.stream.StreamSupport;
 
 import static ch.threema.app.glide.AvatarOptions.DefaultAvatarPolicy.CUSTOM_AVATAR;
 
@@ -128,13 +125,11 @@ public class ContactServiceImpl implements ContactService {
     private static final Logger logger = LoggingUtil.getThreemaLogger("ContactServiceImpl");
 
     private static final int TYPING_RECEIVE_TIMEOUT = (int) DateUtils.MINUTE_IN_MILLIS;
-    private static final String CONTACT_UID_PREFIX = "c-";
 
     private final Context context;
     private final AvatarCacheService avatarCacheService;
     private final DatabaseContactStore contactStore;
     private final DatabaseServiceNew databaseServiceNew;
-    private final DeviceService deviceService;
     private final UserService userService;
     private final IdentityStore identityStore;
     private final PreferenceService preferenceService;
@@ -142,14 +137,14 @@ public class ContactServiceImpl implements ContactService {
     // layer, since that data layer has caching built-in.
     private final Map<String, ContactModel> contactModelCache;
     private final IdListService blockedContactsService, profilePicRecipientsService;
-    private final DeadlineListService mutedChatsListService;
-    private final DeadlineListService hiddenChatsListService;
-    private final RingtoneService ringtoneService;
     private final FileService fileService;
     private final ApiService apiService;
-    private final WallpaperService wallpaperService;
     private final LicenseService licenseService;
     private final APIConnector apiConnector;
+    @NonNull
+    private final TaskCreator taskCreator;
+    @NonNull
+    private final MultiDeviceManager multiDeviceManager;
     private final Timer typingTimer;
     private final Map<String, TimerTask> typingTimerTasks;
 
@@ -160,20 +155,26 @@ public class ContactServiceImpl implements ContactService {
 
     private ContactModel me;
 
+    public final static byte[] THREEMA_PUBLIC_KEY = new byte[]{ // *THREEMA
+        58, 56, 101, 12, 104, 20, 53, -67, 31, -72, 73, -114, 33, 58, 41, 25,
+        -80, -109, -120, -11, -128, 58, -92, 70, 64, -32, -9, 6, 50, 106, -122, 92,
+    };
+
+    public final static byte[] SUPPORT_PUBLIC_KEY = new byte[]{ // *SUPPORT
+        15, -108, 77, 24, 50, 75, 33, 50, -58, 29, -114, 64, -81, -50, 96, -96,
+        -21, -41, 1, -69, 17, -24, -101, -23, 73, 114, -44, 34, -98, -108, 114, 42,
+    };
+
+    public final static byte[] MY_DATA_PUBLIC_KEY = new byte[]{ // *MY3DATA
+        59, 1, -123, 79, 36, 115, 110, 45, 13, 45, -61, -121, -22, -14, -64, 39,
+        60, 80, 73, 5, 33, 71, 19, 35, 105, -65, 57, 96, -48, -96, -65, 2
+    };
+
     // These are public keys of identities that will be immediately trusted (three green dots)
-    private final static byte[][] TRUSTED_PUBLIC_KEYS = {
-        new byte[]{ // *THREEMA
-            58, 56, 101, 12, 104, 20, 53, -67, 31, -72, 73, -114, 33, 58, 41, 25,
-            -80, -109, -120, -11, -128, 58, -92, 70, 64, -32, -9, 6, 50, 106, -122, 92,
-        },
-        new byte[]{ // *SUPPORT
-            15, -108, 77, 24, 50, 75, 33, 50, -58, 29, -114, 64, -81, -50, 96, -96,
-            -21, -41, 1, -69, 17, -24, -101, -23, 73, 114, -44, 34, -98, -108, 114, 42,
-        },
-        new byte[]{ // *MY3DATA
-            59, 1, -123, 79, 36, 115, 110, 45, 13, 45, -61, -121, -22, -14, -64, 39,
-            60, 80, 73, 5, 33, 71, 19, 35, 105, -65, 57, 96, -48, -96, -65, 2
-        }
+    public final static byte[][] TRUSTED_PUBLIC_KEYS = {
+        THREEMA_PUBLIC_KEY,
+        SUPPORT_PUBLIC_KEY,
+        MY_DATA_PUBLIC_KEY,
     };
 
     public ContactServiceImpl(
@@ -181,49 +182,44 @@ public class ContactServiceImpl implements ContactService {
         DatabaseContactStore contactStore,
         AvatarCacheService avatarCacheService,
         DatabaseServiceNew databaseServiceNew,
-        DeviceService deviceService,
         UserService userService,
         IdentityStore identityStore,
         PreferenceService preferenceService,
         IdListService blockedContactsService,
         IdListService profilePicRecipientsService,
-        RingtoneService ringtoneService,
-        DeadlineListService mutedChatsListService,
-        DeadlineListService hiddenChatsListService,
         FileService fileService,
         CacheService cacheService,
         ApiService apiService,
-        WallpaperService wallpaperService,
         LicenseService licenseService,
         APIConnector apiConnector,
-        @NonNull ContactModelRepository contactModelRepository
+        @NonNull ContactModelRepository contactModelRepository,
+        @NonNull TaskCreator taskCreator,
+        @NonNull MultiDeviceManager multiDeviceManager
     ) {
 
         this.context = context;
         this.avatarCacheService = avatarCacheService;
         this.contactStore = contactStore;
         this.databaseServiceNew = databaseServiceNew;
-        this.deviceService = deviceService;
         this.userService = userService;
         this.identityStore = identityStore;
         this.preferenceService = preferenceService;
         this.blockedContactsService = blockedContactsService;
         this.profilePicRecipientsService = profilePicRecipientsService;
-        this.ringtoneService = ringtoneService;
-        this.mutedChatsListService = mutedChatsListService;
-        this.hiddenChatsListService = hiddenChatsListService;
         this.fileService = fileService;
         this.apiService = apiService;
-        this.wallpaperService = wallpaperService;
         this.licenseService = licenseService;
         this.apiConnector = apiConnector;
         this.contactModelRepository = contactModelRepository;
+        this.taskCreator = taskCreator;
+        this.multiDeviceManager = multiDeviceManager;
         this.typingTimer = new Timer();
         this.typingTimerTasks = new HashMap<>();
         this.contactModelCache = cacheService.getContactModelCache();
     }
 
     @Override
+    @NonNull
     public ContactModel getMe() {
         if (this.me == null && this.userService.getIdentity() != null) {
             this.me = new ContactModel(
@@ -231,7 +227,7 @@ public class ContactServiceImpl implements ContactService {
                 this.userService.getPublicKey()
             );
             this.me.setPublicNickName(this.userService.getPublicNickname());
-            this.me.setState(ContactModel.State.ACTIVE);
+            this.me.setState(IdentityState.ACTIVE);
             this.me.setFirstName(context.getString(R.string.me_myself_and_i));
             this.me.verificationLevel = VerificationLevel.FULLY_VERIFIED;
             this.me.setFeatureMask(-1);
@@ -245,20 +241,20 @@ public class ContactServiceImpl implements ContactService {
     public List<ContactModel> getAllDisplayed(@NonNull ContactSelection contactSelection) {
         return this.find(new Filter() {
             @Override
-            public ContactModel.State[] states() {
+            public IdentityState[] states() {
                 if (preferenceService.showInactiveContacts()) {
                     switch (contactSelection) {
                         case EXCLUDE_INVALID:
-                            return new ContactModel.State[]{
-                                ContactModel.State.ACTIVE,
-                                ContactModel.State.INACTIVE,
+                            return new IdentityState[]{
+                                IdentityState.ACTIVE,
+                                IdentityState.INACTIVE,
                             };
                         case INCLUDE_INVALID:
                         default:
                             return null;
                     }
                 } else {
-                    return new ContactModel.State[]{ContactModel.State.ACTIVE};
+                    return new IdentityState[]{IdentityState.ACTIVE};
                 }
             }
 
@@ -305,12 +301,12 @@ public class ContactServiceImpl implements ContactService {
 
         List<ContactModel> result;
         if (filter != null) {
-            ContactModel.State[] filterStates = filter.states();
+            IdentityState[] filterStates = filter.states();
             if (filterStates != null && filterStates.length > 0) {
 
                 //dirty, add placeholder should be added to makePlaceholders
                 queryBuilder.appendWhere(ContactModel.COLUMN_STATE + " IN (" + DatabaseUtil.makePlaceholders(filterStates.length) + ")");
-                for (ContactModel.State s : filterStates) {
+                for (IdentityState s : filterStates) {
                     placeholders.add(s.toString());
                 }
             }
@@ -319,7 +315,7 @@ public class ContactServiceImpl implements ContactService {
                 queryBuilder.appendWhere(ContactModel.COLUMN_ACQUAINTANCE_LEVEL + "=0");
             }
 
-            if (!filter.includeMyself() && getMe() != null) {
+            if (!filter.includeMyself()) {
                 queryBuilder.appendWhere(ContactModel.COLUMN_IDENTITY + "!=?");
                 placeholders.add(getMe().getIdentity());
             }
@@ -331,14 +327,14 @@ public class ContactServiceImpl implements ContactService {
             result = contactModelFactory.convert
                 (
                     queryBuilder,
-                    placeholders.toArray(new String[placeholders.size()]),
+                    placeholders.toArray(new String[0]),
                     null
                 );
         } else {
             result = contactModelFactory.convert
                 (
                     queryBuilder,
-                    placeholders.toArray(new String[placeholders.size()]),
+                    placeholders.toArray(new String[0]),
                     null
                 );
         }
@@ -356,24 +352,26 @@ public class ContactServiceImpl implements ContactService {
             if (feature != null) {
                 if (filter.fetchMissingFeatureLevel()) {
                     //do not filtering with sql
-                    UpdateFeatureLevelRoutine routine = new UpdateFeatureLevelRoutine(this,
+                    UpdateFeatureLevelRoutine routine = new UpdateFeatureLevelRoutine(
+                        contactModelRepository,
+                        userService,
                         this.apiConnector,
-                        Functional.filter(result, new IPredicateNonNull<ContactModel>() {
-                            @Override
-                            public boolean apply(@NonNull ContactModel contactModel) {
-                                return !ThreemaFeature.hasFeature(contactModel.getFeatureMask(), feature);
-                            }
-                        }));
+                        result
+                            .stream()
+                            .filter(Objects::nonNull)
+                            .filter(model -> !ThreemaFeature.hasFeature(model.getFeatureMask(), feature))
+                            .map(Contact::getIdentity)
+                            .collect(Collectors.toList())
+                    );
                     routine.run();
                 }
 
-                // Now filter
-                result = Functional.filter(result, new IPredicateNonNull<ContactModel>() {
-                    @Override
-                    public boolean apply(@NonNull ContactModel contactModel) {
-                        return ThreemaFeature.hasFeature(contactModel.getFeatureMask(), feature);
-                    }
-                });
+                // Filter the result by the required feature
+                result = result
+                    .stream()
+                    .map(outdatedModel -> getByIdentity(outdatedModel.getIdentity()))
+                    .filter(model -> model != null && ThreemaFeature.hasFeature(model.getFeatureMask(), feature))
+                    .collect(Collectors.toList());
             }
 
         }
@@ -421,21 +419,6 @@ public class ContactServiceImpl implements ContactService {
         return this.cache(this.contactStore.getContactForIdentity(identity));
     }
 
-    /**
-     * If a contact for the specified identity exists, return the contactmodel.
-     * Otherwise, create a new contact and return the contactmodel.
-     */
-    @Override
-    @NonNull
-    public ContactModel getOrCreateByIdentity(@NonNull String identity, boolean force)
-        throws EntryAlreadyExistsException, InvalidEntryException, PolicyViolationException {
-        ContactModel contactModel = this.getByIdentity(identity);
-        if (contactModel == null) {
-            contactModel = this.createContactByIdentity(identity, force);
-        }
-        return contactModel;
-    }
-
     private ContactModel cache(ContactModel contactModel) {
         if (contactModel != null) {
             this.contactModelCache.put(contactModel.getIdentity(), contactModel);
@@ -502,11 +485,11 @@ public class ContactServiceImpl implements ContactService {
     public List<ContactModel> getCanReceiveProfilePics() {
         return Functional.filter(this.find(new Filter() {
             @Override
-            public ContactModel.State[] states() {
+            public IdentityState[] states() {
                 if (preferenceService.showInactiveContacts()) {
                     return null;
                 }
-                return new ContactModel.State[]{ContactModel.State.ACTIVE};
+                return new IdentityState[]{IdentityState.ACTIVE};
             }
 
             @Override
@@ -690,43 +673,22 @@ public class ContactServiceImpl implements ContactService {
     }
 
     @Override
-    public void setActive(@Nullable String identity) {
-        final ContactModel contact = this.getByIdentity(identity);
-
-        if (contact != null && contact.getState() == ContactModel.State.INACTIVE) {
-            contact.setState(ContactModel.State.ACTIVE);
-            this.save(contact);
-        }
-    }
-
-    /**
-     * Change hidden status of contact
-     *
-     * @param identity
-     * @param hide     true if we want to hide the contact, false to unhide
-     */
-    @Override
-    public void setIsHidden(String identity, boolean hide) {
-        final ContactModel contact = this.getByIdentity(identity);
+    public void setAcquaintanceLevel(
+        @NonNull String identity,
+        @NonNull AcquaintanceLevel acquaintanceLevel
+    ) {
+        final ch.threema.data.models.ContactModel contactModel =
+            contactModelRepository.getByIdentity(identity);
 
-        if (contact != null && contact.isHidden() != hide) {
-            this.removeFromCache(identity);
-            this.contactStore.hideContact(contact, hide);
+        if (contactModel != null) {
+            try {
+                contactModel.setAcquaintanceLevelFromLocal(acquaintanceLevel);
+            } catch (ModelDeletedException e) {
+                logger.warn("Could not set acquaintance level because model has been deleted", e);
+            }
         }
     }
 
-    /**
-     * Get hidden status of contact
-     *
-     * @param identity
-     * @return true if contact is hidden from contact list, false otherwise
-     */
-    @Override
-    public boolean getIsHidden(String identity) {
-        final ContactModel contact = this.getByIdentity(identity);
-        return (contact != null && contact.isHidden());
-    }
-
     @Override
     public void setIsArchived(String identity, boolean archived) {
         final ContactModel contact = this.getByIdentity(identity);
@@ -741,8 +703,10 @@ public class ContactServiceImpl implements ContactService {
         logger.info("Bump last update for contact with identity {}", identity);
         final ContactModel contact = this.getByIdentity(identity);
         if (contact != null) {
-            contact.setLastUpdate(new Date());
-            save(contact); // listeners will be fired by save()
+            Date lastUpdate = new Date();
+            contact.setLastUpdate(lastUpdate);
+            databaseServiceNew.getContactModelFactory().setLastUpdate(identity, lastUpdate);
+            ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
         } else {
             logger.warn(
                 "Could not bump last update because the contact with identity {} is null",
@@ -756,104 +720,27 @@ public class ContactServiceImpl implements ContactService {
         final ContactModel contact = this.getByIdentity(identity);
         if (contact != null) {
             contact.setLastUpdate(null);
-            save(contact); // listeners will be fired by save()
+            databaseServiceNew.getContactModelFactory().setLastUpdate(identity, null);
+            ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
         }
     }
 
     @Override
+    @Deprecated
     public void save(@NonNull ContactModel contactModel) {
-        this.contactStore.addContact(contactModel);
-    }
+        logger.info("Saving old contact model of contact {}", contactModel.getIdentity());
 
-    @Override
-    public int save(List<ContactModel> contactModels, ContactProcessor contactProcessor) {
-        int savedModels = 0;
-        if (TestUtil.required(contactModels, contactProcessor)) {
-            for (ContactModel contactModel : contactModels) {
-                if (contactProcessor.process(contactModel)) {
-                    this.save(contactModel);
-                    savedModels++;
-                }
-            }
+        for (StackTraceElement stackTraceElement : Thread.currentThread().getStackTrace()) {
+            logger.info("{}", stackTraceElement);
         }
-        return savedModels;
-    }
 
-    @Override
-    public boolean remove(ContactModel model) {
-        return this.remove(model, true);
-    }
-
-    @Override
-    public boolean remove(@NonNull ContactModel model, boolean removeLink) {
-        String uniqueIdString = getUniqueIdString(model);
-
-        clearAvatarCache(model);
-
-        // Remove draft of this contact
-        ContactMessageReceiver receiver = createReceiver(model);
-        ThreemaApplication.putMessageDraft(receiver.getUniqueIdString(), null, null);
-
-        AccessModel access = this.getAccess(model);
-        if (access.canDelete()) {
-            // remove
-            this.contactStore.removeContact(model);
-
-            this.removeFromCache(model.getIdentity());
-
-            this.ringtoneService.removeCustomRingtone(uniqueIdString);
-            this.mutedChatsListService.remove(uniqueIdString);
-            this.hiddenChatsListService.remove(uniqueIdString);
-            this.profilePicRecipientsService.remove(model.getIdentity());
-            this.wallpaperService.removeWallpaper(uniqueIdString);
-            this.fileService.removeAndroidContactAvatar(model.getIdentity());
-            ShortcutUtil.deleteShareTargetShortcut(uniqueIdString);
-            ShortcutUtil.deletePinnedShortcut(uniqueIdString);
-
-            removeDHSessions(model.getIdentity());
-        } else {
-            // Hide contact
-            setIsHidden(model.getIdentity(), true);
-        }
-
-        deleteConversation(model);
-
-        if (removeLink) {
-            AndroidContactUtil.getInstance().deleteThreemaRawContact(model);
-        }
-
-        return true;
-    }
-
-    private void deleteConversation(@NonNull ContactModel contactModel) {
-        // Delete the conversation with the contact
-        try {
-            ConversationService conversationService = ThreemaApplication.getServiceManager().getConversationService();
-            conversationService.delete(contactModel);
-        } catch (Exception e) {
-            logger.error("Exception", e);
-        }
-    }
-
-    private void removeDHSessions(@Nullable String peerIdentity) {
-        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-        String identity = userService.getIdentity();
-        if (serviceManager != null && identity != null && peerIdentity != null) {
-            try {
-                DHSessionStoreInterface dhSessionStore = serviceManager.getDHSessionStore();
-                dhSessionStore.deleteAllDHSessions(identity, peerIdentity);
-            } catch (DHSessionStoreException e) {
-                logger.error("Could not delete all DH sessions");
-            }
-        } else {
-            logger.warn("Could not delete DH sessions because the service manager or identity is null");
-        }
+        this.contactStore.addContact(contactModel);
     }
 
     @NonNull
     @Override
-    public AccessModel getAccess(ContactModel model) {
-        if (model == null) {
+    public AccessModel getAccess(@Nullable String identity) {
+        if (identity == null) {
             return new AccessModel() {
                 @Override
                 public boolean canDelete() {
@@ -872,17 +759,14 @@ public class ContactServiceImpl implements ContactService {
             };
         } else {
             boolean isInGroup = false;
-            Cursor c = this.databaseServiceNew.getReadableDatabase().rawQuery("" +
-                "SELECT COUNT(*) FROM m_group g " +
-                "INNER JOIN group_member m " +
-                "	ON m.groupId = g.id " +
-                "WHERE m.identity = ? AND deleted = 0", new String[]{
-                model.getIdentity()
-            });
+            Cursor c = this.databaseServiceNew.getReadableDatabase().rawQuery(
+                DatabaseUtil.IS_GROUP_MEMBER_QUERY,
+                identity
+            );
 
             if (c != null) {
                 if (c.moveToFirst()) {
-                    isInGroup = c.getInt(0) > 0;
+                    isInGroup = c.getInt(0) == 1;
                 }
                 c.close();
             }
@@ -920,25 +804,6 @@ public class ContactServiceImpl implements ContactService {
         };
     }
 
-    @Override
-    public int updateContactVerification(String identity, byte[] publicKey) {
-        ContactModel c = this.getByIdentity(identity);
-
-        if (c != null) {
-            if (Arrays.equals(c.getPublicKey(), publicKey)) {
-                if (c.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-                    c.verificationLevel = VerificationLevel.FULLY_VERIFIED;
-                    this.save(c);
-                    return ContactVerificationResult_VERIFIED;
-                } else {
-                    return ContactVerificationResult_ALREADY_VERIFIED;
-                }
-            }
-        }
-
-        return ContactVerificationResult_NO_MATCH;
-    }
-
     @AnyThread
     @Override
     public Bitmap getAvatar(@Nullable ContactModel contact, @NonNull AvatarOptions options) {
@@ -980,7 +845,7 @@ public class ContactServiceImpl implements ContactService {
             return false;
         }
 
-        return fileService.hasContactAvatarFile(contact.getIdentity()) || fileService.hasContactPhotoFile(contact.getIdentity());
+        return fileService.hasUserDefinedProfilePicture(contact.getIdentity()) || fileService.hasContactDefinedProfilePicture(contact.getIdentity());
     }
 
     @Override
@@ -1002,110 +867,6 @@ public class ContactServiceImpl implements ContactService {
         avatarCacheService.loadContactAvatarIntoImage(model, imageView, options, requestManager);
     }
 
-    @AnyThread
-    @Override
-    public void clearAvatarCache(@NonNull ContactModel contactModel) {
-        if (this.avatarCacheService != null) {
-            this.avatarCacheService.reset(contactModel);
-        }
-    }
-
-    @Override
-    public @NonNull ContactModel createContactByIdentity(
-        @NonNull String identity,
-        boolean force
-    ) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException {
-        return createContactByIdentity(identity, force, AcquaintanceLevel.DIRECT);
-    }
-
-    @Override
-    public @NonNull ContactModel createContactByIdentity(
-        @NonNull String identity,
-        boolean force,
-        @NonNull AcquaintanceLevel acquaintanceLevel
-    ) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException {
-        logger.info("Create contact by identity; identity={}, force={}, acquaintanceLevel={}", identity, force, acquaintanceLevel);
-        if (!force && AppRestrictionUtil.isAddContactDisabled(ThreemaApplication.getAppContext())) {
-            throw new PolicyViolationException();
-        }
-
-        if (identity.equals(getMe().getIdentity())) {
-            throw new InvalidEntryException(R.string.identity_already_exists);
-        }
-
-        ContactModel newContact = this.getByIdentity(identity);
-        if (newContact == null) {
-            // create a new contact
-            newContact = this.createContactModelByIdentity(identity);
-        } else if (newContact.getAcquaintanceLevel() == AcquaintanceLevel.DIRECT || acquaintanceLevel == AcquaintanceLevel.GROUP) {
-            throw new EntryAlreadyExistsException(R.string.identity_already_exists);
-        }
-
-        newContact.setAcquaintanceLevel(acquaintanceLevel);
-        newContact.verificationLevel = getInitialVerificationLevel(newContact);
-
-        this.save(newContact);
-
-        return newContact;
-    }
-
-    @Override
-    public void createGroupContactsByIdentities(@NonNull List<String> identities) {
-        List<String> newIdentities = StreamSupport.stream(identities)
-            .filter(identity -> {
-                if (identity == null) {
-                    return false;
-                }
-                if (identity.equals(getMe().getIdentity())) {
-                    logger.warn("Ignore own identity");
-                    return false;
-                }
-                if (getByIdentity(identity) != null) {
-                    logger.warn("Ignore ID that is already in contact list");
-                    return false;
-                }
-                return true;
-            }).collect(Collectors.toList());
-
-        if (newIdentities.isEmpty()) {
-            return;
-        }
-
-        try {
-            for (APIConnector.FetchIdentityResult result : apiConnector.fetchIdentities(newIdentities)) {
-                ContactModel contactModel = createContactByFetchIdentityResult(result);
-                if (contactModel != null) {
-                    contactModel.setAcquaintanceLevel(AcquaintanceLevel.GROUP);
-                    contactStore.addContact(contactModel);
-                }
-            }
-        } catch (Exception e) {
-            logger.error("Error while bulk creating contacts", e);
-        }
-    }
-
-    @Override
-    @NonNull
-    public VerificationLevel getInitialVerificationLevel(ContactModel contactModel) {
-        // Determine whether this is a trusted public key (e.g. for *SUPPORT)
-        final byte[] pubKey = contactModel.getPublicKey();
-        boolean isTrusted = false;
-        for (byte[] trustedKey : TRUSTED_PUBLIC_KEYS) {
-            if (Arrays.equals(trustedKey, pubKey)) {
-                isTrusted = true;
-                break;
-            }
-        }
-        return isTrusted ? VerificationLevel.FULLY_VERIFIED : VerificationLevel.UNVERIFIED;
-    }
-
-    @Override
-    public void removeAll() {
-        for (ContactModel model : this.find(null)) {
-            this.remove(model, false);
-        }
-    }
-
     @Override
     @NonNull
     public ContactMessageReceiver createReceiver(ContactModel contact) {
@@ -1123,27 +884,20 @@ public class ContactServiceImpl implements ContactService {
         );
     }
 
-    private ContactModel getContact(AbstractMessage msg) {
-        return this.getByIdentity(msg.getFromIdentity());
+    @Override
+    @Nullable
+    public ContactMessageReceiver createReceiver(@NonNull ch.threema.data.models.ContactModel contact) {
+        return createReceiver(contact.getIdentity());
     }
 
     @Override
-    public void updatePublicNickName(@NonNull AbstractMessage msg) {
-        ContactModel contact = getContact(msg);
-        if (contact == null) {
-            return;
-        }
-
-        String nickname = msg.getNickname();
-        // If nickname is present (not null), trim whitespaces
-        if (nickname != null) {
-            nickname = nickname.trim();
-        }
-
-        // Update nickname if it is not null (and different from the current nickname)
-        if (nickname != null && !nickname.equals(contact.getPublicNickName())) {
-            contact.setPublicNickName(nickname);
-            save(contact);
+    @Nullable
+    public ContactMessageReceiver createReceiver(@NonNull String identity) {
+        ContactModel contactModel = getByIdentity(identity);
+        if (contactModel != null) {
+            return createReceiver(contactModel);
+        } else {
+            return null;
         }
     }
 
@@ -1155,233 +909,119 @@ public class ContactServiceImpl implements ContactService {
             return false;
         }
 
-        List<ContactModel> contactModels = this.getAll();
-        for (ContactModel contactModel : contactModels) {
-            if (contactModel.isLinkedToAndroidContact()) {
+        // TODO(ANDR-3172): Get all contacts via contact model repository
+        this.getAll().stream()
+            .map(m -> contactModelRepository.getByIdentity(m.getIdentity()))
+            .filter(Objects::nonNull)
+            .filter(contactModel -> {
+                ContactModelData data = contactModel.getData().getValue();
+                return data != null && data.isLinkedToAndroidContact();
+            })
+            .forEach(contactModel -> {
                 try {
                     AndroidContactUtil.getInstance().updateNameByAndroidContact(contactModel);
                 } catch (ThreemaException e) {
-                    contactModel.setAndroidContactLookupKey(null);
                     logger.error("Unable to update contact name", e);
                 }
-                this.save(contactModel);
-            }
-        }
+            });
         return true;
     }
 
     @Override
     public void removeAllSystemContactLinks() {
-        for (ContactModel c : this.find(null)) {
-            if (c.isLinkedToAndroidContact()) {
-                c.setAndroidContactLookupKey(null);
-                this.save(c);
-            }
-        }
-    }
-
-    @Override
-    @Deprecated
-    public int getUniqueId(@Nullable ContactModel contactModel) {
-        if (contactModel != null) {
-            return getUniqueId(contactModel.getIdentity());
-        } else {
-            return 0;
-        }
-    }
-
-    @Override
-    @Deprecated
-    public int getUniqueId(@NonNull String identity) {
-        return (CONTACT_UID_PREFIX + identity).hashCode();
-    }
-
-    @Override
-    public String getUniqueIdString(ContactModel contactModel) {
-        if (contactModel != null) {
-            return getUniqueIdString(contactModel.getIdentity());
-        }
-        return "";
-    }
-
-    @Override
-    public String getUniqueIdString(String identity) {
-        if (identity != null) {
-            try {
-                MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-                messageDigest.update((CONTACT_UID_PREFIX + identity).getBytes());
-                return Base32.encode(messageDigest.digest());
-            } catch (NoSuchAlgorithmException e) {
-                //
-            }
-        }
-        return "";
+        // TODO(ANDR-3172): Get all contacts via contact model repository
+        this.getAll()
+            .stream()
+            .filter(ContactModel::isLinkedToAndroidContact)
+            .map(m -> contactModelRepository.getByIdentity(m.getIdentity()))
+            .filter(Objects::nonNull)
+            .forEach(contactModel -> {
+                try {
+                    contactModel.removeAndroidContactLink();
+                } catch (ModelDeletedException e) {
+                    logger.info("Could not set android lookup key as model has been deleted");
+                }
+            });
     }
 
     @Override
-    public boolean setAvatar(final ContactModel contactModel, File temporaryAvatarFile) throws Exception {
+    public boolean setUserDefinedProfilePicture(
+        @Nullable final ContactModel contactModel,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    ) {
         if (contactModel != null && temporaryAvatarFile != null) {
-            if (this.fileService.writeContactAvatar(contactModel.getIdentity(), temporaryAvatarFile)) {
-                return this.onAvatarSet(contactModel);
+            if (this.fileService.writeUserDefinedProfilePicture(contactModel.getIdentity(), temporaryAvatarFile)) {
+                if (triggerSource != TriggerSource.SYNC && multiDeviceManager.isMultiDeviceActive()) {
+                    taskCreator.scheduleUserDefinedProfilePictureUpdate(contactModel.getIdentity());
+                }
+                return this.onUserDefinedProfilePictureSet(contactModel);
             }
         }
         return false;
     }
 
     @Override
-    public boolean setAvatar(@NonNull String identity, @Nullable File temporaryAvatarFile) throws Exception {
+    public boolean setUserDefinedProfilePicture(
+        @NonNull String identity,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    ) {
         ContactModel contactModel = getByIdentity(identity);
-        return setAvatar(contactModel, temporaryAvatarFile);
+        return setUserDefinedProfilePicture(contactModel, temporaryAvatarFile, triggerSource);
     }
 
     @Override
-    public boolean setAvatar(final ContactModel contactModel, byte[] avatar) throws Exception {
+    public boolean setUserDefinedProfilePicture(
+        @Nullable final ContactModel contactModel,
+        @Nullable byte[] avatar,
+        @NonNull TriggerSource triggerSource
+    ) throws IOException, MasterKeyLockedException {
         if (contactModel != null && avatar != null) {
-            if (this.fileService.writeContactAvatar(contactModel.getIdentity(), avatar)) {
-                return this.onAvatarSet(contactModel);
+            if (this.fileService.writeUserDefinedProfilePicture(contactModel.getIdentity(), avatar)) {
+                if (triggerSource != TriggerSource.SYNC && multiDeviceManager.isMultiDeviceActive()) {
+                    taskCreator.scheduleUserDefinedProfilePictureUpdate(contactModel.getIdentity());
+                }
+                return this.onUserDefinedProfilePictureSet(contactModel);
             }
         }
         return false;
     }
 
-    private boolean onAvatarSet(final ContactModel contactModel) {
-        this.clearAvatarCache(contactModel);
-
+    private boolean onUserDefinedProfilePictureSet(final ContactModel contactModel) {
         if (this.userService.isMe(contactModel.getIdentity())) {
-            // Update last profile picture upload date
-            this.preferenceService.setProfilePicUploadDate(new Date(0));
-            this.preferenceService.setProfilePicUploadData(null);
-
-            // Notify listeners
-            ListenerManager.profileListeners.handle(ProfileListener::onAvatarChanged);
+            logger.error("The users profile picture must not be set via contact service");
         } else {
-            ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel));
+            ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel.getIdentity()));
+            ShortcutUtil.updateShareTargetShortcut(createReceiver(contactModel));
         }
 
         return true;
     }
 
     @Override
-    public boolean removeAvatar(final ContactModel contactModel) {
-        if (contactModel != null) {
-            if (this.fileService.removeContactAvatar(contactModel.getIdentity())) {
-                this.clearAvatarCache(contactModel);
-
-                // Notify listeners
-                if (this.userService.isMe(contactModel.getIdentity())) {
-                    ListenerManager.profileListeners.handle(ProfileListener::onAvatarRemoved);
-                }
-                ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel));
-
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public void clearAvatarCache(@NonNull String identity) {
-        ContactModel contactModel = getByIdentity(identity);
-        if (contactModel != null) {
-            clearAvatarCache(contactModel);
-        }
-    }
-
-    @Override
-    @WorkerThread
-    @NonNull
-    public ProfilePictureUploadData getUpdatedProfilePictureUploadData() {
-        Bitmap contactPhoto;
-        try {
-            contactPhoto = getMyProfilePicture();
-        } catch (ThreemaException e) {
-            logger.error("Could not get my profile picture", e);
-            // Returning empty profile picture upload data means no set or delete profile picture
-            // message will be sent.
-            return new ProfilePictureUploadData();
-        }
-        if (contactPhoto == null) {
-            // If there is no profile picture set, then return empty upload data with an empty byte
-            // array as blob ID. This means, that a delete-profile-picture message will be sent.
-            ProfilePictureUploadData data = new ProfilePictureUploadData();
-            data.blobId = ContactModel.NO_PROFILE_PICTURE_BLOB_ID;
-            return data;
-        }
-
-        /* only upload blob every 7 days */
-        long uploadedAt = preferenceService.getProfilePicUploadDate();
-        Date uploadDeadline = new Date(uploadedAt + ContactUtil.PROFILE_PICTURE_BLOB_CACHE_DURATION);
-        Date now = new Date();
-
-        if (now.after(uploadDeadline)) {
-            logger.info("Uploading profile picture blob");
-
-            ProfilePictureUploadData data = uploadContactPhoto(contactPhoto);
-
-            if (data == null) {
-                return new ProfilePictureUploadData();
-            }
-
-            preferenceService.setProfilePicUploadDate(now);
-            preferenceService.setProfilePicUploadData(data);
-
-            data.uploadedAt = now.getTime();
-            return data;
-        } else {
-            ProfilePictureUploadData data = preferenceService.getProfilePicUploadData();
-            if (data != null) {
-                data.uploadedAt = uploadedAt;
-                return data;
-            } else {
-                return new ProfilePictureUploadData();
-            }
+    public boolean removeUserDefinedProfilePicture(
+        @Nullable final ContactModel contactModel,
+        @NonNull TriggerSource triggerSource
+    ) {
+        if (contactModel == null) {
+            logger.warn("Could not remove user defined profile picture as contact model is null");
+            return false;
         }
-    }
-
-    @WorkerThread
-    @Nullable
-    private Bitmap getMyProfilePicture() throws ThreemaException {
-        ContactModel myContactModel = getMe();
-        Bitmap myProfilePicture = getAvatar(myContactModel, true, false);
-        if (myProfilePicture == null && fileService.hasContactAvatarFile(myContactModel.getIdentity())) {
-            throw new ThreemaException("Could not load profile picture despite having set one");
+        if (userService.isMe(contactModel.getIdentity())) {
+            logger.error("The user's profile picture cannot be removed using the contact service");
+            return false;
         }
-        return myProfilePicture;
-    }
-
-    @Nullable
-    private ProfilePictureUploadData uploadContactPhoto(@NonNull Bitmap contactPhoto) {
-        ProfilePictureUploadData data = new ProfilePictureUploadData();
-
-        SecureRandom rnd = new SecureRandom();
-        data.encryptionKey = new byte[NaCl.SYMMKEYBYTES];
-        rnd.nextBytes(data.encryptionKey);
 
-        data.bitmapArray = BitmapUtil.bitmapToJpegByteArray(contactPhoto);
-        byte[] imageData = NaCl.symmetricEncryptData(data.bitmapArray, data.encryptionKey, ProtocolDefines.CONTACT_PHOTO_NONCE);
-        try {
-            BlobUploader blobUploader = this.apiService.createUploader(imageData);
-            data.blobId = blobUploader.upload();
-        } catch (ThreemaException | IOException e) {
-            logger.error("Could not upload contact photo", e);
-
-            if (e instanceof FileNotFoundException && ConfigUtils.isOnPremBuild()) {
-                logger.info("Invalidating auth token");
-                apiService.invalidateAuthToken();
+        if (this.fileService.removeUserDefinedProfilePicture(contactModel.getIdentity())) {
+            if (triggerSource != TriggerSource.SYNC && multiDeviceManager.isMultiDeviceActive()) {
+                taskCreator.scheduleUserDefinedProfilePictureUpdate(contactModel.getIdentity());
             }
-
-            return null;
+            ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel.getIdentity()));
+            return true;
         }
-        data.size = imageData.length;
-        return data;
-    }
 
-    @Override
-    public void resetContactPhotoSentState(@NonNull ContactModel contactModel) {
-        // Note that setting the blob id to null also triggers a delete-profile-picture message to
-        // be sent again in case there is no profile picture set.
-        contactModel.setProfilePicBlobID(null);
-        save(contactModel);
+        return false;
     }
 
     @Override
@@ -1393,15 +1033,15 @@ public class ContactServiceImpl implements ContactService {
             case PreferenceService.PROFILEPIC_RELEASE_EVERYONE:
                 policy = ProfilePictureSharePolicy.Policy.EVERYONE;
                 break;
-            case PreferenceService.PROFILEPIC_RELEASE_SOME:
-                policy = ProfilePictureSharePolicy.Policy.SOME;
+            case PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST:
+                policy = ProfilePictureSharePolicy.Policy.ALLOW_LIST;
                 break;
             default:
                 policy = ProfilePictureSharePolicy.Policy.NOBODY;
                 break;
         }
 
-        List<String> allowedIdentities = policy == ProfilePictureSharePolicy.Policy.SOME
+        List<String> allowedIdentities = policy == ProfilePictureSharePolicy.Policy.ALLOW_LIST
             ? Arrays.asList(profilePicRecipientsService.getAll())
             : Collections.emptyList();
 
@@ -1409,55 +1049,10 @@ public class ContactServiceImpl implements ContactService {
     }
 
     @Override
-    public boolean isContactAllowedToReceiveProfilePicture(@NonNull ContactModel contactModel) {
+    public boolean isContactAllowedToReceiveProfilePicture(@NonNull String identity) {
         int profilePicRelease = preferenceService.getProfilePicRelease();
         return profilePicRelease == PreferenceService.PROFILEPIC_RELEASE_EVERYONE ||
-            (profilePicRelease == PreferenceService.PROFILEPIC_RELEASE_SOME && profilePicRecipientsService.has(contactModel.getIdentity()));
-    }
-
-    @Override
-    public ContactModel createContactModelByIdentity(String identity) throws InvalidEntryException {
-        if (identity == null || identity.length() != ProtocolDefines.IDENTITY_LEN) {
-            throw new InvalidEntryException(R.string.invalid_threema_id);
-        }
-
-        //auto UPPERCASE identity
-        identity = identity.toUpperCase();
-
-        //check for existing
-        if (this.getByIdentity(identity) != null) {
-            throw new InvalidEntryException(R.string.contact_already_exists);
-        }
-
-        if (identity.equals(userService.getIdentity())) {
-            throw new InvalidEntryException(R.string.contact_already_exists);
-        }
-
-        if (!this.deviceService.isOnline()) {
-            throw new InvalidEntryException(R.string.connection_error);
-        }
-
-        ContactModel contact;
-        try {
-            contact = this.fetchPublicKeyForIdentity(identity);
-        } catch (APIConnector.HttpConnectionException e) {
-            logger.error("Could not fetch public key", e);
-            if (e.getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
-                throw new InvalidEntryException(R.string.invalid_threema_id);
-            } else {
-                throw new InvalidEntryException(R.string.connection_error);
-            }
-        } catch (APIConnector.NetworkException e) {
-            throw new InvalidEntryException(R.string.connection_error);
-        }
-
-        if (contact == null) {
-            throw new InvalidEntryException(R.string.invalid_threema_id);
-        }
-
-        save(contact);
-
-        return contact;
+            (profilePicRelease == PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST && profilePicRecipientsService.has(identity));
     }
 
     @Override
@@ -1513,64 +1108,6 @@ public class ContactServiceImpl implements ContactService {
         return contactLookupUri;
     }
 
-    /**
-     * Create a ContactModel for the provided Work contact. If a ContactModel already exists, it will be updated with the data from the Work API,
-     * namely. name, verification level, work status. If the contact was hidden (i.e. added by a group), it will be visible after this operation
-     *
-     * @param workContact          WorkContact object for the contact to add
-     * @param existingWorkContacts An optional list of ContactModels. If a ContactModel already exists for workContact, the ContactModel will be removed from this list
-     * @return ContactModel of created or updated contact or null if public key of provided WorkContact was invalid
-     */
-    @Override
-    @Nullable
-    public ContactModel addWorkContact(@NonNull WorkContact workContact, @Nullable List<ContactModel> existingWorkContacts) {
-        if (!ConfigUtils.isWorkBuild()) {
-            return null;
-        }
-
-        if (workContact.publicKey == null || workContact.publicKey.length != NaCl.PUBLICKEYBYTES) {
-            // ignore work contact with invalid public key
-            return null;
-        }
-
-        if (workContact.threemaId != null && workContact.threemaId.equals(getMe().getIdentity())) {
-            // do not add our own ID as a contact
-            return null;
-        }
-
-        ContactModel contactModel = getByIdentity(workContact.threemaId);
-
-        if (contactModel == null) {
-            contactModel = new ContactModel(workContact.threemaId, workContact.publicKey);
-        } else if (existingWorkContacts != null) {
-            // try to remove from list of existing work contacts
-            for (int x = 0; x < existingWorkContacts.size(); x++) {
-                if (existingWorkContacts.get(x).getIdentity().equals(workContact.threemaId)) {
-                    existingWorkContacts.remove(x);
-                    break;
-                }
-            }
-        }
-
-        if (
-            !contactModel.isLinkedToAndroidContact()
-                && (workContact.firstName != null || workContact.lastName != null)
-        ) {
-            contactModel.setFirstName(workContact.firstName);
-            contactModel.setLastName(workContact.lastName);
-        }
-        contactModel.setJobTitle(workContact.jobTitle);
-        contactModel.setDepartment(workContact.department);
-        contactModel.setIsWork(true);
-        contactModel.setAcquaintanceLevel(AcquaintanceLevel.DIRECT);
-        if (contactModel.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-            contactModel.verificationLevel = VerificationLevel.SERVER_VERIFIED;
-        }
-        this.save(contactModel);
-
-        return contactModel;
-    }
-
     @Override
     public void removeFromCache(@NonNull String identity) {
         synchronized (this.contactModelCache) {
@@ -1607,9 +1144,9 @@ public class ContactServiceImpl implements ContactService {
 
         try {
             // Otherwise try to fetch the identity
-            Contact contact = fetchPublicKeyForIdentity(identity);
-            if (contact != null) {
-                contactStore.addCachedContact(contact);
+            BasicContact contactModel = fetchPublicKeyForIdentity(identity);
+            if (contactModel != null) {
+                contactStore.addCachedContact(contactModel);
             }
         } catch (APIConnector.HttpConnectionException e) {
             if (e.getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
@@ -1628,72 +1165,24 @@ public class ContactServiceImpl implements ContactService {
      *
      * @param identity the identity of the contact that might be a work contact
      */
+    @WorkerThread
     private void fetchAndCreateWorkContact(@NonNull String identity) {
-        LicenseService.Credentials credentials = this.licenseService.loadCredentials();
-        if ((credentials instanceof UserCredentials)) {
-            try {
-                List<WorkContact> workContacts = apiConnector.fetchWorkContacts(((UserCredentials) credentials).username, ((UserCredentials) credentials).password, new String[]{identity});
-                if (workContacts.size() > 0) {
-                    WorkContact workContact = workContacts.get(0);
-                    addWorkContact(workContact, null);
-                }
-            } catch (Exception e) {
-                logger.error("Error fetching work contact", e);
-            }
-        }
-    }
-
-    /**
-     * Create a visible (i.e. non-hidden) contact by an identity fetch result but do NOT save it yet.
-     *
-     * @param result the result of the identity fetch
-     * @return the contact model if the fetch was successful, null otherwise
-     */
-    private @Nullable ContactModel createContactByFetchIdentityResult(
-        @Nullable APIConnector.FetchIdentityResult result
-    ) {
-        if (result == null || result.publicKey == null) {
-            return null;
-        }
-
-        byte[] b = result.publicKey;
-
-        ContactModel contact = new ContactModel(result.identity, b);
-        contact.setFeatureMask(result.featureMask);
-        contact.verificationLevel = VerificationLevel.UNVERIFIED;
-        contact.setDateCreated(new Date());
-        switch (result.type) {
-            case 0:
-                contact.setIdentityType(IdentityType.NORMAL);
-                break;
-            case 1:
-                contact.setIdentityType(IdentityType.WORK);
-                break;
-            default:
-                logger.warn("Identity fetch returned invalid identity type: {}", result.type);
-        }
-        switch (result.state) {
-            case IdentityState.ACTIVE:
-                contact.setState(ContactModel.State.ACTIVE);
-                break;
-            case IdentityState.INACTIVE:
-                contact.setState(ContactModel.State.INACTIVE);
-                break;
-            case IdentityState.INVALID:
-                contact.setState(ContactModel.State.INVALID);
-                break;
-        }
-
-        return contact;
+        new AddOrUpdateWorkIdentityBackgroundTask(
+            identity,
+            userService.getIdentity(),
+            licenseService,
+            apiConnector,
+            contactModelRepository
+        ).runSynchronously();
     }
 
     @Override
     @WorkerThread
-    public boolean resetReceiptsSettings() {
+    public void resetReceiptsSettings() {
         List<ContactModel> contactModels = find(new Filter() {
             @Override
-            public ContactModel.State[] states() {
-                return new ContactModel.State[]{ContactModel.State.ACTIVE, ContactModel.State.INACTIVE};
+            public IdentityState[] states() {
+                return new IdentityState[]{IdentityState.ACTIVE, IdentityState.INACTIVE};
             }
 
             @Override
@@ -1722,28 +1211,38 @@ public class ContactServiceImpl implements ContactService {
             }
         });
 
-        if (contactModels.size() > 0) {
-            for (ContactModel contactModel : contactModels) {
-                contactModel.setTypingIndicators(ContactModel.DEFAULT);
-                contactModel.setReadReceipts(ContactModel.DEFAULT);
-                save(contactModel);
-            }
-            return true;
-        }
-        return false;
+        contactModels
+            .stream()
+            .map(contactModel -> contactModelRepository.getByIdentity(contactModel.getIdentity()))
+            .forEach(contactModel -> {
+                if (contactModel != null) {
+                    contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.DEFAULT);
+                    contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.DEFAULT);
+                }
+            });
     }
 
     @Override
     @UiThread
-    public void reportSpam(@NonNull final ContactModel spammerContactModel, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure) {
+    public void reportSpam(@NonNull final String identity, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure) {
         new Thread(() -> {
             try {
-                apiConnector.reportJunk(identityStore, spammerContactModel.getIdentity(), spammerContactModel.getPublicNickName());
+                ch.threema.data.models.ContactModel spammerContactModel = contactModelRepository.getByIdentity(identity);
+                if (spammerContactModel == null) {
+                    logger.warn("No contact with identity {} found", identity);
+                    return;
+                }
+                ContactModelData contactModelData = spammerContactModel.getData().getValue();
+                if (contactModelData == null) {
+                    logger.warn("Contact model data for identity {} is null", identity);
+                    return;
+                }
+
+                apiConnector.reportJunk(identityStore, identity, contactModelData.nickname);
 
                 // Note: This is semantically wrong. Once we support multi-device, we probably
                 //       need to adapt the logic. Protocol discussions are ongoing.
-                spammerContactModel.setAcquaintanceLevel(AcquaintanceLevel.GROUP);
-                save(spammerContactModel);
+                spammerContactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.GROUP);
 
                 if (onSuccess != null) {
                     RuntimeUtil.runOnUiThread(() -> onSuccess.accept(null));
@@ -1794,10 +1293,10 @@ public class ContactServiceImpl implements ContactService {
      * @throws ch.threema.domain.protocol.api.APIConnector.NetworkException        when the identity cannot be fetched
      */
     @WorkerThread
-    private @Nullable ContactModel fetchPublicKeyForIdentity(@NonNull String identity) throws APIConnector.HttpConnectionException, APIConnector.NetworkException {
+    private @Nullable BasicContact fetchPublicKeyForIdentity(@NonNull String identity) throws APIConnector.HttpConnectionException, APIConnector.NetworkException {
         ContactModel contactModel = contactStore.getContactForIdentity(identity);
         if (contactModel != null) {
-            return contactModel;
+            return contactModel.toBasicContact();
         }
 
         APIConnector.FetchIdentityResult result;
@@ -1812,32 +1311,36 @@ public class ContactServiceImpl implements ContactService {
             throw new APIConnector.NetworkException(e);
         }
 
-        ContactModel contact = new ContactModel(identity, result.publicKey);
-        contact.setFeatureMask(result.featureMask);
-        contact.verificationLevel = VerificationLevel.UNVERIFIED;
-        contact.setDateCreated(new Date());
+        IdentityType identityType;
         switch (result.type) {
             case 0:
-                contact.setIdentityType(IdentityType.NORMAL);
+                identityType = IdentityType.NORMAL;
                 break;
             case 1:
-                contact.setIdentityType(IdentityType.WORK);
+                identityType = IdentityType.WORK;
                 break;
             default:
                 logger.warn("Identity fetch returned invalid identity type: {}", result.type);
-        }
-        switch (result.state) {
-            case IdentityState.ACTIVE:
-                contact.setState(ContactModel.State.ACTIVE);
-                break;
-            case IdentityState.INACTIVE:
-                contact.setState(ContactModel.State.INACTIVE);
-                break;
-            case IdentityState.INVALID:
-                contact.setState(ContactModel.State.INVALID);
-                break;
+                identityType = IdentityType.NORMAL;
+        }
+        IdentityState identityState;
+        if (result.state == IdentityState.ACTIVE.getValue()) {
+            identityState = IdentityState.ACTIVE;
+        } else if (result.state == IdentityState.INACTIVE.getValue()) {
+            identityState = IdentityState.INACTIVE;
+        } else if (result.state == IdentityState.INVALID.getValue()) {
+            identityState = IdentityState.INVALID;
+        } else {
+            logger.warn("Identity fetch returned invalid identity state: {}", result.state);
+            identityState = IdentityState.ACTIVE;
         }
 
-        return contact;
+        return BasicContact.javaCreate(
+            result.identity,
+            result.publicKey,
+            result.featureMask,
+            identityState,
+            identityType
+        );
     }
 }
diff --git a/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java b/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java
index 655b2f30..cf7b257f 100644
--- a/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java
+++ b/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java
@@ -29,9 +29,33 @@ import ch.threema.app.adapters.ContactsSyncAdapter;
 
 public class ContactsSyncAdapterService extends Service {
 
-	private ContactsSyncAdapter contactsSyncAdapter = null;
+	private static ContactsSyncAdapter contactsSyncAdapter = null;
 	private static final Object syncAdapterLock = new Object();
 
+	private static boolean isSyncEnabled = true;
+
+	public static void enableSync() {
+		synchronized (syncAdapterLock) {
+			isSyncEnabled = true;
+			setAdapterSyncEnabled();
+		}
+	}
+
+	public static void disableSync() {
+		synchronized (syncAdapterLock) {
+			isSyncEnabled = false;
+			setAdapterSyncEnabled();
+		}
+	}
+
+	private static void setAdapterSyncEnabled() {
+		synchronized (syncAdapterLock) {
+			if (contactsSyncAdapter != null) {
+				contactsSyncAdapter.setSyncEnabled(isSyncEnabled);
+			}
+		}
+	}
+
 	@Override
 	public void onCreate() {
 		super.onCreate();
@@ -39,6 +63,7 @@ public class ContactsSyncAdapterService extends Service {
 		synchronized (syncAdapterLock) {
 			if (contactsSyncAdapter == null) {
 				contactsSyncAdapter = new ContactsSyncAdapter(getApplicationContext(), true);
+				contactsSyncAdapter.setSyncEnabled(isSyncEnabled);
 			}
 		}
 	}
diff --git a/app/src/main/java/ch/threema/app/services/ConversationService.java b/app/src/main/java/ch/threema/app/services/ConversationService.java
index f1f474ff..28631a6f 100644
--- a/app/src/main/java/ch/threema/app/services/ConversationService.java
+++ b/app/src/main/java/ch/threema/app/services/ConversationService.java
@@ -161,15 +161,6 @@ public interface ConversationService {
 	 */
 	int empty(@NonNull MessageReceiver messageReceiver);
 
-	/**
-	 * Empty associated conversation (remove all messages).
-	 *
-	 * The message listener onRemoved method will *not* be called for removed messages.
-	 *
-	 * @return the number of removed messages.
-	 */
-	int empty(@NonNull ContactModel contactModel);
-
 	/**
 	 * Empty associated conversation (remove all messages).
 	 *
diff --git a/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java b/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java
index 6679364c..f3da3f3f 100644
--- a/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java
@@ -51,6 +51,7 @@ import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.MessageUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -245,20 +246,20 @@ public class ConversationServiceImpl implements ConversationService {
                     });
                 }
 
-                if (filter.noInvalid()) {
-                    logger.debug("filter chats with revoked contacts / left group that cannot receive messages");
-                    filtered = Functional.filter(filtered, new IPredicateNonNull<ConversationModel>() {
-                        @Override
-                        public boolean apply(@NonNull ConversationModel conversationModel) {
-                            if (conversationModel.isContactConversation()) {
-                                return conversationModel.getContact() != null && !(conversationModel.getContact().getState() == ContactModel.State.INVALID);
-                            } else if (conversationModel.isGroupConversation()) {
-                                return conversationModel.getGroup() != null && groupService.isGroupMember(conversationModel.getGroup());
-                            }
-                            return true;
-                        }
-                    });
-                }
+				if (filter.noInvalid()) {
+					logger.debug("filter chats with revoked contacts / left group that cannot receive messages");
+					filtered = Functional.filter(filtered, new IPredicateNonNull<ConversationModel>() {
+						@Override
+						public boolean apply(@NonNull ConversationModel conversationModel) {
+							if (conversationModel.isContactConversation()) {
+								return conversationModel.getContact() != null && conversationModel.getContact().getState() != IdentityState.INVALID;
+							} else if (conversationModel.isGroupConversation()) {
+								return conversationModel.getGroup() != null && groupService.isGroupMember(conversationModel.getGroup());
+							}
+							return true;
+						}
+					});
+				}
 
                 if (filter.onlyPersonal()) {
                     logger.debug("filter non-personal chats such as channels/broadcasts or blocked chats");
@@ -538,15 +539,14 @@ public class ConversationServiceImpl implements ConversationService {
 
     @Override
     public synchronized int empty(@NonNull MessageReceiver receiver) {
-        switch (receiver.getType()) {
-            case MessageReceiver.Type_CONTACT:
-                return this.empty(((ContactMessageReceiver) receiver).getContact());
-            case MessageReceiver.Type_GROUP:
-                return this.empty(((GroupMessageReceiver) receiver).getGroup());
-            case MessageReceiver.Type_DISTRIBUTION_LIST:
-                return this.empty(((DistributionListMessageReceiver) receiver).getDistributionList());
-            default:
-                throw new IllegalStateException("Got ReceiverModel with invalid receiver type!");
+        // First refresh the receiver. Otherwise it is possible that the conversation is null as it
+        // does not yet exist (or is just not yet loaded) and then the chat won't be emptied.
+        ConversationModel model = refresh(receiver);
+        if (model != null) {
+            return this.empty(model, true);
+        } else {
+            logger.error("Could not empty conversation as conversation model is null");
+            return 0;
         }
     }
 
@@ -576,11 +576,6 @@ public class ConversationServiceImpl implements ConversationService {
         return messages.size();
     }
 
-    @Override
-    public synchronized int empty(@NonNull ContactModel contactModel) {
-        return empty(contactModel.getIdentity());
-    }
-
     @Override
     public int empty(@NonNull String identity) {
         final ConversationModel conversationModel = new ContactConversationModelParser().getCached(identity);
diff --git a/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java b/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java
index ad16a1d8..e957cbf8 100644
--- a/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java
@@ -163,11 +163,6 @@ public class DistributionListServiceImpl implements DistributionListService {
 		avatarCacheService.loadDistributionListAvatarIntoImage(model, imageView, options, requestManager);
 	}
 
-	@Override
-	public void clearAvatarCache(@NonNull DistributionListModel model) {
-		// Nothing to do, as distribution list avatars currently aren't being cached
-	}
-
 	@Override
 	public @ColorInt int getAvatarColor(@Nullable DistributionListModel distributionList) {
 		if (distributionList != null) {
diff --git a/app/src/main/java/ch/threema/app/services/DownloadService.java b/app/src/main/java/ch/threema/app/services/DownloadService.java
index 2c4d7281..d8872d1f 100644
--- a/app/src/main/java/ch/threema/app/services/DownloadService.java
+++ b/app/src/main/java/ch/threema/app/services/DownloadService.java
@@ -21,18 +21,36 @@
 
 package ch.threema.app.services;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
 import ch.threema.base.ProgressListener;
+import ch.threema.domain.protocol.blob.BlobScope;
 
-public interface DownloadService{
-	@WorkerThread @Nullable byte[] download(int id, byte[] blobId, boolean markAsDown, @Nullable ProgressListener progressListener);
-	void complete(int id, byte[] blobId);
-	boolean cancel(int id);
+public interface DownloadService {
 
-	boolean isDownloading(int blobId);
+    /**
+     * @param blobScopeMarkAsDone If this field is <strong>not</strong> {@code null}, the blob will
+     *                            automatically be marked as "done" on the server. Of course only if
+     *                            the preceding download succeeded.
+     */
+    @WorkerThread
+    @Nullable
+    byte[] download(
+        int id,
+        @Nullable byte[] blobId,
+        @NonNull BlobScope blobScopeDownload,
+        @Nullable BlobScope blobScopeMarkAsDone,
+        @Nullable ProgressListener progressListener
+    );
 
-	boolean isDownloading();
+    void complete(int id, byte[] blobId);
 
-	void error(int id);
+    boolean cancel(int id);
+
+    boolean isDownloading(int blobId);
+
+    boolean isDownloading();
+
+    void error(int id);
 }
diff --git a/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java b/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java
index 45037752..e1368723 100644
--- a/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java
@@ -46,6 +46,7 @@ import ch.threema.base.ProgressListener;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.protocol.blob.BlobLoader;
+import ch.threema.domain.protocol.blob.BlobScope;
 
 public class DownloadServiceImpl implements DownloadService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("DownloadServiceImpl");
@@ -109,7 +110,7 @@ public class DownloadServiceImpl implements DownloadService {
 						messageModelId,
 						cancel);
 					if (cancel) {
-						download.blobLoader.cancel();
+						download.blobLoader.cancelDownload();
 					}
 					this.downloads.remove(download);
 				}
@@ -127,7 +128,13 @@ public class DownloadServiceImpl implements DownloadService {
 
 	@Override
 	@WorkerThread
-	public @Nullable byte[] download(int messageModelId, final byte[] blobId, boolean markAsDown, @Nullable ProgressListener progressListener) {
+	public @Nullable byte[] download(
+        int messageModelId,
+        final @Nullable byte[] blobId,
+        @NonNull BlobScope blobScopeDownload,
+        @Nullable BlobScope blobScopeMarkAsDone,
+        @Nullable ProgressListener progressListener
+    ) {
 		PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKELOCK_TAG);
 		try {
 			if (wakeLock != null) {
@@ -174,12 +181,12 @@ public class DownloadServiceImpl implements DownloadService {
 				}
 
 				if (progressListener != null) {
-					blobLoader.setProgressListener(progressListener);
+					blobLoader.progressListener = progressListener;
 				}
 
 				// Load blob from server
 				logger.info("Blob {} now fetching", blobIdHex);
-				blobBytes = blobLoader.load(false);
+				blobBytes = blobLoader.load(blobScopeDownload);
 
 				if (blobBytes != null) {
 					synchronized (this.downloads) {
@@ -197,8 +204,8 @@ public class DownloadServiceImpl implements DownloadService {
 								if (downloadFile.length() == blobBytes.length) {
 									downloadSuccess = true;
 
-									//ok download saved, set as down if set
-									if (markAsDown) {
+									//ok download saved, set as done if set
+									if (blobScopeMarkAsDone != null) {
 										logger.info("Blob {} scheduled for marking as downloaded", blobIdHex);
 										try {
 											new Thread(() -> {
@@ -208,7 +215,7 @@ public class DownloadServiceImpl implements DownloadService {
 												}
 												if (download != null) {
 													if (download.blobLoader != null) {
-														download.blobLoader.markAsDone(download.blobId);
+														download.blobLoader.markAsDone(download.blobId, blobScopeMarkAsDone);
 													}
 													logger.info("Blob {} marked as downloaded", blobIdHex);
 												}
diff --git a/app/src/main/java/ch/threema/app/services/FileService.java b/app/src/main/java/ch/threema/app/services/FileService.java
index cb0ada78..7041af75 100644
--- a/app/src/main/java/ch/threema/app/services/FileService.java
+++ b/app/src/main/java/ch/threema/app/services/FileService.java
@@ -128,9 +128,9 @@ public interface FileService {
 	 */
 	File createWallpaperFile(MessageReceiver messageReceiver) throws IOException;
 
-	boolean hasContactAvatarFile(@NonNull String identity);
+	boolean hasUserDefinedProfilePicture(@NonNull String identity);
 
-	boolean hasContactPhotoFile(@NonNull String identity);
+	boolean hasContactDefinedProfilePicture(@NonNull String identity);
 
 	/**
 	 * decrypt a file and save into a new one
@@ -194,93 +194,107 @@ public interface FileService {
 	 */
 	boolean writeConversationMedia(AbstractMessageModel messageModel, byte[] data, int pos, int length, boolean overwrite) throws Exception;
 
-	/**
-	 * Save a group avatar (resize if needed) and return true on success.
-	 */
-	boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws Exception;
+    /**
+     * Save a group avatar (resize if needed) and return true on success. Additionally, this resets
+     * the avatar cache for this group.
+     */
+	boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * get the group avatar as InputStream
 	 */
-	InputStream getGroupAvatarStream(GroupModel groupModel) throws Exception;
+	InputStream getGroupAvatarStream(GroupModel groupModel) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * get the group avatar if the file exists
 	 */
-	Bitmap getGroupAvatar(GroupModel groupModel) throws Exception;
+	Bitmap getGroupAvatar(GroupModel groupModel) throws IOException, MasterKeyLockedException;
 
 	/**
-	 * remove the group avatar
+	 * Remove the group avatar. Additionally, this resets the avatar cache for this group.
 	 */
-	void removeGroupAvatar(GroupModel groupModel);
+	void removeGroupAvatar(@NonNull GroupModel groupModel);
 
 	boolean hasGroupAvatarFile(GroupModel groupModel);
 
-	/**
-	 * write the contact avatar
-	 */
-	boolean writeContactAvatar(@NonNull String identity, File file) throws Exception;
+    /**
+     * Write the contact profile picture set by the user. Additionally, this resets the avatar cache
+     * for this contact.
+     */
+	boolean writeUserDefinedProfilePicture(@NonNull String identity, File file);
 
 	/**
-	 * write the contact avatar
+	 * Write the contact profile picture set by the user. Additionally, this resets the avatar cache
+     * for this contact.
 	 */
-	boolean writeContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception;
+	boolean writeUserDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws IOException, MasterKeyLockedException;
 
 	/**
-	 * write the contact photo received by the contact
+	 * Write the contact profile picture received by the contact. Additionally, this resets the
+     * avatar cache for this contact.
 	 */
-	boolean writeContactPhoto(@NonNull String identity, byte[] encryptedBlob) throws Exception;
+	boolean writeContactDefinedProfilePicture(@NonNull String identity, byte[] encryptedBlob) throws IOException, MasterKeyLockedException;
 
 	/**
-	 * write the contact avatar from Android's address book
+	 * Write the contact profile picture from Android's address book. Additionally, this resets the
+     * avatar cache for this contact.
 	 */
-	boolean writeAndroidContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception;
+	boolean writeAndroidDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws Exception;
 
 	/**
 	 * return the decrypted bitmap of a contact avatar
 	 * if no file exists, null will be returned
 	 */
-	Bitmap getContactAvatar(@NonNull String identity) throws Exception;
+	Bitmap getUserDefinedProfilePicture(@NonNull String identity) throws Exception;
 
-	Bitmap getAndroidContactAvatar(@NonNull ContactModel contactModel) throws Exception;
+	Bitmap getAndroidDefinedProfilePicture(@NonNull ContactModel contactModel) throws Exception;
 
 	/**
 	 * Return a input stream of a local saved contact avatar
 	 */
-	InputStream getContactAvatarStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
+	InputStream getUserDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * Return a input stream of a contact photo
 	 */
-	InputStream getContactPhotoStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
+	InputStream getContactDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * return the decrypted bitmap of a contact-provided profile picture
 	 * returns null if no file exists
 	 */
-	Bitmap getContactPhoto(@NonNull String identity) throws Exception;
+	Bitmap getContactDefinedProfilePicture(@NonNull String identity) throws Exception;
 
 	/**
-	 * remove the saved avatar
-	 * return true if the avatar was deleted, false if the remove failed or no avatar file exists
-	 */
-	boolean removeContactAvatar(@NonNull String identity);
+     * Remove the user defined profile picture for the contact with the given identity.
+     * Additionally, this resets the avatar cache for this contact.
+     *
+     * @param identity the identity of the contact
+     * @return true if the avatar was deleted, false if the remove failed or no avatar file exists
+     */
+	boolean removeUserDefinedProfilePicture(@NonNull String identity);
 
-	/**
-	 * remove the saved profile pic for this contact
-	 * @param identity the identity of the contact
-	 * @return true if avatar was deleted, false if the remove failed or no avatar file exists
-	 */
-	boolean removeContactPhoto(@NonNull String identity);
+    /**
+     * Remove the contact defined profile picture for the contact with the given identity.
+     * Additionally, this resets the avatar cache for this contact.
+     *
+     * @param identity the identity of the contact
+     * @return true if avatar was deleted, false if the remove failed or no avatar file exists
+     */
+	boolean removeContactDefinedProfilePicture(@NonNull String identity);
 
 	/**
-	 * remove the saved avatar from Android's address book
-	 * return true if the avatar was deleted, false if the remove failed or no avatar file exists
+	 * Remove the profile picture from Android's address book. Additionally, this resets the avatar
+     * cache for this contact.
+     *
+     * @param identity the identity of the contact
+	 * @return true if the avatar was deleted, false if the remove failed or no avatar file exists
 	 */
-	boolean removeAndroidContactAvatar(@NonNull String identity);
+	boolean removeAndroidDefinedProfilePicture(@NonNull String identity);
 
 	/**
-	 * remove all avatars in the respective directory
+	 * Remove all avatars in the respective directory. Note that this does *not* reset the avatar
+     * caches.
 	 */
 	void removeAllAvatars();
 
diff --git a/app/src/main/java/ch/threema/app/services/FileServiceImpl.java b/app/src/main/java/ch/threema/app/services/FileServiceImpl.java
index 7fb48ce8..512471cc 100644
--- a/app/src/main/java/ch/threema/app/services/FileServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/FileServiceImpl.java
@@ -139,10 +139,19 @@ public class FileServiceImpl implements FileService {
 	private final File appDataPath;
 	private final File backupPath;
 
-	public FileServiceImpl(Context c, MasterKey masterKey, PreferenceService preferenceService) {
+    @NonNull
+    private final AvatarCacheService avatarCacheService;
+
+	public FileServiceImpl(
+        @NonNull Context c,
+        @NonNull MasterKey masterKey,
+        @NonNull PreferenceService preferenceService,
+        @NonNull AvatarCacheService avatarCacheService
+    ) {
 		this.context = c;
 		this.preferenceService = preferenceService;
 		this.masterKey = masterKey;
+        this.avatarCacheService = avatarCacheService;
 
 		String mediaPathPrefix = Environment.getExternalStorageDirectory() + "/" + BuildConfig.MEDIA_PATH + "/";
 
@@ -491,14 +500,14 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean hasContactAvatarFile(@NonNull String identity) {
+	public boolean hasUserDefinedProfilePicture(@NonNull String identity) {
 		File avatar = getContactAvatarFile(identity);
 
 		return avatar != null && avatar.exists();
 	}
 
 	@Override
-	public boolean hasContactPhotoFile(@NonNull String identity) {
+	public boolean hasContactDefinedProfilePicture(@NonNull String identity) {
 		File avatar = getContactPhotoFile(identity);
 
 		return avatar != null && avatar.exists();
@@ -524,6 +533,7 @@ public class FileServiceImpl implements FileService {
 		return getPictureFile(getAvatarDirPath(), ".p-", identity);
 	}
 
+	@Nullable
 	private File getAndroidContactAvatarFile(@NonNull String identity) {
 		return getPictureFile(getAvatarDirPath(), ".a-", identity);
 	}
@@ -928,12 +938,16 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws Exception {
-		return this.writeFile(photoData, new File(getGroupAvatarDirPath(), getGroupAvatarFileName(groupModel)));
+	public boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(photoData, new File(getGroupAvatarDirPath(), getGroupAvatarFileName(groupModel)));
+        if (success) {
+            avatarCacheService.reset(groupModel);
+        }
+        return success;
 	}
 
 	@Override
-	public InputStream getGroupAvatarStream(GroupModel groupModel) throws Exception {
+	public InputStream getGroupAvatarStream(GroupModel groupModel) throws IOException, MasterKeyLockedException {
 		File f = this.getGroupAvatarFile(groupModel);
 		if (f.exists()) {
 			return masterKey.getCipherInputStream(new FileInputStream(f));
@@ -943,19 +957,20 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public Bitmap getGroupAvatar(GroupModel groupModel) throws Exception {
+	public Bitmap getGroupAvatar(GroupModel groupModel) throws IOException, MasterKeyLockedException {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
 		return decryptBitmapFromFile(this.getGroupAvatarFile(groupModel));
 	}
 
 	@Override
-	public void removeGroupAvatar(GroupModel groupModel) {
+	public void removeGroupAvatar(@NonNull GroupModel groupModel) {
 		File f = this.getGroupAvatarFile(groupModel);
 		if (f.exists()) {
 			FileUtil.deleteFileOrWarn(f, "removeGroupAvatar", logger);
+            avatarCacheService.reset(groupModel);
 		}
 	}
 
@@ -967,38 +982,54 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean writeContactAvatar(@NonNull String identity, File file) throws Exception {
-		return this.decryptFileToFile(file, this.getContactAvatarFile(identity));
+	public boolean writeUserDefinedProfilePicture(@NonNull String identity, File file) {
+		boolean success = this.decryptFileToFile(file, this.getContactAvatarFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean writeContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception {
-		return this.writeFile(avatarFile, this.getContactAvatarFile(identity));
+	public boolean writeUserDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(avatarFile, this.getContactAvatarFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean writeContactPhoto(@NonNull String identity, byte[] encryptedBlob) throws Exception {
-		return this.writeFile(encryptedBlob, this.getContactPhotoFile(identity));
+	public boolean writeContactDefinedProfilePicture(@NonNull String identity, byte[] encryptedBlob) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(encryptedBlob, this.getContactPhotoFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean writeAndroidContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception {
-		return this.writeFile(avatarFile, this.getAndroidContactAvatarFile(identity));
+	public boolean writeAndroidDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(avatarFile, this.getAndroidContactAvatarFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public Bitmap getContactAvatar(@NonNull String identity) throws Exception {
+	public Bitmap getUserDefinedProfilePicture(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
 		return decryptBitmapFromFile(this.getContactAvatarFile(identity));
 	}
 
 	@Override
-	public Bitmap getAndroidContactAvatar(@NonNull ContactModel contactModel) throws Exception {
+	public Bitmap getAndroidDefinedProfilePicture(@NonNull ContactModel contactModel) throws Exception {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
 		long now = System.currentTimeMillis();
@@ -1006,9 +1037,13 @@ public class FileServiceImpl implements FileService {
 		if (expiration < now) {
 			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
 			if (serviceManager != null) {
-				if (AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contactModel)) {
-					ContactService contactService = serviceManager.getContactService();
-					contactService.save(contactModel);
+				try {
+					if (AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contactModel)) {
+						ContactService contactService = serviceManager.getContactService();
+						contactService.save(contactModel);
+					}
+				} catch (SecurityException e) {
+					logger.error("Could not update avatar by android contact", e);
 				}
 			}
 		}
@@ -1017,7 +1052,7 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public InputStream getContactAvatarStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
+	public InputStream getUserDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		File f = this.getContactAvatarFile(identity);
 		if (f != null && f.exists() && f.length() > 0) {
 			return masterKey.getCipherInputStream(new FileInputStream(f));
@@ -1027,7 +1062,7 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public InputStream getContactPhotoStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
+	public InputStream getContactDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		File f = this.getContactPhotoFile(identity);
 		if (f != null && f.exists() && f.length() > 0) {
 			return masterKey.getCipherInputStream(new FileInputStream(f));
@@ -1036,18 +1071,15 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public Bitmap getContactPhoto(@NonNull String identity) throws Exception {
+	public Bitmap getContactDefinedProfilePicture(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
-		if (this.preferenceService.getProfilePicReceive()) {
-			return decryptBitmapFromFile(this.getContactPhotoFile(identity));
-		}
-		return null;
+		return decryptBitmapFromFile(this.getContactPhotoFile(identity));
 	}
 
-	private Bitmap decryptBitmapFromFile(@Nullable File file) throws Exception {
+	private Bitmap decryptBitmapFromFile(@Nullable File file) throws IOException, MasterKeyLockedException {
 		if (file != null && file.exists()) {
 			InputStream inputStream = masterKey.getCipherInputStream(new FileInputStream(file));
 			if (inputStream != null) {
@@ -1062,21 +1094,33 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean removeContactAvatar(@NonNull String identity) {
+	public boolean removeUserDefinedProfilePicture(@NonNull String identity) {
 		File f = this.getContactAvatarFile(identity);
-		return f != null && f.exists() && f.delete();
+		boolean success = f != null && f.exists() && f.delete();
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean removeContactPhoto(@NonNull String identity) {
+	public boolean removeContactDefinedProfilePicture(@NonNull String identity) {
 		File f = this.getContactPhotoFile(identity);
-		return f != null && f.exists() && f.delete();
+		boolean success = f != null && f.exists() && f.delete();
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean removeAndroidContactAvatar(@NonNull String identity) {
+	public boolean removeAndroidDefinedProfilePicture(@NonNull String identity) {
 		File f = this.getAndroidContactAvatarFile(identity);
-		return f != null && f.exists() && f.delete();
+		boolean success = f != null && f.exists() && f.delete();
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
@@ -1088,8 +1132,8 @@ public class FileServiceImpl implements FileService {
 		}
 	}
 
-	private boolean writeFile(byte[] data, File file) throws Exception {
-		if (data != null && data.length > 0) {
+	private boolean writeFile(@Nullable byte[] data, @Nullable File file) throws IOException, MasterKeyLockedException {
+		if (data != null && data.length > 0 && file != null) {
 			try (FileOutputStream fileOutputStream = new FileOutputStream(file); CipherOutputStream cipherOutputStream = this.masterKey.getCipherOutputStream(fileOutputStream)) {
 				cipherOutputStream.write(data);
 				return true;
@@ -1101,7 +1145,7 @@ public class FileServiceImpl implements FileService {
 		return false;
 	}
 
-	private boolean writeFile(byte[] data, int pos, int length, File file) throws Exception {
+	private boolean writeFile(byte[] data, int pos, int length, File file) throws IOException, MasterKeyLockedException {
 		if (data != null && data.length > 0) {
 			try (FileOutputStream fileOutputStream = new FileOutputStream(file); CipherOutputStream cipherOutputStream = this.masterKey.getCipherOutputStream(fileOutputStream)) {
 				cipherOutputStream.write(data, pos, length);
diff --git a/app/src/main/java/ch/threema/app/services/GroupService.java b/app/src/main/java/ch/threema/app/services/GroupService.java
index 95cbf3f3..8db28b7a 100644
--- a/app/src/main/java/ch/threema/app/services/GroupService.java
+++ b/app/src/main/java/ch/threema/app/services/GroupService.java
@@ -25,10 +25,6 @@ import android.app.Activity;
 import android.content.Intent;
 import android.graphics.Bitmap;
 
-import androidx.annotation.IntDef;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collection;
@@ -36,15 +32,17 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.messagereceiver.GroupMessageReceiver;
-import ch.threema.app.processors.groupcontrol.IncomingGroupSetupTask;
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupSetupTask;
 import ch.threema.app.utils.GroupFeatureSupport;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
 import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.GroupMemberModel;
 import ch.threema.storage.models.GroupMessageModel;
 import ch.threema.storage.models.GroupModel;
 import ch.threema.storage.models.MessageState;
@@ -200,12 +198,13 @@ public interface GroupService extends AvatarService<GroupModel> {
 	) throws Exception;
 
 	/**
-	 * Add a member to a group. Will fetch the identity from the server if not known. If "block
-	 * unknown" is enabled, the contact (and group member) will not be created if not already in
-	 * contacts. Note that this does not fire any listeners nor sending any messages.
+	 * Add a member to a group. Note that the user's identity must not be added to the member list
+	 * and is therefore ignored by this method. If the contact does not exist, the identity won't be
+	 * added to the members list. Note that this does not fire any listeners nor sending any
+	 * messages.
 	 *
 	 * @return true if the identity is added or already in the group, false if no contact with this
-	 * identity exists
+	 * identity exists or it is the user's identity
 	 */
 	boolean addMemberToGroup(@NonNull GroupModel groupModel, @NonNull String identity);
 
@@ -278,35 +277,31 @@ public interface GroupService extends AvatarService<GroupModel> {
 	void leaveGroupFromLocal(@NonNull GroupModel groupModel);
 
 	/**
-	 * Return the member identities of the group except the user.
+	 * Get the group members including the group creator and the user (if the creator or user are
+	 * members).
+	 *
+	 * @param groupModel the group model
+	 * @return a list of the contact models
 	 */
 	@NonNull
-	Set<String> getOtherMembers(@NonNull GroupModel groupModel);
+	Collection<ContactModel> getMembers(@NonNull GroupModel groupModel);
 
 	/**
-	 * Return the identities of all members of this group including the creator and including the current user
+	 * Return the identities of all members of this group including the creator (if the creator has
+	 * not left the group) and the user (if the user is part of the group). To check whether the
+	 * user is a member of the group, use {@link #isGroupMember(GroupModel)}.
+	 *
 	 * @param groupModel Group model of the group
 	 * @return String array of identities (i.e. Threema IDs)
 	 */
 	@NonNull String[] getGroupIdentities(@NonNull GroupModel groupModel);
 
 	/**
-	 * Return the group member models of the group. This includes the group creator - except in
-	 * orphaned groups.
-	 *
-	 * @param groupModel the group model
-	 * @return a list of the group members
-	 */
-	List<GroupMemberModel> getGroupMemberModels(@NonNull GroupModel groupModel);
-
-	/**
-	 * Get the group members including the group creator.
-	 *
-	 * @param groupModel the group model
-	 * @return a list of the contact models
+	 * Return the member identities (including the creator if part of the group) of the group except
+	 * the user.
 	 */
 	@NonNull
-	Collection<ContactModel> getMembers(@NonNull GroupModel groupModel);
+	Set<String> getMembersWithoutUser(@NonNull GroupModel groupModel);
 
 	/**
 	 * Get a string where the group members' display names are concatenated and separated by a
@@ -344,6 +339,16 @@ public interface GroupService extends AvatarService<GroupModel> {
 	 */
 	boolean isGroupMember(@NonNull GroupModel groupModel);
 
+	/**
+	 * Check whether the given identity is part of the group. Note that the group creator is also a
+	 * member.
+	 *
+	 * @param groupModel the group model
+	 * @param identity   the identity that is checked
+	 * @return {@code true} if the identity belongs to a group member, {@code false} otherwise
+	 */
+	boolean isGroupMember(@NonNull GroupModel groupModel, @NonNull String identity);
+
 	/**
 	 * Check whether the group is orphaned or not. In an orphaned group, the group creator is not a
 	 * member. Additionally, the user must not be the creator, otherwise it is a dissolved group.
@@ -358,7 +363,7 @@ public interface GroupService extends AvatarService<GroupModel> {
 	boolean isOrphanedGroup(@NonNull GroupModel groupModel);
 
 	/**
-	 * Count members in a group. This includes the group creator.
+	 * Count members in a group. This includes the group creator and the user.
 	 *
 	 * @param groupModel the group model
 	 * @return Number of members in this group including group creator and the current user
@@ -391,7 +396,7 @@ public interface GroupService extends AvatarService<GroupModel> {
 	 * @param model the group model
 	 * @return the number of other members
 	 */
-	int getOtherMemberCount(@NonNull GroupModel model);
+	int countMembersWithoutUser(@NonNull GroupModel model);
 
 	/**
 	 * Get a map from the group member identity to its id color index.
diff --git a/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java b/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java
index 66837f22..6a44e5cb 100644
--- a/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java
@@ -227,14 +227,15 @@ public class GroupServiceImpl implements GroupService {
 		String[] identities = getGroupIdentities(groupModel);
 		scheduleEmptyGroupSetup(groupModel, Set.of(identities));
 
-		// Remove me from the group members
-		removeMemberFromGroup(groupModel, userService.getIdentity());
+		// Do not remove user from members: just set the user state of the group
+		groupModel.setUserState(GroupModel.UserState.LEFT);
+		save(groupModel);
 
 		// Update the rejected message states
 		runRejectedMessagesRefreshSteps(groupModel);
 
 		// Trigger listener
-		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, myIdentity, identities.length));
+		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, myIdentity));
 		ListenerManager.groupListeners.handle(listener -> listener.onLeave(groupModel));
 	}
 
@@ -245,14 +246,14 @@ public class GroupServiceImpl implements GroupService {
 			return;
 		}
 
-		String[] identities = this.getGroupIdentities(groupModel);
+		Set<String> identities = this.getMembersWithoutUser(groupModel);
 
 		// Send group leave to all members
-		scheduleGroupLeave(groupModel, Set.of(identities));
+		scheduleGroupLeave(groupModel, identities);
 
-		// Remove only me from the members
-		String myIdentity = userService.getIdentity();
-		removeMemberFromGroup(groupModel, myIdentity);
+		// Do not remove user from members: just set the user state of the group
+		groupModel.setUserState(GroupModel.UserState.LEFT);
+		save(groupModel);
 
 		// Update the rejected message states
 		runRejectedMessagesRefreshSteps(groupModel);
@@ -264,7 +265,7 @@ public class GroupServiceImpl implements GroupService {
 		this.resetIdentityCache(groupModel.getId());
 
 		// Fire group left listener
-		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, myIdentity, identities.length));
+		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, userService.getIdentity()));
 		ListenerManager.groupListeners.handle(listener -> listener.onLeave(groupModel));
 		updateAllowedCallParticipants(groupModel);
 	}
@@ -486,12 +487,12 @@ public class GroupServiceImpl implements GroupService {
 			.setCreatorIdentity(creatorIdentity)
 			.setCreatedAt(now)
 			.setLastUpdate(now)
-			.setSynchronizedAt(now);
+			.setSynchronizedAt(now)
+			.setUserState(GroupModel.UserState.MEMBER);
 		this.databaseServiceNew.getGroupModelFactory().create(groupModel);
 		this.cache(groupModel);
 
-		// Add members to group (including own identity)
-		this.addMemberToGroup(groupModel, creatorIdentity);
+		// Add members to group (do not include the user's identity)
 		for (String identity : groupMemberIdentities) {
 			this.addMemberToGroup(groupModel, identity);
 		}
@@ -499,7 +500,7 @@ public class GroupServiceImpl implements GroupService {
 		// Notify listeners
 		for (String memberIdentity : groupMemberIdentities) {
 			ListenerManager.groupListeners.handle(listener ->
-				listener.onNewMember(groupModel, memberIdentity, 0)
+				listener.onNewMember(groupModel, memberIdentity)
 			);
 		}
 		ListenerManager.groupListeners.handle(listener -> listener.onCreate(groupModel));
@@ -518,6 +519,11 @@ public class GroupServiceImpl implements GroupService {
 	public boolean addMemberToGroup(@NonNull final GroupModel groupModel, @NonNull final String identity) {
 		final GroupMemberModel memberModel = this.getGroupMember(groupModel, identity);
 
+		if (userService.getIdentity().equals(identity)) {
+			logger.warn("User should not be added to member list");
+			return false;
+		}
+
 		if (memberModel == null) {
 			// Do not add the member to the group if it is already in the group or there is no contact
 			// with that ID. Note that the contacts for the valid identities have been created at this
@@ -660,15 +666,13 @@ public class GroupServiceImpl implements GroupService {
 		Set<String> kickedGroupMembers = new HashSet<>(existingMembers);
 		kickedGroupMembers.removeAll(updatedGroupMembers);
 
-		int previousMemberCount = countMembers(groupModel);
-
 		// Remove the kicked members from the database
 		for (final String kickedIdentity : kickedGroupMembers) {
 			logger.debug("Remove member {} from group", kickedIdentity);
 			removeMemberFromGroup(groupModel, kickedIdentity);
 
 			ListenerManager.groupListeners.handle(listener ->
-				listener.onMemberKicked(groupModel, kickedIdentity, previousMemberCount)
+				listener.onMemberKicked(groupModel, kickedIdentity)
 			);
 		}
 
@@ -725,6 +729,7 @@ public class GroupServiceImpl implements GroupService {
 				// If there was a change, then the method above already dealt with sending sync
 				// messages to all members (including new members).
 				sendPictureToNewMembers = false;
+                ShortcutUtil.updateShareTargetShortcut(createReceiver(groupModel));
 			}
 		}
 		if (sendPictureToNewMembers && hasNewMembers) {
@@ -742,7 +747,7 @@ public class GroupServiceImpl implements GroupService {
 		// members and must therefore be called *after* the group setup has been sent.
 		for (String newMember : newMembers) {
 			ListenerManager.groupListeners.handle(listener ->
-				listener.onNewMember(groupModel, newMember, previousMemberCount)
+				listener.onNewMember(groupModel, newMember)
 			);
 		}
 
@@ -960,7 +965,7 @@ public class GroupServiceImpl implements GroupService {
 
 	@NonNull
 	@Override
-	public Set<String> getOtherMembers(@NonNull GroupModel groupModel) {
+	public Set<String> getMembersWithoutUser(@NonNull GroupModel groupModel) {
 		Set<String> otherMembers = new HashSet<>(Arrays.asList(getGroupIdentities(groupModel)));
 		otherMembers.remove(userService.getIdentity());
 		return otherMembers;
@@ -976,9 +981,23 @@ public class GroupServiceImpl implements GroupService {
 			}
 
 			List<GroupMemberModel> memberModels = this.getGroupMemberModels(groupModel);
-			String[] res = new String[memberModels.size()];
+			boolean isGroupMember = isGroupMember(groupModel);
+
+			String[] res;
+			int arrayIndexOffset;
+			if (isGroupMember) {
+				res = new String[memberModels.size() + 1];
+				arrayIndexOffset = 1;
+				// Include the user in the array if it is a member. Note that this is required as the
+				// user is never stored as a group member.
+				res[0] = userService.getIdentity();
+			} else {
+				res = new String[memberModels.size()];
+				arrayIndexOffset = 0;
+			}
+
 			for (int i = 0; i < memberModels.size(); i++) {
-				res[i] = memberModels.get(i).getIdentity();
+				res[i + arrayIndexOffset] = memberModels.get(i).getIdentity();
 			}
 
 			this.groupIdentityCache.put(groupModel.getId(), res);
@@ -986,8 +1005,18 @@ public class GroupServiceImpl implements GroupService {
 		}
 	}
 
-	private boolean isGroupMember(@NonNull GroupModel groupModel, @Nullable String identity) {
+	@Override
+	public boolean isGroupMember(@NonNull GroupModel groupModel) {
+		return groupModel.getUserState() == GroupModel.UserState.MEMBER;
+	}
+
+	@Override
+	public boolean isGroupMember(@NonNull GroupModel groupModel, @Nullable String identity) {
 		if (!TestUtil.isEmptyOrNull(identity)) {
+			if (userService.getIdentity().equals(identity)) {
+				return isGroupMember(groupModel);
+			}
+
 			for (String existingIdentity : this.getGroupIdentities(groupModel)) {
 				if (TestUtil.compare(existingIdentity, identity)) {
 					return true;
@@ -997,21 +1026,29 @@ public class GroupServiceImpl implements GroupService {
 		return false;
 	}
 
-	@Override
-	public boolean isGroupMember(@NonNull GroupModel groupModel) {
-		return isGroupMember(groupModel, userService.getIdentity());
-	}
-
 	@Override
 	public boolean isOrphanedGroup(@NonNull GroupModel groupModel) {
 		return !isGroupMember(groupModel, groupModel.getCreatorIdentity()) && !isGroupCreator(groupModel);
 	}
 
-	@Override
-	public List<GroupMemberModel> getGroupMemberModels(@NonNull GroupModel groupModel) {
-		return this.databaseServiceNew.getGroupMemberModelFactory().getByGroupId(
-			groupModel.getId()
-		);
+	/**
+	 * Get the group member models of the given group. Note that the user is not part of this list.
+	 */
+	private List<GroupMemberModel> getGroupMemberModels(@NonNull GroupModel groupModel) {
+		List<GroupMemberModel> groupMemberModels = databaseServiceNew
+			.getGroupMemberModelFactory()
+			.getByGroupId(groupModel.getId());
+
+		// Remove own identity. Note that the user's identity should never be stored as member.
+		// This is just a check to ensure correct behavior even if the member list is wrong.
+		String myIdentity = userService.getIdentity();
+		if (groupMemberModels.removeIf(
+			groupMemberModel -> myIdentity.equals(groupMemberModel.getIdentity())
+		)) {
+			logger.warn("User is contained as member in group");
+		}
+
+		return groupMemberModels;
 	}
 
 	/**
@@ -1094,11 +1131,6 @@ public class GroupServiceImpl implements GroupService {
 		return ColorUtil.getInstance().getCurrentThemeGray(this.context);
 	}
 
-	@Override
-	public void clearAvatarCache(@NonNull GroupModel model) {
-		avatarCacheService.reset(model);
-	}
-
 	@Override
 	public boolean isGroupCreator(GroupModel groupModel) {
 		return groupModel != null
@@ -1114,7 +1146,8 @@ public class GroupServiceImpl implements GroupService {
 				return existingIdentities.length;
 			}
 		}
-		return (int) this.databaseServiceNew.getGroupMemberModelFactory().countMembers(groupModel.getId());
+		int userMemberCount = groupModel.getUserState() == GroupModel.UserState.MEMBER ? 1 : 0;
+		return (int) this.databaseServiceNew.getGroupMemberModelFactory().countMembersWithoutUser(groupModel.getId()) + userMemberCount;
 	}
 
 	@Override
@@ -1125,15 +1158,10 @@ public class GroupServiceImpl implements GroupService {
 	}
 
 	@Override
-	public int getOtherMemberCount(@NonNull GroupModel groupModel) {
-		int count = 0;
-		String[] identities = this.getGroupIdentities(groupModel);
-		for (String identity : identities) {
-			if (!this.userService.isMe(identity)) {
-				count++;
-			}
-		}
-		return count;
+	public int countMembersWithoutUser(@NonNull GroupModel groupModel) {
+		return (int) this.databaseServiceNew
+			.getGroupMemberModelFactory()
+			.countMembersWithoutUser(groupModel.getId());
 	}
 
 	@Override
@@ -1333,7 +1361,7 @@ public class GroupServiceImpl implements GroupService {
 					false,
 					R.string.you_are_not_a_member_of_this_group
 				));
-			} else if (getOtherMemberCount(groupModel) <= 0 && !allowEmpty) {
+			} else if (countMembersWithoutUser(groupModel) <= 0 && !allowEmpty) {
 				// Don't allow sending in empty groups (except allowEmpty is true)
 				groupAccessModel.setCanReceiveMessageAccess(new Access(
 					false,
@@ -1440,7 +1468,7 @@ public class GroupServiceImpl implements GroupService {
 		return new GroupFeatureSupport(
 			feature,
 			new ArrayList<>(
-				OutgoingCspMessageUtilsKt.filterBroadcastIdentity(getMembers(groupModel), groupModel)
+				OutgoingCspMessageUtilsKt.removeCreatorIfRequired(getMembers(groupModel), groupModel)
 					.stream().filter((member) -> !userService.isMe(member.getIdentity())).collect(Collectors.toList())
 			)
 		);
diff --git a/app/src/main/java/ch/threema/app/services/IdListService.java b/app/src/main/java/ch/threema/app/services/IdListService.java
index 6478bd04..01d60861 100644
--- a/app/src/main/java/ch/threema/app/services/IdListService.java
+++ b/app/src/main/java/ch/threema/app/services/IdListService.java
@@ -32,6 +32,6 @@ public interface IdListService {
 	void toggle(Context context, ContactModel contactModel);
 
 	String[] getAll();
-	void addAll(String[] ids);
 	void removeAll();
+    void replaceAll(String[] ids);
 }
diff --git a/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java b/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java
index c10dd09b..ce011b07 100644
--- a/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java
@@ -28,94 +28,93 @@ import java.util.Arrays;
 import java.util.List;
 
 import ch.threema.app.R;
-import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.storage.models.ContactModel;
 
 public class IdListServiceImpl implements IdListService {
-	private final Object lock = new Object();
-	private String[] ids;
-	private final String uniqueListName;
-	private final PreferenceService preferenceService;
+    private final Object lock = new Object();
+    private String[] ids;
+    private final String uniqueListName;
+    private final PreferenceService preferenceService;
 
-	public IdListServiceImpl(String uniqueListName, PreferenceService preferenceService) {
-		this.uniqueListName = uniqueListName;
-		this.preferenceService = preferenceService;
-		this.ids = preferenceService.getList(this.uniqueListName);
-	}
+    public IdListServiceImpl(String uniqueListName, PreferenceService preferenceService) {
+        this.uniqueListName = uniqueListName;
+        this.preferenceService = preferenceService;
+        this.ids = preferenceService.getList(this.uniqueListName);
+    }
 
-	@Override
-	public boolean has(String id) {
-		if(this.ids != null) {
-			synchronized (this.lock) {
-				return Arrays.asList(this.ids).contains(id);
-			}
-		}
-		return false;
-	}
+    @Override
+    public boolean has(String id) {
+        if (this.ids != null) {
+            synchronized (this.lock) {
+                return Arrays.asList(this.ids).contains(id);
+            }
+        }
+        return false;
+    }
 
-	@Override
-	public void remove(String id) {
-		if(this.ids != null) {
-			synchronized (this.lock) {
-				List<String> idList = Arrays.asList(this.ids);
-				if(idList.contains(id)) {
-					String[] newIdentities = new String[idList.size()-1];
-					int pos = 0;
-					for(String other: idList) {
-						if(other != null && !other.equals(id)) {
-							newIdentities[pos++] = other;
-						}
-					}
-					this.preferenceService.setList(this.uniqueListName, newIdentities);
-					this.ids = newIdentities;
-				}
-			}
-		}
-	}
+    @Override
+    public void remove(String id) {
+        if (this.ids != null) {
+            synchronized (this.lock) {
+                List<String> idList = Arrays.asList(this.ids);
+                if (idList.contains(id)) {
+                    String[] newIdentities = new String[idList.size() - 1];
+                    int pos = 0;
+                    for (String other : idList) {
+                        if (other != null && !other.equals(id)) {
+                            newIdentities[pos++] = other;
+                        }
+                    }
+                    this.preferenceService.setList(this.uniqueListName, newIdentities);
+                    this.ids = newIdentities;
+                }
+            }
+        }
+    }
 
-	@Override
-	public void add(String id) {
-		if(this.ids != null && (id != null && id.length() > 0)) {
-			synchronized (this.lock) {
-				List<String> idList = Arrays.asList(this.ids);
-				if(!idList.contains(id)) {
-					this.ids = Arrays.copyOf(this.ids, this.ids.length + 1);
-					this.ids[ids.length-1] = id;
-					this.preferenceService.setList(this.uniqueListName, ids);
-				}
-			}
-		}
-	}
+    @Override
+    public void add(String id) {
+        if (this.ids != null && (id != null && !id.isEmpty())) {
+            synchronized (this.lock) {
+                List<String> idList = Arrays.asList(this.ids);
+                if (!idList.contains(id)) {
+                    this.ids = Arrays.copyOf(this.ids, this.ids.length + 1);
+                    this.ids[ids.length - 1] = id;
+                    this.preferenceService.setList(this.uniqueListName, ids);
+                }
+            }
+        }
+    }
 
-	@Override
-	public void toggle(Context context, final ContactModel contactModel) {
-		String identity = contactModel.getIdentity();
+    @Override
+    public void toggle(Context context, final ContactModel contactModel) {
+        String identity = contactModel.getIdentity();
 
-		if (this.has(identity)) {
-			this.remove(identity);
-			Toast.makeText(context, context.getString(R.string.contact_now_unblocked), Toast.LENGTH_SHORT).show();
-		} else {
-			IdListServiceImpl.this.add(contactModel.getIdentity());
-			Toast.makeText(context, context.getString(R.string.contact_now_blocked), Toast.LENGTH_SHORT).show();
-		}
-		ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
-	}
+        if (this.has(identity)) {
+            this.remove(identity);
+            Toast.makeText(context, context.getString(R.string.contact_now_unblocked), Toast.LENGTH_SHORT).show();
+        } else {
+            IdListServiceImpl.this.add(contactModel.getIdentity());
+            Toast.makeText(context, context.getString(R.string.contact_now_blocked), Toast.LENGTH_SHORT).show();
+        }
+        ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
+    }
 
-	@Override
-	public synchronized String[] getAll() {
-		return this.ids;
-	}
+    @Override
+    public synchronized String[] getAll() {
+        return this.ids;
+    }
 
-	@Override
-	public void addAll(String[] ids) {
-		this.ids = ids;
-		this.preferenceService.setList(this.uniqueListName, this.ids);
-	}
+    @Override
+    public void removeAll() {
+        this.ids = new String[0];
+        this.preferenceService.setList(this.uniqueListName, this.ids);
+    }
 
-	@Override
-	public void removeAll() {
-		this.ids = new String[0];
-		this.preferenceService.setList(this.uniqueListName, this.ids);
-	}
+    @Override
+    public void replaceAll(String[] ids) {
+        this.ids = ids;
+        this.preferenceService.setList(this.uniqueListName, this.ids);
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/MessageSendingService.java b/app/src/main/java/ch/threema/app/services/MessageSendingService.java
index a589fbbe..584aad1a 100644
--- a/app/src/main/java/ch/threema/app/services/MessageSendingService.java
+++ b/app/src/main/java/ch/threema/app/services/MessageSendingService.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.services;
 
-import androidx.annotation.NonNull;
-
 import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.storage.models.AbstractMessageModel;
 
diff --git a/app/src/main/java/ch/threema/app/services/MessageService.java b/app/src/main/java/ch/threema/app/services/MessageService.java
index 574e63af..3957ca62 100644
--- a/app/src/main/java/ch/threema/app/services/MessageService.java
+++ b/app/src/main/java/ch/threema/app/services/MessageService.java
@@ -47,12 +47,12 @@ import ch.threema.app.ui.MediaItem;
 import ch.threema.app.voip.groupcall.GroupCallDescription;
 import ch.threema.base.ProgressListener;
 import ch.threema.base.ThreemaException;
+import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
 import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage;
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage;
+import ch.threema.domain.protocol.csp.messages.file.FileData;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.DistributionListMessageModel;
@@ -267,35 +267,44 @@ public interface MessageService {
     @WorkerThread
     boolean sendUserDecline(@NonNull AbstractMessageModel messageModel, boolean markAsRead);
 
-    void updateMessageState(@NonNull final MessageId apiMessageId, MessageState state, @NonNull DeliveryReceiptMessage stateMessage);
-
-    void updateGroupMessageState(@NonNull final MessageId apiMessageId, @NonNull MessageState state, @NonNull GroupDeliveryReceiptMessage stateMessage);
-
-    /**
-     * Update the message state of a contact message. Currently only used for server acks.
-     *
-     * @param messageId         the message id of the message
-     * @param recipientIdentity the recipient of the message
-     * @param state             the new state
-     * @param stateDate         the date of state change
-     */
-    boolean updateContactMessageState(
-        @NonNull final MessageId messageId,
-        @NonNull String recipientIdentity,
-        @NonNull MessageState state,
-        @Nullable Date stateDate
-    );
-
-    /**
-     * Update message state of outgoing message. Currently only used for server acks.
-     *
-     * @param messageModel the message model that should be updated
-     * @param state        the mew state
-     * @param stateDate    the date of state change
-     */
-    boolean updateMessageState(@NonNull final AbstractMessageModel messageModel, @NonNull MessageState state, @Nullable Date stateDate);
-
-    boolean markAsRead(AbstractMessageModel message, boolean silent) throws ThreemaException;
+	/**
+	 * Update message state of an outgoing message. Note that the state is only changed if it is a
+	 * legal transition. E.g. a message's state won't be changed from read to delivered. See
+	 * {@link ch.threema.app.utils.MessageUtil#canChangeToState(MessageState, MessageState, boolean)}
+	 * for possible state transitions.
+	 *
+	 * The corresponding timestamps are changed in any case. E.g. the delivered at timestamp will be
+	 * saved even if the message has already been marked as read.
+	 *
+	 * Do not use this method for reactions: Use
+	 * {@link #addMessageReaction(AbstractMessageModel, MessageState, String, Date)} instead.
+	 *
+	 * @param messageModel the message model that should be updated
+	 * @param state        the mew state
+	 * @param date         the date of the state change
+	 */
+	void updateOutgoingMessageState(
+		@NonNull final AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull Date date
+	);
+
+	/**
+	 * Add a reaction to a contact or group message.
+	 *
+	 * @param messageModel the message model that should be updated
+	 * @param state        the reaction (as state, but only ACK and DEC allowed)
+	 * @param fromIdentity the identity that reacted to the message
+	 * @param date         the date of the state change
+	 */
+	void addMessageReaction(
+		@NonNull AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull String fromIdentity,
+		@NonNull Date date
+	);
+
+	boolean markAsRead(AbstractMessageModel message, boolean silent) throws ThreemaException;
 
     @WorkerThread
     boolean markAsConsumed(AbstractMessageModel message) throws ThreemaException;
@@ -354,12 +363,34 @@ public interface MessageService {
     @Nullable
     DistributionListMessageModel getDistributionListMessageModel(long id);
 
-    MessageString getMessageString(AbstractMessageModel messageModel, int maxLength);
-
-    MessageString getMessageString(AbstractMessageModel messageModel, int maxLength, boolean withPrefix);
+	/**
+	 * Get the contact message model by message id and identity.
+	 */
+	@Nullable
+	MessageModel getContactMessageModel(
+		@NonNull final MessageId messageId,
+		@NonNull final String identity
+	);
+
+	/**
+	 * Get the group message model by message id, creator identity, and group id.
+	 */
+	@Nullable
+	GroupMessageModel getGroupMessageModel(
+		@NonNull MessageId messageId,
+		@NonNull String creatorIdentity,
+		@NonNull GroupId groupId
+	);
+
+	MessageString getMessageString(AbstractMessageModel messageModel, int maxLength);
+	MessageString getMessageString(AbstractMessageModel messageModel, int maxLength, boolean withPrefix);
 
     void saveIncomingServerMessage(ServerMessageModel msg);
 
+    boolean downloadThumbnailIfPresent(@NonNull FileData fileData, @NonNull AbstractMessageModel messageModel) throws Exception;
+
+    boolean shouldAutoDownload(@NonNull AbstractMessageModel messageModel);
+
     boolean downloadMediaMessage(AbstractMessageModel mediaMessageModel, ProgressListener progressListener) throws Exception;
 
     boolean cancelMessageDownload(AbstractMessageModel messageModel);
diff --git a/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java b/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java
index 62f2317f..60672150 100644
--- a/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java
@@ -21,21 +21,6 @@
 
 package ch.threema.app.services;
 
-import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE;
-import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE_MB;
-import static ch.threema.app.services.PreferenceService.ImageScale_DEFAULT;
-import static ch.threema.app.ui.MediaItem.TIME_UNDEFINED;
-import static ch.threema.app.ui.MediaItem.TYPE_FILE;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_ANIMATED;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_CAM;
-import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
-import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
-import static ch.threema.app.ui.MediaItem.TYPE_VIDEO;
-import static ch.threema.app.ui.MediaItem.TYPE_VIDEO_CAM;
-import static ch.threema.app.ui.MediaItem.TYPE_VOICEMESSAGE;
-import static ch.threema.domain.protocol.csp.messages.file.FileData.RENDERING_STICKER;
-
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.ActivityNotFoundException;
@@ -104,6 +89,7 @@ import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.messagereceiver.DistributionListMessageReceiver;
 import ch.threema.app.messagereceiver.GroupMessageReceiver;
 import ch.threema.app.messagereceiver.MessageReceiver;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.routines.ReadMessagesRoutine;
 import ch.threema.app.services.ballot.BallotService;
 import ch.threema.app.services.ballot.BallotUpdateResult;
@@ -115,6 +101,7 @@ import ch.threema.app.ui.MediaItem;
 import ch.threema.app.utils.BallotUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.ExifInterface;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.GeoLocationUtil;
@@ -124,7 +111,6 @@ import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.QuoteUtil;
 import ch.threema.app.utils.RuntimeUtil;
-import ch.threema.app.utils.StreamUtil;
 import ch.threema.app.utils.StringConversionUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.ThumbnailUtil;
@@ -141,6 +127,7 @@ import ch.threema.base.utils.Utils;
 import ch.threema.data.repositories.EditHistoryRepository;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.MessageId;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.blob.BlobUploader;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
@@ -149,10 +136,8 @@ import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.AudioMessage;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
 import ch.threema.domain.protocol.csp.messages.DeleteMessage;
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage;
 import ch.threema.domain.protocol.csp.messages.EditMessage;
 import ch.threema.domain.protocol.csp.messages.GroupAudioMessage;
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage;
 import ch.threema.domain.protocol.csp.messages.GroupImageMessage;
 import ch.threema.domain.protocol.csp.messages.GroupLocationMessage;
 import ch.threema.domain.protocol.csp.messages.GroupTextMessage;
@@ -161,13 +146,10 @@ import ch.threema.domain.protocol.csp.messages.ImageMessage;
 import ch.threema.domain.protocol.csp.messages.LocationMessage;
 import ch.threema.domain.protocol.csp.messages.TextMessage;
 import ch.threema.domain.protocol.csp.messages.VideoMessage;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotCreateInterface;
+import ch.threema.domain.protocol.csp.messages.ballot.BallotSetupInterface;
 import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.file.FileData;
-import ch.threema.domain.protocol.csp.messages.file.FileMessage;
-import ch.threema.domain.protocol.csp.messages.file.FileMessageInterface;
-import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.GroupMessageModelFactory;
@@ -197,6 +179,22 @@ import ch.threema.storage.models.data.status.GroupCallStatusDataModel;
 import ch.threema.storage.models.data.status.GroupStatusDataModel;
 import ch.threema.storage.models.data.status.VoipStatusDataModel;
 
+import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE;
+import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE_MB;
+import static ch.threema.app.services.PreferenceService.ImageScale_DEFAULT;
+import static ch.threema.app.ui.MediaItem.TIME_UNDEFINED;
+import static ch.threema.app.ui.MediaItem.TYPE_FILE;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_ANIMATED;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_CAM;
+import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
+import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
+import static ch.threema.app.ui.MediaItem.TYPE_VIDEO;
+import static ch.threema.app.ui.MediaItem.TYPE_VIDEO_CAM;
+import static ch.threema.app.ui.MediaItem.TYPE_VOICEMESSAGE;
+import static ch.threema.app.utils.StreamUtilKt.getFromUri;
+import static ch.threema.domain.protocol.csp.messages.file.FileData.RENDERING_STICKER;
+
 public class MessageServiceImpl implements MessageService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("MessageServiceImpl");
 
@@ -226,6 +224,9 @@ public class MessageServiceImpl implements MessageService {
     // Repositories
     private final EditHistoryRepository editHistoryRepository;
 
+    // Managers
+    private final MultiDeviceManager multiDeviceManager;
+
 	// Caches
 	private final Collection<MessageModel> contactMessageCache;
 	private final Collection<GroupMessageModel> groupMessageCache;
@@ -234,23 +235,24 @@ public class MessageServiceImpl implements MessageService {
 	private final SparseIntArray loadingProgress = new SparseIntArray();
 
 	public MessageServiceImpl(
-		Context context,
-	    CacheService cacheService,
-	    DatabaseServiceNew databaseServiceNew,
-	    ContactService contactService,
-	    FileService fileService,
-	    IdentityStore identityStore,
-	    SymmetricEncryptionService symmetricEncryptionService,
-	    PreferenceService preferenceService,
-	    LockAppService appLockService,
-	    BallotService ballotService,
-	    GroupService groupService,
-	    ApiService apiService,
-	    DownloadService downloadService,
-	    DeadlineListService hiddenChatsListService,
-	    IdListService blockedContactsService,
-        EditHistoryRepository editHistoryRepository
-	) {
+        Context context,
+        CacheService cacheService,
+        DatabaseServiceNew databaseServiceNew,
+        ContactService contactService,
+        FileService fileService,
+        IdentityStore identityStore,
+        SymmetricEncryptionService symmetricEncryptionService,
+        PreferenceService preferenceService,
+        LockAppService appLockService,
+        BallotService ballotService,
+        GroupService groupService,
+        ApiService apiService,
+        DownloadService downloadService,
+        DeadlineListService hiddenChatsListService,
+        IdListService blockedContactsService,
+        EditHistoryRepository editHistoryRepository,
+        MultiDeviceManager multiDeviceManager
+    ) {
 		this.context = context;
 		this.databaseServiceNew = databaseServiceNew;
 		this.contactService = contactService;
@@ -271,14 +273,15 @@ public class MessageServiceImpl implements MessageService {
 		distributionListMessageCache = cacheService.getDistributionListMessageCache();
 
         this.editHistoryRepository = editHistoryRepository;
+        this.multiDeviceManager = multiDeviceManager;
 
-		// init queue
+        // init queue
 		messageSendingService = new MessageSendingServiceExponentialBackOff(new MessageSendingService.MessageSendingServiceState() {
 			@Override
 			public void processingFailed(AbstractMessageModel messageModel, MessageReceiver<AbstractMessageModel> receiver) {
 				//remove send machine
 				removeSendMachine(messageModel);
-				updateMessageState(messageModel, MessageState.SENDFAILED, null);
+				updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 			}
 
 			@Override
@@ -511,7 +514,7 @@ public class MessageServiceImpl implements MessageService {
 		// If the referred message has been sent (`sent-at`) more than 6 hours ago,
 		//  prevent creation and abort these steps.
 		if (deltaTime > EditMessage.EDIT_MESSAGES_MAX_AGE) {
-			logger.error("Cannot edit message older than {}}ms", EditMessage.EDIT_MESSAGES_MAX_AGE);
+			logger.error("Cannot edit message older than {}ms", EditMessage.EDIT_MESSAGES_MAX_AGE);
 			return;
 		}
 
@@ -726,7 +729,7 @@ public class MessageServiceImpl implements MessageService {
 			return;
 		}
 
-		updateMessageState(messageModel, MessageState.SENDING, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDING, new Date());
 		fireOnModifiedMessage(messageModel);
 	}
 
@@ -752,7 +755,7 @@ public class MessageServiceImpl implements MessageService {
 			return;
 		}
 
-		updateMessageState(messageModel, MessageState.SENDING, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDING, new Date());
 		fireOnModifiedMessage(messageModel);
 		if (completionHandler != null) {
 			completionHandler.sendQueued(messageModel);
@@ -773,7 +776,7 @@ public class MessageServiceImpl implements MessageService {
 			throw new ThreemaException("Message file not present");
 		}
 
-		updateMessageState(messageModel, MessageState.PENDING, new Date());
+		updateOutgoingMessageState(messageModel, MessageState.PENDING, new Date());
 
 		//enqueue processing and uploading stuff...
 		messageSendingService.addToQueue(new MessageSendingService.MessageSendingProcess() {
@@ -841,8 +844,12 @@ public class MessageServiceImpl implements MessageService {
 					})
 					.next(() -> {
 						// upload (encrypted) file data
-						BlobUploader blobUploader = initUploader(getMessageModel(), contentEncryptResult.getData());
-						blobUploader.setProgressListener(new ProgressListener() {
+						BlobUploader blobUploader = initUploader(
+                            getMessageModel(),
+                            contentEncryptResult.getData(),
+                            getReceiver()
+                        );
+						blobUploader.progressListener = new ProgressListener() {
 							@Override
 							public void updateProgress(int progress) {
 								updateMessageLoadingProgress(messageModel, progress);
@@ -852,7 +859,7 @@ public class MessageServiceImpl implements MessageService {
 							public void onFinished(boolean success) {
 								setMessageLoadingFinished(messageModel);
 							}
-						});
+						};
 						blobId = blobUploader.upload();
 					})
 					.next(() -> {
@@ -863,8 +870,12 @@ public class MessageServiceImpl implements MessageService {
 							if (thumbnailEncryptResult.isEmpty()) {
 								throw new ThreemaException("Thumbnail encryption failed");
 							} else {
-								BlobUploader blobUploader = initUploader(getMessageModel(), thumbnailEncryptResult.getData());
-								blobUploader.setProgressListener(new ProgressListener() {
+								BlobUploader blobUploader = initUploader(
+                                    getMessageModel(),
+                                    thumbnailEncryptResult.getData(),
+                                    getReceiver()
+                                );
+								blobUploader.progressListener = new ProgressListener() {
 									@Override
 									public void updateProgress(int progress) {
 										updateMessageLoadingProgress(messageModel, progress);
@@ -874,7 +885,7 @@ public class MessageServiceImpl implements MessageService {
 									public void onFinished(boolean success) {
 										setMessageLoadingFinished(messageModel);
 									}
-								});
+								};
 								blobIdThumbnail = blobUploader.upload();
 							}
 						}
@@ -892,7 +903,7 @@ public class MessageServiceImpl implements MessageService {
 						save(messageModel);
 					})
 					.next(() -> {
-						updateMessageState(messageModel, MessageState.SENDING, null);
+						updateOutgoingMessageState(messageModel, MessageState.SENDING, new Date());
 
 						if (completionHandler != null)
 							completionHandler.sendComplete(messageModel);
@@ -946,7 +957,7 @@ public class MessageServiceImpl implements MessageService {
 		if(!TestUtil.required(messageModel, ballotModel, receiver)) {
 			return;
 		}
-		updateMessageState(messageModel, MessageState.PENDING, new Date());
+		updateOutgoingMessageState(messageModel, MessageState.PENDING, new Date());
 		try {
 			ballotService.publish(receiver, ballotModel, messageModel);
 		}
@@ -957,7 +968,7 @@ public class MessageServiceImpl implements MessageService {
 				fireOnRemovedMessage(messageModel);
 				throw new MessageTooLongException();
 			} else {
-				updateMessageState(messageModel, MessageState.SENDFAILED, new Date());
+				updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 			}
 		}
 	}
@@ -995,7 +1006,8 @@ public class MessageServiceImpl implements MessageService {
 
 		contactService.createReceiver(contactModel).sendDeliveryReceipt(
 			type,
-			new MessageId[]{MessageId.fromString(messageModel.getApiMessageId())}
+			new MessageId[]{MessageId.fromString(messageModel.getApiMessageId())},
+			new Date().getTime()
 		);
 		return true;
 	}
@@ -1056,42 +1068,53 @@ public class MessageServiceImpl implements MessageService {
 		return false;
 	}
 
-	private AbstractMessageModel getAbstractMessageModelByApiIdAndIdentity(final MessageId apiMessageId, final String identity) {
-		//contact message cache
+	@Nullable
+	@Override
+	public MessageModel getContactMessageModel(
+		@NonNull final MessageId apiMessageId,
+		@NonNull final String identity
+	) {
+		// Check contact message cache first
 		synchronized (contactMessageCache) {
-			AbstractMessageModel messageModel = Functional.select(contactMessageCache, m -> m.getApiMessageId() != null
+			MessageModel messageModel = Functional.select(contactMessageCache, m -> m.getApiMessageId() != null
 				&& m.getApiMessageId().equals(apiMessageId.toString())
 				&& TestUtil.compare(m.getIdentity(), identity));
-			if(messageModel != null) {
+			if (messageModel != null) {
 				return messageModel;
 			}
 		}
 
+		// If not cached, load from database (and cache it)
 		MessageModel contactMessageModel = databaseServiceNew.getMessageModelFactory().getByApiMessageIdAndIdentity(
 				apiMessageId,
 				identity);
-		if(contactMessageModel != null) {
+		if (contactMessageModel != null) {
 			cache(contactMessageModel);
-			return contactMessageModel;
 		}
-		return null;
+
+		return contactMessageModel;
 	}
 
 	/**
-	 * Get the AbstractMessageModel of a group message referenced by apiMessageId, apiGroupId and creatorId
-	 * @param apiMessageId the message
-	 * @param apiGroupId the group id
+	 * Get the AbstractMessageModel of a group message referenced by messageId, creatorId, and groupId
+	 * @param messageId the message
 	 * @param creatorIdentity the creator of the group
+	 * @param groupId the group id
 	 * @return a GroupMessageModel of the matching message or null in case a message could not be found
 	 */
+	@Override
 	@Nullable
-	private GroupMessageModel getGroupMessageModel(@NonNull final MessageId apiMessageId, @NonNull final GroupId apiGroupId, @NonNull String creatorIdentity) {
-		String apiMessageIdString = apiMessageId.toString();
+	public GroupMessageModel getGroupMessageModel(
+		@NonNull final MessageId messageId,
+		@NonNull final String creatorIdentity,
+		@NonNull final GroupId groupId
+	) {
+		String apiMessageIdString = messageId.toString();
 		if (apiMessageIdString == null) {
 			return null;
 		}
 
-		GroupModel groupModel = groupService.getByApiGroupIdAndCreator(apiGroupId, creatorIdentity);
+		GroupModel groupModel = groupService.getByApiGroupIdAndCreator(groupId, creatorIdentity);
 		if (groupModel == null) {
 			return null;
 		}
@@ -1106,7 +1129,7 @@ public class MessageServiceImpl implements MessageService {
 
 		// retrieve from database
 		GroupMessageModel groupMessageModel = databaseServiceNew.getGroupMessageModelFactory().getByApiMessageIdAndGroupId(
-				apiMessageId,
+				messageId,
 				groupModel.getId());
 
 		if (groupMessageModel != null) {
@@ -1118,96 +1141,115 @@ public class MessageServiceImpl implements MessageService {
 	}
 
 	@Override
-	public void updateMessageState(@NonNull final MessageId apiMessageId,
-	                               MessageState state,
-	                               @NonNull DeliveryReceiptMessage stateMessage) {
+	public void updateOutgoingMessageState(
+		@NonNull AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull Date date
+	) {
+		if (!messageModel.isOutbox()) {
+			throw new IllegalArgumentException("Updating outgoing message state on incoming message " + messageModel.getApiMessageId());
+		}
 
-		AbstractMessageModel messageModel = getAbstractMessageModelByApiIdAndIdentity(apiMessageId, stateMessage.getFromIdentity());
-		if (messageModel != null && !messageModel.isDeleted()) {
-			updateMessageState(messageModel, state, stateMessage.getDate());
+		if (MessageUtil.isReaction(state)) {
+			throw new IllegalArgumentException("The given message state is a reaction: " + state);
 		}
-	}
 
-	/**
-	 * Update the message state for the message referenced by the supplied apiMessageId
-	 * @param apiMessageId apiMessageID of the message whose state needs to be changed
-	 * @param state new state
-	 * @param stateMessage incoming message that contains the state information
-	 */
-	@Override
-	public void updateGroupMessageState(@NonNull MessageId apiMessageId,
-										@NonNull MessageState state,
-										@NonNull GroupDeliveryReceiptMessage stateMessage) {
-		if (!MessageUtil.isAllowedGroupMessageState(state)) {
+		if (messageModel.isDeleted()) {
 			return;
 		}
 
-		GroupMessageModel messageModel = getGroupMessageModel(apiMessageId, stateMessage.getApiGroupId(), stateMessage.getGroupCreator());
-		if (messageModel != null && !messageModel.isDeleted()) {
-			updateGroupMessageState(messageModel, stateMessage, state);
-		}
-	}
+		synchronized (this) {
+			logger.debug(
+				"Updating message state from {} to {} at {}",
+				messageModel.getState(), state, date.getTime()
+			);
 
-	@Override
-	public boolean updateContactMessageState(
-		@NonNull MessageId messageId,
-		@NonNull String recipientIdentity,
-		@NonNull MessageState state,
-		@Nullable Date date
-	) {
-		AbstractMessageModel messageModel = getAbstractMessageModelByApiIdAndIdentity(messageId, recipientIdentity);
-		if (messageModel != null) {
-			return updateMessageState(messageModel, state, date);
-		}
-		return false;
-	}
+			boolean hasChanges = true;
+
+			// Save date of state change
+			switch (state) {
+				case SENT:
+					// Note that we do not check whether the posted at time already exists as this
+					// value is already set when the message model has been created. We just update
+					// it when the message actually has been sent.
+					messageModel.setPostedAt(date);
+					messageModel.setModifiedAt(date);
+					break;
+				case DELIVERED:
+					if (messageModel.getDeliveredAt() != null) {
+						logger.warn("'Delivered at' already set for message {}", messageModel.getApiMessageId());
+					}
+					messageModel.setDeliveredAt(date);
+					messageModel.setModifiedAt(date);
+					break;
+				case READ:
+					if (messageModel.getReadAt() != null) {
+						logger.warn("'Read at' already set for message {}", messageModel.getApiMessageId());
+					}
+					messageModel.setReadAt(date);
+					messageModel.setModifiedAt(date);
+					break;
+				case SENDFAILED:
+				case FS_KEY_MISMATCH:
+				case CONSUMED:
+					messageModel.setModifiedAt(date);
+					break;
+				default:
+					hasChanges = false;
+			}
 
-	@Override
-	public boolean updateMessageState(
-		@NonNull AbstractMessageModel messageModel,
-		@NonNull MessageState state,
-		@Nullable Date stateDate
-	) {
-		synchronized (this) {
-			logger.debug("Updating message state from {} to {} (outbox={})", messageModel.getState(), state, messageModel.isOutbox());
-			if (MessageUtil.canChangeToState(messageModel.getState(), state, messageModel.isOutbox())) {
+			// Change the state only if it is possible
+			if (MessageUtil.canChangeToState(messageModel.getState(), state, messageModel instanceof GroupMessageModel)) {
 				messageModel.setState(state);
-				if (stateDate != null) {
-					messageModel.setModifiedAt(stateDate);
-				}
+				hasChanges = true;
+			} else {
+				logger.warn(
+					"State transition from {} to {}, ignoring",
+					messageModel.getState(), state
+				);
+			}
+
+			if (hasChanges) {
 				save(messageModel);
 				fireOnModifiedMessage(messageModel);
-				return true;
-			} else {
-				logger.warn("State transition from {} to {} (outbox={}), ignoring",
-					messageModel.getState(), state, messageModel.isOutbox());
-				return false;
 			}
 		}
 	}
 
-	/**
-	 * Update message states for group messages. Currently, only ACK and DEC are supported
-	 * @param messageModel Group Message to update
-	 * @param stateMessage Message of delivery receipt
-	 * @param newState Desired new state
-	 */
-	private void updateGroupMessageState(
-		@NonNull GroupMessageModel messageModel,
-		@NonNull AbstractMessage stateMessage,
-		@NonNull MessageState newState
+	@Override
+	public void addMessageReaction(
+		@NonNull AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull String fromIdentity,
+		@NonNull Date date
 	) {
-		if (!MessageUtil.isAllowedGroupMessageState(newState)) {
-			return;
+		if (!MessageUtil.isReaction(state)) {
+			throw new IllegalArgumentException("The given message state is not a reaction: " + state);
 		}
 
-		synchronized (this) {
-			logger.debug("Updating message state for group {} from identity {} to state {} ", messageModel.getGroupId(), stateMessage.getFromIdentity(), newState);
+		messageModel.setModifiedAt(date);
 
-			groupService.addGroupMessageState(messageModel, stateMessage.getFromIdentity(), newState);
-			messageModel.setModifiedAt(stateMessage.getDate());
+		if (messageModel instanceof GroupMessageModel) {
+			// Add group reaction
+			groupService.addGroupMessageState((GroupMessageModel) messageModel, fromIdentity, state);
 			save(messageModel);
 			fireOnModifiedMessage(messageModel);
+		} else {
+			// Add contact reaction (only if state transition is possible)
+			boolean canChangeState;
+			if (messageModel.isOutbox()) {
+				// For outbound messages, we need to check whether the message state transition is
+				// possible. For example, we can't add a reaction to failed messages.
+				canChangeState = MessageUtil.canChangeToState(messageModel.getState(), state, false);
+			} else {
+				// For inbound messages it is always possible to add a reaction
+				canChangeState = true;
+			}
+			if (canChangeState) {
+				messageModel.setState(state);
+				save(messageModel);
+				fireOnModifiedMessage(messageModel);
+			}
 		}
 	}
 
@@ -1219,41 +1261,68 @@ public class MessageServiceImpl implements MessageService {
 		if (MessageUtil.canMarkAsRead(message)) {
 			ContactModel contactModel = contactService.getByIdentity(message.getIdentity());
 
-			boolean sendDeliveryReceipt = MessageUtil.canSendDeliveryReceipt(message, ProtocolDefines.DELIVERYRECEIPT_MSGREAD);
-			if (sendDeliveryReceipt && contactModel != null) {
-				if (preferenceService.isReadReceipts()) {
-					if (contactModel.getReadReceipts() == ContactModel.DONT_SEND) {
-						sendDeliveryReceipt = false;
-					}
-				} else {
-					if (contactModel.getReadReceipts() != ContactModel.SEND) {
-						sendDeliveryReceipt = false;
-					}
-				}
-			}
+			// Check whether the message allows read receipt before setting the message to read
+			// because a message only allows a read receipt if has not been marked as read yet.
+			boolean messageAllowsDeliveryReceipt = MessageUtil.canSendDeliveryReceipt(message, ProtocolDefines.DELIVERYRECEIPT_MSGREAD);
+
+			Date readAt = new Date();
 
 			//save is read
 			message.setRead(true);
-			message.setReadAt(new Date());
-			message.setModifiedAt(new Date());
+			message.setReadAt(readAt);
+			message.setModifiedAt(readAt);
 
 			save(message);
 
-			if(!silent) {
+			if (!silent) {
 				//fire on modified if not silent
 				fireOnModifiedMessage(message);
 			}
 
 			saved = true;
 
-			if (sendDeliveryReceipt && contactModel != null) {
+			if (contactModel == null) {
+				return saved;
+			}
+
+            boolean receiverAllowsDeliveryReceipt;
+            switch (contactModel.getReadReceipts()) {
+                case ContactModel.SEND:
+                    receiverAllowsDeliveryReceipt = true;
+                    break;
+                case ContactModel.DONT_SEND:
+                    receiverAllowsDeliveryReceipt = false;
+                    break;
+                default:
+                    receiverAllowsDeliveryReceipt = preferenceService.isReadReceipts();
+                    break;
+            }
+
+			if (messageAllowsDeliveryReceipt && receiverAllowsDeliveryReceipt) {
 				contactService.createReceiver(contactModel).sendDeliveryReceipt(
 					ProtocolDefines.DELIVERYRECEIPT_MSGREAD,
-					new MessageId[]{MessageId.fromString(message.getApiMessageId())}
+					new MessageId[]{MessageId.fromString(message.getApiMessageId())},
+					readAt.getTime()
 				);
-
-				logger.info("Enqueue delivery receipt (read) message for message ID {} from {}",
+				logger.info("Enqueued delivery receipt (read) message for message ID {} from {}",
 					message.getApiMessageId(), contactModel.getIdentity());
+			} else {
+				if (message instanceof MessageModel) {
+					contactService.createReceiver(contactModel).sendIncomingMessageUpdateRead(
+						Set.of(MessageId.fromString(message.getApiMessageId())), readAt.getTime()
+					);
+				} else if (message instanceof GroupMessageModel) {
+					int localGroupId = ((GroupMessageModel) message).getGroupId();
+					GroupModel groupModel = groupService.getById(localGroupId);
+					if (groupModel != null) {
+						groupService.createReceiver(groupModel).sendIncomingMessageUpdateRead(
+							Set.of(MessageId.fromString(message.getApiMessageId())),
+							readAt.getTime()
+						);
+					} else {
+						logger.warn("Could not find group with local group id {}", localGroupId);
+					}
+				}
 			}
 		}
 
@@ -1289,7 +1358,7 @@ public class MessageServiceImpl implements MessageService {
 	@Override
 	public void remove(final AbstractMessageModel messageModel, boolean silent) {
 
-		SendMachine machine = getSendMachine(messageModel);
+		SendMachine machine = getSendMachine(messageModel, false);
 		if(machine != null) {
 			//abort pending send machine
 			//do not remove SendMachine (fix ANDR-522)
@@ -1405,7 +1474,7 @@ public class MessageServiceImpl implements MessageService {
 		}
 
         // As soon as we get a direct message, unhide and unarchive the contact
-        contactService.setIsHidden(senderIdentity, false);
+        contactService.setAcquaintanceLevel(senderIdentity, ContactModel.AcquaintanceLevel.DIRECT);
         contactService.setIsArchived(senderIdentity, false);
 
         // Bump "lastUpdate" if necessary, depending on the message type. Note that due to the
@@ -1428,7 +1497,7 @@ public class MessageServiceImpl implements MessageService {
 				preferenceService != null
 				&& preferenceService.isSaveMedia()
 				&& messageModel.getImageData().isDownloaded()
-				&& !hiddenChatsListService.has(contactService.getUniqueIdString(messageModel.getIdentity()))
+				&& !hiddenChatsListService.has(ContactUtil.getUniqueIdString(messageModel.getIdentity()))
 			) {
 				fileService.saveMedia(null, null, new CopyOnWriteArrayList<>(Collections.singletonList(messageModel)), true);
 			}
@@ -1445,9 +1514,6 @@ public class MessageServiceImpl implements MessageService {
 		else if (messageClass.equals(PollSetupMessage.class)) {
 			messageModel = saveBoxMessage((PollSetupMessage) message, messageModel, contactModel);
 		}
-		else if (messageClass.equals(FileMessage.class)) {
-			messageModel = saveBoxMessage((FileMessage) message, messageModel, contactModel);
-		}
 
 		if (messageModel == null) {
 			logger.info("processIncomingContactMessage: {} FAILED", message.getMessageId());
@@ -1544,12 +1610,9 @@ public class MessageServiceImpl implements MessageService {
 			messageModel = saveGroupMessage((GroupPollSetupMessage) message, messageModel);
 			// This is only used for debugging
 			if (ConfigUtils.isDevBuild()) {
-				logger.info("Processed GroupBallotCreateMessage {}", ((GroupPollSetupMessage) message).getRawBallotData());
+				logger.info("Processed GroupBallotCreateMessage {}", ((GroupPollSetupMessage) message).rawBallotData);
 			}
 		}
-		else if(message.getClass().equals(GroupFileMessage.class)) {
-			messageModel = saveGroupMessage((GroupFileMessage) message, messageModel);
-		}
 
 		if (messageModel != null) {
 			logger.info("processIncomingGroupMessage: {} SUCCESS - Message ID = {}", message.getMessageId(), messageModel.getId());
@@ -1630,7 +1693,7 @@ public class MessageServiceImpl implements MessageService {
 
 	private AbstractMessageModel saveBallotCreateMessage(MessageReceiver receiver,
 	                                                     MessageId messageId,
-	                                                     BallotCreateInterface message,
+	                                                     BallotSetupInterface message,
 	                                                     AbstractMessageModel messageModel,
 														 int messageFlags,
 	                                                     ForwardSecurityMode forwardSecurityMode)
@@ -1659,36 +1722,6 @@ public class MessageServiceImpl implements MessageService {
 		return messageModel;
 	}
 
-	/**
-	 * Process a 1:1 file message (0x17).
-	 */
-	private MessageModel saveBoxMessage(
-		@NonNull FileMessage message,
-		MessageModel messageModel,
-		@NonNull ContactModel contactModel
-	) throws Exception {
-		MessageReceiver messageReceiver = contactService.createReceiver(contactModel);
-		return (MessageModel) saveFileMessage(
-				messageReceiver,
-				message,
-				messageModel);
-	}
-
-	private GroupMessageModel saveGroupMessage(GroupFileMessage message, GroupMessageModel messageModel) throws Exception {
-		GroupModel groupModel = groupService.getByGroupMessage(message);
-
-		if(groupModel == null) {
-			return null;
-		}
-
-		MessageReceiver messageReceiver = groupService.createReceiver(groupModel);
-
-		return (GroupMessageModel) saveFileMessage(
-				messageReceiver,
-				message,
-				messageModel);
-	}
-
 	@Deprecated
 	private AbstractMessageModel saveAudioMessage(@NonNull MessageReceiver receiver,
 	                                              AbstractMessage message,
@@ -1731,7 +1764,7 @@ public class MessageServiceImpl implements MessageService {
 		if (newModel) {
 			fireOnCreatedMessage(messageModel);
 
-			if (canDownload(MessageType.VOICEMESSAGE)) {
+			if (shouldAutoDownload(MessageType.VOICEMESSAGE)) {
 				try {
 					downloadMediaMessage(messageModel, null);
 				} catch (Exception e) {
@@ -1747,9 +1780,11 @@ public class MessageServiceImpl implements MessageService {
 	}
 
 	@Deprecated
-	private AbstractMessageModel saveVideoMessage(@NonNull MessageReceiver receiver,
-	                                             AbstractMessage message,
-	                                             AbstractMessageModel messageModel) throws Exception {
+	private AbstractMessageModel saveVideoMessage(
+        @NonNull MessageReceiver receiver,
+	    AbstractMessage message,
+	    AbstractMessageModel messageModel
+    ) throws Exception {
 		boolean newModel = false;
 		int duration, videoSize;
 		byte[] encryptionKey, videoBlobId, thumbnailBlobId;
@@ -1791,21 +1826,31 @@ public class MessageServiceImpl implements MessageService {
 
 		//use download service!
 		logger.info("Downloading blob for message {} id = {}", messageModel.getApiMessageId(), messageModel.getId());
-		byte[] thumbnailBlob = downloadService.download(
-				messageModel.getId(),
-				thumbnailBlobId,
-				!(message instanceof AbstractGroupMessage),
-				new ProgressListener() {
-					@Override
-					public void updateProgress(int progress) {
-						updateMessageLoadingProgress(messageModel1, progress);
-					}
 
-					@Override
-					public void onFinished(boolean success) {
-						setMessageLoadingFinished(messageModel1);
-					}
-				});
+        // If multi-device is active, we always mark as done. Otherwise we do not mark as done if its a group message
+        boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive() || !(message instanceof AbstractGroupMessage);
+        @Nullable BlobScope blobScopeMarkAsDone = null;
+        if (shouldMarkAsDone) {
+            blobScopeMarkAsDone = messageModel.getBlobScopeForMarkAsDone();
+        }
+
+        byte[] thumbnailBlob = downloadService.download(
+            messageModel.getId(),
+            thumbnailBlobId,
+            messageModel.getBlobScopeForDownload(),
+            blobScopeMarkAsDone,
+            new ProgressListener() {
+                @Override
+                public void updateProgress(int progress) {
+                    updateMessageLoadingProgress(messageModel1, progress);
+                }
+
+                @Override
+                public void onFinished(boolean success) {
+                    setMessageLoadingFinished(messageModel1);
+                }
+            }
+        );
 
 		if (thumbnailBlob != null && thumbnailBlob.length > NaCl.BOXOVERHEAD) {
 			byte[] thumbnail = symmetricEncryptionService.decrypt(thumbnailBlob, encryptionKey, ProtocolDefines.THUMBNAIL_NONCE);
@@ -1827,7 +1872,7 @@ public class MessageServiceImpl implements MessageService {
 			if (newModel) {
 				fireOnCreatedMessage(messageModel);
 
-				if (canDownload(MessageType.VIDEO)) {
+				if (shouldAutoDownload(MessageType.VIDEO)) {
 					if (videoSize <= FILE_AUTO_DOWNLOAD_MAX_SIZE_ISO) {
 						try {
 							downloadMediaMessage(messageModel, null);
@@ -1848,128 +1893,63 @@ public class MessageServiceImpl implements MessageService {
 		return null;
 	}
 
-	private AbstractMessageModel saveFileMessage(MessageReceiver receiver,
-	                                             AbstractMessage message,
-	                                             AbstractMessageModel messageModel) throws Exception {
-		boolean newModel = false;
+    /**
+     * @return {@code true} if the thumbnail was downloaded and saved
+     */
+    @Override
+	public boolean downloadThumbnailIfPresent(@NonNull FileData fileData, @NonNull AbstractMessageModel messageModel) throws Exception {
 
-		if(!(message instanceof FileMessageInterface)) {
-			throw new ThreemaException("not a file message interface");
-		}
-		FileData fileData = ((FileMessageInterface)message).getData();
-
-		if(null == fileData) {
-			return null;
-		}
-
-		if (TestUtil.isEmptyOrNull(fileData.getMimeType())) {
-			fileData.setMimeType(MimeUtil.MIME_TYPE_DEFAULT);
-		}
-
-		logger.debug("process incoming file");
-		if (messageModel == null) {
-			newModel = true;
-
-			FileDataModel fileDataModel = new FileDataModel(
-				fileData.getFileBlobId(),
-				fileData.getEncryptionKey(),
-				fileData.getMimeType(),
-				fileData.getThumbnailMimeType(),
-				fileData.getFileSize(),
-				FileUtil.sanitizeFileName(fileData.getFileName()),
-				fileData.getRenderingType(),
-				fileData.getCaption(),
-				false,
-				fileData.getMetaData());
-
-			messageModel = receiver.createLocalModel(MessageType.FILE, MimeUtil.getContentTypeFromFileData(fileDataModel), message.getDate());
-			cache(messageModel);
-
-			messageModel.setApiMessageId(message.getMessageId().toString());
-			messageModel.setMessageFlags(message.getMessageFlags());
-			messageModel.setOutbox(false);
-			messageModel.setIdentity(message.getFromIdentity());
-			// Save correlation id into db field instead json
-			messageModel.setCorrelationId(fileData.getCorrelationId());
-			messageModel.setFileData(fileDataModel);
-			messageModel.setForwardSecurityMode(message.getForwardSecurityMode());
-
-			// Set the message model as saved in case the app gets killed while downloading the
-			// thumbnail. Due to forward security the message can not be processed twice anyway.
-			messageModel.setSaved(true);
-
-			//create the record
-			receiver.saveLocalModel(messageModel);
-		}
-
-		try {
-			downloadThumbnail(fileData, messageModel);
-		} catch (Exception e) {
-			logger.error("Download of thumbnail failed", e);
-		}
-
-		messageModel.setSaved(true);
-		receiver.saveLocalModel(messageModel);
-
-		if(newModel) {
-			fireOnCreatedMessage(messageModel);
-			// Auto download
-			if (canDownload(messageModel)) {
-				try {
-					downloadMediaMessage(messageModel, null);
-				} catch (Exception e) {
-					// a failed blob auto-download should not be considered a failure as the user can try again manually
-					logger.error("Unable to auto-download blob", e);
-				}
-			}
-		}
-		else {
-			fireOnModifiedMessage(messageModel);
-		}
+        if (fileData.getThumbnailBlobId() == null) {
+            return false;
+        }
 
-		return messageModel;
-	}
+        logger.info("Downloading thumbnail of message {}", messageModel.getApiMessageId());
+        final AbstractMessageModel messageModel1 = messageModel;
 
-	private void downloadThumbnail(FileData fileData, AbstractMessageModel messageModel) throws Exception {
-		if (fileData.getThumbnailBlobId() != null) {
-			logger.info("Downloading thumbnail of message {}", messageModel.getApiMessageId());
-			final AbstractMessageModel messageModel1 = messageModel;
-			byte[] thumbnailBlob = downloadService.download(
-				messageModel.getId(),
-				fileData.getThumbnailBlobId(),
-				!(messageModel instanceof GroupMessageModel),
-				new ProgressListener() {
-					@Override
-					public void updateProgress(int progress) {
-						updateMessageLoadingProgress(messageModel1, progress);
-					}
-
-					@Override
-					public void onFinished(boolean success) {
-						setMessageLoadingFinished(messageModel1);
-					}
-				});
+        // If multi-device is active, we always mark as done. Otherwise we do not mark as done if its a group message
+        boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive() || !(messageModel instanceof GroupMessageModel);
+        @Nullable BlobScope blobScopeMarkAsDone = null;
+        if (shouldMarkAsDone) {
+            blobScopeMarkAsDone = messageModel.getBlobScopeForMarkAsDone();
+        }
 
-			if (thumbnailBlob == null) {
-				downloadService.error(messageModel.getId());
-				logger.info("Error downloading thumbnail for message {}", messageModel.getApiMessageId());
-				throw new ThreemaException("Error downloading thumbnail");
-			}
+        byte[] thumbnailBlob = downloadService.download(
+            messageModel.getId(),
+            fileData.getThumbnailBlobId(),
+            messageModel.getBlobScopeForDownload(),
+            blobScopeMarkAsDone,
+            new ProgressListener() {
+                @Override
+                public void updateProgress(int progress) {
+                    updateMessageLoadingProgress(messageModel1, progress);
+                }
+
+                @Override
+                public void onFinished(boolean success) {
+                    setMessageLoadingFinished(messageModel1);
+                }
+            });
+
+        if (thumbnailBlob == null) {
+            downloadService.error(messageModel.getId());
+            logger.info("Error downloading thumbnail for message {}", messageModel.getApiMessageId());
+            throw new ThreemaException("Error downloading thumbnail");
+        }
 
-			byte[] thumbnail = symmetricEncryptionService.decrypt(thumbnailBlob, fileData.getEncryptionKey(), ProtocolDefines.FILE_THUMBNAIL_NONCE);
+        byte[] thumbnail = symmetricEncryptionService.decrypt(thumbnailBlob, fileData.getEncryptionKey(), ProtocolDefines.FILE_THUMBNAIL_NONCE);
 
-			if (thumbnail != null) {
-				try {
-					fileService.writeConversationMediaThumbnail(messageModel, thumbnail);
-				} catch (Exception e) {
-					downloadService.error(messageModel.getId());
-					logger.info("Error writing thumbnail for message {}", messageModel.getApiMessageId());
-					throw e;
-				}
-			}
+        if (thumbnail != null) {
+            try {
+                fileService.writeConversationMediaThumbnail(messageModel, thumbnail);
+            } catch (Exception exception) {
+                downloadService.error(messageModel.getId());
+                logger.info("Error writing thumbnail for message {}", messageModel.getApiMessageId());
+                throw exception;
+            }
+        }
 
-			downloadService.complete(messageModel.getId(), fileData.getThumbnailBlobId());
-		}
+        downloadService.complete(messageModel.getId(), fileData.getThumbnailBlobId());
+        return true;
 	}
 
 	private GroupMessageModel saveGroupMessage(GroupTextMessage message, GroupMessageModel messageModel) {
@@ -2003,7 +1983,7 @@ public class MessageServiceImpl implements MessageService {
 		return messageModel;
 	}
 
-	private boolean canDownload(MessageType type) {
+	private boolean shouldAutoDownload(MessageType type) {
 		if (preferenceService != null) {
 			ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
 			NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
@@ -2029,7 +2009,8 @@ public class MessageServiceImpl implements MessageService {
 	 * @param messageModel AbstractMessageModel to check
 	 * @return true if file should be downloaded immediately, false otherwise
 	 */
-	private boolean canDownload(@NonNull AbstractMessageModel messageModel) {
+    @Override
+	public boolean shouldAutoDownload(@NonNull AbstractMessageModel messageModel) {
 		MessageType type = MessageType.FILE;
 		FileDataModel fileDataModel = messageModel.getFileData();
 
@@ -2111,20 +2092,34 @@ public class MessageServiceImpl implements MessageService {
 
 		final GroupMessageModel messageModel1 = messageModel;
 
-		if (canDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
-			byte[] blob = downloadService.download(messageModel.getId(), message.getBlobId(), false, new ProgressListener() {
-
-				// do we really need a progress listener for images?
-				@Override
-				public void updateProgress(int progress) {
-					updateMessageLoadingProgress(messageModel1, progress);
-				}
-
-				@Override
-				public void onFinished(boolean success) {
-					setMessageLoadingFinished(messageModel1);
-				}
-			});
+		if (shouldAutoDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
+
+            // If multi-device is active, we always mark as done (even for a group message)
+            boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive();
+            @Nullable BlobScope blobScopeMarkAsDone = null;
+            if (shouldMarkAsDone) {
+                blobScopeMarkAsDone = messageModel.getBlobScopeForMarkAsDone();
+            }
+
+            byte[] blob = downloadService.download(
+                messageModel.getId(),
+                message.getBlobId(),
+                messageModel.getBlobScopeForDownload(),
+                blobScopeMarkAsDone,
+                new ProgressListener() {
+
+                    // do we really need a progress listener for images?
+                    @Override
+                    public void updateProgress(int progress) {
+                        updateMessageLoadingProgress(messageModel1, progress);
+                    }
+
+                    @Override
+                    public void onFinished(boolean success) {
+                        setMessageLoadingFinished(messageModel1);
+                    }
+                }
+            );
 
 			if (blob != null && messageModel.getImageData().getEncryptionKey().length > 0) {
 				try {
@@ -2310,9 +2305,16 @@ public class MessageServiceImpl implements MessageService {
 
 		logger.info("saveBoxMessage: {} - F", message.getMessageId());
 
-		if (canDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
-			// Use download class to handle failures after downloads
-			byte[] imageBlob = downloadService.download(messageModel.getId(), message.getBlobId(), true, null);
+		if (shouldAutoDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
+
+            // Use download class to handle failures after downloads
+			byte[] imageBlob = downloadService.download(
+                messageModel.getId(),
+                message.getBlobId(),
+                messageModel.getBlobScopeForDownload(),
+                messageModel.getBlobScopeForMarkAsDone(),
+                null
+            );
 			if (imageBlob != null) {
 				byte[] image = identityStore.decryptData(imageBlob, message.getNonce(), contactModel.getPublicKey());
 				if (image != null) {
@@ -2798,7 +2800,7 @@ public class MessageServiceImpl implements MessageService {
 			isHidden = hiddenChatsListService.has(groupService.getUniqueIdString(groupModel));
 		} else {
 			final ContactModel contactModel = contactService.getByIdentity(messageModel.getIdentity());
-			isHidden = hiddenChatsListService.has(contactService.getUniqueIdString(contactModel));
+			isHidden = hiddenChatsListService.has(ContactUtil.getUniqueIdString(messageModel.getIdentity()));
 		}
 
 		if (isHidden) {
@@ -2960,10 +2962,18 @@ public class MessageServiceImpl implements MessageService {
 			}
 		}
 
+        // If multi-device is active, we always mark as done. Otherwise we do not mark as done if its a group message
+        boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive() || !(mediaMessageModel instanceof GroupMessageModel);
+        @Nullable BlobScope blobScopeMarkAsDone = null;
+        if (shouldMarkAsDone) {
+            blobScopeMarkAsDone = mediaMessageModel.getBlobScopeForMarkAsDone();
+        }
+
 		byte[] blob = downloadService.download(
 			mediaMessageModel.getId(),
 			data.getBlobId(),
-			!(mediaMessageModel instanceof GroupMessageModel),
+            mediaMessageModel.getBlobScopeForDownload(),
+            blobScopeMarkAsDone,
 			progressListener
 		);
 		if (blob == null || blob.length < NaCl.BOXOVERHEAD) {
@@ -3009,7 +3019,7 @@ public class MessageServiceImpl implements MessageService {
 			&& isImageOrVideoFile(mediaMessageModel, data)) {
 			boolean isHidden = mediaMessageModel instanceof GroupMessageModel
 				? hiddenChatsListService.has(groupService.getUniqueIdString(((GroupMessageModel) mediaMessageModel).getGroupId()))
-				: hiddenChatsListService.has(contactService.getUniqueIdString(mediaMessageModel.getIdentity()));
+				: hiddenChatsListService.has(ContactUtil.getUniqueIdString(mediaMessageModel.getIdentity()));
 
 			if (!isHidden) {
 				fileService.saveMedia(null, null, new CopyOnWriteArrayList<>(Collections.singletonList(mediaMessageModel)), true);
@@ -3167,11 +3177,14 @@ public class MessageServiceImpl implements MessageService {
 							(MessageModel) messageModel
 					);
 
-					//remove "old" message models from cache
-					for(MessageModel m: Functional.filter(contactMessageCache, (IPredicateNonNull<MessageModel>) type -> type.getId() == messageModel.getId() && messageModel != type)){
-						//remove cached unsaved object
-						logger.debug("copy from message model fix");
-						m.copyFrom(messageModel);
+					// Update the cache
+					Iterator<MessageModel> iterator = contactMessageCache.iterator();
+					while (iterator.hasNext()) {
+						MessageModel cached = iterator.next();
+						if (cached.getId() == messageModel.getId() && cached != messageModel) {
+							// Remove old message model from cache if not the same object
+							iterator.remove();
+						}
 					}
 
 				}
@@ -3464,14 +3477,34 @@ public class MessageServiceImpl implements MessageService {
 	 * create a new AbstractMessageModel uploader
 	 * a existing uploader will be canceled
 	 */
-	private BlobUploader initUploader(AbstractMessageModel messageModel, byte[] data) throws ThreemaException {
+	@NonNull
+    private BlobUploader initUploader(
+        AbstractMessageModel messageModel,
+        byte[] data,
+        @NonNull MessageReceiver<?> messageReceiver
+    ) throws ThreemaException {
 		synchronized (uploaders) {
 			String key = cancelUploader(messageModel);
-			BlobUploader up = apiService.createUploader(data);
+
+            boolean shouldPersist = shouldPersistUploadForMessage(messageModel);
+
+            @NonNull BlobScope blobScope = BlobScope.Public.INSTANCE;
+
+            // If the message is send to a notes group, the blob scope must not be "public"
+            if (messageReceiver instanceof GroupMessageReceiver) {
+                if (groupService.isNotesGroup(((GroupMessageReceiver) messageReceiver).getGroup())) {
+                    blobScope = BlobScope.Local.INSTANCE;
+                }
+            }
+
+            BlobUploader up = apiService.createUploader(
+                data,
+                shouldPersist,
+                blobScope
+            );
 			uploaders.put(key, up);
-			boolean persist = shouldPersistUploadForMessage(messageModel);
-			up.setPersist(persist);
-			logger.debug("create new uploader for message {}, persist={}", key, persist);
+
+			logger.debug("create new uploader for message {}, persist={}", key, shouldPersist);
 			return up;
 		}
 	}
@@ -3485,7 +3518,7 @@ public class MessageServiceImpl implements MessageService {
 	}
 
 	/**
-	 * cancel a existing AbstractMessageModel uploader
+	 * cancel an existing AbstractMessageModel uploader
 	 */
 	private String cancelUploader(AbstractMessageModel messageModel) {
 		synchronized (uploaders) {
@@ -3525,7 +3558,7 @@ public class MessageServiceImpl implements MessageService {
 
 	@Override
 	public void cancelMessageUpload(AbstractMessageModel messageModel) {
-		updateMessageState(messageModel, MessageState.SENDFAILED, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 
 		if (messageSendingService != null) {
 			messageSendingService.abort(messageModel.getUid());
@@ -3536,7 +3569,7 @@ public class MessageServiceImpl implements MessageService {
 
 	@Override
 	public void cancelVideoTranscoding(AbstractMessageModel messageModel) {
-		updateMessageState(messageModel, MessageState.SENDFAILED, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 
 		removeSendMachine(messageModel);
 		cancelTranscoding(messageModel);
@@ -3943,7 +3976,7 @@ public class MessageServiceImpl implements MessageService {
 				break;
 			case TYPE_IMAGE_CAM:
 				// cam images will always be sent in their original size. no scaling needed but possibly rotate and flip
-				try (InputStream inputStream = StreamUtil.getFromUri(context, mediaItem.getUri())) {
+				try (InputStream inputStream = getFromUri(context, mediaItem.getUri())) {
 					if (inputStream != null && inputStream.available() > 0) {
 						bitmap = BitmapFactory.decodeStream(new BufferedInputStream(inputStream), null, null);
 						if (bitmap != null) {
@@ -4201,14 +4234,18 @@ public class MessageServiceImpl implements MessageService {
 								save(messageModel);
 							}
 							fileDataModel.setFileSize(contentData.length - NaCl.BOXOVERHEAD);
-							messageModel.setFileData(fileDataModel);
+							messageModel.setFileDataModel(fileDataModel);
 							fireOnModifiedMessage(messageModel);
 						})
 						.next(() -> {
 							if (getReceiver().sendMediaData()) {
 								// upload file data
-								BlobUploader blobUploader = initUploader(getMessageModel(), contentEncryptResult[0].getData());
-								blobUploader.setProgressListener(new ProgressListener() {
+								BlobUploader blobUploader = initUploader(
+                                    getMessageModel(),
+                                    contentEncryptResult[0].getData(),
+                                    getReceiver()
+                                );
+								blobUploader.progressListener = new ProgressListener() {
 									@Override
 									public void updateProgress(int progress) {
 										updateMessageLoadingProgress(messageModel, progress);
@@ -4218,9 +4255,8 @@ public class MessageServiceImpl implements MessageService {
 									public void onFinished(boolean success) {
 										setMessageLoadingFinished(messageModel);
 									}
-								});
+								};
 								contentBlobId = blobUploader.upload();
-								logger.debug("blobId = {}", Utils.byteArrayToHexString(contentBlobId));
 							}
 						})
 						.next(() -> {
@@ -4233,8 +4269,12 @@ public class MessageServiceImpl implements MessageService {
 									if (thumbnailEncryptResult[0].isEmpty()) {
 										throw new ThreemaException("Thumbnail encrypt failed");
 									} else {
-										BlobUploader blobUploader = initUploader(getMessageModel(), thumbnailEncryptResult[0].getData());
-										blobUploader.setProgressListener(new ProgressListener() {
+										BlobUploader blobUploader = initUploader(
+                                            getMessageModel(),
+                                            thumbnailEncryptResult[0].getData(),
+                                            getReceiver()
+                                        );
+										blobUploader.progressListener = new ProgressListener() {
 											@Override
 											public void updateProgress(int progress) {
 												updateMessageLoadingProgress(messageModel, progress);
@@ -4244,10 +4284,8 @@ public class MessageServiceImpl implements MessageService {
 											public void onFinished(boolean success) {
 												setMessageLoadingFinished(messageModel);
 											}
-										});
+										};
 										thumbnailBlobId = blobUploader.upload();
-										logger.debug("blobIdThumbnail = {}", Utils.byteArrayToHexString(thumbnailBlobId));
-
 										fireOnModifiedMessage(messageModel);
 									}
 								}
@@ -4262,22 +4300,22 @@ public class MessageServiceImpl implements MessageService {
 								null,
 								null
 							);
-							updateMessageState(messageModel,
+							updateOutgoingMessageState(messageModel,
 								getReceiver().sendMediaData() && getReceiver().offerRetry() ?
 									MessageState.SENDING :
-									MessageState.SENT, null);
+									MessageState.SENT, new Date());
 
-							messageModel.setFileData(fileDataModel);
+							messageModel.setFileDataModel(fileDataModel);
 							// save updated model
 							save(messageModel);
 						})
 						.next(() -> {
 							messageModel.setSaved(true);
 							// Verify current saved state
-							updateMessageState(messageModel,
+							updateOutgoingMessageState(messageModel,
 								getReceiver().sendMediaData() && getReceiver().offerRetry() ?
 									MessageState.SENDING :
-									MessageState.SENT, null);
+									MessageState.SENT, new Date());
 
 							if (!getReceiver().sendMediaData()) {
 								// update status for message that stay local
@@ -4315,7 +4353,7 @@ public class MessageServiceImpl implements MessageService {
 
 			messageModel.setOutbox(true);
 			messageModel.setState(MessageState.PENDING); // shows a progress bar
-			messageModel.setFileData(fileDataModel);
+			messageModel.setFileDataModel(fileDataModel);
 			messageModel.setCorrelationId(correlationId);
 			String trimmedCaption = mediaItem.getTrimmedCaption();
 			if (trimmedCaption != null && !trimmedCaption.isBlank()) {
@@ -4665,7 +4703,7 @@ public class MessageServiceImpl implements MessageService {
 	 */
 	@WorkerThread
 	private byte[] getContentData(MediaItem mediaItem) {
-		try (InputStream inputStream = StreamUtil.getFromUri(context, mediaItem.getUri())) {
+		try (InputStream inputStream = getFromUri(context, mediaItem.getUri())) {
 			if (inputStream != null) {
  				int fileLength = inputStream.available();
 
diff --git a/app/src/main/java/ch/threema/app/services/PreferenceService.java b/app/src/main/java/ch/threema/app/services/PreferenceService.java
index 48475add..1ec16162 100644
--- a/app/src/main/java/ch/threema/app/services/PreferenceService.java
+++ b/app/src/main/java/ch/threema/app/services/PreferenceService.java
@@ -28,8 +28,6 @@ import androidx.annotation.IntDef;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
-import org.jetbrains.annotations.NotNull;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Date;
@@ -78,7 +76,7 @@ public interface PreferenceService {
 
 	int PROFILEPIC_RELEASE_NOBODY = 0;
 	int PROFILEPIC_RELEASE_EVERYONE = 1;
-	int PROFILEPIC_RELEASE_SOME = 2;
+	int PROFILEPIC_RELEASE_ALLOW_LIST = 2;
 
 	int PRIVACY_POLICY_ACCEPT_NONE = 0;
 	int PRIVACY_POLICY_ACCEPT_EXCPLICIT = 1;
@@ -221,8 +219,6 @@ public interface PreferenceService {
 
 	/**
 	 * value in seconds!
-	 *
-	 * @return
 	 */
 	int getPinLockGraceTime();
 
@@ -252,14 +248,10 @@ public interface PreferenceService {
 
 	void clear();
 
-	public List<String[]> write();
+	List<String[]> write();
 
 	boolean read(List<String[]> values);
 
-	Integer getRoutineInterval(String key);
-
-	void setRoutineInterval(String key, Integer intervalSeconds);
-
 	boolean showInactiveContacts();
 
 	boolean getLastOnlineStatus();
@@ -503,6 +495,17 @@ public interface PreferenceService {
 	void setWorkSyncCheckInterval(int checkInterval);
 	int getWorkSyncCheckInterval();
 
+	/**
+	 * Store the interval for the identity state sync in seconds.
+	 * @param syncIntervalS The sync interval in seconds
+	 */
+	void setIdentityStateSyncInterval(int syncIntervalS);
+
+	/**
+	 * @return The identity state sync interval in seconds
+	 */
+	int getIdentityStateSyncIntervalS();
+
 	boolean getIsExportIdTooltipShown();
 
 	void setThreemaSafeMDMConfig(String mdmConfigHash);
diff --git a/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java b/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java
index 88fc9eff..e8f5e31f 100644
--- a/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java
@@ -228,7 +228,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 			return ImageScale_MEDIUM;
 		}
 
-		switch (Integer.valueOf(imageScale)) {
+		switch (Integer.parseInt(imageScale)) {
 			case 0:
 				return ImageScale_SMALL;
 			case 2:
@@ -250,7 +250,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 			return VideoSize_MEDIUM;
 		}
 
-		switch (Integer.valueOf(videoSize)) {
+		switch (Integer.parseInt(videoSize)) {
 			case 0:
 				return VideoSize_SMALL;
 			case 2:
@@ -335,7 +335,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 
 	@Override
 	public void setRecentEmojis2(LinkedList<String> list) {
-		this.preferenceStore.save(this.getKeyName(R.string.preferences__recent_emojis2), list.toArray(new String[list.size()]), false);
+		this.preferenceStore.save(this.getKeyName(R.string.preferences__recent_emojis2), list.toArray(new String[0]), false);
 	}
 
 	@Override
@@ -506,7 +506,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 			return R.style.FontStyle_Normal;
 		}
 
-		switch (Integer.valueOf(fontStyle)) {
+		switch (Integer.parseInt(fontStyle)) {
 			case 1:
 				return R.style.FontStyle_Large;
 			case 2:
@@ -669,11 +669,9 @@ public class PreferenceServiceImpl implements PreferenceService {
 			String valueClass = v[2];
 
 			if (valueClass.equals(Boolean.class.toString())) {
-				this.preferenceStore.save(key, Boolean.valueOf(value));
-			} else if (valueClass.equals(Float.class.toString())) {
-//					this.preferenceStore.save(key, ((Float) v).floatValue());
+				this.preferenceStore.save(key, Boolean.parseBoolean(value));
 			} else if (valueClass.equals(Integer.class.toString())) {
-				this.preferenceStore.save(key, Integer.valueOf(value));
+				this.preferenceStore.save(key, Integer.parseInt(value));
 			} else if (valueClass.equals(Long.class.toString())) {
 				this.preferenceStore.save(key, Long.valueOf(value));
 			} else if (valueClass.equals(String.class.toString())) {
@@ -688,16 +686,6 @@ public class PreferenceServiceImpl implements PreferenceService {
 		return this.context.getString(resourceId);
 	}
 
-	@Override
-	public Integer getRoutineInterval(String key) {
-		return this.preferenceStore.getInt(key);
-	}
-
-	@Override
-	public void setRoutineInterval(String key, Integer intervalSeconds) {
-		this.preferenceStore.save(key, intervalSeconds);
-	}
-
 	@Override
 	public boolean showInactiveContacts() {
 		return this.preferenceStore.getBoolean(this.getKeyName(R.string.preferences__show_inactive_contacts));
@@ -1373,6 +1361,16 @@ public class PreferenceServiceImpl implements PreferenceService {
 		return this.preferenceStore.getInt(this.getKeyName(R.string.preferences__work_sync_check_interval));
 	}
 
+	@Override
+	public void setIdentityStateSyncInterval(int syncIntervalS) {
+		this.preferenceStore.save(this.getKeyName(R.string.preferences__identity_states_check_interval), syncIntervalS);
+	}
+
+	@Override
+	public int getIdentityStateSyncIntervalS() {
+		return this.preferenceStore.getInt(this.getKeyName(R.string.preferences__identity_states_check_interval));
+	}
+
 	@Override
 	public boolean getIsExportIdTooltipShown() {
 		return this.preferenceStore.getBoolean(this.getKeyName(R.string.preferences__tooltip_export_id_shown));
diff --git a/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java b/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java
index 9bb84dd5..83e41541 100644
--- a/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java
@@ -27,170 +27,267 @@ import java.net.URL;
 import java.net.URLEncoder;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.utils.Utils;
 import ch.threema.domain.onprem.OnPremConfigFetcher;
 import ch.threema.domain.onprem.ServerAddressProviderOnPrem;
 import ch.threema.domain.protocol.ServerAddressProvider;
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider;
 
 public class ServerAddressProviderServiceImpl implements ServerAddressProviderService {
-	private final PreferenceService preferenceService;
-	private OnPremConfigFetcher onPremConfigFetcher;
-	private URL lastOnPremServer;
-
-	public ServerAddressProviderServiceImpl(PreferenceService preferenceService) {
-		this.preferenceService = preferenceService;
-	}
-
-	@Override
-	@NonNull
-	public ServerAddressProvider getServerAddressProvider() {
-		if (ConfigUtils.isOnPremBuild()) {
-			return getServerAddressProviderOnPrem();
-		} else {
-			return getServerAddressProviderBuildConfig();
-		}
-	}
-
-	private ServerAddressProvider getServerAddressProviderOnPrem() {
-		return new ServerAddressProviderOnPrem(this::getOnPremConfigFetcher);
-	}
-
-	private ServerAddressProvider getServerAddressProviderBuildConfig() {
-		return new ServerAddressProvider() {
-			@Override
-			public String getChatServerNamePrefix(boolean ipv6) {
-				return ipv6 ? BuildConfig.CHAT_SERVER_IPV6_PREFIX : BuildConfig.CHAT_SERVER_PREFIX;
-			}
-
-			@Override
-			public String getChatServerNameSuffix(boolean ipv6) {
-				return BuildConfig.CHAT_SERVER_SUFFIX;
-			}
-
-			@Override
-			public int[] getChatServerPorts() {
-				return BuildConfig.CHAT_SERVER_PORTS;
-			}
-
-			@Override
-			public boolean getChatServerUseServerGroups() {
-				return BuildConfig.CHAT_SERVER_GROUPS;
-			}
-
-			@Override
-			public byte[] getChatServerPublicKey() {
-				return BuildConfig.SERVER_PUBKEY;
-			}
-
-			@Override
-			public byte[] getChatServerPublicKeyAlt() {
-				return BuildConfig.SERVER_PUBKEY_ALT;
-			}
-
-			@Override
-			public String getDirectoryServerUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.DIRECTORY_SERVER_IPV6_URL : BuildConfig.DIRECTORY_SERVER_URL;
-			}
-
-			@Override
-			public String getWorkServerUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.WORK_SERVER_IPV6_URL : BuildConfig.WORK_SERVER_URL;
-			}
-
-			@Override
-			public String getBlobServerDownloadUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.BLOB_SERVER_DOWNLOAD_IPV6_URL : BuildConfig.BLOB_SERVER_DOWNLOAD_URL;
-			}
-
-			@Override
-			public String getBlobServerDoneUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.BLOB_SERVER_DONE_IPV6_URL : BuildConfig.BLOB_SERVER_DONE_URL;
-			}
-
-			@Override
-			public String getBlobServerUploadUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.BLOB_SERVER_UPLOAD_IPV6_URL : BuildConfig.BLOB_SERVER_UPLOAD_URL;
-			}
-
-			@Override
-			public String getAvatarServerUrl(boolean ipv6) {
-				return BuildConfig.AVATAR_FETCH_URL;
-			}
-
-			@Override
-			public String getSafeServerUrl(boolean ipv6) {
-				return BuildConfig.SAFE_SERVER_URL;
-			}
-
-			@Override
-			public String getWebServerUrl() {
-				return BuildConfig.WEB_SERVER_URL;
-			}
-
-			@Override
-			public String getWebOverrideSaltyRtcHost() {
-				return null;
-			}
-
-			@Override
-			public int getWebOverrideSaltyRtcPort() {
-				return 0;
-			}
-
-			@Override
-			public byte[] getThreemaPushPublicKey() {
-				return BuildConfig.THREEMA_PUSH_PUBLIC_KEY;
-			}
-
-			@NonNull
-			@Override
-			public String getMediatorUrl() {
-				return BuildConfig.MEDIATOR_SERVER_URL;
-			}
-
-			@NonNull
-			@Override
-			public String getAppRatingUrl() {
-				return BuildConfig.APP_RATING_URL;
-			}
-		};
-	}
-
-	private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
-		try {
-			URL curOnPremServer = makeUrlWithUsernamePassword(new URL(preferenceService.getOnPremServer()),
-				preferenceService.getLicenseUsername(), preferenceService.getLicensePassword());
-
-			// Note: must use toString when comparing URLs, as Java ignores userInfo in URL.equals()
-			if (onPremConfigFetcher == null || !curOnPremServer.toString().equals(lastOnPremServer.toString())) {
-				onPremConfigFetcher = new OnPremConfigFetcher(curOnPremServer, BuildConfig.ONPREM_CONFIG_TRUSTED_PUBLIC_KEYS);
-				lastOnPremServer = curOnPremServer;
-			}
-		} catch (MalformedURLException e) {
-			throw new ThreemaException("Bad OnPrem server URL", e);
-		}
-
-		return onPremConfigFetcher;
-	}
-
-	private URL makeUrlWithUsernamePassword(URL url, String username, String password) throws MalformedURLException {
-		String urlAuth = null;
-		try {
-			urlAuth = url.getProtocol() + "://" +
-				URLEncoder.encode(username, "UTF-8") + ":" +
-				URLEncoder.encode(password, "UTF-8") + "@" +
-				url.getHost();
-		} catch (UnsupportedEncodingException e) {
-			// UTF-8 is always supported
-			throw new RuntimeException(e);
-		}
-		if (url.getPort() > 0) {
-			urlAuth += ":" + url.getPort();
-		}
-		urlAuth += url.getFile();
-
-		return new URL(urlAuth);
-	}
+    private final PreferenceService preferenceService;
+    private OnPremConfigFetcher onPremConfigFetcher;
+    private URL lastOnPremServer;
+
+    public ServerAddressProviderServiceImpl(PreferenceService preferenceService) {
+        this.preferenceService = preferenceService;
+    }
+
+    @Override
+    @NonNull
+    public ServerAddressProvider getServerAddressProvider() {
+        if (ConfigUtils.isOnPremBuild()) {
+            return getServerAddressProviderOnPrem();
+        } else {
+            return getServerAddressProviderBuildConfig();
+        }
+    }
+
+    private ServerAddressProvider getServerAddressProviderOnPrem() {
+        return new ServerAddressProviderOnPrem(this::getOnPremConfigFetcher);
+    }
+
+    private ServerAddressProvider getServerAddressProviderBuildConfig() {
+        return new ServerAddressProvider() {
+            @Override
+            public String getChatServerNamePrefix(boolean ipv6) {
+                return ipv6 ? BuildConfig.CHAT_SERVER_IPV6_PREFIX : BuildConfig.CHAT_SERVER_PREFIX;
+            }
+
+            @Override
+            public String getChatServerNameSuffix(boolean ipv6) {
+                return BuildConfig.CHAT_SERVER_SUFFIX;
+            }
+
+            @Override
+            public int[] getChatServerPorts() {
+                return BuildConfig.CHAT_SERVER_PORTS;
+            }
+
+            @Override
+            public boolean getChatServerUseServerGroups() {
+                return BuildConfig.CHAT_SERVER_GROUPS;
+            }
+
+            @Override
+            public byte[] getChatServerPublicKey() {
+                return BuildConfig.SERVER_PUBKEY;
+            }
+
+            @Override
+            public byte[] getChatServerPublicKeyAlt() {
+                return BuildConfig.SERVER_PUBKEY_ALT;
+            }
+
+            @Override
+            public String getDirectoryServerUrl(boolean ipv6) {
+                return ipv6 ? BuildConfig.DIRECTORY_SERVER_IPV6_URL : BuildConfig.DIRECTORY_SERVER_URL;
+            }
+
+            @Override
+            public String getWorkServerUrl(boolean ipv6) {
+                return ipv6 ? BuildConfig.WORK_SERVER_IPV6_URL : BuildConfig.WORK_SERVER_URL;
+            }
+
+            /**
+             * @throws ThreemaException if the build config field for the correct base url is missing in current build flavor. This
+             * is the case if this implementation is incorrectly used in an on-prem build.
+             */
+            @NonNull
+            private String getBlobBaseUrlDefaultServer(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                final @NonNull String blobIdPrefix8 = blobIdHexString.substring(0, 2);
+                final @Nullable String baseUrlRawValue = useIpV6 ? BuildConfig.BLOB_SERVER_IPV6_URL : BuildConfig.BLOB_SERVER_URL;
+                // Could actually be null, if the build-config field was explicitly set to value "null" in build.gradle
+                //noinspection ConstantValue
+                if (baseUrlRawValue == null) {
+                    throw new ThreemaException("Missing value for blob server url in current build flavor");
+                }
+                return baseUrlRawValue.replace("{blobIdPrefix8}", blobIdPrefix8);
+            }
+
+            /**
+             * @throws ThreemaException if the build config field for the correct base url is missing in current build flavor. This
+             * is the case if this implementation is incorrectly used in an on-prem build.
+             */
+            @NonNull
+            @Override
+            public String getBlobBaseUrlMirrorServer(@NonNull MultiDevicePropertyProvider multiDevicePropertyProvider) throws ThreemaException {
+                final @NonNull byte[] deviceGroupId = multiDevicePropertyProvider.get().getKeys().getDgid$domain();
+                final @Nullable String deviceGroupIdHexString = Utils.byteArrayToHexString(deviceGroupId);
+                if (deviceGroupIdHexString == null || deviceGroupIdHexString.length() < 2) {
+                    throw new ThreemaException("Key deviceGroupId is not in correct form");
+                }
+                final @NonNull String deviceGroupIdPrefix4 = deviceGroupIdHexString.substring(0, 1);
+                final @NonNull String deviceGroupIdPrefix8 = deviceGroupIdHexString.substring(0, 2);
+                // Could actually be null, if the build-config field was explicitly set to value "null" in build.gradle
+                //noinspection ConstantValue
+                if (BuildConfig.BLOB_MIRROR_SERVER_URL == null) {
+                    throw new ThreemaException("Missing value for blob server url in current build flavor");
+                }
+                return BuildConfig.BLOB_MIRROR_SERVER_URL
+                    .replace("{deviceGroupIdPrefix4}", deviceGroupIdPrefix4)
+                    .replace("{deviceGroupIdPrefix8}", deviceGroupIdPrefix8);
+            }
+
+            @NonNull
+            @Override
+            public String getBlobServerDownloadUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+                final @NonNull String blobBaseUrlDefaultServer = getBlobBaseUrlDefaultServer(useIpV6, blobId);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlDefaultServer + "/" + blobIdHexString;
+            }
+
+            @NonNull
+            @Override
+            public String getBlobServerUploadUrl(boolean useIpV6) {
+                return useIpV6 ? BuildConfig.BLOB_SERVER_IPV6_URL_UPLOAD : BuildConfig.BLOB_SERVER_URL_UPLOAD;
+            }
+
+            @NonNull
+            @Override
+            public String getBlobServerDoneUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+                final @NonNull String blobBaseUrlDefaultServer = getBlobBaseUrlDefaultServer(useIpV6, blobId);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlDefaultServer + "/" + blobIdHexString + "/done";
+            }
+
+            @NonNull
+            @Override
+            public String getBlobMirrorServerDownloadUrl(
+                @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+                @NonNull byte[] blobId
+            ) throws ThreemaException {
+                final @NonNull String blobBaseUrlMirrorServer = getBlobBaseUrlMirrorServer(multiDevicePropertyProvider);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlMirrorServer + "/" + blobIdHexString;
+            }
+
+            @NonNull
+            @Override
+            public String getBlobMirrorServerUploadUrl(
+                @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+            ) throws ThreemaException {
+                final @NonNull String blobBaseUrlMirrorServer = getBlobBaseUrlMirrorServer(multiDevicePropertyProvider);
+                return blobBaseUrlMirrorServer + "/upload";
+            }
+
+            @NonNull
+            @Override
+            public String getBlobMirrorServerDoneUrl(
+                @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+                @NonNull byte[] blobId
+            ) throws ThreemaException {
+                final @NonNull String blobBaseUrlMirrorServer = getBlobBaseUrlMirrorServer(multiDevicePropertyProvider);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlMirrorServer + "/" + blobIdHexString + "/done";
+            }
+
+            @Override
+            public String getAvatarServerUrl(boolean ipv6) {
+                return BuildConfig.AVATAR_FETCH_URL;
+            }
+
+            @Override
+            public String getSafeServerUrl(boolean ipv6) {
+                return BuildConfig.SAFE_SERVER_URL;
+            }
+
+            @Override
+            public String getWebServerUrl() {
+                return BuildConfig.WEB_SERVER_URL;
+            }
+
+            @Override
+            public String getWebOverrideSaltyRtcHost() {
+                return null;
+            }
+
+            @Override
+            public int getWebOverrideSaltyRtcPort() {
+                return 0;
+            }
+
+            @Override
+            public byte[] getThreemaPushPublicKey() {
+                return BuildConfig.THREEMA_PUSH_PUBLIC_KEY;
+            }
+
+            @NonNull
+            @Override
+            public String getMediatorUrl() {
+                return BuildConfig.MEDIATOR_SERVER_URL;
+            }
+
+            @NonNull
+            @Override
+            public String getAppRatingUrl() {
+                return BuildConfig.APP_RATING_URL;
+            }
+        };
+    }
+
+    private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
+        try {
+            URL curOnPremServer = makeUrlWithUsernamePassword(new URL(preferenceService.getOnPremServer()),
+                preferenceService.getLicenseUsername(), preferenceService.getLicensePassword());
+
+            // Note: must use toString when comparing URLs, as Java ignores userInfo in URL.equals()
+            if (onPremConfigFetcher == null || !curOnPremServer.toString().equals(lastOnPremServer.toString())) {
+                onPremConfigFetcher = new OnPremConfigFetcher(curOnPremServer, BuildConfig.ONPREM_CONFIG_TRUSTED_PUBLIC_KEYS);
+                lastOnPremServer = curOnPremServer;
+            }
+        } catch (MalformedURLException e) {
+            throw new ThreemaException("Bad OnPrem server URL", e);
+        }
+
+        return onPremConfigFetcher;
+    }
+
+    private URL makeUrlWithUsernamePassword(@NonNull URL url, String username, String password) throws MalformedURLException {
+        String urlAuth = null;
+        try {
+            urlAuth = url.getProtocol() + "://" +
+                URLEncoder.encode(username, "UTF-8") + ":" +
+                URLEncoder.encode(password, "UTF-8") + "@" +
+                url.getHost();
+        } catch (UnsupportedEncodingException e) {
+            // UTF-8 is always supported
+            throw new RuntimeException(e);
+        }
+        if (url.getPort() > 0) {
+            urlAuth += ":" + url.getPort();
+        }
+        urlAuth += url.getFile();
+
+        return new URL(urlAuth);
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java b/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java
index 7f7baf44..740bfe8e 100644
--- a/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java
@@ -36,7 +36,6 @@ import java.util.List;
 import androidx.annotation.NonNull;
 import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
-import ch.threema.app.listeners.NewSyncedContactsListener;
 import ch.threema.app.listeners.SynchronizeContactsListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.routines.SynchronizeContactsRoutine;
@@ -44,6 +43,7 @@ import ch.threema.app.routines.UpdateBusinessAvatarRoutine;
 import ch.threema.app.utils.AndroidContactUtil;
 import ch.threema.app.utils.ContactUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ModelDeletedException;
 import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.api.APIConnector;
@@ -61,7 +61,7 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 	private final LocaleService localeService;
 	private final IdentityStoreInterface identityStore;
 
-	private final List<SynchronizeContactsRoutine> pendingRoutines = new ArrayList<SynchronizeContactsRoutine>();
+	private final List<SynchronizeContactsRoutine> pendingRoutines = new ArrayList<>();
 	private final IdListService excludedIdentityListService;
 	private final PreferenceService preferenceService;
 	private final DeviceService deviceService;
@@ -106,18 +106,10 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 
 		if (sync != null) {
 			if(this.deviceService != null && this.deviceService.isOnline()) {
-				sync.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
-					@Override
-					public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
-						// let user know that contact was added
-						ListenerManager.newSyncedContactListener.handle(new ListenerManager.HandleListener<NewSyncedContactsListener>() {
-							@Override
-							public void handle(NewSyncedContactsListener listener) {
-								listener.onNew(createdContacts);
-							}
-						});
-					}
-				});
+				sync.addOnFinished((success, modifiedAccounts, createdContacts, deletedAccounts) ->
+					// let user know that contact was added
+					ListenerManager.newSyncedContactListener.handle(listener -> listener.onNew(createdContacts))
+				);
 
 				new Thread(new Runnable() {
 					@Override
@@ -180,19 +172,20 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 		logger.info("Running contact sync");
 		logger.debug("instantiateSynchronization with account {}", account);
 
-        final SynchronizeContactsRoutine routine = new SynchronizeContactsRoutine(
-            this.context,
-            this.apiConnector,
-            this.contactService,
-            this.userService,
-            this.localeService,
-            this.contentResolver,
-            this.excludedIdentityListService,
-            this.deviceService,
-            this.preferenceService,
-            this.identityStore,
-            this.blockedContactsService
-        );
+		final SynchronizeContactsRoutine routine =
+				new SynchronizeContactsRoutine(
+						this.context,
+						this.apiConnector,
+						this.contactService,
+						this.contactModelRepository,
+						this.userService,
+						this.localeService,
+						this.contentResolver,
+						this.excludedIdentityListService,
+						this.deviceService,
+						this.preferenceService,
+						this.identityStore,
+						this.blockedContactsService);
 
 		synchronized (this.pendingRoutines) {
 			this.pendingRoutines.add(routine);
@@ -200,7 +193,7 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 
 		routine.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
 			@Override
-			public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
+			public void finished(boolean success, long modifiedAccounts, List<ch.threema.data.models.ContactModel> createdContacts, long deletedAccounts) {
 				finishedRoutine(routine);
 			}
 		});
@@ -292,9 +285,15 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 			// cleanup / degrade remaining identities that are still server verified
 			List<String> identities = contactService.getIdentitiesByVerificationLevel(VerificationLevel.SERVER_VERIFIED);
 			if (identities != null && !identities.isEmpty()) {
-				for (ContactModel contactModel : contactService.getByIdentities(identities)) {
-					contactModel.verificationLevel = VerificationLevel.UNVERIFIED;
-					contactService.save(contactModel);
+				for (String identity : identities) {
+					ch.threema.data.models.ContactModel model = contactModelRepository.getByIdentity(identity);
+					if (model != null) {
+						try {
+							model.setVerificationLevelFromLocal(VerificationLevel.UNVERIFIED);
+						} catch (ModelDeletedException e) {
+							logger.info("Could not set verification level because contact {} has been deleted", identity, e);
+						}
+					}
 				}
 			}
 		}
diff --git a/app/src/main/java/ch/threema/app/services/UserService.java b/app/src/main/java/ch/threema/app/services/UserService.java
index b5d87724..9476de98 100644
--- a/app/src/main/java/ch/threema/app/services/UserService.java
+++ b/app/src/main/java/ch/threema/app/services/UserService.java
@@ -24,10 +24,15 @@ package ch.threema.app.services;
 import android.accounts.Account;
 import android.accounts.AccountManagerCallback;
 
+import java.io.File;
 import java.util.Date;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.services.license.LicenseService;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.storage.models.ContactModel;
 
 /**
  * Method and actions for the current Threema-User!
@@ -103,7 +108,44 @@ public interface UserService {
 	 *
 	 * @return converted and truncated string or null if an error happens.
 	 */
-	@Nullable String setPublicNickname(String publicNickname);
+	@Nullable String setPublicNickname(String publicNickname, @NonNull TriggerSource triggerSource);
+
+    /**
+     * Get the user profile picture. If no profile picture is set, then null is returned.
+     */
+    @Nullable
+    byte[] getUserProfilePicture();
+
+    /**
+     * Set the user profile picture. Note that this will trigger a user profile sync if multi device
+     * is active.
+     */
+    boolean setUserProfilePicture(@NonNull File userProfilePicture, @NonNull TriggerSource triggerSource);
+
+    /**
+     * Set the user profile picture. Note that this will trigger a user profile sync if multi device
+     * is active.
+     */
+    boolean setUserProfilePicture(@NonNull byte[] userProfilePicture, @NonNull TriggerSource triggerSource);
+
+    /**
+     * Remove the user profile picture. Note that this will trigger a user profile sync if multi
+     * device is active.
+     */
+    void removeUserProfilePicture(@NonNull TriggerSource triggerSource);
+
+    /**
+     * Upload the current profile picture if it hasn't been uploaded recently and get the most
+     * recent contact profile picture upload data.
+     *
+     * @return the most recent profile picture upload data. If the upload failed or the last stored
+     * data could not be read, the returned data contains null as blob ID. If there is no profile
+     * picture set, the blob ID is {@link ContactModel#NO_PROFILE_PICTURE_BLOB_ID}.
+     */
+    @NonNull
+    @WorkerThread
+    ContactService.ProfilePictureUploadData uploadUserProfilePictureOrGetPreviousUploadData();
+
 
 	boolean restoreIdentity(String backupString, String password) throws Exception;
 
diff --git a/app/src/main/java/ch/threema/app/services/UserServiceImpl.java b/app/src/main/java/ch/threema/app/services/UserServiceImpl.java
index 510ddbb7..a058e0b1 100644
--- a/app/src/main/java/ch/threema/app/services/UserServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/UserServiceImpl.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.services;
 
-import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
-
 import android.accounts.Account;
 import android.accounts.AccountManager;
 import android.accounts.AccountManagerCallback;
@@ -31,22 +29,31 @@ import android.content.Context;
 import android.provider.ContactsContract;
 import android.text.format.DateUtils;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
+import com.neilalexander.jnacl.NaCl;
 
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.security.SecureRandom;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.HashSet;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.BuildFlavor;
 import ch.threema.app.R;
+import ch.threema.app.ThreemaApplication;
 import ch.threema.app.collections.Functional;
+import ch.threema.app.listeners.ProfileListener;
 import ch.threema.app.listeners.SMSVerificationListener;
 import ch.threema.app.managers.ListenerManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.routines.UpdateWorkInfoRoutine;
 import ch.threema.app.services.license.LicenseService;
 import ch.threema.app.services.license.SerialCredentials;
@@ -55,7 +62,10 @@ import ch.threema.app.stores.IdentityStore;
 import ch.threema.app.stores.PreferenceStore;
 import ch.threema.app.stores.PreferenceStoreInterface;
 import ch.threema.app.stores.PreferenceStoreInterfaceDevNullImpl;
+import ch.threema.app.tasks.ReflectUserProfileNicknameSyncTask;
+import ch.threema.app.tasks.TaskCreator;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.DeviceIdUtil;
 import ch.threema.app.utils.LocaleUtil;
 import ch.threema.app.utils.PushUtil;
@@ -67,8 +77,16 @@ import ch.threema.domain.identitybackup.IdentityBackupDecoder;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.api.CreateIdentityRequestDataInterface;
+import ch.threema.domain.protocol.blob.BlobScope;
+import ch.threema.domain.protocol.blob.BlobUploader;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.stores.IdentityStoreInterface;
+import ch.threema.domain.taskmanager.TaskManager;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.storage.models.ContactModel;
+
+import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
+import static ch.threema.app.utils.StreamUtilKt.toByteArray;
 
 /**
  * This service class handle all user actions (db/identity....)
@@ -76,12 +94,28 @@ import ch.threema.domain.stores.IdentityStoreInterface;
 public class UserServiceImpl implements UserService, CreateIdentityRequestDataInterface  {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("UserServiceImpl");
 
+    @NonNull
 	private final Context context;
+    @NonNull
 	private final PreferenceStoreInterface preferenceStore;
+    @NonNull
 	private final IdentityStore identityStore;
+    @NonNull
 	private final APIConnector apiConnector;
+    @NonNull
+    private final ApiService apiService;
+    @NonNull
+    private final FileService fileService;
+    @NonNull
 	private final LocaleService localeService;
+    @NonNull
 	private final PreferenceService preferenceService;
+    @NonNull
+	private final TaskManager taskManager;
+    @NonNull
+    private final TaskCreator taskCreator;
+    @NonNull
+    private final MultiDeviceManager multiDeviceManager;
 	private String policyResponseData;
 	private String policySignature;
 	private int policyErrorCode;
@@ -92,19 +126,29 @@ public class UserServiceImpl implements UserService, CreateIdentityRequestDataIn
 	private boolean isFsEnabled = true;
 
 	public UserServiceImpl(
-		Context context,
-		PreferenceStoreInterface preferenceStore,
-		LocaleService localeService,
-		APIConnector apiConnector,
-		IdentityStore identityStore,
-		PreferenceService preferenceService
+		@NonNull Context context,
+		@NonNull PreferenceStoreInterface preferenceStore,
+		@NonNull LocaleService localeService,
+		@NonNull APIConnector apiConnector,
+        @NonNull ApiService apiService,
+        @NonNull FileService fileService,
+		@NonNull IdentityStore identityStore,
+		@NonNull PreferenceService preferenceService,
+        @NonNull TaskManager taskManager,
+        @NonNull TaskCreator taskCreator,
+        @NonNull MultiDeviceManager multiDeviceManager
 	) {
 		this.context = context;
 		this.preferenceStore = preferenceStore;
 		this.localeService = localeService;
 		this.identityStore = identityStore;
 		this.apiConnector = apiConnector;
+        this.apiService = apiService;
+        this.fileService = fileService;
 		this.preferenceService = preferenceService;
+        this.taskCreator = taskCreator;
+        this.taskManager = taskManager;
+        this.multiDeviceManager = multiDeviceManager;
 	}
 
 	@Override
@@ -437,19 +481,167 @@ public class UserServiceImpl implements UserService, CreateIdentityRequestDataIn
 	}
 
 	@Override
-	public String setPublicNickname(String publicNickname) {
-		//truncate string into a 32 byte length string
-		//fix #ANDR-530
-		String truncated = Utils.truncateUTF8String(publicNickname, ProtocolDefines.PUSH_FROM_LEN);
-		this.identityStore.setPublicNickname(truncated);
-		//run update work info (only if the app is the work version)
-		if(ConfigUtils.isWorkBuild()) {
+	public String setPublicNickname(String publicNickname, @NonNull TriggerSource triggerSource) {
+        final @NonNull String oldNickname = this.identityStore.getPublicNickname();
+		// truncate string into a 32 byte length string
+		// fix #ANDR-530
+		final @Nullable String publicNicknameTruncated = Utils.truncateUTF8String(
+            publicNickname,
+            ProtocolDefines.PUSH_FROM_LEN
+        );
+		this.identityStore.persistPublicNickname(publicNicknameTruncated);
+		// run update work info (only if the app is the work version)
+		if (ConfigUtils.isWorkBuild()) {
 			UpdateWorkInfoRoutine.start();
 		}
-		return truncated;
-	}
+        if (publicNicknameTruncated != null && !publicNicknameTruncated.equals(oldNickname)
+            && multiDeviceManager.isMultiDeviceActive()
+            && triggerSource != TriggerSource.SYNC) {
+            taskManager.schedule(
+                new ReflectUserProfileNicknameSyncTask(
+                    publicNicknameTruncated,
+                    ThreemaApplication.requireServiceManager()
+                )
+            );
+        }
+		return publicNicknameTruncated;
+	}
+
+    @Override
+    @Nullable
+    public byte[] getUserProfilePicture() {
+        try {
+            return toByteArray(fileService.getUserDefinedProfilePictureStream(getIdentity()));
+        } catch (Exception e) {
+            logger.error("Could not get user profile picture");
+            return null;
+        }
+    }
+
+    @Override
+    public boolean setUserProfilePicture(@NonNull File userProfilePicture, @NonNull TriggerSource triggerSource) {
+        try {
+            fileService.writeUserDefinedProfilePicture(getIdentity(), userProfilePicture);
+            onUserProfilePictureChanged();
+            if (multiDeviceManager.isMultiDeviceActive() && triggerSource != TriggerSource.SYNC) {
+               taskCreator.scheduleReflectUserProfilePictureTask();
+            }
+            return true;
+        } catch (Exception e) {
+            logger.error("Could not set user profile picture", e);
+            return false;
+        }
+    }
+
+    @Override
+    public boolean setUserProfilePicture(@NonNull byte[] userProfilePicture, @NonNull TriggerSource triggerSource) {
+        try {
+            fileService.writeUserDefinedProfilePicture(getIdentity(), userProfilePicture);
+            onUserProfilePictureChanged();
+            if (multiDeviceManager.isMultiDeviceActive() && triggerSource != TriggerSource.SYNC) {
+                taskCreator.scheduleReflectUserProfilePictureTask();
+            }
+            return true;
+        } catch (Exception e) {
+            logger.error("Could not set user profile picture", e);
+            return false;
+        }
+    }
+
+    @Override
+    public void removeUserProfilePicture(@NonNull TriggerSource triggerSource) {
+        fileService.removeUserDefinedProfilePicture(getIdentity());
+        onUserProfilePictureChanged();
+        if (multiDeviceManager.isMultiDeviceActive() && triggerSource != TriggerSource.SYNC) {
+            taskCreator.scheduleReflectUserProfilePictureTask();
+        }
+    }
+
+    @Override
+    @WorkerThread
+    @NonNull
+    public ContactService.ProfilePictureUploadData uploadUserProfilePictureOrGetPreviousUploadData() {
+        byte[] profilePicture = getUserProfilePicture();
+        if (profilePicture == null) {
+            // If there is no profile picture set, then return empty upload data with an empty byte
+            // array as blob ID.
+            ContactService.ProfilePictureUploadData data = new ContactService.ProfilePictureUploadData();
+            data.blobId = ContactModel.NO_PROFILE_PICTURE_BLOB_ID;
+            return data;
+        }
+
+        // Only upload blob every 7 days
+        long uploadedAt = preferenceService.getProfilePicUploadDate();
+        Date uploadDeadline = new Date(uploadedAt + ContactUtil.PROFILE_PICTURE_BLOB_CACHE_DURATION);
+        Date now = new Date();
+
+        if (now.after(uploadDeadline)) {
+            logger.info("Uploading profile picture blob");
+
+            ContactService.ProfilePictureUploadData data = uploadContactPhoto(profilePicture);
+
+            if (data == null) {
+                return new ContactService.ProfilePictureUploadData();
+            }
+
+            data.uploadedAt = now.getTime();
+
+            preferenceService.setProfilePicUploadDate(now);
+            preferenceService.setProfilePicUploadData(data);
+            return data;
+        } else {
+            ContactService.ProfilePictureUploadData data = preferenceService.getProfilePicUploadData();
+            if (data != null) {
+                data.uploadedAt = uploadedAt;
+                data.bitmapArray = profilePicture;
+                return data;
+            } else {
+                return new ContactService.ProfilePictureUploadData();
+            }
+        }
+    }
+
+    @Nullable
+    private ContactService.ProfilePictureUploadData uploadContactPhoto(@NonNull byte[] contactPhoto) {
+        ContactService.ProfilePictureUploadData data = new ContactService.ProfilePictureUploadData();
+
+        SecureRandom rnd = new SecureRandom();
+        data.encryptionKey = new byte[NaCl.SYMMKEYBYTES];
+        rnd.nextBytes(data.encryptionKey);
+
+        data.bitmapArray = contactPhoto;
+        byte[] imageData = NaCl.symmetricEncryptData(data.bitmapArray, data.encryptionKey, ProtocolDefines.CONTACT_PHOTO_NONCE);
+        try {
+            BlobUploader blobUploader = this.apiService.createUploader(
+                imageData,
+                false,
+                BlobScope.Public.INSTANCE
+            );
+            data.blobId = blobUploader.upload();
+        } catch (ThreemaException | IOException e) {
+            logger.error("Could not upload contact photo", e);
+
+            if (e instanceof FileNotFoundException && ConfigUtils.isOnPremBuild()) {
+                logger.info("Invalidating auth token");
+                apiService.invalidateAuthToken();
+            }
+
+            return null;
+        }
+        data.size = imageData.length;
+        return data;
+    }
+
+    private void onUserProfilePictureChanged() {
+        // Reset the last profile picture upload date
+        this.preferenceService.setProfilePicUploadDate(new Date(0));
+        this.preferenceService.setProfilePicUploadData(null);
+
+        // Notify listeners
+        ListenerManager.profileListeners.handle(ProfileListener::onAvatarChanged);
+    }
 
-	private String getLanguage() {
+    private String getLanguage() {
 		return LocaleUtil.getLanguage();
 	}
 
diff --git a/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt b/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt
index 45751c37..022f0a8b 100644
--- a/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt
+++ b/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt
@@ -23,8 +23,6 @@ package ch.threema.app.services
 
 import android.Manifest
 import android.annotation.SuppressLint
-import android.app.NotificationChannel
-import android.app.NotificationManager
 import android.app.PendingIntent
 import android.app.PendingIntent.FLAG_IMMUTABLE
 import android.app.PendingIntent.FLAG_UPDATE_CURRENT
@@ -71,7 +69,6 @@ import com.google.common.util.concurrent.ListenableFuture
 
 @androidx.annotation.OptIn(androidx.media3.common.util.UnstableApi::class)
 class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudioFocusChangeListener {
-    private val logger = LoggingUtil.getThreemaLogger(TAG)
     private val audioBecomingNoisyFilter = IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY)
     private val audioBecomingNoisyReceiver: BroadcastReceiver = object : BroadcastReceiver() {
         override fun onReceive(context: Context, intent: Intent) {
@@ -82,7 +79,7 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
     }
 
     private lateinit var player: ExoPlayer
-    private lateinit var mediaSession: MediaSession
+    private var mediaSession: MediaSession? = null
     private lateinit var audioManager: AudioManager
     private lateinit var audioFocusRequestCompat: AudioFocusRequestCompat
 
@@ -92,6 +89,8 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
 
     companion object {
         private const val TAG = "VoiceMessagePlayerService"
+        private val logger = LoggingUtil.getThreemaLogger(TAG)
+
         private const val NOTIFICATION_ID = 59843
     }
 
@@ -122,8 +121,10 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         mediaNotificationProvider.setSmallIcon(R.drawable.ic_notification_small)
         setMediaNotificationProvider(mediaNotificationProvider)
 
-        initializeSessionAndPlayer()
-        setListener(MediaSessionServiceListener())
+        val sessionWasCreated = initializeSessionAndPlayer()
+        if (sessionWasCreated) {
+            setListener(MediaSessionServiceListener())
+        }
     }
 
     override fun onUpdateNotification(session: MediaSession, startInForegroundRequired: Boolean) {
@@ -133,9 +134,7 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         super.onUpdateNotification(session, true)
     }
 
-    override fun onGetSession(controllerInfo: MediaSession.ControllerInfo): MediaSession {
-        return mediaSession
-    }
+    override fun onGetSession(controllerInfo: MediaSession.ControllerInfo): MediaSession? = mediaSession
 
     override fun onTaskRemoved(rootIntent: Intent?) {
         logger.info("onTaskRemoved")
@@ -146,6 +145,11 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
 
     override fun onDestroy() {
         logger.info("onDestroy")
+        destroySelf()
+        super.onDestroy()
+    }
+
+    private fun destroySelf() {
         preferenceService?.let {
             if (it.isUseProximitySensor) {
                 sensorService?.unregisterSensors(TAG)
@@ -153,22 +157,21 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         }
         releaseAudioFocus()
         player.release()
-        mediaSession.release()
+        mediaSession?.release()
         clearListener()
-        super.onDestroy()
     }
 
-    private fun initializeSessionAndPlayer() {
+    private fun initializeSessionAndPlayer(): Boolean {
         player = ExoPlayer.Builder(this)
-                .setRenderersFactory(SamsungQuirkRenderersFactory(this))
-                .setAudioAttributes(getRegularAudioAttributes(), false)
-                .setWakeMode(C.WAKE_MODE_LOCAL)
-                .setLoadControl(
-                        DefaultLoadControl.Builder()
-                                .setBufferDurationsMs(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE)
-                                .build()
-                )
-                .build()
+            .setRenderersFactory(SamsungQuirkRenderersFactory(this))
+            .setAudioAttributes(getRegularAudioAttributes(), false)
+            .setWakeMode(C.WAKE_MODE_LOCAL)
+            .setLoadControl(
+                DefaultLoadControl.Builder()
+                    .setBufferDurationsMs(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE)
+                    .build()
+            )
+            .build()
 
         preferenceService?.let {
             player.addListener(object : Player.Listener {
@@ -192,32 +195,56 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         }
 
         val mediaSessionCallback = (object : Callback {
-            override fun onAddMediaItems(mediaSession: MediaSession, controller: MediaSession.ControllerInfo, mediaItems: MutableList<MediaItem>): ListenableFuture<MutableList<MediaItem>> {
+            override fun onAddMediaItems(
+                mediaSession: MediaSession,
+                controller: MediaSession.ControllerInfo,
+                mediaItems: MutableList<MediaItem>
+            ): ListenableFuture<MutableList<MediaItem>> {
                 val resolvedMediaItems = mutableListOf<MediaItem>()
                 for (mediaItem in mediaItems) {
                     val resolvedMediaItem = MediaItem.Builder()
-                            .setUri(Uri.parse(mediaItem.mediaId))
-                            .setMediaId(mediaItem.mediaId)
-                            .setMediaMetadata(mediaItem.mediaMetadata)
-                            .build()
+                        .setUri(Uri.parse(mediaItem.mediaId))
+                        .setMediaId(mediaItem.mediaId)
+                        .setMediaMetadata(mediaItem.mediaMetadata)
+                        .build()
                     resolvedMediaItems.add(resolvedMediaItem)
                 }
                 return Futures.immediateFuture(resolvedMediaItems)
             }
         })
 
-        mediaSession =
-                MediaSession.Builder(this, player)
-                        .setCallback(mediaSessionCallback)
-                        .setSessionActivity(getSessionActivityPendingIntent())
-                        .build()
+        val mediaSessionBuilder = MediaSession
+            .Builder(this, player)
+            .setCallback(mediaSessionCallback)
+            .setSessionActivity(getSessionActivityPendingIntent())
+
+        // TODO(ANDR-3531): Remove this workaround after media3 dependency update to version >= 1.5
+        try {
+            mediaSession = mediaSessionBuilder.build()
+        } catch (exception: IllegalArgumentException) {
+            if (ConfigUtils.isMotorolaDevice()) {
+                // Some motorola devices throw an unexpected IllegalArgumentException.
+                // This workaround can be removed when we update media3-session to >= 1.5
+                // https://github.com/androidx/media/issues/1730
+                logger.error(
+                    "Caught IllegalArgumentException on a motorola device when attempting to set the media button broadcast receiver.",
+                    exception
+                )
+            } else {
+                logger.error("Failed to create a media session.", exception)
+            }
+            destroySelf()
+            stopSelf()
+            return false
+        }
+        return true
     }
 
     private fun getSessionActivityPendingIntent(): PendingIntent {
         val intent = packageManager
-                .getLaunchIntentForPackage(packageName)
-                ?.setPackage(null)
-                ?.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)
+            .getLaunchIntentForPackage(packageName)
+            ?.setPackage(null)
+            ?.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)
 
         val immutableFlag = if (Build.VERSION.SDK_INT >= 23) FLAG_IMMUTABLE else 0
         return getActivity(this, 0, intent, immutableFlag or FLAG_UPDATE_CURRENT)
@@ -235,16 +262,16 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
             if (ConfigUtils.isPermissionGranted(this@VoiceMessagePlayerService, Manifest.permission.POST_NOTIFICATIONS)) {
                 val notificationManagerCompat = NotificationManagerCompat.from(this@VoiceMessagePlayerService)
                 val builder =
-                        NotificationCompat.Builder(this@VoiceMessagePlayerService, NotificationChannels.NOTIFICATION_CHANNEL_ALERT)
-                                .setContentIntent(getSessionActivityPendingIntent())
-                                .setSmallIcon(R.drawable.ic_notification_small)
-                                .setColor(ResourcesCompat.getColor(resources, R.color.md_theme_light_primary, theme))
-                                .setContentTitle(getString(R.string.vm_fg_service_not_allowed))
-                                .setStyle(
-                                        NotificationCompat.BigTextStyle().bigText(getString(R.string.vm_fg_service_not_allowed_explain))
-                                )
-                                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
-                                .setAutoCancel(true)
+                    NotificationCompat.Builder(this@VoiceMessagePlayerService, NotificationChannels.NOTIFICATION_CHANNEL_ALERT)
+                        .setContentIntent(getSessionActivityPendingIntent())
+                        .setSmallIcon(R.drawable.ic_notification_small)
+                        .setColor(ResourcesCompat.getColor(resources, R.color.md_theme_light_primary, theme))
+                        .setContentTitle(getString(R.string.vm_fg_service_not_allowed))
+                        .setStyle(
+                            NotificationCompat.BigTextStyle().bigText(getString(R.string.vm_fg_service_not_allowed_explain))
+                        )
+                        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
+                        .setAutoCancel(true)
 
                 notificationManagerCompat.notify(NOTIFICATION_ID, builder.build())
             } else {
@@ -295,19 +322,22 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
             AudioManager.AUDIOFOCUS_GAIN -> {
                 player.volume = 1.0f
             }
+
             AudioManager.AUDIOFOCUS_LOSS -> {
                 player.pause()
             }
+
             AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {
                 player.pause()
             }
+
             AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {
                 player.volume = 0.2f
             }
         }
     }
 
-    private fun getRegularAudioAttributes() : AudioAttributes {
+    private fun getRegularAudioAttributes(): AudioAttributes {
         return AudioAttributes.Builder()
             .setUsage(C.USAGE_MEDIA)
             .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)
@@ -315,7 +345,7 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
             .build()
     }
 
-    private fun getEarpieceAudioAttributes() : AudioAttributes {
+    private fun getEarpieceAudioAttributes(): AudioAttributes {
         return AudioAttributes.Builder()
             .setUsage(C.USAGE_VOICE_COMMUNICATION)
             .setContentType(C.AUDIO_CONTENT_TYPE_SPEECH)
diff --git a/app/src/main/java/ch/threema/app/services/ballot/BallotService.java b/app/src/main/java/ch/threema/app/services/ballot/BallotService.java
index 79cfc936..8bf08b4a 100644
--- a/app/src/main/java/ch/threema/app/services/ballot/BallotService.java
+++ b/app/src/main/java/ch/threema/app/services/ballot/BallotService.java
@@ -35,7 +35,7 @@ import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotCreateInterface;
+import ch.threema.domain.protocol.csp.messages.ballot.BallotSetupInterface;
 import ch.threema.domain.protocol.csp.messages.ballot.BallotVoteInterface;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -95,7 +95,7 @@ public interface BallotService {
 	 * @return BallotUpdateResult
 	 * @throws ThreemaException if an error occurred during processing
 	 */
-	@NonNull BallotUpdateResult update(BallotCreateInterface createMessage) throws ThreemaException, BadMessageException;
+	@NonNull BallotUpdateResult update(BallotSetupInterface createMessage) throws ThreemaException, BadMessageException;
 	boolean update(BallotModel ballotModel);
 
 	BallotPublishResult publish(MessageReceiver<?> messageReceiver, BallotModel ballotModel,
diff --git a/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java b/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java
index 90a513d4..a683c7ba 100644
--- a/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java
@@ -61,7 +61,7 @@ import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotCreateInterface;
+import ch.threema.domain.protocol.csp.messages.ballot.BallotSetupInterface;
 import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.BallotData;
 import ch.threema.domain.protocol.csp.messages.ballot.BallotDataChoice;
@@ -83,1433 +83,1416 @@ import ch.threema.storage.models.ballot.IdentityBallotModel;
 import ch.threema.storage.models.ballot.LinkBallotModel;
 
 public class BallotServiceImpl implements BallotService {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BallotServiceImpl");
-
-	private static final int REQUIRED_CHOICE_COUNT = 2;
-
-	private final SparseArray<BallotModel> ballotModelCache;
-	private final SparseArray<LinkBallotModel> linkBallotModelCache;
-
-	private final DatabaseServiceNew databaseServiceNew;
-	private final UserService userService;
-	private final GroupService groupService;
-	private final ContactService contactService;
-	private final ServiceManager serviceManager;
-
-	private int openBallotId = 0;
-
-	public BallotServiceImpl(SparseArray<BallotModel> ballotModelCache,
-	                         SparseArray<LinkBallotModel> linkBallotModelCache,
-	                         DatabaseServiceNew databaseServiceNew,
-	                         UserService userService,
-	                         GroupService groupService,
-	                         ContactService contactService,
-	                         ServiceManager serviceManager) {
-		this.ballotModelCache = ballotModelCache;
-		this.linkBallotModelCache = linkBallotModelCache;
-		this.databaseServiceNew = databaseServiceNew;
-		this.userService = userService;
-		this.groupService = groupService;
-		this.contactService = contactService;
-		this.serviceManager = serviceManager;
-	}
-
-	@Override
-	public BallotModel create(GroupModel groupModel,
-							  String description,
-							  BallotModel.State state,
-							  BallotModel.Assessment assessment,
-							  BallotModel.Type type,
-							  BallotModel.ChoiceType choiceType) throws NotAllowedException {
-
-		final BallotModel model = this.create(description, state, assessment, type, choiceType);
-		if (model != null) {
-			this.link(groupModel, model);
-			//handle
-		}
-
-
-		return model;
-	}
-
-	@Override
-	public boolean modifyFinished(final BallotModel ballotModel) throws MessageTooLongException {
-		if(ballotModel != null) {
-			switch (ballotModel.getState()) {
-				case TEMPORARY:
-					ballotModel.setState(BallotModel.State.OPEN);
-					try {
-						this.checkAccess();
-						this.databaseServiceNew.getBallotModelFactory().update(
-								ballotModel
-						);
-					} catch (NotAllowedException e) {
-						logger.error("Exception", e);
-						return false;
-					}
-
-					try {
-						return this.send(ballotModel, listener -> {
-							if (listener.handle(ballotModel)) {
-								listener.onCreated(ballotModel);
-							}
-						});
-					} catch (MessageTooLongException e) {
-						ballotModel.setState(BallotModel.State.TEMPORARY);
-						this.databaseServiceNew.getBallotModelFactory().update(
-							ballotModel
-						);
-						throw new MessageTooLongException();
-					}
-				default:
-					this.handleModified(ballotModel);
-					break;
-			}
-			return true;
-		}
-		return false;
-	}
-
-	@Override
-	public boolean viewingBallot(BallotModel ballotModel,  boolean view) {
-		if(ballotModel != null) {
-			if(view) {
-				ballotModel.setLastViewedAt(new Date());
-				this.databaseServiceNew.getBallotModelFactory().update(
-						ballotModel);
-				this.openBallotId = ballotModel.getId();
-				//disabled for the moment!
+    private static final Logger logger = LoggingUtil.getThreemaLogger("BallotServiceImpl");
+
+    private static final int REQUIRED_CHOICE_COUNT = 2;
+
+    private final SparseArray<BallotModel> ballotModelCache;
+    private final SparseArray<LinkBallotModel> linkBallotModelCache;
+
+    private final DatabaseServiceNew databaseServiceNew;
+    private final UserService userService;
+    private final GroupService groupService;
+    private final ContactService contactService;
+    private final ServiceManager serviceManager;
+
+    private int openBallotId = 0;
+
+    public BallotServiceImpl(SparseArray<BallotModel> ballotModelCache,
+                             SparseArray<LinkBallotModel> linkBallotModelCache,
+                             DatabaseServiceNew databaseServiceNew,
+                             UserService userService,
+                             GroupService groupService,
+                             ContactService contactService,
+                             ServiceManager serviceManager) {
+        this.ballotModelCache = ballotModelCache;
+        this.linkBallotModelCache = linkBallotModelCache;
+        this.databaseServiceNew = databaseServiceNew;
+        this.userService = userService;
+        this.groupService = groupService;
+        this.contactService = contactService;
+        this.serviceManager = serviceManager;
+    }
+
+    @Override
+    public BallotModel create(GroupModel groupModel,
+                              String description,
+                              BallotModel.State state,
+                              BallotModel.Assessment assessment,
+                              BallotModel.Type type,
+                              BallotModel.ChoiceType choiceType) throws NotAllowedException {
+
+        final BallotModel model = this.create(description, state, assessment, type, choiceType);
+        if (model != null) {
+            this.link(groupModel, model);
+            //handle
+        }
+
+
+        return model;
+    }
+
+    @Override
+    public boolean modifyFinished(final BallotModel ballotModel) throws MessageTooLongException {
+        if (ballotModel != null) {
+            switch (ballotModel.getState()) {
+                case TEMPORARY:
+                    ballotModel.setState(BallotModel.State.OPEN);
+                    try {
+                        this.checkAccess();
+                        this.databaseServiceNew.getBallotModelFactory().update(
+                            ballotModel
+                        );
+                    } catch (NotAllowedException e) {
+                        logger.error("Exception", e);
+                        return false;
+                    }
+
+                    try {
+                        return this.send(ballotModel, listener -> {
+                            if (listener.handle(ballotModel)) {
+                                listener.onCreated(ballotModel);
+                            }
+                        });
+                    } catch (MessageTooLongException e) {
+                        ballotModel.setState(BallotModel.State.TEMPORARY);
+                        this.databaseServiceNew.getBallotModelFactory().update(
+                            ballotModel
+                        );
+                        throw new MessageTooLongException();
+                    }
+                default:
+                    this.handleModified(ballotModel);
+                    break;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean viewingBallot(BallotModel ballotModel, boolean view) {
+        if (ballotModel != null) {
+            if (view) {
+                ballotModel.setLastViewedAt(new Date());
+                this.databaseServiceNew.getBallotModelFactory().update(
+                    ballotModel);
+                this.openBallotId = ballotModel.getId();
+                //disabled for the moment!
 //						this.handleModified(ballotModel);
-				return true;
-			}
-			else if(this.openBallotId == ballotModel.getId()) {
-				this.openBallotId = 0;
-			}
-
-		}
-		return false;
-	}
-
-	@Override
-	public BallotModel create(ContactModel contactModel,
-							  String description,
-							  BallotModel.State state,
-							  BallotModel.Assessment assessment,
-							  BallotModel.Type type,
-							  BallotModel.ChoiceType choiceType) throws NotAllowedException {
-		final BallotModel model = this.create(description,state,assessment,type, choiceType);
-		if(model != null) {
-			this.link(contactModel, model);
-		}
-
-		return model;
-	}
-
-	private BallotModel create(String description,
-							  BallotModel.State state,
-							  BallotModel.Assessment assessment,
-							  BallotModel.Type type,
-							  BallotModel.ChoiceType choiceType) throws NotAllowedException {
-		//create a new blank model
-		try {
-			this.checkAccess();
-
-
-
-			final BallotModel ballotModel = new BallotModel();
-			//unique id
-			String randomId = UUID.randomUUID().toString();
-			BallotId newBallotId = new BallotId(
-					Utils.hexStringToByteArray(
-							randomId.substring(randomId.length() - (ProtocolDefines.BALLOT_ID_LEN * 2))
-					));
-
-			ballotModel.setApiBallotId(Utils.byteArrayToHexString(newBallotId.getBallotId()));
-			ballotModel.setCreatorIdentity(this.userService.getIdentity());
-			ballotModel.setCreatedAt(new Date());
-			ballotModel.setModifiedAt(new Date());
-			ballotModel.setName(description);
-			ballotModel.setState(state);
-			ballotModel.setAssessment(assessment);
-			ballotModel.setType(type);
-			ballotModel.setChoiceType(choiceType);
-			ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE); // default display type for ballots created on mobile client.
-			ballotModel.setLastViewedAt(new Date());
-
-			this.databaseServiceNew.getBallotModelFactory().create(
-					ballotModel
-			);
-
-			this.cache(ballotModel);
-
-			return ballotModel;
-
-		}
-		catch (NotAllowedException notAllowedException) {
-			logger.error("Not allowed", notAllowedException);
-			throw notAllowedException;
-		}
-		catch (ThreemaException e) {
-			logger.error("Exception", e);
-			return null;
-		}
-	}
-
-	@Override
-	public boolean update(BallotModel ballotModel, BallotChoiceModel choice) throws NotAllowedException {
-		if(choice.getId() > 0 && choice.getBallotId() > 0 && choice.getBallotId() != ballotModel.getId()) {
-			throw new NotAllowedException("choice already set on another ballot");
-		}
-
-		if(choice.getApiBallotChoiceId() <= 0) {
-			throw new NotAllowedException("no api ballot choice id set");
-		}
-		choice.setBallotId(ballotModel.getId());
-
-		if(choice.getCreatedAt() == null) {
-			choice.setCreatedAt(new Date());
-		}
-
-		choice.setModifiedAt(new Date());
-
-		return this.databaseServiceNew.getBallotChoiceModelFactory().create(
-				choice
-		);
-	}
-
-	@Override
-	public boolean close(Integer ballotModelId) throws NotAllowedException, MessageTooLongException {
-		//be sure to use the cached ballot model!
-		final BallotModel ballotModel = this.get(ballotModelId);
-
-		//if i am not the creator
-		if(!BallotUtil.canClose(ballotModel, this.userService.getIdentity())) {
-			throw new NotAllowedException();
-		}
-
-		MessageReceiver messageReceiver = this.getReceiver(ballotModel);
-		if(messageReceiver == null) {
-			return false;
-		}
-
-		//save model
-		ballotModel.setState(BallotModel.State.CLOSED);
-		if (this.update(ballotModel)) {
-			return this.send(ballotModel, listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onClosed(ballotModel);
-				}
-			});
-		}
-		return false;
-	}
-
-	@Override
-	public boolean send(BallotModel ballotModel, ListenerManager.HandleListener<BallotListener> handleListener) throws MessageTooLongException {
-		//add message
-		if (TestUtil.compare(userService.getIdentity(), ballotModel.getCreatorIdentity())) {
-			//ok, i am the creator.... send a message to every participant
-			try {
-				if (serviceManager.getMessageService() != null) {
-					if (serviceManager.getMessageService().sendBallotMessage(ballotModel) != null) {
-						ListenerManager.ballotListeners.handle(handleListener);
-						return true;
-					}
-				}
-			} catch (ThreemaException e) {
-				logger.error("Exception", e);
-				if (e instanceof MessageTooLongException) {
-					throw new MessageTooLongException();
-				}
-			}
-		}
-		return false;
-	}
-
-	@Override
-	@Nullable
-	public BallotModel get(int ballotId) {
-		BallotModel model = this.getFromCache(ballotId);
-		if(model == null) {
-			model = this.databaseServiceNew.getBallotModelFactory().getById(
-					ballotId
-			);
-
-			this.cache(model);
-		}
-		return model;
-	}
-
-	@Override
-	@NonNull
-	public BallotUpdateResult update(BallotCreateInterface createMessage) throws ThreemaException, BadMessageException {
-		//check if allowed
-		BallotData data = createMessage.getData();
-		if (data == null) {
-			throw new ThreemaException("invalid format");
-		}
-
-		final BallotModel.State toState;
-		final BallotModel ballotModel;
-
-		Date date = ((AbstractMessage)createMessage).getDate();
-		BallotModel existingModel = this.get(createMessage.getBallotId().toString(), createMessage.getBallotCreator());
-
-		if (existingModel != null) {
-			if (data.getDisplayType() != null && existingModel.getDisplayType() != null && data.getDisplayType().ordinal() != existingModel.getDisplayType().ordinal()) {
-				throw new BadMessageException("Ballot display mode not allowed to change. Discarding message");
-			}
-			if (data.getState() == BallotData.State.CLOSED) {
-				ballotModel = existingModel;
-				toState = BallotModel.State.CLOSED;
-			}
-			else {
-				throw new BadMessageException("Ballot with same ID already exists. Discarding message.");
-			}
-		} else {
-			if (data.getState() != BallotData.State.CLOSED) {
-				ballotModel = new BallotModel();
-				ballotModel.setCreatorIdentity(createMessage.getBallotCreator());
-				ballotModel.setApiBallotId(createMessage.getBallotId().toString());
-				ballotModel.setCreatedAt(date);
-				ballotModel.setLastViewedAt(null);
-				toState = BallotModel.State.OPEN;
-			} else {
-				throw new BadMessageException("New ballot with closed state requested. Discarding message.");
-			}
-		}
-
-		ballotModel.setName(data.getDescription());
-		ballotModel.setModifiedAt(new Date());
-
-		switch (data.getAssessmentType()) {
-			case MULTIPLE:
-				ballotModel.setAssessment(BallotModel.Assessment.MULTIPLE_CHOICE);
-				break;
-			case SINGLE:
-				ballotModel.setAssessment(BallotModel.Assessment.SINGLE_CHOICE);
-				break;
-		}
-
-		switch (data.getType()) {
-			case RESULT_ON_CLOSE:
-				ballotModel.setType(BallotModel.Type.RESULT_ON_CLOSE);
-				break;
-			case INTERMEDIATE:
-				ballotModel.setType(BallotModel.Type.INTERMEDIATE);
-				break;
-		}
-
-		switch (data.getChoiceType()) {
-			case TEXT:
-				ballotModel.setChoiceType(BallotModel.ChoiceType.TEXT);
-				break;
-		}
-
-		switch (data.getDisplayType()) {
-			case SUMMARY_MODE:
-				ballotModel.setDisplayType(BallotModel.DisplayType.SUMMARY_MODE);
-				break;
-			case LIST_MODE:
-			default:
-				ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE);
-				break;
-
-		}
-
-		ballotModel.setState(toState);
-
-		if (toState == BallotModel.State.OPEN) {
-			this.databaseServiceNew.getBallotModelFactory().create(
-					ballotModel
-			);
-		}
-		else {
-			this.databaseServiceNew.getBallotModelFactory().update(
-					ballotModel
-			);
-		}
-
-		if(createMessage instanceof GroupPollSetupMessage) {
-			GroupModel groupModel;
-			groupModel = this.groupService.getByGroupMessage((GroupPollSetupMessage) createMessage);
-			if (groupModel == null) {
-				throw new ThreemaException("invalid group");
-			}
-			//link with group
-			this.link(groupModel, ballotModel);
-		}
-		else if(createMessage instanceof PollSetupMessage) {
-			ContactModel contactModel = this.contactService.getByIdentity(createMessage.getBallotCreator());
-			if (contactModel == null) {
-				throw new ThreemaException("invalid identity");
-			}
-			//link with group
-			this.link(contactModel, ballotModel);
-		}
-		else {
-			throw new ThreemaException("invalid");
-		}
-
-		if (toState == BallotModel.State.CLOSED && ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE) {
-			//first remove all previously known votes if result should be shown in list mode to ensure a common result for all participants
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
-					ballotModel.getId()
-			);
-		}
-
-		//create choices of ballot
-		for (BallotDataChoice apiChoice: data.getChoiceList()) {
-			//check if choice already exist
-			BallotChoiceModel ballotChoiceModel = this.getChoiceByApiId(ballotModel, apiChoice.getId());
-			if(ballotChoiceModel == null) {
-				ballotChoiceModel = new BallotChoiceModel();
-				ballotChoiceModel.setBallotId(ballotModel.getId());
-				ballotChoiceModel.setApiBallotChoiceId(apiChoice.getId());
-			}
-
-			// save returned total vote count if ballot is in summary mode (case broadcast poll)
-			if (ballotModel.getDisplayType() == BallotModel.DisplayType.SUMMARY_MODE) {
-				ballotChoiceModel.setVoteCount(apiChoice.getTotalVotes());
-			}
-
-			ballotChoiceModel.setName(apiChoice.getName());
-			ballotChoiceModel.setOrder(apiChoice.getOrder());
-			switch (data.getChoiceType()) {
-				case TEXT:
-					ballotChoiceModel.setType(BallotChoiceModel.Type.Text);
-					break;
-			}
-			ballotChoiceModel.setCreatedAt(date);
-
-			this.databaseServiceNew.getBallotChoiceModelFactory().createOrUpdate(
-					ballotChoiceModel
-			);
-
-			//save individual votes received in case result should be shown in list mode for each participant (case mobile client user poll)
-			if (ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE && !data.getParticipants().isEmpty()) {
-				int participantPos = 0;
-				for(String p: data.getParticipants()) {
-					BallotVoteModel voteModel = new BallotVoteModel();
-					voteModel.setBallotId(ballotModel.getId());
-					voteModel.setBallotChoiceId(ballotChoiceModel.getId());
-					voteModel.setVotingIdentity(p);
-					voteModel.setChoice(apiChoice.getResult(participantPos));
-					voteModel.setModifiedAt(new Date());
-					voteModel.setCreatedAt(new Date());
-
-					this.databaseServiceNew.getBallotVoteModelFactory().create(
-						voteModel
-					);
-
-					participantPos++;
-				}
-			}
-		}
-
-		if (toState == BallotModel.State.OPEN) {
-			this.cache(ballotModel);
-			this.send(ballotModel, listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onCreated(ballotModel);
-				}
-			});
-
-			return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CREATE);
-		}
-		else {
-			// toState == BallotModel.State.CLOSED
-			this.send(ballotModel, listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onClosed(ballotModel);
-				}
-			});
-			return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CLOSE);
-		}
-	}
-
-	@Override
-	public BallotModel get(String id, String creator) {
-		if(TestUtil.isEmptyOrNull(id, creator)) {
-			return null;
-		}
-
-		BallotModel model = this.getFromCache(id, creator);
-		if(model == null) {
-			model = this.databaseServiceNew.getBallotModelFactory().getByApiBallotIdAndIdentity(
-					id,
-					creator
-			);
-
-			this.cache(model);
-		}
-
-		return model;
-	}
-
-	@Override
-	public List<BallotModel> getBallots(final BallotFilter filter) {
-		List<BallotModel> ballots = this.databaseServiceNew.getBallotModelFactory().filter(
-				filter
-		);
-		this.cache(ballots);
-
-		if(filter != null) {
-			return Functional.filter(ballots, new IPredicateNonNull<BallotModel>() {
-				@Override
-				public boolean apply(@NonNull BallotModel type) {
-					return filter.filter(type);
-				}
-			});
-		}
-		else {
-			return ballots;
-		}
-	}
-
-	@Override
-	public long countBallots(final BallotFilter filter) {
-		return this.databaseServiceNew.getBallotModelFactory().count(filter);
-	}
-
-	@Override
-	public List<BallotChoiceModel> getChoices(Integer ballotModelId) throws NotAllowedException {
-		if(ballotModelId == null) {
-			throw new NotAllowedException();
-		}
-
-		return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotId(
-				ballotModelId
-		);
-	}
-
-	@Override
-	public int getVotingCount(BallotChoiceModel choiceModel) {
-		BallotModel b = this.get(choiceModel.getBallotId());
-		if(b == null) {
-			return 0;
-		}
-
-		return this.getCalculatedVotingCount(choiceModel);
-	}
-
-
-	@Override
-	public boolean update(final BallotModel ballotModel) {
-		ballotModel.setModifiedAt(new Date());
-		this.databaseServiceNew.getBallotModelFactory().update(
-				ballotModel);
-
-		this.handleModified(ballotModel);
-		return true;
-	}
-
-	@Override
-	public boolean removeVotes(final MessageReceiver receiver, final String identity) {
-		List<BallotModel> ballots = this.getBallots(new BallotFilter() {
-			@Override
-			public MessageReceiver getReceiver() {
-				return receiver;
-			}
-
-			@Override
-			public BallotModel.State[] getStates() {
-				return new BallotModel.State[0];
-			}
-
-			@Override
-			public boolean filter(BallotModel ballotModel) {
-				return true;
-			}
-		});
-
-		for(final BallotModel ballotModel: ballots) {
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
-					ballotModel.getId(),
-					identity
-			);
-
-			ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
-				@Override
-				public void handle(BallotVoteListener listener) {
-					if(listener.handle(ballotModel)) {
-						listener.onVoteRemoved(ballotModel, identity);
-					}
-				}
-			});
-		}
-
-		return true;
-	}
-
-	@Override
-	@NonNull
-	public List<String> getVotedParticipants(Integer ballotModelId) {
-		List<String> identities = new ArrayList<>();
-
-		if(ballotModelId !=null) {
-			List<BallotVoteModel> ballotVotes = this.getBallotVotes(ballotModelId);
-			for (BallotVoteModel v : ballotVotes) {
-				if (!identities.contains(v.getVotingIdentity())) {
-					identities.add(v.getVotingIdentity());
-				}
-			}
-		}
-		return identities;
-	}
-
-	@Override
-	@NonNull
-	public List<String> getPendingParticipants(Integer ballotModelId) {
-		String[] allParticipants = this.getParticipants(ballotModelId);
-		List<String> pendingParticipants = new ArrayList<>();
-		if(allParticipants.length > 0) {
-			for(String i: allParticipants) {
-				List<BallotVoteModel> voteModels = this.getVotes(ballotModelId, i);
-				if(voteModels == null || voteModels.size() == 0) {
-					pendingParticipants.add(i);
-				}
-			}
-		}
-
-		return pendingParticipants;
-	}
-
-
-	@Override
-	@NonNull
-	public String[] getParticipants(MessageReceiver messageReceiver) {
-		if(messageReceiver != null) {
-			switch (messageReceiver.getType()) {
-				case MessageReceiver.Type_GROUP:
-					return this.groupService.getGroupIdentities(((GroupMessageReceiver)messageReceiver).getGroup());
-
-				case MessageReceiver.Type_CONTACT:
-					return new String[] {
-							this.userService.getIdentity(),
-							((ContactMessageReceiver)messageReceiver).getContact().getIdentity()
-					};
-				case MessageReceiver.Type_DISTRIBUTION_LIST:
-					break;
-			}
-		}
-		return new String[0];
-	}
-
-	@Override
-	@NonNull
-	public String[] getParticipants(Integer ballotModelId) {
-		BallotModel b = this.get(ballotModelId);
-		if (b != null) {
-			try {
-				LinkBallotModel link = this.getLinkedBallotModel(b);
-				if (link != null) {
-					switch (link.getType()) {
-						case GROUP:
-							GroupModel groupModel = this.getGroupModel(link);
-							if (groupModel != null) {
-								return this.groupService.getGroupIdentities(this.getGroupModel(link));
-							}
-							break;
-						case CONTACT:
-							ContactModel contactModel = this.getContactModel(link);
-							if (contactModel != null) {
-								return new String[]{
-										this.userService.getIdentity(),
-										contactModel.getIdentity()};
-							}
-							break;
-
-						default:
-							throw new NotAllowedException("invalid type");
-					}
-				}
-			} catch (NotAllowedException e) {
-				logger.error("Exception", e);
-			}
-		}
-
-		return new String[0];
-	}
-
-	private List<BallotVoteModel> getVotes(Integer ballotModelId, String fromIdentity) {
-		if(ballotModelId == null) {
-			return null;
-		}
-
-		return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotIdAndVotingIdentity(
-				ballotModelId,
-				fromIdentity
-		);
-	}
-
-	@Override
-	public boolean hasVoted(Integer ballotModelId, String fromIdentity) {
-		if(ballotModelId == null) {
-			return false;
-		}
-
-		return this.databaseServiceNew.getBallotVoteModelFactory().countByBallotIdAndVotingIdentity(
-			ballotModelId,
-			fromIdentity
-		) > 0L;
-	}
-
-	@Override
-	public List<BallotVoteModel> getMyVotes(Integer ballotModelId) {
-		return this.getVotes(ballotModelId, this.userService.getIdentity());
-	}
-
-	@Override
-	public List<BallotVoteModel> getBallotVotes(Integer ballotModelId) {
-		if(ballotModelId == null) {
-			return null;
-		}
-		return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotId(
-				ballotModelId);
-	}
-
-
-	@Override
-	public boolean removeAll() {
-		this.databaseServiceNew.getBallotModelFactory().deleteAll();
-		this.databaseServiceNew.getBallotVoteModelFactory().deleteAll();
-		this.databaseServiceNew.getBallotChoiceModelFactory().deleteAll();
-		this.databaseServiceNew.getGroupBallotModelFactory().deleteAll();
-		return true;
-	}
-
-	@Override
-	public BallotPublishResult publish(MessageReceiver messageReceiver, final BallotModel ballotModel, AbstractMessageModel abstractMessageModel) throws NotAllowedException, MessageTooLongException {
-		return this.publish(messageReceiver, ballotModel, abstractMessageModel, null);
-	}
-
-	@Override
-	public BallotPublishResult publish(MessageReceiver messageReceiver,
-	                                   final BallotModel ballotModel,
-	                                   AbstractMessageModel abstractMessageModel,
-	                                   @Nullable Collection<String> receivingIdentities
-	) throws NotAllowedException, MessageTooLongException {
-		BallotPublishResult result = new BallotPublishResult();
-
-		this.checkAccess();
-
-		if(!TestUtil.required(messageReceiver, ballotModel)) {
-			return result;
-		}
-
-		// validate choices
-		List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
-		if(choices == null || choices.size() < REQUIRED_CHOICE_COUNT) {
-			return result.error(R.string.ballot_error_more_than_x_choices);
-		}
-
-		switch (messageReceiver.getType()) {
-			case MessageReceiver.Type_GROUP:
-				this.link(((GroupMessageReceiver)messageReceiver).getGroup(), ballotModel);
-				break;
-
-			case MessageReceiver.Type_CONTACT:
-				this.link(((ContactMessageReceiver)messageReceiver).getContact(), ballotModel);
-				break;
-		}
-
-		final boolean isClosing = ballotModel.getState() == BallotModel.State.CLOSED;
-
-		BallotData ballotData = new BallotData();
-		ballotData.setDescription(ballotModel.getName());
-
-		switch (ballotModel.getChoiceType()) {
-			case TEXT:
-				ballotData.setChoiceType(BallotData.ChoiceType.TEXT);
-				break;
-		}
-
-		switch (ballotModel.getType()) {
-			case RESULT_ON_CLOSE:
-				ballotData.setType(BallotData.Type.RESULT_ON_CLOSE);
-				break;
-			case INTERMEDIATE:
-			default:
-				ballotData.setType(BallotData.Type.INTERMEDIATE);
-		}
-
-		switch (ballotModel.getAssessment()) {
-			case MULTIPLE_CHOICE:
-				ballotData.setAssessmentType(BallotData.AssessmentType.MULTIPLE);
-				break;
-			case SINGLE_CHOICE:
-			default:
-				ballotData.setAssessmentType(BallotData.AssessmentType.SINGLE);
-		}
-
-		switch (ballotModel.getState()) {
-			case CLOSED:
-				ballotData.setState(BallotData.State.CLOSED);
-				break;
-			case OPEN:
-			default:
-				ballotData.setState(BallotData.State.OPEN);
-		}
-
-		switch (ballotModel.getDisplayType()) {
-			case SUMMARY_MODE:
-				ballotData.setDisplayType(BallotData.DisplayType.SUMMARY_MODE);
-				break;
-			case LIST_MODE:
-			default:
-				ballotData.setDisplayType(BallotData.DisplayType.LIST_MODE);
-				break;
-		}
-
-		HashMap<String, Integer> votersPositions = new HashMap<>();
-		List<BallotVoteModel> voteModels = null;
-		int votersCount = 0;
-		if (isClosing || receivingIdentities != null) {
-			// load a list of voters
-			String[] voters = this.getVotedParticipants(ballotModel.getId()).toArray(new String[0]);
-
-			for (String s : voters) {
-				ballotData.addParticipant(s);
-				votersPositions.put(s, votersCount);
-				votersCount++;
-			}
-
-			voteModels = this.getBallotVotes(ballotModel.getId());
-		}
-		// if closing, add result!
-		for(final BallotChoiceModel c: choices) {
-			BallotDataChoice choice = new BallotDataChoice(votersCount);
-			choice.setId(c.getApiBallotChoiceId());
-			choice.setName(c.getName());
-			choice.setOrder(c.getOrder());
-
-			if ((isClosing || receivingIdentities != null) && TestUtil.required(voteModels, votersPositions)) {
-
-				for(BallotVoteModel v: Functional.filter(voteModels, new IPredicateNonNull<BallotVoteModel>() {
-					@Override
-					public boolean apply(@NonNull BallotVoteModel type) {
-						return type.getBallotChoiceId() == c.getId();
-					}
-				})){
-					int pos = votersPositions.get(v.getVotingIdentity());
-					if(pos >= 0) {
-						choice.addResult(pos, v.getChoice());
-					}
-				}
-
-			}
-			ballotData.getChoiceList().add(choice);
-		}
-
-		try {
-			messageReceiver.createAndSendBallotSetupMessage(
-				ballotData,
-				ballotModel,
-				abstractMessageModel,
-				null,
-				receivingIdentities
-			);
-
-			//set as open
-			if(ballotModel.getState() == BallotModel.State.TEMPORARY) {
-				ballotModel.setState(BallotModel.State.OPEN);
-				ballotModel.setModifiedAt(new Date());
-
-				this.databaseServiceNew.getBallotModelFactory().update(
-						ballotModel
-				);
-
-			}
-
-			result.success();
-		} catch (ThreemaException e) {
-			logger.error("create boxed ballot failed", e);
-			if (e instanceof MessageTooLongException) {
-				throw new MessageTooLongException();
-			}
-		}
-
-		return result;
-	}
-
-	@Override
-	public LinkBallotModel getLinkedBallotModel(BallotModel ballotModel) throws NotAllowedException {
-		if(ballotModel == null) {
-			return null;
-		}
-
-		LinkBallotModel linkBallotModel = this.getLinkModelFromCache(ballotModel.getId());
-		if(linkBallotModel != null) {
-			return linkBallotModel;
-		}
-
-		GroupBallotModel group = this.databaseServiceNew.getGroupBallotModelFactory().getByBallotId(
-				ballotModel.getId());
-
-		if(group != null) {
-			this.cache(group);
-			return group;
-		}
-
-		IdentityBallotModel identityBallotModel = this.databaseServiceNew.getIdentityBallotModelFactory().getByBallotId(
-				ballotModel.getId()
-		);
-		if(identityBallotModel != null) {
-			this.cache(identityBallotModel);
-			return identityBallotModel;
-		}
-
-		return null;
-	}
-
-	@Override
-	public boolean remove(final BallotModel ballotModel) throws NotAllowedException {
-		if (serviceManager == null) {
-			logger.debug("Unable to delete ballot, ServiceManager is not available");
-			return false;
-		}
-
-		MessageService messageService;
-		try {
-			messageService = serviceManager.getMessageService();
-		} catch (ThreemaException e) {
-			logger.error("Unable to delete ballot, MessageService not available", e);
-			return false;
-		}
-
-		if (ballotModel != null) {
-			List<AbstractMessageModel> messageModels = messageService.getMessageForBallot(ballotModel);
-
-			//remove all votes
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			//remove choices
-			this.databaseServiceNew.getBallotChoiceModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			//remove link
-			this.databaseServiceNew.getGroupBallotModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			this.databaseServiceNew.getIdentityBallotModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			//remove ballot
-			this.databaseServiceNew.getBallotModelFactory().delete(
-				ballotModel
-			);
-
-			// delete associated messages
-			if (messageModels != null) {
-				for (AbstractMessageModel m : messageModels) {
-					if (m != null) {
-						try {
-							logger.debug("Removing ballot message {} of type {}", m.getApiMessageId() != null ? m.getApiMessageId() : m.getId(), m.getBallotData().getType());
-							messageService.remove(m);
-						} catch (Exception e) {
-							logger.error("Unable to remove message", e);
-						}
-					}
-				}
-			}
-
-			// remove ballot from cache
-			this.resetCache(ballotModel);
-
-			ListenerManager.ballotListeners.handle(listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onRemoved(ballotModel);
-				}
-			});
-		}
-		return true;
-	}
-
-	@Override
-	public boolean remove(final MessageReceiver receiver) {
-		try {
-			for(BallotModel ballotModel: this.getBallots(new BallotFilter() {
-				@Override
-				public MessageReceiver getReceiver() {
-					return receiver;
-				}
-
-				@Override
-				public BallotModel.State[] getStates() {
-					return null;
-				}
-
-				@Override
-				public boolean filter(BallotModel ballotModel) {
-					return true;
-				}
-			})) {
-				if(!this.remove(ballotModel)) {
-					return false;
-				}
-			}
-		}
-		catch (NotAllowedException x) {
-			//do nothing more
-			logger.error("Exception", x);
-			return false;
-		}
-
-		return true;
-	}
-
-	@Override
-	public boolean belongsToMe(Integer ballotModelId, MessageReceiver messageReceiver) throws NotAllowedException {
-		BallotModel ballotModel = this.get(ballotModelId);
-
-		if(!TestUtil.required(ballotModel, messageReceiver)) {
-			return false;
-		}
-
-		switch (messageReceiver.getType()) {
-			case MessageReceiver.Type_CONTACT:
-			case MessageReceiver.Type_GROUP:
-				LinkBallotModel l = this.getLinkedBallotModel(ballotModel);
-				if(l != null) {
-					if(messageReceiver.getType() == MessageReceiver.Type_GROUP && l.getType() == LinkBallotModel.Type.GROUP) {
-						return ((GroupBallotModel)l).getGroupId() == ((GroupMessageReceiver)messageReceiver).getGroup().getId();
-					}
-					else if(messageReceiver.getType() == MessageReceiver.Type_CONTACT && l.getType() == LinkBallotModel.Type.CONTACT) {
-						return TestUtil.compare(((IdentityBallotModel)l).getIdentity(), ((ContactMessageReceiver)messageReceiver).getContact().getIdentity());
-					}
-				}
-		}
-
-		return false;
-	}
-
-	@Override
-	public BallotVoteResult vote(Integer ballotModelId, Map<Integer, Integer> voting) throws NotAllowedException {
-		BallotModel ballotModel = this.get(ballotModelId);
-
-		if(!TestUtil.required(ballotModel, voting)) {
-			return new BallotVoteResult(false);
-		}
-
-		List<BallotChoiceModel> allChoices = this.getChoices(ballotModel.getId());
-		if(allChoices == null) {
-			return new BallotVoteResult(false);
-		}
-
-		LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
-		MessageReceiver messageReceiver = this.getReceiver(link);
-
-		if(messageReceiver == null) {
-			return new BallotVoteResult(false);
-		}
-
-		//prepare all messages and save local
-		BallotVote[] votes = new BallotVote[allChoices.size()];
-		int n = 0;
-		for(final BallotChoiceModel choiceModel: allChoices) {
-			BallotVote vote = new BallotVote();
-			vote.setId(choiceModel.getApiBallotChoiceId());
-
-			//change if other values implement
-			if(voting.containsKey(choiceModel.getId())){
-				vote.setValue(voting.get(choiceModel.getId()));
-			}
-			else {
-				vote.setValue(0);
-			}
-
-			votes[n] = vote;
-			n++;
-		}
-
-		try {
-			//send
-			messageReceiver.createAndSendBallotVoteMessage(votes, ballotModel);
-
-			//and save
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
-					ballotModel.getId(),
-					this.userService.getIdentity()
-			);
-
-			for(BallotChoiceModel choiceModel: allChoices) {
-				BallotVoteModel ballotVoteModel = new BallotVoteModel();
-				ballotVoteModel.setVotingIdentity(this.userService.getIdentity());
-				ballotVoteModel.setBallotId(ballotModel.getId());
-				ballotVoteModel.setBallotChoiceId(choiceModel.getId());
-
-				if(voting.containsKey(choiceModel.getId())){
-					ballotVoteModel.setChoice(voting.get(choiceModel.getId()));
-				}
-				else {
-					ballotVoteModel.setChoice(0);
-				}
-
-				ballotVoteModel.setModifiedAt(new Date());
-				ballotVoteModel.setCreatedAt(new Date());
-				this.databaseServiceNew.getBallotVoteModelFactory().create(
-						ballotVoteModel
-				);
-			}
-		} catch (ThreemaException e) {
-			logger.error("create boxed ballot failed", e);
-			return new BallotVoteResult(false);
-		}
-
-		ListenerManager.ballotVoteListeners.handle(listener -> {
-			if(listener.handle(ballotModel)) {
-				listener.onSelfVote(
-					ballotModel);
-			}
-		});
-
-		return new BallotVoteResult(true);
-	}
-
-	@Override
-	public BallotVoteResult vote(final BallotVoteInterface voteMessage) throws NotAllowedException {
-		final BallotModel ballotModel = this.get(voteMessage.getBallotId().toString(), voteMessage.getBallotCreator());
-
-		//invalid ballot model
-		if(ballotModel == null) {
-			return new BallotVoteResult(false);
-		}
-
-		if(ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE && !TestUtil.compare(
-				ballotModel.getCreatorIdentity(),
-				this.userService.getIdentity())) {
-			logger.error("this is not a intermediate ballot and not mine, ingore the message");
-			//return true to ack the message
-			return new BallotVoteResult(true);
-		}
-
-		//if the ballot is closed, ignore any votes
-		if(ballotModel.getState() == BallotModel.State.CLOSED) {
-			logger.error("this is a closed ballot, ignore this message");
-			return new BallotVoteResult(true);
-		}
-
-		final String fromIdentity = ((AbstractMessage)voteMessage).getFromIdentity();
-
-		//load existing votes of user
-		List<BallotVoteModel> existingVotes = this.getVotes(ballotModel.getId(), fromIdentity);
-		final boolean firstVote = existingVotes == null || existingVotes.size() == 0;
-
-		List<BallotVoteModel> savingVotes = new ArrayList<>();
-		List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
-
-		for(final BallotVote apiVoteModel: voteMessage.getBallotVotes()) {
-			apiVoteModel.getId();
-
-			//check if the choice correct
-			final BallotChoiceModel c = Functional.select(choices, new IPredicateNonNull<BallotChoiceModel>() {
-				@Override
-				public boolean apply(@NonNull BallotChoiceModel type) {
-					return type.getApiBallotChoiceId() == apiVoteModel.getId();
-				}
-			});
-
-			if(c != null) {
-				//cool, correct choice
-				BallotVoteModel ballotVoteModel = Functional.select(existingVotes, new IPredicateNonNull<BallotVoteModel>() {
-					@Override
-					public boolean apply(@NonNull BallotVoteModel type) {
-						return type.getBallotChoiceId() == c.getId();
-					}
-				});
-
-				if(ballotVoteModel == null) {
-					//ok, a new vote
-					ballotVoteModel = new BallotVoteModel();
-					ballotVoteModel.setBallotId(ballotModel.getId());
-					ballotVoteModel.setBallotChoiceId(c.getId());
-					ballotVoteModel.setVotingIdentity(fromIdentity);
-					ballotVoteModel.setCreatedAt(new Date());
-				}
-				else {
-					//remove from existing votes
-					if(existingVotes != null) {
-						existingVotes.remove(ballotVoteModel);
-					}
-				}
-
-				if(
-						//is a new vote...
-						ballotVoteModel.getId() <= 0
-						//... or a modified
-					|| ballotVoteModel.getChoice() != apiVoteModel.getValue()) {
-
-					ballotVoteModel.setChoice(apiVoteModel.getValue());
-					ballotVoteModel.setModifiedAt(new Date());
-					savingVotes.add(ballotVoteModel);
-				}
-			}
-		}
-
-		//remove votes
-		boolean hasModifications = false;
-
-		if(existingVotes != null && existingVotes.size() > 0) {
-			int[] ids = new int[existingVotes.size()];
-			for(int n = 0; n < ids.length; n++) {
-				ids[n] = existingVotes.get(n).getId();
-			}
-
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByIds(
-					ids);
-
-			hasModifications = true;
-		}
-
-		for(BallotVoteModel ballotVoteModel: savingVotes) {
-			this.databaseServiceNew.getBallotVoteModelFactory().createOrUpdate(
-					ballotVoteModel
-			);
-			hasModifications = true;
-		}
-
-		if(hasModifications) {
-
-			ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
-				@Override
-				public void handle(BallotVoteListener listener) {
-					if(listener.handle(ballotModel)) {
-						listener.onVoteChanged(
-								ballotModel,
-								fromIdentity,
-								firstVote);
-					}
-				}
-			});
-		}
-		return new BallotVoteResult(true);
-	}
-
-
-
-	private GroupModel getGroupModel(LinkBallotModel link) {
-		if(link.getType() != LinkBallotModel.Type.GROUP) {
-			return null;
-		}
-
-		int groupId = ((GroupBallotModel)link).getGroupId();
-		return this.groupService.getById(groupId);
-	}
-
-
-	private ContactModel getContactModel(LinkBallotModel link) {
-		if(link.getType() != LinkBallotModel.Type.CONTACT) {
-			return null;
-		}
-
-		String identity = ((IdentityBallotModel)link).getIdentity();
-		return this.contactService.getByIdentity(identity);
-
-	}
-
-	@Override
-	public MessageReceiver getReceiver(BallotModel ballotModel) {
-		try {
-			LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
-			return this.getReceiver(link);
-		} catch (NotAllowedException e) {
-			logger.error("Exception", e);
-			return null;
-		}
-	}
-
-	@Override
-	public BallotMatrixData getMatrixData(int ballotModelId) {
-		try {
-			BallotModel ballotModel = this.get(ballotModelId);
-
-			//ok, ballot not found
-			if(ballotModel == null) {
-				throw new ThreemaException("invalid ballot");
-			}
-
-			BallotMatrixService matrixService = new BallotMatrixServiceImpl(ballotModel);
-
-			String[] participants = this.getParticipants(ballotModelId);
-
-			if (participants.length > 0) {
-				for (String identity : participants) {
-					matrixService.createParticipant(identity);
-				}
-
-				for (BallotChoiceModel choice : this.getChoices(ballotModelId)) {
-					matrixService.createChoice(choice);
-				}
-
-				for (BallotVoteModel ballotVoteModel : this.getBallotVotes(ballotModelId)) {
-					matrixService.addVote(ballotVoteModel);
-				}
-
-				return matrixService.finish();
-			}
-		}
-		catch (ThreemaException x) {
-			logger.error("Exception", x);
-		}
-		return null;
-	}
-
-	private MessageReceiver getReceiver(LinkBallotModel link) {
-		if(link != null) {
-			switch (link.getType()) {
-				case GROUP:
-					GroupModel groupModel = this.getGroupModel(link);
-					return this.groupService.createReceiver(groupModel);
-				case CONTACT:
-					ContactModel contactModel = this.getContactModel(link);
-					return this.contactService.createReceiver(contactModel);
-			}
-		}
-		return null;
-	}
-
-	private int getCalculatedVotingCount(BallotChoiceModel choiceModel) {
-		return (int) this.databaseServiceNew.getBallotVoteModelFactory().countByBallotChoiceIdAndChoice(
-				choiceModel.getId(),
-				1);
-	}
-
-	private BallotChoiceModel getChoiceByApiId(BallotModel ballotModel, int choiceId) {
-		return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotIdAndApiChoiceId(
-				ballotModel.getId(),
-				choiceId
-		);
-	}
-
-	/**
-	 * Link a ballot with a contact
-	 *
-	 * @return success
-	 */
-	private boolean link(ContactModel contactModel, BallotModel ballotModel) {
-		IdentityBallotModelFactory identityBallotModelFactory = this.databaseServiceNew.getIdentityBallotModelFactory();
-		if(identityBallotModelFactory.getByIdentityAndBallotId(
-				contactModel.getIdentity(),
-				ballotModel.getId()
-		) != null) {
-			//already linked
-			return true;
-		}
-
-		IdentityBallotModel m = new IdentityBallotModel();
-		m.setBallotId(ballotModel.getId());
-		m.setIdentity(contactModel.getIdentity());
-		identityBallotModelFactory.create(
-				m);
-
-		this.cache(m);
-
-		return true;
-	}
-
-	/**
-	 * Link a a ballot with a group
-	 *
-	 * @return success
-	 */
-	private boolean link(GroupModel groupModel, BallotModel ballotModel) {
-		GroupBallotModelFactory groupBallotModelFactory = this.databaseServiceNew.getGroupBallotModelFactory();
-		if(groupBallotModelFactory.getByGroupIdAndBallotId(
-				groupModel.getId(),
-				ballotModel.getId()
-		) != null) {
-			//already linked
-			return true;
-		}
-
-		GroupBallotModel m = new GroupBallotModel();
-		m.setBallotId(ballotModel.getId());
-		m.setGroupId(groupModel.getId());
-		groupBallotModelFactory.create(
-				m);
-
-		this.cache(m);
-		return true;
-	}
-
-	private void handleModified(final BallotModel ballotModel) {
-		ListenerManager.ballotListeners.handle(new ListenerManager.HandleListener<BallotListener>() {
-			@Override
-			public void handle(BallotListener listener) {
-				if(listener.handle(ballotModel)) {
-					listener.onModified(ballotModel);
-				}
-			}
-		});
-	}
-
-	private void checkAccess() throws NotAllowedException {
-		if(!this.userService.hasIdentity()) {
-			throw new NotAllowedException();
-		}
-	}
-
-	private void cache(List<BallotModel> ballotModels) {
-		for(BallotModel m: ballotModels) {
-			this.cache(m);
-		}
-	}
-
-	private void cache(BallotModel ballotModel) {
-		if(ballotModel != null) {
-			synchronized (this.ballotModelCache) {
-				this.ballotModelCache.put(ballotModel.getId(), ballotModel);
-			}
-		}
-	}
-
-	private void cache(LinkBallotModel linkBallotModel) {
-		if(linkBallotModel != null) {
-			synchronized (this.linkBallotModelCache) {
-				this.linkBallotModelCache.put(linkBallotModel.getBallotId(), linkBallotModel);
-			}
-		}
-	}
-
-	private void resetCache(BallotModel ballotModel) {
-		if(ballotModel != null) {
-			synchronized (this.ballotModelCache) {
-				this.ballotModelCache.remove(ballotModel.getId());
-			}
-		}
-	}
-
-	@Nullable
-	private BallotModel getFromCache(int id) {
-		synchronized (this.ballotModelCache) {
-			if(this.ballotModelCache.indexOfKey(id) >= 0) {
-				return this.ballotModelCache.get(id);
-			}
-		}
-
-		return null;
-	}
-
-	private LinkBallotModel getLinkModelFromCache(int ballotId) {
-		synchronized (this.linkBallotModelCache) {
-			if(this.linkBallotModelCache.indexOfKey(ballotId) >= 0) {
-				return this.linkBallotModelCache.get(ballotId);
-			}
-		}
-		return null;
-	}
-
-	private BallotModel getFromCache(final String apiId, final String creator) {
-		synchronized (this.ballotModelCache) {
-			return Functional.select(this.ballotModelCache, new IPredicateNonNull<BallotModel>() {
-				@Override
-				public boolean apply(@NonNull BallotModel type) {
-					return TestUtil.compare(type.getApiBallotId(), apiId)
-							&& TestUtil.compare(type.getCreatorIdentity(), creator);
-				}
-			});
-		}
-	}
+                return true;
+            } else if (this.openBallotId == ballotModel.getId()) {
+                this.openBallotId = 0;
+            }
+
+        }
+        return false;
+    }
+
+    @Override
+    public BallotModel create(ContactModel contactModel,
+                              String description,
+                              BallotModel.State state,
+                              BallotModel.Assessment assessment,
+                              BallotModel.Type type,
+                              BallotModel.ChoiceType choiceType) throws NotAllowedException {
+        final BallotModel model = this.create(description, state, assessment, type, choiceType);
+        if (model != null) {
+            this.link(contactModel, model);
+        }
+
+        return model;
+    }
+
+    private BallotModel create(String description,
+                               BallotModel.State state,
+                               BallotModel.Assessment assessment,
+                               BallotModel.Type type,
+                               BallotModel.ChoiceType choiceType) throws NotAllowedException {
+        //create a new blank model
+        try {
+            this.checkAccess();
+
+
+            final BallotModel ballotModel = new BallotModel();
+            //unique id
+            String randomId = UUID.randomUUID().toString();
+            BallotId newBallotId = new BallotId(
+                Utils.hexStringToByteArray(
+                    randomId.substring(randomId.length() - (ProtocolDefines.BALLOT_ID_LEN * 2))
+                ));
+
+            ballotModel.setApiBallotId(Utils.byteArrayToHexString(newBallotId.getBallotId()));
+            ballotModel.setCreatorIdentity(this.userService.getIdentity());
+            ballotModel.setCreatedAt(new Date());
+            ballotModel.setModifiedAt(new Date());
+            ballotModel.setName(description);
+            ballotModel.setState(state);
+            ballotModel.setAssessment(assessment);
+            ballotModel.setType(type);
+            ballotModel.setChoiceType(choiceType);
+            ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE); // default display type for ballots created on mobile client.
+            ballotModel.setLastViewedAt(new Date());
+
+            this.databaseServiceNew.getBallotModelFactory().create(
+                ballotModel
+            );
+
+            this.cache(ballotModel);
+
+            return ballotModel;
+
+        } catch (NotAllowedException notAllowedException) {
+            logger.error("Not allowed", notAllowedException);
+            throw notAllowedException;
+        } catch (ThreemaException e) {
+            logger.error("Exception", e);
+            return null;
+        }
+    }
+
+    @Override
+    public boolean update(BallotModel ballotModel, BallotChoiceModel choice) throws NotAllowedException {
+        if (choice.getId() > 0 && choice.getBallotId() > 0 && choice.getBallotId() != ballotModel.getId()) {
+            throw new NotAllowedException("choice already set on another ballot");
+        }
+
+        if (choice.getApiBallotChoiceId() <= 0) {
+            throw new NotAllowedException("no api ballot choice id set");
+        }
+        choice.setBallotId(ballotModel.getId());
+
+        if (choice.getCreatedAt() == null) {
+            choice.setCreatedAt(new Date());
+        }
+
+        choice.setModifiedAt(new Date());
+
+        return this.databaseServiceNew.getBallotChoiceModelFactory().create(
+            choice
+        );
+    }
+
+    @Override
+    public boolean close(Integer ballotModelId) throws NotAllowedException, MessageTooLongException {
+        //be sure to use the cached ballot model!
+        final BallotModel ballotModel = this.get(ballotModelId);
+
+        //if i am not the creator
+        if (!BallotUtil.canClose(ballotModel, this.userService.getIdentity())) {
+            throw new NotAllowedException();
+        }
+
+        MessageReceiver messageReceiver = this.getReceiver(ballotModel);
+        if (messageReceiver == null) {
+            return false;
+        }
+
+        //save model
+        ballotModel.setState(BallotModel.State.CLOSED);
+        if (this.update(ballotModel)) {
+            return this.send(ballotModel, listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onClosed(ballotModel);
+                }
+            });
+        }
+        return false;
+    }
+
+    @Override
+    public boolean send(BallotModel ballotModel, ListenerManager.HandleListener<BallotListener> handleListener) throws MessageTooLongException {
+        //add message
+        if (TestUtil.compare(userService.getIdentity(), ballotModel.getCreatorIdentity())) {
+            //ok, i am the creator.... send a message to every participant
+            try {
+                if (serviceManager.getMessageService() != null) {
+                    if (serviceManager.getMessageService().sendBallotMessage(ballotModel) != null) {
+                        ListenerManager.ballotListeners.handle(handleListener);
+                        return true;
+                    }
+                }
+            } catch (ThreemaException e) {
+                logger.error("Exception", e);
+                if (e instanceof MessageTooLongException) {
+                    throw new MessageTooLongException();
+                }
+            }
+        }
+        return false;
+    }
+
+    @Override
+    @Nullable
+    public BallotModel get(int ballotId) {
+        BallotModel model = this.getFromCache(ballotId);
+        if (model == null) {
+            model = this.databaseServiceNew.getBallotModelFactory().getById(
+                ballotId
+            );
+
+            this.cache(model);
+        }
+        return model;
+    }
+
+    @Override
+    @NonNull
+    public BallotUpdateResult update(BallotSetupInterface createMessage) throws ThreemaException, BadMessageException {
+        //check if allowed
+        BallotData ballotData = createMessage.getBallotData();
+        if (ballotData == null) {
+            throw new ThreemaException("invalid format");
+        }
+
+        final BallotModel.State toState;
+        final BallotModel ballotModel;
+
+        Date date = ((AbstractMessage) createMessage).getDate();
+        BallotModel existingModel = this.get(createMessage.getBallotId().toString(), createMessage.getBallotCreatorIdentity());
+
+        if (existingModel != null) {
+            if (ballotData.getDisplayType() != null && existingModel.getDisplayType() != null && ballotData.getDisplayType().ordinal() != existingModel.getDisplayType().ordinal()) {
+                throw new BadMessageException("Ballot display mode not allowed to change. Discarding message");
+            }
+            if (ballotData.getState() == BallotData.State.CLOSED) {
+                ballotModel = existingModel;
+                toState = BallotModel.State.CLOSED;
+            } else {
+                throw new BadMessageException("Ballot with same ID already exists. Discarding message.");
+            }
+        } else {
+            if (ballotData.getState() != BallotData.State.CLOSED) {
+                ballotModel = new BallotModel();
+                ballotModel.setCreatorIdentity(createMessage.getBallotCreatorIdentity());
+                ballotModel.setApiBallotId(createMessage.getBallotId().toString());
+                ballotModel.setCreatedAt(date);
+                ballotModel.setLastViewedAt(null);
+                toState = BallotModel.State.OPEN;
+            } else {
+                throw new BadMessageException("New ballot with closed state requested. Discarding message.");
+            }
+        }
+
+        ballotModel.setName(ballotData.getDescription());
+        ballotModel.setModifiedAt(new Date());
+
+        switch (ballotData.getAssessmentType()) {
+            case MULTIPLE:
+                ballotModel.setAssessment(BallotModel.Assessment.MULTIPLE_CHOICE);
+                break;
+            case SINGLE:
+                ballotModel.setAssessment(BallotModel.Assessment.SINGLE_CHOICE);
+                break;
+        }
+
+        switch (ballotData.getType()) {
+            case RESULT_ON_CLOSE:
+                ballotModel.setType(BallotModel.Type.RESULT_ON_CLOSE);
+                break;
+            case INTERMEDIATE:
+                ballotModel.setType(BallotModel.Type.INTERMEDIATE);
+                break;
+        }
+
+        switch (ballotData.getChoiceType()) {
+            case TEXT:
+                ballotModel.setChoiceType(BallotModel.ChoiceType.TEXT);
+                break;
+        }
+
+        switch (ballotData.getDisplayType()) {
+            case SUMMARY_MODE:
+                ballotModel.setDisplayType(BallotModel.DisplayType.SUMMARY_MODE);
+                break;
+            case LIST_MODE:
+            default:
+                ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE);
+                break;
+
+        }
+
+        ballotModel.setState(toState);
+
+        if (toState == BallotModel.State.OPEN) {
+            this.databaseServiceNew.getBallotModelFactory().create(
+                ballotModel
+            );
+        } else {
+            this.databaseServiceNew.getBallotModelFactory().update(
+                ballotModel
+            );
+        }
+
+        if (createMessage instanceof GroupPollSetupMessage) {
+            GroupModel groupModel;
+            groupModel = this.groupService.getByGroupMessage((GroupPollSetupMessage) createMessage);
+            if (groupModel == null) {
+                throw new ThreemaException("invalid group");
+            }
+            //link with group
+            this.link(groupModel, ballotModel);
+        } else if (createMessage instanceof PollSetupMessage) {
+            ContactModel contactModel = this.contactService.getByIdentity(createMessage.getBallotCreatorIdentity());
+            if (contactModel == null) {
+                throw new ThreemaException("invalid identity");
+            }
+            //link with group
+            this.link(contactModel, ballotModel);
+        } else {
+            throw new ThreemaException("invalid");
+        }
+
+        if (toState == BallotModel.State.CLOSED && ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE) {
+            //first remove all previously known votes if result should be shown in list mode to ensure a common result for all participants
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
+                ballotModel.getId()
+            );
+        }
+
+        //create choices of ballot
+        for (BallotDataChoice apiChoice : ballotData.getChoiceList()) {
+            //check if choice already exist
+            BallotChoiceModel ballotChoiceModel = this.getChoiceByApiId(ballotModel, apiChoice.getId());
+            if (ballotChoiceModel == null) {
+                ballotChoiceModel = new BallotChoiceModel();
+                ballotChoiceModel.setBallotId(ballotModel.getId());
+                ballotChoiceModel.setApiBallotChoiceId(apiChoice.getId());
+            }
+
+            // save returned total vote count if ballot is in summary mode (case broadcast poll)
+            if (ballotModel.getDisplayType() == BallotModel.DisplayType.SUMMARY_MODE) {
+                ballotChoiceModel.setVoteCount(apiChoice.getTotalVotes());
+            }
+
+            ballotChoiceModel.setName(apiChoice.getName());
+            ballotChoiceModel.setOrder(apiChoice.getOrder());
+            switch (ballotData.getChoiceType()) {
+                case TEXT:
+                    ballotChoiceModel.setType(BallotChoiceModel.Type.Text);
+                    break;
+            }
+            ballotChoiceModel.setCreatedAt(date);
+
+            this.databaseServiceNew.getBallotChoiceModelFactory().createOrUpdate(
+                ballotChoiceModel
+            );
+
+            //save individual votes received in case result should be shown in list mode for each participant (case mobile client user poll)
+            if (ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE && !ballotData.getParticipants().isEmpty()) {
+                int participantPos = 0;
+                for (String p : ballotData.getParticipants()) {
+                    BallotVoteModel voteModel = new BallotVoteModel();
+                    voteModel.setBallotId(ballotModel.getId());
+                    voteModel.setBallotChoiceId(ballotChoiceModel.getId());
+                    voteModel.setVotingIdentity(p);
+                    voteModel.setChoice(apiChoice.getResult(participantPos));
+                    voteModel.setModifiedAt(new Date());
+                    voteModel.setCreatedAt(new Date());
+
+                    this.databaseServiceNew.getBallotVoteModelFactory().create(
+                        voteModel
+                    );
+
+                    participantPos++;
+                }
+            }
+        }
+
+        if (toState == BallotModel.State.OPEN) {
+            this.cache(ballotModel);
+            this.send(ballotModel, listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onCreated(ballotModel);
+                }
+            });
+
+            return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CREATE);
+        } else {
+            // toState == BallotModel.State.CLOSED
+            this.send(ballotModel, listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onClosed(ballotModel);
+                }
+            });
+            return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CLOSE);
+        }
+    }
+
+    @Override
+    public BallotModel get(String id, String creator) {
+        if (TestUtil.isEmptyOrNull(id, creator)) {
+            return null;
+        }
+
+        BallotModel model = this.getFromCache(id, creator);
+        if (model == null) {
+            model = this.databaseServiceNew.getBallotModelFactory().getByApiBallotIdAndIdentity(
+                id,
+                creator
+            );
+
+            this.cache(model);
+        }
+
+        return model;
+    }
+
+    @Override
+    public List<BallotModel> getBallots(final BallotFilter filter) {
+        List<BallotModel> ballots = this.databaseServiceNew.getBallotModelFactory().filter(
+            filter
+        );
+        this.cache(ballots);
+
+        if (filter != null) {
+            return Functional.filter(ballots, new IPredicateNonNull<BallotModel>() {
+                @Override
+                public boolean apply(@NonNull BallotModel type) {
+                    return filter.filter(type);
+                }
+            });
+        } else {
+            return ballots;
+        }
+    }
+
+    @Override
+    public long countBallots(final BallotFilter filter) {
+        return this.databaseServiceNew.getBallotModelFactory().count(filter);
+    }
+
+    @Override
+    public List<BallotChoiceModel> getChoices(Integer ballotModelId) throws NotAllowedException {
+        if (ballotModelId == null) {
+            throw new NotAllowedException();
+        }
+
+        return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotId(
+            ballotModelId
+        );
+    }
+
+    @Override
+    public int getVotingCount(BallotChoiceModel choiceModel) {
+        BallotModel b = this.get(choiceModel.getBallotId());
+        if (b == null) {
+            return 0;
+        }
+
+        return this.getCalculatedVotingCount(choiceModel);
+    }
+
+
+    @Override
+    public boolean update(final BallotModel ballotModel) {
+        ballotModel.setModifiedAt(new Date());
+        this.databaseServiceNew.getBallotModelFactory().update(
+            ballotModel);
+
+        this.handleModified(ballotModel);
+        return true;
+    }
+
+    @Override
+    public boolean removeVotes(final MessageReceiver receiver, final String identity) {
+        List<BallotModel> ballots = this.getBallots(new BallotFilter() {
+            @Override
+            public MessageReceiver getReceiver() {
+                return receiver;
+            }
+
+            @Override
+            public BallotModel.State[] getStates() {
+                return new BallotModel.State[0];
+            }
+
+            @Override
+            public boolean filter(BallotModel ballotModel) {
+                return true;
+            }
+        });
+
+        for (final BallotModel ballotModel : ballots) {
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
+                ballotModel.getId(),
+                identity
+            );
+
+            ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
+                @Override
+                public void handle(BallotVoteListener listener) {
+                    if (listener.handle(ballotModel)) {
+                        listener.onVoteRemoved(ballotModel, identity);
+                    }
+                }
+            });
+        }
+
+        return true;
+    }
+
+    @Override
+    @NonNull
+    public List<String> getVotedParticipants(Integer ballotModelId) {
+        List<String> identities = new ArrayList<>();
+
+        if (ballotModelId != null) {
+            List<BallotVoteModel> ballotVotes = this.getBallotVotes(ballotModelId);
+            for (BallotVoteModel v : ballotVotes) {
+                if (!identities.contains(v.getVotingIdentity())) {
+                    identities.add(v.getVotingIdentity());
+                }
+            }
+        }
+        return identities;
+    }
+
+    @Override
+    @NonNull
+    public List<String> getPendingParticipants(Integer ballotModelId) {
+        String[] allParticipants = this.getParticipants(ballotModelId);
+        List<String> pendingParticipants = new ArrayList<>();
+        if (allParticipants.length > 0) {
+            for (String i : allParticipants) {
+                List<BallotVoteModel> voteModels = this.getVotes(ballotModelId, i);
+                if (voteModels == null || voteModels.size() == 0) {
+                    pendingParticipants.add(i);
+                }
+            }
+        }
+
+        return pendingParticipants;
+    }
+
+
+    @Override
+    @NonNull
+    public String[] getParticipants(MessageReceiver messageReceiver) {
+        if (messageReceiver != null) {
+            switch (messageReceiver.getType()) {
+                case MessageReceiver.Type_GROUP:
+                    return this.groupService.getGroupIdentities(((GroupMessageReceiver) messageReceiver).getGroup());
+
+                case MessageReceiver.Type_CONTACT:
+                    return new String[]{
+                        this.userService.getIdentity(),
+                        ((ContactMessageReceiver) messageReceiver).getContact().getIdentity()
+                    };
+                case MessageReceiver.Type_DISTRIBUTION_LIST:
+                    break;
+            }
+        }
+        return new String[0];
+    }
+
+    @Override
+    @NonNull
+    public String[] getParticipants(Integer ballotModelId) {
+        BallotModel b = this.get(ballotModelId);
+        if (b != null) {
+            try {
+                LinkBallotModel link = this.getLinkedBallotModel(b);
+                if (link != null) {
+                    switch (link.getType()) {
+                        case GROUP:
+                            GroupModel groupModel = this.getGroupModel(link);
+                            if (groupModel != null) {
+                                return this.groupService.getGroupIdentities(this.getGroupModel(link));
+                            }
+                            break;
+                        case CONTACT:
+                            ContactModel contactModel = this.getContactModel(link);
+                            if (contactModel != null) {
+                                return new String[]{
+                                    this.userService.getIdentity(),
+                                    contactModel.getIdentity()};
+                            }
+                            break;
+
+                        default:
+                            throw new NotAllowedException("invalid type");
+                    }
+                }
+            } catch (NotAllowedException e) {
+                logger.error("Exception", e);
+            }
+        }
+
+        return new String[0];
+    }
+
+    private List<BallotVoteModel> getVotes(Integer ballotModelId, String fromIdentity) {
+        if (ballotModelId == null) {
+            return null;
+        }
+
+        return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotIdAndVotingIdentity(
+            ballotModelId,
+            fromIdentity
+        );
+    }
+
+    @Override
+    public boolean hasVoted(Integer ballotModelId, String fromIdentity) {
+        if (ballotModelId == null) {
+            return false;
+        }
+
+        return this.databaseServiceNew.getBallotVoteModelFactory().countByBallotIdAndVotingIdentity(
+            ballotModelId,
+            fromIdentity
+        ) > 0L;
+    }
+
+    @Override
+    public List<BallotVoteModel> getMyVotes(Integer ballotModelId) {
+        return this.getVotes(ballotModelId, this.userService.getIdentity());
+    }
+
+    @Override
+    public List<BallotVoteModel> getBallotVotes(Integer ballotModelId) {
+        if (ballotModelId == null) {
+            return null;
+        }
+        return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotId(
+            ballotModelId);
+    }
+
+
+    @Override
+    public boolean removeAll() {
+        this.databaseServiceNew.getBallotModelFactory().deleteAll();
+        this.databaseServiceNew.getBallotVoteModelFactory().deleteAll();
+        this.databaseServiceNew.getBallotChoiceModelFactory().deleteAll();
+        this.databaseServiceNew.getGroupBallotModelFactory().deleteAll();
+        return true;
+    }
+
+    @Override
+    public BallotPublishResult publish(MessageReceiver messageReceiver, final BallotModel ballotModel, AbstractMessageModel abstractMessageModel) throws NotAllowedException, MessageTooLongException {
+        return this.publish(messageReceiver, ballotModel, abstractMessageModel, null);
+    }
+
+    @Override
+    public BallotPublishResult publish(MessageReceiver messageReceiver,
+                                       final BallotModel ballotModel,
+                                       AbstractMessageModel abstractMessageModel,
+                                       @Nullable Collection<String> receivingIdentities
+    ) throws NotAllowedException, MessageTooLongException {
+        BallotPublishResult result = new BallotPublishResult();
+
+        this.checkAccess();
+
+        if (!TestUtil.required(messageReceiver, ballotModel)) {
+            return result;
+        }
+
+        // validate choices
+        List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
+        if (choices == null || choices.size() < REQUIRED_CHOICE_COUNT) {
+            return result.error(R.string.ballot_error_more_than_x_choices);
+        }
+
+        switch (messageReceiver.getType()) {
+            case MessageReceiver.Type_GROUP:
+                this.link(((GroupMessageReceiver) messageReceiver).getGroup(), ballotModel);
+                break;
+
+            case MessageReceiver.Type_CONTACT:
+                this.link(((ContactMessageReceiver) messageReceiver).getContact(), ballotModel);
+                break;
+        }
+
+        final boolean isClosing = ballotModel.getState() == BallotModel.State.CLOSED;
+
+        BallotData ballotData = new BallotData();
+        ballotData.setDescription(ballotModel.getName());
+
+        switch (ballotModel.getChoiceType()) {
+            case TEXT:
+                ballotData.setChoiceType(BallotData.ChoiceType.TEXT);
+                break;
+        }
+
+        switch (ballotModel.getType()) {
+            case RESULT_ON_CLOSE:
+                ballotData.setType(BallotData.Type.RESULT_ON_CLOSE);
+                break;
+            case INTERMEDIATE:
+            default:
+                ballotData.setType(BallotData.Type.INTERMEDIATE);
+        }
+
+        switch (ballotModel.getAssessment()) {
+            case MULTIPLE_CHOICE:
+                ballotData.setAssessmentType(BallotData.AssessmentType.MULTIPLE);
+                break;
+            case SINGLE_CHOICE:
+            default:
+                ballotData.setAssessmentType(BallotData.AssessmentType.SINGLE);
+        }
+
+        switch (ballotModel.getState()) {
+            case CLOSED:
+                ballotData.setState(BallotData.State.CLOSED);
+                break;
+            case OPEN:
+            default:
+                ballotData.setState(BallotData.State.OPEN);
+        }
+
+        switch (ballotModel.getDisplayType()) {
+            case SUMMARY_MODE:
+                ballotData.setDisplayType(BallotData.DisplayType.SUMMARY_MODE);
+                break;
+            case LIST_MODE:
+            default:
+                ballotData.setDisplayType(BallotData.DisplayType.LIST_MODE);
+                break;
+        }
+
+        HashMap<String, Integer> votersPositions = new HashMap<>();
+        List<BallotVoteModel> voteModels = null;
+        int votersCount = 0;
+        if (isClosing || receivingIdentities != null) {
+            // load a list of voters
+            String[] voters = this.getVotedParticipants(ballotModel.getId()).toArray(new String[0]);
+
+            for (String s : voters) {
+                ballotData.addParticipant(s);
+                votersPositions.put(s, votersCount);
+                votersCount++;
+            }
+
+            voteModels = this.getBallotVotes(ballotModel.getId());
+        }
+        // if closing, add result!
+        for (final BallotChoiceModel c : choices) {
+            BallotDataChoice choice = new BallotDataChoice(votersCount);
+            choice.setId(c.getApiBallotChoiceId());
+            choice.setName(c.getName());
+            choice.setOrder(c.getOrder());
+
+            if ((isClosing || receivingIdentities != null) && TestUtil.required(voteModels, votersPositions)) {
+
+                for (BallotVoteModel v : Functional.filter(voteModels, new IPredicateNonNull<BallotVoteModel>() {
+                    @Override
+                    public boolean apply(@NonNull BallotVoteModel type) {
+                        return type.getBallotChoiceId() == c.getId();
+                    }
+                })) {
+                    int pos = votersPositions.get(v.getVotingIdentity());
+                    if (pos >= 0) {
+                        choice.addResult(pos, v.getChoice());
+                    }
+                }
+
+            }
+            ballotData.getChoiceList().add(choice);
+        }
+
+        try {
+            messageReceiver.createAndSendBallotSetupMessage(
+                ballotData,
+                ballotModel,
+                abstractMessageModel,
+                null,
+                receivingIdentities
+            );
+
+            //set as open
+            if (ballotModel.getState() == BallotModel.State.TEMPORARY) {
+                ballotModel.setState(BallotModel.State.OPEN);
+                ballotModel.setModifiedAt(new Date());
+
+                this.databaseServiceNew.getBallotModelFactory().update(
+                    ballotModel
+                );
+
+            }
+
+            result.success();
+        } catch (ThreemaException e) {
+            logger.error("create boxed ballot failed", e);
+            if (e instanceof MessageTooLongException) {
+                throw new MessageTooLongException();
+            }
+        }
+
+        return result;
+    }
+
+    @Override
+    public LinkBallotModel getLinkedBallotModel(BallotModel ballotModel) throws NotAllowedException {
+        if (ballotModel == null) {
+            return null;
+        }
+
+        LinkBallotModel linkBallotModel = this.getLinkModelFromCache(ballotModel.getId());
+        if (linkBallotModel != null) {
+            return linkBallotModel;
+        }
+
+        GroupBallotModel group = this.databaseServiceNew.getGroupBallotModelFactory().getByBallotId(
+            ballotModel.getId());
+
+        if (group != null) {
+            this.cache(group);
+            return group;
+        }
+
+        IdentityBallotModel identityBallotModel = this.databaseServiceNew.getIdentityBallotModelFactory().getByBallotId(
+            ballotModel.getId()
+        );
+        if (identityBallotModel != null) {
+            this.cache(identityBallotModel);
+            return identityBallotModel;
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean remove(final BallotModel ballotModel) throws NotAllowedException {
+        if (serviceManager == null) {
+            logger.debug("Unable to delete ballot, ServiceManager is not available");
+            return false;
+        }
+
+        MessageService messageService;
+        try {
+            messageService = serviceManager.getMessageService();
+        } catch (ThreemaException e) {
+            logger.error("Unable to delete ballot, MessageService not available", e);
+            return false;
+        }
+
+        if (ballotModel != null) {
+            List<AbstractMessageModel> messageModels = messageService.getMessageForBallot(ballotModel);
+
+            //remove all votes
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            //remove choices
+            this.databaseServiceNew.getBallotChoiceModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            //remove link
+            this.databaseServiceNew.getGroupBallotModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            this.databaseServiceNew.getIdentityBallotModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            //remove ballot
+            this.databaseServiceNew.getBallotModelFactory().delete(
+                ballotModel
+            );
+
+            // delete associated messages
+            if (messageModels != null) {
+                for (AbstractMessageModel m : messageModels) {
+                    if (m != null) {
+                        try {
+                            logger.debug("Removing ballot message {} of type {}", m.getApiMessageId() != null ? m.getApiMessageId() : m.getId(), m.getBallotData().getType());
+                            messageService.remove(m);
+                        } catch (Exception e) {
+                            logger.error("Unable to remove message", e);
+                        }
+                    }
+                }
+            }
+
+            // remove ballot from cache
+            this.resetCache(ballotModel);
+
+            ListenerManager.ballotListeners.handle(listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onRemoved(ballotModel);
+                }
+            });
+        }
+        return true;
+    }
+
+    @Override
+    public boolean remove(final MessageReceiver receiver) {
+        try {
+            for (BallotModel ballotModel : this.getBallots(new BallotFilter() {
+                @Override
+                public MessageReceiver getReceiver() {
+                    return receiver;
+                }
+
+                @Override
+                public BallotModel.State[] getStates() {
+                    return null;
+                }
+
+                @Override
+                public boolean filter(BallotModel ballotModel) {
+                    return true;
+                }
+            })) {
+                if (!this.remove(ballotModel)) {
+                    return false;
+                }
+            }
+        } catch (NotAllowedException x) {
+            //do nothing more
+            logger.error("Exception", x);
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean belongsToMe(Integer ballotModelId, MessageReceiver messageReceiver) throws NotAllowedException {
+        BallotModel ballotModel = this.get(ballotModelId);
+
+        if (!TestUtil.required(ballotModel, messageReceiver)) {
+            return false;
+        }
+
+        switch (messageReceiver.getType()) {
+            case MessageReceiver.Type_CONTACT:
+            case MessageReceiver.Type_GROUP:
+                LinkBallotModel l = this.getLinkedBallotModel(ballotModel);
+                if (l != null) {
+                    if (messageReceiver.getType() == MessageReceiver.Type_GROUP && l.getType() == LinkBallotModel.Type.GROUP) {
+                        return ((GroupBallotModel) l).getGroupId() == ((GroupMessageReceiver) messageReceiver).getGroup().getId();
+                    } else if (messageReceiver.getType() == MessageReceiver.Type_CONTACT && l.getType() == LinkBallotModel.Type.CONTACT) {
+                        return TestUtil.compare(((IdentityBallotModel) l).getIdentity(), ((ContactMessageReceiver) messageReceiver).getContact().getIdentity());
+                    }
+                }
+        }
+
+        return false;
+    }
+
+    @Override
+    public BallotVoteResult vote(Integer ballotModelId, Map<Integer, Integer> voting) throws NotAllowedException {
+        BallotModel ballotModel = this.get(ballotModelId);
+
+        if (!TestUtil.required(ballotModel, voting)) {
+            return new BallotVoteResult(false);
+        }
+
+        List<BallotChoiceModel> allChoices = this.getChoices(ballotModel.getId());
+        if (allChoices == null) {
+            return new BallotVoteResult(false);
+        }
+
+        LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
+        MessageReceiver messageReceiver = this.getReceiver(link);
+
+        if (messageReceiver == null) {
+            return new BallotVoteResult(false);
+        }
+
+        //prepare all messages and save local
+        BallotVote[] votes = new BallotVote[allChoices.size()];
+        int n = 0;
+        for (final BallotChoiceModel choiceModel : allChoices) {
+            //change if other values implement
+            final int voteValue;
+            if (voting.containsKey(choiceModel.getId())) {
+                voteValue = voting.get(choiceModel.getId());
+            } else {
+                voteValue = 0;
+            }
+            votes[n] = new BallotVote(
+                choiceModel.getApiBallotChoiceId(),
+                voteValue
+            );
+            n++;
+        }
+
+        try {
+            //send
+            messageReceiver.createAndSendBallotVoteMessage(votes, ballotModel);
+
+            //and save
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
+                ballotModel.getId(),
+                this.userService.getIdentity()
+            );
+
+            for (BallotChoiceModel choiceModel : allChoices) {
+                BallotVoteModel ballotVoteModel = new BallotVoteModel();
+                ballotVoteModel.setVotingIdentity(this.userService.getIdentity());
+                ballotVoteModel.setBallotId(ballotModel.getId());
+                ballotVoteModel.setBallotChoiceId(choiceModel.getId());
+
+                if (voting.containsKey(choiceModel.getId())) {
+                    ballotVoteModel.setChoice(voting.get(choiceModel.getId()));
+                } else {
+                    ballotVoteModel.setChoice(0);
+                }
+
+                ballotVoteModel.setModifiedAt(new Date());
+                ballotVoteModel.setCreatedAt(new Date());
+                this.databaseServiceNew.getBallotVoteModelFactory().create(
+                    ballotVoteModel
+                );
+            }
+        } catch (ThreemaException e) {
+            logger.error("create boxed ballot failed", e);
+            return new BallotVoteResult(false);
+        }
+
+        ListenerManager.ballotVoteListeners.handle(listener -> {
+            if (listener.handle(ballotModel)) {
+                listener.onSelfVote(
+                    ballotModel);
+            }
+        });
+
+        return new BallotVoteResult(true);
+    }
+
+    @Override
+    public BallotVoteResult vote(final BallotVoteInterface voteMessage) throws NotAllowedException {
+        final BallotModel ballotModel = this.get(voteMessage.getBallotId().toString(), voteMessage.getBallotCreatorIdentity());
+
+        //invalid ballot model
+        if (ballotModel == null) {
+            return new BallotVoteResult(false);
+        }
+
+        if (ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE && !TestUtil.compare(
+            ballotModel.getCreatorIdentity(),
+            this.userService.getIdentity())) {
+            logger.error("this is not a intermediate ballot and not mine, ingore the message");
+            //return true to ack the message
+            return new BallotVoteResult(true);
+        }
+
+        //if the ballot is closed, ignore any votes
+        if (ballotModel.getState() == BallotModel.State.CLOSED) {
+            logger.error("this is a closed ballot, ignore this message");
+            return new BallotVoteResult(true);
+        }
+
+        final String fromIdentity = ((AbstractMessage) voteMessage).getFromIdentity();
+
+        //load existing votes of user
+        List<BallotVoteModel> existingVotes = this.getVotes(ballotModel.getId(), fromIdentity);
+        final boolean firstVote = existingVotes == null || existingVotes.size() == 0;
+
+        List<BallotVoteModel> savingVotes = new ArrayList<>();
+        List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
+
+        for (final BallotVote apiVoteModel : voteMessage.getVotes()) {
+            apiVoteModel.getId();
+
+            //check if the choice correct
+            final BallotChoiceModel c = Functional.select(choices, new IPredicateNonNull<BallotChoiceModel>() {
+                @Override
+                public boolean apply(@NonNull BallotChoiceModel type) {
+                    return type.getApiBallotChoiceId() == apiVoteModel.getId();
+                }
+            });
+
+            if (c != null) {
+                //cool, correct choice
+                BallotVoteModel ballotVoteModel = Functional.select(existingVotes, new IPredicateNonNull<BallotVoteModel>() {
+                    @Override
+                    public boolean apply(@NonNull BallotVoteModel type) {
+                        return type.getBallotChoiceId() == c.getId();
+                    }
+                });
+
+                if (ballotVoteModel == null) {
+                    //ok, a new vote
+                    ballotVoteModel = new BallotVoteModel();
+                    ballotVoteModel.setBallotId(ballotModel.getId());
+                    ballotVoteModel.setBallotChoiceId(c.getId());
+                    ballotVoteModel.setVotingIdentity(fromIdentity);
+                    ballotVoteModel.setCreatedAt(new Date());
+                } else {
+                    //remove from existing votes
+                    if (existingVotes != null) {
+                        existingVotes.remove(ballotVoteModel);
+                    }
+                }
+
+                if (
+                    //is a new vote...
+                    ballotVoteModel.getId() <= 0
+                        //... or a modified
+                        || ballotVoteModel.getChoice() != apiVoteModel.getValue()) {
+
+                    ballotVoteModel.setChoice(apiVoteModel.getValue());
+                    ballotVoteModel.setModifiedAt(new Date());
+                    savingVotes.add(ballotVoteModel);
+                }
+            }
+        }
+
+        //remove votes
+        boolean hasModifications = false;
+
+        if (existingVotes != null && existingVotes.size() > 0) {
+            int[] ids = new int[existingVotes.size()];
+            for (int n = 0; n < ids.length; n++) {
+                ids[n] = existingVotes.get(n).getId();
+            }
+
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByIds(
+                ids);
+
+            hasModifications = true;
+        }
+
+        for (BallotVoteModel ballotVoteModel : savingVotes) {
+            this.databaseServiceNew.getBallotVoteModelFactory().createOrUpdate(
+                ballotVoteModel
+            );
+            hasModifications = true;
+        }
+
+        if (hasModifications) {
+
+            ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
+                @Override
+                public void handle(BallotVoteListener listener) {
+                    if (listener.handle(ballotModel)) {
+                        listener.onVoteChanged(
+                            ballotModel,
+                            fromIdentity,
+                            firstVote);
+                    }
+                }
+            });
+        }
+        return new BallotVoteResult(true);
+    }
+
+
+    private GroupModel getGroupModel(LinkBallotModel link) {
+        if (link.getType() != LinkBallotModel.Type.GROUP) {
+            return null;
+        }
+
+        int groupId = ((GroupBallotModel) link).getGroupId();
+        return this.groupService.getById(groupId);
+    }
+
+
+    private ContactModel getContactModel(LinkBallotModel link) {
+        if (link.getType() != LinkBallotModel.Type.CONTACT) {
+            return null;
+        }
+
+        String identity = ((IdentityBallotModel) link).getIdentity();
+        return this.contactService.getByIdentity(identity);
+
+    }
+
+    @Override
+    public MessageReceiver getReceiver(BallotModel ballotModel) {
+        try {
+            LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
+            return this.getReceiver(link);
+        } catch (NotAllowedException e) {
+            logger.error("Exception", e);
+            return null;
+        }
+    }
+
+    @Override
+    public BallotMatrixData getMatrixData(int ballotModelId) {
+        try {
+            BallotModel ballotModel = this.get(ballotModelId);
+
+            //ok, ballot not found
+            if (ballotModel == null) {
+                throw new ThreemaException("invalid ballot");
+            }
+
+            BallotMatrixService matrixService = new BallotMatrixServiceImpl(ballotModel);
+
+            String[] participants = this.getParticipants(ballotModelId);
+
+            if (participants.length > 0) {
+                for (String identity : participants) {
+                    matrixService.createParticipant(identity);
+                }
+
+                for (BallotChoiceModel choice : this.getChoices(ballotModelId)) {
+                    matrixService.createChoice(choice);
+                }
+
+                for (BallotVoteModel ballotVoteModel : this.getBallotVotes(ballotModelId)) {
+                    matrixService.addVote(ballotVoteModel);
+                }
+
+                return matrixService.finish();
+            }
+        } catch (ThreemaException x) {
+            logger.error("Exception", x);
+        }
+        return null;
+    }
+
+    private MessageReceiver getReceiver(LinkBallotModel link) {
+        if (link != null) {
+            switch (link.getType()) {
+                case GROUP:
+                    GroupModel groupModel = this.getGroupModel(link);
+                    return this.groupService.createReceiver(groupModel);
+                case CONTACT:
+                    ContactModel contactModel = this.getContactModel(link);
+                    return this.contactService.createReceiver(contactModel);
+            }
+        }
+        return null;
+    }
+
+    private int getCalculatedVotingCount(BallotChoiceModel choiceModel) {
+        return (int) this.databaseServiceNew.getBallotVoteModelFactory().countByBallotChoiceIdAndChoice(
+            choiceModel.getId(),
+            1);
+    }
+
+    private BallotChoiceModel getChoiceByApiId(BallotModel ballotModel, int choiceId) {
+        return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotIdAndApiChoiceId(
+            ballotModel.getId(),
+            choiceId
+        );
+    }
+
+    /**
+     * Link a ballot with a contact
+     *
+     * @return success
+     */
+    private boolean link(ContactModel contactModel, BallotModel ballotModel) {
+        IdentityBallotModelFactory identityBallotModelFactory = this.databaseServiceNew.getIdentityBallotModelFactory();
+        if (identityBallotModelFactory.getByIdentityAndBallotId(
+            contactModel.getIdentity(),
+            ballotModel.getId()
+        ) != null) {
+            //already linked
+            return true;
+        }
+
+        IdentityBallotModel m = new IdentityBallotModel();
+        m.setBallotId(ballotModel.getId());
+        m.setIdentity(contactModel.getIdentity());
+        identityBallotModelFactory.create(
+            m);
+
+        this.cache(m);
+
+        return true;
+    }
+
+    /**
+     * Link a a ballot with a group
+     *
+     * @return success
+     */
+    private boolean link(GroupModel groupModel, BallotModel ballotModel) {
+        GroupBallotModelFactory groupBallotModelFactory = this.databaseServiceNew.getGroupBallotModelFactory();
+        if (groupBallotModelFactory.getByGroupIdAndBallotId(
+            groupModel.getId(),
+            ballotModel.getId()
+        ) != null) {
+            //already linked
+            return true;
+        }
+
+        GroupBallotModel m = new GroupBallotModel();
+        m.setBallotId(ballotModel.getId());
+        m.setGroupId(groupModel.getId());
+        groupBallotModelFactory.create(
+            m);
+
+        this.cache(m);
+        return true;
+    }
+
+    private void handleModified(final BallotModel ballotModel) {
+        ListenerManager.ballotListeners.handle(new ListenerManager.HandleListener<BallotListener>() {
+            @Override
+            public void handle(BallotListener listener) {
+                if (listener.handle(ballotModel)) {
+                    listener.onModified(ballotModel);
+                }
+            }
+        });
+    }
+
+    private void checkAccess() throws NotAllowedException {
+        if (!this.userService.hasIdentity()) {
+            throw new NotAllowedException();
+        }
+    }
+
+    private void cache(List<BallotModel> ballotModels) {
+        for (BallotModel m : ballotModels) {
+            this.cache(m);
+        }
+    }
+
+    private void cache(BallotModel ballotModel) {
+        if (ballotModel != null) {
+            synchronized (this.ballotModelCache) {
+                this.ballotModelCache.put(ballotModel.getId(), ballotModel);
+            }
+        }
+    }
+
+    private void cache(LinkBallotModel linkBallotModel) {
+        if (linkBallotModel != null) {
+            synchronized (this.linkBallotModelCache) {
+                this.linkBallotModelCache.put(linkBallotModel.getBallotId(), linkBallotModel);
+            }
+        }
+    }
+
+    private void resetCache(BallotModel ballotModel) {
+        if (ballotModel != null) {
+            synchronized (this.ballotModelCache) {
+                this.ballotModelCache.remove(ballotModel.getId());
+            }
+        }
+    }
+
+    @Nullable
+    private BallotModel getFromCache(int id) {
+        synchronized (this.ballotModelCache) {
+            if (this.ballotModelCache.indexOfKey(id) >= 0) {
+                return this.ballotModelCache.get(id);
+            }
+        }
+
+        return null;
+    }
+
+    private LinkBallotModel getLinkModelFromCache(int ballotId) {
+        synchronized (this.linkBallotModelCache) {
+            if (this.linkBallotModelCache.indexOfKey(ballotId) >= 0) {
+                return this.linkBallotModelCache.get(ballotId);
+            }
+        }
+        return null;
+    }
+
+    private BallotModel getFromCache(final String apiId, final String creator) {
+        synchronized (this.ballotModelCache) {
+            return Functional.select(this.ballotModelCache, new IPredicateNonNull<BallotModel>() {
+                @Override
+                public boolean apply(@NonNull BallotModel type) {
+                    return TestUtil.compare(type.getApiBallotId(), apiId)
+                        && TestUtil.compare(type.getCreatorIdentity(), creator);
+                }
+            });
+        }
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java
index 22166638..212da01e 100644
--- a/app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java
+++ b/app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java
@@ -89,7 +89,7 @@ public class AnimatedImageDrawableMessagePlayer extends MessagePlayer {
 	@Override
 	protected AbstractMessageModel setData(MediaMessageDataInterface data) {
 		AbstractMessageModel messageModel = this.getMessageModel();
-		messageModel.setFileData((FileDataModel) data);
+		messageModel.setFileDataModel((FileDataModel) data);
 		return messageModel;
 	}
 
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java
index eb2e8cb2..7a9fa21a 100644
--- a/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java
+++ b/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java
@@ -161,7 +161,7 @@ public class AudioMessagePlayer extends MessagePlayer {
         if (messageModel.getType() == MessageType.VOICEMESSAGE) {
             messageModel.setAudioData((AudioDataModel) data);
         } else {
-            messageModel.setFileData((FileDataModel) data);
+            messageModel.setFileDataModel((FileDataModel) data);
         }
         return messageModel;
     }
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java
index af76eb02..535d10e7 100644
--- a/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java
+++ b/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java
@@ -57,7 +57,7 @@ public class FileMessagePlayer extends MessagePlayer {
 	@Override
 	protected AbstractMessageModel setData(MediaMessageDataInterface data) {
 		AbstractMessageModel messageModel =  this.getMessageModel();
-		messageModel.setFileData((FileDataModel) data);
+		messageModel.setFileDataModel((FileDataModel) data);
 		return messageModel;
 	}
 
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java
index df30fd0c..4683633d 100644
--- a/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java
+++ b/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java
@@ -29,6 +29,7 @@ import android.os.AsyncTask;
 
 import androidx.annotation.AnyThread;
 import androidx.annotation.MainThread;
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
 
@@ -51,6 +52,7 @@ import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ProgressListener;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.data.media.MediaMessageDataInterface;
 
diff --git a/app/src/main/java/ch/threema/app/services/notification/NotificationService.java b/app/src/main/java/ch/threema/app/services/notification/NotificationService.java
index 1c717c21..5eb1a4fa 100644
--- a/app/src/main/java/ch/threema/app/services/notification/NotificationService.java
+++ b/app/src/main/java/ch/threema/app/services/notification/NotificationService.java
@@ -259,7 +259,7 @@ public interface NotificationService {
 
 	void cancelWorkSyncProgress();
 
-	void showNewSyncedContactsNotification(List<ContactModel> contactModels);
+	void showNewSyncedContactsNotification(List<ch.threema.data.models.ContactModel> contactModels);
 
 	void showWebclientResumeFailed(String msg);
 	void cancelRestartNotification();
diff --git a/app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java b/app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java
index 49e44a65..bcfe9d4e 100644
--- a/app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java
@@ -21,17 +21,6 @@
 
 package ch.threema.app.services.notification;
 
-import static android.provider.Settings.System.DEFAULT_NOTIFICATION_URI;
-import static android.provider.Settings.System.DEFAULT_RINGTONE_URI;
-import static androidx.core.app.NotificationCompat.MessagingStyle.MAXIMUM_RETAINED_MESSAGES;
-import static ch.threema.app.ThreemaApplication.WORK_SYNC_NOTIFICATION_ID;
-import static ch.threema.app.backuprestore.csv.RestoreService.RESTORE_COMPLETION_NOTIFICATION_ID;
-import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_ACTIVITY_MODE;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CALL_ID;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CONTACT_IDENTITY;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_IS_INITIATOR;
-
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
@@ -50,17 +39,6 @@ import android.os.SystemClock;
 import android.service.notification.StatusBarNotification;
 import android.text.format.DateUtils;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.RequiresApi;
-import androidx.core.app.NotificationCompat;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.app.Person;
-import androidx.core.app.RemoteInput;
-import androidx.core.app.TaskStackBuilder;
-import androidx.core.content.LocusIdCompat;
-import androidx.core.graphics.drawable.IconCompat;
-
 import org.jetbrains.annotations.Contract;
 import org.slf4j.Logger;
 
@@ -76,6 +54,16 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.RequiresApi;
+import androidx.core.app.NotificationCompat;
+import androidx.core.app.NotificationManagerCompat;
+import androidx.core.app.Person;
+import androidx.core.app.RemoteInput;
+import androidx.core.app.TaskStackBuilder;
+import androidx.core.content.LocusIdCompat;
+import androidx.core.graphics.drawable.IconCompat;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
@@ -100,6 +88,7 @@ import ch.threema.app.services.LockAppService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.RingtoneService;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.DNDUtil;
 import ch.threema.app.utils.IntentDataUtil;
 import ch.threema.app.utils.NameUtil;
@@ -120,6 +109,17 @@ import ch.threema.storage.models.ServerMessageModel;
 import ch.threema.storage.models.group.IncomingGroupJoinRequestModel;
 import ch.threema.storage.models.group.OutgoingGroupJoinRequestModel;
 
+import static android.provider.Settings.System.DEFAULT_NOTIFICATION_URI;
+import static android.provider.Settings.System.DEFAULT_RINGTONE_URI;
+import static androidx.core.app.NotificationCompat.MessagingStyle.MAXIMUM_RETAINED_MESSAGES;
+import static ch.threema.app.ThreemaApplication.WORK_SYNC_NOTIFICATION_ID;
+import static ch.threema.app.backuprestore.csv.RestoreService.RESTORE_COMPLETION_NOTIFICATION_ID;
+import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_ACTIVITY_MODE;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CALL_ID;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CONTACT_IDENTITY;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_IS_INITIATOR;
+
 public class NotificationServiceImpl implements NotificationService {
     private static final Logger logger = LoggingUtil.getThreemaLogger("NotificationServiceImpl");
     private static final long NOTIFY_AGAIN_TIMEOUT = 30 * DateUtils.SECOND_IN_MILLIS;
@@ -587,15 +587,18 @@ public class NotificationServiceImpl implements NotificationService {
 
     @Nullable
     private NotificationCompat.MessagingStyle getMessagingStyle(ConversationNotificationGroup group, ArrayList<ConversationNotification> notifications) {
-        if (getContactService() == null) {
+        getContactService();
+        if (contactService == null) {
+            logger.warn("Contact service is null");
             return null;
         }
 
+
         String chatName = group.name;
         boolean isGroupChat = group.messageReceiver instanceof GroupMessageReceiver;
         Person.Builder builder = new Person.Builder()
             .setName(context.getString(R.string.me_myself_and_i))
-            .setKey(getContactService().getUniqueIdString(getContactService().getMe()));
+            .setKey(ContactUtil.getUniqueIdString(getContactService().getMe().getIdentity()));
 
         Bitmap avatar = getContactService().getAvatar(getContactService().getMe(), false);
         if (avatar != null) {
@@ -1203,14 +1206,14 @@ public class NotificationServiceImpl implements NotificationService {
     }
 
     @Override
-    public void showNewSyncedContactsNotification(@Nullable List<ContactModel> contactModels) {
+    public void showNewSyncedContactsNotification(@Nullable List<ch.threema.data.models.ContactModel> contactModels) {
         if (contactModels != null && !contactModels.isEmpty()) {
             String message;
             Intent notificationIntent;
 
             if (contactModels.size() > 1) {
                 StringBuilder contactListBuilder = new StringBuilder();
-                for (ContactModel contactModel : contactModels) {
+                for (ch.threema.data.models.ContactModel contactModel : contactModels) {
                     if (contactListBuilder.length() > 0) {
                         contactListBuilder.append(", ");
                     }
@@ -1312,13 +1315,8 @@ public class NotificationServiceImpl implements NotificationService {
 
     @Override
     public void cancel(@NonNull String identity) {
-        if (contactService == null) {
-            logger.warn("Cannot cancel notification because contact service is null");
-            return;
-        }
-
-        int uniqueId = contactService.getUniqueId(identity);
-        String uniqueIdString = contactService.getUniqueIdString(identity);
+        int uniqueId = ContactUtil.getUniqueId(identity);
+        String uniqueIdString = ContactUtil.getUniqueIdString(identity);
 
         this.cancel(uniqueId, uniqueIdString);
     }
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion104.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion104.kt
new file mode 100644
index 00000000..ee0d0869
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion104.kt
@@ -0,0 +1,98 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.services.systemupdate
+
+import android.content.Context
+import androidx.preference.PreferenceManager
+import ch.threema.app.services.UpdateSystemService
+import ch.threema.app.stores.PreferenceStore
+import net.zetetic.database.sqlcipher.SQLiteDatabase
+
+internal class SystemUpdateToVersion104(
+    private val db: SQLiteDatabase,
+    private val context: Context,
+) : UpdateSystemService.SystemUpdate {
+    companion object {
+        const val VERSION = 104
+    }
+
+    override fun runAsync() = true
+
+    override fun runDirectly(): Boolean {
+
+        addUserStateColumn()
+
+        val myIdentity = PreferenceManager.getDefaultSharedPreferences(context)
+            .getString(PreferenceStore.PREFS_IDENTITY, null)
+            ?: // In case there is no identity, there is also no data in the database and we can
+            // skip the following steps.
+            return true
+
+        initializeUserStateColumn(myIdentity)
+
+        removeUserFromGroupMembers(myIdentity)
+
+        return true
+    }
+
+    private fun addUserStateColumn() {
+        val table = "m_group"
+        val field = "userState"
+
+        // Add field
+        if (!fieldExists(db, table, field)) {
+            db.execSQL("ALTER TABLE `$table` ADD COLUMN `$field` INTEGER DEFAULT 0 NOT NULL")
+        }
+    }
+
+    private fun initializeUserStateColumn(myIdentity: String) {
+        // The default value is 0 (member) and we set all groups where the user is no member anymore
+        // to 2 (left). We cannot (yet) distinguish 1 (kicked) from 2 (left) at this point.
+        db.execSQL(
+            """
+                UPDATE m_group
+                SET userState = 2
+                WHERE m_group.id NOT IN (
+                    SELECT groupId
+                    FROM group_member
+                    WHERE identity = ?
+                );
+        """, arrayOf(myIdentity)
+        )
+    }
+
+    private fun removeUserFromGroupMembers(myIdentity: String) {
+        // Ensure that the user is not part of any groups' member list. From this point on, we do
+        // never store the user in the member list even if the user is a member of the group. This
+        // is because we now have the user state which becomes the new single source of truth
+        // regarding the user's group membership.
+        db.execSQL(
+            """
+            DELETE FROM group_member
+            WHERE identity = ?
+        """, arrayOf(myIdentity)
+        )
+    }
+
+    override fun getText() = "version $VERSION (add group user state)"
+
+}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java
index f3dfe22b..859fb476 100644
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java
+++ b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java
@@ -28,6 +28,7 @@ import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.UpdateSystemService;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.models.ContactModel;
@@ -60,7 +61,7 @@ public class SystemUpdateToVersion39 implements UpdateSystemService.SystemUpdate
 			// call find with fetchMissingFeatureLevel = true to fetch all contacts without current feature level
 			contactService.find(new ContactService.Filter() {
 				@Override
-				public ContactModel.State[] states() {
+				public IdentityState[] states() {
 					return null;
 				}
 
diff --git a/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java b/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java
index 1f9a6b88..07e12bbd 100644
--- a/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java
+++ b/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java
@@ -31,31 +31,20 @@ import java.util.stream.Collectors;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
-import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ListenerManager;
-import ch.threema.app.managers.ServiceManager;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.services.MessageService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.fs.DHSession;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.ServerAddressProvider;
-import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.stores.ContactStore;
-import ch.threema.domain.stores.DHSessionStoreException;
-import ch.threema.domain.stores.DHSessionStoreInterface;
-import ch.threema.domain.stores.IdentityStoreInterface;
-import ch.threema.protobuf.csp.e2e.fs.Terminate;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.ContactModelFactory;
 import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
-import ch.threema.storage.models.data.status.ForwardSecurityStatusDataModel;
 
 /**
  * The {@link DatabaseContactStore} is an implementation of the {@link ContactStore} interface
@@ -64,8 +53,6 @@ import ch.threema.storage.models.data.status.ForwardSecurityStatusDataModel;
 public class DatabaseContactStore implements ContactStore {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("DatabaseContactStore");
 
-	private final @NonNull IdentityStoreInterface identityStore;
-	private final @NonNull DHSessionStoreInterface fsSessions;
 	private final @NonNull DatabaseServiceNew databaseServiceNew;
 
 	/**
@@ -74,19 +61,15 @@ public class DatabaseContactStore implements ContactStore {
 	private final @NonNull Map<String, Contact> specialContacts = new HashMap<>();
 
 	/**
-	 * The cache of fetched contacts. Note that this cache only contains the cached contacts from a
-	 * server fetch. Contacts from the database are not cached here.
+	 * The cache of contacts. Note that this cache only contains the cached contacts from a server
+	 * fetch. Contacts from the database are not cached here.
 	 */
-	private final @NonNull Map<String, Contact> contactCache = new HashMap<>();
+	private final @NonNull Map<String, BasicContact> contactCache = new HashMap<>();
 
 	public DatabaseContactStore(
-		@NonNull IdentityStoreInterface identityStore,
-		@NonNull DHSessionStoreInterface fsSessions,
 		@NonNull DatabaseServiceNew databaseServiceNew,
 		@NonNull ServerAddressProvider serverAddressProvider
 	) {
-		this.identityStore = identityStore;
-		this.fsSessions = fsSessions;
 		this.databaseServiceNew = databaseServiceNew;
 
 		try {
@@ -119,10 +102,16 @@ public class DatabaseContactStore implements ContactStore {
 	}
 
 	@Override
-	public void addCachedContact(@NonNull Contact contact) {
+	public void addCachedContact(@NonNull BasicContact contact) {
 		contactCache.put(contact.getIdentity(), contact);
 	}
 
+	@Nullable
+	@Override
+	public BasicContact getCachedContact(@NonNull String identity) {
+		return contactCache.get(identity);
+	}
+
 	@Nullable
 	@Override
 	public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
@@ -173,28 +162,6 @@ public class DatabaseContactStore implements ContactStore {
 					);
 				}
 			}
-
-			// Only warn about an FS feature mask downgrade if an FS session existed.
-			DHSession fsSession = null;
-			try {
-				fsSession = fsSessions.getBestDHSession(identityStore.getIdentity(), contact.getIdentity(), ThreemaApplication.requireServiceManager().getMigrationTaskHandle());
-			} catch (DHSessionStoreException | NullPointerException exception) {
-				logger.error("Unable to determine best DH session", exception);
-			}
-			if (fsSession != null && !ThreemaFeature.canForwardSecurity(contactModel.getFeatureMask())) {
-				logger.info("Forward security feature has been downgraded for contact {}", contactModel.getIdentity());
-				// Create a status message that forward security has been disabled for this contact
-				// due to a downgrade.
-				createForwardSecurityDowngradedStatus(contactModel);
-
-				// Clear and terminate all sessions with that contact
-				ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-				if (serviceManager != null) {
-					serviceManager.getTaskCreator().scheduleDeleteAndTerminateFSSessionsTaskAsync(
-						contact, Terminate.Cause.DISABLED_BY_REMOTE
-					);
-				}
-			}
 		}
 
 		contactModelFactory.createOrUpdate(contactModel);
@@ -207,49 +174,9 @@ public class DatabaseContactStore implements ContactStore {
 		}
 	}
 
-	private void createForwardSecurityDowngradedStatus(@NonNull ContactModel contactModel) {
-		try {
-			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-			if (serviceManager != null) {
-				MessageService messageService = serviceManager.getMessageService();
-				ContactService contactService = serviceManager.getContactService();
-				messageService.createForwardSecurityStatus(
-					contactService.createReceiver(contactModel),
-					ForwardSecurityStatusDataModel.ForwardSecurityStatusType.FORWARD_SECURITY_UNAVAILABLE_DOWNGRADE,
-					0,
-					null
-				);
-			} else {
-				logger.error("ServiceManager is null");
-			}
-		} catch (ThreemaException e) {
-			logger.error("Error while creating forward security downgrade status message", e);
-		}
-	}
-
-	/**
-	 * Mark the contact as hidden / unhidden. Then store or update the contact in the database.
-	 */
-	public void hideContact(@NonNull ContactModel contactModel, boolean hide) {
-		// Mark as hidden / unhidden
-		contactModel.setAcquaintanceLevel(hide ? AcquaintanceLevel.GROUP : AcquaintanceLevel.DIRECT);
-
-		// Update database
-		ContactModelFactory contactModelFactory = this.databaseServiceNew.getContactModelFactory();
-		contactModelFactory.createOrUpdate(contactModel);
-
-		// Fire listeners
-		this.fireOnModifiedContact(contactModel.getIdentity());
-	}
-
 	@Override
-	public void removeContact(@NonNull Contact contact) {
-		this.removeContact((ContactModel)contact);
-	}
-
-	public void removeContact(final ContactModel contactModel) {
-		this.databaseServiceNew.getContactModelFactory().delete(contactModel);
-		fireOnRemovedContact(contactModel);
+	public boolean isSpecialContact(@NonNull String identity) {
+		return specialContacts.containsKey(identity);
 	}
 
 	private void fireOnNewContact(final ContactModel createdContactModel) {
@@ -263,10 +190,4 @@ public class DatabaseContactStore implements ContactStore {
 			listener.onModified(identity);
 		});
 	}
-
-	private void fireOnRemovedContact(final ContactModel removedContactModel) {
-		ListenerManager.contactListeners.handle(listener -> {
-			listener.onRemoved(removedContactModel.getIdentity());
-		});
-	}
 }
diff --git a/app/src/main/java/ch/threema/app/stores/IdentityStore.java b/app/src/main/java/ch/threema/app/stores/IdentityStore.java
index d6c5d286..9a9e017b 100644
--- a/app/src/main/java/ch/threema/app/stores/IdentityStore.java
+++ b/app/src/main/java/ch/threema/app/stores/IdentityStore.java
@@ -132,7 +132,11 @@ public class IdentityStore implements IdentityStoreInterface {
 		return this.publicNickname;
 	}
 
-	public void setPublicNickname(String publicNickname) {
+    /**
+     * This method persists the public nickname. It does *not* reflect the changes and must
+     * therefore only be used to persist the nickname.
+     */
+	public void persistPublicNickname(String publicNickname) {
 		this.publicNickname = publicNickname;
 		this.preferenceStore.save(PreferenceStore.PREFS_PUBLIC_NICKNAME, publicNickname);
 		ListenerManager.profileListeners.handle(listener -> listener.onNicknameChanged(publicNickname));
@@ -156,7 +160,7 @@ public class IdentityStore implements IdentityStoreInterface {
 		this.preferenceStore.save(PreferenceStore.PREFS_PRIVATE_KEY, privateKey, true);
 
 		//default identity
-		this.setPublicNickname(identity);
+		this.persistPublicNickname(identity);
 	}
 
 	public void clear() {
diff --git a/app/src/main/java/ch/threema/app/stores/PreferenceStore.java b/app/src/main/java/ch/threema/app/stores/PreferenceStore.java
index 315054a4..147d2c7f 100644
--- a/app/src/main/java/ch/threema/app/stores/PreferenceStore.java
+++ b/app/src/main/java/ch/threema/app/stores/PreferenceStore.java
@@ -35,15 +35,11 @@ import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 
-import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
-import java.io.FilenameFilter;
 import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectInputStream;
 import java.io.ObjectOutput;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -59,7 +55,6 @@ import java.util.Set;
 import javax.crypto.CipherInputStream;
 import javax.crypto.CipherOutputStream;
 
-import ch.threema.app.listeners.PreferenceListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.StringConversionUtil;
@@ -91,7 +86,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 
 	private final Context context;
 	private final MasterKey masterKey;
-	private SharedPreferences sharedPreferences;
+	private final SharedPreferences sharedPreferences;
 
 	public PreferenceStore(Context context, MasterKey masterKey) {
 		this.context = context;
@@ -309,7 +304,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		if (crypt) {
 			//save into a file
 			try {
-				//TODO
+				// TODO(ANDR-2798): Implement or remove method if unused
 				//this.saveDataToCryptedFile(thing, key);
 			} catch (Exception e) {
 				logger.error("Exception", e);
@@ -340,6 +335,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		// ignore close exception
 	}
 
+	@Override
 	public void save(String key, JSONArray array, boolean crypt) {
 		if (crypt) {
 			if (array != null) {
@@ -423,7 +419,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 	@Override
 	@Nullable
 	public String[] getStringArray(String key, boolean crypted) {
-		String value = null;
+		String value;
 		if (crypted) {
 			byte[] r = this.getDataFromCryptedFile(key);
 			if (r != null) {
@@ -606,10 +602,12 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		return this.sharedPreferences.getFloat(key, defValue);
 	}
 
+	@Override
 	public boolean getBoolean(String key) {
 		return this.sharedPreferences.getBoolean(key, false);
 	}
 
+	@Override
 	public boolean getBoolean(String key, boolean defValue) {
 		return this.sharedPreferences.getBoolean(key, defValue);
 	}
@@ -668,37 +666,6 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		return null;
 	}
 
-	@Override
-	public <T> T getRealObject(String key, boolean crypt) {
-		try {
-			if (crypt) {
-				byte[] data = this.getDataFromCryptedFile(key);
-
-				ByteArrayInputStream bis = new ByteArrayInputStream(data);
-				ObjectInput in = null;
-				T o = null;
-				try {
-					in = new ObjectInputStream(bis);
-					o = (T)in.readObject();
-				} finally {
-					try {
-						if (in != null) {
-							in.close();
-						}
-					} catch (IOException ex) {
-						// ignore close exception
-					}
-				}
-				return o;
-			} else {
-				// not implemented
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-		return null;
-	}
-
 	@Override
 	public void clear() {
 		SharedPreferences.Editor editor = this.sharedPreferences.edit();
@@ -706,12 +673,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		editor.apply();
 
 		try {
-			for (File f : this.context.getFilesDir().listFiles(new FilenameFilter() {
-				@Override
-				public boolean accept(File dir, String filename) {
-					return filename.startsWith(CRYPTED_FILE_PREFIX);
-				}
-			})) {
+			for (File f : this.context.getFilesDir().listFiles((dir, filename) -> filename.startsWith(CRYPTED_FILE_PREFIX))) {
 				FileUtil.deleteFileOrWarn(f, "clear", logger);
 			}
 		} catch (Exception e) {
@@ -749,12 +711,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 	}
 
 	private void fireOnChanged(final String key, final  Object value) {
-		ListenerManager.preferenceListeners.handle(new ListenerManager.HandleListener<PreferenceListener>() {
-			@Override
-			public void handle(PreferenceListener listener) {
-				listener.onChanged(key, value);
-			}
-		});
+		ListenerManager.preferenceListeners.handle(listener -> listener.onChanged(key, value));
 	}
 
 	@WorkerThread
diff --git a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java
index b677b64c..96a5839e 100644
--- a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java
+++ b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java
@@ -155,8 +155,6 @@ public interface PreferenceStoreInterface {
 
 	JSONObject getJSONObject(String key, boolean crypt);
 
-	<T> T getRealObject(String key, boolean crypt);
-
 	void clear();
 
 	Map<String, ?> getAllNonCrypted();
diff --git a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java
index 668f99df..9e0dc8ac 100644
--- a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java
+++ b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java
@@ -284,11 +284,6 @@ public class PreferenceStoreInterfaceDevNullImpl implements PreferenceStoreInter
 		return null;
 	}
 
-	@Override
-	public <T> T getRealObject(String key, boolean crypt) {
-		return null;
-	}
-
 	@Override
 	public void clear() {
 
@@ -301,7 +296,7 @@ public class PreferenceStoreInterfaceDevNullImpl implements PreferenceStoreInter
 
 	@Override
 	public Set<String> getStringSet(String key, int defaultRes) {
-		return new HashSet<String>();
+		return new HashSet<>();
 	}
 
 	@Override
diff --git a/app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt b/app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt
index e4862a7e..362d282e 100644
--- a/app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt
@@ -21,8 +21,6 @@
 
 package ch.threema.app.tasks
 
-import androidx.work.OneTimeWorkRequest
-import androidx.work.WorkManager
 import ch.threema.app.ThreemaApplication
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.workers.ContactUpdateWorker
@@ -41,8 +39,7 @@ class ApplicationUpdateStepsTask(serviceManager: ServiceManager) : ActiveTask<Un
     override val type = "ApplicationUpdateStepsTask"
 
     override suspend fun invoke(handle: ActiveTaskCodec) {
-        val workRequest = OneTimeWorkRequest.Builder(ContactUpdateWorker::class.java).build()
-        WorkManager.getInstance(ThreemaApplication.getAppContext()).enqueue(workRequest)
+        ContactUpdateWorker.performOneTimeSync(ThreemaApplication.getAppContext())
 
         // Remove all sessions with contacts where the version is not known
         contactService.all.forEach {
diff --git a/app/src/main/java/ch/threema/app/tasks/DeleteDeviceGroupTask.kt b/app/src/main/java/ch/threema/app/tasks/DeleteDeviceGroupTask.kt
new file mode 100644
index 00000000..dbdd0ada
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/DeleteDeviceGroupTask.kt
@@ -0,0 +1,74 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.connection.data.DeviceId
+import ch.threema.domain.protocol.multidevice.MultiDeviceProperties
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+
+private val logger = LoggingUtil.getThreemaLogger("DeleteDeviceGroupTask")
+
+class DeleteDeviceGroupTask(
+    serviceManager: ServiceManager
+) : ActiveTask<Unit> {
+    override val type: String = "DeleteDeviceGroupTask"
+
+    private val multiDeviceManager: MultiDeviceManager by lazy { serviceManager.multiDeviceManager }
+    private val properties: MultiDeviceProperties by lazy { multiDeviceManager.propertiesProvider.get() }
+
+    override suspend fun invoke(handle: ActiveTaskCodec) {
+        // 1. Abort if md is not active
+        if (!multiDeviceManager.isMultiDeviceActive) {
+            logger.warn("Abort md device group deletion: md is not active")
+            return
+        }
+
+        // 2. Drop _all_ other devices from group
+        var linkedDevicesIds = getLinkedDevicesIds(handle)
+        while (linkedDevicesIds.isNotEmpty()) {
+            // Remove in a loop as _theoretically_ other devices could be linked in the meantime.
+            // Normally the loop should only be run once.
+            logger.debug("Drop {} linked device(s)", linkedDevicesIds.size)
+            linkedDevicesIds.forEach {
+                DropDeviceTask(it).invoke(handle)
+            }
+            linkedDevicesIds = getLinkedDevicesIds(handle)
+        }
+
+        // 3. Drop own device from group
+        logger.debug("Drop own device")
+        DropDeviceTask(properties.mediatorDeviceId).invoke(handle)
+    }
+
+    /**
+     * @return The [DeviceId]s of all linked devices _excluding_ the own device.
+     */
+    private suspend fun getLinkedDevicesIds(handle: ActiveTaskCodec): Set<DeviceId> {
+        return GetDevicesInfoTask().invoke(handle).augmentedDeviceInfo.keys
+            .filter { it != properties.mediatorDeviceId }
+            .toSet()
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/DeviceLinkingTask.kt b/app/src/main/java/ch/threema/app/tasks/DeviceLinkingTask.kt
new file mode 100644
index 00000000..d0d39abb
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/DeviceLinkingTask.kt
@@ -0,0 +1,297 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import android.content.Context
+import androidx.work.await
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.multidevice.linking.Completed
+import ch.threema.app.multidevice.linking.Connected
+import ch.threema.app.multidevice.linking.DeviceLinkingCancelledException
+import ch.threema.app.multidevice.linking.DeviceLinkingDataCollector
+import ch.threema.app.multidevice.linking.DeviceLinkingException
+import ch.threema.app.multidevice.linking.DeviceLinkingStatus
+import ch.threema.app.multidevice.linking.Failed
+import ch.threema.app.services.ContactsSyncAdapterService
+import ch.threema.app.services.PreferenceService
+import ch.threema.app.webclient.services.instance.DisconnectContext
+import ch.threema.app.workers.AutoDeleteWorker
+import ch.threema.app.workers.ContactUpdateWorker
+import ch.threema.app.workers.WorkSyncWorker
+import ch.threema.base.utils.Base64UrlSafe
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.toHexString
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
+import ch.threema.domain.protocol.rendezvous.RendezvousConnection
+import ch.threema.domain.protocol.rendezvous.DeviceJoinMessage
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TRANSACTION_TTL_MAX
+import ch.threema.domain.taskmanager.createTransaction
+import ch.threema.protobuf.d2d.MdD2D.TransactionScope.Scope
+import ch.threema.protobuf.url_payloads.DeviceGroupJoinRequestOrOffer
+import com.google.protobuf.InvalidProtocolBufferException
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.coroutineScope
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.MutableSharedFlow
+import kotlinx.coroutines.flow.transformWhile
+import kotlinx.coroutines.launch
+import okhttp3.OkHttpClient
+import java.io.IOException
+
+private val logger = LoggingUtil.getThreemaLogger("DeviceLinkingTask")
+
+private val supportedVersionRange = 0..0
+
+class DeviceLinkingTask(
+    private val deviceJoinOfferUri: String,
+    private val serviceManager: ServiceManager,
+    private val cancelledSignal: Deferred<Unit>
+) : ActiveTask<Result<Unit>> {
+    override val type: String = "DeviceLinkingTask"
+
+    private val preferenceService: PreferenceService by lazy { serviceManager.preferenceService }
+    private val multiDeviceManager: MultiDeviceManager by lazy { serviceManager.multiDeviceManager }
+    private val multiDeviceKeys: MultiDeviceKeys by lazy { multiDeviceManager.propertiesProvider.get().keys }
+    private val deviceLinkingDataCollector by lazy { DeviceLinkingDataCollector(serviceManager) }
+    private val okHttpClient: OkHttpClient by lazy { serviceManager.okHttpClient }
+
+    val deviceLinkingController = DeviceLinkingController()
+
+    override suspend fun invoke(handle: ActiveTaskCodec): Result<Unit> {
+        return coroutineScope {
+            val linkingResult = CompletableDeferred<Result<Unit>>()
+
+            val stateChangingProcesses = getStateChangingProcesses()
+            val context = serviceManager.context
+            val linkingJob = launch {
+                try {
+                    pauseStateChangingProcesses(context, stateChangingProcesses)
+                    linkingResult.complete(performLinking(handle))
+                } catch (e: Exception) {
+                    linkingResult.complete(Result.failure(e))
+                } finally {
+                    resumeStateChangingProcesses(context, stateChangingProcesses)
+                }
+            }
+
+            val cancelJob = launch {
+                cancelledSignal.await()
+                logger.warn("Linking has been cancelled")
+                linkingJob.cancel()
+                linkingResult.complete(Result.failure(DeviceLinkingCancelledException()))
+            }
+
+            try {
+                linkingResult.await()
+            } catch (e: Exception) {
+                linkingJob.cancel()
+                Result.failure(e)
+            } finally {
+                cancelJob.cancel()
+            }
+        }
+    }
+
+    private suspend fun pauseStateChangingProcesses(context: Context, processes: List<StateChangingProcess>) {
+        logger.info("Pause state changing processes")
+        processes.forEach {
+            logger.info("Pause '{}'", it.name)
+            it.pause.invoke(context)
+        }
+    }
+
+    private suspend fun resumeStateChangingProcesses(context: Context, processes: List<StateChangingProcess>) {
+        logger.info("Resume state changing processes")
+        processes.forEach {
+            if (it.resume != null) {
+                logger.info("Resume '{}'", it.name)
+                it.resume.invoke(context)
+            } else {
+                logger.info("Do not resume '{}'", it.name)
+            }
+        }
+    }
+
+    private suspend fun performLinking(handle: ActiveTaskCodec): Result<Unit> {
+        var connection: RendezvousConnection? = null
+        return try {
+            connection = createConnection()
+
+            deviceLinkingController.waitForRendezvousPathConfirmation(connection.rph)
+
+            handle.createTransaction(
+                multiDeviceKeys,
+                Scope.NEW_DEVICE_SYNC,
+                TRANSACTION_TTL_MAX,
+            ).execute {
+                transferEssentialData(connection)
+            }
+            connection.closedSignal.await()
+            Result.success(Unit)
+        } catch (e: Exception) {
+            connection?.close()
+            when (e) {
+                is DeviceLinkingException,
+                is IOException -> Result.failure(e)
+                else -> throw e
+            }
+        } finally {
+            connection?.close()
+        }
+    }
+
+    private suspend fun transferEssentialData(connection: RendezvousConnection) {
+        logger.info("Begin sending of essential data")
+        // 1. Send begin
+        connection.write(DeviceJoinMessage.Begin())
+
+        val essentialData = deviceLinkingDataCollector.collectData(multiDeviceKeys.dgk)
+        // 2. Send blob data
+        logger.debug("Send blob data")
+        essentialData.blobs.forEach {
+            connection.write(DeviceJoinMessage.BlobData(it))
+        }
+
+        // 3. Send Essential data
+        logger.debug("Send essential data")
+        connection.write(DeviceJoinMessage.EssentialData(essentialData.essentialData))
+
+        // 4. Wait for `Registered`
+        val inboundMessage = connection.read()
+        if (inboundMessage is DeviceJoinMessage.Registered) {
+            logger.info("Linking of new device completed")
+            deviceLinkingController.onCompleted()
+        } else {
+            throw DeviceLinkingException("Received unexpected message")
+        }
+    }
+
+    private fun parseDeviceJoinOfferUri(deviceJoinOfferUri: String): DeviceGroupJoinRequestOrOffer {
+        val parts = deviceJoinOfferUri.split("#")
+        if (parts.size != 2 && parts[0] != "threema://device-group/join") {
+            throw DeviceLinkingException("Invalid device join offer uri: $deviceJoinOfferUri")
+        }
+        val bytes = Base64UrlSafe.decode(parts[1])
+        return try {
+            DeviceGroupJoinRequestOrOffer.parseFrom(bytes)
+        } catch (e: InvalidProtocolBufferException) {
+            throw DeviceLinkingException("Could not decode device join offer", e)
+        }
+    }
+
+    private suspend fun createConnection(): RendezvousConnection {
+        logger.trace("Join with device join offer uri `{}`", deviceJoinOfferUri)
+        val offer = parseDeviceJoinOfferUri(deviceJoinOfferUri)
+        logger.trace("Parsed offer: {}", offer)
+
+        offer.version.number.let {
+            if (it !in supportedVersionRange) {
+                throw DeviceLinkingException("Unsupported offer version `$it`")
+            }
+        }
+
+        offer.variant.typeCase.let {
+            if (it != DeviceGroupJoinRequestOrOffer.Variant.TypeCase.REQUEST_TO_JOIN) {
+                throw DeviceLinkingException("Unsupported offer variant `$it`")
+            }
+        }
+
+        return RendezvousConnection.connect(okHttpClient, offer.rendezvousInit).also {
+            logger.debug("Connection created (rph={})", it.rph.toHexString())
+        }
+    }
+
+    private fun getStateChangingProcesses(): List<StateChangingProcess> {
+        return listOf(
+            StateChangingProcess("ContactSyncAdapter", { disableContactSyncAdapter() }, { enableContactSyncAdapter() }),
+            StateChangingProcess("AutoDeleteWorker", ::pauseAutoDeleteWorker, ::resumeAutoDeleteWorker),
+            StateChangingProcess("WorkSync", ::pauseWorkSync, ::resumeWorkSync),
+            StateChangingProcess("IdentityStatesSync", ::pauseIdentityStatesSync, ::resumeIdentityStatesSync),
+            // Webclient sessions are not resumed after linking
+            StateChangingProcess("WebClient", { pauseWebClientSessions() }, null),
+        )
+    }
+
+    private fun disableContactSyncAdapter() {
+        ContactsSyncAdapterService.disableSync()
+    }
+
+    private fun enableContactSyncAdapter() {
+        ContactsSyncAdapterService.enableSync()
+    }
+
+    private suspend fun pauseAutoDeleteWorker(context: Context) {
+        AutoDeleteWorker.cancelAutoDeleteAwait(context)
+    }
+
+    private fun resumeAutoDeleteWorker(context: Context) {
+        AutoDeleteWorker.scheduleAutoDelete(context)
+    }
+
+    private suspend fun pauseWorkSync(context: Context) {
+        WorkSyncWorker.cancelPeriodicWorkSyncAwait(context)
+    }
+
+    private fun resumeWorkSync(context: Context) {
+        WorkSyncWorker.schedulePeriodicWorkSync(context, preferenceService)
+    }
+
+    private suspend fun pauseIdentityStatesSync(context: Context) {
+        ContactUpdateWorker.cancelPeriodicSync(context).await()
+    }
+
+    private fun resumeIdentityStatesSync(context: Context) {
+        ContactUpdateWorker.schedulePeriodicSync(context, preferenceService)
+    }
+
+    private fun pauseWebClientSessions() {
+        serviceManager.webClientServiceManager.sessionService.stopAll(DisconnectContext.byUs(DisconnectContext.REASON_SESSION_STOPPED))
+    }
+}
+
+class DeviceLinkingController {
+    private val _linkingStatus = MutableSharedFlow<DeviceLinkingStatus>(1, 0)
+    val linkingStatus: Flow<DeviceLinkingStatus> = _linkingStatus.transformWhile {
+        emit(it)
+        when (it) {
+            is Completed, is Failed -> false
+            else -> true
+        }
+    }
+
+    suspend fun waitForRendezvousPathConfirmation(rph: ByteArray) {
+        val connectedState = Connected(rph)
+        _linkingStatus.emit(connectedState)
+        // Wait for the path to be confirmed in the ui (emoji verification)
+        connectedState.rendezvousPathConfirmedSignal.await()
+    }
+
+    suspend fun onCompleted() {
+        _linkingStatus.emit(Completed())
+    }
+}
+
+private data class StateChangingProcess(val name: String, val pause: suspend (Context) -> Unit, val resume: (suspend (Context) -> Unit)?)
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingD2mMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/DropDeviceTask.kt
similarity index 54%
rename from app/src/main/java/ch/threema/app/tasks/OutgoingD2mMessageTask.kt
rename to app/src/main/java/ch/threema/app/tasks/DropDeviceTask.kt
index 9049ccff..731871d1 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingD2mMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/DropDeviceTask.kt
@@ -21,34 +21,27 @@
 
 package ch.threema.app.tasks
 
-import ch.threema.app.managers.ServiceManager
 import ch.threema.domain.protocol.connection.data.DeviceId
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
 import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
 import ch.threema.domain.taskmanager.ActiveTask
 import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
+import ch.threema.domain.taskmanager.MessageFilterInstruction
 
-sealed class OutgoingD2mMessageTask : ActiveTask<Unit>, PersistableTask {
-    protected suspend fun sendD2mMessage(message: OutboundD2mMessage, handle: ActiveTaskCodec) {
-        handle.write(message)
-    }
-}
-
-class OutgoingDropDeviceTask(private val deviceId: DeviceId) : OutgoingD2mMessageTask() {
-    override val type: String = "OutgoingDropDeviceTask"
+class DropDeviceTask(private val deviceId: DeviceId) : ActiveTask<Unit> {
+    override val type: String = "DropDeviceTask"
 
     override suspend fun invoke(handle: ActiveTaskCodec) {
-        sendD2mMessage(OutboundD2mMessage.DropDevice(deviceId), handle)
-    }
-
-    override fun serialize(): SerializableTaskData =
-        OutgoingDropDeviceData(deviceId.id)
-
-    @Serializable
-    data class OutgoingDropDeviceData(private val deviceId: ULong) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingDropDeviceTask(DeviceId(deviceId))
+        handle.write(OutboundD2mMessage.DropDevice(deviceId))
+        handle.read {
+            when (it) {
+                is InboundD2mMessage.DropDeviceAck -> if (it.deviceId == deviceId) {
+                    MessageFilterInstruction.ACCEPT
+                } else {
+                    MessageFilterInstruction.BYPASS_OR_BACKLOG
+                }
+                else -> MessageFilterInstruction.BYPASS_OR_BACKLOG
+            }
+        }
     }
 }
diff --git a/app/src/main/java/ch/threema/app/tasks/GetDevicesInfoTask.kt b/app/src/main/java/ch/threema/app/tasks/GetDevicesInfoTask.kt
new file mode 100644
index 00000000..b4954cc5
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/GetDevicesInfoTask.kt
@@ -0,0 +1,42 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
+import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.MessageFilterInstruction
+
+class GetDevicesInfoTask : ActiveTask<InboundD2mMessage.DevicesInfo> {
+    override val type: String = "GetDevicesInfoTask"
+
+    override suspend fun invoke(handle: ActiveTaskCodec): InboundD2mMessage.DevicesInfo {
+        handle.write(OutboundD2mMessage.GetDevicesInfo())
+        return handle.read {
+            when (it) {
+                is InboundD2mMessage.DevicesInfo -> MessageFilterInstruction.ACCEPT
+                else -> MessageFilterInstruction.BYPASS_OR_BACKLOG
+            }
+        } as InboundD2mMessage.DevicesInfo
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt b/app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt
index a7a420b4..8fef8c91 100644
--- a/app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt
@@ -32,7 +32,7 @@ import ch.threema.domain.protocol.csp.coders.MessageBox
 import ch.threema.domain.taskmanager.ActiveTask
 import ch.threema.domain.taskmanager.ActiveTaskCodec
 import ch.threema.domain.taskmanager.NetworkException
-import ch.threema.domain.taskmanager.waitForServerAck
+import ch.threema.domain.taskmanager.awaitOutgoingMessageAck
 import ch.threema.localcrypto.MasterKey
 import ch.threema.storage.factories.GroupMessageModelFactory
 import ch.threema.storage.factories.MessageModelFactory
@@ -158,19 +158,18 @@ class MessageQueueMigrationTask(
         val recipientIdentity = messageBox.toIdentity
 
         // Wait until message has been sent
-        handle.waitForServerAck(messageId, recipientIdentity)
+        handle.awaitOutgoingMessageAck(messageId, recipientIdentity)
 
         // Update state if message model found for message
         updateMessageModel(messageId, recipientIdentity)
     }
 
     private fun updateMessageModel(messageId: MessageId, identity: String) {
-        val date = Date()
         val messageModels = getMatchingMessageModels(messageId, identity).filterNotNull()
         // We update the state for each message model that fits the message id and identity. Note
         // that for group messages, the message state is set to sent too early. Since this is only
         // needed for the migration to the task manager queue, this is acceptable.
-        messageModels.forEach { messageService.updateMessageState(it, MessageState.SENT, date) }
+        messageModels.forEach { messageService.updateOutgoingMessageState(it, MessageState.SENT, Date()) }
     }
 
     private fun getMatchingMessageModels(
diff --git a/app/src/main/java/ch/threema/app/tasks/OnFSFeatureMaskDowngradedTask.kt b/app/src/main/java/ch/threema/app/tasks/OnFSFeatureMaskDowngradedTask.kt
new file mode 100644
index 00000000..d94aee15
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/OnFSFeatureMaskDowngradedTask.kt
@@ -0,0 +1,157 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.services.ContactService
+import ch.threema.app.services.MessageService
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModel
+import ch.threema.domain.fs.DHSession
+import ch.threema.domain.models.Contact
+import ch.threema.domain.protocol.ThreemaFeature
+import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
+import ch.threema.domain.stores.DHSessionStoreException
+import ch.threema.domain.stores.DHSessionStoreInterface
+import ch.threema.domain.stores.IdentityStoreInterface
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.protobuf.csp.e2e.fs.Terminate
+import ch.threema.storage.models.data.status.ForwardSecurityStatusDataModel
+import kotlinx.serialization.Serializable
+
+private val logger = LoggingUtil.getThreemaLogger("OnFSFeatureMaskDowngradedTask")
+
+/**
+ * Performs the required steps if a contact does not support forward security anymore due to a
+ * change of its feature mask. This includes creating a status message in the conversation with that
+ * contact to warn the user that forward security has been disabled for this contact. This task also
+ * terminates all existing sessions with the contact by invoking [DeleteAndTerminateFSSessionsTask].
+ * <p>
+ * Note that the status message is only created if a forward security session currently exists.
+ * <p>
+ * Note that this task must only be scheduled if the feature mask of a contact is changed from a
+ * feature mask that indicates forward security support to a feature mask without forward
+ * security support.
+ *
+ * @param contactModel the affected contact
+ */
+class OnFSFeatureMaskDowngradedTask(
+    private val contactModel: ContactModel,
+    private val contactService: ContactService,
+    private val messageService: MessageService,
+    private val dhSessionStore: DHSessionStoreInterface,
+    private val identityStore: IdentityStoreInterface,
+    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
+) : ActiveTask<Unit>, PersistableTask {
+
+    override val type = "FSFeatureMaskDowngraded"
+
+    private val contactModelData by lazy { contactModel.data.value }
+
+    override suspend fun invoke(handle: ActiveTaskCodec) {
+        val data = contactModelData ?: return
+
+        if (ThreemaFeature.canForwardSecurity(data.featureMaskLong())) {
+            logger.warn("Forward security is supported by this contact")
+            return
+        }
+
+        if (hasForwardSecuritySession(handle)) {
+            terminateAllSessions(handle)
+            createForwardSecurityDowngradedStatus()
+        }
+    }
+
+    private fun hasForwardSecuritySession(handle: ActiveTaskCodec): Boolean {
+        // Get the best forward security session with that contact.
+        var fsSession: DHSession? = null
+        try {
+            fsSession = dhSessionStore.getBestDHSession(
+                identityStore.identity,
+                contactModel.identity,
+                handle,
+            )
+        } catch (exception: DHSessionStoreException) {
+            logger.error("Unable to determine best DH session", exception)
+        } catch (exception: NullPointerException) {
+            logger.error("Unable to determine best DH session", exception)
+        }
+
+        return fsSession != null
+    }
+
+    private suspend fun terminateAllSessions(handle: ActiveTaskCodec) {
+        val data = contactModelData ?: return
+
+        logger.info(
+            "Forward security feature has been downgraded for contact {}",
+            contactModel.identity
+        )
+
+        // Clear and terminate all sessions with that contact
+        DeleteAndTerminateFSSessionsTask(
+            forwardSecurityMessageProcessor,
+            Contact(data.identity, data.publicKey, data.verificationLevel),
+            Terminate.Cause.DISABLED_BY_REMOTE
+        ).invoke(handle)
+    }
+
+    private fun createForwardSecurityDowngradedStatus() {
+        val receiver = contactService.createReceiver(contactModel) ?: run {
+            logger.error("Contact message receiver is null")
+            return
+        }
+        messageService.createForwardSecurityStatus(
+            receiver,
+            ForwardSecurityStatusDataModel.ForwardSecurityStatusType.FORWARD_SECURITY_UNAVAILABLE_DOWNGRADE,
+            0,
+            null
+        )
+    }
+
+    override fun serialize(): SerializableTaskData =
+        OnFSFeatureMaskDowngradedData(contactModel.identity)
+
+    @Serializable
+    class OnFSFeatureMaskDowngradedData(
+        private val identity: String,
+    ) : SerializableTaskData {
+        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> {
+            val contactModel = serviceManager.modelRepositories.contacts.getByIdentity(identity)
+            if (contactModel == null) {
+                logger.warn("Contact with identity {} does not exist anymore", identity)
+                throw IllegalStateException("Can not create task for deleted contact")
+            }
+            return OnFSFeatureMaskDowngradedTask(
+                contactModel,
+                serviceManager.contactService,
+                serviceManager.messageService,
+                serviceManager.dhSessionStore,
+                serviceManager.identityStore,
+                serviceManager.forwardSecurityMessageProcessor,
+            )
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutboundD2mMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutboundD2mMessageTask.kt
new file mode 100644
index 00000000..fb00f1b6
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/OutboundD2mMessageTask.kt
@@ -0,0 +1,26 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.domain.taskmanager.ActiveTask
+
+interface OutboundD2mMessageTask<R> : ActiveTask<R>
diff --git a/app/src/main/java/ch/threema/app/tasks/OutboundIncomingContactMessageUpdateReadTask.kt b/app/src/main/java/ch/threema/app/tasks/OutboundIncomingContactMessageUpdateReadTask.kt
new file mode 100644
index 00000000..300716b6
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/OutboundIncomingContactMessageUpdateReadTask.kt
@@ -0,0 +1,81 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.getEncryptedIncomingContactMessageUpdateReadEnvelope
+import kotlinx.serialization.Serializable
+
+class OutboundIncomingContactMessageUpdateReadTask(
+    private val messageIds: Set<MessageId>,
+    private val timestamp: Long,
+    private val recipientIdentity: String,
+    serviceManager: ServiceManager,
+) : OutboundD2mMessageTask<Unit>, PersistableTask {
+    private val multiDeviceProperties by lazy { serviceManager.multiDeviceManager.propertiesProvider.get() }
+    private val deviceId by lazy { multiDeviceProperties.mediatorDeviceId }
+    private val multiDeviceKeys by lazy { multiDeviceProperties.keys }
+
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+
+    override val type: String = "OutboundIncomingContactMessageUpdateReadTask"
+
+    override suspend fun invoke(handle: ActiveTaskCodec) {
+        val encryptedEnvelopeResult = getEncryptedIncomingContactMessageUpdateReadEnvelope(
+            messageIds,
+            timestamp,
+            recipientIdentity,
+            deviceId,
+            multiDeviceKeys,
+        )
+        handle.reflectAndAwaitAck(
+            encryptedEnvelopeResult = encryptedEnvelopeResult,
+            storeD2dNonce = true,
+            nonceFactory = nonceFactory
+        )
+    }
+
+    override fun serialize(): SerializableTaskData = OutboundIncomingContactMessageUpdateReadData(
+        messageIds.map { it.messageId }.toSet(),
+        timestamp,
+        recipientIdentity,
+    )
+
+    @Serializable
+    data class OutboundIncomingContactMessageUpdateReadData(
+        private val messageIds: Set<ByteArray>,
+        private val timestamp: Long,
+        private val recipientIdentity: String,
+    ) : SerializableTaskData {
+        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+            OutboundIncomingContactMessageUpdateReadTask(
+                messageIds.map { MessageId(it) }.toSet(),
+                timestamp,
+                recipientIdentity,
+                serviceManager,
+            )
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutboundIncomingGroupMessageUpdateReadTask.kt b/app/src/main/java/ch/threema/app/tasks/OutboundIncomingGroupMessageUpdateReadTask.kt
new file mode 100644
index 00000000..035f287a
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/OutboundIncomingGroupMessageUpdateReadTask.kt
@@ -0,0 +1,87 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.getEncryptedIncomingGroupMessageUpdateReadEnvelope
+import kotlinx.serialization.Serializable
+
+class OutboundIncomingGroupMessageUpdateReadTask(
+    private val messageIds: Set<MessageId>,
+    private val timestamp: Long,
+    private val groupId: GroupId,
+    private val creatorIdentity: String,
+    serviceManager: ServiceManager,
+) : OutboundD2mMessageTask<Unit>, PersistableTask {
+    private val multiDeviceProperties by lazy { serviceManager.multiDeviceManager.propertiesProvider.get() }
+    private val deviceId by lazy { multiDeviceProperties.mediatorDeviceId }
+    private val multiDeviceKeys by lazy { multiDeviceProperties.keys }
+
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+
+    override val type: String = "OutboundIncomingGroupMessageUpdateReadTask"
+
+    override suspend fun invoke(handle: ActiveTaskCodec) {
+        val encryptedEnvelopeResult = getEncryptedIncomingGroupMessageUpdateReadEnvelope(
+            messageIds,
+            timestamp,
+            creatorIdentity,
+            groupId,
+            deviceId,
+            multiDeviceKeys,
+        )
+        handle.reflectAndAwaitAck(
+            encryptedEnvelopeResult = encryptedEnvelopeResult,
+            storeD2dNonce = true,
+            nonceFactory = nonceFactory
+        )
+    }
+
+    override fun serialize() = OutboundIncomingGroupMessageUpdateReadData(
+        messageIds.map { it.messageId }.toSet(),
+        timestamp,
+        groupId.groupId,
+        creatorIdentity,
+    )
+
+    @Serializable
+    class OutboundIncomingGroupMessageUpdateReadData(
+        private val messageIds: Set<ByteArray>,
+        private val timestamp: Long,
+        private val groupId: ByteArray,
+        private val creatorIdentity: String,
+    ) : SerializableTaskData {
+        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+            OutboundIncomingGroupMessageUpdateReadTask(
+                messageIds.map { MessageId(it) }.toSet(),
+                timestamp,
+                GroupId(groupId),
+                creatorIdentity,
+                serviceManager,
+            )
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt
index 99725453..d0fbc9b3 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt
@@ -49,11 +49,8 @@ class OutgoingContactDeleteMessageTask(
         val deleteMessage = DeleteMessage(
             DeleteMessageData(messageId = MessageId.fromString(message.apiMessageId).messageIdLong)
         )
-        deleteMessage.toIdentity = toIdentity
-        deleteMessage.date = deletedAt
-        deleteMessage.messageId = messageId
 
-        sendContactMessage(deleteMessage, null, handle)
+        sendContactMessage(deleteMessage, null, toIdentity, messageId, deletedAt, handle)
     }
 
     override fun serialize(): SerializableTaskData =
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt
index bb292de2..aba1bdcd 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt
@@ -43,12 +43,9 @@ class OutgoingContactDeliveryReceiptMessageTask(
         val message = DeliveryReceiptMessage().also {
             it.receiptType = receiptType
             it.receiptMessageIds = messageIds
-            it.toIdentity = toIdentity
-            it.messageId = MessageId()
-            it.date = Date(date)
         }
 
-        sendContactMessage(message, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(date), handle)
     }
 
     override fun serialize(): SerializableTaskData = OutgoingDeliveryReceiptMessageData(
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt
index 22be17c3..1dce2c2d 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt
@@ -53,11 +53,8 @@ class OutgoingContactEditMessageTask(
                 text = editedText
             )
         )
-        editMessage.toIdentity = toIdentity
-        editMessage.date = editedAt
-        editMessage.messageId = messageId
 
-        sendContactMessage(editMessage, null, handle)
+        sendContactMessage(editMessage, null, toIdentity, messageId, editedAt, handle)
     }
 
     override fun serialize(): SerializableTaskData = OutgoingContactEditMessageData(
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt
index ab7b0ba8..dbdfda70 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt
@@ -44,8 +44,8 @@ class OutgoingContactRequestProfilePictureTask(
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         // Get contact and check that sending a profile picture request is necessary
-        val contact = contactService.getByIdentity(toIdentity)
-        if (contact == null) {
+        val contactModel = contactModelRepository.getByIdentity(toIdentity)
+        if (contactModel == null) {
             logger.warn(
                 "Contact {} is unknown, even though a profile picture request should be sent",
                 toIdentity
@@ -53,7 +53,16 @@ class OutgoingContactRequestProfilePictureTask(
             return
         }
 
-        if (!contact.isRestored) {
+        val contactModelData = contactModel.data.value
+        if (contactModelData == null) {
+            logger.warn(
+                "Contact model data for identity {} is null, even though a profile picture request should be sent",
+                toIdentity,
+            )
+            return
+        }
+
+        if (!contactModelData.isRestored) {
             logger.warn(
                 "Contact {} is not restored; sending profile picture request is skipped",
                 toIdentity
@@ -64,8 +73,7 @@ class OutgoingContactRequestProfilePictureTask(
         // Send the profile picture request message
         sendRequestProfilePictureMessage(toIdentity, handle)
 
-        contact.setIsRestored(false)
-        contactService.save(contact)
+        contactModel.setIsRestored(false)
     }
 
     override fun serialize() = OutgoingContactRequestProfilePictureData(toIdentity)
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt
index 707fb7a1..4da39022 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt
@@ -23,9 +23,10 @@ package ch.threema.app.tasks
 
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.filterValid
-import ch.threema.app.utils.sendMessageToReceivers
-import ch.threema.app.utils.toKnownContactModels
+import ch.threema.app.utils.OutgoingCspMessageHandle
+import ch.threema.app.utils.OutgoingCspMessageServices
+import ch.threema.app.utils.runBundledMessagesSendSteps
+import ch.threema.app.utils.toBasicContacts
 import ch.threema.domain.models.GroupId
 import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
@@ -34,8 +35,9 @@ import java.util.Date
 
 abstract class OutgoingCspGroupControlMessageTask(serviceManager: ServiceManager) :
     OutgoingCspMessageTask(serviceManager) {
-    private val taskCreator by lazy { serviceManager.taskCreator }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
     private val blockedContactsService by lazy { serviceManager.blockedContactsService }
+    private val apiConnector by lazy { serviceManager.apiConnector }
 
     protected abstract val messageId: MessageId
     protected abstract val creatorIdentity: String
@@ -45,28 +47,36 @@ abstract class OutgoingCspGroupControlMessageTask(serviceManager: ServiceManager
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         val recipients = recipientIdentities
-            .toSet()
-            .toKnownContactModels(contactService)
-            .filterValid()
+            .toBasicContacts(contactModelRepository, contactStore, apiConnector)
             .toSet()
 
         val messageCreator = OutgoingCspGroupMessageCreator(
             messageId,
+            date,
             groupId,
-            creatorIdentity
+            creatorIdentity,
         ) { createGroupMessage() }
 
-        // Note that the given recipients may no longer be part of the group. Therefore we must use
-        // sendMessageToReceivers instead of sendGroupMessage.
-        handle.sendMessageToReceivers(
-            messageCreator,
+        val outgoingCspMessageHandle = OutgoingCspMessageHandle(
             recipients,
-            forwardSecurityMessageProcessor,
-            identityStore,
-            contactStore,
-            nonceFactory,
-            blockedContactsService,
-            taskCreator
+            messageCreator,
+        )
+
+        handle.runBundledMessagesSendSteps(
+            outgoingCspMessageHandle,
+            OutgoingCspMessageServices(
+                forwardSecurityMessageProcessor,
+                identityStore,
+                userService,
+                contactStore,
+                contactService,
+                contactModelRepository,
+                groupService,
+                nonceFactory,
+                blockedContactsService,
+                preferenceService,
+                multiDeviceManager
+            )
         )
     }
 
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt
index 4167f6d5..36f8c808 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt
@@ -24,15 +24,14 @@ package ch.threema.app.tasks
 import ch.threema.app.listeners.MessageListener
 import ch.threema.app.managers.ListenerManager
 import ch.threema.app.managers.ServiceManager
-import ch.threema.app.messagereceiver.MessageReceiver.MessageReceiverType
 import ch.threema.app.messagereceiver.MessageReceiver
+import ch.threema.app.messagereceiver.MessageReceiver.MessageReceiverType
 import ch.threema.app.utils.OutgoingCspContactMessageCreator
 import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.filterBroadcastIdentity
-import ch.threema.app.utils.filterValid
-import ch.threema.app.utils.sendContactMessage
-import ch.threema.app.utils.sendGroupMessage
-import ch.threema.app.utils.toKnownContactModels
+import ch.threema.app.utils.OutgoingCspMessageHandle
+import ch.threema.app.utils.OutgoingCspMessageServices.Companion.getOutgoingCspMessageServices
+import ch.threema.app.utils.removeGroupCreatorIfRequired
+import ch.threema.app.utils.runBundledMessagesSendSteps
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.base.utils.Utils
 import ch.threema.domain.models.MessageId
@@ -54,9 +53,12 @@ import java.util.Date
 
 private val logger = LoggingUtil.getThreemaLogger("OutgoingCspMessageTask")
 
-sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
+sealed class OutgoingCspMessageTask(private val serviceManager: ServiceManager) :
     ActiveTask<Unit>, PersistableTask {
-    private val myIdentity by lazy { serviceManager.userService.identity }
+    protected val userService by lazy { serviceManager.userService }
+    private val myIdentity by lazy { userService.identity }
+    protected val contactModelRepository by lazy { serviceManager.modelRepositories.contacts }
+    private val groupModelRepository by lazy { serviceManager.modelRepositories.groups }
     protected val contactService by lazy { serviceManager.contactService }
     protected val groupService by lazy { serviceManager.groupService }
     protected val contactStore by lazy { serviceManager.contactStore }
@@ -64,12 +66,13 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
     protected val nonceFactory by lazy { serviceManager.nonceFactory }
     protected val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
     protected val messageService by lazy { serviceManager.messageService }
-    private val rejectedGroupMessageFactory by lazy { serviceManager.databaseServiceNew.rejectedGroupMessageFactory }
+    private val databaseService by lazy { serviceManager.databaseServiceNew }
+    private val rejectedGroupMessageFactory by lazy { databaseService.rejectedGroupMessageFactory }
 
     // It is important that the task creator is loaded lazily, as the task archiver may instantiate
     // this class before the connection is initialized (which is used for the task creator).
     private val taskCreator by lazy { serviceManager.taskCreator }
-    private val blockedContactsService by lazy { serviceManager.blockedContactsService }
+    protected val preferenceService by lazy { serviceManager.preferenceService }
 
     final override suspend fun invoke(handle: ActiveTaskCodec) {
         suspend {
@@ -101,9 +104,16 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
 
     /**
      * Encapsulate and send the given message. Note that the message must be ready to be sent. This
-     * includes having the correct flags, from and to identities as well as a message id. If there
-     * is a message model to this message, it should also be passed to this method, so that it gets
-     * updated.
+     * must include the message flags that should be used. Note that the following fields should not
+     * be set as they will get overridden:
+     *
+     * - [AbstractMessage.toIdentity]
+     * - [AbstractMessage.fromIdentity]
+     * - [AbstractMessage.messageId]
+     * - [AbstractMessage.date]
+     *
+     * If there is a message model to this message, it should also be passed to this method, so that
+     * it gets updated.
      *
      * Note that there must exists a contact model of the receiver. Otherwise, the message cannot be
      * sent. In this case the message model state is set to [MessageState.SENDFAILED] (if provided)
@@ -112,16 +122,19 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
     suspend fun sendContactMessage(
         message: AbstractMessage,
         messageModel: MessageModel?,
+        toIdentity: String,
+        messageId: MessageId,
+        createdAt: Date,
         handle: ActiveTaskCodec,
     ) {
-        val recipient = contactService.getByIdentity(message.toIdentity)
-        if (recipient == null) {
+        val contactModelData = contactModelRepository.getByIdentity(toIdentity)?.data?.value
+        if (contactModelData == null) {
             logger.error(
-                "Could not send message to {} as the contact model is null",
-                message.toIdentity
+                "Could not send message to {} as the contact model data is null",
+                toIdentity
             )
             messageModel?.let {
-                messageService.updateMessageState(
+                messageService.updateOutgoingMessageState(
                     it,
                     MessageState.SENDFAILED,
                     Date()
@@ -130,45 +143,54 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
             throw IllegalStateException("Could not send message as the receiver model is unknown")
         }
 
-        message.date = messageModel?.createdAt ?: message.date
-
-        val sentMessageContainer = suspend {
-            handle.sendContactMessage(
-                OutgoingCspContactMessageCreator(message.messageId) { message },
-                recipient,
-                forwardSecurityMessageProcessor,
-                identityStore,
-                contactStore,
-                nonceFactory,
-                blockedContactsService,
-                taskCreator
-            )
-        }.catchExceptNetworkException { e: BadDHStateException ->
+        val createMessage = OutgoingCspContactMessageCreator(
+            messageId,
+            createdAt,
+            toIdentity,
+        ) { message }
+
+        val markAsSent = { sentAt: ULong ->
             if (messageModel != null) {
-                messageService.updateMessageState(messageModel, MessageState.SENDFAILED, Date())
+                // Update the message state for the outgoing message
+                messageService.updateOutgoingMessageState(
+                    messageModel,
+                    MessageState.SENT,
+                    Date(sentAt.toLong())
+                )
             }
-            throw e
         }
 
-        if (messageModel != null) {
-            if (sentMessageContainer != null) {
-                // Update the message state for the outgoing message
-                val sentDate = Date(sentMessageContainer.sentTimestamp.toLong())
-                messageService.updateMessageState(messageModel, MessageState.SENT, sentDate)
-
-                // Set forward security mode
-                messageModel.forwardSecurityMode = sentMessageContainer.forwardSecurityMode
-            } else {
-                // In this case the message was not sent because the recipient is blocked. This
-                // should never happen as sending a message that corresponds to a message model
-                // should be prevented by the UI. If the user sends a message and then blocks the
-                // recipient, the message may end in this state if the message could not be sent in
-                // the meanwhile.
-                messageService.updateMessageState(messageModel, MessageState.SENDFAILED, Date())
+        val updateFsState = { stateMap: Map<String, ForwardSecurityMode> ->
+            if (messageModel != null) {
+                val forwardSecurityMode = stateMap[toIdentity]
+                if (forwardSecurityMode == null) {
+                    logger.error("No forward security mode available")
+                } else {
+                    messageModel.forwardSecurityMode = forwardSecurityMode
+                    messageService.save(messageModel)
+                }
             }
+        }
 
-            // Save the updated message model
-            messageService.save(messageModel)
+        suspend {
+            handle.runBundledMessagesSendSteps(
+                OutgoingCspMessageHandle(
+                    contactModelData.toBasicContact(),
+                    createMessage,
+                    markAsSent,
+                    updateFsState,
+                ),
+                serviceManager.getOutgoingCspMessageServices(),
+            )
+        }.catchExceptNetworkException { e: BadDHStateException ->
+            if (messageModel != null) {
+                messageService.updateOutgoingMessageState(
+                    messageModel,
+                    MessageState.SENDFAILED,
+                    Date()
+                )
+            }
+            throw e
         }
     }
 
@@ -176,6 +198,19 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
      * Send the group message to the recipients following the _Common Send Steps_. The message is
      * only sent to those recipients that are still part of the group.
      *
+     * Note that the message created by [createAbstractMessage] must be ready to be sent. This must
+     * include the message flags that should be used. Note that the following fields should not be
+     * set as they will get overridden:
+     *
+     * - [AbstractMessage.toIdentity]
+     * - [AbstractMessage.fromIdentity]
+     * - [AbstractMessage.messageId]
+     * - [AbstractMessage.date]
+     * - [AbstractGroupMessage.apiGroupId]
+     * - [AbstractGroupMessage.groupCreator]
+     *
+     * Each invocation of [createAbstractMessage] must return a new instance of the message.
+     *
      * Note that the message is only sent to valid members and if the member is not blocked (except
      * the message should be exempted from blocking). If there is no contact model for a member, the
      * message will not be sent to this member.
@@ -184,6 +219,7 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
         group: GroupModel,
         recipients: Collection<String>,
         messageModel: GroupMessageModel?,
+        createdAt: Date,
         messageId: MessageId,
         createAbstractMessage: () -> AbstractGroupMessage,
         handle: ActiveTaskCodec,
@@ -195,107 +231,108 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
 
         // Get the known contacts
         val finalRecipients = recipients
-            .toKnownContactModels(contactService)
-            .filterValid()
-            .filterBroadcastIdentity(group)
+            .mapNotNull { contactModelRepository.getByIdentity(it) }
+            .removeGroupCreatorIfRequired(group)
+            .mapNotNull { it.data.value }
+            .map { it.toBasicContact() }
             .toSet()
 
-        // Create and send the messages for all recipients
-        val sentMessageContainers = suspend {
-            handle.sendGroupMessage(
-                OutgoingCspGroupMessageCreator(messageId, group) { createAbstractMessage() },
-                finalRecipients,
-                group,
-                forwardSecurityMessageProcessor,
-                identityStore,
-                contactStore,
-                nonceFactory,
-                groupService,
-                blockedContactsService,
-                taskCreator
-            )
-        }.catchExceptNetworkException { e: BadDHStateException ->
-            if (messageModel != null) {
-                messageService.updateMessageState(messageModel, MessageState.SENDFAILED, Date())
-            }
-            throw e
-        }
+        val messageCreator = OutgoingCspGroupMessageCreator(
+            messageId,
+            createdAt,
+            group,
+            createAbstractMessage,
+        )
 
-        if (sentMessageContainers == null) {
-            // If the message has not been sent (sentMessageContainers is null), then update the
-            // message state (if available) and return. Note that this only happens, if the user is
-            // not a member of the group.
+        val markAsSent = { sentAt: ULong ->
             if (messageModel != null) {
-                // Note that this should be prevented by the UI, but may happen with some bad timing
-                messageModel.state = MessageState.SENDFAILED
+                // Update sent timestamp
+                val sentDate = Date(sentAt.toLong())
+
+                // Note that we set the postedAt directly because the new state could be
+                // FS_KEY_MISMATCH and then MessageService#updateOutgoingMessageState wouldn't set
+                // this timestamp.
+                messageModel.postedAt = sentDate
+                messageModel.modifiedAt = sentDate
+
                 messageService.save(messageModel)
             }
-
-            return
         }
 
-        sentMessageContainers.map { it.recipient.identity }.forEach {
-            rejectedGroupMessageFactory.removeMessageReject(messageId, it, group)
-        }
+        val updateFsState = { fsStateMap: Map<String, ForwardSecurityMode> ->
+            fsStateMap.keys.forEach {
+                rejectedGroupMessageFactory.removeMessageReject(messageId, it, group)
+            }
 
-        // Update the message state as all messages have been sent now
-        if (messageModel != null) {
-            // If there is no recipient (notes group), then we set the message state directly to
-            // read, otherwise sent. If there are (still) some rejected identities, we set the state
-            // to fs key mismatch, so that the message can be sent again to those. Note that we use
-            // the fs key mismatch state to represent the 're-send requested'-mark.
-            val state = when {
-                recipients.isEmpty() -> MessageState.READ
+            // Update the message state as all messages have been sent now
+            if (messageModel != null) {
+                // If there is no recipient (notes group), then we set the message state directly to
+                // read, otherwise sent. If there are (still) some rejected identities, we set the state
+                // to fs key mismatch, so that the message can be sent again to those. Note that we use
+                // the fs key mismatch state to represent the 're-send requested'-mark.
+                val state = when {
+                    recipients.isEmpty() -> MessageState.READ
 
-                rejectedGroupMessageFactory.getMessageRejects(messageId, group)
-                    .isNotEmpty() -> MessageState.FS_KEY_MISMATCH
+                    rejectedGroupMessageFactory.getMessageRejects(messageId, group)
+                        .isNotEmpty() -> MessageState.FS_KEY_MISMATCH
 
-                else -> MessageState.SENT
-            }
-            messageModel.state = state
-
-            // Update sent timestamp
-            val sentDate = if (sentMessageContainers.isNotEmpty()) {
-                // The message has been sent to at least someone
-                Date(sentMessageContainers.first().sentTimestamp.toLong())
-            } else {
-                // The message wasn't sent to anybody. This can happen in notes groups.
-                // TODO(ANDR-2705): When reflecting a message in a notes group, we should still be
-                // able to get the timestamp (when it has been reflected)
-                Date()
-            }
-            messageModel.postedAt = sentDate
-            messageModel.modifiedAt = sentDate
-
-            // Update forward security mode
-            val forwardSecurityMode =
-                when (sentMessageContainers.count { it.forwardSecurityMode != ForwardSecurityMode.NONE }) {
-                    0 -> ForwardSecurityMode.NONE
-                    sentMessageContainers.size -> ForwardSecurityMode.ALL
-                    else -> ForwardSecurityMode.PARTIAL
+                    else -> MessageState.SENT
                 }
-            if (messageModel.forwardSecurityMode == null) {
-                // If the forward security mode is null, it is the first time we send this message.
-                // Therefore we can set the mode directly to the current mode.
-                messageModel.forwardSecurityMode = forwardSecurityMode
-            } else {
-                // If the previous forward security mode is already set, this means this has been a
-                // resend of the message that only reached a subset of the group members. Therefore
-                // we follow a best effort downgrade procedure:
-                if (forwardSecurityMode == ForwardSecurityMode.PARTIAL || forwardSecurityMode == ForwardSecurityMode.NONE) {
-                    // If there is a re-sent message without forward security, we set the mode to
-                    // partial, as some may have received the message with forward security in an
-                    // earlier attempt.
-                    messageModel.forwardSecurityMode = ForwardSecurityMode.PARTIAL
+                // Note that we set the state directly (without using MessageService#updateOutgoingMessageState)
+                // because we need to modify the postedAt timestamp also when the state is FS_KEY_MISMATCH.
+                messageModel.state = state
+
+                // Update forward security mode
+                val forwardSecurityMode =
+                    when (fsStateMap.count { it.value != ForwardSecurityMode.NONE }) {
+                        0 -> ForwardSecurityMode.NONE
+                        fsStateMap.size -> ForwardSecurityMode.ALL
+                        else -> ForwardSecurityMode.PARTIAL
+                    }
+                if (messageModel.forwardSecurityMode == null) {
+                    // If the forward security mode is null, it is the first time we send this message.
+                    // Therefore we can set the mode directly to the current mode.
+                    messageModel.forwardSecurityMode = forwardSecurityMode
+                } else {
+                    // If the previous forward security mode is already set, this means this has been a
+                    // resend of the message that only reached a subset of the group members. Therefore
+                    // we follow a best effort downgrade procedure:
+                    if (forwardSecurityMode == ForwardSecurityMode.PARTIAL || forwardSecurityMode == ForwardSecurityMode.NONE) {
+                        // If there is a re-sent message without forward security, we set the mode to
+                        // partial, as some may have received the message with forward security in an
+                        // earlier attempt.
+                        messageModel.forwardSecurityMode = ForwardSecurityMode.PARTIAL
+                    }
                 }
-            }
 
-            messageService.save(messageModel)
+                messageService.save(messageModel)
 
-            // Trigger listener TODO(ANDR-2705): Check updated version of MessageService#updateMessageState
-            ListenerManager.messageListeners.handle { listener: MessageListener ->
-                listener.onModified(listOf(messageModel))
+                // Trigger listener
+                ListenerManager.messageListeners.handle { listener: MessageListener ->
+                    listener.onModified(listOf(messageModel))
+                }
+            }
+        }
+
+        suspend {
+            handle.runBundledMessagesSendSteps(
+                OutgoingCspMessageHandle(
+                    finalRecipients,
+                    messageCreator,
+                    markAsSent,
+                    updateFsState,
+                ),
+                serviceManager.getOutgoingCspMessageServices(),
+            )
+        }.catchExceptNetworkException { e: BadDHStateException ->
+            if (messageModel != null) {
+                messageService.updateOutgoingMessageState(
+                    messageModel,
+                    MessageState.SENDFAILED,
+                    Date()
+                )
             }
+            throw e
         }
 
         groupService.setIsArchived(group, false)
@@ -322,7 +359,7 @@ sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
      */
     protected fun getMessageModel(
         @MessageReceiverType receiverType: Int,
-        messageModelId: Int
+        messageModelId: Int,
     ): AbstractMessageModel? {
         return when (receiverType) {
             MessageReceiver.Type_CONTACT -> getContactMessageModel(messageModelId)
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt
index 9bd86a61..7a73c080 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt
@@ -47,6 +47,10 @@ class OutgoingFileMessageTask(
     serviceManager: ServiceManager,
 ) : OutgoingCspMessageTask(serviceManager) {
 
+    private val myIdentity by lazy { serviceManager.userService.identity }
+
+    private val isMultiDeviceActive by lazy { serviceManager.multiDeviceManager.isMultiDeviceActive }
+
     override val type: String = "OutgoingFileMessageTask"
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
@@ -66,14 +70,23 @@ class OutgoingFileMessageTask(
 
         val fileDataModel = messageModel.fileData
 
+        val apiMessageId = ensureMessageId(messageModel)
+
         // Create the message
         val message = FileMessage().apply {
-            data = fileDataModel.toFileData(thumbnailBlobId, messageModel)
+            fileData = fileDataModel.toFileData(thumbnailBlobId, messageModel)
             toIdentity = messageModel.identity
-            messageId = ensureMessageId(messageModel)
+            messageId = apiMessageId
         }
 
-        sendContactMessage(message, messageModel, handle)
+        sendContactMessage(
+            message,
+            messageModel,
+            messageModel.identity,
+            apiMessageId,
+            messageModel.createdAt,
+            handle
+        )
     }
 
     private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
@@ -88,13 +101,14 @@ class OutgoingFileMessageTask(
             group,
             recipientIdentities,
             messageModel,
+            messageModel.createdAt,
             ensureMessageId(messageModel),
             {
                 GroupFileMessage().apply {
-                    data = fileDataModel.toFileData(thumbnailBlobId, messageModel)
+                    fileData = fileDataModel.toFileData(thumbnailBlobId, messageModel)
                 }
             },
-            handle
+            handle,
         )
     }
 
@@ -103,16 +117,22 @@ class OutgoingFileMessageTask(
         messageModel: AbstractMessageModel,
     ): FileData {
 
-        // Validate that the blob id has the correct length
-        if (blobId == null || blobId.size != ProtocolDefines.BLOB_ID_LEN) {
-            logger.error("Invalid blob id of length {}", blobId?.size)
-            throw IllegalStateException("Invalid blob id")
-        }
-
-        // Validate that the encryption key has the correct length
-        if (encryptionKey == null || encryptionKey.size != ProtocolDefines.BLOB_KEY_LEN) {
-            logger.error("Invalid encryption key of length {}", encryptionKey?.size)
-            throw IllegalStateException("Invalid blob encryption key")
+        // In case there are recipients or multi device is active, we need a blob id and an
+        // encryption key. Otherwise the message will be invalid and cannot be sent. In case there
+        // is no recipient and multi device is not active, the message is sent in a notes group
+        // where we do not upload the blob.
+        if (recipientIdentities.minus(myIdentity).isNotEmpty() || isMultiDeviceActive) {
+            // Validate that the blob id has the correct length
+            if (blobId == null || blobId.size != ProtocolDefines.BLOB_ID_LEN) {
+                logger.error("Invalid blob id of length {}", blobId?.size)
+                throw IllegalStateException("Invalid blob id")
+            }
+
+            // Validate that the encryption key has the correct length
+            if (encryptionKey == null || encryptionKey.size != ProtocolDefines.BLOB_KEY_LEN) {
+                logger.error("Invalid encryption key of length {}", encryptionKey?.size)
+                throw IllegalStateException("Invalid blob encryption key")
+            }
         }
 
         return FileData().also {
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt
index ed7adea4..50c618a6 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt
@@ -55,20 +55,17 @@ class OutgoingGroupDeleteMessageTask(
             group,
             recipientIdentities,
             null,
+            deletedAt,
             messageId,
-            createAbstractMessage =  { createDeleteMessage(
-                editedMessageIdLong,
-                deletedAt
-            ) },
+            createAbstractMessage =  { createDeleteMessage(editedMessageIdLong) },
             handle
         )
     }
 
-    private fun createDeleteMessage(messageId: Long, date: Date) : GroupDeleteMessage {
+    private fun createDeleteMessage(messageId: Long) : GroupDeleteMessage {
         val deleteMessage = GroupDeleteMessage(
             DeleteMessageData(messageId = messageId)
         )
-        deleteMessage.date = date
         return deleteMessage
     }
 
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt
index 6ca6f83a..876d0ee0 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt
@@ -29,6 +29,7 @@ import ch.threema.domain.taskmanager.ActiveTaskCodec
 import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
 import kotlinx.serialization.Serializable
+import java.util.Date
 
 private val logger = LoggingUtil.getThreemaLogger("OutgoingGroupDeliverReceiptMessageTask")
 
@@ -59,6 +60,7 @@ class OutgoingGroupDeliveryReceiptMessageTask(
             group,
             recipientIdentities,
             null,
+            Date(),
             messageId,
             {
                 GroupDeliveryReceiptMessage().also {
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt
index 5f07a1bf..fd2db55a 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt
@@ -50,28 +50,25 @@ class OutgoingGroupEditMessageTask(
         val group = groupService.getById(message.groupId)
             ?: throw ThreemaException("No group model found for groupId=${message.groupId}")
 
-        val editedMessageId = MessageId.fromString(message.apiMessageId).messageIdLong
+        val editedMessageIdLong = MessageId.fromString(message.apiMessageId).messageIdLong
 
         sendGroupMessage(
-                group,
-                groupService.getGroupIdentities(group).toSet(),
-                null,
-                messageId,
-                createAbstractMessage =  { createEditMessage(editedMessageId, editedAt) },
-                handle
+            group,
+            groupService.getGroupIdentities(group).toSet(),
+            null,
+            editedAt,
+            messageId,
+            createAbstractMessage = { createEditMessage(editedMessageIdLong) },
+            handle
         )
     }
 
-    private fun createEditMessage(messageId: Long, date: Date): GroupEditMessage {
-        val editMessage = GroupEditMessage(
-            EditMessageData(
-                messageId = messageId,
-                text = editedText
-            )
+    private fun createEditMessage(messageId: Long) = GroupEditMessage(
+        EditMessageData(
+            messageId = messageId,
+            text = editedText
         )
-        editMessage.date = date
-        return editMessage
-    }
+    )
 
     override fun serialize(): SerializableTaskData = OutgoingGroupEditMessageData(
         messageModelId,
@@ -87,7 +84,7 @@ class OutgoingGroupEditMessageTask(
         private val messageId: ByteArray,
         private val editedText: String,
         private val editedAt: Long,
-        private val recipientIdentities: Set<String>
+        private val recipientIdentities: Set<String>,
     ) : SerializableTaskData {
         override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
             OutgoingGroupEditMessageTask(
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt
index eeed8530..0aa2a722 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt
@@ -46,7 +46,6 @@ class OutgoingGroupProfilePictureTask(
     private val serviceManager: ServiceManager,
 ) : OutgoingCspMessageTask(serviceManager) {
     private val messageId by lazy { messageId ?: MessageId() }
-    private val userService by lazy { serviceManager.userService }
     private val receiverIdentities by lazy { receiverIdentities - userService.identity }
     private val fileService by lazy { serviceManager.fileService }
 
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt
index a4b51f13..b187983e 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt
@@ -28,11 +28,13 @@ import ch.threema.app.utils.ConfigUtils
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.GroupId
 import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.blob.BlobScope
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
 import ch.threema.domain.protocol.csp.messages.GroupSetProfilePictureMessage
 import com.neilalexander.jnacl.NaCl
 import java.io.FileNotFoundException
+import java.io.IOException
 import java.security.SecureRandom
 
 private val logger = LoggingUtil.getThreemaLogger("OutgoingGroupSetProfilePictureTask")
@@ -44,7 +46,7 @@ class OutgoingGroupSetProfilePictureTask(
     private val groupPhoto: Bitmap,
     messageId: MessageId?,
     serviceManager: ServiceManager,
-): OutgoingCspGroupControlMessageTask(serviceManager) {
+) : OutgoingCspGroupControlMessageTask(serviceManager) {
     private val apiService by lazy { serviceManager.apiService }
     private val groupPhotoUploadResult by lazy { tryUploadingGroupPhoto(groupPhoto) }
 
@@ -92,10 +94,21 @@ class OutgoingGroupSetProfilePictureTask(
             encryptionKey,
             ProtocolDefines.GROUP_PHOTO_NONCE
         )
-        val blobUploader = apiService.createUploader(encryptedData)
-        val blobId = blobUploader.upload()
+        val blobUploader = apiService.createUploader(
+            /* data = */ encryptedData,
+            /* shouldPersist = */ false,
+            /* scope = */ BlobScope.Public
+        )
+        val blobId: ByteArray? = blobUploader.upload()
         val size = encryptedData.size
 
+        if (blobId == null) {
+            // This should never happen because the blob uploader only returns null when
+            // it's explicitly cancelled. If the upload request fails for any other reason,
+            // the exception is thrown directly from the uploader
+            throw IOException("failed to upload blob")
+        }
+
         return GroupPhotoUploadResult(blobId, encryptionKey, size)
     }
 
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt
index 85c82510..5d191a6f 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt
@@ -24,8 +24,10 @@ package ch.threema.app.tasks
 import android.text.format.DateUtils
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.fetchContactModel
-import ch.threema.app.utils.sendMessageToReceivers
+import ch.threema.app.utils.OutgoingCspMessageHandle
+import ch.threema.app.utils.OutgoingCspMessageServices
+import ch.threema.app.utils.runBundledMessagesSendSteps
+import ch.threema.app.utils.toBasicContact
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.GroupId
 import ch.threema.domain.models.MessageId
@@ -54,7 +56,7 @@ class OutgoingGroupSyncRequestTask(
 ) : OutgoingCspMessageTask(serviceManager) {
     private val messageId = messageId ?: MessageId()
     private val apiConnector by lazy { serviceManager.apiConnector }
-    private val taskCreator by lazy { serviceManager.taskCreator }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
     private val outgoingGroupSyncRequestLogModelFactory by lazy { serviceManager.databaseServiceNew.outgoingGroupSyncRequestLogModelFactory }
     private val blockedContactsService by lazy { serviceManager.blockedContactsService }
 
@@ -79,35 +81,50 @@ class OutgoingGroupSyncRequestTask(
             return
         }
 
-        val recipient = contactService.getByIdentity(creatorIdentity)
-            ?: creatorIdentity.fetchContactModel(apiConnector)
+        val recipient = creatorIdentity.toBasicContact(
+            contactModelRepository, contactStore, apiConnector
+        )
+
+        val createdAt = Date()
 
         val messageCreator = OutgoingCspGroupMessageCreator(
             messageId,
+            createdAt,
             groupId,
-            creatorIdentity
+            creatorIdentity,
         ) { GroupSyncRequestMessage() }
 
-        // Send message
-        handle.sendMessageToReceivers(
-            messageCreator,
+        val outgoingCspMessageHandle = OutgoingCspMessageHandle(
             setOf(recipient),
-            forwardSecurityMessageProcessor,
-            identityStore,
-            contactStore,
-            nonceFactory,
-            blockedContactsService,
-            taskCreator
+            messageCreator,
+        )
+
+        // Send message
+        handle.runBundledMessagesSendSteps(
+            outgoingCspMessageHandle,
+            OutgoingCspMessageServices(
+                forwardSecurityMessageProcessor,
+                identityStore,
+                userService,
+                contactStore,
+                contactService,
+                contactModelRepository,
+                groupService,
+                nonceFactory,
+                blockedContactsService,
+                preferenceService,
+                multiDeviceManager
+            )
         )
 
         // Update sync request sent date
         if (model == null) {
             val newModel = OutgoingGroupSyncRequestLogModel()
             newModel.setAPIGroupId(groupId.toString(), creatorIdentity)
-            newModel.lastRequest = Date()
+            newModel.lastRequest = createdAt
             outgoingGroupSyncRequestLogModelFactory.create(newModel)
         } else {
-            model.lastRequest = Date()
+            model.lastRequest = createdAt
             outgoingGroupSyncRequestLogModelFactory.update(model)
         }
     }
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt
index 323841a9..f37d197e 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt
@@ -43,7 +43,6 @@ class OutgoingGroupSyncTask(
     private val receiverIdentities: Set<String>,
     private val serviceManager: ServiceManager,
 ) : OutgoingCspMessageTask(serviceManager) {
-    private val userService by lazy { serviceManager.userService }
 
     override val type: String = "OutgoingGroupSyncTask"
 
@@ -68,7 +67,7 @@ class OutgoingGroupSyncTask(
         OutgoingGroupSetupTask(
             groupId,
             creatorIdentity,
-            groupService.getMembers(group).map { it.identity }.toSet(),
+            groupService.getGroupIdentities(group).toSet(),
             receiverIdentities,
             null,
             serviceManager
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt
index ee1f1b60..b17bbf74 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt
@@ -68,12 +68,16 @@ class OutgoingLocationMessageTask(
             accuracy = locationDataModel.accuracy.toDouble()
             poiName = locationDataModel.poi
             poiAddress = locationDataModel.address
-
-            toIdentity = messageModel.identity
-            messageId = ensureMessageId(messageModel)
         }
 
-        sendContactMessage(message, messageModel, handle)
+        sendContactMessage(
+            message,
+            messageModel,
+            messageModel.identity,
+            ensureMessageId(messageModel),
+            messageModel.createdAt,
+            handle
+        )
     }
 
     private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
@@ -88,6 +92,7 @@ class OutgoingLocationMessageTask(
             group,
             recipientIdentities,
             messageModel,
+            messageModel.createdAt,
             ensureMessageId(messageModel),
             {
                 GroupLocationMessage().apply {
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt
index b8244986..d3b9e79a 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt
@@ -60,16 +60,20 @@ class OutgoingPollSetupMessageTask(
         val messageModel = getContactMessageModel(messageModelId) ?: return
 
         // Create the message
-        val message = PollSetupMessage()
-            .also {
-                it.ballotCreator = serviceManager.identityStore.identity
-                it.ballotId = ballotId
-                it.data = ballotData
-                it.toIdentity = messageModel.identity
-                it.messageId = ensureMessageId(messageModel)
-            }
+        val message = PollSetupMessage().also {
+            it.ballotCreatorIdentity = serviceManager.identityStore.identity
+            it.ballotId = ballotId
+            it.ballotData = ballotData
+        }
 
-        sendContactMessage(message, messageModel, handle)
+        sendContactMessage(
+            message,
+            messageModel,
+            messageModel.identity,
+            ensureMessageId(messageModel),
+            messageModel.createdAt,
+            handle
+        )
     }
 
     private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
@@ -82,14 +86,14 @@ class OutgoingPollSetupMessageTask(
             group,
             recipientIdentities,
             messageModel,
+            messageModel.createdAt,
             ensureMessageId(messageModel),
             {
-                GroupPollSetupMessage()
-                    .also {
-                        it.ballotCreator = serviceManager.identityStore.identity
-                        it.ballotId = ballotId
-                        it.data = ballotData
-                    }
+                GroupPollSetupMessage().also {
+                    it.ballotCreatorIdentity = serviceManager.identityStore.identity
+                    it.ballotId = ballotId
+                    it.ballotData = ballotData
+                }
             },
             handle
         )
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt
index 68c79aa1..204745dd 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt
@@ -30,6 +30,7 @@ import ch.threema.domain.taskmanager.ActiveTaskCodec
 import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
 import kotlinx.serialization.Serializable
+import java.util.Date
 
 class OutgoingPollVoteContactMessageTask(
     private val messageId: MessageId,
@@ -43,19 +44,16 @@ class OutgoingPollVoteContactMessageTask(
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         // Create the message
-        val message = PollVoteMessage()
-            .also {
-                it.ballotCreator = ballotCreator
-                it.ballotId = ballotId
-                it.toIdentity = toIdentity
-                it.messageId = messageId
-            }
+        val message = PollVoteMessage().also {
+            it.ballotCreatorIdentity = ballotCreator
+            it.ballotId = ballotId
+        }
 
         // Add all ballot votes
         message.addVotes(ballotVotes.toList())
 
         // Send the message
-        sendContactMessage(message, null, handle)
+        sendContactMessage(message, null, toIdentity, messageId, Date(), handle)
     }
 
     override fun serialize(): SerializableTaskData = OutgoingPollVoteContactMessageData(
@@ -80,10 +78,7 @@ class OutgoingPollVoteContactMessageTask(
                 BallotId(ballotId),
                 ballotCreator,
                 ballotVotes.map {
-                    BallotVote().apply {
-                        id = it.first
-                        value = it.second
-                    }
+                    BallotVote(it.first, it.second)
                 }.toTypedArray(),
                 toIdentity,
                 serviceManager
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt
index 35a6d35d..0bca8ff7 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt
@@ -33,6 +33,7 @@ import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
 import ch.threema.storage.models.ballot.BallotModel
 import kotlinx.serialization.Serializable
+import java.util.Date
 
 private val logger = LoggingUtil.getThreemaLogger("OutgoingPollVoteGroupMessageTask")
 
@@ -74,6 +75,7 @@ class OutgoingPollVoteGroupMessageTask(
             group,
             recipients,
             null,
+            Date(),
             messageId,
             { createMessage() },
             handle
@@ -81,7 +83,7 @@ class OutgoingPollVoteGroupMessageTask(
     }
 
     private fun createMessage() = GroupPollVoteMessage().also {
-        it.ballotCreator = ballotCreator
+        it.ballotCreatorIdentity = ballotCreator
         it.ballotId = ballotId
         it.addVotes(ballotVotes.toList())
     }
@@ -115,10 +117,7 @@ class OutgoingPollVoteGroupMessageTask(
                 BallotId(ballotId),
                 ballotCreator,
                 ballotVotes.map {
-                    BallotVote().apply {
-                        id = it.first
-                        value = it.second
-                    }
+                    BallotVote(it.first, it.second)
                 }.toTypedArray(),
                 ballotType,
                 GroupId(apiGroupId),
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt
index e133efd4..770338c6 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt
@@ -23,14 +23,16 @@ package ch.threema.app.tasks
 
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.services.ContactService
+import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
 import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
 import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import java.util.Date
 
 /**
- * This class provides methods to send set-profile-picture, request-profile-picture, and
- * delete-profile-picture messages.
+ * This class provides methods to send the csp messages set-profile-picture,
+ * request-profile-picture, and delete-profile-picture messages.
  */
 sealed class OutgoingProfilePictureTask(serviceManager: ServiceManager) :
     OutgoingCspMessageTask(serviceManager), PersistableTask {
@@ -42,11 +44,10 @@ sealed class OutgoingProfilePictureTask(serviceManager: ServiceManager) :
         handle: ActiveTaskCodec,
     ) {
         // Create the message
-        val innerMsg = ContactRequestProfilePictureMessage()
-        innerMsg.toIdentity = toIdentity
+        val message = ContactRequestProfilePictureMessage()
 
         // Encapsulate and send the message
-        sendContactMessage(innerMsg, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 
     /**
@@ -60,14 +61,13 @@ sealed class OutgoingProfilePictureTask(serviceManager: ServiceManager) :
         handle: ActiveTaskCodec,
     ) {
         // Create the message
-        val innerMsg =
-            SetProfilePictureMessage()
-        innerMsg.blobId = data.blobId
-        innerMsg.encryptionKey = data.encryptionKey
-        innerMsg.size = data.size
-        innerMsg.toIdentity = toIdentity
+        val message = SetProfilePictureMessage(
+            blobId = data.blobId,
+            size = data.size,
+            encryptionKey = data.encryptionKey,
+        )
 
-        sendContactMessage(innerMsg, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 
     /**
@@ -78,10 +78,8 @@ sealed class OutgoingProfilePictureTask(serviceManager: ServiceManager) :
         handle: ActiveTaskCodec,
     ) {
         // Create the message
-        val innerMsg =
-            DeleteProfilePictureMessage()
-        innerMsg.toIdentity = toIdentity
+        val message = DeleteProfilePictureMessage()
 
-        sendContactMessage(innerMsg, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 }
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt
index 14e8de67..42a6aa22 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt
@@ -59,11 +59,16 @@ class OutgoingTextMessageTask(
 
         // Create the message
         val message = TextMessage()
-        message.messageId = ensureMessageId(messageModel)
         message.text = messageModel.bodyAndQuotedMessageId
-        message.toIdentity = messageModel.identity
 
-        sendContactMessage(message, messageModel, handle)
+        sendContactMessage(
+            message,
+            messageModel,
+            messageModel.identity,
+            ensureMessageId(messageModel),
+            messageModel.createdAt,
+            handle
+        )
     }
 
     private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
@@ -78,6 +83,7 @@ class OutgoingTextMessageTask(
             group,
             recipientIdentities,
             messageModel,
+            messageModel.createdAt,
             ensureMessageId(messageModel),
             {
                 GroupTextMessage().apply {
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt
index ca2b119f..70f2d95b 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt
@@ -25,6 +25,7 @@ import ch.threema.app.managers.ServiceManager
 import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import java.util.Date
 
 class OutgoingTypingIndicatorMessageTask(
     private val isTyping: Boolean,
@@ -35,12 +36,10 @@ class OutgoingTypingIndicatorMessageTask(
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         val message = TypingIndicatorMessage().also {
-            it.messageId = MessageId()
-            it.toIdentity = toIdentity
             it.isTyping = isTyping
         }
 
-        sendContactMessage(message, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 
     override fun serialize(): SerializableTaskData? = null
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt
index ff19c287..12c10094 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt
@@ -26,6 +26,7 @@ import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import java.util.Date
 
 class OutgoingVoipCallAnswerMessageTask(
     private val voipCallAnswerData: VoipCallAnswerData,
@@ -39,12 +40,10 @@ class OutgoingVoipCallAnswerMessageTask(
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         val message = VoipCallAnswerMessage()
         message.data = voipCallAnswerData
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
 
         voipStateService.addRequiredMessageId(voipCallAnswerData.callId ?: 0, message.messageId)
 
-        sendContactMessage(message, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 
     // We do not need to persist this message
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt
index 666bf6d7..bf8c8f09 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt
@@ -26,6 +26,7 @@ import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupData
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import java.util.Date
 
 class OutgoingVoipCallHangupMessageTask(
     private val voipCallHangupData: VoipCallHangupData,
@@ -35,12 +36,10 @@ class OutgoingVoipCallHangupMessageTask(
     override val type: String = "OutgoingVoipCallHangupMessageTask"
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = VoipCallHangupMessage()
-        message.setData(voipCallHangupData)
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
-
-        sendContactMessage(message, null, handle)
+        val message = VoipCallHangupMessage().apply {
+            this.data = voipCallHangupData
+        }
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 
     // We do not need to persist this message
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt
index 4ae9ab5e..fb7b34f3 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt
@@ -26,6 +26,7 @@ import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferData
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import java.util.Date
 
 class OutgoingVoipCallOfferMessageTask(
     private val voipCallOfferData: VoipCallOfferData,
@@ -39,12 +40,10 @@ class OutgoingVoipCallOfferMessageTask(
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         val message = VoipCallOfferMessage()
         message.data = voipCallOfferData
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
 
         voipStateService.addRequiredMessageId(voipCallOfferData.callId ?: 0, message.messageId)
 
-        sendContactMessage(message, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
 
         contactService.bumpLastUpdate(toIdentity)
     }
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt
index aaf8e517..3d2eaf71 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt
@@ -26,6 +26,7 @@ import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingData
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import java.util.Date
 
 class OutgoingVoipCallRingingMessageTask(
     private val voipCallRingingData: VoipCallRingingData,
@@ -38,13 +39,13 @@ class OutgoingVoipCallRingingMessageTask(
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         val message = VoipCallRingingMessage()
-        message.setData(voipCallRingingData)
+        message.data = voipCallRingingData
         message.toIdentity = toIdentity
         message.messageId = MessageId()
 
         voipStateService.addRequiredMessageId(voipCallRingingData.callId ?: 0, message.messageId)
 
-        sendContactMessage(message, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 
     // We do not need to persist this message
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt
index 5c70a368..9c8f3eca 100644
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt
@@ -26,6 +26,7 @@ import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
 import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesData
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import java.util.Date
 
 class OutgoingVoipICECandidateMessageTask(
     private val voipICECandidatesData: VoipICECandidatesData,
@@ -37,10 +38,8 @@ class OutgoingVoipICECandidateMessageTask(
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
         val message = VoipICECandidatesMessage()
         message.data = voipICECandidatesData
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
 
-        sendContactMessage(message, null, handle)
+        sendContactMessage(message, null, toIdentity, MessageId(), Date(), handle)
     }
 
     // We do not need to persist this message
diff --git a/app/src/main/java/ch/threema/app/tasks/PersistableTask.kt b/app/src/main/java/ch/threema/app/tasks/PersistableTask.kt
index f54f7045..33e71d59 100644
--- a/app/src/main/java/ch/threema/app/tasks/PersistableTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/PersistableTask.kt
@@ -25,8 +25,6 @@ import ch.threema.app.managers.ServiceManager
 import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
 import kotlinx.serialization.Serializable
-import kotlinx.serialization.encodeToString
-import kotlinx.serialization.json.Json
 
 internal sealed interface PersistableTask {
     fun serialize(): SerializableTaskData?
diff --git a/app/src/main/java/ch/threema/app/tasks/ProfilePictureDistributionTask.kt b/app/src/main/java/ch/threema/app/tasks/ProfilePictureDistributionTask.kt
deleted file mode 100644
index 3750ab3d..00000000
--- a/app/src/main/java/ch/threema/app/tasks/ProfilePictureDistributionTask.kt
+++ /dev/null
@@ -1,128 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.services.ContactService.ProfilePictureUploadData
-import ch.threema.app.utils.ContactUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.storage.models.ContactModel
-import kotlinx.serialization.Serializable
-import java.util.Arrays
-
-private val logger = LoggingUtil.getThreemaLogger("ProfilePictureDistributionTask")
-
-/**
- * This task runs the profile distribution
- */
-class ProfilePictureDistributionTask(
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingProfilePictureTask(serviceManager) {
-
-    override val type: String = "ProfilePictureDistributionTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        // Step 1 is already done as this task is only scheduled for messages that allow user
-        // profile distribution.
-
-        val prefix = "Profile picture distribution"
-
-        val contactModel = contactService.getByIdentity(toIdentity)
-        if (contactModel == null) {
-            logger.warn("{}: Contact model not found", prefix)
-            return
-        }
-
-        // Step 2: Abort if the contact's id is ECHOECHO or a Gateway ID
-        if (ContactUtil.isEchoEchoOrGatewayContact(contactModel)) {
-            logger.info(
-                "{}: Contact {} should not receive the profile picture",
-                prefix,
-                toIdentity
-            )
-            return
-        }
-
-        // If the contact has been restored, send a photo request message and mark contact as not
-        // restored if successful. Don't do this for ECHOECHO or channel IDs.
-        if (contactModel.isRestored) {
-            sendRequestProfilePictureMessage(toIdentity, handle)
-            contactModel.setIsRestored(false)
-            contactService.save(contactModel)
-        }
-
-        // Step 3: Abort if the contact should not receive the profile picture according to settings
-        if (!contactService.isContactAllowedToReceiveProfilePicture(contactModel)) {
-            logger.info(
-                "{}: Contact {} is not allowed to receive the profile picture",
-                prefix,
-                toIdentity
-            )
-            return
-        }
-
-        // Step 4: Upload profile picture to blob server if no valid cached blob id exists
-        val data: ProfilePictureUploadData = contactService.updatedProfilePictureUploadData
-        if (data.blobId == null) {
-            logger.warn("{}: Blob ID is null; abort", prefix)
-            return
-        }
-
-        // Step 5: If the currently cached blob ID equals the blob ID that was most recently
-        // distributed to the contact, abort these steps
-        if (Arrays.equals(data.blobId, contactModel.profilePicBlobID)) {
-            logger.debug(
-                "{}: Contact {} already has the latest profile picture",
-                prefix,
-                toIdentity
-            )
-            return
-        }
-
-        // Step 6: Send a set-profile-picture message to the contact using the cached blob ID
-        if (!data.blobId.contentEquals(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)) {
-            sendSetProfilePictureMessage(data, toIdentity, handle)
-            logger.info("{}: Profile picture successfully sent to {}", prefix, toIdentity)
-        } else {
-            sendDeleteProfilePictureMessage(toIdentity, handle)
-            logger.info("{}: Profile picture deletion successfully sent to {}", prefix, toIdentity)
-        }
-
-        // Step 7: Store the cached blob ID as the most recently used blob ID for this contact
-        contactModel.profilePicBlobID = data.blobId
-        contactService.save(contactModel)
-    }
-
-    override fun serialize(): SerializableTaskData = ProfilePictureDistributionTaskData(toIdentity)
-
-    @Serializable
-    data class ProfilePictureDistributionTaskData(
-        private val toIdentity: String
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            ProfilePictureDistributionTask(toIdentity, serviceManager)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncCreateTask.kt b/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncCreateTask.kt
new file mode 100644
index 00000000..25b0cbe8
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncCreateTask.kt
@@ -0,0 +1,71 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModel
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.taskmanager.ActiveTask
+
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.getEncryptedContactSyncCreate
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectContactSyncCreate")
+
+class ReflectContactSyncCreateTask(
+    private val contactModelData: ContactModelData,
+    private val contactModelRepository: ContactModelRepository,
+    private val nonceFactory: NonceFactory,
+    private val createLocally: () -> ContactModel,
+    multiDeviceManager: MultiDeviceManager,
+) : ReflectContactSyncTask<Unit, ContactModel>(multiDeviceManager), ActiveTask<ContactModel> {
+
+    override val type = "ReflectContactSyncCreate"
+
+    override suspend fun invoke(handle: ActiveTaskCodec): ContactModel = reflectContactSync(handle)
+
+    override val runPrecondition: () -> Boolean = {
+        // Precondition: Contact must not exist
+        contactModelRepository.getByIdentity(contactModelData.identity) == null
+    }
+
+    override val runInsideTransaction: suspend (handle: ActiveTaskCodec) -> Unit = { handle ->
+        logger.info("Reflecting contact sync create for identity {}", contactModelData.identity)
+
+        val encryptedEnvelopeResult = getEncryptedContactSyncCreate(
+            contactModelData.toFullSyncContact(),
+            mdProperties,
+        )
+        handle.reflectAndAwaitAck(
+            encryptedEnvelopeResult = encryptedEnvelopeResult,
+            storeD2dNonce = true,
+            nonceFactory = nonceFactory
+        )
+    }
+
+    override val runAfterSuccessfulTransaction: (transactionResult: Unit) -> ContactModel = {
+        createLocally()
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncTask.kt b/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncTask.kt
new file mode 100644
index 00000000..63e82af6
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncTask.kt
@@ -0,0 +1,308 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.services.ContactService.ProfilePictureUploadData
+import ch.threema.app.services.ConversationService
+import ch.threema.app.services.DeadlineListService
+import ch.threema.app.services.RingtoneService
+import ch.threema.app.utils.ContactUtil
+import ch.threema.data.models.ContactModelData
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TRANSACTION_TTL_MAX
+import ch.threema.domain.taskmanager.createTransaction
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.Common.DeltaImage
+import ch.threema.protobuf.blob
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.protobuf.d2d.sync.ContactKt
+import ch.threema.protobuf.d2d.sync.MdD2DSync
+import ch.threema.protobuf.d2d.sync.MdD2DSync.NotificationSoundPolicy
+import ch.threema.protobuf.d2d.sync.contact
+import ch.threema.protobuf.deltaImage
+import ch.threema.protobuf.image
+import ch.threema.protobuf.unit
+import ch.threema.storage.models.ContactModel
+import com.google.protobuf.kotlin.toByteString
+
+abstract class ReflectContactSyncTask<TransactionResult, TaskResult>(
+    protected val multiDeviceManager: MultiDeviceManager,
+) {
+    protected val mdProperties by lazy { multiDeviceManager.propertiesProvider.get() }
+
+    /**
+     * This is run as the precondition of the transaction that is used when reflecting the contact
+     * sync with [reflectContactSync].
+     */
+    protected abstract val runPrecondition: () -> Boolean
+
+    /**
+     * This is run inside the transaction of the contact sync reflection in [reflectContactSync].
+     */
+    protected abstract val runInsideTransaction: suspend (handle: ActiveTaskCodec) -> TransactionResult
+
+    /**
+     * This is run after the transaction has been successfully executed.
+     */
+    protected abstract val runAfterSuccessfulTransaction: (transactionResult: TransactionResult) -> TaskResult
+
+    /**
+     * The transaction ttl that is used for the transaction in [reflectContactSync].
+     */
+    protected open val transactionTTL: UInt = TRANSACTION_TTL_MAX
+
+    /**
+     * Reflect the contact sync. Note that this creates a transaction with [transactionTTL] and runs
+     * [runPrecondition] as precondition of it. Inside the transaction [runInsideTransaction] is
+     * run.
+     *
+     * @throws IllegalStateException if multi device is not active
+     */
+    protected suspend fun reflectContactSync(handle: ActiveTaskCodec): TaskResult {
+        if (!multiDeviceManager.isMultiDeviceActive) {
+            throw IllegalStateException("Multi device is not active and a contact sync must not be reflected")
+        }
+
+        val transactionResult = handle.createTransaction(
+            mdProperties.keys, MdD2D.TransactionScope.Scope.CONTACT_SYNC, transactionTTL
+        ) {
+            runPrecondition()
+        }.execute {
+            runInsideTransaction(handle)
+        }
+
+        return runAfterSuccessfulTransaction(transactionResult)
+    }
+
+    protected fun ContactModelData.toFullSyncContact(
+        conversationService: ConversationService? = null,
+        hiddenChatListService: DeadlineListService? = null,
+        mutedChatsService: DeadlineListService? = null,
+        ringtoneService: RingtoneService? = null,
+        contactDefinedProfilePictureUpload: ProfilePictureUploadData? = null,
+        userDefinedProfilePictureUpload: ProfilePictureUploadData? = null,
+    ): MdD2DSync.Contact {
+        val data = this
+        return contact {
+            identity = data.identity
+            publicKey = data.publicKey.toByteString()
+            createdAt = data.createdAt.time
+            firstName = data.firstName
+            lastName = data.lastName
+            data.nickname?.let { nickname = it }
+            verificationLevel = data.getSyncVerificationLevel()
+            workVerificationLevel = data.getSyncWorkVerificationLevel()
+            identityType = data.getSyncIdentityType()
+            acquaintanceLevel = data.getSyncAcquaintanceLevel()
+            activityState = data.getSyncActivityState()
+            featureMask = data.featureMask.toLong()
+            syncState = data.getSyncSyncState()
+            readReceiptPolicyOverride = data.getSyncReadReceiptPolicyOverride()
+            typingIndicatorPolicyOverride = data.getSyncTypingIndicatorPolicyOverride()
+            notificationTriggerPolicyOverride =
+                data.getSyncNotificationTriggerPolicyOverride(mutedChatsService)
+            notificationSoundPolicyOverride =
+                getSyncNotificationSoundPolicyOverride(ringtoneService)
+            contactDefinedProfilePicture = contactDefinedProfilePictureUpload.toDeltaImage()
+            userDefinedProfilePicture = userDefinedProfilePictureUpload.toDeltaImage()
+            conversationCategory = data.getSyncConversationCategory(hiddenChatListService)
+            conversationVisibility = data.getSyncConversationVisibility(conversationService)
+        }
+    }
+
+    private fun ContactModelData.getSyncVerificationLevel(): MdD2DSync.Contact.VerificationLevel =
+        when (this.verificationLevel) {
+            VerificationLevel.FULLY_VERIFIED -> MdD2DSync.Contact.VerificationLevel.FULLY_VERIFIED
+            VerificationLevel.SERVER_VERIFIED -> MdD2DSync.Contact.VerificationLevel.SERVER_VERIFIED
+            VerificationLevel.UNVERIFIED -> MdD2DSync.Contact.VerificationLevel.UNVERIFIED
+        }
+
+    private fun ContactModelData.getSyncWorkVerificationLevel(): MdD2DSync.Contact.WorkVerificationLevel =
+        when (this.workVerificationLevel) {
+            WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED -> MdD2DSync.Contact.WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+            WorkVerificationLevel.NONE -> MdD2DSync.Contact.WorkVerificationLevel.NONE
+        }
+
+    private fun ContactModelData.getSyncIdentityType(): MdD2DSync.Contact.IdentityType =
+        when (this.identityType) {
+            IdentityType.NORMAL -> MdD2DSync.Contact.IdentityType.REGULAR
+            IdentityType.WORK -> MdD2DSync.Contact.IdentityType.WORK
+        }
+
+    private fun ContactModelData.getSyncAcquaintanceLevel(): MdD2DSync.Contact.AcquaintanceLevel =
+        when (this.acquaintanceLevel) {
+            ContactModel.AcquaintanceLevel.DIRECT -> MdD2DSync.Contact.AcquaintanceLevel.DIRECT
+            ContactModel.AcquaintanceLevel.GROUP -> MdD2DSync.Contact.AcquaintanceLevel.GROUP
+        }
+
+    private fun ContactModelData.getSyncActivityState(): MdD2DSync.Contact.ActivityState =
+        when (this.activityState) {
+            IdentityState.ACTIVE -> MdD2DSync.Contact.ActivityState.ACTIVE
+            IdentityState.INACTIVE -> MdD2DSync.Contact.ActivityState.INACTIVE
+            IdentityState.INVALID -> MdD2DSync.Contact.ActivityState.INVALID
+        }
+
+    private fun ContactModelData.getSyncSyncState(): MdD2DSync.Contact.SyncState =
+        // TODO(ANDR-2327): Consolidate this mechanism
+        if (androidContactLookupKey != null) {
+            MdD2DSync.Contact.SyncState.IMPORTED
+        } else if (lastName.isBlank() && firstName.isBlank()) {
+            MdD2DSync.Contact.SyncState.INITIAL
+        } else {
+            MdD2DSync.Contact.SyncState.CUSTOM
+        }
+
+    private fun ContactModelData.getSyncReadReceiptPolicyOverride(): MdD2DSync.Contact.ReadReceiptPolicyOverride =
+        ContactKt.readReceiptPolicyOverride {
+            when (readReceiptPolicy) {
+                ReadReceiptPolicy.DEFAULT -> default = unit { }
+                ReadReceiptPolicy.SEND -> policy = MdD2DSync.ReadReceiptPolicy.SEND_READ_RECEIPT
+                ReadReceiptPolicy.DONT_SEND -> policy =
+                    MdD2DSync.ReadReceiptPolicy.DONT_SEND_READ_RECEIPT
+            }
+        }
+
+    private fun ContactModelData.getSyncTypingIndicatorPolicyOverride(): MdD2DSync.Contact.TypingIndicatorPolicyOverride =
+        ContactKt.typingIndicatorPolicyOverride {
+            when (typingIndicatorPolicy) {
+                TypingIndicatorPolicy.DEFAULT -> default = unit { }
+
+                TypingIndicatorPolicy.SEND ->
+                    policy = MdD2DSync.TypingIndicatorPolicy.SEND_TYPING_INDICATOR
+
+                TypingIndicatorPolicy.DONT_SEND ->
+                    policy = MdD2DSync.TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR
+            }
+        }
+
+    // TODO(ANDR-2998): Use notification trigger policy override from new contact model
+    private fun ContactModelData.getSyncNotificationTriggerPolicyOverride(
+        mutedChatsService: DeadlineListService?,
+    ): MdD2DSync.Contact.NotificationTriggerPolicyOverride {
+        return if (mutedChatsService != null) {
+            ContactKt.notificationTriggerPolicyOverride {
+                val mutedUntil =
+                    mutedChatsService.getDeadline(ContactUtil.getUniqueIdString(identity))
+                if (mutedUntil == DeadlineListService.DEADLINE_INDEFINITE || mutedUntil > 0) {
+                    policy = ContactKt.NotificationTriggerPolicyOverrideKt.policy {
+                        policy =
+                            MdD2DSync.Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy.NEVER
+                        if (mutedUntil > 0) {
+                            expiresAt = mutedUntil
+                        }
+                    }
+                } else {
+                    default = unit { }
+                }
+            }
+        } else {
+            ContactKt.notificationTriggerPolicyOverride {
+                default = unit { }
+            }
+        }
+    }
+
+    // TODO(ANDR-2998): Use notification sound policy override from new contact model
+    private fun ContactModelData.getSyncNotificationSoundPolicyOverride(
+        ringtoneService: RingtoneService?,
+    ): MdD2DSync.Contact.NotificationSoundPolicyOverride {
+        return if (ringtoneService != null) {
+            ContactKt.notificationSoundPolicyOverride {
+                if (ringtoneService.isSilent(ContactUtil.getUniqueIdString(identity), false)) {
+                    policy = NotificationSoundPolicy.MUTED
+                } else {
+                    default = unit { }
+                }
+            }
+        } else {
+            ContactKt.notificationSoundPolicyOverride {
+                default = unit { }
+            }
+        }
+    }
+
+    // TODO(ANDR-3034): Use conversation category from the new contact model
+    private fun ContactModelData.getSyncConversationCategory(
+        hiddenChatListService: DeadlineListService?,
+    ): MdD2DSync.ConversationCategory {
+        return if (hiddenChatListService != null) {
+            if (hiddenChatListService.has(ContactUtil.getUniqueIdString(identity))) {
+                MdD2DSync.ConversationCategory.PROTECTED
+            } else {
+                MdD2DSync.ConversationCategory.DEFAULT
+            }
+        } else {
+            MdD2DSync.ConversationCategory.DEFAULT
+        }
+    }
+
+    private fun ContactModelData.getSyncConversationVisibility(
+        conversationService: ConversationService?,
+    ): MdD2DSync.ConversationVisibility {
+        // TODO(ANDR-3035): Use conversation visibility from the new contact model
+        if (conversationService != null) {
+            // In case there is a conversation with the contact: Check the pin tag, otherwise it is normal
+            conversationService.getAll(true).find { it.contact?.identity == identity }?.let {
+                return if (it.isPinTagged) {
+                    MdD2DSync.ConversationVisibility.PINNED
+                } else {
+                    MdD2DSync.ConversationVisibility.NORMAL
+                }
+            }
+
+            // In case there is an archived conversation with the contact: The visibility is archived.
+            conversationService.getArchived(null).find { it.contact?.identity == identity }?.let {
+                return MdD2DSync.ConversationVisibility.PINNED
+            }
+        }
+
+        // In case there is no conversation with the contact: The visibility is normal.
+        return MdD2DSync.ConversationVisibility.NORMAL
+    }
+
+    private fun ProfilePictureUploadData?.toDeltaImage(): DeltaImage {
+        return if (this == null) {
+            deltaImage { removed = unit { } }
+        } else {
+            val uploadData = this
+            deltaImage {
+                updated = image {
+                    type = Common.Image.Type.JPEG
+                    blob = blob {
+                        id = uploadData.blobId.toByteString()
+                        nonce = ProtocolDefines.CONTACT_PHOTO_NONCE.toByteString()
+                        key = uploadData.encryptionKey.toByteString()
+                        uploadedAt = uploadData.uploadedAt
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncUpdateTask.kt b/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncUpdateTask.kt
new file mode 100644
index 00000000..59503698
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectContactSyncUpdateTask.kt
@@ -0,0 +1,835 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.services.ApiService
+import ch.threema.app.services.FileService
+import ch.threema.app.utils.runtimeAssert
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.SymmetricEncryptionService
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModelData
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.models.IdentityState
+import ch.threema.domain.models.IdentityType
+import ch.threema.domain.models.ReadReceiptPolicy
+import ch.threema.domain.models.TypingIndicatorPolicy
+import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.blob.BlobScope
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.TransactionScope
+import ch.threema.domain.taskmanager.getEncryptedContactSyncUpdate
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.blob
+import ch.threema.protobuf.d2d.sync.ContactKt.readReceiptPolicyOverride
+import ch.threema.protobuf.d2d.sync.ContactKt.typingIndicatorPolicyOverride
+import ch.threema.protobuf.d2d.sync.MdD2DSync
+import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact
+import ch.threema.protobuf.d2d.sync.contact
+import ch.threema.protobuf.deltaImage
+import ch.threema.protobuf.image
+import ch.threema.protobuf.unit
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
+import com.google.protobuf.kotlin.toByteString
+import kotlinx.serialization.Serializable
+
+private val logger = LoggingUtil.getThreemaLogger("ReflectContactSyncUpdate")
+
+abstract class ReflectContactSyncUpdateBaseTask(
+    protected val contactIdentity: String,
+    private val contactModelRepository: ContactModelRepository,
+    multiDeviceManager: MultiDeviceManager,
+    private val nonceFactory: NonceFactory,
+) : ReflectContactSyncTask<Unit, Unit>(multiDeviceManager) {
+
+    /**
+     * The task type. This is just used for debugging.
+     */
+    protected abstract val type: String
+
+    /**
+     * This method is called to check whether the contact reflection is still necessary. Note that
+     * the general strategy to decide may differ between different types of tasks.
+     */
+    abstract fun isUpdateRequired(currentData: ContactModelData): Boolean
+
+    /**
+     * Get the contact sync that contains the delta updates.
+     */
+    abstract fun getContactSync(): Contact
+
+    /**
+     * As a precondition for an update task, the contact with the given identity must exist and the
+     * changed data must differ from the current data.
+     */
+    final override val runPrecondition: () -> Boolean = {
+        // The contact must exist and there needs to be a change
+        contactModelRepository.getByIdentity(contactIdentity)?.data?.value?.let {
+            isUpdateRequired(it)
+        } ?: false
+    }
+
+    /**
+     * Inside the transaction we just reflect the contact sync update from [getContactSync] with the
+     * [runPrecondition].
+     */
+    override val runInsideTransaction: suspend (handle: ActiveTaskCodec) -> Unit = { handle ->
+        logger.info("Reflecting contact sync update of type {} for {}", type, contactIdentity)
+
+        val encryptedEnvelopeResult = getEncryptedContactSyncUpdate(
+            getContactSync().also {
+                runtimeAssert(it.identity == contactIdentity, "Identity must match")
+            },
+            mdProperties,
+        )
+        handle.reflectAndAwaitAck(
+            encryptedEnvelopeResult = encryptedEnvelopeResult,
+            storeD2dNonce = true,
+            nonceFactory = nonceFactory
+        )
+    }
+
+    override val runAfterSuccessfulTransaction: (transactionResult: Unit) -> Unit = {
+        // Nothing to do
+    }
+
+}
+
+/**
+ * This task must be run *before* the changes have been persisted. It cannot be run using the task
+ * manager as it must be run immediately inside another task.
+ */
+abstract class ReflectContactSyncUpdateImmediateTask(
+    contactIdentity: String,
+    contactModelRepository: ContactModelRepository,
+    multiDeviceManager: MultiDeviceManager,
+    nonceFactory: NonceFactory,
+) : ReflectContactSyncUpdateBaseTask(
+    contactIdentity,
+    contactModelRepository,
+    multiDeviceManager,
+    nonceFactory,
+) {
+
+    /**
+     * Check whether the data has changed. Note that immediate tasks are executed before the update
+     * has been persisted. In this case, we reflect only if the current data is different to the new
+     * data.
+     */
+    abstract fun hasDataChanged(currentData: ContactModelData): Boolean
+
+    /**
+     * An update of an immediate task is required if the data has changed.
+     */
+    final override fun isUpdateRequired(currentData: ContactModelData) = hasDataChanged(currentData)
+
+    /**
+     * Reflect the current change.
+     *
+     * @throws TransactionScope.TransactionException if the current contact data already contains
+     * this change
+     */
+    suspend fun reflect(handle: ActiveTaskCodec) {
+        reflectContactSync(handle)
+    }
+
+    /**
+     * A task to reflect a new nickname.
+     */
+    class ReflectContactNickname(
+        contactIdentity: String,
+        private val newNickname: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateImmediateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+
+        override val type = "ReflectContactNickname"
+
+        override fun hasDataChanged(currentData: ContactModelData): Boolean {
+            return currentData.nickname != newNickname
+        }
+
+        override fun getContactSync() = contact {
+            identity = contactIdentity
+            nickname = newNickname
+        }
+    }
+
+    /**
+     * A task to reflect a new profile picture. Note that this task should always be run when a
+     * profile picture has been received to ensure that the other devices can mark the blob as done
+     * on the blob mirror.
+     */
+    class ReflectContactProfilePicture(
+        contactIdentity: String,
+        private val profilePictureUpdate: ProfilePictureUpdate,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateImmediateTask(
+        contactIdentity = contactIdentity,
+        contactModelRepository = contactModelRepository,
+        multiDeviceManager = multiDeviceManager,
+        nonceFactory = nonceFactory,
+    ) {
+        sealed interface ProfilePictureUpdate
+
+        class UpdatedProfilePicture(
+            val blobId: ByteArray,
+            val nonce: ByteArray,
+            val encryptionKey: ByteArray,
+        ) : ProfilePictureUpdate
+
+        data object RemovedProfilePicture : ProfilePictureUpdate
+
+        override val type: String = "ReflectContactProfilePicture"
+
+        /**
+         * Note that we cannot check this based on the contact model data. Therefore, we assume that
+         * the data has changed and rely on the caller to check this.
+         */
+        override fun hasDataChanged(currentData: ContactModelData): Boolean = true
+
+        override fun getContactSync() = contact {
+            identity = contactIdentity
+            contactDefinedProfilePicture = deltaImage {
+                when (profilePictureUpdate) {
+                    is UpdatedProfilePicture -> {
+                        updated = image {
+                            type = Common.Image.Type.JPEG
+                            blob = blob {
+                                id = profilePictureUpdate.blobId.toByteString()
+                                nonce = profilePictureUpdate.nonce.toByteString()
+                                key = profilePictureUpdate.encryptionKey.toByteString()
+                            }
+                        }
+                    }
+
+                    is RemovedProfilePicture -> {
+                        removed = unit { }
+                    }
+                }
+            }
+        }
+    }
+
+}
+
+/**
+ * This task must be executed *after* the updates have been persisted to local storage. It must be
+ * run using the task manager.
+ */
+abstract class ReflectContactSyncUpdateTask(
+    contactIdentity: String,
+    contactModelRepository: ContactModelRepository,
+    multiDeviceManager: MultiDeviceManager,
+    nonceFactory: NonceFactory,
+) : ReflectContactSyncUpdateBaseTask(
+    contactIdentity,
+    contactModelRepository,
+    multiDeviceManager,
+    nonceFactory
+), ActiveTask<Unit>, PersistableTask {
+
+    /**
+     * Return true if the change that should be reflected still matches the current data. Note that
+     * if a task performs several changes, then *all* of the new values must be equal to
+     * [currentData].
+     */
+    abstract fun isChangeValid(currentData: ContactModelData): Boolean
+
+    /**
+     * We only reflect a change if it is still valid. This is a consequence of the strategy to first
+     * persist changes locally followed by scheduling a persistent task to reflect the changes.
+     *
+     * There are two cases where the data has been changed in the meantime:
+     * - Bypassed d2d messages may have altered the contact, as the same fields have been changed on
+     *   a linked device. In this case we do not reflect the change, as it already is outdated.
+     * - The user has already changed the values again. In this case we can also skip the reflection
+     *   because a new update task containing the changes will be scheduled.
+     */
+    final override fun isUpdateRequired(currentData: ContactModelData) = isChangeValid(currentData)
+
+    /**
+     * Invoke the task. Note that the reflected changes must already be written to the database.
+     */
+    final override suspend fun invoke(handle: ActiveTaskCodec) {
+        reflectContactSync(handle)
+    }
+
+    /**
+     * Reflect a new name.
+     */
+    class ReflectNameUpdate(
+        private val newFirstName: String,
+        private val newLastName: String,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type: String = "ReflectNameUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData): Boolean =
+            currentData.firstName == newFirstName
+                && currentData.lastName == newLastName
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            firstName = newFirstName
+            lastName = newLastName
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectNameUpdateData(
+            firstName = newFirstName,
+            lastName = newLastName,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectNameUpdateData(
+            private val firstName: String,
+            private val lastName: String,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectNameUpdate(
+                    newFirstName = firstName,
+                    newLastName = lastName,
+                    contactIdentity = identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new read receipt policy.
+     */
+    class ReflectReadReceiptPolicyUpdate(
+        private val readReceiptPolicy: ReadReceiptPolicy,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type: String = "ReflectReadReceiptPolicyUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData): Boolean =
+            currentData.readReceiptPolicy == readReceiptPolicy
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            readReceiptPolicyOverride = readReceiptPolicyOverride {
+                when (readReceiptPolicy) {
+                    ReadReceiptPolicy.DEFAULT -> default = unit {}
+                    ReadReceiptPolicy.SEND -> policy = MdD2DSync.ReadReceiptPolicy.SEND_READ_RECEIPT
+                    ReadReceiptPolicy.DONT_SEND -> policy =
+                        MdD2DSync.ReadReceiptPolicy.DONT_SEND_READ_RECEIPT
+                }
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectReadReceiptPolicyUpdateData(
+            readReceiptPolicy = readReceiptPolicy,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectReadReceiptPolicyUpdateData(
+            private val readReceiptPolicy: ReadReceiptPolicy,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectReadReceiptPolicyUpdate(
+                    readReceiptPolicy,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new typing indicator policy.
+     */
+    class ReflectTypingIndicatorPolicyUpdate(
+        private val typingIndicatorPolicy: TypingIndicatorPolicy,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type: String = "ReflectTypingIndicatorPolicyUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData): Boolean =
+            currentData.typingIndicatorPolicy == typingIndicatorPolicy
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            typingIndicatorPolicyOverride = typingIndicatorPolicyOverride {
+                when (typingIndicatorPolicy) {
+                    TypingIndicatorPolicy.DEFAULT -> default = unit {}
+
+                    TypingIndicatorPolicy.SEND -> policy =
+                        MdD2DSync.TypingIndicatorPolicy.SEND_TYPING_INDICATOR
+
+                    TypingIndicatorPolicy.DONT_SEND -> policy =
+                        MdD2DSync.TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR
+                }
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectTypingIndicatorPolicyUpdateData(
+            typingIndicatorPolicy = typingIndicatorPolicy,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectTypingIndicatorPolicyUpdateData(
+            private val typingIndicatorPolicy: TypingIndicatorPolicy,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectTypingIndicatorPolicyUpdate(
+                    typingIndicatorPolicy,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new activity state.
+     */
+    class ReflectActivityStateUpdate(
+        private val newIdentityState: IdentityState,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type = "ReflectActivityStateUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData) =
+            currentData.activityState == newIdentityState
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            activityState = when (newIdentityState) {
+                IdentityState.ACTIVE -> Contact.ActivityState.ACTIVE
+                IdentityState.INACTIVE -> Contact.ActivityState.INACTIVE
+                IdentityState.INVALID -> Contact.ActivityState.INVALID
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectActivityStateUpdateData(
+            identityState = newIdentityState,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectActivityStateUpdateData(
+            private val identityState: IdentityState,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectActivityStateUpdate(
+                    identityState,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new feature mask.
+     */
+    class ReflectFeatureMaskUpdate(
+        private val newFeatureMask: Long,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type = "ReflectFeatureMaskUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData) =
+            currentData.featureMask == newFeatureMask.toULong()
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            featureMask = newFeatureMask
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectFeatureMaskUpdateData(
+            featureMask = newFeatureMask,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectFeatureMaskUpdateData(
+            private val featureMask: Long,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectFeatureMaskUpdate(
+                    featureMask,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new verification level.
+     */
+    class ReflectVerificationLevelUpdate(
+        private val newVerificationLevel: VerificationLevel,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type = "ReflectVerificationLevelUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData) =
+            currentData.verificationLevel == newVerificationLevel
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            verificationLevel = when (newVerificationLevel) {
+                VerificationLevel.FULLY_VERIFIED -> Contact.VerificationLevel.FULLY_VERIFIED
+                VerificationLevel.SERVER_VERIFIED -> Contact.VerificationLevel.SERVER_VERIFIED
+                VerificationLevel.UNVERIFIED -> Contact.VerificationLevel.UNVERIFIED
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectVerificationLevelUpdateData(
+            verificationLevel = newVerificationLevel,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectVerificationLevelUpdateData(
+            private val verificationLevel: VerificationLevel,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectVerificationLevelUpdate(
+                    verificationLevel,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new work verification level.
+     */
+    class ReflectWorkVerificationLevelUpdate(
+        private val newWorkVerificationLevel: WorkVerificationLevel,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type = "ReflectWorkVerificationLevelUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData) =
+            currentData.workVerificationLevel == newWorkVerificationLevel
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            workVerificationLevel = when (newWorkVerificationLevel) {
+                WorkVerificationLevel.NONE -> Contact.WorkVerificationLevel.NONE
+                WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED -> Contact.WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectWorkVerificationLevelUpdateData(
+            workVerificationLevel = newWorkVerificationLevel,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectWorkVerificationLevelUpdateData(
+            private val workVerificationLevel: WorkVerificationLevel,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectWorkVerificationLevelUpdate(
+                    workVerificationLevel,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new identity type.
+     */
+    class ReflectIdentityTypeUpdate(
+        private val newIdentityType: IdentityType,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type = "ReflectIdentityTypeUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData) =
+            currentData.identityType == newIdentityType
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            identityType = when (newIdentityType) {
+                IdentityType.NORMAL -> Contact.IdentityType.REGULAR
+                IdentityType.WORK -> Contact.IdentityType.WORK
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectIdentityTypeUpdateData(
+            identityType = newIdentityType,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectIdentityTypeUpdateData(
+            private val identityType: IdentityType,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectIdentityTypeUpdate(
+                    identityType,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new acquaintance level.
+     */
+    class ReflectAcquaintanceLevelUpdate(
+        private val newAcquaintanceLevel: AcquaintanceLevel,
+        contactIdentity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity,
+        contactModelRepository,
+        multiDeviceManager,
+        nonceFactory,
+    ) {
+        override val type = "ReflectAcquaintanceLevelUpdate"
+
+        override fun isChangeValid(currentData: ContactModelData): Boolean =
+            currentData.acquaintanceLevel == newAcquaintanceLevel
+
+        override fun getContactSync(): Contact = contact {
+            identity = contactIdentity
+            acquaintanceLevel = when (newAcquaintanceLevel) {
+                AcquaintanceLevel.DIRECT -> Contact.AcquaintanceLevel.DIRECT
+                AcquaintanceLevel.GROUP -> Contact.AcquaintanceLevel.GROUP
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectAcquaintanceLevelUpdateData(
+            acquaintanceLevel = newAcquaintanceLevel,
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectAcquaintanceLevelUpdateData(
+            private val acquaintanceLevel: AcquaintanceLevel,
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectAcquaintanceLevelUpdate(
+                    acquaintanceLevel,
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                )
+        }
+    }
+
+    /**
+     * Reflect a new user defined profile picture.
+     */
+    class ReflectUserDefinedProfilePictureUpdate(
+        identity: String,
+        contactModelRepository: ContactModelRepository,
+        multiDeviceManager: MultiDeviceManager,
+        nonceFactory: NonceFactory,
+        private val fileService: FileService,
+        private val symmetricEncryptionService: SymmetricEncryptionService,
+        private val apiService: ApiService,
+    ) : ReflectContactSyncUpdateTask(
+        contactIdentity = identity,
+        contactModelRepository = contactModelRepository,
+        multiDeviceManager = multiDeviceManager,
+        nonceFactory = nonceFactory,
+    ) {
+        override val type = "ReflectUserDefinedProfilePictureUpdate"
+
+        /**
+         * Note that we do always sync the currently set user defined profile picture. This is to
+         * prevent having to persist the whole profile picture. In the worst case, this can lead to
+         * the same profile picture uploaded twice: once from a reflected device and later from this
+         * device (if a race occurs).
+         */
+        override fun isChangeValid(currentData: ContactModelData) = true
+
+        override fun getContactSync(): Contact {
+            val userDefinedProfilePictureBytes =
+                fileService.getUserDefinedProfilePictureStream(contactIdentity)
+                    ?.buffered()
+                    ?.use { it.readBytes() }
+            return if (userDefinedProfilePictureBytes != null) {
+                val encryptionResult = symmetricEncryptionService.encrypt(
+                    userDefinedProfilePictureBytes,
+                    symmetricEncryptionService.generateSymmetricKey(),
+                    ProtocolDefines.CONTACT_PHOTO_NONCE
+                )
+                val blobId = apiService.createUploader(
+                    data = encryptionResult.data,
+                    shouldPersist = false,
+                    blobScope = BlobScope.Local,
+                ).upload()
+
+                checkNotNull(blobId) { "UploadCancelled" }
+
+                contact {
+                    identity = contactIdentity
+                    userDefinedProfilePicture = deltaImage {
+                        updated = image {
+                            type = Common.Image.Type.JPEG
+                            blob = blob {
+                                id = blobId.toByteString()
+                                nonce = ProtocolDefines.CONTACT_PHOTO_NONCE.toByteString()
+                                key = encryptionResult.key.toByteString()
+                            }
+                        }
+                    }
+                }
+            } else {
+                contact {
+                    identity = contactIdentity
+                    userDefinedProfilePicture = deltaImage {
+                        removed = unit { }
+                    }
+                }
+            }
+        }
+
+        override fun serialize(): SerializableTaskData = ReflectUserDefinedProfilePictureUpdateData(
+            identity = contactIdentity,
+        )
+
+        @Serializable
+        data class ReflectUserDefinedProfilePictureUpdateData(
+            private val identity: String,
+        ) : SerializableTaskData {
+            override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+                ReflectUserDefinedProfilePictureUpdate(
+                    identity,
+                    serviceManager.modelRepositories.contacts,
+                    serviceManager.multiDeviceManager,
+                    serviceManager.nonceFactory,
+                    serviceManager.fileService,
+                    serviceManager.symmetricEncryptionService,
+                    serviceManager.apiService,
+                )
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileNicknameSyncTask.kt b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileNicknameSyncTask.kt
new file mode 100644
index 00000000..b1676081
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileNicknameSyncTask.kt
@@ -0,0 +1,93 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TRANSACTION_TTL_MAX
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.createTransaction
+import ch.threema.domain.taskmanager.getEncryptedUserProfileSyncUpdate
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.protobuf.d2d.sync.userProfile
+import kotlinx.serialization.Serializable
+
+class ReflectUserProfileNicknameSyncTask(
+    private val newNickname: String,
+    serviceManager: ServiceManager
+) : ActiveTask<Unit>, PersistableTask {
+
+    private val identityStore by lazy { serviceManager.identityStore }
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
+    private val mdProperties by lazy { multiDeviceManager.propertiesProvider.get() }
+
+    override val type: String = "ReflectUserProfileNicknameSyncTask"
+
+    override suspend fun invoke(handle: ActiveTaskCodec) {
+        check(multiDeviceManager.isMultiDeviceActive) {
+            "Multi device is not active and a user profile nickname change must not be reflected"
+        }
+        handle.createTransaction(
+            keys = mdProperties.keys,
+            scope = MdD2D.TransactionScope.Scope.USER_PROFILE_SYNC,
+            ttl = TRANSACTION_TTL_MAX,
+        ).execute {
+            encryptAndReflectUserProfileUpdate(handle)
+        }
+        identityStore.persistPublicNickname(newNickname)
+    }
+
+    private suspend fun encryptAndReflectUserProfileUpdate(handle: ActiveTaskCodec) {
+        val encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult = getEncryptedUserProfileSyncUpdate(
+            userProfile = userProfile {
+                nickname = newNickname
+            },
+            mdProperties
+        )
+        handle.reflectAndAwaitAck(
+            encryptedEnvelopeResult = encryptedEnvelopeResult,
+            storeD2dNonce = true,
+            nonceFactory = nonceFactory
+        )
+    }
+
+    override fun serialize(): SerializableTaskData =
+        ReflectUserProfileNicknameSyncTaskData(
+            newNickname = newNickname
+        )
+
+    @Serializable
+    data class ReflectUserProfileNicknameSyncTaskData(
+        private val newNickname: String,
+    ) : SerializableTaskData {
+
+        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+            ReflectUserProfileNicknameSyncTask(
+                newNickname = newNickname,
+                serviceManager = serviceManager
+            )
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectUserProfilePictureSyncTask.kt b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfilePictureSyncTask.kt
new file mode 100644
index 00000000..8dc2605f
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfilePictureSyncTask.kt
@@ -0,0 +1,114 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.services.UserService
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TRANSACTION_TTL_MAX
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.createTransaction
+import ch.threema.domain.taskmanager.getEncryptedUserProfileSyncUpdate
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.blob
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.protobuf.d2d.sync.userProfile
+import ch.threema.protobuf.deltaImage
+import ch.threema.protobuf.image
+import ch.threema.protobuf.unit
+import ch.threema.storage.models.ContactModel
+import com.google.protobuf.kotlin.toByteString
+import kotlinx.serialization.Serializable
+
+/**
+ * This task just reflects the currently stored user profile picture. This is a simple mechanism
+ * that is not optimal when other devices also support user profile picture changes as in case of a
+ * sync race condition a reflected profile picture may be reflected back. The advantage of this
+ * approach is its simplicity and the fact that this task can be scheduled and run without causing
+ * any damage.
+ */
+class ReflectUserProfilePictureSyncTask(
+    private val userService: UserService,
+    private val nonceFactory: NonceFactory,
+    private val multiDeviceManager: MultiDeviceManager,
+) : ActiveTask<Unit>, PersistableTask {
+
+    private val mdProperties by lazy { multiDeviceManager.propertiesProvider.get() }
+
+    override val type = "ReflectUserProfilePictureSyncTask"
+
+    override suspend fun invoke(handle: ActiveTaskCodec) {
+        check(multiDeviceManager.isMultiDeviceActive) {
+            "Multi device is not active and a user profile picture must not be reflected"
+        }
+
+        val profilePictureUploadData = userService.uploadUserProfilePictureOrGetPreviousUploadData()
+
+        val profilePictureUpdate = deltaImage {
+            if (profilePictureUploadData.blobId.contentEquals(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)) {
+                removed = unit { }
+            } else {
+                updated = image {
+                    type = Common.Image.Type.JPEG
+                    blob = blob {
+                        id = profilePictureUploadData.blobId.toByteString()
+                        nonce = ProtocolDefines.CONTACT_PHOTO_NONCE.toByteString()
+                        key = profilePictureUploadData.encryptionKey.toByteString()
+                        uploadedAt = profilePictureUploadData.uploadedAt
+                    }
+                }
+            }
+        }
+
+        handle.createTransaction(
+            keys = mdProperties.keys,
+            scope = MdD2D.TransactionScope.Scope.USER_PROFILE_SYNC,
+            ttl = TRANSACTION_TTL_MAX,
+        ).execute {
+            val encryptedEnvelopeResult = getEncryptedUserProfileSyncUpdate(
+                userProfile = userProfile {
+                    profilePicture = profilePictureUpdate
+                },
+                mdProperties,
+            )
+
+            handle.reflectAndAwaitAck(encryptedEnvelopeResult, true, nonceFactory)
+        }
+    }
+
+    override fun serialize(): SerializableTaskData = ReflectUserProfilePictureSyncTaskData
+
+    @Serializable
+    data object ReflectUserProfilePictureSyncTaskData : SerializableTaskData {
+        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
+            ReflectUserProfilePictureSyncTask(
+                serviceManager.userService,
+                serviceManager.nonceFactory,
+                serviceManager.multiDeviceManager,
+            )
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithAllowListSyncTask.kt b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithAllowListSyncTask.kt
new file mode 100644
index 00000000..2fb34ca2
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithAllowListSyncTask.kt
@@ -0,0 +1,79 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.services.ContactService.ProfilePictureSharePolicy.Policy
+import ch.threema.app.services.PreferenceService
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.protobuf.d2d.sync.MdD2DSync
+import ch.threema.protobuf.d2d.sync.UserProfileKt.profilePictureShareWith
+import ch.threema.protobuf.d2d.sync.userProfile
+import ch.threema.protobuf.identities
+import kotlinx.serialization.Serializable
+
+/**
+ *
+ * Sync the profile picture sharing policy of type [Policy.ALLOW_LIST] with its allowed identities into the device group.
+ *
+ * @param allowedIdentities Will be sent to the device group in a transaction and saved additionally after the transaction was committed.
+ * Any empty list can be passed here as specified by the protocol.
+ */
+class ReflectUserProfileShareWithAllowListSyncTask(
+    private val allowedIdentities: List<String>,
+    serviceManager: ServiceManager
+) : ReflectUserProfileShareWithPolicySyncTaskBase(
+    newPolicy = Policy.ALLOW_LIST,
+    serviceManager = serviceManager
+) {
+    override val type = "ReflectUserProfileShareWithAllowListSyncTask"
+
+    private val profilePicRecipientsService by lazy { serviceManager.profilePicRecipientsService }
+
+    override fun createUpdatedUserProfile(): MdD2DSync.UserProfile = userProfile {
+        this.profilePictureShareWith = profilePictureShareWith {
+            this.allowList = identities {
+                this.identities.addAll(allowedIdentities)
+            }
+        }
+    }
+
+    override fun persistLocally(preferenceService: PreferenceService) {
+        super.persistLocally(preferenceService)
+        profilePicRecipientsService.replaceAll(allowedIdentities.toTypedArray<String>())
+    }
+
+    override fun serialize(): SerializableTaskData = ReflectUserProfileShareWithAllowListSyncTaskData(allowedIdentities)
+
+    @Serializable
+    data class ReflectUserProfileShareWithAllowListSyncTaskData(
+        val allowedIdentities: List<String>
+    ) : SerializableTaskData {
+        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> {
+            return ReflectUserProfileShareWithAllowListSyncTask(
+                allowedIdentities = allowedIdentities,
+                serviceManager = serviceManager
+            )
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTask.kt b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTask.kt
new file mode 100644
index 00000000..67137605
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTask.kt
@@ -0,0 +1,85 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.services.ContactService.ProfilePictureSharePolicy.Policy
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.protobuf.d2d.sync.MdD2DSync
+import ch.threema.protobuf.d2d.sync.UserProfileKt.profilePictureShareWith
+import ch.threema.protobuf.d2d.sync.userProfile
+import ch.threema.protobuf.unit
+import kotlinx.serialization.Serializable
+
+/**
+ *
+ * Sync the profile picture sharing policy setting into the device group.
+ *
+ * @param newPolicy Will be sent to the device group in a transaction and saved additionally after the transaction was committed.
+ * The value can be one of [Policy.EVERYONE] or [Policy.NOBODY]. In case this task is created with policy [Policy.ALLOW_LIST] an exception
+ * will be thrown by the constructor. One should use the more specific task [ReflectUserProfileShareWithAllowListSyncTask] in this case.
+ *
+ * @throws IllegalStateException if the policy is [Policy.ALLOW_LIST]
+ */
+class ReflectUserProfileShareWithPolicySyncTask(
+    newPolicy: Policy,
+    serviceManager: ServiceManager
+) : ReflectUserProfileShareWithPolicySyncTaskBase(
+    newPolicy = newPolicy,
+    serviceManager = serviceManager
+) {
+
+    override val type = "ReflectUserProfileShareWithPolicySyncTask"
+
+    init {
+        check(newPolicy != Policy.ALLOW_LIST) {
+            "This task does not support policy of type ALLOW_LIST. Use the more specific task in that case."
+        }
+    }
+
+    override fun createUpdatedUserProfile(): MdD2DSync.UserProfile = userProfile {
+        this.profilePictureShareWith = profilePictureShareWith {
+            when (newPolicy) {
+                Policy.NOBODY -> this.nobody = unit {}
+                Policy.EVERYONE -> this.everyone = unit {}
+                Policy.ALLOW_LIST -> throw IllegalStateException(
+                    "This task does not support policy of type ALLOW_LIST. Use the more specific task in that case."
+                )
+            }
+        }
+    }
+
+    override fun serialize(): SerializableTaskData = ReflectUserProfileShareWithPolicySyncTaskData(newPolicy)
+
+    @Serializable
+    data class ReflectUserProfileShareWithPolicySyncTaskData(
+        val newPolicy: Policy
+    ) : SerializableTaskData {
+        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> {
+            return ReflectUserProfileShareWithPolicySyncTask(
+                newPolicy = newPolicy,
+                serviceManager = serviceManager
+            )
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTaskBase.kt b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTaskBase.kt
new file mode 100644
index 00000000..3eaea266
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTaskBase.kt
@@ -0,0 +1,78 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.tasks
+
+import androidx.annotation.CallSuper
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.services.ContactService.ProfilePictureSharePolicy
+import ch.threema.app.services.PreferenceService
+import ch.threema.domain.taskmanager.ActiveTask
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TRANSACTION_TTL_MAX
+import ch.threema.domain.taskmanager.createTransaction
+import ch.threema.domain.taskmanager.getEncryptedUserProfileSyncUpdate
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.protobuf.d2d.sync.MdD2DSync
+
+abstract class ReflectUserProfileShareWithPolicySyncTaskBase(
+    protected val newPolicy: ProfilePictureSharePolicy.Policy,
+    serviceManager: ServiceManager
+) : ActiveTask<Unit>, PersistableTask {
+
+    private val nonceFactory by lazy { serviceManager.nonceFactory }
+    private val multiDeviceManager by lazy { serviceManager.multiDeviceManager }
+    private val mdProperties by lazy { multiDeviceManager.propertiesProvider.get() }
+    private val preferenceService by lazy { serviceManager.preferenceService }
+
+    abstract fun createUpdatedUserProfile(): MdD2DSync.UserProfile
+
+    override suspend fun invoke(handle: ActiveTaskCodec) {
+        check(multiDeviceManager.isMultiDeviceActive) {
+            "Multi device is not active and a user profile picture policy change must not be reflected"
+        }
+        handle.createTransaction(
+            keys = mdProperties.keys,
+            scope = MdD2D.TransactionScope.Scope.USER_PROFILE_SYNC,
+            ttl = TRANSACTION_TTL_MAX,
+        ).execute {
+            encryptAndReflectUserProfileUpdate(handle)
+        }
+        persistLocally(preferenceService)
+    }
+
+    private suspend fun encryptAndReflectUserProfileUpdate(handle: ActiveTaskCodec) {
+        val encryptedEnvelopeResult = getEncryptedUserProfileSyncUpdate(
+            userProfile = createUpdatedUserProfile(),
+            multiDeviceProperties = mdProperties
+        )
+        handle.reflectAndAwaitAck(
+            encryptedEnvelopeResult = encryptedEnvelopeResult,
+            storeD2dNonce = true,
+            nonceFactory = nonceFactory
+        )
+    }
+
+    @CallSuper
+    open fun persistLocally(preferenceService: PreferenceService) {
+        preferenceService.profilePicRelease = newPolicy.ordinal
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt
index 14eed5f4..3c55673c 100644
--- a/app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt
+++ b/app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt
@@ -28,7 +28,6 @@ import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
 import ch.threema.storage.models.ContactModel
 import kotlinx.serialization.Serializable
-import java.util.Arrays
 
 private val logger = LoggingUtil.getThreemaLogger("SendProfilePictureTask")
 
@@ -43,13 +42,13 @@ class SendProfilePictureTask(private val toIdentity: String, serviceManager: Ser
     override val type: String = "SendProfilePictureTask"
 
     override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val data = contactService.updatedProfilePictureUploadData
+        val data = userService.uploadUserProfilePictureOrGetPreviousUploadData()
         if (data.blobId == null) {
             logger.warn("Blob ID is null; cannot send profile picture")
             return
         }
 
-        return if (Arrays.equals(data.blobId, ContactModel.NO_PROFILE_PICTURE_BLOB_ID)) {
+        return if (data.blobId.contentEquals(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)) {
             sendDeleteProfilePictureMessage(toIdentity, handle)
         } else {
             sendSetProfilePictureMessage(data, toIdentity, handle)
diff --git a/app/src/main/java/ch/threema/app/tasks/TaskCreator.kt b/app/src/main/java/ch/threema/app/tasks/TaskCreator.kt
index af7c4ac1..6beedd33 100644
--- a/app/src/main/java/ch/threema/app/tasks/TaskCreator.kt
+++ b/app/src/main/java/ch/threema/app/tasks/TaskCreator.kt
@@ -23,6 +23,8 @@ package ch.threema.app.tasks
 
 import ch.threema.app.managers.ServiceManager
 import ch.threema.domain.models.Contact
+import ch.threema.domain.protocol.connection.data.DeviceId
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
 import ch.threema.domain.taskmanager.Task
 import ch.threema.domain.taskmanager.TaskCodec
 import ch.threema.protobuf.csp.e2e.fs.Terminate.Cause
@@ -34,10 +36,6 @@ class TaskCreator(private val serviceManager: ServiceManager) {
             SendProfilePictureTask(toIdentity, serviceManager)
         }
 
-    fun scheduleProfilePictureExecution(toIdentity: String): Deferred<Unit> = scheduleTaskAsync {
-        ProfilePictureDistributionTask(toIdentity, serviceManager)
-    }
-
     fun scheduleDeleteAndTerminateFSSessionsTaskAsync(
         contact: Contact,
         cause: Cause,
@@ -53,6 +51,47 @@ class TaskCreator(private val serviceManager: ServiceManager) {
     fun scheduleSendPushTokenTask(token: String, type: Int): Deferred<Unit> =
         scheduleTaskAsync { SendPushTokenTask(token, type, serviceManager) }
 
+    fun scheduleDeviceLinkingTask(
+        deviceJoinOfferUri: String,
+        cancelSignal: Deferred<Unit>
+    ): Pair<DeviceLinkingController, Deferred<Result<Unit>>> {
+        return DeviceLinkingTask(deviceJoinOfferUri, serviceManager, cancelSignal).let {
+            it.deviceLinkingController to scheduleTaskAsync { it }
+        }
+    }
+
+    fun scheduleGetDevicesInfoTask(): Deferred<InboundD2mMessage.DevicesInfo> = scheduleTaskAsync {
+        GetDevicesInfoTask()
+    }
+
+    fun scheduleDropDeviceTask(deviceId: DeviceId): Deferred<Unit> = scheduleTaskAsync {
+        DropDeviceTask(deviceId)
+    }
+
+    fun scheduleDeleteDeviceGroupTask(): Deferred<Unit> = scheduleTaskAsync {
+        DeleteDeviceGroupTask(serviceManager)
+    }
+
+    fun scheduleUserDefinedProfilePictureUpdate(identity: String) = scheduleTaskAsync {
+        ReflectContactSyncUpdateTask.ReflectUserDefinedProfilePictureUpdate(
+            identity = identity,
+            contactModelRepository = serviceManager.modelRepositories.contacts,
+            multiDeviceManager = serviceManager.multiDeviceManager,
+            nonceFactory = serviceManager.nonceFactory,
+            fileService = serviceManager.fileService,
+            symmetricEncryptionService = serviceManager.symmetricEncryptionService,
+            apiService = serviceManager.apiService,
+        )
+    }
+
+    fun scheduleReflectUserProfilePictureTask() = scheduleTaskAsync {
+        ReflectUserProfilePictureSyncTask(
+            serviceManager.userService,
+            serviceManager.nonceFactory,
+            serviceManager.multiDeviceManager,
+        )
+    }
+
     private fun <R> scheduleTaskAsync(createTask: () -> Task<R, TaskCodec>): Deferred<R> {
         return serviceManager.taskManager.schedule(createTask())
     }
diff --git a/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java b/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java
index 28a3255e..32ce4849 100644
--- a/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java
@@ -32,14 +32,6 @@ import android.view.Display;
 import android.view.WindowManager;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.work.ExistingPeriodicWorkPolicy;
-import androidx.work.ExistingWorkPolicy;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.PeriodicWorkRequest;
-import androidx.work.WorkManager;
-
 import com.neilalexander.jnacl.NaCl;
 
 import org.bouncycastle.crypto.generators.SCrypt;
@@ -65,6 +57,7 @@ import java.util.Arrays;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.zip.Deflater;
@@ -72,12 +65,20 @@ import java.util.zip.GZIPInputStream;
 
 import javax.net.ssl.HttpsURLConnection;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.work.ExistingPeriodicWorkPolicy;
+import androidx.work.ExistingWorkPolicy;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.PeriodicWorkRequest;
+import androidx.work.WorkManager;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.services.ApiService;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeadlineListService;
@@ -93,6 +94,7 @@ import ch.threema.app.stores.PreferenceStoreInterface;
 import ch.threema.app.utils.AppRestrictionUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.GzipOutputStream;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.StringConversionUtil;
@@ -103,6 +105,7 @@ import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.Base64;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
@@ -111,6 +114,7 @@ import ch.threema.domain.protocol.ProtocolStrings;
 import ch.threema.domain.protocol.ServerAddressProvider;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.ContactModelFactory;
 import ch.threema.storage.factories.DistributionListMemberModelFactory;
@@ -128,11 +132,13 @@ import static ch.threema.app.ThreemaApplication.WORKER_PERIODIC_THREEMA_SAFE_UPL
 import static ch.threema.app.ThreemaApplication.WORKER_THREEMA_SAFE_UPLOAD;
 import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_EVERYONE;
 import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_NOBODY;
-import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_SOME;
+import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST;
 import static ch.threema.app.threemasafe.ThreemaSafeConfigureActivity.EXTRA_OPEN_HOME_ACTIVITY;
 import static ch.threema.app.threemasafe.ThreemaSafeConfigureActivity.EXTRA_WORK_FORCE_PASSWORD;
 import static ch.threema.app.threemasafe.ThreemaSafeServerTestResponse.CONFIG_MAX_BACKUP_BYTES;
 import static ch.threema.app.threemasafe.ThreemaSafeServerTestResponse.CONFIG_RETENTION_DAYS;
+import static ch.threema.storage.models.GroupModel.UserState.LEFT;
+import static ch.threema.storage.models.GroupModel.UserState.MEMBER;
 
 public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("ThreemaSafeServiceImpl");
@@ -247,6 +253,8 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 	private final ServerAddressProvider serverAddressProvider;
 	@NonNull
 	private final PreferenceStoreInterface preferenceStore;
+	@NonNull
+	private final ContactModelRepository contactModelRepository;
 
 	public ThreemaSafeServiceImpl(
 		Context context,
@@ -266,7 +274,8 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		@NonNull APIConnector apiConnector,
 		DeadlineListService hiddenChatsListService,
 		@NonNull ServerAddressProvider serverAddressProvider,
-		@NonNull PreferenceStoreInterface preferenceStore
+		@NonNull PreferenceStoreInterface preferenceStore,
+		@NonNull ContactModelRepository contactModelRepository
 		) {
 		this.context = context;
 		this.preferenceService = preferenceService;
@@ -286,6 +295,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		this.hiddenChatsListService = hiddenChatsListService;
 		this.serverAddressProvider = serverAddressProvider;
 		this.preferenceStore = preferenceStore;
+		this.contactModelRepository = contactModelRepository;
 	}
 
 	@Override
@@ -816,7 +826,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 
 		ContactModel contactModel = contactService.getByIdentity(userService.getIdentity());
 		if (contactModel != null) {
-			userService.setPublicNickname(nickname);
+			userService.setPublicNickname(nickname, TriggerSource.LOCAL);
 
 
 			boolean isLinksRestricted = false;
@@ -847,7 +857,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 			String profilePic = user.optString(TAG_SAFE_USER_PROFILE_PIC, null);
 			if (profilePic != null) {
 				try {
-					contactService.setAvatar(contactModel, Base64.decode(profilePic));
+					contactService.setUserDefinedProfilePicture(contactModel, Base64.decode(profilePic), TriggerSource.LOCAL);
 				} catch (Exception e) {
 					// base 64 decoding or avatar setting failed - forget about the pic
 				}
@@ -855,7 +865,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 
 			JSONArray profilePicRelease = user.optJSONArray(TAG_SAFE_USER_PROFILE_PIC_RELEASE);
 			if (profilePicRelease != null) {
-				preferenceService.setProfilePicRelease(PROFILEPIC_RELEASE_SOME);
+				preferenceService.setProfilePicRelease(PROFILEPIC_RELEASE_ALLOW_LIST);
 
 				for (int i = 0; i < profilePicRelease.length(); i++) {
 					String id = profilePicRelease.getString(i);
@@ -937,7 +947,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 			return;
 		}
 
-		ArrayList<APIConnector.FetchIdentityResult> results;
+		List<APIConnector.FetchIdentityResult> results;
 		try {
 			results = this.apiConnector.fetchIdentities(identities);
 		}
@@ -978,16 +988,12 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 							default:
 								logger.warn("Identity fetch returned invalid identity type: {}", result.type);
 						}
-						switch (result.state) {
-							case IdentityState.ACTIVE:
-								contactModel.setState(ContactModel.State.ACTIVE);
-								break;
-							case IdentityState.INACTIVE:
-								contactModel.setState(ContactModel.State.INACTIVE);
-								break;
-							case IdentityState.INVALID:
-								contactModel.setState(ContactModel.State.INVALID);
-								break;
+						if (result.state == IdentityState.ACTIVE.getValue()) {
+							contactModel.setState(IdentityState.ACTIVE);
+						} else if (result.state == IdentityState.INACTIVE.getValue()) {
+							contactModel.setState(IdentityState.INACTIVE);
+						} else if (result.state == IdentityState.INVALID.getValue()) {
+							contactModel.setState(IdentityState.INVALID);
 						}
 						contactModel.setIsWork(contact.optBoolean(TAG_SAFE_CONTACT_WORK_VERIFIED));
 						contactModel.setFirstName(contact.optString(TAG_SAFE_CONTACT_FIRST_NAME));
@@ -1011,7 +1017,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 						contactModelFactory.createOrUpdate(contactModel);
 
 						if (contact.optBoolean(TAG_SAFE_CONTACT_PRIVATE, false)) {
-							hiddenChatsListService.add(contactService.getUniqueIdString(contactModel), DeadlineListService.DEADLINE_INDEFINITE);
+							hiddenChatsListService.add(ContactUtil.getUniqueIdString(contactModel.getIdentity()), DeadlineListService.DEADLINE_INDEFINITE);
 						}
 					}
 				}
@@ -1046,7 +1052,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 					groupModel.setDeleted(group.getBoolean(TAG_SAFE_GROUP_DELETED));
 					groupModel.setSynchronizedAt(new Date(0));
 					if (!group.isNull(TAG_SAFE_GROUP_LAST_UPDATE)) {
-						final long lastUpdate = group.getLong("lastUpdate");
+						final long lastUpdate = group.getLong(TAG_SAFE_GROUP_LAST_UPDATE);
 						groupModel.setLastUpdate(new Date(lastUpdate));
 					}
 
@@ -1055,27 +1061,48 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 							hiddenChatsListService.add(this.groupService.getUniqueIdString(groupModel), DeadlineListService.DEADLINE_INDEFINITE);
 						}
 
+						String myIdentity = userService.getIdentity();
+						boolean isMember = false;
+
 						JSONArray members = group.getJSONArray(TAG_SAFE_GROUP_MEMBERS);
 						for (int j = 0; j < members.length(); j++) {
 							String identity = members.getString(j);
 							if (!TestUtil.isEmptyOrNull(identity)) {
 								if (contactService.getByIdentity(identity) == null) {
-									// fetch group contact if not in contact list
-									try {
-										contactService.createContactByIdentity(identity, true, AcquaintanceLevel.GROUP);
-									} catch (InvalidEntryException | EntryAlreadyExistsException | PolicyViolationException e) {
-										// do not add as group member if contact cannot be created
+									// Fetch group contact if not in contact list. Note that we do
+									// not add the contact to the group if it couldn't be created.
+									ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+										identity,
+										AcquaintanceLevel.GROUP,
+										myIdentity,
+										apiConnector,
+										contactModelRepository,
+										AddContactRestrictionPolicy.IGNORE,
+										context,
+										null
+									).runSynchronously();
+
+									if (!(result instanceof ContactAvailable)) {
+										logger.error("Contact {} could not be created", identity);
 										continue;
 									}
 								}
 
-								GroupMemberModel groupMemberModel = new GroupMemberModel();
-								groupMemberModel.setGroupId(groupModel.getId());
-								groupMemberModel.setIdentity(identity);
+								if (identity.equals(myIdentity)) {
+									isMember = true;
+								} else {
+									// Only create a group member model if it is not the user itself
+									GroupMemberModel groupMemberModel = new GroupMemberModel();
+									groupMemberModel.setGroupId(groupModel.getId());
+									groupMemberModel.setIdentity(identity);
 
-								groupMemberModelFactory.create(groupMemberModel);
+									groupMemberModelFactory.create(groupMemberModel);
+								}
 							}
 						}
+
+						groupModel.setUserState(isMember ? MEMBER : LEFT);
+						groupModelFactory.update(groupModel);
 					}
 				}
 			} catch (JSONException | NullPointerException e){
@@ -1123,11 +1150,21 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 					String identity = members.getString(j);
 					if (!TestUtil.isEmptyOrNull(identity)) {
 						if (contactService.getByIdentity(identity) == null) {
-							// fetch contact if not in contact list
-							try {
-								contactService.createContactByIdentity(identity, true, AcquaintanceLevel.GROUP);
-							} catch (InvalidEntryException | EntryAlreadyExistsException | PolicyViolationException e) {
-								// do not add as distribution list member if contact cannot be created
+							// Fetch contact if not in contact list. Note that we do not add the
+							// contact to the distribution list if it couldn't be created.
+							ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+								identity,
+								AcquaintanceLevel.DIRECT,
+								userService.getIdentity(),
+								apiConnector,
+								contactModelRepository,
+								AddContactRestrictionPolicy.IGNORE,
+								context,
+								null
+							).runSynchronously();
+
+							if (!(result instanceof ContactAvailable)) {
+								logger.error("Contact {} could not be created", identity);
 								continue;
 							}
 						}
@@ -1331,7 +1368,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 
 		contact.put(TAG_SAFE_CONTACT_IDENTITY, contactModel.getIdentity());
 		boolean contactIsVerified = contactModel.verificationLevel == VerificationLevel.FULLY_VERIFIED;
-		boolean contactIsRevoked = contactModel.getState() == ContactModel.State.INVALID;
+		boolean contactIsRevoked = contactModel.getState() == IdentityState.INVALID;
 		if (contactIsVerified || contactIsRevoked) {
 			// Back up the public key if the contact is verified, or if it's revoked.
 			//
@@ -1358,7 +1395,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		contact.put(TAG_SAFE_CONTACT_HIDDEN, contactModel.getAcquaintanceLevel() == AcquaintanceLevel.GROUP);
 		contact.put(TAG_SAFE_CONTACT_TYPING_INDICATORS, contactModel.getTypingIndicators());
 		contact.put(TAG_SAFE_CONTACT_READ_RECEIPTS, contactModel.getReadReceipts());
-		contact.put(TAG_SAFE_CONTACT_PRIVATE, hiddenChatsListService.has(contactService.getUniqueIdString(contactModel)));
+		contact.put(TAG_SAFE_CONTACT_PRIVATE, hiddenChatsListService.has(ContactUtil.getUniqueIdString(contactModel.getIdentity())));
 
 		return contact;
 	}
@@ -1375,11 +1412,13 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		return contactsArray;
 	}
 
-	private JSONArray getGroupMembers(String[] groupMembers) {
+	private JSONArray getGroupMembers(String[] groupMembers, @Nullable String ignoreIdentity) {
 		JSONArray membersArray = new JSONArray();
 
 		for (final String groupMember : groupMembers) {
-			membersArray.put(groupMember);
+			if (!groupMember.equals(ignoreIdentity)) {
+				membersArray.put(groupMember);
+			}
 		}
 
 		return membersArray;
@@ -1398,7 +1437,15 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		} else {
 			group.put(TAG_SAFE_GROUP_CREATED_AT, 0);
 		}
-		group.put(TAG_SAFE_GROUP_MEMBERS, getGroupMembers(this.groupService.getGroupIdentities(groupModel)));
+		JSONArray groupMembers;
+		if (groupModel.getUserState() == MEMBER) {
+			// In case the user is a member, we should include the user in the list
+			groupMembers = getGroupMembers(this.groupService.getGroupIdentities(groupModel), null);
+		} else {
+			// If the user is no member, we do not include the user's identity
+			groupMembers = getGroupMembers(this.groupService.getGroupIdentities(groupModel), userService.getIdentity());
+		}
+		group.put(TAG_SAFE_GROUP_MEMBERS, groupMembers);
 		group.put(TAG_SAFE_GROUP_DELETED, groupModel.isDeleted());
 		if (groupModel.getLastUpdate() != null) {
 			group.put(TAG_SAFE_GROUP_LAST_UPDATE, groupModel.getLastUpdate().getTime());
@@ -1519,7 +1566,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		user.put(TAG_SAFE_USER_NICKNAME, userService.getPublicNickname());
 
 		try {
-			Bitmap image = fileService.getContactAvatar(contactService.getMe().getIdentity());
+			Bitmap image = fileService.getUserDefinedProfilePicture(contactService.getMe().getIdentity());
 			if (image != null) {
 				// scale image - assume profile pics are always square
 				if (Math.max(image.getWidth(), image.getHeight()) > PROFILEPIC_MAX_WIDTH) {
@@ -1531,7 +1578,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 					case PROFILEPIC_RELEASE_EVERYONE:
 						profilePicRelease.put(PROFILE_PIC_RELEASE_ALL_PLACEHOLDER);
 						break;
-					case PROFILEPIC_RELEASE_SOME:
+					case PROFILEPIC_RELEASE_ALLOW_LIST:
 						for (String id: profilePicRecipientsService.getAll()) {
 							profilePicRelease.put(id);
 						}
diff --git a/app/src/main/java/ch/threema/app/ui/AckjiPopup.java b/app/src/main/java/ch/threema/app/ui/AckjiPopup.java
index 1ff706ba..6caebd5d 100644
--- a/app/src/main/java/ch/threema/app/ui/AckjiPopup.java
+++ b/app/src/main/java/ch/threema/app/ui/AckjiPopup.java
@@ -133,7 +133,7 @@ AckjiPopup extends PopupWindow implements View.OnClickListener {
                     if (!isMember) {
                         this.editButton.setVisibility(View.GONE);
                     }
-                    if (!isMember || groupService.getOtherMemberCount(groupModel) < 1) {
+                    if (!isMember || groupService.countMembersWithoutUser(groupModel) < 1) {
                         this.decButton.setVisibility(View.GONE);
                         this.ackButton.setVisibility(View.GONE);
                     }
diff --git a/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt b/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt
index bd469ee0..eea6410b 100644
--- a/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt
+++ b/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt
@@ -51,8 +51,9 @@ import ch.threema.storage.models.AbstractMessageModel
 import kotlin.math.min
 import kotlin.math.roundToInt
 
+private val logger = LoggingUtil.getThreemaLogger("AudioProgressBarView")
+
 class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWaveformGeneratorTask.AudioWaveformGeneratorListener {
-    private val logger = LoggingUtil.getThreemaLogger("AudioProgressBarView")
 
     private var barHeight = 20
     private var barWidth = 5
@@ -62,7 +63,7 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
     private var state = 0
 
     private lateinit var barColor: ColorStateList
-    var barColorActivated = Color.TRANSPARENT
+    private var barColorActivated = Color.TRANSPARENT
     private lateinit var barPaint: Paint
     private lateinit var barPaintChecked: Paint
     private lateinit var barPaintActivated: Paint
@@ -76,8 +77,7 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
     private var messageModel: AbstractMessageModel? = null
     private var changeBounds: Transition = ChangeClipBounds()
 
-    // we calculate a sufficiently large number of samples upfront so we don't need to wait for onLayout
-    private val numPreCalculatedSamples = 30
+    private var numPreCalculatedSamples: Int = 0
 
     // radius of bar edges in px
     private val radius = 2F
@@ -107,6 +107,8 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
             recycle()
         }
 
+        numPreCalculatedSamples = guessSuitableAmountOfSamples(context)
+
         barPaint = Paint().apply {
             isAntiAlias = true
             color = if (Build.VERSION.SDK_INT >= 23) {
@@ -194,7 +196,16 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
         super.onDraw(canvas)
     }
 
-    private fun createEmptyBitmap() : Bitmap {
+    /**
+     *  We calculate a sufficiently large number of samples upfront so we don't need to wait for onLayout
+     *  to tell us the width of our view.
+     *  The number will adapt based on the devices screen width. Because on tablets we want to present more samples.
+     */
+    private fun guessSuitableAmountOfSamples(context: Context): Int {
+        return (30f + (context.resources.displayMetrics.widthPixels / 40f)).roundToInt()
+    }
+
+    private fun createEmptyBitmap(): Bitmap {
         val tmpBitmap = Bitmap.createBitmap(viewWidth, barHeight, Bitmap.Config.ARGB_8888)
         val unusedHeight: Float = (barHeight / 2F) - halfBarMinHeight
         val halfSpace = spaceWidth.toFloat() / 2F
@@ -202,23 +213,27 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
         for (i: Int in 0 until numSamples) {
             tmpBitmap.applyCanvas {
                 drawRoundRect(
-                        RectF(
-                                halfSpace + (i * (barWidth + spaceWidth)),
-                                unusedHeight,
-                                halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
-                                barHeight - unusedHeight
-                        ),
-                        radius,
-                        radius,
-                        barPaint
+                    RectF(
+                        halfSpace + (i * (barWidth + spaceWidth)),
+                        unusedHeight,
+                        halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
+                        barHeight - unusedHeight
+                    ),
+                    radius,
+                    radius,
+                    barPaint
                 )
             }
         }
         return tmpBitmap
     }
 
-    private fun createWaveformBitmap(samplesData: List<Float>) : Bitmap {
+    private fun createWaveformBitmap(samplesData: List<Float>): Bitmap {
         val tmpBitmap = Bitmap.createBitmap(viewWidth, barHeight, Bitmap.Config.ARGB_8888)
+        if (samplesData.size < numSamples) {
+            logger.warn("Insufficient amount of calculated samples: {} < {}", samplesData.size, numSamples)
+            return tmpBitmap
+        }
         val factor: Float = samplesData.size.toFloat() / numSamples.toFloat()
         val halfSpace = spaceWidth.toFloat() / 2F
         val halfBarHeight = barHeight / 2F
@@ -229,15 +244,15 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
 
             tmpBitmap.applyCanvas {
                 drawRoundRect(
-                        RectF(
-                                halfSpace + (i * (barWidth + spaceWidth)),
-                                unusedHeight,
-                                halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
-                                barHeight - unusedHeight
-                        ),
-                        radius,
-                        radius,
-                        barPaint
+                    RectF(
+                        halfSpace + (i * (barWidth + spaceWidth)),
+                        unusedHeight,
+                        halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
+                        barHeight - unusedHeight
+                    ),
+                    radius,
+                    radius,
+                    barPaint
                 )
             }
         }
@@ -302,11 +317,11 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
 
         if (messageModel?.id != newMessageModel.id) {
             // recycled view
-            waveFormTask?.let {
-                if (it.getMessageId() == newMessageModel.id) {
+            waveFormTask?.let { task ->
+                if (task.getMessageId() == newMessageModel.id) {
                     return
                 } else {
-                    it.cancel()
+                    task.cancel()
                 }
             }
         }
@@ -319,17 +334,19 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
             postInvalidate()
             visibility = VISIBLE
         } else {
-            waveFormTask?.let {
-                if (it.getMessageId() == newMessageModel.id) {
+            waveFormTask?.let { task ->
+                if (task.getMessageId() == newMessageModel.id) {
                     return
                 }
             }
 
             waveBitmap = null
             messageModel = newMessageModel
-            waveFormTask = AudioWaveformGeneratorTask(newMessageModel,
-                    numPreCalculatedSamples,
-                    this@AudioProgressBarView)
+            waveFormTask = AudioWaveformGeneratorTask(
+                newMessageModel,
+                numPreCalculatedSamples,
+                this@AudioProgressBarView
+            )
 
             ThreemaApplication.voiceMessageThumbnailExecutorService.execute(Thread(waveFormTask, "WaveformGenerator"))
         }
diff --git a/app/src/main/java/ch/threema/app/ui/AvatarEditView.java b/app/src/main/java/ch/threema/app/ui/AvatarEditView.java
index 22e48fac..ba2c0e50 100644
--- a/app/src/main/java/ch/threema/app/ui/AvatarEditView.java
+++ b/app/src/main/java/ch/threema/app/ui/AvatarEditView.java
@@ -85,10 +85,12 @@ import ch.threema.app.glide.AvatarOptions;
 import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.listeners.ProfileListener;
 import ch.threema.app.managers.ListenerManager;
+import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.FileService;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.PreferenceService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.AvatarConverterUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ColorUtil;
@@ -99,6 +101,7 @@ import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
 
@@ -109,6 +112,7 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 	private static final int REQUEST_CODE_CAMERA = 43322;
 	private static final int REQUEST_CODE_CROP = 43323;
 	private static final String DIALOG_TAG_SAMSUNG_FIX = "samsung_fix";
+    private UserService userService;
 	private ContactService contactService;
 	private GroupService groupService;
 	private FileService fileService;
@@ -153,10 +157,12 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 		avatarData = new ViewModelProvider(getActivity()).get(AvatarEditViewModel.class);
 
 		try {
-			contactService = ThreemaApplication.getServiceManager().getContactService();
-			groupService = ThreemaApplication.getServiceManager().getGroupService();
-			fileService = ThreemaApplication.getServiceManager().getFileService();
-			preferenceService = ThreemaApplication.getServiceManager().getPreferenceService();
+            ServiceManager serviceManager = ThreemaApplication.requireServiceManager();
+            userService = serviceManager.getUserService();
+			contactService = serviceManager.getContactService();
+			groupService = serviceManager.getGroupService();
+			fileService = serviceManager.getFileService();
+			preferenceService = serviceManager.getPreferenceService();
 		} catch (Exception e) {
 			logger.error("Exception", e);
 			return;
@@ -179,7 +185,8 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 
 	private final ContactListener contactListener = new ContactListener() {
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
+            ContactModel contactModel = contactService.getByIdentity(identity);
 			if (contactModel != null && this.shouldHandleChange(contactModel.getIdentity())) {
 				RuntimeUtil.runOnUiThread(() -> loadAvatarForModel(contactModel, null));
 			}
@@ -229,19 +236,20 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 
 		try {
 			if (contactModel != null) {
-				// Get the custom avatar (or null if no custom avatar available)
-				Bitmap bitmap = getCustomContactAvatar(contactModel);
-				boolean isCustomAvatar = true;
-				if (bitmap == null) {
-					// Get default avatar as no custom avatar is available
-					bitmap = contactService.getAvatar(contactModel, new AvatarOptions.Builder()
-						.setHighRes(true)
-						.setReturnPolicy(AvatarOptions.DefaultAvatarPolicy.DEFAULT_FALLBACK)
-						.setDarkerBackground(isAvatarEditable())
-						.toOptions()
-					);
-					isCustomAvatar = false;
-				}
+				// Respect the settings for getting the profile picture.
+				Bitmap bitmap = contactService.getAvatar(contactModel, new AvatarOptions.Builder()
+					.setHighRes(true)
+					.setReturnPolicy(AvatarOptions.DefaultAvatarPolicy.DEFAULT_FALLBACK)
+					.setDarkerBackground(isAvatarEditable())
+					.toOptions()
+				);
+
+				// If the preferences allow showing the profile pictures, then check if there is a
+				// profile picture available for the contact. Otherwise, check whether there is a
+				// locally saved avatar.
+				boolean isCustomAvatar =
+					(preferenceService.getProfilePicReceive() && fileService.hasContactDefinedProfilePicture(contactModel.getIdentity()))
+						|| fileService.hasUserDefinedProfilePicture(contactModel.getIdentity());
 
 				// If it is my profile picture then make it round
 				if (isMyProfilePicture) {
@@ -282,49 +290,6 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 		avatarEditOverlay.setVisibility(editable ? View.VISIBLE : View.GONE);
 	}
 
-	/**
-	 * Get the custom contact avatar. The size is automatically scaled down to the maximum possible
-	 * size if it was too large. Due to a bug in compression some avatars may be too large and then
-	 * the application crashes when displaying them in full size.
-	 *
-	 * Updates the avatar if it needs to be resized (only if it is my profile picture).
-	 *
-	 * If there is no custom avatar set for the contact, null is returned.
-	 */
-	@Nullable
-	private Bitmap getCustomContactAvatar(@NonNull ContactModel contactModel) {
-		Bitmap customAvatar = contactService.getAvatar(contactModel, new AvatarOptions.Builder()
-			.setHighRes(true)
-			.setReturnPolicy(AvatarOptions.DefaultAvatarPolicy.CUSTOM_AVATAR)
-			.toOptions()
-		);
-
-		Bitmap scaledAvatar = scaleToSize(customAvatar);
-		if (scaledAvatar != null && scaledAvatar != customAvatar && isLocallySavedAvatar(contactModel)) {
-			try {
-				logger.info("Updating resized contact avatar");
-				contactService.setAvatar(contactModel, BitmapUtil.bitmapToByteArray(scaledAvatar, Bitmap.CompressFormat.PNG, 100));
-			} catch (Exception e) {
-				logger.error("Could not update avatar", e);
-			}
-		}
-
-		return scaledAvatar;
-	}
-
-	/**
-	 * Returns true if the locally saved avatar is displayed. The locally saved avatar is displayed
-	 * if it is my profile picture or there is a locally saved avatar available and the profile
-	 * pictures are hidden ('getProfilePicReceive-preference') or there is no profile picture.
-	 */
-	private boolean isLocallySavedAvatar(@NonNull ContactModel contactModel) {
-		boolean showProfilePictures = preferenceService.getProfilePicReceive();
-		boolean hasProfilePicture = fileService.hasContactPhotoFile(contactModel.getIdentity());
-		boolean hasLocallySavedAvatar = fileService.hasContactAvatarFile(contactModel.getIdentity());
-
-		return isMyProfilePicture || (hasLocallySavedAvatar && (!showProfilePictures || !hasProfilePicture));
-	}
-
 	/**
 	 * Get the custom contact avatar. The size is automatically scaled down to the maximum possible
 	 * size if it was too large. Due to a bug in compression some avatars may be too large and then
@@ -471,10 +436,16 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 			new AsyncTask<Void, Void, Void>() {
 				@Override
 				protected Void doInBackground(Void... voids) {
-					if (avatarData.getContactModel() != null) {
-						contactService.removeAvatar(avatarData.getContactModel());
-						fileService.removeContactPhoto(avatarData.getContactModel().getIdentity());
-					} else if (avatarData.getGroupModel() != null) {
+                    ContactModel contactModel = avatarData.getContactModel();
+                    if (contactModel != null) {
+                        if (userService.isMe(contactModel.getIdentity())) {
+                            userService.removeUserProfilePicture(TriggerSource.LOCAL);
+                        } else {
+                            contactService.removeUserDefinedProfilePicture(
+                                avatarData.getContactModel(), TriggerSource.LOCAL
+                            );
+                        }
+                    } else if (avatarData.getGroupModel() != null) {
 						saveGroupAvatar(null, true);
 					}
 					return null;
@@ -605,9 +576,20 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 							if (listenerRef.get() != null) {
 								listenerRef.get().onAvatarSet(avatarData.getCroppedFile());
 							} else {
-								if (this.avatarData.getContactModel() != null) {
+                                ContactModel contactModel = avatarData.getContactModel();
+								if (contactModel != null) {
 									try {
-										contactService.setAvatar(this.avatarData.getContactModel(), avatarData.getCroppedFile());
+                                        File profilePicture = avatarData.getCroppedFile();
+                                        if (profilePicture == null) {
+                                            logger.error("Cropped file for profile picture is null");
+                                            return;
+                                        }
+
+                                        if (userService.isMe(contactModel.getIdentity())) {
+                                            userService.setUserProfilePicture(profilePicture, TriggerSource.LOCAL);
+                                        } else {
+                                            contactService.setUserDefinedProfilePicture(contactModel, profilePicture, TriggerSource.LOCAL);
+                                        }
 										loadAvatarForModel(this.avatarData.getContactModel(), null);
 									} catch (Exception e) {
 										logger.error("Exception", e);
@@ -738,8 +720,8 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 	 */
 	private boolean hasAvatar() {
 		if (this.avatarData.getContactModel() != null) {
-			return fileService.hasContactAvatarFile(this.avatarData.getContactModel().getIdentity())
-				|| fileService.hasContactPhotoFile(this.avatarData.getContactModel().getIdentity());
+			return fileService.hasUserDefinedProfilePicture(this.avatarData.getContactModel().getIdentity())
+				|| fileService.hasContactDefinedProfilePicture(this.avatarData.getContactModel().getIdentity());
 		} else if (this.avatarData.getGroupModel() != null) {
 			return fileService.hasGroupAvatarFile(this.avatarData.getGroupModel());
 		}
@@ -754,7 +736,7 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 		if (this.avatarData.getContactModel() != null) {
 			return isEditable && ContactUtil.canHaveCustomAvatar(this.avatarData.getContactModel())
 				&& !(preferenceService.getProfilePicReceive()
-				&& fileService.hasContactPhotoFile(this.avatarData.getContactModel().getIdentity()));
+				&& fileService.hasContactDefinedProfilePicture(this.avatarData.getContactModel().getIdentity()));
 		} else if (this.avatarData.getGroupModel() != null) {
 			GroupModel group = avatarData.getGroupModel();
 			return isEditable && groupService.isGroupCreator(group) && groupService.isGroupMember(group);
diff --git a/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java b/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java
index f49d99a5..9a703972 100644
--- a/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java
+++ b/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java
@@ -63,7 +63,7 @@ public class AvatarListItemUtil {
 			contactService.loadAvatarIntoImage(
 				conversationModel.getContact(),
 				avatarView,
-				AvatarOptions.PRESET_RESPECT_SETTINGS,
+				AvatarOptions.PRESET_DEFAULT_FALLBACK,
 				requestManager
 			);
 		} else if (conversationModel.isGroupConversation()) {
@@ -115,7 +115,7 @@ public class AvatarListItemUtil {
 
 		AvatarOptions options;
 		if (model instanceof ContactModel) {
-			options = AvatarOptions.PRESET_RESPECT_SETTINGS;
+			options = AvatarOptions.PRESET_DEFAULT_FALLBACK;
 		} else if (model instanceof GroupModel) {
 			options = AvatarOptions.PRESET_DEFAULT_FALLBACK;
 		} else {
diff --git a/app/src/main/java/ch/threema/app/ui/ControllerView.java b/app/src/main/java/ch/threema/app/ui/ControllerView.java
index 7ea4bced..4e042226 100644
--- a/app/src/main/java/ch/threema/app/ui/ControllerView.java
+++ b/app/src/main/java/ch/threema/app/ui/ControllerView.java
@@ -104,7 +104,6 @@ public class ControllerView extends MaterialCardView {
 
     private void initProgressBars() {
         progressBarIndeterminate.setIndicatorColor(getProgressTrackIndicatorColor());
-        progressBarDeterminate.setTrackColor(getProgressTrackColor());
         progressBarDeterminate.setIndicatorColor(getProgressTrackIndicatorColor());
     }
 
@@ -260,68 +259,28 @@ public class ControllerView extends MaterialCardView {
         }
     }
 
-    /**
-     * We only want to apply dynamic colors if the current view is used to
-     * render an outbox message and they are enabled by the threema setting.
-     * This workaround is necessary because we actually use different color
-     * references when this returns true.
-     */
-    private boolean shouldUseDynamicColors() {
-        return isUsedForOutboxMessage && ColorUtil.areDynamicColorsCurrentlyApplied(getContext());
-    }
-
-    /**
-     *  We do this color workaround to render this view on the left side of the chat in its fixed colors (old way)
-     *  and on the right side with the <strong>possibility</strong> to show itself in dynamic colors.
-     */
     private @ColorInt int getBackgroundDefaultColor() {
-        if (shouldUseDynamicColors()) {
-            return ConfigUtils.getColorFromAttribute(getContext(), R.attr.colorPrimary);
-        } else {
-            return getResources().getColor(
-                ColorUtil.shouldUseDarkVariant(getContext())
-                    ? R.color.md_theme_dark_tertiaryContainer
-                    : R.color.md_theme_light_tertiaryContainer
-            );
-        }
-    }
-
-    /**
-     *  We do this color workaround to render this view on the left side of the chat in its fixed colors (old way)
-     *  and on the right side with the <strong>possibility</strong> to show itself in dynamic colors.
-     */
-    private @ColorInt int getProgressTrackColor() {
-        if (shouldUseDynamicColors()) {
-            return ConfigUtils.getColorFromAttribute(getContext(), R.attr.colorSurfaceBright);
-        } else {
-            return getResources().getColor(
-                ColorUtil.shouldUseDarkVariant(getContext())
-                    ? R.color.md_theme_dark_primaryContainer
-                    : R.color.md_theme_light_primaryContainer
-            );
-        }
+        return ConfigUtils.getColorFromAttribute(
+            getContext(),
+            ColorUtil.areDynamicColorsCurrentlyApplied(getContext())
+                ? R.attr.colorPrimary
+                : R.attr.colorTertiaryContainer
+        );
     }
 
-    /**
-     *  We do this color workaround to render this view on the left side of the chat in its fixed colors (old way)
-     *  and on the right side with the <strong>possibility</strong> to show itself in dynamic colors.
-     */
     private @ColorInt int getProgressTrackIndicatorColor() {
-        if (shouldUseDynamicColors()) {
-            return ConfigUtils.getColorFromAttribute(getContext(), R.attr.colorOnPrimary);
-        } else {
-            return getResources().getColor(
-                ColorUtil.shouldUseDarkVariant(getContext())
-                    ? R.color.md_theme_dark_primary
-                    : R.color.md_theme_light_primary
-            );
-        }
+        return ConfigUtils.getColorFromAttribute(
+            getContext(),
+            ColorUtil.areDynamicColorsCurrentlyApplied(getContext())
+                ? R.attr.colorOnPrimary
+                : R.attr.colorPrimary
+        );
     }
 
     private @ColorInt int getIconTintColor() {
         return ConfigUtils.getColorFromAttribute(
             getContext(),
-            shouldUseDynamicColors()
+            ColorUtil.areDynamicColorsCurrentlyApplied(getContext())
                 ? R.attr.colorOnPrimary
                 : R.attr.colorOnBackground
         );
diff --git a/app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt b/app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt
index 9991a8ed..2b65b121 100644
--- a/app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt
+++ b/app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt
@@ -52,6 +52,7 @@ import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.ContactUtil
 import ch.threema.app.utils.NameUtil
 import ch.threema.app.utils.TestUtil
+import ch.threema.domain.models.IdentityState
 import ch.threema.storage.models.ContactModel
 import ch.threema.storage.models.GroupModel
 import com.google.android.material.card.MaterialCardView
@@ -143,7 +144,7 @@ class MentionSelectorPopup(
         height = 1
 
         allContactModel.setName(context.getString(R.string.all), "")
-        allContactModel.state = ContactModel.State.ACTIVE
+        allContactModel.state = IdentityState.ACTIVE
         filterText = ""
         filterStart = 0
 
diff --git a/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java b/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java
index adc5156e..c66cf866 100644
--- a/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java
+++ b/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java
@@ -28,6 +28,8 @@ import androidx.annotation.NonNull;
 import ch.threema.app.R;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ContactUtil;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.storage.models.ContactModel;
 
 public class VerificationLevelImageView extends androidx.appcompat.widget.AppCompatImageView {
@@ -50,32 +52,47 @@ public class VerificationLevelImageView extends androidx.appcompat.widget.AppCom
 	}
 
 	/**
-	 * takes a ContactModel and sets the according verification
-	 * level image source and content description on the VerificationLevelImageView.
-	 * The ContactModel input contains a contacts' attributes name, publicKey etc.
-	 * @param ContactModel contact
+	 * Sets the view to the provided verification levels.
 	 */
-	public void setContactModel(@NonNull ContactModel contact){
-		setContentDescription(getVerificationLevelDescription(contact));
-		setImageDrawable(ContactUtil.getVerificationDrawable(context, contact));
+	public void setVerificationLevel(
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		setContentDescription(
+			getVerificationLevelDescription(
+				verificationLevel, workVerificationLevel
+			)
+		);
+		setImageDrawable(
+			ContactUtil.getVerificationDrawable(
+				context,
+				verificationLevel,
+				workVerificationLevel
+			)
+		);
 	}
 
 	/**
-	 * takes a ContactModel and gets the according verificationlevel description.
-	 * The ContactModel input contains a contacts' attributes name, publicKey etc.
-	 * @param ContactModel contactModel
+	 * Get the verification level description from the given verification level. This also depends
+	 * on the build and whether the contact is a work contact or not.
+	 *
 	 * @return String defined text in strings.xml for the according verification level
 	 */
-	private @NonNull String getVerificationLevelDescription(@NonNull ContactModel contactModel) {
-		switch (contactModel.verificationLevel) {
+	private @NonNull String getVerificationLevelDescription(
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		boolean isWorkVerifiedOnWorkBuild = ConfigUtils.isWorkBuild()
+			&& workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED;
+		switch (verificationLevel) {
 			case FULLY_VERIFIED:
-				if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
+				if (isWorkVerifiedOnWorkBuild) {
 					return context.getString(R.string.verification_level3_work_explain);
 				} else {
 					return context.getString(R.string.verification_level3_explain);
 				}
 			case SERVER_VERIFIED:
-				if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
+				if (isWorkVerifiedOnWorkBuild) {
 					return context.getString(R.string.verification_level2_work_explain);
 				}
 				return context.getString(R.string.verification_level2_explain);
diff --git a/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java b/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java
index ca18dc0d..6fc4c3b8 100644
--- a/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java
@@ -27,7 +27,6 @@ import android.Manifest;
 import android.accounts.Account;
 import android.accounts.AccountManager;
 import android.accounts.AuthenticatorDescription;
-import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.ContentProviderOperation;
 import android.content.ContentResolver;
@@ -70,6 +69,7 @@ import ch.threema.app.services.FileService;
 import ch.threema.app.services.UserService;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModelData;
 import ch.threema.storage.models.ContactModel;
 
 public class AndroidContactUtil {
@@ -170,7 +170,7 @@ public class AndroidContactUtil {
 					try {
 						contactLookupUri = ContactsContract.Contacts.lookupContact(contentResolver, contactLookupUri);
 					} catch (Exception e) {
-						logger.error("Exception", e);
+						logger.error("Could not lookup the contact with identity {}", contactModel.getIdentity(), e);
 						return null;
 					}
 				}
@@ -181,14 +181,49 @@ public class AndroidContactUtil {
 	}
 
 	/**
-	 * Update the avatar for the specified contact from Android's contact database, if any
-	 * If there's no avatar for this Android contact, any current avatar on file will be deleted
+	 * Return a valid uri to the given contact that can be used to build an intent for the contact app
+	 * It is safe to call this method if permission to access contacts is not granted - null will be returned in that case
+	 *
+	 * @param contactModel ContactModel for which to get the Android contact URI
+	 * @return a valid uri pointing to the android contact or null if permission was not granted, no android contact is linked or android contact could not be looked up
+	 */
+	@Nullable
+	public Uri getAndroidContactUri(@NonNull ch.threema.data.models.ContactModel contactModel) {
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
+			ContextCompat.checkSelfPermission(ThreemaApplication.getAppContext(), Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+			return null;
+		}
+
+		ContactModelData data = contactModel.getData().getValue();
+
+		if (data != null) {
+			final String androidContactLookupKey = data.androidContactLookupKey;
+			if (androidContactLookupKey != null) {
+				Uri contactLookupUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_LOOKUP_URI, androidContactLookupKey);
+				if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.LOLLIPOP_MR1) {
+					try {
+						contactLookupUri = ContactsContract.Contacts.lookupContact(contentResolver, contactLookupUri);
+					} catch (Exception e) {
+						logger.error("Could not lookup the contact with identity {}", contactModel.getIdentity(), e);
+						return null;
+					}
+				}
+				return contactLookupUri;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Update the avatar for the specified contact from Android's contact database, if any.
+	 * If there's no avatar for this Android contact, any current avatar file will be deleted.
 	 *
 	 * It is safe to call this method even if permission to read contacts is not given
 	 *
 	 * @param contactModel ContactModel
 	 * @return true if setting or deleting the avatar was successful, false otherwise
 	 */
+	@RequiresPermission(Manifest.permission.READ_CONTACTS)
 	public boolean updateAvatarByAndroidContact(@NonNull ContactModel contactModel) {
 		if (fileService == null) {
 			logger.info("FileService not available");
@@ -203,19 +238,19 @@ public class AndroidContactUtil {
 		// contactUri will be null if permission is not granted
 		Uri contactUri = getAndroidContactUri(contactModel);
 		if (contactUri != null) {
-			@SuppressLint("MissingPermission") Bitmap bitmap = AvatarConverterUtil.convert(ThreemaApplication.getAppContext(), contactUri);
+			Bitmap bitmap = AvatarConverterUtil.convert(ThreemaApplication.getAppContext(), contactUri);
 
 			if (bitmap != null) {
 				try {
-					fileService.writeAndroidContactAvatar(contactModel.getIdentity(), BitmapUtil.bitmapToByteArray(bitmap, Bitmap.CompressFormat.PNG, 100));
+					fileService.writeAndroidDefinedProfilePicture(contactModel.getIdentity(), BitmapUtil.bitmapToByteArray(bitmap, Bitmap.CompressFormat.PNG, 100));
 					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
 					return true;
 				} catch (Exception e) {
-					logger.error("Exception", e);
+					logger.error("Could not write android contact avatar of contact {}", contactModel.getIdentity(), e);
 				}
 			} else {
 				// delete old avatar
-				boolean success = fileService.removeAndroidContactAvatar(contactModel.getIdentity());
+				boolean success = fileService.removeAndroidDefinedProfilePicture(contactModel.getIdentity());
 				if (success) {
 					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
 					return true;
@@ -227,38 +262,86 @@ public class AndroidContactUtil {
 		return false;
 	}
 
+	/**
+	 * Update the avatar for the specified contact from Android's contact database, if any.
+	 * If there's no avatar for this Android contact, any current avatar file will be deleted.
+	 *
+	 * It is safe to call this method even if permission to read contacts is not given
+	 *
+	 * @param contactModel ContactModel
+	 * @return true if setting or deleting the avatar was successful, false otherwise
+	 */
+	@RequiresPermission(Manifest.permission.READ_CONTACTS)
+	public void updateAvatarByAndroidContact(@NonNull ch.threema.data.models.ContactModel contactModel) {
+		if (fileService == null) {
+			logger.info("FileService not available");
+			return;
+		}
+
+		ContactModelData data = contactModel.getData().getValue();
+		if (data == null) {
+			logger.warn("Contact model data is null");
+			return;
+		}
+
+		final String androidContactLookupKey = data.androidContactLookupKey;
+		if (androidContactLookupKey == null) {
+			return;
+		}
+
+		// contactUri will be null if permission is not granted
+		Uri contactUri = getAndroidContactUri(contactModel);
+		if (contactUri != null) {
+			Bitmap bitmap = AvatarConverterUtil.convert(ThreemaApplication.getAppContext(), contactUri);
+
+			if (bitmap != null) {
+				try {
+					fileService.writeAndroidDefinedProfilePicture(contactModel.getIdentity(), BitmapUtil.bitmapToByteArray(bitmap, Bitmap.CompressFormat.PNG, 100));
+					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
+					return;
+				} catch (Exception e) {
+					logger.error("Exception", e);
+				}
+			} else {
+				// delete old avatar
+				boolean success = fileService.removeAndroidDefinedProfilePicture(contactModel.getIdentity());
+				if (success) {
+					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
+					return;
+				}
+			}
+		}
+
+		logger.debug("Unable to get avatar for {} lookupKey = {} contactUri = {}", contactModel.getIdentity(), androidContactLookupKey, contactUri);
+	}
+
 	/**
 	 * Update the name of this contact according to the name of the Android contact
-	 * Note that the ContactModel needs to be saved to the ContactStore to apply the changes!
 	 *
 	 * @param contactModel ContactModel
-	 * @return true if the name has changed, false otherwise
 	 */
 	@RequiresPermission(Manifest.permission.READ_CONTACTS)
-	public boolean updateNameByAndroidContact(@NonNull ContactModel contactModel) throws ThreemaException {
+	public void updateNameByAndroidContact(@NonNull ch.threema.data.models.ContactModel contactModel) throws ThreemaException {
+		ContactModelData data = contactModel.getData().getValue();
+		if (data == null) {
+			logger.warn("Contact model data is null");
+			return;
+		}
 		Uri namedContactUri = getAndroidContactUri(contactModel);
-		if(TestUtil.required(contactModel, namedContactUri)) {
-			ContactName contactName = this.getContactName(namedContactUri);
+		if (namedContactUri != null) {
+			ContactName contactName = getContactName(namedContactUri);
 
 			if (contactName == null) {
-				logger.info("Unable to get contact name for {} lookupKey = {} namedUri = {}", contactModel.getIdentity(), contactModel.getAndroidContactLookupKey(), namedContactUri);
+				logger.info("Unable to get contact name for {} lookupKey = {} namedUri = {}", contactModel.getIdentity(), data.androidContactLookupKey, namedContactUri);
 				// remove contact link to unresolvable contact
-				contactModel.setAndroidContactLookupKey(null);
+				contactModel.removeAndroidContactLink();
 				throw new ThreemaException("Unable to get contact name");
 			}
 
-			if(!TestUtil.compare(contactModel.getFirstName(), contactName.firstName)
-					|| !TestUtil.compare(contactModel.getLastName(), contactName.lastName)) {
-				contactModel.setFirstName(contactName.firstName);
-				contactModel.setLastName(contactName.lastName);
-				return true;
-			}
+			contactModel.setNameFromLocal(contactName.firstName, contactName.lastName);
 		} else {
-			if (contactModel != null) {
-				logger.info("Unable to get android contact uri for {} lookupkey = {}", contactModel.getIdentity(), contactModel.getAndroidContactLookupKey());
-			}
+			logger.info("Unable to get android contact uri for {} lookupKey = {}", contactModel.getIdentity(), data.androidContactLookupKey);
 		}
-		return false;
 	}
 
 	/**
@@ -415,12 +498,11 @@ public class AndroidContactUtil {
 	 *
 	 * @param contentProviderOperations List of ContentProviderOperations to add this operation to
 	 * @param systemRawContactId The raw contact that matched the criteria for aggregation (i.e. email or phone number)
-	 * @param contactModel ContactModel to create a raw contact for
+	 * @param identity the identity of the contact to create a raw contact for
 	 * @param supportsVoiceCalls Whether the user has voice calls enabled
 	 */
 	@RequiresPermission(allOf = {Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS})
-	public void createThreemaRawContact(@NonNull List<ContentProviderOperation> contentProviderOperations, long systemRawContactId, @NonNull ContactModel contactModel, boolean supportsVoiceCalls) {
-		String identity = contactModel.getIdentity();
+	public void createThreemaRawContact(@NonNull List<ContentProviderOperation> contentProviderOperations, long systemRawContactId, @NonNull String identity, boolean supportsVoiceCalls) {
 		Context context = ThreemaApplication.getAppContext();
 		Account account = this.getAccount();
 		if (!TestUtil.required(account, identity)) {
@@ -487,10 +569,10 @@ public class AndroidContactUtil {
 	 * Delete all raw contacts where the given identity matches the entry in the contact's SYNC1 column
 	 * It's safe to call this method without contacts permission
 	 *
-	 * @param contactModel ContactModel whose raw contact we want to be deleted
+	 * @param identity the identity of the contact whose raw contact we want to be deleted
 	 * @return number of raw contacts deleted
 	 */
-	public int deleteThreemaRawContact(@NonNull ContactModel contactModel) {
+	public int deleteThreemaRawContact(@NonNull String identity) {
 		if (!ConfigUtils.isPermissionGranted(ThreemaApplication.getAppContext(), Manifest.permission.WRITE_CONTACTS)) {
 			return 0;
 		}
@@ -503,7 +585,7 @@ public class AndroidContactUtil {
 		Uri rawContactUri = ContactsContract.RawContacts.CONTENT_URI
 			.buildUpon()
 			.appendQueryParameter(ContactsContract.CALLER_IS_SYNCADAPTER, "true")
-			.appendQueryParameter(ContactsContract.RawContacts.SYNC1, contactModel.getIdentity())
+			.appendQueryParameter(ContactsContract.RawContacts.SYNC1, identity)
 			.appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_NAME, account.name)
 			.appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_TYPE, account.type).build();
 
@@ -684,7 +766,7 @@ public class AndroidContactUtil {
 	@RequiresPermission(allOf = {Manifest.permission.READ_CONTACTS, Manifest.permission.GET_ACCOUNTS})
 	@Nullable
 	@WorkerThread
-	public Drawable getAccountIcon(@NonNull ContactModel contactModel) {
+	public Drawable getAccountIcon(@Nullable String androidContactLookupKey) {
 		final PackageManager pm = ThreemaApplication.getAppContext().getPackageManager();
 
 		Account myAccount = this.getAccount();
@@ -692,7 +774,6 @@ public class AndroidContactUtil {
 			return null;
 		}
 
-		final String androidContactLookupKey = contactModel.getAndroidContactLookupKey();
 		if (androidContactLookupKey == null) {
 			return null;
 		}
diff --git a/app/src/main/java/ch/threema/app/utils/ArrayExtensions.kt b/app/src/main/java/ch/threema/app/utils/ArrayExtensions.kt
new file mode 100644
index 00000000..d16f5525
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/utils/ArrayExtensions.kt
@@ -0,0 +1,36 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.utils
+
+fun <T : Comparable<T>> Array<out T>.equalsIgnoreOrder(other: Array<out T>): Boolean {
+    if (this.size != other.size) {
+        return false
+    }
+    return this.sortedArray().contentEquals(other.sortedArray())
+}
+
+fun <T : Comparable<T>> Array<out T>.deepEqualsIgnoreOrder(other: Array<out T>): Boolean {
+    if (this.size != other.size) {
+        return false
+    }
+    return this.sortedArray().contentDeepEquals(other.sortedArray())
+}
diff --git a/app/src/main/java/ch/threema/app/utils/BackupUtils.java b/app/src/main/java/ch/threema/app/utils/BackupUtils.java
index f4644e96..91b02d9c 100644
--- a/app/src/main/java/ch/threema/app/utils/BackupUtils.java
+++ b/app/src/main/java/ch/threema/app/utils/BackupUtils.java
@@ -28,9 +28,6 @@ import ch.threema.storage.models.ballot.BallotModel;
 
 public class BackupUtils {
 
-	public static final String BACKUP_DIR = "backup/";
-	public static final String KEY_BACKUP_PATH = BACKUP_DIR + "keybackup.bin";
-
 	private static String buildBallotChoiceUid(int apiChoiceId) {
 		return String.valueOf(apiChoiceId);
 	}
@@ -60,4 +57,27 @@ public class BackupUtils {
 	public static String buildDistributionListUid(DistributionListModel distributionListModel) {
 		return String.valueOf(distributionListModel.getId());
 	}
+
+	/**
+	 * Calculate the count of nonces that are not yet respected in the progress calculation.
+	 *
+	 * This calculation is based on the assumption that per noncesPerChunk of processed nonces
+	 * the steps are calculated like `steps = noncesInChunk / noncesPerStep`. It is assumed that every
+	 * chunk except the last contains noncesPerChunk.
+	 * Therefore for every processed chunk there may remain some nonces that are not yet respected.
+	 *
+	 * @return The number of nonces not yet respected for step calculation
+	 */
+	public static int calcRemainingNoncesProgress(
+		final int noncesPerChunk,
+		final int noncesPerStep,
+		final int nonceCount
+	) {
+		int fullChunks = nonceCount / noncesPerChunk;
+		int lastChunkCount = nonceCount - (noncesPerChunk * fullChunks);
+
+		int remainingPerFullChunk = noncesPerChunk % noncesPerStep;
+		int remainingInLastChunk = lastChunkCount % noncesPerStep;
+		return remainingPerFullChunk * fullChunks + remainingInLastChunk;
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/utils/CSVReader.java b/app/src/main/java/ch/threema/app/utils/CSVReader.java
index c670eddc..13bb4595 100644
--- a/app/src/main/java/ch/threema/app/utils/CSVReader.java
+++ b/app/src/main/java/ch/threema/app/utils/CSVReader.java
@@ -27,45 +27,11 @@ import java.io.Reader;
 public class CSVReader extends au.com.bytecode.opencsv.CSVReader {
 	private String[] headerRow;
 
-	public CSVReader(Reader reader) {
-		super(reader);
-	}
-
 	public CSVReader(Reader reader, boolean firstRowIsHeader) throws IOException{
 		super(reader);
-		this.headerRow = this.readNext();
-	}
-
-	public CSVReader(Reader reader, char c) {
-		super(reader, c);
-	}
-
-	public CSVReader(Reader reader, char c, char c2) {
-		super(reader, c, c2);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, boolean b) {
-		super(reader, c, c2, b);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3) {
-		super(reader, c, c2, c3);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, int i) {
-		super(reader, c, c2, i);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3, int i) {
-		super(reader, c, c2, c3, i);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3, int i, boolean b) {
-		super(reader, c, c2, c3, i, b);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3, int i, boolean b, boolean b2) {
-		super(reader, c, c2, c3, i, b, b2);
+		if (firstRowIsHeader) {
+			this.headerRow = this.readNext();
+		}
 	}
 
 	public CSVRow readNextRow() throws IOException {
diff --git a/app/src/main/java/ch/threema/app/utils/ConfigUtils.java b/app/src/main/java/ch/threema/app/utils/ConfigUtils.java
index b4a07439..fc407f6a 100644
--- a/app/src/main/java/ch/threema/app/utils/ConfigUtils.java
+++ b/app/src/main/java/ch/threema/app/utils/ConfigUtils.java
@@ -217,6 +217,9 @@ public class ConfigUtils {
     public static boolean isSamsungDevice() {
         return (Build.MANUFACTURER.equalsIgnoreCase("Samsung"));
     }
+    public static boolean isMotorolaDevice() {
+        return (Build.MANUFACTURER.equalsIgnoreCase("motorola"));
+    }
 
     public static boolean isSonyDevice() {
         return (Build.MANUFACTURER.equalsIgnoreCase("Sony"));
@@ -337,9 +340,10 @@ public class ConfigUtils {
      */
     public static @NonNull SSLSocketFactory getSSLSocketFactory(String host) {
         return new TLSUpgradeSocketFactoryWrapper(
-            ConfigUtils.isOnPremBuild() ?
-                HttpsURLConnection.getDefaultSSLSocketFactory() :
-                TrustKit.getInstance().getSSLSocketFactory(host));
+            ConfigUtils.isOnPremBuild()
+                ? HttpsURLConnection.getDefaultSSLSocketFactory()
+                : TrustKit.getInstance().getSSLSocketFactory(host)
+        );
     }
 
     public static boolean isXiaomiDevice() {
diff --git a/app/src/main/java/ch/threema/app/utils/ContactUtil.java b/app/src/main/java/ch/threema/app/utils/ContactUtil.java
index ed6ee257..77bc2eb5 100644
--- a/app/src/main/java/ch/threema/app/utils/ContactUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/ContactUtil.java
@@ -33,6 +33,8 @@ import android.text.format.DateUtils;
 
 import org.slf4j.Logger;
 
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.text.Collator;
 import java.util.Comparator;
 import java.util.Date;
@@ -46,10 +48,17 @@ import androidx.appcompat.content.res.AppCompatResources;
 import androidx.core.util.Pair;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.services.FileService;
 import ch.threema.app.services.IdListService;
 import ch.threema.app.services.PreferenceService;
+import ch.threema.app.tasks.OnFSFeatureMaskDowngradedTask;
+import ch.threema.base.ThreemaException;
+import ch.threema.base.utils.Base32;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.IdentityState;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.storage.models.ContactModel;
 
 /**
@@ -60,10 +69,34 @@ import ch.threema.storage.models.ContactModel;
 public class ContactUtil {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("ContactUtil");
 
+	private static final String CONTACT_UID_PREFIX = "c-";
+
 	public static final int CHANNEL_NAME_MAX_LENGTH_BYTES = 256;
 
 	public static final long PROFILE_PICTURE_BLOB_CACHE_DURATION = DateUtils.WEEK_IN_MILLIS;
 
+	@Deprecated
+	public static int getUniqueId(@Nullable String identity) {
+		if (identity == null) {
+			return 0;
+		}
+		return (CONTACT_UID_PREFIX + identity).hashCode();
+	}
+
+	@NonNull
+	public static String getUniqueIdString(@Nullable String identity) {
+		if (identity != null) {
+			try {
+				MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+				messageDigest.update((CONTACT_UID_PREFIX + identity).getBytes());
+				return Base32.encode(messageDigest.digest());
+			} catch (NoSuchAlgorithmException e) {
+				logger.warn("Could not calculate unique id string");
+			}
+		}
+		return "";
+	}
+
 	public static boolean canChangeFirstName(@Nullable ContactModel contact) {
 		return contact != null && !contact.isLinkedToAndroidContact();
 	}
@@ -80,7 +113,7 @@ public class ContactUtil {
 		@NonNull FileService fileService
 	) {
 		return canHaveCustomAvatar(contactModel)
-				&& !(preferenceService.getProfilePicReceive() && fileService.hasContactPhotoFile(contactModel.getIdentity()));
+				&& !(preferenceService.getProfilePicReceive() && fileService.hasContactDefinedProfilePicture(contactModel.getIdentity()));
 	}
 
 	/**
@@ -127,22 +160,28 @@ public class ContactUtil {
 				&& !isEchoEchoOrGatewayContact(contactModel);
 	}
 
+	public static boolean canReceiveVoipMessages(@Nullable String identity, @Nullable IdListService blockedContactsService) {
+		return identity != null
+			&& blockedContactsService != null
+			&& !blockedContactsService.has(identity)
+			&& !isEchoEchoOrGatewayContact(identity);
+	}
+
 	public static boolean allowedChangeToState(
-		@Nullable ContactModel contactModel,
-		@Nullable ContactModel.State newState
+		@Nullable IdentityState oldState,
+		@Nullable IdentityState newState
 	) {
-		if(contactModel != null && newState != null && contactModel.getState() != newState) {
-			ContactModel.State oldState = contactModel.getState();
-
-			switch (newState) {
-				//change to active is always allowed
-				case ACTIVE:
-					return true;
-				case INACTIVE:
-					return oldState == ContactModel.State.ACTIVE;
-				case INVALID:
-					return true;
-			}
+		if (oldState == newState || newState == null) {
+			return false;
+		}
+		switch (newState) {
+			//change to active is always allowed
+			case ACTIVE:
+				return true;
+			case INACTIVE:
+				return oldState == IdentityState.ACTIVE;
+			case INVALID:
+				return true;
 		}
 		return false;
 	}
@@ -214,34 +253,46 @@ public class ContactUtil {
 		return key;
 	}
 
-	public static @DrawableRes int getVerificationResource(ContactModel contactModel) {
-		int iconResource = R.drawable.ic_verification_none;
-		if(contactModel != null) {
-			switch (contactModel.verificationLevel) {
-				case SERVER_VERIFIED:
-					if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
-						iconResource = R.drawable.ic_verification_server_work;
-					} else {
-						iconResource = R.drawable.ic_verification_server;
-					}
-					break;
-				case FULLY_VERIFIED:
-					if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
-						iconResource = R.drawable.ic_verification_full_work;
-					} else {
-						iconResource = R.drawable.ic_verification_full;
-					}
-					break;
-			}
+	public static @DrawableRes int getVerificationResource(
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		int iconResource;
+		boolean isWorkVerifiedOnWorkBuild = ConfigUtils.isWorkBuild()
+			&& workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED;
+		switch (verificationLevel) {
+			case SERVER_VERIFIED:
+				if (isWorkVerifiedOnWorkBuild) {
+					iconResource = R.drawable.ic_verification_server_work;
+				} else {
+					iconResource = R.drawable.ic_verification_server;
+				}
+				break;
+			case FULLY_VERIFIED:
+				if (isWorkVerifiedOnWorkBuild) {
+					iconResource = R.drawable.ic_verification_full_work;
+				} else {
+					iconResource = R.drawable.ic_verification_full;
+				}
+				break;
+			case UNVERIFIED:
+			default:
+				iconResource = R.drawable.ic_verification_none;
+				break;
 		}
 		return iconResource;
 	}
 
-	public static Drawable getVerificationDrawable(Context context, ContactModel contactModel) {
-		if (context != null) {
-			return AppCompatResources.getDrawable(context, getVerificationResource(contactModel));
-		}
-		return null;
+	@Nullable
+	public static Drawable getVerificationDrawable(
+		@NonNull Context context,
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		return AppCompatResources.getDrawable(context, getVerificationResource(
+			verificationLevel,
+			workVerificationLevel
+		));
 	}
 
 	public static String getIdentityFromViewIntent(Context context, Intent intent) {
@@ -280,4 +331,41 @@ public class ContactUtil {
 			return String.join(", ", contactNames);
 		}
 	}
+
+	/**
+	 * Perform the required steps if a contact does not support forward security anymore due to a
+	 * change of its feature mask. This includes creating a status message in the conversation with
+	 * that contact to warn the user that forward security has been disabled for this contact. This
+	 * method also terminates all existing sessions with the contact.
+	 * <p>
+	 * Note that the status message is only created if a forward security session currently exists.
+	 * <p>
+	 * Note that this method must only be called if the feature mask of a contact is changed from a
+	 * feature mask that indicates forward security support to a feature mask without forward
+	 * security support.
+	 *
+	 * @param contactModel the affected contact
+	 */
+	public static void onForwardSecurityNotSupportedAnymore(@NonNull ch.threema.data.models.ContactModel contactModel) {
+		ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+		if (serviceManager == null) {
+			logger.error("Service manager is null");
+			return;
+		}
+
+		try {
+			serviceManager.getTaskManager().schedule(
+				new OnFSFeatureMaskDowngradedTask(
+					contactModel,
+					serviceManager.getContactService(),
+					serviceManager.getMessageService(),
+					serviceManager.getDHSessionStore(),
+					serviceManager.getIdentityStore(),
+					serviceManager.getForwardSecurityMessageProcessor()
+				)
+			);
+		} catch (ThreemaException e) {
+			logger.error("Could not schedule fs feature mask downgraded task");
+		}
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java b/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java
index d321e994..2c609231 100644
--- a/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java
@@ -25,18 +25,15 @@ import android.content.Context;
 import android.graphics.Bitmap;
 import android.net.Uri;
 
-import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 import java.util.Date;
 import java.util.HashMap;
 
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
 import androidx.core.app.Person;
 import androidx.core.graphics.drawable.IconCompat;
-
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
@@ -106,19 +103,21 @@ public class ConversationNotificationUtil {
             return null;
         }
 
-        Person.Builder builder = new Person.Builder()
-            .setKey(contactService.getUniqueIdString(contactModel))
-            .setName(name);
-        Bitmap avatar = contactService.getAvatar(contactModel, false);
-        if (avatar != null) {
-            IconCompat iconCompat = IconCompat.createWithBitmap(avatar);
-            builder.setIcon(iconCompat);
-        }
-        if (contactModel != null && contactModel.isLinkedToAndroidContact()) {
-            builder.setUri(contactService.getAndroidContactLookupUriString(contactModel));
-        }
-        return builder.build();
-    }
+		String identity = contactModel != null ? contactModel.getIdentity() : null;
+
+		Person.Builder builder = new Person.Builder()
+			.setKey(ContactUtil.getUniqueIdString(identity))
+			.setName(name);
+		Bitmap avatar = contactService.getAvatar(contactModel, false);
+		if (avatar != null) {
+			IconCompat iconCompat = IconCompat.createWithBitmap(avatar);
+			builder.setIcon(iconCompat);
+		}
+		if (contactModel != null && contactModel.isLinkedToAndroidContact()) {
+			builder.setUri(contactService.getAndroidContactLookupUriString(contactModel));
+		}
+		return builder.build();
+	}
 
     private static MessageType getMessageType(AbstractMessageModel messageModel) {
         return messageModel.getType();
@@ -128,40 +127,44 @@ public class ConversationNotificationUtil {
         return messageModel.getCreatedAt();
     }
 
-    private static NotificationService.ConversationNotification create(
-        final Context context,
-        final MessageModel messageModel,
-        final @NonNull ContactService contactService,
-        final DeadlineListService hiddenChatsListService
-    ) {
-        final ContactModel contactModel = contactService.getByIdentity(messageModel.getIdentity());
-        String groupUid = "i" + messageModel.getIdentity();
-        synchronized (notificationGroupHashMap) {
-            @Nullable ConversationNotificationGroup group = notificationGroupHashMap.get(groupUid);
-            final @NotNull String longName = hiddenChatsListService.has(contactService.getUniqueIdString(contactModel))
-                ? context.getString(R.string.private_chat_subject)
-                : NameUtil.getDisplayNameOrNickname(contactModel, true);
-            final @Nullable String shortName = hiddenChatsListService.has(contactService.getUniqueIdString(contactModel))
-                ? context.getString(R.string.private_chat_subject)
-                : NameUtil.getShortName(contactModel);
-
-            if (group == null) {
-                group = new ConversationNotificationGroup(
-                    groupUid,
-                    longName,
-                    shortName,
-                    contactService.createReceiver(contactModel),
-                    () -> contactService.getAvatar(
-                        hiddenChatsListService.has(contactService.getUniqueIdString(contactModel)) ? null : contactModel,
-                        false
-                    )
-                );
-                notificationGroupHashMap.put(groupUid, group);
-            } else {
-                // contact name may change between notifications - set it again
-                group.name = longName;
-                group.shortName = shortName;
-            }
+	private static NotificationService.ConversationNotification create(final Context context, final MessageModel messageModel,
+	                                                                   final ContactService contactService, final DeadlineListService hiddenChatsListService) {
+		final ContactModel contactModel = contactService.getByIdentity(messageModel.getIdentity());
+		String groupUid = "i" + messageModel.getIdentity();
+		synchronized (notificationGroupHashMap) {
+			ConversationNotificationGroup group = notificationGroupHashMap.get(groupUid);
+			boolean isPrivateChat = hiddenChatsListService.has(
+				ContactUtil.getUniqueIdString(messageModel.getIdentity())
+			);
+			String longName, shortName;
+			if (isPrivateChat) {
+				longName = shortName = context.getString(R.string.private_chat_subject);
+			} else {
+				longName = NameUtil.getDisplayNameOrNickname(contactModel, true);
+				shortName = NameUtil.getShortName(contactModel);
+			}
+
+			if (group == null) {
+				group = new ConversationNotificationGroup(
+						groupUid,
+						longName,
+						shortName,
+						contactService.createReceiver(contactModel),
+                        () -> {
+                            if (contactModel != null) {
+                                return contactService.getAvatar(
+                                        isPrivateChat ? null : contactModel,
+                                        false
+                                );
+                            }
+                            return null;
+                        });
+				notificationGroupHashMap.put(groupUid, group);
+			} else {
+				// contact name may change between notifications - set it again
+				group.name = longName;
+				group.shortName = shortName;
+			}
 
             return new NotificationService.ConversationNotification(
                 getMessage(messageModel),
diff --git a/app/src/main/java/ch/threema/app/utils/FileUtil.java b/app/src/main/java/ch/threema/app/utils/FileUtil.java
index 69c2fcf4..4e77c6c1 100644
--- a/app/src/main/java/ch/threema/app/utils/FileUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/FileUtil.java
@@ -75,6 +75,7 @@ import ch.threema.storage.models.data.media.FileDataModel;
 
 import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE;
 import static ch.threema.app.filepicker.FilePickerActivity.INTENT_DATA_DEFAULT_PATH;
+import static ch.threema.app.utils.StreamUtilKt.getFromUri;
 
 public class FileUtil {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("FileUtil");
@@ -832,7 +833,7 @@ public class FileUtil {
 	 * @return true if the file is an animated WebP file, false if it is not animated, in another format, corrupt or not readable
 	 */
 	private static boolean isAnimatedWebPFile(@NonNull Uri uri) {
-		try (InputStream inputStream = StreamUtil.getFromUri(ThreemaApplication.getAppContext(), uri)) {
+		try (InputStream inputStream = getFromUri(ThreemaApplication.getAppContext(), uri)) {
 			byte[] buffer = new byte[34];
 			return inputStream != null
 				&& inputStream.read(buffer) == 34
diff --git a/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java b/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java
index 931631fe..657f0ade 100644
--- a/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java
+++ b/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java
@@ -32,7 +32,9 @@ import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.routines.UpdateFeatureLevelRoutine;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.services.UserService;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.fs.DHSession;
 import ch.threema.domain.fs.DHSessionId;
 import ch.threema.domain.models.Contact;
@@ -50,15 +52,30 @@ import ch.threema.storage.models.data.status.ForwardSecurityStatusDataModel.Forw
 public class ForwardSecurityStatusSender implements ForwardSecurityStatusListener {
 	private final static Logger logger = LoggingUtil.getThreemaLogger("ForwardSecurityStatusSender");
 	private final boolean debug;
+	@NonNull
 	private final ContactService contactService;
+	@NonNull
 	private final MessageService messageService;
+	@NonNull
 	private final APIConnector apiConnector;
-
-	public ForwardSecurityStatusSender(ContactService contactService, MessageService messageService, APIConnector apiConnector) {
+	@NonNull
+	private final UserService userService;
+	@NonNull
+	private final ContactModelRepository contactModelRepository;
+
+	public ForwardSecurityStatusSender(
+		@NonNull ContactService contactService,
+		@NonNull MessageService messageService,
+		@NonNull APIConnector apiConnector,
+		@NonNull UserService userService,
+		@NonNull ContactModelRepository contactModelRepository
+	) {
 		this.debug = ConfigUtils.isDevBuild();
 		this.contactService = contactService;
 		this.messageService = messageService;
 		this.apiConnector = apiConnector;
+		this.userService = userService;
+		this.contactModelRepository = contactModelRepository;
 	}
 
 	@Override
@@ -247,11 +264,12 @@ public class ForwardSecurityStatusSender implements ForwardSecurityStatusListene
 		}
 
 		// Force a feature mask re-fetch
-		UpdateFeatureLevelRoutine.removeTimeCache(contactModel);
+		UpdateFeatureLevelRoutine.removeTimeCache(contactModel.getIdentity());
 		new UpdateFeatureLevelRoutine(
-			contactService,
+			contactModelRepository,
+			userService,
 			apiConnector,
-			Collections.singletonList(contactModel)
+			Collections.singletonList(contactModel.getIdentity())
 		).run();
 	}
 
diff --git a/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt b/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt
index 780ae743..351e946c 100644
--- a/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt
+++ b/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt
@@ -86,6 +86,7 @@ fun initiateCall(
         groupModel: GroupModel
 ) {
     val serviceManager = ThreemaApplication.getServiceManager() ?: return
+    val contactModelRepository = serviceManager.modelRepositories.contacts
     val userService: UserService
     val groupService: GroupService
     val contactService: ContactService
@@ -112,7 +113,7 @@ fun initiateCall(
         return
     }
 
-    val otherMemberIdentities = groupService.getGroupIdentities(groupModel).filter { !userService.isMe(it) }
+    val otherMemberIdentities = groupService.getMembersWithoutUser(groupModel).toList()
     val otherMembers = contactService.getByIdentities(otherMemberIdentities)
 
     // Disallow group calls in empty groups
@@ -131,8 +132,13 @@ fun initiateCall(
                 .show(activity.supportFragmentManager, dialogTagFetchingFeatureMask)
 
             withContext(Dispatchers.Default) {
-                otherMembers.forEach { UpdateFeatureLevelRoutine.removeTimeCache(it) }
-                UpdateFeatureLevelRoutine(contactService, apiConnector, otherMembers).run()
+                otherMembers.forEach { UpdateFeatureLevelRoutine.removeTimeCache(it.identity) }
+                UpdateFeatureLevelRoutine(
+                    contactModelRepository,
+                    userService,
+                    apiConnector,
+                    otherMembers.map { it.identity }
+                ).run()
             }
 
             DialogUtil.dismissDialog(activity.supportFragmentManager, dialogTagFetchingFeatureMask, true)
diff --git a/app/src/main/java/ch/threema/app/utils/MessageUtil.java b/app/src/main/java/ch/threema/app/utils/MessageUtil.java
index 87a536ca..dd6a9797 100644
--- a/app/src/main/java/ch/threema/app/utils/MessageUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/MessageUtil.java
@@ -23,10 +23,6 @@ package ch.threema.app.utils;
 
 import android.content.Context;
 
-import androidx.annotation.DrawableRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
@@ -36,6 +32,9 @@ import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.adapters.decorators.GroupStatusAdapterDecorator;
@@ -353,6 +352,7 @@ public class MessageUtil {
 
 	/**
 	 * Check if a MessageState change from fromState to toState is allowed
+	 *
 	 * @param fromState State from which a state change is requested
 	 * @param toState State to which a state change is requested
 	 * @param isGroupMessage true, if it's a group message
@@ -465,11 +465,12 @@ public class MessageUtil {
 	}
 
 	/**
-	 * Check if the provided MessageState is acceptable as a group message state and should be saved to the database
-	 * @param state MessageState
-	 * @return true if MessageState is acceptable, false otherwise
+	 * Check if the provided MessageState is a user reaction.
+	 *
+	 * @param state the message state
+	 * @return true if it is a user reaction, false otherwise
 	 */
-	public static boolean isAllowedGroupMessageState(MessageState state) {
+	public static boolean isReaction(MessageState state) {
 		return state == MessageState.USERACK || state == MessageState.USERDEC;
 	}
 
@@ -930,4 +931,20 @@ public class MessageUtil {
 			&& (message.getPostedAt() != null && message.getState() != MessageState.SENDFAILED)
 			&& !message.isDeleted();
 	}
+
+	@Nullable
+	public static MessageState receiptTypeToMessageState(int receiptType) {
+		switch (receiptType) {
+			case ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED:
+				return MessageState.DELIVERED;
+			case ProtocolDefines.DELIVERYRECEIPT_MSGREAD:
+				return MessageState.READ;
+			case ProtocolDefines.DELIVERYRECEIPT_MSGUSERACK:
+				return MessageState.USERACK;
+			case ProtocolDefines.DELIVERYRECEIPT_MSGUSERDEC:
+				return MessageState.USERDEC;
+			default:
+				return null;
+		}
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/utils/MimeUtil.java b/app/src/main/java/ch/threema/app/utils/MimeUtil.java
index af3cb638..5e764a10 100644
--- a/app/src/main/java/ch/threema/app/utils/MimeUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/MimeUtil.java
@@ -452,7 +452,7 @@ public class MimeUtil {
 		String mimeType = fileDataModel.getMimeType();
 
 		int messageContentsType = MessageContentsType.FILE;
-		if (mimeType.length() > 0) {
+		if (!mimeType.isEmpty()) {
 			if (MimeUtil.isGifFile(mimeType)) {
 				messageContentsType = MessageContentsType.GIF;
 			} else if (MimeUtil.isImageFile(mimeType)) {
diff --git a/app/src/main/java/ch/threema/app/utils/NameUtil.java b/app/src/main/java/ch/threema/app/utils/NameUtil.java
index 7eadb535..64516939 100644
--- a/app/src/main/java/ch/threema/app/utils/NameUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/NameUtil.java
@@ -36,6 +36,7 @@ import ch.threema.app.services.GroupService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.stores.PreferenceStore;
+import ch.threema.data.models.ContactModelData;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.DistributionListModel;
@@ -65,7 +66,7 @@ public class NameUtil {
 	 * Return the display name for a group.
 	 */
 	public static String getDisplayName(GroupModel groupModel, GroupService groupService) {
-		if (groupModel.getName() != null && groupModel.getName().length() > 0) {
+		if (groupModel.getName() != null && !groupModel.getName().isEmpty()) {
 			return groupModel.getName();
 		}
 
@@ -175,9 +176,23 @@ public class NameUtil {
 	 * Return the display name for a contact.
 	 */
 	@NonNull
-	public static String getDisplayName(ContactModel contactModel) {
-		String c = "";
+	public static String getDisplayName(@Nullable ContactModel contactModel) {
+		if (contactModel == null) {
+			return "undefined";
+		}
+
+		if (contactModel.getIdentity().isEmpty()) {
+			return "invalid contact";
+		}
+
+		String firstName = contactModel.getFirstName();
+		String lastName = contactModel.getLastName();
+
+		return getDisplayName(contactModel.getIdentity(), firstName, lastName);
+	}
 
+	@NonNull
+	public static String getDisplayName(@Nullable ch.threema.data.models.ContactModel contactModel) {
 		if (contactModel == null) {
 			return "undefined";
 		}
@@ -186,37 +201,47 @@ public class NameUtil {
 			return "invalid contact";
 		}
 
-		String f = contactModel.getFirstName();
-		String l = contactModel.getLastName();
+		ContactModelData data = contactModel.getData().getValue();
+		if (data == null) {
+			return "undefined";
+		}
+
+		return getDisplayName(data.identity, data.firstName, data.lastName);
+	}
 
-		if (TestUtil.isEmptyOrNull(f, l)) {
-			return contactModel.getIdentity();
+	public static String getDisplayName(@NonNull String identity, @Nullable String firstName, @Nullable String lastName) {
+		if (TestUtil.isEmptyOrNull(firstName, lastName)) {
+			return identity;
 		}
 
+		String c = "";
+
 		PreferenceService preferenceService = NameUtil.getPreferenceService();
 		if (preferenceService == null || preferenceService.isContactFormatFirstNameLastName()) {
-			if (f != null) {
-				c += f + " ";
+			if (firstName != null) {
+				c += firstName + " ";
 			}
 
-			if (l != null) {
-				c += l;
+			if (lastName != null) {
+				c += lastName;
 			}
 		} else {
-			if (l != null) {
-				c += l + " ";
+			if (lastName != null) {
+				c += lastName + " ";
 			}
 
-			if (f != null) {
-				c += f;
+			if (firstName != null) {
+				c += firstName;
 			}
 		}
 
+		c = c.trim();
+
 		if (TestUtil.isEmptyOrNull(c)) {
-			c = contactModel.getIdentity();
+			c = identity.trim();
 		}
 
-		return c.trim();
+		return c;
 	}
 
 	/**
diff --git a/app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt b/app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt
index 48f5b2e6..f2fa5834 100644
--- a/app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt
+++ b/app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt
@@ -22,33 +22,43 @@
 package ch.threema.app.utils
 
 import androidx.annotation.WorkerThread
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.protocol.runIdentityBlockedSteps
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.GroupService
 import ch.threema.app.services.IdListService
-import ch.threema.app.tasks.TaskCreator
+import ch.threema.app.services.PreferenceService
+import ch.threema.app.services.UserService
+import ch.threema.base.crypto.Nonce
 import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceScope
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.base.utils.Utils
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.models.BasicContact
 import ch.threema.domain.models.GroupId
 import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.ThreemaFeature
 import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityEncryptionResult
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
 import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
+import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
+import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode
 import ch.threema.domain.stores.ContactStore
 import ch.threema.domain.stores.IdentityStoreInterface
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.PassiveTaskCodec
+import ch.threema.domain.taskmanager.awaitOutgoingMessageAck
+import ch.threema.domain.taskmanager.awaitReflectAck
+import ch.threema.domain.taskmanager.getEncryptedOutgoingMessageEnvelope
+import ch.threema.domain.taskmanager.getEncryptedOutgoingMessageUpdateSentEnvelope
 import ch.threema.domain.taskmanager.toCspMessage
-import ch.threema.domain.taskmanager.waitForServerAck
 import ch.threema.storage.models.ContactModel
 import ch.threema.storage.models.GroupModel
 import java.util.Date
@@ -56,71 +66,73 @@ import java.util.Date
 private val logger = LoggingUtil.getThreemaLogger("OutgoingCspMessageUtils")
 
 /**
- * Get all contact models of the given identities. If there are unknown contact models, they are
- * fetched from the server. Note that this may throw an exception when no connection is available or
- * there are invalid identities.
+ * Map each identity to a cached contact. If the contact is known, it is converted to a cached
+ * contact. Otherwise, the contact is loaded from the contact store's cache or fetched from the
+ * server.
  */
-fun Collection<String>.toContactModels(contactService: ContactService, apiConnector: APIConnector) =
-    map { contactService.getByIdentity(it) ?: it.fetchContactModel(apiConnector) }
+@WorkerThread
+fun Iterable<String>.toBasicContacts(
+    contactModelRepository: ContactModelRepository,
+    contactStore: ContactStore,
+    apiConnector: APIConnector,
+) = map { it.toBasicContact(contactModelRepository, contactStore, apiConnector) }
+
+/**
+ * Map the identity to a cached contact. If the contact is known, it is converted to a cached
+ * contact. Otherwise, the contact is loaded from the contact store's cache or fetched from the
+ * server.
+ */
+@WorkerThread
+fun String.toBasicContact(
+    contactModelRepository: ContactModelRepository,
+    contactStore: ContactStore,
+    apiConnector: APIConnector,
+) = contactModelRepository.getByIdentity(this)?.data?.value?.toBasicContact()
+    ?: contactStore.getCachedContact(this)
+    ?: fetchContactModel(apiConnector)
 
 /**
  * Fetch a contact model. Note that this may throw an exception when no connection is available or
  * the identity is invalid.
  */
 @WorkerThread
-fun String.fetchContactModel(apiConnector: APIConnector): ContactModel =
+fun String.fetchContactModel(apiConnector: APIConnector): BasicContact =
     apiConnector.fetchIdentity(this)
         .let {
-            ContactModel(it.identity, it.publicKey)
-                .setFeatureMask(it.featureMask)
-                .setIdentityType(when (it.type) {
+            BasicContact(
+                it.identity,
+                it.publicKey,
+                it.featureMask.toULong(),
+                when (it.state) {
+                    IdentityState.ACTIVE.value -> IdentityState.ACTIVE
+                    IdentityState.INACTIVE.value -> IdentityState.INACTIVE
+                    else -> IdentityState.INVALID
+                },
+                when (it.type) {
                     0 -> IdentityType.NORMAL
                     1 -> IdentityType.WORK
                     else -> IdentityType.NORMAL /* Out of range! */
-                })
-                .setState(
-                    when (it.state) {
-                        IdentityState.ACTIVE -> ContactModel.State.ACTIVE
-                        IdentityState.INACTIVE -> ContactModel.State.INACTIVE
-                        else -> ContactModel.State.INVALID
-                    }
-                )
+                },
+            )
         }
 
 /**
- * Only known contact models are returned. Hidden contacts (acquaintance level 'group') are also
- * included. Note that no cached contacts (added with [ContactStore.addCachedContact]) are returned.
- */
-fun Collection<String>.toKnownContactModels(contactService: ContactService): Collection<ContactModel> =
-    mapNotNull { contactService.getByIdentity(it) }
-
-/**
- * All contacts that are not invalid are included. Only invalid contacts are discarded.
- */
-fun Collection<ContactModel>.filterValid() = filter { it.state != ContactModel.State.INVALID }
-
-/**
- * Only include non-blocked contacts. Note that only explicitly blocked identities are excluded.
- */
-fun Collection<ContactModel>.filterNotBlocked(blockedContactsService: IdListService) =
-    filterNotBlockedIf(true, blockedContactsService)
-
-/**
- * Only include non-blocked contacts if [applyFilter] is true. Note that only explicitly blocked
- * identities are excluded.
+ * Remove the group creator if no messages should be sent to it according to
+ * [GroupUtil.sendMessageToCreator].
  */
-fun Collection<ContactModel>.filterNotBlockedIf(
-    applyFilter: Boolean,
-    blockedContactsService: IdListService,
-) = filterIf(applyFilter) { !blockedContactsService.has(it.identity) }
+fun Collection<ContactModel>.removeCreatorIfRequired(group: GroupModel): Collection<ContactModel> =
+    filterIf(!GroupUtil.sendMessageToCreator(group)) { it.identity != group.creatorIdentity }
 
 /**
- * Filter the broadcast identity if no messages should be sent to it according to
+ * Remove the group creator if no messages should be sent to it according to
  * [GroupUtil.sendMessageToCreator].
  */
-fun Collection<ContactModel>.filterBroadcastIdentity(group: GroupModel): Collection<ContactModel> =
+fun Collection<ch.threema.data.models.ContactModel>.removeGroupCreatorIfRequired(group: GroupModel): Collection<ch.threema.data.models.ContactModel> =
     filterIf(!GroupUtil.sendMessageToCreator(group)) { it.identity != group.creatorIdentity }
 
+/**
+ * If the [condition] is fulfilled, the [predicate] is used to filter the collection.
+ */
 fun <T> Collection<T>.filterIf(condition: Boolean, predicate: (T) -> Boolean): Collection<T> =
     if (condition) {
         this.filter(predicate)
@@ -128,109 +140,80 @@ fun <T> Collection<T>.filterIf(condition: Boolean, predicate: (T) -> Boolean): C
         this
     }
 
-data class OutgoingMessageResult(
+/**
+ * Used to create messages that are sent with [ActiveTaskCodec.runBundledMessagesSendSteps].
+ */
+sealed interface OutgoingCspMessageCreator {
+
     /**
-     * The recipient that received the message.
+     * The message id that is used to create the message.
      */
-    val recipient: ContactModel,
+    val messageId: MessageId
 
     /**
-     * The forward security mode that has been used to encapsulate the message.
+     * The created at date of the message.
      */
-    val forwardSecurityMode: ForwardSecurityMode,
+    val createdAt: Date
 
     /**
-     * The timestamp when the message has been sent.
+     * Create a generic message that can be used to be reflected.
      */
-    val sentTimestamp: ULong,
-)
+    fun createGenericMessage(myIdentity: String): AbstractMessage
 
-/**
- * This class is internally used to bundle different information used for sending the messages out.
- */
-private data class MessageSendContainer(
-    val recipient: ContactModel,
-    val forwardSecurityEncryptionResult: ForwardSecurityEncryptionResult?,
-    val nonces: List<ByteArray>,
-    val outgoingMessages: List<AbstractMessage>,
-    val forwardSecurityMode: ForwardSecurityMode,
-) {
-    companion object {
-        internal fun create(
-            recipient: ContactModel,
-            innerMessage: AbstractMessage,
-            forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-            nonceFactory: NonceFactory,
-            handle: ActiveTaskCodec,
-        ): MessageSendContainer {
-            //TODO(ANDR-2519): Remove when md allows fs
-            val senderCanForwardSecurity = forwardSecurityMessageProcessor.isForwardSecurityEnabled()
-            val recipientCanForwardSecurity =
-                ThreemaFeature.canForwardSecurity(recipient.featureMask)
-            val innerMessageEncapsulated = innerMessage is ForwardSecurityEnvelopeMessage
-
-            // Create forward security encryption result
-            val encryptionResult =
-                if (senderCanForwardSecurity && recipientCanForwardSecurity && !innerMessageEncapsulated) {
-                    forwardSecurityMessageProcessor.makeMessage(recipient, innerMessage, handle)
-                } else {
-                    null
-                }
-
-            // Get the message from the result. If there is no result, then forward security is not
-            // supported (or the provided message is already encapsulated) and we add the list of
-            // the message without encapsulating it (again)
-            val outgoingMessages = encryptionResult?.outgoingMessages ?: listOf(innerMessage)
-
-            // Get the forward security mode from the encryption result if available, otherwise take
-            // the forward security mode of the inner message.
-            val forwardSecurityMode =
-                encryptionResult?.forwardSecurityMode ?: innerMessage.forwardSecurityMode
-
-            // Create a nonce for every outgoing message. Note that the nonce will be saved when the
-            // message is encoded (depending on the message type)
-            val nonces = outgoingMessages.map { nonceFactory.next(false) }
-
-            return MessageSendContainer(
-                recipient,
-                encryptionResult,
-                nonces,
-                outgoingMessages,
-                forwardSecurityMode,
-            )
-        }
-    }
-}
-
-/**
- * Used to create messages that are sent with [ActiveTaskCodec.sendMessageToReceivers].
- */
-sealed interface OutgoingCspMessageCreator {
     /**
-     * Create an abstract message containing all the message type specific information. The
-     * following fields must not be set, as they will be set by the send utils or the message
-     * creator:
+     * Create an abstract message containing all the message type specific information. Any
+     * implementation of this must set the following fields:
      *
-     * - [AbstractMessage.toIdentity]
-     * - [AbstractMessage.fromIdentity]
-     * - [AbstractMessage.date]
      * - [AbstractMessage.messageId]
+     * - [AbstractMessage.date]
+     *
+     * In case of a group message, the following fields must be set additionally:
+     *
      * - [AbstractGroupMessage.apiGroupId]
      * - [AbstractGroupMessage.groupCreator]
      *
      *  Note that each call of this method must return a new instance of the message.
      */
-    fun createAbstractMessage(): AbstractMessage
+    fun createAbstractMessage(fromIdentity: String, toIdentity: String): AbstractMessage
 }
 
 /**
- * Used to create messages that are sent with [ActiveTaskCodec.sendContactMessage].
+ * Used to create messages that are sent with [ActiveTaskCodec.runBundledMessagesSendSteps].
  */
 class OutgoingCspContactMessageCreator(
-    private val messageId: MessageId,
+    /**
+     * The message id that will be applied to the given message.
+     */
+    override val messageId: MessageId,
+
+    /**
+     * The date that will be used as created-at date for the message.
+     */
+    override val createdAt: Date,
+
+    /**
+     * The identity of the recipient contact.
+     */
+    private val identity: String,
+
+    /**
+     * This should create the contact message with all message type specific attributes set. Note
+     * that the following fields should not be set, as they will get overridden by these utils:
+     *
+     * - [AbstractMessage.toIdentity]
+     * - [AbstractMessage.fromIdentity]
+     * - [AbstractMessage.messageId]
+     * - [AbstractMessage.date]
+     */
     private val createContactMessage: () -> AbstractMessage,
 ) : OutgoingCspMessageCreator {
-    override fun createAbstractMessage(): AbstractMessage {
+
+    override fun createGenericMessage(myIdentity: String) =
+    // We need to set the 'toIdentity' here because the conversation is determined based on this
+        // message when reflecting it.
+        createAbstractMessage(myIdentity, identity)
+
+    override fun createAbstractMessage(fromIdentity: String, toIdentity: String): AbstractMessage {
         return createContactMessage().also {
             // Check that this message creator is only used for contact messages
             if (it is AbstractGroupMessage) {
@@ -240,45 +223,82 @@ class OutgoingCspContactMessageCreator(
             }
 
             it.messageId = messageId
+            it.date = createdAt
+            it.fromIdentity = fromIdentity
+            it.toIdentity = toIdentity
         }
     }
+
 }
 
 /**
- * Used to create message that are sent with [ActiveTaskCodec.sendGroupMessage].
+ * Used to create message that are sent with [ActiveTaskCodec.runBundledMessagesSendSteps].
  */
 class OutgoingCspGroupMessageCreator(
-    private val messageId: MessageId,
+    /**
+     * The message id that will be set for the outgoing messages.
+     */
+    override val messageId: MessageId,
+
+    /**
+     * The date that will be used as created-at date for the outgoing messages.
+     */
+    override val createdAt: Date,
+
+    /**
+     * The group id of the group that will be set for the outgoing messages.
+     */
     private val groupId: GroupId,
+
+    /**
+     * The group creator identity that will be set for the outgoing messages.
+     */
     private val groupCreator: String,
+
+    /**
+     * This should create the contact message with all message type specific attributes set. Note
+     * that the following fields should not be set, as they will get overridden by these utils:
+     *
+     * - [AbstractMessage.toIdentity]
+     * - [AbstractMessage.fromIdentity]
+     * - [AbstractMessage.messageId]
+     * - [AbstractMessage.date]
+     * - [AbstractGroupMessage.apiGroupId]
+     * - [AbstractGroupMessage.groupCreator]
+     *
+     * Each call of this function must return a new instance of the message.
+     */
     private val createGroupMessage: () -> AbstractGroupMessage,
 ) : OutgoingCspMessageCreator {
 
     constructor(
         messageId: MessageId,
+        createdAt: Date,
         group: GroupModel,
         createAbstractGroupMessage: () -> AbstractGroupMessage,
     ) : this(
         messageId,
+        createdAt,
         group.apiGroupId,
         group.creatorIdentity,
-        createAbstractGroupMessage
+        createAbstractGroupMessage,
     )
 
-    /**
-     * Create an abstract message containing all the message type specific information. The
-     * following fields must not be set, as they will be set by the send utils:
-     *
-     * - [AbstractMessage.toIdentity]
-     * - [AbstractMessage.fromIdentity]
-     * - [AbstractMessage.date]
-     * - [AbstractMessage.messageId]
-     *
-     *  Note that each call of this method must return a new instance of the message.
-     */
-    override fun createAbstractMessage(): AbstractGroupMessage {
+    override fun createGenericMessage(myIdentity: String): AbstractMessage =
+    // We do not need to set a 'toIdentity' in case of a generic message as this message will
+    // never be sent. In case of a group message it is sufficient if it contains the correct
+        // group identity.
+        createAbstractMessage(myIdentity, "")
+
+    override fun createAbstractMessage(
+        fromIdentity: String,
+        toIdentity: String,
+    ): AbstractGroupMessage {
         return createGroupMessage().also {
             it.messageId = messageId
+            it.date = createdAt
+            it.fromIdentity = fromIdentity
+            it.toIdentity = toIdentity
             it.apiGroupId = groupId
             it.groupCreator = groupCreator
         }
@@ -286,207 +306,481 @@ class OutgoingCspGroupMessageCreator(
 }
 
 /**
- * Run the _Common Send Steps_ to send the provided message to the given recipient. Note that if the
- * recipient is blocked and [AbstractMessage.exemptFromBlocking] is not set, the message is not sent
- * and null is returned.
- *
- * @return the [OutgoingMessageResult] with the send information of the message or null if it was
- * not sent because the recipient is blocked
- */
-suspend fun ActiveTaskCodec.sendContactMessage(
-    messageCreator: OutgoingCspContactMessageCreator,
-    recipient: ContactModel,
-    forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    identityStore: IdentityStoreInterface,
-    contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    blockedContactsService: IdListService,
-    taskCreator: TaskCreator,
-): OutgoingMessageResult? = sendMessageToReceivers(
-    messageCreator,
-    setOf(recipient),
-    forwardSecurityMessageProcessor,
-    identityStore,
-    contactStore,
-    nonceFactory,
-    blockedContactsService,
-    taskCreator
-).firstOrNull()
-
-/**
- * Run the _Common Send Steps_ and the _Common Group Send Steps_. If the user is not a member of the
- * given group, null is returned. The messages are created for every recipient of the group.
- * Depending on the message type, they are only sent to not-blocked contacts.
- *
- * Note that the messages are only sent to recipients that are part of the group.
- *
- * @return the [OutgoingMessageResult]s with the send information of the messages that were sent, or
- * null if the user is not a member of the group
+ * This handle can be used to keep track of the sending process of a message.
  */
-suspend fun ActiveTaskCodec.sendGroupMessage(
-    messageCreator: OutgoingCspGroupMessageCreator,
-    recipients: Set<ContactModel>,
-    group: GroupModel,
-    forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    identityStore: IdentityStoreInterface,
-    contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    groupService: GroupService,
-    blockedContactsService: IdListService,
-    taskCreator: TaskCreator,
-): Set<OutgoingMessageResult>? {
-    if (!groupService.isGroupMember(group)) {
-        logger.warn("Tried to send a message in a group where the user is not a member anymore")
-        return null
-    }
+class OutgoingCspMessageHandle(
+    /**
+     * The receivers of the message.
+     */
+    val receivers: Set<BasicContact>,
+    /**
+     * The message creator that creates the message that will be sent.
+     */
+    val messageCreator: OutgoingCspMessageCreator,
+    /**
+     * This callback is run as soon as the sent at timestamp is determined.
+     */
+    val markAsSent: (sentAt: ULong) -> Unit = { },
+    /**
+     * This callback is run as soon as the forward security modes are known.
+     */
+    val addForwardSecurityStateInfo: (stateMap: Map<String, ForwardSecurityMode>) -> Unit = { },
+) {
+    constructor(
+        receiver: BasicContact,
+        messageCreator: OutgoingCspMessageCreator,
+        markAsSent: (sentAt: ULong) -> Unit = { },
+        addForwardSecurityStateInfo: (stateMap: Map<String, ForwardSecurityMode>) -> Unit = { },
+    ) : this(setOf(receiver), messageCreator, markAsSent, addForwardSecurityStateInfo)
+}
 
-    val groupMembers = groupService.getMembers(group).toSet()
+private fun OutgoingCspMessageHandle.toOutgoingCspMessageSender(
+    services: OutgoingCspMessageServices,
+): OutgoingCspMessageSender {
+    val myIdentity = services.identityStore.identity
+    val genericMessage = messageCreator.createGenericMessage(myIdentity)
+    val filteredReceivers = receivers
+        .filter { it.identity != myIdentity }
+        .filter { it.identityState != IdentityState.INVALID }
+        .filterBlockedRecipients(
+            genericMessage,
+            services.contactModelRepository,
+            services.contactStore,
+            services.groupService,
+            services.blockedContactsService,
+            services.preferenceService,
+        )
+        .toSet()
 
-    return sendMessageToReceivers(
+    return OutgoingCspMessageSender(
+        filteredReceivers,
         messageCreator,
-        recipients.intersect(groupMembers),
-        forwardSecurityMessageProcessor,
-        identityStore,
-        contactStore,
-        nonceFactory,
-        blockedContactsService,
-        taskCreator
+        genericMessage,
+        markAsSent,
+        addForwardSecurityStateInfo,
+        services.multiDeviceManager,
+        services.forwardSecurityMessageProcessor,
+        services.identityStore,
+        services.contactStore,
+        services.nonceFactory,
     )
 }
 
-/**
- * Run the _Common Send Steps_ for the given recipients. Note that this method does not run the
- * _Common Group Send Steps_. Therefore, this method can also be used to send a group message to
- * members that are not part of the group anymore (e.g. [GroupLeaveMessage]s) or in a group where
- * the user is not a member (e.g. when receiving a [GroupSetupMessage] from a blocked identity).
- */
-suspend fun ActiveTaskCodec.sendMessageToReceivers(
-    messageCreator: OutgoingCspMessageCreator,
-    recipients: Set<ContactModel>,
-    forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    identityStore: IdentityStoreInterface,
-    contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    blockedContactsService: IdListService,
-    taskCreator: TaskCreator,
-): Set<OutgoingMessageResult> {
-    val myIdentity = identityStore.identity
+private class OutgoingCspMessageSender(
+    receivers: Set<BasicContact>,
+    val messageCreator: OutgoingCspMessageCreator,
+    /**
+     * A generic message that can be used to check message type properties.
+     */
+    val genericMessage: AbstractMessage,
+    private val markAsSent: (sentAt: ULong) -> Unit,
+    private val addForwardSecurityStateInfo: (stateMap: Map<String, ForwardSecurityMode>) -> Unit,
+    multiDeviceManager: MultiDeviceManager,
+    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
+    private val identityStore: IdentityStoreInterface,
+    private val contactStore: ContactStore,
+    private val nonceFactory: NonceFactory,
+) {
+    /**
+     * The multi device properties. Note that they are not null if and only if multi device is
+     * active. Therefore, this can be used to check whether multi device is enabled or not.
+     */
+    private val multiDeviceProperties = if (multiDeviceManager.isMultiDeviceActive) {
+        multiDeviceManager.propertiesProvider.get()
+    } else {
+        null
+    }
 
-    val recipientList = recipients.filter { it.identity != myIdentity }
-    val messageList = recipientList.map { messageCreator.createAbstractMessage() }
+    /**
+     * The csp nonce that is used for the message. Note that any additional forward security control
+     * message uses a different nonce.
+     */
+    private val receiverPairs: List<Pair<BasicContact, Nonce>> by lazy {
+        receivers.map { it to nonceFactory.next(NonceScope.CSP) }
+    }
 
-    // Perform some sanity checks
-    messageList.let {
-        val expectedSize = it.size
-        val messageSet = it.toSet()
+    /**
+     * The receivers of the message.
+     */
+    val receivers: List<BasicContact> by lazy {
+        receiverPairs.map { it.first }
+    }
 
-        if (messageSet.size < expectedSize) {
-            throw IllegalArgumentException("The message creator created at least two identical messages")
-        }
+    /**
+     * Contains the recipient identities and message ids where the csp message ack is still pending.
+     */
+    private val pendingCspMessageAcks by lazy { mutableListOf<Pair<String, MessageId>>() }
+
+    /**
+     * Contains the reflect id and d2d nonce where the reflect ack is still pending.
+     */
+    private var pendingReflectAck: Pair<UInt, Nonce>? = null
+
+    /**
+     * Stores the forward security encryption results that contain the updated fs session states
+     * that must be commited after the csp message has been acknowledged by the server.
+     */
+    private val forwardSecurityResults by lazy { mutableListOf<ForwardSecurityEncryptionResult>() }
 
-        messageSet.map { message -> message.type }.toSet().size.let { numTypes ->
-            if (numTypes > 1) {
-                throw IllegalArgumentException("The message create created messages of $numTypes different types")
+    /**
+     * The forward security modes of the message. This should reflect the state of the main message
+     * (of the same type as [genericMessage]) and is independent of any other messages sent with it,
+     * e.g., a forward security control message.
+     */
+    private val fsModeMap by lazy { mutableMapOf<String, ForwardSecurityMode>() }
+
+    /**
+     * Reflect the message. Note that the message will only be reflected if multi device is enabled.
+     * It is safe to call this method even if multi device is deactivated.
+     */
+    suspend fun reflectMessage(handle: ActiveTaskCodec) {
+        if (multiDeviceProperties != null && genericMessage.reflectOutgoing()) {
+            genericMessage.logMessage("Reflecting")
+            val cspNonces = receiverPairs.map { it.second }.toList()
+            val encryptedEnvelopeResult = getEncryptedOutgoingMessageEnvelope(
+                genericMessage,
+                cspNonces,
+                multiDeviceProperties.mediatorDeviceId,
+                multiDeviceProperties.keys,
+            )
+
+            if (encryptedEnvelopeResult != null) {
+                val reflectId: UInt = handle.reflect(encryptedEnvelopeResult)
+                pendingReflectAck = reflectId to encryptedEnvelopeResult.nonce
+            } else {
+                logger.error("Cannot reflect message")
             }
         }
     }
 
-    // Create list of recipients that are not blocked (or exempted from blocking) with the messages
-    val recipientMessageList = recipientList.zip(messageList).filter { (recipient, message) ->
-        //Filter blocked recipients except message type is exempted from blocking
-        (message.exemptFromBlocking() || !blockedContactsService.has(recipient.identity)).also {
-            if (!it) {
-                message.logMessage("Skipping message because recipient $recipient is blocked:")
+    /**
+     * Await every reflection ack in [pendingReflectAck]. If no message has been reflected this
+     * immediately returns. Note that this message may return without suspending even if a message
+     * has been reflected before. This method clears the [pendingReflectAck]s.
+     *
+     * @return the reflected at timestamp or null if there is nothing to await
+     */
+    suspend fun awaitReflectAck(handle: PassiveTaskCodec): ULong? {
+        val (reflectId, d2dNonce) = pendingReflectAck ?: return null
+        val reflectedAt = handle.awaitReflectAck(reflectId)
+        if (genericMessage.protectAgainstReplay()) {
+            nonceFactory.store(NonceScope.D2D, d2dNonce)
+        }
+        pendingReflectAck = null
+        genericMessage.logMessage("Received reflect ack for")
+        return reflectedAt
+    }
+
+    /**
+     * Send the message. This will encapsulate the message in a forward security envelope if it is
+     * not already a forward security envelope message.
+     */
+    suspend fun sendMessage(handle: ActiveTaskCodec) {
+        genericMessage.logMessage("Sending")
+        receiverPairs.mapNotNull { (receiver, nonce) ->
+            // Encapsulate the messages with the given nonce. Note that this may lead to two
+            // messages in total if an fs init or empty message needs to be sent too.
+            if (genericMessage.type != ProtocolDefines.MSGTYPE_FS_ENVELOPE) {
+                val result = forwardSecurityMessageProcessor.runFsEncapsulationSteps(
+                    receiver,
+                    messageCreator.createAbstractMessage(
+                        identityStore.identity,
+                        receiver.identity
+                    ),
+                    nonce,
+                    nonceFactory,
+                    handle
+                )
+                receiver.identity to result
+            } else {
+                logger.error("Sending an already encapsulated message with the bundled messages send steps is currently not possible.")
+                null
+            }
+        }.forEach { (receiverIdentity, fsEncryptionResult) ->
+            // Update the fs state map and store the result for commiting the fs session later on
+            fsModeMap[receiverIdentity] = fsEncryptionResult.forwardSecurityMode
+            forwardSecurityResults.add(fsEncryptionResult)
+
+            for ((message, nonce) in fsEncryptionResult.outgoingMessages) {
+                // If a server ack is required, store the message id to await it later on
+                if (!message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK)) {
+                    pendingCspMessageAcks.add(receiverIdentity to message.messageId)
+                }
+
+                // Store the nonce if the message should be protected against replay
+                if (message.protectAgainstReplay()) {
+                    nonceFactory.store(NonceScope.CSP, nonce)
+                }
+
+                // Send the message
+                handle.write(
+                    message.toCspMessage(
+                        identityStore,
+                        contactStore,
+                        nonce
+                    )
+                )
+                message.logMessage("Sent")
             }
         }
     }
 
-    // TODO(ANDR-2705): Reflect the message here
+    /**
+     * Await server ack. If there is no message without the flag
+     * [ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK]
+     */
+    suspend fun awaitServerAck(
+        handle: PassiveTaskCodec,
+    ) {
+        pendingCspMessageAcks.forEach { (receiverIdentity, messageId) ->
+            handle.awaitOutgoingMessageAck(messageId, receiverIdentity)
+        }
+        pendingCspMessageAcks.clear()
+    }
 
-    val createdAt = Date()
+    /**
+     * Commit the forward security session states. Every state that has changed in [sendMessage]
+     * will be committed by running this method. Note that this should happen after the server ack
+     * has been received. The [forwardSecurityResults] will be cleared afterwards.
+     */
+    fun commitFsSession() {
+        forwardSecurityResults.forEach {
+            forwardSecurityMessageProcessor.commitSessionState(it)
+        }
+        forwardSecurityResults.clear()
+    }
 
-    // Prepare messages to be sent
-    recipientMessageList.forEach { (recipient, message) ->
-        message.also {
-            it.fromIdentity = myIdentity
-            it.toIdentity = recipient.identity
-            it.date = createdAt
+    /**
+     * Reflect a message update sent if MD is active and the message type requires this. This will
+     * add the reflect ids to [pendingReflectAck].
+     */
+    suspend fun reflectMessageUpdateSent(handle: ActiveTaskCodec) {
+        if (multiDeviceProperties != null && genericMessage.reflectSentUpdate()) {
+            genericMessage.logMessage("Reflecting outgoing message sent update for")
+            val encryptedEnvelopeResult = getEncryptedOutgoingMessageUpdateSentEnvelope(
+                genericMessage,
+                multiDeviceProperties.mediatorDeviceId,
+                multiDeviceProperties.keys
+            )
+            val reflectId: UInt = handle.reflect(encryptedEnvelopeResult)
+            pendingReflectAck = reflectId to encryptedEnvelopeResult.nonce
         }
-        message.logMessage("Preparing to send")
     }
 
-    // Create the send containers of the remaining recipients and messages
-    val sendContainers = recipientMessageList.map { (recipient, message) ->
-        MessageSendContainer.create(
-            recipient,
-            message,
+    fun storeForwardSecurityStateInfo() {
+        addForwardSecurityStateInfo(fsModeMap)
+    }
+
+    fun storeSentAt(sentAt: ULong) {
+        markAsSent(sentAt)
+    }
+}
+
+data class OutgoingCspMessageServices(
+    val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
+    val identityStore: IdentityStoreInterface,
+    val userService: UserService,
+    val contactStore: ContactStore,
+    val contactService: ContactService,
+    val contactModelRepository: ContactModelRepository,
+    val groupService: GroupService,
+    val nonceFactory: NonceFactory,
+    val blockedContactsService: IdListService,
+    val preferenceService: PreferenceService,
+    val multiDeviceManager: MultiDeviceManager,
+) {
+    companion object {
+        fun ServiceManager.getOutgoingCspMessageServices() = OutgoingCspMessageServices(
             forwardSecurityMessageProcessor,
+            identityStore,
+            userService,
+            contactStore,
+            contactService,
+            modelRepositories.contacts,
+            groupService,
             nonceFactory,
-            this
+            blockedContactsService,
+            preferenceService,
+            multiDeviceManager,
         )
     }
+}
+
+suspend fun ActiveTaskCodec.runBundledMessagesSendSteps(
+    outgoingCspMessageHandle: OutgoingCspMessageHandle,
+    services: OutgoingCspMessageServices,
+) = runBundledMessagesSendSteps(listOf(outgoingCspMessageHandle), services)
 
-    // Cache the public keys of the contacts (if not available)
-    sendContainers.forEach { (recipient, _) ->
-        if (contactStore.getContactForIdentityIncludingCache(recipient.identity) == null) {
-            contactStore.addCachedContact(recipient)
+suspend fun ActiveTaskCodec.runBundledMessagesSendSteps(
+    outgoingCspMessageHandles: List<OutgoingCspMessageHandle>,
+    services: OutgoingCspMessageServices,
+) {
+    val outgoingCspMessageSenders = outgoingCspMessageHandles
+        .map { it.toOutgoingCspMessageSender(services) }
+
+    val profilePictureSenders = outgoingCspMessageSenders
+        .map { messageSender ->
+            messageSender.receivers
+                .mapNotNull { receiver ->
+                    runProfilePictureDistributionSteps(
+                        messageSender.genericMessage,
+                        receiver,
+                        services,
+                    )
+                }
+        }.flatten()
+
+    val messageSenders = outgoingCspMessageSenders + profilePictureSenders
+
+    val localSentAtTimestamp = System.currentTimeMillis().toULong()
+
+    messageSenders
+        .onEach {
+            it.reflectMessage(this)
+        }.onEach {
+            it.awaitReflectAck(this)
+        }.onEach {
+            it.sendMessage(this)
+        }.onEach {
+            it.awaitServerAck(this)
+            it.commitFsSession()
+        }.onEach {
+            it.reflectMessageUpdateSent(this)
+        }.forEach {
+            val sentAt = it.awaitReflectAck(this) ?: localSentAtTimestamp
+            it.storeSentAt(sentAt)
+            it.storeForwardSecurityStateInfo()
         }
+}
+
+private fun Iterable<BasicContact>.filterBlockedRecipients(
+    abstractMessage: AbstractMessage,
+    contactModelRepository: ContactModelRepository,
+    contactStore: ContactStore,
+    groupService: GroupService,
+    blockedContactsService: IdListService,
+    preferenceService: PreferenceService,
+) = filter {
+    if (abstractMessage.exemptFromBlocking()) {
+        return@filter true
     }
 
-    // Send messages
-    sendContainers.forEach { messageContainer ->
-        val outgoingMessages = messageContainer.outgoingMessages
+    val isBlocked = runIdentityBlockedSteps(
+        it.identity,
+        contactModelRepository,
+        contactStore,
+        groupService,
+        blockedContactsService,
+        preferenceService,
+    ).isBlocked()
 
-        for ((message, nonce) in outgoingMessages.zip(messageContainer.nonces)) {
-            write(message.toCspMessage(identityStore, contactStore, nonceFactory, nonce))
-            message.logMessage("Sent")
-        }
+    if (isBlocked) {
+        abstractMessage.logMessage("Skipping recipient ${it.identity} for")
     }
 
-    // Await server acknowledgments
-    sendContainers.forEach { messageContainer ->
-        for (message in messageContainer.outgoingMessages) {
-            if (!message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK)) {
-                waitForServerAck(message.messageId, message.toIdentity)
-                message.logMessage("Received server ack for")
-            }
-        }
+    !isBlocked
+}
+
+/**
+ * Run the profile picture distribution steps.
+ *
+ * TODO(ANDR-3243): Update the profile picture distribution steps.
+ */
+private fun runProfilePictureDistributionSteps(
+    genericMessage: AbstractMessage,
+    receiver: BasicContact,
+    services: OutgoingCspMessageServices,
+): OutgoingCspMessageSender? {
+    val prefix = "Profile picture distribution"
+    val receiverIdentity = receiver.identity
+
+    if (!genericMessage.allowUserProfileDistribution()) {
+        return null
     }
 
-    // Schedule user profile distribution tasks
-    sendContainers.forEach { messageContainer ->
-        // Schedule a user profile distribution task if at least one of the sent messages allows it
-        if (messageContainer.outgoingMessages.any { it.allowUserProfileDistribution() }) {
-            taskCreator.scheduleProfilePictureExecution(messageContainer.recipient.identity)
-        }
+    if (ContactUtil.isEchoEchoOrGatewayContact(receiverIdentity)) {
+        logger.info(
+            "{}: Contact {} should not receive the profile picture",
+            prefix,
+            receiverIdentity
+        )
+        return null
     }
 
-    // Commit the session state of each recipient
-    sendContainers.forEach { messageContainer ->
-        messageContainer.forwardSecurityEncryptionResult?.let {
-            forwardSecurityMessageProcessor.commitSessionState(it)
-        }
+    val contactModel = services.contactModelRepository.getByIdentity(receiverIdentity) ?: run {
+        logger.info("{}: Contact model for identity {} not found", prefix, receiverIdentity)
+        return null
+    }
+
+    if (!services.contactService.isContactAllowedToReceiveProfilePicture(receiverIdentity)) {
+        logger.info(
+            "{}: Contact {} is not allowed to receive the profile picture",
+            prefix,
+            receiverIdentity,
+        )
+        return null
+    }
+
+    val data = services.userService.uploadUserProfilePictureOrGetPreviousUploadData()
+    if (data.blobId == null) {
+        logger.warn("{}: Blob ID is null; abort", prefix)
+        return null
     }
 
-    // TODO(ANDR-2705): Reflect an outgoing message update
+    val contactModelData = contactModel.data.value ?: run {
+        logger.info("{}: Contact {} has been deleted", prefix, receiverIdentity)
+        return null
+    }
 
-    // Set the timestamp of each message container
-    val sentTimestamp = Date().time.toULong()
-    return sendContainers.map {
-        OutgoingMessageResult(
-            it.recipient,
-            it.forwardSecurityMode,
-            sentTimestamp,
+    if (data.blobId.contentEquals(contactModelData.profilePictureBlobId)) {
+        logger.debug(
+            "{}: Contact {} already has the latest profile picture",
+            prefix,
+            receiverIdentity
         )
-    }.toSet()
+        return null
+    }
+
+    contactModel.setProfilePictureBlobId(data.blobId)
+
+    val profilePictureMessageCreator =
+        OutgoingCspContactMessageCreator(
+            MessageId(),
+            Date(),
+            receiverIdentity,
+        ) {
+            if (data.blobId.contentEquals(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)) {
+                DeleteProfilePictureMessage()
+            } else {
+                SetProfilePictureMessage(
+                    blobId = data.blobId,
+                    size = data.size,
+                    encryptionKey = data.encryptionKey,
+                )
+            }
+        }
+
+    return OutgoingCspMessageHandle(
+        setOf(receiver),
+        profilePictureMessageCreator,
+    ).toOutgoingCspMessageSender(services)
 }
 
 private fun AbstractMessage.logMessage(logMessage: String) {
-    logger.info(
-        "{} message {} of type {} to {}",
-        logMessage,
-        messageId,
-        Utils.byteToHex(type.toByte(), true, true),
-        toIdentity
-    )
+    if (toIdentity.isNotBlank()) {
+        logger.info(
+            "{} message {} of type {} to {}",
+            logMessage,
+            messageId,
+            Utils.byteToHex(type.toByte(), true, true),
+            toIdentity,
+        )
+    } else {
+        logger.info(
+            "{} message {} of type {}",
+            logMessage,
+            messageId,
+            Utils.byteToHex(type.toByte(), true, true),
+        )
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/utils/QuoteUtil.java b/app/src/main/java/ch/threema/app/utils/QuoteUtil.java
index e766a33e..eec66640 100644
--- a/app/src/main/java/ch/threema/app/utils/QuoteUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/QuoteUtil.java
@@ -24,6 +24,7 @@ package ch.threema.app.utils;
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.util.Pair;
 
 import org.slf4j.Logger;
 
@@ -201,31 +202,53 @@ public class QuoteUtil {
 	}
 
 	/**
-	 * Extract body text and quoted message reference from text string containing a quote v2 signature and add to MessageModel
-	 * If no valid quote v2 signature is found, add full input text to body
-	 * @param messageModel where to add extracted information
-	 * @param text source text containing a quote v2 signature
+	 * Get the body and quoted message id based on the text of a text message. Note that the message
+	 * id is null, if the text does not contain a quote. If parsing the text fails, the passed text
+	 * is returned as body and the message id is null.
+	 *
+	 * @param text the text of a text message
+	 * @return a pair of the body and the quoted message id
 	 */
-	public static void addBodyAndQuotedMessageId(@NonNull AbstractMessageModel messageModel, @Nullable String text) {
+	@NonNull
+	public static Pair<String, String> getBodyAndQuotedMessageId(@Nullable String text) {
+		String body = text;
+		String quotedMessageId = null;
+
 		if (!TestUtil.isEmptyOrNull(text)) {
 			Matcher match = quoteV2MatchPattern.matcher(text);
 			try {
 				if (match.find()) {
 					if (match.groupCount() == 2) {
-						messageModel.setQuotedMessageId(match.group(1));
-						if (!TestUtil.isEmptyOrNull(match.group(2))) {
-							messageModel.setBody(match.group(2).trim());
-						} else {
-							messageModel.setBody("");
+						quotedMessageId = match.group(1);
+						body = match.group(2);
+						if (body == null) {
+							body = "";
 						}
-						return;
 					}
 				}
 			} catch (Exception e) {
-				//
+				logger.error("Could not extract quote from text");
 			}
 		}
-		messageModel.setBody(text);
+
+		return new Pair<>(body, quotedMessageId);
+	}
+
+
+	/**
+	 * Extract body text and quoted message reference from text string containing a quote v2 signature and add to MessageModel
+	 * If no valid quote v2 signature is found, add full input text to body
+	 * @param messageModel where to add extracted information
+	 * @param text source text containing a quote v2 signature
+	 */
+	public static void addBodyAndQuotedMessageId(@NonNull AbstractMessageModel messageModel, @Nullable String text) {
+		Pair<String, String> quoteContent = getBodyAndQuotedMessageId(text);
+
+		// The first string contains the body
+		messageModel.setBody(quoteContent.first);
+
+		// The second string contains the message id (as string)
+		messageModel.setQuotedMessageId(quoteContent.second);
 	}
 
 	/**
diff --git a/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java b/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java
index 56738a69..8ea9089a 100644
--- a/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java
@@ -461,7 +461,10 @@ public final class ShortcutUtil {
 	 * @param messageReceiver MessageReceiver represented by shortcut
 	 */
 	@WorkerThread
-	public static void updateShareTargetShortcut(MessageReceiver messageReceiver) {
+	public static void updateShareTargetShortcut(@Nullable MessageReceiver<?> messageReceiver) {
+        if (messageReceiver == null) {
+            return;
+        }
 		synchronized (dynamicShortcutLock) {
 			List<ShortcutInfoCompat> shortcutInfos = ShortcutManagerCompat.getDynamicShortcuts(getContext());
 			for (ShortcutInfoCompat shortcutInfo: shortcutInfos) {
diff --git a/app/src/main/java/ch/threema/app/utils/StreamUtil.java b/app/src/main/java/ch/threema/app/utils/StreamUtil.java
deleted file mode 100644
index 0b6687a1..00000000
--- a/app/src/main/java/ch/threema/app/utils/StreamUtil.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.net.Uri;
-
-import org.slf4j.Logger;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-
-import ch.threema.app.ThreemaApplication;
-import ch.threema.base.utils.LoggingUtil;
-
-public class StreamUtil {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("StreamUtil");
-
-	public static InputStream getFromUri(Context context, Uri uri) throws FileNotFoundException {
-		InputStream inputStream = null;
-
-		if (uri != null && uri.getScheme() != null) {
-			if (ContentResolver.SCHEME_CONTENT.equalsIgnoreCase(uri.getScheme())) {
-				try {
-					inputStream = context.getContentResolver().openInputStream(uri);
-				} catch (FileNotFoundException e) {
-					logger.info("Unable to get an InputStream for this file using ContentResolver: " + uri.toString());
-				}
-			}
-
-			if (inputStream == null) {
-				// try to open as local file if openInputStream fails for a content Uri
-				String filePath = FileUtil.getRealPathFromURI(context, uri);
-				String appPath;
-				String tmpPath;
-				String intTmpPath;
-
-				try {
-					tmpPath = ThreemaApplication.getServiceManager().getFileService().getTempPath().getAbsolutePath();
-					intTmpPath = ThreemaApplication.getServiceManager().getFileService().getIntTmpPath().getAbsolutePath();
-					appPath = context.getApplicationInfo().dataDir;
-				} catch (Exception e) {
-					return null;
-				}
-
-				if (TestUtil.required(filePath, appPath, tmpPath)) {
-					// do not allow sending of files from local directories - but allow tmp dir
-					if (!filePath.startsWith(appPath) || filePath.startsWith(tmpPath) || filePath.startsWith(intTmpPath)) {
-						inputStream = new FileInputStream(filePath);
-					} else {
-						throw new FileNotFoundException("File on private directory");
-					}
-				} else {
-					inputStream = context.getContentResolver().openInputStream(uri);
-				}
-			}
-			return inputStream;
-		} else {
-			throw new FileNotFoundException();
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/utils/StreamUtil.kt b/app/src/main/java/ch/threema/app/utils/StreamUtil.kt
new file mode 100644
index 00000000..c70b6a4c
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/utils/StreamUtil.kt
@@ -0,0 +1,118 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2014-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.utils
+
+import android.content.ContentResolver
+import android.content.Context
+import android.net.Uri
+import ch.threema.app.ThreemaApplication
+import ch.threema.base.utils.LoggingUtil
+import org.slf4j.Logger
+import java.io.FileInputStream
+import java.io.FileNotFoundException
+import java.io.InputStream
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("StreamUtil")
+
+@Throws(FileNotFoundException::class)
+fun getFromUri(context: Context, uri: Uri?): InputStream? {
+    var inputStream: InputStream? = null
+
+    if (uri == null || uri.scheme == null) {
+        throw FileNotFoundException()
+    }
+
+    if (ContentResolver.SCHEME_CONTENT.equals(uri.scheme, ignoreCase = true)) {
+        try {
+            inputStream = context.contentResolver.openInputStream(uri)
+        } catch (e: FileNotFoundException) {
+            logger.info("Unable to get an InputStream for this file using ContentResolver: $uri")
+        }
+    }
+
+    if (inputStream == null) {
+        // try to open as local file if openInputStream fails for a content Uri
+        val filePath = FileUtil.getRealPathFromURI(context, uri)
+        val appPath: String
+        val tmpPath: String
+        val intTmpPath: String
+
+        try {
+            tmpPath =
+                ThreemaApplication.getServiceManager()!!.fileService.tempPath.absolutePath
+            intTmpPath =
+                ThreemaApplication.getServiceManager()!!.fileService.intTmpPath.absolutePath
+            appPath = context.applicationInfo.dataDir
+        } catch (e: Exception) {
+            return null
+        }
+
+        inputStream = if (TestUtil.required(filePath, appPath, tmpPath)) {
+            // do not allow sending of files from local directories - but allow tmp dir
+            if (!filePath!!.startsWith(appPath) || filePath.startsWith(tmpPath) || filePath.startsWith(
+                    intTmpPath
+                )
+            ) {
+                FileInputStream(filePath)
+            } else {
+                throw FileNotFoundException("File on private directory")
+            }
+        } else {
+            context.contentResolver.openInputStream(uri)
+        }
+    }
+    return inputStream
+}
+
+fun InputStream?.contentEquals(byteArray: ByteArray?): Boolean {
+    if (this == null && byteArray == null) {
+        return true
+    }
+
+    if (this == null) {
+        return false
+    }
+
+    if (byteArray == null) {
+        return false
+    }
+
+    use { input ->
+        var index = 0
+        var next: Int
+        while (input.read().also { next = it } != -1) {
+            if (next.toByte() != byteArray[index]) {
+                return false
+            }
+            index++
+        }
+        return index == byteArray.size
+    }
+}
+
+fun InputStream?.toByteArray(): ByteArray? {
+    if (this == null) {
+        return null
+    }
+
+    return buffered().use(InputStream::readBytes)
+}
diff --git a/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.java b/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.java
deleted file mode 100644
index f1f2fcd4..00000000
--- a/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils;
-
-import com.google.common.util.concurrent.ListenableFuture;
-
-import org.slf4j.Logger;
-
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ExecutionException;
-
-import androidx.work.WorkInfo;
-import androidx.work.WorkManager;
-import ch.threema.base.utils.LoggingUtil;
-
-public class WorkManagerUtil {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("WorkManagerUtil");
-
-	/**
-	 * Check if periodic work with provided tag is already scheduled or running and has the same schedule period.
-	 * Cancel existing work in case of error
-	 * @param workManager An instance of the WorkManager
-	 * @param tag Unique work name
-	 * @param schedulePeriod scheduled period of this work
-	 * @return true if no periodic work with the same tag exists or the existing work has a different schedule period;
-	 *      false if the work already exists and has the same schedule period
-	 */
-	public static boolean shouldScheduleNewWorkManagerInstance(WorkManager workManager, String tag, long schedulePeriod) {
-		// check if work is already scheduled or running, if yes, do not attempt launch a new request
-		ListenableFuture<List<WorkInfo>> workInfos = workManager.getWorkInfosForUniqueWork(tag);
-		try {
-			List<WorkInfo> workInfoList = workInfos.get();
-			for (WorkInfo workInfo : workInfoList) {
-				WorkInfo.State state = workInfo.getState();
-				if (state == WorkInfo.State.RUNNING || state == WorkInfo.State.ENQUEUED) {
-					logger.debug("a job of the same name is already running or queued");
-					Set<String> tags = workInfo.getTags();
-					if (tags.size() > 0 && tags.contains(String.valueOf(schedulePeriod))) {
-						logger.debug("job has same schedule period");
-						return false;
-					} else {
-						logger.debug("job has a different schedule period");
-						break;
-					}
-				}
-			}
-		} catch (Exception e) {
-			logger.info("WorkManager Exception");
-			workManager.cancelUniqueWork(tag);
-		}
-		return true;
-	}
-
-	public static boolean isWorkManagerInstanceScheduled(WorkManager workManager, String tag) {
-		ListenableFuture<List<WorkInfo>> workInfos = workManager.getWorkInfosForUniqueWork(tag);
-		try {
-			List<WorkInfo> workInfoList = workInfos.get();
-			for (WorkInfo workInfo : workInfoList) {
-				WorkInfo.State state = workInfo.getState();
-				if (state == WorkInfo.State.ENQUEUED || state == WorkInfo.State.BLOCKED) {
-					return true;
-				}
-			}
-		} catch (ExecutionException | InterruptedException e) {
-			logger.error("Could not get work info", e);
-			return false;
-		}
-		return false;
-	}
-
-}
diff --git a/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.kt b/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.kt
new file mode 100644
index 00000000..799d9fea
--- /dev/null
+++ b/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.kt
@@ -0,0 +1,112 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.utils
+
+import android.content.Context
+import android.text.format.DateUtils
+import androidx.work.Operation
+import androidx.work.WorkInfo
+import androidx.work.WorkManager
+import androidx.work.await
+import ch.threema.base.utils.LoggingUtil
+import java.util.concurrent.ExecutionException
+
+private val logger = LoggingUtil.getThreemaLogger("WorkManagerUtil")
+
+object WorkManagerUtil {
+    @JvmStatic
+    fun cancelUniqueWork(context: Context, uniqueWorkName: String): Operation {
+        logger.info("Cancel unique work '{}'", uniqueWorkName)
+        return WorkManager.getInstance(context).cancelUniqueWork(uniqueWorkName)
+    }
+
+    suspend fun cancelUniqueWorkAwait(context: Context, uniqueWorkName: String) {
+        logger.info("Cancel result = {}", cancelUniqueWork(context, uniqueWorkName).await())
+    }
+
+    /**
+     * Check if periodic work with provided [uniqueWorkName] is already scheduled or running and has the same schedule period.
+     * Cancel existing work in case of error
+     *
+     * @param workManager An instance of the WorkManager
+     * @param uniqueWorkName Unique work name
+     * @param schedulePeriod scheduled period of this work
+     * @return true if no periodic work with the same tag exists or the existing work has a different schedule period;
+     *      false if the work already exists and has the same schedule period
+     */
+    @JvmStatic
+    fun shouldScheduleNewWorkManagerInstance(workManager: WorkManager, uniqueWorkName: String, schedulePeriod: Long): Boolean {
+        return try {
+            workManager.getWorkInfosForUniqueWork(uniqueWorkName).get().none {
+                val state = it.state
+                if (state == WorkInfo.State.RUNNING || state == WorkInfo.State.ENQUEUED) {
+                    logger.debug("A job of the same name is already running or queued")
+                    if (it.tags.contains(schedulePeriod.toString())) {
+                        logger.debug("Job has same schedule period")
+                        true
+                    } else {
+                        logger.debug("Job has a different schedule period")
+                        false
+                    }
+                } else {
+                    false
+                }
+            }
+        } catch (e: Exception) {
+            logger.info("WorkManager Exception")
+            workManager.cancelUniqueWork(uniqueWorkName)
+            true
+        }
+    }
+
+    @JvmStatic
+    fun isWorkManagerInstanceScheduled(workManager: WorkManager, uniqueWorkName: String): Boolean {
+        return try {
+            workManager.getWorkInfosForUniqueWork(uniqueWorkName).get().any {
+                val state = it.state
+                state == WorkInfo.State.ENQUEUED || state == WorkInfo.State.BLOCKED
+            }
+        } catch (e: Exception) {
+            when (e) {
+                is ExecutionException, is InterruptedException -> logger.error("Could not get work info", e)
+                else -> throw e
+            }
+            false
+        }
+    }
+
+    /**
+     * Normalize a schedule period in seconds to milliseconds:
+     *
+     * When [schedulePeriodS] is <= 0, a period of one day is returned.
+     * Otherwise the [schedulePeriodS] is converted to milliseconds.
+     *
+     * @return The normalized schedule period in milliseconds
+     */
+    @JvmStatic
+    fun normalizeSchedulePeriod(schedulePeriodS: Int): Long {
+        return when {
+            schedulePeriodS <= 0 -> DateUtils.DAY_IN_MILLIS
+            else -> schedulePeriodS * DateUtils.SECOND_IN_MILLIS
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java b/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java
index 8f36b529..6f50c1b8 100644
--- a/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java
+++ b/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java
@@ -125,6 +125,7 @@ import ch.threema.app.services.LifetimeService;
 import ch.threema.app.services.LockAppService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SensorService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.ui.AnimatedEllipsisTextView;
 import ch.threema.app.ui.BottomSheetItem;
 import ch.threema.app.ui.DebouncedOnClickListener;
@@ -151,6 +152,7 @@ import ch.threema.app.voip.services.VoipStateService;
 import ch.threema.app.voip.util.VoipUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData;
@@ -284,6 +286,10 @@ public class CallActivity extends ThreemaActivity implements
 	private NotificationManagerCompat notificationManagerCompat;
 	private AudioManager audioManager;
 
+	@Nullable
+	private ContactModelRepository contactModelRepository;
+	@Nullable
+	private UserService userService;
 	private ContactService contactService;
 	private SensorService sensorService;
 	private PreferenceService preferenceService;
@@ -639,8 +645,8 @@ public class CallActivity extends ThreemaActivity implements
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			this.handleUpdate(contactModel.getIdentity());
+		public void onAvatarChanged(@NonNull String identity) {
+			this.handleUpdate(identity);
 		}
 
 		private void handleUpdate(String identity) {
@@ -733,7 +739,14 @@ public class CallActivity extends ThreemaActivity implements
 		// Threema services
 		try {
 			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+			if (serviceManager == null) {
+				logger.error("Service manager is null");
+				finish();
+				return;
+			}
+			this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
 			this.contactService = serviceManager.getContactService();
+			this.userService = serviceManager.getUserService();
 			this.sensorService = serviceManager.getSensorService();
 			this.preferenceService = serviceManager.getPreferenceService();
 			this.voipStateService = serviceManager.getVoipStateService();
@@ -1203,7 +1216,11 @@ public class CallActivity extends ThreemaActivity implements
 			}.execute();
 
 			this.commonViews.contactName.setText(NameUtil.getDisplayNameOrNickname(contact, true));
-			this.commonViews.contactDots.setImageDrawable(ContactUtil.getVerificationDrawable(this, contact));
+			this.commonViews.contactDots.setImageDrawable(ContactUtil.getVerificationDrawable(
+				this,
+				contact.verificationLevel,
+				contact.getWorkVerificationLevel()
+			));
 		}
 	}
 
@@ -1267,11 +1284,17 @@ public class CallActivity extends ThreemaActivity implements
 					setEnabled(this.commonViews.toggleOutgoingVideoButton, true);
 				} else {
 					try {
+						if (contactModelRepository == null || userService == null) {
+							logger.warn("Could not refresh feature mask due to unavailable services");
+							return;
+						}
+
 						CompletableFuture
 							.runAsync(new UpdateFeatureLevelRoutine(
-								contactService,
+								contactModelRepository,
+								userService,
 								apiConnector,
-								Collections.singletonList(contact)
+								Collections.singletonList(contact.getIdentity())
 							))
 							.thenRun(() -> RuntimeUtil.runOnUiThread(() -> {
 								if (!isDestroyed()) {
diff --git a/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java b/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java
index 15abcaaa..a9ae1f2b 100644
--- a/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java
+++ b/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java
@@ -21,12 +21,9 @@
 
 package ch.threema.app.voip.activities;
 
-import static ch.threema.app.preference.SettingsAdvancedOptionsFragment.THREEMA_SUPPORT_IDENTITY;
-
 import android.annotation.SuppressLint;
 import android.content.ClipData;
 import android.content.ClipboardManager;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.Handler;
 import android.view.MenuItem;
@@ -37,12 +34,6 @@ import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-
 import com.google.android.material.progressindicator.CircularProgressIndicator;
 
 import org.slf4j.Logger;
@@ -56,24 +47,35 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.ThreemaToolbarActivity;
+import ch.threema.app.asynctasks.SendToSupportBackgroundTask;
+import ch.threema.app.asynctasks.SendToSupportResult;
 import ch.threema.app.dialogs.TextEntryDialog;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.LocaleUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.WebRTCUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.PeerConnectionClient;
 import ch.threema.app.voip.util.SdpPatcher;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.protobuf.callsignaling.O2OCall;
-import ch.threema.storage.models.ContactModel;
 
 /**
  * An activity to debug problems with WebRTC (in the context of Threema Calls).
@@ -83,8 +85,13 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 	private static final String DIALOG_TAG_SEND_WEBRTC_DEBUG = "swd";
 
 	// Threema services
-	@NonNull private MessageService messageService;
-	@NonNull private ContactService contactService;
+	@Nullable private MessageService messageService;
+	@Nullable private ContactService contactService;
+	@Nullable private APIConnector apiConnector;
+	@Nullable private ContactModelRepository contactModelRepository;
+	@Nullable private UserService userService;
+
+	@Nullable private BackgroundExecutor backgroundExecutor;
 
 	// Views
 	@NonNull private CircularProgressIndicator progressBar;
@@ -126,6 +133,9 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 			finish();
 			return;
 		}
+		this.apiConnector = serviceManager.getAPIConnector();
+		this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+		this.userService = serviceManager.getUserService();
 
 		final ActionBar actionBar = getSupportActionBar();
 		if (actionBar != null) {
@@ -428,17 +438,30 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 
 	@SuppressLint("StaticFieldLeak")
 	private void sendToSupport(@NonNull String caption) {
-		if (this.contactService == null || messageService == null) {
+		if (
+			contactService == null
+				|| messageService == null
+				|| userService == null
+				|| apiConnector == null
+				|| contactModelRepository == null
+		) {
 			logger.error("Cannot send to support, some services are null");
 			return;
 		}
 
-		new AsyncTask<Void, Void, Boolean>() {
+		SendToSupportBackgroundTask sendToSupportTask = new SendToSupportBackgroundTask(
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			this
+		) {
+			@NonNull
 			@Override
-			protected Boolean doInBackground(Void... voids) {
+			public SendToSupportResult onSupportAvailable(@NonNull ContactModel contactModel) {
 				try {
-					final ContactModel contactModel = contactService.getOrCreateByIdentity(THREEMA_SUPPORT_IDENTITY, true);
-					final ContactMessageReceiver messageReceiver = contactService.createReceiver(contactModel);
+					final ContactMessageReceiver messageReceiver = contactService.createReceiver(
+						contactModel
+					);
 
 					messageService.sendText(clipboardString +
 						"\n---\n" +
@@ -448,23 +471,28 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 						"Threema " + ConfigUtils.getAppVersion() + "\n" +
 						getMyIdentity(), messageReceiver);
 
-					return true;
+					return SendToSupportResult.SUCCESS;
 				} catch (Exception e) {
 					logger.error("Exception while sending information to support", e);
-					return false;
+					return SendToSupportResult.FAILED;
 				}
 			}
 
 			@Override
-			protected void onPostExecute(Boolean success) {
+			public void onFinished(SendToSupportResult result) {
 				Toast.makeText(
 					getApplicationContext(),
-					Boolean.TRUE.equals(success) ? R.string.message_sent : R.string.an_error_occurred,
+					result == SendToSupportResult.SUCCESS ? R.string.message_sent : R.string.an_error_occurred,
 					Toast.LENGTH_LONG
 				).show();
 				finish();
 			}
-		}.execute();
+		};
+
+		if (backgroundExecutor == null) {
+			backgroundExecutor = new BackgroundExecutor();
+		}
+		backgroundExecutor.execute(sendToSupportTask);
 	}
 
 	@AnyThread
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt b/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt
index 35a1c693..1107044e 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt
@@ -615,8 +615,10 @@ class GroupCallManagerImpl(
 			return
 		}
 
-		logger.debug("Show group call notification")
-		notificationService.addGroupCallNotification(group, callerContactModel)
+        if (callerContactModel.identity != contactService.me.identity) {
+		    logger.debug("Show group call notification")
+            notificationService.addGroupCallNotification(group, callerContactModel)
+        }
 	}
 
 	/**
@@ -812,8 +814,7 @@ class GroupCallManagerImpl(
 			groupJson.put("id", Base64.encodeBytes(group.apiGroupId.groupId))
 
 			val membersJson = JSONArray()
-			groupService.getGroupIdentities(group)
-				.mapNotNull { contactService.getByIdentity(it) }
+			groupService.getMembers(group)
 				.forEach {
 					val member = JSONObject()
 					member.put("identity", it.identity)
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt b/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt
index cf73dd5f..5098666f 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt
@@ -65,6 +65,8 @@ import ch.threema.app.voip.services.VoipStateService
 import ch.threema.app.voip.util.VoipUtil
 import ch.threema.base.ThreemaException
 import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.storage.models.GroupModel
 import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.CoroutineScope
@@ -143,6 +145,8 @@ class GroupCallService : Service() {
     private lateinit var identityStore: IdentityStore
     private lateinit var contactService: ContactService
     private lateinit var groupService: GroupService
+    private lateinit var apiConnector: APIConnector
+    private lateinit var contactModelRepository: ContactModelRepository
     private lateinit var sfuConnection: SfuConnection
     private lateinit var preferenceService: PreferenceService
     private lateinit var voipStateService: VoipStateService
@@ -201,6 +205,8 @@ class GroupCallService : Service() {
         contactService = serviceManager.contactService
         sfuConnection = serviceManager.sfuConnection
         groupService = serviceManager.groupService
+        apiConnector = serviceManager.apiConnector
+        contactModelRepository = serviceManager.modelRepositories.contacts
         preferenceService = serviceManager.preferenceService
         voipStateService = serviceManager.voipStateService
     }
@@ -329,7 +335,9 @@ class GroupCallService : Service() {
                 controller.dependencies = GroupCallDependencies(
                     identityStore,
                     contactService,
-                    groupService
+                    groupService,
+                    apiConnector,
+                    contactModelRepository
                 )
                 CoroutineScope(GroupCallThreadUtil.DISPATCHER).launch {
                     launch { controller.join(applicationContext, sfuBaseUrl, sfuConnection) { stopService() } }
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt
index 909fe667..4e912898 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt
@@ -24,9 +24,13 @@ package ch.threema.app.voip.groupcall.sfu
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.GroupService
 import ch.threema.app.stores.IdentityStore
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.protocol.api.APIConnector
 
 data class GroupCallDependencies(
     val identityStore: IdentityStore,
     val contactService: ContactService,
-    val groupService: GroupService
+    val groupService: GroupService,
+    val apiConnector: APIConnector,
+    val contactModelRepository: ContactModelRepository,
 )
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt
index 3d8fc41f..c42e6662 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt
@@ -24,6 +24,11 @@ package ch.threema.app.voip.groupcall.sfu
 import androidx.annotation.AnyThread
 import androidx.annotation.UiThread
 import androidx.annotation.WorkerThread
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask
+import ch.threema.app.asynctasks.ContactAvailable
+import ch.threema.app.asynctasks.Failed
 import ch.threema.app.voip.groupcall.GroupCallException
 import ch.threema.app.voip.groupcall.GroupCallThreadUtil
 import ch.threema.app.voip.groupcall.gcBlake2b
@@ -36,6 +41,7 @@ import ch.threema.app.voip.groupcall.sfu.webrtc.ConnectionCtx
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.storage.models.ContactModel
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
 import com.neilalexander.jnacl.NaCl
 import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.Deferred
@@ -49,7 +55,7 @@ class P2PHandshake private constructor(
     val sender: LocalParticipant,
     val receiverId: ParticipantId,
     private val call: GroupCall,
-    initialState: HandshakeState
+    initialState: HandshakeState,
 ) {
     private var handshakeState: HandshakeState = initialState
         set(value) {
@@ -77,7 +83,8 @@ class P2PHandshake private constructor(
     lateinit var p2pContexts: P2PContexts
 
     private val queuedMessages = mutableListOf<P2PMessageContent>()
-    private val completedSignal: CompletableDeferred<Pair<P2PContexts, List<P2PMessageContent.MediaKey>>> = CompletableDeferred()
+    private val completedSignal: CompletableDeferred<Pair<P2PContexts, List<P2PMessageContent.MediaKey>>> =
+        CompletableDeferred()
 
     val isDone: Boolean
         get() = handshakeState == HandshakeState.DONE
@@ -113,10 +120,12 @@ class P2PHandshake private constructor(
                 logger.debug("Queuing Rekey to be sent once authenticated")
                 queuedMessages.add(message)
             }
+
             HandshakeState.DONE -> {
                 // Note: This is considered unreachable
                 throw Error("Cannot queue Rekey, handshake already done!")
             }
+
             HandshakeState.CANCELLED -> logger.debug("Ignoring Rekey because handshake is cancelled")
             else -> logger.debug("Ignoring Rekey because we have not sent a Handshake.*Auth yet")
         }
@@ -131,8 +140,14 @@ class P2PHandshake private constructor(
             try {
                 when (handshakeState) {
                     HandshakeState.INIT -> handleUnexpectedMessage(message)
-                    HandshakeState.AWAIT_EXISTING_PARTICIPANT_HELLO -> handleMessageInAwaitEpHelloState(message)
-                    HandshakeState.AWAIT_NEW_PARTICIPANT_HELLO -> handleMessageInAwaitNpHelloState(message)
+                    HandshakeState.AWAIT_EXISTING_PARTICIPANT_HELLO -> handleMessageInAwaitEpHelloState(
+                        message
+                    )
+
+                    HandshakeState.AWAIT_NEW_PARTICIPANT_HELLO -> handleMessageInAwaitNpHelloState(
+                        message
+                    )
+
                     HandshakeState.AWAIT_AUTH -> handleMessageInAwaitAuthState(message)
                     HandshakeState.DONE, HandshakeState.CANCELLED -> handleUnexpectedMessage(message)
                 }
@@ -161,7 +176,8 @@ class P2PHandshake private constructor(
         logger.info("Create Hello from {} to {}", sender.id, receiverId)
         val hello = Handshake.Hello(
             call.dependencies.identityStore.identity,
-            call.dependencies.identityStore.publicNickname ?: call.dependencies.identityStore.identity,
+            call.dependencies.identityStore.publicNickname
+                ?: call.dependencies.identityStore.identity,
             senderP2PContext.pckPublic,
             senderP2PContext.pcck
         )
@@ -180,7 +196,8 @@ class P2PHandshake private constructor(
             receiverP2PContext.pcck,
             call.context.connectionCtx.pcmk.all().map { P2PMessageContent.MediaKey.fromState(it) },
         )
-        val encryptedInnerData = NaCl.symmetricEncryptData(auth.getEnvelopeBytes(), gcnhak, innerNonce)
+        val encryptedInnerData =
+            NaCl.symmetricEncryptData(auth.getEnvelopeBytes(), gcnhak, innerNonce)
         val encryptedAuthData = pck.encrypt(
             innerNonce + encryptedInnerData,
             senderP2PContext.nextPcckNonce()
@@ -200,9 +217,16 @@ class P2PHandshake private constructor(
                 renderer: SurfaceViewRenderer,
                 width: Int,
                 height: Int,
-                fps: Int
+                fps: Int,
             ): DetachSinkFn {
-                call.context.sendMessageToSfu { P2SMessage.SubscribeParticipantCamera(participantId, width, height, fps) }
+                call.context.sendMessageToSfu {
+                    P2SMessage.SubscribeParticipantCamera(
+                        participantId,
+                        width,
+                        height,
+                        fps
+                    )
+                }
 
                 participantLogger.trace("Starting to render remote camera video")
                 val videoContext = remoteCtx?.cameraVideoContext
@@ -215,14 +239,22 @@ class P2PHandshake private constructor(
             @UiThread
             override fun unsubscribeCamera() {
                 participantLogger.trace("Unsubscribe camera participant={}", participantId.id)
-                call.context.sendMessageToSfu { P2SMessage.UnsubscribeParticipantCamera(participantId) }
+                call.context.sendMessageToSfu {
+                    P2SMessage.UnsubscribeParticipantCamera(
+                        participantId
+                    )
+                }
             }
         }
     }
 
     @WorkerThread
     private fun handleUnexpectedMessage(message: P2POuterEnvelope) {
-        logger.warn("Received unexpected message from {} while in handshake state '{}'", message.senderId, handshakeState)
+        logger.warn(
+            "Received unexpected message from {} while in handshake state '{}'",
+            message.senderId,
+            handshakeState
+        )
     }
 
     @WorkerThread
@@ -273,7 +305,7 @@ class P2PHandshake private constructor(
     private fun isGroupMember(identity: String): Boolean {
         val groupService = call.dependencies.groupService
         return groupService.getById(call.description.groupId.id)?.let {
-            identity in groupService.getGroupIdentities(it)
+            groupService.isGroupMember(it, identity)
         } ?: false
     }
 
@@ -307,7 +339,7 @@ class P2PHandshake private constructor(
         GroupCallThreadUtil.assertDispatcherThread()
 
         try {
-            receiverContact = call.dependencies.contactService.getOrCreateByIdentity(hello.identity, false)
+            receiverContact = getOrCreateContact(hello.identity)
             val receiverParticipant = createRemoteParticipant(receiverId)
             receiverP2PContext = RemoteP2PContext(receiverParticipant, hello.pck, hello.pcck)
         } catch (e: Exception) {
@@ -315,6 +347,36 @@ class P2PHandshake private constructor(
         }
     }
 
+    @WorkerThread
+    private fun getOrCreateContact(identity: String): ContactModel {
+        // Check if the contact already exists
+        call.dependencies.contactService.getByIdentity(identity)?.let {
+            return it
+        }
+
+        val result = BasicAddOrUpdateContactBackgroundTask(
+            identity = identity,
+            AcquaintanceLevel.GROUP,
+            myIdentity = sender.identity,
+            call.dependencies.apiConnector,
+            call.dependencies.contactModelRepository,
+            AddContactRestrictionPolicy.CHECK,
+            context = ThreemaApplication.getAppContext(),
+            null
+        ).runSynchronously()
+
+        when (result) {
+            is ContactAvailable -> Unit
+            is Failed -> {
+                logger.error("Could not create contact: {}", result.message)
+                throw IllegalStateException("Could not create contact")
+            }
+        }
+
+        return call.dependencies.contactService.getByIdentity(identity)
+            ?: throw IllegalStateException("Contact must exist after creating it")
+    }
+
     @WorkerThread
     private fun handleMessageInAwaitAuthState(message: P2POuterEnvelope) {
         GroupCallThreadUtil.assertDispatcherThread()
@@ -332,7 +394,9 @@ class P2PHandshake private constructor(
 
     @WorkerThread
     private fun hasValidRepeatedAuthFeatures(auth: Handshake.Auth): Boolean {
-        return auth.pck.contentEquals(senderP2PContext.pckPublic) && auth.pcck.contentEquals(senderP2PContext.pcck)
+        return auth.pck.contentEquals(senderP2PContext.pckPublic) && auth.pcck.contentEquals(
+            senderP2PContext.pcck
+        )
     }
 
     @WorkerThread
@@ -367,7 +431,8 @@ class P2PHandshake private constructor(
         GroupCallThreadUtil.assertDispatcherThread()
 
         val nonce = decryptedOuterData.copyOfRange(0, NaCl.NONCEBYTES)
-        val encryptedInnerData = decryptedOuterData.copyOfRange(NaCl.NONCEBYTES, decryptedOuterData.size)
+        val encryptedInnerData =
+            decryptedOuterData.copyOfRange(NaCl.NONCEBYTES, decryptedOuterData.size)
         return NaCl.symmetricDecryptData(encryptedInnerData, gcnhak, nonce)
     }
 
@@ -407,7 +472,7 @@ class P2PHandshake private constructor(
     @WorkerThread
     internal class P2PHandshakeFactory(
         private val sender: LocalParticipant,
-        private val call: GroupCall
+        private val call: GroupCall,
     ) {
         /**
          * This will initiate a Handshake with an existing call participant.
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt
index 2fd54c12..89d246f6 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt
@@ -178,7 +178,7 @@ internal class SfuConnectionImpl (
     }
 
     private fun getUserAgent(): String {
-        return "${ProtocolStrings.USER_AGENT}/${version.version}"
+        return "${ProtocolStrings.USER_AGENT}/${version.versionString}"
     }
 
     @WorkerThread
diff --git a/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java b/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java
index 0f1fe32a..54f58a5a 100644
--- a/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java
+++ b/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java
@@ -21,22 +21,6 @@
 
 package ch.threema.app.voip.services;
 
-import static ch.threema.app.ThreemaApplication.INCOMING_CALL_NOTIFICATION_ID;
-import static ch.threema.app.ThreemaApplication.getAppContext;
-import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
-import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_MUTABLE;
-import static ch.threema.app.voip.activities.CallActivity.EXTRA_ACCEPT_INCOMING_CALL;
-import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CALL_ID;
-import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CONTACT_IDENTITY;
-import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_REJECT_REASON;
-import static ch.threema.app.voip.services.VoipCallService.ACTION_ICE_CANDIDATES;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_ACTIVITY_MODE;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CALL_ID;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANCEL_WEAR;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANDIDATES;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CONTACT_IDENTITY;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_IS_INITIATOR;
-
 import android.app.ActivityOptions;
 import android.app.Notification;
 import android.app.PendingIntent;
@@ -61,18 +45,6 @@ import android.text.Spannable;
 import android.text.SpannableString;
 import android.text.style.ForegroundColorSpan;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.WorkerThread;
-import androidx.core.app.NotificationCompat;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.LocusIdCompat;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import androidx.work.Data;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.WorkManager;
-
 import org.slf4j.Logger;
 import org.webrtc.IceCandidate;
 import org.webrtc.SessionDescription;
@@ -88,17 +60,30 @@ import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
+import androidx.core.app.NotificationCompat;
+import androidx.core.app.NotificationManagerCompat;
+import androidx.core.content.LocusIdCompat;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import androidx.work.Data;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkManager;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.notifications.NotificationChannels;
 import ch.threema.app.notifications.NotificationGroups;
+import ch.threema.app.routines.UpdateFeatureLevelRoutine;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.LifetimeService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.RingtoneService;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.DNDUtil;
 import ch.threema.app.utils.IdUtil;
 import ch.threema.app.utils.MediaPlayerStateWrapper;
@@ -129,6 +114,22 @@ import ch.threema.domain.protocol.csp.messages.voip.features.VideoFeature;
 import ch.threema.storage.models.ContactModel;
 import java8.util.concurrent.CompletableFuture;
 
+import static ch.threema.app.ThreemaApplication.INCOMING_CALL_NOTIFICATION_ID;
+import static ch.threema.app.ThreemaApplication.getAppContext;
+import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
+import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_MUTABLE;
+import static ch.threema.app.voip.activities.CallActivity.EXTRA_ACCEPT_INCOMING_CALL;
+import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CALL_ID;
+import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CONTACT_IDENTITY;
+import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_REJECT_REASON;
+import static ch.threema.app.voip.services.VoipCallService.ACTION_ICE_CANDIDATES;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_ACTIVITY_MODE;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CALL_ID;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANCEL_WEAR;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANDIDATES;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CONTACT_IDENTITY;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_IS_INITIATOR;
+
 /**
  * The service keeping track of VoIP call state.
  * <p>
@@ -576,7 +577,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
             return false;
         }
         final String sdpType = offer.getSdpType();
-        if (!sdpType.equals("offer")) {
+        if (sdpType == null || !sdpType.equals("offer")) {
             logger.error("Offer data is invalid: Sdp type is {}, not offer", sdpType);
             return false;
         }
@@ -632,13 +633,13 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
      * @return true if messages was successfully processed
      */
     @WorkerThread
-    public synchronized boolean handleCallOffer(final VoipCallOfferMessage msg) {
+    public synchronized boolean handleCallOffer(@NonNull final VoipCallOfferMessage voipCallOfferMessage) {
         // Unwrap data
-        final String callerIdentity = msg.getFromIdentity();
-        final VoipCallOfferData callOfferData = msg.getData();
+        final String callerIdentity = voipCallOfferMessage.getFromIdentity();
+        final VoipCallOfferData callOfferData = voipCallOfferMessage.getData();
         if (callOfferData == null) {
             logger.warn("Call offer received from {}. Data is null, ignoring.", callerIdentity);
-            return true;
+            return false;
         }
         final long callId = callOfferData.getCallIdOrDefault(0L);
         logCallInfo(
@@ -652,7 +653,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         final ContactModel contact = this.contactService.getByIdentity(callerIdentity);
         if (contact == null) {
             logCallError(callId, "Could not fetch contact for identity {}", callerIdentity);
-            return true;
+            return false;
         }
 
         // Handle some reasons for rejecting calls...
@@ -698,7 +699,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         Config.getTurnServerCache().prefetchTurnServers();
 
         // Reset fetch cache
-        ch.threema.app.routines.UpdateFeatureLevelRoutine.removeTimeCache(contact);
+        UpdateFeatureLevelRoutine.removeTimeCache(contact.getIdentity());
 
         // Store offer in offer map
         logger.debug("Adding information for call {} to offerMap", callId);
@@ -736,7 +737,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         this.setStateRinging(callId);
 
         // Show call notification
-        final Notification notification = this.showNotification(contact, accept, reject, msg);
+        final Notification notification = this.showNotification(contact, accept, reject, voipCallOfferMessage);
 
         DNDUtil dndUtil = DNDUtil.getInstance();
         boolean isReceiverMuted = dndUtil.isMutedPrivate(messageReceiver, null);
@@ -752,7 +753,9 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         this.startVibration(notification, isMuted);
 
         // Update conversation timestamp
-        contactService.bumpLastUpdate(callerIdentity);
+        if (voipCallOfferMessage.bumpLastUpdate()) {
+            contactService.bumpLastUpdate(callerIdentity);
+        }
 
         // Send "ringing" message to caller
         try {
@@ -770,7 +773,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         // Notify listeners
         VoipListenerManager.messageListener.handle(listener -> {
             if (listener.handle(callerIdentity)) {
-                listener.onOffer(callerIdentity, msg.getData());
+                listener.onOffer(callerIdentity, voipCallOfferMessage.getData());
             }
         });
         VoipListenerManager.callEventListener.handle(listener -> listener.onRinging(callerIdentity));
@@ -854,16 +857,16 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
      * @return true if messages was successfully processed
      */
     @WorkerThread
-    public synchronized boolean handleICECandidates(final VoipICECandidatesMessage msg) {
+    public synchronized boolean handleICECandidates(@NonNull final VoipICECandidatesMessage voipICECandidatesMessage) {
         // Unwrap data
-        final VoipICECandidatesData candidatesData = msg.getData();
+        final VoipICECandidatesData candidatesData = voipICECandidatesMessage.getData();
         if (candidatesData == null) {
-            logger.warn("Call ICE candidate message received from {}. Data is null, ignoring", msg.getFromIdentity());
-            return true;
+            logger.warn("Call ICE candidate message received from {}. Data is null, ignoring", voipICECandidatesMessage.getFromIdentity());
+            return false;
         }
         if (candidatesData.getCandidates() == null) {
-            logger.warn("Call ICE candidate message received from {}. Candidates are null, ignoring", msg.getFromIdentity());
-            return true;
+            logger.warn("Call ICE candidate message received from {}. Candidates are null, ignoring", voipICECandidatesMessage.getFromIdentity());
+            return false;
         }
 
         // Validate Call ID
@@ -871,21 +874,21 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         if (!this.isCallIdValid(callId)) {
             logger.info(
                 "Call ICE candidate message received from {} for an invalid Call ID ({}, local={}), ignoring",
-                msg.getFromIdentity(), callId, this.callState.getCallId()
+                voipICECandidatesMessage.getFromIdentity(), callId, this.callState.getCallId()
             );
-            return true;
+            return false;
         }
 
         // The "removed" flag is deprecated, see ANDR-1145 / SE-66
         if (candidatesData.isRemoved()) {
             logCallInfo(callId, "Call ICE candidate message received from {} with removed=true, ignoring");
-            return true;
+            return false;
         }
 
         logCallInfo(
             callId,
             "Call ICE candidate message received from {} ({} candidates)",
-            msg.getFromIdentity(), candidatesData.getCandidates().length
+            voipICECandidatesMessage.getFromIdentity(), candidatesData.getCandidates().length
         );
         for (VoipICECandidatesData.Candidate candidate : candidatesData.getCandidates()) {
             logCallInfo(callId, "  Incoming ICE candidate: {}", candidate.getCandidate());
@@ -894,21 +897,19 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         // Handle candidates depending on state
         if (this.callState.isIdle() || this.callState.isRinging()) {
             // If the call hasn't been started yet, cache the candidate(s)
-            this.cacheCandidate(msg.getFromIdentity(), candidatesData);
+            this.cacheCandidate(voipICECandidatesMessage.getFromIdentity(), candidatesData);
         } else if (this.callState.isInitializing() || this.callState.isCalling()) {
             // Otherwise, send candidate(s) directly to call service via broadcast
             Intent intent = new Intent();
             intent.setAction(ACTION_ICE_CANDIDATES);
-            intent.putExtra(EXTRA_CALL_ID, msg.getData().getCallIdOrDefault(0L));
-            intent.putExtra(EXTRA_CONTACT_IDENTITY, msg.getFromIdentity());
+            intent.putExtra(EXTRA_CALL_ID, voipICECandidatesMessage.getData().getCallIdOrDefault(0L));
+            intent.putExtra(EXTRA_CONTACT_IDENTITY, voipICECandidatesMessage.getFromIdentity());
             intent.putExtra(EXTRA_CANDIDATES, candidatesData);
             LocalBroadcastManager.getInstance(appContext).sendBroadcast(intent);
         } else {
             logCallWarning(callId, "Received ICE candidates in invalid call state ({})", this.callState);
+            return false;
         }
-
-        // Otherwise, ignore message.
-
         return true;
     }
 
@@ -965,30 +966,30 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
      * @return true if message was successfully processed
      */
     @WorkerThread
-    public synchronized boolean handleRemoteCallHangup(final VoipCallHangupMessage msg) {
+    public synchronized boolean handleRemoteCallHangup(@NonNull final VoipCallHangupMessage voipCallHangupMessage) {
         // Validate Call ID
         //
         // NOTE: Hangup messages from older Threema versions may not have any associated data!
         // NOTE: If a remote hangup message arrives with an invalid call id that does not appear
         // in the call history, it is a missed call
-        final long callId = msg.getData() == null
+        final long callId = voipCallHangupMessage.getData() == null
             ? 0L
-            : msg.getData().getCallIdOrDefault(0L);
+            : voipCallHangupMessage.getData().getCallIdOrDefault(0L);
         if (!this.isCallIdValid(callId)) {
-            if (isMissedCall(msg, callId)) {
-                handleMissedCall(msg, callId, false);
+            if (isMissedCall(voipCallHangupMessage, callId)) {
+                handleMissedCall(voipCallHangupMessage, callId, false);
                 return true;
             }
             logger.info(
                 "Call hangup message received from {} for an invalid Call ID ({}, local={}), ignoring",
-                msg.getFromIdentity(), callId, this.callState.getCallId()
+                voipCallHangupMessage.getFromIdentity(), callId, this.callState.getCallId()
             );
-            return true;
+            return false;
         }
 
-        logCallInfo(callId, "Call hangup message received from {}", msg.getFromIdentity());
+        logCallInfo(callId, "Call hangup message received from {}", voipCallHangupMessage.getFromIdentity());
 
-        final String identity = msg.getFromIdentity();
+        final String identity = voipCallHangupMessage.getFromIdentity();
 
         final CallStateSnapshot prevState = this.callState.getStateSnapshot();
         final Integer duration = getCallDuration();
@@ -1003,20 +1004,20 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         this.setStateIdle();
 
         // Cancel call notification for that person
-        this.cancelCallNotification(msg.getFromIdentity(), CallActivity.ACTION_DISCONNECTED);
+        this.cancelCallNotification(voipCallHangupMessage.getFromIdentity(), CallActivity.ACTION_DISCONNECTED);
 
         // Notify listeners
         VoipListenerManager.messageListener.handle(listener -> {
             if (listener.handle(identity)) {
-                listener.onHangup(identity, msg.getData());
+                listener.onHangup(identity, voipCallHangupMessage.getData());
             }
         });
         if (incoming && (prevState.isIdle() || prevState.isRinging() || prevState.isInitializing())) {
             final boolean accepted = prevState.isInitializing();
-            handleMissedCall(msg, callId, accepted);
+            handleMissedCall(voipCallHangupMessage, callId, accepted);
         } else if (prevState.isCalling() && duration != null) {
             VoipListenerManager.callEventListener.handle(listener -> {
-                listener.onFinished(callId, msg.getFromIdentity(), !incoming, duration);
+                listener.onFinished(callId, voipCallHangupMessage.getFromIdentity(), !incoming, duration);
             });
         }
 
@@ -1063,13 +1064,8 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         // ANDR-1140: If we are the initiator, then we will have initialized the call ID to a
         // random value. If however the remote device does not yet support call IDs, then returned
         // messages will not contain a Call ID. Accept the messages anyways.
-        final boolean isInitiatior = this.isInitiator() == Boolean.TRUE;
-        if (isInitiatior && callId == 0L) {
-            return true;
-        }
-
-        // Otherwise, there's a call ID mismatch.
-        return false;
+        final boolean isInitiator = this.isInitiator() == Boolean.TRUE;
+        return isInitiator && callId == 0L;
     }
 
     /**
@@ -1591,7 +1587,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
                 nbuilder.addPerson(contactLookupUri);
             }
 
-            nbuilder.setLocusId(new LocusIdCompat(contactService.getUniqueIdString(contact)));
+            nbuilder.setLocusId(new LocusIdCompat(ContactUtil.getUniqueIdString(contact.getIdentity())));
 
             // Actions
             final SpannableString rejectString = new SpannableString(appContext.getString(R.string.voip_reject));
diff --git a/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java b/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java
index 2ad3b582..6fbb8785 100644
--- a/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java
+++ b/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java
@@ -31,6 +31,10 @@ import android.telecom.TelecomManager;
 import android.telephony.TelephonyManager;
 import android.widget.Toast;
 
+import org.slf4j.Logger;
+
+import java.util.Collections;
+
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.RequiresApi;
@@ -38,11 +42,6 @@ import androidx.appcompat.app.AppCompatActivity;
 import androidx.core.content.ContextCompat;
 import androidx.fragment.app.FragmentManager;
 import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-
-import org.slf4j.Logger;
-
-import java.util.Collections;
-
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.dialogs.GenericProgressDialog;
@@ -176,15 +175,14 @@ public class VoipUtil {
 				protected Exception doInBackground(Void... params) {
 					try {
 						// Reset the cache (only for Beta?)
-						UpdateFeatureLevelRoutine.removeTimeCache(contactModel);
+						UpdateFeatureLevelRoutine.removeTimeCache(contactModel.getIdentity());
 
-						(new UpdateFeatureLevelRoutine
-								(
-										serviceManager.getContactService(),
-										// Bad code
-										serviceManager.getAPIConnector(),
-										Collections.singletonList(contactModel)
-								)).run();
+						new UpdateFeatureLevelRoutine(
+							serviceManager.getModelRepositories().getContacts(),
+							serviceManager.getUserService(),
+							serviceManager.getAPIConnector(),
+							Collections.singletonList(contactModel.getIdentity())
+						).run();
 					} catch (Exception e) {
 						return e;
 					}
diff --git a/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java b/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java
index cea67bef..4697f281 100644
--- a/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java
+++ b/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.webclient.activities;
 
-import static ch.threema.app.preference.SettingsAdvancedOptionsFragment.THREEMA_SUPPORT_IDENTITY;
-
 import android.annotation.SuppressLint;
 import android.content.ClipData;
 import android.content.ClipboardManager;
@@ -30,7 +28,6 @@ import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.Network;
 import android.net.NetworkInfo;
-import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
@@ -42,12 +39,6 @@ import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-
 import com.google.android.material.progressindicator.CircularProgressIndicator;
 import com.neovisionaries.ws.client.DualStackMode;
 import com.neovisionaries.ws.client.WebSocket;
@@ -86,24 +77,35 @@ import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
 import ch.threema.app.R;
 import ch.threema.app.activities.ThreemaToolbarActivity;
+import ch.threema.app.asynctasks.SendToSupportBackgroundTask;
+import ch.threema.app.asynctasks.SendToSupportResult;
 import ch.threema.app.dialogs.TextEntryDialog;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
-import ch.threema.app.messagereceiver.ContactMessageReceiver;
+import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.WebRTCUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.webclient.utils.DefaultNoopPeerConnectionObserver;
 import ch.threema.app.webclient.utils.DefaultNoopWebSocketListener;
 import ch.threema.app.webclient.webrtc.PeerConnectionWrapper;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
 
 @SuppressWarnings("FieldCanBeLocal")
 @UiThread
@@ -152,6 +154,7 @@ public class WebDiagnosticsActivity extends ThreemaToolbarActivity implements Te
 	// Executor service that should be used for running creation / destruction
 	// of the peer connection and related objects.
 	@Nullable private ScheduledExecutorService webrtcExecutor;
+	@Nullable private BackgroundExecutor backgroundExecutor;
 
 	@Override
 	protected void onCreate(@Nullable Bundle savedInstanceState) {
@@ -303,23 +306,27 @@ public class WebDiagnosticsActivity extends ThreemaToolbarActivity implements Te
 			return;
 		}
 
-		if (this.contactService == null || messageService == null) {
+		if (this.contactService == null) {
 			return;
 		}
 
-		new AsyncTask<Void, Void, ContactMessageReceiver>() {
-			@Override
-			protected ContactMessageReceiver doInBackground(Void... voids) {
-				try {
-					final ContactModel contactModel = contactService.getOrCreateByIdentity(THREEMA_SUPPORT_IDENTITY, true);
-					return contactService.createReceiver(contactModel);
-				} catch (Exception e) {
-					return null;
-				}
-			}
+		final UserService userService = serviceManager.getUserService();
+		final APIConnector apiConnector = serviceManager.getAPIConnector();
+		final ContactModelRepository contactModelRepository = serviceManager.getModelRepositories().getContacts();
+		if (backgroundExecutor == null) {
+			this.backgroundExecutor = new BackgroundExecutor();
+		}
 
+		backgroundExecutor.execute(new SendToSupportBackgroundTask(
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			this
+		) {
 			@Override
-			protected void onPostExecute(ContactMessageReceiver messageReceiver) {
+			@NonNull
+			public SendToSupportResult onSupportAvailable(@NonNull ContactModel contactModel) {
+				MessageReceiver<?> messageReceiver = contactService.createReceiver(contactModel);
 				try {
 					messageService.sendText(clipboardString +
 						"\n---\n" +
@@ -328,15 +335,23 @@ public class WebDiagnosticsActivity extends ThreemaToolbarActivity implements Te
 						ConfigUtils.getSupportDeviceInfo() + "\n" +
 						"Threema " + ConfigUtils.getAppVersion() + "\n" +
 						getMyIdentity(), messageReceiver);
-					Toast.makeText(getApplicationContext(), R.string.message_sent, Toast.LENGTH_LONG).show();
 					finish();
-					return;
-				} catch (Exception e1) {
-					logger.error("Exception", e1);
+					return SendToSupportResult.SUCCESS;
+				} catch (Exception e) {
+					logger.error("Exception", e);
 				}
-				Toast.makeText(getApplicationContext(), R.string.an_error_occurred, Toast.LENGTH_LONG).show();
+				return SendToSupportResult.FAILED;
 			}
-		}.execute();
+
+			@Override
+			public void onFinished(SendToSupportResult result) {
+				if (result == SendToSupportResult.SUCCESS) {
+					Toast.makeText(WebDiagnosticsActivity.this, R.string.message_sent, Toast.LENGTH_LONG).show();
+				} else {
+					Toast.makeText(WebDiagnosticsActivity.this, R.string.an_error_occurred, Toast.LENGTH_LONG).show();
+				}
+			}
+		});
 	}
 
 	@UiThread
diff --git a/app/src/main/java/ch/threema/app/webclient/converter/Contact.java b/app/src/main/java/ch/threema/app/webclient/converter/Contact.java
index 83cfa079..92e949b3 100644
--- a/app/src/main/java/ch/threema/app/webclient/converter/Contact.java
+++ b/app/src/main/java/ch/threema/app/webclient/converter/Contact.java
@@ -38,6 +38,7 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.webclient.exceptions.ConversionException;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.storage.models.ContactModel;
@@ -103,13 +104,13 @@ public class Contact extends Converter {
 			// TODO(ANDR-2708): Remove
 			builder.put(FEATURE_LEVEL, ThreemaFeature.featureMaskToLevel(featureMask));
 
-			boolean isSecretChat = getHiddenChatListService().has(getContactService().getUniqueIdString(contact));
+			boolean isSecretChat = getHiddenChatListService().has(ContactUtil.getUniqueIdString(contact.getIdentity()));
 			builder.put(Receiver.LOCKED, isSecretChat);
 			builder.put(Receiver.VISIBLE, !isSecretChat || !getPreferenceService().isPrivateChatsHidden());
 
 			//define access
 			builder.put(Receiver.ACCESS, (new MsgpackObjectBuilder())
-					.put(Receiver.CAN_DELETE, getContactService().getAccess(contact).canDelete())
+					.put(Receiver.CAN_DELETE, getContactService().getAccess(contact.getIdentity()).canDelete())
 					.put(CAN_CHANGE_AVATAR, ContactUtil.canChangeAvatar(contact, getPreferenceService(), getFileService()))
 					.put(CAN_CHANGE_FIRST_NAME, ContactUtil.canChangeFirstName(contact))
 					.put(CAN_CHANGE_LAST_NAME, ContactUtil.canChangeLastName(contact)));
@@ -246,11 +247,11 @@ public class Contact extends Converter {
 	public static ContactService.Filter getContactFilter() {
 		return new ContactService.Filter() {
 			@Override
-			public ContactModel.State[] states() {
-				return new ContactModel.State[] {
-					ContactModel.State.ACTIVE,
-					ContactModel.State.INACTIVE,
-					ContactModel.State.INVALID,
+			public IdentityState[] states() {
+				return new IdentityState[] {
+					IdentityState.ACTIVE,
+					IdentityState.INACTIVE,
+					IdentityState.INVALID,
 				};
 			}
 
diff --git a/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java b/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java
index 5423c386..c58d6401 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java
@@ -95,7 +95,8 @@ public class BatteryStatusServiceImpl implements BatteryStatusService {
 	/**
 	 * Subscribe to the battery status broadcast.
 	 */
-	public void acquire(WebClientSessionModel session) {
+	@Override
+    public void acquire(WebClientSessionModel session) {
 		logger.debug("Acquire webclient battery status subscription for session {}", session.getId());
 		if (!this.acquiredSessionIds.contains(session.getId())) {
 			this.acquiredSessionIds.add(session.getId());
@@ -106,7 +107,8 @@ public class BatteryStatusServiceImpl implements BatteryStatusService {
 	/**
 	 * Unsubscribe from the battery status broadcast.
 	 */
-	public void release(WebClientSessionModel session) {
+	@Override
+    public void release(WebClientSessionModel session) {
 		logger.debug("Release webclient battery status subscription for session {}", session.getId());
 		if (this.acquiredSessionIds.contains(session.getId())) {
 			this.acquiredSessionIds.remove((Integer)session.getId());
diff --git a/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java b/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java
index 46a0757e..b5e914b3 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java
@@ -41,6 +41,8 @@ import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SynchronizeContactsService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.services.license.LicenseService;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.storage.DatabaseServiceNew;
 
 /**
@@ -71,6 +73,8 @@ public class ServicesContainer {
 	@NonNull public final SessionWakeUpService sessionWakeUp;
 	@NonNull public final WakeLockService wakeLock;
 	@NonNull public final BatteryStatusService batteryStatus;
+	@NonNull public final APIConnector apiConnector;
+	@NonNull public final ContactModelRepository contactModelRepository;
 
 	public ServicesContainer(
 		@NonNull final Context appContext,
@@ -89,7 +93,9 @@ public class ServicesContainer {
 		@NonNull final DeadlineListService hiddenChat,
 		@NonNull final FileService file,
 		@NonNull final SynchronizeContactsService synchronizeContacts,
-		@NonNull final LicenseService license
+		@NonNull final LicenseService license,
+		@NonNull final APIConnector apiConnector,
+		@NonNull final ContactModelRepository contactModelRepository
 	) {
 		this.appContext = appContext;
 		this.lifetime = lifetime;
@@ -109,6 +115,8 @@ public class ServicesContainer {
 		this.synchronizeContacts = synchronizeContacts;
 		this.license = license;
 		this.sessionWakeUp = SessionWakeUpServiceImpl.getInstance();
+		this.apiConnector = apiConnector;
+		this.contactModelRepository = contactModelRepository;
 
 		// Initialize wakelock service
 		this.wakeLock = new WakeLockServiceImpl(appContext, lifetime);
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java b/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java
index 31394a86..48c97614 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java
@@ -189,7 +189,8 @@ public class SessionInstanceServiceImpl implements SessionInstanceService {
 		);
 		final AvatarUpdateHandler avatarUpdateHandler = new AvatarUpdateHandler(
 			handler,
-			updateDispatcher
+			updateDispatcher,
+            services.contact
 		);
 		final ConversationUpdateHandler conversationUpdateHandler = new ConversationUpdateHandler(
 			handler,
@@ -438,7 +439,10 @@ public class SessionInstanceServiceImpl implements SessionInstanceService {
 
 		createDispatcher.addReceiver(new CreateContactHandler(
 			createDispatcher,
-			services.contact
+			services.contact,
+			services.user,
+			services.apiConnector,
+			services.contactModelRepository
 		));
 
 		createDispatcher.addReceiver(new CreateGroupHandler(
@@ -465,7 +469,6 @@ public class SessionInstanceServiceImpl implements SessionInstanceService {
 		));
 		updateDispatcher.addReceiver(new ModifyProfileHandler(
 			responseDispatcher,
-			services.contact,
 			services.user
 		));
 		updateDispatcher.addReceiver(new ModifyConversationHandler(
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java
index 4dd46f08..7e40de86 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java
@@ -21,10 +21,6 @@
 
 package ch.threema.app.webclient.services.instance.message.receiver;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.StringDef;
-import androidx.annotation.WorkerThread;
-
 import org.msgpack.core.MessagePackException;
 import org.msgpack.value.Value;
 import org.slf4j.Logger;
@@ -33,17 +29,32 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.StringDef;
+import androidx.annotation.WorkerThread;
+import ch.threema.app.R;
+import ch.threema.app.ThreemaApplication;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactCreated;
+import ch.threema.app.asynctasks.PolicyViolation;
 import ch.threema.app.exceptions.EntryAlreadyExistsException;
 import ch.threema.app.exceptions.InvalidEntryException;
+import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.webclient.Protocol;
 import ch.threema.app.webclient.converter.Contact;
 import ch.threema.app.webclient.converter.MsgpackObjectBuilder;
 import ch.threema.app.webclient.exceptions.ConversionException;
 import ch.threema.app.webclient.services.instance.MessageDispatcher;
 import ch.threema.app.webclient.services.instance.MessageReceiver;
-import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.storage.models.ContactModel;
 
@@ -53,6 +64,9 @@ public class CreateContactHandler extends MessageReceiver {
 
 	private final MessageDispatcher dispatcher;
 	private final ContactService contactService;
+	private final UserService userService;
+	private final APIConnector apiConnector;
+	private final ContactModelRepository contactModelRepository;
 
 	@Retention(RetentionPolicy.SOURCE)
 	@StringDef({
@@ -63,11 +77,19 @@ public class CreateContactHandler extends MessageReceiver {
 	private @interface ErrorCode {}
 
 	@AnyThread
-	public CreateContactHandler(MessageDispatcher dispatcher,
-	                            ContactService contactService) {
+	public CreateContactHandler(
+		MessageDispatcher dispatcher,
+		ContactService contactService,
+		@NonNull UserService userService,
+		@NonNull APIConnector apiConnector,
+		@NonNull ContactModelRepository contactModelRepository
+	) {
 		super(Protocol.SUB_TYPE_CONTACT);
 		this.dispatcher = dispatcher;
 		this.contactService = contactService;
+		this.userService = userService;
+		this.apiConnector = apiConnector;
+		this.contactModelRepository = contactModelRepository;
 	}
 
 	@Override
@@ -102,7 +124,7 @@ public class CreateContactHandler extends MessageReceiver {
 
 		// Otherwise try to create the contact
 		try {
-			contactModel = this.contactService.createContactByIdentity(threemaId, false);
+			contactModel = createContact(threemaId);
 			this.success(threemaId, temporaryId, contactModel);
 		} catch (InvalidEntryException e) {
 			this.failed(threemaId, temporaryId, Protocol.ERROR_INVALID_IDENTITY);
@@ -145,4 +167,34 @@ public class CreateContactHandler extends MessageReceiver {
 	protected boolean maybeNeedsConnection() {
 		return false;
 	}
+
+	@NonNull
+	@WorkerThread
+	private ContactModel createContact(@NonNull String identity)
+		throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException {
+		ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+			identity,
+			ContactModel.AcquaintanceLevel.DIRECT,
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			AddContactRestrictionPolicy.CHECK,
+			ThreemaApplication.getAppContext(),
+			null
+		).runSynchronously();
+
+		if (result instanceof ContactCreated) {
+			ContactModel contactModel = contactService.getByIdentity(identity);
+			if (contactModel == null) {
+				throw new IllegalStateException("Contact model is null after adding it");
+			}
+			return contactModel;
+		} else if (result instanceof ContactAvailable) {
+			throw new EntryAlreadyExistsException(R.string.identity_already_exists);
+		} else if (result instanceof PolicyViolation) {
+			throw new PolicyViolationException();
+		} else {
+			throw new InvalidEntryException(R.string.invalid_threema_id);
+		}
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java
index 6fb65872..ddca428c 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java
@@ -21,15 +21,14 @@
 
 package ch.threema.app.webclient.services.instance.message.receiver;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.WorkerThread;
-
 import org.msgpack.core.MessagePackException;
 import org.msgpack.value.Value;
 import org.slf4j.Logger;
 
 import java.util.Map;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.routines.ReadMessagesRoutine;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.GroupService;
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java
index bac3196c..ee44efa5 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java
@@ -46,6 +46,7 @@ import ch.threema.app.webclient.exceptions.ConversionException;
 import ch.threema.app.webclient.services.instance.MessageDispatcher;
 import ch.threema.app.webclient.services.instance.MessageReceiver;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
 
@@ -96,6 +97,7 @@ public class ModifyContactHandler extends MessageReceiver {
 		final String identity = args.get(Protocol.ARGUMENT_IDENTITY).asStringValue().toString();
 		final String temporaryId = args.get(Protocol.ARGUMENT_TEMPORARY_ID).asStringValue().toString();
 
+		// TODO(ANDR-3139): Use new contact model
 		// Validate identity
 		final ContactModel contactModel = this.contactService.getByIdentity(identity);
 		if (contactModel == null) {
@@ -139,7 +141,7 @@ public class ModifyContactHandler extends MessageReceiver {
 					final Value avatarValue = data.get(Protocol.ARGUMENT_AVATAR);
 					if (avatarValue == null || avatarValue.isNilValue()) {
 						// Clear avatar
-						this.contactService.removeAvatar(contactModel);
+						this.contactService.removeUserDefinedProfilePicture(contactModel, TriggerSource.LOCAL);
 					} else {
 						// Set avatar
 						final byte[] bmp = avatarValue.asBinaryValue().asByteArray();
@@ -149,11 +151,13 @@ public class ModifyContactHandler extends MessageReceiver {
 							avatar = BitmapUtil.resizeBitmap(avatar,
 									ContactEditDialog.CONTACT_AVATAR_WIDTH_PX,
 									ContactEditDialog.CONTACT_AVATAR_HEIGHT_PX);
-							this.contactService.setAvatar(
-									contactModel,
-									// Without quality loss
-									BitmapUtil.bitmapToByteArray(avatar, Bitmap.CompressFormat.PNG, 100)
-							);
+                            this.contactService.setUserDefinedProfilePicture(
+                                contactModel,
+                                // Without quality loss
+                                BitmapUtil.bitmapToByteArray(avatar, Bitmap.CompressFormat.PNG,
+                                    100),
+                                TriggerSource.LOCAL
+                            );
 						}
 					}
 				} catch (Exception e) {
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java
index dde9365a..ca1747f1 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java
@@ -33,18 +33,18 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 
 import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.StringDef;
 import androidx.annotation.WorkerThread;
 import ch.threema.app.dialogs.ContactEditDialog;
-import ch.threema.app.services.ContactService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.webclient.Protocol;
 import ch.threema.app.webclient.services.instance.MessageDispatcher;
 import ch.threema.app.webclient.services.instance.MessageReceiver;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.models.ContactModel;
+import ch.threema.domain.taskmanager.TriggerSource;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
@@ -59,10 +59,11 @@ public class ModifyProfileHandler extends MessageReceiver {
 	private static final String FIELD_AVATAR = "avatar";
 
 	// Dispatchers
+    @NonNull
 	private final MessageDispatcher responseDispatcher;
 
 	// Services
-	private final ContactService contactService;
+    @NonNull
 	private final UserService userService;
 
 	// Error codes
@@ -83,12 +84,12 @@ public class ModifyProfileHandler extends MessageReceiver {
 	}
 
 	@AnyThread
-	public ModifyProfileHandler(MessageDispatcher responseDispatcher,
-	                            ContactService contactService,
-	                            UserService userService) {
+	public ModifyProfileHandler(
+        @NonNull MessageDispatcher responseDispatcher,
+        @NonNull UserService userService
+    ) {
 		super(Protocol.SUB_TYPE_PROFILE);
 		this.responseDispatcher = responseDispatcher;
-		this.contactService = contactService;
 		this.userService = userService;
 	}
 
@@ -138,18 +139,16 @@ public class ModifyProfileHandler extends MessageReceiver {
 		if (nickname.getBytes(UTF_8).length > Protocol.LIMIT_BYTES_PUBLIC_NICKNAME) {
 			throw new ModifyProfileException(Protocol.ERROR_VALUE_TOO_LONG);
 		}
-		this.userService.setPublicNickname(nickname);
+		this.userService.setPublicNickname(nickname, TriggerSource.LOCAL);
 	}
 
 	/**
 	 * Update the avatar.
 	 */
 	private void processAvatar(@Nullable byte[] avatarBytes) throws ModifyProfileException {
-		final ContactModel me = this.contactService.getMe();
-
 		// If avatar bytes are null, delete own avatar.
 		if (avatarBytes == null) {
-			this.contactService.removeAvatar(me);
+            userService.removeUserProfilePicture(TriggerSource.LOCAL);
 			return;
 		}
 
@@ -170,15 +169,15 @@ public class ModifyProfileHandler extends MessageReceiver {
 			ContactEditDialog.CONTACT_AVATAR_HEIGHT_PX
 		);
 
-		// Set the avatar
-		try {
-			final byte[] converted = BitmapUtil
-				.bitmapToByteArray(resized, Bitmap.CompressFormat.PNG, 100);
-			this.contactService.setAvatar(this.contactService.getMe(), converted);
-		} catch (Exception e) {
-			logger.error("Could not update own avatar", e);
-			throw new ModifyProfileException(Protocol.ERROR_INTERNAL);
-		}
+        // Set the avatar
+        try {
+            final byte[] converted = BitmapUtil
+                .bitmapToByteArray(resized, Bitmap.CompressFormat.PNG, 100);
+            userService.setUserProfilePicture(converted, TriggerSource.LOCAL);
+        } catch (Exception e) {
+            logger.error("Could not update own avatar", e);
+            throw new ModifyProfileException(Protocol.ERROR_INTERNAL);
+        }
 	}
 
 	@Override
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java
index 4d49ffd2..c601a0cb 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java
@@ -21,14 +21,14 @@
 
 package ch.threema.app.webclient.services.instance.message.updater;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.WorkerThread;
-
 import org.msgpack.core.MessagePackException;
 import org.slf4j.Logger;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.managers.ListenerManager;
+import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.executor.HandlerExecutor;
 import ch.threema.app.webclient.Protocol;
 import ch.threema.app.webclient.converter.MsgpackObjectBuilder;
@@ -57,14 +57,24 @@ public class AvatarUpdateHandler extends MessageUpdater {
 	// Dispatchers
 	private final @NonNull MessageDispatcher updateDispatcher;
 
+    // Services
+    private final @NonNull ContactService contactService;
+
 	@AnyThread
-	public AvatarUpdateHandler(@NonNull HandlerExecutor handler, @NonNull MessageDispatcher updateDispatcher) {
+	public AvatarUpdateHandler(
+        @NonNull HandlerExecutor handler,
+        @NonNull MessageDispatcher updateDispatcher,
+        @NonNull ContactService contactService
+    ) {
 		super(Protocol.SUB_TYPE_AVATAR);
 		this.handler = handler;
 
 		// Dispatchers
 		this.updateDispatcher = updateDispatcher;
 
+        // Services
+        this.contactService = contactService;
+
 		// Create receiver listeners
 		this.contactListener = new ContactListener();
 		this.groupListener = new GroupListener();
@@ -90,7 +100,7 @@ public class AvatarUpdateHandler extends MessageUpdater {
 	/**
 	 * Update a contact avatar.
 	 */
-	private void update(final ContactModel contact) {
+	private void update(@NonNull final ContactModel contact) {
 		this.update(new Utils.ModelWrapper(contact));
 	}
 
@@ -125,9 +135,14 @@ public class AvatarUpdateHandler extends MessageUpdater {
 	@AnyThread
 	private class ContactListener implements ch.threema.app.listeners.ContactListener {
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
 			logger.debug("Contact Listener: onAvatarChanged");
-			handler.post(() -> AvatarUpdateHandler.this.update(contactModel));
+            ContactModel contactModel = contactService.getByIdentity(identity);
+            if (contactModel == null) {
+                logger.error("Got an avatar update for an unknown contact");
+            } else {
+                handler.post(() -> AvatarUpdateHandler.this.update(contactModel));
+            }
 		}
 	}
 
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java
index c52add15..54bd3587 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java
@@ -34,6 +34,7 @@ import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeadlineListService;
 import ch.threema.app.services.DistributionListService;
 import ch.threema.app.services.GroupService;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.executor.HandlerExecutor;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.webclient.Protocol;
@@ -114,7 +115,11 @@ public class ConversationUpdateHandler extends MessageUpdater {
 		if (model.isGroupConversation()) {
 			uniqueId = this.groupService.getUniqueIdString(model.getGroup());
 		} else if (model.isContactConversation()) {
-			uniqueId = this.contactService.getUniqueIdString(model.getContact());
+			String identity = null;
+			if (model.getContact() != null) {
+				identity = model.getContact().getIdentity();
+			}
+			uniqueId = ContactUtil.getUniqueIdString(identity);
 		} else if (model.isDistributionListConversation()) {
 			uniqueId = this.distributionListService.getUniqueIdString(model.getDistributionList());
 		}
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java
index 4122f88c..df3851ec 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java
@@ -261,19 +261,19 @@ public class ReceiverUpdateHandler extends MessageUpdater {
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			logger.debug("Group Listener: onNewMember");
 			updateGroup(group, Protocol.ARGUMENT_MODE_MODIFIED);
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String identity) {
 			logger.debug("Group Listener: onMemberLeave");
 			updateGroup(group, Protocol.ARGUMENT_MODE_MODIFIED);
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String identity) {
 			logger.debug("Group Listener: onMemberKicked");
 			updateGroup(group, Protocol.ARGUMENT_MODE_MODIFIED);
 		}
diff --git a/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt b/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt
index 019baf13..d1ee4b3f 100644
--- a/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt
+++ b/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt
@@ -42,6 +42,7 @@ import ch.threema.app.services.ballot.BallotService
 import ch.threema.app.utils.AppRestrictionUtil
 import ch.threema.app.utils.AutoDeleteUtil
 import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.WorkManagerUtil
 import ch.threema.base.ThreemaException
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.ProtocolDefines
@@ -71,7 +72,11 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
         const val EXTRA_GRACE_DAYS = "grace_days"
         private const val schedulePeriodMs = DateUtils.DAY_IN_MILLIS / 2
 
-        fun scheduleAutoDelete(context: Context) : Boolean {
+        /**
+         * Schedule the auto delete worker to run periodically. If auto delete is not configured
+         * and a worker is already scheduled, it will be cancelled.
+         */
+        fun scheduleAutoDelete(context: Context) {
             val graceDays = getGraceDays(context)
             if (graceDays != null && graceDays > ProtocolDefines.AUTO_DELETE_KEEP_MESSAGES_DAYS_OFF_VALUE) {
                 logger.info("Scheduling auto delete")
@@ -90,11 +95,10 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
                         logger.error("Exception scheduling auto delete", e)
                     }
                 }
-                return true
             } else {
                 logger.info("No auto delete configured")
+                cancelAutoDelete(context)
             }
-            return false
         }
 
         private fun buildPeriodicWorkRequest(graceDays: Int): PeriodicWorkRequest {
@@ -124,16 +128,14 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
         }
 
         fun cancelAutoDelete(context: Context) {
-            logger.info("Canceling auto delete")
             CoroutineScope(Dispatchers.IO).launch {
-                val operation = WorkManager.getInstance(context)
-                    .cancelUniqueWork(ThreemaApplication.WORKER_AUTO_DELETE)
-                logger.info("Cancel result = {}",
-                    withContext(Dispatchers.IO) {
-                        operation.result.get()
-                    })
+                cancelAutoDeleteAwait(context)
             }
         }
+
+        suspend fun cancelAutoDeleteAwait(context: Context) {
+            WorkManagerUtil.cancelUniqueWorkAwait(context, ThreemaApplication.WORKER_AUTO_DELETE)
+        }
     }
 
     override fun doWork(): Result {
@@ -230,7 +232,7 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
                     }
                 } else {
                     logger.info("Removing message {}", messageModel.apiMessageId ?: messageModel.id)
-                    fileService.removeMessageFiles(messageModel, true);
+                    fileService.removeMessageFiles(messageModel, true)
                     messageService.remove(messageModel, false)
                     numDeletedMessages++
                 }
diff --git a/app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt b/app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt
index 1184dece..6a8095c4 100644
--- a/app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt
+++ b/app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt
@@ -22,21 +22,33 @@
 package ch.threema.app.workers
 
 import android.content.Context
+import androidx.work.Constraints
+import androidx.work.ExistingPeriodicWorkPolicy
+import androidx.work.NetworkType
+import androidx.work.OneTimeWorkRequest
+import androidx.work.Operation
+import androidx.work.PeriodicWorkRequest
+import androidx.work.WorkManager
 import androidx.work.Worker
 import androidx.work.WorkerParameters
-import ch.threema.app.R
 import ch.threema.app.ThreemaApplication
+import ch.threema.app.ThreemaApplication.WORKER_CONTACT_UPDATE_PERIODIC_NAME
+import ch.threema.app.ThreemaApplication.WORKER_IDENTITY_STATES_PERIODIC_NAME
 import ch.threema.app.managers.ServiceManager
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.PollingHelper
 import ch.threema.app.services.PreferenceService
 import ch.threema.app.services.UserService
 import ch.threema.app.utils.ContactUtil
+import ch.threema.app.utils.WorkManagerUtil
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.protocol.api.APIConnector
-import ch.threema.storage.models.ContactModel
+import ch.threema.data.models.ContactModel
+import ch.threema.data.models.ModelDeletedException
+import ch.threema.data.repositories.ContactModelRepository
+import java.util.concurrent.TimeUnit
 
 private val logger = LoggingUtil.getThreemaLogger("ContactUpdateWorker")
 
@@ -53,12 +65,12 @@ class ContactUpdateWorker(
         val serviceManager = ThreemaApplication.getServiceManager()
 
         val success = sendFeatureMaskAndUpdateContacts(
+            serviceManager?.modelRepositories?.contacts,
             serviceManager?.contactService,
             serviceManager?.apiConnector,
             serviceManager?.userService,
             serviceManager?.preferenceService,
             PollingHelper(context, "contactUpdateWorker"),
-            applicationContext
         )
 
         return if (success) {
@@ -69,27 +81,77 @@ class ContactUpdateWorker(
     }
 
     companion object {
-        fun sendFeatureMaskAndUpdateContacts(serviceManager: ServiceManager, context: Context) =
+        @JvmStatic
+        fun schedulePeriodicSync(context: Context, preferenceService: PreferenceService) {
+            // We use the sync interval from the previously named IdentityStatesWorker
+            val schedulePeriodMs = WorkManagerUtil.normalizeSchedulePeriod(preferenceService.identityStateSyncIntervalS)
+
+            logger.info("Initializing contact update sync. Requested schedule period: {} ms", schedulePeriodMs)
+
+            try {
+                val workManager = WorkManager.getInstance(context)
+
+                if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(
+                    workManager,
+                    WORKER_CONTACT_UPDATE_PERIODIC_NAME,
+                    schedulePeriodMs
+                )) {
+                    logger.debug("Scheduling new job")
+
+                    // Cancel the work with the old name as the IdentityStatesWorker class does not
+                    // exist anymore.
+                    workManager.cancelUniqueWork(WORKER_IDENTITY_STATES_PERIODIC_NAME)
+
+                    // Schedule the start of the service according to schedule period
+                    val constraints = Constraints.Builder()
+                        .setRequiredNetworkType(NetworkType.CONNECTED)
+                        .build()
+
+                    val workRequest = PeriodicWorkRequest.Builder(ContactUpdateWorker::class.java, schedulePeriodMs, TimeUnit.MILLISECONDS)
+                        .setConstraints(constraints)
+                        .addTag(schedulePeriodMs.toString())
+                        .setInitialDelay(1000, TimeUnit.MILLISECONDS)
+                        .build()
+
+                    workManager.enqueueUniquePeriodicWork(WORKER_CONTACT_UPDATE_PERIODIC_NAME, ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE, workRequest)
+                }
+            } catch (e: IllegalStateException) {
+                logger.error("Unable to schedule ContactUpdateWorker", e)
+            }
+        }
+
+        @JvmStatic
+        fun performOneTimeSync(context: Context) {
+            val workRequest = OneTimeWorkRequest.Builder(ContactUpdateWorker::class.java)
+                .build()
+            WorkManager.getInstance(context).enqueue(workRequest)
+        }
+
+        fun cancelPeriodicSync(context: Context): Operation {
+            return WorkManagerUtil.cancelUniqueWork(context, WORKER_CONTACT_UPDATE_PERIODIC_NAME)
+        }
+
+        fun sendFeatureMaskAndUpdateContacts(serviceManager: ServiceManager) =
             sendFeatureMaskAndUpdateContacts(
+                serviceManager.modelRepositories.contacts,
                 serviceManager.contactService,
                 serviceManager.apiConnector,
                 serviceManager.userService,
                 serviceManager.preferenceService,
                 null,
-                context,
             )
 
         private fun sendFeatureMaskAndUpdateContacts(
+            contactModelRepository: ContactModelRepository?,
             contactService: ContactService?,
             apiConnector: APIConnector?,
             userService: UserService?,
             preferenceService: PreferenceService?,
             pollingHelper: PollingHelper?,
-            context: Context,
         ): Boolean {
             logger.info("Starting contact update")
 
-            if (contactService == null || apiConnector == null || userService == null || preferenceService == null) {
+            if (contactService == null || apiConnector == null || userService == null || preferenceService == null || contactModelRepository == null) {
                 logger.warn("Services not available while updating contact states")
                 return false
             }
@@ -106,9 +168,10 @@ class ContactUpdateWorker(
                 return false
             }
 
+            // TODO(ANDR-3172): Fetch all contacts using the contact model repository
             val contactModels = contactService.find(object : ContactService.Filter {
-                override fun states(): Array<ContactModel.State> =
-                    arrayOf(ContactModel.State.ACTIVE, ContactModel.State.INACTIVE)
+                override fun states(): Array<IdentityState> =
+                    arrayOf(IdentityState.ACTIVE, IdentityState.INACTIVE)
 
                 override fun requiredFeature() = null
 
@@ -119,15 +182,13 @@ class ContactUpdateWorker(
                 override fun includeHidden() = true
 
                 override fun onlyWithReceiptSettings() = false
-            })
+            }).mapNotNull { contactModelRepository.getByIdentity(it.identity) }
 
             val success = if (contactModels.isNotEmpty()) {
                 fetchAndUpdateContactModels(
                     contactModels,
                     apiConnector,
-                    contactService,
                     preferenceService,
-                    context,
                 )
             } else {
                 true
@@ -144,9 +205,7 @@ class ContactUpdateWorker(
         fun fetchAndUpdateContactModels(
             contactModels: List<ContactModel>,
             apiConnector: APIConnector,
-            contactService: ContactService,
             preferenceService: PreferenceService,
-            context: Context,
         ): Boolean {
             val identities = contactModels.map { it.identity }.toTypedArray()
             val contactModelMap = contactModels.associateBy { it.identity }
@@ -158,9 +217,9 @@ class ContactUpdateWorker(
                     val contactModel = contactModelMap[identity] ?: continue
 
                     val newState = when (result.states[i]) {
-                        IdentityState.ACTIVE -> ContactModel.State.ACTIVE
-                        IdentityState.INACTIVE -> ContactModel.State.INACTIVE
-                        IdentityState.INVALID -> ContactModel.State.INVALID
+                        IdentityState.ACTIVE.value -> IdentityState.ACTIVE
+                        IdentityState.INACTIVE.value -> IdentityState.INACTIVE
+                        IdentityState.INVALID.value -> IdentityState.INVALID
 
                         // In case we receive an unexpected value from the server, we set the new
                         // state to null. We should not abort these steps as this contact update
@@ -179,7 +238,7 @@ class ContactUpdateWorker(
                         0 -> IdentityType.NORMAL
                         1 -> IdentityType.WORK
                         else -> {
-                            logger.warn("Received invalid type {} for identity {}", result.types[i], identity);
+                            logger.warn("Received invalid type {} for identity {}", result.types[i], identity)
                             IdentityType.NORMAL
                         }
                     }
@@ -191,15 +250,11 @@ class ContactUpdateWorker(
                         newState,
                         newIdentityType,
                         newFeatureMask,
-                        contactService
                     )
 
                     if (result.checkInterval > 0) {
                         // Save new interval duration
-                        preferenceService.setRoutineInterval(
-                            context.getString(R.string.preferences__identity_states_check_interval),
-                            result.checkInterval
-                        )
+                        preferenceService.setIdentityStateSyncInterval(result.checkInterval)
                     }
                 }
 
@@ -212,34 +267,29 @@ class ContactUpdateWorker(
 
         private fun updateContactModel(
             contactModel: ContactModel,
-            newState: ContactModel.State?,
+            newState: IdentityState?,
             newIdentityType: IdentityType,
             newFeatureMask: Long?,
-            contactService: ContactService,
         ) {
-            var updated = false
+            try {
+                val data = contactModel.data.value ?: return
 
-            // Only update the state if it is a valid state change. Note that changing to null is
-            // not allowed and will not result in any change.
-            if (ContactUtil.allowedChangeToState(contactModel, newState)) {
-                contactModel.state = newState
-                updated = true
-            }
+                // Only update the state if it is a valid state change. Note that changing to null is
+                // not allowed and will not result in any change.
+                if (newState != null && ContactUtil.allowedChangeToState(data.activityState, newState)) {
+                    contactModel.setActivityStateFromLocal(newState)
+                }
 
-            if (contactModel.identityType != newIdentityType) {
-                contactModel.identityType = newIdentityType
-                updated = true
-            }
+                contactModel.setIdentityTypeFromLocal(newIdentityType)
 
-            if (newFeatureMask == null) {
-                logger.warn("Feature mask for contact {} is null", contactModel.identity)
-            } else if (newFeatureMask != contactModel.featureMask) {
-                contactModel.featureMask = newFeatureMask
-                updated = true
-            }
+                if (newFeatureMask == null) {
+                    logger.warn("Feature mask for contact {} is null", contactModel.identity)
+                } else {
+                    contactModel.setFeatureMaskFromLocal(newFeatureMask)
+                }
 
-            if (updated) {
-                contactService.save(contactModel)
+            } catch (e: ModelDeletedException) {
+                logger.warn("Could not update contact {} because the model has been deleted", contactModel.identity, e)
             }
         }
     }
diff --git a/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt b/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt
index cc1df71c..a61a6bb5 100644
--- a/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt
+++ b/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt
@@ -30,6 +30,7 @@ import androidx.core.app.NotificationCompat
 import androidx.preference.PreferenceManager
 import androidx.work.Constraints
 import androidx.work.Data
+import androidx.work.ExistingPeriodicWorkPolicy
 import androidx.work.ExistingWorkPolicy
 import androidx.work.ForegroundInfo
 import androidx.work.NetworkType
@@ -44,8 +45,9 @@ import androidx.work.Worker
 import androidx.work.WorkerParameters
 import ch.threema.app.R
 import ch.threema.app.ThreemaApplication
-import ch.threema.app.notifications.NotificationChannels
+import ch.threema.app.asynctasks.AddOrUpdateWorkContactBackgroundTask
 import ch.threema.app.managers.ServiceManager
+import ch.threema.app.notifications.NotificationChannels
 import ch.threema.app.routines.UpdateAppLogoRoutine
 import ch.threema.app.routines.UpdateWorkInfoRoutine
 import ch.threema.app.services.AppRestrictionService
@@ -61,11 +63,15 @@ import ch.threema.app.utils.AppRestrictionUtil
 import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.RuntimeUtil
 import ch.threema.app.utils.TestUtil
+import ch.threema.app.utils.WorkManagerUtil
 import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModel
+import ch.threema.data.repositories.ContactModelRepository
 import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
 import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.domain.protocol.api.work.WorkData
-import ch.threema.storage.models.ContactModel
+import ch.threema.domain.taskmanager.TriggerSource
 import com.google.common.util.concurrent.Futures
 import com.google.common.util.concurrent.ListenableFuture
 import java.net.HttpURLConnection
@@ -83,12 +89,41 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
     private val notificationService: NotificationService? = serviceManager?.notificationService
     private val userService: UserService? = serviceManager?.userService
     private val identityStore: IdentityStore? = serviceManager?.identityStore
+    private val contactModelRepository: ContactModelRepository? = serviceManager?.modelRepositories?.contacts
 
     companion object {
         private const val EXTRA_REFRESH_RESTRICTIONS_ONLY = "RESTRICTIONS_ONLY"
         private const val EXTRA_FORCE_UPDATE = "FORCE_UPDATE"
 
-        fun buildOneTimeWorkRequest(refreshRestrictionsOnly: Boolean, forceUpdate: Boolean, tag: String?): OneTimeWorkRequest {
+        fun schedulePeriodicWorkSync(context: Context, preferenceService: PreferenceService) {
+            if (!ConfigUtils.isWorkBuild()) {
+                logger.debug("Do not start work sync worker in non-work build")
+                return
+            }
+
+            val schedulePeriodMs = WorkManagerUtil.normalizeSchedulePeriod(preferenceService.workSyncCheckInterval)
+            logger.info("Scheduling periodic work sync. Schedule period: {} ms", schedulePeriodMs)
+
+            try {
+                val workManager = WorkManager.getInstance(context)
+                val policy = if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(workManager, ThreemaApplication.WORKER_PERIODIC_WORK_SYNC, schedulePeriodMs)) {
+                    ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE
+                } else {
+                    ExistingPeriodicWorkPolicy.KEEP
+                }
+                logger.info("{}: {} existing periodic work", ThreemaApplication.WORKER_PERIODIC_WORK_SYNC, policy)
+                val workRequest = buildPeriodicWorkRequest(schedulePeriodMs)
+                workManager.enqueueUniquePeriodicWork(ThreemaApplication.WORKER_PERIODIC_WORK_SYNC, policy, workRequest)
+            } catch (e: IllegalStateException) {
+                logger.error("Unable to schedule periodic work sync work", e)
+            }
+        }
+
+        suspend fun cancelPeriodicWorkSyncAwait(context: Context) {
+            WorkManagerUtil.cancelUniqueWorkAwait(context, ThreemaApplication.WORKER_PERIODIC_WORK_SYNC)
+        }
+
+        private fun buildOneTimeWorkRequest(refreshRestrictionsOnly: Boolean, forceUpdate: Boolean, tag: String?): OneTimeWorkRequest {
             val data = Data.Builder()
                     .putBoolean(EXTRA_REFRESH_RESTRICTIONS_ONLY, refreshRestrictionsOnly)
                     .putBoolean(EXTRA_FORCE_UPDATE, forceUpdate)
@@ -105,7 +140,7 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
             return builder.build()
         }
 
-        fun buildPeriodicWorkRequest(schedulePeriodMs: Long): PeriodicWorkRequest {
+        private fun buildPeriodicWorkRequest(schedulePeriodMs: Long): PeriodicWorkRequest {
             val data = Data.Builder()
                 .putBoolean(EXTRA_REFRESH_RESTRICTIONS_ONLY, false)
                 .putBoolean(EXTRA_FORCE_UPDATE, false)
@@ -121,6 +156,22 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
                 .build()
         }
 
+        /**
+         * Start a one time work sync request. Existing work will be [ExistingWorkPolicy.REPLACE]d.
+         *
+         * If it is required to run a callback when the request was successful or failed, use
+         * `performOneTimeWorkSync(Activity, Runnable, Runnable)`.
+         */
+        fun performOneTimeWorkSync(
+            context: Context,
+            refreshRestrictionsOnly: Boolean,
+            forceUpdate: Boolean,
+            tag: String?
+        ) {
+            val workRequest = buildOneTimeWorkRequest(refreshRestrictionsOnly, forceUpdate, tag)
+            WorkManager.getInstance(context).enqueueUniqueWork(ThreemaApplication.WORKER_WORK_SYNC, ExistingWorkPolicy.REPLACE, workRequest)
+        }
+
         /**
          * Start a one time work sync request.
          *
@@ -166,7 +217,14 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
 
         logger.info("Refreshing work data. Restrictions only = {}, force = {}", updateRestrictionsOnly, forceUpdate)
 
-        if (licenseService == null || notificationService == null || contactService == null || apiConnector == null || preferenceService == null) {
+        if (licenseService == null
+            || notificationService == null
+            || contactService == null
+            || apiConnector == null
+            || preferenceService == null
+            || userService == null
+            || contactModelRepository == null
+        ) {
             logger.info("Services not available")
             return Result.failure()
         }
@@ -181,7 +239,8 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
         if (!updateRestrictionsOnly) {
             val workData: WorkData?
             try {
-                val allContacts: List<ContactModel> = contactService.all
+                // TODO(ANDR-3172): Get all contacts via contact model repository
+                val allContacts: List<ch.threema.storage.models.ContactModel> = contactService.all
                 val identities = arrayOfNulls<String>(allContacts.size)
                 for (n in allContacts.indices) {
                     identities[n] = allContacts[n].identity
@@ -208,24 +267,34 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
                 return Result.failure()
             }
 
-            val existingWorkContacts: List<ContactModel> = contactService.allWork
-            val immutableExistingWorkContacts = existingWorkContacts.toList()
-            for (workContact in workData.workContacts) {
-                val newContact = contactService.addWorkContact(workContact, existingWorkContacts)
-                if (immutableExistingWorkContacts.none { it == newContact }) {
-                    newContact?.let { newWorkContacts.add(it) }
-                }
-            }
+            val existingWorkIdentities = contactService.allWork.map { it.identity }.toSet()
+            val fetchedWorkIdentities = workData.workContacts.map { it.threemaId }.toSet()
+
+            // Create or update work contacts
+            val refreshedWorkIdentities = workData.workContacts.mapNotNull { workContact ->
+                AddOrUpdateWorkContactBackgroundTask(
+                    workContact,
+                    userService.identity,
+                    contactModelRepository,
+                ).runSynchronously()
+            }.map { it.identity }
+
+            val newWorkIdentities = refreshedWorkIdentities - existingWorkIdentities
+            newWorkContacts.addAll(
+                newWorkIdentities.mapNotNull { contactModelRepository.getByIdentity(it) }
+            )
+
+            // Downgrade work contacts
+            val downgradedIdentities = existingWorkIdentities - fetchedWorkIdentities
+            downgradedIdentities.mapNotNull { contactModelRepository.getByIdentity(it) }.forEach {
+                // The contact is no longer a work contact, so set work verification level to none
+                it.setWorkVerificationLevelFromLocal(WorkVerificationLevel.NONE)
 
-            //downgrade work contacts
-            for (x in existingWorkContacts.indices) {
-                //remove isWork flag
-                val c = existingWorkContacts[x]
-                c.setIsWork(false)
-                if (c.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-                    c.verificationLevel = VerificationLevel.UNVERIFIED
+                // Additionally, the contact may not be server verified anymore (except it has been
+                // fully verified before)
+                if (it.data.value?.verificationLevel == VerificationLevel.SERVER_VERIFIED) {
+                    it.setVerificationLevelFromLocal(VerificationLevel.UNVERIFIED)
                 }
-                this.contactService.save(c)
             }
 
             // update applogos
@@ -273,9 +342,7 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
             if (newWorkContacts.isEmpty() || ContactUpdateWorker.fetchAndUpdateContactModels(
                 contactModels = newWorkContacts,
                 apiConnector = apiConnector,
-                contactService = contactService,
                 preferenceService = preferenceService,
-                context = context
             )) {
                 return Result.success()
             } else {
@@ -341,9 +408,9 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
     }
 
     private fun applyNicknameRestriction() {
-        AppRestrictionUtil.getStringRestriction(context.getString(R.string.restriction__nickname))?.let {
-            if (userService != null && !TestUtil.compare(userService.publicNickname, it)) {
-                userService.publicNickname = it
+        AppRestrictionUtil.getStringRestriction(context.getString(R.string.restriction__nickname))?.let { nickname ->
+            if (userService != null && !TestUtil.compare(userService.publicNickname, nickname)) {
+                userService.setPublicNickname(nickname, TriggerSource.LOCAL)
             }
         }
     }
diff --git a/app/src/main/java/ch/threema/data/ModelCache.kt b/app/src/main/java/ch/threema/data/ModelCache.kt
index c1ee8b9d..11e0656d 100644
--- a/app/src/main/java/ch/threema/data/ModelCache.kt
+++ b/app/src/main/java/ch/threema/data/ModelCache.kt
@@ -51,7 +51,7 @@ class ModelCache {
  * Internally, it uses a [WeakValueMap], so the values are not prevented from being
  * garbage collected by the cache.
  */
-class ModelTypeCache<TIdentifier, TModel : BaseModel<*>> {
+class ModelTypeCache<TIdentifier, TModel : BaseModel<*, *>> {
     private val map = WeakValueMap<TIdentifier, TModel>()
 
     /**
diff --git a/app/src/main/java/ch/threema/data/models/BaseModel.kt b/app/src/main/java/ch/threema/data/models/BaseModel.kt
index 61ad3b18..1a9edfab 100644
--- a/app/src/main/java/ch/threema/data/models/BaseModel.kt
+++ b/app/src/main/java/ch/threema/data/models/BaseModel.kt
@@ -21,6 +21,10 @@
 
 package ch.threema.data.models
 
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.TaskManager
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
 
@@ -47,7 +51,7 @@ class ModelDeletedException(modelName: String, methodName: String)
  *
  * It handles reactivity and provides common APIs shared by all models.
  */
-abstract class BaseModel<TData>(
+abstract class BaseModel<TData, TReflectionTask : Task<*, TaskCodec>?>(
     /**
      * Mutable state flow that holds the model data.
      *
@@ -65,6 +69,16 @@ abstract class BaseModel<TData>(
      * The name of this model. Used for debugging purposes.
      */
     protected val modelName: String,
+
+    /**
+     * The multi device manager is needed to determine whether to reflect a change or not.
+     */
+    protected val multiDeviceManager: MultiDeviceManager,
+
+    /**
+     * The task manager is needed to schedule a task that reflects the changes.
+     */
+    protected val taskManager: TaskManager,
 ) {
     /**
      * State flow that holds
@@ -89,6 +103,8 @@ abstract class BaseModel<TData>(
      * @param updateData A function that receives the original data and returns the updated data.
      * @param updateDatabase A function that updates the database with the updated data.
      * @param onUpdated An optional function that is invoked at the end if data was updated.
+     * @param reflectUpdateTask The task that should be executed after the fields have been updated.
+     * Note that the [reflectUpdateTask] is only executed when MD is active.
      */
     protected fun updateFields(
         methodName: String,
@@ -96,6 +112,7 @@ abstract class BaseModel<TData>(
         updateData: (originalData: TData) -> TData,
         updateDatabase: (updatedData: TData) -> Unit,
         onUpdated: ((updatedData: TData) -> Unit)?,
+        reflectUpdateTask: TReflectionTask? = null,
     ) {
         val updatedData = synchronized(this) {
             val originalData = ensureNotDeleted(mutableData.value, methodName)
@@ -104,6 +121,9 @@ abstract class BaseModel<TData>(
                 val updatedData = updateData(originalData)
                 mutableData.value = updatedData
                 updateDatabase(updatedData)
+                if (reflectUpdateTask != null && multiDeviceManager.isMultiDeviceActive) {
+                    taskManager.schedule(reflectUpdateTask)
+                }
                 updatedData
             } else {
                 null
diff --git a/app/src/main/java/ch/threema/data/models/ContactModel.kt b/app/src/main/java/ch/threema/data/models/ContactModel.kt
index b7bece45..3d5b0154 100644
--- a/app/src/main/java/ch/threema/data/models/ContactModel.kt
+++ b/app/src/main/java/ch/threema/data/models/ContactModel.kt
@@ -23,7 +23,11 @@ package ch.threema.data.models
 
 import androidx.lifecycle.LiveData
 import androidx.lifecycle.asLiveData
+import ch.threema.app.tasks.ReflectContactSyncUpdateImmediateTask
+import ch.threema.app.tasks.ReflectContactSyncUpdateTask
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.app.managers.ListenerManager
+import ch.threema.app.utils.ColorUtil
 import ch.threema.app.utils.ContactUtil
 import ch.threema.app.utils.runtimeAssert
 import ch.threema.base.utils.LoggingUtil
@@ -32,16 +36,22 @@ import ch.threema.data.repositories.ContactModelRepository
 import ch.threema.data.repositories.RepositoryToken
 import ch.threema.data.storage.DatabaseBackend
 import ch.threema.data.storage.DbContact
+import ch.threema.domain.models.BasicContact
 import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.models.ReadReceiptPolicy
 import ch.threema.domain.models.TypingIndicatorPolicy
 import ch.threema.domain.models.VerificationLevel
 import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.protocol.ThreemaFeature
+import ch.threema.domain.taskmanager.ActiveTaskCodec
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
 import kotlinx.coroutines.flow.MutableStateFlow
 import java.math.BigInteger
+import java.nio.charset.StandardCharsets
+import java.security.MessageDigest
+import java.security.NoSuchAlgorithmException
 import java.util.Date
 
 private val logger = LoggingUtil.getThreemaLogger("data.ContactModel")
@@ -63,7 +73,7 @@ data class ContactModelData(
     /** Public nickname. */
     @JvmField val nickname: String?,
     /** Color index (0-255). */
-    val colorIndex: UByte,
+    val colorIndex: UByte = getIdColorIndex(identity),
     /** Verification level. */
     @JvmField val verificationLevel: VerificationLevel,
     /** Threema Work verification level. */
@@ -73,7 +83,7 @@ data class ContactModelData(
     /** Acquaintance level (direct / group). */
     @JvmField val acquaintanceLevel: AcquaintanceLevel,
     /** Activity state (active / inactive / invalid). */
-    @JvmField val activityState: State,
+    @JvmField val activityState: IdentityState,
     /** Contact sync state. */
     @JvmField val syncState: ContactSyncState,
     /** Feature mask. */
@@ -125,7 +135,7 @@ data class ContactModelData(
             workVerificationLevel: WorkVerificationLevel,
             identityType: IdentityType,
             acquaintanceLevel: AcquaintanceLevel,
-            activityState: State,
+            activityState: IdentityState,
             featureMask: BigInteger,
             syncState: ContactSyncState,
             readReceiptPolicy: ReadReceiptPolicy,
@@ -168,6 +178,23 @@ data class ContactModelData(
                 department,
             )
         }
+
+        /**
+         * Compute the id color index based on the identity.
+         */
+        fun getIdColorIndex(identity: String): UByte = try {
+            val firstByte = MessageDigest.getInstance("SHA-256")
+                .digest(identity.toByteArray(StandardCharsets.UTF_8)).first()
+            ColorUtil.getInstance().getIDColorIndex(firstByte).toUByte()
+        } catch (e: NoSuchAlgorithmException) {
+            throw IllegalStateException("Could not find hashing algorithm for id color", e)
+        }
+
+        /**
+         * Compute the id color index based on the identity.
+         */
+        @JvmStatic
+        fun getIdColorIndexInt(identity: String): Int = getIdColorIndex(identity).toInt()
     }
 
     /**
@@ -236,6 +263,74 @@ data class ContactModelData(
      * Check if the contact is a gateway contact.
      */
     fun isGatewayContact(): Boolean = ContactUtil.isGatewayContact(identity)
+
+    /**
+     * Get the contact model data as basic contact.
+     */
+    fun toBasicContact(): BasicContact = BasicContact(
+        identity,
+        publicKey,
+        featureMask,
+        activityState,
+        identityType,
+    )
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (javaClass != other?.javaClass) return false
+
+        other as ContactModelData
+
+        if (identity != other.identity) return false
+        if (!publicKey.contentEquals(other.publicKey)) return false
+        if (createdAt != other.createdAt) return false
+        if (firstName != other.firstName) return false
+        if (lastName != other.lastName) return false
+        if (nickname != other.nickname) return false
+        if (colorIndex != other.colorIndex) return false
+        if (verificationLevel != other.verificationLevel) return false
+        if (workVerificationLevel != other.workVerificationLevel) return false
+        if (identityType != other.identityType) return false
+        if (acquaintanceLevel != other.acquaintanceLevel) return false
+        if (activityState != other.activityState) return false
+        if (syncState != other.syncState) return false
+        if (featureMask != other.featureMask) return false
+        if (readReceiptPolicy != other.readReceiptPolicy) return false
+        if (typingIndicatorPolicy != other.typingIndicatorPolicy) return false
+        if (androidContactLookupKey != other.androidContactLookupKey) return false
+        if (localAvatarExpires != other.localAvatarExpires) return false
+        if (isRestored != other.isRestored) return false
+        if (profilePictureBlobId != null) {
+            if (other.profilePictureBlobId == null) return false
+            if (!profilePictureBlobId.contentEquals(other.profilePictureBlobId)) return false
+        } else if (other.profilePictureBlobId != null) return false
+
+        return true
+    }
+
+    override fun hashCode(): Int {
+        var result = identity.hashCode()
+        result = 31 * result + publicKey.contentHashCode()
+        result = 31 * result + createdAt.hashCode()
+        result = 31 * result + firstName.hashCode()
+        result = 31 * result + lastName.hashCode()
+        result = 31 * result + (nickname?.hashCode() ?: 0)
+        result = 31 * result + colorIndex.hashCode()
+        result = 31 * result + verificationLevel.hashCode()
+        result = 31 * result + workVerificationLevel.hashCode()
+        result = 31 * result + identityType.hashCode()
+        result = 31 * result + acquaintanceLevel.hashCode()
+        result = 31 * result + activityState.hashCode()
+        result = 31 * result + syncState.hashCode()
+        result = 31 * result + featureMask.hashCode()
+        result = 31 * result + readReceiptPolicy.hashCode()
+        result = 31 * result + typingIndicatorPolicy.hashCode()
+        result = 31 * result + (androidContactLookupKey?.hashCode() ?: 0)
+        result = 31 * result + (localAvatarExpires?.hashCode() ?: 0)
+        result = 31 * result + isRestored.hashCode()
+        result = 31 * result + (profilePictureBlobId?.contentHashCode() ?: 0)
+        return result
+    }
 }
 
 /**
@@ -245,7 +340,16 @@ class ContactModel(
     val identity: String,
     data: ContactModelData,
     private val databaseBackend: DatabaseBackend,
-) : BaseModel<ContactModelData>(MutableStateFlow(data), "ContactModel") {
+    private val contactModelRepository: ContactModelRepository,
+    coreServiceManager: CoreServiceManager,
+) : BaseModel<ContactModelData, ReflectContactSyncUpdateTask>(
+    MutableStateFlow(data),
+    "ContactModel",
+    coreServiceManager.multiDeviceManager,
+    coreServiceManager.taskManager,
+) {
+
+    private val nonceFactory by lazy { coreServiceManager.nonceFactory }
 
     init {
         runtimeAssert(identity == data.identity, "Contact model identity mismatch")
@@ -263,11 +367,19 @@ class ContactModel(
      */
     fun setNameFromLocal(firstName: String, lastName: String) {
         this.updateFields(
-            "setNameFromLocal",
-            { originalData -> originalData.firstName != firstName || originalData.lastName != lastName },
-            { originalData -> originalData.copy(firstName = firstName, lastName = lastName) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
+            methodName = "setNameFromLocal",
+            detectChanges = { originalData -> originalData.firstName != firstName || originalData.lastName != lastName },
+            updateData = { originalData -> originalData.copy(firstName = firstName, lastName = lastName) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectNameUpdate(
+                newFirstName = firstName,
+                newLastName = lastName,
+                contactIdentity = identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            ),
         )
     }
 
@@ -278,11 +390,23 @@ class ContactModel(
      */
     fun setAcquaintanceLevelFromLocal(acquaintanceLevel: AcquaintanceLevel) {
         this.updateFields(
-            "setAcquaintanceLevelFromLocal",
-            { originalData -> originalData.acquaintanceLevel != acquaintanceLevel },
-            { originalData -> originalData.copy(acquaintanceLevel = acquaintanceLevel) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
+            methodName = "setAcquaintanceLevelFromLocal",
+            detectChanges = { originalData -> originalData.acquaintanceLevel != acquaintanceLevel },
+            updateData = { originalData -> originalData.copy(acquaintanceLevel = acquaintanceLevel) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = { contactModelData ->
+                when (acquaintanceLevel) {
+                    AcquaintanceLevel.DIRECT -> notifyDeprecatedOnModifiedListeners(contactModelData)
+                    AcquaintanceLevel.GROUP -> notifyDeprecatedOnRemovedListeners(contactModelData.identity)
+                }
+            },
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectAcquaintanceLevelUpdate(
+                acquaintanceLevel,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
         )
     }
 
@@ -293,11 +417,121 @@ class ContactModel(
      */
     fun setVerificationLevelFromLocal(verificationLevel: VerificationLevel) {
         this.updateFields(
-            "setVerificationLevelFromLocal",
-            { originalData -> originalData.verificationLevel != verificationLevel },
-            { originalData -> originalData.copy(verificationLevel = verificationLevel) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
+            methodName = "setVerificationLevelFromLocal",
+            detectChanges = { originalData -> originalData.verificationLevel != verificationLevel },
+            updateData = { originalData -> originalData.copy(verificationLevel = verificationLevel) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate(
+                verificationLevel,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
+        )
+    }
+
+    /**
+     * Update the contact's work verification level.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setWorkVerificationLevelFromLocal(workVerificationLevel: WorkVerificationLevel) {
+        this.updateFields(
+            methodName = "setWorkVerificationLevelFromLocal",
+            detectChanges = { originalData -> originalData.workVerificationLevel != workVerificationLevel },
+            updateData = { originalData -> originalData.copy(workVerificationLevel = workVerificationLevel) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectWorkVerificationLevelUpdate(
+                workVerificationLevel,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
+        )
+    }
+
+    /**
+     * Update the contact's identity type.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setIdentityTypeFromLocal(identityType: IdentityType) {
+        this.updateFields(
+            methodName = "setIdentityTypeFromLocal",
+            detectChanges = { originalData -> originalData.identityType != identityType },
+            updateData = { originalData -> originalData.copy(identityType = identityType) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectIdentityTypeUpdate(
+                identityType,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
+        )
+    }
+
+    fun setFeatureMaskFromLocal(
+        featureMask: Long
+    ) {
+        // Warn the user in case there is no forward security support anymore (indicated by a
+        // feature mask change).
+        data.value?.let {
+            val previousFSSupport = ThreemaFeature.canForwardSecurity(it.featureMaskLong())
+            val newFSSupport = ThreemaFeature.canForwardSecurity(featureMask)
+            if (previousFSSupport && !newFSSupport) {
+                ContactUtil.onForwardSecurityNotSupportedAnymore(this)
+            }
+        }
+
+        this.updateFields(
+            methodName = "setFeatureMaskFromLocal",
+            detectChanges = { originalData -> originalData.featureMask != featureMask.toULong() },
+            updateData = { originalData -> originalData.copy(featureMask = featureMask.toULong()) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectFeatureMaskUpdate(
+                featureMask,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
+        )
+    }
+
+    /**
+     * Update the contact's first name.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setFirstNameFromSync(firstName: String) {
+        this.updateFields(
+            methodName = "setFirstNameFromSync",
+            detectChanges = { originalData -> originalData.firstName != firstName },
+            updateData = { originalData -> originalData.copy(firstName = firstName) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's last name.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setLastNameFromSync(lastName: String) {
+        this.updateFields(
+            methodName = "setLastNameFromSync",
+            detectChanges = { originalData -> originalData.lastName != lastName },
+            updateData = { originalData -> originalData.copy(lastName = lastName) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
         )
     }
 
@@ -308,24 +542,287 @@ class ContactModel(
      */
     fun setNicknameFromSync(nickname: String?) {
         this.updateFields(
-            "setNicknameFromSync",
-            { originalData -> originalData.nickname != nickname },
-            { originalData -> originalData.copy(nickname = nickname) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
+            methodName = "setNicknameFromSync",
+            detectChanges = { originalData -> originalData.nickname != nickname },
+            updateData = { originalData -> originalData.copy(nickname = nickname) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    suspend fun setNicknameFromRemote(nickname: String, handle: ActiveTaskCodec) {
+        logger.debug("Updating nickname of {} to {}", identity, nickname)
+
+        // We check whether the nickname is different before trying to reflect it.
+        val data = ensureNotDeleted(data.value, "setNicknameFromRemote")
+        if (data.nickname == nickname) {
+            return
+        }
+
+        if (multiDeviceManager.isMultiDeviceActive) {
+            ReflectContactSyncUpdateImmediateTask.ReflectContactNickname(
+                contactIdentity = identity,
+                newNickname = nickname,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            ).reflect(handle)
+        }
+
+        this.updateFields(
+            methodName = "setNicknameFromRemote",
+            detectChanges = { originalData -> originalData.nickname != nickname },
+            updateData = { originalData -> originalData.copy(nickname = nickname) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's verification level.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setVerificationLevelFromSync(verificationLevel: VerificationLevel) {
+        this.updateFields(
+            methodName = "setVerificationLevelFromSync",
+            detectChanges = { it.verificationLevel != verificationLevel },
+            updateData = { it.copy(verificationLevel = verificationLevel) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's work verification level.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setWorkVerificationLevelFromSync(workVerificationLevel: WorkVerificationLevel) {
+        this.updateFields(
+            methodName = "setWorkVerificationLevelFromSync",
+            detectChanges = { it.workVerificationLevel != workVerificationLevel },
+            updateData = { it.copy(workVerificationLevel = workVerificationLevel) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's identity type.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setIdentityTypeFromSync(identityType: IdentityType) {
+        this.updateFields(
+            methodName = "setIdentityTypeFromSync",
+            detectChanges = { it.identityType != identityType },
+            updateData = { it.copy(identityType = identityType) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's acquaintance level.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setAcquaintanceLevelFromSync(acquaintanceLevel: AcquaintanceLevel) {
+        this.updateFields(
+            methodName = "setAcquaintanceLevelFromSync",
+            detectChanges = { it.acquaintanceLevel != acquaintanceLevel },
+            updateData = { it.copy(acquaintanceLevel = acquaintanceLevel) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's activity state.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setActivityStateFromSync(activityState: IdentityState) {
+        this.updateFields(
+            methodName = "setActivityStateFromSync",
+            detectChanges = { it.activityState != activityState },
+            updateData = { it.copy(activityState = activityState) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's activity state.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setActivityStateFromLocal(activityState: IdentityState) {
+        this.updateFields(
+            methodName = "setActivityStateFromLocal",
+            detectChanges = { it.activityState != activityState },
+            updateData = { it.copy(activityState = activityState) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectActivityStateUpdate(
+                activityState,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
+        )
+    }
+
+    /**
+     * Update the contact's feature mask.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setFeatureMaskFromSync(featureMask: ULong) {
+        this.updateFields(
+            methodName = "setFeatureMaskFromSync",
+            detectChanges = { it.featureMask != featureMask },
+            updateData = { it.copy(featureMask = featureMask) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's sync state.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setSyncStateFromSync(syncState: ContactSyncState) {
+        this.updateFields(
+            methodName = "setSyncStateFromSync",
+            detectChanges = { it.syncState != syncState },
+            updateData = { it.copy(syncState = syncState) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = null // No need to notify listeners, this isn't something that will result in a UI change.
+        )
+    }
+
+    /**
+     * Update the contact's read receipt policy.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setReadReceiptPolicyFromSync(readReceiptPolicy: ReadReceiptPolicy) {
+        this.updateFields(
+            methodName = "setReadReceiptPolicyFromSync",
+            detectChanges = { it.readReceiptPolicy != readReceiptPolicy },
+            updateData = { it.copy(readReceiptPolicy = readReceiptPolicy) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's read receipt policy.
+     *
+     * @throws ModelDeletedException if model is deleted
+     */
+    fun setReadReceiptPolicyFromLocal(readReceiptPolicy: ReadReceiptPolicy) {
+        this.updateFields(
+            methodName = "setReadReceiptPolicyFromLocal",
+            detectChanges = { it.readReceiptPolicy != readReceiptPolicy },
+            updateData = { it.copy(readReceiptPolicy = readReceiptPolicy) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate(
+                readReceiptPolicy,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
+        )
+    }
+
+    /**
+     * Update the contact's typing indicator policy.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setTypingIndicatorPolicyFromSync(typingIndicatorPolicy: TypingIndicatorPolicy) {
+        this.updateFields(
+            methodName = "setTypingIndicatorPolicyFromSync",
+            detectChanges = { it.typingIndicatorPolicy != typingIndicatorPolicy },
+            updateData = { it.copy(typingIndicatorPolicy = typingIndicatorPolicy) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Update the contact's typing indicator policy.
+     *
+     * @throws [ModelDeletedException] if model is deleted.
+     */
+    fun setTypingIndicatorPolicyFromLocal(typingIndicatorPolicy: TypingIndicatorPolicy) {
+        this.updateFields(
+            methodName = "setTypingIndicatorPolicyFromLocal",
+            detectChanges = { it.typingIndicatorPolicy != typingIndicatorPolicy },
+            updateData = { it.copy(typingIndicatorPolicy = typingIndicatorPolicy) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate(
+                typingIndicatorPolicy,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            )
         )
     }
 
     /**
      * Update or remove the contact's Android contact lookup key.
      */
-    fun setAndroidLookupKey(lookupKey: String?) {
+    fun setAndroidLookupKey(lookupKey: String) {
         this.updateFields(
-            "setAndroidLookupKey",
-            { originalData -> originalData.androidContactLookupKey != lookupKey },
-            { originalData -> originalData.copy(androidContactLookupKey = lookupKey) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
+            methodName = "setAndroidLookupKey",
+            detectChanges = { originalData -> originalData.androidContactLookupKey != lookupKey },
+            updateData = { originalData -> originalData.copy(androidContactLookupKey = lookupKey) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+        )
+    }
+
+    /**
+     * Unlink the contact from the android contact. This sets the android lookup key to null and
+     * downgrades the verification level if it is [VerificationLevel.SERVER_VERIFIED]. Note that
+     * the verification level change is reflected if MD is active.
+     */
+    fun removeAndroidContactLink() {
+        // Remove the android lookup key
+        this.updateFields(
+            methodName = "unlinkAndroidContact",
+            detectChanges = { originalData -> originalData.androidContactLookupKey != null },
+            updateData = { originalData -> originalData.copy(androidContactLookupKey = null) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+        )
+
+        // Change verification level if it is server verified. Note that we do not use
+        // setVerificationLevelFromLocal as this must only be done when the verification level is
+        // server verified.
+        this.updateFields(
+            methodName = "unlinkAndroidContact",
+            detectChanges = { originalData -> originalData.verificationLevel == VerificationLevel.SERVER_VERIFIED },
+            updateData = { originalData -> originalData.copy(verificationLevel = VerificationLevel.UNVERIFIED) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners,
+            reflectUpdateTask = ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate(
+                VerificationLevel.UNVERIFIED,
+                identity,
+                contactModelRepository,
+                multiDeviceManager,
+                nonceFactory,
+            ),
         )
     }
 
@@ -334,11 +831,11 @@ class ContactModel(
      */
     fun setLocalAvatarExpires(expiresAt: Date?) {
         this.updateFields(
-            "setLocalAvatarExpires",
-            { originalData -> originalData.localAvatarExpires != expiresAt },
-            { originalData -> originalData.copy(localAvatarExpires = expiresAt) },
-            ::updateDatabase,
-            null, // No need to notify listeners, this isn't something that will result in a UI change.
+            methodName = "setLocalAvatarExpires",
+            detectChanges = { originalData -> originalData.localAvatarExpires != expiresAt },
+            updateData = { originalData -> originalData.copy(localAvatarExpires = expiresAt) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = null, // No need to notify listeners, this isn't something that will result in a UI change.
         )
     }
 
@@ -350,11 +847,11 @@ class ContactModel(
      */
     fun clearIsRestored() {
         this.updateFields(
-            "clearIsRestored",
-            { originalData -> originalData.isRestored },
-            { originalData -> originalData.copy(isRestored = false) },
-            ::updateDatabase,
-            null, // No need to notify listeners, this isn't something that will result in a UI change.
+            methodName = "clearIsRestored",
+            detectChanges = { originalData -> originalData.isRestored },
+            updateData = { originalData -> originalData.copy(isRestored = false) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = null, // No need to notify listeners, this isn't something that will result in a UI change.
         )
     }
 
@@ -367,11 +864,26 @@ class ContactModel(
      */
     fun setProfilePictureBlobId(blobId: ByteArray?) {
         this.updateFields(
-            "setProfilePictureBlobId",
-            { originalData -> !originalData.profilePictureBlobId.contentEquals(blobId) },
-            { originalData -> originalData.copy(profilePictureBlobId = blobId) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
+            methodName = "setProfilePictureBlobId",
+            detectChanges = { originalData -> !originalData.profilePictureBlobId.contentEquals(blobId) },
+            updateData = { originalData -> originalData.copy(profilePictureBlobId = blobId) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = ::notifyDeprecatedOnModifiedListeners
+        )
+    }
+
+    /**
+     * Set whether the contact has been restored or not. After a restore of a backup, every contact
+     * is marked as restored to track whether the profile picture must be requested from this
+     * contact.
+     */
+    fun setIsRestored(isRestored: Boolean) {
+        this.updateFields(
+            methodName = "setIsRestored",
+            detectChanges = { originalData -> originalData.isRestored != isRestored },
+            updateData = { originalData -> originalData.copy(isRestored = isRestored) },
+            updateDatabase = ::updateDatabase,
+            onUpdated = null,
         )
     }
 
@@ -401,29 +913,6 @@ class ContactModel(
         }
     }
 
-    /**
-     * Mark this model as deleted. If [fromDatabase] is true, then the entry will be deleted
-     * from the database as well.
-     *
-     * Note: This method may only be called by the repository! To delete a contact model, call the
-     * appropriate method on the [ContactModelRepository].
-     *
-     * @throws [ModelDeletedException] if model was already marked as deleted.
-     */
-    internal fun delete(token: RepositoryToken, fromDatabase: Boolean) {
-        logger.info("Delete")
-        synchronized(this) {
-            ensureNotDeleted(mutableData.value, "delete")
-            if (fromDatabase) {
-                databaseBackend.deleteContactByIdentity(identity)
-            }
-            mutableData.value = null
-        }
-        if (fromDatabase) {
-            ListenerManager.contactListeners.handle { it.onRemoved(identity) }
-        }
-    }
-
     private fun updateDatabase(updatedData: ContactModelData) {
         databaseBackend.updateContact(ContactModelDataFactory.toDbType(updatedData))
     }
@@ -434,6 +923,13 @@ class ContactModel(
     private fun notifyDeprecatedOnModifiedListeners(data: ContactModelData) {
         ListenerManager.contactListeners.handle { it.onModified(data.identity) }
     }
+
+    /**
+     * Synchronously notify contact change listeners.
+     */
+    private fun notifyDeprecatedOnRemovedListeners(identity: String) {
+        ListenerManager.contactListeners.handle { it.onRemoved(identity) }
+    }
 }
 
 internal object ContactModelDataFactory : ModelDataFactory<ContactModelData, DbContact> {
diff --git a/app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt b/app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt
index 8dba998f..72b84669 100644
--- a/app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt
+++ b/app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt
@@ -21,11 +21,19 @@
 
 package ch.threema.data.models
 
+import ch.threema.app.managers.CoreServiceManager
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
 import kotlinx.coroutines.flow.MutableStateFlow
 
-class EditHistoryListModel(data: List<EditHistoryEntryData>) : BaseModel<List<EditHistoryEntryData>>(
+class EditHistoryListModel(
+    data: List<EditHistoryEntryData>,
+    coreServiceManager: CoreServiceManager,
+) : BaseModel<List<EditHistoryEntryData>, Task<*, TaskCodec>>(
     modelName = "EditHistoryListModel",
-    mutableData = MutableStateFlow(data)
+    mutableData = MutableStateFlow(data),
+    multiDeviceManager = coreServiceManager.multiDeviceManager,
+    taskManager = coreServiceManager.taskManager,
 ) {
     fun addEntry(entry: EditHistoryEntryData) {
         if (mutableData.value?.none { it == entry } == true) {
diff --git a/app/src/main/java/ch/threema/data/models/GroupModel.kt b/app/src/main/java/ch/threema/data/models/GroupModel.kt
index 0f653110..09d04605 100644
--- a/app/src/main/java/ch/threema/data/models/GroupModel.kt
+++ b/app/src/main/java/ch/threema/data/models/GroupModel.kt
@@ -23,12 +23,15 @@ package ch.threema.data.models
 
 import androidx.lifecycle.LiveData
 import androidx.lifecycle.asLiveData
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.app.utils.runtimeAssert
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.base.utils.Utils
 import ch.threema.data.repositories.RepositoryToken
 import ch.threema.data.storage.DatabaseBackend
 import ch.threema.data.storage.DbGroup
+import ch.threema.domain.taskmanager.Task
+import ch.threema.storage.models.GroupModel.UserState
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.serialization.Serializable
 import java.nio.ByteBuffer
@@ -89,6 +92,8 @@ data class GroupModelData(
      * @throws UnsupportedOperationException if the set is being modified
      */
     @JvmField val members: Set<String>,
+    /** The group user state */
+    @JvmField val userState: UserState,
 ) {
     companion object {
         /**
@@ -108,6 +113,7 @@ data class GroupModelData(
             groupDescription: String?,
             groupDescriptionChangedAt: Date?,
             members: Set<String>,
+            userState: UserState,
         ): GroupModelData {
             if (colorIndex < 0 || colorIndex > 255) {
                 throw IllegalArgumentException("colorIndex must be between 0 and 255")
@@ -124,6 +130,7 @@ data class GroupModelData(
                 groupDescription,
                 groupDescriptionChangedAt,
                 Collections.unmodifiableSet(members),
+                userState,
             )
         }
     }
@@ -141,7 +148,13 @@ class GroupModel(
     val groupIdentity: GroupIdentity,
     data: GroupModelData,
     private val databaseBackend: DatabaseBackend,
-) : BaseModel<GroupModelData>(MutableStateFlow(data), "GroupModel") {
+    coreServiceManager: CoreServiceManager,
+) : BaseModel<GroupModelData, Task<*, Any>>(
+    MutableStateFlow(data),
+    "GroupModel",
+    coreServiceManager.multiDeviceManager,
+    coreServiceManager.taskManager
+) {
 
     init {
         runtimeAssert(
@@ -197,6 +210,7 @@ internal object GroupModelDataFactory : ModelDataFactory<GroupModelData, DbGroup
         groupDescription = value.groupDescription,
         groupDescriptionChangedAt = value.groupDescriptionChangedAt,
         members = value.members,
+        userState = value.userState,
     )
 
     override fun toDataType(value: DbGroup): GroupModelData = GroupModelData(
@@ -211,6 +225,7 @@ internal object GroupModelDataFactory : ModelDataFactory<GroupModelData, DbGroup
         groupDescription = value.groupDescription,
         groupDescriptionChangedAt = value.groupDescriptionChangedAt,
         members = value.members,
+        userState = value.userState,
     )
 
     private fun groupIdDbToData(littleEndianHexGroupId: String): Long {
diff --git a/app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt b/app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt
index 27326bc5..7380e84d 100644
--- a/app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt
+++ b/app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt
@@ -23,34 +23,25 @@ package ch.threema.data.repositories
 
 import android.database.sqlite.SQLiteException
 import ch.threema.app.listeners.ContactListener
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.app.managers.ListenerManager
-import ch.threema.app.utils.ColorUtil
+import ch.threema.app.tasks.ReflectContactSyncCreateTask
 import ch.threema.base.ThreemaException
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.data.ModelTypeCache
 import ch.threema.data.models.ContactModel
 import ch.threema.data.models.ContactModelData
 import ch.threema.data.models.ContactModelDataFactory
-import ch.threema.data.models.ModelDeletedException
 import ch.threema.data.storage.DatabaseBackend
-import ch.threema.domain.models.ContactSyncState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.ReadReceiptPolicy
-import ch.threema.domain.models.TypingIndicatorPolicy
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.models.WorkVerificationLevel
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
-import java.nio.charset.StandardCharsets
-import java.security.MessageDigest
-import java.security.NoSuchAlgorithmException
-import java.util.Date
+import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.TransactionScope
 
 private val logger = LoggingUtil.getThreemaLogger("data.ContactModelRepository")
 
 class ContactModelRepository(
     private val cache: ModelTypeCache<String, ContactModel>, // Note: Synchronize access
     private val databaseBackend: DatabaseBackend,
+    private val coreServiceManager: CoreServiceManager,
 ) {
     private object ContactModelRepositoryToken : RepositoryToken
 
@@ -62,75 +53,84 @@ class ContactModelRepository(
                     cache.get(identity)?.refreshFromDb(ContactModelRepositoryToken)
                 }
             }
-
-            override fun onAvatarChanged(contactModel: ch.threema.storage.models.ContactModel?) {
-                // Ignored, avatars are not handled in contact model
-            }
-
-            override fun onRemoved(identity: String) {
-                // Called when the "old model" was deleted. Propagate the deletion.
-                synchronized(this@ContactModelRepository) {
-                    cache.get(identity)?.let {
-                        delete(it, true)
-                    }
-                }
-            }
         })
     }
 
     /**
      * Create a new contact from local. This also reflects the contact if MD is active.
      *
-     * @throws ContactCreateException if inserting the contact in the database failed
+     * @throws ContactReflectException if reflecting the contact failed
+     * @throws ContactStoreException if inserting the contact in the database failed
      */
-    fun createFromLocal(
-        identity: String,
-        publicKey: ByteArray,
-        date: Date,
-        identityType: IdentityType,
-        acquaintanceLevel: AcquaintanceLevel,
-        activityState: State,
-        featureMask: ULong,
-        verificationLevel: VerificationLevel = VerificationLevel.UNVERIFIED,
-    ): ContactModel = createAndReflect(
-        identity,
-        publicKey,
-        date,
-        identityType,
-        acquaintanceLevel,
-        activityState,
-        featureMask,
-        verificationLevel,
-    )
+    suspend fun createFromLocal(contactModelData: ContactModelData): ContactModel {
+        val createContactLocally: () -> ContactModel = {
+            createContactLocally(contactModelData)
+        }
+
+        return if (coreServiceManager.multiDeviceManager.isMultiDeviceActive) {
+            try {
+                coreServiceManager.taskManager.schedule(
+                    ReflectContactSyncCreateTask(
+                        contactModelData,
+                        this,
+                        coreServiceManager.nonceFactory,
+                        createContactLocally,
+                        coreServiceManager.multiDeviceManager,
+                    )
+                ).await()
+            } catch (e: TransactionScope.TransactionException) {
+                logger.error("Could not reflect the contact")
+                throw ContactReflectException(e)
+            }
+        } else {
+            createContactLocally()
+        }
+    }
 
     /**
      * Create a new contact from remote. This also reflects the contact if MD is active.
      *
-     * @throws ContactCreateException if inserting the contact in the database failed
+     * @throws ContactReflectException if reflecting the contact failed
+     * @throws ContactStoreException if inserting the contact in the database failed
      */
     suspend fun createFromRemote(
-        identity: String,
-        publicKey: ByteArray,
-        date: Date,
-        identityType: IdentityType,
-        acquaintanceLevel: AcquaintanceLevel,
-        activityState: State,
-        featureMask: ULong,
-        verificationLevel: VerificationLevel = VerificationLevel.UNVERIFIED,
-    ) = createAndReflect(
-        identity,
-        publicKey,
-        date,
-        identityType,
-        acquaintanceLevel,
-        activityState,
-        featureMask,
-        verificationLevel,
-    )
+        contactModelData: ContactModelData,
+        handle: ActiveTaskCodec,
+    ): ContactModel {
+        val createContactLocally: () -> ContactModel = {
+            createContactLocally(contactModelData)
+        }
 
+        return if (coreServiceManager.multiDeviceManager.isMultiDeviceActive) {
+            try {
+                ReflectContactSyncCreateTask(
+                    contactModelData,
+                    this,
+                    coreServiceManager.nonceFactory,
+                    createContactLocally,
+                    coreServiceManager.multiDeviceManager,
+                ).invoke(handle)
+            } catch (e: TransactionScope.TransactionException) {
+                logger.error("Could not reflect the contact", e)
+                throw ContactReflectException(e)
+            }
+        } else {
+            createContactLocally()
+        }
+    }
+
+    /**
+     * Create a new contact from sync.
+     *
+     * @throws ContactStoreException if the contact could not be stored in the database
+     */
     @Synchronized
     fun createFromSync(contactModelData: ContactModelData): ContactModel {
-        databaseBackend.createContact(ContactModelDataFactory.toDbType(contactModelData))
+        try {
+            databaseBackend.createContact(ContactModelDataFactory.toDbType(contactModelData))
+        } catch (e: SQLiteException) {
+            throw ContactStoreException(e)
+        }
 
         notifyDeprecatedListenersNew(contactModelData.identity)
 
@@ -139,61 +139,26 @@ class ContactModelRepository(
     }
 
     /**
-     * Create and reflect a new contact.
+     * Creates the contact with the given data locally. After adding the contact, the listeners are
+     * fired.
      *
-     * @throws ContactCreateException if inserting the contact in the database failed
+     * @throws ContactStoreException if inserting the contact in the database fails
      */
-    private fun createAndReflect(
-        identity: String,
-        publicKey: ByteArray,
-        date: Date,
-        identityType: IdentityType,
-        acquaintanceLevel: AcquaintanceLevel,
-        activityState: State,
-        featureMask: ULong,
-        verificationLevel: VerificationLevel
-    ): ContactModel {
-        val contactModelData = ContactModelData(
-            identity = identity,
-            publicKey = publicKey,
-            createdAt = date,
-            firstName = "",
-            lastName = "",
-            nickname = null,
-            colorIndex = getIdColorIndex(identity),
-            verificationLevel = verificationLevel,
-            workVerificationLevel = WorkVerificationLevel.NONE,
-            identityType = identityType,
-            acquaintanceLevel = acquaintanceLevel,
-            activityState = activityState,
-            syncState = ContactSyncState.INITIAL,
-            featureMask = featureMask,
-            readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
-            typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
-            androidContactLookupKey = null,
-            localAvatarExpires = null,
-            isRestored = false,
-            profilePictureBlobId = null,
-            jobTitle = null,
-            department = null
-        )
-
-        // TODO(ANDR-3002) and TODO(ANDR-3003): Reflect contact sync create
-
+    private fun createContactLocally(contactModelData: ContactModelData): ContactModel {
         val contactModel = synchronized(this) {
             try {
                 databaseBackend.createContact(ContactModelDataFactory.toDbType(contactModelData))
             } catch (exception: SQLiteException) {
                 // Note that in case the insertion fails, this is most likely because the identity
                 // already exists.
-                throw ContactCreateException(exception)
+                throw ContactStoreException(exception)
             }
 
-            getByIdentity(identity)
+            getByIdentity(contactModelData.identity)
                 ?: throw IllegalStateException("Contact must exist at this point")
         }
 
-        notifyDeprecatedListenersNew(identity)
+        notifyDeprecatedListenersNew(contactModelData.identity)
 
         return contactModel
     }
@@ -204,73 +169,41 @@ class ContactModelRepository(
     @Synchronized
     fun getByIdentity(identity: String): ContactModel? {
         return cache.getOrCreate(identity) {
-            val dbContact =
-                databaseBackend.getContactByIdentity(identity) ?: return@getOrCreate null
-            ContactModel(identity, ContactModelDataFactory.toDataType(dbContact), databaseBackend)
+            val dbContact = databaseBackend.getContactByIdentity(identity) ?: return@getOrCreate null
+            ContactModel(
+                identity,
+                ContactModelDataFactory.toDataType(dbContact),
+                databaseBackend,
+                this,
+                coreServiceManager,
+            )
         }
     }
 
-    /**
-     * Remove the specified contact from the database and cache.
-     */
-    @Synchronized
-    fun deleteByIdentity(identity: String) {
-        // Look up model. If found, delete it.
-        getByIdentity(identity)?.let { this.delete(it, false) }
-
-        // TODO(ANDR-2835): Test that deletion works as intended, by opening the contact details,
-        // and then deleting the contact via multi-device protocol.
-    }
-
-    /**
-     * Remove the specified contact model from the database and cache.
-     */
     @Synchronized
-    fun delete(contact: ContactModel) {
-        this.delete(contact, false)
-    }
-
-    /**
-     * Remove the specified contact model from the cache and possibly from the database.
-     *
-     * @param indirect This parameter should be set to `false` when called directly by app code,
-     *     and `true` when called as an effect of a `onRemoved` listener.
-     */
-    @Synchronized
-    private fun delete(model: ContactModel, indirect: Boolean) {
-        // Remove from cache
-        cache.remove(model.identity)
-
-        // Delete data from database and deactivate model
-        try {
-            model.delete(ContactModelRepositoryToken, !indirect)
-        } catch (e: ModelDeletedException) {
-            if (!indirect) {
-                throw e
-            } else {
-                logger.warn("Model for ${model.identity} is already marked as deleted")
-            }
-        }
-    }
+    fun existsByIdentity(identity: String): Boolean =
+        (cache.get(identity) ?: databaseBackend.getContactByIdentity(identity)) != null
 
     private fun notifyDeprecatedListenersNew(identity: String) {
         ListenerManager.contactListeners.handle { it.onNew(identity) }
     }
-
-    /**
-     * Compute the sha 256 hash of this identity and set the color index accordingly.
-     */
-    private fun getIdColorIndex(identity: String): UByte = try {
-        val firstByte = MessageDigest.getInstance("SHA-256")
-            .digest(identity.toByteArray(StandardCharsets.UTF_8))[0]
-        ColorUtil.getInstance().getIDColorIndex(firstByte).toUByte()
-    } catch (e: NoSuchAlgorithmException) {
-        throw IllegalStateException("Could not find hashing algorithm for id color", e)
-    }
 }
 
 /**
- * This exception is thrown if the contact could not be added. A corrupt database or
+ * This exception is thrown if the contact could not be added. This is either due to a failure
+ * reflecting ([ContactReflectException]) or storing ([ContactStoreException]) the contact.
+ */
+sealed class ContactCreateException(msg: String, e: Exception) : ThreemaException(msg, e)
+
+/**
+ * This exception is thrown if the contact could not be added because reflecting it failed.
+ */
+class ContactReflectException(e: TransactionScope.TransactionException) :
+    ContactCreateException("Failed to reflect the contact", e)
+
+/**
+ * This exception is thrown if the contact could not be added. A corrupt database or a contact with
+ * the same identity already exists.
  */
-class ContactCreateException(e: SQLiteException) :
-    ThreemaException("Failed to create the contact", e)
+class ContactStoreException(e: SQLiteException) :
+    ContactCreateException("Failed to create the contact", e)
diff --git a/app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt b/app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt
index 3dd9ad12..0c7aec84 100644
--- a/app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt
+++ b/app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt
@@ -22,6 +22,7 @@
 package ch.threema.data.repositories
 
 import android.database.sqlite.SQLiteException
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.base.ThreemaException
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.data.ModelTypeCache
@@ -39,14 +40,15 @@ private val logger: Logger = LoggingUtil.getThreemaLogger("EditHistoryRepository
 class EditHistoryRepository(
     private val cache: ModelTypeCache<String, EditHistoryListModel>,
     private val editHistoryDao: EditHistoryDao,
+    private val coreServiceManager: CoreServiceManager,
 ) {
     fun getByMessageUid(messageUid: String): EditHistoryListModel? {
         return cache.getOrCreate(messageUid) {
             logger.debug("Load edit history for message {} from database", messageUid)
             EditHistoryListModel(
-                editHistoryDao
-                    .findAllByMessageUid(messageUid)
-                    .map(DbEditHistoryEntry::toDataType)
+                editHistoryDao.findAllByMessageUid(messageUid)
+                    .map { it.toDataType() },
+                coreServiceManager,
             )
         }
     }
diff --git a/app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt b/app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt
index 0c276dc1..8907ff4b 100644
--- a/app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt
+++ b/app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt
@@ -22,6 +22,7 @@
 package ch.threema.data.repositories
 
 import ch.threema.app.listeners.GroupListener
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.app.managers.ListenerManager
 import ch.threema.data.ModelTypeCache
 import ch.threema.data.models.GroupIdentity
@@ -33,6 +34,7 @@ import ch.threema.domain.models.GroupId
 class GroupModelRepository(
     private val cache: ModelTypeCache<GroupIdentity, GroupModel>, // Note: Synchronize access
     private val databaseBackend: DatabaseBackend,
+    private val coreServiceManager: CoreServiceManager,
 ) {
     private object GroupModelRepositoryToken : RepositoryToken
 
@@ -46,7 +48,6 @@ class GroupModelRepository(
             override fun onNewMember(
                 group: ch.threema.storage.models.GroupModel?,
                 newIdentity: String?,
-                previousMemberCount: Int,
             ) {
                 onModified(group)
             }
@@ -54,7 +55,6 @@ class GroupModelRepository(
             override fun onMemberLeave(
                 group: ch.threema.storage.models.GroupModel?,
                 identity: String?,
-                previousMemberCount: Int,
             ) {
                 onModified(group)
             }
@@ -62,7 +62,6 @@ class GroupModelRepository(
             override fun onMemberKicked(
                 group: ch.threema.storage.models.GroupModel?,
                 identity: String?,
-                previousMemberCount: Int,
             ) {
                 onModified(group)
             }
@@ -114,6 +113,7 @@ class GroupModelRepository(
                 groupIdentity,
                 GroupModelDataFactory.toDataType(dbGroup),
                 databaseBackend,
+                coreServiceManager,
             )
         }
     }
@@ -132,7 +132,8 @@ class GroupModelRepository(
             GroupModel(
                 groupIdentity,
                 GroupModelDataFactory.toDataType(dbGroup),
-                databaseBackend
+                databaseBackend,
+                coreServiceManager,
             )
         }
     }
diff --git a/app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt b/app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt
index abfe95a5..2e737f33 100644
--- a/app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt
+++ b/app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt
@@ -21,22 +21,24 @@
 
 package ch.threema.data.repositories
 
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.data.ModelCache
 import ch.threema.data.storage.EditHistoryDaoImpl
 import ch.threema.data.storage.SqliteDatabaseBackend
-import ch.threema.storage.DatabaseServiceNew
 
-class ModelRepositories(databaseService: DatabaseServiceNew) {
+class ModelRepositories(
+    coreServiceManager: CoreServiceManager,
+) {
     private val logger = LoggingUtil.getThreemaLogger("data.ModelRepositories")
 
     private val cache = ModelCache()
-    private val databaseBackend = SqliteDatabaseBackend(databaseService)
-    private val editHistoryDao = EditHistoryDaoImpl(databaseService)
+    private val databaseBackend = SqliteDatabaseBackend(coreServiceManager.databaseService)
+    private val editHistoryDao = EditHistoryDaoImpl(coreServiceManager.databaseService)
 
-    val contacts = ContactModelRepository(cache.contacts, databaseBackend)
-    val groups = GroupModelRepository(cache.groups, databaseBackend)
-    val editHistory = EditHistoryRepository(cache.editHistory, editHistoryDao)
+    val contacts = ContactModelRepository(cache.contacts, databaseBackend, coreServiceManager)
+    val groups = GroupModelRepository(cache.groups, databaseBackend, coreServiceManager)
+    val editHistory = EditHistoryRepository(cache.editHistory, editHistoryDao, coreServiceManager)
 
     init {
         logger.debug("Created")
diff --git a/app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt b/app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt
index ae4a569a..ba646460 100644
--- a/app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt
+++ b/app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt
@@ -60,6 +60,12 @@ interface DatabaseBackend {
      */
     fun deleteContactByIdentity(identity: String): Boolean
 
+    /**
+     * Check whether the contact is currently part of a group. Note that only groups are considered
+     * where 'deleted' is set to 0.
+     */
+    fun isContactInGroup(identity: String): Boolean
+
     /**
      * Insert a new group.
      *
diff --git a/app/src/main/java/ch/threema/data/storage/DbTypes.kt b/app/src/main/java/ch/threema/data/storage/DbTypes.kt
index 45174dbc..48c4bde0 100644
--- a/app/src/main/java/ch/threema/data/storage/DbTypes.kt
+++ b/app/src/main/java/ch/threema/data/storage/DbTypes.kt
@@ -22,12 +22,14 @@
 package ch.threema.data.storage
 
 import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.models.ReadReceiptPolicy
 import ch.threema.domain.models.TypingIndicatorPolicy
 import ch.threema.domain.models.VerificationLevel
 import ch.threema.domain.models.WorkVerificationLevel
 import ch.threema.storage.models.ContactModel
+import ch.threema.storage.models.GroupModel.UserState
 import java.util.Date
 
 // This file contains the types used in the database abstraction layer.
@@ -56,7 +58,7 @@ data class DbContact(
     /** Acquaintance level (direct / group). */
     val acquaintanceLevel: ContactModel.AcquaintanceLevel,
     /** Activity state (active / inactive / invalid). */
-    val activityState: ContactModel.State,
+    val activityState: IdentityState,
     /** Contact sync state. */
     val syncState: ContactSyncState,
     /** Feature mask. */
@@ -107,6 +109,8 @@ data class DbGroup(
     val groupDescriptionChangedAt: Date?,
     /** The group members' identities. */
     val members: Set<String>,
+    /** The group user state. */
+    val userState: UserState,
 )
 
 data class DbEditHistoryEntry(
diff --git a/app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt b/app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt
index cde0ccf6..e851b4f3 100644
--- a/app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt
+++ b/app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt
@@ -34,11 +34,13 @@ import androidx.sqlite.db.SupportSQLiteQueryBuilder
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.data.models.GroupIdentity
 import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.models.ReadReceiptPolicy
 import ch.threema.domain.models.TypingIndicatorPolicy
 import ch.threema.domain.models.VerificationLevel
 import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.storage.DatabaseUtil
 import ch.threema.storage.CursorHelper
 import ch.threema.storage.models.ContactModel
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel
@@ -307,16 +309,16 @@ class SqliteDatabaseBackend(private val sqlite: SupportSQLiteOpenHelper) : Datab
             }
         }
         val activityState = when (activityStateRaw) {
-            "INACTIVE" -> ContactModel.State.INACTIVE
-            "INVALID" -> ContactModel.State.INVALID
-            "ACTIVE" -> ContactModel.State.ACTIVE
-            "TEMPORARY" -> ContactModel.State.ACTIVE // Legacy state, see !276
+            "INACTIVE" -> IdentityState.INACTIVE
+            "INVALID" -> IdentityState.INVALID
+            "ACTIVE" -> IdentityState.ACTIVE
+            "TEMPORARY" -> IdentityState.ACTIVE // Legacy state, see !276
             else -> {
                 logger.warn(
                     "activityState value out of range: {}. Falling back to ACTIVE.",
                     activityStateRaw
                 )
-                ContactModel.State.ACTIVE
+                IdentityState.ACTIVE
             }
         }
         val syncState = when (syncStateRaw) {
@@ -426,9 +428,9 @@ class SqliteDatabaseBackend(private val sqlite: SupportSQLiteOpenHelper) : Datab
         )
         put(
             ContactModel.COLUMN_STATE, when (contact.activityState) {
-                ContactModel.State.ACTIVE -> "ACTIVE"
-                ContactModel.State.INACTIVE -> "INACTIVE"
-                ContactModel.State.INVALID -> "INVALID"
+                IdentityState.ACTIVE -> "ACTIVE"
+                IdentityState.INACTIVE -> "INACTIVE"
+                IdentityState.INVALID -> "INVALID"
             }
         )
         put(
@@ -469,6 +471,20 @@ class SqliteDatabaseBackend(private val sqlite: SupportSQLiteOpenHelper) : Datab
         ) > 0
     }
 
+    override fun isContactInGroup(identity: String): Boolean {
+        sqlite.readableDatabase.query(
+            DatabaseUtil.IS_GROUP_MEMBER_QUERY,
+            arrayOf(identity)
+        ).use {
+            return if (it.moveToFirst()) {
+                it.getInt(0) == 1
+            } else {
+                logger.error("Could not execute query to check whether contact is group member")
+                false
+            }
+        }
+    }
+
     /**
      * Create a group.
      *
@@ -534,6 +550,7 @@ class SqliteDatabaseBackend(private val sqlite: SupportSQLiteOpenHelper) : Datab
                         GroupModel.COLUMN_COLOR_INDEX,
                         GroupModel.COLUMN_GROUP_DESC,
                         GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP,
+                        GroupModel.COLUMN_USER_STATE,
                     )
                 )
                 .apply(addSelection)
@@ -543,44 +560,41 @@ class SqliteDatabaseBackend(private val sqlite: SupportSQLiteOpenHelper) : Datab
                 return null
             }
 
-            val localDbId = cursor.getLong(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_ID))
-            val creatorIdentity = cursor.getString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_CREATOR_IDENTITY))
-            val groupId = cursor.getString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_API_GROUP_ID))
-            val name = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_NAME))
-            val createdAt = cursor.getDateByString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_CREATED_AT))
-            val synchronizedAt = cursor.getDateOrNull(
-                getColumnIndexOrThrow(
-                    cursor,
-                    GroupModel.COLUMN_SYNCHRONIZED_AT
-                )
-            )
-            val lastUpdate = cursor.getDateOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_LAST_UPDATE))
-            val deleted = cursor.getBoolean(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_DELETED))
-            val isArchived = cursor.getBoolean(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_IS_ARCHIVED))
-            val colorIndex = cursor.getUByte(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_COLOR_INDEX))
-            val groupDesc = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_GROUP_DESC))
-            val groupDescChangedAt = cursor.getDateByStringOrNull(
-                getColumnIndexOrThrow(
-                    cursor,
-                    GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP
-                )
-            )
-            val members = getGroupMembers(localDbId)
-
-            return DbGroup(
-                creatorIdentity = creatorIdentity,
-                groupId = groupId,
-                name = name,
-                createdAt = createdAt,
-                synchronizedAt = synchronizedAt,
-                lastUpdate = lastUpdate,
-                deleted = deleted,
-                isArchived = isArchived,
-                colorIndex = colorIndex,
-                groupDescription = groupDesc,
-                groupDescriptionChangedAt = groupDescChangedAt,
-                members = members,
-            )
+             val localDbId = cursor.getLong(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_ID))
+             val creatorIdentity = cursor.getString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_CREATOR_IDENTITY))
+             val groupId = cursor.getString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_API_GROUP_ID))
+             val name = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_NAME))
+             val createdAt = cursor.getDateByString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_CREATED_AT))
+             val synchronizedAt = cursor.getDateOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_SYNCHRONIZED_AT))
+             val lastUpdate = cursor.getDateOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_LAST_UPDATE))
+             val deleted = cursor.getBoolean(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_DELETED))
+             val isArchived = cursor.getBoolean(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_IS_ARCHIVED))
+             val colorIndex = cursor.getUByte(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_COLOR_INDEX))
+             val groupDesc = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_GROUP_DESC))
+             val groupDescChangedAt = cursor.getDateByStringOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP))
+             val members = getGroupMembers(localDbId)
+             val userStateValue = cursor.getInt(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_USER_STATE))
+             val userState = GroupModel.UserState.valueOf(userStateValue) ?: run {
+                 logger.error("Invalid group user state: {}", userStateValue)
+                 // We use member as fallback to not accidentally remove the user from the group
+                 GroupModel.UserState.MEMBER
+             }
+
+             return DbGroup(
+                 creatorIdentity = creatorIdentity,
+                 groupId = groupId,
+                 name = name,
+                 createdAt = createdAt,
+                 synchronizedAt = synchronizedAt,
+                 lastUpdate = lastUpdate,
+                 deleted = deleted,
+                 isArchived = isArchived,
+                 colorIndex = colorIndex,
+                 groupDescription = groupDesc,
+                 groupDescriptionChangedAt = groupDescChangedAt,
+                 members = members,
+                 userState = userState,
+             )
         }
     }
 
@@ -611,10 +625,8 @@ class SqliteDatabaseBackend(private val sqlite: SupportSQLiteOpenHelper) : Datab
         put(GroupModel.COLUMN_IS_ARCHIVED, group.isArchived)
         put(GroupModel.COLUMN_COLOR_INDEX, group.colorIndex.toInt())
         put(GroupModel.COLUMN_GROUP_DESC, group.groupDescription)
-        put(
-            GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP,
-            group.groupDescriptionChangedAt?.toDateStringOrNull()
-        )
+        put(GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP, group.groupDescriptionChangedAt?.toDateStringOrNull())
+        put(GroupModel.COLUMN_USER_STATE, group.userState.value)
     }
 
     private fun getLocalGroupDbId(group: DbGroup): Long {
diff --git a/app/src/main/java/ch/threema/logging/LibthreemaLogger.kt b/app/src/main/java/ch/threema/logging/LibthreemaLogger.kt
new file mode 100644
index 00000000..4f504af1
--- /dev/null
+++ b/app/src/main/java/ch/threema/logging/LibthreemaLogger.kt
@@ -0,0 +1,40 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.logging
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.libthreema.LogDispatcher
+import ch.threema.libthreema.LogLevel
+
+private val logger = LoggingUtil.getThreemaLogger("libthreema")
+
+class LibthreemaLogger : LogDispatcher {
+    override fun log(level: LogLevel, record: String) {
+        when (level) {
+            LogLevel.TRACE -> logger.trace(record)
+            LogLevel.DEBUG -> logger.debug(record)
+            LogLevel.INFO -> logger.info(record)
+            LogLevel.WARN -> logger.warn(record)
+            LogLevel.ERROR -> logger.error(record)
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/storage/DatabaseNonceStore.java b/app/src/main/java/ch/threema/storage/DatabaseNonceStore.java
deleted file mode 100644
index b5649c35..00000000
--- a/app/src/main/java/ch/threema/storage/DatabaseNonceStore.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage;
-
-import android.annotation.SuppressLint;
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteException;
-
-import androidx.annotation.NonNull;
-
-import net.zetetic.database.sqlcipher.SQLiteConnection;
-import net.zetetic.database.sqlcipher.SQLiteDatabase;
-import net.zetetic.database.sqlcipher.SQLiteDatabaseHook;
-import net.zetetic.database.sqlcipher.SQLiteOpenHelper;
-
-import org.slf4j.Logger;
-
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.crypto.Mac;
-import javax.crypto.spec.SecretKeySpec;
-
-import ch.threema.base.crypto.NonceStore;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.base.utils.Utils;
-import ch.threema.domain.stores.IdentityStoreInterface;
-
-public class DatabaseNonceStore extends SQLiteOpenHelper
-	implements NonceStore {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("NonceDatabaseBlobService");
-
-	public static final String DATABASE_NAME_V4 = "threema-nonce-blob4.db";
-	private static final int DATABASE_VERSION = 1;
-	private final IdentityStoreInterface identityStore;
-
-	public DatabaseNonceStore(final Context context, IdentityStoreInterface identityStore) {
-		super(
-			context,
-			DATABASE_NAME_V4,
-			"",
-			null,
-			DATABASE_VERSION,
-			0,
-			null,
-			new SQLiteDatabaseHook() {
-				@Override
-				public void preKey(SQLiteConnection connection) {
-					// not used
-				}
-
-				@SuppressLint("DefaultLocale")
-				@Override
-				public void postKey(SQLiteConnection connection) {
-					// turn off memory wiping for now due to https://github.com/sqlcipher/android-database-sqlcipher/issues/411
-					connection.execute("PRAGMA cipher_memory_security = OFF;", new Object[]{}, null);
-				}
-			}
-			,
-			false);
-		this.identityStore = identityStore;
-	}
-
-	@Override
-	public void onCreate(SQLiteDatabase sqLiteDatabase) {
-		sqLiteDatabase.execSQL("CREATE TABLE `threema_nonce` (`nonce` BLOB PRIMARY KEY)");
-	}
-
-	@Override
-	public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {
-		// no special upgrade handling
-	}
-
-	public void executeNull() throws SQLiteException {
-		try {
-			getWritableDatabase().rawQuery("SELECT NULL").close();
-		} catch (Exception e) {
-			logger.error("Unable to execute initial query", e);
-		}
-	}
-
-	@Override
-	public boolean exists(@NonNull byte[] nonce) {
-		boolean hasRecord = false;
-		Cursor c = this.getReadableDatabase()
-				.rawQuery("SELECT COUNT(*) FROM `threema_nonce` WHERE `nonce` = x'"
-								+ Utils.byteArrayToHexString(nonce)
-								+ "' OR `nonce` = x'"
-								+ Utils.byteArrayToHexString(this.hashNonce(nonce))
-								+ "'", null);
-		if (c != null) {
-			if (c.moveToFirst()) {
-				hasRecord = c.getInt(0) > 0;
-			}
-			c.close();
-		}
-		return hasRecord;
-	}
-
-	@Override
-	public boolean store(@NonNull byte[] nonce) {
-		ContentValues c = new ContentValues();
-		c.put("nonce", this.hashNonce(nonce));
-
-		try {
-			return this.getWritableDatabase()
-					.insertOrThrow("threema_nonce", null, c) >= 1;
-		} catch (SQLException x) {
-			//ignore exception
-			logger.error("Exception", x);
-		}
-
-		return false;
-	}
-
-	public long getCount() {
-		long size = 0;
-		Cursor c = this.getReadableDatabase().rawQuery("SELECT COUNT(*) FROM `threema_nonce`", null);
-		if (c != null) {
-			if (c.moveToFirst()) {
-				size = c.getLong(0);
-			}
-			c.close();
-		}
-		return size;
-	}
-
-	@NonNull
-	@Override
-	public List<byte[]> getAllHashedNonces() {
-		int nonceCount = (int) getCount();
-		List<byte[]> nonces = new ArrayList<>(nonceCount);
-		addHashedNonceChunk(nonceCount, 0, nonces);
-		return nonces;
-	}
-
-	/**
-	 * Get the hashed nonces of the provided chunk in their byte array representation.
-	 *
-	 * @param chunkSize the number of nonces that is returned
-	 * @param offset    the offset where reading the nonces starts
-	 * @return a list of the hashed nonces in their byte array representation.
-	 */
-	public void addHashedNonceChunk(int chunkSize, int offset, List<byte[]> nonces) {
-		Cursor c = this.getReadableDatabase().rawQuery(
-			"SELECT `nonce` FROM `threema_nonce` LIMIT ? OFFSET ?",
-			new String[]{String.valueOf(chunkSize), String.valueOf(offset)}
-	);
-		if (c != null) {
-			if (c.moveToFirst()) {
-				int columnIndex = c.getColumnIndex("nonce");
-				do {
-					nonces.add(c.getBlob(columnIndex));
-				} while (c.moveToNext());
-			}
-			c.close();
-		}
-	}
-
-	/**
-	 * Insert hashed nonces to the database.
-	 *
-	 * @param hashedNonces the hashed nonces
-	 * @return true if all nonces have been inserted successfully, false otherwise
-	 */
-	public boolean insertHashedNonces(@NonNull String[] hashedNonces) {
-		boolean success = true;
-		SQLiteDatabase database = getWritableDatabase();
-		for (String hashedNonce : hashedNonces) {
-			ContentValues values = new ContentValues();
-			values.put("nonce", Utils.hexStringToByteArray(hashedNonce));
-			try {
-				long row = database.insertOrThrow("threema_nonce", null, values);
-				if (row < 0) {
-					logger.warn("Could not insert a nonce into the nonce database");
-					success = false;
-				}
-			} catch (SQLException e) {
-				logger.error("Could not insert a nonce into the nonce database", e);
-				success = false;
-			}
-		}
-
-		return success;
-	}
-
-	private byte[] hashNonce(byte[] nonce) {
-		// Hash nonce with HMAC-SHA256 using the identity as the key if available.
-		// This serves to make it impossible to correlate the nonce DBs of users to determine whether they have been communicating. */
-		String identity = identityStore.getIdentity();
-		if (identity == null) {
-			return nonce;
-		}
-
-		try {
-			Mac mobileNoMac = Mac.getInstance("HmacSHA256");
-			mobileNoMac.init(new SecretKeySpec(identity.getBytes(), "HmacSHA256"));
-			return mobileNoMac.doFinal(nonce);
-		} catch (NoSuchAlgorithmException | InvalidKeyException e) {
-			throw new RuntimeException(e);
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/storage/DatabaseNonceStore.kt b/app/src/main/java/ch/threema/storage/DatabaseNonceStore.kt
new file mode 100644
index 00000000..a924ddf5
--- /dev/null
+++ b/app/src/main/java/ch/threema/storage/DatabaseNonceStore.kt
@@ -0,0 +1,243 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.storage
+
+import android.content.Context
+import android.database.SQLException
+import ch.threema.base.crypto.HashedNonce
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.crypto.NonceStore
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.toHexString
+import ch.threema.domain.stores.IdentityStoreInterface
+import net.zetetic.database.sqlcipher.SQLiteConnection
+import net.zetetic.database.sqlcipher.SQLiteDatabase
+import net.zetetic.database.sqlcipher.SQLiteDatabaseHook
+import net.zetetic.database.sqlcipher.SQLiteOpenHelper
+import java.security.InvalidKeyException
+import java.security.NoSuchAlgorithmException
+import javax.crypto.Mac
+import javax.crypto.spec.SecretKeySpec
+
+private val logger = LoggingUtil.getThreemaLogger("DatabaseNonceStore")
+
+class DatabaseNonceStore(
+    context: Context,
+    private val identityStore: IdentityStoreInterface,
+    databaseName: String
+) : NonceStore, SQLiteOpenHelper(
+    context,
+    databaseName,
+    "",
+    null,
+    DATABASE_VERSION,
+    0,
+    null,
+    object : SQLiteDatabaseHook {
+        override fun preKey(connection: SQLiteConnection?) {
+            // not used
+        }
+
+        override fun postKey(connection: SQLiteConnection?) {
+            // turn off memory wiping for now due to https://github.com/sqlcipher/android-database-sqlcipher/issues/411
+            connection!!.execute("PRAGMA cipher_memory_security = OFF;", arrayOf(), null)
+        }
+    },
+    false
+) {
+    constructor(
+        context: Context,
+        identityStore: IdentityStoreInterface
+    ) : this(context, identityStore, DATABASE_NAME_V4)
+
+    companion object {
+        const val DATABASE_NAME_V4 = "threema-nonce-blob4.db"
+
+        // Versions:
+        //  1: initial
+        //  2: add nonce scope
+        const val DATABASE_VERSION = 2
+
+        private const val TABLE_NAME_CSP = "nonce_csp"
+        private const val TABLE_NAME_D2D = "nonce_d2d"
+
+        private const val COLUMN_NONCE = "nonce"
+    }
+
+    override fun onCreate(db: SQLiteDatabase?) {
+        db!!.execSQL("CREATE TABLE `$TABLE_NAME_CSP` (" +
+            "`$COLUMN_NONCE` BLOB NOT NULL PRIMARY KEY);")
+
+        db.execSQL("CREATE TABLE `$TABLE_NAME_D2D` (" +
+            "`$COLUMN_NONCE` BLOB NOT NULL PRIMARY KEY);")
+    }
+
+    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
+        logger.info("Upgrade nonce database from {} -> {}", oldVersion, newVersion)
+        if (oldVersion < 2) {
+            migrateToVersion2(db!!)
+        }
+    }
+
+    fun executeNull() {
+        try {
+            readableDatabase.rawQuery("SELECT NULL").close()
+        } catch (e: SQLException) {
+            logger.error("Unable to execute initial query", e)
+        }
+    }
+
+    override fun exists(scope: NonceScope, nonce: Nonce): Boolean {
+        val tableName = scope.getTableName()
+        return readableDatabase.rawQuery(
+            "SELECT COUNT(*) FROM `$tableName` WHERE nonce=? OR nonce=?;",
+            nonce.bytes,
+            nonce.hashNonce().bytes
+        ).use {
+            if (it.moveToFirst()) {
+                it.getInt(0) > 0
+            } else {
+                false
+            }
+        }
+    }
+
+    override fun store(scope: NonceScope, nonce: Nonce): Boolean {
+        val insertNonce = createInsertNonce(scope, writableDatabase)
+        if (logger.isTraceEnabled) {
+            logger.trace("Store nonce {} for scope {}", nonce.bytes.toHexString(), scope)
+        }
+        return insertNonce(nonce.hashNonce())
+    }
+
+    override fun getCount(scope: NonceScope): Long {
+        val tableName = scope.getTableName()
+        return readableDatabase
+            .rawQuery("SELECT COUNT(*) FROM `$tableName`;")
+            .use {
+                if (it.moveToFirst()) {
+                    it.getLong(0)
+                } else {
+                    0
+                }
+            }
+    }
+
+    override fun getAllHashedNonces(scope: NonceScope): List<HashedNonce> {
+        val nonceCount = getCount(scope).toInt()
+        val nonces = ArrayList<HashedNonce>(nonceCount)
+        addHashedNoncesChunk(scope, nonceCount, 0, nonces)
+        return nonces
+    }
+
+    override fun addHashedNoncesChunk(scope: NonceScope, chunkSize: Int, offset: Int, nonces: MutableList<HashedNonce>) {
+        val tableName = scope.getTableName()
+        readableDatabase
+            .rawQuery(
+                "SELECT `$COLUMN_NONCE` FROM `$tableName` LIMIT ? OFFSET ?",
+                chunkSize,
+                offset
+                )
+            .use {
+                while(it.moveToNext()) {
+                    nonces.add(HashedNonce(it.getBlob(0)))
+                }
+            }
+    }
+
+    private fun createInsertNonce(scope: NonceScope, database: SQLiteDatabase): (nonce: HashedNonce) -> Boolean {
+        val tableName = scope.getTableName()
+        val stmt = database.compileStatement("INSERT INTO $tableName VALUES (?)")
+        return { nonce ->
+            try {
+                stmt.bindBlob(1, nonce.bytes)
+                stmt.executeInsert() >= 0
+            } catch (e: SQLException) {
+                logger.warn("Could not insert nonce", e)
+                false
+            } finally {
+                stmt.clearBindings()
+            }
+        }
+    }
+
+    override fun insertHashedNonces(scope: NonceScope, nonces: List<HashedNonce>): Boolean {
+        val database = writableDatabase
+        database.beginTransaction()
+        return try {
+            val insertNonce = createInsertNonce(scope, database)
+            nonces
+                .map {  insertNonce(it) }
+                .all { it }
+                .also {
+                    database.setTransactionSuccessful()
+                }
+        } finally {
+            database.endTransaction()
+        }
+    }
+
+    private fun NonceScope.getTableName(): String {
+        return when(this) {
+            NonceScope.CSP -> TABLE_NAME_CSP
+            NonceScope.D2D -> TABLE_NAME_D2D
+        }
+    }
+
+    /**
+     * Hash nonce with HMAC-SHA256 using the identity as the key if available.
+     * This serves to make it impossible to correlate the nonce DBs of users to
+     * determine whether they have been communicating.
+     */
+    private fun Nonce.hashNonce(): HashedNonce {
+        val identity = identityStore.identity
+        return if (identity == null) {
+            HashedNonce(this.bytes)
+        } else {
+            try {
+                val mac = Mac.getInstance("HmacSHA256")
+                mac.init(SecretKeySpec(identity.encodeToByteArray(), "HmacSHA256"))
+                HashedNonce(mac.doFinal(this.bytes))
+            } catch (e: Exception) {
+                when (e) {
+                    is NoSuchAlgorithmException, is InvalidKeyException -> throw RuntimeException(e)
+                    else -> throw e
+                }
+            }
+        }
+    }
+
+    private fun migrateToVersion2(db: SQLiteDatabase) {
+        logger.info("- Different tables for csp- and d2d-nonces")
+        db.beginTransaction()
+        try {
+            db.execSQL("ALTER TABLE `threema_nonce` RENAME TO `nonce_csp`;")
+            db.execSQL("CREATE TABLE `nonce_d2d` (`nonce` BLOB NOT NULL PRIMARY KEY);")
+            logger.info("- Nonce scope added and data migrated")
+            db.setTransactionSuccessful()
+        } finally {
+            db.endTransaction()
+            logger.info("- Nonce scope added and data migrated")
+        }
+    }
+}
diff --git a/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java b/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java
index df257c4e..2f557e0c 100644
--- a/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java
+++ b/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java
@@ -25,8 +25,6 @@ import android.content.Context;
 import android.database.sqlite.SQLiteException;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-
 import net.zetetic.database.sqlcipher.SQLiteConnection;
 import net.zetetic.database.sqlcipher.SQLiteDatabase;
 import net.zetetic.database.sqlcipher.SQLiteDatabaseHook;
@@ -34,10 +32,15 @@ import net.zetetic.database.sqlcipher.SQLiteOpenHelper;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.app.services.UpdateSystemService;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion10;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion99;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion100;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion101;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion102;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion103;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion104;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion11;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion12;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion13;
@@ -124,10 +127,7 @@ import ch.threema.app.services.systemupdate.SystemUpdateToVersion95;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion96;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion97;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion98;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion100;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion101;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion102;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion103;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion99;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
@@ -148,13 +148,13 @@ import ch.threema.storage.factories.GroupInviteModelFactory;
 import ch.threema.storage.factories.GroupMemberModelFactory;
 import ch.threema.storage.factories.GroupMessageModelFactory;
 import ch.threema.storage.factories.GroupModelFactory;
-import ch.threema.storage.factories.IncomingGroupSyncRequestLogModelFactory;
-import ch.threema.storage.factories.OutgoingGroupSyncRequestLogModelFactory;
 import ch.threema.storage.factories.IdentityBallotModelFactory;
 import ch.threema.storage.factories.IncomingGroupJoinRequestModelFactory;
+import ch.threema.storage.factories.IncomingGroupSyncRequestLogModelFactory;
 import ch.threema.storage.factories.MessageModelFactory;
 import ch.threema.storage.factories.ModelFactory;
 import ch.threema.storage.factories.OutgoingGroupJoinRequestModelFactory;
+import ch.threema.storage.factories.OutgoingGroupSyncRequestLogModelFactory;
 import ch.threema.storage.factories.RejectedGroupMessageFactory;
 import ch.threema.storage.factories.ServerMessageModelFactory;
 import ch.threema.storage.factories.TaskArchiveFactory;
@@ -165,7 +165,7 @@ public class DatabaseServiceNew extends SQLiteOpenHelper {
 
     public static final String DEFAULT_DATABASE_NAME_V4 = "threema4.db";
     public static final String DATABASE_BACKUP_EXT = ".backup";
-    private static final int DATABASE_VERSION = SystemUpdateToVersion103.VERSION;
+    private static final int DATABASE_VERSION = SystemUpdateToVersion104.VERSION;
 
     private final Context context;
     private final UpdateSystemService updateSystemService;
@@ -818,6 +818,9 @@ public class DatabaseServiceNew extends SQLiteOpenHelper {
         if (oldVersion < SystemUpdateToVersion103.VERSION) {
             this.updateSystemService.addUpdate(new SystemUpdateToVersion103(sqLiteDatabase));
         }
+        if (oldVersion < SystemUpdateToVersion104.VERSION) {
+            this.updateSystemService.addUpdate(new SystemUpdateToVersion104(sqLiteDatabase, context));
+        }
     }
 
     public void executeNull() throws SQLiteException {
diff --git a/app/src/main/java/ch/threema/storage/DatabaseUtil.java b/app/src/main/java/ch/threema/storage/DatabaseUtil.java
index ad74d931..c745abd5 100644
--- a/app/src/main/java/ch/threema/storage/DatabaseUtil.java
+++ b/app/src/main/java/ch/threema/storage/DatabaseUtil.java
@@ -27,6 +27,10 @@ import android.database.Cursor;
 import java.util.Date;
 import java.util.List;
 
+import androidx.annotation.NonNull;
+import ch.threema.storage.models.GroupMemberModel;
+import ch.threema.storage.models.GroupModel;
+
 public class DatabaseUtil {
 
 	private DatabaseUtil() { }
@@ -89,4 +93,16 @@ public class DatabaseUtil {
 		}
 		return arguments;
 	}
+
+	/**
+	 * An SQL query that can be used to check whether an identity is part of a group. There is one
+	 * placeholder (?) that should be used for the identity that should be checked. Note that only
+	 * groups are considered where 'deleted' is 0.
+	 */
+	@NonNull
+	public final static String IS_GROUP_MEMBER_QUERY = "SELECT EXISTS(" +
+		"SELECT 1 FROM " + GroupModel.TABLE + " g INNER JOIN " + GroupMemberModel.TABLE + " m" +
+		"  ON m." + GroupMemberModel.COLUMN_GROUP_ID + " = g." + GroupModel.COLUMN_ID + " " +
+		"WHERE m." + GroupMemberModel.COLUMN_IDENTITY + " = ? AND " + GroupModel.COLUMN_DELETED + " = 0" +
+		")";
 }
diff --git a/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java b/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java
index 9f891c38..1fe2cfbe 100644
--- a/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java
+++ b/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java
@@ -25,16 +25,19 @@ import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteException;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
+import java.util.Date;
 import java.util.List;
 
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.storage.CursorHelper;
@@ -127,7 +130,7 @@ public class ContactModelFactory extends ModelFactory {
                     cursorFactory1.getString(ContactModel.COLUMN_FIRST_NAME),
                     cursorFactory1.getString(ContactModel.COLUMN_LAST_NAME))
                 .setPublicNickName(cursorFactory1.getString(ContactModel.COLUMN_PUBLIC_NICK_NAME))
-                .setState(ContactModel.State.valueOf(cursorFactory1.getString(ContactModel.COLUMN_STATE)))
+                .setState(IdentityState.valueOf(cursorFactory1.getString(ContactModel.COLUMN_STATE)))
                 .setAndroidContactLookupKey(cursorFactory1.getString(ContactModel.COLUMN_ANDROID_CONTACT_LOOKUP_KEY))
                 .setIsWork(cursorFactory1.getInt(ContactModel.COLUMN_IS_WORK) == 1)
                 .setIdentityType(
@@ -157,15 +160,15 @@ public class ContactModelFactory extends ModelFactory {
             // Convert state to enum
             switch (cursorFactory1.getString(ContactModel.COLUMN_STATE)) {
                 case "INACTIVE":
-                    c.setState(ContactModel.State.INACTIVE);
+                    c.setState(IdentityState.INACTIVE);
                     break;
                 case "INVALID":
-                    c.setState(ContactModel.State.INVALID);
+                    c.setState(IdentityState.INVALID);
                     break;
                 case "ACTIVE":
                 case "TEMPORARY": // Legacy state, see !276
                 default:
-                    c.setState(ContactModel.State.ACTIVE);
+                    c.setState(IdentityState.ACTIVE);
                     break;
             }
 
@@ -220,7 +223,7 @@ public class ContactModelFactory extends ModelFactory {
         contentValues.put(ContactModel.COLUMN_VERIFICATION_LEVEL, contactModel.verificationLevel.ordinal());
 
         if (contactModel.getState() == null) {
-            contactModel.setState(ContactModel.State.ACTIVE);
+            contactModel.setState(IdentityState.ACTIVE);
         }
         contentValues.put(ContactModel.COLUMN_STATE, contactModel.getState().toString());
         contentValues.put(ContactModel.COLUMN_ANDROID_CONTACT_LOOKUP_KEY, contactModel.getAndroidContactLookupKey());
@@ -265,6 +268,22 @@ public class ContactModelFactory extends ModelFactory {
         return true;
     }
 
+    /**
+     * Updates the last update flag of the given identity.
+     */
+    public void setLastUpdate(@NonNull String identity, @Nullable Date lastUpdate) {
+        Long lastUpdateTime = lastUpdate != null ? lastUpdate.getTime() : null;
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(ContactModel.COLUMN_LAST_UPDATE, lastUpdateTime);
+
+        getWritableDatabase().update(
+            ContactModel.TABLE,
+            contentValues,
+            ContactModel.COLUMN_IDENTITY + " = ?",
+            new String[]{identity}
+        );
+    }
+
     public int delete(ContactModel contactModel) {
         return this.databaseService.getWritableDatabase().delete(this.getTableName(),
             ContactModel.COLUMN_IDENTITY + "=?",
diff --git a/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java b/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java
index c3018c99..4c684c7b 100644
--- a/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java
+++ b/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java
@@ -64,7 +64,11 @@ public class GroupMemberModelFactory extends ModelFactory {
 				null));
 	}
 
-	public long countMembers(int groupId) {
+	/**
+	 * This does not include the user itself. If the user is part of the group, the total number of
+	 * members is the value returned by this method + 1.
+	 */
+	public long countMembersWithoutUser(int groupId) {
 		return DatabaseUtil.count(this.databaseService.getReadableDatabase().rawQuery(
 			"SELECT COUNT(*) FROM " + this.getTableName()
 				+ " WHERE " + GroupMemberModel.COLUMN_GROUP_ID + "=?",
diff --git a/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java b/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java
index 938222d4..08ba2807 100644
--- a/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java
+++ b/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java
@@ -104,18 +104,19 @@ public class GroupModelFactory extends ModelFactory {
 				@Override
 				public boolean next(CursorHelper cursorHelper) {
 					c
-							.setId(cursorHelper.getInt(GroupModel.COLUMN_ID))
-							.setApiGroupId(new GroupId(cursorHelper.getString(GroupModel.COLUMN_API_GROUP_ID)))
-							.setName(cursorHelper.getString(GroupModel.COLUMN_NAME))
-							.setCreatorIdentity(cursorHelper.getString(GroupModel.COLUMN_CREATOR_IDENTITY))
-							.setSynchronizedAt(cursorHelper.getDate(GroupModel.COLUMN_SYNCHRONIZED_AT))
-							.setCreatedAt(cursorHelper.getDateByString(GroupModel.COLUMN_CREATED_AT))
-							.setLastUpdate(cursorHelper.getDate(GroupModel.COLUMN_LAST_UPDATE))
-							.setDeleted(cursorHelper.getBoolean(GroupModel.COLUMN_DELETED))
-							.setArchived(cursorHelper.getBoolean(GroupModel.COLUMN_IS_ARCHIVED))
-							.setGroupDesc(cursorHelper.getString(GroupModel.COLUMN_GROUP_DESC))
-							.setGroupDescTimestamp(cursorHelper.getDateByString(GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP))
-							.setColorIndex(cursorHelper.getInt(GroupModel.COLUMN_COLOR_INDEX))
+						.setId(cursorHelper.getInt(GroupModel.COLUMN_ID))
+						.setApiGroupId(new GroupId(cursorHelper.getString(GroupModel.COLUMN_API_GROUP_ID)))
+						.setName(cursorHelper.getString(GroupModel.COLUMN_NAME))
+						.setCreatorIdentity(cursorHelper.getString(GroupModel.COLUMN_CREATOR_IDENTITY))
+						.setSynchronizedAt(cursorHelper.getDate(GroupModel.COLUMN_SYNCHRONIZED_AT))
+						.setCreatedAt(cursorHelper.getDateByString(GroupModel.COLUMN_CREATED_AT))
+						.setLastUpdate(cursorHelper.getDate(GroupModel.COLUMN_LAST_UPDATE))
+						.setDeleted(cursorHelper.getBoolean(GroupModel.COLUMN_DELETED))
+						.setArchived(cursorHelper.getBoolean(GroupModel.COLUMN_IS_ARCHIVED))
+						.setGroupDesc(cursorHelper.getString(GroupModel.COLUMN_GROUP_DESC))
+						.setGroupDescTimestamp(cursorHelper.getDateByString(GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP))
+						.setColorIndex(cursorHelper.getInt(GroupModel.COLUMN_COLOR_INDEX))
+						.setUserState(GroupModel.UserState.valueOf(cursorHelper.getInt(GroupModel.COLUMN_USER_STATE)))
 					;
 
 					return false;
@@ -173,6 +174,8 @@ public class GroupModelFactory extends ModelFactory {
 		contentValues.put(GroupModel.COLUMN_GROUP_DESC, groupModel.getGroupDesc());
 		contentValues.put(GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP, groupModel.getGroupDescTimestamp() !=null ? CursorHelper.dateAsStringFormat.get().format(groupModel.getGroupDescTimestamp()) : null);
 		contentValues.put(GroupModel.COLUMN_COLOR_INDEX, groupModel.getColorIndex());
+		// In case the user state is not set, we fall back to 'member'.
+		contentValues.put(GroupModel.COLUMN_USER_STATE, groupModel.getUserState() != null ? groupModel.getUserState().value : GroupModel.UserState.MEMBER.value);
 
 		return contentValues;
 	}
@@ -305,7 +308,8 @@ public class GroupModelFactory extends ModelFactory {
 				"`" + GroupModel.COLUMN_IS_ARCHIVED + "` TINYINT DEFAULT 0, " +
 				"`" + GroupModel.COLUMN_GROUP_DESC + "` VARCHAR DEFAULT NULL, " +
 				"`" + GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP + "` VARCHAR DEFAULT NULL, " +
-				"`" + GroupModel.COLUMN_COLOR_INDEX + "` INTEGER DEFAULT 0 NOT NULL" +
+				"`" + GroupModel.COLUMN_COLOR_INDEX + "` INTEGER DEFAULT 0 NOT NULL, " +
+				"`" + GroupModel.COLUMN_USER_STATE + "` INTEGER DEFAULT 0 NOT NULL " +
 				");",
 			"CREATE UNIQUE INDEX `apiGroupIdAndCreator` ON `" + GroupModel.TABLE + "` ( " +
 				"`" + GroupModel.COLUMN_API_GROUP_ID + "`, `" + GroupModel.COLUMN_CREATOR_IDENTITY + "` " +
diff --git a/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java b/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java
index 1cd8154a..55ea7b81 100644
--- a/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java
+++ b/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java
@@ -35,6 +35,7 @@ import ch.threema.app.R;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.QuoteUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode;
 import ch.threema.storage.models.data.DisplayTag;
 import ch.threema.storage.models.data.LocationDataModel;
@@ -346,11 +347,6 @@ public abstract class AbstractMessageModel {
 
     public AbstractMessageModel setModifiedAt(Date modifiedAt) {
         this.modifiedAt = modifiedAt;
-        if (getState() == MessageState.DELIVERED) {
-            this.deliveredAt = modifiedAt;
-        } else if (getState() == MessageState.READ) {
-            this.readAt = modifiedAt;
-        }
         return this;
     }
 
@@ -566,7 +562,7 @@ public abstract class AbstractMessageModel {
         return (FileDataModel) this.dataObject;
     }
 
-    public void setFileData(FileDataModel fileDataModel) {
+    public void setFileDataModel(@NonNull FileDataModel fileDataModel) {
         this.setType(MessageType.FILE);
         this.setBody(fileDataModel.toString());
         this.dataObject = fileDataModel;
@@ -672,9 +668,38 @@ public abstract class AbstractMessageModel {
     }
 
     /**
-     * TODO(ANDR-XXXX): evil code!
+     * This method only makes sense (finds its use) when multi device is active.
+     * The api call to download a blob without multi-device does not require a scope.
+     *
+     * @return The {@code BlobScope} to use when downloading the blob from the mirror server.
+     * If the message if outgoing ({@code isOutbox()}) we use the local scope to download the
+     * blob, as we know we received a reflected message. For every kind of incoming message we
+     * need to use the public scope, as the blob might only be present on the usual blob
+     * server (not mirror)
+     */
+    public BlobScope getBlobScopeForDownload() {
+        return isOutbox()
+            ? BlobScope.Local.INSTANCE
+            : BlobScope.Public.INSTANCE;
+    }
+
+    /**
+     * This method only makes sense (finds its use) when multi device is active.
+     * The api call to mark a blob as done without multi-device does not require a scope.
      *
-     * @param sourceModel
+     * @return The {@code BlobScope} to use when marking the blob as "done" on the blob mirror server.
+     * We only use the public scope here if the message is incoming and its not a group message. If
+     * the message in outgoing, always use local scope (because we got the reflection only). If the
+     * message is incoming but in a group, we use local scope (so that the blob is retained for other group members).
+     */
+    public BlobScope getBlobScopeForMarkAsDone() {
+        return (!this.isOutbox() && !(this instanceof GroupMessageModel))
+            ? BlobScope.Public.INSTANCE
+            : BlobScope.Local.INSTANCE;
+    }
+
+    /**
+     * TODO(ANDR-XXXX): evil code!
      */
     public void copyFrom(AbstractMessageModel sourceModel) {
         //copy all objects
diff --git a/app/src/main/java/ch/threema/storage/models/ContactModel.java b/app/src/main/java/ch/threema/storage/models/ContactModel.java
index a5b4a848..75559ff5 100644
--- a/app/src/main/java/ch/threema/storage/models/ContactModel.java
+++ b/app/src/main/java/ch/threema/storage/models/ContactModel.java
@@ -43,8 +43,11 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 
 import static ch.threema.app.utils.TextUtil.SPACE;
 import static ch.threema.app.utils.TextUtil.TILDE;
@@ -82,36 +85,21 @@ public class ContactModel extends Contact implements ReceiverModel {
 
     public static final byte[] NO_PROFILE_PICTURE_BLOB_ID = new byte[0];
 
-    public enum State {
-        /**
-         * Contact is active.
-         */
-        ACTIVE,
-        /**
-         * Contact is inactive.
-         */
-        INACTIVE,
-        /**
-         * Contact does not have a valid Threema-ID, or the ID was revoked.
-         */
-        INVALID
-    }
-
-    /**
-     * Acquaintance level of the contact.
-     */
-    public enum AcquaintanceLevel {
-        /**
-         * The contact was explicitly added by the user or a 1:1 conversation with the contact
-         * has been initiated.
-         */
-        DIRECT,
-        /**
-         * The contact is part of a group the user is also part of. The contact was not explicitly
-         * added and no 1:1 conversation has been initiated.
-         */
-        GROUP
-    }
+	/**
+	 * Acquaintance level of the contact.
+	 */
+	public enum AcquaintanceLevel {
+		/**
+		 * The contact was explicitly added by the user or a 1:1 conversation with the contact
+		 * has been initiated.
+		 */
+		DIRECT,
+		/**
+		 * The contact is part of a group the user is also part of. The contact was not explicitly
+		 * added and no 1:1 conversation has been initiated.
+		 */
+		GROUP
+	}
 
     /**
      * Policy for sending read receipts or typing indicators
@@ -140,19 +128,20 @@ public class ContactModel extends Contact implements ReceiverModel {
     // Timeout for avatars of linked contacts
     public static long DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY = DateUtils.DAY_IN_MILLIS * 14;
 
-    private String publicNickName;
-    private State state;
-    private String androidContactId;
-    private long featureMask;
-    private int colorIndex = -1;
-    private boolean isWork, isRestored, isArchived;
-    private AcquaintanceLevel acquaintanceLevel = AcquaintanceLevel.DIRECT;
-    private Date localAvatarExpires, dateCreated;
-    private @Nullable Date lastUpdate;
-    private byte[] profilePicBlobID;
-    private @Nullable IdentityType type;
-    private @OverridePolicy int readReceipts, typingIndicators;
-    private int forwardSecurityState; // TODO(ANDR-2452): Remove the forward security state when most of clients support 1.1 anyway
+	private String publicNickName;
+	private IdentityState state;
+	private String androidContactId;
+	private long featureMask;
+	private int colorIndex = -1;
+	private boolean isWork, isRestored, isArchived;
+	private AcquaintanceLevel acquaintanceLevel = AcquaintanceLevel.DIRECT;
+	private Date localAvatarExpires, dateCreated;
+	private @Nullable Date lastUpdate;
+	private byte[] profilePicBlobID;
+	private @Nullable IdentityType type;
+	private @OverridePolicy int readReceipts, typingIndicators;
+	// TODO(ANDR-2452): Remove the forward security state when most of clients support 1.1 anyway
+	private int forwardSecurityState;
     private @Nullable String jobTitle;
     private @Nullable String department;
 
@@ -293,14 +282,14 @@ public class ContactModel extends Contact implements ReceiverModel {
         return this;
     }
 
-    public State getState() {
-        return this.state;
-    }
+	public IdentityState getState() {
+		return this.state;
+	}
 
-    public ContactModel setState(State state) {
-        this.state = state;
-        return this;
-    }
+	public ContactModel setState(IdentityState state) {
+		this.state = state;
+		return this;
+	}
 
     /**
      * Get the expiration date of a local avatar (either a gateway contact avatar,
@@ -340,16 +329,30 @@ public class ContactModel extends Contact implements ReceiverModel {
         return this.isWork;
     }
 
-    /**
-     * Get the BlobId of the latest profile picture that was sent to this contact.
-     *
-     * @return The blobId of the latest profile-picture sent to this contact, {@code null} if no
-     * profile-picture has been sent or {@code new byte[0]} if a delete-profile-picture message has been sent
-     */
-    @Nullable
-    public byte[] getProfilePicBlobID() {
-        return profilePicBlobID;
-    }
+	/**
+	 * Get the work verification level of the contact. If {@link #isWork} is true,
+	 * {@link WorkVerificationLevel#WORK_SUBSCRIPTION_VERIFIED} is returned,
+	 * {@link WorkVerificationLevel#NONE} otherwise.
+	 */
+	@NonNull
+	public WorkVerificationLevel getWorkVerificationLevel() {
+		if (isWork) {
+			return WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED;
+		} else {
+			return WorkVerificationLevel.NONE;
+		}
+	}
+
+	/**
+	 * Get the BlobId of the latest profile picture that was sent to this contact.
+	 *
+	 * @return The blobId of the latest profile-picture sent to this contact, {@code null} if no
+	 *      profile-picture has been sent or {@code new byte[0]} if a delete-profile-picture message has been sent
+	 */
+	@Nullable
+	public byte[] getProfilePicBlobID() {
+		return profilePicBlobID;
+	}
 
     /**
      * Set the {@link AcquaintanceLevel} of the contact.
@@ -500,33 +503,48 @@ public class ContactModel extends Contact implements ReceiverModel {
         return this;
     }
 
-    public Object[] getModifiedValueCandidates() {
-        return new Object[]{
-            this.getPublicKey(),
-            this.getFirstName(),
-            this.getLastName(),
-            this.publicNickName,
-            this.verificationLevel,
-            this.androidContactId,
-            this.colorIndex,
-            this.state,
-            this.featureMask,
-            this.localAvatarExpires,
-            this.isWork,
-            this.profilePicBlobID,
-            this.type,
-            this.dateCreated,
-            this.acquaintanceLevel,
-            this.lastUpdate,
-            this.isRestored,
-            this.isArchived,
-            this.readReceipts,
-            this.typingIndicators,
-            this.forwardSecurityState,
-            this.jobTitle,
-            this.department
-        };
-    }
+	@NonNull
+	public BasicContact toBasicContact() {
+		if (type == null) {
+			logger.warn("Identity type is null. Using normal as default.");
+		}
+		if (state == null) {
+			logger.warn("Identity state is null. Using active as default.");
+		}
+		return BasicContact.javaCreate(
+			getIdentity(),
+			getPublicKey(),
+			featureMask,
+			state != null ? state : IdentityState.ACTIVE,
+			type != null ? type : IdentityType.NORMAL
+		);
+	}
+
+	public Object[] getModifiedValueCandidates() {
+		return new Object[] {
+			this.getPublicKey(),
+			this.getFirstName(),
+			this.getLastName(),
+			this.publicNickName,
+			this.verificationLevel,
+			this.androidContactId,
+			this.colorIndex,
+			this.state,
+			this.featureMask,
+			this.localAvatarExpires,
+			this.isWork,
+			this.profilePicBlobID,
+			this.type,
+			this.dateCreated,
+			this.acquaintanceLevel,
+			this.lastUpdate,
+			this.isRestored,
+			this.isArchived,
+			this.readReceipts,
+			this.typingIndicators,
+			this.forwardSecurityState
+		};
+	}
 
     @Override
     @NonNull
diff --git a/app/src/main/java/ch/threema/storage/models/GroupModel.java b/app/src/main/java/ch/threema/storage/models/GroupModel.java
index 0422c007..9946c544 100644
--- a/app/src/main/java/ch/threema/storage/models/GroupModel.java
+++ b/app/src/main/java/ch/threema/storage/models/GroupModel.java
@@ -59,6 +59,7 @@ public class GroupModel implements ReceiverModel {
 	public static final String COLUMN_GROUP_DESC = "groupDesc";
 	public static final String COLUMN_GROUP_DESC_CHANGED_TIMESTAMP = "changedGroupDescTimestamp";
 	public static final String COLUMN_COLOR_INDEX = "colorIndex";
+	public static final String COLUMN_USER_STATE = "userState";
 
 	private String groupDesc;
 	private Date changedGroupDescTimestamp;
@@ -73,6 +74,37 @@ public class GroupModel implements ReceiverModel {
 	private boolean deleted;
 	private boolean isArchived;
 	private int colorIndex = -1;
+	private @Nullable UserState userState;
+
+	/**
+	 * The user's state within the group.
+	 */
+	public enum UserState {
+
+		MEMBER(0),
+
+		KICKED(1),
+
+		LEFT(2);
+
+		public final int value;
+
+		UserState(int value) {
+			this.value = value;
+		}
+
+		@Nullable
+		public static UserState valueOf(int value) {
+			for (UserState userState : values()) {
+				if (userState.value == value) {
+					return userState;
+				}
+			}
+
+			return null;
+		}
+
+	}
 
 	// dummy class
 	@Nullable
@@ -222,6 +254,17 @@ public class GroupModel implements ReceiverModel {
 		return ColorUtil.getInstance().getIDColorDark(colorIndex);
 	}
 
+	@NonNull
+	public GroupModel setUserState(@Nullable UserState userState) {
+		this.userState = userState;
+		return this;
+	}
+
+	@Nullable
+	public UserState getUserState() {
+		return userState;
+	}
+
 	private void computeColorIndex() {
 		byte[] groupCreatorIdentity = creatorIdentity.getBytes(StandardCharsets.UTF_8);
 		byte[] apiGroupIdBin = apiGroupId.getGroupId();
diff --git a/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java b/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java
index a5367d1c..41ae2621 100644
--- a/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java
+++ b/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java
@@ -33,6 +33,7 @@ import java.io.StringWriter;
 import java.util.Iterator;
 import java.util.Map;
 
+import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.JsonUtil;
 import ch.threema.app.utils.ListReader;
 import ch.threema.app.utils.MimeUtil;
@@ -43,340 +44,364 @@ import ch.threema.base.utils.Utils;
 import ch.threema.domain.protocol.csp.messages.file.FileData;
 
 public class FileDataModel implements MediaMessageDataInterface {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("FileDataModel");
-
-	public static final String METADATA_KEY_DURATION = "d";
-	public static final String METADATA_KEY_WIDTH = "w";
-	public static final String METADATA_KEY_HEIGHT = "h";
-	public static final String METADATA_KEY_ANIMATED = "a";
-
-	private byte[] fileBlobId;
-	private byte[] encryptionKey;
-	private String mimeType;
-	private String thumbnailMimeType;
-	private long fileSize;
-	private @Nullable String fileName;
-	private @FileData.RenderingType int renderingType;
-	private boolean isDownloaded;
-	private String caption;
-	private Map<String, Object> metaData;
-
-	// incoming
-	public FileDataModel(byte[] fileBlobId,
-	                     byte[] encryptionKey,
-	                     String mimeType,
-	                     String thumbnailMimeType,
-	                     long fileSize,
-	                     @Nullable String fileName,
-	                     @FileData.RenderingType int renderingType,
-	                     String caption,
-	                     boolean isDownloaded,
-	                     Map<String, Object> metaData) {
-		this.fileBlobId = fileBlobId;
-		this.encryptionKey = encryptionKey;
-		this.mimeType = mimeType;
-		this.thumbnailMimeType = thumbnailMimeType;
-		this.fileSize = fileSize;
-		this.fileName = fileName;
-		this.renderingType = renderingType;
-		this.caption = caption;
-		this.isDownloaded = isDownloaded;
-		this.metaData = metaData;
-	}
-
-	// outgoing
-	public FileDataModel(String mimeType,
-	                     String thumbnailMimeType,
-	                     long fileSize,
-	                     @Nullable String fileName,
-	                     @FileData.RenderingType int renderingType,
-	                     String caption,
-	                     boolean isDownloaded,
-	                     Map<String, Object> metaData) {
-		this.mimeType = mimeType;
-		this.thumbnailMimeType = thumbnailMimeType;
-		this.fileSize = fileSize;
-		this.fileName = fileName;
-		this.renderingType = renderingType;
-		this.caption = caption;
-		this.isDownloaded = isDownloaded;
-		this.metaData = metaData;
-	}
-
-	private FileDataModel() {
-	}
-
-	public void setCaption(String caption) {
-		this.caption = caption;
-	}
-
-	public void setFileName(@Nullable String fileName) {
-		this.fileName = fileName;
-	}
-
-	public void setRenderingType(@FileData.RenderingType int renderingType) {
-		this.renderingType = renderingType;
-	}
-
-	public void setBlobId(byte[] blobId) {
-		this.fileBlobId = blobId;
-	}
-
-	@Override
-	public byte[] getBlobId() {
-		return this.fileBlobId;
-	}
-
-	public void setEncryptionKey(byte[] encryptionKey) {
-		this.encryptionKey = encryptionKey;
-	}
-
-	@Override
-	public byte[] getEncryptionKey() {
-		return this.encryptionKey;
-	}
-
-	@Override
-	public boolean isDownloaded() {
-		return this.isDownloaded;
-	}
-
-	@Override
-	public void isDownloaded(boolean isDownloaded) {
-		this.isDownloaded = isDownloaded;
-	}
-
-	@Override
-	public byte[] getNonce() {
-		return new byte[0];
-	}
-
-	@NonNull
-	public String getMimeType() {
-		if (this.mimeType == null) {
-			return MimeUtil.MIME_TYPE_DEFAULT;
-		}
-		return this.mimeType;
-	}
-
-	public void setMimeType(String mimeType) {
-		this.mimeType = mimeType;
-	}
-
-	@Nullable
-	public String getThumbnailMimeType() {
-		return this.thumbnailMimeType;
-	}
-
-	public void setThumbnailMimeType(String thumbnailMimeType) {
-		this.thumbnailMimeType = thumbnailMimeType;
-	}
-
-	public void setFileSize(long fileSize) {
-		this.fileSize = fileSize;
-	}
-
-	public long getFileSize() {
-		return this.fileSize;
-	}
-
-	public @Nullable String getFileName() {
-		return this.fileName;
-	}
-
-	public @FileData.RenderingType int getRenderingType() {
-		return this.renderingType;
-	}
-
-	public String getCaption() {
-		return this.caption;
-	}
-
-	public Map<String, Object> getMetaData() {
-		return this.metaData;
-	}
-
-	public void setMetaData(Map<String, Object> metaData) {
-		this.metaData = metaData;
-	}
-
-	@Nullable
-	public Integer getMetaDataInt(String metaDataKey) {
-		return this.metaData != null
-			&& this.metaData.containsKey(metaDataKey)
-			&& this.metaData.get(metaDataKey) instanceof Number ?
-			(Integer) this.metaData.get(metaDataKey) : null;
-	}
-
-	@Nullable
-	public String getMetaDataString(String metaDataKey) {
-		return this.metaData != null
-			&& this.metaData.containsKey(metaDataKey)
-			&& this.metaData.get(metaDataKey) instanceof String ?
-			(String) this.metaData.get(metaDataKey) : null;
-	}
-
-	@Nullable
-	public Boolean getMetaDataBool(String metaDataKey) {
-		return this.metaData != null
-			&& this.metaData.containsKey(metaDataKey)
-			&& this.metaData.get(metaDataKey) instanceof Boolean ?
-			(Boolean) this.metaData.get(metaDataKey) : null;
-	}
-
-	@Nullable
-	public Float getMetaDataFloat(String metaDataKey) {
-		if (this.metaData != null && this.metaData.containsKey(metaDataKey)) {
-
-			Object value = this.metaData.get(metaDataKey);
-			if (value instanceof Number) {
-				if (value instanceof Double) {
-					return ((Double) value).floatValue();
-				} else if (value instanceof Float) {
-					return (Float) value;
-				} else if (value instanceof Integer) {
-					return ((Integer) value).floatValue();
-				} else {
-					return 0F;
-				}
-			}
-		}
-		return null;
-	}
-
-	/**
-	 * Return a formatted string representing the duration as provided by the respective metadata field
-	 * in the format of hours:minutes:seconds
-	 * @return Formatted duration string or 00:00 in case of error
-	 */
-	public @NonNull String getDurationString() {
-		return StringConversionUtil.secondsToString(getDurationSeconds(), false);
-	}
-
-	/**
-	 * Return the duration in SECONDS as set in the metadata field.
-	 */
-	public long getDurationSeconds() {
-		try {
-			Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
-			if (durationF != null) {
-				return Math.round(durationF);
-			}
-		} catch (Exception ignored) {}
-		return 0L;
-	}
-
-	/**
-	 * Return the duration in MILLISECONDS as set in the metadata field.
-	 *
-	 * Note: Floats are converted to long integers. No rounding.
-	 */
-	public long getDurationMs() {
-		try {
-			Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
-			if (durationF != null) {
-				durationF *= 1000F;
-				return durationF.longValue();
-			}
-		} catch (Exception ignored) {}
-		return 0L;
-	}
-
-	private void fromString(String s) {
-		if (TestUtil.isEmptyOrNull(s)) {
-			return;
-		}
-
-		try {
-			ListReader reader  = new ListReader(JsonUtil.convertArray(s));
-			this.fileBlobId = reader.nextStringAsByteArray();
-			this.encryptionKey = reader.nextStringAsByteArray();
-			this.mimeType = reader.nextString();
-			this.fileSize = reader.nextInteger();
-			this.fileName = reader.nextString();
-			try {
-				Integer typeId = reader.nextInteger();
-				if (typeId != null) {
-					this.renderingType = typeId;
-				}
-			} catch (ClassCastException ignore) {
-				// ignore very old filedatamodel without rendering type
-			}
-			this.isDownloaded = reader.nextBool();
-			this.caption = reader.nextString();
-			this.thumbnailMimeType = reader.nextString();
-			this.metaData = reader.nextMap();
-		} catch (Exception e) {
-			// Ignore error, just log
-			logger.error("Extract file data model", e);
-		}
-	}
-
-	@Override
-	public String toString() {
-		StringWriter sw = new StringWriter();
-		JsonWriter j = new JsonWriter(sw);
-
-		try {
-			j.beginArray();
-			j
-					.value(Utils.byteArrayToHexString(this.getBlobId()))
-					.value(Utils.byteArrayToHexString(this.getEncryptionKey()))
-					.value(this.mimeType)
-					.value(this.fileSize)
-					.value(this.fileName)
-					.value(this.renderingType)
-					.value(this.isDownloaded)
-					.value(this.caption)
-					.value(this.thumbnailMimeType);
-
-			// Always write the meta data object
-			JsonWriter metaDataObject = j.beginObject();
-			if (this.metaData != null) {
-				Iterator<String> keys = this.metaData.keySet().iterator();
-
-				while (keys.hasNext()) {
-					String key = keys.next();
-					Object value = this.metaData.get(key);
-
-					metaDataObject.name(key);
-
-					try {
-						if (value instanceof Integer) {
-							metaDataObject.value((Integer) value);
-						} else if (value instanceof Float) {
-							metaDataObject.value((Float) value);
-						} else if (value instanceof Double) {
-							metaDataObject.value((Double) value);
-						} else if (value instanceof Boolean) {
-							metaDataObject.value((Boolean) value);
-						} else if (value == null) {
-							metaDataObject.nullValue();
-						} else {
-							metaDataObject.value(value.toString());
-						}
-					}
-					catch (IOException x) {
-						logger.error("Failed to write meta data", x);
-						// Write a NULL
-						metaDataObject.nullValue();
-					}
-				}
-			}
-			j.endObject();
-			j.endArray();
-		}
-		catch (Exception x) {
-			logger.error("Exception", x);
-			return null;
-		}
-
-		return sw.toString();
-	}
-
-	public static FileDataModel create(@NonNull String s) {
-		FileDataModel m = new FileDataModel();
-		m.fromString(s);
-		return m;
-	}
+    private static final Logger logger = LoggingUtil.getThreemaLogger("FileDataModel");
+
+    public static final String METADATA_KEY_DURATION = "d";
+    public static final String METADATA_KEY_WIDTH = "w";
+    public static final String METADATA_KEY_HEIGHT = "h";
+    public static final String METADATA_KEY_ANIMATED = "a";
+
+    private byte[] fileBlobId;
+    private byte[] encryptionKey;
+    private String mimeType;
+    private String thumbnailMimeType;
+    private long fileSize;
+    private @Nullable String fileName;
+    private @FileData.RenderingType int renderingType;
+    private boolean isDownloaded;
+    private String caption;
+    private Map<String, Object> metaData;
+
+    /**
+     * @return A new instance of {@code FileDataModel} with the field {@code isDownloaded} set to {@code false} (as its an incoming message file data).
+     */
+    @NonNull
+    public static FileDataModel fromIncomingFileData(@NonNull FileData fileData) {
+        return new FileDataModel(
+            /* fileBlobId = */ fileData.getFileBlobId(),
+            /* encryptionKey = */ fileData.getEncryptionKey(),
+            /* mimeType = */ fileData.getMimeType(),
+            /* thumbnailMimeType = */ fileData.getThumbnailMimeType(),
+            /* fileSize = */ fileData.getFileSize(),
+            /* fileName = */ FileUtil.sanitizeFileName(fileData.getFileName()),
+            /* renderingType = */ fileData.getRenderingType(),
+            /* caption = */ fileData.getCaption(),
+            /* isDownloaded = */ false,
+            /* metaData = */ fileData.getMetaData()
+        );
+    }
+
+    // incoming
+    public FileDataModel(
+        byte[] fileBlobId,
+        byte[] encryptionKey,
+        String mimeType,
+        String thumbnailMimeType,
+        long fileSize,
+        @Nullable String fileName,
+        @FileData.RenderingType int renderingType,
+        String caption,
+        boolean isDownloaded,
+        Map<String, Object> metaData
+    ) {
+        this.fileBlobId = fileBlobId;
+        this.encryptionKey = encryptionKey;
+        this.mimeType = mimeType;
+        this.thumbnailMimeType = thumbnailMimeType;
+        this.fileSize = fileSize;
+        this.fileName = fileName;
+        this.renderingType = renderingType;
+        this.caption = caption;
+        this.isDownloaded = isDownloaded;
+        this.metaData = metaData;
+    }
+
+    // outgoing
+    public FileDataModel(
+        String mimeType,
+        String thumbnailMimeType,
+        long fileSize,
+        @Nullable String fileName,
+        @FileData.RenderingType int renderingType,
+        String caption,
+        boolean isDownloaded,
+        Map<String, Object> metaData
+    ) {
+        this.mimeType = mimeType;
+        this.thumbnailMimeType = thumbnailMimeType;
+        this.fileSize = fileSize;
+        this.fileName = fileName;
+        this.renderingType = renderingType;
+        this.caption = caption;
+        this.isDownloaded = isDownloaded;
+        this.metaData = metaData;
+    }
+
+    private FileDataModel() {
+    }
+
+    public void setCaption(String caption) {
+        this.caption = caption;
+    }
+
+    public void setFileName(@Nullable String fileName) {
+        this.fileName = fileName;
+    }
+
+    public void setRenderingType(@FileData.RenderingType int renderingType) {
+        this.renderingType = renderingType;
+    }
+
+    public void setBlobId(byte[] blobId) {
+        this.fileBlobId = blobId;
+    }
+
+    @Override
+    public byte[] getBlobId() {
+        return this.fileBlobId;
+    }
+
+    public void setEncryptionKey(byte[] encryptionKey) {
+        this.encryptionKey = encryptionKey;
+    }
+
+    @Override
+    public byte[] getEncryptionKey() {
+        return this.encryptionKey;
+    }
+
+    @Override
+    public boolean isDownloaded() {
+        return this.isDownloaded;
+    }
+
+    @Override
+    public void isDownloaded(boolean isDownloaded) {
+        this.isDownloaded = isDownloaded;
+    }
+
+    @Override
+    public byte[] getNonce() {
+        return new byte[0];
+    }
+
+    @NonNull
+    public String getMimeType() {
+        if (this.mimeType == null) {
+            return MimeUtil.MIME_TYPE_DEFAULT;
+        }
+        return this.mimeType;
+    }
+
+    public void setMimeType(String mimeType) {
+        this.mimeType = mimeType;
+    }
+
+    @Nullable
+    public String getThumbnailMimeType() {
+        return this.thumbnailMimeType;
+    }
+
+    public void setThumbnailMimeType(String thumbnailMimeType) {
+        this.thumbnailMimeType = thumbnailMimeType;
+    }
+
+    public void setFileSize(long fileSize) {
+        this.fileSize = fileSize;
+    }
+
+    public long getFileSize() {
+        return this.fileSize;
+    }
+
+    public @Nullable String getFileName() {
+        return this.fileName;
+    }
+
+    public @FileData.RenderingType int getRenderingType() {
+        return this.renderingType;
+    }
+
+    public String getCaption() {
+        return this.caption;
+    }
+
+    public Map<String, Object> getMetaData() {
+        return this.metaData;
+    }
+
+    public void setMetaData(Map<String, Object> metaData) {
+        this.metaData = metaData;
+    }
+
+    @Nullable
+    public Integer getMetaDataInt(String metaDataKey) {
+        return this.metaData != null
+            && this.metaData.containsKey(metaDataKey)
+            && this.metaData.get(metaDataKey) instanceof Number ?
+            (Integer) this.metaData.get(metaDataKey) : null;
+    }
+
+    @Nullable
+    public String getMetaDataString(String metaDataKey) {
+        return this.metaData != null
+            && this.metaData.containsKey(metaDataKey)
+            && this.metaData.get(metaDataKey) instanceof String ?
+            (String) this.metaData.get(metaDataKey) : null;
+    }
+
+    @Nullable
+    public Boolean getMetaDataBool(String metaDataKey) {
+        return this.metaData != null
+            && this.metaData.containsKey(metaDataKey)
+            && this.metaData.get(metaDataKey) instanceof Boolean ?
+            (Boolean) this.metaData.get(metaDataKey) : null;
+    }
+
+    @Nullable
+    public Float getMetaDataFloat(String metaDataKey) {
+        if (this.metaData != null && this.metaData.containsKey(metaDataKey)) {
+
+            Object value = this.metaData.get(metaDataKey);
+            if (value instanceof Number) {
+                if (value instanceof Double) {
+                    return ((Double) value).floatValue();
+                } else if (value instanceof Float) {
+                    return (Float) value;
+                } else if (value instanceof Integer) {
+                    return ((Integer) value).floatValue();
+                } else {
+                    return 0F;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Return a formatted string representing the duration as provided by the respective metadata field
+     * in the format of hours:minutes:seconds
+     *
+     * @return Formatted duration string or 00:00 in case of error
+     */
+    public @NonNull String getDurationString() {
+        return StringConversionUtil.secondsToString(getDurationSeconds(), false);
+    }
+
+    /**
+     * Return the duration in SECONDS as set in the metadata field.
+     */
+    public long getDurationSeconds() {
+        try {
+            Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
+            if (durationF != null) {
+                return Math.round(durationF);
+            }
+        } catch (Exception ignored) {
+        }
+        return 0L;
+    }
+
+    /**
+     * Return the duration in MILLISECONDS as set in the metadata field.
+     * <p>
+     * Note: Floats are converted to long integers. No rounding.
+     */
+    public long getDurationMs() {
+        try {
+            Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
+            if (durationF != null) {
+                durationF *= 1000F;
+                return durationF.longValue();
+            }
+        } catch (Exception ignored) {
+        }
+        return 0L;
+    }
+
+    private void fromString(String s) {
+        if (TestUtil.isEmptyOrNull(s)) {
+            return;
+        }
+
+        try {
+            ListReader reader = new ListReader(JsonUtil.convertArray(s));
+            this.fileBlobId = reader.nextStringAsByteArray();
+            this.encryptionKey = reader.nextStringAsByteArray();
+            this.mimeType = reader.nextString();
+            this.fileSize = reader.nextInteger();
+            this.fileName = reader.nextString();
+            try {
+                Integer typeId = reader.nextInteger();
+                if (typeId != null) {
+                    this.renderingType = typeId;
+                }
+            } catch (ClassCastException ignore) {
+                // ignore very old filedatamodel without rendering type
+            }
+            this.isDownloaded = reader.nextBool();
+            this.caption = reader.nextString();
+            this.thumbnailMimeType = reader.nextString();
+            this.metaData = reader.nextMap();
+        } catch (Exception e) {
+            // Ignore error, just log
+            logger.error("Extract file data model", e);
+        }
+    }
+
+    @Override
+    public String toString() {
+        StringWriter sw = new StringWriter();
+        JsonWriter j = new JsonWriter(sw);
+
+        try {
+            j.beginArray();
+            j
+                .value(Utils.byteArrayToHexString(this.getBlobId()))
+                .value(Utils.byteArrayToHexString(this.getEncryptionKey()))
+                .value(this.mimeType)
+                .value(this.fileSize)
+                .value(this.fileName)
+                .value(this.renderingType)
+                .value(this.isDownloaded)
+                .value(this.caption)
+                .value(this.thumbnailMimeType);
+
+            // Always write the meta data object
+            JsonWriter metaDataObject = j.beginObject();
+            if (this.metaData != null) {
+                Iterator<String> keys = this.metaData.keySet().iterator();
+
+                while (keys.hasNext()) {
+                    String key = keys.next();
+                    Object value = this.metaData.get(key);
+
+                    metaDataObject.name(key);
+
+                    try {
+                        if (value instanceof Integer) {
+                            metaDataObject.value((Integer) value);
+                        } else if (value instanceof Float) {
+                            metaDataObject.value((Float) value);
+                        } else if (value instanceof Double) {
+                            metaDataObject.value((Double) value);
+                        } else if (value instanceof Boolean) {
+                            metaDataObject.value((Boolean) value);
+                        } else if (value == null) {
+                            metaDataObject.nullValue();
+                        } else {
+                            metaDataObject.value(value.toString());
+                        }
+                    } catch (IOException x) {
+                        logger.error("Failed to write meta data", x);
+                        // Write a NULL
+                        metaDataObject.nullValue();
+                    }
+                }
+            }
+            j.endObject();
+            j.endArray();
+        } catch (Exception x) {
+            logger.error("Exception", x);
+            return null;
+        }
+
+        return sw.toString();
+    }
+
+    public static FileDataModel create(@NonNull String s) {
+        FileDataModel m = new FileDataModel();
+        m.fromString(s);
+        return m;
+    }
 }
diff --git a/app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java b/app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java
index ad0547f8..b7134584 100644
--- a/app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java
+++ b/app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java
@@ -43,6 +43,7 @@ import java.util.Locale;
 import java.util.TimeZone;
 
 import ch.threema.app.BuildConfig;
+import ch.threema.app.managers.CoreServiceManager;
 import ch.threema.app.services.ApiService;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeadlineListService;
@@ -57,6 +58,9 @@ import ch.threema.app.stores.IdentityStore;
 import ch.threema.app.stores.PreferenceStoreInterface;
 import ch.threema.base.utils.JSONUtil;
 import ch.threema.base.utils.Utils;
+import ch.threema.data.ModelTypeCache;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.data.storage.DatabaseBackend;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.protocol.ServerAddressProvider;
 import ch.threema.domain.protocol.api.APIConnector;
@@ -68,47 +72,53 @@ import ch.threema.storage.models.GroupModel;
 import static ch.threema.testhelpers.TestHelpersKt.nonSecureRandomArray;
 import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.doCallRealMethod;
+import static org.mockito.Mockito.mock;
 import static org.powermock.api.mockito.PowerMockito.when;
 
 @RunWith(PowerMockRunner.class)
 @PowerMockIgnore("javax.crypto.*")
 public class ThreemaSafeServiceTest {
-    @Mock
-    private Context contextMock;
-    @Mock
-    private PreferenceService preferenceServiceMock;
-    @Mock
-    private UserService userServiceMock;
-    @Mock
-    private ContactService contactServiceMock;
-    @Mock
-    private GroupService groupServiceMock;
-    @Mock
-    private DistributionListService distributionListServiceMock;
-    @Mock
-    private LocaleService localeServiceMock;
-    @Mock
-    private FileService fileServiceMock;
-    @Mock
-    private DatabaseServiceNew databaseServiceNewMock;
-    @Mock
-    private IdentityStore identityStoreMock;
-    @Mock
-    private ApiService apiService;
-    @Mock
-    private APIConnector apiConnectorMock;
-    @Mock
-    private IdListService profilePicRecipientsServiceMock;
-    @Mock
-    private IdListService blockedContactsServiceMock;
-    @Mock
-    private IdListService excludedSyncIdentitiesServiceMock;
-    @Mock
-    private DeadlineListService hiddenContactsListMock;
-    @Mock
-    private ServerAddressProvider serverAddressProviderMock;
-    @Mock
-    private PreferenceStoreInterface preferenceStoreMock;
+	@Mock
+	private	Context contextMock;
+	@Mock
+	private	PreferenceService preferenceServiceMock;
+	@Mock
+	private	UserService userServiceMock;
+	@Mock
+	private	ContactService contactServiceMock;
+	@Mock
+	private GroupService groupServiceMock;
+	@Mock
+	private DistributionListService distributionListServiceMock;
+	@Mock
+	private	LocaleService localeServiceMock;
+	@Mock
+	private	FileService fileServiceMock;
+	@Mock
+	private	DatabaseServiceNew databaseServiceNewMock;
+	@Mock
+	private	IdentityStore identityStoreMock;
+	@Mock
+	private ApiService apiService;
+	@Mock
+	private	APIConnector apiConnectorMock;
+	@Mock
+	private IdListService profilePicRecipientsServiceMock;
+	@Mock
+	private IdListService blockedContactsServiceMock;
+	@Mock
+	private IdListService excludedSyncIdentitiesServiceMock;
+	@Mock
+	private DeadlineListService hiddenContactsListMock;
+	@Mock
+	private ServerAddressProvider serverAddressProviderMock;
+	@Mock
+	private PreferenceStoreInterface preferenceStoreMock;
+	private final DatabaseBackend databaseBackendMock = mock(DatabaseBackend.class);
+	private final CoreServiceManager coreServiceManagerMock = mock(CoreServiceManager.class);
+	private final ContactModelRepository contactModelRepository = new ContactModelRepository(
+		new ModelTypeCache<>(), databaseBackendMock, coreServiceManagerMock
+	);
 
     // Test vector: Password "shootdeathstar" and salt "ECHOECHO" should result in this master key
     private static final String MASTER_KEY_HEX = "066384d3695fbbd9f31a7d533900fd0cd8d1373beb6a28678522d2a49980c9c351c3d8d752fb6e1fd3199ead7f0895d6e3893ff691f2a5ee1976ed0897fc2f66";
@@ -124,16 +134,17 @@ public class ThreemaSafeServiceTest {
     private Date testDate1, testDate2;
     private long testDate1Timestamp, testDate2Timestamp;
 
-    private ThreemaSafeServiceImpl getServiceImpl() {
-        return new ThreemaSafeServiceImpl(
-            contextMock, preferenceServiceMock, userServiceMock,
-            contactServiceMock, groupServiceMock, distributionListServiceMock,
-            localeServiceMock, fileServiceMock,
-            blockedContactsServiceMock, excludedSyncIdentitiesServiceMock, profilePicRecipientsServiceMock,
-            databaseServiceNewMock, identityStoreMock, apiService, apiConnectorMock,
-            hiddenContactsListMock, serverAddressProviderMock, preferenceStoreMock
-        );
-    }
+	private ThreemaSafeServiceImpl getServiceImpl() {
+		return new ThreemaSafeServiceImpl(
+			contextMock, preferenceServiceMock, userServiceMock,
+			contactServiceMock, groupServiceMock, distributionListServiceMock,
+			localeServiceMock, fileServiceMock,
+			blockedContactsServiceMock, excludedSyncIdentitiesServiceMock, profilePicRecipientsServiceMock,
+			databaseServiceNewMock, identityStoreMock, apiService, apiConnectorMock,
+			hiddenContactsListMock, serverAddressProviderMock, preferenceStoreMock,
+			contactModelRepository
+		);
+	}
 
     private ThreemaSafeService getService() {
         return getServiceImpl();
diff --git a/app/src/test/java/ch/threema/app/utils/BackupUtilsTest.kt b/app/src/test/java/ch/threema/app/utils/BackupUtilsTest.kt
new file mode 100644
index 00000000..89f74aff
--- /dev/null
+++ b/app/src/test/java/ch/threema/app/utils/BackupUtilsTest.kt
@@ -0,0 +1,56 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.utils
+
+import org.junit.Test
+import kotlin.test.assertEquals
+
+class BackupUtilsTest {
+    @Test
+    fun testCalcRemainingNoncesProgress() {
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 50, 0))
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 50, 50))
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 50, 1000))
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 50, 1100))
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 50, 2100))
+
+        assertEquals(1, BackupUtils.calcRemainingNoncesProgress(1000, 50, 1))
+        assertEquals(49, BackupUtils.calcRemainingNoncesProgress(1000, 50, 49))
+        assertEquals(1, BackupUtils.calcRemainingNoncesProgress(1000, 50, 1001))
+        assertEquals(23, BackupUtils.calcRemainingNoncesProgress(1000, 50, 11723))
+
+        // when noncesPerChunk is not a multiple of noncesPerStep
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 30, 0))
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 30, 30))
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 30, 210))
+        assertEquals(0, BackupUtils.calcRemainingNoncesProgress(1000, 30, 990))
+
+        assertEquals(1, BackupUtils.calcRemainingNoncesProgress(1000, 30, 1))
+        assertEquals(1, BackupUtils.calcRemainingNoncesProgress(1000, 30, 211))
+        assertEquals(8, BackupUtils.calcRemainingNoncesProgress(1000, 30, 728))
+        assertEquals(3, BackupUtils.calcRemainingNoncesProgress(1000, 30, 993))
+
+        assertEquals(10, BackupUtils.calcRemainingNoncesProgress(1000, 30, 1000))
+        assertEquals(35, BackupUtils.calcRemainingNoncesProgress(1000, 30, 1025))
+        assertEquals(37, BackupUtils.calcRemainingNoncesProgress(1000, 30, 3157))
+    }
+}
diff --git a/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java b/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java
index 7253787d..117bd557 100644
--- a/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java
+++ b/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java
@@ -87,8 +87,8 @@ public class ContactUtilTest {
 
 		// Preferences disabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(false);
-		// No contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(false);
+		// No contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(false);
 
 		// Normal contact, not linked
 		Assert.assertTrue(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
@@ -103,8 +103,8 @@ public class ContactUtilTest {
 
 		// Preferences disabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(false);
-		// Contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(true);
+		// Contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(true);
 
 		// Normal contact, not linked
 		Assert.assertTrue(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
@@ -119,8 +119,8 @@ public class ContactUtilTest {
 
 		// Preferences enabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(true);
-		// No contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(false);
+		// No contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(false);
 
 		// Normal contact, not linked
 		Assert.assertTrue(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
@@ -135,8 +135,8 @@ public class ContactUtilTest {
 
 		// Preferences enabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(true);
-		// Contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(true);
+		// Contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(true);
 
 		// Normal contact, not linked
 		Assert.assertFalse(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
diff --git a/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java b/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java
index 86192865..a0af1608 100644
--- a/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java
+++ b/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java
@@ -75,7 +75,7 @@ public class MessageUtilTest  {
 	private GroupMessageModel groupMessageModelInbox;
 	private GroupMessageModel groupMessageModelOutbox;
 
-	private ServiceManager serviceManagerMock = mock(ServiceManager.class);
+	private final ServiceManager serviceManagerMock = mock(ServiceManager.class);
 
 	private DistributionListMessageModel distributionListMessageModelOutbox;
 
@@ -591,7 +591,7 @@ public class MessageUtilTest  {
 		when(distributionListService.getMembers(any())).thenReturn(contacts);
 
 		ContactService contactService = mock(ContactService.class);
-		when(contactService.createReceiver(any())).thenAnswer(invocation -> {
+		when(contactService.createReceiver((ContactModel) any())).thenAnswer(invocation -> {
 			ContactModel contactModel = invocation.getArgument(0, ContactModel.class);
 			return new ContactMessageReceiver(contactModel, null, serviceManagerMock, null, null, null);
 		});
diff --git a/app/src/test/java/ch/threema/app/utils/StreamUtilTest.kt b/app/src/test/java/ch/threema/app/utils/StreamUtilTest.kt
new file mode 100644
index 00000000..406ef11e
--- /dev/null
+++ b/app/src/test/java/ch/threema/app/utils/StreamUtilTest.kt
@@ -0,0 +1,91 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.utils
+
+import org.junit.Test
+import java.io.ByteArrayInputStream
+import java.io.InputStream
+import kotlin.test.assertFalse
+import kotlin.test.assertTrue
+
+class StreamUtilTest {
+
+    @Test
+    fun testEqual() {
+        val bytes = byteArrayOf(0, 1, 2, 3)
+        val inputStream = ByteArrayInputStream(bytes)
+        assertTrue(inputStream.contentEquals(bytes))
+    }
+
+    @Test
+    fun testDifferentLength() {
+        val bytes = byteArrayOf(0, 1, 2, 3)
+        val inputStream = ByteArrayInputStream(bytes)
+
+        // Assert false when the provided byte array is longer
+        assertFalse(inputStream.contentEquals(bytes + 11))
+
+        // Assert false when the provided byte array is shorter
+        assertFalse(inputStream.contentEquals(bytes.copyOf(bytes.size - 1)))
+    }
+
+    @Test
+    fun testDifferentContent() {
+        val inputBytes = byteArrayOf(0, 1, 2, 3)
+        val inputStream = ByteArrayInputStream(inputBytes)
+
+        assertFalse(inputStream.contentEquals(byteArrayOf(0, 1, 2, 42)))
+        assertFalse(inputStream.contentEquals(byteArrayOf(42, 1, 2, 3)))
+        assertFalse(inputStream.contentEquals(byteArrayOf(42, 42, 42, 42)))
+        assertFalse(inputStream.contentEquals(byteArrayOf(0, 42, 3, 4)))
+    }
+
+    @Test
+    fun testStreamNull() {
+        val inputStream: InputStream? = null
+
+        // Assert that the comparison fails when the input is not null
+        assertFalse(inputStream.contentEquals(byteArrayOf(0,1,2,3)))
+        assertFalse(inputStream.contentEquals(byteArrayOf()))
+
+        // Assert that the comparison succeeds when the byte array is also null
+        assertTrue(inputStream.contentEquals(null))
+    }
+
+    @Test
+    fun testBytesNull() {
+        val inputStream = ByteArrayInputStream(byteArrayOf(0,1,2,3))
+
+        // Assert that the comparison fails when the input is null
+        assertFalse(inputStream.contentEquals(null))
+    }
+
+    @Test
+    fun testStreamEmpty() {
+        val inputStream = ByteArrayInputStream(byteArrayOf())
+
+        // Assert that the comparison fails when the input is not empty or null
+        assertFalse(inputStream.contentEquals(byteArrayOf(0)))
+        assertFalse(inputStream.contentEquals(null))
+    }
+
+}
diff --git a/app/src/test/java/ch/threema/app/utils/WorkManagerUtilTest.kt b/app/src/test/java/ch/threema/app/utils/WorkManagerUtilTest.kt
new file mode 100644
index 00000000..c133e830
--- /dev/null
+++ b/app/src/test/java/ch/threema/app/utils/WorkManagerUtilTest.kt
@@ -0,0 +1,55 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.app.utils
+
+import org.junit.Test
+
+import org.junit.Assert.*
+
+
+
+class WorkManagerUtilTest {
+
+    /**
+     * Periods in seconds less than or equal to zero should be normalized to one day in milliseconds.
+     */
+    @Test
+    fun normalizeSchedulePeriodLessThanOrEqualZero() {
+        val dayInMillis = 24L * 60 * 60 * 1000
+        listOf(Int.MIN_VALUE, -1, 0)
+            .forEach {
+                assertEquals(dayInMillis, WorkManagerUtil.normalizeSchedulePeriod(it))
+            }
+    }
+
+    /**
+     * Periods in seconds larger than zero must be normalized to the same period in milliseconds.
+     */
+    @Test
+    fun normalizeSchedulePeriodGreaterThanZero() {
+        listOf(1, 10, Int.MAX_VALUE)
+            .forEach {
+                val expected = it * 1000L
+                assertEquals(expected, WorkManagerUtil.normalizeSchedulePeriod(it))
+            }
+    }
+}
diff --git a/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java b/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java
index 249c3168..3340d920 100644
--- a/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java
+++ b/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java
@@ -140,7 +140,8 @@ public class VoipStateServiceTest {
 		);
 	}
 
-	@Test
+	/** @noinspection deprecation*/
+    @Test
 	public void callCounterIncrement() {
 		// Initially at 0
 		assertEquals(0, service.getCallState().getIncomingCallCounter());
@@ -240,7 +241,7 @@ public class VoipStateServiceTest {
 
 		// Handling should not change the state
 		assertTrue(service.getCallState().isIdle());
-		assertTrue(service.handleCallOffer(msg));
+		assertFalse(service.handleCallOffer(msg));
 		assertTrue(service.getCallState().isIdle());
 	}
 
@@ -255,7 +256,7 @@ public class VoipStateServiceTest {
 
 		// Handling should not change the state
 		assertTrue(service.getCallState().isIdle());
-		assertTrue(service.handleCallOffer(msg));
+		assertFalse(service.handleCallOffer(msg));
 		assertTrue(service.getCallState().isIdle());
 	}
 
@@ -335,7 +336,6 @@ public class VoipStateServiceTest {
 
 	/**
 	 * Reject a call while another call is active.
-	 *
 	 * The call ID in the reject message should correspond to the incoming call,
 	 * not to the current call.
 	 */
diff --git a/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java b/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java
index dddde446..33afefc4 100644
--- a/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java
+++ b/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java
@@ -43,8 +43,8 @@ import ch.threema.app.utils.ZipUtil;
 import ch.threema.app.utils.executor.HandlerExecutor;
 import ch.threema.logging.LoggerManager;
 import ch.threema.logging.backend.DebugLogFileBackend;
-import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.DatabaseNonceStore;
+import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.BallotModelFactory;
 import ch.threema.storage.models.ConversationModel;
 import ch.threema.storage.models.data.media.FileDataModel;
@@ -61,7 +61,8 @@ import static ch.threema.architecture.ArchitectureDefinitions.getLayeredArchitec
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = THREEMA_ROOT_PACKAGE, importOptions = {ArchitectureTestUtils.DoNotIncludeAndroidTests.class})
+@AnalyzeClasses(packages = THREEMA_ROOT_PACKAGE, importOptions =
+    {ArchitectureTestUtils.DoNotIncludeAndroidTests.class})
 public class LayerDependenciesTest {
     @ArchTest
     public static final ArchRule appLayerAccess = getLayeredArchitecture()
@@ -75,7 +76,7 @@ public class LayerDependenciesTest {
             nameMatching("ch\\.threema\\.storage\\..*"),
             nameMatching("ch\\.threema\\.app\\.utils\\..*")
         )
-        // Data layer may access listeners and utils
+        // Data layer may access listeners, utils, multi-device, and reflection tasks
         .ignoreDependency(
             nameMatching("ch\\.threema\\.data\\..*"),
             nameMatching("ch\\.threema\\.app\\.managers\\..*")
@@ -88,6 +89,14 @@ public class LayerDependenciesTest {
             nameMatching("ch\\.threema\\.data\\..*"),
             nameMatching("ch\\.threema\\.app\\.utils\\..*")
         )
+        .ignoreDependency(
+            nameMatching("ch\\.threema\\.data\\..*"),
+            nameMatching("ch\\.threema\\.app\\.multidevice\\..*")
+        )
+        .ignoreDependency(
+            nameMatching("ch\\.threema\\.data\\..*"),
+            nameMatching("ch\\.threema\\.app\\.tasks\\..*")
+        )
         .ignoreDependency(DatabaseServiceNew.class, DatabaseMigrationFailedException.class)
         .ignoreDependency(DatabaseServiceNew.class, DatabaseMigrationLockedException.class)
         .ignoreDependency(DatabaseNonceStore.class, DatabaseMigrationFailedException.class)
@@ -125,6 +134,7 @@ public class LayerDependenciesTest {
 
     @ArchTest
     public static final ArchRule baseLayerAccess = getLayeredArchitecture()
-        .whereLayer(BASE).mayOnlyBeAccessedByLayers(APP, DATA, STORAGE, LOCALCRYPTO, DOMAIN, LOGGING);
+        .whereLayer(BASE).mayOnlyBeAccessedByLayers(APP, DATA, STORAGE, LOCALCRYPTO, DOMAIN,
+            LOGGING);
 
 }
diff --git a/app/src/test/java/ch/threema/architecture/LayerTest.java b/app/src/test/java/ch/threema/architecture/LayerTest.java
index 37a258c3..0aabcb21 100644
--- a/app/src/test/java/ch/threema/architecture/LayerTest.java
+++ b/app/src/test/java/ch/threema/architecture/LayerTest.java
@@ -42,6 +42,7 @@ import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 @RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(packages = THREEMA_ROOT_PACKAGE, importOptions = { ArchitectureTestUtils.DoNotIncludeAndroidTests.class })
 public class LayerTest {
+	/** @noinspection unused*/
 	@ArchTest
 	public static final ArchRule classesInPredefinedLayers = classes().should().resideInAnyPackage(
 		PACKAGE_ANNOTATION,
@@ -56,7 +57,8 @@ public class LayerTest {
 		"ch.threema.protobuf..",
 		"ch.threema.webrtc..",
 		"ch.threema.taskmanager..",
-		"ch.threema.testhelpers.."
+		"ch.threema.testhelpers..",
+		"ch.threema.libthreema.."
 	);
 
 }
diff --git a/app/src/test/java/ch/threema/data/ContactModelJavaTest.java b/app/src/test/java/ch/threema/data/ContactModelJavaTest.java
index df9d79e8..af46161a 100644
--- a/app/src/test/java/ch/threema/data/ContactModelJavaTest.java
+++ b/app/src/test/java/ch/threema/data/ContactModelJavaTest.java
@@ -22,71 +22,93 @@
 package ch.threema.data;
 
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 
 import java.math.BigInteger;
 import java.util.Date;
 
+import ch.threema.app.managers.CoreServiceManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.data.models.ContactModel;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.data.storage.DatabaseBackend;
 import ch.threema.domain.models.ContactSyncState;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.models.ReadReceiptPolicy;
 import ch.threema.domain.models.TypingIndicatorPolicy;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.models.WorkVerificationLevel;
+import ch.threema.domain.taskmanager.TaskManager;
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
-import ch.threema.storage.models.ContactModel.State;
 
 import static junit.framework.TestCase.assertEquals;
 import static junit.framework.TestCase.assertNull;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.when;
 import static org.powermock.api.mockito.PowerMockito.mock;
 import static org.powermock.api.mockito.PowerMockito.verifyZeroInteractions;
-import static org.powermock.api.mockito.PowerMockito.when;
 
 public class ContactModelJavaTest {
-    private final DatabaseBackend databaseBackendMock = mock(DatabaseBackend.class);
-
+	private final DatabaseBackend databaseBackendMock = mock(DatabaseBackend.class);
     private final PreferenceService preferenceServiceMock = mock(PreferenceService.class);
-
-    /**
-     * Test the construction using the primary constructor from Java.
-     */
-    @Test
-    public void testConstruction() {
-        final Date createdAt = new Date();
-        final byte[] publicKey = new byte[32];
-        final BigInteger largeBigInteger = new BigInteger("18446744073709551600");
-        final String identity = "TESTTEST";
-        final ContactModel contact = new ContactModel(identity, ContactModelData.javaCreate(
-            identity,
-            publicKey,
-            createdAt,
-            "Test",
-            "Contact",
-            null,
-            42,
-            VerificationLevel.SERVER_VERIFIED,
-            WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
-            IdentityType.NORMAL,
-            AcquaintanceLevel.DIRECT,
-            State.ACTIVE,
-            largeBigInteger,
-            ContactSyncState.CUSTOM,
-            ReadReceiptPolicy.DONT_SEND,
-            TypingIndicatorPolicy.SEND,
-            "asdf",
-            null,
-            false,
-            new byte[]{1, 2, 3},
-            null,
-            null
-        ), databaseBackendMock);
+	private final CoreServiceManager coreServiceManagerMock = mock(CoreServiceManager.class);
+	private final ContactModelRepository contactModelRepository = new ContactModelRepository(
+		new ModelTypeCache<>(), databaseBackendMock, coreServiceManagerMock
+	);
+	private final MultiDeviceManager multiDeviceManagerMock = mock(MultiDeviceManager.class);
+	private final TaskManager taskManagerMock = mock(TaskManager.class);
+
+	@Before
+	public void init() {
+		when(coreServiceManagerMock.getMultiDeviceManager()).thenReturn(multiDeviceManagerMock);
+		when(coreServiceManagerMock.getTaskManager()).thenReturn(taskManagerMock);
+	}
+
+	/**
+	 * Test the construction using the primary constructor from Java.
+	 */
+	@Test
+	public void testConstruction() {
+		final Date createdAt = new Date();
+		final byte[] publicKey = new byte[32];
+		final BigInteger largeBigInteger = new BigInteger("18446744073709551600");
+		final String identity = "TESTTEST";
+		final ContactModel contact = new ContactModel(
+			identity,
+			ContactModelData.javaCreate(
+				identity,
+				publicKey,
+				createdAt,
+				"Test",
+				"Contact",
+				null,
+				42,
+				VerificationLevel.SERVER_VERIFIED,
+				WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
+				IdentityType.NORMAL,
+				AcquaintanceLevel.DIRECT,
+				IdentityState.ACTIVE,
+				largeBigInteger,
+				ContactSyncState.CUSTOM,
+				ReadReceiptPolicy.DONT_SEND,
+				TypingIndicatorPolicy.SEND,
+				"asdf",
+				null,
+				false,
+				new byte[]{1, 2, 3},
+                null,
+                null
+			),
+			databaseBackendMock,
+			contactModelRepository,
+			coreServiceManagerMock
+		);
 
         final ContactModelData data = contact.getData().getValue();
         assertEquals("TESTTEST", data.identity);
@@ -99,7 +121,7 @@ public class ContactModelJavaTest {
         assertEquals(WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED, data.workVerificationLevel);
         assertEquals(IdentityType.NORMAL, data.identityType);
         assertEquals(AcquaintanceLevel.DIRECT, data.acquaintanceLevel);
-        assertEquals(State.ACTIVE, data.activityState);
+        assertEquals(IdentityState.ACTIVE, data.activityState);
         assertEquals(largeBigInteger, data.featureMaskBigInteger());
         try {
             data.featureMaskLong();
diff --git a/app/src/test/java/ch/threema/data/ContactModelTest.kt b/app/src/test/java/ch/threema/data/ContactModelTest.kt
index 51e60e42..861c49da 100644
--- a/app/src/test/java/ch/threema/data/ContactModelTest.kt
+++ b/app/src/test/java/ch/threema/data/ContactModelTest.kt
@@ -23,47 +23,52 @@ package ch.threema.data
 
 import android.text.format.DateUtils
 import ch.threema.app.listeners.ContactListener
+import ch.threema.app.managers.CoreServiceManager
 import ch.threema.app.managers.ListenerManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.app.tasks.ReflectContactSyncUpdateTask
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceStore
 import ch.threema.data.models.ContactModel
 import ch.threema.data.models.ContactModelData
-import ch.threema.data.repositories.RepositoryToken
+import ch.threema.data.repositories.ContactModelRepository
 import ch.threema.data.storage.DatabaseBackend
 import ch.threema.domain.models.ContactSyncState
+import ch.threema.domain.models.IdentityState
 import ch.threema.domain.models.IdentityType
 import ch.threema.domain.models.ReadReceiptPolicy
 import ch.threema.domain.models.TypingIndicatorPolicy
 import ch.threema.domain.models.VerificationLevel
 import ch.threema.domain.models.WorkVerificationLevel
+import ch.threema.domain.taskmanager.QueueSendCompleteListener
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.TaskManager
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
 import org.junit.After
 import org.junit.Assert
 import org.junit.Assert.assertArrayEquals
 import org.junit.Before
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mockito.Mockito.verifyNoInteractions
+import org.mockito.Mockito.`when`
 import org.powermock.api.mockito.PowerMockito
 import java.util.Date
 import kotlin.random.Random
 import kotlin.test.Test
 import kotlin.test.assertEquals
 import kotlin.test.assertFalse
-import kotlin.test.assertNotNull
 import kotlin.test.assertNull
 import kotlin.test.assertTrue
 import kotlin.test.fail
 
-// Used for testing, this is fine™
-class TestRepositoryToken : RepositoryToken
-
 /**
  * Track calls to the contact listener.
  */
 private class ContactListenerTracker {
     val onNew = mutableListOf<String>()
     val onModified = mutableListOf<String>()
-    val onAvatarChanged = mutableListOf<ch.threema.storage.models.ContactModel?>()
+    val onAvatarChanged = mutableListOf<String>()
     val onRemoved = mutableListOf<String>()
 
     val listener = object : ContactListener {
@@ -75,8 +80,8 @@ private class ContactListenerTracker {
             onModified.add(identity)
         }
 
-        override fun onAvatarChanged(contactModel: ch.threema.storage.models.ContactModel?) {
-            onAvatarChanged.add(contactModel)
+        override fun onAvatarChanged(identity: String) {
+            onAvatarChanged.add(identity)
         }
 
         override fun onRemoved(identity: String) {
@@ -95,13 +100,45 @@ private class ContactListenerTracker {
 
 class ContactModelTest {
     private val databaseBackendMock = PowerMockito.mock(DatabaseBackend::class.java)
+    private val multiDeviceManagerMock = PowerMockito.mock(MultiDeviceManager::class.java).also {
+        `when`(it.isMultiDeviceActive).thenReturn(true)
+    }
+    private val nonceStoreMock = PowerMockito.mock(NonceStore::class.java)
+    private val nonceFactory = NonceFactory(nonceStoreMock)
+    private val taskManager = object : TaskManager {
+        val scheduledTasks = mutableListOf<Task<*, TaskCodec>>()
+
+        override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> {
+            scheduledTasks.add(task)
+            return CompletableDeferred()
+        }
+
+        override fun hasPendingTasks(): Boolean = scheduledTasks.isNotEmpty()
+
+        override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+            // Nothing to do
+        }
+
+        override fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+            // Nothing to do
+        }
+    }
+    private val coreServiceManagerMock = PowerMockito.mock(CoreServiceManager::class.java).also {
+        `when`(it.taskManager).thenReturn(taskManager)
+        `when`(it.multiDeviceManager).thenReturn(multiDeviceManagerMock)
+        `when`(it.nonceFactory).thenReturn(nonceFactory)
+    }
+    private val contactModelRepository = ContactModelRepository(
+        ModelTypeCache(), databaseBackendMock, coreServiceManagerMock
+    )
 
     private lateinit var contactListenerTracker: ContactListenerTracker
 
     private fun createTestContact(isRestored: Boolean = false): ContactModel {
         val identity = "TESTTEST"
         return ContactModel(
-            identity, ContactModelData(
+            identity,
+            ContactModelData(
                 identity,
                 Random.nextBytes(32),
                 Date(),
@@ -113,7 +150,7 @@ class ContactModelTest {
                 WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
                 IdentityType.NORMAL,
                 AcquaintanceLevel.DIRECT,
-                State.ACTIVE,
+                IdentityState.ACTIVE,
                 ContactSyncState.INITIAL,
                 7uL,
                 ReadReceiptPolicy.DONT_SEND,
@@ -124,7 +161,10 @@ class ContactModelTest {
                 null,
                 null,
                 null,
-            ), databaseBackendMock
+            ),
+            databaseBackendMock,
+            contactModelRepository,
+            coreServiceManagerMock,
         )
     }
 
@@ -151,7 +191,8 @@ class ContactModelTest {
         val localAvatarExpires = Date()
         val identity = "TESTTEST"
         val contact = ContactModel(
-            identity, ContactModelData(
+            identity,
+            ContactModelData(
                 identity,
                 publicKey,
                 createdAt,
@@ -163,7 +204,7 @@ class ContactModelTest {
                 WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
                 IdentityType.NORMAL,
                 AcquaintanceLevel.DIRECT,
-                State.ACTIVE,
+                IdentityState.ACTIVE,
                 ContactSyncState.INITIAL,
                 7uL,
                 ReadReceiptPolicy.SEND,
@@ -174,7 +215,10 @@ class ContactModelTest {
                 byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8),
                 null,
                 null,
-            ), databaseBackendMock
+            ),
+            databaseBackendMock,
+            contactModelRepository,
+            coreServiceManagerMock,
         )
 
         val value = contact.data.value!!
@@ -189,7 +233,7 @@ class ContactModelTest {
         assertEquals(WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED, value.workVerificationLevel)
         assertEquals(IdentityType.NORMAL, value.identityType)
         assertEquals(AcquaintanceLevel.DIRECT, value.acquaintanceLevel)
-        assertEquals(State.ACTIVE, value.activityState)
+        assertEquals(IdentityState.ACTIVE, value.activityState)
         assertEquals(ContactSyncState.INITIAL, value.syncState)
         assertEquals(7uL, value.featureMask)
         assertEquals(ReadReceiptPolicy.SEND, value.readReceiptPolicy)
@@ -227,6 +271,204 @@ class ContactModelTest {
         }
     }
 
+    @Test
+    fun testSetNameFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setNameFromLocal("First", "Last") },
+            { c -> "First" == c.data.value!!.firstName && "Last" == c.data.value!!.lastName },
+            ReflectContactSyncUpdateTask.ReflectNameUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testSetNameFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setFirstNameFromSync("First") },
+            { c -> "First" == c.data.value!!.firstName },
+        )
+        contactListenerTracker.onModified.clear()
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setLastNameFromSync("Last") },
+            { c -> "Last" == c.data.value!!.lastName },
+        )
+    }
+
+    @Test
+    fun testNicknameFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setNicknameFromSync("NewNickname") },
+            { c -> "NewNickname" == c.data.value!!.nickname },
+        )
+    }
+
+    @Test
+    fun testVerificationLevelFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setVerificationLevelFromLocal(VerificationLevel.SERVER_VERIFIED) },
+            { c -> VerificationLevel.SERVER_VERIFIED == c.data.value!!.verificationLevel },
+            ReflectContactSyncUpdateTask.ReflectVerificationLevelUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testVerificationLevelFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setVerificationLevelFromSync(VerificationLevel.SERVER_VERIFIED) },
+            { c -> VerificationLevel.SERVER_VERIFIED == c.data.value!!.verificationLevel },
+        )
+    }
+
+    @Test
+    fun testWorkVerificationLevelFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setWorkVerificationLevelFromLocal(WorkVerificationLevel.NONE) },
+            { c -> WorkVerificationLevel.NONE == c.data.value!!.workVerificationLevel },
+            ReflectContactSyncUpdateTask.ReflectWorkVerificationLevelUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testWorkVerificationLevelFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setWorkVerificationLevelFromSync(WorkVerificationLevel.NONE) },
+            { c -> WorkVerificationLevel.NONE == c.data.value!!.workVerificationLevel },
+        )
+    }
+
+    @Test
+    fun testIdentityTypeFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setIdentityTypeFromLocal(IdentityType.WORK) },
+            { c -> IdentityType.WORK == c.data.value!!.identityType },
+            ReflectContactSyncUpdateTask.ReflectIdentityTypeUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testIdentityTypeFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setIdentityTypeFromSync(IdentityType.WORK) },
+            { c -> IdentityType.WORK == c.data.value!!.identityType },
+        )
+    }
+
+    @Test
+    fun testAcquaintanceLevelFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setAcquaintanceLevelFromLocal(AcquaintanceLevel.GROUP) },
+            { c -> AcquaintanceLevel.GROUP == c.data.value!!.acquaintanceLevel },
+            ReflectContactSyncUpdateTask.ReflectAcquaintanceLevelUpdate::class.java,
+            shouldTriggerModifyListener = false,
+        )
+    }
+
+    @Test
+    fun testAcquaintanceLevelFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setAcquaintanceLevelFromSync(AcquaintanceLevel.GROUP) },
+            { c -> AcquaintanceLevel.GROUP == c.data.value!!.acquaintanceLevel },
+            shouldTriggerModifyListener = false,
+        )
+    }
+
+    @Test
+    fun testActivityStateFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setActivityStateFromLocal(IdentityState.INVALID) },
+            { c -> IdentityState.INVALID == c.data.value!!.activityState },
+            ReflectContactSyncUpdateTask.ReflectActivityStateUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testActivityStateFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setActivityStateFromSync(IdentityState.INVALID) },
+            { c -> IdentityState.INVALID == c.data.value!!.activityState },
+        )
+    }
+
+    @Test
+    fun testFeatureMaskFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setFeatureMaskFromLocal(12) },
+            { c -> 12 == c.data.value!!.featureMask.toInt() },
+            ReflectContactSyncUpdateTask.ReflectFeatureMaskUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testFeatureMaskFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setFeatureMaskFromSync(12u) },
+            { c -> 12 == c.data.value!!.featureMask.toInt() },
+        )
+    }
+
+    @Test
+    fun testSyncStateFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setSyncStateFromSync(ContactSyncState.CUSTOM) },
+            { c -> ContactSyncState.CUSTOM == c.data.value!!.syncState },
+            shouldTriggerModifyListener = false,
+        )
+    }
+
+    @Test
+    fun testReadReceiptPolicyFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.DEFAULT) },
+            { c -> ReadReceiptPolicy.DEFAULT == c.data.value!!.readReceiptPolicy },
+            ReflectContactSyncUpdateTask.ReflectReadReceiptPolicyUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testReadReceiptPolicyFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setReadReceiptPolicyFromSync(ReadReceiptPolicy.DEFAULT) },
+            { c -> ReadReceiptPolicy.DEFAULT == c.data.value!!.readReceiptPolicy },
+        )
+    }
+
+    @Test
+    fun testTypingIndicatorPolicyFromLocal() {
+        assertChangeFromLocal(
+            createTestContact(),
+            { c -> c.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.DONT_SEND) },
+            { c -> TypingIndicatorPolicy.DONT_SEND == c.data.value!!.typingIndicatorPolicy },
+            ReflectContactSyncUpdateTask.ReflectTypingIndicatorPolicyUpdate::class.java,
+        )
+    }
+
+    @Test
+    fun testTypingIndicatorPolicyFromSync() {
+        assertChangeFromSync(
+            createTestContact(),
+            { c -> c.setTypingIndicatorPolicyFromSync(TypingIndicatorPolicy.DONT_SEND) },
+            { c -> TypingIndicatorPolicy.DONT_SEND == c.data.value!!.typingIndicatorPolicy },
+        )
+    }
+
     @Test
     fun testDisplayName() {
         val contact = createTestContact()
@@ -252,43 +494,16 @@ class ContactModelTest {
     fun testConstructorValidateIdentity() {
         val data = createTestContact().data.value!!.copy(identity = "AAAAAAAA")
         Assert.assertThrows(AssertionError::class.java) {
-            ContactModel("BBBBBBBB", data, databaseBackendMock)
+            ContactModel(
+                "BBBBBBBB",
+                data,
+                databaseBackendMock,
+                contactModelRepository,
+                coreServiceManagerMock
+            )
         }
     }
 
-    @Test
-    fun testDeleteIndirect() {
-        val contact = createTestContact()
-        assertNotNull(contact.data.value)
-
-        // Delete only model state, not database entry
-        contact.delete(TestRepositoryToken(), false)
-        assertNull(contact.data.value)
-
-        // No interaction with database backend should take place
-        verifyNoInteractions(databaseBackendMock)
-
-        // Listeners should not be called
-        assertEquals(0, contactListenerTracker.onRemoved.size)
-    }
-
-    @Test
-    fun testDeleteDirect() {
-        val contact = createTestContact()
-        assertNotNull(contact.data.value)
-
-        // Delete only model state, not database entry
-        contact.delete(TestRepositoryToken(), true)
-        assertNull(contact.data.value)
-
-        // Ensure that the contact was deleted from the database backend
-        verify(databaseBackendMock, times(1))
-            .deleteContactByIdentity(contact.identity)
-
-        assertEquals(1, contactListenerTracker.onRemoved.size)
-        assertEquals(contact.identity, contactListenerTracker.onRemoved[0])
-    }
-
     @Test
     fun testAndroidContactLookupKey() {
         val contact = createTestContact()
@@ -306,6 +521,9 @@ class ContactModelTest {
             assertTrue { it.isLinkedToAndroidContact() }
         }
         assertEquals(1, contactListenerTracker.onModified.size)
+
+        // Assert that no tasks have been scheduled
+        assertTrue(taskManager.scheduledTasks.isEmpty())
     }
 
     @Test
@@ -328,6 +546,9 @@ class ContactModelTest {
 
         // Change listener not called
         assertEquals(0, contactListenerTracker.onModified.size)
+
+        // Assert that no tasks have been scheduled
+        assertTrue(taskManager.scheduledTasks.isEmpty())
     }
 
     @Test
@@ -343,6 +564,9 @@ class ContactModelTest {
 
         // Change listener not called
         assertEquals(0, contactListenerTracker.onModified.size)
+
+        // Assert that no tasks have been scheduled
+        assertTrue(taskManager.scheduledTasks.isEmpty())
     }
 
     @Test
@@ -379,5 +603,89 @@ class ContactModelTest {
         assertTrue("Contact listener onModified called for wrong identity") {
             contactListenerTracker.onModified.all { it == contact.identity }
         }
+
+        // Assert that no tasks have been scheduled
+        assertTrue(taskManager.scheduledTasks.isEmpty())
+    }
+
+    private fun assertChangeFromLocal(
+        contactModel: ContactModel,
+        performChange: (c: ContactModel) -> Unit,
+        checkDataChanged: (c: ContactModel) -> Boolean,
+        expectedTaskReflectType: Class<*>,
+        shouldTriggerModifyListener: Boolean = true,
+    ) {
+        // Check that the data is not yet updated, listener count is zero, and no task is scheduled
+        assertFalse(checkDataChanged(contactModel))
+        assertEquals(0, contactListenerTracker.onModified.size)
+        assertTrue(taskManager.scheduledTasks.isEmpty())
+
+        // Perform change
+        performChange(contactModel)
+
+        // Assert that the data has been updated, the listeners has been fired and a sync task has
+        // been created
+        assertTrue(checkDataChanged(contactModel))
+        if (shouldTriggerModifyListener) {
+            assertEquals(1, contactListenerTracker.onModified.size)
+        }
+        assertEquals(expectedTaskReflectType, taskManager.scheduledTasks.first()::class.java)
+        assertEquals(1, taskManager.scheduledTasks.size)
+        taskManager.scheduledTasks.clear()
+
+        // Perform the change another time
+        performChange(contactModel)
+
+        // Assert that the data is still correct, but no listener should be fired and no sync task
+        // should be scheduled
+        assertTrue(checkDataChanged(contactModel))
+        if (shouldTriggerModifyListener) {
+            assertEquals(1, contactListenerTracker.onModified.size)
+        }
+        assertTrue(taskManager.scheduledTasks.isEmpty())
+
+        // The listeners should have been notified for out test contact
+        assertTrue("Contact listener onModified called for wrong identity") {
+            contactListenerTracker.onModified.all { it == contactModel.identity }
+        }
+    }
+
+    private fun assertChangeFromSync(
+        contactModel: ContactModel,
+        performChange: (c: ContactModel) -> Unit,
+        checkDataChanged: (c: ContactModel) -> Boolean,
+        shouldTriggerModifyListener: Boolean = true,
+    ) {
+        // Check that the data is not yet updated, listener count is zero, and no task is scheduled
+        assertFalse(checkDataChanged(contactModel))
+        assertEquals(0, contactListenerTracker.onModified.size)
+        assertTrue(taskManager.scheduledTasks.isEmpty())
+
+        // Perform change
+        performChange(contactModel)
+
+        // Assert that the data has been updated, the listeners has been fired and no sync task has
+        // been created
+        assertTrue(checkDataChanged(contactModel))
+        if (shouldTriggerModifyListener) {
+            assertEquals(1, contactListenerTracker.onModified.size)
+        }
+        assertEquals(0, taskManager.scheduledTasks.size)
+
+        // Perform the change another time
+        performChange(contactModel)
+
+        // Assert that the data is still correct, but no listener should be fired and still no sync
+        // task should be scheduled
+        assertTrue(checkDataChanged(contactModel))
+        if (shouldTriggerModifyListener) {
+            assertEquals(1, contactListenerTracker.onModified.size)
+        }
+        assertTrue(taskManager.scheduledTasks.isEmpty())
+
+        // The listeners should have been notified for out test contact
+        assertTrue("Contact listener onModified called for wrong identity") {
+            contactListenerTracker.onModified.all { it == contactModel.identity }
+        }
     }
 }
diff --git a/app/src/test/java/ch/threema/data/GroupModelJavaTest.java b/app/src/test/java/ch/threema/data/GroupModelJavaTest.java
index 76c83463..969ed184 100644
--- a/app/src/test/java/ch/threema/data/GroupModelJavaTest.java
+++ b/app/src/test/java/ch/threema/data/GroupModelJavaTest.java
@@ -21,25 +21,39 @@
 
 package ch.threema.data;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import java.util.Collections;
 import java.util.Date;
 import java.util.Set;
 
+import ch.threema.app.managers.CoreServiceManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.data.models.GroupIdentity;
 import ch.threema.data.models.GroupModel;
 import ch.threema.data.models.GroupModelData;
 import ch.threema.data.storage.DatabaseBackend;
 import ch.threema.domain.models.GroupId;
+import ch.threema.domain.taskmanager.TaskManager;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.when;
 import static org.powermock.api.mockito.PowerMockito.mock;
 
 public class GroupModelJavaTest {
 	private final DatabaseBackend databaseBackendMock = mock(DatabaseBackend.class);
+	private final CoreServiceManager coreServiceManagerMock = mock(CoreServiceManager.class);
+	private final MultiDeviceManager multiDeviceManagerMock = mock(MultiDeviceManager.class);
+	private final TaskManager taskManagerMock = mock(TaskManager.class);
+
+	@Before
+	public void init() {
+		when(coreServiceManagerMock.getMultiDeviceManager()).thenReturn(multiDeviceManagerMock);
+		when(coreServiceManagerMock.getTaskManager()).thenReturn(taskManagerMock);
+	}
 
 	@Test
 	public void testConstruction() {
@@ -55,6 +69,7 @@ public class GroupModelJavaTest {
 		final String groupDesc = "Description";
 		final Date groupDescChangedAt = new Date();
 		final Set<String> members = Set.of("AAAAAAAA", "BBBBBBBB");
+		final ch.threema.storage.models.GroupModel.UserState userState = ch.threema.storage.models.GroupModel.UserState.MEMBER;
 
 		final GroupModel groupModel = new GroupModel(
 			new GroupIdentity(creatorIdentity, groupId.toLong()),
@@ -70,9 +85,11 @@ public class GroupModelJavaTest {
 				colorIndex,
 				groupDesc,
 				groupDescChangedAt,
-				members
+				members,
+				userState
 			),
-			databaseBackendMock
+			databaseBackendMock,
+			coreServiceManagerMock
 		);
 
 		final GroupModelData value = groupModel.getData().getValue();
@@ -157,7 +174,8 @@ public class GroupModelJavaTest {
 			colorIndex,
 			"Description",
 			new Date(),
-			Collections.emptySet()
+			Collections.emptySet(),
+			ch.threema.storage.models.GroupModel.UserState.MEMBER
 		);
 	}
 
@@ -176,7 +194,8 @@ public class GroupModelJavaTest {
 				colorIndex,
 				"Description",
 				new Date(),
-				Collections.emptySet()
+				Collections.emptySet(),
+				ch.threema.storage.models.GroupModel.UserState.MEMBER
 			)
 		);
 	}
diff --git a/app/src/test/java/ch/threema/data/GroupModelTest.kt b/app/src/test/java/ch/threema/data/GroupModelTest.kt
index 42b4e49b..ba9a08a6 100644
--- a/app/src/test/java/ch/threema/data/GroupModelTest.kt
+++ b/app/src/test/java/ch/threema/data/GroupModelTest.kt
@@ -21,12 +21,23 @@
 
 package ch.threema.data
 
+import ch.threema.app.managers.CoreServiceManager
+import ch.threema.app.multidevice.MultiDeviceManager
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceStore
 import ch.threema.data.models.GroupIdentity
 import ch.threema.data.models.GroupModel
 import ch.threema.data.models.GroupModelData
 import ch.threema.data.storage.DatabaseBackend
+import ch.threema.domain.taskmanager.QueueSendCompleteListener
+import ch.threema.domain.taskmanager.Task
+import ch.threema.domain.taskmanager.TaskCodec
+import ch.threema.domain.taskmanager.TaskManager
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
 import org.junit.Assert
 import org.junit.Assert.assertArrayEquals
+import org.mockito.Mockito.`when`
 import org.powermock.api.mockito.PowerMockito
 import java.util.Date
 import kotlin.test.Test
@@ -34,6 +45,34 @@ import kotlin.test.assertEquals
 
 class GroupModelTest {
     private val databaseBackendMock = PowerMockito.mock(DatabaseBackend::class.java)
+    private val multiDeviceManagerMock = PowerMockito.mock(MultiDeviceManager::class.java).also {
+        `when`(it.isMultiDeviceActive).thenReturn(true)
+    }
+    private val nonceStoreMock = PowerMockito.mock(NonceStore::class.java)
+    private val nonceFactory = NonceFactory(nonceStoreMock)
+    private val taskManager = object : TaskManager {
+        val scheduledTasks = mutableListOf<Task<*, TaskCodec>>()
+
+        override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> {
+            scheduledTasks.add(task)
+            return CompletableDeferred()
+        }
+
+        override fun hasPendingTasks(): Boolean = scheduledTasks.isNotEmpty()
+
+        override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+            // Nothing to do
+        }
+
+        override fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener) {
+            // Nothing to do
+        }
+    }
+    private val coreServiceManagerMock = PowerMockito.mock(CoreServiceManager::class.java).also {
+        `when`(it.taskManager).thenReturn(taskManager)
+        `when`(it.multiDeviceManager).thenReturn(multiDeviceManagerMock)
+        `when`(it.nonceFactory).thenReturn(nonceFactory)
+    }
 
     private fun createTestGroup(): GroupModel {
         val groupIdentity = GroupIdentity("TESTTEST", 42)
@@ -52,8 +91,10 @@ class GroupModelTest {
                 "Description",
                 Date(),
                 members,
+                ch.threema.storage.models.GroupModel.UserState.MEMBER,
             ),
-            databaseBackendMock
+            databaseBackendMock,
+            coreServiceManagerMock,
         )
     }
 
@@ -117,7 +158,10 @@ class GroupModelTest {
                 groupDesc,
                 groupDescChangedAt,
                 members,
-            ), databaseBackendMock
+                ch.threema.storage.models.GroupModel.UserState.MEMBER,
+            ),
+            databaseBackendMock,
+            coreServiceManagerMock,
         )
 
         val value = group.data.value!!
@@ -143,7 +187,8 @@ class GroupModelTest {
             // The same identity but different object is provided
             GroupIdentity("AAAAAAAA", 42),
             data,
-            databaseBackendMock
+            databaseBackendMock,
+            coreServiceManagerMock,
         )
 
         assertEquals("AAAAAAAA", model.groupIdentity.creatorIdentity)
@@ -159,7 +204,8 @@ class GroupModelTest {
             GroupModel(
                 data.groupIdentity.copy(creatorIdentity = "BBBBBBBB"),
                 data,
-                databaseBackendMock
+                databaseBackendMock,
+                coreServiceManagerMock,
             )
         }
     }
@@ -173,7 +219,8 @@ class GroupModelTest {
             GroupModel(
                 data.groupIdentity.copy(groupId = 0),
                 data,
-                databaseBackendMock
+                databaseBackendMock,
+                coreServiceManagerMock,
             )
         }
     }
diff --git a/domain/src/main/java/ch/threema/base/crypto/NonceFactory.java b/domain/src/main/java/ch/threema/base/crypto/NonceFactory.java
deleted file mode 100644
index 6c2d6571..00000000
--- a/domain/src/main/java/ch/threema/base/crypto/NonceFactory.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.crypto;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.ThreemaException;
-import com.neilalexander.jnacl.NaCl;
-
-import java.security.SecureRandom;
-import java.util.List;
-
-/**
- * Interface for identity stores.
- */
-final public class NonceFactory {
-	private final SecureRandom secureRandom;
-	private final NonceStore nonceStore;
-
-	public NonceFactory(NonceStore nonceStore) {
-		this(new SecureRandom(), nonceStore);
-	}
-	public NonceFactory(SecureRandom secureRandom,
-						NonceStore nonceStore) {
-		this.secureRandom = secureRandom;
-		this.nonceStore = nonceStore;
-	}
-
-	/**
-	 * Create the next unique nonce
-	 * @return nonce
-	 */
-	public synchronized byte[] next() throws ThreemaException {
-		return this.next(true);
-	}
-
-	/**
-	 * Create the next unique nonce
-	 * @param save
-	 * @return nonce
-	 */
-	public synchronized byte[] next(boolean save) {
-		byte[] nonce = new byte[NaCl.NONCEBYTES];
-		boolean success;
-		do {
-			this.secureRandom.nextBytes(nonce);
-			// The nonce has been created successfully if it does not exist yet.
-			if (save) {
-				success = this.store(nonce);
-			} else {
-				success = !this.exists(nonce);
-			}
-		} while(!success);
-
-		return nonce;
-	}
-
-	/**
-	 * Store the nonce into the nonce store
-	 * @param nonce
-	 * @return
-	 */
-	public synchronized boolean store(byte[] nonce) {
-		return this.nonceStore.store(nonce);
-	}
-
-	/**
-	 * Return true if the given nonce already exists
-	 *
-	 * @param nonce
-	 * @return
-	 */
-	public boolean exists(byte[] nonce) {
-		return this.nonceStore.exists(nonce);
-	}
-
-	@NonNull
-	public List<byte[]> getAllHashedNonces() {
-		return this.nonceStore.getAllHashedNonces();
-	}
-}
diff --git a/domain/src/main/java/ch/threema/base/crypto/NonceStore.kt b/domain/src/main/java/ch/threema/base/crypto/NonceStore.kt
new file mode 100644
index 00000000..dc1247aa
--- /dev/null
+++ b/domain/src/main/java/ch/threema/base/crypto/NonceStore.kt
@@ -0,0 +1,105 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.base.crypto
+
+import ch.threema.base.utils.SecureRandomUtil
+import com.neilalexander.jnacl.NaCl
+
+enum class NonceScope {
+    CSP,
+    D2D
+}
+
+@JvmInline
+value class Nonce(val bytes: ByteArray)
+
+@JvmInline
+value class HashedNonce(val bytes: ByteArray)
+
+interface NonceStore {
+    fun exists(scope: NonceScope, nonce: Nonce): Boolean
+    fun store(scope: NonceScope, nonce: Nonce): Boolean
+    fun getCount(scope: NonceScope): Long
+    fun getAllHashedNonces(scope: NonceScope): List<HashedNonce>
+
+    /**
+     * Add a chunk of hashed nonces in their byte array representation to a list.
+     *
+     * @param scope The scope of which nonces should be used
+     * @param chunkSize The number of nonces to add
+     * @param offset the offset where reading the nonces starts
+     * @param nonces The list to which the nonces should be added
+     */
+    fun addHashedNoncesChunk(scope: NonceScope, chunkSize: Int, offset: Int, nonces: MutableList<HashedNonce>)
+    fun insertHashedNonces(scope: NonceScope, nonces: List<HashedNonce>): Boolean
+}
+
+fun interface NonceFactoryNonceBytesProvider {
+    fun next(length: Int): ByteArray
+}
+
+class NonceFactory(
+    private val nonceStore: NonceStore,
+    // Nonce Provider is injectable for testing purposes
+    private val nonceProvider: NonceFactoryNonceBytesProvider
+) {
+    constructor(nonceStore: NonceStore)
+        : this(nonceStore, { length -> SecureRandomUtil.generateRandomBytes(length)})
+
+    @JvmName("nextNonce")
+    fun next(scope: NonceScope): Nonce {
+        return sequence {
+            while(true) {
+                val nonce = Nonce(nonceProvider.next(NaCl.NONCEBYTES))
+                yield(nonce)
+            }
+        }
+            .first { !exists(scope, it) }
+    }
+
+    /**
+     * @return true if the nonce has been stored, false if the nonce could not be stored or already existed.
+     */
+    @JvmName("storeNonce")
+    fun store(scope: NonceScope, nonce: Nonce) = nonceStore.store(scope, nonce)
+
+    @JvmName("existsNonce")
+    fun exists(scope: NonceScope, nonce: Nonce) = nonceStore.exists(scope, nonce)
+
+    fun getCount(scope: NonceScope): Long = nonceStore.getCount(scope)
+
+    fun getAllHashedNonces(scope: NonceScope) = nonceStore.getAllHashedNonces(scope)
+
+    /**
+     * @see NonceStore.addHashedNoncesChunk
+     */
+    fun addHashedNoncesChunk(scope: NonceScope, chunkSize: Int, offset: Int, nonces: MutableList<HashedNonce>) {
+        nonceStore.addHashedNoncesChunk(scope, chunkSize, offset, nonces)
+    }
+
+    fun insertHashedNonces(scope: NonceScope, nonces: List<HashedNonce>) =
+        nonceStore.insertHashedNonces(scope, nonces)
+
+    fun insertHashedNoncesJava (scope: NonceScope, nonces: List<ByteArray>): Boolean {
+        return insertHashedNonces(scope, nonces.map { HashedNonce(it) })
+    }
+}
diff --git a/domain/src/main/java/ch/threema/base/utils/Base64UrlSafe.kt b/domain/src/main/java/ch/threema/base/utils/Base64UrlSafe.kt
new file mode 100644
index 00000000..af5820c7
--- /dev/null
+++ b/domain/src/main/java/ch/threema/base/utils/Base64UrlSafe.kt
@@ -0,0 +1,54 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.base.utils
+
+/**
+ * Url safe en-/decoding according to https://datatracker.ietf.org/doc/html/rfc3548
+ */
+object Base64UrlSafe {
+    /**
+     * Encode with a url safe base 64 alphabet. Padding characters are stripped.
+     */
+    fun encode(bytes: ByteArray): String {
+        return Base64.encodeBytes(bytes)
+            .replace("+", "-")
+            .replace("/", "_")
+            .trimEnd('=')
+    }
+
+    /**
+     * Decode a url safe base 64 string.
+     */
+    fun decode(s: String): ByteArray {
+        val defaultBase64 = s
+            .replace("-", "+")
+            .replace("_", "/")
+
+        val padding = when(defaultBase64.length % 4) {
+            2 -> "=="
+            3 -> "="
+            else -> ""
+        }
+
+        return Base64.decode("$defaultBase64$padding")
+    }
+}
diff --git a/domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt b/domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt
index 2ed4c488..dfd120d2 100644
--- a/domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt
+++ b/domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt
@@ -36,3 +36,7 @@ fun ByteArray.toHexString(maxBytes: Int = 0): String {
         Utils.byteArrayToHexString(this)
     }
 }
+
+fun ByteArray.chunked(size: Int): List<ByteArray> = asIterable()
+    .chunked(size)
+    .map { it.toByteArray() }
diff --git a/domain/src/main/java/ch/threema/base/utils/Utils.java b/domain/src/main/java/ch/threema/base/utils/Utils.java
index 3148ead4..ed5cb1af 100644
--- a/domain/src/main/java/ch/threema/base/utils/Utils.java
+++ b/domain/src/main/java/ch/threema/base/utils/Utils.java
@@ -113,6 +113,14 @@ public class Utils {
 		return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getLong();
 	}
 
+	public static @NonNull byte[] shortToByteArrayLittleEndian(short value) {
+		return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(value).array();
+	}
+
+	public static @NonNull byte[] intToByteArrayLittleEndian(int value) {
+		return ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
+	}
+
 	public static @NonNull byte[] longToByteArrayLittleEndian(long value) {
 		return ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(value).array();
 	}
diff --git a/domain/src/main/java/ch/threema/domain/models/AppVersion.java b/domain/src/main/java/ch/threema/domain/models/AppVersion.java
index 558926fa..4254ca29 100644
--- a/domain/src/main/java/ch/threema/domain/models/AppVersion.java
+++ b/domain/src/main/java/ch/threema/domain/models/AppVersion.java
@@ -50,11 +50,16 @@ public class AppVersion extends Version {
 		this.appSystemVersion = appSystemVersion;
 	}
 
+	@Override
+	public String getVersionNumber() {
+		return appVersionNumber;
+	}
+
 	/**
 	 * Return the short version: Version;PlatformCode
 	 */
 	@Override
-	public String getVersion() {
+	public String getVersionString() {
 		return appVersionNumber + appPlatformCode;
 	}
 
@@ -64,7 +69,7 @@ public class AppVersion extends Version {
 	 * Format: `<app-version>;<platform>;<lang>/<country-code>;<device-model>;<os-version>`
 	 */
 	@Override
-	public String getFullVersion() {
+	public String getFullVersionString() {
 		return appVersionNumber.replace(";", "_") + ";"
 			+ appPlatformCode.replace(";", "_") + ";"
 			+ appLanguage.replace(";", "_") + "/"
diff --git a/domain/src/main/java/ch/threema/domain/models/Contact.kt b/domain/src/main/java/ch/threema/domain/models/Contact.kt
index b3cd72f7..469e3998 100644
--- a/domain/src/main/java/ch/threema/domain/models/Contact.kt
+++ b/domain/src/main/java/ch/threema/domain/models/Contact.kt
@@ -74,6 +74,36 @@ open class Contact(
     }
 }
 
+/**
+ * This represents a contact with reduced properties. Note that this is mainly used for caching. A
+ * basic contact may be a contact that is not present in the database. The existence of a
+ * [BasicContact] does therefore not mean that it is a known contact.
+ */
+open class BasicContact(
+    identity: String,
+    publicKey: ByteArray,
+    val featureMask: ULong,
+    val identityState: IdentityState,
+    val identityType: IdentityType,
+) : Contact(identity, publicKey) {
+    companion object {
+        @JvmStatic
+        fun javaCreate(
+            identity: String,
+            publicKey: ByteArray,
+            featureMask: Long,
+            identityState: IdentityState,
+            identityType: IdentityType,
+        ): BasicContact = BasicContact(
+            identity,
+            publicKey,
+            featureMask.toULong(),
+            identityState,
+            identityType,
+        )
+    }
+}
+
 enum class IdentityType {
     /**
      * A normal Threema identity.
@@ -86,6 +116,27 @@ enum class IdentityType {
     WORK,
 }
 
+/**
+ * This represents the identity state. Note that the variants must not be renamed as they are stored
+ * as string in the database.
+ */
+enum class IdentityState(val value: Int) {
+    /**
+     * Contact is active.
+     */
+    ACTIVE(0),
+
+    /**
+     * Contact is inactive.
+     */
+    INACTIVE(1),
+
+    /**
+     * Contact does not have a valid Threema-ID, or the ID was revoked.
+     */
+    INVALID(2)
+}
+
 enum class WorkVerificationLevel {
     NONE,
 
diff --git a/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java b/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java
index 7a6b76bb..bc9bed09 100644
--- a/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java
+++ b/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java
@@ -22,6 +22,9 @@
 package ch.threema.domain.onprem;
 
 public class OnPremConfigBlob {
+
+    public static final String PLACEHOLDER_BLOB_ID = "{blobId}";
+
 	// Note: these are Strings instead of URLs so that they can include placeholders
 	private final String uploadUrl;
 	private final String downloadUrl;
diff --git a/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java b/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java
index 5a92319f..890665dd 100644
--- a/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java
+++ b/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java
@@ -26,141 +26,198 @@ import java.util.Objects;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.utils.Utils;
 import ch.threema.domain.protocol.ServerAddressProvider;
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider;
 
 public class ServerAddressProviderOnPrem implements ServerAddressProvider {
 
-	public interface FetcherProvider {
-		OnPremConfigFetcher getFetcher() throws ThreemaException;
-	}
-
-	private final FetcherProvider fetcherProvider;
-
-	public ServerAddressProviderOnPrem(FetcherProvider fetcherProvider) {
-		this.fetcherProvider = fetcherProvider;
-	}
-
-	@Override
-	public String getChatServerNamePrefix(boolean ipv6) throws ThreemaException {
-		return "";
-	}
-
-	@Override
-	public String getChatServerNameSuffix(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getChatConfig().getHostname();
-	}
-
-	@Override
-	public int[] getChatServerPorts() throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getChatConfig().getPorts();
-	}
-
-	@Override
-	public boolean getChatServerUseServerGroups() {
-		return false;
-	}
-
-	@Override
-	public byte[] getChatServerPublicKey() throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
-	}
-
-	@Override
-	public byte[] getChatServerPublicKeyAlt() throws ThreemaException {
-		// No alternate public key for OnPrem, as it can easily be switched in OPPF
-		return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
-	}
-
-	@Override
-	public String getDirectoryServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getDirectoryConfig().getUrl();
-	}
-
-	@Override
-	public String getWorkServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getWorkConfig().getUrl();
-	}
-
-	@Override
-	public String getBlobServerDownloadUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getBlobConfig().getDownloadUrl();
-	}
-
-	@Override
-	public String getBlobServerDoneUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getBlobConfig().getDoneUrl();
-	}
-
-	@Override
-	public String getBlobServerUploadUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getBlobConfig().getUploadUrl();
-	}
-
-	@Override
-	public String getAvatarServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getAvatarConfig().getUrl();
-	}
-
-	@Override
-	public String getSafeServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getSafeConfig().getUrl();
-	}
-
-	@Override
-	@Nullable
-	public String getWebServerUrl() throws ThreemaException {
-		OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
-
-		if (onPremConfigWeb != null) {
-			return onPremConfigWeb.getUrl();
-		}
-		throw new ThreemaException("Unable to fetch Threema Web server url");
-	}
-
-	@Override
-	public String getWebOverrideSaltyRtcHost() throws ThreemaException {
-		OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
-
-		if (onPremConfigWeb != null) {
-			return onPremConfigWeb.getOverrideSaltyRtcHost();
-		}
-		return null;
-	}
-
-	@Override
-	public int getWebOverrideSaltyRtcPort() throws ThreemaException {
-		OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
-
-		if (onPremConfigWeb != null) {
-			return onPremConfigWeb.getOverrideSaltyRtcPort();
-		}
-		return 0;
-	}
-
-	@Override
-	public byte[] getThreemaPushPublicKey() throws ThreemaException {
-		// TODO(ONPREM-164): Allow to configure for OnPrem
-		return null;
-	}
-
-	@NonNull
-	@Override
-	public String getMediatorUrl() throws ThreemaException {
-		OnPremConfigMediator onPremConfigMediator = getOnPremConfigFetcher().fetch().getMediatorConfig();
-
-		if (onPremConfigMediator == null) {
-			throw new ThreemaException("No mediator config available");
-		}
-		return Objects.requireNonNull(onPremConfigMediator.getUrl());
-	}
-
-	@NonNull
-	@Override
-	public String getAppRatingUrl() throws ThreemaException {
-		throw new ThreemaException("App rating is not supported in onprem");
-	}
-
-	private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
-		return fetcherProvider.getFetcher();
-	}
+    public interface FetcherProvider {
+        OnPremConfigFetcher getFetcher() throws ThreemaException;
+    }
+
+    private final FetcherProvider fetcherProvider;
+
+    public ServerAddressProviderOnPrem(FetcherProvider fetcherProvider) {
+        this.fetcherProvider = fetcherProvider;
+    }
+
+    @Override
+    public String getChatServerNamePrefix(boolean ipv6) throws ThreemaException {
+        return "";
+    }
+
+    @Override
+    public String getChatServerNameSuffix(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getChatConfig().getHostname();
+    }
+
+    @Override
+    public int[] getChatServerPorts() throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getChatConfig().getPorts();
+    }
+
+    @Override
+    public boolean getChatServerUseServerGroups() {
+        return false;
+    }
+
+    @Override
+    public byte[] getChatServerPublicKey() throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
+    }
+
+    @Override
+    public byte[] getChatServerPublicKeyAlt() throws ThreemaException {
+        // No alternate public key for OnPrem, as it can easily be switched in OPPF
+        return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
+    }
+
+    @Override
+    public String getDirectoryServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getDirectoryConfig().getUrl();
+    }
+
+    @Override
+    public String getWorkServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getWorkConfig().getUrl();
+    }
+
+    // TODO(ANDR-3375): Return correct base url of mirror server
+    @NonNull
+    @Override
+    public String getBlobBaseUrlMirrorServer(@NonNull MultiDevicePropertyProvider multiDevicePropertyProvider) throws ThreemaException {
+        throw new ThreemaException("Not yet implemented.");
+    }
+
+    @NonNull
+    @Override
+    public String getBlobServerDownloadUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+        final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+        if (blobIdHexString == null || blobIdHexString.isBlank()) {
+            throw new ThreemaException("Argument blobId is not in correct form");
+        }
+        return getOnPremConfigFetcher()
+            .fetch()
+            .getBlobConfig()
+            .getDownloadUrl()
+            .replace(OnPremConfigBlob.PLACEHOLDER_BLOB_ID, blobIdHexString);
+    }
+
+    @NonNull
+    @Override
+    public String getBlobServerUploadUrl(boolean useIpV6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getBlobConfig().getUploadUrl();
+    }
+
+    @NonNull
+    @Override
+    public String getBlobServerDoneUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+        final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+        if (blobIdHexString == null || blobIdHexString.isBlank()) {
+            throw new ThreemaException("Argument blobId is not in correct form");
+        }
+        return getOnPremConfigFetcher()
+            .fetch()
+            .getBlobConfig()
+            .getDoneUrl()
+            .replace(OnPremConfigBlob.PLACEHOLDER_BLOB_ID, blobIdHexString);
+    }
+
+    // TODO(ANDR-3375): Return correct url of mirror server
+    @NonNull
+    @Override
+    public String getBlobMirrorServerDownloadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException {
+        return getBlobServerDownloadUrl(false, blobId);
+    }
+
+    // TODO(ANDR-3375): Return correct url of mirror server
+    @NonNull
+    @Override
+    public String getBlobMirrorServerUploadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+    ) throws ThreemaException {
+        return getBlobServerUploadUrl(false);
+    }
+
+    // TODO(ANDR-3375): Return correct url of mirror server
+    @NonNull
+    @Override
+    public String getBlobMirrorServerDoneUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException {
+        return getBlobServerDoneUrl(false, blobId);
+    }
+
+    @Override
+    public String getAvatarServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getAvatarConfig().getUrl();
+    }
+
+    @Override
+    public String getSafeServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getSafeConfig().getUrl();
+    }
+
+    @Override
+    @Nullable
+    public String getWebServerUrl() throws ThreemaException {
+        OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
+
+        if (onPremConfigWeb != null) {
+            return onPremConfigWeb.getUrl();
+        }
+        throw new ThreemaException("Unable to fetch Threema Web server url");
+    }
+
+    @Override
+    public String getWebOverrideSaltyRtcHost() throws ThreemaException {
+        OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
+
+        if (onPremConfigWeb != null) {
+            return onPremConfigWeb.getOverrideSaltyRtcHost();
+        }
+        return null;
+    }
+
+    @Override
+    public int getWebOverrideSaltyRtcPort() throws ThreemaException {
+        OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
+
+        if (onPremConfigWeb != null) {
+            return onPremConfigWeb.getOverrideSaltyRtcPort();
+        }
+        return 0;
+    }
+
+    @Override
+    public byte[] getThreemaPushPublicKey() throws ThreemaException {
+        // TODO(ONPREM-164): Allow to configure for OnPrem
+        return null;
+    }
+
+    @NonNull
+    @Override
+    public String getMediatorUrl() throws ThreemaException {
+        OnPremConfigMediator onPremConfigMediator = getOnPremConfigFetcher().fetch().getMediatorConfig();
+
+        if (onPremConfigMediator == null) {
+            throw new ThreemaException("No mediator config available");
+        }
+        return Objects.requireNonNull(onPremConfigMediator.getUrl());
+    }
+
+    @NonNull
+    @Override
+    public String getAppRatingUrl() throws ThreemaException {
+        throw new ThreemaException("App rating is not supported in onprem");
+    }
+
+    private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
+        return fetcherProvider.getFetcher();
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java b/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java
index e87148ec..065716b0 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java
@@ -24,34 +24,79 @@ package ch.threema.domain.protocol;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
+import ch.threema.domain.protocol.blob.BlobScope;
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider;
 
 public interface ServerAddressProvider {
-	String getChatServerNamePrefix(boolean ipv6) throws ThreemaException;
-	String getChatServerNameSuffix(boolean ipv6) throws ThreemaException;
-	int[] getChatServerPorts() throws ThreemaException;
-	boolean getChatServerUseServerGroups() throws ThreemaException;
-	byte[] getChatServerPublicKey() throws ThreemaException;
-	byte[] getChatServerPublicKeyAlt() throws ThreemaException;
+    String getChatServerNamePrefix(boolean ipv6) throws ThreemaException;
 
-	String getDirectoryServerUrl(boolean ipv6) throws ThreemaException;
+    String getChatServerNameSuffix(boolean ipv6) throws ThreemaException;
 
-	String getWorkServerUrl(boolean ipv6) throws ThreemaException;
+    int[] getChatServerPorts() throws ThreemaException;
 
-	String getBlobServerDownloadUrl(boolean ipv6) throws ThreemaException;
-	String getBlobServerDoneUrl(boolean ipv6) throws ThreemaException;
-	String getBlobServerUploadUrl(boolean ipv6) throws ThreemaException;
+    boolean getChatServerUseServerGroups() throws ThreemaException;
 
-	String getAvatarServerUrl(boolean ipv6) throws ThreemaException;
+    byte[] getChatServerPublicKey() throws ThreemaException;
 
-	String getSafeServerUrl(boolean ipv6) throws ThreemaException;
-	String getWebServerUrl() throws ThreemaException;
-	String getWebOverrideSaltyRtcHost() throws ThreemaException;
-	int getWebOverrideSaltyRtcPort() throws ThreemaException;
-	@Nullable byte[] getThreemaPushPublicKey() throws ThreemaException;
+    byte[] getChatServerPublicKeyAlt() throws ThreemaException;
 
-	@NonNull
-	String getMediatorUrl() throws ThreemaException;
+    String getDirectoryServerUrl(boolean ipv6) throws ThreemaException;
 
-	@NonNull
-	String getAppRatingUrl() throws ThreemaException;
+    String getWorkServerUrl(boolean ipv6) throws ThreemaException;
+
+    @NonNull
+    String getBlobBaseUrlMirrorServer(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobServerDownloadUrl(
+        boolean useIpV6,
+        @NonNull byte[] blobId
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobServerUploadUrl(boolean useIpV6) throws ThreemaException;
+
+    @NonNull
+    String getBlobServerDoneUrl(
+        boolean useIpV6,
+        @NonNull byte[] blobId
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobMirrorServerDownloadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException, IllegalArgumentException;
+
+    @NonNull
+    String getBlobMirrorServerUploadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobMirrorServerDoneUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException, IllegalArgumentException;
+
+    String getAvatarServerUrl(boolean ipv6) throws ThreemaException;
+
+    String getSafeServerUrl(boolean ipv6) throws ThreemaException;
+
+    String getWebServerUrl() throws ThreemaException;
+
+    String getWebOverrideSaltyRtcHost() throws ThreemaException;
+
+    int getWebOverrideSaltyRtcPort() throws ThreemaException;
+
+    @Nullable
+    byte[] getThreemaPushPublicKey() throws ThreemaException;
+
+    @NonNull
+    String getMediatorUrl() throws ThreemaException;
+
+    @NonNull
+    String getAppRatingUrl() throws ThreemaException;
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/Version.java b/domain/src/main/java/ch/threema/domain/protocol/Version.java
index 9e5471ac..6a384574 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/Version.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/Version.java
@@ -25,11 +25,15 @@ public class Version {
 
 	private static final String VERSION = "0.2";
 
-	public String getVersion() {
+	public String getVersionNumber() {
+		return VERSION;
+	}
+
+	public String getVersionString() {
 		return VERSION + "J";
 	}
 
-	public String getFullVersion() {
+	public String getFullVersionString() {
 		return VERSION + ";J;;;" + System.getProperty("java.version");
 	}
 
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.java b/domain/src/main/java/ch/threema/domain/protocol/X509TrustManagerFactory.java
similarity index 65%
rename from domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.java
rename to domain/src/main/java/ch/threema/domain/protocol/X509TrustManagerFactory.java
index 85e7d43f..c2203925 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/X509TrustManagerFactory.java
@@ -19,13 +19,19 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.domain.protocol.csp.messages.ballot;
+package ch.threema.domain.protocol;
 
-import java.util.Collection;
-import java.util.List;
+import javax.net.ssl.X509TrustManager;
 
-public interface BallotVoteInterface extends BallotMessageInterface  {
-	List<BallotVote> getBallotVotes();
+import androidx.annotation.NonNull;
+import ch.threema.base.ThreemaException;
 
-	void addVotes(Collection<BallotVote> votes);
+/**
+ * A factory that creates a x509 trust manager (based on a hostname). Very java-esque :)
+ */
+@FunctionalInterface
+public interface X509TrustManagerFactory {
+
+    @NonNull
+    X509TrustManager makeX509TrustManager(@NonNull String hostname) throws ThreemaException;
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java b/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java
index 6dd30629..f5896cfb 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java
@@ -34,7 +34,6 @@ import org.json.JSONException;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStreamWriter;
@@ -80,9 +79,8 @@ import ch.threema.domain.stores.TokenStoreInterface;
 import ove.crypto.digest.Blake2b;
 
 /**
- * Fetches data and executes commands on the Threema API (such as creating a new
- * identity, fetching public keys for a given identity, linking e-mail addresses
- * and mobile phone numbers, etc.).
+ * Fetches data and executes commands on the Threema API (such as creating a new identity, fetching
+ * public keys for a given identity, linking e-mail addresses and mobile phone numbers, etc.).
  * <p>
  * All calls run synchronously; if necessary the caller should dispatch a separate thread.
  */
@@ -94,8 +92,18 @@ public class APIConnector {
     private static final String JSON_FIELD_DEPARTMENT = "department";
 
     // HMAC-SHA256 keys for contact matching
-    private static final byte[] EMAIL_HMAC_KEY = new byte[]{(byte) 0x30, (byte) 0xa5, (byte) 0x50, (byte) 0x0f, (byte) 0xed, (byte) 0x97, (byte) 0x01, (byte) 0xfa, (byte) 0x6d, (byte) 0xef, (byte) 0xdb, (byte) 0x61, (byte) 0x08, (byte) 0x41, (byte) 0x90, (byte) 0x0f, (byte) 0xeb, (byte) 0xb8, (byte) 0xe4, (byte) 0x30, (byte) 0x88, (byte) 0x1f, (byte) 0x7a, (byte) 0xd8, (byte) 0x16, (byte) 0x82, (byte) 0x62, (byte) 0x64, (byte) 0xec, (byte) 0x09, (byte) 0xba, (byte) 0xd7};
-    private static final byte[] MOBILENO_HMAC_KEY = new byte[]{(byte) 0x85, (byte) 0xad, (byte) 0xf8, (byte) 0x22, (byte) 0x69, (byte) 0x53, (byte) 0xf3, (byte) 0xd9, (byte) 0x6c, (byte) 0xfd, (byte) 0x5d, (byte) 0x09, (byte) 0xbf, (byte) 0x29, (byte) 0x55, (byte) 0x5e, (byte) 0xb9, (byte) 0x55, (byte) 0xfc, (byte) 0xd8, (byte) 0xaa, (byte) 0x5e, (byte) 0xc4, (byte) 0xf9, (byte) 0xfc, (byte) 0xd8, (byte) 0x69, (byte) 0xe2, (byte) 0x58, (byte) 0x37, (byte) 0x07, (byte) 0x23};
+    private static final byte[] EMAIL_HMAC_KEY = new byte[]{(byte) 0x30, (byte) 0xa5, (byte) 0x50
+		    , (byte) 0x0f, (byte) 0xed, (byte) 0x97, (byte) 0x01, (byte) 0xfa, (byte) 0x6d,
+		    (byte) 0xef, (byte) 0xdb, (byte) 0x61, (byte) 0x08, (byte) 0x41, (byte) 0x90,
+		    (byte) 0x0f, (byte) 0xeb, (byte) 0xb8, (byte) 0xe4, (byte) 0x30, (byte) 0x88,
+		    (byte) 0x1f, (byte) 0x7a, (byte) 0xd8, (byte) 0x16, (byte) 0x82, (byte) 0x62,
+		    (byte) 0x64, (byte) 0xec, (byte) 0x09, (byte) 0xba, (byte) 0xd7};
+    private static final byte[] MOBILENO_HMAC_KEY = new byte[]{(byte) 0x85, (byte) 0xad,
+		    (byte) 0xf8, (byte) 0x22, (byte) 0x69, (byte) 0x53, (byte) 0xf3, (byte) 0xd9,
+		    (byte) 0x6c, (byte) 0xfd, (byte) 0x5d, (byte) 0x09, (byte) 0xbf, (byte) 0x29,
+		    (byte) 0x55, (byte) 0x5e, (byte) 0xb9, (byte) 0x55, (byte) 0xfc, (byte) 0xd8,
+		    (byte) 0xaa, (byte) 0x5e, (byte) 0xc4, (byte) 0xf9, (byte) 0xfc, (byte) 0xd8,
+		    (byte) 0x69, (byte) 0xe2, (byte) 0x58, (byte) 0x37, (byte) 0x07, (byte) 0x23};
 
     private static final int DEFAULT_MATCH_CHECK_INTERVAL = 86400;
     private static final int RESPONSE_LEN = 32;
@@ -215,8 +223,7 @@ public class APIConnector {
     }
 
     /**
-     * Fetch identity-related information (public key) for
-     * a given identity.
+     * Fetch identity-related information (public key) for a given identity.
      *
      * @param identity the desired identity
      * @return information related to identity
@@ -224,7 +231,8 @@ public class APIConnector {
      * @throws HttpConnectionException on http error
      * @throws NetworkException        on network error
      */
-    public FetchIdentityResult fetchIdentity(String identity) throws ThreemaException, NetworkException, HttpConnectionException {
+    public FetchIdentityResult fetchIdentity(String identity) throws ThreemaException,
+		    NetworkException, HttpConnectionException {
         try {
             String responseStr = doGet(getServerUrl() + "identity/" + identity);
             JSONObject jsonResponse = new JSONObject(responseStr);
@@ -247,39 +255,44 @@ public class APIConnector {
      *
      * @param identities the desired identities
      * @return array list of information related to identity
-     * @throws FileNotFoundException if identity not found
-     * @throws Exception             on network error
+     * @throws ThreemaException         if the server url cannot be fetched on onprem builds
+     * @throws IllegalArgumentException if the argument is null or empty
+     * @throws NetworkException         on network error
      */
-    public ArrayList<FetchIdentityResult> fetchIdentities(List<String> identities) throws Exception {
-        if (identities == null || identities.size() < 1) {
-            throw new ThreemaException("empty identities array");
+    public List<FetchIdentityResult> fetchIdentities(List<String> identities) throws ThreemaException, NetworkException {
+        if (identities == null || identities.isEmpty()) {
+            throw new IllegalArgumentException("empty identities array");
         }
 
-        JSONObject postObject = new JSONObject();
-        postObject.put("identities", new JSONArray(identities));
-        String postResponse = this.postJson(getServerUrl() + "identity/fetch_bulk", postObject);
-
-        if (postResponse == null) {
-            throw new ThreemaException("no valid response or network error");
-        }
-
-        JSONObject resultObject = new JSONObject(postResponse);
-        JSONArray resultArray = resultObject.getJSONArray("identities");
+        try {
+            JSONObject postObject = new JSONObject();
+            postObject.put("identities", new JSONArray(identities));
+            String postResponse = this.postJson(getServerUrl() + "identity/fetch_bulk", postObject);
 
-        ArrayList<FetchIdentityResult> fetchIdentityResults = new ArrayList<>();
-        for (int i = 0; i < resultArray.length(); i++) {
-            JSONObject jsonResponse = resultArray.getJSONObject(i);
-            FetchIdentityResult fetchIdentityResult = new FetchIdentityResult();
-            fetchIdentityResult.publicKey = Base64.decode(jsonResponse.getString("publicKey"));
-            fetchIdentityResult.featureLevel = jsonResponse.optInt("featureLevel");
-            fetchIdentityResult.featureMask = jsonResponse.optInt("featureMask");
-            fetchIdentityResult.identity = jsonResponse.getString("identity");
-            fetchIdentityResult.state = jsonResponse.optInt("state");
-            fetchIdentityResult.type = jsonResponse.optInt("type");
+            if (postResponse == null) {
+                throw new NetworkException("no valid response or network error");
+            }
 
-            fetchIdentityResults.add(fetchIdentityResult);
+            JSONObject resultObject = new JSONObject(postResponse);
+            JSONArray resultArray = resultObject.getJSONArray("identities");
+
+            List<FetchIdentityResult> fetchIdentityResults = new ArrayList<>();
+            for (int i = 0; i < resultArray.length(); i++) {
+                JSONObject jsonResponse = resultArray.getJSONObject(i);
+                FetchIdentityResult fetchIdentityResult = new FetchIdentityResult();
+                fetchIdentityResult.publicKey = Base64.decode(jsonResponse.getString("publicKey"));
+                fetchIdentityResult.featureLevel = jsonResponse.optInt("featureLevel");
+                fetchIdentityResult.featureMask = jsonResponse.optInt("featureMask");
+                fetchIdentityResult.identity = jsonResponse.getString("identity");
+                fetchIdentityResult.state = jsonResponse.optInt("state");
+                fetchIdentityResult.type = jsonResponse.optInt("type");
+
+                fetchIdentityResults.add(fetchIdentityResult);
+            }
+            return fetchIdentityResults;
+        } catch (JSONException | IOException e) {
+            throw new NetworkException(e);
         }
-        return fetchIdentityResults;
     }
 
     /**
@@ -329,8 +342,8 @@ public class APIConnector {
 
     /**
      * Link an e-mail address with the identity from the given store. The user gets a verification
-     * e-mail with a link. {@link #linkEmailCheckStatus(String, IdentityStoreInterface)} should be called
-     * to check whether the user has already confirmed.
+     * e-mail with a link. {@link #linkEmailCheckStatus(String, IdentityStoreInterface)} should be
+     * called to check whether the user has already confirmed.
      * <p>
      * To unlink, pass an empty string as the e-mail address. In that case, checking status is not
      * necessary as the unlink operation does not need e-mail verification.
@@ -339,7 +352,8 @@ public class APIConnector {
      * @param language      language for confirmation e-mail, ISO-639-1 (e.g. "de", "en", "fr")
      * @param identityStore identity store for authentication of request
      * @return true if e-mail address is accepted for verification, false if already linked
-     * @throws LinkEmailException if the server reports an error (should be displayed to the user verbatim)
+     * @throws LinkEmailException if the server reports an error (should be displayed to the user
+     *                            verbatim)
      * @throws Exception          if a network error occurs
      */
     public boolean linkEmail(String email, String language, IdentityStoreInterface identityStore) throws LinkEmailException, Exception {
@@ -379,8 +393,8 @@ public class APIConnector {
     }
 
     /**
-     * Check whether a given e-mail address is already linked to the identity (i.e. the user
-     * has confirmed the verification mail).
+     * Check whether a given e-mail address is already linked to the identity (i.e. the user has
+     * confirmed the verification mail).
      *
      * @param email         e-mail address to be linked
      * @param identityStore identity store for authentication of request
@@ -402,27 +416,33 @@ public class APIConnector {
     }
 
     /**
-     * Link a mobile phone number with the identity from the given store. The user gets a verification code via
-     * SMS; this code should be passed to {@link #linkMobileNoVerify(String, String)} along with the verification ID
-     * returned by this method to complete the operation.
+     * Link a mobile phone number with the identity from the given store. The user gets a
+     * verification code via SMS; this code should be passed to
+     * {@link #linkMobileNoVerify(String, String)} along with the verification ID returned by this
+     * method to complete the operation.
      * <p>
      * To unlink, pass an empty string as the mobile number.
      *
      * @param mobileNo      mobile phone number in E.164 format without + (e.g. 41791234567)
      * @param language      language for SMS text, ISO-639-1 (e.g. "de", "en", "fr")
      * @param identityStore identity store for authentication of request
-     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)}, or null if verification is already complete
-     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user verbatim)
+     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)},
+     * or null if verification is already complete
+     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user
+     *                               verbatim)
      * @throws Exception             if a network error occurs
      */
-    public String linkMobileNo(String mobileNo, String language, IdentityStoreInterface identityStore) throws LinkMobileNoException, Exception {
+    public String linkMobileNo(String mobileNo, String language,
+                               IdentityStoreInterface identityStore) throws LinkMobileNoException
+		    , Exception {
         return this.linkMobileNo(mobileNo, language, identityStore, null);
     }
 
     /**
-     * Link a mobile phone number with the identity from the given store. The user gets a verification code via
-     * SMS; this code should be passed to {@link #linkMobileNoVerify(String, String)} along with the verification ID
-     * returned by this method to complete the operation.
+     * Link a mobile phone number with the identity from the given store. The user gets a
+     * verification code via SMS; this code should be passed to
+     * {@link #linkMobileNoVerify(String, String)} along with the verification ID returned by this
+     * method to complete the operation.
      * <p>
      * To unlink, pass an empty string as the mobile number.
      *
@@ -430,11 +450,14 @@ public class APIConnector {
      * @param language      language for SMS text, ISO-639-1 (e.g. "de", "en", "fr")
      * @param identityStore identity store for authentication of request
      * @param urlScheme     optional parameter (url schema of the verification link)
-     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)}, or null if verification is already complete
-     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user verbatim)
+     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)},
+     * or null if verification is already complete
+     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user
+     *                               verbatim)
      * @throws Exception             if a network error occurs
      */
-    public String linkMobileNo(String mobileNo, String language, IdentityStoreInterface identityStore, String urlScheme) throws LinkMobileNoException, Exception {
+    public String linkMobileNo(String mobileNo, String language,
+                               IdentityStoreInterface identityStore, String urlScheme) throws LinkMobileNoException, Exception {
         String url = getServerUrl() + "identity/link_mobileno";
 
         // Phase 1: send identity and mobile no
@@ -480,9 +503,11 @@ public class APIConnector {
     /**
      * Complete verification of mobile number link.
      *
-     * @param verificationId the verification ID returned by {@link #linkMobileNo(String, String, IdentityStoreInterface)}
+     * @param verificationId the verification ID returned by
+     *                       {@link #linkMobileNo(String, String, IdentityStoreInterface)}
      * @param code           the SMS code (usually 6 digits)
-     * @throws LinkMobileNoException if the server reports an error, e.g. wrong code or too many attempts (should be displayed to the user verbatim)
+     * @throws LinkMobileNoException if the server reports an error, e.g. wrong code or too many
+     *                               attempts (should be displayed to the user verbatim)
      * @throws Exception             if a network error occurs
      */
     public void linkMobileNoVerify(String verificationId, String code) throws LinkMobileNoException, Exception {
@@ -500,12 +525,16 @@ public class APIConnector {
     }
 
     /**
-     * Trigger a phone call for the given verification ID. This should only be done if the SMS doesn't arrive
-     * in a normal amount of time (e.g. 10 minutes). The verification code will be read to the user twice,
-     * and {@link #linkMobileNoVerify(String, String)} should then be called with the code.
+     * Trigger a phone call for the given verification ID. This should only be done if the SMS
+     * doesn't arrive in a normal amount of time (e.g. 10 minutes). The verification code will be
+     * read to the user twice, and {@link #linkMobileNoVerify(String, String)} should then be called
+     * with the code.
      *
-     * @param verificationId verification ID returned from {@link #linkMobileNo(String, String, IdentityStoreInterface)}
-     * @throws LinkMobileNoException if the server reports an error, e.g. unable to call the destination, already called etc. (should be displayed to the user verbatim)
+     * @param verificationId verification ID returned from
+     *                       {@link #linkMobileNo(String, String, IdentityStoreInterface)}
+     * @throws LinkMobileNoException if the server reports an error, e.g. unable to call the
+     *                               destination, already called etc. (should be displayed to the
+     *                               user verbatim)
      * @throws Exception             if a network error occurs
      */
     public void linkMobileNoCall(String verificationId) throws LinkMobileNoException, Exception {
@@ -522,23 +551,28 @@ public class APIConnector {
     }
 
     /**
-     * Find identities that have been linked with the given e-mail addresses and/or mobile phone numbers.
-     * The mobile phone numbers can be provided in national or international format, as they will be automatically
-     * passed through libphonenumber (which also takes care of spaces, brackets etc.).
+     * Find identities that have been linked with the given e-mail addresses and/or mobile phone
+     * numbers. The mobile phone numbers can be provided in national or international format, as
+     * they will be automatically passed through libphonenumber (which also takes care of spaces,
+     * brackets etc.).
      * <p>
-     * The server also returns its desired check interval to the {@code APIConnector} object during this call.
-     * The caller should use {@link #getMatchCheckInterval()} to determine the earliest time for the next call
-     * after this call. This is important so that the server can request longer intervals from its clients during
-     * periods of heavy traffic or temporary capacity problems.
+     * The server also returns its desired check interval to the {@code APIConnector} object during
+     * this call. The caller should use {@link #getMatchCheckInterval()} to determine the earliest
+     * time for the next call after this call. This is important so that the server can request
+     * longer intervals from its clients during periods of heavy traffic or temporary capacity
+     * problems.
      *
-     * @param emails          map of e-mail addresses (key = e-mail, value = arbitrary object for reference that is returned with any found identities)
-     * @param mobileNos       map of phone numbers (key = phone number, value = arbitrary object for reference that is returned with any found identities)
-     * @param userCountry     the user's home country (for correct interpretation of national phone numbers), ISO 3166-1, e.g. "CH" (or null to disable normalization)
+     * @param emails          map of e-mail addresses (key = e-mail, value = arbitrary object for
+     *                        reference that is returned with any found identities)
+     * @param mobileNos       map of phone numbers (key = phone number, value = arbitrary object for
+     *                        reference that is returned with any found identities)
+     * @param userCountry     the user's home country (for correct interpretation of national phone
+     *                        numbers), ISO 3166-1, e.g. "CH" (or null to disable normalization)
      * @param includeInactive if true, inactive IDs will be included in the results also
      * @param identityStore   identity store to use for obtaining match token
      * @param matchTokenStore for storing match token for reuse (may be null)
-     * @return map of found identities (key = identity). The value objects from the {@code emails} and {@code mobileNos} parameters
-     * will be returned in {@code refObject}.
+     * @return map of found identities (key = identity). The value objects from the {@code emails}
+     * and {@code mobileNos} parameters will be returned in {@code refObject}.
      */
     @SuppressLint("DefaultLocale")
     public Map<String, MatchIdentityResult> matchIdentities(
@@ -557,7 +591,8 @@ public class APIConnector {
 
         for (Map.Entry<String, ?> entry : emails.entrySet()) {
             String normalizedEmail = entry.getKey().toLowerCase().trim();
-            byte[] emailHash = emailMac.doFinal(normalizedEmail.getBytes(StandardCharsets.US_ASCII));
+            byte[] emailHash =
+		            emailMac.doFinal(normalizedEmail.getBytes(StandardCharsets.US_ASCII));
             emailHashes.put(Base64.encodeBytes(emailHash), entry.getValue());
 
             // Gmail address? If so, hash with the other domain as well
@@ -569,7 +604,8 @@ public class APIConnector {
             }
 
             if (normalizedEmailAlt != null) {
-                byte[] emailHashAlt = emailMac.doFinal(normalizedEmailAlt.getBytes(StandardCharsets.US_ASCII));
+                byte[] emailHashAlt =
+		                emailMac.doFinal(normalizedEmailAlt.getBytes(StandardCharsets.US_ASCII));
                 emailHashes.put(Base64.encodeBytes(emailHashAlt), entry.getValue());
             }
         }
@@ -589,14 +625,17 @@ public class APIConnector {
             try {
                 String normalizedMobileNo;
                 if (phoneNumberUtil != null) {
-                    Phonenumber.PhoneNumber phoneNumber = phoneNumberUtil.parse(entry.getKey(), userCountry);
-                    String normalizedMobileNoWithPlus = phoneNumberUtil.format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164);
+                    Phonenumber.PhoneNumber phoneNumber = phoneNumberUtil.parse(entry.getKey(),
+		                    userCountry);
+                    String normalizedMobileNoWithPlus = phoneNumberUtil.format(phoneNumber,
+		                    PhoneNumberUtil.PhoneNumberFormat.E164);
                     normalizedMobileNo = normalizedMobileNoWithPlus.replace("+", "");
                 } else {
                     normalizedMobileNo = entry.getKey().replaceAll("[^0-9]", "");
                 }
 
-                byte[] mobileNoHash = mobileNoMac.doFinal(normalizedMobileNo.getBytes(StandardCharsets.US_ASCII));
+                byte[] mobileNoHash =
+		                mobileNoMac.doFinal(normalizedMobileNo.getBytes(StandardCharsets.US_ASCII));
                 mobileNoHashes.put(Base64.encodeBytes(mobileNoHash), entry.getValue());
             } catch (NumberParseException e) {
                 // Skip/ignore this number
@@ -604,7 +643,8 @@ public class APIConnector {
             }
         }
 
-        return matchIdentitiesHashed(emailHashes, mobileNoHashes, includeInactive, identityStore, matchTokenStore);
+        return matchIdentitiesHashed(emailHashes, mobileNoHashes, includeInactive, identityStore,
+		        matchTokenStore);
     }
 
     public Map<String, MatchIdentityResult> matchIdentitiesHashed(
@@ -616,12 +656,14 @@ public class APIConnector {
     ) throws Exception {
         String matchToken = obtainMatchToken(identityStore, matchTokenStore, false);
         try {
-            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive, matchToken);
+            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive,
+		            matchToken);
         } catch (Exception e) {
             // Match token may be invalid/expired, refresh and try again
             logger.debug("Match failed", e);
             matchToken = obtainMatchToken(identityStore, matchTokenStore, true);
-            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive, matchToken);
+            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive,
+		            matchToken);
         }
     }
 
@@ -647,7 +689,8 @@ public class APIConnector {
         logger.debug(String.format("Match identities: sending to server: %s", request.toString()));
 
         JSONObject result = new JSONObject(postJson(url, request));
-        logger.debug(String.format("Match identities: response from server: %s", result.toString()));
+        logger.debug(String.format("Match identities: response from server: %s",
+		        result.toString()));
 
         matchCheckInterval = result.getInt("checkInterval");
         logger.debug("Server requested check interval of {} seconds", matchCheckInterval);
@@ -681,8 +724,8 @@ public class APIConnector {
      *
      * @param identityStore   Obtain a match token for the identity stored in this identity store.
      * @param matchTokenStore Optional cache used to store match tokens after lookup.
-     * @param forceRefresh    If set to true, then a match token will always be re-fetched.
-     *                        The `matchTokenStore` cache will be ignored.
+     * @param forceRefresh    If set to true, then a match token will always be re-fetched. The
+     *                        `matchTokenStore` cache will be ignored.
      * @return The match token as string
      */
     private String obtainMatchToken(
@@ -734,7 +777,8 @@ public class APIConnector {
      * Obtain an authentication token (for OnPrem only).
      *
      * @param authTokenStore the token store to use for caching the token
-     * @param forceRefresh   if true, a new token is always requested even if one is currently cached
+     * @param forceRefresh   if true, a new token is always requested even if one is currently
+     *                       cached
      * @return The authentication token
      */
     public String obtainAuthToken(
@@ -770,7 +814,8 @@ public class APIConnector {
      * <p>
      * The token will be prefixed with `3ma;`.
      *
-     * @param identityStore Obtain a Threema Push token for the identity stored in this identity store.
+     * @param identityStore Obtain a Threema Push token for the identity stored in this identity
+     *                      store.
      * @return The match token as string
      */
     public @NonNull String obtainThreemaPushToken(
@@ -867,7 +912,8 @@ public class APIConnector {
      *
      * @param featureMask   feature mask of the current identity
      * @param identityStore identity store for authentication of request
-     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user verbatim)
+     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user
+     *                               verbatim)
      * @throws Exception             if a network error occurs
      */
     public void setFeatureMask(long featureMask, IdentityStoreInterface identityStore) throws Exception {
@@ -960,7 +1006,8 @@ public class APIConnector {
     /**
      * Set the revocation key for the stored identity
      */
-    public SetRevocationKeyResult setRevocationKey(IdentityStoreInterface identityStore, String revocationKey) throws Exception {
+    public SetRevocationKeyResult setRevocationKey(IdentityStoreInterface identityStore,
+                                                   String revocationKey) throws Exception {
 
         // Calculate key
         MessageDigest md = MessageDigest.getInstance("SHA-256");
@@ -993,8 +1040,8 @@ public class APIConnector {
     }
 
     /**
-     * This call is used to check a list of IDs and determine the status of each ID.
-     * The response contains a list of status codes, one for each ID in the same order as in the request.
+     * This call is used to check a list of IDs and determine the status of each ID. The response
+     * contains a list of status codes, one for each ID in the same order as in the request.
      */
     public CheckIdentityStatesResult checkIdentityStates(String[] identities) throws Exception {
         String url = getServerUrl() + "identity/check";
@@ -1078,13 +1125,15 @@ public class APIConnector {
         }
 
         String[] turnUrls = jsonArrayToStringArray(p2Result.getJSONArray("turnUrls"));
-        String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray("turnUrlsDualStack"));
+        String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray(
+				"turnUrlsDualStack"));
         String turnUsername = p2Result.getString("turnUsername");
         String turnPassword = p2Result.getString("turnPassword");
         int expiration = p2Result.getInt("expiration");
         Date expirationDate = new Date(new Date().getTime() + expiration * 1000L);
 
-        return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword, expirationDate);
+        return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword,
+		        expirationDate);
     }
 
     /**
@@ -1095,7 +1144,8 @@ public class APIConnector {
      * @param senderNickname Nickname of sender, if known
      * @throws Exception If junk report could not be sent
      */
-    public void reportJunk(IdentityStoreInterface identityStore, @NonNull String senderIdentity, @Nullable String senderNickname) throws Exception {
+    public void reportJunk(IdentityStoreInterface identityStore, @NonNull String senderIdentity,
+                           @Nullable String senderNickname) throws Exception {
         if (identityStore == null || identityStore.getIdentity() == null || identityStore.getIdentity().isEmpty()) {
             return;
         }
@@ -1181,7 +1231,7 @@ public class APIConnector {
     private CheckLicenseResult checkLicense(JSONObject request, String deviceId) throws Exception {
         String url = getServerUrl() + "check_license";
         request.put("deviceId", deviceId);
-        request.put("version", version.getFullVersion());
+        request.put("version", version.getFullVersionString());
         request.put("arch", version.getArchitecture());
 
         JSONObject result = new JSONObject(this.postJson(url, request));
@@ -1222,7 +1272,8 @@ public class APIConnector {
         }
         request.put("contacts", identityArray);
 
-        PostJsonResult postJsonResult = this.postJsonWithResult(getWorkServerUrl() + "fetch2", request);
+        PostJsonResult postJsonResult = this.postJsonWithResult(getWorkServerUrl() + "fetch2",
+		        request);
         if (postJsonResult.responseCode > 0 || postJsonResult.responseBody == null || postJsonResult.responseBody.length() == 0) {
             workData.responseCode = postJsonResult.responseCode;
             return workData;
@@ -1260,8 +1311,10 @@ public class APIConnector {
                             Base64.decode(contact.getString("pk")),
                             contact.has("first") ? contact.getString("first") : null,
                             contact.has("last") ? contact.getString("last") : null,
-                            contact.has(JSON_FIELD_JOB_TITLE) ? contact.getString(JSON_FIELD_JOB_TITLE) : null,
-                            contact.has(JSON_FIELD_DEPARTMENT) ? contact.getString(JSON_FIELD_DEPARTMENT) : null
+                            contact.has(JSON_FIELD_JOB_TITLE) ?
+		                            contact.getString(JSON_FIELD_JOB_TITLE) : null,
+                            contact.has(JSON_FIELD_DEPARTMENT) ?
+		                            contact.getString(JSON_FIELD_DEPARTMENT) : null
                         )
                     );
                 }
@@ -1290,7 +1343,8 @@ public class APIConnector {
         JSONObject jsonResponseOrganization = jsonResponse.optJSONObject("org");
         if (jsonResponseOrganization != null) {
             workData.organization.name =
-                jsonResponseOrganization.isNull("name") ? null : jsonResponseOrganization.optString("name");
+                jsonResponseOrganization.isNull("name") ? null :
+		                jsonResponseOrganization.optString("name");
         }
 
         JSONObject directory = jsonResponse.optJSONObject("directory");
@@ -1319,7 +1373,8 @@ public class APIConnector {
      * @param username   Threema Work license username
      * @param password   Threema Work license password
      * @param identities List of Threema IDs to check
-     * @return List of valid threema work contacts - empty list if there are no matching contacts in this package.
+     * @return List of valid threema work contacts - empty list if there are no matching contacts in
+     * this package.
      */
     @NonNull
     public List<WorkContact> fetchWorkContacts(
@@ -1361,8 +1416,10 @@ public class APIConnector {
                             Base64.decode(contact.getString("pk")),
                             contact.isNull("first") ? null : contact.getString("first"),
                             contact.isNull("last") ? null : contact.getString("last"),
-                            contact.isNull(JSON_FIELD_JOB_TITLE) ? null : contact.getString(JSON_FIELD_JOB_TITLE),
-                            contact.isNull(JSON_FIELD_DEPARTMENT) ? null : contact.getString(JSON_FIELD_DEPARTMENT)
+                            contact.isNull(JSON_FIELD_JOB_TITLE) ? null :
+		                            contact.getString(JSON_FIELD_JOB_TITLE),
+                            contact.isNull(JSON_FIELD_DEPARTMENT) ? null :
+		                            contact.getString(JSON_FIELD_DEPARTMENT)
                         )
                     );
                 }
@@ -1467,18 +1524,27 @@ public class APIConnector {
                     WorkDirectoryContact directoryContact = new WorkDirectoryContact(
                         contact.getString("id"),
                         Base64.decode(contact.getString("pk")),
-                        contact.has("first") ? (contact.isNull("first") ? null : contact.optString("first")) : null,
-                        contact.has("last") ? (contact.isNull("last") ? null : contact.optString("last")) : null,
-                        contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString("csi")) : null,
-                        contact.has(JSON_FIELD_JOB_TITLE) ? (contact.isNull(JSON_FIELD_JOB_TITLE) ? null : contact.optString(JSON_FIELD_JOB_TITLE)) : null,
-                        contact.has(JSON_FIELD_DEPARTMENT) ? (contact.isNull(JSON_FIELD_DEPARTMENT) ? null : contact.optString(JSON_FIELD_DEPARTMENT)) : null
+                        contact.has("first") ? (contact.isNull("first") ? null :
+		                        contact.optString("first")) : null,
+                        contact.has("last") ? (contact.isNull("last") ? null : contact.optString(
+								"last")) : null,
+                        contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString(
+								"csi")) : null,
+                        contact.has(JSON_FIELD_JOB_TITLE) ?
+		                        (contact.isNull(JSON_FIELD_JOB_TITLE) ? null :
+				                        contact.optString(JSON_FIELD_JOB_TITLE)) : null,
+                        contact.has(JSON_FIELD_DEPARTMENT) ?
+		                        (contact.isNull(JSON_FIELD_DEPARTMENT) ? null :
+				                        contact.optString(JSON_FIELD_DEPARTMENT)) : null
                     );
 
                     if (!contact.isNull("org")) {
                         JSONObject jsonResponseOrganization = contact.optJSONObject("org");
 
-                        if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull("name")) {
-                            directoryContact.organization.name = jsonResponseOrganization.optString("name");
+                        if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull(
+								"name")) {
+                            directoryContact.organization.name =
+		                            jsonResponseOrganization.optString("name");
                         }
                     }
 
@@ -1572,16 +1638,16 @@ public class APIConnector {
     /**
      * Get the full app version.
      * <p>
-     * If provided also append the mdm source to the version.
-     * This might seem to not be the appropriate location for this information
-     * but has been specified in ANDR-2213 and "Update Work Info" in documentation.
+     * If provided also append the mdm source to the version. This might seem to not be the
+     * appropriate location for this information but has been specified in ANDR-2213 and "Update
+     * Work Info" in documentation.
      *
      * @param mdmSource The source(s) of the active mdm parameters
      * @return The version string
      */
     @NonNull
     private String getUpdateWorkInfoVersion(@Nullable String mdmSource) {
-        StringBuilder updateWorkInfoVersion = new StringBuilder(version.getFullVersion());
+        StringBuilder updateWorkInfoVersion = new StringBuilder(version.getFullVersionString());
         if (mdmSource != null) {
             updateWorkInfoVersion.append(";");
             updateWorkInfoVersion.append(mdmSource);
@@ -1619,7 +1685,8 @@ public class APIConnector {
         urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000);
         urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000);
         urlConnection.setRequestMethod("GET");
-        urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
+        urlConnection.setRequestProperty("User-Agent",
+		        ProtocolStrings.USER_AGENT + "/" + version.getVersionString());
         if (language != null) {
             urlConnection.setRequestProperty("Accept-Language", language);
         }
@@ -1645,8 +1712,8 @@ public class APIConnector {
     /**
      * Send a HTTP POST request with the specified body to the specified URL.
      * <p>
-     * The `Content-Type` header will be set to `application/json`, and the `User-Agent`
-     * will be set appropriately as well.
+     * The `Content-Type` header will be set to `application/json`, and the `User-Agent` will be set
+     * appropriately as well.
      *
      * @param urlStr The target URL
      * @param body   The request body
@@ -1664,12 +1731,13 @@ public class APIConnector {
     /**
      * Send a HTTP POST request with the specified body to the specified URL.
      * <p>
-     * The `Content-Type` header will be set to `application/json`, and the `User-Agent`
-     * will be set appropriately as well.
+     * The `Content-Type` header will be set to `application/json`, and the `User-Agent` will be set
+     * appropriately as well.
      *
      * @param urlStr The target URL
      * @param body   The request body
-     * @return A PostJsonResult object containing the response body, UTF-8 decoded and the server's response code
+     * @return A PostJsonResult object containing the response body, UTF-8 decoded and the server's
+     * response code
      */
     @NonNull
     protected PostJsonResult postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException {
@@ -1683,7 +1751,8 @@ public class APIConnector {
         urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000);
         urlConnection.setRequestMethod("POST");
         urlConnection.setRequestProperty("Content-Type", "application/json");
-        urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion());
+        urlConnection.setRequestProperty("User-Agent",
+		        ProtocolStrings.USER_AGENT + "/" + this.version.getVersionString());
         if (this.language != null) {
             urlConnection.setRequestProperty("Accept-Language", this.language);
         }
@@ -1695,7 +1764,8 @@ public class APIConnector {
 
         try {
             // Send request
-            try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) {
+            try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(),
+		            StandardCharsets.UTF_8)) {
                 osw.write(body.toString());
             }
 
@@ -1713,8 +1783,8 @@ public class APIConnector {
     }
 
     /**
-     * Create a token response for a two-phase API request by updating
-     * the original request JSON object.
+     * Create a token response for a two-phase API request by updating the original request JSON
+     * object.
      *
      * @param p1Result      Phase 1 response.
      * @param request       Phase 1 request. This request will be updated with the signed token.
@@ -1739,7 +1809,7 @@ public class APIConnector {
     }
 
     public @Nullable APIConnector.FetchIdentityResult getFetchResultByIdentity(
-        ArrayList<APIConnector.FetchIdentityResult> results,
+        List<APIConnector.FetchIdentityResult> results,
         String identity
     ) {
         if (identity != null) {
@@ -1847,7 +1917,8 @@ public class APIConnector {
         public final String turnPassword;
         public final Date expirationDate;
 
-        public TurnServerInfo(String[] turnUrls, String[] turnUrlsDualStack, String turnUsername, String turnPassword, Date expirationDate) {
+        public TurnServerInfo(String[] turnUrls, String[] turnUrlsDualStack, String turnUsername,
+                              String turnPassword, Date expirationDate) {
             this.turnUrls = turnUrls;
             this.turnUrlsDualStack = turnUrlsDualStack;
             this.turnUsername = turnUsername;
@@ -1860,6 +1931,10 @@ public class APIConnector {
         public NetworkException(Throwable cause) {
             super(cause);
         }
+
+        public NetworkException(@Nullable String msg) {
+            super(msg);
+        }
     }
 
     public static class HttpConnectionException extends Exception {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java
index b7a14c5b..fcd8c2ec 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java
@@ -21,21 +21,22 @@
 
 package ch.threema.domain.protocol.api.work;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 public class WorkContact {
-    public final String firstName;
-    public final String lastName;
-    public final byte[] publicKey;
-    public final String threemaId;
+    public final @Nullable String firstName;
+    public final @Nullable String lastName;
+    public final @NonNull byte[] publicKey;
+    public final @NonNull String threemaId;
     public final @Nullable String jobTitle;
     public final @Nullable String department;
 
     public WorkContact(
-        String threemaId,
-        byte[] publicKey,
-        String firstName,
-        String lastName,
+        @NonNull String threemaId,
+        @NonNull byte[] publicKey,
+        @Nullable String firstName,
+        @Nullable String lastName,
         @Nullable String jobTitle,
         @Nullable String department
     ) {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java
index 7f810974..c4d9d79a 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java
@@ -24,19 +24,21 @@ package ch.threema.domain.protocol.api.work;
 import java.util.ArrayList;
 import java.util.List;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 public class WorkDirectoryContact extends WorkContact {
+    @Nullable
     public final String csi;
     public final List<String> categoryIds = new ArrayList<>();
     public final WorkOrganization organization = new WorkOrganization();
 
     public WorkDirectoryContact(
-        String threemaId,
-        byte[] publicKey,
-        String firstName,
-        String lastName,
-        String csi,
+        @NonNull String threemaId,
+        @NonNull byte[] publicKey,
+        @Nullable String firstName,
+        @Nullable String lastName,
+        @Nullable String csi,
         @Nullable String jobTitle,
         @Nullable String department
     ) {
@@ -55,7 +57,7 @@ public class WorkDirectoryContact extends WorkContact {
                 (firstName != null ? firstName : "");
         }
 
-        if (name.length() > 0) {
+        if (!name.isEmpty()) {
             return name.substring(0, 1);
         }
         return " ";
diff --git a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.java b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.java
deleted file mode 100644
index 3336f0ec..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.blob;
-
-import org.apache.commons.io.IOUtils;
-import org.slf4j.Logger;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-import javax.net.ssl.HttpsURLConnection;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.base.utils.Utils;
-import ch.threema.domain.protocol.SSLSocketFactoryFactory;
-import ch.threema.base.ProgressListener;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.ProtocolStrings;
-import ch.threema.domain.protocol.ServerAddressProvider;
-import ch.threema.domain.protocol.Version;
-
-/**
- * Helper class that loads blobs (images, videos etc.) from the blob server given a blob ID. No
- * processing is done on the loaded data; any decryption etc. must be done separately.
- */
-public class BlobLoader {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BlobLoader");
-
-	private static final int BUFFER_SIZE = 8192;
-
-	private final @NonNull SSLSocketFactoryFactory factory;
-	private final ServerAddressProvider serverAddressProvider;
-	private final boolean ipv6;
-
-	private final byte[] blobId;
-
-	private volatile boolean cancel;
-	private ProgressListener progressListener;
-	private Version version;
-
-	public BlobLoader(@NonNull SSLSocketFactoryFactory factory, byte[] blobId, boolean ipv6, ServerAddressProvider serverAddressProvider, ProgressListener progressListener) {
-		this.factory = factory;
-		this.blobId = blobId;
-		this.progressListener = progressListener;
-		this.version = new Version();
-		this.ipv6 = ipv6;
-		this.serverAddressProvider = serverAddressProvider;
-	}
-
-	/**
-	 * Attempt to load the given blob.
-	 *
-	 * @param markAsDone if true, the server is informed of successful download and will delete the
-	 * blob. Do not use for group messages.
-	 * @return blob data or null if download was cancelled
-	 */
-	public @Nullable byte[] load(boolean markAsDone) throws IOException, ThreemaException {
-
-		cancel = false;
-
-		InputStreamLength isl = getInputStream();
-
-		int read;
-		byte[] blob;
-		byte[] buffer = new byte[BUFFER_SIZE];
-		ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-		/* Content length known? */
-		if (isl.length != -1) {
-			logger.debug("Blob content length is {}", isl.length);
-
-			int offset = 0;
-			while ((read = isl.inputStream.read(buffer)) != -1 && !cancel) {
-				offset += read;
-
-				try {
-					bos.write(buffer, 0, read);
-				} catch (OutOfMemoryError e) {
-					throw new IOException("Out of memory on write");
-				}
-
-				if (progressListener != null) {
-					progressListener.updateProgress((int) ((float) 100 * offset / isl.length));
-				}
-			}
-
-			if (cancel) {
-				logger.info("Blob load cancelled");
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				return null;
-			}
-
-			if (offset != isl.length) {
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				throw new IOException("Unexpected read size. current: " + offset + ", excepted: " + isl.length);
-			}
-
-			blob = bos.toByteArray();
-		} else {
-			/* Content length is unknown - need to read until EOF */
-			logger.debug("Blob content length is unknown");
-
-			while ((read = isl.inputStream.read(buffer)) != -1 && !cancel) {
-				bos.write(buffer, 0, read);
-			}
-
-			if (cancel) {
-				logger.info("Blob load cancelled");
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				return null;
-			}
-
-			blob = bos.toByteArray();
-		}
-
-		logger.info("Blob load complete ({} bytes received)", blob.length);
-
-		if (progressListener != null) {
-			progressListener.onFinished(true);
-		}
-
-		if (markAsDone) {
-			if (blob.length > 0) {
-				this.markAsDone(blobId);
-			}
-		}
-
-		return blob;
-	}
-
-	private InputStreamLength getInputStream() throws IOException, ThreemaException {
-
-		URL blobUrl = getBlobUrl(blobId, false);
-
-		logger.info("Loading blob from {}", blobUrl.getHost());
-		HttpURLConnection connection = (HttpURLConnection)blobUrl.openConnection();
-		if (connection instanceof HttpsURLConnection) {
-			((HttpsURLConnection)connection).setSSLSocketFactory(this.factory.makeFactory(blobUrl.getHost()));
-		}
-		connection.setConnectTimeout(ProtocolDefines.BLOB_CONNECT_TIMEOUT * 1000);
-		connection.setReadTimeout(ProtocolDefines.BLOB_LOAD_TIMEOUT * 1000);
-		connection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
-		connection.setDoOutput(false);
-
-		BufferedInputStream inputStream = new BufferedInputStream(connection.getInputStream());
-		int contentLength = connection.getContentLength();
-		return new InputStreamLength(inputStream, contentLength);
-	}
-
-	public void markAsDone(byte[] blobId) {
-		try {
-			URL blobDoneUrl = getBlobUrl(blobId, true);
-
-			HttpURLConnection doneConnection = (HttpURLConnection)blobDoneUrl.openConnection();
-			if (doneConnection instanceof HttpsURLConnection) {
-				((HttpsURLConnection)doneConnection).setSSLSocketFactory(this.factory.makeFactory(blobDoneUrl.getHost()));
-			}
-			doneConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
-			doneConnection.setDoOutput(false);
-			doneConnection.setDoInput(true);
-			doneConnection.setRequestMethod("POST");
-			IOUtils.toByteArray(doneConnection.getInputStream());
-		} catch (IOException | ThreemaException e) {
-			logger.warn("Marking blob as done failed", e);
-		}
-	}
-
-	/**
-	 * Cancel a download in progress. load() will return null.
-	 */
-	public void cancel() {
-		cancel = true;
-	}
-
-	public void setProgressListener(ProgressListener progressListener) {
-		this.progressListener = progressListener;
-	}
-
-	public void setVersion(Version version) {
-		this.version = version;
-	}
-
-	private URL getBlobUrl(byte[] blobId, boolean done) throws ThreemaException, MalformedURLException {
-		String blobIdHex = Utils.byteArrayToHexString(blobId);
-		String blobIdPrefix = blobIdHex.substring(0, 2);
-		String blobUrl;
-		if (done) {
-			blobUrl = serverAddressProvider.getBlobServerDoneUrl(ipv6);
-		} else {
-			blobUrl = serverAddressProvider.getBlobServerDownloadUrl(ipv6);
-		}
-		blobUrl = blobUrl.replace("{blobIdPrefix}", blobIdPrefix)
-			.replace("{blobId}", blobIdHex);
-		return new URL(blobUrl);
-	}
-
-	private static class InputStreamLength {
-		public final BufferedInputStream inputStream;
-		public final int length;
-
-		public InputStreamLength(BufferedInputStream inputStream, int length) {
-			this.inputStream = inputStream;
-			this.length = length;
-		}
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.kt b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.kt
new file mode 100644
index 00000000..3a95113f
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.kt
@@ -0,0 +1,336 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.blob
+
+import ch.threema.base.ProgressListener
+import ch.threema.base.ThreemaException
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.Utils
+import ch.threema.base.utils.toHexString
+import ch.threema.domain.protocol.ProtocolStrings
+import ch.threema.domain.protocol.ServerAddressProvider
+import ch.threema.domain.protocol.Version
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
+import ch.threema.domain.protocol.connection.data.leBytes
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody.Companion.toRequestBody
+import okhttp3.Response
+import okhttp3.ResponseBody
+import okhttp3.logging.HttpLoggingInterceptor
+import okio.BufferedSource
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.io.IOException
+import java.net.URL
+import java.util.concurrent.TimeUnit
+import kotlin.concurrent.Volatile
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("BlobLoader")
+
+// TODO (ANDR-2869): Rework exception handling (and maybe return types)
+/**
+ * Helper class that loads blobs (images, videos etc.) from the blob server given a blob ID. No
+ * processing is done on the loaded data; any decryption etc. must be done separately.
+ *
+ * It can target both the default blob server and the mirror blob server for multi-device sessions.
+ */
+class BlobLoader private constructor(
+    private val baseOkHttpClient: OkHttpClient,
+    private val blobId: ByteArray,
+    private val version: Version,
+    private val useMirror: Boolean,
+    private val shouldLogHttp: Boolean,
+    private val serverAddressProvider: ServerAddressProvider,
+    @JvmField var progressListener: ProgressListener?,
+    // used only for non-mirror blob server
+    private val useIpv6: Boolean?,
+    // used only for mirror blob sever requests:
+    private val multiDevicePropertyProvider: MultiDevicePropertyProvider?
+) {
+
+    @Volatile
+    private var isCancelled = false
+
+    companion object {
+
+        private const val BUFFER_SIZE = 8192
+
+        @JvmStatic
+        fun usual(
+            baseOkHttpClient: OkHttpClient,
+            blobId: ByteArray,
+            version: Version,
+            shouldLogHttp: Boolean,
+            serverAddressProvider: ServerAddressProvider,
+            progressListener: ProgressListener?,
+            useIpv6: Boolean,
+        ) = BlobLoader(
+            baseOkHttpClient = baseOkHttpClient,
+            blobId = blobId,
+            version = version,
+            useMirror = false,
+            shouldLogHttp = shouldLogHttp,
+            serverAddressProvider = serverAddressProvider,
+            progressListener = progressListener,
+            useIpv6 = useIpv6,
+            multiDevicePropertyProvider = null
+        )
+
+        @JvmStatic
+        fun mirror(
+            baseOkHttpClient: OkHttpClient,
+            blobId: ByteArray,
+            version: Version,
+            shouldLogHttp: Boolean,
+            serverAddressProvider: ServerAddressProvider,
+            progressListener: ProgressListener?,
+            multiDevicePropertyProvider: MultiDevicePropertyProvider
+        ) = BlobLoader(
+            baseOkHttpClient = baseOkHttpClient,
+            blobId = blobId,
+            version = version,
+            useMirror = true,
+            shouldLogHttp = shouldLogHttp,
+            serverAddressProvider = serverAddressProvider,
+            progressListener = progressListener,
+            useIpv6 = null,
+            multiDevicePropertyProvider = multiDevicePropertyProvider
+        )
+    }
+
+    /**
+     * Attempt to load the given blob.
+     *
+     * @param scope Sets the passed scope when downloading the data from the multi-device blob mirror server.
+     * Will have no effect if multi-device is not active.
+     *
+     * @return blob data or null if download was cancelled
+     */
+    @Throws(IOException::class, ThreemaException::class)
+    fun load(scope: BlobScope): ByteArray? {
+        isCancelled = false
+
+        val blobResult: BufferedSourceWithLength = requestBlob(scope)
+
+        var read: Int = -1
+        val blobData: ByteArray
+        val buffer = ByteArray(BUFFER_SIZE)
+        val bos = ByteArrayOutputStream()
+
+        if (blobResult.containsContent()) {
+
+            logger.debug("Blob content length is {}", blobResult.length)
+
+            var offset = 0
+            while (!isCancelled && (blobResult.source.read(buffer).also { read = it }) != -1) {
+                offset += read
+
+                try {
+                    bos.write(buffer, 0, read)
+                } catch (outOfMemoryError: OutOfMemoryError) {
+                    throw IOException("Out of memory on write")
+                }
+                progressListener?.updateProgress((100f * offset / blobResult.length).toInt())
+            }
+
+            if (isCancelled) {
+                logger.info("Blob load cancelled")
+                progressListener?.onFinished(false)
+                return null
+            }
+
+            if (offset.toLong() != blobResult.length) {
+                progressListener?.onFinished(false)
+                throw IOException("Unexpected read size. current: " + offset + ", excepted: " + blobResult.length)
+            }
+
+            blobData = bos.toByteArray()
+        } else {
+            /* Content length is unknown - need to read until EOF */
+
+            logger.debug("Blob content length is unknown")
+
+            while (!isCancelled && (blobResult.source.read(buffer).also { read = it }) != -1) {
+                bos.write(buffer, 0, read)
+            }
+
+            if (isCancelled) {
+                logger.info("Blob load cancelled")
+                progressListener?.onFinished(false)
+                return null
+            }
+
+            blobData = bos.toByteArray()
+        }
+
+        logger.info("Blob load complete ({} bytes received)", blobData.size)
+
+        progressListener?.onFinished(true)
+
+        return blobData
+    }
+
+    /**
+     * Hands through exceptions from [getBlobDownloadUrl]
+     */
+    @Throws(IOException::class, ThreemaException::class)
+    private fun requestBlob(scope: BlobScope): BufferedSourceWithLength {
+
+        val blobUrl: URL = getBlobDownloadUrl(blobId, scope)
+
+        val okHttpClientLoad: OkHttpClient = baseOkHttpClient.newBuilder().apply {
+            connectTimeout(ProtocolDefines.BLOB_CONNECT_TIMEOUT.toLong(), TimeUnit.SECONDS)
+            readTimeout(ProtocolDefines.BLOB_LOAD_TIMEOUT.toLong(), TimeUnit.SECONDS)
+            if (shouldLogHttp) {
+                addInterceptor(
+                    HttpLoggingInterceptor().apply {
+                        level = HttpLoggingInterceptor.Level.BASIC
+                    }
+                )
+            }
+        }.build()
+
+        val request: Request = Request.Builder()
+            .get()
+            .url(blobUrl)
+            .addHeader("User-Agent", "${ProtocolStrings.USER_AGENT}/${version.versionString}")
+            .build()
+
+        logger.info("Loading blob from {}", blobUrl.host)
+
+        val response: Response = okHttpClientLoad.newCall(request).execute()
+
+        if (!response.isSuccessful) {
+            logger.error("Blob download failed. HTTP response code not in range 200..299")
+            throw IOException("download request failed with code ${response.code}")
+        }
+
+        val responseBody: ResponseBody = response.body ?: run {
+            logger.error("Blob download failed. Empty successful response body")
+            throw IOException("download request failed because of missing response body")
+        }
+
+        return BufferedSourceWithLength(
+            responseBody.source(),
+            responseBody.contentLength()
+        )
+    }
+
+    /**
+     *  @param scope Sets the passed scope when marking the blob as done on the multi device blob mirror server.
+     *  Will have no effect if multi-device is not active.
+     */
+    fun markAsDone(blobId: ByteArray, scope: BlobScope) {
+        try {
+            val blobDoneUrl: URL = getBlobDoneUrl(blobId, scope)
+
+            val okHttpClientMarkAsDone: OkHttpClient = baseOkHttpClient.newBuilder().apply {
+                if (shouldLogHttp) {
+                    addInterceptor(
+                        HttpLoggingInterceptor().apply {
+                            level = HttpLoggingInterceptor.Level.BASIC
+                        }
+                    )
+                }
+            }.build()
+
+            val request: Request = Request.Builder()
+                .post("".toRequestBody(null))
+                .url(blobDoneUrl)
+                .addHeader("User-Agent", "${ProtocolStrings.USER_AGENT}/${version.versionString}")
+                .build()
+
+            val response: Response = okHttpClientMarkAsDone.newCall(request).execute()
+
+            if (!response.isSuccessful) {
+                logger.warn("Marking blob as done failed. HTTP response code: {}", response.code)
+            }
+        } catch (exception: IOException) {
+            logger.warn("Marking blob as done failed", exception)
+        } catch (exception: ThreemaException) {
+            logger.warn("Marking blob as done failed", exception)
+        }
+    }
+
+    /**
+     * Cancel a download in progress. load() will return null.
+     */
+    fun cancelDownload() {
+        isCancelled = true
+    }
+
+    @Throws(ThreemaException::class)
+    private fun getBlobDownloadUrl(blobId: ByteArray, scope: BlobScope): URL {
+        if (useMirror) {
+            if (multiDevicePropertyProvider == null) {
+                throw ThreemaException("Missing argument")
+            }
+            val urlWithoutQueryParameters = serverAddressProvider.getBlobMirrorServerDownloadUrl(multiDevicePropertyProvider, blobId)
+            return URL(appendMirrorQueryParameters(urlWithoutQueryParameters, multiDevicePropertyProvider, scope))
+        } else {
+            if (useIpv6 == null) {
+                throw ThreemaException("Missing argument")
+            }
+            return URL(serverAddressProvider.getBlobServerDownloadUrl(useIpv6, blobId))
+        }
+    }
+
+    @Throws(ThreemaException::class)
+    private fun getBlobDoneUrl(blobId: ByteArray, scope: BlobScope): URL {
+        if (useMirror) {
+            if (multiDevicePropertyProvider == null) {
+                throw ThreemaException("Missing argument")
+            }
+            val urlWithoutQueryParameters = serverAddressProvider.getBlobMirrorServerDoneUrl(multiDevicePropertyProvider, blobId)
+            return URL(appendMirrorQueryParameters(urlWithoutQueryParameters, multiDevicePropertyProvider, scope))
+        } else {
+            if (useIpv6 == null) {
+                throw ThreemaException("Missing argument")
+            }
+            return URL(serverAddressProvider.getBlobServerDoneUrl(useIpv6, blobId))
+        }
+    }
+
+    /**
+     * @param rawUrl An url string **without** any query parameters. The value of this will not be mutated.
+     */
+    @Throws(ThreemaException::class)
+    private fun appendMirrorQueryParameters(
+        rawUrl: String,
+        multiDevicePropertyProvider: MultiDevicePropertyProvider,
+        scope: BlobScope
+    ): String {
+        val deviceIdHex: String = multiDevicePropertyProvider.get().mediatorDeviceId.leBytes().toHexString()
+        val deviceGroupIdHex: String = Utils.byteArrayToHexString(multiDevicePropertyProvider.get().keys.dgid)
+            ?: throw ThreemaException("Could not read device group id")
+        return "$rawUrl?deviceId=${deviceIdHex}&deviceGroupId=${deviceGroupIdHex}&scope=${scope.name}"
+    }
+
+    private data class BufferedSourceWithLength(
+        val source: BufferedSource,
+        val length: Long
+    ) {
+        fun containsContent(): Boolean = length != -1L
+    }
+}
diff --git a/domain/src/main/java/ch/threema/base/crypto/NonceStore.java b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobScope.kt
similarity index 55%
rename from domain/src/main/java/ch/threema/base/crypto/NonceStore.java
rename to domain/src/main/java/ch/threema/domain/protocol/blob/BlobScope.kt
index e47666e2..a5d6adae 100644
--- a/domain/src/main/java/ch/threema/base/crypto/NonceStore.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobScope.kt
@@ -4,7 +4,7 @@
  *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
  *
  * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
+ * Copyright (c) 2019-2024 Threema GmbH
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Affero General Public License, version 3,
@@ -19,31 +19,22 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.base.crypto;
+package ch.threema.domain.protocol.blob
 
-import java.util.List;
-
-import androidx.annotation.NonNull;
-
-public interface NonceStore {
-	/**
-	 * Return true if the given nonce already exists
-	 *
-	 * @param nonce The nonce bytes
-	 */
-	boolean exists(@NonNull byte[] nonce);
-
-	/**
-	 * Store a nonce
-	 *
-	 * @param nonce The nonce bytes
-	 * @return return true if the nonce was added, false if the nonce already existed
-	 */
-	boolean store(@NonNull byte[] nonce);
+/**
+ *  This scope only takes effect when dealing with the blob mirror server.
+ *  It needs to be passed as a query parameter to all 3 endpoints (upload, download, done).
+ */
+sealed class BlobScope(
+    @JvmField val name: String
+) {
+    /**
+     *  Blob is **only** present blob mirror server to share between devices in the same device group
+     */
+    data object Local : BlobScope("local")
 
-	/**
-	 * @return all hashed nonces that are present in this store.
-	 */
-	@NonNull
-	List<byte[]> getAllHashedNonces();
+    /**
+     *  Blob is **both** present on the mirror server and on the default blob server
+     */
+    data object Public : BlobScope("public")
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.java b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.java
deleted file mode 100644
index 24531d60..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.blob;
-
-import org.apache.commons.io.IOUtils;
-import org.slf4j.Logger;
-
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.URL;
-import java.nio.charset.StandardCharsets;
-
-import javax.net.ssl.HttpsURLConnection;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.base.utils.Utils;
-import ch.threema.domain.protocol.SSLSocketFactoryFactory;
-import ch.threema.base.ProgressListener;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.ProtocolStrings;
-import ch.threema.domain.protocol.ServerAddressProvider;
-import ch.threema.domain.protocol.Version;
-
-/**
- * Helper class that uploads a blob (image, video) to the blob server and returns the assigned blob
- * ID. No processing is done on the data; any encryption must happen separately.
- */
-public class BlobUploader {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BlobUploader");
-
-	private static final int CHUNK_SIZE = 16384;
-
-	private final @NonNull SSLSocketFactoryFactory factory;
-	private final ServerAddressProvider serverAddressProvider;
-	private final boolean ipv6;
-
-	private final @NonNull InputStream blobInputStream;
-	private final int blobLength;
-	private String authToken;
-	private boolean persist = false;
-
-	private volatile boolean cancel;
-	private ProgressListener progressListener;
-	private Version version;
-
-	public BlobUploader(@NonNull SSLSocketFactoryFactory factory, byte[] blobData, boolean ipv6, ServerAddressProvider serverAddressProvider, ProgressListener progressListener) {
-		this(factory, new ByteArrayInputStream(blobData), blobData.length, ipv6, serverAddressProvider, progressListener);
-	}
-
-	private BlobUploader(
-		@NonNull SSLSocketFactoryFactory factory,
-		@NonNull InputStream blobInputStream,
-		int blobLength,
-		boolean ipv6,
-		ServerAddressProvider serverAddressProvider,
-		ProgressListener progressListener
-	) {
-		this.factory = factory;
-		this.blobInputStream = blobInputStream;
-		this.blobLength = blobLength;
-		this.progressListener = progressListener;
-		this.version = new Version();
-		this.ipv6 = ipv6;
-		this.serverAddressProvider = serverAddressProvider;
-	}
-
-	/**
-	 * Upload the given blob and return the blob ID on success.
-	 *
-	 * @return blob ID
-	 * @throws IOException if a network error occurs
-	 * @throws ThreemaException if the server response is invalid
-	 */
-	public byte[] upload() throws IOException, ThreemaException {
-		cancel = false;
-
-		String urlStr = serverAddressProvider.getBlobServerUploadUrl(ipv6);
-		if (persist) {
-			urlStr += "?persist=1";
-		}
-		URL url = new URL(urlStr);
-		String boundary = "---------------------------Boundary_Line";
-
-		logger.info("Uploading blob ({} bytes)", blobLength);
-
-		HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();
-		if (urlConnection instanceof HttpsURLConnection) {
-			((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.factory.makeFactory(url.getHost()));
-		}
-		urlConnection.setConnectTimeout(ProtocolDefines.CONNECT_TIMEOUT * 1000);
-		urlConnection.setReadTimeout(ProtocolDefines.BLOB_LOAD_TIMEOUT * 1000);
-		urlConnection.setRequestMethod("POST");
-		urlConnection.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary);
-		urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
-		if (this.authToken != null) {
-			urlConnection.setRequestProperty("Authorization", "Token " + this.authToken);
-		}
-		String header = "--" + boundary + "\r\nContent-Disposition: form-data; name=\"blob\"; filename=\"blob.bin\"\r\n" + "Content-Type: application/octet-stream\r\n\r\n";
-		byte[] headerBytes = header.getBytes();
-
-		String footer = "\r\n--" + boundary + "--\r\n";
-		byte[] footerBytes = footer.getBytes();
-
-		urlConnection.setFixedLengthStreamingMode(headerBytes.length + blobLength + footerBytes.length);
-		urlConnection.setDoOutput(true);
-		urlConnection.setDoInput(true);
-
-		try (BufferedOutputStream bos = new BufferedOutputStream(urlConnection.getOutputStream())) {
-			bos.write(headerBytes);
-
-			int ndone = 0;
-			int nread;
-			byte[] buf = new byte[CHUNK_SIZE];
-			while ((nread = blobInputStream.read(buf)) > 0 && !cancel) {
-				bos.write(buf, 0, nread);
-				ndone += nread;
-
-				if (progressListener != null && blobLength > 0)
-					progressListener.updateProgress(100 * ndone / blobLength);
-			}
-
-			if (cancel) {
-				try {
-					bos.close();
-				} catch (ProtocolException x) {
-					//ignore this exception, the upload was canceled
-				}
-				logger.info("Blob upload cancelled");
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				return null;
-			}
-
-			bos.write(footerBytes);
-			bos.flush();
-
-			String blobIdHex;
-			try (InputStream blobIdInputStream = urlConnection.getInputStream()) {
-				blobIdHex = IOUtils.toString(blobIdInputStream, StandardCharsets.UTF_8);
-			}
-
-			if (blobIdHex == null) {
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				throw new ThreemaException("TB001");    /* Invalid blob ID received from server */
-			}
-
-			byte[] blobId = Utils.hexStringToByteArray(blobIdHex);
-			if (blobId.length != ProtocolDefines.BLOB_ID_LEN) {
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				throw new ThreemaException("TB001");    /* Invalid blob ID received from server */
-			}
-
-			if (progressListener != null) {
-				progressListener.onFinished(true);
-			}
-
-			logger.info("Blob upload completed; ID = {}", blobIdHex);
-
-			return blobId;
-		} finally {
-			urlConnection.disconnect();
-			try {
-				blobInputStream.close();
-			} catch (IOException ignored) {}
-		}
-	}
-
-	/**
-	 * Cancel an upload in progress. upload() will return null.
-	 */
-	public void cancel() {
-		cancel = true;
-	}
-
-	public void setProgressListener(ProgressListener progressListener) {
-		this.progressListener = progressListener;
-	}
-
-	public void setVersion(Version version) {
-		this.version = version;
-	}
-
-	public void setAuthToken(String authToken) {
-		this.authToken = authToken;
-	}
-
-	public void setPersist(boolean persist) { this.persist = persist; }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.kt b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.kt
new file mode 100644
index 00000000..de4e4886
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.kt
@@ -0,0 +1,346 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.blob
+
+import ch.threema.base.ProgressListener
+import ch.threema.base.ThreemaException
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.Utils
+import ch.threema.base.utils.toHexString
+import ch.threema.domain.protocol.ProtocolStrings
+import ch.threema.domain.protocol.ServerAddressProvider
+import ch.threema.domain.protocol.Version
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
+import ch.threema.domain.protocol.connection.data.leBytes
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import okhttp3.MediaType
+import okhttp3.MediaType.Companion.toMediaType
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.RequestBody
+import okhttp3.internal.closeQuietly
+import okhttp3.logging.HttpLoggingInterceptor
+import okio.BufferedSink
+import okio.source
+import org.apache.commons.io.IOUtils
+import org.slf4j.Logger
+import java.io.ByteArrayInputStream
+import java.io.IOException
+import java.io.InputStream
+import java.net.URL
+import java.nio.charset.StandardCharsets
+import java.util.concurrent.TimeUnit
+import kotlin.concurrent.Volatile
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("BlobUploader")
+
+// TODO (ANDR-2869): Rework exception handling (and maybe return types)
+/**
+ * Helper class that uploads a blob (image, video) to the blob server and returns the assigned blob
+ * ID. No processing is done on the data; any encryption must happen separately.
+ *
+ * It can target both the default blob server and the mirror blob server for multi-device sessions.
+ */
+class BlobUploader private constructor(
+    private val baseOkhttpClient: OkHttpClient,
+    private val authToken: String?,
+    private val blobInputStream: InputStream,
+    private val blobLength: Int,
+    private val version: Version,
+    private val useMirror: Boolean,
+    private val shouldLogHttp: Boolean,
+    private val serverAddressProvider: ServerAddressProvider,
+    @JvmField var progressListener: ProgressListener?,
+    // used for usual blob server request:
+    private val useIpv6: Boolean?,
+    private val shouldPersist: Boolean?,
+    // used for mirror blob server request:
+    private val multiDevicePropertyProvider: MultiDevicePropertyProvider?,
+    private val blobScope: BlobScope?
+) {
+
+    @Volatile
+    private var isCancelled = false
+
+    companion object {
+
+        private const val MULTIPART_BOUNDARY = "---------------------------Boundary_Line"
+
+        /**
+         * Use this constructor when multi-device is currently **not** active on the device. <br></br>
+         * Use `BlobUploader.mirror()` otherwise.
+         */
+        @JvmStatic
+        fun usual(
+            baseOkhttpClient: OkHttpClient,
+            authToken: String?,
+            blobData: ByteArray,
+            version: Version,
+            shouldLogHttp: Boolean,
+            serverAddressProvider: ServerAddressProvider,
+            progressListener: ProgressListener?,
+            useIpv6: Boolean,
+            shouldPersist: Boolean
+        ): BlobUploader = BlobUploader(
+            baseOkhttpClient = baseOkhttpClient,
+            authToken = authToken,
+            blobInputStream = ByteArrayInputStream(blobData),
+            blobLength = blobData.size,
+            version = version,
+            useMirror = false,
+            shouldLogHttp = shouldLogHttp,
+            serverAddressProvider = serverAddressProvider,
+            progressListener = progressListener,
+            useIpv6 = useIpv6,
+            shouldPersist = shouldPersist,
+            multiDevicePropertyProvider = null,
+            blobScope = null
+        )
+
+        /**
+         * Use this constructor when multi-device is currently active on the device. <br></br>
+         * Use `BlobUploader.usual()` otherwise.
+         */
+        @JvmStatic
+        fun mirror(
+            baseOkhttpClient: OkHttpClient,
+            authToken: String?,
+            blobData: ByteArray,
+            version: Version,
+            shouldLogHttp: Boolean,
+            serverAddressProvider: ServerAddressProvider,
+            progressListener: ProgressListener?,
+            multiDevicePropertyProvider: MultiDevicePropertyProvider,
+            blobScope: BlobScope
+        ): BlobUploader = BlobUploader(
+            baseOkhttpClient = baseOkhttpClient,
+            authToken = authToken,
+            blobInputStream = ByteArrayInputStream(blobData),
+            blobLength = blobData.size,
+            version = version,
+            shouldLogHttp = shouldLogHttp,
+            useMirror = true,
+            serverAddressProvider = serverAddressProvider,
+            progressListener = progressListener,
+            useIpv6 = null,
+            shouldPersist = null,
+            multiDevicePropertyProvider = multiDevicePropertyProvider,
+            blobScope = blobScope
+        )
+    }
+
+    /**
+     * Upload the given blob and return the blob ID on success.
+     *
+     * @return blob ID as a byte array or `null` if cancelled via `cancel()`
+     */
+    @Throws(IOException::class, ThreemaException::class)
+    fun upload(): ByteArray? {
+        isCancelled = false
+
+        val blobUploadUrl = getBlobUploadUrl()
+
+        val okHttpClientUpload : OkHttpClient = baseOkhttpClient.newBuilder().apply {
+            connectTimeout(ProtocolDefines.BLOB_CONNECT_TIMEOUT.toLong(), TimeUnit.SECONDS)
+            readTimeout(ProtocolDefines.BLOB_LOAD_TIMEOUT.toLong(), TimeUnit.SECONDS)
+            if (shouldLogHttp) {
+                addInterceptor(
+                    HttpLoggingInterceptor().apply {
+                        level = HttpLoggingInterceptor.Level.BASIC
+                    }
+                )
+            }
+        }.build()
+
+        val uploadRequest: Request = Request.Builder().apply {
+            url(blobUploadUrl)
+            addHeader("Content-Type", "multipart/form-data; boundary=$MULTIPART_BOUNDARY")
+            addHeader("User-Agent", "${ProtocolStrings.USER_AGENT}/${version.versionString}")
+            if (authToken != null) {
+                addHeader("Authorization", "Token $authToken")
+            }
+            post(buildRequestBody())
+        }.build()
+
+        logger.info("Uploading blob ({} bytes) in scope {}", blobLength, blobScope)
+
+        try {
+            okHttpClientUpload.newCall(uploadRequest).execute().use { response ->
+                if (isCancelled) {
+                    progressListener?.onFinished(false)
+                    return null
+                }
+                if (!response.isSuccessful) {
+                    logger.error("Blob upload failed. HTTP response code not in range 200..299")
+                    throw IOException("upload request failed with code ${response.code}")
+                }
+
+                val responseBodyStream: InputStream = response.body?.byteStream() ?: run {
+                    logger.error("Blob upload failed. Empty successful response body")
+                    throw ThreemaException("TB001") // Invalid blob ID received from server
+                }
+
+                val blobIdHex = IOUtils.toString(responseBodyStream, StandardCharsets.UTF_8)
+
+                progressListener?.onFinished(blobIdHex != null)
+
+                if (blobIdHex != null) {
+                    logger.info("Blob upload completed. ID = $blobIdHex")
+                    return Utils.hexStringToByteArray(blobIdHex)
+                } else {
+                    logger.error("Blob upload failed. Could not read ID from successful response")
+                    throw ThreemaException("TB001") // Invalid blob ID received from server
+                }
+            }
+        } catch (ioException: IOException) {
+            // Mutable field `isCancelled` will be mutated by calls to progressListener.onFinished
+            val isCancelledAtTimeOfException = isCancelled
+            progressListener?.onFinished(false)
+            // If the "UploadBlobRequestBody" stops writing bytes due to cancellation, it result
+            // in an IOException. But only catch it, if we cancelled this uploader on our own
+            if (isCancelledAtTimeOfException) {
+                logger.info("Blob upload cancelled manually")
+                return null
+            } else {
+                logger.error("Blob upload failed (isCancelled: false)", ioException)
+                throw ioException
+            }
+        } finally {
+            blobInputStream.closeQuietly()
+        }
+    }
+
+    @Throws(ThreemaException::class)
+    private fun getBlobUploadUrl(): URL {
+        if (useMirror) {
+            if (multiDevicePropertyProvider == null) {
+                throw ThreemaException("Missing parameter multiDevicePropertyProvider")
+            }
+            if (blobScope == null) {
+                throw ThreemaException("Missing parameter blobScope")
+            }
+            val blobMirrorServerUploadUrl: String = serverAddressProvider.getBlobMirrorServerUploadUrl(multiDevicePropertyProvider)
+            return URL(
+                appendQueryParametersForMirrorServer(
+                    blobMirrorServerUploadUrl,
+                    multiDevicePropertyProvider,
+                    blobScope
+                )
+            )
+        } else {
+            if (useIpv6 == null) {
+                throw ThreemaException("Missing parameter useIpv6")
+            }
+            val blobServerUploadUrl: String = serverAddressProvider.getBlobServerUploadUrl(useIpv6)
+            return URL(appendQueryParametersForUsualServer(blobServerUploadUrl))
+        }
+    }
+
+    /**
+     * @param rawUrl An url string **without** any query parameters. The value of this will not be mutated.
+     */
+    private fun appendQueryParametersForUsualServer(rawUrl: String): String {
+        if (shouldPersist != null && shouldPersist) {
+            return "$rawUrl?persist=1"
+        }
+        return rawUrl
+    }
+
+    /**
+     * @param rawUrl An url string **without** any query parameters. The value of this will not be mutated.
+     */
+    @Throws(ThreemaException::class)
+    private fun appendQueryParametersForMirrorServer(
+        rawUrl: String,
+        multiDevicePropertyProvider: MultiDevicePropertyProvider,
+        scope: BlobScope
+    ): String {
+        val deviceGroupIdHex: String = Utils.byteArrayToHexString(multiDevicePropertyProvider.get().keys.dgid)
+            ?: throw ThreemaException("Could not read device group id")
+        val deviceIdHex: String = multiDevicePropertyProvider.get().mediatorDeviceId.leBytes().toHexString()
+        return "$rawUrl?deviceId=${deviceIdHex}&deviceGroupId=${deviceGroupIdHex}&scope=${scope.name}"
+    }
+
+    private fun buildRequestBody(): RequestBody {
+        val header =
+            "--$MULTIPART_BOUNDARY\r\nContent-Disposition: form-data; name=\"blob\"; filename=\"blob.bin\"\r\nContent-Type: application/octet-stream\r\n\r\n"
+        val footer = "\r\n--$MULTIPART_BOUNDARY--\r\n"
+        return UploadBlobRequestBody(
+            blobInputStream = blobInputStream,
+            blobLength = blobLength.toLong(),
+            bodyHeaderBytes = header.toByteArray(),
+            bodyFooterBytes = footer.toByteArray()
+        )
+    }
+
+    /**
+     * Send a cancel signal. If an upload is currently in progress, it will stop and `upload()` will return `null` immediately.
+     */
+    fun cancel() {
+        this.isCancelled = true
+    }
+
+    private inner class UploadBlobRequestBody(
+        private val blobInputStream: InputStream,
+        private val blobLength: Long,
+        private val bodyHeaderBytes: ByteArray,
+        private val bodyFooterBytes: ByteArray
+    ) : RequestBody() {
+
+        override fun contentType(): MediaType = ("multipart/form-data; boundary=$MULTIPART_BOUNDARY").toMediaType()
+
+        override fun contentLength(): Long = bodyHeaderBytes.size + blobLength + bodyFooterBytes.size
+
+        override fun isOneShot(): Boolean = true
+
+        @Throws(IOException::class)
+        override fun writeTo(sink: BufferedSink) {
+            if (!isCancelled) {
+                sink.write(bodyHeaderBytes)
+            }
+            blobInputStream.source().use { source ->
+                // The rounded progress that is used for triggering the listeners
+                var roundedProgress = 0
+                // Actual progress
+                var progress = 0L
+                var read: Long = -1L
+                while (
+                    !isCancelled &&
+                    (source.read(sink.buffer, 2048L).also { read = it }) != -1L
+                ) {
+                    progress += read
+                    sink.flush()
+                    // Compute rounded progress in percent
+                    val newRoundedProgress = (100 * (progress.toDouble() / blobLength)).toInt()
+                    // Only trigger listener if there is an update
+                    if (newRoundedProgress != roundedProgress) {
+                        progressListener?.updateProgress(newRoundedProgress)
+                        roundedProgress = newRoundedProgress
+                    }
+                }
+            }
+            if (!isCancelled) {
+                sink.write(bodyFooterBytes)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt
index 420c7be6..fc2ba3ed 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt
@@ -206,6 +206,9 @@ internal class CspSession(
             logger.debug("Server nonce = {}", NaCl.asHex(nonce))
         }
 
+        // Note that the public key of the server is checked here in our custom chat server
+        // protocol. This gives us the same security protections as certificate pinning in the tls
+        // context.
         serverPubKeyPerm = serverAddressProvider.chatServerPublicKey
         var kClientTempServerPerm = NaCl(clientTempKeySec, serverPubKeyPerm)
         var serverHello = kClientTempServerPerm.decrypt(serverHelloBox, nonce)
@@ -306,7 +309,7 @@ internal class CspSession(
 
     private fun createExtensions(): ByteArray {
         /* Client info (0x00) */
-        val clientInfo = ProtocolExtension(ProtocolExtension.CLIENT_INFO_TYPE, version.fullVersion.encodeToByteArray())
+        val clientInfo = ProtocolExtension(ProtocolExtension.CLIENT_INFO_TYPE, version.fullVersionString.encodeToByteArray())
 
         /* Csp device id (0x01) if multi device is active, omit if md is not active */
         val cspDeviceIdBytes = cspDeviceId
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt
index 12b82fe8..01d7d50f 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt
@@ -53,6 +53,7 @@ internal class D2mConnectionImpl(
 fun interface MultiDevicePropertyProvider {
     fun get(): MultiDeviceProperties
 }
+
 data class D2mConnectionConfiguration(
     override val identityStore: IdentityStoreInterface,
     override val serverAddressProvider: ServerAddressProvider,
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt
index 2e2084d8..ca8e2a64 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt
@@ -34,6 +34,27 @@ sealed interface D2dMessage {
         val appVersion: String,
         val label: String
     ) : D2dMessage {
+        companion object {
+            val INVALID_DEVICE_INFO = DeviceInfo(Platform.UNSPECIFIED, "", "", "")
+
+            fun fromProtobuf(deviceInfo: MdD2D.DeviceInfo): DeviceInfo {
+                val platform: Platform = when (deviceInfo.platform) {
+                    MdD2D.DeviceInfo.Platform.UNSPECIFIED -> Platform.UNSPECIFIED
+                    MdD2D.DeviceInfo.Platform.ANDROID -> Platform.ANDROID
+                    MdD2D.DeviceInfo.Platform.IOS -> Platform.IOS
+                    MdD2D.DeviceInfo.Platform.DESKTOP -> Platform.DESKTOP
+                    MdD2D.DeviceInfo.Platform.WEB -> Platform.WEB
+                    null, MdD2D.DeviceInfo.Platform.UNRECOGNIZED -> Platform.UNSPECIFIED
+                }
+                return DeviceInfo(
+                    platform,
+                    deviceInfo.platformDetails,
+                    deviceInfo.appVersion,
+                    deviceInfo.label
+                )
+            }
+        }
+
         enum class Platform(val value: Int) {
             UNSPECIFIED(0),
             ANDROID(1),
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt
index a83198da..c151f04a 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt
@@ -21,16 +21,17 @@
 
 package ch.threema.domain.protocol.connection.data
 
+import ch.threema.base.utils.Utils
 import ch.threema.base.utils.toHexString
 import ch.threema.domain.protocol.D2mPayloadType
 import ch.threema.domain.protocol.connection.ServerConnectionException
 import ch.threema.protobuf.d2m.MdD2M
 import com.google.protobuf.ByteString
+import java.io.ByteArrayOutputStream
 import java.nio.ByteBuffer
 import java.nio.ByteOrder
 
-class D2mContainer(val payloadType: UByte, val payload: ByteArray)
-    : InboundL1Message,
+class D2mContainer(val payloadType: UByte, val payload: ByteArray) : InboundL1Message,
     OutboundL2Message {
     override val type: String = "D2mContainer"
 
@@ -103,7 +104,7 @@ sealed class OutboundD2mMessage(override val payloadType: UByte) :
             DROP_LEAST_RECENT(1);
         }
 
-        override val type: String = "D2mClientHello"
+        override val type: String = "ClientHello"
 
         override fun toContainer(): D2mContainer {
             val hello = MdD2M.ClientHello.newBuilder()
@@ -122,14 +123,18 @@ sealed class OutboundD2mMessage(override val payloadType: UByte) :
         }
 
         override fun toString(): String {
-            return "ClientHello(version=$version, response=${response.toHexString(4)}, deviceId=$deviceId, deviceSlotsExhaustedPolicy=$deviceSlotsExhaustedPolicy, deviceSlotExpirationPolicy=$deviceSlotExpirationPolicy, expectedDeviceSlotState=$expectedDeviceSlotState, encryptedDeviceInfo=${encryptedDeviceInfo.toHexString(4)}, type='$type')"
+            return "ClientHello(version=$version, response=${response.toHexString(4)}, deviceId=$deviceId, deviceSlotsExhaustedPolicy=$deviceSlotsExhaustedPolicy, deviceSlotExpirationPolicy=$deviceSlotExpirationPolicy, expectedDeviceSlotState=$expectedDeviceSlotState, encryptedDeviceInfo=${
+                encryptedDeviceInfo.toHexString(
+                    4
+                )
+            }, type='$type')"
         }
 
 
     }
 
     class GetDevicesInfo : OutboundD2mMessage(D2mPayloadType.GET_DEVICES_INFO) {
-        override val type: String = "D2mGetDevicesInfo"
+        override val type: String = "GetDevicesInfo"
 
         override fun toContainer(): D2mContainer {
             val getDevicesInfo = MdD2M.GetDevicesInfo.newBuilder().build()
@@ -138,7 +143,7 @@ sealed class OutboundD2mMessage(override val payloadType: UByte) :
     }
 
     class DropDevice(val deviceId: DeviceId) : OutboundD2mMessage(D2mPayloadType.DROP_DEVICE), OutboundMessage {
-        override val type: String = "D2mDropDevice"
+        override val type: String = "DropDevice"
 
         override fun toContainer(): D2mContainer {
             val dropDevice = MdD2M.DropDevice.newBuilder()
@@ -152,7 +157,7 @@ sealed class OutboundD2mMessage(override val payloadType: UByte) :
         private val encryptedScope: ByteArray,
         private val ttl: UInt
     ) : OutboundD2mMessage(D2mPayloadType.BEGIN_TRANSACTION) {
-        override val type: String = "D2mBeginTransaction"
+        override val type: String = "BeginTransaction"
 
         override fun toContainer(): D2mContainer {
             val beginTransaction = MdD2M.BeginTransaction.newBuilder()
@@ -164,7 +169,7 @@ sealed class OutboundD2mMessage(override val payloadType: UByte) :
     }
 
     class SetSharedDeviceData(private val encryptedSharedDeviceData: ByteArray) : OutboundD2mMessage(D2mPayloadType.SET_SHARED_DEVICE_DATA) {
-        override val type: String = "D2mSetSharedDeviceData"
+        override val type: String = "SetSharedDeviceData"
 
         override fun toContainer(): D2mContainer {
             val data = MdD2M.SetSharedDeviceData.newBuilder()
@@ -175,7 +180,7 @@ sealed class OutboundD2mMessage(override val payloadType: UByte) :
     }
 
     class CommitTransaction : OutboundD2mMessage(D2mPayloadType.COMMIT_TRANSACTION) {
-        override val type: String = "D2mCommitTransaction"
+        override val type: String = "CommitTransaction"
 
         override fun toContainer(): D2mContainer {
             val commitTransaction = MdD2M.CommitTransaction.newBuilder()
@@ -183,6 +188,37 @@ sealed class OutboundD2mMessage(override val payloadType: UByte) :
             return D2mContainer(payloadType, commitTransaction.toByteArray())
         }
     }
+
+    class Reflect(
+        private val flags: UShort,
+        private val reflectId: UInt,
+        private val encryptedEnvelope: ByteArray,
+    ) : OutboundD2mMessage(D2mPayloadType.REFLECT) {
+        override val type: String = "Reflect"
+
+        override fun toContainer(): D2mContainer {
+            val outputStream = ByteArrayOutputStream()
+            outputStream.write(8)
+            outputStream.write(0)
+            outputStream.write(Utils.shortToByteArrayLittleEndian(flags.toShort()))
+            outputStream.write(Utils.intToByteArrayLittleEndian(reflectId.toInt()))
+            outputStream.write(encryptedEnvelope)
+            return D2mContainer(payloadType, outputStream.toByteArray())
+        }
+    }
+
+    class ReflectedAck(
+        private val reflectId: UInt,
+    ) : OutboundD2mMessage(D2mPayloadType.REFLECTED_ACK) {
+        override val type: String = "ReflectedAck"
+
+        override fun toContainer(): D2mContainer {
+            val outputStream = ByteArrayOutputStream()
+            outputStream.write(ByteArray(4)) // reserved
+            outputStream.write(Utils.intToByteArrayLittleEndian(reflectId.toInt()))
+            return D2mContainer(payloadType, outputStream.toByteArray())
+        }
+    }
 }
 
 sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Message, InboundL3Message, InboundL4Message, InboundMessage {
@@ -199,6 +235,8 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
                 D2mPayloadType.COMMIT_TRANSACTION_ACK -> CommitTransactionAck.decodeContainer(container)
                 D2mPayloadType.TRANSACTION_REJECTED -> TransactionRejected.decodeContainer(container)
                 D2mPayloadType.TRANSACTION_ENDED -> TransactionEnded.decodeContainer(container)
+                D2mPayloadType.REFLECTED -> Reflected.decodeContainer(container)
+                D2mPayloadType.REFLECT_ACK -> ReflectAck.decodeContainer(container)
                 else -> throw D2mProtocolException("Unsupported payload type `${container.payloadType.toHex()}`")
             }
         }
@@ -209,8 +247,9 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
     internal class ServerHello(
         val version: UInt,
         val esk: ByteArray,
-        val challenge: ByteArray) : InboundD2mMessage(D2mPayloadType.SERVER_HELLO) {
-        override val type: String = "D2mServerHello"
+        val challenge: ByteArray
+    ) : InboundD2mMessage(D2mPayloadType.SERVER_HELLO) {
+        override val type: String = "ServerHello"
 
         companion object {
             fun decodeContainer(container: D2mContainer): ServerHello {
@@ -234,7 +273,7 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
         val encryptedSharedDeviceData: ByteArray,
         val reflectionQueueLength: UInt
     ) : InboundD2mMessage(D2mPayloadType.SERVER_INFO) {
-        override val type: String = "D2mServerInfo"
+        override val type: String = "ServerInfo"
 
         companion object {
             fun decodeContainer(container: D2mContainer): ServerInfo {
@@ -254,20 +293,20 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
     }
 
     internal class ReflectionQueueDry : InboundD2mMessage(D2mPayloadType.REFLECTION_QUEUE_DRY) {
-        override val type: String = "D2mReflectionQueueDry"
+        override val type: String = "ReflectionQueueDry"
 
         companion object {
             fun decodeContainer(container: D2mContainer): ReflectionQueueDry {
-                 if (container.payloadType != D2mPayloadType.REFLECTION_QUEUE_DRY) {
-                     throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                 }
+                if (container.payloadType != D2mPayloadType.REFLECTION_QUEUE_DRY) {
+                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
+                }
                 return ReflectionQueueDry()
             }
         }
     }
 
     internal class RolePromotedToLeader : InboundD2mMessage(D2mPayloadType.ROLE_PROMOTED_TO_LEADER) {
-        override val type: String = "D2mRolePromotedToLeader"
+        override val type: String = "RolePromotedToLeader"
 
         companion object {
             fun decodeContainer(container: D2mContainer): RolePromotedToLeader {
@@ -280,20 +319,20 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
     }
 
     class DevicesInfo(val augmentedDeviceInfo: Map<DeviceId, AugmentedDeviceInfo>) : InboundD2mMessage(D2mPayloadType.DEVICES_INFO) {
-        override val type: String = "D2mDevicesInfo"
+        override val type: String = "DevicesInfo"
 
-        data class AugmentedDeviceInfo (
+        data class AugmentedDeviceInfo(
             val encryptedDeviceInfo: ByteArray,
-            val connectedSince: ULong,
-            val lastDisconnectAt: ULong,
+            val connectedSince: ULong?,
+            val lastDisconnectAt: ULong?,
             val deviceSlotExpirationPolicy: DeviceSlotExpirationPolicy
         ) {
             companion object {
                 fun fromProto(augmentedDeviceInfo: MdD2M.DevicesInfo.AugmentedDeviceInfo): AugmentedDeviceInfo {
                     return AugmentedDeviceInfo(
                         augmentedDeviceInfo.encryptedDeviceInfo.toByteArray(),
-                        augmentedDeviceInfo.connectedSince.toULong(),
-                        augmentedDeviceInfo.lastDisconnectAt.toULong(),
+                        augmentedDeviceInfo.connectedSince.takeIf { augmentedDeviceInfo.hasConnectedSince() }?.toULong(),
+                        augmentedDeviceInfo.lastDisconnectAt.takeIf { augmentedDeviceInfo.hasLastDisconnectAt() }?.toULong(),
                         DeviceSlotExpirationPolicy.fromProto(augmentedDeviceInfo.deviceSlotExpirationPolicyValue)
                     )
                 }
@@ -328,13 +367,7 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
                 val proto = MdD2M.DevicesInfo.parseFrom(container.payload)
                 val info = proto.augmentedDeviceInfoMap.entries.associate {
                     val deviceId = DeviceId(it.key.toULong())
-                    val info = AugmentedDeviceInfo(
-                        it.value.encryptedDeviceInfo.toByteArray(),
-                        it.value.connectedSince.toULong(),
-                        it.value.lastDisconnectAt.toULong(),
-                        DeviceSlotExpirationPolicy.fromProto(it.value.deviceSlotExpirationPolicyValue)
-                    )
-                    deviceId to info
+                    deviceId to AugmentedDeviceInfo.fromProto(it.value)
                 }
                 return DevicesInfo(info)
             }
@@ -342,7 +375,7 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
     }
 
     class DropDeviceAck(val deviceId: DeviceId) : InboundD2mMessage(D2mPayloadType.DROP_DEVICE_ACK) {
-        override val type: String = "D2mDropDeviceAck"
+        override val type: String = "DropDeviceAck"
 
         companion object {
             fun decodeContainer(container: D2mContainer): DropDeviceAck {
@@ -356,7 +389,7 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
     }
 
     class BeginTransactionAck : InboundD2mMessage(D2mPayloadType.BEGIN_TRANSACTION_ACK) {
-        override val type: String = "D2mBeginTransactionAck"
+        override val type: String = "BeginTransactionAck"
 
         companion object {
             fun decodeContainer(container: D2mContainer): BeginTransactionAck {
@@ -369,7 +402,7 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
     }
 
     class CommitTransactionAck : InboundD2mMessage(D2mPayloadType.COMMIT_TRANSACTION_ACK) {
-        override val type: String = "D2mCommitTransactionAck"
+        override val type: String = "CommitTransactionAck"
 
         companion object {
             fun decodeContainer(container: D2mContainer): CommitTransactionAck {
@@ -385,7 +418,7 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
         val deviceId: DeviceId,
         val encryptedScope: ByteArray
     ) : InboundD2mMessage(D2mPayloadType.TRANSACTION_REJECTED) {
-        override val type: String = "D2mTransactionRejected"
+        override val type: String = "TransactionRejected"
 
         companion object {
             fun decodeContainer(container: D2mContainer): TransactionRejected {
@@ -405,7 +438,7 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
         val deviceId: DeviceId,
         val encryptedScope: ByteArray
     ) : InboundD2mMessage(D2mPayloadType.TRANSACTION_ENDED) {
-        override val type: String = "D2mTransactionEnded"
+        override val type: String = "TransactionEnded"
 
         companion object {
             fun decodeContainer(container: D2mContainer): TransactionEnded {
@@ -421,9 +454,47 @@ sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Messa
         }
     }
 
-    // TODO(ANDR-2475): Reflected messages
-    // class Reflect : OutboundD2mMessage
-    // class ReflectAck : D2mMessage
-    // class Reflected : D2mMessage
-    // class ReflectedAck : OutboundD2mMessage
+    class ReflectAck(
+        val reflectId: UInt,
+        val timestamp: ULong,
+    ) : InboundD2mMessage(D2mPayloadType.REFLECT_ACK) {
+        override val type: String = "ReflectAck"
+
+        companion object {
+            fun decodeContainer(container: D2mContainer): ReflectAck {
+                val buffer = ByteBuffer
+                    .wrap(container.payload, 4, 12)
+                    .order(ByteOrder.LITTLE_ENDIAN)
+                val reflectId = buffer.int.toUInt()
+                val timestamp = buffer.long.toULong()
+                return ReflectAck(reflectId, timestamp)
+            }
+        }
+    }
+
+    class Reflected(
+        val flags: UShort,
+        val reflectedId: UInt,
+        val timestamp: ULong,
+        val envelope: ByteArray
+    ) : InboundD2mMessage(D2mPayloadType.REFLECTED) {
+        override val type: String = "Reflected"
+
+        companion object {
+            fun decodeContainer(container: D2mContainer): Reflected {
+                val headerLength = container.payload[0].toUByte().toInt()
+                if (headerLength != 16) {
+                    throw D2mProtocolException("Unexpected header length in `Reflected`: $headerLength")
+                }
+                val buffer = ByteBuffer
+                    // we start at [2] because [0] is the header length and [1] is reserved
+                    .wrap(container.payload.copyOfRange(2, headerLength))
+                    .order(ByteOrder.LITTLE_ENDIAN)
+                val flags = buffer.short.toUShort()
+                val reflectedId = buffer.int.toUInt()
+                val timestamp = buffer.long.toULong()
+                return Reflected(flags, reflectedId, timestamp, container.payload.copyOfRange(headerLength, container.payload.size))
+            }
+        }
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt
index fa43b14d..73615347 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt
@@ -83,7 +83,7 @@ internal class MonitoringLayer(
         CoroutineScope(controller.dispatcher.coroutineContext).launch {
             launch {
                 controller.cspAuthenticated.await()
-                startMonitoring(ProtocolDefines.CONNECTION_IDLE_TIMEOUT)
+                startMonitoring()
             }
             launch {
                 controller.connectionClosed.await()
@@ -133,8 +133,8 @@ internal class MonitoringLayer(
         CoroutineScope(controller.dispatcher.coroutineContext).launch {
             controller.cspAuthenticated.await()
             logger.debug("Send UnblockIncomingMessage to chat server")
-            // TODO(ANDR-2475): Only send this when all (supported) reflected messages have been processed and acked (ReflectedAck)
-            //  Should unsupported (yet) messages also be acked, or ignored for this?
+            // We can send unblock incoming messages directly as we will process the messages
+            // sequentially, i.e., the reflected messages will be processed before new messages
             outbound.send(CspContainer(ProtocolDefines.PLTYPE_UNBLOCK_INCOMING_MESSAGES.toUByte(), ByteArray(0)))
         }
     }
@@ -202,19 +202,30 @@ internal class MonitoringLayer(
         logger.info("Received echo reply (seq: {}, rtt: {} ms) ", lastRcvdEchoSeq, rttMs)
     }
 
-    private fun startMonitoring(connectionIdleTimeoutS: Short) {
+    private fun startMonitoring() {
         controller.dispatcher.assertDispatcherContext()
 
+        val (echoRequestInterval, echoResponseTimeout, connectionIdleTimeout) = if (controller is MdLayer4Controller) {
+            // Multi device is active
+            Triple(ProtocolDefines.ECHO_REQUEST_INTERVAL_MD, ProtocolDefines.ECHO_RESPONSE_TIMEOUT, ProtocolDefines.CONNECTION_IDLE_TIMEOUT_MD)
+        } else {
+            Triple(ProtocolDefines.ECHO_REQUEST_INTERVAL_CSP, ProtocolDefines.ECHO_RESPONSE_TIMEOUT, ProtocolDefines.CONNECTION_IDLE_TIMEOUT_CSP)
+        }
+        logger.debug("echoRequestInterval={}, echoResponseTimeout={}, connectionIdleTimeout={}", echoRequestInterval, echoResponseTimeout, connectionIdleTimeout)
+
         if (stopped) {
             logger.warn("Ignore attempt to start monitoring after monitoring has already been stopped")
         } else {
-            logger.trace("Set connection idle timeout to {} seconds", connectionIdleTimeoutS)
-            outbound.send(prepareSetConnectionIdleTimeout(connectionIdleTimeoutS))
+            logger.trace("Set connection idle timeout to {} seconds", connectionIdleTimeout)
+            outbound.send(prepareSetConnectionIdleTimeout(connectionIdleTimeout))
             logger.debug("Start periodic echo requests")
             echoRequestJob = CoroutineScope(controller.dispatcher.coroutineContext).launch {
                 while(true) {
-                    delay(ProtocolDefines.ECHO_REQUEST_INTERVAL * 1000L)
-                    sendEchoRequest()
+                    delay(echoRequestInterval * 1000L)
+                    val sequence = sendEchoRequest()
+                    launch {
+                        expectEchoResponse(sequence, echoResponseTimeout)
+                    }
                 }
             }
         }
@@ -230,16 +241,22 @@ internal class MonitoringLayer(
         echoRequestJob = null
     }
 
-    private suspend fun sendEchoRequest() {
+    /**
+     * @return the sequence number of the sent echo request
+     */
+    private fun sendEchoRequest(): Int {
         controller.dispatcher.assertDispatcherContext()
 
-        lastSentEchoSeq++
-        logger.info("Sending echo request (seq: $lastSentEchoSeq)")
-        outbound.send(prepareEchoRequest(lastSentEchoSeq))
+        val sequence = ++lastSentEchoSeq
+        logger.info("Sending echo request (seq: {})", sequence)
+        outbound.send(prepareEchoRequest(sequence))
+        return sequence
+    }
 
-        delay(ProtocolDefines.ECHO_RESPONSE_TIMEOUT * 1000L)
-        if (lastRcvdEchoSeq < lastSentEchoSeq) {
-            logger.info("No reply to echo request (seq: {}); terminate connection", lastSentEchoSeq)
+    private suspend fun expectEchoResponse(expectedSequence: Int, responseTimeoutS: Short) {
+        delay(responseTimeoutS * 1000L)
+        if (lastRcvdEchoSeq < expectedSequence) {
+            logger.info("No reply to echo request (seq: {}); terminate connection", expectedSequence)
             controller.ioProcessingStoppedSignal.completeExceptionally(ServerConnectionException("No reply to echo request"))
         }
     }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java b/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java
index 74861511..0602570e 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java
@@ -39,9 +39,11 @@ public class ProtocolDefines {
 	public static final int RECONNECT_MAX_INTERVAL = 10;
 
 	// Echo request timeouts (in seconds)
-	public static final short ECHO_REQUEST_INTERVAL = 60;
-	public static final short CONNECTION_IDLE_TIMEOUT = 120;
 	public static final short ECHO_RESPONSE_TIMEOUT = 10;
+	public static final short ECHO_REQUEST_INTERVAL_CSP = 60;
+	public static final short CONNECTION_IDLE_TIMEOUT_CSP = 120;
+	public static final short ECHO_REQUEST_INTERVAL_MD = 15;
+	public static final short CONNECTION_IDLE_TIMEOUT_MD = 30;
 
 	/* object lengths */
 	public static final int COOKIE_LEN = 16;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java b/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java
index dbf7bc45..45253473 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java
@@ -43,7 +43,6 @@ import java.util.HashMap;
 import java.util.Map;
 
 import ch.threema.base.ThreemaException;
-import ch.threema.base.crypto.NonceFactory;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.GroupId;
@@ -84,12 +83,9 @@ import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage;
 import ch.threema.domain.protocol.csp.messages.WebSessionResumeMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotData;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotId;
 import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.GroupPollVoteMessage;
-import ch.threema.domain.protocol.csp.messages.file.FileData;
 import ch.threema.domain.protocol.csp.messages.file.FileMessage;
 import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityData;
@@ -98,17 +94,11 @@ import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestData;
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestMessage;
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseData;
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseMessage;
-import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartData;
 import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage;
 import ch.threema.domain.stores.ContactStore;
 import ch.threema.domain.stores.IdentityStoreInterface;
@@ -284,12 +274,16 @@ public class MessageCoder {
 	 * @return boxed message
 	 */
 	public @NonNull
-	MessageBox encode(@NonNull AbstractMessage message, @NonNull byte[] nonce, @NonNull NonceFactory nonceFactory) throws ThreemaException {
+	MessageBox encode(@NonNull AbstractMessage message, @NonNull byte[] nonce) throws ThreemaException {
 		try {
 			/* prepare data for box */
 			ByteArrayOutputStream bos = new ByteArrayOutputStream();
 			bos.write(message.getType());
-			bos.write(message.getBody());
+            byte[] body = message.getBody();
+            if (body == null) {
+                throw new ThreemaException("Message body is null");
+            }
+            bos.write(body);
 
 			/* PKCS7 padding */
 			SecureRandom rnd = new SecureRandom();
@@ -314,11 +308,6 @@ public class MessageCoder {
 				throw new ThreemaException("Missing public key for ID " + message.getToIdentity());
 			}
 
-			/* Only save the nonce if the message is protected against replay */
-			if (message.protectAgainstReplay()) {
-				nonceFactory.store(nonce);
-			}
-
 			/* sign/encrypt with our private key */
 			byte[] boxedData = identityStore.encryptData(boxData, nonce, receiverPublicKey);
 			if (boxedData == null) {
@@ -376,17 +365,11 @@ public class MessageCoder {
 	private @NonNull AbstractMessage deserializeData(byte[] data, int realDataLength, String fromIdentity, String toIdentity) throws BadMessageException {
 		/* first byte of data is type */
 		int type = data[0] & 0xFF;
-		AbstractMessage msg;
+		AbstractMessage message;
 
 		switch (type) {
 			case ProtocolDefines.MSGTYPE_TEXT: {
-				if (realDataLength < 2) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for text message");
-				}
-
-				TextMessage textmsg = new TextMessage();
-				textmsg.setText(new String(data, 1, realDataLength - 1, UTF_8));
-				msg = textmsg;
+				message = TextMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
@@ -408,7 +391,7 @@ public class MessageCoder {
 				System.arraycopy(data, 1 + 4 + ProtocolDefines.BLOB_ID_LEN, nonce, 0, nonce.length);
 				imagemsg.setNonce(nonce);
 
-				msg = imagemsg;
+				message = imagemsg;
 
 				break;
 			}
@@ -444,7 +427,7 @@ public class MessageCoder {
 					throw new RuntimeException(e);
 				}
 
-				msg = videomsg;
+				message = videomsg;
 
 				break;
 			}
@@ -489,7 +472,7 @@ public class MessageCoder {
 					throw new BadMessageException("Invalid coordinate values in location message");
 				}
 
-				msg = locationmsg;
+				message = locationmsg;
 
 				break;
 			}
@@ -519,7 +502,7 @@ public class MessageCoder {
 					throw new RuntimeException(e);
 				}
 
-				msg = audiomsg;
+				message = audiomsg;
 
 				break;
 			}
@@ -539,7 +522,7 @@ public class MessageCoder {
 					members[i] = new String(data, 1 + ProtocolDefines.GROUP_ID_LEN + i * ProtocolDefines.IDENTITY_LEN, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII);
 				}
 				groupcreatemsg.setMembers(members);
-				msg = groupcreatemsg;
+				message = groupcreatemsg;
 				break;
 			}
 
@@ -552,7 +535,7 @@ public class MessageCoder {
 				groupSyncRequestMessage.setGroupCreator(toIdentity);
 				groupSyncRequestMessage.setApiGroupId(new GroupId(data, 1));
 
-				msg = groupSyncRequestMessage;
+				message = groupSyncRequestMessage;
 
 				break;
 			}
@@ -566,7 +549,7 @@ public class MessageCoder {
 				grouprenamemsg.setGroupCreator(fromIdentity);
 				grouprenamemsg.setApiGroupId(new GroupId(data, 1));
 				grouprenamemsg.setGroupName(new String(data, 1 + ProtocolDefines.GROUP_ID_LEN, realDataLength - 1 - ProtocolDefines.GROUP_ID_LEN, UTF_8));
-				msg = grouprenamemsg;
+				message = grouprenamemsg;
 
 				break;
 			}
@@ -579,20 +562,12 @@ public class MessageCoder {
 				GroupLeaveMessage groupleavemsg = new GroupLeaveMessage();
 				groupleavemsg.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
 				groupleavemsg.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				msg = groupleavemsg;
+				message = groupleavemsg;
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_TEXT: {
-				if (realDataLength < (1 + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN)) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for group text message");
-				}
-
-				GroupTextMessage grouptextmsg = new GroupTextMessage();
-				grouptextmsg.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				grouptextmsg.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				grouptextmsg.setText(new String(data, 1 + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN, realDataLength - 1 - ProtocolDefines.IDENTITY_LEN - ProtocolDefines.GROUP_ID_LEN, UTF_8));
-				msg = grouptextmsg;
+				message = GroupTextMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
@@ -616,7 +591,7 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupsetphotomsg.setEncryptionKey(blobKey);
-				msg = groupsetphotomsg;
+				message = groupsetphotomsg;
 
 				break;
 			}
@@ -630,7 +605,7 @@ public class MessageCoder {
 				groupDeleteProfilePictureMessage.setGroupCreator(fromIdentity);
 				groupDeleteProfilePictureMessage.setApiGroupId(new GroupId(data, 1));
 
-				msg = groupDeleteProfilePictureMessage;
+				message = groupDeleteProfilePictureMessage;
 
 				break;
 			}
@@ -656,7 +631,7 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupimagemsg.setEncryptionKey(blobKey);
-				msg = groupimagemsg;
+				message = groupimagemsg;
 
 				break;
 			}
@@ -690,7 +665,7 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupvideomsg.setEncryptionKey(blobKey);
-				msg = groupvideomsg;
+				message = groupvideomsg;
 
 				break;
 			}
@@ -731,7 +706,7 @@ public class MessageCoder {
 					throw new BadMessageException("Invalid coordinate values in group location message");
 				}
 
-				msg = grouplocationmsg;
+				message = grouplocationmsg;
 
 				break;
 			}
@@ -759,169 +734,67 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupaudiomsg.setEncryptionKey(blobKey);
-				msg = groupaudiomsg;
+				message = groupaudiomsg;
 
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_BALLOT_CREATE: {
-				PollSetupMessage groupPollSetupMessage = new PollSetupMessage();
-				int pos = 1;
-				groupPollSetupMessage.setBallotCreator(fromIdentity);
-				groupPollSetupMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-				groupPollSetupMessage.setData(BallotData.parse(new String(data, pos, realDataLength - pos, UTF_8)));
-				msg = groupPollSetupMessage;
+                message = PollSetupMessage.fromByteArray(data, 1, realDataLength - 1, fromIdentity);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_FILE: {
-				FileMessage fileMessage = new FileMessage();
-				int pos = 1;
-				fileMessage.setData(FileData.parse(new String(data, pos, realDataLength - pos, UTF_8)));
-				msg = fileMessage;
+				message = FileMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_BALLOT_VOTE: {
-				PollVoteMessage groupPollVoteMessage = new PollVoteMessage();
-				int pos = 1;
-
-				groupPollVoteMessage.setBallotCreator(new String(data, pos, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollVoteMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-
-				groupPollVoteMessage.parseVotes(new String(data, pos, realDataLength - pos, UTF_8));
-				msg = groupPollVoteMessage;
+				message = PollVoteMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_BALLOT_CREATE: {
-				GroupPollSetupMessage groupPollSetupMessage = new GroupPollSetupMessage();
-				int pos = 1;
-				groupPollSetupMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollSetupMessage.setApiGroupId(new GroupId(data, pos));
-				pos += ProtocolDefines.GROUP_ID_LEN;
-
-				groupPollSetupMessage.setBallotCreator(fromIdentity);
-				groupPollSetupMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-
-				String jsonObjectString = new String(data, pos, realDataLength - pos, UTF_8);
-				groupPollSetupMessage.setData(BallotData.parse(jsonObjectString));
-				groupPollSetupMessage.setRawBallotData(jsonObjectString);
-				msg = groupPollSetupMessage;
+				message = GroupPollSetupMessage.fromByteArray(data, 1, realDataLength - 1, fromIdentity);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_FILE: {
-				GroupFileMessage groupFileMessage = new GroupFileMessage();
-				int pos = 1;
-				groupFileMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupFileMessage.setApiGroupId(new GroupId(data, pos));
-				pos += ProtocolDefines.GROUP_ID_LEN;
-
-				final String jsonObjectString = new String(data, pos, realDataLength - pos, UTF_8);
-				groupFileMessage.setData(FileData.parse(jsonObjectString));
-				msg = groupFileMessage;
+				message = GroupFileMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_BALLOT_VOTE: {
-				GroupPollVoteMessage groupPollVoteMessage = new GroupPollVoteMessage();
-				int pos = 1;
-				groupPollVoteMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollVoteMessage.setApiGroupId(new GroupId(data, pos));
-				pos += ProtocolDefines.GROUP_ID_LEN;
-
-				groupPollVoteMessage.setBallotCreator(new String(data, pos, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollVoteMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-
-				groupPollVoteMessage.parseVotes(new String(data, pos, realDataLength - pos, UTF_8));
-				msg = groupPollVoteMessage;
+				message = GroupPollVoteMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_JOIN_REQUEST: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final GroupJoinRequestData groupJoinRequestData = GroupJoinRequestData.fromProtobuf(protobufPayload);
-				msg = new GroupJoinRequestMessage(groupJoinRequestData);
+				message = new GroupJoinRequestMessage(groupJoinRequestData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_JOIN_RESPONSE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final GroupJoinResponseData groupJoinResponseData = GroupJoinResponseData.fromProtobuf(protobufPayload);
-				msg = new GroupJoinResponseMessage(groupJoinResponseData);
+				message = new GroupJoinResponseMessage(groupJoinResponseData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_CALL_START: {
-				int headerLength = 1 + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
-				if (realDataLength < headerLength) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for group call start message");
-				}
-
-				final byte[] protobufPayload = Arrays.copyOfRange(data, headerLength, realDataLength);
-				final GroupCallStartData groupCallStartData = GroupCallStartData.fromProtobuf(protobufPayload);
-				final GroupCallStartMessage callStartMessage = new GroupCallStartMessage(groupCallStartData);
-				callStartMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				callStartMessage.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				msg = callStartMessage;
+                message = GroupCallStartMessage.fromByteArray(data, 1, realDataLength -1 );
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_DELIVERY_RECEIPT: {
-				if (realDataLength < ProtocolDefines.MESSAGE_ID_LEN + 2 || ((realDataLength - 2) % ProtocolDefines.MESSAGE_ID_LEN) != 0) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for delivery receipt");
-				}
-
-				DeliveryReceiptMessage receiptmsg = new DeliveryReceiptMessage();
-				receiptmsg.setReceiptType(data[1] & 0xFF);
-
-				int numMsgIds = ((realDataLength - 2) / ProtocolDefines.MESSAGE_ID_LEN);
-				MessageId[] receiptMessageIds = new MessageId[numMsgIds];
-				for (int i = 0; i < numMsgIds; i++) {
-					receiptMessageIds[i] = new MessageId(data, 2 + i * ProtocolDefines.MESSAGE_ID_LEN);
-				}
-
-				receiptmsg.setReceiptMessageIds(receiptMessageIds);
-				msg = receiptmsg;
-
+				message = DeliveryReceiptMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_DELIVERY_RECEIPT: {
-				int groupHeaderLength = ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
-				if ((realDataLength - groupHeaderLength) < ProtocolDefines.MESSAGE_ID_LEN + 2 || ((realDataLength - groupHeaderLength - 2) % ProtocolDefines.MESSAGE_ID_LEN) != 0) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for group delivery receipt");
-				}
-
-				GroupDeliveryReceiptMessage receiptmsg = new GroupDeliveryReceiptMessage();
-				receiptmsg.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				receiptmsg.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				receiptmsg.setReceiptType(data[groupHeaderLength + 1] & 0xFF);
-
-				int numMsgIds = ((realDataLength - groupHeaderLength - 2) / ProtocolDefines.MESSAGE_ID_LEN);
-				MessageId[] receiptMessageIds = new MessageId[numMsgIds];
-				for (int i = 0; i < numMsgIds; i++) {
-					receiptMessageIds[i] = new MessageId(data, groupHeaderLength + 2 + i * ProtocolDefines.MESSAGE_ID_LEN);
-				}
-
-				receiptmsg.setReceiptMessageIds(receiptMessageIds);
-				msg = receiptmsg;
-
+                message = GroupDeliveryReceiptMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
@@ -932,100 +805,59 @@ public class MessageCoder {
 
 				TypingIndicatorMessage typingmsg = new TypingIndicatorMessage();
 				typingmsg.setTyping((data[1] & 0xFF) > 0);
-				msg = typingmsg;
+				message = typingmsg;
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_CONTACT_SET_PHOTO: {
-				if (realDataLength != (1 + ProtocolDefines.BLOB_ID_LEN + 4 + ProtocolDefines.BLOB_KEY_LEN)) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for contact set photo message");
-				}
-
-				SetProfilePictureMessage setProfilePictureMessage = new SetProfilePictureMessage();
-				setProfilePictureMessage.setFromIdentity(fromIdentity);
-
-				int i = 1;
-				byte[] blobId = new byte[ProtocolDefines.BLOB_ID_LEN];
-				System.arraycopy(data, i, blobId, 0, ProtocolDefines.BLOB_ID_LEN);
-				i += ProtocolDefines.BLOB_ID_LEN;
-				setProfilePictureMessage.setBlobId(blobId);
-				setProfilePictureMessage.setSize(EndianUtils.readSwappedInteger(data, i));
-				i += 4;
-				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
-				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
-				setProfilePictureMessage.setEncryptionKey(blobKey);
-				msg = setProfilePictureMessage;
-
+                message = SetProfilePictureMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_CONTACT_DELETE_PHOTO: {
-				if (realDataLength != 1) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for contact delete photo message");
-				}
-				msg = new DeleteProfilePictureMessage();
-
+                message = DeleteProfilePictureMessage.fromByteArray(data, 1, realDataLength -1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_CONTACT_REQUEST_PHOTO: {
-				if (realDataLength != 1) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for contact request photo message");
-				}
-				msg = new ContactRequestProfilePictureMessage();
-
+                message = ContactRequestProfilePictureMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_OFFER: {
-				final VoipCallOfferData offerData = VoipCallOfferData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallOfferMessage().setData(offerData);
+				message = VoipCallOfferMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_ANSWER: {
-				final VoipCallAnswerData answerData = VoipCallAnswerData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallAnswerMessage().setData(answerData);
+				message = VoipCallAnswerMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_ICE_CANDIDATES: {
-				final VoipICECandidatesData candidatesData = VoipICECandidatesData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipICECandidatesMessage().setData(candidatesData);
+				message = VoipICECandidatesMessage.fromByteArray(data, 1, realDataLength -1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_HANGUP: {
-				final VoipCallHangupData hangupData = VoipCallHangupData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallHangupMessage().setData(hangupData);
+				message = VoipCallHangupMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_RINGING: {
-				final VoipCallRingingData ringingData = VoipCallRingingData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallRingingMessage().setData(ringingData);
+				message = VoipCallRingingMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_FS_ENVELOPE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final ForwardSecurityData forwardSecurityData = ForwardSecurityData.fromProtobuf(protobufPayload);
-				msg = new ForwardSecurityEnvelopeMessage(forwardSecurityData);
+				message = new ForwardSecurityEnvelopeMessage(forwardSecurityData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_EMPTY: {
-				msg = new EmptyMessage();
+				message = new EmptyMessage();
 				break;
 			}
 
@@ -1042,21 +874,21 @@ public class MessageCoder {
 				} catch (JSONException e) {
 					throw new BadMessageException(e.getMessage());
 				}
-				msg = new WebSessionResumeMessage(webSessionResumeData);
+				message = new WebSessionResumeMessage(webSessionResumeData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_EDIT_MESSAGE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final EditMessageData editMessageData = EditMessageData.fromProtobuf(protobufPayload);
-				msg = new EditMessage(editMessageData);
+				message = new EditMessage(editMessageData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_DELETE_MESSAGE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final DeleteMessageData deleteMessageData = DeleteMessageData.fromProtobuf(protobufPayload);
-				msg = new DeleteMessage(deleteMessageData);
+				message = new DeleteMessage(deleteMessageData);
 				break;
 			}
 
@@ -1074,7 +906,7 @@ public class MessageCoder {
 				editMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
 				editMessage.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
 
-				msg = editMessage;
+				message = editMessage;
 
 				break;
 			}
@@ -1093,7 +925,7 @@ public class MessageCoder {
 				deleteMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
 				deleteMessage.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
 
-				msg = deleteMessage;
+				message = deleteMessage;
 
 				break;
 			}
@@ -1102,6 +934,6 @@ public class MessageCoder {
 				throw new BadMessageException("Unsupported message type " + type);
 		}
 
-		return msg;
+		return message;
 	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt
index c66bf3b9..8e763c15 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt
@@ -22,13 +22,18 @@
 package ch.threema.domain.protocol.csp.fs
 
 import ch.threema.base.ThreemaException
+import ch.threema.base.crypto.Nonce
 import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceScope
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.fs.DHSession
 import ch.threema.domain.fs.DHSession.RejectMessageError
 import ch.threema.domain.fs.DHSessionId
 import ch.threema.domain.fs.KDFRatchet.RatchetRotationException
+import ch.threema.domain.models.BasicContact
 import ch.threema.domain.models.Contact
+import ch.threema.domain.protocol.ThreemaFeature
+import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.domain.protocol.csp.coders.MessageCoder
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
 import ch.threema.domain.protocol.csp.messages.AbstractMessage
@@ -47,8 +52,8 @@ import ch.threema.domain.stores.DHSessionStoreException
 import ch.threema.domain.stores.DHSessionStoreInterface
 import ch.threema.domain.stores.IdentityStoreInterface
 import ch.threema.domain.taskmanager.ActiveTaskCodec
+import ch.threema.domain.taskmanager.awaitOutgoingMessageAck
 import ch.threema.domain.taskmanager.toCspMessage
-import ch.threema.domain.taskmanager.waitForServerAck
 import ch.threema.protobuf.Common.GroupIdentity
 import ch.threema.protobuf.csp.e2e.fs.Encapsulated.DHType
 import ch.threema.protobuf.csp.e2e.fs.Reject
@@ -93,8 +98,8 @@ class ForwardSecurityMessageProcessor(
     /**
      * Set whether forward security is enabled.
      *
-     * If disabled calls to [makeMessage] will throw an exception and received fs messages will be
-     * answered with a [Terminate].
+     * If disabled, [runFsEncapsulationSteps] does not encapsulate the message and received fs
+     * messages will be answered with a [Terminate].
      *
      * TODO(ANDR-2519): Remove when md allows fs
      */
@@ -132,29 +137,80 @@ class ForwardSecurityMessageProcessor(
     }
 
     /**
-     * Encapsulate the message for sending it with forward security. This method returns a
-     * [ForwardSecurityEncryptionResult] that contains a list of all message that should be sent out
-     * and the forward security mode of the given message. The list of messages may contain an init
-     * or an empty forward security message. The given inner message is always part of the returned
-     * list - either encapsulated or in its original form if it cannot be encapsulated in the
-     * existing session.
+     * Run the forward security encapsulation steps for the given recipient and inner message.
      *
      * Note that this result must be used to commit the forward security session after all messages
      * of this result have been acknowledged by the server. To commit the forward security session
      * use [commitSessionState].
      *
+     * @param recipient    the recipient of the [innerMessage]
+     * @param innerMessage the message that will be encapsulated if the session allows it
+     * @param nonce        the nonce that will be used for the [innerMessage]. Note that the nonce
+     *                     is only appended to the corresponding [innerMessage] in the result.
+     * @param nonceFactory the nonce factory is only used to pre generate a nonce for every outgoing
+     *                     message
+     * @param handle       the task codec that is only used to communicate an illegal state of a
+     *                     session to the chat partner
+     *
+     * @return a [ForwardSecurityEncryptionResult] with the outgoing messages and their nonce
+     */
+    fun runFsEncapsulationSteps(
+        recipient: BasicContact,
+        innerMessage: AbstractMessage,
+        nonce: Nonce,
+        nonceFactory: NonceFactory,
+        handle: ActiveTaskCodec,
+    ): ForwardSecurityEncryptionResult {
+        //TODO(ANDR-2519): Remove when md allows fs
+        val senderCanForwardSecurity = isForwardSecurityEnabled()
+        val recipientCanForwardSecurity =
+            ThreemaFeature.canForwardSecurity(recipient.featureMask.toLong())
+        val innerMessageEncapsulated = innerMessage is ForwardSecurityEnvelopeMessage
+
+        // Create forward security encryption result
+        val (outgoingMessages, session) =
+            if (senderCanForwardSecurity && recipientCanForwardSecurity && !innerMessageEncapsulated) {
+                makeMessage(recipient, innerMessage, handle)
+            } else {
+                listOf(innerMessage) to null
+            }
+
+        // Get the forward security mode from the encryption result if available, otherwise take
+        // the forward security mode of the inner message.
+        val forwardSecurityMode = outgoingMessages.last().forwardSecurityMode
+
+        // Create a nonce for every outgoing message. Note that the nonce will be saved when the
+        // message is encoded (depending on the message type)
+        val nonces = outgoingMessages.dropLast(1).map { nonceFactory.next(NonceScope.CSP) }
+
+        return ForwardSecurityEncryptionResult(
+            outgoingMessages zip (nonces + nonce),
+            session,
+            forwardSecurityMode,
+        )
+    }
+
+    /**
+     * Encapsulate the message for sending it with forward security. This method returns a list of
+     * messages to be sent in the same order and an updated dh session. The list of messages may
+     * contain an init or an empty forward security message. The given inner message is always part
+     * of the returned list - either encapsulated or in its original form if it cannot be
+     * encapsulated in the existing session.
+     *
      * @param contact      the recipient identity
      * @param innerMessage the inner message that may get encapsulated
      * @param handle       the task codec that is only used to communicate an illegal state of a
      *                     session to the chat partner
-     * @return a [ForwardSecurityEncryptionResult] that contains the encapsulated message
+     * @return the encapsulated messages and an updated dh session
+     *
+     * @throws IllegalStateException if [isFsEnabled] is false
      */
     @Throws(ThreemaException::class)
-    fun makeMessage(
+    private fun makeMessage(
         contact: Contact,
         innerMessage: AbstractMessage,
         handle: ActiveTaskCodec,
-    ): ForwardSecurityEncryptionResult {
+    ): Pair<List<AbstractMessage>, DHSession> {
         // TODO(ANDR-2519): Remove when md allows fs
         if (!isFsEnabled) {
             throw IllegalStateException("Sending messages with fs is not supported locally")
@@ -206,11 +262,7 @@ class ForwardSecurityMessageProcessor(
                 )
 
                 // If the session has been newly created, add the inner message un-encapsulated
-                return ForwardSecurityEncryptionResult(
-                    initMessage,
-                    innerMessage,
-                    session
-                )
+                return listOfNotNull(initMessage, innerMessage) to session
             }
         }
 
@@ -245,20 +297,13 @@ class ForwardSecurityMessageProcessor(
                 // after the outgoing messages have been acknowledged by the server.
                 session.lastOutgoingMessageTimestamp = now
             }
-            ForwardSecurityEncryptionResult(
-                emptyMessage,
-                innerMessage,
-                session
-            )
+            listOfNotNull(emptyMessage, innerMessage) to session
         } else {
             // Update the session, but do not yet persist this change. It must only be persisted
             // after the outgoing messages have been acknowledged by the server.
             session.lastOutgoingMessageTimestamp = Date().time
-            ForwardSecurityEncryptionResult(
-                initMessage,
-                encapsulateMessage(session, innerMessage, isExistingSession),
-                session
-            )
+            val encapsulatedMessage = encapsulateMessage(session, innerMessage, isExistingSession)
+            listOfNotNull(initMessage, encapsulatedMessage) to session
         }
     }
 
@@ -269,8 +314,10 @@ class ForwardSecurityMessageProcessor(
      * @param result the encryption result that was generated when encrypting the messages
      */
     fun commitSessionState(result: ForwardSecurityEncryptionResult) {
+        val updatedSessionState = result.updatedSessionState ?: return
+
         try {
-            dhSessionStoreInterface.storeDHSession(result.updatedSessionState)
+            dhSessionStoreInterface.storeDHSession(updatedSessionState)
         } catch (e: DHSessionStoreException) {
             logger.error("Could not store updated session state", e)
         }
@@ -835,13 +882,8 @@ class ForwardSecurityMessageProcessor(
         val message = ForwardSecurityEnvelopeMessage(init, true)
         message.toIdentity = contact.identity
 
-        handle.write(
-            message.toCspMessage(
-                identityStoreInterface, contactStore, nonceFactory, nonceFactory.next(false)
-            )
-        )
-
-        handle.waitForServerAck(message.messageId, message.toIdentity)
+        // Send and await server ack
+        sendMessageToContact(message, handle)
 
         // As soon as the server ack has been received, we store the session locally.
         dhSessionStoreInterface.storeDHSession(session)
@@ -860,15 +902,7 @@ class ForwardSecurityMessageProcessor(
             emptyMessage.messageId,
             emptyMessage.toIdentity
         )
-        handle.write(
-            fsMessage.toCspMessage(
-                identityStoreInterface,
-                contactStore,
-                nonceFactory,
-                nonceFactory.next(false)
-            )
-        )
-        handle.waitForServerAck(fsMessage.messageId, fsMessage.toIdentity)
+        sendMessageToContact(fsMessage, handle)
     }
 
     @Throws(ThreemaException::class)
@@ -905,12 +939,7 @@ class ForwardSecurityMessageProcessor(
         // Symmetrically encrypt message (type byte + body)
         val bos = ByteArrayOutputStream()
         bos.write(message.type)
-        try {
-            bos.write(message.body)
-        } catch (e: IOException) {
-            // Should never happen
-            throw RuntimeException(e)
-        }
+        message.body?.let { bos.write(it) } ?: throw ThreemaException("Message body is null")
         val plaintext = bos.toByteArray()
         // A new key is used for each message, so the nonce can be zero
         val nonce = ByteArray(NaCl.NONCEBYTES)
@@ -1032,17 +1061,22 @@ class ForwardSecurityMessageProcessor(
             contact.identity
         )
 
-        // Note that the nonce may be saved when it is sent (depending on message type)
-        val nonce = nonceFactory.next(false)
-        handle.write(
-            message.toCspMessage(
-                identityStoreInterface,
-                contactStore,
-                nonceFactory,
-                nonce
-            )
-        )
-        handle.waitForServerAck(message.messageId, message.toIdentity)
+        sendMessageToContact(message, handle)
+    }
+
+    /**
+     * Send the [message] to the contact that is specified as 'toIdentity'. Stores the nonce
+     * depending on the message type and awaits the server ack if expected to receive one.
+     */
+    private suspend fun sendMessageToContact(message: AbstractMessage, handle: ActiveTaskCodec) {
+        val nonce = nonceFactory.next(NonceScope.CSP)
+        handle.write(message.toCspMessage(identityStoreInterface, contactStore, nonce))
+        if (message.protectAgainstReplay()) {
+            nonceFactory.store(NonceScope.CSP, nonce)
+        }
+        if (!message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK)) {
+            handle.awaitOutgoingMessageAck(message.messageId, message.toIdentity)
+        }
     }
 
     /**
@@ -1166,37 +1200,28 @@ class ForwardSecurityDecryptionResult(
 
 /**
  * This is the result we get when encrypting a message with forward security. It contains a list
- * of messages that should be sent out in the same order. After a server acknowledge has been
- * received, this result should be used to commit the session. For more details see
- * [ForwardSecurityMessageProcessor.makeMessage] and
+ * of messages and nonces that should be sent out in the same order. After a server acknowledge has
+ * been received, this result should be used to commit the session. For more details see
+ * [ForwardSecurityMessageProcessor.runFsEncapsulationSteps] and
  * [ForwardSecurityMessageProcessor.commitSessionState].
  */
 class ForwardSecurityEncryptionResult(
-    preFSMessage: ForwardSecurityEnvelopeMessage?,
-    message: AbstractMessage,
+    /**
+     * This contains the outgoing messages and the nonces that will be used. These messages must be
+     * sent in the same order as in this list.
+     */
+    val outgoingMessages: List<Pair<AbstractMessage, Nonce>>,
     /**
      * This is the updated session state of the session in which the message(s) should be sent. This
      * state must be committed once all the messages have been successfully acknowledged by the
      * server.
      */
-    internal val updatedSessionState: DHSession,
-) {
-    /**
-     * This contains the outgoing messages including the aimed message. These messages must be sent
-     * in the same order as in this list.
-     */
-    val outgoingMessages: List<AbstractMessage>
-
+    internal val updatedSessionState: DHSession?,
     /**
      * The forward security mode of the aimed message.
      */
-    val forwardSecurityMode: ForwardSecurityMode
-
-    init {
-        outgoingMessages = listOfNotNull(preFSMessage, message)
-        forwardSecurityMode = message.forwardSecurityMode
-    }
-}
+    val forwardSecurityMode: ForwardSecurityMode,
+)
 
 
 class UnknownMessageTypeException(msg: String) : ThreemaException(msg)
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java
index 81fc51fb..d0213401 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java
@@ -23,6 +23,7 @@ package ch.threema.domain.protocol.csp.messages;
 
 import java.util.Date;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.models.MessageId;
@@ -30,6 +31,7 @@ import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.coders.MessageBox;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
 
 /**
  * Abstract base class for messages that can be sent via the Threema server interface,
@@ -68,10 +70,13 @@ public abstract class AbstractMessage implements MessageTypeProperties, MessageF
 	public abstract Version getMinimumRequiredForwardSecurityVersion();
 
 	/**
-	 * Return the body of this message in network format (i.e. formatted as a byte array).
+	 * Return the body of this message in network format (i.e. formatted as a byte array). Note that
+     * a valid message should not return null. If null is returned, this is an indication that the
+     * message hasn't been initialized properly.
 	 *
 	 * @return message body
 	 */
+    @Nullable
 	public abstract byte[] getBody() throws ThreemaException;
 
 	/* Getters/Setters */
@@ -164,4 +169,25 @@ public abstract class AbstractMessage implements MessageTypeProperties, MessageF
 	public void setForwardSecurityMode(ForwardSecurityMode forwardSecurityMode) {
 		this.forwardSecurityMode = forwardSecurityMode;
 	}
+
+	/**
+	 * Initialize common properties from a reflected incoming message.
+	 *
+	 * @param message the incoming MdD2D message
+	 */
+	protected void initializeCommonProperties(@NonNull MdD2D.IncomingMessage message) {
+		this.fromIdentity = message.getSenderIdentity();
+		this.messageId = new MessageId(message.getMessageId());
+		this.date = new Date(message.getCreatedAt());
+	}
+
+    /**
+     * Initialize common properties for an outgoing message.
+     *
+     * @param message the outgoing MdD2D message
+     */
+	protected void initializeCommonProperties(@NonNull MdD2D.OutgoingMessage message) {
+		this.messageId = new MessageId((message.getMessageId()));
+		this.date = new Date(message.getCreatedAt());
+	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java
index f9f4e136..95d0beed 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java
@@ -22,11 +22,13 @@
 package ch.threema.domain.protocol.csp.messages;
 
 import org.apache.commons.io.EndianUtils;
+import org.slf4j.Logger;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 
 import androidx.annotation.Nullable;
+import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 
@@ -40,6 +42,9 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
  */
 @Deprecated
 public class AudioMessage extends AbstractMessage {
+
+    private final static Logger logger = LoggingUtil.getThreemaLogger("AudioMessage");
+
 	private int duration;
 	private byte[] audioBlobId;
 	private int audioSize;
@@ -95,6 +100,11 @@ public class AudioMessage extends AbstractMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return true;
@@ -106,6 +116,7 @@ public class AudioMessage extends AbstractMessage {
 	}
 
 	@Override
+    @Nullable
 	public byte[] getBody() {
 		ByteArrayOutputStream bos = new ByteArrayOutputStream();
 
@@ -114,11 +125,11 @@ public class AudioMessage extends AbstractMessage {
 			bos.write(audioBlobId);
 			EndianUtils.writeSwappedInteger(bos, audioSize);
 			bos.write(encryptionKey);
+            return bos.toByteArray();
 		} catch (IOException e) {
-			throw new RuntimeException(e);
+            logger.error("Cannot create body of message", e);
+            return null;
 		}
-
-		return bos.toByteArray();
 	}
 
 	public int getDuration() {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.java
deleted file mode 100644
index 37ceca73..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class ContactRequestProfilePictureMessage extends AbstractMessage {
-
-	public ContactRequestProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_CONTACT_REQUEST_PHOTO;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return false;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		return new byte[0];
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.kt
new file mode 100644
index 00000000..05145b1a
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.kt
@@ -0,0 +1,110 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2018-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages
+
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+
+class ContactRequestProfilePictureMessage : AbstractMessage() {
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_CONTACT_REQUEST_PHOTO
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_1
+
+    override fun allowUserProfileDistribution(): Boolean = false
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = false
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    override fun getBody(): ByteArray = ByteArray(0)
+
+    companion object {
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): ContactRequestProfilePictureMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.OutgoingMessage): ContactRequestProfilePictureMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray): ContactRequestProfilePictureMessage =
+            fromByteArray(
+                data = data,
+                offset = 0,
+                length = data.size
+            )
+
+        /**
+         * Get the request contact profile picture message from the given array.
+         *
+         * @param data   the data that represents the message
+         * @param offset the offset where the data starts
+         * @param length the length of the data (needed to ignore the padding)
+         * @return the contact request profile picture message
+         * @throws BadMessageException if the length is invalid
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(
+            data: ByteArray,
+            offset: Int,
+            length: Int,
+        ): ContactRequestProfilePictureMessage = when {
+            length > 0 -> {
+                throw BadMessageException("Bad length ($length) for contact request profile picture message")
+            }
+
+            offset < 0 -> {
+                throw BadMessageException("Bad offset ($offset) for contact request profile picture message")
+            }
+
+            data.size < length + offset -> {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            else -> ContactRequestProfilePictureMessage()
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt
index 83155a7c..966a4d13 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt
@@ -47,6 +47,8 @@ class DeleteMessage(payloadData: DeleteMessageData) : AbstractProtobufMessage<De
 
     override fun reflectOutgoing() = true
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate() = false
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.java
deleted file mode 100644
index 9d75e8e5..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class DeleteProfilePictureMessage extends AbstractMessage {
-
-	public DeleteProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_CONTACT_DELETE_PHOTO;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		return new byte[0];
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.kt
new file mode 100644
index 00000000..a9ab52e6
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.kt
@@ -0,0 +1,107 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages
+
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+
+class DeleteProfilePictureMessage : AbstractMessage() {
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_CONTACT_DELETE_PHOTO
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_1
+
+    override fun allowUserProfileDistribution(): Boolean = false
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    override fun getBody(): ByteArray = ByteArray(0)
+
+    companion object {
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): DeleteProfilePictureMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.OutgoingMessage): DeleteProfilePictureMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray): DeleteProfilePictureMessage =
+            fromByteArray(
+                data = data,
+                offset = 0,
+                length = data.size
+            )
+
+        /**
+         * Get the delete profile picture message from the given array.
+         *
+         * @param data   the data that represents the message
+         * @param offset the offset where the data starts
+         * @param length the length of the data (needed to ignore the padding)
+         * @return the delete profile picture message
+         * @throws BadMessageException if the length is invalid
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): DeleteProfilePictureMessage =
+            when {
+                length > 0 -> {
+                    throw BadMessageException("Bad length ($length) for delete profile picture message")
+                }
+
+                offset < 0 -> {
+                    throw BadMessageException("Bad offset ($offset) for delete profile picture message")
+                }
+
+                data.size < length + offset -> {
+                    throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+                }
+
+                else -> DeleteProfilePictureMessage()
+            }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java
index 046c131f..fb68edd9 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java
@@ -26,11 +26,13 @@ import org.slf4j.Logger;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
 
 /**
  * A message that confirms delivery of one or multiple other messages, listed with their
@@ -93,6 +95,11 @@ public class DeliveryReceiptMessage extends AbstractMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -104,6 +111,7 @@ public class DeliveryReceiptMessage extends AbstractMessage {
 	}
 
 	@Override
+    @NonNull
 	public byte[] getBody() {
 
 		ByteArrayOutputStream bos = new ByteArrayOutputStream();
@@ -136,4 +144,64 @@ public class DeliveryReceiptMessage extends AbstractMessage {
 	public void setReceiptMessageIds(MessageId[] receiptMessageIds) {
 		this.receiptMessageIds = receiptMessageIds;
 	}
+
+	@NonNull
+	public static DeliveryReceiptMessage fromReflected(@NonNull MdD2D.IncomingMessage message) throws BadMessageException {
+		DeliveryReceiptMessage deliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+		deliveryReceiptMessage.initializeCommonProperties(message);
+		return deliveryReceiptMessage;
+	}
+
+	@NonNull
+	public static DeliveryReceiptMessage fromReflected(@NonNull MdD2D.OutgoingMessage message) throws BadMessageException {
+		DeliveryReceiptMessage deliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+		deliveryReceiptMessage.initializeCommonProperties(message);
+		return deliveryReceiptMessage;
+	}
+
+	@NonNull
+	public static DeliveryReceiptMessage fromByteArray(@NonNull byte[] data) throws BadMessageException {
+		return fromByteArray(data, 0, data.length);
+	}
+
+	/**
+	 * Get the delivery receipt message from the given array.
+	 *
+	 * @param data   the data that represents the message
+	 * @param offset the offset where the data starts
+	 * @param length the length of the data (needed to ignore the padding)
+	 * @return the delivery receipt message
+	 * @throws BadMessageException if the length is invalid
+	 */
+	@NonNull
+	public static DeliveryReceiptMessage fromByteArray(@NonNull byte[] data, int offset, int length) throws BadMessageException {
+		if (data.length < offset + length) {
+			throw new BadMessageException("Invalid byte array length (" + data.length + ") for " +
+				"offset " + offset + " and length " + length);
+		}
+
+		int deliveryReceiptTypeLength = 1;
+		int minDataLength = ProtocolDefines.MESSAGE_ID_LEN + deliveryReceiptTypeLength;
+		int messageIdsLength = length - deliveryReceiptTypeLength;
+
+		if (length < minDataLength || (messageIdsLength % ProtocolDefines.MESSAGE_ID_LEN) != 0) {
+			throw new BadMessageException("Bad length (" + length + ") for delivery receipt");
+		}
+
+		DeliveryReceiptMessage deliveryReceiptMessage = new DeliveryReceiptMessage();
+		deliveryReceiptMessage.setReceiptType(data[offset] & 0xFF);
+
+		// The offset where the message ids start
+		int messageIdsOffset = deliveryReceiptTypeLength + offset;
+
+		int numMsgIds = (messageIdsLength / ProtocolDefines.MESSAGE_ID_LEN);
+		MessageId[] receiptMessageIds = new MessageId[numMsgIds];
+		for (int i = 0; i < numMsgIds; i++) {
+			receiptMessageIds[i] = new MessageId(data, messageIdsOffset + i * ProtocolDefines.MESSAGE_ID_LEN);
+		}
+
+		deliveryReceiptMessage.setReceiptMessageIds(receiptMessageIds);
+
+		return deliveryReceiptMessage;
+	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt
index 04e7f6f5..1fba6f32 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt
@@ -47,6 +47,8 @@ class EditMessage(payloadData: EditMessageData) : AbstractProtobufMessage<EditMe
 
     override fun reflectOutgoing() = true
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate() = false
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt
index db4a02e8..d1ab72ed 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt
@@ -46,6 +46,8 @@ class EmptyMessage : AbstractMessage() {
 
     override fun reflectOutgoing() = false
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate() = false
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java
index 1cf44c62..15eb797b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java
@@ -22,12 +22,14 @@
 package ch.threema.domain.protocol.csp.messages;
 
 import org.apache.commons.io.EndianUtils;
+import org.slf4j.Logger;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 
 import androidx.annotation.Nullable;
+import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 
@@ -42,7 +44,9 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
 @Deprecated
 public class GroupAudioMessage extends AbstractGroupMessage {
 
-	private int duration;
+    private final static Logger logger = LoggingUtil.getThreemaLogger("GroupAudioMessage");
+
+    private int duration;
 	private byte[] audioBlobId;
 	private int audioSize;
 	private byte[] encryptionKey;
@@ -97,6 +101,11 @@ public class GroupAudioMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -108,6 +117,7 @@ public class GroupAudioMessage extends AbstractGroupMessage {
 	}
 
 	@Override
+    @Nullable
 	public byte[] getBody() {
 		ByteArrayOutputStream bos = new ByteArrayOutputStream();
 
@@ -118,11 +128,11 @@ public class GroupAudioMessage extends AbstractGroupMessage {
 			bos.write(audioBlobId);
 			EndianUtils.writeSwappedInteger(bos, audioSize);
 			bos.write(encryptionKey);
+            return bos.toByteArray();
 		} catch (IOException e) {
-			throw new RuntimeException(e);
+            logger.error("Cannot create body of message", e);
+            return null;
 		}
-
-		return bos.toByteArray();
 	}
 
 	public int getDuration() {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt
index 623dc1c6..c76d9b64 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt
@@ -43,6 +43,8 @@ class GroupDeleteMessage(payloadData: DeleteMessageData) : AbstractProtobufGroup
 
     override fun reflectOutgoing() = true
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate() = false
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java
index 63c61f19..8732e320 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java
@@ -82,6 +82,11 @@ public class GroupDeleteProfilePictureMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -93,6 +98,7 @@ public class GroupDeleteProfilePictureMessage extends AbstractGroupMessage {
 	}
 
 	@Override
+    @Nullable
 	public byte[] getBody() {
 		try {
 			ByteArrayOutputStream bos = new ByteArrayOutputStream();
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java
index ab2f8d7b..b5b87ac1 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java
@@ -26,11 +26,14 @@ import org.slf4j.Logger;
 import java.io.ByteArrayOutputStream;
 import java.nio.charset.StandardCharsets;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
 
 /**
  * A message that confirms delivery of one or multiple other messages, listed with their
@@ -39,102 +42,172 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
  */
 public class GroupDeliveryReceiptMessage extends AbstractGroupMessage {
 
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupDeliveryReceiptMessage");
-
-	private int receiptType;
-	private MessageId[] receiptMessageIds;
-
-	public GroupDeliveryReceiptMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_DELIVERY_RECEIPT;
-	}
-
-	private boolean isReaction() {
-		return DeliveryReceiptUtils.isReaction(this.receiptType);
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return this.isReaction();
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return isReaction();
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		ByteArrayOutputStream bos = new ByteArrayOutputStream();
-		try {
-			bos.write(getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(getApiGroupId().getGroupId());
-			bos.write((byte) receiptType);
-
-			for (MessageId messageId : receiptMessageIds) {
-				bos.write(messageId.getMessageId());
-			}
-			return bos.toByteArray();
-
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-		}
-		return null;
-	}
-
-	public int getReceiptType() {
-		return receiptType;
-	}
-
-	public void setReceiptType(int receiptType) {
-		this.receiptType = receiptType;
-	}
-
-	public MessageId[] getReceiptMessageIds() {
-		return receiptMessageIds;
-	}
-
-	public void setReceiptMessageIds(MessageId[] receiptMessageIds) {
-		this.receiptMessageIds = receiptMessageIds;
-	}
+    private static final Logger logger = LoggingUtil.getThreemaLogger("GroupDeliveryReceiptMessage");
+
+    private int receiptType;
+    private MessageId[] receiptMessageIds;
+
+    public GroupDeliveryReceiptMessage() {
+        super();
+    }
+
+    @Override
+    public int getType() {
+        return ProtocolDefines.MSGTYPE_GROUP_DELIVERY_RECEIPT;
+    }
+
+    private boolean isReaction() {
+        return DeliveryReceiptUtils.isReaction(this.receiptType);
+    }
+
+    @Override
+    @Nullable
+    public Version getMinimumRequiredForwardSecurityVersion() {
+        return Version.V1_2;
+    }
+
+    @Override
+    public boolean allowUserProfileDistribution() {
+        return this.isReaction();
+    }
+
+    @Override
+    public boolean exemptFromBlocking() {
+        return false;
+    }
+
+    @Override
+    public boolean createImplicitlyDirectContact() {
+        return false;
+    }
+
+    @Override
+    public boolean protectAgainstReplay() {
+        return isReaction();
+    }
+
+    @Override
+    public boolean reflectIncoming() {
+        return true;
+    }
+
+    @Override
+    public boolean reflectOutgoing() {
+        return true;
+    }
+
+    @Override
+    public boolean reflectSentUpdate() {
+        return false;
+    }
+
+    @Override
+    public boolean sendAutomaticDeliveryReceipt() {
+        return false;
+    }
+
+    @Override
+    public boolean bumpLastUpdate() {
+        return false;
+    }
+
+    @Override
+    @Nullable
+    public byte[] getBody() {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        try {
+            bos.write(getGroupCreator().getBytes(StandardCharsets.US_ASCII));
+            bos.write(getApiGroupId().getGroupId());
+            bos.write((byte) receiptType);
+
+            for (MessageId messageId : receiptMessageIds) {
+                bos.write(messageId.getMessageId());
+            }
+            return bos.toByteArray();
+
+        } catch (Exception e) {
+            logger.error(e.getMessage());
+        }
+        return null;
+    }
+
+    public int getReceiptType() {
+        return receiptType;
+    }
+
+    public void setReceiptType(int receiptType) {
+        this.receiptType = receiptType;
+    }
+
+    public MessageId[] getReceiptMessageIds() {
+        return receiptMessageIds;
+    }
+
+    public void setReceiptMessageIds(MessageId[] receiptMessageIds) {
+        this.receiptMessageIds = receiptMessageIds;
+    }
+
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromReflected(@NonNull MdD2D.IncomingMessage message) throws BadMessageException {
+        GroupDeliveryReceiptMessage groupDeliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+        groupDeliveryReceiptMessage.initializeCommonProperties(message);
+        return groupDeliveryReceiptMessage;
+    }
+
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromReflected(@NonNull MdD2D.OutgoingMessage message) throws BadMessageException {
+        GroupDeliveryReceiptMessage groupDeliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+        groupDeliveryReceiptMessage.initializeCommonProperties(message);
+        return groupDeliveryReceiptMessage;
+    }
+
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromByteArray(@NonNull byte[] data) throws BadMessageException {
+        return fromByteArray(data, 0, data.length);
+    }
+
+    /**
+     * Get the delivery receipt group message from the given array.
+     *
+     * @param data   the data that represents the group message
+     * @param offset the offset where the data starts
+     * @param length the length of the data (needed to ignore the padding)
+     * @return the GroupDeliveryReceiptMessage
+     * @throws BadMessageException if the length is invalid
+     */
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromByteArray(@NonNull byte[] data, int offset, int length) throws BadMessageException {
+
+        if (data.length < offset + length) {
+            throw new BadMessageException("Invalid byte array length (" + data.length + ") for offset " + offset + " and length " + length);
+        }
+
+        final int receiptTypeByteLength = 1;
+        int groupHeaderLength = ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
+        if (
+            (length - groupHeaderLength) < (ProtocolDefines.MESSAGE_ID_LEN + receiptTypeByteLength) ||
+                ((length - groupHeaderLength - receiptTypeByteLength) % ProtocolDefines.MESSAGE_ID_LEN) != 0
+        ) {
+            throw new BadMessageException("Bad length (" + length + ") for group delivery receipt");
+        }
+
+        GroupDeliveryReceiptMessage groupDeliveryReceiptMessage = new GroupDeliveryReceiptMessage();
+        groupDeliveryReceiptMessage.setGroupCreator(
+            new String(data, offset, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+        );
+        groupDeliveryReceiptMessage.setApiGroupId(new GroupId(data, offset + ProtocolDefines.IDENTITY_LEN));
+        groupDeliveryReceiptMessage.setReceiptType(data[groupHeaderLength + offset] & 0xFF);
+
+        int messageIdsCount = ((length - groupHeaderLength - receiptTypeByteLength) / ProtocolDefines.MESSAGE_ID_LEN);
+        MessageId[] receiptMessageIds = new MessageId[messageIdsCount];
+        for (int i = 0; i < messageIdsCount; i++) {
+            receiptMessageIds[i] = new MessageId(
+                data,
+                groupHeaderLength + receiptTypeByteLength + offset + (i * ProtocolDefines.MESSAGE_ID_LEN)
+            );
+        }
+
+        groupDeliveryReceiptMessage.setReceiptMessageIds(receiptMessageIds);
+        return groupDeliveryReceiptMessage;
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt
index 670bab4f..c5571905 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt
@@ -43,6 +43,8 @@ class GroupEditMessage(payloadData: EditMessageData) : AbstractProtobufGroupMess
 
     override fun reflectOutgoing() = true
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate() = false
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java
index 4f57939b..19d32fc3 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java
@@ -99,6 +99,11 @@ public class GroupImageMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java
index 03baaebb..c1abb63b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java
@@ -78,6 +78,11 @@ public class GroupLeaveMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java
index f0501e92..f70c4614 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java
@@ -97,6 +97,11 @@ public class GroupLocationMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java
index 63cf37d1..5ea8b09b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java
@@ -85,6 +85,11 @@ public class GroupNameMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java
index 5724aef0..f8c56b61 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java
@@ -87,6 +87,11 @@ public class GroupSetProfilePictureMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java
index 3359bdb3..cd3fc980 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java
@@ -84,6 +84,11 @@ public class GroupSetupMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java
index ee2408d0..1a6e7919 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java
@@ -77,6 +77,11 @@ public class GroupSyncRequestMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java
index d5b5b87f..d0c9c2e3 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java
@@ -26,10 +26,15 @@ import org.slf4j.Logger;
 import java.io.ByteArrayOutputStream;
 import java.nio.charset.StandardCharsets;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.GroupId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
  * A group message that has plain text as its contents.
@@ -90,6 +95,11 @@ public class GroupTextMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -121,4 +131,45 @@ public class GroupTextMessage extends AbstractGroupMessage {
 	public void setText(String text) {
 		this.text = text;
 	}
+
+	@NonNull
+	public static GroupTextMessage fromReflected(MdD2D.IncomingMessage message) throws BadMessageException {
+		GroupTextMessage textMessage = fromByteArray(message.getBody().toByteArray());
+		textMessage.initializeCommonProperties(message);
+		return textMessage;
+	}
+
+	@NonNull
+	public static GroupTextMessage fromByteArray(@NonNull byte[] data) throws BadMessageException {
+		return fromByteArray(data, 0, data.length);
+	}
+
+	/**
+	 * Get the group text message from the given array.
+	 *
+	 * @param data   the data that represents the message
+	 * @param offset the offset where the data starts
+	 * @param length the length of the data (needed to ignore the padding)
+	 * @return the group text message
+	 * @throws BadMessageException if the length is invalid
+	 */
+	@NonNull
+	public static GroupTextMessage fromByteArray(@NonNull byte[] data, int offset, int length) throws BadMessageException {
+		if (data.length < offset + length) {
+			throw new BadMessageException("Invalid byte array length (" + data.length + ") for " +
+				"offset " + offset + " and length " + length);
+		}
+
+		int minTextLength = 1;
+		int minByteArrayLength = minTextLength + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
+		if (length < minByteArrayLength) {
+			throw new BadMessageException("Bad length (" + length + ") for group text message");
+		}
+
+		GroupTextMessage groupTextMessage = new GroupTextMessage();
+		groupTextMessage.setGroupCreator(new String(data, offset, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
+		groupTextMessage.setApiGroupId(new GroupId(data, offset + ProtocolDefines.IDENTITY_LEN));
+		groupTextMessage.setText(new String(data, offset + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN, length - ProtocolDefines.IDENTITY_LEN - ProtocolDefines.GROUP_ID_LEN, UTF_8));
+		return groupTextMessage;
+	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java
index db4ea35f..091f269b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java
@@ -22,12 +22,14 @@
 package ch.threema.domain.protocol.csp.messages;
 
 import org.apache.commons.io.EndianUtils;
+import org.slf4j.Logger;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 
 import androidx.annotation.Nullable;
+import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 
@@ -48,7 +50,9 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
 @Deprecated
 public class GroupVideoMessage extends AbstractGroupMessage {
 
-	private int duration;
+    private final static Logger logger = LoggingUtil.getThreemaLogger("GroupVideoMessage");
+
+    private int duration;
 	private byte[] videoBlobId;
 	private int videoSize;
 	private byte[] thumbnailBlobId;
@@ -105,6 +109,11 @@ public class GroupVideoMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -128,11 +137,11 @@ public class GroupVideoMessage extends AbstractGroupMessage {
 			bos.write(thumbnailBlobId);
 			EndianUtils.writeSwappedInteger(bos, thumbnailSize);
 			bos.write(encryptionKey);
+            return bos.toByteArray();
 		} catch (IOException e) {
-			throw new RuntimeException(e);
+			logger.error("Cannot create body of message", e);
+            return null;
 		}
-
-		return bos.toByteArray();
 	}
 
 	public int getDuration() {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java
index ecf0dc27..1b68859d 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java
@@ -93,6 +93,11 @@ public class ImageMessage extends AbstractMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return true;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java
index 46a25dab..3a357beb 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java
@@ -91,6 +91,11 @@ public class LocationMessage extends AbstractMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return true;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java
index 72655ff2..9ba97735 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java
@@ -58,6 +58,11 @@ public interface MessageTypeProperties {
 	 */
 	boolean reflectOutgoing();
 
+	/**
+	 * Return whether an 'outgoing message update sent' should be reflected for this message.
+	 */
+	boolean reflectSentUpdate();
+
 	/**
 	 * Return whether an automatic delivery receipt should be send back when receiving a message of
 	 * this type. Note that sending automatic delivery receipts must be prevented for messages that
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.java
deleted file mode 100644
index 676ca39a..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.apache.commons.io.EndianUtils;
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A profile picture uploaded as a blob
- *
- * The contents are referenced by the {@code blobId}, the file {@code size} in bytes,
- * and the nonce to be used when decrypting the image blob.
- */
-public class SetProfilePictureMessage extends AbstractMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("ContactSetPhotoMessage");
-
-	private byte[] blobId;
-	private int size;
-	private byte[] encryptionKey;
-
-	public SetProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_CONTACT_SET_PHOTO;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			bos.write(blobId);
-			EndianUtils.writeSwappedInteger(bos, size);
-			bos.write(encryptionKey);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	public byte[] getBlobId() {
-		return blobId;
-	}
-
-	public void setBlobId(byte[] blobId) {
-		this.blobId = blobId;
-	}
-
-	public int getSize() {
-		return size;
-	}
-
-	public void setSize(int size) {
-		this.size = size;
-	}
-
-	public byte[] getEncryptionKey() {
-		return encryptionKey;
-	}
-
-	public void setEncryptionKey(byte[] encryptionKey) {
-		this.encryptionKey = encryptionKey;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.kt
new file mode 100644
index 00000000..3131b699
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.kt
@@ -0,0 +1,161 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import org.apache.commons.io.EndianUtils
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.ByteBuffer
+import java.nio.ByteOrder
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("ContactSetPhotoMessage")
+
+/**
+ * A profile picture uploaded as a blob
+ *
+ * The contents are referenced by the `blobId`, the file `size` in bytes,
+ * and the nonce to be used when decrypting the image blob.
+ */
+class SetProfilePictureMessage(
+    @JvmField
+    val blobId: ByteArray,
+    @JvmField
+    val size: Int,
+    @JvmField
+    val encryptionKey: ByteArray,
+) : AbstractMessage() {
+
+    override fun getType(): Int {
+        return ProtocolDefines.MSGTYPE_CONTACT_SET_PHOTO
+    }
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_1
+
+    override fun allowUserProfileDistribution(): Boolean = false
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    override fun getBody(): ByteArray {
+        try {
+            val bos = ByteArrayOutputStream()
+            bos.write(blobId)
+            EndianUtils.writeSwappedInteger(bos, size)
+            bos.write(encryptionKey)
+            return bos.toByteArray()
+        } catch (e: Exception) {
+            logger.error(e.message)
+            return byteArrayOf()
+        }
+    }
+
+    companion object {
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): SetProfilePictureMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.OutgoingMessage): SetProfilePictureMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray): SetProfilePictureMessage =
+            fromByteArray(
+                data = data,
+                offset = 0,
+                length = data.size
+            )
+
+        /**
+         * Get the set profile picture message from the given array.
+         *
+         * @param data   the data that represents the message
+         * @param offset the offset where the data starts
+         * @param length the length of the data (needed to ignore the padding)
+         * @return the set profile picture message
+         * @throws BadMessageException if the length is invalid
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): SetProfilePictureMessage {
+            // Blob size is an int (4 bytes)
+            val blobSizeLength = 4
+            when {
+                length != ProtocolDefines.BLOB_ID_LEN + blobSizeLength + ProtocolDefines.BLOB_KEY_LEN -> {
+                    throw BadMessageException("Bad length ($length) for set profile picture message")
+                }
+
+                offset < 0 -> {
+                    throw BadMessageException("Bad offset ($offset) for set profile picture message")
+                }
+
+                data.size < length + offset -> {
+                    throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+                }
+            }
+            var readOffset = offset
+
+            val blobId = data.copyOfRange(readOffset, readOffset + ProtocolDefines.BLOB_ID_LEN)
+            readOffset += ProtocolDefines.BLOB_ID_LEN
+
+            val blobSize = ByteBuffer.wrap(data, readOffset, blobSizeLength)
+                .order(ByteOrder.LITTLE_ENDIAN)
+                .getInt()
+            readOffset += blobSizeLength
+
+            val encryptionKey =
+                data.copyOfRange(readOffset, readOffset + ProtocolDefines.BLOB_KEY_LEN)
+
+            return SetProfilePictureMessage(
+                blobId = blobId,
+                size = blobSize,
+                encryptionKey = encryptionKey,
+            )
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java
index fbc4f778..ff9d5f6e 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java
@@ -23,9 +23,13 @@ package ch.threema.domain.protocol.csp.messages;
 
 import java.nio.charset.StandardCharsets;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
  * A message that has plain text as its contents.
@@ -83,6 +87,11 @@ public class TextMessage extends AbstractMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return true;
@@ -105,4 +114,40 @@ public class TextMessage extends AbstractMessage {
 	public void setText(String text) {
 		this.text = text;
 	}
+
+	@NonNull
+	public static TextMessage fromReflected(MdD2D.IncomingMessage message) throws BadMessageException {
+		TextMessage textMessage = fromByteArray(message.getBody().toByteArray());
+		textMessage.initializeCommonProperties(message);
+		return textMessage;
+	}
+
+	@NonNull
+	public static TextMessage fromByteArray(@NonNull byte[] data) throws BadMessageException {
+		return fromByteArray(data, 0, data.length);
+	}
+
+	/**
+	 * Get the text message from the given array.
+	 *
+	 * @param data   the data that represents the message
+	 * @param offset the offset where the data starts
+	 * @param length the length of the data (needed to ignore the padding)
+	 * @return the text message
+	 * @throws BadMessageException if the length is invalid
+	 */
+	@NonNull
+	public static TextMessage fromByteArray(@NonNull byte[] data, int offset, int length) throws BadMessageException {
+		if (data.length < offset + length) {
+			throw new BadMessageException("Invalid byte array length (" + data.length + ") for " +
+				"offset " + offset + " and length " + length);
+		}
+		if (length < 1) {
+			throw new BadMessageException("Bad length (" + length + ") for text message");
+		}
+
+		TextMessage textMessage = new TextMessage();
+		textMessage.setText(new String(data, offset, length, UTF_8));
+		return textMessage;
+	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java
index b9f6d737..3e9e409b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java
@@ -78,6 +78,11 @@ public class TypingIndicatorMessage extends AbstractMessage {
 		return false;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java
index 4ccc32f9..eb26b498 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java
@@ -22,11 +22,13 @@
 package ch.threema.domain.protocol.csp.messages;
 
 import org.apache.commons.io.EndianUtils;
+import org.slf4j.Logger;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 
 import androidx.annotation.Nullable;
+import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 
@@ -47,7 +49,9 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
 @Deprecated
 public class VideoMessage extends AbstractMessage {
 
-	private int duration;
+    private final static Logger logger = LoggingUtil.getThreemaLogger("VideoMessage");
+
+    private int duration;
 	private byte[] videoBlobId;
 	private int videoSize;
 	private byte[] thumbnailBlobId;
@@ -104,6 +108,11 @@ public class VideoMessage extends AbstractMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return true;
@@ -125,11 +134,11 @@ public class VideoMessage extends AbstractMessage {
 			bos.write(thumbnailBlobId);
 			EndianUtils.writeSwappedInteger(bos, thumbnailSize);
 			bos.write(encryptionKey);
+            return bos.toByteArray();
 		} catch (IOException e) {
-			throw new RuntimeException(e);
+            logger.error("Cannot create body of message", e);
+            return null;
 		}
-
-		return bos.toByteArray();
 	}
 
 	public int getDuration() {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt
index 4b0d9df2..8eec5c34 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt
@@ -41,6 +41,8 @@ class WebSessionResumeMessage(private val data: Map<String, String>) : AbstractM
 
     override fun reflectOutgoing() = false
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate(): Boolean = false
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java
index fc71d083..b0fb93e9 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java
@@ -57,7 +57,6 @@ public class BallotData {
 			}
 			throw new IllegalArgumentException();
 		}
-
 	}
 
 	public enum AssessmentType {
@@ -228,7 +227,8 @@ public class BallotData {
 		return this.participants;
 	}
 
-	public static BallotData parse(String jsonObjectString) throws BadMessageException {
+	@NonNull
+    public static BallotData parse(String jsonObjectString) throws BadMessageException {
 		try {
 			JSONObject o = new JSONObject(jsonObjectString);
 
@@ -284,13 +284,12 @@ public class BallotData {
 
 			return ballotData;
 		}
-		catch (JSONException e) {
-			throw new BadMessageException("TM029");
+		catch (JSONException jsonException) {
+			throw new BadMessageException("TM029", jsonException);
 		}
-
 	}
 
-	public void write(ByteArrayOutputStream bos) throws Exception {
+	public void write(@NonNull ByteArrayOutputStream bos) throws Exception {
 		bos.write(this.generateString().getBytes(StandardCharsets.UTF_8));
 	}
 
@@ -316,8 +315,8 @@ public class BallotData {
 			}
 			o.put(KEY_PARTICIPANTS, p);
 		}
-		catch (Exception e) {
-			throw new BadMessageException("TM033");
+		catch (Exception jsonException) {
+			throw new BadMessageException("TM033", jsonException);
 		}
 
 		return o.toString();
diff --git a/domain/src/main/java/ch/threema/domain/models/IdentityState.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.kt
similarity index 82%
rename from domain/src/main/java/ch/threema/domain/models/IdentityState.java
rename to domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.kt
index b4379044..b95dc1b7 100644
--- a/domain/src/main/java/ch/threema/domain/models/IdentityState.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.kt
@@ -19,10 +19,11 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.domain.models;
+package ch.threema.domain.protocol.csp.messages.ballot
 
-public class IdentityState {
-	public static final int ACTIVE = 0;
-	public static final int INACTIVE = 1;
-	public static final int INVALID = 2;
+interface BallotMessageInterface {
+
+    var ballotId: BallotId?
+
+    var ballotCreatorIdentity: String?
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotSetupInterface.kt
similarity index 84%
rename from domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.java
rename to domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotSetupInterface.kt
index 040cf900..aba21aa4 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotSetupInterface.kt
@@ -19,9 +19,9 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.domain.protocol.csp.messages.file;
+package ch.threema.domain.protocol.csp.messages.ballot
 
-public interface FileMessageInterface  {
-	void setData(FileData ballotData);
-	FileData getData();
+interface BallotSetupInterface : BallotMessageInterface {
+
+    var ballotData: BallotData?
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java
index 517182d9..462c72b2 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java
@@ -21,7 +21,10 @@
 
 package ch.threema.domain.protocol.csp.messages.ballot;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 
@@ -30,63 +33,63 @@ import java.nio.charset.StandardCharsets;
 
 public class BallotVote {
 
-	private final static int POS_CHOICE_ID = 0;
-	private final static int POS_CHOICE_VALUE = 1;
-
-	private int id;
-	private int value;
-
-
-	public int getId() {
-		return id;
-	}
-
-	public void setId(int id) {
-		this.id = id;
-	}
-
-	public int getValue() {
-		return value;
-	}
-
-	public void setValue(int value) {
-		this.value = value;
-	}
-
-
-	public static BallotVote parse(JSONArray o) throws BadMessageException {
-		try {
-			if(o == null) {
-				throw new BadMessageException("TM036");
-			}
-
-			BallotVote ballotVote = new BallotVote();
-			ballotVote.id = o.getInt(POS_CHOICE_ID);
-			ballotVote.value = o.getInt(POS_CHOICE_VALUE);
-			return ballotVote;
-		}
-		catch (JSONException e) {
-			throw new BadMessageException("TM033");
-		}
-	}
-
-	public JSONArray getJsonArray() throws BadMessageException {
-		JSONArray o = new JSONArray();
-		try {
-			o.put(POS_CHOICE_ID, this.id);
-			o.put(POS_CHOICE_VALUE, this.value);
-		}
-		catch (Exception e) {
-			throw new BadMessageException("TM036");
-		}
-		return o;
-	}
-
-	public void write(ByteArrayOutputStream bos) throws Exception {
-		bos.write(this.generateString().getBytes(StandardCharsets.US_ASCII));
-	}
-
-	public String generateString() throws BadMessageException {
-		return this.getJsonArray().toString();
-	}
+    private final static int POS_CHOICE_ID = 0;
+    private final static int POS_CHOICE_VALUE = 1;
+
+    private int id;
+    private int value;
+
+    public BallotVote(int id, int value) {
+        this.id = id;
+        this.value = value;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public int getValue() {
+        return value;
+    }
+
+    public void setValue(int value) {
+        this.value = value;
+    }
+
+    @NonNull
+    public static BallotVote parse(@Nullable JSONArray jsonArray) throws BadMessageException {
+        try {
+            if (jsonArray == null) {
+                throw new BadMessageException("TM036");
+            }
+            int id = jsonArray.getInt(POS_CHOICE_ID);
+            int value = jsonArray.getInt(POS_CHOICE_VALUE);
+            return new BallotVote(id, value);
+        } catch (JSONException e) {
+            throw new BadMessageException("TM033", e);
+        }
+    }
+
+    public JSONArray getJsonArray() throws BadMessageException {
+        JSONArray jsonArray = new JSONArray();
+        try {
+            jsonArray.put(POS_CHOICE_ID, this.id);
+            jsonArray.put(POS_CHOICE_VALUE, this.value);
+        } catch (Exception e) {
+            throw new BadMessageException("TM036", e);
+        }
+        return jsonArray;
+    }
+
+    public void write(@NonNull ByteArrayOutputStream bos) throws Exception {
+        bos.write(this.generateString().getBytes(StandardCharsets.US_ASCII));
+    }
+
+    public String generateString() throws BadMessageException {
+        return this.getJsonArray().toString();
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotCreateInterface.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.kt
similarity index 81%
rename from domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotCreateInterface.java
rename to domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.kt
index acf66a04..505e71ef 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotCreateInterface.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.kt
@@ -19,9 +19,11 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.domain.protocol.csp.messages.ballot;
+package ch.threema.domain.protocol.csp.messages.ballot
 
-public interface BallotCreateInterface extends BallotMessageInterface  {
-	void setData(BallotData ballotData);
-	BallotData getData();
+interface BallotVoteInterface : BallotMessageInterface {
+
+    val votes: List<BallotVote>
+
+    fun addVotes(votes: List<BallotVote>)
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.java
deleted file mode 100644
index 88867ba0..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A group ballot creation message.
- */
-public class GroupPollSetupMessage extends AbstractGroupMessage
-	implements BallotCreateInterface{
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupBallotCreateMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-	private BallotData ballotData;
-	// This is only used for debugging
-	private String rawBallotData;
-
-	public GroupPollSetupMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public void setData(BallotData ballotData) {
-		this.ballotData = ballotData;
-	}
-
-	@Override
-	public BallotData getData() {
-		return this.ballotData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getApiGroupId().getGroupId());
-			bos.write(this.getBallotId().getBallotId());
-			this.ballotData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_BALLOT_CREATE;
-	}
-
-	// This is only used for debugging
-	public void setRawBallotData(String rawBallotData) {
-		this.rawBallotData = rawBallotData;
-	}
-
-	// This is only used for debugging
-	public String getRawBallotData() {
-		return this.rawBallotData;
-	}
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.kt
new file mode 100644
index 00000000..09506b96
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.kt
@@ -0,0 +1,154 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("GroupPollSetupMessage")
+
+/**
+ * A group poll creation message.
+ */
+class GroupPollSetupMessage : AbstractGroupMessage(), BallotSetupInterface {
+
+    override var ballotId: BallotId? = null
+    override var ballotCreatorIdentity: String? = null
+    override var ballotData: BallotData? = null
+
+    // this is only used for debugging
+    @JvmField
+    var rawBallotData: String? = null
+
+    override fun flagSendPush(): Boolean = true
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_2
+
+    override fun allowUserProfileDistribution(): Boolean = true
+
+    override fun exemptFromBlocking(): Boolean = true
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = true
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = true
+
+    override fun getBody(): ByteArray? {
+        if (ballotId == null || ballotData == null) {
+            return null
+        }
+        try {
+            val bos = ByteArrayOutputStream()
+            bos.write(groupCreator.toByteArray(StandardCharsets.US_ASCII))
+            bos.write(apiGroupId.groupId)
+            bos.write(ballotId!!.ballotId)
+            ballotData!!.write(bos)
+            return bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            return null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_GROUP_BALLOT_CREATE
+
+    companion object {
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage, fromIdentity: String): GroupPollSetupMessage =
+            fromByteArray(
+                data = message.body.toByteArray(),
+                fromIdentity = fromIdentity
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray, fromIdentity: String): GroupPollSetupMessage =
+            fromByteArray(
+                data = data,
+                offset = 0,
+                length = data.size,
+                fromIdentity = fromIdentity
+            )
+
+        /**
+         * Get the group poll-setup message from the given array.
+         *
+         * @param data   the data that represents the message
+         * @param offset the offset where the data starts
+         * @param length the length of the data (needed to ignore the padding)
+         * @param fromIdentity the identity of the sender
+         * @return the poll-setup message
+         * @throws BadMessageException if the length is invalid
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int, fromIdentity: String): GroupPollSetupMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for poll setup message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for poll setup message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            return GroupPollSetupMessage().apply {
+
+                ballotCreatorIdentity = fromIdentity
+
+                var positionIndex = offset
+                groupCreator = String(data, positionIndex, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+                positionIndex += ProtocolDefines.IDENTITY_LEN
+
+                apiGroupId = GroupId(data, positionIndex)
+                positionIndex += ProtocolDefines.GROUP_ID_LEN
+
+                ballotId = BallotId(data, positionIndex)
+                positionIndex += ProtocolDefines.BALLOT_ID_LEN
+
+                val jsonObjectString = String(data, positionIndex, length + offset - positionIndex, StandardCharsets.UTF_8)
+                ballotData = BallotData.parse(jsonObjectString)
+
+                // this is only used for debugging
+                rawBallotData = jsonObjectString
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.java
deleted file mode 100644
index 2d42afed..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
-import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A group ballot vote message.
- */
-public class GroupPollVoteMessage extends AbstractGroupMessage
-	implements BallotVoteInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupBallotVoteMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-
-	private final List<BallotVote> ballotVotes = new ArrayList<>();
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public List<BallotVote> getBallotVotes() {
-		return this.ballotVotes;
-	}
-
-	@Override
-	public void addVotes(Collection<BallotVote> votes) {
-		this.ballotVotes.addAll(votes);
-	}
-
-	public void parseVotes(String votes) throws BadMessageException{
-		try {
-			JSONArray array = new JSONArray(votes);
-			for(int n = 0; n < array.length(); n++) {
-				this.ballotVotes.add(BallotVote.parse(array.getJSONArray(n)));
-			}
-		} catch (JSONException e) {
-			throw new BadMessageException("TM035");
-		}
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getApiGroupId().getGroupId());
-			bos.write(this.getBallotCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getBallotId().getBallotId());
-
-			JSONArray jsonArray = new JSONArray();
-			for(BallotVote c: this.ballotVotes) {
-				jsonArray.put(c.getJsonArray());
-			}
-			bos.write(jsonArray.toString().getBytes(StandardCharsets.US_ASCII));
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_BALLOT_VOTE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.kt
new file mode 100644
index 00000000..751ac628
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.kt
@@ -0,0 +1,167 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import org.json.JSONArray
+import org.json.JSONException
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("GroupPollVoteMessage")
+
+/**
+ * A group poll vote message.
+ */
+class GroupPollVoteMessage : AbstractGroupMessage(), BallotVoteInterface {
+
+    override var ballotId: BallotId? = null
+    override var ballotCreatorIdentity: String? = null
+    override val votes: MutableList<BallotVote> = mutableListOf()
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_2
+
+    override fun allowUserProfileDistribution(): Boolean = true
+
+    override fun exemptFromBlocking(): Boolean = true
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    override fun addVotes(votes: List<BallotVote>) {
+        this.votes.addAll(votes)
+    }
+
+    @Throws(BadMessageException::class)
+    fun parseVotes(votes: String?) {
+        try {
+            val votesJsonArray = JSONArray(votes)
+            for (voteJson in 0 until votesJsonArray.length()) {
+                this.votes.add(BallotVote.parse(votesJsonArray.getJSONArray(voteJson)))
+            }
+        } catch (jsonException: JSONException) {
+            throw BadMessageException("TM035")
+        }
+    }
+
+    override fun getBody(): ByteArray? {
+        if (ballotCreatorIdentity == null || ballotId == null) {
+            return null
+        }
+        try {
+            val bos = ByteArrayOutputStream()
+
+            bos.write(groupCreator.toByteArray(StandardCharsets.US_ASCII))
+            bos.write(apiGroupId.groupId)
+            bos.write(ballotCreatorIdentity!!.toByteArray(StandardCharsets.US_ASCII))
+            bos.write(ballotId!!.ballotId)
+
+            val jsonArrayVotes = JSONArray()
+            for (vote in votes) {
+                jsonArrayVotes.put(vote.jsonArray)
+            }
+            bos.write(jsonArrayVotes.toString().toByteArray(StandardCharsets.US_ASCII))
+            return bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            return null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_GROUP_BALLOT_VOTE
+
+    companion object {
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): GroupPollVoteMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray): GroupPollVoteMessage =
+            fromByteArray(
+                data = data,
+                offset = 0,
+                length = data.size
+            )
+
+        /**
+         * Get the group poll-vote message from the given array.
+         *
+         * @param data   the data that represents the message
+         * @param offset the offset where the data starts
+         * @param length the length of the data (needed to ignore the padding)
+         * @return the poll-vote message
+         * @throws BadMessageException if the length is invalid
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): GroupPollVoteMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for poll vote message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for poll vote message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            return GroupPollVoteMessage().apply {
+
+                var positionIndex = offset
+                groupCreator = String(data, positionIndex, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+                positionIndex += ProtocolDefines.IDENTITY_LEN
+
+                apiGroupId = GroupId(data, positionIndex)
+                positionIndex += ProtocolDefines.GROUP_ID_LEN
+
+                ballotCreatorIdentity = String(data, positionIndex, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+                positionIndex += ProtocolDefines.IDENTITY_LEN
+
+                ballotId = BallotId(data, positionIndex)
+                positionIndex += ProtocolDefines.BALLOT_ID_LEN
+
+                parseVotes(String(data, positionIndex, length + offset - positionIndex, StandardCharsets.UTF_8))
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.java
deleted file mode 100644
index a4f609dd..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A ballot creation message.
- */
-public class PollSetupMessage extends AbstractMessage implements BallotCreateInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BallotCreateMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-	private BallotData ballotData;
-
-	public PollSetupMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public void setData(BallotData ballotData) {
-		this.ballotData = ballotData;
-	}
-
-	@Override
-	public BallotData getData() {
-		return this.ballotData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getBallotId().getBallotId());
-			this.ballotData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_BALLOT_CREATE;
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		sb.append(super.toString());
-		sb.append(": create message, description: ");
-		sb.append(this.ballotData.getDescription());
-
-		return sb.toString();
-	}
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.kt
new file mode 100644
index 00000000..31d57cd1
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.kt
@@ -0,0 +1,149 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("PollSetupMessage")
+
+/**
+ * A poll creation message.
+ */
+open class PollSetupMessage : AbstractMessage(), BallotSetupInterface {
+
+    override var ballotId: BallotId? = null
+    override var ballotCreatorIdentity: String? = null
+    override var ballotData: BallotData? = null
+
+    override fun flagSendPush(): Boolean = true
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_0
+
+    override fun allowUserProfileDistribution(): Boolean = true
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = true
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = true
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = true
+
+    override fun bumpLastUpdate(): Boolean = true
+
+    override fun getBody(): ByteArray? {
+        if (ballotId == null || ballotData == null) {
+            return null
+        }
+        try {
+            val bos = ByteArrayOutputStream()
+            bos.write(ballotId!!.ballotId)
+            ballotData!!.write(bos)
+            return bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            return null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_BALLOT_CREATE
+
+    override fun toString(): String =
+        StringBuilder().apply {
+            append(super.toString())
+            append(": poll setup message")
+            ballotData?.let { ballotDataNotNull ->
+                append(", description: ")
+                append(ballotDataNotNull.description)
+            }
+        }.toString()
+
+    companion object {
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage, fromIdentity: String): PollSetupMessage =
+            fromByteArray(
+                data = message.body.toByteArray(),
+                fromIdentity = fromIdentity
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray, fromIdentity: String): PollSetupMessage =
+            fromByteArray(
+                data = data,
+                offset = 0,
+                length = data.size,
+                fromIdentity = fromIdentity
+            )
+
+        /**
+         * Get the poll-setup message from the given array.
+         *
+         * @param data   the data that represents the message
+         * @param offset the offset where the data starts
+         * @param length the length of the data (needed to ignore the padding)
+         * @param fromIdentity the identity of the sender
+         * @return the poll-setup message
+         * @throws BadMessageException if the length is invalid
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int, fromIdentity: String): PollSetupMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for poll setup message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for poll setup message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            return PollSetupMessage().apply {
+
+                ballotCreatorIdentity = fromIdentity
+
+                var positionIndex = offset
+                ballotId = BallotId(data, positionIndex)
+
+                positionIndex += ProtocolDefines.BALLOT_ID_LEN
+
+                val jsonObjectString = String(data, positionIndex, length + offset - positionIndex, StandardCharsets.UTF_8)
+                ballotData = BallotData.parse(jsonObjectString)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.java
deleted file mode 100644
index f544ce8e..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A ballot vote message.
- */
-public class PollVoteMessage extends AbstractMessage implements BallotVoteInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BallotVoteMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-
-	private final List<BallotVote> ballotVotes = new ArrayList<>();
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public List<BallotVote> getBallotVotes() {
-		return this.ballotVotes;
-	}
-
-	@Override
-	public void addVotes(Collection<BallotVote> votes) {
-		this.ballotVotes.addAll(votes);
-	}
-
-	public void parseVotes(String votes) throws BadMessageException{
-		try {
-			JSONArray array = new JSONArray(votes);
-			for(int n = 0; n < array.length(); n++) {
-				this.ballotVotes.add(BallotVote.parse(array.getJSONArray(n)));
-			}
-		} catch (JSONException e) {
-			throw new BadMessageException("TM035");
-		}
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getBallotCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getBallotId().getBallotId());
-
-			JSONArray jsonArray = new JSONArray();
-			for(BallotVote c: this.ballotVotes) {
-				jsonArray.put(c.getJsonArray());
-			}
-			bos.write(jsonArray.toString().getBytes(StandardCharsets.US_ASCII));
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_BALLOT_VOTE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.kt
new file mode 100644
index 00000000..f7e7a813
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.kt
@@ -0,0 +1,157 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import org.json.JSONArray
+import org.json.JSONException
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("PollVoteMessage")
+
+/**
+ * A poll vote message.
+ */
+open class PollVoteMessage : AbstractMessage(), BallotVoteInterface {
+
+    override var ballotId: BallotId? = null
+    override var ballotCreatorIdentity: String? = null
+    override val votes: MutableList<BallotVote> = mutableListOf()
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_0
+
+    override fun allowUserProfileDistribution(): Boolean = true
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    override fun addVotes(votes: List<BallotVote>) {
+        this.votes.addAll(votes)
+    }
+
+    @Throws(BadMessageException::class)
+    fun parseVotes(votesJsonArrayString: String?) {
+        try {
+            val votesJsonArray = JSONArray(votesJsonArrayString)
+            for (n in 0 until votesJsonArray.length()) {
+                votes.add(BallotVote.parse(votesJsonArray.getJSONArray(n)))
+            }
+        } catch (jsonException: JSONException) {
+            throw BadMessageException("TM035", jsonException)
+        }
+    }
+
+    override fun getBody(): ByteArray? {
+        if (ballotCreatorIdentity == null || ballotId == null) {
+            return null
+        }
+        try {
+            val bos = ByteArrayOutputStream()
+            bos.write(ballotCreatorIdentity!!.toByteArray(StandardCharsets.US_ASCII))
+            bos.write(ballotId!!.ballotId)
+            val ballotVotesJsonArray = JSONArray()
+            for (ballotVote in votes) {
+                ballotVotesJsonArray.put(ballotVote.jsonArray)
+            }
+            bos.write(ballotVotesJsonArray.toString().toByteArray(StandardCharsets.US_ASCII))
+            return bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            return null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_BALLOT_VOTE
+
+    companion object {
+
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): PollVoteMessage =
+            fromByteArray(
+                data = message.body.toByteArray()
+            ).apply {
+                initializeCommonProperties(message)
+            }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray): PollVoteMessage =
+            fromByteArray(
+                data = data,
+                offset = 0,
+                length = data.size
+            )
+
+        /**
+         * Get the poll-vote message from the given array.
+         *
+         * @param data   the data that represents the message
+         * @param offset the offset where the data starts
+         * @param length the length of the data (needed to ignore the padding)
+         * @return the poll-vote message
+         * @throws BadMessageException if the length is invalid
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): PollVoteMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for poll vote message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for poll vote message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            return PollVoteMessage().apply {
+
+                var positionIndex = offset
+
+                ballotCreatorIdentity = String(data, positionIndex, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+                positionIndex += ProtocolDefines.IDENTITY_LEN
+
+                ballotId = BallotId(data, positionIndex)
+                positionIndex += ProtocolDefines.BALLOT_ID_LEN
+
+                parseVotes(String(data, positionIndex, length + offset - positionIndex, StandardCharsets.UTF_8))
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java
index c8488713..33e8d3b6 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java
@@ -282,7 +282,7 @@ public class FileData {
 			}
 			return fileData;
 		} catch (JSONException e) {
-			throw new BadMessageException("TM037");
+			throw new BadMessageException("TM037", e);
 		}
 	}
 
@@ -320,7 +320,7 @@ public class FileData {
 			o.put(KEY_RENDERING_TYPE, this.renderingType);
 		}
 		catch (Exception e) {
-			throw new BadMessageException("TM037");
+			throw new BadMessageException("TM037", e);
 		}
 
 		return o.toString();
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.java
deleted file mode 100644
index 7cb891f7..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.file;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class FileMessage extends AbstractMessage implements FileMessageInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("FileMessage");
-
-	private FileData fileData;
-
-	public FileMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setData(FileData fileData) {
-		this.fileData = fileData;
-	}
-
-	@Override
-	public FileData getData() {
-		return this.fileData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.fileData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_FILE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.kt
new file mode 100644
index 00000000..1a8f9b1c
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.kt
@@ -0,0 +1,131 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.file
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("FileMessage")
+
+/**
+ *  This class is not final as a workaround to test it using Mockito.
+ *  Another solution would be to use the mock-maker-inline mockito plugin.
+ */
+open class FileMessage : AbstractMessage(), FileMessageInterface {
+
+    override var fileData: FileData? = null
+
+    override fun flagSendPush(): Boolean = true
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_0
+
+    override fun allowUserProfileDistribution(): Boolean = true
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = true
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = true
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = true
+
+    override fun bumpLastUpdate(): Boolean = true
+
+    override fun getBody(): ByteArray? {
+        return try {
+            val bos = ByteArrayOutputStream()
+            fileData!!.write(bos)
+            bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_FILE
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the file message
+         *  @return Instance of [FileMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): FileMessage {
+            val fileMessage = fromByteArray(message.body.toByteArray())
+            fileMessage.initializeCommonProperties(message)
+            return fileMessage
+        }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray): FileMessage = fromByteArray(data, 0, data.size)
+
+        /**
+         * Build an instance of [FileMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - body json bytes of [FileData]
+         *
+         * @param data   the data that represents the file message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [FileMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): FileMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+            return FileMessage().apply {
+                val json = String(data, offset, length, StandardCharsets.UTF_8)
+                fileData = FileData.parse(json)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.kt
similarity index 77%
rename from domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.java
rename to domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.kt
index a30802f9..5c01c1b7 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.kt
@@ -19,12 +19,9 @@
  * along with this program. If not, see <https://www.gnu.org/licenses/>.
  */
 
-package ch.threema.domain.protocol.csp.messages.ballot;
+package ch.threema.domain.protocol.csp.messages.file
 
-public interface BallotMessageInterface {
-	void setBallotId(BallotId ballotId);
-	void setBallotCreator(String ballotCreator);
+interface FileMessageInterface {
 
-	BallotId getBallotId();
-	String getBallotCreator();
+    var fileData: FileData?
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.java
deleted file mode 100644
index 35e38758..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.file;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class GroupFileMessage extends AbstractGroupMessage implements FileMessageInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupFileMessage");
-
-	private FileData fileData;
-
-	public GroupFileMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setData(FileData ballotData) {
-		this.fileData = ballotData;
-	}
-
-	@Override
-	public FileData getData() {
-		return this.fileData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getApiGroupId().getGroupId());
-			this.fileData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_FILE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.kt
new file mode 100644
index 00000000..b3f6bef6
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.kt
@@ -0,0 +1,150 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2013-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.file
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("GroupFileMessage")
+
+/**
+ *  This class is not final as a workaround to test it using Mockito.
+ *  Another solution would be to use the mock-maker-inline mockito plugin.
+ */
+open class GroupFileMessage : AbstractGroupMessage(), FileMessageInterface {
+
+    override var fileData: FileData? = null
+
+    override fun flagSendPush(): Boolean = true
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version = Version.V1_2
+
+    override fun allowUserProfileDistribution(): Boolean = true
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = true
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = true
+
+    override fun getBody(): ByteArray? {
+        return try {
+            val bos = ByteArrayOutputStream()
+            bos.write(groupCreator.toByteArray(StandardCharsets.US_ASCII))
+            bos.write(apiGroupId.groupId)
+            fileData!!.write(bos)
+            bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_GROUP_FILE
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the group-file message
+         *  @return Instance of [GroupFileMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): GroupFileMessage {
+            val groupFileMessage = fromByteArray(message.body.toByteArray())
+            groupFileMessage.initializeCommonProperties(message)
+            return groupFileMessage
+        }
+
+        @JvmStatic
+        fun fromByteArray(data: ByteArray): GroupFileMessage = fromByteArray(
+            data = data,
+            offset = 0,
+            length = data.size
+        )
+
+        /**
+         * Build an instance of [GroupFileMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - header field: group-creator (identity, length 8)
+         *  - header field: api-group-id (id, length 8)
+         *  - body json bytes of [FileData]
+         *
+         * @param data   the data that represents the group-file message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [GroupFileMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): GroupFileMessage {
+            if (length <= ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            val groupFileMessage = GroupFileMessage()
+
+            var positionIndex = offset
+            groupFileMessage.groupCreator = String(data, positionIndex, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+            positionIndex += ProtocolDefines.IDENTITY_LEN
+
+            groupFileMessage.apiGroupId = GroupId(data, positionIndex)
+            positionIndex += ProtocolDefines.GROUP_ID_LEN
+
+            val jsonObjectString = String(data, positionIndex, length + offset - positionIndex, StandardCharsets.UTF_8)
+            groupFileMessage.fileData = FileData.parse(jsonObjectString)
+
+            return groupFileMessage
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java
index 899e531b..7f2fe9ee 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java
@@ -132,6 +132,14 @@ public class ForwardSecurityEnvelopeMessage extends AbstractProtobufMessage<Forw
 		return false;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		if (innerMessage == null) {
+			throw new IllegalStateException("Cannot check sent update reflection of incoming fs envelopes");
+		}
+		return innerMessage.reflectSentUpdate();
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		throw new IllegalStateException("Cannot check for sending automatic delivery receipt on fs envelopes");
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java
index 7e24b320..8d924306 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java
@@ -68,6 +68,11 @@ public class GroupJoinRequestMessage extends AbstractProtobufMessage<GroupJoinRe
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java
index 1f79b333..2bf74e85 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java
@@ -68,6 +68,11 @@ public class GroupJoinResponseMessage extends AbstractProtobufMessage<GroupJoinR
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt
index a6674af3..cac085f1 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt
@@ -40,12 +40,12 @@ class GroupCallStartData(
             try {
                 val protobufMessage = GroupCallStart.parseFrom(rawProtobufMessage)
                 return GroupCallStartData(
-                        protobufMessage.protocolVersion.toUInt(),
-                        protobufMessage.gck.toByteArray(),
-                        protobufMessage.sfuBaseUrl
+                    protobufMessage.protocolVersion.toUInt(),
+                    protobufMessage.gck.toByteArray(),
+                    protobufMessage.sfuBaseUrl
                 )
             } catch (e: InvalidProtocolBufferException) {
-                throw BadMessageException("Invalid group call start protobuf data")
+                throw BadMessageException("Invalid group call start protobuf data", e)
             } catch (e: IllegalArgumentException) {
                 throw BadMessageException("Could not create group call start data", e)
             }
@@ -53,17 +53,17 @@ class GroupCallStartData(
     }
 
     init {
-    	if (gck.size != GCK_LENGTH) {
+        if (gck.size != GCK_LENGTH) {
             throw IllegalArgumentException("Invalid length of gck")
         }
     }
 
     override fun toProtobufMessage(): GroupCallStart {
         return GroupCallStart.newBuilder()
-                .setProtocolVersion(protocolVersion.toInt())
-                .setGck(ByteString.copyFrom(gck))
-                .setSfuBaseUrl(sfuBaseUrl)
-                .build()
+            .setProtocolVersion(protocolVersion.toInt())
+            .setGck(ByteString.copyFrom(gck))
+            .setSfuBaseUrl(sfuBaseUrl)
+            .build()
     }
 
     override fun equals(other: Any?): Boolean {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt
index d19d0591..b94adf27 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt
@@ -21,13 +21,19 @@
 
 package ch.threema.domain.protocol.csp.messages.groupcall
 
+import ch.threema.domain.models.GroupId
 import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartData.Companion.fromProtobuf
 import ch.threema.domain.protocol.csp.messages.protobuf.AbstractProtobufGroupMessage
 import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import java.nio.charset.StandardCharsets
+import java.util.Arrays
 
 class GroupCallStartMessage(payloadData: GroupCallStartData) : AbstractProtobufGroupMessage<GroupCallStartData>(
-        ProtocolDefines.MSGTYPE_GROUP_CALL_START,
-        payloadData
+    ProtocolDefines.MSGTYPE_GROUP_CALL_START,
+    payloadData
 ), GroupCallControlMessage {
     override fun flagSendPush() = true
 
@@ -45,7 +51,93 @@ class GroupCallStartMessage(payloadData: GroupCallStartData) : AbstractProtobufG
 
     override fun reflectOutgoing() = true
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate(): Boolean = true
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the group-call-start message
+         *  @return Instance of [GroupCallStartMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): GroupCallStartMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val groupCallStartMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            groupCallStartMessage.initializeCommonProperties(message)
+            return groupCallStartMessage
+        }
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the group-call-start message
+         *  @return Instance of [GroupCallStartMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.OutgoingMessage, ownIdentity: String): GroupCallStartMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val groupCallStartMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            groupCallStartMessage.initializeCommonProperties(message)
+            groupCallStartMessage.fromIdentity = ownIdentity
+            return groupCallStartMessage
+        }
+
+        /**
+         * Build an instance of [GroupCallStartMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - header field: group-creator (identity, length 8)
+         *  - header field: api-group-id (id, length 8)
+         *  - body protobuf bytes of [GroupCallStartData]
+         *
+         * @param data   the data that represents the group-call-start message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [GroupCallStartMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): GroupCallStartMessage {
+            if (length <= ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            var positionIndex = offset
+
+            val groupCreator = String(data, positionIndex, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+            positionIndex += ProtocolDefines.IDENTITY_LEN
+
+            val apiGroupId = GroupId(data, positionIndex)
+            positionIndex += ProtocolDefines.GROUP_ID_LEN
+
+            val protobufPayload = Arrays.copyOfRange(data, positionIndex, length + offset)
+            val groupCallStartData: GroupCallStartData = fromProtobuf(protobufPayload)
+
+            return GroupCallStartMessage(groupCallStartData).apply {
+                setGroupCreator(groupCreator)
+                setApiGroupId(apiGroupId)
+            }
+        }
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt
index 006bc871..d63b0b4d 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt
@@ -31,12 +31,13 @@ private val logger = LoggingUtil.getThreemaLogger("AbstractProtobufGroupMessage"
 
 /**
  * @param type Protocol type of the message as defined in [ch.threema.domain.protocol.csp.ProtocolDefines]
- * @param protobufData Parsed protobuf data
+ * @param data Parsed protobuf data
  */
 abstract class AbstractProtobufGroupMessage<D : ProtobufDataInterface<*>?>(
     private val type: Int,
     val data: D
 ) : AbstractGroupMessage() {
+
     override fun getBody(): ByteArray? {
         return try {
             val bos = ByteArrayOutputStream()
@@ -46,11 +47,9 @@ abstract class AbstractProtobufGroupMessage<D : ProtobufDataInterface<*>?>(
             bos.toByteArray()
         } catch (e: Exception) {
             logger.error(e.message)
-            byteArrayOf()
+            null
         }
     }
 
-    override fun getType(): Int {
-        return type
-    }
+    override fun getType(): Int = type
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.java
deleted file mode 100644
index 4739c987..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-public class VoipCallAnswerMessage extends VoipMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallAnswerMessage");
-
-	private VoipCallAnswerData callAnswerData;
-
-	public VoipCallAnswerMessage() {
-		super();
-	}
-
-	public VoipCallAnswerMessage setData(VoipCallAnswerData callAnswerData) {
-		this.callAnswerData = callAnswerData;
-		return this;
-	}
-
-	public VoipCallAnswerData getData() {
-		return this.callAnswerData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callAnswerData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_ANSWER;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		// True only if we're accepting the call
-		final VoipCallAnswerData answerData = this.callAnswerData;
-		if (answerData == null) {
-			return false;
-		}
-		final Byte action = answerData.getAction();
-		return action != null && action == VoipCallAnswerData.Action.ACCEPT;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.kt
new file mode 100644
index 00000000..f51025ca
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.kt
@@ -0,0 +1,123 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.voip
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("VoipCallAnswerMessage")
+
+class VoipCallAnswerMessage : VoipMessage() {
+    var data: VoipCallAnswerData? = null
+
+    override fun getBody(): ByteArray? {
+        return try {
+            val bos = ByteArrayOutputStream()
+            data!!.write(bos)
+            bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_VOIP_CALL_ANSWER
+
+    override fun allowUserProfileDistribution(): Boolean {
+        // True only if we're accepting the call
+        val answerData = this.data ?: return false
+        val action = answerData.action
+        return action != null && action == VoipCallAnswerData.Action.ACCEPT
+    }
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the voip-call-answer message
+         *  @return Instance of [VoipCallAnswerMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): VoipCallAnswerMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val voipCallAnswerMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            voipCallAnswerMessage.initializeCommonProperties(message)
+            return voipCallAnswerMessage
+        }
+
+        /**
+         * Build an instance of [VoipCallAnswerMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - body json bytes of [VoipCallAnswerData]
+         *
+         * @param data   the data that represents the voip-call-answer message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [VoipCallAnswerMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): VoipCallAnswerMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+            return VoipCallAnswerMessage().apply {
+                val json = String(data, offset, length, StandardCharsets.UTF_8)
+                this.data = VoipCallAnswerData.parse(json)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java
index f9339adb..98b52634 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java
@@ -38,7 +38,8 @@ public class VoipCallHangupData extends VoipCallData<VoipCallHangupData> {
 
 	//region Serialization
 
-	public static @NonNull VoipCallHangupData parse(@NonNull String jsonObjectString) throws BadMessageException {
+    @NonNull
+    public static VoipCallHangupData parse(@NonNull String jsonObjectString) throws BadMessageException {
 		final JSONObject o;
 		if (jsonObjectString.trim().isEmpty()) {
 			// Historically, hangup messages may be empty
@@ -71,7 +72,8 @@ public class VoipCallHangupData extends VoipCallData<VoipCallHangupData> {
 		bos.write(this.generateString().getBytes(UTF_8));
 	}
 
-	private @NonNull String generateString() {
+    @NonNull
+    private String generateString() {
 		final JSONObject o = this.buildJsonObject();
 		return o.toString();
 	}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.java
deleted file mode 100644
index a327a067..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-/**
- * This packet is sent to indicate that one of the call participants has ended the call.
- */
-public class VoipCallHangupMessage extends VoipMessage {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallHangupMessage");
-
-	private @Nullable VoipCallHangupData callHangupData;
-
-	public VoipCallHangupMessage() {
-		super();
-	}
-
-	public VoipCallHangupMessage setData(@NonNull VoipCallHangupData callHangupData) {
-		this.callHangupData = callHangupData;
-		return this;
-	}
-
-	public @Nullable VoipCallHangupData getData() {
-		return this.callHangupData;
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_HANGUP;
-	}
-
-	@Override
-	@NonNull
-	public byte[] getBody() throws ThreemaException  {
-		try {
-			final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callHangupData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error("Could not serialize VoipCallHangupMessage", e);
-			throw new ThreemaException("Could not serialize VoipCallHangupMessage");
-		}
-	}
-
-	@Override
-	public boolean flagShortLivedServerQueuing() {
-		// Hangup messages should persist in the message queue
-		return false;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		// Note: Incoming hangup messages should trigger lastUpdate, but only if the call was
-		//       missed. Thus, we set the field to `false` here, and handle it in the "call missed"
-		//       logic instead.
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.kt
new file mode 100644
index 00000000..a26cf711
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.kt
@@ -0,0 +1,131 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.voip
+
+import ch.threema.base.ThreemaException
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("VoipCallHangupMessage")
+
+/**
+ * This packet is sent to indicate that one of the call participants has ended the call.
+ */
+class VoipCallHangupMessage : VoipMessage() {
+
+    var data: VoipCallHangupData? = null
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_VOIP_CALL_HANGUP
+
+    override fun getBody(): ByteArray? {
+        return try {
+            val bos = ByteArrayOutputStream()
+            data!!.write(bos)
+            bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error("Could not serialize VoipCallHangupMessage", exception)
+            null
+        }
+    }
+
+    // Hangup messages should persist in the message queue
+    override fun flagShortLivedServerQueuing(): Boolean = false
+
+    override fun allowUserProfileDistribution(): Boolean = false
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    /**
+     * Note: Incoming hangup messages should trigger lastUpdate, but only if the call was
+     *     missed. Thus, we set the field to `false` here, and handle it in the "call missed"
+     *     logic instead.
+     */
+    override fun bumpLastUpdate(): Boolean = false
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the voip-call-hangup message
+         *  @return Instance of [VoipCallHangupMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): VoipCallHangupMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val voipCallHangupMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            voipCallHangupMessage.initializeCommonProperties(message)
+            return voipCallHangupMessage
+        }
+
+        /**
+         * Build an instance of [VoipCallHangupMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - body json bytes of [VoipCallHangupData]
+         *
+         * @param data   the data that represents the voip-call-hangup message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [VoipCallHangupMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): VoipCallHangupMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+            return VoipCallHangupMessage().apply {
+                val json = String(data, offset, length, StandardCharsets.UTF_8)
+                this.data = VoipCallHangupData.parse(json)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.java
deleted file mode 100644
index 806e74b3..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-public class VoipCallOfferMessage extends VoipMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallOfferMessage");
-
-	private VoipCallOfferData callOfferData;
-
-	public VoipCallOfferMessage() {
-		super();
-	}
-
-	public VoipCallOfferMessage setData(VoipCallOfferData callOfferData) {
-		this.callOfferData = callOfferData;
-		return this;
-	}
-
-	public VoipCallOfferData getData() {
-		return this.callOfferData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callOfferData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_OFFER;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.kt
new file mode 100644
index 00000000..2fbb9c8f
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.kt
@@ -0,0 +1,119 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.voip
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("VoipCallOfferMessage")
+
+class VoipCallOfferMessage : VoipMessage() {
+
+    var data: VoipCallOfferData? = null
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_VOIP_CALL_OFFER
+
+    override fun allowUserProfileDistribution(): Boolean = true
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = true
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = true
+
+    override fun getBody(): ByteArray? {
+        return try {
+            val bos = ByteArrayOutputStream()
+            data!!.write(bos)
+            bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            null
+        }
+    }
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the voip-call-offer message
+         *  @return Instance of [VoipCallOfferMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): VoipCallOfferMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val voipCallOfferMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            voipCallOfferMessage.initializeCommonProperties(message)
+            return voipCallOfferMessage
+        }
+
+        /**
+         * Build an instance of [VoipCallOfferMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - body json bytes of [VoipCallOfferData]
+         *
+         * @param data   the data that represents the voip-call-offer message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [VoipCallOfferMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): VoipCallOfferMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+            return VoipCallOfferMessage().apply {
+                val json = String(data, offset, length, StandardCharsets.UTF_8)
+                this.data = VoipCallOfferData.parse(json)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.java
deleted file mode 100644
index 4ecb80a2..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-/**
- * This packet is sent by the receiver of a call.
- * It indicates towards the caller that the phone is ringing.
- */
-public class VoipCallRingingMessage extends VoipMessage {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallRingingMessage");
-
-	private @Nullable VoipCallRingingData callRingingData;
-
-	public VoipCallRingingMessage() {
-		super();
-	}
-
-	public VoipCallRingingMessage setData(@NonNull VoipCallRingingData callRingingData) {
-		this.callRingingData = callRingingData;
-		return this;
-	}
-
-	public @Nullable VoipCallRingingData getData() {
-		return this.callRingingData;
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_RINGING;
-	}
-
-	@Override
-	@NonNull
-	public byte[] getBody() throws ThreemaException {
-		try {
-			final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callRingingData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error("Could not serialize VoipCallRingingMessage", e);
-			throw new ThreemaException("Could not serialize VoipCallRingingMessage");
-		}
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.kt
new file mode 100644
index 00000000..828cba61
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.kt
@@ -0,0 +1,124 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.voip
+
+import ch.threema.base.ThreemaException
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("VoipCallRingingMessage")
+
+/**
+ * This packet is sent by the receiver of a call.
+ * It indicates towards the caller that the phone is ringing.
+ */
+class VoipCallRingingMessage : VoipMessage() {
+
+    var data: VoipCallRingingData? = null
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_VOIP_CALL_RINGING
+
+    override fun getBody(): ByteArray? {
+        return try {
+            val bos = ByteArrayOutputStream()
+            data!!.write(bos)
+            bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error("Could not serialize VoipCallRingingMessage", exception)
+            null
+        }
+    }
+
+    override fun allowUserProfileDistribution(): Boolean = false
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = true
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = true
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the voip-call-ringing message
+         *  @return Instance of [VoipCallRingingMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): VoipCallRingingMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val voipCallRingingMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            voipCallRingingMessage.initializeCommonProperties(message)
+            return voipCallRingingMessage
+        }
+
+        /**
+         * Build an instance of [VoipCallRingingMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - body json bytes of [VoipCallRingingData]
+         *
+         * @param data   the data that represents the voip-call-ringing message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [VoipCallRingingMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): VoipCallRingingMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+            return VoipCallRingingMessage().apply {
+                val json = String(data, offset, length, StandardCharsets.UTF_8)
+                this.data = VoipCallRingingData.parse(json)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.java
deleted file mode 100644
index c0000598..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-public class VoipICECandidatesMessage extends VoipMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipICECandidatesMessage");
-
-	private VoipICECandidatesData iceCandidatesData;
-
-	public VoipICECandidatesMessage() {
-		super();
-	}
-
-	public VoipICECandidatesMessage setData(VoipICECandidatesData iceCandidatesData) {
-		this.iceCandidatesData = iceCandidatesData;
-		return this;
-	}
-
-	public VoipICECandidatesData getData() {
-		return this.iceCandidatesData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.iceCandidatesData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_ICE_CANDIDATES;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return false;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.kt
new file mode 100644
index 00000000..f6fd590e
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.kt
@@ -0,0 +1,119 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.voip
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.MdD2D
+import org.slf4j.Logger
+import java.io.ByteArrayOutputStream
+import java.nio.charset.StandardCharsets
+
+private val logger: Logger = LoggingUtil.getThreemaLogger("VoipICECandidatesMessage")
+
+class VoipICECandidatesMessage : VoipMessage() {
+
+    var data: VoipICECandidatesData? = null
+
+    override fun getBody(): ByteArray? {
+        return try {
+            val bos = ByteArrayOutputStream()
+            data!!.write(bos)
+            bos.toByteArray()
+        } catch (exception: Exception) {
+            logger.error(exception.message)
+            null
+        }
+    }
+
+    override fun getType(): Int = ProtocolDefines.MSGTYPE_VOIP_ICE_CANDIDATES
+
+    override fun allowUserProfileDistribution(): Boolean = false
+
+    override fun exemptFromBlocking(): Boolean = false
+
+    override fun protectAgainstReplay(): Boolean = false
+
+    override fun createImplicitlyDirectContact(): Boolean = false
+
+    override fun reflectIncoming(): Boolean = true
+
+    override fun reflectOutgoing(): Boolean = false
+
+    override fun reflectSentUpdate(): Boolean = false
+
+    override fun sendAutomaticDeliveryReceipt(): Boolean = false
+
+    override fun bumpLastUpdate(): Boolean = false
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the voip-ice-candidates message
+         *  @return Instance of [VoipICECandidatesMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage) : VoipICECandidatesMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val voipICECandidatesMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            voipICECandidatesMessage.initializeCommonProperties(message)
+            return voipICECandidatesMessage
+        }
+
+        /**
+         * Build an instance of [VoipICECandidatesMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - body json bytes of [VoipICECandidatesData]
+         *
+         * @param data   the data that represents the voip-ice-candidates message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [VoipICECandidatesMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): VoipICECandidatesMessage {
+            if (length < 1) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+            return VoipICECandidatesMessage().apply {
+                val json = String(data, offset, length, StandardCharsets.UTF_8)
+                this.data = VoipICECandidatesData.parse(json)
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.kt
new file mode 100644
index 00000000..8d591601
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.kt
@@ -0,0 +1,35 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.voip
+
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.protobuf.csp.e2e.fs.Version
+
+abstract class VoipMessage : AbstractMessage() {
+
+    override fun flagSendPush(): Boolean = true
+
+    // Should be set for all VoIP messages except for the hangup message
+    override fun flagShortLivedServerQueuing(): Boolean = true
+
+    override fun getMinimumRequiredForwardSecurityVersion(): Version? = Version.V1_1
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt b/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt
index a7e55864..825fe4cd 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt
@@ -21,11 +21,18 @@
 
 package ch.threema.domain.protocol.multidevice
 
+import ch.threema.base.crypto.Nonce
 import ch.threema.base.crypto.ThreemaKDF
 import ch.threema.base.utils.SecureRandomUtil.generateRandomBytes
 import ch.threema.domain.protocol.connection.data.D2dMessage
 import ch.threema.domain.protocol.connection.data.InboundD2mMessage
 import ch.threema.domain.protocol.connection.data.D2mProtocolException
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.protobuf.d2d.MdD2D.DeviceInfo
+import ch.threema.protobuf.d2d.MdD2D.Envelope
+import ch.threema.protobuf.d2d.MdD2D.TransactionScope
+import ch.threema.protobuf.d2d.MdD2D.TransactionScope.Scope
+import ch.threema.protobuf.d2d.transactionScope
 import com.neilalexander.jnacl.NaCl
 
 data class MultiDeviceKeys(val dgk: ByteArray) {
@@ -68,6 +75,49 @@ data class MultiDeviceKeys(val dgk: ByteArray) {
         return nonce + NaCl.symmetricEncryptData(deviceInfo.bytes, dgdik, nonce)
     }
 
+    fun decryptDeviceInfo(deviceInfo: ByteArray): D2dMessage.DeviceInfo {
+        val nonce = deviceInfo.copyOfRange(0, NaCl.NONCEBYTES)
+        val data = deviceInfo.copyOfRange(nonce.size, deviceInfo.size)
+        val decrypted = NaCl.symmetricDecryptData(data, dgdik, nonce)
+        return DeviceInfo.parseFrom(decrypted).let { D2dMessage.DeviceInfo.fromProtobuf(it) }
+    }
+
+    fun encryptTransactionScope(scope: Scope): ByteArray {
+        val nonce = createNonce()
+        val bytes = transactionScope {
+            this.scope = scope
+        }.toByteArray()
+        val encrypted = NaCl.symmetricEncryptData(bytes, dgtsk, nonce)
+        return nonce + encrypted
+    }
+
+    fun decryptTransactionScope(encryptedTransactionScope: ByteArray): Scope {
+        val nonce = encryptedTransactionScope.copyOfRange(0, NaCl.NONCEBYTES)
+        val data = encryptedTransactionScope.copyOfRange(nonce.size, encryptedTransactionScope.size)
+        val decrypted = NaCl.symmetricDecryptData(data, dgtsk, nonce)
+        return TransactionScope.parseFrom(decrypted).scope
+    }
+
+    fun encryptEnvelope(envelope: Envelope): EncryptedEnvelopeResult {
+        val nonceBytes = createNonce()
+        val encryptedEnvelope = nonceBytes + NaCl.symmetricEncryptData(envelope.toByteArray(), dgrk, nonceBytes)
+        return EncryptedEnvelopeResult(
+            encryptedEnvelope = encryptedEnvelope,
+            nonce = Nonce(nonceBytes),
+            debugInfo = EncryptedEnvelopeResult.DebugInfo(
+                protoContentCaseName = envelope.contentCase.name,
+                rawEnvelopeContent = envelope.toString()
+            )
+        )
+    }
+
+    fun decryptEnvelope(encryptedEnvelopeBytes: ByteArray): Pair<Nonce, Envelope> {
+        val nonce = encryptedEnvelopeBytes.copyOfRange(0, NaCl.NONCEBYTES)
+        val data = encryptedEnvelopeBytes.copyOfRange(nonce.size, encryptedEnvelopeBytes.size)
+        val decrypted = NaCl.symmetricDecryptData(data, dgrk, nonce)
+        return Nonce(nonce) to Envelope.parseFrom(decrypted)
+    }
+
     override fun equals(other: Any?): Boolean {
         if (this === other) return true
         if (other !is MultiDeviceKeys) return false
@@ -85,5 +135,50 @@ data class MultiDeviceKeys(val dgk: ByteArray) {
         return "MultiDeviceKeys(dgk=********)"
     }
 
+    /**
+     * @param encryptedEnvelope Encrypted envelope bytes
+     * @param debugInfo         Only used for debugging. Contains the unencrypted contents of [MdD2D.Envelope.toString]
+     */
+    data class EncryptedEnvelopeResult(
+        val encryptedEnvelope: ByteArray,
+        val nonce: Nonce,
+        val debugInfo: DebugInfo
+    ) {
+
+        override fun equals(other: Any?): Boolean {
+            if (this === other) return true
+            if (javaClass != other?.javaClass) return false
+            other as EncryptedEnvelopeResult
+            if (!encryptedEnvelope.contentEquals(other.encryptedEnvelope)) return false
+            if (nonce != other.nonce) return false
+            if (debugInfo != other.debugInfo) return false
+            return true
+        }
+
+        override fun hashCode(): Int {
+            var result = encryptedEnvelope.contentHashCode()
+            result = 31 * result + nonce.hashCode()
+            result = 31 * result + debugInfo.hashCode()
+            return result
+        }
 
+        override fun toString(): String {
+            return "EncryptedEnvelopeResult(encryptedEnvelope: ${encryptedEnvelope.contentToString()}, nonce: ***, debugInfo: $debugInfo"
+        }
+
+        /**
+         * @param protoContentCaseName Is the value of [Envelope.getContentCase]
+         * @param rawEnvelopeContent   Contains the whole proto message contents in an **unencrypted** form. Never send this
+         * and only log it on debug level!
+         */
+        data class DebugInfo(
+            val protoContentCaseName: String,
+            val rawEnvelopeContent: String
+        ) {
+
+            override fun toString(): String {
+                return "EncryptedEnvelopeResult(protoContentCaseName: $protoContentCaseName, rawEnvelopeContent: ***)"
+            }
+        }
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt b/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt
index 004df7e4..92854f02 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt
@@ -55,6 +55,4 @@ data class MultiDeviceProperties(
     override fun toString(): String {
         return "MultiDeviceProperties(registrationTime=$registrationTime, mediatorDeviceId=$mediatorDeviceId, cspDeviceId=$cspDeviceId, keys=********, deviceInfo=$deviceInfo, protocolVersion=$protocolVersion, serverInfoListener=$serverInfoListener, deviceSlotState=$deviceSlotState)"
     }
-
-
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPath.kt b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPath.kt
new file mode 100644
index 00000000..0ef5a4ca
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPath.kt
@@ -0,0 +1,165 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import ch.threema.base.utils.LoggingUtil
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.cancelAndJoin
+import kotlinx.coroutines.channels.Channel
+import kotlinx.coroutines.channels.ClosedReceiveChannelException
+import kotlinx.coroutines.launch
+import java.io.IOException
+
+typealias MultiplexedBytes = Pair<UInt, ByteArray>
+
+private val logger = LoggingUtil.getThreemaLogger("MultiplexedRendezvousPath")
+
+internal class MultiplexedRendezvousPath(
+    paths: Map<UInt, RendezvousPath>,
+    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO
+) {
+    private val paths = paths.toMutableMap()
+    private val readBytes = Channel<MultiplexedBytes>(Channel.UNLIMITED)
+
+    private val readJobs: MutableMap<UInt, Job> = mutableMapOf()
+
+    /**
+     * @throws IOException if there are no paths to connect to
+     */
+    suspend fun connect() {
+        if (paths.isEmpty()) {
+            throw IOException("Cannot connect as there are no paths")
+        }
+        paths.values.forEach { path ->
+            setupReading(path)
+        }
+    }
+
+    /**
+     * Close _all_ paths contained in this multiplexed path.
+     * If all but a single path should be closed, use [nominate]
+     */
+    fun closeAll() {
+        closePaths(paths.values)
+    }
+
+    /**
+     * Get a single path contained in this multiplexed path and close all other paths.
+     * Reading of _all_ paths will be stopped. For further reading the nominated paths'
+     * [RendezvousPath.close] method should be used.
+     *
+     * If no path with the provided [pid] is found, all paths will be closed and and exception is thrown.
+     */
+    suspend fun nominate(pid: UInt): RendezvousPath {
+        val otherPaths = paths.entries
+            .filter { it.key != pid }
+            .map { it.value }
+        closePaths(otherPaths)
+        logger.trace("Cancel reading jobs")
+        readJobs.values.forEach { it.cancelAndJoin() }
+        readJobs.clear()
+        val nominatedPath = paths[pid] ?: throw RendezvousException("No path with pid=`$pid` found")
+        paths.clear()
+        return nominatedPath
+    }
+
+    /**
+     * Write [data] to this [MultiplexedRendezvousPath].
+     * Note: If no path with the requested pid is found, but there are remaining open paths
+     * [data] is silently ignored.
+     *
+     * @throws IOException if no open paths are available
+     */
+    suspend fun write(data: MultiplexedBytes) {
+        val (pid, bytes) = data
+        val path = getPath(pid)
+        if (path != null) {
+            path.write(bytes)
+        } else if (paths.isEmpty()) {
+            throw IOException("No paths available")
+        }
+    }
+
+    /**
+     * Read the next bytes that are received by the multiplexed path.
+     *
+     * @throws IOException if there are no underlying [RendezvousPath]s.
+     */
+    suspend fun read(): MultiplexedBytes = try {
+        readBytes.receive()
+    } catch (e: ClosedReceiveChannelException) {
+        throw IOException(e)
+    }
+
+    private fun closePaths(pathsToClose: Collection<RendezvousPath>) {
+        // Use a defensive copy of the paths because it might be linked
+        // to the [paths] map, which would lead to a ConcurrentModificationException
+        pathsToClose.toList().forEach {
+            it.close()
+            removePath(it)
+        }
+    }
+
+    private fun getPath(pid: UInt): RendezvousPath? {
+        return paths[pid].also {
+            if (it == null) {
+                logger.warn("Attempt to access an unknown path (pid=$pid)")
+            }
+        }
+    }
+
+    private suspend fun setupReading(path: RendezvousPath) {
+        val pid = path.pid
+        logger.trace("Setup reading for pid={}", pid)
+        if (readJobs.containsKey(pid)) {
+            logger.warn("There is already a reading job for pid={}", pid)
+            return
+        }
+        path.connect()
+        readJobs[pid] = CoroutineScope(ioDispatcher).launch {
+            try {
+                while (true) {
+                    readBytes.send(pid to path.read())
+                }
+            } catch (e: IOException) {
+                logger.error("Path with pid={} was closed while reading; remove path", pid)
+                removePath(path)
+            }
+        }
+    }
+
+    private fun removePath(path: RendezvousPath) {
+        logger.info("Remove path with pid={}", path.pid)
+        paths.remove(path.pid)
+        if (paths.isEmpty()) {
+            logger.info("No remaining paths. Close readBytes channel.")
+            readBytes.close()
+        }
+    }
+}
+
+internal fun Map<UInt, RendezvousPath>.toMultiplexedPath(): MultiplexedRendezvousPath {
+    return MultiplexedRendezvousPath(this)
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousConnection.kt
new file mode 100644
index 00000000..8cf5df32
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousConnection.kt
@@ -0,0 +1,233 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import ch.threema.base.utils.LoggingUtil
+import ch.threema.base.utils.chunked
+import ch.threema.libthreema.PathProcessResult
+import ch.threema.libthreema.PathStateUpdate
+import ch.threema.libthreema.RendezvousProtocol
+import ch.threema.protobuf.d2d.join.MdD2DJoin.NdToEd
+import ch.threema.protobuf.d2d.rendezvous.MdD2DRendezvous.RendezvousInit
+import kotlinx.coroutines.Deferred
+import okhttp3.OkHttpClient
+
+private val logger = LoggingUtil.getThreemaLogger("DeviceJoin.RendezvousConnection")
+
+class RendezvousConnection private constructor(
+    val rph: ByteArray,
+    private val protocol: RendezvousProtocol,
+    private val rendezvousPath: RendezvousPath
+) {
+    val closedSignal: Deferred<Unit> = rendezvousPath.closedSignal
+
+    /**
+     * @throws RendezvousException if the [DeviceJoinMessage] does not result in a valid outgoingFrame
+     * @throws java.io.IOException if writing to the underlying [RendezvousPath] failed
+     */
+    suspend fun write(message: DeviceJoinMessage) {
+        logger.debug("Sending ULP data (length={})", message.bytes.size)
+        val result = protocol.createUlpFrame(message.bytes)
+
+        if (result.stateUpdate != null) {
+            logger.warn("Ignore unexpected state update")
+        }
+
+        if (result.incomingUlpData != null) {
+            logger.warn("Ignore unexpected incoming ulp data")
+        }
+
+        if (result.outgoingFrame == null) {
+            throw RendezvousException("Outgoing frame is missing")
+        }
+
+        result.outgoingFrame.chunked(1024 * 1024).forEach {
+            rendezvousPath.write(it)
+        }
+    }
+
+    /**
+     * @throws java.io.IOException if reading from the underlying [RendezvousPath] failed.
+     */
+    suspend fun read(): DeviceJoinMessage {
+        while (true) {
+            val pid = rendezvousPath.pid
+            protocol.addChunks(pid, listOf(rendezvousPath.read()))
+            val result = protocol.processFrame(pid) ?: continue
+
+            if (result.stateUpdate != null) {
+                logger.warn("Ignore unexpected state update")
+            }
+
+            if (result.outgoingFrame != null) {
+                logger.warn("Ignore unexpected outgoing frame")
+            }
+
+            if (result.incomingUlpData != null) {
+                return result.incomingUlpData.decodeUlpData()
+            }
+        }
+    }
+
+    /**
+     * Close the connection. If the connection has already been closed, this method has no effect.
+     */
+    fun close() {
+        rendezvousPath.close()
+    }
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is RendezvousConnection) return false
+
+        if (!rph.contentEquals(other.rph)) return false
+        return rendezvousPath == other.rendezvousPath
+    }
+
+    override fun hashCode(): Int {
+        var result = rph.contentHashCode()
+        result = 31 * result + rendezvousPath.hashCode()
+        return result
+    }
+
+    // TODO(ANDR-2696): Also decode EdToNd messages
+    private fun ByteArray.decodeUlpData(): DeviceJoinMessage {
+        try {
+            val message = NdToEd.parseFrom(this)
+            return when(message.contentCase!!) {
+                NdToEd.ContentCase.REGISTERED -> DeviceJoinMessage.Registered()
+                NdToEd.ContentCase.CONTENT_NOT_SET -> throw RendezvousException("NdToEd message has no content")
+            }
+        } catch (e: Exception) {
+            throw RendezvousException("Cannot parse ulp data", e)
+        }
+    }
+
+    companion object {
+        private class DefaultRendezvousPathProvider(private val okHttpClient: OkHttpClient) : RendezvousPathProvider {
+            override fun getPaths(rendezvousInit: RendezvousInit): Map<UInt, RendezvousPath> {
+                return getPaths(okHttpClient, rendezvousInit)
+            }
+
+            private fun getPaths(okHttpClient: OkHttpClient, rendezvousInit: RendezvousInit): Map<UInt, RendezvousPath> {
+                if (rendezvousInit.hasDirectTcpServer()) {
+                    logger.info("Ignore unsupported direct tcp server")
+                    logger.debug("Ignored direct tcp server: {}", rendezvousInit.directTcpServer)
+                }
+                if (!rendezvousInit.hasRelayedWebSocket()) {
+                    throw RendezvousException("No relayed web socket provided")
+                }
+                return mapOf(
+                    rendezvousInit.relayedWebSocket.let { it.pathId.toUInt() to WebSocketRendezvousPath(it.pathId.toUInt(), okHttpClient, it.url) }
+                )
+            }
+        }
+
+        suspend fun connect(okHttpClient: OkHttpClient, rendezvousInit: RendezvousInit): RendezvousConnection {
+            return connect(DefaultRendezvousPathProvider(okHttpClient), rendezvousInit)
+        }
+
+        private suspend fun connect(rendezvousPathProvider: RendezvousPathProvider, rendezvousInit: RendezvousInit): RendezvousConnection {
+            val paths = rendezvousPathProvider.getPaths(rendezvousInit)
+
+            val protocol = RendezvousProtocol.newAsRrd(
+                true,
+                rendezvousInit.ak.toByteArray(),
+                paths.keys.toList()
+            )
+
+            val multiplexedPath = paths.toMultiplexedPath()
+            return try {
+                multiplexedPath.connect()
+                logger.debug("Connected")
+
+                // Send initial frames
+                protocol.initialOutgoingFrames()?.let { frames ->
+                    logger.debug("Send {} initial outgoing frames", frames.size)
+                    frames.forEach { frame ->
+                        multiplexedPath.write(frame.pid to frame.frame)
+                    }
+                }
+
+                runNominationLoop(protocol, multiplexedPath)
+            } catch (e: Exception) {
+                logger.warn("Rendezvous connection failed. Close all possible paths.")
+                multiplexedPath.closeAll()
+                throw e
+            }
+        }
+
+        /**
+         * Run the nomination loop where we run the handshakes simultaneously over all
+         * available paths until we have nominated one path.
+         */
+        private suspend fun runNominationLoop(
+            protocol: RendezvousProtocol,
+            multiplexedPath: MultiplexedRendezvousPath
+        ): RendezvousConnection {
+            logger.info("Entering nomination loop")
+            while(true) {
+                val (pid, incomingFrame) = multiplexedPath.read()
+                protocol.addChunks(pid, listOf(incomingFrame))
+                var result: PathProcessResult? = protocol.processFrame(pid)
+
+                while (result != null) {
+                    if (result.incomingUlpData != null) {
+                        logger.warn("Unexpected incoming ULP data in nomination loop")
+                    }
+
+                    result.outgoingFrame?.let {
+                        multiplexedPath.write(pid to it)
+                    }
+
+                    when (val update = result.stateUpdate) {
+                        is PathStateUpdate.AwaitingNominate -> {
+                            // Check if we should nominate the path
+                            // TODO(ANDR-2691): Choose the _best_ path based on the measured RTT
+                            logger.debug("Path ready to nominate (measuredRttMs={})", update.measuredRttMs)
+                            result = if (protocol.isNominator()) {
+                                try {
+                                    protocol.nominatePath(pid)
+                                } catch (e: Exception) {
+                                    multiplexedPath.closeAll()
+                                    throw RendezvousException("Unable to nominate path", e)
+                                }
+                            } else {
+                                null
+                            }
+                        }
+                        is PathStateUpdate.Nominated -> {
+                            val nominated = multiplexedPath.nominate(pid)
+                            logger.info("Nomination complete, rendezvous connection established")
+                            return RendezvousConnection(
+                                update.rph,
+                                protocol,
+                                nominated
+                            )
+                        }
+                        null -> result = null
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousException.kt b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousException.kt
new file mode 100644
index 00000000..db5f23be
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousException.kt
@@ -0,0 +1,29 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import ch.threema.base.ThreemaException
+
+class RendezvousException : ThreemaException {
+    constructor(msg: String) : super(msg)
+    constructor(msg: String, throwable: Throwable) : super(msg, throwable)
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPath.kt b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPath.kt
new file mode 100644
index 00000000..a0b7e5ce
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPath.kt
@@ -0,0 +1,51 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import kotlinx.coroutines.Deferred
+
+internal interface RendezvousPath {
+    val pid: UInt
+    val closedSignal: Deferred<Unit>
+
+    suspend fun connect()
+
+    /**
+     * Close this path. This must close all underlying connections.
+     */
+    fun close()
+
+    /**
+     * Write [bytes] to this path. This suspends until the bytes are sent.
+     *
+     * @throws java.io.IOException if writing is not possible
+     */
+    suspend fun write(bytes: ByteArray)
+
+    /**
+     * Read the next chunk of bytes from this path.
+     *
+     * @throws java.io.IOException if the path is closed while waiting for bytes
+     */
+    suspend fun read(): ByteArray
+}
+
diff --git a/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPathProvider.kt b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPathProvider.kt
new file mode 100644
index 00000000..ff597214
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPathProvider.kt
@@ -0,0 +1,28 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import ch.threema.protobuf.d2d.rendezvous.MdD2DRendezvous
+
+internal fun interface RendezvousPathProvider {
+    fun getPaths(rendezvousInit: MdD2DRendezvous.RendezvousInit): Map<UInt, RendezvousPath>
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/rendezvous/WebSocketRendezvousPath.kt b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/WebSocketRendezvousPath.kt
new file mode 100644
index 00000000..0d178afd
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/WebSocketRendezvousPath.kt
@@ -0,0 +1,143 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import ch.threema.base.utils.LoggingUtil
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.channels.Channel
+import kotlinx.coroutines.channels.ClosedReceiveChannelException
+import kotlinx.coroutines.delay
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.WebSocket
+import okhttp3.WebSocketListener
+import okio.ByteString
+import okio.ByteString.Companion.toByteString
+import java.io.IOException
+
+private val logger = LoggingUtil.getThreemaLogger("WebSocketRendezvousPath")
+
+internal class WebSocketRendezvousPath(
+    override val pid: UInt,
+    private val okHttpClient: OkHttpClient,
+    private val url: String
+) : RendezvousPath {
+    private val _closedSignal = CompletableDeferred<Unit>()
+    override val closedSignal: Deferred<Unit> = _closedSignal
+
+    private val inboundQueue = Channel<ByteArray>(Channel.UNLIMITED)
+
+    private val connectedSignal = CompletableDeferred<Unit>()
+
+    private var webSocket: WebSocket? = null
+    private val webSocketListener = object : WebSocketListener() {
+        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
+            logger.debug("WebSocket closed: code={}, reason={}", code, reason)
+            _closedSignal.complete(Unit)
+            inboundQueue.close()
+        }
+
+        override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
+            logger.debug("WebSocket closing: code={}, reason={}", code, reason)
+            close()
+        }
+
+        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
+            logger.warn("WebSocket failure", t)
+            connectedSignal.completeExceptionally(t)
+            inboundQueue.close(IOException("WebSocket failure", t))
+            _closedSignal.complete(Unit)
+        }
+
+        override fun onMessage(webSocket: WebSocket, text: String) {
+            logger.trace("Text message received: {}", text)
+        }
+
+        override fun onMessage(webSocket: WebSocket, bytes: ByteString) {
+            logger.trace("Byte message received (length={})", bytes.size)
+            val result = inboundQueue.trySend(bytes.toByteArray())
+            result.exceptionOrNull()?.let {
+                logger.error("Error when receiving a message", it)
+            }
+        }
+
+        override fun onOpen(webSocket: WebSocket, response: Response) {
+            logger.info("Connected to {}", response.request.url)
+            connectedSignal.complete(Unit)
+        }
+    }
+
+    override fun close() {
+        webSocket.let {
+            if (it != null) {
+                val initiated = it.close(1000, "Closed")
+                logger.debug("Close rendezvous websocket (initiatedByThisCall={})", initiated)
+            } else {
+                logger.debug("Websocket is `null`, cannot close")
+            }
+        }
+    }
+
+    override suspend fun connect() {
+        val request = Request.Builder()
+            .url(url)
+            .build()
+        webSocket = okHttpClient.newWebSocket(request, webSocketListener)
+        connectedSignal.await()
+    }
+
+    override suspend fun write(bytes: ByteArray) {
+        val socket = webSocket ?: throw RendezvousException("Web socket is not initialized")
+        if (!socket.send(bytes.toByteString())) {
+            throw IOException("Could not write bytes")
+        }
+        while(socket.queueSize() > 0) {
+            if (closedSignal.isCompleted) {
+                throw IOException("Socket has been closed while writing")
+            }
+            // Delay before next check to make the method suspending
+            delay(1)
+        }
+    }
+
+    override suspend fun read(): ByteArray {
+        logger.trace("Read from inbound queue")
+        return try {
+            inboundQueue.receive()
+        } catch (e: ClosedReceiveChannelException) {
+            throw IOException(e)
+        }
+    }
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is WebSocketRendezvousPath) return false
+
+        return url == other.url
+    }
+
+    override fun hashCode(): Int {
+        return url.hashCode()
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/rendezvous/messages.kt b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/messages.kt
new file mode 100644
index 00000000..10af7307
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/protocol/rendezvous/messages.kt
@@ -0,0 +1,63 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import ch.threema.protobuf.Common
+import ch.threema.protobuf.d2d.join.MdD2DJoin
+import ch.threema.protobuf.d2d.join.begin
+import ch.threema.protobuf.d2d.join.edToNd
+import ch.threema.protobuf.d2d.join.ndToEd
+import ch.threema.protobuf.d2d.join.registered
+
+sealed interface DeviceJoinMessage {
+    val bytes: ByteArray
+
+    @Suppress("CanSealedSubClassBeObject")
+    class Begin : DeviceJoinMessage {
+        override val bytes: ByteArray
+            get() = edToNd {
+                begin = begin {}
+            }.toByteArray()
+    }
+
+    @Suppress("CanSealedSubClassBeObject")
+    class Registered : DeviceJoinMessage {
+        override val bytes: ByteArray
+            get() = ndToEd {
+                registered = registered {}
+            }.toByteArray()
+    }
+
+    data class BlobData(val data: Common.BlobData) : DeviceJoinMessage {
+        override val bytes: ByteArray
+            get() = edToNd {
+                blobData = data
+            }.toByteArray()
+    }
+
+    data class EssentialData(val data: MdD2DJoin.EssentialData) : DeviceJoinMessage {
+        override val bytes: ByteArray
+            get() = edToNd {
+                essentialData = data
+            }.toByteArray()
+    }
+}
diff --git a/domain/src/main/java/ch/threema/domain/stores/ContactStore.java b/domain/src/main/java/ch/threema/domain/stores/ContactStore.java
index 54bf85f5..69080a33 100644
--- a/domain/src/main/java/ch/threema/domain/stores/ContactStore.java
+++ b/domain/src/main/java/ch/threema/domain/stores/ContactStore.java
@@ -24,6 +24,7 @@ package ch.threema.domain.stores;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 
 /**
  * A contact store stores {@link Contact} instances.
@@ -44,7 +45,15 @@ public interface ContactStore {
 	 *
  	 * @param contact the contact that is temporarily saved
 	 */
-	void addCachedContact(@NonNull Contact contact);
+	void addCachedContact(@NonNull BasicContact contact);
+
+	/**
+	 * Get the cached contact for the given identity. If there is no cached contact, null is
+	 * returned. Note that if the contact with the given identity exists but is not in cache, null
+	 * is returned.
+	 */
+	@Nullable
+	BasicContact getCachedContact(@NonNull String identity);
 
 	/**
 	 * Get the cached or stored contact for the given identity. This method first checks if the
@@ -65,7 +74,8 @@ public interface ContactStore {
 	void addContact(@NonNull Contact contact);
 
 	/**
-	 * Remove a contact from the contact store.
+	 * Check whether the identity belongs to a special contact or not.
 	 */
-	void removeContact(@NonNull Contact contact);
+	boolean isSpecialContact(@NonNull String identity);
+
 }
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt
index 32ae7a33..62d96927 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt
@@ -48,14 +48,17 @@ class IncomingCspMessageTask(
     }
 
     private fun processError(data: CspMessage.ServerErrorData) {
+        // Note that server errors are already processed in the task manager
         logger.warn("Processed server error in incoming csp message task: '{}'", data.message)
     }
 
     private fun processAlert(data: CspMessage.ServerAlertData) {
+        // Note that server alerts are already processed in the task manager
         logger.warn("Processed server alert in incoming csp message task: '{}'", data.message)
     }
 
     private fun processOutgoingMessageAck(data: CspMessage.MessageAck) {
+        // Note that outgoing message acks should be consumed in the task that sent out the message
         logger.warn(
             "Processed ack for outgoing message {} to {} in incoming csp message task",
             data.messageId,
@@ -67,23 +70,27 @@ class IncomingCspMessageTask(
         data: CspMessage.IncomingMessageData,
         handle: ActiveTaskCodec,
     ) {
+        // TODO(ANDR-2732): If multi device is active and the device is not the leader: abort and restart connection
+
         if (data.data.size < ProtocolDefines.OVERHEAD_MSG_HDR) {
             throw PayloadProcessingException("Bad length (${data.data.size}) for message payload")
         }
         suspend {
             val messageBox = MessageBox.parseBinary(data.data)
 
-            incomingMessageProcessor.processIncomingMessage(messageBox, handle)
+            incomingMessageProcessor.processIncomingCspMessage(messageBox, handle)
         }.catchAllExceptNetworkException {
             logger.error("Could not process incoming message", it)
         }
     }
 
     private fun processQueueSendComplete() {
+        // Note that queue send complete messages are already processed in the task manager
         logger.warn("Processed queue send complete inside incoming csp message task")
     }
 
     private fun processDeviceCookieChangeIndication() {
+        // Note that device cookie change indications are already processed in the task manager
         logger.warn("Processed device cookie change indication inside incoming csp message task")
     }
 
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt
index a80592d7..5d0ecdcc 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt
@@ -22,21 +22,30 @@
 package ch.threema.domain.taskmanager
 
 import ch.threema.base.utils.LoggingUtil
+import ch.threema.domain.protocol.D2mPayloadType
 import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.toHex
 
 private val logger = LoggingUtil.getThreemaLogger("IncomingD2mMessageTask")
 
 class IncomingD2mMessageTask(
-    private val message: InboundD2mMessage
+    private val message: InboundD2mMessage,
+    private val incomingMessageProcessor: IncomingMessageProcessor,
 ) : ActiveTask<Unit> {
     override val type: String = "IncomingD2mMessageTask"
 
     override suspend fun invoke(handle: ActiveTaskCodec) {
-        logger.warn(
-            "Ignore incoming d2m message with type={} and payloadType={}",
-            message.type,
-            message.payloadType.toHex()
-        )
+        when (message.payloadType) {
+            D2mPayloadType.REFLECTED ->
+                handleReflected(message as InboundD2mMessage.Reflected, handle)
+
+            else -> logger.warn("Unexpected d2m message of type {} received", message.payloadType)
+        }
+    }
+
+    private suspend fun handleReflected(
+        message: InboundD2mMessage.Reflected,
+        handle: ActiveTaskCodec,
+    ) {
+        incomingMessageProcessor.processIncomingD2mMessage(message, handle)
     }
 }
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt
index 5654ea26..e87c7cac 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt
@@ -22,14 +22,20 @@
 package ch.threema.domain.taskmanager
 
 import ch.threema.domain.protocol.connection.data.CspMessage
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
 import ch.threema.domain.protocol.csp.coders.MessageBox
 
 interface IncomingMessageProcessor {
 
     /**
-     * Process an incoming message.
+     * Process an incoming csp message.
      */
-    suspend fun processIncomingMessage(messageBox: MessageBox, handle: ActiveTaskCodec)
+    suspend fun processIncomingCspMessage(messageBox: MessageBox, handle: ActiveTaskCodec)
+
+    /**
+     * Process an incoming d2m message.
+     */
+    suspend fun processIncomingD2mMessage(message: InboundD2mMessage.Reflected, handle: ActiveTaskCodec)
 
     /**
      * Process an incoming server alert
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt
index 0cd3e7e2..9f5ca56a 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt
@@ -95,7 +95,7 @@ internal class IncomingMessageTaskQueue(
                     return ReadMessageResult(bypassMessages, backlogMessage.inboundMessage)
                 }
 
-                // TODO(ANDR-2475): once we bypass messages, no bypassed message should be added to the backlog queue
+                // TODO(ANDR-2707): once we bypass messages, no bypassed message should be added to the backlog queue
                 MessageFilterInstruction.BYPASS_OR_BACKLOG -> continue
 
                 MessageFilterInstruction.REJECT -> TODO("Implement") // TODO(ANDR-2868)
@@ -112,11 +112,11 @@ internal class IncomingMessageTaskQueue(
                 )
 
                 MessageFilterInstruction.BYPASS_OR_BACKLOG -> {
-                    // TODO(ANDR-2475): bypass d2d messages
+                    // TODO(ANDR-2707): bypass d2d messages
                     backlogQueue.add(message)
                 }
 
-                MessageFilterInstruction.REJECT -> TODO("Implement") // TODO(ANDR-2475)
+                MessageFilterInstruction.REJECT -> TODO("Implement") // TODO(ANDR-2868)
             }
         }
     }
@@ -140,7 +140,7 @@ internal class IncomingMessageTaskQueue(
         private val task by lazy {
             when (inboundMessage) {
                 is CspMessage -> IncomingCspMessageTask(inboundMessage, incomingMessageProcessor)
-                is InboundD2mMessage -> IncomingD2mMessageTask(inboundMessage)
+                is InboundD2mMessage -> IncomingD2mMessageTask(inboundMessage, incomingMessageProcessor)
             }
         }
         private val done: CompletableDeferred<Unit> = CompletableDeferred()
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt b/domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt
index 76d98fb5..30fcb7a7 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt
@@ -21,7 +21,7 @@
 
 package ch.threema.domain.taskmanager
 
-import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.Nonce
 import ch.threema.domain.protocol.connection.data.CspMessage
 import ch.threema.domain.protocol.csp.MessageTooLongException
 import ch.threema.domain.protocol.csp.ProtocolDefines
@@ -30,11 +30,11 @@ import ch.threema.domain.protocol.csp.messages.AbstractMessage
 import ch.threema.domain.stores.ContactStore
 import ch.threema.domain.stores.IdentityStoreInterface
 
+@JvmName("toCspMessageJava")
 fun AbstractMessage.toCspMessage(
     identityStore: IdentityStoreInterface,
     contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    nonce: ByteArray,
+    nonce: Nonce,
 ): CspMessage {
     // Add missing attributes, if necessary
     if (fromIdentity == null) {
@@ -43,7 +43,7 @@ fun AbstractMessage.toCspMessage(
 
     // Make box
     val messageCoder = MessageCoder(contactStore, identityStore)
-    val messageBox = messageCoder.encode(this, nonce, nonceFactory)
+    val messageBox = messageCoder.encode(this, nonce.bytes)
 
     // For the sake of efficiency: simply deduct overhead size
     val overhead = (ProtocolDefines.OVERHEAD_MSG_HDR
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt
index 881438c9..8589e555 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt
@@ -56,13 +56,6 @@ interface TaskManager {
      */
     fun hasPendingTasks(): Boolean
 
-    // This is only used for the migration phase until we fully use the task manager
-    @Deprecated(
-        "We should only be able to send and receive messages from within tasks.",
-        ReplaceWith("TaskManager#schedule")
-    )
-    fun getMigrationTaskHandle(): ActiveTaskCodec
-
     /**
      * Add a queue send complete listener.
      */
@@ -126,12 +119,6 @@ internal class TaskManagerImpl(
         TaskRunner(dispatchers, taskQueue)
     }
 
-    @Deprecated(
-        "We should only be able to send and receive messages from within tasks.",
-        replaceWith = ReplaceWith("TaskManager#schedule")
-    )
-    override fun getMigrationTaskHandle(): ActiveTaskCodec = taskRunner.value.getTaskCodec()
-
     override suspend fun startRunningTasks(
         layer5Codec: Layer5Codec,
         incomingMessageProcessor: IncomingMessageProcessor,
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt
index 99d207d0..207dce34 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt
@@ -21,10 +21,14 @@
 
 package ch.threema.domain.taskmanager
 
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceScope
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.connection.data.InboundMessage
+import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
 import ch.threema.domain.protocol.connection.data.OutboundMessage
 import ch.threema.domain.protocol.connection.layer.Layer5Codec
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
 import kotlinx.coroutines.CancellationException
 import kotlinx.coroutines.CoroutineExceptionHandler
 import kotlinx.coroutines.CoroutineScope
@@ -66,11 +70,13 @@ internal class TaskRunner(
      * The task handle that allows tasks to receive and send messages.
      */
     private val taskCodec = object : TaskCodec {
+        private val reflectIdManager = ReflectIdManager()
+
         override suspend fun read(
             preProcess: (InboundMessage) -> MessageFilterInstruction,
         ): InboundMessage {
             val (bypassMessages, inboundMessage) = taskQueue.readMessage(preProcess)
-            // TODO(ANDR-2475): Carefully handle exceptions here. Note that these should be logged.
+            // TODO(ANDR-2706): Carefully handle exceptions here. Note that these should be logged.
             bypassMessages.forEach { it.run(this) }
             return inboundMessage
         }
@@ -79,8 +85,41 @@ internal class TaskRunner(
             layer5Codec?.sendOutbound(message) ?: awaitCancellation()
         }
 
-        override suspend fun reflect(message: OutboundMessage) {
-            // TODO(ANDR-2475)
+        override suspend fun reflectAndAwaitAck(
+            encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult,
+            storeD2dNonce: Boolean,
+            nonceFactory: NonceFactory
+        ): ULong {
+            val reflectId: UInt = reflect(encryptedEnvelopeResult)
+            return awaitReflectAck(reflectId).also {
+                if (storeD2dNonce) {
+                    nonceFactory.store(NonceScope.D2D, encryptedEnvelopeResult.nonce)
+                }
+            }
+        }
+
+        override suspend fun reflect(encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult): UInt {
+            val flags: UShort = 0u
+            val reflectId: UInt = reflectIdManager.next()
+            val reflect: OutboundD2mMessage.Reflect = OutboundD2mMessage.Reflect(flags, reflectId, encryptedEnvelopeResult.encryptedEnvelope)
+            logReflect(debugInfo = encryptedEnvelopeResult.debugInfo, reflectId = reflectId, flags = flags)
+            write(reflect)
+            return reflectId
+        }
+
+        private fun logReflect(
+            debugInfo: MultiDeviceKeys.EncryptedEnvelopeResult.DebugInfo,
+            reflectId: UInt,
+            flags: UShort
+        ) {
+            logger.run {
+                info("--> SENDING outbound D2D reflect message ${debugInfo.protoContentCaseName}")
+                debug("--> SEND outbound D2D reflect message")
+                debug("Id: {}", reflectId)
+                debug("Flags: {}", flags)
+                debug("Envelope: {}", debugInfo.rawEnvelopeContent)
+                debug("--> END SEND")
+            }
         }
     }
 
@@ -172,9 +211,6 @@ internal class TaskRunner(
         executorSemaphore.release()
     }
 
-    @Deprecated("Do not use the task codec outside of a task")
-    internal fun getTaskCodec(): TaskCodec = taskCodec
-
     /**
      * Send an outbound message immediately. This method must only be used by the task manager to
      * send messages that are required to be sent outside of a task. This functionality must not be
@@ -347,7 +383,11 @@ enum class MessageFilterInstruction {
     ACCEPT,
 
     /**
-     * Reject the message. TODO(ANDR-2475): handle this correctly
+     * Reject the message. TODO(ANDR-2868): handle this correctly
+     *
+     * This instruction is used when a message is received which is not expected at this moment and
+     * violates the protocol. The message must be dropped and an exception should be raised in the
+     * task manager and trigger a reconnect.
      */
     REJECT,
 }
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TriggerSource.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TriggerSource.kt
new file mode 100644
index 00000000..c645f388
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/TriggerSource.kt
@@ -0,0 +1,48 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.taskmanager
+
+enum class TriggerSource {
+
+    /**
+     * An update triggered by synchronisation from another device.
+     *
+     * This should never trigger further messages to other devices.
+     */
+    SYNC,
+
+    /**
+     * An update triggered locally, e.g. by a user interaction.
+     *
+     * This will always trigger messages to other devices.
+     */
+    LOCAL,
+
+    /**
+     * An update triggered remotely, e.g. by an incoming message.
+     *
+     * The task that was triggered by the remote message will take care of reflection, but further
+     * side effects (e.g. implicit contact creation) will need to be reflected separately.
+     */
+    REMOTE,
+
+}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/codec.kt b/domain/src/main/java/ch/threema/domain/taskmanager/codec.kt
index 4e649225..0913701c 100644
--- a/domain/src/main/java/ch/threema/domain/taskmanager/codec.kt
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/codec.kt
@@ -21,12 +21,22 @@
 
 package ch.threema.domain.taskmanager
 
+import ch.threema.base.ThreemaException
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceFactory
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.D2mPayloadType
 import ch.threema.domain.protocol.connection.data.CspMessage
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
 import ch.threema.domain.protocol.connection.data.InboundMessage
+import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
 import ch.threema.domain.protocol.connection.data.OutboundMessage
 import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
+import ch.threema.domain.taskmanager.MessageFilterInstruction.ACCEPT
+import ch.threema.domain.taskmanager.MessageFilterInstruction.BYPASS_OR_BACKLOG
+import ch.threema.protobuf.d2d.MdD2D.TransactionScope.Scope
 
 /**
  * A passive task codec is used to retrieve messages from the server. To send messages we need an
@@ -57,40 +67,178 @@ sealed interface ActiveTaskCodec : PassiveTaskCodec {
     suspend fun write(message: OutboundMessage)
 
     /**
-     * Reflect the given message.
+     * Reflect the given message. Returns the timestamp of the reflect ack.
      */
-    suspend fun reflect(message: OutboundMessage)
+    // TODO(ANDR-2983): Adapt storing of d2d nonces to protocol
+    suspend fun reflectAndAwaitAck(
+        encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult,
+        storeD2dNonce: Boolean,
+        nonceFactory: NonceFactory
+    ): ULong
+
+    /**
+     * Reflect the given message. Returns the used reflect id.
+     */
+    suspend fun reflect(encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult): UInt
 }
 
 interface TaskCodec : ActiveTaskCodec
 
 private val logger = LoggingUtil.getThreemaLogger("TaskCodec")
 
-suspend fun PassiveTaskCodec.waitForServerAck(
-    messageId: MessageId,
-    recipientIdentity: String,
-) {
+suspend fun PassiveTaskCodec.awaitOutgoingMessageAck(messageId: MessageId, identity: String) {
     read { inboundMessage ->
+        // If the inbound message is not a csp message, we bypass it
+        if (inboundMessage !is CspMessage) {
+            return@read BYPASS_OR_BACKLOG
+        }
+
         return@read when (inboundMessage.payloadType.toInt()) {
             ProtocolDefines.PLTYPE_OUTGOING_MESSAGE_ACK -> {
-                val ack = (inboundMessage as CspMessage).toOutgoingMessageAck()
+                val ack = inboundMessage.toOutgoingMessageAck()
 
-                logger.debug(
-                    "Checking message ack for message {} to {}",
-                    ack.messageId,
-                    ack.recipient
-                )
+                if (ack.messageId == messageId && ack.recipient == identity) {
+                    ACCEPT
+                } else {
+                    BYPASS_OR_BACKLOG
+                }
+            }
 
-                if (ack.messageId == messageId && ack.recipient == recipientIdentity) {
-                    MessageFilterInstruction.ACCEPT
+            else -> {
+                BYPASS_OR_BACKLOG
+            }
+        }
+    }
+}
+
+suspend fun PassiveTaskCodec.awaitReflectAck(reflectId: UInt): ULong {
+    val acceptedMessage = read { inboundMessage ->
+        // If the inbound message is not a d2m message, we backlog it
+        if (inboundMessage !is InboundD2mMessage) {
+            return@read BYPASS_OR_BACKLOG
+        }
+
+        return@read when (inboundMessage.payloadType) {
+            D2mPayloadType.REFLECT_ACK -> {
+                val ack = inboundMessage as InboundD2mMessage.ReflectAck
+                if (ack.reflectId == reflectId) {
+                    ACCEPT
                 } else {
-                    MessageFilterInstruction.BYPASS_OR_BACKLOG
+                    BYPASS_OR_BACKLOG
                 }
             }
 
             else -> {
-                MessageFilterInstruction.BYPASS_OR_BACKLOG
+                BYPASS_OR_BACKLOG
+            }
+        }
+    }
+    return (acceptedMessage as InboundD2mMessage.ReflectAck).timestamp
+}
+
+private val transactionLogger = LoggingUtil.getThreemaLogger("ActiveTaskCodec")
+
+/**
+ * Use the maximum time to live for this transaction. The maximum time is used, when the value 0 is
+ * used as ttl.
+ */
+const val TRANSACTION_TTL_MAX: UInt = 0u
+
+fun ActiveTaskCodec.createTransaction(
+    keys: MultiDeviceKeys,
+    scope: Scope,
+    ttl: UInt,
+    precondition: (suspend () -> Boolean)? = null
+): TransactionScope {
+    logger.trace("Create transaction (scope={}, ttl={})", scope, ttl)
+    return TransactionScope(this, keys, scope, ttl, precondition)
+}
+
+class TransactionScope(
+    private val codec: ActiveTaskCodec,
+    private val keys: MultiDeviceKeys,
+    private val scope: Scope,
+    private val ttl: UInt,
+    private val precondition: (suspend () -> Boolean)?
+) {
+    class TransactionException(msg: String) : ThreemaException(msg)
+
+    /**
+     * Execute the provided block within a transaction.
+     *
+     * If another transaction is currently running, this method will suspend, until it was possible to
+     * create a transaction and run the provided block.
+     *
+     * If a precondition is provided but not met a [TransactionException] will be thrown. If the [block]
+     * throws an exception when executed, this exception will also be thrown by this method.
+     *
+     * @throws [TransactionException] if something related to the transaction failed (e.g. precondition was not met)
+     */
+    suspend fun <R> execute(block: suspend () -> R): R {
+        logger.trace("Execute transaction (hasPrecondition={})", precondition != null)
+        assertPrecondition()
+        codec.startTransaction(keys, scope, ttl)
+        return try {
+            assertPrecondition()
+            block.invoke()
+        } finally {
+            codec.commitTransaction()
+        }
+    }
+
+    private suspend fun assertPrecondition() {
+        if (precondition?.invoke() == false) {
+            throw TransactionException("Precondition failed")
+        }
+    }
+
+    private suspend fun ActiveTaskCodec.startTransaction(keys: MultiDeviceKeys, scope: Scope, ttl: UInt) {
+        transactionLogger.trace("Start transaction (scope={}, ttl={})", scope, ttl)
+        // TODO(ANDR-2699) Beware that scope USER_SYNC_SCOPE will not be encrypted correctly
+        val encryptedScope = keys.encryptTransactionScope(scope)
+
+        do {
+            write(OutboundD2mMessage.BeginTransaction(encryptedScope, ttl))
+
+            val message = read {
+                when (it) {
+                    is InboundD2mMessage.BeginTransactionAck -> ACCEPT
+                    is InboundD2mMessage.TransactionRejected -> ACCEPT
+                    else -> BYPASS_OR_BACKLOG
+                }
+            }
+
+            if (message is InboundD2mMessage.TransactionRejected) {
+                if (transactionLogger.isTraceEnabled) {
+                    val decryptedScope = keys.decryptTransactionScope(message.encryptedScope)
+                    transactionLogger.trace(
+                        "Transaction rejected (deviceId={}, scope={}). Wait for ongoing transaction to end",
+                        message.deviceId,
+                        decryptedScope
+                    )
+                }
+                read {
+                    when (it) {
+                        is InboundD2mMessage.TransactionEnded -> ACCEPT
+                        else -> BYPASS_OR_BACKLOG
+                    }
+                }
+            }
+        } while (message !is InboundD2mMessage.BeginTransactionAck)
+        transactionLogger.trace("Transaction started")
+    }
+
+    private suspend fun ActiveTaskCodec.commitTransaction() {
+        transactionLogger.trace("Commit transaction")
+        write(OutboundD2mMessage.CommitTransaction())
+
+        read {
+            if (it is InboundD2mMessage.CommitTransactionAck) {
+                ACCEPT
+            } else {
+                BYPASS_OR_BACKLOG
             }
         }
+        transactionLogger.trace("Transaction committed")
     }
 }
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/reflect.kt b/domain/src/main/java/ch/threema/domain/taskmanager/reflect.kt
new file mode 100644
index 00000000..3c2cc71c
--- /dev/null
+++ b/domain/src/main/java/ch/threema/domain/taskmanager/reflect.kt
@@ -0,0 +1,247 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.taskmanager
+
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.utils.SecureRandomUtil
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.connection.data.DeviceId
+import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
+import ch.threema.domain.protocol.multidevice.MultiDeviceProperties
+import ch.threema.protobuf.Common.GroupIdentity
+import ch.threema.protobuf.d2d.ContactSyncKt
+import ch.threema.protobuf.d2d.MdD2D
+import ch.threema.protobuf.d2d.MdD2D.ConversationId
+import ch.threema.protobuf.d2d.UserProfileSyncKt
+import ch.threema.protobuf.d2d.contactSync
+import ch.threema.protobuf.d2d.conversationId
+import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact
+import ch.threema.protobuf.d2d.sync.MdD2DSync.UserProfile
+import ch.threema.protobuf.d2d.userProfileSync
+import ch.threema.protobuf.groupIdentity
+import com.google.protobuf.ByteString
+import com.google.protobuf.kotlin.toByteString
+
+class ReflectIdManager {
+    private var counter: UInt = 0u
+
+    fun next() = counter++
+}
+
+fun getEncryptedIncomingMessageEnvelope(
+    message: AbstractMessage,
+    nonce: ByteArray,
+    mediatorDeviceId: DeviceId,
+    multiDeviceKeys: MultiDeviceKeys,
+): MultiDeviceKeys.EncryptedEnvelopeResult? {
+    val messageBody = message.body ?: return null
+    val envelope = buildEnvelopeFor(mediatorDeviceId) {
+        setIncomingMessage(
+            MdD2D.IncomingMessage.newBuilder()
+                .setSenderIdentity(message.fromIdentity)
+                .setMessageId(message.messageId.messageIdLong)
+                .setCreatedAt(message.date.time)
+                .setTypeValue(message.type)
+                .setBody(messageBody.toByteString())
+                .setNonce(nonce.toByteString())
+        )
+    }
+    return multiDeviceKeys.encryptEnvelope(envelope)
+}
+
+fun getEncryptedOutgoingMessageEnvelope(
+    message: AbstractMessage,
+    nonces: Collection<Nonce>,
+    mediatorDeviceId: DeviceId,
+    multiDeviceKeys: MultiDeviceKeys,
+): MultiDeviceKeys.EncryptedEnvelopeResult? {
+    val messageBody = message.body ?: return null
+    val envelope = buildEnvelopeFor(mediatorDeviceId) {
+        setOutgoingMessage(
+            MdD2D.OutgoingMessage.newBuilder()
+                .setConversation(getConversation(message))
+                .setMessageId(message.messageId.messageIdLong)
+                .setCreatedAt(message.date.time)
+                .setTypeValue(message.type)
+                .setBody(messageBody.toByteString())
+                .addAllNonces(nonces.map { it.bytes.toByteString() })
+        )
+    }
+    return multiDeviceKeys.encryptEnvelope(envelope)
+}
+
+fun getEncryptedOutgoingMessageUpdateSentEnvelope(
+    message: AbstractMessage,
+    mediatorDeviceId: DeviceId,
+    multiDeviceKeys: MultiDeviceKeys,
+): MultiDeviceKeys.EncryptedEnvelopeResult {
+    val envelope = buildEnvelopeFor(mediatorDeviceId) {
+        setOutgoingMessageUpdate(
+            MdD2D.OutgoingMessageUpdate.newBuilder()
+                .addUpdates(
+                    MdD2D.OutgoingMessageUpdate.Update.newBuilder()
+                        .setConversation(getConversation(message))
+                        .setMessageId(message.messageId.messageIdLong)
+                        .setSent(MdD2D.OutgoingMessageUpdate.Sent.newBuilder())
+                )
+        )
+    }
+    return multiDeviceKeys.encryptEnvelope(envelope)
+}
+
+fun getEncryptedIncomingContactMessageUpdateReadEnvelope(
+    messageIds: Set<MessageId>,
+    timestamp: Long,
+    senderIdentity: String,
+    mediatorDeviceId: DeviceId,
+    multiDeviceKeys: MultiDeviceKeys,
+): MultiDeviceKeys.EncryptedEnvelopeResult {
+    return getEncryptedIncomingMessageUpdateReadEnvelope(
+        messageIds,
+        timestamp,
+        conversationId { contact = senderIdentity },
+        mediatorDeviceId,
+        multiDeviceKeys,
+    )
+}
+
+fun getEncryptedIncomingGroupMessageUpdateReadEnvelope(
+    messageIds: Set<MessageId>,
+    timestamp: Long,
+    creatorIdentity: String,
+    groupId: GroupId,
+    mediatorDeviceId: DeviceId,
+    multiDeviceKeys: MultiDeviceKeys,
+): MultiDeviceKeys.EncryptedEnvelopeResult {
+    return getEncryptedIncomingMessageUpdateReadEnvelope(
+        messageIds,
+        timestamp,
+        conversationId {
+            group = groupIdentity {
+                this.creatorIdentity = creatorIdentity
+                this.groupId = groupId.toLong()
+            }
+        },
+        mediatorDeviceId,
+        multiDeviceKeys,
+    )
+}
+
+private fun getEncryptedIncomingMessageUpdateReadEnvelope(
+    messageIds: Set<MessageId>,
+    timestamp: Long,
+    conversation: ConversationId,
+    mediatorDeviceId: DeviceId,
+    multiDeviceKeys: MultiDeviceKeys,
+): MultiDeviceKeys.EncryptedEnvelopeResult {
+    val envelope = buildEnvelopeFor(mediatorDeviceId) {
+        setIncomingMessageUpdate(
+            MdD2D.IncomingMessageUpdate.newBuilder()
+                .addAllUpdates(messageIds.map {
+                    MdD2D.IncomingMessageUpdate.Update.newBuilder()
+                        .setMessageId(it.messageIdLong)
+                        .setConversation(conversation)
+                        .setRead(
+                            MdD2D.IncomingMessageUpdate.Read.newBuilder().setAt(timestamp).build()
+                        )
+                        .build()
+                })
+        )
+    }
+    return multiDeviceKeys.encryptEnvelope(envelope)
+}
+
+fun getEncryptedContactSyncCreate(
+    contact: Contact,
+    multiDeviceProperties: MultiDeviceProperties,
+): MultiDeviceKeys.EncryptedEnvelopeResult {
+    val envelope = buildEnvelopeFor(multiDeviceProperties.mediatorDeviceId) {
+        setContactSync(
+            contactSync {
+                create = ContactSyncKt.create {
+                    this.contact = contact
+                }
+            }
+        )
+    }
+    return multiDeviceProperties.keys.encryptEnvelope(envelope)
+}
+
+fun getEncryptedContactSyncUpdate(
+    contact: Contact,
+    multiDeviceProperties: MultiDeviceProperties,
+): MultiDeviceKeys.EncryptedEnvelopeResult {
+    val envelope = buildEnvelopeFor(multiDeviceProperties.mediatorDeviceId) {
+        setContactSync(
+            contactSync {
+                update = ContactSyncKt.update {
+                    this.contact = contact
+                }
+            }
+        )
+    }
+    return multiDeviceProperties.keys.encryptEnvelope(envelope)
+}
+
+fun getEncryptedUserProfileSyncUpdate(
+    userProfile: UserProfile,
+    multiDeviceProperties: MultiDeviceProperties,
+): MultiDeviceKeys.EncryptedEnvelopeResult {
+    val envelope: MdD2D.Envelope = buildEnvelopeFor(multiDeviceProperties.mediatorDeviceId) {
+        setUserProfileSync(
+            userProfileSync {
+                update = UserProfileSyncKt.update {
+                    this.userProfile = userProfile
+                }
+            }
+        )
+    }
+    return multiDeviceProperties.keys.encryptEnvelope(envelope)
+}
+
+private fun buildEnvelopeFor(
+    mediatorDeviceId: DeviceId,
+    buildBody: MdD2D.Envelope.Builder.() -> Unit
+): MdD2D.Envelope =
+    MdD2D.Envelope.newBuilder()
+        .setPadding(SecureRandomUtil.generateRandomProtobufPadding())
+        .setDeviceId(mediatorDeviceId.id.toLong())
+        .apply { buildBody() }
+        .build()
+
+private fun getConversation(message: AbstractMessage): ConversationId {
+    val conversationId = ConversationId.newBuilder()
+    when (message) {
+        is AbstractGroupMessage ->
+            conversationId.setGroup(
+                GroupIdentity.newBuilder()
+                    .setCreatorIdentity(message.groupCreator)
+                    .setGroupId(message.apiGroupId.toLong())
+            )
+
+        else -> conversationId.contact = message.toIdentity
+    }
+    return conversationId.build()
+}
diff --git a/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.java b/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.java
deleted file mode 100644
index aafa51bd..00000000
--- a/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.crypto;
-import static org.mockito.Mockito.*;
-
-import ch.threema.base.ThreemaException;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.security.SecureRandom;
-
-public class NonceFactoryTest {
-
-	// Hack to "Mock" the Secure Random
-	private class SecureRandomMocken extends SecureRandom {
-		private byte[][] next;
-		private int nextPos = 0;
-
-		public void nextNonces(byte[]... next) {
-			this.next = next;
-		}
-
-		@Override
-		public void nextBytes(byte[] bytes) {
-			// Check length
-			Assert.assertEquals(bytes.length, 24);
-
-			if (this.next != null && this.nextPos < this.next.length) {
-				for(int n = 0; n < bytes.length; n++) {
-					bytes[n] = this.next[this.nextPos][n];
-				}
-				this.nextPos++;
-				return;
-			}
-
-			super.nextBytes(bytes);
-		}
-	}
-
-	@Test
-	public void testNext() throws Exception {
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-		SecureRandomMocken secureRandomMock = new SecureRandomMocken();
-
-		// Store always return true
-		when(nonceStoreMock.store(any())).thenReturn(true);
-
-		NonceFactory factory = new NonceFactory(secureRandomMock, nonceStoreMock);
-		byte[] result = factory.next();
-
-		// Check if store is called
-		verify(nonceStoreMock, times(1)).store(any());
-
-		// Verify the result
-		Assert.assertEquals(24, result.length);
-	}
-
-	@Test
-	public void testNext2Times() throws Exception {
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-		SecureRandomMocken secureRandomMock = new SecureRandomMocken();
-
-		byte[] existingNonce = new byte[]{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01};
-
-		byte[] newNonce = new byte[]{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x02};
-
-		// Store always return true
-		when(nonceStoreMock.store(eq(existingNonce))).thenReturn(false);
-		when(nonceStoreMock.store(eq(newNonce))).thenReturn(true);
-
-		NonceFactory factory = new NonceFactory(secureRandomMock, nonceStoreMock);
-		secureRandomMock.nextNonces(existingNonce, newNonce);
-		byte[] result = factory.next();
-
-		// Check if store is called twice
-		verify(nonceStoreMock, times(2)).store(any());
-
-		// Verify the result
-		Assert.assertEquals(24, result.length);
-	}
-
-	@Test
-	public void testNextWithoutStore() throws Exception {
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-
-		NonceFactory factory = new NonceFactory(new SecureRandom(), nonceStoreMock);
-		factory.next(false);
-
-		verify(nonceStoreMock, never()).store(any());
-	}
-
-	@Test
-	public void textNextWithoutStore() throws Exception {
-		byte[] existingNonce = new byte[]{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01};
-
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-		when(nonceStoreMock.exists(eq(existingNonce))).thenReturn(true);
-		NonceFactory factory = new NonceFactory(new SecureRandom(), nonceStoreMock);
-		Assert.assertTrue(factory.exists(existingNonce));
-
-
-		when(nonceStoreMock.exists(eq(existingNonce))).thenReturn(false);
-		Assert.assertFalse(factory.exists(existingNonce));
-	}
-
-}
diff --git a/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.kt b/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.kt
new file mode 100644
index 00000000..7e2e5404
--- /dev/null
+++ b/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.kt
@@ -0,0 +1,140 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.base.crypto
+
+import android.annotation.SuppressLint
+import ch.threema.base.utils.SecureRandomUtil.generateRandomBytes
+import org.junit.Assert
+import org.junit.Test
+import org.mockito.Mockito
+import org.mockito.invocation.InvocationOnMock
+import java.util.LinkedList
+
+class NonceFactoryTest {
+    @Test
+    fun testNext() {
+        val nonceStoreMock = Mockito.mock(NonceStore::class.java)
+
+        // Store always return true
+        Mockito.`when`(nonceStoreMock.store(anyScope(), anyNonce())).thenReturn(true)
+        val factory = NonceFactory(nonceStoreMock)
+        val result: Nonce = factory.next(NonceScope.CSP)
+
+        // Check if uniqueness is verified
+        Mockito.verify(nonceStoreMock, Mockito.times(1)).exists(anyScope(), anyNonce())
+
+        // Verify the result
+        Assert.assertEquals(24, result.bytes.size)
+    }
+
+    @Test
+    fun testNext2Times() {
+        val nonceProvider = TestNonceProvider()
+        val existingNonce = byteArrayOf(0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01)
+        val newNonce = byteArrayOf(0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x02)
+
+        nonceProvider.addNextNonces(listOf(existingNonce, newNonce))
+
+        val nonceStoreMock = Mockito.mock(NonceStore::class.java)
+        Mockito.`when`(nonceStoreMock.exists(anyScope(), anyNonce())).thenAnswer { invocation: InvocationOnMock ->
+            val nonce = invocation.getArgument(1, ByteArray::class.java)
+            nonce.contentEquals(existingNonce)
+        }
+
+        val factory = NonceFactory(nonceStoreMock, nonceProvider)
+        val result: Nonce = factory.next(NonceScope.CSP)
+
+        // Check if uniqueness is verified twice (because the first nonce already existed)
+        Mockito.verify(nonceStoreMock, Mockito.times(2)).exists(anyScope(), anyNonce())
+
+        // Verify the result
+        Assert.assertEquals(24, result.bytes.size)
+    }
+
+    @Test
+    fun testNextDoesNotStoreNonce() {
+        val nonceStoreMock = Mockito.mock(NonceStore::class.java)
+
+        val factory = NonceFactory(nonceStoreMock)
+        factory.next(NonceScope.CSP)
+
+        Mockito.verify(nonceStoreMock, Mockito.never()).store(anyScope(), anyNonce())
+    }
+
+    @Test
+    fun testExistsReturnsValueReturnedByNonceStore() {
+        val existingNonce = Nonce(byteArrayOf(0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+            0x01, 0x01, 0x01, 0x01))
+
+        val nonceStoreMock = Mockito.mock(NonceStore::class.java)
+
+        Mockito.`when`(nonceStoreMock.exists(anyScope(), anyNonce())).thenAnswer { invocation: InvocationOnMock ->
+            val nonce = invocation.getArgument(1, ByteArray::class.java)
+            nonce.contentEquals(existingNonce.bytes)
+        }
+
+        val factory = NonceFactory(nonceStoreMock)
+        Assert.assertTrue(factory.exists(NonceScope.CSP, existingNonce))
+
+        Mockito.`when`(nonceStoreMock.exists(anyScope(), anyNonce())).thenAnswer { invocation: InvocationOnMock ->
+            val nonce = invocation.getArgument(1, ByteArray::class.java)
+            !nonce.contentEquals(existingNonce.bytes)
+        }
+
+        Assert.assertFalse(factory.exists(NonceScope.CSP, existingNonce))
+    }
+}
+
+@SuppressLint("CheckResult")
+private fun anyScope(): NonceScope {
+    Mockito.any<NonceScope>()
+    return NonceScope.CSP
+}
+
+@SuppressLint("CheckResult")
+private fun anyNonce(): Nonce {
+    Mockito.any<Nonce>()
+    return Nonce(byteArrayOf())
+}
+
+private class TestNonceProvider : NonceFactoryNonceBytesProvider {
+    private val nextNonces = LinkedList<ByteArray>()
+    fun addNextNonces(nonces: List<ByteArray>) {
+        nextNonces.addAll(nonces)
+    }
+
+    override fun next(length: Int): ByteArray {
+        // Check length
+        Assert.assertEquals(24, length.toLong())
+        val nonce: ByteArray? = nextNonces.pollFirst()
+        if (nonce != null) {
+            Assert.assertEquals(24, nonce.size.toLong())
+        }
+        return nonce ?: generateRandomBytes(length)
+    }
+}
+
diff --git a/domain/src/test/java/ch/threema/base/utils/Base64UrlSafeTest.kt b/domain/src/test/java/ch/threema/base/utils/Base64UrlSafeTest.kt
new file mode 100644
index 00000000..fd1a1340
--- /dev/null
+++ b/domain/src/test/java/ch/threema/base/utils/Base64UrlSafeTest.kt
@@ -0,0 +1,50 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.base.utils
+
+import org.junit.Assert.*
+import org.junit.Test
+
+class Base64UrlSafeTest {
+    // encodes to
+    // 000000 ('A') 111110 ('-') 000001 ('B') 111111 ('_') 011110 ('e') 000000 ('A')
+    private val decoded = byteArrayOf(0b00000011, 0b11100000.toByte(), 0b01111111, 0b01111000)
+
+    // decodes to
+    // 00000011 11100000 01111111 01111000 0000 (where the last `0000` is discarded)
+    private val encoded = "A-B_eA" // "A+B/eA" in base64 encoding
+
+    @Test
+    fun testEncode() {
+        assertEquals(encoded, Base64UrlSafe.encode(decoded))
+    }
+
+    @Test
+    fun testDecode() {
+        assertArrayEquals(decoded, Base64UrlSafe.decode(encoded))
+    }
+
+    @Test
+    fun testDecodePadded() {
+        assertArrayEquals(decoded, Base64UrlSafe.decode("$encoded=="))
+    }
+}
diff --git a/domain/src/test/java/ch/threema/base/utils/ByteArrayUtilsKtTest.kt b/domain/src/test/java/ch/threema/base/utils/ByteArrayUtilsKtTest.kt
new file mode 100644
index 00000000..405894ad
--- /dev/null
+++ b/domain/src/test/java/ch/threema/base/utils/ByteArrayUtilsKtTest.kt
@@ -0,0 +1,62 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.base.utils
+
+import org.junit.Assert.*
+import org.junit.Test
+
+class ByteArrayUtilsKtTest {
+    @Test
+    fun testChunkedEmptyArray() {
+        assertTrue(byteArrayOf().chunked(1).isEmpty())
+    }
+
+    @Test
+    fun testChunkedEqualParts() {
+        val chunks = byteArrayOf(1, 2, 3, 4, 5, 6).chunked(3)
+
+        assertEquals(2, chunks.size)
+        assertArrayEquals(byteArrayOf(1, 2, 3), chunks[0])
+        assertArrayEquals(byteArrayOf(4, 5, 6), chunks[1])
+    }
+
+    @Test
+    fun testChunkedWithDifferentSizedParts() {
+        val a = byteArrayOf(1).chunked(3)
+        assertEquals(1, a.size)
+        assertArrayEquals(byteArrayOf(1), a[0])
+
+        val b = byteArrayOf(1, 2).chunked(3)
+        assertEquals(1, b.size)
+        assertArrayEquals(byteArrayOf(1, 2), b[0])
+
+        val c = byteArrayOf(1, 2, 3, 4).chunked(3)
+        assertEquals(2, c.size)
+        assertArrayEquals(byteArrayOf(1, 2, 3), c[0])
+        assertArrayEquals(byteArrayOf(4), c[1])
+
+        val d = byteArrayOf(1, 2, 3, 4, 5).chunked(3)
+        assertEquals(2, d.size)
+        assertArrayEquals(byteArrayOf(1, 2, 3), d[0])
+        assertArrayEquals(byteArrayOf(4, 5), d[1])
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt b/domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt
index efe7d263..7f34546b 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt
+++ b/domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt
@@ -24,10 +24,12 @@ package ch.threema.domain.protocol.connection
 import ch.threema.domain.protocol.ServerAddressProvider
 import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
 import ch.threema.domain.protocol.connection.csp.socket.ChatServerAddressProvider
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
 import ch.threema.domain.protocol.connection.data.CspMessage
 import ch.threema.domain.protocol.connection.data.OutboundMessage
 import ch.threema.domain.protocol.csp.coders.MessageBox
 import ch.threema.domain.stores.IdentityStoreInterface
+import ch.threema.testhelpers.MUST_NOT_BE_CALLED
 import com.neilalexander.jnacl.NaCl
 import java.io.InputStream
 import java.io.OutputStream
@@ -79,6 +81,7 @@ internal class TestIdentityStore : IdentityStoreInterface {
         MUST_NOT_BE_CALLED()
     }
 }
+
 internal class TestServerAddressProvider(
     private val skPublic: ByteArray,
     private val skPublicAlt: ByteArray,
@@ -116,9 +119,14 @@ internal class TestServerAddressProvider(
     // The following methods should not be used by the connection
     override fun getDirectoryServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
     override fun getWorkServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getBlobServerDownloadUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getBlobServerDoneUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getBlobServerUploadUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
+    override fun getBlobBaseUrlMirrorServer(multiDevicePropertyProvider: MultiDevicePropertyProvider): String { MUST_NOT_BE_CALLED() }
+    override fun getBlobServerDownloadUrl(useIpV6: Boolean, blobId: ByteArray): String { MUST_NOT_BE_CALLED() }
+    override fun getBlobServerUploadUrl(useIpV6: Boolean): String { MUST_NOT_BE_CALLED() }
+    override fun getBlobServerDoneUrl(useIpV6: Boolean, blobId: ByteArray): String { MUST_NOT_BE_CALLED() }
+    override fun getBlobMirrorServerDownloadUrl(multiDevicePropertyProvider: MultiDevicePropertyProvider, blobId: ByteArray): String { MUST_NOT_BE_CALLED() }
+    override fun getBlobMirrorServerUploadUrl(multiDevicePropertyProvider: MultiDevicePropertyProvider): String { MUST_NOT_BE_CALLED() }
+    override fun getBlobMirrorServerDoneUrl(multiDevicePropertyProvider: MultiDevicePropertyProvider, blobId: ByteArray): String { MUST_NOT_BE_CALLED() }
+
     override fun getAvatarServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
     override fun getSafeServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
     override fun getWebServerUrl(): String { MUST_NOT_BE_CALLED() }
@@ -189,11 +197,6 @@ internal class TestNoopDeviceCookieManager : DeviceCookieManager {
     override fun deleteDeviceCookie() { MUST_NOT_BE_CALLED() }
 }
 
-@Suppress("TestFunctionName")
-internal fun MUST_NOT_BE_CALLED(): Nothing {
-    throw UnsupportedOperationException("This method must not be called")
-}
-
 fun getFromOutboundMessage(message: OutboundMessage): MessageBox? {
     return try {
         val cspMessage = message as CspMessage
diff --git a/domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt b/domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt
index a60486b3..e2101dba 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt
+++ b/domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt
@@ -48,6 +48,7 @@ import ch.threema.domain.taskmanager.TaskManager
 import ch.threema.domain.taskmanager.TaskManagerConfiguration
 import ch.threema.domain.taskmanager.TaskManagerProvider
 import ch.threema.domain.helpers.UnusedTaskCodec
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
 import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.Deferred
 
@@ -70,12 +71,6 @@ internal class CspConnectionTest : ServerConnectionTest() {
 
             override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> = CompletableDeferred()
 
-            @Deprecated(
-                "We should only be able to send and receive messages from within tasks.",
-                replaceWith = ReplaceWith("TaskManager#schedule")
-            )
-            override fun getMigrationTaskHandle(): ActiveTaskCodec = UnusedTaskCodec()
-
             override fun hasPendingTasks(): Boolean = false
 
             override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
@@ -109,7 +104,8 @@ internal class CspConnectionTest : ServerConnectionTest() {
 
     private fun createConfiguration(): CspConnectionConfiguration {
         val incomingMessageProcessor = object : IncomingMessageProcessor {
-            override suspend fun processIncomingMessage(messageBox: MessageBox, handle: ActiveTaskCodec) { }
+            override suspend fun processIncomingCspMessage(messageBox: MessageBox, handle: ActiveTaskCodec) { }
+            override suspend fun processIncomingD2mMessage(message: InboundD2mMessage.Reflected, handle: ActiveTaskCodec) {}
             override fun processIncomingServerAlert(alertData: CspMessage.ServerAlertData) { }
             override fun processIncomingServerError(errorData: CspMessage.ServerErrorData) { }
         }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java
index c8850437..cb7e0878 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java
@@ -21,30 +21,96 @@
 
 package ch.threema.domain.protocol.csp.coders;
 
+import com.neilalexander.jnacl.NaCl;
+
+import androidx.annotation.NonNull;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
+import ch.threema.domain.helpers.InMemoryContactStore;
+import ch.threema.domain.helpers.InMemoryIdentityStore;
+import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.GroupId;
+import ch.threema.domain.models.MessageId;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.messages.AbstractMessage;
+import ch.threema.domain.protocol.csp.messages.BadMessageException;
+import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage;
+import ch.threema.domain.protocol.csp.messages.GroupTextMessage;
+import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
+import ch.threema.domain.protocol.csp.messages.TextMessage;
+import ch.threema.domain.stores.ContactStore;
+import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.domain.testhelpers.TestHelpers;
 import ch.threema.domain.protocol.csp.messages.voip.*;
+
 import org.junit.Assert;
 import org.junit.Test;
 
+import static ch.threema.domain.testhelpers.TestHelpers.setMessageDefaultSenderAndReceiver;
+
 public class MessageCoderTest {
 
+	@NonNull
+	private final MessageCoder encoder;
+	@NonNull
+	private final MessageCoder decoder;
+
+	public MessageCoderTest() {
+		byte[] myPublicKey = new byte[NaCl.PUBLICKEYBYTES];
+		byte[] myPrivateKey = new byte[NaCl.SECRETKEYBYTES];
+		byte[] peerPublicKey = new byte[NaCl.PUBLICKEYBYTES];
+		byte[] peerPrivateKey = new byte[NaCl.SECRETKEYBYTES];
+
+		NaCl.genkeypair(myPublicKey, myPrivateKey);
+		NaCl.genkeypair(peerPublicKey, peerPrivateKey);
+
+		IdentityStoreInterface myIdentityStore = new InMemoryIdentityStore(
+			"01234567",
+			null,
+			myPrivateKey,
+			"Me"
+		);
+
+		IdentityStoreInterface peerIdentityStore = new InMemoryIdentityStore(
+			"0ABCDEFG",
+			null,
+			peerPrivateKey,
+			"Peer"
+		);
+
+		ContactStore myContactStore = new InMemoryContactStore();
+		myContactStore.addContact(new Contact("0ABCDEFG", peerPublicKey, VerificationLevel.UNVERIFIED));
+
+		ContactStore peerContactStore = new InMemoryContactStore();
+		peerContactStore.addContact(new Contact("01234567", myPublicKey, VerificationLevel.UNVERIFIED));
+
+		encoder = new MessageCoder(
+			myContactStore,
+			myIdentityStore
+		);
+
+		decoder = new MessageCoder(
+			peerContactStore,
+			peerIdentityStore
+		);
+	}
+
 	private MessageBox box(AbstractMessage msg) throws ThreemaException {
 		MessageCoder messageCoder = new MessageCoder(
 			TestHelpers.getNoopContactStore(),
 			TestHelpers.getNoopIdentityStore()
 		);
 		NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
-		byte[] nonce = nonceFactory.next(false);
-		return messageCoder.encode(msg, nonce, nonceFactory);
+		byte[] nonce = nonceFactory.nextNonce(NonceScope.CSP);
+		return messageCoder.encode(msg, nonce);
 	}
 
 	@Test
 	public void testVoipFlagsOffer() throws ThreemaException {
 		final VoipCallOfferMessage msg = new VoipCallOfferMessage();
-		msg.setToIdentity("TESTTEST");
+		setMessageDefaultSenderAndReceiver(msg);
 		final VoipCallOfferData offerData = new VoipCallOfferData();
 		final VoipCallOfferData.OfferData data = new VoipCallOfferData.OfferData()
 			.setSdp("testsdp")
@@ -59,12 +125,12 @@ public class MessageCoderTest {
 	@Test
 	public void testVoipFlagsAnswer() throws ThreemaException {
 		final VoipCallAnswerMessage msg = new VoipCallAnswerMessage();
-		msg.setToIdentity("TESTTEST");
 		final VoipCallAnswerData answerData = new VoipCallAnswerData()
 			.setAction(VoipCallAnswerData.Action.REJECT)
 			.setAnswerData(null)
 			.setRejectReason(VoipCallAnswerData.RejectReason.BUSY);
 		msg.setData(answerData);
+		setMessageDefaultSenderAndReceiver(msg);
 		final MessageBox boxed = this.box(msg);
 		// Flags: Voip + Push
 		Assert.assertEquals(0x20 | 0x01, boxed.getFlags());
@@ -73,13 +139,13 @@ public class MessageCoderTest {
 	@Test
 	public void testVoipFlagsCandidates() throws ThreemaException {
 		final VoipICECandidatesMessage msg = new VoipICECandidatesMessage();
-		msg.setToIdentity("TESTTEST");
 		final VoipICECandidatesData candidatesData = new VoipICECandidatesData()
 			.setCandidates(new VoipICECandidatesData.Candidate[]{
 				new VoipICECandidatesData.Candidate("testcandidate1", "testmid1", 42, "testufrag1"),
 				new VoipICECandidatesData.Candidate("testcandidate2", "testmid2", 23, "testufrag2"),
 			});
 		msg.setData(candidatesData);
+		setMessageDefaultSenderAndReceiver(msg);
 		final MessageBox boxed = this.box(msg);
 		// Flags: Voip + Push
 		Assert.assertEquals(0x20 | 0x01, boxed.getFlags());
@@ -88,11 +154,141 @@ public class MessageCoderTest {
 	@Test
 	public void testVoipFlagsHangup() throws ThreemaException {
 		final VoipCallHangupMessage msg = new VoipCallHangupMessage();
-		msg.setToIdentity("TESTTEST");
 		msg.setData(new VoipCallHangupData());
+		setMessageDefaultSenderAndReceiver(msg);
 		final MessageBox boxed = this.box(msg);
 		// Flags: Push only
 		Assert.assertEquals(0x01, boxed.getFlags());
 	}
 
+	@Test
+	public void testDeserializeTextMessage() throws MissingPublicKeyException, BadMessageException, ThreemaException {
+		TextMessage textMessage = new TextMessage();
+
+		setAndAssertText(textMessage, "Hello");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, ".");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, new String(Character.toChars(0x1F4A1)));
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "");
+		Assert.assertThrows(BadMessageException.class, () -> encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "a");
+		byte[] body = encode(textMessage).getBox();
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid offset
+			TextMessage.fromByteArray(body, body.length, body.length)
+		);
+
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid length
+			TextMessage.fromByteArray(body, 1, body.length)
+		);
+	}
+
+	private void setAndAssertText(@NonNull TextMessage message, @NonNull String text) {
+		message.setText(text);
+		Assert.assertEquals(text, message.getText());
+	}
+
+	@Test
+	public void testDeserializeGroupTextMessage() throws MissingPublicKeyException, BadMessageException, ThreemaException {
+		GroupTextMessage textMessage = new GroupTextMessage();
+		textMessage.setGroupCreator("01234567");
+		textMessage.setApiGroupId(new GroupId());
+
+		setAndAssertText(textMessage, "Hello");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, ".");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, new String(Character.toChars(0x1F4A1)));
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "");
+		Assert.assertThrows(BadMessageException.class, () -> encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "a");
+		byte[] body = encode(textMessage).getBox();
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid offset
+			GroupTextMessage.fromByteArray(body, body.length, body.length)
+		);
+
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid length
+			GroupTextMessage.fromByteArray(body, 1, body.length)
+		);
+	}
+
+	private void setAndAssertText(@NonNull GroupTextMessage message, @NonNull String text) {
+		message.setText(text);
+		Assert.assertEquals(text, message.getText());
+	}
+
+	@Test
+	public void testDeliveryReceiptMessage() throws MissingPublicKeyException, BadMessageException, ThreemaException {
+		DeliveryReceiptMessage deliveryReceiptMessage = new DeliveryReceiptMessage();
+
+		setAndAssertReceiptType(deliveryReceiptMessage, ProtocolDefines.MSGTYPE_DELIVERY_RECEIPT);
+		setAndAssertMessageIds(deliveryReceiptMessage, new MessageId[]{new MessageId()});
+		assertEqualMessage(deliveryReceiptMessage, encodeAndDecode(deliveryReceiptMessage));
+
+		setAndAssertMessageIds(deliveryReceiptMessage, new MessageId[]{});
+		Assert.assertThrows(BadMessageException.class, () -> encodeAndDecode(deliveryReceiptMessage));
+
+		setAndAssertMessageIds(deliveryReceiptMessage, new MessageId[]{
+			new MessageId(), new MessageId(), new MessageId(), new MessageId()
+		});
+		assertEqualMessage(deliveryReceiptMessage, encodeAndDecode(deliveryReceiptMessage));
+
+		MessageBox messageBox = encode(deliveryReceiptMessage);
+		byte[] invalidLengthBody = new byte[messageBox.getBox().length + 1];
+		Assert.assertThrows(BadMessageException.class, () -> DeliveryReceiptMessage.fromByteArray(invalidLengthBody, 1, invalidLengthBody.length - 1));
+
+		byte[] body = messageBox.getBox();
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid offset
+			TextMessage.fromByteArray(body, body.length, body.length)
+		);
+
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid length
+			TextMessage.fromByteArray(body, 1, body.length)
+		);
+	}
+
+	private void setAndAssertReceiptType(@NonNull DeliveryReceiptMessage message, int type) {
+		message.setReceiptType(type);
+		Assert.assertEquals(type, message.getType());
+	}
+
+	private void setAndAssertMessageIds(
+		@NonNull DeliveryReceiptMessage message,
+		@NonNull MessageId[] messageIds
+	) {
+		message.setReceiptMessageIds(messageIds);
+		Assert.assertArrayEquals(messageIds, message.getReceiptMessageIds());
+	}
+
+	private void assertEqualMessage(@NonNull AbstractMessage expected, @NonNull AbstractMessage actual) throws ThreemaException {
+		Assert.assertArrayEquals(expected.getBody(), actual.getBody());
+	}
+
+	private MessageBox encode(@NonNull AbstractMessage message) throws ThreemaException {
+		message.setToIdentity("0ABCDEFG");
+		message.setFromIdentity("01234567");
+		return encoder.encode(message, new byte[NaCl.NONCEBYTES]);
+	}
+
+	@NonNull
+	private AbstractMessage encodeAndDecode(@NonNull AbstractMessage message) throws ThreemaException, MissingPublicKeyException, BadMessageException {
+		return decoder.decode(encode(message));
+	}
+
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java
index d4726e8a..66ed07a0 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java
@@ -22,6 +22,7 @@
 package ch.threema.domain.protocol.csp.coders;
 
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.testhelpers.TestHelpers;
@@ -47,7 +48,7 @@ public class MetadataCoderTest {
 	@Test
 	public void testEncodeDecode() throws ThreemaException, InvalidProtocolBufferException {
 
-		byte[] nonce = TestHelpers.getNoopNonceFactory().next();
+		byte[] nonce = TestHelpers.getNoopNonceFactory().nextNonce(NonceScope.CSP);
 		MessageId messageId = new MessageId();
 
 		Date createdAt = new Date();
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java
index 62ac93a8..1cf333b7 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java
@@ -28,17 +28,17 @@ import org.mockito.exceptions.base.MockitoException;
 import org.powermock.reflect.Whitebox;
 
 import java.lang.reflect.Field;
-import java.util.Collections;
 import java.util.Date;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Objects;
+import java.util.stream.Collectors;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
-import ch.threema.base.crypto.NonceStore;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.domain.fs.DHSession;
 import ch.threema.domain.fs.DHSessionId;
 import ch.threema.domain.fs.KDFRatchet;
@@ -95,12 +95,14 @@ import ch.threema.domain.stores.DHSessionStoreInterface;
 import ch.threema.domain.stores.DummyContactStore;
 import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.domain.taskmanager.ActiveTaskCodec;
+import ch.threema.domain.testhelpers.TestHelpers;
 import ch.threema.protobuf.csp.e2e.fs.Terminate;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 import ch.threema.protobuf.csp.e2e.fs.VersionRange;
+import kotlin.Pair;
 
 import static ch.threema.domain.protocol.connection.ConnectionTestUtilsKt.getFromOutboundMessage;
-import static ch.threema.domain.taskmanager.OutgoingCspMessageUtilsKt.toCspMessage;
+import static ch.threema.domain.taskmanager.OutgoingCspMessageUtilsKt.toCspMessageJava;
 
 public class ForwardSecurityMessageProcessorTest {
 
@@ -122,23 +124,7 @@ public class ForwardSecurityMessageProcessorTest {
 
 	private final ActiveTaskCodec testCodec = new UnusedTaskCodec();
 
-	private final NonceFactory nonceFactory = new NonceFactory(new NonceStore() {
-		@Override
-		public boolean exists(@NonNull byte[] nonce) {
-			return false;
-		}
-
-		@Override
-		public boolean store(@NonNull byte[] nonce) {
-			return true;
-		}
-
-		@Override
-		@NonNull
-		public List<byte[]> getAllHashedNonces() {
-			return Collections.emptyList();
-		}
-	});
+	private final NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
 
 	private final ForwardSecurityStatusListener forwardSecurityStatusListener = new ForwardSecurityStatusListener() {
 		@Override
@@ -647,7 +633,7 @@ public class ForwardSecurityMessageProcessorTest {
 		Field appliedVersionField = ForwardSecurityDataMessage.class.getDeclaredField("offeredVersion");
 		appliedVersionField.setAccessible(true);
 		appliedVersionField.setInt(data, 0x01FF);
-		aliceContext.handle.writeAsync(toCspMessage(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory, nonceFactory.next(false)));
+		aliceContext.handle.writeAsync(toCspMessageJava(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory.nextNonce(NonceScope.CSP)));
 
 		// Now Bob processes the text message from Alice. This should not fail, even if the offered
 		// version is not known.
@@ -700,7 +686,7 @@ public class ForwardSecurityMessageProcessorTest {
 		Field appliedVersionField = ForwardSecurityDataMessage.class.getDeclaredField("appliedVersion");
 		appliedVersionField.setAccessible(true);
 		appliedVersionField.setInt(data, 0x0100);
-		aliceContext.handle.writeAsync(toCspMessage(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory, nonceFactory.next(false)));
+		aliceContext.handle.writeAsync(toCspMessageJava(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory.nextNonce(NonceScope.CSP)));
 
 		// Now Bob processes the text message from Alice. Note that the message should be rejected
 		// and therefore return an empty list.
@@ -799,7 +785,7 @@ public class ForwardSecurityMessageProcessorTest {
 		assertMessageNotEncapsulated(new VoipICECandidatesMessage(), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new DeliveryReceiptMessage(), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new TypingIndicatorMessage(), aliceContext, DummyUsers.BOB);
-		assertMessageNotEncapsulated(new SetProfilePictureMessage(), aliceContext, DummyUsers.BOB);
+		assertMessageNotEncapsulated(new SetProfilePictureMessage(new byte[0], 0, new byte[0]), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new DeleteProfilePictureMessage(), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new ContactRequestProfilePictureMessage(), aliceContext, DummyUsers.BOB);
 	}
@@ -842,7 +828,7 @@ public class ForwardSecurityMessageProcessorTest {
 			new VoipICECandidatesMessage(),
 			new DeliveryReceiptMessage(),
 			new TypingIndicatorMessage(),
-			new SetProfilePictureMessage(),
+			new SetProfilePictureMessage(new byte[0], 0, new byte[0]),
 			new DeleteProfilePictureMessage(),
 			new ContactRequestProfilePictureMessage()
 		).forEach( fs1_1_message -> {
@@ -923,14 +909,16 @@ public class ForwardSecurityMessageProcessorTest {
 		// Set the (non-sense) group identity
 		textMessage.setGroupCreator(DummyUsers.ALICE.getIdentity());
 		textMessage.setApiGroupId(new GroupId(0));
-
-		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.makeMessage(
-			DummyUsers.getContactForUser(DummyUsers.BOB),
+		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(DummyUsers.BOB),
 			textMessage,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
 			aliceContext.handle
 		);
 
-		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages();
+		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		Assert.assertEquals(2, outgoingMessages.size());
 
 		// Assert that the first message is sent with FS
@@ -941,11 +929,10 @@ public class ForwardSecurityMessageProcessorTest {
 
 		for (AbstractMessage message : outgoingMessages) {
 			aliceContext.handle.writeAsync(
-				toCspMessage(message,
+				toCspMessageJava(message,
 					aliceContext.identityStore,
 					aliceContext.contactStore,
-					nonceFactory,
-					nonceFactory.next(false))
+					nonceFactory.nextNonce(NonceScope.CSP))
 			);
 		}
 
@@ -972,21 +959,23 @@ public class ForwardSecurityMessageProcessorTest {
 		textMessage.setText(ALICE_MESSAGE_2);
 		textMessage.setToIdentity(DummyUsers.BOB.getIdentity());
 
-		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.makeMessage(
-			DummyUsers.getContactForUser(DummyUsers.BOB),
+		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(DummyUsers.BOB),
 			textMessage,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
 			aliceContext.handle
 		);
 
-		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages();
+		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		Assert.assertEquals(1, outgoingMessages.size());
 
 		aliceContext.handle.writeAsync(
-			toCspMessage(outgoingMessages.get(0),
+			toCspMessageJava(outgoingMessages.get(0),
 				aliceContext.identityStore,
 				aliceContext.contactStore,
-				nonceFactory,
-				nonceFactory.next(false))
+				nonceFactory.nextNonce(NonceScope.CSP))
 		);
 
 		TextMessage receivedMessage = (TextMessage) processOneReceivedMessage(
@@ -1404,7 +1393,7 @@ public class ForwardSecurityMessageProcessorTest {
 
 	private List<AbstractMessage> processReceivedMessages(ServerAckTaskCodec sourceHandle, UserContext recipientContext) throws BadMessageException, ThreemaException, MissingPublicKeyException {
 		List<AbstractMessage> decapsulatedMessages = new LinkedList<>();
-		while (sourceHandle.getOutboundMessages().size() > 0) {
+		while (!sourceHandle.getOutboundMessages().isEmpty()) {
 			AbstractMessage decapMsg = processOneReceivedMessage(sourceHandle, recipientContext, 0, false);
 			if (decapMsg != null) {
 				decapsulatedMessages.add(decapMsg);
@@ -1485,7 +1474,7 @@ public class ForwardSecurityMessageProcessorTest {
 	private AbstractMessage sendTextMessage(String text, UserContext senderContext, DummyUsers.User recipient) throws ThreemaException {
 		List<AbstractMessage> messages = makeEncapTextMessage(text, senderContext, recipient);
 		for (AbstractMessage message : messages) {
-			senderContext.handle.writeAsync(toCspMessage(message, senderContext.identityStore, senderContext.contactStore, nonceFactory, nonceFactory.next(false)));
+			senderContext.handle.writeAsync(toCspMessageJava(message, senderContext.identityStore, senderContext.contactStore, nonceFactory.nextNonce(NonceScope.CSP)));
 		}
 		return getEncapsulatedMessageFromOutgoingMessageList(messages);
 	}
@@ -1519,9 +1508,16 @@ public class ForwardSecurityMessageProcessorTest {
 		TextMessage textMessage = new TextMessage();
 		textMessage.setText(text);
 		textMessage.setToIdentity(recipient.getIdentity());
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(DummyUsers.getContactForUser(recipient), textMessage, senderContext.handle);
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
+			textMessage,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
+			senderContext.handle
+		);
 		senderContext.fsmp.commitSessionState(result);
-		List<AbstractMessage> outgoingMessages = result.getOutgoingMessages();
+		List<AbstractMessage> outgoingMessages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		for (AbstractMessage message : outgoingMessages) {
 			message.setToIdentity(recipient.getIdentity());
 		}
@@ -1540,13 +1536,16 @@ public class ForwardSecurityMessageProcessorTest {
 			// mocking usually only works for the empty message.
 			messageMock = message;
 		}
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(
-			DummyUsers.getContactForUser(recipient),
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
 			messageMock,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
 			senderContext.handle
 		);
 
-		List<AbstractMessage> messages = result.getOutgoingMessages();
+		List<AbstractMessage> messages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 
 		Assert.assertEquals(2, messages.size());
 		Assert.assertTrue(((ForwardSecurityEnvelopeMessage) messages.get(0)).getData() instanceof ForwardSecurityDataInit);
@@ -1554,9 +1553,16 @@ public class ForwardSecurityMessageProcessorTest {
 	}
 
 	private void assertNewSessionMessageNotEncapsulated(AbstractMessage message, UserContext senderContext, DummyUsers.User recipient) throws ThreemaException {
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(DummyUsers.getContactForUser(recipient), message, senderContext.handle);
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
+			message,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
+			senderContext.handle
+		);
 		senderContext.fsmp.commitSessionState(result);
-		List<AbstractMessage> messages = result.getOutgoingMessages();
+		List<AbstractMessage> messages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		// As the message type is not supported for the available forward security session, it is
 		// sent without being encapsulated. Therefore the message equals the original message.
 		Assert.assertEquals(2, messages.size());
@@ -1565,9 +1571,16 @@ public class ForwardSecurityMessageProcessorTest {
 	}
 
 	private void assertMessageNotEncapsulated(AbstractMessage message, UserContext senderContext, DummyUsers.User recipient) throws ThreemaException {
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(DummyUsers.getContactForUser(recipient), message, senderContext.handle);
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
+			message,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
+			senderContext.handle
+		);
 		senderContext.fsmp.commitSessionState(result);
-		List<AbstractMessage> messages = result.getOutgoingMessages();
+		List<AbstractMessage> messages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		// As the message type is not supported for the available forward security session, it is
 		// sent without being encapsulated. Therefore the message equals the original message.
 		// If the size does not match, then check that this method is used for existing and fresh
@@ -1609,7 +1622,7 @@ public class ForwardSecurityMessageProcessorTest {
 		Contact contact,
 		ForwardSecurityEnvelopeMessage msg,
 		ActiveTaskCodec handle
-	) throws BadMessageException, ThreemaException {
+	) throws ThreemaException, BadMessageException {
 		ForwardSecurityData data = msg.getData();
 		if (data instanceof ForwardSecurityDataInit) {
 			fsmp.processInit(contact, (ForwardSecurityDataInit) data, handle);
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessageTest.kt
new file mode 100644
index 00000000..8363eb3d
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessageTest.kt
@@ -0,0 +1,86 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages
+
+import ch.threema.testutils.willThrow
+import kotlin.test.Test
+import kotlin.test.assertIs
+
+class ContactRequestProfilePictureMessageTest {
+
+    @Test
+    fun testValid() {
+        assertIs<ContactRequestProfilePictureMessage>(
+            ContactRequestProfilePictureMessage.fromByteArray(
+                ByteArray(0)
+            )
+        )
+    }
+
+    @Test
+    fun testValidExplicit() {
+        assertIs<ContactRequestProfilePictureMessage>(
+            ContactRequestProfilePictureMessage.fromByteArray(
+                data = ByteArray(0),
+                offset = 0,
+                length = 0,
+            )
+        )
+    }
+
+    @Test
+    fun testNegativeOffset() {
+        val testBlockLazy = {
+            ContactRequestProfilePictureMessage.fromByteArray(
+                data = ByteArray(0),
+                offset = -1,
+                length = 0,
+            )
+        }
+
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun testInvalidLength() {
+        val testBlockLazy = {
+            ContactRequestProfilePictureMessage.fromByteArray(
+                data = ByteArray(42),
+                offset = 0,
+                length = 42,
+            )
+        }
+
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun testValidWithOffset() {
+        assertIs<ContactRequestProfilePictureMessage>(
+            ContactRequestProfilePictureMessage.fromByteArray(
+                data = ByteArray(1),
+                offset = 1,
+                length = 0,
+            )
+        )
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessageTest.kt
new file mode 100644
index 00000000..5f601a1c
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessageTest.kt
@@ -0,0 +1,86 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages
+
+import ch.threema.testutils.willThrow
+import kotlin.test.Test
+import kotlin.test.assertIs
+
+class DeleteProfilePictureMessageTest {
+
+    @Test
+    fun testValid() {
+        assertIs<DeleteProfilePictureMessage>(
+            DeleteProfilePictureMessage.fromByteArray(
+                ByteArray(0)
+            )
+        )
+    }
+
+    @Test
+    fun testValidExplicit() {
+        assertIs<DeleteProfilePictureMessage>(
+            DeleteProfilePictureMessage.fromByteArray(
+                data = ByteArray(0),
+                offset = 0,
+                length = 0,
+            )
+        )
+    }
+
+    @Test
+    fun testNegativeOffset() {
+        val testBlockLazy = {
+            DeleteProfilePictureMessage.fromByteArray(
+                data = ByteArray(0),
+                offset = -1,
+                length = 0,
+            )
+        }
+
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun testInvalidLength() {
+        val testBlockLazy = {
+            DeleteProfilePictureMessage.fromByteArray(
+                data = ByteArray(42),
+                offset = 0,
+                length = 42,
+            )
+        }
+
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun testValidWithOffset() {
+        assertIs<DeleteProfilePictureMessage>(
+            DeleteProfilePictureMessage.fromByteArray(
+                data = ByteArray(1),
+                offset = 1,
+                length = 0,
+            )
+        )
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java
index 60ff8f03..95a851f3 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java
@@ -28,7 +28,7 @@ import ch.threema.domain.models.GroupId;
 public class GroupDeleteProfilePictureMessageTest {
 
 	@Test
-	public void testGetBody() throws Exception {
+	public void testGetBody() {
 		final GroupDeleteProfilePictureMessage msg = new GroupDeleteProfilePictureMessage();
 		msg.setGroupCreator("GRCREATE");
 		GroupId groupId = new GroupId();
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessageTest.kt
new file mode 100644
index 00000000..bf76bef4
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessageTest.kt
@@ -0,0 +1,117 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages
+
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.testutils.willThrow
+import java.nio.ByteBuffer
+import java.nio.ByteOrder
+import kotlin.test.Test
+import kotlin.test.assertContentEquals
+import kotlin.test.assertEquals
+
+class SetProfilePictureMessageTest {
+
+    private val validBlobId = ByteArray(ProtocolDefines.BLOB_ID_LEN).apply { fill(1) }
+    private val validSize = ByteArray(4).apply { fill(2) }
+    private val validEncryptionKey = ByteArray(ProtocolDefines.BLOB_KEY_LEN).apply { fill(3) }
+
+    private val validBody = validBlobId + validSize + validEncryptionKey
+
+    @Test
+    fun testValidBody() {
+        val message = SetProfilePictureMessage.fromByteArray(validBody)
+        assertContentEquals(validBlobId, message.blobId)
+        assertEquals(ByteBuffer.wrap(validSize).order(ByteOrder.LITTLE_ENDIAN).getInt(), message.size)
+        assertContentEquals(validEncryptionKey, message.encryptionKey)
+    }
+
+    @Test
+    fun testValidBodyExplicit() {
+        val message = SetProfilePictureMessage.fromByteArray(
+            data = validBody,
+            offset = 0,
+            length = validBody.size,
+        )
+        assertContentEquals(validBlobId, message.blobId)
+        assertEquals(ByteBuffer.wrap(validSize).order(ByteOrder.LITTLE_ENDIAN).getInt(), message.size)
+        assertContentEquals(validEncryptionKey, message.encryptionKey)
+    }
+
+    @Test
+    fun testValidBodyWithOffset() {
+        val prefix = ByteArray(10)
+
+        val message = SetProfilePictureMessage.fromByteArray(
+            data = prefix + validBody,
+            offset = prefix.size,
+            length = validBody.size,
+        )
+        assertContentEquals(validBlobId, message.blobId)
+        assertEquals(ByteBuffer.wrap(validSize).order(ByteOrder.LITTLE_ENDIAN).getInt(), message.size)
+        assertContentEquals(validEncryptionKey, message.encryptionKey)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenTooSmall() {
+        val testBlockLazy = {
+            SetProfilePictureMessage.fromByteArray(
+                ByteArray(ProtocolDefines.BLOB_ID_LEN)
+            )
+        }
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenTooBig() {
+        val testBlockLazy = {
+            SetProfilePictureMessage.fromByteArray(
+                ByteArray(ProtocolDefines.BLOB_ID_LEN + 4 + ProtocolDefines.BLOB_KEY_LEN + 10)
+            )
+        }
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionOffsetNegative() {
+        val testBlockLazy = {
+            SetProfilePictureMessage.fromByteArray(
+                data = validBody,
+                offset = -1,
+                length = validBody.size,
+            )
+        }
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionUnexpectedLength() {
+        val testBlockLazy = {
+            SetProfilePictureMessage.fromByteArray(
+                data = validSize.copyOf(5),
+                offset = 0,
+                length = validBody.size,
+            )
+        }
+        testBlockLazy willThrow BadMessageException::class
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java
index 353e796e..dba0f588 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java
@@ -22,75 +22,79 @@
 package ch.threema.domain.protocol.csp.messages.ballot;
 
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.junit.Assert;
 import org.junit.Test;
 
 public class BallotVoteTest {
-	class BallotVotString extends BallotVote {
-		@Override
-		public String toString() {
-			try {
-				return this.generateString();
-			} catch (BadMessageException e) {
-				return "ERROR " + e.getMessage();
-			}
-		}
-	}
 
-	@Test
-	public void parseValidString() {
-		String correct = "[10,1]";
+    static class BallotVoteString extends BallotVote {
+
+        public BallotVoteString(int id, int value) {
+            super(id, value);
+        }
+
+        @Override
+        public String toString() {
+            try {
+                return this.generateString();
+            } catch (BadMessageException e) {
+                return "ERROR " + e.getMessage();
+            }
+        }
+    }
 
-		try {
-			Assert.assertNotNull(BallotVote.parse(new JSONArray(correct)));
-		} catch (Exception e) {
-			Assert.fail(e.getMessage());
-		}
-	}
+    @Test
+    public void parseValidString() {
+        String correct = "[10,1]";
 
-	@Test
-	public void parseInvalidType() {
-		String correct = "[\"a\",\"b\"]";
+        try {
+            Assert.assertNotNull(BallotVote.parse(new JSONArray(correct)));
+        } catch (Exception e) {
+            Assert.fail(e.getMessage());
+        }
+    }
 
-		try {
-			try {
-				BallotVote.parse(new JSONArray(correct));
-			} catch (JSONException e) {
-				e.printStackTrace();
-			}
-			Assert.fail("wrong type parsed");
-		} catch (BadMessageException e) {
-			//cool!
-		}
-	}
+    @Test
+    public void parseInvalidType() {
+        String correct = "[\"a\",\"b\"]";
 
-	@Test
-	public void parseInvalidString() {
-		try {
-			BallotDataChoice.parse("i want to be a hippie");
-			Assert.fail("invalid string parsed");
-		} catch (BadMessageException e) {
-			//ok! exception received
-		}
-	}
+        try {
+            try {
+                BallotVote.parse(new JSONArray(correct));
+            } catch (JSONException e) {
+                e.printStackTrace();
+            }
+            Assert.fail("wrong type parsed");
+        } catch (BadMessageException e) {
+            //cool!
+        }
+    }
 
-	@Test
-	public void toStringTest() {
-		BallotVote v = new BallotVotString();
-		v.setId(100);
-		v.setValue(1);
+    @Test
+    public void parseInvalidString() {
+        try {
+            BallotDataChoice.parse("i want to be a hippie");
+            Assert.fail("invalid string parsed");
+        } catch (BadMessageException e) {
+            //ok! exception received
+        }
+    }
 
-		try {
-			JSONArray o = new JSONArray("[100, 1]");
-			Assert.assertEquals(
-					o.toString(),
-					v.toString()
-			);
-		} catch (JSONException e) {
-			Assert.fail("internal error");
-		}
+    @Test
+    public void toStringTest() {
+        BallotVote v = new BallotVoteString(100, 1);
 
-	}
+        try {
+            JSONArray o = new JSONArray("[100, 1]");
+            Assert.assertEquals(
+                o.toString(),
+                v.toString()
+            );
+        } catch (JSONException e) {
+            Assert.fail("internal error");
+        }
+    }
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessageTest.kt
new file mode 100644
index 00000000..45fbff1c
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessageTest.kt
@@ -0,0 +1,260 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.incomingMessage
+import ch.threema.testutils.willThrow
+import com.google.protobuf.kotlin.toByteString
+import org.junit.Test
+import kotlin.test.assertContentEquals
+import kotlin.test.assertEquals
+import kotlin.test.fail
+
+open class GroupPollSetupMessageTest {
+
+    private val fromIdentity = "01234567"
+
+    private val groupPollSetupMessage = GroupPollSetupMessage().apply {
+
+        ballotId = BallotId()
+        groupCreator = "01234567"
+        apiGroupId = GroupId()
+        ballotCreatorIdentity = "01234567"
+
+        ballotData = BallotData().apply {
+            this.setDescription("Cool ballot")
+            setState(BallotData.State.OPEN)
+            setAssessmentType(BallotData.AssessmentType.SINGLE)
+            setType(BallotData.Type.INTERMEDIATE)
+            setChoiceType(BallotData.ChoiceType.TEXT)
+            addChoice(
+                BallotDataChoiceBuilder()
+                    .setId(0)
+                    .setSortKey(0)
+                    .setDescription("Coice 1")
+                    .build()
+            )
+            addChoice(
+                BallotDataChoiceBuilder()
+                    .setId(1)
+                    .setSortKey(1)
+                    .setDescription("Coice 2")
+                    .build()
+            )
+            addChoice(
+                BallotDataChoiceBuilder()
+                    .setId(2)
+                    .setSortKey(2)
+                    .setDescription("Coice 3")
+                    .build()
+            )
+            addParticipant("01234567")
+            addParticipant("0Y123456")
+            setDisplayType(BallotData.DisplayType.LIST_MODE)
+        }
+    }
+
+    private val groupPollSetupMessageBody: ByteArray = groupPollSetupMessage.body!!
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthTooShort() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollSetupMessage.fromByteArray(
+                data = groupPollSetupMessageBody,
+                offset = 0,
+                length = 0,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetBelowZero() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollSetupMessage.fromByteArray(
+                data = groupPollSetupMessageBody,
+                offset = -1,
+                length = 64,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLength() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollSetupMessage.fromByteArray(
+                data = groupPollSetupMessageBody,
+                offset = 0,
+                length = groupPollSetupMessageBody.size + 1,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLengthWithOffset() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollSetupMessage.fromByteArray(
+                data = groupPollSetupMessageBody,
+                offset = 1,
+                length = groupPollSetupMessageBody.size,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithoutOffset() {
+
+        // act
+        val resultGroupPollSetupMessage = GroupPollSetupMessage.fromByteArray(
+            data = groupPollSetupMessageBody,
+            offset = 0,
+            length = groupPollSetupMessageBody.size,
+            fromIdentity = fromIdentity
+        )
+
+        // assert
+        assertGroupPollSetupMessageFields(resultGroupPollSetupMessage)
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithOffset() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + groupPollSetupMessageBody
+
+        // act
+        val resultGroupPollSetupMessage = GroupPollSetupMessage.fromByteArray(
+            data = dataWithOffsetByte,
+            offset = 1,
+            length = groupPollSetupMessageBody.size,
+            fromIdentity = fromIdentity
+        )
+
+        // assert
+        assertGroupPollSetupMessageFields(resultGroupPollSetupMessage)
+    }
+
+    @Test
+    fun fromReflectedShouldParseBodyAndSetCommonFields() {
+
+        // act
+        val incomingMessageId = 12345678L
+        val incomingMessageCreatedAt: Long = System.currentTimeMillis()
+        val incomingD2DMessage = incomingMessage {
+            this.senderIdentity = fromIdentity
+            this.messageId = incomingMessageId
+            this.createdAt = incomingMessageCreatedAt
+            this.body = groupPollSetupMessageBody.toByteString()
+        }
+
+        // act
+        val resultGroupPollSetupMessage: GroupPollSetupMessage = GroupPollSetupMessage.fromReflected(
+            message = incomingD2DMessage,
+            fromIdentity = fromIdentity
+        )
+
+        // assert
+        assertEquals(resultGroupPollSetupMessage.messageId, MessageId(incomingMessageId))
+        assertEquals(resultGroupPollSetupMessage.date.time, incomingMessageCreatedAt)
+        assertEquals(resultGroupPollSetupMessage.fromIdentity, fromIdentity)
+        assertGroupPollSetupMessageFields(resultGroupPollSetupMessage)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetNotPassedCorrectly() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + groupPollSetupMessageBody
+
+        val testBlockLazy = {
+
+            // act
+            GroupPollSetupMessage.fromByteArray(
+                data = dataWithOffsetByte,
+                offset = 0,
+                length = groupPollSetupMessageBody.size,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    private fun assertGroupPollSetupMessageFields(actual: GroupPollSetupMessage?) {
+        if (actual?.ballotData == null) {
+            fail()
+        }
+        assertEquals(groupPollSetupMessage.ballotId, actual.ballotId)
+        assertEquals(groupPollSetupMessage.groupCreator, actual.groupCreator)
+        assertEquals(groupPollSetupMessage.apiGroupId, actual.apiGroupId)
+        assertEquals(groupPollSetupMessage.ballotCreatorIdentity, actual.ballotCreatorIdentity)
+        assertEquals(groupPollSetupMessage.ballotData!!.description, actual.ballotData!!.description)
+        assertEquals(groupPollSetupMessage.ballotData!!.state, actual.ballotData!!.state)
+        assertEquals(groupPollSetupMessage.ballotData!!.assessmentType, actual.ballotData!!.assessmentType)
+        assertEquals(groupPollSetupMessage.ballotData!!.type, actual.ballotData!!.type)
+        assertEquals(groupPollSetupMessage.ballotData!!.choiceType, actual.ballotData!!.choiceType)
+        assertContentEquals(groupPollSetupMessage.ballotData!!.participants, actual.ballotData!!.participants)
+        assertEquals(groupPollSetupMessage.ballotData!!.displayType, actual.ballotData!!.displayType)
+        assertEquals(groupPollSetupMessage.ballotData!!.choiceList.size, actual.ballotData!!.choiceList.size)
+        groupPollSetupMessage.ballotData!!.choiceList.forEachIndexed { index, value ->
+            assertEquals(value.id, actual.ballotData!!.choiceList[index].id)
+            assertEquals(value.name, actual.ballotData!!.choiceList[index].name)
+            assertEquals(value.order, actual.ballotData!!.choiceList[index].order)
+            assertContentEquals(value.ballotDataChoiceResults, actual.ballotData!!.choiceList[index].ballotDataChoiceResults)
+            assertEquals(value.totalVotes, actual.ballotData!!.choiceList[index].totalVotes)
+        }
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessageTest.kt
new file mode 100644
index 00000000..a06d25ce
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessageTest.kt
@@ -0,0 +1,214 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.incomingMessage
+import ch.threema.testutils.willThrow
+import com.google.protobuf.kotlin.toByteString
+import org.junit.Test
+import kotlin.test.assertEquals
+import kotlin.test.fail
+
+open class GroupPollVoteMessageTest {
+
+    private val groupPollVoteMessage = GroupPollVoteMessage().apply {
+
+        groupCreator = "01234567"
+        apiGroupId = GroupId()
+        ballotCreatorIdentity = "01234567"
+        ballotId = BallotId()
+
+        addVotes(
+            listOf(
+                BallotVote(2, 8),
+                BallotVote(3, 5),
+                BallotVote(4, 1)
+            )
+        )
+    }
+
+    private var groupPollVoteMessageBody: ByteArray = groupPollVoteMessage.body!!
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthTooShort() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollVoteMessage.fromByteArray(
+                data = groupPollVoteMessageBody,
+                offset = 0,
+                length = 0,
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetBelowZero() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollVoteMessage.fromByteArray(
+                data = groupPollVoteMessageBody,
+                offset = -1,
+                length = 64,
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLength() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollVoteMessage.fromByteArray(
+                data = groupPollVoteMessageBody,
+                offset = 0,
+                length = groupPollVoteMessageBody.size + 1
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLengthWithOffset() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupPollVoteMessage.fromByteArray(
+                data = groupPollVoteMessageBody,
+                offset = 1,
+                length = groupPollVoteMessageBody.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithoutOffset() {
+
+        // act
+        val resultGroupPollVoteMessage = GroupPollVoteMessage.fromByteArray(
+            data = groupPollVoteMessageBody,
+            offset = 0,
+            length = groupPollVoteMessageBody.size
+        )
+
+        // assert
+        assertGroupPollVoteMessageFields(resultGroupPollVoteMessage)
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithOffset() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + groupPollVoteMessageBody
+
+        // act
+        val resultGroupPollVoteMessage: GroupPollVoteMessage = GroupPollVoteMessage.fromByteArray(
+            data = dataWithOffsetByte,
+            offset = 1,
+            length = groupPollVoteMessageBody.size
+        )
+
+        // assert
+        assertGroupPollVoteMessageFields(resultGroupPollVoteMessage)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetNotPassedCorrectly() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + groupPollVoteMessageBody
+
+        val testBlockLazy = {
+
+            // act
+            GroupPollVoteMessage.fromByteArray(
+                data = dataWithOffsetByte,
+                offset = 0,
+                length = groupPollVoteMessageBody.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun fromReflectedShouldParseBodyAndSetCommonFields() {
+
+        // act
+        val incomingMessageId = 12345678L
+        val incomingMessageCreatedAt: Long = System.currentTimeMillis()
+        val incomingMessageSenderIdentity = "01234567"
+        val incomingD2DMessage = incomingMessage {
+            this.senderIdentity = incomingMessageSenderIdentity
+            this.messageId = incomingMessageId
+            this.createdAt = incomingMessageCreatedAt
+            this.body = groupPollVoteMessageBody.toByteString()
+        }
+
+        // act
+        val resultGroupPollVoteMessage: GroupPollVoteMessage = GroupPollVoteMessage.fromReflected(incomingD2DMessage)
+
+        // assert
+        assertEquals(resultGroupPollVoteMessage.messageId, MessageId(incomingMessageId))
+        assertEquals(resultGroupPollVoteMessage.date.time, incomingMessageCreatedAt)
+        assertEquals(resultGroupPollVoteMessage.fromIdentity, incomingMessageSenderIdentity)
+        assertGroupPollVoteMessageFields(resultGroupPollVoteMessage)
+    }
+
+    private fun assertGroupPollVoteMessageFields(actual: GroupPollVoteMessage?) {
+        if (actual == null) {
+            fail()
+        }
+        assertEquals(groupPollVoteMessage.groupCreator, actual.groupCreator)
+        assertEquals(groupPollVoteMessage.apiGroupId, actual.apiGroupId)
+        assertEquals(groupPollVoteMessage.ballotCreatorIdentity, actual.ballotCreatorIdentity)
+        assertEquals(groupPollVoteMessage.ballotId, actual.ballotId)
+        assertEquals(groupPollVoteMessage.votes.size, actual.votes.size)
+        groupPollVoteMessage.votes.forEachIndexed { index, vote ->
+            assertEquals(vote.id, actual.votes[index].id)
+            assertEquals(vote.value, actual.votes[index].value)
+        }
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessageTest.kt
new file mode 100644
index 00000000..ceff63e3
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessageTest.kt
@@ -0,0 +1,252 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.incomingMessage
+import ch.threema.testutils.willThrow
+import com.google.protobuf.kotlin.toByteString
+import org.junit.Test
+import kotlin.test.assertContentEquals
+import kotlin.test.assertEquals
+import kotlin.test.fail
+
+open class PollSetupMessageTest {
+
+    private val fromIdentity = "01234567"
+
+    private val pollSetupMessage = PollSetupMessage().apply {
+        ballotId = BallotId()
+        ballotCreatorIdentity = "01234567"
+        ballotData = BallotData().apply {
+            setDescription("Cool ballot")
+            setState(BallotData.State.OPEN)
+            setAssessmentType(BallotData.AssessmentType.SINGLE)
+            setType(BallotData.Type.INTERMEDIATE)
+            setChoiceType(BallotData.ChoiceType.TEXT)
+            addChoice(
+                BallotDataChoiceBuilder()
+                    .setId(0)
+                    .setSortKey(0)
+                    .setDescription("Coice 1")
+                    .build()
+            )
+            addChoice(
+                BallotDataChoiceBuilder()
+                    .setId(1)
+                    .setSortKey(1)
+                    .setDescription("Coice 2")
+                    .build()
+            )
+            addChoice(
+                BallotDataChoiceBuilder()
+                    .setId(2)
+                    .setSortKey(2)
+                    .setDescription("Coice 3")
+                    .build()
+            )
+            addParticipant("01234567")
+            setDisplayType(BallotData.DisplayType.LIST_MODE)
+        }
+    }
+
+    private val pollSetupMessageBody: ByteArray = pollSetupMessage.body!!
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthTooShort() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollSetupMessage.fromByteArray(
+                data = pollSetupMessageBody,
+                offset = 0,
+                length = 0,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetBelowZero() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollSetupMessage.fromByteArray(
+                data = pollSetupMessageBody,
+                offset = -1,
+                length = 64,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLength() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollSetupMessage.fromByteArray(
+                data = pollSetupMessageBody,
+                offset = 0,
+                length = pollSetupMessageBody.size + 1,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLengthWithOffset() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollSetupMessage.fromByteArray(
+                data = pollSetupMessageBody,
+                offset = 1,
+                length = pollSetupMessageBody.size,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithoutOffset() {
+
+        // act
+        val resultPollSetupMessage = PollSetupMessage.fromByteArray(
+            data = pollSetupMessageBody,
+            offset = 0,
+            length = pollSetupMessageBody.size,
+            fromIdentity = fromIdentity
+        )
+
+        // assert
+        assertPollSetupMessageFields(resultPollSetupMessage)
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithOffset() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + pollSetupMessageBody
+
+        // act
+        val resultPollSetupMessage = PollSetupMessage.fromByteArray(
+            data = dataWithOffsetByte,
+            offset = 1,
+            length = pollSetupMessageBody.size,
+            fromIdentity = fromIdentity
+        )
+
+        // assert
+        assertPollSetupMessageFields(resultPollSetupMessage)
+    }
+
+    @Test
+    fun fromReflectedShouldParseBodyAndSetCommonFields() {
+
+        // act
+        val incomingMessageId = 12345678L
+        val incomingMessageCreatedAt: Long = System.currentTimeMillis()
+        val incomingD2DMessage = incomingMessage {
+            this.senderIdentity = fromIdentity
+            this.messageId = incomingMessageId
+            this.createdAt = incomingMessageCreatedAt
+            this.body = pollSetupMessageBody.toByteString()
+        }
+
+        // act
+        val resultPollSetupMessage: PollSetupMessage = PollSetupMessage.fromReflected(
+            message = incomingD2DMessage,
+            fromIdentity = fromIdentity
+        )
+
+        // assert
+        assertEquals(resultPollSetupMessage.messageId, MessageId(incomingMessageId))
+        assertEquals(resultPollSetupMessage.date.time, incomingMessageCreatedAt)
+        assertEquals(resultPollSetupMessage.fromIdentity, fromIdentity)
+        assertPollSetupMessageFields(resultPollSetupMessage)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetNotPassedCorrectly() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + pollSetupMessageBody
+
+        val testBlockLazy = {
+
+            // act
+            PollSetupMessage.fromByteArray(
+                data = dataWithOffsetByte,
+                offset = 0,
+                length = pollSetupMessageBody.size,
+                fromIdentity = fromIdentity
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    private fun assertPollSetupMessageFields(actual: PollSetupMessage?) {
+        if (actual?.ballotData == null) {
+            fail()
+        }
+        assertEquals(pollSetupMessage.ballotId, actual.ballotId)
+        assertEquals(pollSetupMessage.ballotCreatorIdentity, actual.ballotCreatorIdentity)
+        assertEquals(pollSetupMessage.ballotData!!.description, actual.ballotData!!.description)
+        assertEquals(pollSetupMessage.ballotData!!.state, actual.ballotData!!.state)
+        assertEquals(pollSetupMessage.ballotData!!.assessmentType, actual.ballotData!!.assessmentType)
+        assertEquals(pollSetupMessage.ballotData!!.type, actual.ballotData!!.type)
+        assertEquals(pollSetupMessage.ballotData!!.choiceType, actual.ballotData!!.choiceType)
+        assertContentEquals(pollSetupMessage.ballotData!!.participants, actual.ballotData!!.participants)
+        assertEquals(pollSetupMessage.ballotData!!.displayType, actual.ballotData!!.displayType)
+        assertEquals(pollSetupMessage.ballotData!!.choiceList.size, actual.ballotData!!.choiceList.size)
+        pollSetupMessage.ballotData!!.choiceList.forEachIndexed { index, value ->
+            assertEquals(value.id, actual.ballotData!!.choiceList[index].id)
+            assertEquals(value.name, actual.ballotData!!.choiceList[index].name)
+            assertEquals(value.order, actual.ballotData!!.choiceList[index].order)
+            assertContentEquals(value.ballotDataChoiceResults, actual.ballotData!!.choiceList[index].ballotDataChoiceResults)
+            assertEquals(value.totalVotes, actual.ballotData!!.choiceList[index].totalVotes)
+        }
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessageTest.kt
new file mode 100644
index 00000000..101d0857
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessageTest.kt
@@ -0,0 +1,207 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.ballot
+
+import ch.threema.domain.models.MessageId
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.protobuf.d2d.incomingMessage
+import ch.threema.testutils.willThrow
+import com.google.protobuf.kotlin.toByteString
+import org.junit.Test
+import kotlin.test.assertEquals
+import kotlin.test.fail
+
+open class PollVoteMessageTest {
+
+    private val pollVoteMessage = PollVoteMessage().apply {
+        ballotId = BallotId()
+        ballotCreatorIdentity = "01234567"
+        addVotes(
+            listOf(
+                BallotVote(2, 8),
+                BallotVote(3, 5),
+                BallotVote(4, 1)
+            )
+        )
+    }
+
+    private val pollVoteMessageBody: ByteArray = pollVoteMessage.body!!
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthTooShort() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollVoteMessage.fromByteArray(
+                data = pollVoteMessageBody,
+                offset = 0,
+                length = 0,
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetBelowZero() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollVoteMessage.fromByteArray(
+                data = pollVoteMessageBody,
+                offset = -1,
+                length = 64,
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLength() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollVoteMessage.fromByteArray(
+                data = pollVoteMessageBody,
+                offset = 0,
+                length = pollVoteMessageBody.size + 1
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLengthWithOffset() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            PollVoteMessage.fromByteArray(
+                data = pollVoteMessageBody,
+                offset = 1,
+                length = pollVoteMessageBody.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithoutOffset() {
+
+        // act
+        val resultPollVoteMessage = PollVoteMessage.fromByteArray(
+            data = pollVoteMessageBody,
+            offset = 0,
+            length = pollVoteMessageBody.size
+        )
+
+        // assert
+        assertPollVoteMessageContainsCorrectValues(resultPollVoteMessage)
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithOffset() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + pollVoteMessageBody
+
+        // act
+        val resultPollVoteMessage: PollVoteMessage = PollVoteMessage.fromByteArray(
+            data = dataWithOffsetByte,
+            offset = 1,
+            length = pollVoteMessageBody.size
+        )
+
+        // assert
+        assertPollVoteMessageContainsCorrectValues(resultPollVoteMessage)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetNotPassedCorrectly() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + pollVoteMessageBody
+
+        val testBlockLazy = {
+
+            // act
+            PollVoteMessage.fromByteArray(
+                data = dataWithOffsetByte,
+                offset = 0,
+                length = pollVoteMessageBody.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun fromReflectedShouldParseBodyAndSetCommonFields() {
+
+        // act
+        val incomingMessageId = 12345678L
+        val incomingMessageCreatedAt: Long = System.currentTimeMillis()
+        val incomingMessageSenderIdentity = "01234567"
+        val incomingD2DMessage = incomingMessage {
+            this.senderIdentity = incomingMessageSenderIdentity
+            this.messageId = incomingMessageId
+            this.createdAt = incomingMessageCreatedAt
+            this.body = pollVoteMessageBody.toByteString()
+        }
+
+        // act
+        val resultPollVoteMessage: PollVoteMessage = PollVoteMessage.fromReflected(incomingD2DMessage)
+
+        // assert
+        assertEquals(resultPollVoteMessage.messageId, MessageId(incomingMessageId))
+        assertEquals(resultPollVoteMessage.date.time, incomingMessageCreatedAt)
+        assertEquals(resultPollVoteMessage.fromIdentity, incomingMessageSenderIdentity)
+        assertPollVoteMessageContainsCorrectValues(resultPollVoteMessage)
+    }
+
+    private fun assertPollVoteMessageContainsCorrectValues(actual: PollVoteMessage?) {
+        if (actual == null) {
+            fail()
+        }
+        assertEquals(pollVoteMessage.ballotId, actual.ballotId)
+        assertEquals(pollVoteMessage.ballotCreatorIdentity, actual.ballotCreatorIdentity)
+        assertEquals(pollVoteMessage.votes.size, actual.votes.size)
+        pollVoteMessage.votes.forEachIndexed { index, vote ->
+            assertEquals(vote.id, actual.votes[index].id)
+            assertEquals(vote.value, actual.votes[index].value)
+        }
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java
index 9e971a23..9687cd53 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java
@@ -26,6 +26,7 @@ import org.junit.Test;
 
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.coders.MessageBox;
@@ -42,7 +43,7 @@ public class ProtocolTest {
 	@Test
 	public void groupTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
 		//create a new ballot
-		final String myIdentity = "TESTTST";
+		final String myIdentity = "TESTTEST";
 		final String toIdentity = "ABCDEFGH";
 
 		BallotId ballotId = new BallotId(new byte[ProtocolDefines.BALLOT_ID_LEN]);
@@ -57,7 +58,7 @@ public class ProtocolTest {
 		b.setApiGroupId(groupId);
 		b.setGroupCreator(groupCreator);
 		b.setBallotId(ballotId);
-		b.setBallotCreator(ballotCreator);
+		b.setBallotCreatorIdentity(ballotCreator);
 		BallotData data = new BallotData();
 		data.setDescription("Test Ballot");
 		data.setType(BallotData.Type.RESULT_ON_CLOSE);
@@ -75,14 +76,14 @@ public class ProtocolTest {
 			c.setTotalVotes(2);
 			data.getChoiceList().add(c);
 		}
-		b.setData(data);
+		b.setBallotData(data);
 
 		ContactStore contactStore = TestHelpers.getNoopContactStore();
 		IdentityStoreInterface identityStore = TestHelpers.getNoopIdentityStore();
 		NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
 		MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
 
-		MessageBox boxmsg = messageCoder.encode(b, nonceFactory.next(false), nonceFactory);
+		MessageBox boxmsg = messageCoder.encode(b, nonceFactory.nextNonce(NonceScope.CSP));
 		Assert.assertNotNull("BoxMessage failed", boxmsg);
 
 		//now decode again
@@ -92,34 +93,33 @@ public class ProtocolTest {
 
 		GroupPollSetupMessage db = (GroupPollSetupMessage) decodedBoxMessage;
 
-		BallotData d = db.getData();
+		BallotData d = db.getBallotData();
 		Assert.assertNotNull(d);
 
 		Assert.assertEquals(BallotData.State.OPEN,  d.getState());
 		Assert.assertEquals(BallotData.AssessmentType.SINGLE, d.getAssessmentType());
 		Assert.assertEquals(BallotData.Type.RESULT_ON_CLOSE, d.getType());
-		Assert.assertEquals(10, b.getData().getChoiceList().size());
-		Assert.assertEquals("Choice 7", b.getData().getChoiceList().get(6).getName());
-		Assert.assertEquals(1, (int) b.getData().getChoiceList().get(2).getResult(0));
-		Assert.assertEquals(0, (int) b.getData().getChoiceList().get(2).getResult(1));
+		Assert.assertEquals(10, b.getBallotData().getChoiceList().size());
+		Assert.assertEquals("Choice 7", b.getBallotData().getChoiceList().get(6).getName());
+		Assert.assertEquals(1, (int) b.getBallotData().getChoiceList().get(2).getResult(0));
+		Assert.assertEquals(0, (int) b.getBallotData().getChoiceList().get(2).getResult(1));
 	}
 
 
 	@Test
 	public void identityTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
 		//create a new ballot
-		final String myIdentity = "TESTTST";
+		final String myIdentity = "TESTTEST";
 		final String toIdentity = "ABCDEFGH";
 
 		BallotId ballotId = new BallotId(new byte[ProtocolDefines.BALLOT_ID_LEN]);
 		String ballotCreator = toIdentity;
 
-
-		PollSetupMessage b = new PollSetupMessage();
-		b.setFromIdentity(ballotCreator);
-		b.setToIdentity(myIdentity);
-		b.setBallotId(ballotId);
-		b.setBallotCreator(ballotCreator);
+		PollSetupMessage pollSetupMessage = new PollSetupMessage();
+		pollSetupMessage.setFromIdentity(ballotCreator);
+		pollSetupMessage.setToIdentity(myIdentity);
+		pollSetupMessage.setBallotId(ballotId);
+		pollSetupMessage.setBallotCreatorIdentity(ballotCreator);
 		BallotData data = new BallotData();
 		data.setDescription("Test Ballot");
 		data.setType(BallotData.Type.RESULT_ON_CLOSE);
@@ -135,7 +135,7 @@ public class ProtocolTest {
 			c.addResult(0, 1).addResult(1,0);
 			data.getChoiceList().add(c);
 		}
-		b.setData(data);
+		pollSetupMessage.setBallotData(data);
 
 		ContactStore contactStore = TestHelpers.getNoopContactStore();
 		IdentityStoreInterface identityStore = TestHelpers.getNoopIdentityStore();
@@ -143,7 +143,7 @@ public class ProtocolTest {
 
 		NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
 
-		MessageBox boxmsg = messageCoder.encode(b, nonceFactory.next(false), nonceFactory);
+		MessageBox boxmsg = messageCoder.encode(pollSetupMessage, nonceFactory.nextNonce(NonceScope.CSP));
 		Assert.assertNotNull("BoxMessage failed", boxmsg);
 
 		//now decode again
@@ -153,15 +153,15 @@ public class ProtocolTest {
 
 		PollSetupMessage db = (PollSetupMessage) decodedBoxMessage;
 
-		BallotData d = db.getData();
-		Assert.assertNotNull(d);
+		BallotData ballotData = db.getBallotData();
+		Assert.assertNotNull(ballotData);
 
-		Assert.assertEquals(BallotData.State.OPEN,  d.getState());
-		Assert.assertEquals(BallotData.AssessmentType.SINGLE, d.getAssessmentType());
-		Assert.assertEquals(BallotData.Type.RESULT_ON_CLOSE, d.getType());
-		Assert.assertEquals(10, b.getData().getChoiceList().size());
-		Assert.assertEquals("Choice 7", b.getData().getChoiceList().get(6).getName());
-		Assert.assertEquals(1, (int) b.getData().getChoiceList().get(2).getResult(0));
-		Assert.assertEquals(0, (int) b.getData().getChoiceList().get(2).getResult(1));
+		Assert.assertEquals(BallotData.State.OPEN,  ballotData.getState());
+		Assert.assertEquals(BallotData.AssessmentType.SINGLE, ballotData.getAssessmentType());
+		Assert.assertEquals(BallotData.Type.RESULT_ON_CLOSE, ballotData.getType());
+		Assert.assertEquals(10, pollSetupMessage.getBallotData().getChoiceList().size());
+		Assert.assertEquals("Choice 7", pollSetupMessage.getBallotData().getChoiceList().get(6).getName());
+		Assert.assertEquals(1, (int) pollSetupMessage.getBallotData().getChoiceList().get(2).getResult(0));
+		Assert.assertEquals(0, (int) pollSetupMessage.getBallotData().getChoiceList().get(2).getResult(1));
 	}
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/FileMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/FileMessageTest.kt
new file mode 100644
index 00000000..f71106b1
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/FileMessageTest.kt
@@ -0,0 +1,205 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.file
+
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.testutils.willThrow
+import org.junit.Test
+import java.io.ByteArrayOutputStream
+import kotlin.test.assertContentEquals
+import kotlin.test.assertEquals
+
+open class FileMessageTest {
+
+    private val bytesEncryptionKey: ByteArray = "3415ea32b2ca51e73c670454f9abfbe5".toByteArray()
+    private val bytesBlobIdContent: ByteArray = "126e82deb67b783c".toByteArray()
+    private val bytesBlobIdThumbnail: ByteArray = "2ea7f8501da14be9".toByteArray()
+
+    private val fileData = FileData()
+        .apply {
+            setEncryptionKey(bytesEncryptionKey)
+            setFileBlobId(bytesBlobIdContent)
+            setMimeType("image/jpg")
+            setThumbnailBlobId(bytesBlobIdThumbnail)
+            setThumbnailMimeType("image/jpg")
+            setFileName("group_file_message_text_picture.jpg")
+            setFileSize(1_000L)
+            setRenderingType(FileData.RENDERING_MEDIA)
+            setCaption("Cool group image file!")
+            setCorrelationId("1234567890")
+            setMetaData(
+                mapOf(
+                    "lat" to "secret",
+                    "lng" to "secret",
+                    "hour" to 8,
+                    "minute" to 30
+                )
+            )
+        }
+
+    private val bytesFileData = fileData.let { fileData ->
+        ByteArrayOutputStream().also(fileData::write)
+    }.toByteArray()
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthTooShort() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            FileMessage.fromByteArray(
+                data = bytesFileData,
+                offset = 0,
+                length = 0
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetBelowZero() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            FileMessage.fromByteArray(
+                data = bytesFileData,
+                offset = -1,
+                length = 64
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLength() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            FileMessage.fromByteArray(
+                data = bytesFileData,
+                offset = 0,
+                length = bytesFileData.size + 1
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLengthWithOffset() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            FileMessage.fromByteArray(
+                data = bytesFileData,
+                offset = 1,
+                length = bytesFileData.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithoutOffset() {
+
+        // act
+        val resultFileMessage = FileMessage.fromByteArray(
+            data = bytesFileData,
+            offset = 0,
+            length = bytesFileData.size
+        )
+
+        // assert
+        assertFileDataEquals(fileData, resultFileMessage.fileData)
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithOffset() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + bytesFileData
+
+        // act
+        val resultFileMessage = FileMessage.fromByteArray(
+            data = dataWithOffsetByte,
+            offset = 1,
+            length = bytesFileData.size
+        )
+
+        // assert
+        assertFileDataEquals(fileData, resultFileMessage.fileData)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetNotPassedCorrectly() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + bytesFileData
+
+        val testBlockLazy = {
+
+            // act
+            FileMessage.fromByteArray(
+                data = dataWithOffsetByte,
+                offset = 0,
+                length = bytesFileData.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    private fun assertFileDataEquals(expected: FileData, actual: FileData?) {
+        if (actual == null) {
+            assertEquals(expected, null as FileData?)
+            return
+        }
+        assertContentEquals(fileData.encryptionKey, actual.encryptionKey)
+        assertContentEquals(fileData.fileBlobId, actual.fileBlobId)
+        assertEquals(fileData.mimeType, actual.mimeType)
+        assertContentEquals(fileData.thumbnailBlobId, actual.thumbnailBlobId)
+        assertEquals(fileData.thumbnailMimeType, actual.thumbnailMimeType)
+        assertEquals(fileData.fileName, actual.fileName)
+        assertEquals(fileData.fileSize, actual.fileSize)
+        assertEquals(fileData.renderingType, actual.renderingType)
+        assertEquals(fileData.caption, actual.caption)
+        assertEquals(fileData.correlationId, actual.correlationId)
+        assertEquals(fileData.metaData.size, actual.metaData.size)
+        fileData.metaData.forEach { (key, value) ->
+            assertEquals(value, actual.metaData[key])
+        }
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessageTest.kt
new file mode 100644
index 00000000..53820406
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessageTest.kt
@@ -0,0 +1,243 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.file
+
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.testutils.willThrow
+import org.junit.Test
+import java.io.ByteArrayOutputStream
+import kotlin.test.assertContentEquals
+import kotlin.test.assertEquals
+
+open class GroupFileMessageTest {
+
+    /**
+     *  A group file message in the raw form consists of bytes in the following order:
+     *
+     *  (creator identity bytes (8)) + (api groupId bytes (8)) + ([FileData] bytes (*))
+     */
+
+    private val bytesCreatorIdentity: ByteArray = "9e979235".toByteArray()
+    private val bytesApiGroupId: ByteArray = "fdc34493".toByteArray()
+
+    private val bytesEncryptionKey: ByteArray = "3415ea32b2ca51e73c670454f9abfbe5".toByteArray()
+    private val bytesBlobIdContent: ByteArray = "126e82deb67b783c".toByteArray()
+    private val bytesBlobIdThumbnail: ByteArray = "2ea7f8501da14be9".toByteArray()
+
+    private val fileData = FileData()
+        .apply {
+            setEncryptionKey(bytesEncryptionKey)
+            setFileBlobId(bytesBlobIdContent)
+            setMimeType("image/jpg")
+            setThumbnailBlobId(bytesBlobIdThumbnail)
+            setThumbnailMimeType("image/jpg")
+            setFileName("group_file_message_text_picture.jpg")
+            setFileSize(1_000L)
+            setRenderingType(FileData.RENDERING_MEDIA)
+            setCaption("Cool group image file!")
+            setCorrelationId("1234567890")
+            setMetaData(
+                mapOf(
+                    "lat" to "secret",
+                    "lng" to "secret",
+                    "hour" to 8,
+                    "minute" to 30
+                )
+            )
+        }
+
+    private val bytesFileData = fileData.let { fileData ->
+        ByteArrayOutputStream().also(fileData::write)
+    }.toByteArray()
+
+    private val groupFileMessageBytes = bytesCreatorIdentity + bytesApiGroupId + bytesFileData
+
+    /**
+     *  creator identity length = *8*, api groupId length = *8*
+     */
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthBelowIdentityAndGroupIdLength() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupFileMessage.fromByteArray(
+                data = groupFileMessageBytes,
+                offset = 0,
+                length = 10
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    /**
+     *  creator identity length = *8*, api groupId length = *8*
+     */
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthEqualsIdentityAndGroupIdLength() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupFileMessage.fromByteArray(
+                data = groupFileMessageBytes,
+                offset = 0,
+                length = 16
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetBelowZero() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupFileMessage.fromByteArray(
+                data = groupFileMessageBytes,
+                offset = -1,
+                length = 64
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLength() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupFileMessage.fromByteArray(
+                data = groupFileMessageBytes,
+                offset = 0,
+                length = groupFileMessageBytes.size + 1
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLengthWithOffset() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupFileMessage.fromByteArray(
+                data = groupFileMessageBytes,
+                offset = 1,
+                length = groupFileMessageBytes.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithoutOffset() {
+
+        // act
+        val resultGroupFileMessage = GroupFileMessage.fromByteArray(
+            data = groupFileMessageBytes,
+            offset = 0,
+            length = groupFileMessageBytes.size
+        )
+
+        // assert
+        assertEquals(bytesCreatorIdentity.toString(Charsets.UTF_8), resultGroupFileMessage.groupCreator)
+        assertContentEquals(bytesApiGroupId, resultGroupFileMessage.apiGroupId.groupId)
+        assertFileDataEquals(fileData, resultGroupFileMessage.fileData)
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithOffset() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + groupFileMessageBytes
+
+        // act
+        val resultGroupFileMessage = GroupFileMessage.fromByteArray(
+            data = dataWithOffsetByte,
+            offset = 1,
+            length = groupFileMessageBytes.size
+        )
+
+        // assert
+        assertEquals(bytesCreatorIdentity.toString(Charsets.UTF_8), resultGroupFileMessage.groupCreator)
+        assertContentEquals(bytesApiGroupId, resultGroupFileMessage.apiGroupId.groupId)
+        assertFileDataEquals(fileData, resultGroupFileMessage.fileData)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetNotPassedCorrectly() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + groupFileMessageBytes
+
+        val testBlockLazy = {
+
+            // act
+            GroupFileMessage.fromByteArray(
+                data = dataWithOffsetByte,
+                offset = 0,
+                length = groupFileMessageBytes.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    private fun assertFileDataEquals(expected: FileData, actual: FileData?) {
+        if (actual == null) {
+            assertEquals(expected, null as FileData?)
+            return
+        }
+        assertContentEquals(fileData.encryptionKey, actual.encryptionKey)
+        assertContentEquals(fileData.fileBlobId, actual.fileBlobId)
+        assertEquals(fileData.mimeType, actual.mimeType)
+        assertContentEquals(fileData.thumbnailBlobId, actual.thumbnailBlobId)
+        assertEquals(fileData.thumbnailMimeType, actual.thumbnailMimeType)
+        assertEquals(fileData.fileName, actual.fileName)
+        assertEquals(fileData.fileSize, actual.fileSize)
+        assertEquals(fileData.renderingType, actual.renderingType)
+        assertEquals(fileData.caption, actual.caption)
+        assertEquals(fileData.correlationId, actual.correlationId)
+        assertEquals(fileData.metaData.size, actual.metaData.size)
+        fileData.metaData.forEach { (key, value) ->
+            assertEquals(value, actual.metaData[key])
+        }
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java
index 15ed65f6..561a114b 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java
@@ -26,15 +26,12 @@ import androidx.annotation.NonNull;
 import org.junit.Assert;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
-import ch.threema.base.crypto.NonceStore;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
@@ -45,220 +42,200 @@ import ch.threema.domain.protocol.csp.messages.BadMessageException;
 import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 import ch.threema.domain.stores.ContactStore;
 import ch.threema.domain.stores.IdentityStoreInterface;
+import ch.threema.domain.testhelpers.TestHelpers;
 
 public class ProtocolTest {
 
-	/**
-	 * Encrypt a file for a group.
-	 */
-	@Test
-	public void groupTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
-		//create a new file message
-		final String myIdentity = "TESTTEST";
-		final String toIdentity = "ABCDEFGH";
-
-		byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
-
-		GroupId groupId = new GroupId(new byte[ProtocolDefines.GROUP_ID_LEN]);
-		String groupCreator = myIdentity;
-
-		GroupFileMessage groupFileMessage = new GroupFileMessage();
-		groupFileMessage.setFromIdentity(toIdentity);
-		groupFileMessage.setToIdentity(myIdentity);
-		groupFileMessage.setApiGroupId(groupId);
-		groupFileMessage.setGroupCreator(groupCreator);
-		FileData data = new FileData();
-		data
-				.setFileBlobId(blobIdFile)
-				.setThumbnailBlobId(blobIdThumbnail)
-				.setEncryptionKey(key)
-				.setMimeType("image/jpg")
-				.setFileName("therme.jpg")
-				.setFileSize(123)
-				.setRenderingType(FileData.RENDERING_DEFAULT);
-		groupFileMessage.setData(data);
-
-		ContactStore contactStore = createFakeContactStore();
-		IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
-		MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
-
-		NonceFactory nonceFactory = new NonceFactory(new NonceStore() {
-			@Override
-			public boolean exists(@NonNull byte[] nonce) {
-				return false;
-			}
-
-			@Override
-			public boolean store(@NonNull byte[] nonce) {
-				return true;
-			}
-
-			@NonNull
-			@Override
-			public List<byte[]> getAllHashedNonces() {
-				return Collections.emptyList();
-			}
-		});
-
-		MessageBox boxmsg = messageCoder.encode(groupFileMessage, nonceFactory.next(false), nonceFactory);
-		Assert.assertNotNull("BoxMessage failed", boxmsg);
-
-		//now decode again
-		AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
-		Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
-		Assert.assertTrue(decodedBoxMessage instanceof GroupFileMessage);
-
-		GroupFileMessage groupFileMessageDecoded = (GroupFileMessage)decodedBoxMessage;
-		FileData fileData = groupFileMessageDecoded.getData();
-		Assert.assertNotNull(fileData);
-
-		Assert.assertArrayEquals(blobIdFile, fileData.getFileBlobId());
-		Assert.assertArrayEquals(blobIdThumbnail, fileData.getThumbnailBlobId());
-		Assert.assertArrayEquals(key, fileData.getEncryptionKey());
-		Assert.assertEquals("image/jpg", fileData.getMimeType());
-		Assert.assertEquals("therme.jpg", fileData.getFileName());
-		Assert.assertEquals(123, fileData.getFileSize());
-		Assert.assertEquals(FileData.RENDERING_DEFAULT, fileData.getRenderingType());
-	}
-
-	@Test
-	public void identityTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
-		//create a new file message
-		final String myIdentity = "TESTTEST";
-		final String toIdentity = "ABCDEFGH";
-
-		byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
-
-		FileMessage fileMessage = new FileMessage();
-		fileMessage.setFromIdentity(toIdentity);
-		fileMessage.setToIdentity(myIdentity);
-		FileData data = new FileData();
-		data
-				.setFileBlobId(blobIdFile)
-				.setThumbnailBlobId(blobIdThumbnail)
-				.setEncryptionKey(key)
-				.setMimeType("image/jpg")
-				.setFileName("therme.jpg")
-				.setFileSize(123)
-				.setRenderingType(FileData.RENDERING_MEDIA);
-		fileMessage.setData(data);
-
-		ContactStore contactStore = createFakeContactStore();
-		IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
-		MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
-
-		NonceFactory nonceFactory = new NonceFactory(new NonceStore() {
-			@Override
-			public boolean exists(@NonNull byte[] nonce) {
-				return false;
-			}
-
-			@Override
-			public boolean store(@NonNull byte[] nonce) {
-				return true;
-			}
-
-			@NonNull
-			@Override
-			public List<byte[]> getAllHashedNonces() {
-				return Collections.emptyList();
-			}
-		});
-
-		MessageBox boxmsg = messageCoder.encode(fileMessage, nonceFactory.next(false), nonceFactory);
-		Assert.assertNotNull("BoxMessage failed", boxmsg);
-
-		//now decode again
-		AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
-		Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
-		Assert.assertTrue(decodedBoxMessage instanceof FileMessage);
-
-		FileMessage fileMessageDecoded = (FileMessage)decodedBoxMessage;
-		FileData fileData = fileMessageDecoded.getData();
-		Assert.assertNotNull(fileData);
-
-		Assert.assertTrue(Arrays.equals(blobIdFile, fileData.getFileBlobId()));
-		Assert.assertTrue(Arrays.equals(blobIdThumbnail, fileData.getThumbnailBlobId()));
-		Assert.assertTrue(Arrays.equals(key, fileData.getEncryptionKey()));
-		Assert.assertEquals("image/jpg", fileData.getMimeType());
-		Assert.assertEquals("therme.jpg", fileData.getFileName());
-		Assert.assertEquals(123, fileData.getFileSize());
-		Assert.assertEquals(FileData.RENDERING_MEDIA, fileData.getRenderingType());
-	}
-
-	private static ContactStore createFakeContactStore() {
-		return new ContactStore() {
-			@Override
-			public void addCachedContact(@NonNull Contact contact) { }
-
-			@Nullable
-			@Override
-			public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
-				return getContactForIdentity(identity);
-			}
-
-			@Override
-			public Contact getContactForIdentity(@NonNull String identity) {
-				return new Contact(identity, new byte[256], VerificationLevel.UNVERIFIED);
-			}
-
-			@Override
-			public void addContact(@NonNull Contact contact) { }
-
-			@Override
-			public void removeContact(@NonNull Contact contact) { }
-		};
-	}
-
-	private static IdentityStoreInterface createFakeIdentityStore(final String myIdentity) {
-		return new IdentityStoreInterface() {
-			@Override
-			public byte[] encryptData(byte[] plaintext, byte[] nonce, byte[] receiverPublicKey) {
-				return plaintext;
-			}
-
-			@Override
-			public byte[] decryptData(byte[] ciphertext, byte[] nonce, byte[] senderPublicKey) {
-				return ciphertext;
-			}
-
-			@Override
-			public byte[] calcSharedSecret(@NonNull byte[] publicKey) {
-				return new byte[32];
-			}
-
-			@Override
-			public String getIdentity() {
-				return myIdentity;
-			}
-
-			@Override
-			public String getServerGroup() {
-				return null;
-			}
-
-			@Override
-			public byte[] getPublicKey() {
-				return new byte[256];
-			}
-
-			@Override
-			public byte[] getPrivateKey() {
-				return new byte[32];
-			}
-
-			@Override
-			@NonNull
-			public String getPublicNickname() {
-				return "";
-			}
-
-			@Override
-			public void storeIdentity(String identity, String serverGroup, byte[] publicKey, byte[] privateKey) { }
-		};
-	}
+    /**
+     * Encrypt a file for a group.
+     */
+    @Test
+    public void groupTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
+        //create a new file message
+        final String myIdentity = "TESTTEST";
+        final String toIdentity = "ABCDEFGH";
+
+        byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
+
+        GroupId groupId = new GroupId(new byte[ProtocolDefines.GROUP_ID_LEN]);
+        String groupCreator = myIdentity;
+
+        GroupFileMessage groupFileMessage = new GroupFileMessage();
+        groupFileMessage.setFromIdentity(toIdentity);
+        groupFileMessage.setToIdentity(myIdentity);
+        groupFileMessage.setApiGroupId(groupId);
+        groupFileMessage.setGroupCreator(groupCreator);
+        FileData data = new FileData();
+        data
+            .setFileBlobId(blobIdFile)
+            .setThumbnailBlobId(blobIdThumbnail)
+            .setEncryptionKey(key)
+            .setMimeType("image/jpg")
+            .setFileName("therme.jpg")
+            .setFileSize(123)
+            .setRenderingType(FileData.RENDERING_DEFAULT);
+        groupFileMessage.setFileData(data);
+
+        ContactStore contactStore = createFakeContactStore();
+        IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
+        MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
+
+        NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
+
+        MessageBox boxmsg = messageCoder.encode(groupFileMessage, nonceFactory.nextNonce(NonceScope.CSP));
+        Assert.assertNotNull("BoxMessage failed", boxmsg);
+
+        //now decode again
+        AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
+        Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
+        Assert.assertTrue(decodedBoxMessage instanceof GroupFileMessage);
+
+        GroupFileMessage groupFileMessageDecoded = (GroupFileMessage) decodedBoxMessage;
+        FileData fileData = groupFileMessageDecoded.getFileData();
+        Assert.assertNotNull(fileData);
+
+        Assert.assertArrayEquals(blobIdFile, fileData.getFileBlobId());
+        Assert.assertArrayEquals(blobIdThumbnail, fileData.getThumbnailBlobId());
+        Assert.assertArrayEquals(key, fileData.getEncryptionKey());
+        Assert.assertEquals("image/jpg", fileData.getMimeType());
+        Assert.assertEquals("therme.jpg", fileData.getFileName());
+        Assert.assertEquals(123, fileData.getFileSize());
+        Assert.assertEquals(FileData.RENDERING_DEFAULT, fileData.getRenderingType());
+    }
+
+    @Test
+    public void identityTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
+        //create a new file message
+        final String myIdentity = "TESTTEST";
+        final String toIdentity = "ABCDEFGH";
+
+        byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
+
+        FileMessage fileMessage = new FileMessage();
+        fileMessage.setFromIdentity(toIdentity);
+        fileMessage.setToIdentity(myIdentity);
+        FileData data = new FileData();
+        data
+            .setFileBlobId(blobIdFile)
+            .setThumbnailBlobId(blobIdThumbnail)
+            .setEncryptionKey(key)
+            .setMimeType("image/jpg")
+            .setFileName("therme.jpg")
+            .setFileSize(123)
+            .setRenderingType(FileData.RENDERING_MEDIA);
+        fileMessage.setFileData(data);
+
+        ContactStore contactStore = createFakeContactStore();
+        IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
+        MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
+
+        NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
+
+        MessageBox boxmsg = messageCoder.encode(fileMessage, nonceFactory.nextNonce(NonceScope.CSP));
+        Assert.assertNotNull("BoxMessage failed", boxmsg);
+
+        //now decode again
+        AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
+        Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
+        Assert.assertTrue(decodedBoxMessage instanceof FileMessage);
+
+        FileMessage fileMessageDecoded = (FileMessage) decodedBoxMessage;
+        FileData fileData = fileMessageDecoded.getFileData();
+        Assert.assertNotNull(fileData);
+
+        Assert.assertArrayEquals(blobIdFile, fileData.getFileBlobId());
+        Assert.assertArrayEquals(blobIdThumbnail, fileData.getThumbnailBlobId());
+        Assert.assertArrayEquals(key, fileData.getEncryptionKey());
+        Assert.assertEquals("image/jpg", fileData.getMimeType());
+        Assert.assertEquals("therme.jpg", fileData.getFileName());
+        Assert.assertEquals(123, fileData.getFileSize());
+        Assert.assertEquals(FileData.RENDERING_MEDIA, fileData.getRenderingType());
+    }
+
+    private static ContactStore createFakeContactStore() {
+        return new ContactStore() {
+            @Override
+            public void addCachedContact(@NonNull BasicContact contact) {
+            }
+
+            @Nullable
+            @Override
+            public BasicContact getCachedContact(@NonNull String identity) {
+                return null;
+            }
+
+            @NonNull
+            @Override
+            public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
+                return getContactForIdentity(identity);
+            }
+
+            @Override
+            public Contact getContactForIdentity(@NonNull String identity) {
+                return new Contact(identity, new byte[256], VerificationLevel.UNVERIFIED);
+            }
+
+            @Override
+            public void addContact(@NonNull Contact contact) {
+            }
+
+            @Override
+            public boolean isSpecialContact(@NonNull String identity) {
+                return false;
+            }
+        };
+    }
+
+    private static IdentityStoreInterface createFakeIdentityStore(final String myIdentity) {
+        return new IdentityStoreInterface() {
+            @Override
+            public byte[] encryptData(@NonNull byte[] plaintext, @NonNull byte[] nonce, @NonNull byte[] receiverPublicKey) {
+                return plaintext;
+            }
+
+            @Override
+            public byte[] decryptData(@NonNull byte[] ciphertext, @NonNull byte[] nonce, @NonNull byte[] senderPublicKey) {
+                return ciphertext;
+            }
+
+            @Override
+            public byte[] calcSharedSecret(@NonNull byte[] publicKey) {
+                return new byte[32];
+            }
+
+            @Override
+            public String getIdentity() {
+                return myIdentity;
+            }
+
+            @Override
+            public String getServerGroup() {
+                return null;
+            }
+
+            @Override
+            public byte[] getPublicKey() {
+                return new byte[256];
+            }
+
+            @Override
+            public byte[] getPrivateKey() {
+                return new byte[32];
+            }
+
+            @Override
+            @NonNull
+            public String getPublicNickname() {
+                return "";
+            }
+
+            @Override
+            public void storeIdentity(@NonNull String identity, @NonNull String serverGroup, @NonNull byte[] publicKey, @NonNull byte[] privateKey) {
+            }
+        };
+    }
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java
index 39da698f..c4acac5d 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java
@@ -32,7 +32,7 @@ import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 
 import static ch.threema.domain.testhelpers.TestHelpers.boxMessage;
 import static ch.threema.domain.testhelpers.TestHelpers.decodeMessageFromBox;
-import static ch.threema.domain.testhelpers.TestHelpers.setMessageDefaults;
+import static ch.threema.domain.testhelpers.TestHelpers.setMessageDefaultSenderAndReceiver;
 
 public class ForwardSecurityMessageTest {
 
@@ -42,7 +42,7 @@ public class ForwardSecurityMessageTest {
 
 	private static ForwardSecurityEnvelopeMessage getEnvelopeMessageTestInstance() {
 		final ForwardSecurityEnvelopeMessage msg = new ForwardSecurityEnvelopeMessage(getDataTestInstance(), true);
-		setMessageDefaults(msg);
+		setMessageDefaultSenderAndReceiver(msg);
 		return msg;
 	}
 
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java
index dde0587d..515a11ca 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java
@@ -43,7 +43,7 @@ public class GroupJoinRequestMessageTest {
 	}
 	static GroupJoinRequestMessage getMessageTestInstance() throws BadMessageException {
 		final GroupJoinRequestMessage msg = new GroupJoinRequestMessage(getDataTestInstance());
-		setMessageDefaults(msg);
+		setMessageDefaultSenderAndReceiver(msg);
 		return msg;
 	}
 
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java
index 04ba232f..47987ca8 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java
@@ -42,7 +42,7 @@ public class GroupJoinResponseMessageTest {
 	}
 	static GroupJoinResponseMessage getMessageTestInstance() throws BadMessageException {
 		final GroupJoinResponseMessage msg = new GroupJoinResponseMessage(getDataTestInstance());
-		setMessageDefaults(msg);
+		setMessageDefaultSenderAndReceiver(msg);
 		return msg;
 	}
 
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessageTest.kt b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessageTest.kt
new file mode 100644
index 00000000..92bd765d
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessageTest.kt
@@ -0,0 +1,266 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.csp.messages.groupcall
+
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage
+import ch.threema.protobuf.d2d.incomingMessage
+import ch.threema.protobuf.d2d.outgoingMessage
+import ch.threema.testutils.willThrow
+import com.google.protobuf.kotlin.toByteString
+import org.junit.Test
+import java.io.ByteArrayOutputStream
+import kotlin.random.Random.Default.nextBytes
+import kotlin.test.assertContentEquals
+import kotlin.test.assertEquals
+
+class GroupCallStartMessageTest {
+
+    private val groupCreatorIdentityTest = "01234567"
+    private val apiGroupIdTest = nextBytes(ProtocolDefines.GROUP_ID_LEN)
+
+    private val protocolVersionTest = 1.toUInt()
+    private val gckTest = nextBytes(GroupCallStartData.GCK_LENGTH)
+    private val sfuBaseUrlTest = "https://sfu.test.threema.ch"
+
+    private val groupCallStartData = GroupCallStartData(
+        protocolVersion = protocolVersionTest,
+        gck = gckTest,
+        sfuBaseUrl = sfuBaseUrlTest
+    )
+
+    private val groupCallStartMessage = GroupCallStartMessage(groupCallStartData).apply {
+        this.groupCreator = groupCreatorIdentityTest
+        this.apiGroupId = GroupId(apiGroupIdTest)
+    }
+
+    private val bytesGroupCallStartMessage = ByteArrayOutputStream().also { bos ->
+        bos.write(groupCallStartMessage.body)
+    }.toByteArray()
+
+    /**
+     *  creator identity length = *8*, api groupId length = *8*
+     */
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthBelowIdentityAndGroupIdLength() {
+
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupCallStartMessage.fromByteArray(
+                data = bytesGroupCallStartMessage,
+                offset = 0,
+                length = 10
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    /**
+     *  creator identity length = *8*, api groupId length = *8*
+     */
+    @Test
+    fun shouldThrowBadMessageExceptionWhenLengthEqualsIdentityAndGroupIdLength() {
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupCallStartMessage.fromByteArray(
+                data = bytesGroupCallStartMessage,
+                offset = 0,
+                length = 16
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetBelowZero() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupCallStartMessage.fromByteArray(
+                data = bytesGroupCallStartMessage,
+                offset = -1,
+                length = 64
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLength() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupCallStartMessage.fromByteArray(
+                data = bytesGroupCallStartMessage,
+                offset = 0,
+                length = bytesGroupCallStartMessage.size + 1
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenDataIsShorterThanPassedLengthWithOffset() {
+
+        // arrange
+        val testBlockLazy = {
+
+            // act
+            GroupCallStartMessage.fromByteArray(
+                data = bytesGroupCallStartMessage,
+                offset = 1,
+                length = bytesGroupCallStartMessage.size
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithoutOffset() {
+
+        // act
+        val resultGroupCallStartMessage = GroupCallStartMessage.fromByteArray(
+            data = bytesGroupCallStartMessage,
+            offset = 0,
+            length = bytesGroupCallStartMessage.size
+        )
+
+        // assert
+        assertEquals(groupCreatorIdentityTest, resultGroupCallStartMessage.groupCreator)
+        assertContentEquals(apiGroupIdTest, resultGroupCallStartMessage.apiGroupId.groupId)
+        assertEquals(groupCallStartData, resultGroupCallStartMessage.data)
+    }
+
+    @Test
+    fun shouldDecodeCorrectValuesWithOffset() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + bytesGroupCallStartMessage
+
+        // act
+        val resultGroupCallStartMessage = GroupCallStartMessage.fromByteArray(
+            data = dataWithOffsetByte,
+            offset = 1,
+            length = dataWithOffsetByte.size - 1
+        )
+
+        // assert
+        assertEquals(groupCreatorIdentityTest, resultGroupCallStartMessage.groupCreator)
+        assertContentEquals(apiGroupIdTest, resultGroupCallStartMessage.apiGroupId.groupId)
+        assertEquals(groupCallStartData, resultGroupCallStartMessage.data)
+    }
+
+    @Test
+    fun shouldThrowBadMessageExceptionWhenOffsetNotPassedCorrectly() {
+
+        // arrange
+        val dataWithOffsetByte = byteArrayOf(0.toByte()) + bytesGroupCallStartMessage
+
+        val testBlockLazy = {
+
+            // act
+            GroupFileMessage.fromByteArray(
+                data = dataWithOffsetByte,
+                offset = 0,
+                length = dataWithOffsetByte.size - 1
+            )
+        }
+
+        // assert
+        testBlockLazy willThrow BadMessageException::class
+    }
+
+    @Test
+    fun fromReflectedIncomingShouldParseBodyAndSetCommonMessageProperties() {
+
+        // arrange
+        val incomingMessageId = 12345678L
+        val incomingMessageCreatedAt: Long = System.currentTimeMillis()
+        val incomingMessageSenderIdentity = "01234567"
+        val incomingD2DMessage = incomingMessage {
+            this.senderIdentity = incomingMessageSenderIdentity
+            this.messageId = incomingMessageId
+            this.createdAt = incomingMessageCreatedAt
+            this.body = bytesGroupCallStartMessage.toByteString()
+        }
+
+        // act
+        val resultGroupCallStartMessage = GroupCallStartMessage.fromReflected(incomingD2DMessage)
+
+        // assert
+        assertEquals(incomingMessageId, resultGroupCallStartMessage.messageId.messageIdLong)
+        assertEquals(incomingMessageCreatedAt, resultGroupCallStartMessage.date.time)
+        assertEquals(incomingMessageSenderIdentity, resultGroupCallStartMessage.fromIdentity)
+        assertEquals(groupCreatorIdentityTest, resultGroupCallStartMessage.groupCreator)
+        assertContentEquals(apiGroupIdTest, resultGroupCallStartMessage.apiGroupId.groupId)
+        assertEquals(groupCallStartData, resultGroupCallStartMessage.data)
+    }
+
+    @Test
+    fun fromReflectedOutgoingShouldParseBodyAndSetCommonMessageProperties() {
+
+        // arrange
+        val outgoingMessageId = 12345678L
+        val outgoingMessageCreatedAt: Long = System.currentTimeMillis()
+        val outgoingMessageSenderIdentity = "01234567"
+        val outgoingD2DMessage = outgoingMessage {
+            this.messageId = outgoingMessageId
+            this.createdAt = outgoingMessageCreatedAt
+            this.body = bytesGroupCallStartMessage.toByteString()
+        }
+
+        // act
+        val resultGroupCallStartMessage = GroupCallStartMessage.fromReflected(
+            message = outgoingD2DMessage,
+            ownIdentity = outgoingMessageSenderIdentity
+        )
+
+        // assert
+        assertEquals(outgoingMessageId, resultGroupCallStartMessage.messageId.messageIdLong)
+        assertEquals(outgoingMessageCreatedAt, resultGroupCallStartMessage.date.time)
+        assertEquals(outgoingMessageSenderIdentity, resultGroupCallStartMessage.fromIdentity)
+        assertEquals(groupCreatorIdentityTest, resultGroupCallStartMessage.groupCreator)
+        assertContentEquals(apiGroupIdTest, resultGroupCallStartMessage.apiGroupId.groupId)
+        assertEquals(groupCallStartData, resultGroupCallStartMessage.data)
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java
index e90994fb..56cfd733 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java
@@ -79,6 +79,11 @@ public class AbstractProtobufMessageTest {
 					return false;
 				}
 
+				@Override
+				public boolean reflectSentUpdate() {
+					return false;
+				}
+
 				@Override
 				public boolean sendAutomaticDeliveryReceipt() {
 					return false;
diff --git a/domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt b/domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt
index 1b95edf8..359aed73 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt
+++ b/domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt
@@ -22,6 +22,10 @@
 package ch.threema.domain.protocol.multidevice
 
 import ch.threema.base.utils.Utils
+import ch.threema.domain.protocol.connection.data.D2dMessage
+import ch.threema.protobuf.d2d.MdD2D.TransactionScope
+import ch.threema.protobuf.d2d.transactionScope
+import com.neilalexander.jnacl.NaCl
 import org.junit.Assert.*
 import org.junit.Test
 
@@ -52,7 +56,6 @@ class MultiDeviceKeysTest {
         private val DGTSK3 = Utils.hexStringToByteArray("7ab0a7c3239323e1b9f697eb59196d888747f027df356a305f58f55ebb8c23aa")
     }
 
-
     @Test
     fun testKeyDerivationDgk1() {
         val keys = MultiDeviceKeys(DGK1)
@@ -85,4 +88,68 @@ class MultiDeviceKeysTest {
         assertArrayEquals(DGSDDK3, keys.dgsddk)
         assertArrayEquals(DGTSK3, keys.dgtsk)
     }
+
+    @Test
+    fun testEncryptDecryptDeviceInfo() {
+        val keys = MultiDeviceKeys(DGK1)
+        val deviceInfo = D2dMessage.DeviceInfo(
+            D2dMessage.DeviceInfo.Platform.ANDROID,
+            "Unit Test",
+            "1.2.3",
+            "Test Client"
+        )
+
+        val encrypted = keys.encryptDeviceInfo(deviceInfo)
+        val decrypted = keys.decryptDeviceInfo(encrypted)
+        assertEquals(deviceInfo, decrypted)
+    }
+
+    @Test
+    fun testEncryptTransactionScope() {
+        val keys = MultiDeviceKeys(DGK1)
+
+        listOf(
+            // TODO(ANDR-2699): This leads to an empty array which can not be encrypted at the moment
+            // TransactionScope.Scope.USER_PROFILE_SYNC,
+            TransactionScope.Scope.CONTACT_SYNC,
+            TransactionScope.Scope.GROUP_SYNC,
+            TransactionScope.Scope.DISTRIBUTION_LIST_SYNC,
+            TransactionScope.Scope.SETTINGS_SYNC,
+            TransactionScope.Scope.MDM_PARAMETER_SYNC,
+            TransactionScope.Scope.NEW_DEVICE_SYNC
+        ).forEach {
+            val expected = transactionScope {
+                scope = it
+            }
+            val encrypted = keys.encryptTransactionScope(it)
+            val nonce = encrypted.copyOfRange(0, NaCl.NONCEBYTES)
+            val data = encrypted.copyOfRange(NaCl.NONCEBYTES, encrypted.size)
+            val decrypted = NaCl.symmetricDecryptData(data, keys.dgtsk, nonce)
+            assertEquals(expected, TransactionScope.parseFrom(decrypted))
+        }
+    }
+
+    @Test
+    fun testDecryptTransactionScope() {
+        val keys = MultiDeviceKeys(DGK1)
+
+        listOf(
+            // TODO(ANDR-2699): This leads to an empty array which can not be encrypted at the moment
+            // TransactionScope.Scope.USER_PROFILE_SYNC,
+            TransactionScope.Scope.CONTACT_SYNC,
+            TransactionScope.Scope.GROUP_SYNC,
+            TransactionScope.Scope.DISTRIBUTION_LIST_SYNC,
+            TransactionScope.Scope.SETTINGS_SYNC,
+            TransactionScope.Scope.MDM_PARAMETER_SYNC,
+            TransactionScope.Scope.NEW_DEVICE_SYNC
+        ).forEach { expectedScope ->
+            val bytes = transactionScope {
+                scope = expectedScope
+            }.toByteArray()
+            val nonce = ByteArray(24) { it.toByte() }
+            val encrypted = nonce + NaCl.symmetricEncryptData(bytes, keys.dgtsk, nonce)
+            val decrypted = keys.decryptTransactionScope(encrypted)
+            assertEquals(expectedScope, decrypted)
+        }
+    }
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPathTest.kt b/domain/src/test/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPathTest.kt
new file mode 100644
index 00000000..c225267a
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPathTest.kt
@@ -0,0 +1,302 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2023-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.protocol.rendezvous
+
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.channels.BufferOverflow
+import kotlinx.coroutines.channels.Channel
+import kotlinx.coroutines.runBlocking
+import org.junit.Assert.*
+import org.junit.Test
+import java.io.IOException
+import java.lang.RuntimeException
+
+class MultiplexedRendezvousPathTest {
+
+    @Test
+    fun testConnect() {
+        val paths = TestRendezvousPath.createPaths(5)
+
+        val path = MultiplexedRendezvousPath(paths)
+
+        paths.values.forEach {
+            assertFalse(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            path.connect()
+        }
+
+        paths.values.forEach {
+            assertTrue(it.connected)
+            assertFalse(it.closed)
+        }
+    }
+
+    @Test
+    fun testConnectAndCloseAll() {
+        val paths = TestRendezvousPath.createPaths(5)
+
+        val path = MultiplexedRendezvousPath(paths)
+
+        paths.values.forEach {
+            assertFalse(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            path.connect()
+        }
+
+        paths.values.forEach {
+            assertTrue(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            path.closeAll()
+        }
+
+        paths.values.forEach {
+            assertFalse(it.connected)
+            assertTrue(it.closed)
+        }
+    }
+
+    @Test
+    fun testNominate() {
+        val paths = TestRendezvousPath.createPaths(5)
+
+        val path = MultiplexedRendezvousPath(paths)
+
+        paths.values.forEach {
+            assertFalse(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            path.connect()
+        }
+
+        paths.values.forEach {
+            assertTrue(it.connected)
+            assertFalse(it.closed)
+        }
+
+        val expected = paths[3U]!!
+        val nominated = runBlocking {
+            path.nominate(expected.pid)
+        }
+
+        // Verify the correct path is nominated and not closed
+
+        assertEquals(expected, nominated)
+        assertEquals(3U, nominated.pid)
+        assertTrue(expected.connected)
+        assertFalse(expected.closed)
+
+        // Verify all other paths are closed
+        paths.values
+            .filter { it.pid != 3U }
+            .forEach {
+                assertTrue(it.closed)
+                assertFalse(it.connected)
+            }
+
+    }
+
+    @OptIn(ExperimentalCoroutinesApi::class)
+    @Test(timeout = 1000)
+    fun testWrite() {
+        val paths = TestRendezvousPath.createPaths(5)
+
+        val path = MultiplexedRendezvousPath(paths)
+
+        paths.values.forEach {
+            assertFalse(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            path.connect()
+        }
+
+        paths.values.forEach {
+            assertTrue(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            paths.keys.forEach {
+                path.write(it to byteArrayOf(it.toByte()))
+            }
+
+            paths.values.forEach {
+                val bytes = it.writtenBytes.receive()
+                assertArrayEquals(byteArrayOf(it.pid.toByte()), bytes)
+                assertTrue(it.writtenBytes.isEmpty)
+            }
+        }
+    }
+
+    @OptIn(ExperimentalCoroutinesApi::class)
+    @Test(timeout = 1000)
+    fun testRead() {
+        val paths = TestRendezvousPath.createPaths(5)
+
+        val path = MultiplexedRendezvousPath(paths)
+
+        paths.values.forEach {
+            assertFalse(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            path.connect()
+        }
+
+        paths.values.forEach {
+            assertTrue(it.connected)
+            assertFalse(it.closed)
+        }
+
+        runBlocking {
+            paths.values.forEach {
+                it.readableBytes.send(byteArrayOf(it.pid.toByte()))
+            }
+
+
+            val readBytes = paths.map { path.read() }
+                .associate { it }
+
+            paths.values.forEach {
+                assertArrayEquals(byteArrayOf(it.pid.toByte()), readBytes[it.pid])
+                assertTrue(it.readableBytes.isEmpty)
+            }
+        }
+    }
+
+    @Test(expected = IOException::class)
+    fun testNoPathsConnect() {
+        val path = MultiplexedRendezvousPath(mapOf())
+
+        runBlocking {
+            path.connect()
+        }
+    }
+
+    @Test
+    fun testReadWithoutOpenPaths() {
+        val pid = 0U
+        val closedPath = TestClosedRendezvousPath(pid, CompletableDeferred())
+
+        val path = MultiplexedRendezvousPath(mapOf(closedPath.pid to closedPath))
+
+        runBlocking {
+            path.connect()
+        }
+
+        assertThrows(IOException::class.java) {
+            runBlocking {
+                path.read()
+            }
+        }
+    }
+
+    @Test
+    fun testWriteWithoutOpenPaths() {
+        val pid = 0U
+        val closedPath = TestClosedRendezvousPath(pid, CompletableDeferred())
+
+        val path = MultiplexedRendezvousPath(mapOf(closedPath.pid to closedPath))
+
+        runBlocking {
+            path.connect()
+        }
+
+        assertThrows(IOException::class.java) {
+            runBlocking {
+                path.write(pid to ByteArray(32))
+            }
+        }
+    }
+}
+
+private class TestClosedRendezvousPath(override val pid: UInt, override val closedSignal: CompletableDeferred<Unit>) : RendezvousPath {
+    init {
+        closedSignal.complete(Unit)
+    }
+
+    override suspend fun connect() {
+        // noop
+    }
+
+    override fun close() {
+        // noop
+    }
+
+    override suspend fun write(bytes: ByteArray) {
+        throw IOException()
+    }
+
+    override suspend fun read(): ByteArray {
+        throw IOException()
+    }
+}
+
+private class TestRendezvousPath(override val pid: UInt, override val closedSignal: CompletableDeferred<Unit>) : RendezvousPath {
+    var connected = false
+    var closed = false
+    val writtenBytes = Channel<ByteArray>(capacity = Channel.UNLIMITED, onBufferOverflow = BufferOverflow.SUSPEND)
+    val readableBytes = Channel<ByteArray>(capacity = Channel.UNLIMITED, onBufferOverflow = BufferOverflow.SUSPEND)
+
+    override suspend fun connect() {
+        if (closed) {
+            throw RuntimeException("Path has been closed")
+        }
+        connected = true
+    }
+
+    override fun close() {
+        connected = false
+        closed = true
+        writtenBytes.close()
+        readableBytes.close()
+    }
+
+    override suspend fun write(bytes: ByteArray) {
+        writtenBytes.send(bytes)
+
+    }
+
+    override suspend fun read(): ByteArray {
+        return readableBytes.receive()
+    }
+
+    companion object {
+        fun createPaths(count: Int): Map<UInt, TestRendezvousPath> = (0 until count)
+            .map { TestRendezvousPath(it.toUInt(), CompletableDeferred()) }
+            .associateBy { it.pid }
+    }
+}
diff --git a/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java b/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java
index 9565dfb5..51bb44e1 100644
--- a/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java
+++ b/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java
@@ -27,10 +27,11 @@ import java.util.Map;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 
 public class DummyContactStore implements ContactStore {
 	private final Map<String, Contact> contactMap;
-	private final Map<String, Contact> contactCache = new HashMap<>();
+	private final Map<String, BasicContact> contactCache = new HashMap<>();
 
 	public DummyContactStore() {
 		this.contactMap = new HashMap<>();
@@ -48,13 +49,14 @@ public class DummyContactStore implements ContactStore {
 	}
 
 	@Override
-	public void removeContact(@NonNull Contact contact) {
-		contactMap.remove(contact.getIdentity());
+	public void addCachedContact(@NonNull BasicContact contact) {
+		this.contactCache.put(contact.getIdentity(), contact);
 	}
 
+	@Nullable
 	@Override
-	public void addCachedContact(@NonNull Contact contact) {
-		this.contactCache.put(contact.getIdentity(), contact);
+	public BasicContact getCachedContact(@NonNull String identity) {
+		return this.contactCache.get(identity);
 	}
 
 	@Nullable
@@ -66,4 +68,9 @@ public class DummyContactStore implements ContactStore {
 		}
 		return getContactForIdentity(identity);
 	}
+
+	@Override
+	public boolean isSpecialContact(@NonNull String identity) {
+		return false;
+	}
 }
diff --git a/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.java b/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.java
deleted file mode 100644
index c9600ed9..00000000
--- a/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.testhelpers;
-
-import java.util.Collections;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.crypto.NonceFactory;
-import ch.threema.base.crypto.NonceStore;
-import ch.threema.domain.models.Contact;
-import ch.threema.domain.models.VerificationLevel;
-import ch.threema.domain.protocol.csp.coders.MessageBox;
-import ch.threema.domain.protocol.csp.coders.MessageCoder;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
-import ch.threema.domain.stores.ContactStore;
-import ch.threema.domain.stores.IdentityStoreInterface;
-
-public class TestHelpers {
-
-	public final static String myIdentity = "TESTTST";
-
-	public static ContactStore getNoopContactStore() {
-		return new ContactStore() {
-			@Override
-			public Contact getContactForIdentity(@NonNull String identity) {
-				return new Contact(identity, new byte[256], VerificationLevel.UNVERIFIED);
-			}
-
-			@Override
-			public void addCachedContact(@NonNull Contact contact) {
-
-			}
-
-			@Override
-			public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
-				return getContactForIdentity(identity);
-			}
-
-			@Override
-			public void addContact(@NonNull Contact contact) { }
-
-			@Override
-			public void removeContact(@NonNull Contact contact) { }
-		};
-	}
-
-	public static IdentityStoreInterface getNoopIdentityStore() {
-		return new IdentityStoreInterface() {
-			@Override
-			public byte[] encryptData(@NonNull byte[] plaintext, @NonNull byte[] nonce, @NonNull byte[] receiverPublicKey) {
-				return plaintext;
-			}
-
-			@Override
-			public byte[] decryptData(@NonNull byte[] ciphertext, @NonNull byte[] nonce, @NonNull byte[] senderPublicKey) {
-				return ciphertext;
-			}
-
-			@Override
-			public byte[] calcSharedSecret(@NonNull byte[] publicKey) {
-				return new byte[32];
-			}
-
-			@Override
-			public String getIdentity() {
-				return myIdentity;
-			}
-
-			@Override
-			public String getServerGroup() {
-				return null;
-			}
-
-			@Override
-			public byte[] getPublicKey() {
-				return new byte[256];
-			}
-
-			@Override
-			public byte[] getPrivateKey() {
-				return new byte[32];
-			}
-
-			@Override
-			@NonNull
-			public String getPublicNickname() {
-				return "";
-			}
-
-			@Override
-			public void storeIdentity(@NonNull String identity, @NonNull String serverGroup, @NonNull byte[] publicKey, @NonNull byte[] privateKey) { }
-		};
-	}
-
-	public static NonceFactory getNoopNonceFactory() {
-		return new NonceFactory(new NonceStore() {
-			@Override
-			public boolean exists(@NonNull byte[] nonce) {
-				return false;
-			}
-
-			@Override
-			public boolean store(@NonNull byte[] nonce) {
-				return true;
-			}
-
-			@NonNull
-			@Override
-			public List<byte[]> getAllHashedNonces() {
-				return Collections.emptyList();
-			}
-		});
-	}
-
-	/**
-	 * Adds a default sender and receiver to a message
-	 */
-	public static AbstractMessage setMessageDefaults(AbstractMessage msg) {
-		final String toIdentity = "ABCDEFGH";
-
-		msg.setFromIdentity(toIdentity);
-		msg.setToIdentity(myIdentity);
-
-		return msg;
-	}
-
-	public static MessageBox boxMessage(AbstractMessage msg) throws ThreemaException {
-		MessageCoder messageCoder = new MessageCoder(getNoopContactStore(), getNoopIdentityStore());
-		NonceFactory nonceFactory = getNoopNonceFactory();
-		byte[] nonce = nonceFactory.next(false);
-		return messageCoder.encode(msg, nonce, nonceFactory);
-	}
-
-	public static AbstractMessage decodeMessageFromBox(@NonNull MessageBox boxedMessage) throws MissingPublicKeyException, BadMessageException {
-		MessageCoder messageCoder = new MessageCoder(getNoopContactStore(), getNoopIdentityStore());
-		return messageCoder.decode(boxedMessage);
-	}
-
-
-}
diff --git a/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.kt b/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.kt
new file mode 100644
index 00000000..274ebda1
--- /dev/null
+++ b/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.kt
@@ -0,0 +1,152 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2017-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.testhelpers
+
+import ch.threema.base.ThreemaException
+import ch.threema.base.crypto.HashedNonce
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.crypto.NonceStore
+import ch.threema.domain.models.Contact
+import ch.threema.domain.models.BasicContact
+import ch.threema.domain.protocol.csp.coders.MessageBox
+import ch.threema.domain.protocol.csp.coders.MessageCoder
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException
+import ch.threema.domain.stores.ContactStore
+import ch.threema.domain.stores.IdentityStoreInterface
+
+object TestHelpers {
+    const val myIdentity = "TESTTEST"
+
+    @JvmStatic
+    val noopContactStore: ContactStore
+        get() = object : ContactStore {
+            override fun getContactForIdentity(identity: String): Contact {
+                return Contact(identity, ByteArray(256))
+            }
+
+            override fun addCachedContact(contact: BasicContact) {}
+            override fun getCachedContact(identity: String) = null
+            override fun getContactForIdentityIncludingCache(identity: String): Contact {
+                return getContactForIdentity(identity)
+            }
+
+            override fun addContact(contact: Contact) {}
+            override fun isSpecialContact(identity: String) = false
+        }
+
+    @JvmStatic
+    val noopIdentityStore: IdentityStoreInterface
+        get() = object : IdentityStoreInterface {
+            override fun encryptData(plaintext: ByteArray, nonce: ByteArray, receiverPublicKey: ByteArray): ByteArray {
+                return plaintext
+            }
+
+            override fun decryptData(ciphertext: ByteArray, nonce: ByteArray, senderPublicKey: ByteArray): ByteArray {
+                return ciphertext
+            }
+
+            override fun calcSharedSecret(publicKey: ByteArray): ByteArray {
+                return ByteArray(32)
+            }
+
+            override fun getIdentity(): String {
+                return myIdentity
+            }
+
+            override fun getServerGroup(): String {
+                return ""
+            }
+
+            override fun getPublicKey(): ByteArray {
+                return ByteArray(256)
+            }
+
+            override fun getPrivateKey(): ByteArray {
+                return ByteArray(32)
+            }
+
+            override fun getPublicNickname(): String {
+                return ""
+            }
+
+            override fun storeIdentity(identity: String, serverGroup: String, publicKey: ByteArray, privateKey: ByteArray) {}
+        }
+
+    @JvmStatic
+    val noopNonceFactory: NonceFactory
+        get() = NonceFactory(object : NonceStore {
+            override fun exists(scope: NonceScope, nonce: Nonce): Boolean {
+                return false
+            }
+
+            override fun store(scope: NonceScope, nonce: Nonce): Boolean {
+                return true
+            }
+
+            override fun getCount(scope: NonceScope): Long {
+                return 0
+            }
+
+            override fun getAllHashedNonces(scope: NonceScope): List<HashedNonce> {
+                return emptyList()
+            }
+
+            override fun addHashedNoncesChunk(scope: NonceScope, chunkSize: Int, offset: Int, nonces: MutableList<HashedNonce>) {
+                // noop
+            }
+
+            override fun insertHashedNonces(scope: NonceScope, nonces: List<HashedNonce>): Boolean {
+                return true
+            }
+        })
+
+    /**
+     * Adds a default sender and receiver to a message
+     */
+    @JvmStatic
+    fun setMessageDefaultSenderAndReceiver(msg: AbstractMessage): AbstractMessage {
+        val toIdentity = "ABCDEFGH"
+        msg.fromIdentity = toIdentity
+        msg.toIdentity = myIdentity
+        return msg
+    }
+
+    @Throws(ThreemaException::class)
+    @JvmStatic
+    fun boxMessage(msg: AbstractMessage?): MessageBox {
+        val messageCoder = MessageCoder(noopContactStore, noopIdentityStore)
+        val nonceFactory = noopNonceFactory
+        val nonce: Nonce = nonceFactory.next(NonceScope.CSP)
+        return messageCoder.encode(msg!!, nonce.bytes)
+    }
+
+    @Throws(MissingPublicKeyException::class, BadMessageException::class)
+    @JvmStatic
+    fun decodeMessageFromBox(boxedMessage: MessageBox): AbstractMessage {
+        val messageCoder = MessageCoder(noopContactStore, noopIdentityStore)
+        return messageCoder.decode(boxedMessage)
+    }
+}
diff --git a/domain/src/test/java/ch/threema/testutils/Assertions.kt b/domain/src/test/java/ch/threema/testutils/Assertions.kt
new file mode 100644
index 00000000..9bdfda22
--- /dev/null
+++ b/domain/src/test/java/ch/threema/testutils/Assertions.kt
@@ -0,0 +1,38 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2019-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.testutils
+
+import org.junit.Assert
+import kotlin.reflect.KClass
+
+infix fun (() -> Any?).willThrow(throwableClass: KClass<out Throwable>) {
+    Assert.assertThrows(throwableClass.java) {
+        try {
+            this()
+        } catch (throwable: Throwable) {
+            if (throwable::class == throwableClass) {
+                println("PASSED ${throwable::class.java.simpleName}: ${throwable.message}")
+            }
+            throw throwable
+        }
+    }
+}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java b/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java
index 0ed014f2..88a4bee5 100644
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java
@@ -21,29 +21,58 @@
 
 package ch.threema.domain.helpers;
 
-import ch.threema.domain.models.Contact;
-import ch.threema.domain.models.VerificationLevel;
-import ch.threema.domain.stores.IdentityStoreInterface;
-import ch.threema.base.utils.Utils;
 import com.neilalexander.jnacl.NaCl;
 
 import java.util.Arrays;
 import java.util.Objects;
 
+import androidx.annotation.NonNull;
+import ch.threema.base.utils.Utils;
+import ch.threema.domain.models.BasicContact;
+import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.IdentityState;
+import ch.threema.domain.models.IdentityType;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.protocol.ThreemaFeature;
+import ch.threema.domain.stores.IdentityStoreInterface;
+
 public class DummyUsers {
 	public static final User ALICE = new User("000ALICE", Utils.hexStringToByteArray("6eda2ebb8527ff5bd0e8719602f710c13e162a3be612de0ad2a2ff66f5050630"));
 	public static final User BOB = new User("00000BOB", Utils.hexStringToByteArray("533058227925006d86bb8dd88b0442ed73fbc49216b6e94b0870a7761d979eca"));
 	public static final User CAROL = new User("000CAROL", Utils.hexStringToByteArray("2ac0f894ef1504d63eef743ffd3cdd2a0604689f2bed6d10cc7895b589f4f821"));
 	public static final User DAVE = new User("0000DAVE", Utils.hexStringToByteArray("2b3d181bbf1eb84a01326c5dc79c70be32688cb3a797a2a0acdd6c067b614b44"));
 
+	private static final long featureMask = new ThreemaFeature.Builder()
+		.audio(true)
+		.group(true)
+		.ballot(true)
+		.file(true)
+		.voip(true)
+		.videocalls(true)
+		.forwardSecurity(true)
+		.groupCalls(true)
+		.editMessages(true)
+		.deleteMessages(true)
+		.build();
+
 	public static IdentityStoreInterface getIdentityStoreForUser(User user) {
 		return new InMemoryIdentityStore(user.identity, null, user.privateKey, user.identity);
 	}
 
-	public static Contact getContactForUser(User user) {
+	public static Contact getContactForUser(@NonNull User user) {
 		return new DummyContact(user.identity, NaCl.derivePublicKey(user.privateKey));
 	}
 
+	public static BasicContact getBasicContactForUser(@NonNull User user) {
+		return BasicContact.javaCreate(
+			user.identity,
+			NaCl.derivePublicKey(user.privateKey),
+			featureMask,
+			IdentityState.ACTIVE,
+			IdentityType.NORMAL
+		);
+	}
+
 	public static class User {
 		final String identity;
 		final byte[] privateKey;
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt
index fc1ee2c6..4d536bbb 100644
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt
@@ -22,6 +22,9 @@
 package ch.threema.domain.helpers
 
 import ch.threema.base.ThreemaException
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.domain.models.BasicContact
 import ch.threema.domain.models.Contact
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityEncryptionResult
@@ -49,12 +52,14 @@ class ForwardSecurityMessageProcessorWrapper(
     private val fsmp: ForwardSecurityMessageProcessor,
 ) {
     @Throws(ThreemaException::class)
-    fun makeMessage(
-        contact: Contact,
+    fun runFsEncapsulationSteps(
+        contact: BasicContact,
         innerMessage: AbstractMessage,
+        nonce: ByteArray,
+        nonceFactory: NonceFactory,
         handle: ActiveTaskCodec,
     ): ForwardSecurityEncryptionResult {
-        return fsmp.makeMessage(contact, innerMessage, handle)
+        return fsmp.runFsEncapsulationSteps(contact, innerMessage, Nonce(nonce), nonceFactory, handle)
     }
 
     @Throws(
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java
index 18a5bb5c..17a28e28 100644
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java
@@ -27,6 +27,7 @@ import java.util.Map;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.stores.ContactStore;
 
 /**
@@ -34,7 +35,7 @@ import ch.threema.domain.stores.ContactStore;
  */
 public class InMemoryContactStore implements ContactStore {
 	private final Map<String, Contact> contacts = new HashMap<>();
-	private final Map<String, Contact> contactsCache = new HashMap<>();
+	private final Map<String, BasicContact> contactsCache = new HashMap<>();
 
 	@Override
 	public Contact getContactForIdentity(@NonNull String identity) {
@@ -47,13 +48,14 @@ public class InMemoryContactStore implements ContactStore {
 	}
 
 	@Override
-	public void removeContact(@NonNull Contact contact) {
-		this.contacts.remove(contact.getIdentity());
+	public void addCachedContact(@NonNull BasicContact contact) {
+		this.contactsCache.put(contact.getIdentity(), contact);
 	}
 
+	@Nullable
 	@Override
-	public void addCachedContact(@NonNull Contact contact) {
-		this.contactsCache.put(contact.getIdentity(), contact);
+	public BasicContact getCachedContact(@NonNull String identity) {
+		return this.contactsCache.get(identity);
 	}
 
 	@Nullable
@@ -66,4 +68,9 @@ public class InMemoryContactStore implements ContactStore {
 
 		return getContactForIdentity(identity);
 	}
+
+	@Override
+	public boolean isSpecialContact(@NonNull String identity) {
+		return false;
+	}
 }
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.java b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.java
deleted file mode 100644
index 369ca5a7..00000000
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2021-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.helpers;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.crypto.NonceStore;
-
-/**
- * An in-memory identity store, used for testing.
- */
-public class InMemoryNonceStore implements NonceStore {
-	private final HashSet<byte[]> nonces = new HashSet<>();
-
-	@Override
-	public boolean exists(@NonNull byte[] nonce) {
-		return this.nonces.contains(nonce);
-	}
-
-	@Override
-	public boolean store(@NonNull byte[] nonce) {
-		return this.nonces.add(nonce);
-	}
-
-	@NonNull
-	@Override
-	public List<byte[]> getAllHashedNonces() {
-		List<byte[]> hashedNonces = new ArrayList<>(nonces.size());
-		hashedNonces.addAll(nonces);
-		return hashedNonces;
-	}
-}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.kt
new file mode 100644
index 00000000..fd4e3c64
--- /dev/null
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.kt
@@ -0,0 +1,70 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2021-2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.helpers
+
+import ch.threema.base.crypto.HashedNonce
+import ch.threema.base.crypto.Nonce
+import ch.threema.base.crypto.NonceScope
+import ch.threema.base.crypto.NonceStore
+import java.util.LinkedList
+
+/**
+ * An in-memory identity store, used for testing.
+ */
+class InMemoryNonceStore : NonceStore {
+    private val nonces = HashMap<NonceScope, LinkedList<HashedNonce>>()
+
+    override fun exists(scope: NonceScope, nonce: Nonce): Boolean {
+        return getScopedHashedNonces(scope).any { it.bytes.contentEquals(nonce.bytes) }
+    }
+
+    override fun store(scope: NonceScope, nonce: Nonce): Boolean {
+        return getScopedHashedNonces(scope).add(HashedNonce(nonce.bytes))
+    }
+
+    override fun getAllHashedNonces(scope: NonceScope): List<HashedNonce> {
+        return ArrayList(getScopedHashedNonces(scope))
+    }
+
+    override fun getCount(scope: NonceScope): Long {
+        return getScopedHashedNonces(scope).size.toLong()
+    }
+
+    override fun addHashedNoncesChunk(scope: NonceScope, chunkSize: Int, offset: Int, nonces: MutableList<HashedNonce>) {
+        val scopedNonces: List<HashedNonce> = getScopedHashedNonces(scope)
+        val from = Math.max(0, offset)
+        val to = Math.min(scopedNonces.size, from + chunkSize)
+        nonces.addAll(scopedNonces.subList(from, to))
+    }
+
+    override fun insertHashedNonces(scope: NonceScope, nonces: List<HashedNonce>): Boolean {
+        return getScopedHashedNonces(scope).addAll(nonces)
+    }
+
+    @Synchronized
+    private fun getScopedHashedNonces(scope: NonceScope): MutableList<HashedNonce> {
+        if (!nonces.containsKey(scope)) {
+            nonces[scope] = LinkedList()
+        }
+        return nonces[scope]!!
+    }
+}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt
index ee67f836..e8d4f348 100644
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt
@@ -21,12 +21,14 @@
 
 package ch.threema.domain.helpers
 
+import ch.threema.base.crypto.NonceFactory
 import ch.threema.domain.models.MessageId
 import ch.threema.domain.protocol.connection.data.CspMessage
 import ch.threema.domain.protocol.connection.data.InboundMessage
 import ch.threema.domain.protocol.connection.data.OutboundMessage
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.domain.protocol.csp.coders.MessageBox
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
 import ch.threema.domain.taskmanager.MessageFilterInstruction
 import ch.threema.domain.taskmanager.TaskCodec
 import kotlinx.coroutines.runBlocking
@@ -39,7 +41,6 @@ open class ServerAckTaskCodec : TaskCodec {
     val inboundMessages = mutableListOf<InboundMessage>()
     val outboundMessages = mutableListOf<OutboundMessage>()
     val ackedIncomingMessages = mutableListOf<MessageId>()
-    val reflectedMessages = mutableListOf<OutboundMessage>()
 
     override suspend fun read(preProcess: (InboundMessage) -> MessageFilterInstruction): InboundMessage {
         for (inboundMessage in inboundMessages) {
@@ -81,9 +82,13 @@ open class ServerAckTaskCodec : TaskCodec {
         }
     }
 
-    override suspend fun reflect(message: OutboundMessage) {
-        reflectedMessages.add(message)
-    }
+    override suspend fun reflectAndAwaitAck(
+        encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult,
+        storeD2dNonce: Boolean,
+        nonceFactory: NonceFactory
+    ): ULong = 0U
+
+    override suspend fun reflect(encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult): UInt = 0U
 
     /**
      * The server ack task codec creates the server ack here. Other tasks may perform additional
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/TransactionAckTaskCodec.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/TransactionAckTaskCodec.kt
new file mode 100644
index 00000000..a6910802
--- /dev/null
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/TransactionAckTaskCodec.kt
@@ -0,0 +1,55 @@
+/*  _____ _
+ * |_   _| |_  _ _ ___ ___ _ __  __ _
+ *   | | | ' \| '_/ -_) -_) '  \/ _` |_
+ *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
+ *
+ * Threema for Android
+ * Copyright (c) 2024 Threema GmbH
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License, version 3,
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program. If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package ch.threema.domain.helpers
+
+import ch.threema.domain.protocol.connection.data.InboundD2mMessage
+import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
+import ch.threema.domain.protocol.connection.data.OutboundMessage
+
+/**
+ * This task codec is used only for tests. It acts as the server and creates server acknowledgements
+ * for sent transaction begin and commit messages. Note that this also acts as [ServerAckTaskCodec].
+ */
+class TransactionAckTaskCodec : ServerAckTaskCodec() {
+    var transactionBeginCount = 0
+    var transactionCommitCount = 0
+
+    override suspend fun write(message: OutboundMessage) {
+        if (message is OutboundD2mMessage) {
+            when (message) {
+                is OutboundD2mMessage.BeginTransaction -> {
+                    transactionBeginCount++
+                    inboundMessages.add(InboundD2mMessage.BeginTransactionAck())
+                }
+
+                is OutboundD2mMessage.CommitTransaction -> {
+                    transactionCommitCount++
+                    inboundMessages.add(InboundD2mMessage.CommitTransactionAck())
+                }
+
+                else -> Unit
+            }
+        } else {
+            super.write(message)
+        }
+    }
+}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt
index 983b84b3..547760f1 100644
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt
@@ -21,8 +21,10 @@
 
 package ch.threema.domain.helpers
 
+import ch.threema.base.crypto.NonceFactory
 import ch.threema.domain.protocol.connection.data.InboundMessage
 import ch.threema.domain.protocol.connection.data.OutboundMessage
+import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
 import ch.threema.domain.taskmanager.MessageFilterInstruction
 import ch.threema.domain.taskmanager.TaskCodec
 
@@ -39,7 +41,15 @@ class UnusedTaskCodec : TaskCodec {
         throw IllegalStateException("This task codec should not be used.")
     }
 
-    override suspend fun reflect(message: OutboundMessage) {
+    override suspend fun reflectAndAwaitAck(
+        encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult,
+        storeD2dNonce: Boolean,
+        nonceFactory: NonceFactory
+    ): ULong {
+        throw IllegalStateException("This task codec should not be used.")
+    }
+
+    override suspend fun reflect(encryptedEnvelopeResult: MultiDeviceKeys.EncryptedEnvelopeResult): UInt {
         throw IllegalStateException("This task codec should not be used.")
     }
 }
diff --git a/test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt b/test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt
index 8412b66f..1e3586c8 100644
--- a/test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt
+++ b/test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt
@@ -44,3 +44,8 @@ fun randomIdentity(): String {
         .map { allowedChars.random() }
         .joinToString("")
 }
+
+@Suppress("FunctionName")
+fun MUST_NOT_BE_CALLED(): Nothing {
+    throw UnsupportedOperationException("This method must not be called")
+}
