diff --git a/app/src/main/java/com/kaeruct/raumballer/AndroidGame.java b/app/src/main/java/com/kaeruct/raumballer/AndroidGame.java
index 7092653..ebd4b11 100644
--- a/app/src/main/java/com/kaeruct/raumballer/AndroidGame.java
+++ b/app/src/main/java/com/kaeruct/raumballer/AndroidGame.java
@@ -1,221 +1,252 @@
 package com.kaeruct.raumballer;
-import java.util.ArrayList;
 
-import com.kaeruct.raumballer.background.*;
-import com.kaeruct.raumballer.bullet.Bullet;
+import com.kaeruct.raumballer.background.BGImage;
+import com.kaeruct.raumballer.background.BGStar;
 import com.kaeruct.raumballer.cannon.Cannon;
-import com.kaeruct.raumballer.ship.*;
-import com.kaeruct.raumballer.ship.player.*;
-import com.kaeruct.raumballer.wave.*;
-import jgame.*;
-import jgame.platform.*;
+import com.kaeruct.raumballer.ship.PlayerShip;
+import com.kaeruct.raumballer.ship.player.NimakRunner;
+import com.kaeruct.raumballer.ship.player.SpinTurn;
+import com.kaeruct.raumballer.ship.player.StenoShot;
+import com.kaeruct.raumballer.wave.Wave;
+
+import java.util.ArrayList;
+
+import jgame.JGColor;
+import jgame.JGPoint;
+import jgame.platform.JGEngine;
 
 public class AndroidGame extends JGEngine {
 
-	private PlayerShip p;
-	private ShooterTitle titleState;
-	public final byte PLAYER_ID = 1;
-	public final byte ENEMY_ID = 2;
-	public int score;
-	public int starCount;
-	public int starMax = 128;
-	public int starFreq = 80;
-	private boolean levelFinished = false;
-	public final int WIDTH = 48/3;
-	public final int HEIGHT = 72/3;
-	public final int VWIDTH = 48/3;
-	public final int VHEIGHT = 72/3;
-	public LevelReader levelReader;
-	public ArrayList<Wave> waves;
-	public int t;
-	public boolean isTapping;
-	public boolean isTouchDown;
-	public int lastTap;
-	
-	public static void main(String [] args) {
-		new AndroidGame(new JGPoint(480, 720));
-	}
-
-	/** Application constructor. */
-	public AndroidGame(JGPoint size) { initEngine(size.x,size.y); }
-
-	/** Applet constructor. */
-	public AndroidGame() { initEngineApplet(); }
-
-	public void initCanvas() {
-		// we set the background colour to same colour as the splash background
-		setCanvasSettings(VWIDTH, VHEIGHT, 16, 16, JGColor.black, new JGColor(0, 0, 0), null);
-
-	}
-
-	public void initGame() {
-		this.setGameState("Title");
-
-		this.dbgShowFullStackTrace(true);
-		this.dbgShowMessagesInPf(false);
-		
-		this.titleState = new ShooterTitle(this);
-		Cannon.game = this;
-		
-		setFrameRate(60, 2);
-		setGameSpeed(1);
-		
-		defineMedia("shooter.tbl");
-	}
-	
-	public void loadLevel(String lvlFile){
-		this.starCount = 0;
-
-		try {
-			this.levelReader = new LevelReader(this, getAssets().open(lvlFile));
-		} catch (Exception e) {
-			this.dbgPrint(e.toString());
-		}
-		
-		// init background
-		new BGImage("pipe", 2, this);
-		new BGImage("pipe", 6, this);
-		new BGImage("bg1", 4, this);
-		
-		removeObjects("bgstar", -1);
-		addStars(16);
-		
-		this.levelReader.init();
-	}
-	
-	public void levelFinished(){
-		
-	}
-	
-	public void addStars(int n){
-		for(int i = 0; i < n; i++){
-			new BGStar(
-					random(0, pfWidth())-8,
-					random(4, pfHeight())-4,
-					(int)Math.ceil(random(1, 8)),
-					this);
-		}
-		starCount+=n;
-	}
-	
-	public void startTitle() {
-		titleState.start();
-	}
-	
-	public void doFrameTitle() {
-		titleState.doFrame();
-	}
-	
-	public void paintFrameTitle() {
-		titleState.paintFrame();
-	}
-	
-	
-	public void startInGame() {
-		setPFSize(WIDTH, HEIGHT);
-		
-		this.waves = new ArrayList<Wave>();
-		this.score = 0;
-		this.t = 0;
-		
-		switch(this.titleState.selectedShip){
-		default:
-		case 0:
-			p = new SpinTurn(pfWidth()/2-16, pfHeight()-32, this);
-			break;
-		case 1:
-			p = new NimakRunner(pfWidth()/2-16, pfHeight()-32, this);
-			break;
-		case 2:
-			p = new StenoShot(pfWidth()/2-16, pfHeight()-32, this);
-			
-			break;
-		}
-		
-		loadLevel("level1.lvl");
-	}
-
-	public void doFrameInGame() {
-		boolean isDown = getMouseButton(1);
-		isTouchDown = isDown;
-		if (isDown) lastTap = t;
-		isTapping = (t - lastTap < 10); // expire taps after 10 frames
-		checkCollision(PLAYER_ID, ENEMY_ID);
-		checkCollision(ENEMY_ID, PLAYER_ID);
-		
-		//setViewOffset(0, (int) p.y+64-viewWidth()/2, true);
-		setViewOffset(0, (int) p.y, true);
-		
-		for(int i = 0; i < this.waves.size(); i++){
-			waves.get(i).update();
-		}
-		
-		for(int i = this.waves.size() - 1; i > 0; i--){
-			if(waves.get(i).stopped){waves.remove(i);}
-		}
-		
-		moveObjects(null, 0);
-		
-		if(t%starFreq==0 && starCount < starMax){
-			addStars(16);
-		}
-
-		t++;
-
-		if ((levelFinished || p.isDead()) && isTapping) {
-			this.removeObjects("", 0);
-			this.setGameState("Title");
-		}
-		
-		if (this.waves.size() == 0) {
-			levelFinished = true;
-		}
-	}
-	
-	public void paintFrameInGame() {
-		setColor(JGColor.white);
-		
-		drawString("Mode:"+p.getMode(), 4, viewHeight()-10, -1);
-		drawString("Score:"+this.score, viewWidth()-8, viewHeight()-20, 1);
-		drawString("Health:"+((int)p.getHealth()), viewWidth()-10, viewHeight()-8, 1);
-		
-		if (levelFinished) {
-			int centerY = viewHeight()/2;
-			int centerX = viewWidth()/2;
-			
-			drawString("Congratulations! Level over!", centerX, centerY-4, 0, "yellow");
-			drawString("Tap to restart!", centerX, centerY+4, 0, "blue");
-			drawString("Try another ship!", centerX, centerY+12, 0, "blue");
-
-		} else if (p.isDead()) {
-			int centerY = viewHeight()/2;
-			int centerX = viewWidth()/2;
-			
-			drawString("Tap to restart!", centerX-4, centerY-4, 0, "yellow");
-			drawString("Try another ship!", centerX+4, centerY+4, 0, "blue");
-		}
-	}
-	
-	public PlayerShip getPlayer(){
-		return p;
-	}
-	
-	public boolean goingUp(double angle){
-		angle = (angle*180/Math.PI)%360;
-		while(angle < 0) angle += 360;
-		
-		return (angle >= 0 && angle <= 180);
-	}
-	
-	public boolean goingDown(double angle){
-		return !goingUp(angle);
-	}
-	
-	public void drawString(String s, double x, double y, int align){
-		drawImageString(s, x, y, align, "font_white", 32, 0);
-	}
-	
-	public void drawString(String s, double x, double y, int align, String color){
-		drawImageString(s, x, y, align, "font_"+color, 32, 0);
-	}
+    private PlayerShip p;
+    private ShooterTitle titleState;
+    private int gameOverStart = 0;
+    public int selectedShip = 0;
+    public final byte PLAYER_ID = 1;
+    public final byte ENEMY_ID = 2;
+    public int score;
+    public int starCount;
+    public int starMax = 128;
+    public int starFreq = 80;
+    private boolean levelFinished = false;
+    public final int WIDTH = 48 / 3;
+    public final int HEIGHT = 68 / 3;
+    public LevelReader levelReader;
+    public ArrayList<Wave> waves;
+    public int t;
+    public boolean isTapping;
+    public boolean prevIsTapping;
+    public boolean isTouchDown;
+    public int lastDown;
+    public int lastUp;
+
+    public static void main(String[] args) {
+        new AndroidGame(new JGPoint(480, 720));
+    }
+
+    /**
+     * Application constructor.
+     */
+    public AndroidGame(JGPoint size) {
+        initEngine(size.x, size.y);
+    }
+
+    /**
+     * Applet constructor.
+     */
+    public AndroidGame() {
+        initEngineApplet();
+    }
+
+    public void initCanvas() {
+        // we set the background colour to same colour as the splash background
+        setCanvasSettings(WIDTH, HEIGHT, 16, 16, JGColor.black, new JGColor(0, 0, 0), null);
+
+    }
+
+    public void initGame() {
+        this.setGameState("Title");
+
+        this.dbgShowFullStackTrace(true);
+        this.dbgShowMessagesInPf(false);
+
+        this.titleState = new ShooterTitle(this);
+        Cannon.game = this;
+
+        setFrameRate(60, 2);
+        setGameSpeed(1);
+
+        defineMedia("shooter.tbl");
+    }
+
+    public void loadLevel(String lvlFile) {
+        this.starCount = 0;
+
+        try {
+            this.levelReader = new LevelReader(this, getAssets().open(lvlFile));
+        } catch (Exception e) {
+            this.dbgPrint(e.toString());
+        }
+
+        // init background
+        new BGImage("pipe", 2, this);
+        new BGImage("pipe", 6, this);
+        new BGImage("bg1", 4, this);
+
+        removeObjects("bgstar", -1);
+        addStars(16);
+
+        this.levelReader.init();
+    }
+
+    public void levelFinished() {
+        levelFinished = true;
+    }
+
+    public void addStars(int n) {
+        for (int i = 0; i < n; i++) {
+            new BGStar(
+                    random(0, pfWidth()) - 8,
+                    random(4, pfHeight()) - 4,
+                    (int) Math.ceil(random(1, 8)),
+                    this);
+        }
+        starCount += n;
+    }
+
+    public void addScore(double n) {
+        score += n;
+        p.onScore(score);
+    }
+
+    public void startTitle() {
+        titleState.start();
+    }
+
+    public void doFrameTitle() {
+        titleState.doFrame();
+    }
+
+    public void paintFrameTitle() {
+        titleState.paintFrame();
+    }
+
+    public void startInGame() {
+        setPFSize(WIDTH, HEIGHT);
+
+        this.waves = new ArrayList<>();
+        this.score = 0;
+        this.t = 0;
+
+        switch (this.selectedShip) {
+            default:
+            case 0:
+                p = new StenoShot(pfWidth() / 2 - 16, pfHeight() - 32, this);
+                break;
+            case 1:
+                p = new NimakRunner(pfWidth() / 2 - 16, pfHeight() - 32, this);
+                break;
+            case 2:
+                p = new SpinTurn(pfWidth() / 2 - 16, pfHeight() - 32, this);
+
+                break;
+        }
+
+        loadLevel("level1.lvl");
+    }
+
+    public void doFrameInGame() {
+        boolean isDown = getMouseButton(1);
+        isTouchDown = isDown;
+        if (isDown) lastDown = t;
+        isTapping = (t - lastDown < 10); // expire taps after 10 frames
+
+        if (!isTapping && prevIsTapping) {
+            lastUp = t;
+        }
+
+        prevIsTapping = isTapping;
+
+        checkCollision(PLAYER_ID, ENEMY_ID);
+        checkCollision(ENEMY_ID, PLAYER_ID);
+
+        setViewOffset(0, (int) p.y, true);
+
+        for (int i = 0; i < this.waves.size(); i++) {
+            waves.get(i).update();
+        }
+
+        for (int i = this.waves.size() - 1; i > 0; i--) {
+            if (waves.get(i).stopped) {
+                waves.remove(i);
+            }
+        }
+
+        moveObjects(null, 0);
+
+        if (t % starFreq == 0 && starCount < starMax) {
+            addStars(16);
+        }
+
+        t++;
+
+        if (gameOverStart > 0 && (t - gameOverStart < 30) && isTapping) {
+            this.removeObjects("", 0);
+            gameOverStart = 0;
+            this.setGameState("Title");
+        }
+
+        if (this.waves.size() == 0) {
+            levelFinished = true;
+        }
+
+        if (levelFinished || p.isDead()) {
+            gameOverStart = t;
+        }
+    }
+
+    public void paintFrameInGame() {
+        setColor(JGColor.white);
+
+        drawString("Mode:" + p.getMode(), 4, viewHeight() - 10, -1);
+        drawString("Score:" + this.score, viewWidth() - 8, viewHeight() - 20, 1);
+        drawString("Health:" + ((int) p.getHealth()), viewWidth() - 10, viewHeight() - 8, 1);
+
+        if (levelFinished) {
+            int centerY = viewHeight() / 2;
+            int centerX = viewWidth() / 2;
+
+            drawString("Congratulations! Level over!", centerX, centerY - 4, 0, "yellow");
+            drawString("TAP to restart!", centerX, centerY + 4, 0, "blue");
+            drawString("Try another ship!", centerX, centerY + 12, 0, "blue");
+        } else if (p.isDead()) {
+            int centerY = viewHeight() / 2;
+            int centerX = viewWidth() / 2;
+
+            drawString("TAP to restart!", centerX - 4, centerY - 4, 0, "yellow");
+            drawString("Try another ship!", centerX + 4, centerY + 12, 0, "blue");
+        }
+    }
+
+    public PlayerShip getPlayer() {
+        return p;
+    }
+
+    public boolean goingUp(double angle) {
+        angle = (angle * 180 / Math.PI) % 360;
+        while (angle < 0) angle += 360;
+
+        return (angle >= 0 && angle <= 180);
+    }
+
+    public boolean goingDown(double angle) {
+        return !goingUp(angle);
+    }
+
+    public void drawString(String s, double x, double y, int align) {
+        drawImageString(s, x, y, align, "font_white", 32, 0);
+    }
+
+    public void drawString(String s, double x, double y, int align, String color) {
+        drawImageString(s, x, y, align, "font_" + color, 32, 0);
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/Explosion.java b/app/src/main/java/com/kaeruct/raumballer/Explosion.java
index f3c6374..4f79f20 100644
--- a/app/src/main/java/com/kaeruct/raumballer/Explosion.java
+++ b/app/src/main/java/com/kaeruct/raumballer/Explosion.java
@@ -2,9 +2,9 @@ package com.kaeruct.raumballer;
 
 import jgame.JGObject;
 
-public class Explosion extends JGObject{
-	public Explosion(double x, double y, String color){
-		super("explosion", true, x, y, 0x99, "explosion_"+color);
-		this.expiry = 16;
-	}
+public class Explosion extends JGObject {
+    public Explosion(double x, double y, String color) {
+        super("explosion", true, x, y, 0x99, "explosion_" + color);
+        this.expiry = 16;
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/LevelReader.java b/app/src/main/java/com/kaeruct/raumballer/LevelReader.java
index e2ac9a9..4e762c7 100644
--- a/app/src/main/java/com/kaeruct/raumballer/LevelReader.java
+++ b/app/src/main/java/com/kaeruct/raumballer/LevelReader.java
@@ -1,97 +1,98 @@
 package com.kaeruct.raumballer;
 
+import com.kaeruct.raumballer.wave.Wave;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
-
-import com.kaeruct.raumballer.wave.Wave;
+import java.nio.charset.StandardCharsets;
 
 public class LevelReader {
-	
-	private BufferedReader reader;
-	private String[] waveClasses;
-	private int[] maxAmounts;
-	private String currentLine;
-	private AndroidGame game;
-	private int wavesDone;
-	
-	public LevelReader(AndroidGame game, InputStream inputStream) throws UnsupportedEncodingException{
-		
-		this.reader = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));
-		this.currentLine = null;
-		this.wavesDone = 0;
-		this.game = game;
-	}
-	
-	public void init(){
-		this.executeNextLine();
-	}
-	
-	private void executeNextLine(){
-		try {
-			this.currentLine = reader.readLine();
-		} catch (IOException e) {
-			this.game.dbgPrint(e.toString());
-		}
-		
-		if(this.currentLine != null){
-			executeCurrentLine();
-		}else{
-			this.levelFinished();
-		}
-	}
-	
-	private void executeCurrentLine(){
-		wavesDone = 0;
-		String[] params = currentLine.split("\\+");
-		waveClasses = new String[params.length];
-		maxAmounts = new int[params.length];
-		
-		for(int i = 0; i < params.length; i++){
-			params[i] = params[i].trim();
-			String[] cl = params[i].split("[ \t]");
-			waveClasses[i] = cl[0].trim();
-			maxAmounts[i] = Integer.parseInt(cl[1].trim());
-		}
-		
-		if(waveClasses.length > 0){
-			createWaves(waveClasses, maxAmounts);
-		}
-	}
-	
-	private void createWaves(String[] classNames, int[] maxAmounts){
-		
-		for(int i = 0; i < classNames.length; i++){
-			try {
-				Class<Wave> wave = (Class<Wave>) Class.forName("com.kaeruct.raumballer.wave."+classNames[i]);
-				Constructor<Wave> c = wave.getConstructor(AndroidGame.class, LevelReader.class, int.class);
-				
-				Wave w = c.newInstance(this.game, this, maxAmounts[i]);
-				this.game.waves.add(w);
-				
-			} catch (Exception e) {
-				this.game.dbgPrint(e.toString());
-			}
-		}
-	}
-
-	public void waveDone() {
-		this.wavesDone++;
-		
-		if(this.wavesDone >= this.waveClasses.length){
-			this.executeNextLine();
-		}
-	}
-	
-	public void levelFinished(){
-		try {
-			this.reader.close();
-		} catch (IOException e) {
-			this.game.dbgPrint(e.toString());
-		}
-		this.game.levelFinished();
-	}
+
+    private final BufferedReader reader;
+    private String[] waveClasses;
+    private int[] maxAmounts;
+    private String currentLine;
+    private final AndroidGame game;
+    private int wavesDone;
+
+    public LevelReader(AndroidGame game, InputStream inputStream) throws UnsupportedEncodingException {
+
+        this.reader = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));
+        this.currentLine = null;
+        this.wavesDone = 0;
+        this.game = game;
+    }
+
+    public void init() {
+        this.executeNextLine();
+    }
+
+    private void executeNextLine() {
+        try {
+            this.currentLine = reader.readLine();
+        } catch (IOException e) {
+            this.game.dbgPrint(e.toString());
+        }
+
+        if (this.currentLine != null) {
+            executeCurrentLine();
+        } else {
+            this.levelFinished();
+        }
+    }
+
+    private void executeCurrentLine() {
+        wavesDone = 0;
+        String[] params = currentLine.split("\\+");
+        waveClasses = new String[params.length];
+        maxAmounts = new int[params.length];
+
+        for (int i = 0; i < params.length; i++) {
+            params[i] = params[i].trim();
+            String[] cl = params[i].split("[ \t]");
+            waveClasses[i] = cl[0].trim();
+            maxAmounts[i] = Integer.parseInt(cl[1].trim());
+        }
+
+        if (waveClasses.length > 0) {
+            createWaves(waveClasses, maxAmounts);
+        }
+    }
+
+    private void createWaves(String[] classNames, int[] maxAmounts) {
+
+        for (int i = 0; i < classNames.length; i++) {
+            try {
+                Class<Wave> wave = (Class<Wave>) Class.forName("com.kaeruct.raumballer.wave." + classNames[i]);
+                Constructor<Wave> c = wave.getConstructor(AndroidGame.class, LevelReader.class, int.class);
+
+                Wave w = c.newInstance(this.game, this, maxAmounts[i]);
+                this.game.waves.add(w);
+
+            } catch (Exception e) {
+                this.game.dbgPrint(e.toString());
+            }
+        }
+    }
+
+    public void waveDone() {
+        this.wavesDone++;
+
+        if (this.wavesDone >= this.waveClasses.length) {
+            this.executeNextLine();
+        }
+    }
+
+    public void levelFinished() {
+        try {
+            this.reader.close();
+        } catch (IOException e) {
+            this.game.dbgPrint(e.toString());
+        }
+        this.game.levelFinished();
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ShooterTitle.java b/app/src/main/java/com/kaeruct/raumballer/ShooterTitle.java
index 1d9cc97..ff9ca3c 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ShooterTitle.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ShooterTitle.java
@@ -7,50 +7,48 @@ import jgame.JGObject;
 import jgame.JGRectangle;
 
 public class ShooterTitle {
-	
-	private AndroidGame game;
-	public int selectedShip;
-	private int centerX;
-	private int centerY;
-	private List<JGObject> ships;
-
-	public ShooterTitle(AndroidGame game){
-		this.game = game;
-		this.selectedShip = 0;
-
-		centerY = this.game.viewHeight()/2;
-		centerX = this.game.viewWidth()/2;
-	}
-	
-	public void start() {
-		game.addStars(128);
-		ships = new ArrayList<>();
-		ships.add(new JGObject("select-steno-shot", true, centerX - 48, centerY, 0, "player1"));
-		ships.add(new JGObject("select-nimak-runner", true, centerX, centerY, 0, "player2"));
-		ships.add(new JGObject("select-spin-turn", true, centerX + 48, centerY, 0, "player3"));
-	}
-	
-	public void doFrame() {
-		game.moveObjects(null, 0);
-
-		if (game.getMouseButton(1)) {
-			JGRectangle mouseRect = new JGRectangle(game.getMouseX(), game.getMouseY(), 1, 1);
-			for (int i = 0 ; i < ships.size(); i++) {
-				if (ships.get(i).getBBox().intersects(mouseRect)) {
-					this.selectedShip = i;
-					game.removeObjects("select-", 0);
-					game.setGameState("InGame");
-					System.out.println("SELECTED SHIP " + i);
-					break;
-				}
-			}
-		}
-	}
-	
-	public void paintFrame() {
-		this.game.drawString("-= RAUM BALLER =-", centerX, centerY-48, 0, "blue");
-		this.game.drawString("TAP a ship to begin", centerX, centerY-32, 0);
-		this.game.drawString("move by TAPPING where to go", centerX, centerY+32, 0);
-		this.game.drawString("change mode by TAPPING TWICE", centerX, centerY+48, 0);
-	}
+
+    private final AndroidGame game;
+    private final int centerX;
+    private final int centerY;
+    private List<JGObject> ships;
+
+    public ShooterTitle(AndroidGame game) {
+        this.game = game;
+
+        centerY = this.game.viewHeight() / 2;
+        centerX = this.game.viewWidth() / 2;
+    }
+
+    public void start() {
+        game.addStars(128);
+        ships = new ArrayList<>();
+        ships.add(new JGObject("select-steno-shot", true, centerX - 48, centerY - 8, 0, "player1"));
+        ships.add(new JGObject("select-nimak-runner", true, centerX, centerY - 8, 0, "player2"));
+        ships.add(new JGObject("select-spin-turn", true, centerX + 48, centerY - 8, 0, "player3"));
+    }
+
+    public void doFrame() {
+        game.moveObjects(null, 0);
+
+        if (game.getMouseButton(1)) {
+            JGRectangle mouseRect = new JGRectangle(game.getMouseX(), game.getMouseY(), 1, 1);
+            for (int i = 0; i < ships.size(); i++) {
+                if (ships.get(i).getBBox().intersects(mouseRect)) {
+                    game.selectedShip = i;
+                    game.removeObjects("select-", 0);
+                    game.setGameState("InGame");
+                    break;
+                }
+            }
+        }
+    }
+
+    public void paintFrame() {
+        game.drawString("-= RAUM BALLER =-", centerX, centerY - 48, 0, "blue");
+        game.drawString("TAP a ship to begin", centerX, centerY - 32, 0);
+        game.drawString("move by TAPPING where to go", centerX, centerY + 32, 0);
+        game.drawString("get stronger by destroying", centerX, centerY + 48, 0);
+        game.drawString("enemy ships", centerX, centerY + 64, 0);
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/background/BGImage.java b/app/src/main/java/com/kaeruct/raumballer/background/BGImage.java
index bf303f5..8b6566b 100644
--- a/app/src/main/java/com/kaeruct/raumballer/background/BGImage.java
+++ b/app/src/main/java/com/kaeruct/raumballer/background/BGImage.java
@@ -1,54 +1,56 @@
 package com.kaeruct.raumballer.background;
+
 import com.kaeruct.raumballer.AndroidGame;
+
 import jgame.JGImage;
 
-public class BGImage{
-	
-	private AndroidGame game;
-	private BGUnit[] sprites;
-	private double width;
-	private double height;
-	private String graphic;
-	private double scroll;
-	
-	public BGImage(String graphic, double scroll, AndroidGame game){
-		this.game = game;
-		
-		JGImage img = game.getImage(graphic);
-		
-		this.graphic = graphic;
-		this.width = img.getSize().x;
-		this.height = img.getSize().y;
-		this.scroll = scroll;
-		
-		createSprites();
-	}
-	
-	public void createSprites(){
-		
-		int xtile = 1+(int)Math.ceil(game.viewWidth()/width);
-		int ytile = 2+(int)Math.ceil(game.viewHeight()/height);
-		int spcnt = 0;
-		double xoff = game.viewXOfs();
-		double yoff = game.viewYOfs();
-
-		sprites = new BGUnit[xtile*ytile];
-		
-		for(int i = 0; i < xtile; i++){
-			for(int j = 0; j < ytile; j++){
-				BGUnit sp = new BGUnit(xoff + i*width/2,
-						yoff + j*height/2,
-						this.graphic, scroll, game);
-
-				sprites[spcnt++] = sp;
-			}
-		}
-	}
-	
-	public void setScroll(double scroll){
-		this.scroll = scroll;
-		for(int i = 0; i < sprites.length; i++){
-			sprites[i].scroll = scroll;
-		}
-	}
+public class BGImage {
+
+    private final AndroidGame game;
+    private BGUnit[] sprites;
+    private final double width;
+    private final double height;
+    private final String graphic;
+    private double scroll;
+
+    public BGImage(String graphic, double scroll, AndroidGame game) {
+        this.game = game;
+
+        JGImage img = game.getImage(graphic);
+
+        this.graphic = graphic;
+        this.width = img.getSize().x;
+        this.height = img.getSize().y;
+        this.scroll = scroll;
+
+        createSprites();
+    }
+
+    public void createSprites() {
+
+        int xtile = 1 + (int) Math.ceil(game.viewWidth() / width);
+        int ytile = 2 + (int) Math.ceil(game.viewHeight() / height);
+        int spcnt = 0;
+        double xoff = game.viewXOfs();
+        double yoff = game.viewYOfs();
+
+        sprites = new BGUnit[xtile * ytile];
+
+        for (int i = 0; i < xtile; i++) {
+            for (int j = 0; j < ytile; j++) {
+                BGUnit sp = new BGUnit(xoff + i * width / 2,
+                        yoff + j * height / 2,
+                        this.graphic, scroll, game);
+
+                sprites[spcnt++] = sp;
+            }
+        }
+    }
+
+    public void setScroll(double scroll) {
+        this.scroll = scroll;
+        for (int i = 0; i < sprites.length; i++) {
+            sprites[i].scroll = scroll;
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/background/BGStar.java b/app/src/main/java/com/kaeruct/raumballer/background/BGStar.java
index c99521d..d0bd88c 100644
--- a/app/src/main/java/com/kaeruct/raumballer/background/BGStar.java
+++ b/app/src/main/java/com/kaeruct/raumballer/background/BGStar.java
@@ -1,22 +1,23 @@
 package com.kaeruct.raumballer.background;
 
 import com.kaeruct.raumballer.AndroidGame;
+
 import jgame.JGObject;
 
-public class BGStar extends JGObject{
-	
-	private AndroidGame game;
-	
-	public BGStar(double x, double y, int n, AndroidGame game){
-		super("bgstar", true, x, y, 0x99, "bgstar_"+n, 0, n*2);
-		this.expiry = -2;
-		this.game = game;
-	}
-	
-	public void move(){
-		super.move();
-		if(y >= this.game.pfHeight()-4){
-			y = 0;
-		}
-	}
+public class BGStar extends JGObject {
+
+    private final AndroidGame game;
+
+    public BGStar(double x, double y, int n, AndroidGame game) {
+        super("bgstar", true, x, y, 0x99, "bgstar_" + n, 0, n * 2);
+        this.expiry = -2;
+        this.game = game;
+    }
+
+    public void move() {
+        super.move();
+        if (y >= this.game.pfHeight() - 4) {
+            y = 0;
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/background/BGUnit.java b/app/src/main/java/com/kaeruct/raumballer/background/BGUnit.java
index 1b2ad90..82bab6a 100644
--- a/app/src/main/java/com/kaeruct/raumballer/background/BGUnit.java
+++ b/app/src/main/java/com/kaeruct/raumballer/background/BGUnit.java
@@ -1,30 +1,31 @@
 package com.kaeruct.raumballer.background;
 
 import com.kaeruct.raumballer.AndroidGame;
+
 import jgame.JGObject;
 
-public class BGUnit extends JGObject{
-	
-	private AndroidGame game;
-	public double scroll;
-	public double ymax;
-	public double w;
-	
-	public BGUnit(double x, double y, String graphic, double yspeed, AndroidGame game){
-		super("bgimg", true, x, y, 0x99, graphic, 0, 0);
-		this.expiry = -1;
-		this.game = game;
-		this.scroll = yspeed;
-		this.w = game.getImage(this.getImageName()).getSize().y;
-		this.ymax = Math.ceil(this.game.viewHeight()/w)*w;
-	}
-	
-	public void move(){
-		if(y > ymax){
-			y = -w/2;
-			y += scroll*2;
-		}else{
-			y += scroll;
-		}
-	}
+public class BGUnit extends JGObject {
+
+    private final AndroidGame game;
+    public double scroll;
+    public double ymax;
+    public double w;
+
+    public BGUnit(double x, double y, String graphic, double yspeed, AndroidGame game) {
+        super("bgimg", true, x, y, 0x99, graphic, 0, 0);
+        this.expiry = -1;
+        this.game = game;
+        this.scroll = yspeed;
+        this.w = game.getImage(this.getImageName()).getSize().y;
+        this.ymax = Math.ceil(this.game.viewHeight() / w) * w;
+    }
+
+    public void move() {
+        if (y > ymax) {
+            y = -w / 2;
+            y += scroll * 2;
+        } else {
+            y += scroll;
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/bullet/BitBullet.java b/app/src/main/java/com/kaeruct/raumballer/bullet/BitBullet.java
index c0c7d0e..29c1cf7 100644
--- a/app/src/main/java/com/kaeruct/raumballer/bullet/BitBullet.java
+++ b/app/src/main/java/com/kaeruct/raumballer/bullet/BitBullet.java
@@ -1,10 +1,10 @@
 package com.kaeruct.raumballer.bullet;
 
-public class BitBullet extends Bullet{
+public class BitBullet extends Bullet {
 
-	public BitBullet(double x, double y, int colid, double angle){
-		super(x, y, "bul5", colid, angle);
-		this.velocity = 4;
-		this.damage = 0.2;
-	}
+    public BitBullet(double x, double y, int colid, double angle) {
+        super(x, y, "bul5", colid, angle);
+        this.velocity = 4;
+        this.damage = 0.2;
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/bullet/Bullet.java b/app/src/main/java/com/kaeruct/raumballer/bullet/Bullet.java
index 20f9354..56b875d 100644
--- a/app/src/main/java/com/kaeruct/raumballer/bullet/Bullet.java
+++ b/app/src/main/java/com/kaeruct/raumballer/bullet/Bullet.java
@@ -1,42 +1,43 @@
 package com.kaeruct.raumballer.bullet;
+
 import com.kaeruct.raumballer.Explosion;
+
 import jgame.JGObject;
-import jgame.platform.JGEngine;
-
-public abstract class Bullet extends JGObject{
-	
-	private double angle;
-	protected int velocity;
-	public double damage;
-	public int width;
-	
-	public Bullet(double x, double y, String anim, int colid,  double angle){
-		super("bullet", true, x, y, colid, anim);
-		
-		this.velocity = 4;
-		this.damage = 1;
-		this.width = 8;
-		this.angle = angle;
-		this.expiry = -2;
-		
-		// center
-		this.x -= width/2;
-		
-		if(!(angle >= 0 && angle <= Math.PI)){
-			this.setAnim(anim+"u");
-		}
-	}
-	
-	public void move(){
-		x += Math.cos(angle)*velocity*gamespeed;
-		y -= Math.sin(angle)*velocity*gamespeed;
-	}
-	
-	public void hit(JGObject obj){
-
-		if(obj instanceof Bullet){
-			new Explosion(x, y, "blue");
-			this.remove();
-		}
-	}
+
+public abstract class Bullet extends JGObject {
+
+    private final double angle;
+    protected int velocity;
+    public double damage;
+    public int width;
+
+    public Bullet(double x, double y, String anim, int colid, double angle) {
+        super("bullet", true, x, y, colid, anim);
+
+        this.velocity = 4;
+        this.damage = 1;
+        this.width = 8;
+        this.angle = angle;
+        this.expiry = -2;
+
+        // center
+        this.x -= width / 2;
+
+        if (!(angle >= 0 && angle <= Math.PI)) {
+            this.setAnim(anim + "u");
+        }
+    }
+
+    public void move() {
+        x += Math.cos(angle) * velocity * gamespeed;
+        y -= Math.sin(angle) * velocity * gamespeed;
+    }
+
+    public void hit(JGObject obj) {
+
+        if (obj instanceof Bullet) {
+            new Explosion(x, y, "blue");
+            this.remove();
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/bullet/DiscBullet.java b/app/src/main/java/com/kaeruct/raumballer/bullet/DiscBullet.java
index 833c781..c70ee0f 100644
--- a/app/src/main/java/com/kaeruct/raumballer/bullet/DiscBullet.java
+++ b/app/src/main/java/com/kaeruct/raumballer/bullet/DiscBullet.java
@@ -1,10 +1,10 @@
 package com.kaeruct.raumballer.bullet;
 
-public class DiscBullet extends Bullet{
+public class DiscBullet extends Bullet {
 
-	public DiscBullet(double x, double y, int colid, double angle){
-		super(x, y, "bul3", colid, angle);
-		this.velocity = 5;
-		this.damage = 0.5;
-	}
+    public DiscBullet(double x, double y, int colid, double angle) {
+        super(x, y, "bul3", colid, angle);
+        this.velocity = 5;
+        this.damage = 0.5;
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/bullet/FireBullet.java b/app/src/main/java/com/kaeruct/raumballer/bullet/FireBullet.java
index a534bcc..ab9a7d6 100644
--- a/app/src/main/java/com/kaeruct/raumballer/bullet/FireBullet.java
+++ b/app/src/main/java/com/kaeruct/raumballer/bullet/FireBullet.java
@@ -1,10 +1,10 @@
 package com.kaeruct.raumballer.bullet;
 
-public class FireBullet extends Bullet{
+public class FireBullet extends Bullet {
 
-	public FireBullet(double x, double y, int colid, double angle){
-		super(x, y, "bul4", colid, angle);
-		this.velocity = 4;
-		this.damage = 2;
-	}
+    public FireBullet(double x, double y, int colid, double angle) {
+        super(x, y, "bul4", colid, angle);
+        this.velocity = 4;
+        this.damage = 2;
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/bullet/PlasmaBullet.java b/app/src/main/java/com/kaeruct/raumballer/bullet/PlasmaBullet.java
index fa0876b..77075ef 100644
--- a/app/src/main/java/com/kaeruct/raumballer/bullet/PlasmaBullet.java
+++ b/app/src/main/java/com/kaeruct/raumballer/bullet/PlasmaBullet.java
@@ -1,10 +1,10 @@
 package com.kaeruct.raumballer.bullet;
 
-public class PlasmaBullet extends Bullet{
+public class PlasmaBullet extends Bullet {
 
-	public PlasmaBullet(double x, double y, int colid, double angle){
-		super(x, y, "bul1", colid, angle);
-		this.velocity = 3;
-		this.damage = 3;
-	}
+    public PlasmaBullet(double x, double y, int colid, double angle) {
+        super(x, y, "bul1", colid, angle);
+        this.velocity = 3;
+        this.damage = 3;
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/bullet/SparkBullet.java b/app/src/main/java/com/kaeruct/raumballer/bullet/SparkBullet.java
index 7b81eab..9fbc0f6 100644
--- a/app/src/main/java/com/kaeruct/raumballer/bullet/SparkBullet.java
+++ b/app/src/main/java/com/kaeruct/raumballer/bullet/SparkBullet.java
@@ -1,10 +1,10 @@
 package com.kaeruct.raumballer.bullet;
 
-public class SparkBullet extends Bullet{
+public class SparkBullet extends Bullet {
 
-	public SparkBullet(double x, double y, int colid, double angle){
-		super(x, y, "bul2", colid, angle);
-		this.velocity = 6;
-		this.damage = 1;
-	}
+    public SparkBullet(double x, double y, int colid, double angle) {
+        super(x, y, "bul2", colid, angle);
+        this.velocity = 6;
+        this.damage = 1;
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/BitWaveCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/BitWaveCannon.java
index e273064..f03732e 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/BitWaveCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/BitWaveCannon.java
@@ -1,21 +1,22 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.BitBullet;
 
-public class BitWaveCannon extends Cannon{
-	
-	public BitWaveCannon(){
-		super();
-		waitTime = 3;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			double v = (Math.cos(t*4)/4);
-			new BitBullet(x, y, colid, angle-v);
-			new BitBullet(x, y, colid, angle+v);
-			
-			//game.playAudio("shoot");
-		}
-	}
+public class BitWaveCannon extends Cannon {
+
+    public BitWaveCannon() {
+        super();
+        waitTime = 3;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            double v = (Math.cos(t * 4) / 4);
+            new BitBullet(x, y, colid, angle - v);
+            new BitBullet(x, y, colid, angle + v);
+
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/Cannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/Cannon.java
index 3f6dd7e..455bd82 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/Cannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/Cannon.java
@@ -4,34 +4,34 @@ import com.kaeruct.raumballer.AndroidGame;
 
 public abstract class Cannon {
 
-	public int waitTime;
-	public static AndroidGame game;
-	public int lastShoot;
-	
-	public Cannon(){
-		waitTime = 5;
-		lastShoot = 0;
-	}
-	
-	public int getWaitTime(){
-		return waitTime;
-	}
-	
-	public void setLastShoot(int t){
-		lastShoot = t;
-	}
-	
-	public int getLastShoot(){
-		return lastShoot;
-	}
-	
-	public boolean canShoot(int t){
-		if(t - getLastShoot() >= getWaitTime()){
-			setLastShoot(t);
-			return true;
-		}
-		return false;
-	}
-	
-	public abstract void shoot(double x, double y, double angle, int colid, int t);
+    public int waitTime;
+    public static AndroidGame game;
+    public int lastShoot;
+
+    public Cannon() {
+        waitTime = 5;
+        lastShoot = 0;
+    }
+
+    public int getWaitTime() {
+        return waitTime;
+    }
+
+    public void setLastShoot(int t) {
+        lastShoot = t;
+    }
+
+    public int getLastShoot() {
+        return lastShoot;
+    }
+
+    public boolean canShoot(int t) {
+        if (t - getLastShoot() >= getWaitTime()) {
+            setLastShoot(t);
+            return true;
+        }
+        return false;
+    }
+
+    public abstract void shoot(double x, double y, double angle, int colid, int t);
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/CombinedCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/CombinedCannon.java
index ca6d6dd..58c5738 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/CombinedCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/CombinedCannon.java
@@ -1,21 +1,21 @@
 package com.kaeruct.raumballer.cannon;
 
-public class CombinedCannon extends Cannon{
-	
-	private Cannon[] cannons;
-	
-	public CombinedCannon(Cannon[] c){
-		super();
-		this.cannons = c;
-		waitTime = 1;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			for(int i = 0; i < cannons.length; i++){
-				cannons[i].shoot(x, y, angle, colid, t);
-			}
-		}
-	}
+public class CombinedCannon extends Cannon {
+
+    private final Cannon[] cannons;
+
+    public CombinedCannon(Cannon[] c) {
+        super();
+        this.cannons = c;
+        waitTime = 1;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            for (int i = 0; i < cannons.length; i++) {
+                cannons[i].shoot(x, y, angle, colid, t);
+            }
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/DiscCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/DiscCannon.java
index 8abbf92..e6a8642 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/DiscCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/DiscCannon.java
@@ -1,19 +1,20 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.DiscBullet;
 
-public class DiscCannon extends Cannon{
-	
-	public DiscCannon(){
-		super();
-		waitTime = 4;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			new DiscBullet(x, y, colid, angle);
-			new DiscBullet(x, y-8, colid, angle);
-			//game.playAudio("shoot");
-		}
-	}
+public class DiscCannon extends Cannon {
+
+    public DiscCannon() {
+        super();
+        waitTime = 4;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            new DiscBullet(x, y, colid, angle);
+            new DiscBullet(x, y - 8, colid, angle);
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/FireCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/FireCannon.java
index 1487d9c..cd7f5c3 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/FireCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/FireCannon.java
@@ -1,18 +1,19 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.FireBullet;
 
-public class FireCannon extends Cannon{
-	
-	public FireCannon(){
-		super();
-		waitTime = 12;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			new FireBullet(x, y, colid, angle);
-			//game.playAudio("shoot");
-		}
-	}
+public class FireCannon extends Cannon {
+
+    public FireCannon() {
+        super();
+        waitTime = 12;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            new FireBullet(x, y, colid, angle);
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/NanoCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/NanoCannon.java
index 677209a..bacf639 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/NanoCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/NanoCannon.java
@@ -1,19 +1,20 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.BitBullet;
 
-public class NanoCannon extends Cannon{
-	
-	public NanoCannon(){
-		super();
-		waitTime = 3;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			new BitBullet(x, y, colid, angle);
-			
-			//game.playAudio("shoot");
-		}
-	}
+public class NanoCannon extends Cannon {
+
+    public NanoCannon() {
+        super();
+        waitTime = 3;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            new BitBullet(x, y, colid, angle);
+
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/PlasmaCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/PlasmaCannon.java
index a849cca..4ab38bd 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/PlasmaCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/PlasmaCannon.java
@@ -1,20 +1,21 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.PlasmaBullet;
 
-public class PlasmaCannon extends Cannon{
-	
-	public PlasmaCannon(){
-		super();
-		waitTime = 16;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			new PlasmaBullet(x, y, colid, angle);
-			new PlasmaBullet(x-2, y-4, colid, angle);
-			new PlasmaBullet(x+2, y-4, colid, angle);
-			//game.playAudio("shoot");
-		}
-	}
+public class PlasmaCannon extends Cannon {
+
+    public PlasmaCannon() {
+        super();
+        waitTime = 16;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            new PlasmaBullet(x, y, colid, angle);
+            new PlasmaBullet(x - 2, y - 4, colid, angle);
+            new PlasmaBullet(x + 2, y - 4, colid, angle);
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/ShipCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/ShipCannon.java
index 60da52e..e2fb45a 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/ShipCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/ShipCannon.java
@@ -1,23 +1,24 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.ship.player.SpinTurn;
 
-public class ShipCannon extends Cannon{
-	
-	public ShipCannon(){
-		super();
-		waitTime = 20;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			SpinTurn a = new SpinTurn((int)x, (int)y, game);
-			a.setHealth(0);
-			a.cannons.set(0, new CombinedCannon(new Cannon[]{}));
-			a.cannonPrototypes[0] = new CombinedCannon(new Cannon[]{});
-			a.cannonPrototypes[1] = new CombinedCannon(new Cannon[]{});
-			a.cannonPrototypes[2] = new CombinedCannon(new Cannon[]{});
-			//game.playAudio("shoot");
-		}
-	}
+public class ShipCannon extends Cannon {
+
+    public ShipCannon() {
+        super();
+        waitTime = 20;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            SpinTurn a = new SpinTurn((int) x, (int) y, game);
+            a.setHealth(0);
+            a.cannons.set(0, new CombinedCannon(new Cannon[]{}));
+            a.cannonPrototypes[0] = new CombinedCannon(new Cannon[]{});
+            a.cannonPrototypes[1] = new CombinedCannon(new Cannon[]{});
+            a.cannonPrototypes[2] = new CombinedCannon(new Cannon[]{});
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/SoloPlasmaCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/SoloPlasmaCannon.java
index 0747d82..71ba7e1 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/SoloPlasmaCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/SoloPlasmaCannon.java
@@ -1,19 +1,20 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.PlasmaBullet;
 
-public class SoloPlasmaCannon extends Cannon{
-	
-	public SoloPlasmaCannon(){
-		super();
-		waitTime = 5;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			
-			new PlasmaBullet(x, y, colid, angle);
-			//game.playAudio("shoot");
-		}
-	}
+public class SoloPlasmaCannon extends Cannon {
+
+    public SoloPlasmaCannon() {
+        super();
+        waitTime = 5;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+
+            new PlasmaBullet(x, y, colid, angle);
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/SparkCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/SparkCannon.java
index 7b094b3..df97e01 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/SparkCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/SparkCannon.java
@@ -1,17 +1,18 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.SparkBullet;
 
-public class SparkCannon extends Cannon{
-	
-	public SparkCannon(){
-		super();
-		waitTime = 4;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		if(canShoot(t)){
-			new SparkBullet(x, y, colid, angle);
-			
-		}
-	}
+public class SparkCannon extends Cannon {
+
+    public SparkCannon() {
+        super();
+        waitTime = 4;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+        if (canShoot(t)) {
+            new SparkBullet(x, y, colid, angle);
+
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/cannon/TripleFireCannon.java b/app/src/main/java/com/kaeruct/raumballer/cannon/TripleFireCannon.java
index 558bf9e..f81cc24 100644
--- a/app/src/main/java/com/kaeruct/raumballer/cannon/TripleFireCannon.java
+++ b/app/src/main/java/com/kaeruct/raumballer/cannon/TripleFireCannon.java
@@ -1,20 +1,21 @@
 package com.kaeruct.raumballer.cannon;
+
 import com.kaeruct.raumballer.bullet.FireBullet;
 
-public class TripleFireCannon extends Cannon{
-	
-	public TripleFireCannon(){
-		super();
-		waitTime = 12;
-	}
-	
-	public void shoot(double x, double y, double angle, int colid, int t){
-		
-		if(canShoot(t)){
-			new FireBullet(x, y, colid, angle);
-			new FireBullet(x, y, colid, angle+0.1);
-			new FireBullet(x, y, colid, angle-0.1);
-			//game.playAudio("shoot");
-		}
-	}
+public class TripleFireCannon extends Cannon {
+
+    public TripleFireCannon() {
+        super();
+        waitTime = 12;
+    }
+
+    public void shoot(double x, double y, double angle, int colid, int t) {
+
+        if (canShoot(t)) {
+            new FireBullet(x, y, colid, angle);
+            new FireBullet(x, y, colid, angle + 0.1);
+            new FireBullet(x, y, colid, angle - 0.1);
+            //game.playAudio("shoot");
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/EnemyShip.java b/app/src/main/java/com/kaeruct/raumballer/ship/EnemyShip.java
index 466e692..a4bd349 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/EnemyShip.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/EnemyShip.java
@@ -1,14 +1,15 @@
 package com.kaeruct.raumballer.ship;
+
 import com.kaeruct.raumballer.AndroidGame;
 
 
 public abstract class EnemyShip extends Ship {
 
-	public EnemyShip(double x, double y, String anim, double maxHealth, AndroidGame game) {
-		super(x, y, "enemy", game.ENEMY_ID, anim, maxHealth, game);
+    public EnemyShip(double x, double y, String anim, double maxHealth, AndroidGame game) {
+        super(x, y, "enemy", game.ENEMY_ID, anim, maxHealth, game);
 
-		this.velocity = 1;
-		this.angle = Math.PI*3/2;
-		this.width = 16;
-	}
+        this.velocity = 1;
+        this.angle = Math.PI * 3 / 2;
+        this.width = 16;
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/PlayerShip.java b/app/src/main/java/com/kaeruct/raumballer/ship/PlayerShip.java
index 537601a..c36e35a 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/PlayerShip.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/PlayerShip.java
@@ -1,83 +1,87 @@
 package com.kaeruct.raumballer.ship;
 
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
-
-import jgame.platform.JGEngine;
+import com.kaeruct.raumballer.cannon.Cannon;
 
 public abstract class PlayerShip extends Ship {
 
-	public Cannon[] cannonPrototypes;
-	protected double acc;
-	
-	public PlayerShip(int x, int y, String anim, int health, AndroidGame game) {
-		super(x, y, "player", game.PLAYER_ID, anim, health, game);
-		this.velocity = 2;
-		this.acc = 0.1;
-		this.angle = Math.PI/2;
-		this.explosionColor = "blue";
-		this.width = 16;
-		this.cannonPrototypes = new Cannon[3];
-	}
-	
-	public void move(){
-		super.update();
+    public Cannon[] cannonPrototypes;
+    protected double acc;
+
+    public PlayerShip(int x, int y, String anim, int health, AndroidGame game) {
+        super(x, y, "player", game.PLAYER_ID, anim, health, game);
+        this.velocity = 2;
+        this.acc = 0.1;
+        this.angle = Math.PI / 2;
+        this.explosionColor = "blue";
+        this.width = 16;
+        this.cannonPrototypes = new Cannon[4];
+    }
+
+    public void move() {
+        super.update();
+
+        // shooting
+        boolean shooting = true;
+        if (shooting) {
+
+            shoot();
+
+            // bounce
+            // bounce is annoying, never uncomment
+            //if(yspeed < velocity)
+            //	this.yspeed += acc*0.1;
+
+            if (clock % 10 == 0) {
+                game.playAudio("laser");
+            }
+        }
+
+        double xacc = 0;
+        double yacc = 0;
+        if (game.isTapping) {
+            double rad = Math.atan2(eng.getMouseY() - getLastY(), eng.getMouseX() - getLastX());
+            xacc = Math.cos(rad) * 0.1;
+            yacc = Math.sin(rad) * 0.1;
+        }
 
-		String type = "1";
-		
-		if(type.equals("1")){
-			this.cannons.clear();
-			this.cannons.add(this.cannonPrototypes[0]);
-		}else if(type.equals("2")){
-			this.cannons.clear();
-			this.cannons.add(this.cannonPrototypes[1]);
-		}else if(type.equals("3")){
-			this.cannons.clear();
-			this.cannons.add(this.cannonPrototypes[2]);
-		}
-		// shooting
-		boolean shooting = true;
-		if(shooting) {
-			
-			shoot();
-			
-			// bounce
-			// bounce is annoying, never uncomment
-			//if(yspeed < velocity)
-			//	this.yspeed += acc*0.1;
-			
-			if (clock%5==0) {
-				game.playAudio("laser");
-			}
-		}
+        this.xspeed += xacc;
+        this.yspeed += yacc;
 
-		double xacc = 0;
-		double yacc = 0;
-		if (game.isTapping) {
-			double angle = Math.atan2(getLastY(), getLastX()) - Math.atan2(game.getMouseY(), game.getMouseX());
-			xacc = Math.cos(angle) * 0.05;
-			yacc = Math.sin(angle) * 0.05;
-			System.out.println(angle);
-		}
+        if (yspeed != 0) {
+            yspeed += 0.3 * (yspeed < 0 ? acc : -acc);
+        }
+        if (xspeed != 0) {
+            xspeed += 0.3 * (xspeed < 0 ? acc : -acc);
+        }
 
-		this.xspeed += xacc;
-		this.yspeed += yacc;
+        // correcting bounds (wrap horizontally)
+        if (x <= -8)
+            x = game.pfWidth() - 9;
+        if (y <= -8)
+            y = -8;
+        if (x + 8 >= game.pfWidth())
+            x = -8;
+        if (y + 8 >= game.pfHeight())
+            y = game.pfHeight() - 8;
+    }
 
-		if (yspeed != 0) {
-			yspeed += 0.1*(yspeed < 0 ? acc : -acc);
-		}
-		if (xspeed != 0) {
-			xspeed += 0.1*(xspeed < 0 ? acc : -acc);
-		}
-		
-		// correcting bounds (wrap horizontally)
-		if(x <= -8)
-			x = game.pfWidth()-9;
-		if(y <= -8)
-			y = -8;
-		if(x+8 >= game.pfWidth())
-			x = -8;
-		if(y+8 >= game.pfHeight())
-			y = game.pfHeight()-8;
-	}
+    @Override
+    public void onScore(int score) {
+        if (score >= 50000) {
+            this.cannons.clear();
+            this.cannons.add(this.cannonPrototypes[3]);
+            return;
+        }
+        if (score >= 25000) {
+            this.cannons.clear();
+            this.cannons.add(this.cannonPrototypes[2]);
+            return;
+        }
+        if (score >= 10000) {
+            this.cannons.clear();
+            this.cannons.add(this.cannonPrototypes[1]);
+            return;
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/Ship.java b/app/src/main/java/com/kaeruct/raumballer/ship/Ship.java
index 16892ee..a11eae8 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/Ship.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/Ship.java
@@ -1,163 +1,168 @@
 package com.kaeruct.raumballer.ship;
-import java.util.ArrayList;
 
-import com.kaeruct.raumballer.Explosion;
 import com.kaeruct.raumballer.AndroidGame;
+import com.kaeruct.raumballer.Explosion;
 import com.kaeruct.raumballer.bullet.Bullet;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.Cannon;
+
+import java.util.ArrayList;
 
 import jgame.JGObject;
 import jgame.JGTimer;
 
 public abstract class Ship extends JGObject {
-	
-	protected AndroidGame game;
-	protected double velocity;
-	public ArrayList<Cannon> cannons;
-	private static int flashingTime = 32;
-	private String baseAnimation;
-	protected double angle;
-	private double health;
-	private double maxHealth;
-	protected int flashStart;
-	protected String explosionColor;
-	protected int clock;
-	public int width;
-	protected Ship parent;
-	protected boolean sturdy; // don't get hurt at all if hit by ships
-	
-	public Ship(double x, double y, String name, int cid, String graphic, double maxHealth, AndroidGame game) {
-		super(name, true, x, y, cid, graphic);
-		this.game = game;
-		this.velocity = 1; // max speed
-		this.maxHealth = maxHealth;
-		this.angle = Math.PI*2;
-		this.expiry = -2;
-		this.baseAnimation = graphic;
-		this.explosionColor = "red";
-		this.setBBox(4, 4, 8, 8);
-		this.clock = 0;
-		this.width = 16;
-		this.parent = null;
-		this.sturdy = false;
-		this.setHealth(maxHealth);
-
-		// initialize cannons
-		this.cannons = new ArrayList<Cannon>();	
-	}
-	
-	public boolean flashing(){
-		
-		if(this.flashStart == 0)
-			return false;
-		else
-			return this.flashStart > game.t-flashingTime;
-	}
-	
-	// begin flashing
-	private void flash(){
-		if(!flashing()){
-			this.flashStart = this.game.t;
-			this.setAnim(baseAnimation+"_flash");
-		}
-	}
-	
-	public String getMode(){
-		String mode = this.cannons.get(0).getClass().getName();
-		return mode.replaceAll("com\\.kaeruct\\.raumballer\\.cannon\\.", "");
-	}
-	
-	// shoot in the same direction the ship is looking
-	public void shoot(){
-		shoot(this.angle);
-	}
-	
-	// shoot at an specific direction
-	public void shoot(double angle){
-		for(Cannon currentCannon : this.cannons){
-			currentCannon.shoot(x+this.width/2, y, angle, this.colid, game.t);
-		}
-		
-	}
-	
-	// update stuff not related to movement
-	public void update(){
-		clock++;
-		if(!flashing()){
-			this.setAnim(baseAnimation);
-		}
-	}
-	
-	public void move(){
-		// movement
-		this.update();
-		x += Math.cos(angle)*velocity*gamespeed;
-		y -= Math.sin(angle)*velocity*gamespeed;
-	}
-	
-	public void hurt(double n){
-		this.setHealth(this.getHealth() - n);
-		
-		if(this.getHealth() <= 0){
-			this.setHealth(0);
-			kill();
-		}
-	}
-	
-	public void kill(){
-		
-		final int offset = this.width/2-8; // 16/2 is explosion width
-		final int r = this.width/2;
-		
-		new Explosion(x+offset, y+offset, explosionColor);
-		
-		for(int i = 0; i < this.width; i+=8){
-			new JGTimer(game.random(i, i+20, 1), true){public void alarm(){
-				new Explosion(x+offset, y+offset+game.random(-r, r), explosionColor);
-				new Explosion(x+offset+game.random(-r, r), y, explosionColor);
-				new Explosion(x+offset, y+offset, explosionColor);
-			}};
-		}
-		
-		game.playAudio("explode");
-		
-		remove();
-	}
-	
-	public void hit(JGObject obj){
-		if(obj instanceof Bullet){
-			Bullet b = ((Bullet)obj);
-			hurt(b.damage);
-			b.remove();
-			
-			flash();
-			
-			// increase score if it was an enemy ship
-			if(this.isDead() && this instanceof EnemyShip){
-				this.game.score += this.maxHealth*100;
-			}
-			
-		}else if(obj instanceof Ship && !sturdy){
-			Ship s = ((Ship)obj);
-			hurt(2*s.getHealth()/this.getHealth());
-			flash();
-		}
-	}
-
-	public double getHealth() {
-		return health;
-	}
-
-	public void setHealth(double health) {
-		this.health = health;
-	}
-	
-	public boolean isDead(){
-		return this.getHealth() == 0;
-	}
-
-	public void setParent(Ship parent) {
-		this.parent = parent;
-		
-	}
+
+    protected AndroidGame game;
+    protected double velocity;
+    public ArrayList<Cannon> cannons;
+    private static final int flashingTime = 32;
+    private final String baseAnimation;
+    protected double angle;
+    private double health;
+    private final double maxHealth;
+    protected int flashStart;
+    protected String explosionColor;
+    protected int clock;
+    public int width;
+    protected Ship parent;
+    protected boolean sturdy; // don't get hurt at all if hit by ships
+
+    public Ship(double x, double y, String name, int cid, String graphic, double maxHealth, AndroidGame game) {
+        super(name, true, x, y, cid, graphic);
+        this.game = game;
+        this.velocity = 1; // max speed
+        this.maxHealth = maxHealth;
+        this.angle = Math.PI * 2;
+        this.expiry = -2;
+        this.baseAnimation = graphic;
+        this.explosionColor = "red";
+        this.setBBox(4, 4, 8, 8);
+        this.clock = 0;
+        this.width = 16;
+        this.parent = null;
+        this.sturdy = false;
+        this.setHealth(maxHealth);
+
+        // initialize cannons
+        this.cannons = new ArrayList<Cannon>();
+    }
+
+    public boolean flashing() {
+
+        if (this.flashStart == 0)
+            return false;
+        else
+            return this.flashStart > game.t - flashingTime;
+    }
+
+    // begin flashing
+    private void flash() {
+        if (!flashing()) {
+            this.flashStart = this.game.t;
+            this.setAnim(baseAnimation + "_flash");
+        }
+    }
+
+    public String getMode() {
+        String mode = this.cannons.get(0).getClass().getName();
+        return mode.replaceAll("com\\.kaeruct\\.raumballer\\.cannon\\.", "");
+    }
+
+    // shoot in the same direction the ship is looking
+    public void shoot() {
+        shoot(this.angle);
+    }
+
+    // shoot at an specific direction
+    public void shoot(double angle) {
+        for (Cannon currentCannon : this.cannons) {
+            currentCannon.shoot(x + this.width / 2, y, angle, this.colid, game.t);
+        }
+
+    }
+
+    // update stuff not related to movement
+    public void update() {
+        clock++;
+        if (!flashing()) {
+            this.setAnim(baseAnimation);
+        }
+    }
+
+    public void move() {
+        // movement
+        this.update();
+        x += Math.cos(angle) * velocity * gamespeed;
+        y -= Math.sin(angle) * velocity * gamespeed;
+    }
+
+    public void hurt(double n) {
+        this.setHealth(this.getHealth() - n);
+
+        if (this.getHealth() <= 0) {
+            this.setHealth(0);
+            kill();
+        }
+    }
+
+    public void kill() {
+
+        final int offset = this.width / 2 - 8; // 16/2 is explosion width
+        final int r = this.width / 2;
+
+        new Explosion(x + offset, y + offset, explosionColor);
+
+        for (int i = 0; i < this.width; i += 8) {
+            new JGTimer(game.random(i, i + 20, 1), true) {
+                public void alarm() {
+                    new Explosion(x + offset, y + offset + game.random(-r, r), explosionColor);
+                    new Explosion(x + offset + game.random(-r, r), y, explosionColor);
+                    new Explosion(x + offset, y + offset, explosionColor);
+                }
+            };
+        }
+
+        game.playAudio("explode");
+
+        remove();
+    }
+
+    public void hit(JGObject obj) {
+        if (obj instanceof Bullet) {
+            Bullet b = ((Bullet) obj);
+            hurt(b.damage);
+            b.remove();
+
+            flash();
+
+            // increase score if it was an enemy ship
+            if (this.isDead() && this instanceof EnemyShip) {
+                this.game.addScore(this.maxHealth * 100);
+            }
+
+        } else if (obj instanceof Ship && !sturdy) {
+            Ship s = ((Ship) obj);
+            hurt(2 * s.getHealth() / this.getHealth());
+            flash();
+        }
+    }
+
+    public double getHealth() {
+        return health;
+    }
+
+    public void setHealth(double health) {
+        this.health = health;
+    }
+
+    public boolean isDead() {
+        return this.getHealth() == 0;
+    }
+
+    public void setParent(Ship parent) {
+        this.parent = parent;
+    }
+
+    public void onScore(int score) {
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/Asterisk.java b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/Asterisk.java
index 7a867fe..e03cd19 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/Asterisk.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/Asterisk.java
@@ -1,40 +1,41 @@
 package com.kaeruct.raumballer.ship.enemy;
+
 import com.kaeruct.raumballer.AndroidGame;
 import com.kaeruct.raumballer.ship.EnemyShip;
 
 public class Asterisk extends EnemyShip {
 
-	private double offset;
-	private double radius;
-	
-	public Asterisk(double x, double y, double vel, double angle, AndroidGame game) {
-		super(x, y, "asterisk", 5, game);
-
-		this.velocity = vel;
-		this.angle = angle;
-		this.explosionColor = "blue";
-		this.width = 16;
-		this.radius = 12; // distance from ship to "orbit"
-		this.offset = angle;
-		this.sturdy = true;
-		this.expiry = -1;
-	}
-	
-	public void move(){
-		super.move();
-		
-		x = parent.x - Math.cos(-offset)*radius;
-		y = parent.y + Math.sin(offset)*radius;
-		
-		offset += 1;
-		
-		// removing if out of range
-		if(x <= -32 || y <= -32 || x-32 >= game.pfWidth() || y-32 >= game.pfHeight())
-			remove();
-		
-		// die if parent died
-		if(!parent.isAlive()){
-			this.kill();
-		}
-	}
+    private double offset;
+    private final double radius;
+
+    public Asterisk(double x, double y, double vel, double angle, AndroidGame game) {
+        super(x, y, "asterisk", 5, game);
+
+        this.velocity = vel;
+        this.angle = angle;
+        this.explosionColor = "blue";
+        this.width = 16;
+        this.radius = 12; // distance from ship to "orbit"
+        this.offset = angle;
+        this.sturdy = true;
+        this.expiry = -1;
+    }
+
+    public void move() {
+        super.move();
+
+        x = parent.x - Math.cos(-offset) * radius;
+        y = parent.y + Math.sin(offset) * radius;
+
+        offset += 1;
+
+        // removing if out of range
+        if (x <= -32 || y <= -32 || x - 32 >= game.pfWidth() || y - 32 >= game.pfHeight())
+            remove();
+
+        // die if parent died
+        if (!parent.isAlive()) {
+            this.kill();
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/CibumDestroyer.java b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/CibumDestroyer.java
index 4527f99..841248e 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/CibumDestroyer.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/CibumDestroyer.java
@@ -1,38 +1,40 @@
 package com.kaeruct.raumballer.ship.enemy;
+
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.SoloPlasmaCannon;
+import com.kaeruct.raumballer.cannon.TripleFireCannon;
 import com.kaeruct.raumballer.ship.EnemyShip;
 
 public class CibumDestroyer extends EnemyShip {
 
-	public CibumDestroyer(double x, double y, double vel, double angle, AndroidGame game) {
-		super(x, y, "cibumdestroyer", 50, game);
+    public CibumDestroyer(double x, double y, double vel, double angle, AndroidGame game) {
+        super(x, y, "cibumdestroyer", 50, game);
+
+        this.velocity = vel;
+        this.angle = angle;
+        this.cannons.add(new TripleFireCannon());
+        this.cannons.add(new SoloPlasmaCannon());
+        this.explosionColor = "red";
+        this.setBBox(4, 4, 24, 24);
+        this.width = 32;
+    }
+
+    public void move() {
+        super.move();
+
+        if (clock % 60 == 0) {
+            double ang = game.atan2(y - game.getPlayer().y, game.getPlayer().x - x);
+            shoot(ang);
+        }
+        // only attempt to stay in screen if not near boundaries
+        if (x >= 8 && x + 8 <= game.viewWidth()) {
+            if (y + 32 >= game.viewHeight() && game.goingDown(angle) ||
+                    y <= 32 && game.goingUp(angle)) {
 
-		this.velocity = vel;
-		this.angle = angle;
-		this.cannons.add(new TripleFireCannon());
-		this.cannons.add(new SoloPlasmaCannon());
-		this.explosionColor = "red";
-		this.setBBox(4, 4, 24, 24);
-		this.width = 32;
-	}
-	
-	public void move(){
-		super.move();
-		
-		if(clock%60 == 0){
-			double ang = game.atan2(y-game.getPlayer().y, game.getPlayer().x-x);
-			shoot(ang);
-		}
-		// only attempt to stay in screen if not near boundaries
-		if(x >= 8 && x+8 <= game.viewWidth()){
-			if(y+32 >= game.viewHeight() && game.goingDown(angle) ||
-				y <= 32 && game.goingUp(angle)){
-				
-				if(game.random(0, 1, 1) == 1){
-					this.angle = -this.angle;
-				}
-			}
-		}
-	}
+                if (game.random(0, 1, 1) == 1) {
+                    this.angle = -this.angle;
+                }
+            }
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/FireStriker.java b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/FireStriker.java
index 1118005..f136e9e 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/FireStriker.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/FireStriker.java
@@ -1,41 +1,42 @@
 package com.kaeruct.raumballer.ship.enemy;
+
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.FireCannon;
 import com.kaeruct.raumballer.ship.EnemyShip;
 import com.kaeruct.raumballer.ship.PlayerShip;
 
 public class FireStriker extends EnemyShip {
 
-	public FireStriker(double x, double y, double vel, double angle, AndroidGame game) {
-		super(x, y, "firestriker", 5, game);
-
-		this.velocity = vel;
-		this.angle = angle;
-		this.cannons.add(new FireCannon());
-		this.explosionColor = "red";
-		this.width = 16;
-	}
-	
-	public void move(){
-		super.move();
-		
-		if(this.clock%10==0){
-			
-			if(this.clock%50 == 0){
-				this.angle = Math.PI*3/2;
-			}
-			
-			PlayerShip p = game.getPlayer();
-			double dFromPlayer = Math.sqrt(Math.pow(p.x-x, 2)+Math.pow(p.y-y, 2));
-			
-			if(dFromPlayer < 128){
-				this.angle = Math.PI*3/2;
-				this.velocity += 1.2;
-			}
-		}
-
-		if(game.t%10 == 0 && game.random(0, 1, 1)==1){
-			shoot(Math.PI*3/2);
-		}
-	}
+    public FireStriker(double x, double y, double vel, double angle, AndroidGame game) {
+        super(x, y, "firestriker", 5, game);
+
+        this.velocity = vel;
+        this.angle = angle;
+        this.cannons.add(new FireCannon());
+        this.explosionColor = "red";
+        this.width = 16;
+    }
+
+    public void move() {
+        super.move();
+
+        if (this.clock % 10 == 0) {
+
+            if (this.clock % 50 == 0) {
+                this.angle = Math.PI * 3 / 2;
+            }
+
+            PlayerShip p = game.getPlayer();
+            double dFromPlayer = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
+
+            if (dFromPlayer < 128) {
+                this.angle = Math.PI * 3 / 2;
+                this.velocity += 1.2;
+            }
+        }
+
+        if (game.t % 10 == 0 && game.random(0, 1, 1) == 1) {
+            shoot(Math.PI * 3 / 2);
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SpaceBall.java b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SpaceBall.java
index d5700f8..206e353 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SpaceBall.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SpaceBall.java
@@ -1,63 +1,64 @@
 package com.kaeruct.raumballer.ship.enemy;
+
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.BitWaveCannon;
 import com.kaeruct.raumballer.ship.EnemyShip;
 import com.kaeruct.raumballer.ship.PlayerShip;
 
 public class SpaceBall extends EnemyShip {
 
-	private boolean lockedOn;
-	private double offset;
-	private double radius;
-	
-	public SpaceBall(double x, double y, double vel, double angle, AndroidGame game) {
-		super(x, y, "spaceball", 5, game);
-
-		this.velocity = vel;
-		this.angle = angle;
-		this.cannons.add(new BitWaveCannon());
-		this.explosionColor = "red";
-		this.width = 16;
-		this.radius = 32; // distance from player to "orbit"
-		this.offset = 0;
-		this.lockedOn = false;
-		this.expiry = -1;
-	}
-	
-	public void move(){
-		super.move();
-		
-		PlayerShip p = game.getPlayer();
-		
-		if(this.lockedOn){
-
-			x = p.x - Math.cos(-offset)*radius;
-			y = p.y + Math.sin(offset)*radius;
-			
-			if(clock%20 == 0 && game.random(0, 2, 1)==1){
-				
-				double ang = game.atan2(y-p.y, p.x-x);
-				shoot(ang);
-			}
-			
-			offset += 0.05;
-		}else{
-
-			double dFromPlayer = Math.sqrt(Math.pow(p.x-x, 2)+Math.pow(p.y-y, 2));
-			double ang;
-			
-			if(clock%80==0){
-				ang = game.atan2(y-p.y, p.x-x);
-				this.angle = ang;
-			}
-			
-			if(dFromPlayer < radius){
-				ang = game.atan2(y-p.y, p.x-x);
-				this.lockedOn = true;
-				this.offset = ang;
-			}
-			
-			
-		}
-	}
+    private boolean lockedOn;
+    private double offset;
+    private final double radius;
+
+    public SpaceBall(double x, double y, double vel, double angle, AndroidGame game) {
+        super(x, y, "spaceball", 5, game);
+
+        this.velocity = vel;
+        this.angle = angle;
+        this.cannons.add(new BitWaveCannon());
+        this.explosionColor = "red";
+        this.width = 16;
+        this.radius = 32; // distance from player to "orbit"
+        this.offset = 0;
+        this.lockedOn = false;
+        this.expiry = -1;
+    }
+
+    public void move() {
+        super.move();
+
+        PlayerShip p = game.getPlayer();
+
+        if (this.lockedOn) {
+
+            x = p.x - Math.cos(-offset) * radius;
+            y = p.y + Math.sin(offset) * radius;
+
+            if (clock % 20 == 0 && game.random(0, 2, 1) == 1) {
+
+                double ang = game.atan2(y - p.y, p.x - x);
+                shoot(ang);
+            }
+
+            offset += 0.05;
+        } else {
+
+            double dFromPlayer = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
+            double ang;
+
+            if (clock % 80 == 0) {
+                ang = game.atan2(y - p.y, p.x - x);
+                this.angle = ang;
+            }
+
+            if (dFromPlayer < radius) {
+                ang = game.atan2(y - p.y, p.x - x);
+                this.lockedOn = true;
+                this.offset = ang;
+            }
+
+
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkDefender.java b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkDefender.java
index 5ba09aa..3cef6bc 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkDefender.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkDefender.java
@@ -1,33 +1,34 @@
 package com.kaeruct.raumballer.ship.enemy;
+
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.SparkCannon;
 import com.kaeruct.raumballer.ship.EnemyShip;
 
 public class SparkDefender extends EnemyShip {
 
-	public SparkDefender(double x, double y, double vel, double angle, AndroidGame game) {
-		super(x, y, "sparkdefender", 15, game);
+    public SparkDefender(double x, double y, double vel, double angle, AndroidGame game) {
+        super(x, y, "sparkdefender", 15, game);
+
+        this.velocity = vel;
+        this.angle = angle;
+        this.cannons.add(new SparkCannon());
+        this.explosionColor = "green";
+        this.width = 16;
+    }
+
+    public void move() {
+        super.move();
+
+        if (game.t % 30 == 0) {
+            shoot(Math.PI * 3 / 2);
+        }
+        // only attempt to stay in screen if not near boundaries
+        if (x >= 8 && x + 8 <= game.viewWidth()) {
+            if (y + 32 >= game.viewHeight() && game.goingDown(angle) ||
+                    y <= 32 && game.goingUp(angle)) {
 
-		this.velocity = vel;
-		this.angle = angle;
-		this.cannons.add(new SparkCannon());
-		this.explosionColor = "green";
-		this.width = 16;
-	}
-	
-	public void move(){
-		super.move();
-		
-		if(game.t%30 == 0){
-			shoot(Math.PI*3/2);
-		}
-		// only attempt to stay in screen if not near boundaries
-		if(x >= 8 && x+8 <= game.viewWidth()){
-			if(y+32 >= game.viewHeight() && game.goingDown(angle) ||
-				y <= 32 && game.goingUp(angle)){
-				
-				this.angle = -this.angle;
-			}
-		}
-	}
+                this.angle = -this.angle;
+            }
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkEye.java b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkEye.java
index 549484c..4c880c2 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkEye.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/enemy/SparkEye.java
@@ -1,31 +1,32 @@
 package com.kaeruct.raumballer.ship.enemy;
+
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.NanoCannon;
 import com.kaeruct.raumballer.ship.EnemyShip;
 
 public class SparkEye extends EnemyShip {
 
-	public SparkEye(double x, double y, double vel, double angle, AndroidGame game) {
-		super(x, y, "sparkeye", 20, game);
+    public SparkEye(double x, double y, double vel, double angle, AndroidGame game) {
+        super(x, y, "sparkeye", 20, game);
+
+        this.velocity = vel;
+        this.angle = angle;
+        this.cannons.add(new NanoCannon());
+        this.explosionColor = "red";
+        this.width = 16;
+        this.sturdy = true;
+    }
+
+    public void move() {
+        super.move();
+
+        if (game.t % 50 == 0) {
+            double ang = game.atan2(y - game.getPlayer().y, game.getPlayer().x - x);
+            shoot(ang + game.random(-0.5, 0.5));
 
-		this.velocity = vel;
-		this.angle = angle;
-		this.cannons.add(new NanoCannon());
-		this.explosionColor = "red";
-		this.width = 16;
-		this.sturdy = true;
-	}
-	
-	public void move(){
-		super.move();
-		
-		if(game.t%50 == 0){
-			double ang = game.atan2(y-game.getPlayer().y, game.getPlayer().x-x);
-			shoot(ang+game.random(-0.5, 0.5));
-			
-			if(game.random(0, 1, 1)==1){
-				this.angle = game.atan2(y-game.viewHeight()/2, game.viewWidth()/2-x);
-			}
-		}
-	}
+            if (game.random(0, 1, 1) == 1) {
+                this.angle = game.atan2(y - game.viewHeight() / 2, game.viewWidth() / 2 - x);
+            }
+        }
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/player/NimakRunner.java b/app/src/main/java/com/kaeruct/raumballer/ship/player/NimakRunner.java
index 3edad11..060910f 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/player/NimakRunner.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/player/NimakRunner.java
@@ -1,23 +1,29 @@
 package com.kaeruct.raumballer.ship.player;
 
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.Cannon;
+import com.kaeruct.raumballer.cannon.CombinedCannon;
+import com.kaeruct.raumballer.cannon.DiscCannon;
+import com.kaeruct.raumballer.cannon.FireCannon;
+import com.kaeruct.raumballer.cannon.NanoCannon;
+import com.kaeruct.raumballer.cannon.TripleFireCannon;
 import com.kaeruct.raumballer.ship.PlayerShip;
 
 public class NimakRunner extends PlayerShip {
-	
-	public NimakRunner(int x, int y, AndroidGame game) {
-		super(x, y, "player2", 80, game);
-		this.velocity = 2.2;
-		this.acc = 0.1;
-		this.explosionColor = "red";
-		this.width = 16;
-		this.cannonPrototypes[0] = new DiscCannon();
-		this.cannonPrototypes[1] = new FireCannon();
-		this.cannonPrototypes[2] = new CombinedCannon(new Cannon[]{
-				new TripleFireCannon(), new NanoCannon(), new FireCannon()
-		});
-		
-		this.cannons.add(cannonPrototypes[0]);
-	}
+
+    public NimakRunner(int x, int y, AndroidGame game) {
+        super(x, y, "player2", 80, game);
+        this.velocity = 1.8;
+        this.acc = 0.1;
+        this.explosionColor = "red";
+        this.width = 16;
+        this.cannonPrototypes[0] = new DiscCannon();
+        this.cannonPrototypes[1] = new FireCannon();
+        this.cannonPrototypes[2] = new TripleFireCannon();
+        this.cannonPrototypes[3] = new CombinedCannon(new Cannon[]{
+                new TripleFireCannon(), new NanoCannon(), new FireCannon()
+        });
+
+        this.cannons.add(cannonPrototypes[0]);
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/player/SpinTurn.java b/app/src/main/java/com/kaeruct/raumballer/ship/player/SpinTurn.java
index 9fd3285..f0805a1 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/player/SpinTurn.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/player/SpinTurn.java
@@ -1,23 +1,31 @@
 package com.kaeruct.raumballer.ship.player;
 
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.Cannon;
+import com.kaeruct.raumballer.cannon.CombinedCannon;
+import com.kaeruct.raumballer.cannon.FireCannon;
+import com.kaeruct.raumballer.cannon.NanoCannon;
+import com.kaeruct.raumballer.cannon.PlasmaCannon;
+import com.kaeruct.raumballer.cannon.SparkCannon;
 import com.kaeruct.raumballer.ship.PlayerShip;
 
 public class SpinTurn extends PlayerShip {
-	
-	public SpinTurn(int x, int y, AndroidGame game) {
-		super(x, y, "player3", 100, game);
-		this.velocity = 2.6;
-		this.acc = 0.2;
-		this.explosionColor = "blue";
-		this.width = 16;
-		this.cannonPrototypes[0] = new SparkCannon();
-		this.cannonPrototypes[1] = new FireCannon();
-		this.cannonPrototypes[2] = new CombinedCannon(new Cannon[]{
-				new SparkCannon(), new PlasmaCannon(), new NanoCannon()
-		});
-		
-		this.cannons.add(cannonPrototypes[0]);
-	}
+
+    public SpinTurn(int x, int y, AndroidGame game) {
+        super(x, y, "player3", 100, game);
+        this.velocity = 2.4;
+        this.acc = 0.2;
+        this.explosionColor = "blue";
+        this.width = 16;
+        this.cannonPrototypes[0] = new SparkCannon();
+        this.cannonPrototypes[1] = new FireCannon();
+        this.cannonPrototypes[2] = new CombinedCannon(new Cannon[]{
+                new SparkCannon(), new FireCannon()
+        });
+        this.cannonPrototypes[3] = new CombinedCannon(new Cannon[]{
+                new SparkCannon(), new PlasmaCannon(), new NanoCannon()
+        });
+
+        this.cannons.add(cannonPrototypes[0]);
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/ship/player/StenoShot.java b/app/src/main/java/com/kaeruct/raumballer/ship/player/StenoShot.java
index aa4be8c..76ed3c9 100644
--- a/app/src/main/java/com/kaeruct/raumballer/ship/player/StenoShot.java
+++ b/app/src/main/java/com/kaeruct/raumballer/ship/player/StenoShot.java
@@ -1,23 +1,31 @@
 package com.kaeruct.raumballer.ship.player;
 
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.cannon.*;
+import com.kaeruct.raumballer.cannon.BitWaveCannon;
+import com.kaeruct.raumballer.cannon.Cannon;
+import com.kaeruct.raumballer.cannon.CombinedCannon;
+import com.kaeruct.raumballer.cannon.DiscCannon;
+import com.kaeruct.raumballer.cannon.NanoCannon;
+import com.kaeruct.raumballer.cannon.SparkCannon;
 import com.kaeruct.raumballer.ship.PlayerShip;
 
 public class StenoShot extends PlayerShip {
-	
-	public StenoShot(int x, int y, AndroidGame game) {
-		super(x, y, "player1", 70, game);
-		this.velocity = 3.2;
-		this.acc = 0.3;
-		this.explosionColor = "green";
-		this.width = 16;
-		this.cannonPrototypes[0] = new DiscCannon();
-		this.cannonPrototypes[1] = new SparkCannon();
-		this.cannonPrototypes[2] = new CombinedCannon(new Cannon[]{
-				new NanoCannon(), new BitWaveCannon(), new DiscCannon()
-		});
-		
-		this.cannons.add(cannonPrototypes[0]);
-	}
+
+    public StenoShot(int x, int y, AndroidGame game) {
+        super(x, y, "player1", 70, game);
+        this.velocity = 3.0;
+        this.acc = 0.2;
+        this.explosionColor = "green";
+        this.width = 16;
+        this.cannonPrototypes[0] = new DiscCannon();
+        this.cannonPrototypes[1] = new SparkCannon();
+        this.cannonPrototypes[2] = new CombinedCannon(new Cannon[]{
+                new SparkCannon(), new DiscCannon()
+        });
+        this.cannonPrototypes[3] = new CombinedCannon(new Cannon[]{
+                new NanoCannon(), new BitWaveCannon(), new DiscCannon()
+        });
+
+        this.cannons.add(cannonPrototypes[0]);
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/wave/CibumWave.java b/app/src/main/java/com/kaeruct/raumballer/wave/CibumWave.java
index d09ca64..ef42f51 100644
--- a/app/src/main/java/com/kaeruct/raumballer/wave/CibumWave.java
+++ b/app/src/main/java/com/kaeruct/raumballer/wave/CibumWave.java
@@ -1,25 +1,25 @@
 package com.kaeruct.raumballer.wave;
 
-import com.kaeruct.raumballer.LevelReader;
 import com.kaeruct.raumballer.AndroidGame;
+import com.kaeruct.raumballer.LevelReader;
 
 public class CibumWave extends Wave {
-	
-	public CibumWave(AndroidGame game, LevelReader r, int maxAmount) {
-		super(game, r, maxAmount);
-		this.setFreq(200);
-		this.setShipClass("CibumDestroyer");
-	}
-	
-	public void spawn(){
 
-		double center = game.viewWidth()/2;
-		
-		super.spawn(
-			game.random(center-64, center+64),
-			-32,
-			0.5,
-			Math.PI*3/2-game.random(-0.1, 0.1)
-		);
-	}
+    public CibumWave(AndroidGame game, LevelReader r, int maxAmount) {
+        super(game, r, maxAmount);
+        this.setFreq(200);
+        this.setShipClass("CibumDestroyer");
+    }
+
+    public void spawn() {
+
+        double center = game.viewWidth() / 2;
+
+        super.spawn(
+                game.random(center - 64, center + 64),
+                -32,
+                0.5,
+                Math.PI * 3 / 2 - game.random(-0.1, 0.1)
+        );
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/wave/FireFormationWave.java b/app/src/main/java/com/kaeruct/raumballer/wave/FireFormationWave.java
index f1881ed..cf618f8 100644
--- a/app/src/main/java/com/kaeruct/raumballer/wave/FireFormationWave.java
+++ b/app/src/main/java/com/kaeruct/raumballer/wave/FireFormationWave.java
@@ -1,22 +1,22 @@
 package com.kaeruct.raumballer.wave;
 
-import com.kaeruct.raumballer.LevelReader;
 import com.kaeruct.raumballer.AndroidGame;
+import com.kaeruct.raumballer.LevelReader;
 
 public class FireFormationWave extends Wave {
-	
-	public FireFormationWave(AndroidGame game, LevelReader r, int maxAmount) {
-		super(game, r, maxAmount*3); // *3 because it spawns in triads
-		this.setFreq(50);
-		this.setShipClass("FireStriker");
-	}
-	
-	public void spawn(){
 
-		double x =  game.getPlayer().x+game.random(-64, 64);
-		
-		super.spawn(x-8, -24, 2.2, Math.PI*3/2-0.2);
-		super.spawn(x, -16, 1.8, Math.PI*3/2);
-		super.spawn(x+8, -24, 2.2, Math.PI*3/2+0.2);
-	}
+    public FireFormationWave(AndroidGame game, LevelReader r, int maxAmount) {
+        super(game, r, maxAmount * 3); // *3 because it spawns in triads
+        this.setFreq(50);
+        this.setShipClass("FireStriker");
+    }
+
+    public void spawn() {
+
+        double x = game.getPlayer().x + game.random(-64, 64);
+
+        super.spawn(x - 8, -24, 2.2, Math.PI * 3 / 2 - 0.2);
+        super.spawn(x, -16, 1.8, Math.PI * 3 / 2);
+        super.spawn(x + 8, -24, 2.2, Math.PI * 3 / 2 + 0.2);
+    }
 }
diff --git a/app/src/main/java/com/kaeruct/raumballer/wave/SpaceBallWave.java b/app/src/main/java/com/kaeruct/raumballer/wave/SpaceBallWave.java
index c02c33e..9a61601 100644
--- a/app/src/main/java/com/kaeruct/raumballer/wave/SpaceBallWave.java
+++ b/app/src/main/java/com/kaeruct/raumballer/wave/SpaceBallWave.java
@@ -1,24 +1,24 @@
 package com.kaeruct.raumballer.wave;
 
-import com.kaeruct.raumballer.LevelReader;
 import com.kaeruct.raumballer.AndroidGame;
+import com.kaeruct.raumballer.LevelReader;
 
 public class SpaceBallWave extends Wave {
-	
-	public SpaceBallWave(AndroidGame game, LevelReader r, int maxAmount) {
-		super(game, r, maxAmount);
-		this.setFreq(300);
-		this.setShipClass("SpaceBall");
-	}
-	
-	public void spawn(){
-	
-		super.spawn(
-			game.random(0, game.viewWidth()),
-			game.viewHeight()-8,
-			game.random(0.7, 1.6),
-			Math.PI/2-game.random(-0.5, 0.5)
-		);
-	}
+
+    public SpaceBallWave(AndroidGame game, LevelReader r, int maxAmount) {
+        super(game, r, maxAmount);
+        this.setFreq(300);
+        this.setShipClass("SpaceBall");
+    }
+
+    public void spawn() {
+
+        super.spawn(
+                game.random(0, game.viewWidth()),
+                game.viewHeight() - 8,
+                game.random(0.7, 1.6),
+                Math.PI / 2 - game.random(-0.5, 0.5)
+        );
+    }
 
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/kaeruct/raumballer/wave/SparkEyeWave.java b/app/src/main/java/com/kaeruct/raumballer/wave/SparkEyeWave.java
index 7686e4d..09be66c 100644
--- a/app/src/main/java/com/kaeruct/raumballer/wave/SparkEyeWave.java
+++ b/app/src/main/java/com/kaeruct/raumballer/wave/SparkEyeWave.java
@@ -1,50 +1,50 @@
 package com.kaeruct.raumballer.wave;
 
-import com.kaeruct.raumballer.LevelReader;
 import com.kaeruct.raumballer.AndroidGame;
+import com.kaeruct.raumballer.LevelReader;
 import com.kaeruct.raumballer.ship.Ship;
 
 public class SparkEyeWave extends Wave {
-	
-	public SparkEyeWave(AndroidGame game, LevelReader r, int maxAmount) {
-		super(game, r, maxAmount*8); // it spawns 8 enemies per spawn
-		this.setFreq(200); 
-		this.setShipClass("SparkEye");
-	}
-	
-	public void spawn(){
-		double ypos = game.getPlayer().y;
-		double xpos, dir;
-	
-		if(game.random(0, 1, 1)==1){
-			xpos = -8;
-			dir = 0;
-		}else{
-			xpos = game.viewWidth()+8;
-			dir = Math.PI;
-		}
-		
-		Ship parent = super.spawn(
-			xpos,
-			ypos,
-			game.random(1, 1.5),
-			dir+game.random(-0.2, 0.2)
-		);
-		
-		double num = 7; // number of asterisks around the eye
-		
-		for(int i = 0; i < 7; i++){
-			double ang = Math.PI*(2*(num/2-i)/num);
-			
-			super.spawn(
-				xpos,
-				ypos,
-				6,
-				ang,
-				"Asterisk",
-				parent
-			);
-		}
-	}
+
+    public SparkEyeWave(AndroidGame game, LevelReader r, int maxAmount) {
+        super(game, r, maxAmount * 8); // it spawns 8 enemies per spawn
+        this.setFreq(200);
+        this.setShipClass("SparkEye");
+    }
+
+    public void spawn() {
+        double ypos = game.getPlayer().y;
+        double xpos, dir;
+
+        if (game.random(0, 1, 1) == 1) {
+            xpos = -8;
+            dir = 0;
+        } else {
+            xpos = game.viewWidth() + 8;
+            dir = Math.PI;
+        }
+
+        Ship parent = super.spawn(
+                xpos,
+                ypos,
+                game.random(1, 1.5),
+                dir + game.random(-0.2, 0.2)
+        );
+
+        double num = 7; // number of asterisks around the eye
+
+        for (int i = 0; i < 7; i++) {
+            double ang = Math.PI * (2 * (num / 2 - i) / num);
+
+            super.spawn(
+                    xpos,
+                    ypos,
+                    6,
+                    ang,
+                    "Asterisk",
+                    parent
+            );
+        }
+    }
 
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/kaeruct/raumballer/wave/SparkWave.java b/app/src/main/java/com/kaeruct/raumballer/wave/SparkWave.java
index 7a2a237..0a7fa09 100644
--- a/app/src/main/java/com/kaeruct/raumballer/wave/SparkWave.java
+++ b/app/src/main/java/com/kaeruct/raumballer/wave/SparkWave.java
@@ -1,25 +1,25 @@
 package com.kaeruct.raumballer.wave;
 
-import com.kaeruct.raumballer.LevelReader;
 import com.kaeruct.raumballer.AndroidGame;
+import com.kaeruct.raumballer.LevelReader;
 
 public class SparkWave extends Wave {
-	
-	public SparkWave(AndroidGame game, LevelReader r, int maxAmount) {
-		super(game, r, maxAmount);
-		this.setFreq(100);
-		this.setShipClass("SparkDefender");
-	}
-	
-	public void spawn(){
-		double center = game.pfWidth()/2;
-		
-		super.spawn(
-			game.random(center-64, center+64),
-			-8,
-			game.random(1, 2),
-			Math.PI*3/2-game.random(-0.5, 0.5)
-		);
-	}
+
+    public SparkWave(AndroidGame game, LevelReader r, int maxAmount) {
+        super(game, r, maxAmount);
+        this.setFreq(100);
+        this.setShipClass("SparkDefender");
+    }
+
+    public void spawn() {
+        double center = game.pfWidth() / 2;
+
+        super.spawn(
+                game.random(center - 64, center + 64),
+                -8,
+                game.random(1, 2),
+                Math.PI * 3 / 2 - game.random(-0.5, 0.5)
+        );
+    }
 
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/kaeruct/raumballer/wave/Wave.java b/app/src/main/java/com/kaeruct/raumballer/wave/Wave.java
index 5d022e0..ba554f7 100644
--- a/app/src/main/java/com/kaeruct/raumballer/wave/Wave.java
+++ b/app/src/main/java/com/kaeruct/raumballer/wave/Wave.java
@@ -1,118 +1,109 @@
 package com.kaeruct.raumballer.wave;
 
-import java.lang.reflect.Constructor;
-
-import com.kaeruct.raumballer.LevelReader;
 import com.kaeruct.raumballer.AndroidGame;
-import com.kaeruct.raumballer.ship.*;
+import com.kaeruct.raumballer.LevelReader;
+import com.kaeruct.raumballer.ship.Ship;
+
+import java.lang.reflect.Constructor;
 
 public abstract class Wave {
-	
-	private int freq;
-	private int spawned;
-	private int maxAmount;
-	private LevelReader reader;
-	public boolean stopped;
-	private String shipClass;
-	protected AndroidGame game;
-	
-	public Wave(AndroidGame game, LevelReader reader, int maxAmount) {
-		this.setFreq(20);
-		this.game = game;
-		this.reader = reader;
-		this.setSpawned(0);
-		this.stopped = false;
-		this.setMaxAmount(maxAmount);
-	}
-	
-	public abstract void spawn();
-	
-	// spawn straight down
-	public Ship spawn(double x, double y, double vel){
-		return this.spawn(x, y, vel, Math.PI*3/2);
-	}
-	
-	// spawn specifying a direction
-	public Ship spawn(double x, double y, double vel, double angle){
-		return this.spawn(x, y, vel, angle, shipClass);
-	}
-	
-	// spawn specifying a direction and a different class
-	public Ship spawn(double x, double y, double vel, double angle , String shipClass){
-		return this.spawn(x, y, vel, angle, shipClass, null);
-	}	
-	
-	public Ship spawn(double x, double y, double vel, double angle, String shipClass, Ship parent){
-		Ship s = null;
-		
-		try {
-			// spawn ship
-			Class<Ship> ship = (Class<Ship>) Class.forName("com.kaeruct.raumballer.ship.enemy."+shipClass);
-			
-			Constructor<Ship> c = ship.getConstructor(double.class, double.class,
-					double.class, double.class, AndroidGame.class);
-			
-			s = c.newInstance(x+game.viewXOfs(), y+game.viewYOfs(), vel, angle, this.game);
-			this.setSpawned(this.getSpawned()+1);
-			
-			if(parent != null){
-				s.setParent(parent);
-			}
-
-		} catch (Exception e) {
-			this.game.dbgPrint(e.toString());
-		}
-		
-		return s;
-	
-	}
-	
-	public void update(){
-		if(!stopped){
-			if(getSpawned() >= getMaxAmount()){
-				this.stop();
-			}else if(game.t%getFreq() == 0){
-				spawn();
-			}
-		}
-		
-	}
-	
-	public void stop(){
-		// tell the level reader this wave is done
-		if(!this.stopped) this.reader.waveDone();
-		this.stopped = true;
-	}
-
-	public int getFreq() {
-		return freq;
-	}
-
-	public void setFreq(int freq) {
-		this.freq = freq;
-	}
-
-	public int getSpawned() {
-		return spawned;
-	}
-
-	public void setSpawned(int spawned) {
-		this.spawned = spawned;
-	}
-
-	public int getMaxAmount() {
-		return maxAmount;
-	}
-
-	public void setMaxAmount(int maxAmount) {
-		this.maxAmount = maxAmount;
-	}
-	
-	public String getShipClass() {
-		return shipClass;
-	}
-
-	public void setShipClass(String shipClass) {
-		this.shipClass = shipClass;
-	}
+
+    private int freq;
+    private int spawned;
+    private int maxAmount;
+    private final LevelReader reader;
+    public boolean stopped;
+    private String shipClass;
+    protected AndroidGame game;
+
+    public Wave(AndroidGame game, LevelReader reader, int maxAmount) {
+        this.setFreq(20);
+        this.game = game;
+        this.reader = reader;
+        this.setSpawned(0);
+        this.stopped = false;
+        this.setMaxAmount(maxAmount);
+    }
+
+    public abstract void spawn();
+
+    // spawn specifying a direction
+    public Ship spawn(double x, double y, double vel, double angle) {
+        return this.spawn(x, y, vel, angle, shipClass);
+    }
+
+    // spawn specifying a direction and a different class
+    public Ship spawn(double x, double y, double vel, double angle, String shipClass) {
+        return this.spawn(x, y, vel, angle, shipClass, null);
+    }
+
+    public Ship spawn(double x, double y, double vel, double angle, String shipClass, Ship parent) {
+        Ship s = null;
+
+        try {
+            // spawn ship
+            Class<Ship> ship = (Class<Ship>) Class.forName("com.kaeruct.raumballer.ship.enemy." + shipClass);
+
+            Constructor<Ship> c = ship.getConstructor(double.class, double.class,
+                    double.class, double.class, AndroidGame.class);
+
+            s = c.newInstance(x + game.viewXOfs(), y + game.viewYOfs(), vel, angle, this.game);
+            this.setSpawned(this.getSpawned() + 1);
+
+            if (parent != null) {
+                s.setParent(parent);
+            }
+
+        } catch (Exception e) {
+            this.game.dbgPrint(e.toString());
+        }
+
+        return s;
+
+    }
+
+    public void update() {
+        if (!stopped) {
+            if (getSpawned() >= getMaxAmount()) {
+                this.stop();
+            } else if (game.t % getFreq() == 0) {
+                spawn();
+            }
+        }
+
+    }
+
+    public void stop() {
+        // tell the level reader this wave is done
+        if (!this.stopped) this.reader.waveDone();
+        this.stopped = true;
+    }
+
+    public int getFreq() {
+        return freq;
+    }
+
+    public void setFreq(int freq) {
+        this.freq = freq;
+    }
+
+    public int getSpawned() {
+        return spawned;
+    }
+
+    public void setSpawned(int spawned) {
+        this.spawned = spawned;
+    }
+
+    public int getMaxAmount() {
+        return maxAmount;
+    }
+
+    public void setMaxAmount(int maxAmount) {
+        this.maxAmount = maxAmount;
+    }
+
+    public void setShipClass(String shipClass) {
+        this.shipClass = shipClass;
+    }
 }
diff --git a/app/src/main/java/jgame/Highscore.java b/app/src/main/java/jgame/Highscore.java
index b0ee9cf..7f29626 100644
--- a/app/src/main/java/jgame/Highscore.java
+++ b/app/src/main/java/jgame/Highscore.java
@@ -1,40 +1,57 @@
 package jgame;
-import java.util.*;
-import java.io.*;
-/** Class for handling highscores.  A highscore consists of a score, a name,
- * and optionally, a number of information fields such as level, etc. */
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.util.Enumeration;
+import java.util.Vector;
+
+/**
+ * Class for handling highscores.  A highscore consists of a score, a name,
+ * and optionally, a number of information fields such as level, etc.
+ */
 public class Highscore {
-	public int score;
-	public String name;
-	public String [] fields=null;
-
-	/** Construct regular highscore */
-	public Highscore(int score,String name) {
-		this.score=score;
-		this.name=name;
-	}
-
-	/** Construct highscore with one extra field */
-	public Highscore(int score,String name,String field1) {
-		this.score=score;
-		this.name=name;
-		this.fields=new String[] { field1 };
-	}
-
-	/** Construct highscore with extra fields */
-	public Highscore(int score,String name,String field1,String field2) {
-		this.score=score;
-		this.name=name;
-		this.fields=new String[] { field1,field2 };
-	}
-
-	/** Construct highscore with extra fields */
-	public Highscore(int score,String name,String field1,String field2,
-	String field3) {
-		this.score=score;
-		this.name=name;
-		this.fields=new String[] { field1,field2,field3 };
-	}
+    public int score;
+    public String name;
+    public String[] fields = null;
+
+    /**
+     * Construct regular highscore
+     */
+    public Highscore(int score, String name) {
+        this.score = score;
+        this.name = name;
+    }
+
+    /**
+     * Construct highscore with one extra field
+     */
+    public Highscore(int score, String name, String field1) {
+        this.score = score;
+        this.name = name;
+        this.fields = new String[]{field1};
+    }
+
+    /**
+     * Construct highscore with extra fields
+     */
+    public Highscore(int score, String name, String field1, String field2) {
+        this.score = score;
+        this.name = name;
+        this.fields = new String[]{field1, field2};
+    }
+
+    /**
+     * Construct highscore with extra fields
+     */
+    public Highscore(int score, String name, String field1, String field2,
+                     String field3) {
+        this.score = score;
+        this.name = name;
+        this.fields = new String[]{field1, field2, field3};
+    }
 
 //	class HighscoreComparator implements Comparator {
 //		public HighscoreComparator() {}
@@ -59,141 +76,145 @@ public class Highscore {
 //		return (Highscore [])sorted.toArray(new Highscore[] {});
 //	}
 
-	/** Find position (array index) of given score in highscore list,
-	 * -1 means not in highscores. 
-	 * @param highscores  sorted highscore list
-	 * @return  0 means first position, etc.  -1 means not in list
-	 */
-	public static int findPos(Highscore [] highscores, int newscore) {
-		for (int i=0; i<highscores.length; i++) {
-			if (newscore > highscores[i].score) return i;
-		}
-		return -1;
-	}
-
-	/** Try to insert new highscore in given highscore list.  Do nothing if
-	 * it's too low.  Leaves old array untouched. */
-	public static Highscore [] insert(Highscore [] highscores,
-	Highscore newscore) {
-		if (findPos(highscores,newscore.score) >= 0) {
-			highscores[highscores.length-1] = newscore;
-			return sort(highscores);
-		} else {
-			return highscores;
-		}
-	}
-
-	public static Highscore [] load(InputStream in)
-	throws IOException {
-		Vector highscores=new Vector(20,40);
-		InputStreamReader inr = new InputStreamReader(in);
-		String line;
-		while ( (line=jgame.impl.EngineLogic.readline(inr)) != null ) {
-			Vector fields = new Vector(5,10);
-			// XXX we use "`" to represent empty string because
-			// StringTokenizer skips empty tokens
-			Vector tokens = jgame.impl.EngineLogic.tokenizeString(line,'\t');
-			//StringTokenizer toker = new StringTokenizer(line,"\t");
-			for (Enumeration e=tokens.elements(); e.hasMoreElements(); ) {
-				String tok = (String)e.nextElement();
-				if (tok.equals("`")) tok="";
-				fields.addElement(tok);
-			}
-			Highscore hs=null;
-			if (fields.size()==1) {
-				// we assume we have a highscore with no fields and empty name
-				hs=new Highscore(Integer.parseInt((String)fields.elementAt(0)), "");
-			}
-			if (fields.size() >= 2) {
-				hs=new Highscore(Integer.parseInt((String)fields.elementAt(0)),
-					(String)fields.elementAt(1) );
-			}
-			if (fields.size() >= 3) {
-				hs.fields=new String[fields.size()-2];
-				for (int i=2; i<fields.size(); i++) {
-					hs.fields[i-2] = (String)fields.elementAt(i);
-				}
-			}
-			highscores.addElement(hs);
-		}
-		Highscore [] ret = new Highscore [highscores.size()];
-		for (int i=0; i<highscores.size(); i++) {
-			ret[i] = (Highscore)highscores.elementAt(i);
-		}
-		return ret;
-		//return (Highscore[])highscores.toArray(new Highscore[]{});
-	}
-
-	public static void save(Highscore [] highscores,OutputStream out)
-	throws IOException {
-		PrintStream outp = new PrintStream(out);
-		for (int i=0; i<highscores.length; i++) {
-			outp.print(highscores[i].score);
-			outp.print('\t');
-			if (highscores[i].name.equals("")) {
-				outp.print("`");//XXX backtick indicates empty string
-			} else {
-				outp.print(highscores[i].name);
-			}
-			if (highscores[i].fields!=null) {
-				for (int j=0; j<highscores[i].fields.length; j++) {
-					outp.print('\t');
-					outp.print(highscores[i].fields[j]);
-				}
-			}
-			outp.println();
-		}
-		outp.flush();
-	}
-
-
-	/* sorting */
-
-
-	static Highscore [] sort(Highscore a[]) {
-		/* index value of last element in array */
-	  	int index;
-
-		int temp;
-
-		index = a.length - 1;
- 		/* Heapify loop*/
-		temp = (int)((index-1) / 2);
-		for (int i=temp; i>=0; i--) {/* index of root value */
-			BubbleDown(index, i, a);
-		}
-		/* DeleteMax loop */
-		while (index > 0) {
-			swap(a,0,index);
-			index--;
-			BubbleDown(index,0,a);
-		}
-
-		return a;
-	}
-
-	static private void BubbleDown(int index, int i, Highscore a[]) {
-		int child;
-
-		child = ((i+1)*2)-1;
-		if ( (child < index) && a[child+1].score < a[child].score ) 
-              child++;
-		if ( (child <= index) && a[i].score > a[child].score ) {
-			swap(a,i,child);
-			BubbleDown(index,child,a);
-		}
-	}
-
-	/**
-	 * This method will be called to
-	 * swap two elements in an array of strings.
-	 */
-	static private void swap(Highscore a[], int i, int j) {
-		Highscore T;
-		T = a[i];
-		a[i] = a[j];
-		a[j] = T;
-	}
+    /**
+     * Find position (array index) of given score in highscore list,
+     * -1 means not in highscores.
+     *
+     * @param highscores sorted highscore list
+     * @return 0 means first position, etc.  -1 means not in list
+     */
+    public static int findPos(Highscore[] highscores, int newscore) {
+        for (int i = 0; i < highscores.length; i++) {
+            if (newscore > highscores[i].score) return i;
+        }
+        return -1;
+    }
+
+    /**
+     * Try to insert new highscore in given highscore list.  Do nothing if
+     * it's too low.  Leaves old array untouched.
+     */
+    public static Highscore[] insert(Highscore[] highscores,
+                                     Highscore newscore) {
+        if (findPos(highscores, newscore.score) >= 0) {
+            highscores[highscores.length - 1] = newscore;
+            return sort(highscores);
+        } else {
+            return highscores;
+        }
+    }
+
+    public static Highscore[] load(InputStream in)
+            throws IOException {
+        Vector highscores = new Vector(20, 40);
+        InputStreamReader inr = new InputStreamReader(in);
+        String line;
+        while ((line = jgame.impl.EngineLogic.readline(inr)) != null) {
+            Vector fields = new Vector(5, 10);
+            // XXX we use "`" to represent empty string because
+            // StringTokenizer skips empty tokens
+            Vector tokens = jgame.impl.EngineLogic.tokenizeString(line, '\t');
+            //StringTokenizer toker = new StringTokenizer(line,"\t");
+            for (Enumeration e = tokens.elements(); e.hasMoreElements(); ) {
+                String tok = (String) e.nextElement();
+                if (tok.equals("`")) tok = "";
+                fields.addElement(tok);
+            }
+            Highscore hs = null;
+            if (fields.size() == 1) {
+                // we assume we have a highscore with no fields and empty name
+                hs = new Highscore(Integer.parseInt((String) fields.elementAt(0)), "");
+            }
+            if (fields.size() >= 2) {
+                hs = new Highscore(Integer.parseInt((String) fields.elementAt(0)),
+                        (String) fields.elementAt(1));
+            }
+            if (fields.size() >= 3) {
+                hs.fields = new String[fields.size() - 2];
+                for (int i = 2; i < fields.size(); i++) {
+                    hs.fields[i - 2] = (String) fields.elementAt(i);
+                }
+            }
+            highscores.addElement(hs);
+        }
+        Highscore[] ret = new Highscore[highscores.size()];
+        for (int i = 0; i < highscores.size(); i++) {
+            ret[i] = (Highscore) highscores.elementAt(i);
+        }
+        return ret;
+        //return (Highscore[])highscores.toArray(new Highscore[]{});
+    }
+
+    public static void save(Highscore[] highscores, OutputStream out)
+            throws IOException {
+        PrintStream outp = new PrintStream(out);
+        for (int i = 0; i < highscores.length; i++) {
+            outp.print(highscores[i].score);
+            outp.print('\t');
+            if (highscores[i].name.equals("")) {
+                outp.print("`");//XXX backtick indicates empty string
+            } else {
+                outp.print(highscores[i].name);
+            }
+            if (highscores[i].fields != null) {
+                for (int j = 0; j < highscores[i].fields.length; j++) {
+                    outp.print('\t');
+                    outp.print(highscores[i].fields[j]);
+                }
+            }
+            outp.println();
+        }
+        outp.flush();
+    }
+
+
+    /* sorting */
+
+
+    static Highscore[] sort(Highscore[] a) {
+        /* index value of last element in array */
+        int index;
+
+        int temp;
+
+        index = a.length - 1;
+        /* Heapify loop*/
+        temp = (int) ((index - 1) / 2);
+        for (int i = temp; i >= 0; i--) {/* index of root value */
+            BubbleDown(index, i, a);
+        }
+        /* DeleteMax loop */
+        while (index > 0) {
+            swap(a, 0, index);
+            index--;
+            BubbleDown(index, 0, a);
+        }
+
+        return a;
+    }
+
+    static private void BubbleDown(int index, int i, Highscore[] a) {
+        int child;
+
+        child = ((i + 1) * 2) - 1;
+        if ((child < index) && a[child + 1].score < a[child].score)
+            child++;
+        if ((child <= index) && a[i].score > a[child].score) {
+            swap(a, i, child);
+            BubbleDown(index, child, a);
+        }
+    }
+
+    /**
+     * This method will be called to
+     * swap two elements in an array of strings.
+     */
+    static private void swap(Highscore[] a, int i, int j) {
+        Highscore T;
+        T = a[i];
+        a[i] = a[j];
+        a[j] = T;
+    }
 
 
 }
diff --git a/app/src/main/java/jgame/JGColor.java b/app/src/main/java/jgame/JGColor.java
index c223392..d988db0 100644
--- a/app/src/main/java/jgame/JGColor.java
+++ b/app/src/main/java/jgame/JGColor.java
@@ -1,54 +1,60 @@
 package jgame;
 
-/** Minimal replacement of java.awt.Color. */
+/**
+ * Minimal replacement of java.awt.Color.
+ */
 public class JGColor {
 
-	public static final JGColor black = new JGColor(0,0,0);
-	public static final JGColor white = new JGColor(255,255,255);
-	public static final JGColor yellow= new JGColor(255,255,0);
-	public static final JGColor green = new JGColor(0,255,0);
-	public static final JGColor cyan  = new JGColor(0,255,255);
-	public static final JGColor blue  = new JGColor(0,0,255);
-	public static final JGColor magenta= new JGColor(255,0,255);
-	public static final JGColor red   = new JGColor(255,0,0);
-
-	public static final JGColor pink  = new JGColor(255,140,140);
-	public static final JGColor orange= new JGColor(255,140,0);
-
-	public static final JGColor grey= new JGColor(128,128,128);
-	public static final JGColor gray= new JGColor(128,128,128);
-
-	/** a value between 0 and 255 */
-	public int r,g,b;
-	/** a value between 0 and 255, default is 255 (opaque) */
-	public int alpha=255;
-
-	public Object impl;
-
-	public JGColor (int r,int g,int b) {
-		this.r=r;
-		this.g=g;
-		this.b=b;
-	}
-
-	public JGColor (int r,int g,int b,int alpha) {
-		this.r=r;
-		this.g=g;
-		this.b=b;
-		this.alpha=alpha;
-	}
-
-	public JGColor (double r,double g,double b) {
-		this.r = (int)(r*255.95);
-		this.g = (int)(g*255.95);
-		this.b = (int)(b*255.95);
-	}
-
-	public JGColor (double r,double g,double b,double alpha) {
-		this.r = (int)(r*255.95);
-		this.g = (int)(g*255.95);
-		this.b = (int)(b*255.95);
-		this.alpha = (int)(alpha*255.95);
-	}
+    public static final JGColor black = new JGColor(0, 0, 0);
+    public static final JGColor white = new JGColor(255, 255, 255);
+    public static final JGColor yellow = new JGColor(255, 255, 0);
+    public static final JGColor green = new JGColor(0, 255, 0);
+    public static final JGColor cyan = new JGColor(0, 255, 255);
+    public static final JGColor blue = new JGColor(0, 0, 255);
+    public static final JGColor magenta = new JGColor(255, 0, 255);
+    public static final JGColor red = new JGColor(255, 0, 0);
+
+    public static final JGColor pink = new JGColor(255, 140, 140);
+    public static final JGColor orange = new JGColor(255, 140, 0);
+
+    public static final JGColor grey = new JGColor(128, 128, 128);
+    public static final JGColor gray = new JGColor(128, 128, 128);
+
+    /**
+     * a value between 0 and 255
+     */
+    public int r, g, b;
+    /**
+     * a value between 0 and 255, default is 255 (opaque)
+     */
+    public int alpha = 255;
+
+    public Object impl;
+
+    public JGColor(int r, int g, int b) {
+        this.r = r;
+        this.g = g;
+        this.b = b;
+    }
+
+    public JGColor(int r, int g, int b, int alpha) {
+        this.r = r;
+        this.g = g;
+        this.b = b;
+        this.alpha = alpha;
+    }
+
+    public JGColor(double r, double g, double b) {
+        this.r = (int) (r * 255.95);
+        this.g = (int) (g * 255.95);
+        this.b = (int) (b * 255.95);
+    }
+
+    public JGColor(double r, double g, double b, double alpha) {
+        this.r = (int) (r * 255.95);
+        this.g = (int) (g * 255.95);
+        this.b = (int) (b * 255.95);
+        this.alpha = (int) (alpha * 255.95);
+    }
 
 }
diff --git a/app/src/main/java/jgame/JGFont.java b/app/src/main/java/jgame/JGFont.java
index 4619676..6ac05dd 100644
--- a/app/src/main/java/jgame/JGFont.java
+++ b/app/src/main/java/jgame/JGFont.java
@@ -1,47 +1,67 @@
 package jgame;
 
-/** A generic font specification for fonts on the different
-* platforms.  It is based on the JRE platform, other platforms should do their
-* best to translate it to something equivalent or use sensible defaults if
-* there is nothing comparable. */
+/**
+ * A generic font specification for fonts on the different
+ * platforms.  It is based on the JRE platform, other platforms should do their
+ * best to translate it to something equivalent or use sensible defaults if
+ * there is nothing comparable.
+ */
 public class JGFont {
 
-	public static final int PLAIN=0;
-	public static final int BOLD=1;
-	public static final int ITALIC=2;
-
-	/** The font name can be a logical font name or a font face name. A
-	 * logical name must be either: Dialog, DialogInput, Monospaced, Serif, or
-	 * SansSerif. If name is null, the name of the new Font is set to the name
-	 * "Default". */
-	public String name="Default";
-
-	/** The style is an integer bitmask that may be PLAIN, or a bitwise union
-	 * of BOLD and/or ITALIC (for example, ITALIC or BOLD|ITALIC). If the
-	 * style argument does not conform to one of the expected integer bitmasks
-	 * then the style is set to PLAIN. */
-	public int style=PLAIN;
-
-	/** Font size is effectively pixel height. */
-	public double size;
-
-	/** Optional object that represents the font on a particular platform.*/
-	public Object impl=null;
-
-	/** Creates a new Font from the specified name, style and point size.
-	* This is a generic font specification for fonts on the different
-	* platforms.  
-	* @param name the font name
-	* @param style - the style constant for the Font
-	* @param size - the point size of the Font
-	*/
-	public JGFont(String name, int style, double size) {
-		if (name!=null) this.name=name;
-		this.style=style;
-		this.size=size;
-	}
-
-	public int getSize() { return (int)size; }
-	public double getSize2D() { return size; }
-	public int getStyle() { return style; }
+    public static final int PLAIN = 0;
+    public static final int BOLD = 1;
+    public static final int ITALIC = 2;
+
+    /**
+     * The font name can be a logical font name or a font face name. A
+     * logical name must be either: Dialog, DialogInput, Monospaced, Serif, or
+     * SansSerif. If name is null, the name of the new Font is set to the name
+     * "Default".
+     */
+    public String name = "Default";
+
+    /**
+     * The style is an integer bitmask that may be PLAIN, or a bitwise union
+     * of BOLD and/or ITALIC (for example, ITALIC or BOLD|ITALIC). If the
+     * style argument does not conform to one of the expected integer bitmasks
+     * then the style is set to PLAIN.
+     */
+    public int style = PLAIN;
+
+    /**
+     * Font size is effectively pixel height.
+     */
+    public double size;
+
+    /**
+     * Optional object that represents the font on a particular platform.
+     */
+    public Object impl = null;
+
+    /**
+     * Creates a new Font from the specified name, style and point size.
+     * This is a generic font specification for fonts on the different
+     * platforms.
+     *
+     * @param name  the font name
+     * @param style - the style constant for the Font
+     * @param size  - the point size of the Font
+     */
+    public JGFont(String name, int style, double size) {
+        if (name != null) this.name = name;
+        this.style = style;
+        this.size = size;
+    }
+
+    public int getSize() {
+        return (int) size;
+    }
+
+    public double getSize2D() {
+        return size;
+    }
+
+    public int getStyle() {
+        return style;
+    }
 }
diff --git a/app/src/main/java/jgame/JGImage.java b/app/src/main/java/jgame/JGImage.java
index 92b91f4..f2a393c 100644
--- a/app/src/main/java/jgame/JGImage.java
+++ b/app/src/main/java/jgame/JGImage.java
@@ -1,92 +1,110 @@
 package jgame;
-/** Image functionality */
+
+/**
+ * Image functionality
+ */
 public interface JGImage {
 
-	/* static in spirit*/
-
-	/** Load image from resource path (using getResource).  Note that GIFs are
-	 * loaded as _translucent_ indexed images.   Images are cached: loading
-	 * an image with the same name twice will get the cached image the second
-	 * time.  If you want to remove an image from the cache, use purgeImage.
-	* Throws JGError when there was an error. */
-	public JGImage loadImage(String imgfile);
-
-	/** Behaves like loadImage(String).  Returns null if there was an error. */
-	// midp has no url
-	//public JGImage loadImage(URL imgurl);
-
-	/** Purge image with the given resourcename from the cache. */
-	public void purgeImage(String imgfile);
-
-
-	/* object-related methods */
-
-	/** Get image size.  The object returned may be a reference to an internal
-	 * variable, so do not change it! */
-	public JGPoint getSize();
-
-	/** True means the image may have some transparent pixels below the given
-	 * alpha threshold, false means image is completely opaque.
-	 * Implementations may choose to return false when they are not sure, but
-	 * should return true whenever applicable to enable maximum performance
-	 * benefits.  Current implementations actually check the alpha channel
-	 * pixel for pixel */
-	public boolean isOpaque(int alpha_thresh);
-
-	/** for angle, only increments of 90 are allowed */
-	public JGImage rotate(int angle);
-
-	/** Image is rotated by rot (radians). Resulting image is square with
-	* dimension max(width, height, 0.75*(width+height))*/
-	public JGImage rotateAny(double angle);
-
-	public JGImage flip(boolean horiz,boolean vert);
-
-	/** Returns a smoothly scaled image using getScaledInstance.  This method
-	 * has interesting behaviour.  The scaled image retains its type
-	 * (indexed/rgb and bitmask/translucent), and the algorithm tries to scale
-	 * smoothly within these constraints.  For indexed, interpolated pixels
-	 * are rounded to the existing indexed colours.  For bitmask, the
-	 * behaviour depends on the platform.  On WinXP/J1.2 I found that the
-	 * colour _behind_ each transparent pixel is used to interpolate between
-	 * nontransparent and transparent pixels.  On BSD/J1.4 I found that the
-	 * colours of transparent pixels are never used, and only the
-	 * nontransparent pixels are used when interpolating a region with mixed
-	 * transparent/nontransparent pixels.
-	 */
-	public JGImage scale(int width, int height);
-
-	//public void ensureLoaded() throws Exception;
-
-	public JGImage crop(int x,int y, int width,int height);
-
-	/** Turn a (possibly) translucent or indexed image into a
-	* display-compatible bitmask image using the given alpha threshold and
-	* render-to-background colour, or to display-compatible translucent image.
-	* In bitmask mode, the alpha values in the
-	* image are set to either 0 (below threshold) or 255 (above threshold).
-	* The render-to-background colour bg_col is used to determine how the
-	* pixels overlapping transparent pixels should be rendered.  The fast
-	* algorithm just sets the colour behind the transparent pixels in the
-	* image (for bitmask source images); the slow algorithm actually
-	* renders the image to a background of bg_col (for translucent sources).
-	*
-	* @param thresh alpha threshold between 0 and 255
-	* @param fast use fast algorithm (only set bg_col behind transp. pixels)
-	* @param bitmask true=make bitmask, false=make translucent */
-	public JGImage toDisplayCompatible(int thresh,JGColor bg_col,
-	boolean fast, boolean bitmask);
-
-	/** Create empty image with given alpha mode that should be efficient on
-	* this display */
-	//public BufferedImage createCompatibleImage(int width,int height,
-	//int transparency);
-
-	// the following is ugly version-conditional execution.  What we really
-	// want is to have a 1.4 and a <1.4 version of the following two methods.
-	// Drawbacks are now that IMAGE_INCOMPATIBLE is coded as a hard number and 
-	// applets cannot do reflection on volatile images for some reason and
-	// hence do not have acceleration.
+    /* static in spirit*/
+
+    /**
+     * Load image from resource path (using getResource).  Note that GIFs are
+     * loaded as _translucent_ indexed images.   Images are cached: loading
+     * an image with the same name twice will get the cached image the second
+     * time.  If you want to remove an image from the cache, use purgeImage.
+     * Throws JGError when there was an error.
+     */
+    JGImage loadImage(String imgfile);
+
+    /** Behaves like loadImage(String).  Returns null if there was an error. */
+    // midp has no url
+    //public JGImage loadImage(URL imgurl);
+
+    /**
+     * Purge image with the given resourcename from the cache.
+     */
+    void purgeImage(String imgfile);
+
+
+    /* object-related methods */
+
+    /**
+     * Get image size.  The object returned may be a reference to an internal
+     * variable, so do not change it!
+     */
+    JGPoint getSize();
+
+    /**
+     * True means the image may have some transparent pixels below the given
+     * alpha threshold, false means image is completely opaque.
+     * Implementations may choose to return false when they are not sure, but
+     * should return true whenever applicable to enable maximum performance
+     * benefits.  Current implementations actually check the alpha channel
+     * pixel for pixel
+     */
+    boolean isOpaque(int alpha_thresh);
+
+    /**
+     * for angle, only increments of 90 are allowed
+     */
+    JGImage rotate(int angle);
+
+    /**
+     * Image is rotated by rot (radians). Resulting image is square with
+     * dimension max(width, height, 0.75*(width+height))
+     */
+    JGImage rotateAny(double angle);
+
+    JGImage flip(boolean horiz, boolean vert);
+
+    /**
+     * Returns a smoothly scaled image using getScaledInstance.  This method
+     * has interesting behaviour.  The scaled image retains its type
+     * (indexed/rgb and bitmask/translucent), and the algorithm tries to scale
+     * smoothly within these constraints.  For indexed, interpolated pixels
+     * are rounded to the existing indexed colours.  For bitmask, the
+     * behaviour depends on the platform.  On WinXP/J1.2 I found that the
+     * colour _behind_ each transparent pixel is used to interpolate between
+     * nontransparent and transparent pixels.  On BSD/J1.4 I found that the
+     * colours of transparent pixels are never used, and only the
+     * nontransparent pixels are used when interpolating a region with mixed
+     * transparent/nontransparent pixels.
+     */
+    JGImage scale(int width, int height);
+
+    //public void ensureLoaded() throws Exception;
+
+    JGImage crop(int x, int y, int width, int height);
+
+    /**
+     * Turn a (possibly) translucent or indexed image into a
+     * display-compatible bitmask image using the given alpha threshold and
+     * render-to-background colour, or to display-compatible translucent image.
+     * In bitmask mode, the alpha values in the
+     * image are set to either 0 (below threshold) or 255 (above threshold).
+     * The render-to-background colour bg_col is used to determine how the
+     * pixels overlapping transparent pixels should be rendered.  The fast
+     * algorithm just sets the colour behind the transparent pixels in the
+     * image (for bitmask source images); the slow algorithm actually
+     * renders the image to a background of bg_col (for translucent sources).
+     *
+     * @param thresh  alpha threshold between 0 and 255
+     * @param fast    use fast algorithm (only set bg_col behind transp. pixels)
+     * @param bitmask true=make bitmask, false=make translucent
+     */
+    JGImage toDisplayCompatible(int thresh, JGColor bg_col,
+                                boolean fast, boolean bitmask);
+
+    /** Create empty image with given alpha mode that should be efficient on
+     * this display */
+    //public BufferedImage createCompatibleImage(int width,int height,
+    //int transparency);
+
+    // the following is ugly version-conditional execution.  What we really
+    // want is to have a 1.4 and a <1.4 version of the following two methods.
+    // Drawbacks are now that IMAGE_INCOMPATIBLE is coded as a hard number and
+    // applets cannot do reflection on volatile images for some reason and
+    // hence do not have acceleration.
 
 
 }
diff --git a/app/src/main/java/jgame/JGObject.java b/app/src/main/java/jgame/JGObject.java
index 7d0580b..7f2d7b8 100644
--- a/app/src/main/java/jgame/JGObject.java
+++ b/app/src/main/java/jgame/JGObject.java
@@ -1,43 +1,45 @@
 package jgame;
-import jgame.impl.JGEngineInterface;
+
 import jgame.impl.Animation;
+import jgame.impl.JGEngineInterface;
 //import java.awt.*;
 //import java.awt.image.ImageObserver;
 //import java.io.Serializable;
 //import java.net.*;
 
-/** Superclass for game objects, override to define animated game objects.
+/**
+ * Superclass for game objects, override to define animated game objects.
  * When an object is created, it is automatically registered with the
  * currently running engine.  The object will become active only after the
  * frame ends.  The object is managed by the engine, which will display it and
  * call the move and hit methods when appropriate.  Call remove() to remove
  * the object.  It will be removed after the frame ends.  Use isAlive()
  * to see if the object has been removed or not.
-
+ *
  * <p> Each object corresponds to one image.  The object's appearance can be
  * changed using setImage or any of the animation functions.  If you want
  * multi-image objects, use multiple objects and co-reference them using
  * regular references or using JGEngine's getObject().  You can also define
  * your own paint() method to generate any appearance you want.
-
+ *
  * <p>
  * Objects have a pointer to the engine by which they are managed (eng).  This
  * can be used to call the various useful methods in the engine.
  * Alternatively, the objects can be made inner classes of your JGEngine
- * class, so that they have direct access to all JGEngine methods. 
-
+ * class, so that they have direct access to all JGEngine methods.
+ *
  * <p> The object remembers some of the state of the previous frame (in
  * particular the previous position and bounding boxes), so that corrective
  * action can be taken after something special happened (such as bumping into
- * a wall).  
-
+ * a wall).
+ *
  * <P> Objects have a direction and speed built in.  After their move() method
  * finishes, their x and y position are incremented with the given
  * speed/direction.  Speed may be used as absolute value (leave the direction
  * at 1), or as a value relative to the direction (the movement is speed*dir).
  * The object speed is automatically multiplied by the game speed (which has
  * default 1.0).
-
+ *
  * <P> Objects can be suspended, which may be useful for having them sleep
  * until they come into view.  When suspended, they are invisible, and their
  * move, hit, and paint methods are not called.  Also, they will not expire.
@@ -46,776 +48,976 @@ import jgame.impl.Animation;
  * the view.  This can be disabled by means of the resume_in_view setting.  An
  * object that has suspend_off_view enabled will be suspended immediately at
  * creation when it is off view.
-
  */
 public class JGObject {
-	static int next_id = 0; 
-	/** global which might be accessed concurrently */
-	static JGEngineInterface default_engine=null;
-
-	/** The engine's viewWidth and viewHeight, stored in a local variable
-	* for extra speed.*/
-	public static int viewwidth,viewheight;
-	/** The engine's tileWidth and tileHeight, stored in a local variable
-	* for extra speed.*/
-	public static int tilewidth,tileheight;
-	/** The engine's pfWrap settings, stored in a local variable
-	* for extra speed. */
-	public static boolean pfwrapx,pfwrapy;
-	/** The engine's gamespeed setting, stored in a local variable
-	* for extra speed. */
-	public static double gamespeed;
-	/** The engine's pfWidth/pfHeight, stored in a local variable
-	* for extra speed. */
-	public static int pfwidth,pfheight;
-	/** The engine's viewX/YOfs, stored in a local variable
-	* for extra speed. */
-	public static int viewxofs,viewyofs;
-
-	/** Set the engine to connect to when a new object is created.  This
-	* should be called only by the JGEngine implementation.
-	* @param engine  pass null to indicate the engine has exited.
-	* @return true if success; false if other engine already running. */
-	public static boolean setEngine(JGEngineInterface engine) {
-		if (engine==null) {
-			default_engine=null;
-			return true;
-		}
-		if (default_engine!=null) return false;
-		default_engine=engine;
-		// copy some constants from engine for fast access
-		viewwidth=engine.viewWidth();
-		viewheight=engine.viewHeight();
-		tilewidth=engine.tileWidth();
-		tileheight=engine.tileHeight();
-		updateEngineSettings();
-		return true;
-	}
-	/** Called automatically by the engine to signal changes to pfWrap,
-	* gameSpeed, pfWidth/Height, viewX/YOfs.  The current values of these
-	* settings are stored in the JGObject local variables. */
-	public static void updateEngineSettings() {
-		pfwrapx = default_engine.pfWrapX();
-		pfwrapy = default_engine.pfWrapY();
-		gamespeed = default_engine.getGameSpeed();
-		pfwidth = default_engine.pfWidth();
-		pfheight = default_engine.pfHeight();
-		viewxofs = default_engine.viewXOfs();
-		viewyofs = default_engine.viewYOfs();
-	}
-
-	// remove object creation when changing anim
-
-	/** Print a message to the debug channel, using the object ID as source */
-	public void dbgPrint(String msg) { eng.dbgPrint(name,msg); }
-
-	/** Expiry value: never expire. */
-	public static final int expire_never=-1;
-	/** Expiry value: expire when off playfield. */
-	public static final int expire_off_pf=-2;
-	/** Expiry value: expire when out of view. */
-	public static final int expire_off_view=-3;
-	/** Expiry value: suspend when out of view. */
-	public static final int suspend_off_view=-4;
-	/** Expiry value: suspend when out of view and expire when out of
-	* playfield.*/
-	public static final int suspend_off_view_expire_off_pf=-5;
-
-	/** Object position */
-	public double x=0, y=0;
-	/** Object speed; default=0 */
-	public double xspeed=0, yspeed=0;
-	/** Object direction, is multiplied with speed; default=1 */
-	public int xdir=1,ydir=1;
-	/** Collision ID */
-	public int colid;
-	/** Object's global identifier; may not change during the lifetime of the
-	 * object. */
-	String name;
-	/** Number of move() steps before object removes itself, -1 (default)
-	 * is never; -2 means expire when off-playfield, -3 means expire when
-	 * off-view, -4 means suspend when off-view, -5 means suspend when
-	 * off-view and expire when off-playfield.  See also the expire_ and
-	 * suspend_ constants. */
-	public double expiry=-1;
-	/** If true, object will automatically start() when it is suspended and in
-	 * view.  Default is true. */
-	public boolean resume_in_view=true;
-
-	private boolean is_alive=true;
-	/** Indicates if object is suspended. */
-	public boolean is_suspended=false;
-
-	/** Get object's ID */
-	public String getName() { return name; }
-
-	/** Get name of current image. */
-	public String getImageName() { return imgname; }
-
-	String imgname=null;
-	Animation anim=null; /* will update imgname if set */
-	String animid=null;
-	/** cached value: has to be recomputed when image changes; simply set to
-	 * null to do this. */
-	JGRectangle imgbbox=null;
-	/** tile bbox is the bbox with offset 0; we have to add the current
-	 * coordinate to obtain the actual tile bbox.  Set to null to use regular
-	 * bbox instead. */
-	JGRectangle tilebbox=null;
-	/** The bbox that should override the image bbox if not null. */
-	JGRectangle bbox=null;
-
-	/** You can use this to call methods in the object's engine.  Even handier
-	 * is to have the objects as inner class of the engine. */
-	public JGEngineInterface eng;
-
-	/* dimensions of last time drawn  */
-	double lastx=0, lasty=0;
-	/* bbox/tilebbox is copied into these variables each time */
-	JGRectangle lastbbox_copy=new JGRectangle();
-	JGRectangle lasttilebbox_copy=new JGRectangle();
-	/* These are equal to lastbbox_copy if bbox was defined, or null
-	 * otherwise. */
-	JGRectangle lastbbox=null;
-	JGRectangle lasttilebbox=null; /* actual coordinates */
-
-	private void initObject(JGEngineInterface engine,
-	String name,int collisionid) {
-		this.eng=engine;
-		this.name=name;
-		colid=collisionid;
-		// XXX the test on suspend should really be done after the
-		// constructor of the subclass is finished, in case the position is
-		// changed later in the constructor.
-		if ((int)expiry==suspend_off_view
-		||  (int)expiry==suspend_off_view_expire_off_pf) {
-			if (!isInView(eng.getOffscreenMarginX(),eng.getOffscreenMarginY()))
-				suspend();
-		}
-		eng.markAddObject(this);
-	}
-
-	/** Clear tile bbox definition so that we use the regular bbox again. */
-	public void clearTileBBox() { tilebbox=null; }
-
-	public void setTileBBox(int x,int y, int width,int height) {
-		tilebbox = new JGRectangle(x,y,width,height);
-	}
-
-	/** Set bbox definition to override the image bbox.  */
-	public void setBBox(int x,int y, int width,int height) {
-		bbox = new JGRectangle(x,y,width,height);
-	}
-	/** Clear bbox definition so that we use the image bbox again. */
-	public void clearBBox() { bbox=null; }
-
-
-	///** Set object's tile span by defining the number of tiles and the margin
-	// * by which the object's position is snapped for determining the object's
-	// * top left position.  */
-	//public void setTiles(int xtiles,int ytiles,int gridsnapx,int gridsnapy){
-	//	this.xtiles=xtiles;
-	//	this.ytiles=ytiles;
-	//	this.gridsnapx=gridsnapx;
-	//	this.gridsnapy=gridsnapy;
-	//}
-
-	public void setPos(double x,double y) {
-		this.x=x;
-		this.y=y;
-	}
-
-	/** Set absolute speed.  Set xdir, ydir to the sign of the supplied speed,
-	 * and xspeed and yspeed to the absolute value of the supplied speed.
-	 * Passing a value of exactly 0.0 sets the dir to 0. */
-	public void setSpeedAbs(double xspeed, double yspeed) {
-		if (xspeed < 0.0) {
-			xdir = -1;
-			this.xspeed = -xspeed;
-		} else if (xspeed == 0.0) {
-			xdir = 0;
-			this.xspeed = 0;
-		} else {
-			xdir = 1;
-			this.xspeed = xspeed;
-		}
-		if (yspeed < 0.0) {
-			ydir = -1;
-			this.yspeed = -yspeed;
-		} else if (yspeed == 0.0) {
-			ydir = 0;
-			this.yspeed = 0;
-		} else {
-			ydir = 1;
-			this.yspeed = yspeed;
-		}
-	}
-
-	/** Set speed and direction in one go. */
-	public void setDirSpeed(int xdir,int ydir, double xspeed, double yspeed) {
-		this.xdir=xdir;
-		this.ydir=ydir;
-		this.xspeed=xspeed;
-		this.yspeed=yspeed;
-	}
-
-	/** Set speed and direction in one go. */
-	public void setDirSpeed(int xdir,int ydir, double speed) {
-		this.xdir=xdir;
-		this.ydir=ydir;
-		this.xspeed=speed;
-		this.yspeed=speed;
-	}
-
-	/** Set relative speed; the values are copied into xspeed,yspeed. */
-	public void setSpeed(double xspeed, double yspeed) {
-		this.xspeed=xspeed;
-		this.yspeed=yspeed;
-	}
-
-	/** Set relative speed; the value is copied into xspeed,yspeed. */
-	public void setSpeed(double speed) {
-		this.xspeed=speed;
-		this.yspeed=speed;
-	}
-
-	/** Set direction. */
-	public void setDir(int xdir, int ydir) {
-		this.xdir=xdir;
-		this.ydir=ydir;
-	}
-
-	/** Set ID of animation or image to display.  First, look for an animation
-	 * with the given ID, and setAnim if found.  Otherwise, look for an image
-	 * with the given ID, and setImage if found.  Passing null clears the
-	 * image and stops the animation.  */
-	public void setGraphic(String gfxname) {
-		if (gfxname==null) {
-			setImage(gfxname);
-		} else {
-			Animation newanim = eng.getAnimation(gfxname);
-			if (newanim!=null) {
-				setAnim(gfxname);
-			} else {
-				setImage(gfxname);
-			}
-		}
-	}
-
-	/** Set ID of image to display; clear animation. Passing null clears
-	* the image. */
-	public void setImage(String imgname) {
-		this.imgname=imgname;
-		imgbbox=null;
-		anim=null;
-		animid=null;
-		//stopAnim();
-	}
-	/** Get object's current animation ID, or image ID if not defined. */
-	public String getGraphic() {
-		if (animid!=null) return animid;
-		return imgname; 
-	}
-
-	/* animation */
-
-	/** Set the animation to the given default animation definition, or leave
-	 * it as it was if the anim_id is unchanged.  Subsequent changes made in
-	 * the animation's parameters do not change the default animation
-	 * definition. The changes will be preserved if another call to
-	 * setAnimation is made with the same anim_id.  If you want to reset the
-	 * animation to the original settings, use resetAnimation().
-	 */
-	public void setAnim(String anim_id) {
-		if (animid==null || !animid.equals(anim_id)) {
-			anim = eng.getAnimation(anim_id);
-			if (anim==null) {
-				eng.dbgPrint(name,"Warning: animation "+anim_id+" not found.");
-				return;
-			}
-			anim = anim.copy();
-			animid = anim_id;
-			imgname = anim.getCurrentFrame();
-		}
-	}
-
-	/** Always set the animation to the given default animation definition,
-	 * resetting any changes or updates made to the animation. Subsequent
-	 * changes made in the animation's parameters do not change the default
-	 * animation definition.
-	 */
-	public void resetAnim(String anim_id) {
-		anim = eng.getAnimation(anim_id).copy();
-		animid = anim_id;
-	}
-
-	/** Clear the animation, the object's current image will remain. */
-	public void clearAnim() { anim=null; animid=null; }
-
-	/** Get the ID of the currently running animation. */
-	public String getAnimId() { return animid; }
-
-	//public void setAnimIncrement(int increment) {
-	//	if (anim!=null) anim.increment=increment;
-	//}
-	/** Set animation speed; speed may be less than 0, indicating that
-	 * animation should go backwards. */
-	public void setAnimSpeed(double speed) {
-		if (anim!=null) {
-			if (speed >= 0) {
-				anim.speed=speed;
-				anim.increment=1;
-			} else {
-				anim.speed=-speed;
-				anim.increment=-1;
-			}
-		}
-	}
-	public void setAnimPingpong(boolean pingpong) {
-		if (anim!=null) anim.pingpong=pingpong;
-	}
-	public void startAnim() { if (anim!=null) anim.start(); }
-	public void stopAnim() { if (anim!=null) anim.stop(); }
-
-	/** Reset the animation's state to the start state. */
-	public void resetAnim() { if (anim!=null) anim.reset(); }
-
-
-	/** Create object.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname) {
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setPos(x,y);
-		setGraphic(gfxname);
-	}
-
-	/** Create object with given expiry.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,int expiry) {
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setPos(x,y);
-		setGraphic(gfxname);
-		this.expiry=expiry;
-	}
-
-	/** Create object with given tile bbox, old style.  Old style constructors
-	 * are not compatible with the JGame Flash parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int tilebbox_x,int tilebbox_y, int tilebbox_width,int tilebbox_height) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setTileBBox(tilebbox_x,tilebbox_y,tilebbox_width,tilebbox_height);
-	}
-
-	/** Create object with given tile bbox and expiry, old style.
-	* Old style constructors are not compatible with the JGame Flash
-	* parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int tilebbox_x,int tilebbox_y, int tilebbox_width,int tilebbox_height,
-	int expiry) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setTileBBox(tilebbox_x,tilebbox_y,tilebbox_width,tilebbox_height);
-		this.expiry=expiry;
-	}
-
-	/** Create object with given absolute speed, old style.
-	* Old style constructors are not compatible with the JGame Flash
-	* parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	double xspeed, double yspeed) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setSpeedAbs(xspeed,yspeed);
-	}
-
-	/** Create object with given absolute speed and expiry, old style.
-	* Old style constructors are not compatible with the JGame Flash
-	* parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	double xspeed, double yspeed, int expiry) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setSpeedAbs(xspeed,yspeed);
-		this.expiry = expiry;
-	}
-
-	/** Create object with given tile bbox and absolute speed, old style.
-	* Old style constructors are not compatible with the JGame Flash
-	* parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int tilebbox_x,int tilebbox_y, int tilebbox_width,int tilebbox_height,
-	double xspeed, double yspeed) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setTileBBox(tilebbox_x,tilebbox_y,tilebbox_width,tilebbox_height);
-		setSpeedAbs(xspeed,yspeed);
-	}
-
-	/** Create object with given tile bbox, absolute speed, expiry, old style.
-	* Old style constructors are not compatible with the JGame Flash
-	* parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int tilebbox_x,int tilebbox_y, int tilebbox_width,int tilebbox_height,
-	double xspeed, double yspeed, int expiry) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setTileBBox(tilebbox_x,tilebbox_y,tilebbox_width,tilebbox_height);
-		setSpeedAbs(xspeed,yspeed);
-		this.expiry = expiry;
-	}
-
-	/** Create object with given direction/speed, expiry, old style.
-	* Old style constructors are not compatible with the JGame Flash
-	* parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int xdir, int ydir, double xspeed, double yspeed, int expiry) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setDirSpeed(xdir,ydir,xspeed,yspeed);
-		this.expiry = expiry;
-	}
-
-	/** Create object with given tile bbox, direction/speed, expiry, old
-	 * style.
-	* Old style constructors are not compatible with the JGame Flash
-	* parameter order.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int tilebbox_x,int tilebbox_y, int tilebbox_width,int tilebbox_height,
-	int xdir, int ydir, double xspeed, double yspeed, int expiry) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setTileBBox(tilebbox_x,tilebbox_y,tilebbox_width,tilebbox_height);
-		setDirSpeed(xdir,ydir,xspeed,yspeed);
-		this.expiry = expiry;
-	}
-
-
-	/** Flash style constructors */
-
-	/** Create object with given absolute speed, expiry, new
-	 * style.  New-style constructors enable easier porting to JGame Flash.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int expiry,
-	double xspeed,double yspeed) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setTileBBox(tilebbox.x,tilebbox.y,tilebbox.width,tilebbox.height);
-		setSpeedAbs(xspeed,yspeed);
-		this.expiry = expiry;
-	}
-
-	/** Create object with given direction/speed, expiry, new
-	 * style.  New-style constructors enable easier porting to JGame Flash.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int expiry,
-	double xspeed,double yspeed,
-	int xdir,int ydir) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setDirSpeed(xdir,ydir,xspeed,yspeed);
-		this.expiry = expiry;
-	}
-
-	/** Create object with given tile bbox, direction/speed, expiry, new
-	 * style.  New-style constructors enable easier porting to JGame Flash.
-	* @param unique_id  append name with unique ID if unique_id set
-	* @param gfxname  id of animation or image, null = no image */
-	public JGObject (String name, boolean unique_id,
-	double x,double y,int collisionid,String gfxname,
-	int expiry,
-	double xspeed,double yspeed,
-	int xdir,int ydir,
-	JGRectangle tilebbox) {
-		setPos(x,y);
-		initObject(default_engine,
-				name + (unique_id ? ""+(next_id++) : "" ), collisionid );
-		setGraphic(gfxname);
-		setTileBBox(tilebbox.x,tilebbox.y,tilebbox.width,tilebbox.height);
-		setDirSpeed(xdir,ydir,xspeed,yspeed);
-		this.expiry = expiry;
-	}
-
-
-	/* Bounding box functions.  Return copies. May return null if
-	 * image is not defined. */
-
-	/** Copy object collision bounding box in pixels into bbox_copy. Has actual
-	* coordinate offset.  If bounding box is not defined, bbox_copy is
-	* unchanged.
-	* @return false if bbox is null, true if not null  */
-	public boolean getBBox(JGRectangle bbox_copy) {
-		if (bbox!=null) {
-			bbox_copy.x = bbox.x+(int)x;
-			bbox_copy.y = bbox.y+(int)y;
-			bbox_copy.width = bbox.width;
-			bbox_copy.height= bbox.height;
-			return true;
-		}
-		//updateImageBBox();
-		// inlined updateImageBBox
-		if (imgbbox==null && imgname!=null) {
-			imgbbox = eng.getImageBBox(imgname);
-		}
-		if (imgbbox!=null) {
-			bbox_copy.x = imgbbox.x+(int)x;
-			bbox_copy.y = imgbbox.y+(int)y;
-			bbox_copy.width=imgbbox.width;
-			bbox_copy.height=imgbbox.height;
-			return true;
-		}
-		return false;
-	}
-
-	/** Get object collision bounding box in pixels.
-	* Has actual coordinate offset.
-	* @return copy of bbox in pixel coordinates, null if no bbox
-	*/
-	public JGRectangle getBBox() {
-		if (bbox!=null) return new JGRectangle(bbox.x+(int)x, bbox.y+(int)y,
-				bbox.width, bbox.height);
-		updateImageBBox();
-		if (imgbbox!=null) {
-			return new JGRectangle(imgbbox.x+(int)x, imgbbox.y+(int)y,
-				imgbbox.width, imgbbox.height );
-		}
-		return null;
-	}
-
-	//JGRectangle bbox_const = new JGRectangle(0,0,0,0);
-
-	/** Get object collision bounding box in pixels.
-	* Has actual coordinate offset.  Uses a fixed temp variable to store the
-	* bbox, so no object is created.  The returned object may not be modified,
-	* nor its contents used after the method is re-entered.
-	* @return bbox in pixel coordinates, null if no bbox
-	*/
-	//public JGRectangle getBBoxConst() {
-	//	if (!getBBox(bbox_const)) return null;
-	//	return bbox_const;
-	//}
-
-	/** Get object collision bounding box in pixels of previous frame.
-	* @return pixel coordinates, null if no bbox */
+    static int next_id = 0;
+    /**
+     * global which might be accessed concurrently
+     */
+    static JGEngineInterface default_engine = null;
+
+    /**
+     * The engine's viewWidth and viewHeight, stored in a local variable
+     * for extra speed.
+     */
+    public static int viewwidth, viewheight;
+    /**
+     * The engine's tileWidth and tileHeight, stored in a local variable
+     * for extra speed.
+     */
+    public static int tilewidth, tileheight;
+    /**
+     * The engine's pfWrap settings, stored in a local variable
+     * for extra speed.
+     */
+    public static boolean pfwrapx, pfwrapy;
+    /**
+     * The engine's gamespeed setting, stored in a local variable
+     * for extra speed.
+     */
+    public static double gamespeed;
+    /**
+     * The engine's pfWidth/pfHeight, stored in a local variable
+     * for extra speed.
+     */
+    public static int pfwidth, pfheight;
+    /**
+     * The engine's viewX/YOfs, stored in a local variable
+     * for extra speed.
+     */
+    public static int viewxofs, viewyofs;
+
+    /**
+     * Set the engine to connect to when a new object is created.  This
+     * should be called only by the JGEngine implementation.
+     *
+     * @param engine pass null to indicate the engine has exited.
+     * @return true if success; false if other engine already running.
+     */
+    public static boolean setEngine(JGEngineInterface engine) {
+        if (engine == null) {
+            default_engine = null;
+            return true;
+        }
+        if (default_engine != null) return false;
+        default_engine = engine;
+        // copy some constants from engine for fast access
+        viewwidth = engine.viewWidth();
+        viewheight = engine.viewHeight();
+        tilewidth = engine.tileWidth();
+        tileheight = engine.tileHeight();
+        updateEngineSettings();
+        return true;
+    }
+
+    /**
+     * Called automatically by the engine to signal changes to pfWrap,
+     * gameSpeed, pfWidth/Height, viewX/YOfs.  The current values of these
+     * settings are stored in the JGObject local variables.
+     */
+    public static void updateEngineSettings() {
+        pfwrapx = default_engine.pfWrapX();
+        pfwrapy = default_engine.pfWrapY();
+        gamespeed = default_engine.getGameSpeed();
+        pfwidth = default_engine.pfWidth();
+        pfheight = default_engine.pfHeight();
+        viewxofs = default_engine.viewXOfs();
+        viewyofs = default_engine.viewYOfs();
+    }
+
+    // remove object creation when changing anim
+
+    /**
+     * Print a message to the debug channel, using the object ID as source
+     */
+    public void dbgPrint(String msg) {
+        eng.dbgPrint(name, msg);
+    }
+
+    /**
+     * Expiry value: never expire.
+     */
+    public static final int expire_never = -1;
+    /**
+     * Expiry value: expire when off playfield.
+     */
+    public static final int expire_off_pf = -2;
+    /**
+     * Expiry value: expire when out of view.
+     */
+    public static final int expire_off_view = -3;
+    /**
+     * Expiry value: suspend when out of view.
+     */
+    public static final int suspend_off_view = -4;
+    /**
+     * Expiry value: suspend when out of view and expire when out of
+     * playfield.
+     */
+    public static final int suspend_off_view_expire_off_pf = -5;
+
+    /**
+     * Object position
+     */
+    public double x = 0, y = 0;
+    /**
+     * Object speed; default=0
+     */
+    public double xspeed = 0, yspeed = 0;
+    /**
+     * Object direction, is multiplied with speed; default=1
+     */
+    public int xdir = 1, ydir = 1;
+    /**
+     * Collision ID
+     */
+    public int colid;
+    /**
+     * Object's global identifier; may not change during the lifetime of the
+     * object.
+     */
+    String name;
+    /**
+     * Number of move() steps before object removes itself, -1 (default)
+     * is never; -2 means expire when off-playfield, -3 means expire when
+     * off-view, -4 means suspend when off-view, -5 means suspend when
+     * off-view and expire when off-playfield.  See also the expire_ and
+     * suspend_ constants.
+     */
+    public double expiry = -1;
+    /**
+     * If true, object will automatically start() when it is suspended and in
+     * view.  Default is true.
+     */
+    public boolean resume_in_view = true;
+
+    private boolean is_alive = true;
+    /**
+     * Indicates if object is suspended.
+     */
+    public boolean is_suspended = false;
+
+    /**
+     * Get object's ID
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Get name of current image.
+     */
+    public String getImageName() {
+        return imgname;
+    }
+
+    String imgname = null;
+    Animation anim = null; /* will update imgname if set */
+    String animid = null;
+    /**
+     * cached value: has to be recomputed when image changes; simply set to
+     * null to do this.
+     */
+    JGRectangle imgbbox = null;
+    /**
+     * tile bbox is the bbox with offset 0; we have to add the current
+     * coordinate to obtain the actual tile bbox.  Set to null to use regular
+     * bbox instead.
+     */
+    JGRectangle tilebbox = null;
+    /**
+     * The bbox that should override the image bbox if not null.
+     */
+    JGRectangle bbox = null;
+
+    /**
+     * You can use this to call methods in the object's engine.  Even handier
+     * is to have the objects as inner class of the engine.
+     */
+    public JGEngineInterface eng;
+
+    /* dimensions of last time drawn  */
+    double lastx = 0, lasty = 0;
+    /* bbox/tilebbox is copied into these variables each time */
+    JGRectangle lastbbox_copy = new JGRectangle();
+    JGRectangle lasttilebbox_copy = new JGRectangle();
+    /* These are equal to lastbbox_copy if bbox was defined, or null
+     * otherwise. */
+    JGRectangle lastbbox = null;
+    JGRectangle lasttilebbox = null; /* actual coordinates */
+
+    private void initObject(JGEngineInterface engine,
+                            String name, int collisionid) {
+        this.eng = engine;
+        this.name = name;
+        colid = collisionid;
+        // XXX the test on suspend should really be done after the
+        // constructor of the subclass is finished, in case the position is
+        // changed later in the constructor.
+        if ((int) expiry == suspend_off_view
+                || (int) expiry == suspend_off_view_expire_off_pf) {
+            if (!isInView(eng.getOffscreenMarginX(), eng.getOffscreenMarginY()))
+                suspend();
+        }
+        eng.markAddObject(this);
+    }
+
+    /**
+     * Clear tile bbox definition so that we use the regular bbox again.
+     */
+    public void clearTileBBox() {
+        tilebbox = null;
+    }
+
+    public void setTileBBox(int x, int y, int width, int height) {
+        tilebbox = new JGRectangle(x, y, width, height);
+    }
+
+    /**
+     * Set bbox definition to override the image bbox.
+     */
+    public void setBBox(int x, int y, int width, int height) {
+        bbox = new JGRectangle(x, y, width, height);
+    }
+
+    /**
+     * Clear bbox definition so that we use the image bbox again.
+     */
+    public void clearBBox() {
+        bbox = null;
+    }
+
+
+    ///** Set object's tile span by defining the number of tiles and the margin
+    // * by which the object's position is snapped for determining the object's
+    // * top left position.  */
+    //public void setTiles(int xtiles,int ytiles,int gridsnapx,int gridsnapy){
+    //	this.xtiles=xtiles;
+    //	this.ytiles=ytiles;
+    //	this.gridsnapx=gridsnapx;
+    //	this.gridsnapy=gridsnapy;
+    //}
+
+    public void setPos(double x, double y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    /**
+     * Set absolute speed.  Set xdir, ydir to the sign of the supplied speed,
+     * and xspeed and yspeed to the absolute value of the supplied speed.
+     * Passing a value of exactly 0.0 sets the dir to 0.
+     */
+    public void setSpeedAbs(double xspeed, double yspeed) {
+        if (xspeed < 0.0) {
+            xdir = -1;
+            this.xspeed = -xspeed;
+        } else if (xspeed == 0.0) {
+            xdir = 0;
+            this.xspeed = 0;
+        } else {
+            xdir = 1;
+            this.xspeed = xspeed;
+        }
+        if (yspeed < 0.0) {
+            ydir = -1;
+            this.yspeed = -yspeed;
+        } else if (yspeed == 0.0) {
+            ydir = 0;
+            this.yspeed = 0;
+        } else {
+            ydir = 1;
+            this.yspeed = yspeed;
+        }
+    }
+
+    /**
+     * Set speed and direction in one go.
+     */
+    public void setDirSpeed(int xdir, int ydir, double xspeed, double yspeed) {
+        this.xdir = xdir;
+        this.ydir = ydir;
+        this.xspeed = xspeed;
+        this.yspeed = yspeed;
+    }
+
+    /**
+     * Set speed and direction in one go.
+     */
+    public void setDirSpeed(int xdir, int ydir, double speed) {
+        this.xdir = xdir;
+        this.ydir = ydir;
+        this.xspeed = speed;
+        this.yspeed = speed;
+    }
+
+    /**
+     * Set relative speed; the values are copied into xspeed,yspeed.
+     */
+    public void setSpeed(double xspeed, double yspeed) {
+        this.xspeed = xspeed;
+        this.yspeed = yspeed;
+    }
+
+    /**
+     * Set relative speed; the value is copied into xspeed,yspeed.
+     */
+    public void setSpeed(double speed) {
+        this.xspeed = speed;
+        this.yspeed = speed;
+    }
+
+    /**
+     * Set direction.
+     */
+    public void setDir(int xdir, int ydir) {
+        this.xdir = xdir;
+        this.ydir = ydir;
+    }
+
+    /**
+     * Set ID of animation or image to display.  First, look for an animation
+     * with the given ID, and setAnim if found.  Otherwise, look for an image
+     * with the given ID, and setImage if found.  Passing null clears the
+     * image and stops the animation.
+     */
+    public void setGraphic(String gfxname) {
+        if (gfxname == null) {
+            setImage(gfxname);
+        } else {
+            Animation newanim = eng.getAnimation(gfxname);
+            if (newanim != null) {
+                setAnim(gfxname);
+            } else {
+                setImage(gfxname);
+            }
+        }
+    }
+
+    /**
+     * Set ID of image to display; clear animation. Passing null clears
+     * the image.
+     */
+    public void setImage(String imgname) {
+        this.imgname = imgname;
+        imgbbox = null;
+        anim = null;
+        animid = null;
+        //stopAnim();
+    }
+
+    /**
+     * Get object's current animation ID, or image ID if not defined.
+     */
+    public String getGraphic() {
+        if (animid != null) return animid;
+        return imgname;
+    }
+
+    /* animation */
+
+    /**
+     * Set the animation to the given default animation definition, or leave
+     * it as it was if the anim_id is unchanged.  Subsequent changes made in
+     * the animation's parameters do not change the default animation
+     * definition. The changes will be preserved if another call to
+     * setAnimation is made with the same anim_id.  If you want to reset the
+     * animation to the original settings, use resetAnimation().
+     */
+    public void setAnim(String anim_id) {
+        if (animid == null || !animid.equals(anim_id)) {
+            anim = eng.getAnimation(anim_id);
+            if (anim == null) {
+                eng.dbgPrint(name, "Warning: animation " + anim_id + " not found.");
+                return;
+            }
+            anim = anim.copy();
+            animid = anim_id;
+            imgname = anim.getCurrentFrame();
+        }
+    }
+
+    /**
+     * Always set the animation to the given default animation definition,
+     * resetting any changes or updates made to the animation. Subsequent
+     * changes made in the animation's parameters do not change the default
+     * animation definition.
+     */
+    public void resetAnim(String anim_id) {
+        anim = eng.getAnimation(anim_id).copy();
+        animid = anim_id;
+    }
+
+    /**
+     * Clear the animation, the object's current image will remain.
+     */
+    public void clearAnim() {
+        anim = null;
+        animid = null;
+    }
+
+    /**
+     * Get the ID of the currently running animation.
+     */
+    public String getAnimId() {
+        return animid;
+    }
+
+    //public void setAnimIncrement(int increment) {
+    //	if (anim!=null) anim.increment=increment;
+    //}
+
+    /**
+     * Set animation speed; speed may be less than 0, indicating that
+     * animation should go backwards.
+     */
+    public void setAnimSpeed(double speed) {
+        if (anim != null) {
+            if (speed >= 0) {
+                anim.speed = speed;
+                anim.increment = 1;
+            } else {
+                anim.speed = -speed;
+                anim.increment = -1;
+            }
+        }
+    }
+
+    public void setAnimPingpong(boolean pingpong) {
+        if (anim != null) anim.pingpong = pingpong;
+    }
+
+    public void startAnim() {
+        if (anim != null) anim.start();
+    }
+
+    public void stopAnim() {
+        if (anim != null) anim.stop();
+    }
+
+    /**
+     * Reset the animation's state to the start state.
+     */
+    public void resetAnim() {
+        if (anim != null) anim.reset();
+    }
+
+
+    /**
+     * Create object.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname) {
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setPos(x, y);
+        setGraphic(gfxname);
+    }
+
+    /**
+     * Create object with given expiry.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname, int expiry) {
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setPos(x, y);
+        setGraphic(gfxname);
+        this.expiry = expiry;
+    }
+
+    /**
+     * Create object with given tile bbox, old style.  Old style constructors
+     * are not compatible with the JGame Flash parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int tilebbox_x, int tilebbox_y, int tilebbox_width, int tilebbox_height) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setTileBBox(tilebbox_x, tilebbox_y, tilebbox_width, tilebbox_height);
+    }
+
+    /**
+     * Create object with given tile bbox and expiry, old style.
+     * Old style constructors are not compatible with the JGame Flash
+     * parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int tilebbox_x, int tilebbox_y, int tilebbox_width, int tilebbox_height,
+                    int expiry) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setTileBBox(tilebbox_x, tilebbox_y, tilebbox_width, tilebbox_height);
+        this.expiry = expiry;
+    }
+
+    /**
+     * Create object with given absolute speed, old style.
+     * Old style constructors are not compatible with the JGame Flash
+     * parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    double xspeed, double yspeed) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setSpeedAbs(xspeed, yspeed);
+    }
+
+    /**
+     * Create object with given absolute speed and expiry, old style.
+     * Old style constructors are not compatible with the JGame Flash
+     * parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    double xspeed, double yspeed, int expiry) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setSpeedAbs(xspeed, yspeed);
+        this.expiry = expiry;
+    }
+
+    /**
+     * Create object with given tile bbox and absolute speed, old style.
+     * Old style constructors are not compatible with the JGame Flash
+     * parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int tilebbox_x, int tilebbox_y, int tilebbox_width, int tilebbox_height,
+                    double xspeed, double yspeed) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setTileBBox(tilebbox_x, tilebbox_y, tilebbox_width, tilebbox_height);
+        setSpeedAbs(xspeed, yspeed);
+    }
+
+    /**
+     * Create object with given tile bbox, absolute speed, expiry, old style.
+     * Old style constructors are not compatible with the JGame Flash
+     * parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int tilebbox_x, int tilebbox_y, int tilebbox_width, int tilebbox_height,
+                    double xspeed, double yspeed, int expiry) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setTileBBox(tilebbox_x, tilebbox_y, tilebbox_width, tilebbox_height);
+        setSpeedAbs(xspeed, yspeed);
+        this.expiry = expiry;
+    }
+
+    /**
+     * Create object with given direction/speed, expiry, old style.
+     * Old style constructors are not compatible with the JGame Flash
+     * parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int xdir, int ydir, double xspeed, double yspeed, int expiry) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setDirSpeed(xdir, ydir, xspeed, yspeed);
+        this.expiry = expiry;
+    }
+
+    /**
+     * Create object with given tile bbox, direction/speed, expiry, old
+     * style.
+     * Old style constructors are not compatible with the JGame Flash
+     * parameter order.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int tilebbox_x, int tilebbox_y, int tilebbox_width, int tilebbox_height,
+                    int xdir, int ydir, double xspeed, double yspeed, int expiry) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setTileBBox(tilebbox_x, tilebbox_y, tilebbox_width, tilebbox_height);
+        setDirSpeed(xdir, ydir, xspeed, yspeed);
+        this.expiry = expiry;
+    }
+
+
+    /** Flash style constructors */
+
+    /**
+     * Create object with given absolute speed, expiry, new
+     * style.  New-style constructors enable easier porting to JGame Flash.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int expiry,
+                    double xspeed, double yspeed) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setTileBBox(tilebbox.x, tilebbox.y, tilebbox.width, tilebbox.height);
+        setSpeedAbs(xspeed, yspeed);
+        this.expiry = expiry;
+    }
+
+    /**
+     * Create object with given direction/speed, expiry, new
+     * style.  New-style constructors enable easier porting to JGame Flash.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int expiry,
+                    double xspeed, double yspeed,
+                    int xdir, int ydir) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setDirSpeed(xdir, ydir, xspeed, yspeed);
+        this.expiry = expiry;
+    }
+
+    /**
+     * Create object with given tile bbox, direction/speed, expiry, new
+     * style.  New-style constructors enable easier porting to JGame Flash.
+     *
+     * @param unique_id append name with unique ID if unique_id set
+     * @param gfxname   id of animation or image, null = no image
+     */
+    public JGObject(String name, boolean unique_id,
+                    double x, double y, int collisionid, String gfxname,
+                    int expiry,
+                    double xspeed, double yspeed,
+                    int xdir, int ydir,
+                    JGRectangle tilebbox) {
+        setPos(x, y);
+        initObject(default_engine,
+                name + (unique_id ? "" + (next_id++) : ""), collisionid);
+        setGraphic(gfxname);
+        setTileBBox(tilebbox.x, tilebbox.y, tilebbox.width, tilebbox.height);
+        setDirSpeed(xdir, ydir, xspeed, yspeed);
+        this.expiry = expiry;
+    }
+
+
+    /* Bounding box functions.  Return copies. May return null if
+     * image is not defined. */
+
+    /**
+     * Copy object collision bounding box in pixels into bbox_copy. Has actual
+     * coordinate offset.  If bounding box is not defined, bbox_copy is
+     * unchanged.
+     *
+     * @return false if bbox is null, true if not null
+     */
+    public boolean getBBox(JGRectangle bbox_copy) {
+        if (bbox != null) {
+            bbox_copy.x = bbox.x + (int) x;
+            bbox_copy.y = bbox.y + (int) y;
+            bbox_copy.width = bbox.width;
+            bbox_copy.height = bbox.height;
+            return true;
+        }
+        //updateImageBBox();
+        // inlined updateImageBBox
+        if (imgbbox == null && imgname != null) {
+            imgbbox = eng.getImageBBox(imgname);
+        }
+        if (imgbbox != null) {
+            bbox_copy.x = imgbbox.x + (int) x;
+            bbox_copy.y = imgbbox.y + (int) y;
+            bbox_copy.width = imgbbox.width;
+            bbox_copy.height = imgbbox.height;
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Get object collision bounding box in pixels.
+     * Has actual coordinate offset.
+     *
+     * @return copy of bbox in pixel coordinates, null if no bbox
+     */
+    public JGRectangle getBBox() {
+        if (bbox != null) return new JGRectangle(bbox.x + (int) x, bbox.y + (int) y,
+                bbox.width, bbox.height);
+        updateImageBBox();
+        if (imgbbox != null) {
+            return new JGRectangle(imgbbox.x + (int) x, imgbbox.y + (int) y,
+                    imgbbox.width, imgbbox.height);
+        }
+        return null;
+    }
+
+    //JGRectangle bbox_const = new JGRectangle(0,0,0,0);
+
+    /** Get object collision bounding box in pixels.
+     * Has actual coordinate offset.  Uses a fixed temp variable to store the
+     * bbox, so no object is created.  The returned object may not be modified,
+     * nor its contents used after the method is re-entered.
+     * @return bbox in pixel coordinates, null if no bbox
+     */
+    //public JGRectangle getBBoxConst() {
+    //	if (!getBBox(bbox_const)) return null;
+    //	return bbox_const;
+    //}
+
+    /** Get object collision bounding box in pixels of previous frame.
+     * @return pixel coordinates, null if no bbox */
 //	public JGRectangle getLastBBox() {
 //		if (lastbbox==null) return null;
 //		return new JGRectangle(lastbbox);
 //	}
 
-	/** Get tile collision bounding box in pixels and store it in bbox_copy.
-	* Bounding box has actual coordinate offset.  If bounding box is not
-	* defined, bbox_copy is unchanged.
-	* @return  false when bounding box is not defined, true otherwise */
-	public boolean getTileBBox(JGRectangle bbox_copy) {
-		if (tilebbox==null) {
-			return getBBox(bbox_copy);
-		}
-		bbox_copy.x = (int)x+tilebbox.x;
-		bbox_copy.y = (int)y+tilebbox.y;
-		bbox_copy.width = tilebbox.width;
-		bbox_copy.height= tilebbox.height;
-		return true;
-	}
-
-	/** Get tile collision bounding box in pixels.
-	* Bounding box has actual coordinate offset.
-	* @return  copy of bbox in pixel coordinates, null if no bbox */
-	public JGRectangle getTileBBox() {
-		if (tilebbox==null) return getBBox();
-		return new JGRectangle((int)x+tilebbox.x,(int)y+tilebbox.y,
-			tilebbox.width,tilebbox.height);
-	}
-
-	//JGRectangle tilebbox_const = new JGRectangle(0,0,0,0);
-	/** Get tile collision bounding box in pixels.
-	* Bounding box has actual coordinate offset.   Returns reference to a
-	* fixed internal variable.  Do not change the object returned, avoid
-	* re-entering this method and then using the previous value returned.
-	* @return  pixel coordinates, null if no bbox */
-	//public JGRectangle getTileBBoxConst() {
-	//	if (tilebbox==null) {
-	//		JGRectangle bbox = getBBoxConst();
-	//		if (bbox==null) return null;
-	//		tilebbox_const.copyFrom(bbox);
-	//		return tilebbox_const;
-	//	}
-	//	tilebbox_const.x = (int)x+tilebbox.x;
-	//	tilebbox_const.y = (int)y+tilebbox.y;
-	//	tilebbox_const.width = tilebbox.width;
-	//	tilebbox_const.height= tilebbox.height;
-	//	return tilebbox_const;
-	//}
-
-
-	/** Get tile collision bounding box of previous frame.
-	* @return  pixel coordinates, null if no bbox */
+    /**
+     * Get tile collision bounding box in pixels and store it in bbox_copy.
+     * Bounding box has actual coordinate offset.  If bounding box is not
+     * defined, bbox_copy is unchanged.
+     *
+     * @return false when bounding box is not defined, true otherwise
+     */
+    public boolean getTileBBox(JGRectangle bbox_copy) {
+        if (tilebbox == null) {
+            return getBBox(bbox_copy);
+        }
+        bbox_copy.x = (int) x + tilebbox.x;
+        bbox_copy.y = (int) y + tilebbox.y;
+        bbox_copy.width = tilebbox.width;
+        bbox_copy.height = tilebbox.height;
+        return true;
+    }
+
+    /**
+     * Get tile collision bounding box in pixels.
+     * Bounding box has actual coordinate offset.
+     *
+     * @return copy of bbox in pixel coordinates, null if no bbox
+     */
+    public JGRectangle getTileBBox() {
+        if (tilebbox == null) return getBBox();
+        return new JGRectangle((int) x + tilebbox.x, (int) y + tilebbox.y,
+                tilebbox.width, tilebbox.height);
+    }
+
+    //JGRectangle tilebbox_const = new JGRectangle(0,0,0,0);
+    /** Get tile collision bounding box in pixels.
+     * Bounding box has actual coordinate offset.   Returns reference to a
+     * fixed internal variable.  Do not change the object returned, avoid
+     * re-entering this method and then using the previous value returned.
+     * @return pixel coordinates, null if no bbox */
+    //public JGRectangle getTileBBoxConst() {
+    //	if (tilebbox==null) {
+    //		JGRectangle bbox = getBBoxConst();
+    //		if (bbox==null) return null;
+    //		tilebbox_const.copyFrom(bbox);
+    //		return tilebbox_const;
+    //	}
+    //	tilebbox_const.x = (int)x+tilebbox.x;
+    //	tilebbox_const.y = (int)y+tilebbox.y;
+    //	tilebbox_const.width = tilebbox.width;
+    //	tilebbox_const.height= tilebbox.height;
+    //	return tilebbox_const;
+    //}
+
+
+    /** Get tile collision bounding box of previous frame.
+     * @return pixel coordinates, null if no bbox */
 //	public JGRectangle getLastTileBBox() {
 //		if (lasttilebbox==null) return null;
 //		return new JGRectangle(lasttilebbox);
 //	}
 
-	/** Get collision bounding box of object's image (same as object's default
-	* bbox, note that the offset is (0,0) here).
-	* @return  copy of bbox's pixel coordinates, null if no bbox */
-	public JGRectangle getImageBBox() {
-		updateImageBBox();
-		if (imgbbox==null) return null;
-		return new JGRectangle(imgbbox);
-	}
-
-	/** Get collision bounding box of object's image (same as object's default
-	* bbox, note that the offset is (0,0) here). Optimised version of
-	* getImageBBox().  Do not change the value of the object!
-	* @return  *original* bbox's pixel coordinates, null if no bbox */
-	public JGRectangle getImageBBoxConst() {
-		updateImageBBox();
-		return imgbbox;
-	}
-
-	/** Update the imgbbox variable. */
-	void updateImageBBox() {
-		if (imgbbox==null && imgname!=null) {
-			imgbbox = eng.getImageBBox(imgname);
-		}
-	}
-
-	/** Get x position of previous frame. Returns 0 if first frame. */
-	public double getLastX() { return lastx; }
-	/** Get y position of previous frame. Returns 0 if first frame. */
-	public double getLastY() { return lasty; }
-
-
-	/* snap functions */
-
-	/** Snap object to grid using the default gridsnap margin of
-	 * (xspeed*gamespeed-epsilon, yspeed*gamespeed-epsilon),
-	 * corresponding to the default is...Aligned margin. */
-	public void snapToGrid() {
-		x = eng.snapToGridX(x,Math.abs(xspeed*gamespeed-0.001));
-		y = eng.snapToGridY(y,Math.abs(yspeed*gamespeed-0.001));
-	}
-
-	/** Snap object to grid.
-	* @param gridsnapx margin below which to snap, 0.0 is no snap
-	* @param gridsnapy margin below which to snap, 0.0 is no snap */
-	public void snapToGrid(double gridsnapx,double gridsnapy) {
-		x = eng.snapToGridX(x,gridsnapx);
-		y = eng.snapToGridY(y,gridsnapy);
-	}
-	///** Snap object to grid. */
-	//public void snapToGrid(int gridsnapx, int gridsnapy) {
-	//	JGPoint p = new JGPoint((int)x,(int)y);
-	//	eng.snapToGrid(p,gridsnapx,gridsnapy);
-	//	x = p.x;
-	//	y = p.y;
-	//}
-	/** Snap an object's tile bbox corner to grid; floats are rounded down.
-	* Snaps to bottom or right of object instead of top and left if the resp.
-	* flags are set. Note that bottom and right alignment means that the
-	* object's bounding box is one pixel away from crossing the tile border.
-	* @param snap_right snap the right hand side of the tile bbox
-	* @param snap_bottom snap the bottom of the tile bbox */
-	public void snapBBoxToGrid(double gridsnapx,double gridsnapy,
-	boolean snap_right, boolean snap_bottom) {
-		JGRectangle bbox = getTileBBox();
-		double bx = x + bbox.x;
-		double by = y + bbox.y;
-		if (snap_right)  bx += bbox.width;
-		if (snap_bottom) by += bbox.height;
-		double bxs = eng.snapToGridX(bx,gridsnapx);
-		double bys = eng.snapToGridY(by,gridsnapy);
-		bxs -= bbox.x;
-		bys -= bbox.y;
-		if (snap_right)  bxs -= bbox.width;
-		if (snap_bottom) bys -= bbox.height;
-		x = bxs;
-		y = bys;
-	}
-
-	/* bg interaction */
-
-	// temp variables used by get*Tiles and isOnScreen/PF
-	JGRectangle temp_bbox_copy = new JGRectangle();
-
-	// variables returned by get*Tiles
-	JGRectangle tiles_copy = null;
-	JGRectangle last_tiles_copy = null;
-	JGRectangle center_tiles_copy = new JGRectangle();
-	JGRectangle last_center_tiles_copy = null;
-	JGPoint center_tile_copy = null;
-	JGPoint tl_tile_copy = null;
-	/** Get the tile index coordinates of all the tiles that the object's
-	* tile bbox overlaps with.  Always returns the same temp object, so no
-	* object creation is necessary.
-	* @return tile index coordinates, null if no bbox */
-	public JGRectangle getTiles() {
-		//orig: return eng.getTiles(getTileBBox());
-		if (!getTileBBox(temp_bbox_copy)) return null;
-		if (tiles_copy==null) tiles_copy = new JGRectangle();
-		if (eng.getTiles(tiles_copy,temp_bbox_copy))
-			return tiles_copy;
-		return null;
-	}
-
-	/** Get the tile index coordinates of the object's previous tile bbox.
-	* Always returns the same temp object, so no object creation is necessary.
-	* @return tile index coordinates, null if no tile bbox */
+    /**
+     * Get collision bounding box of object's image (same as object's default
+     * bbox, note that the offset is (0,0) here).
+     *
+     * @return copy of bbox's pixel coordinates, null if no bbox
+     */
+    public JGRectangle getImageBBox() {
+        updateImageBBox();
+        if (imgbbox == null) return null;
+        return new JGRectangle(imgbbox);
+    }
+
+    /**
+     * Get collision bounding box of object's image (same as object's default
+     * bbox, note that the offset is (0,0) here). Optimised version of
+     * getImageBBox().  Do not change the value of the object!
+     *
+     * @return *original* bbox's pixel coordinates, null if no bbox
+     */
+    public JGRectangle getImageBBoxConst() {
+        updateImageBBox();
+        return imgbbox;
+    }
+
+    /**
+     * Update the imgbbox variable.
+     */
+    void updateImageBBox() {
+        if (imgbbox == null && imgname != null) {
+            imgbbox = eng.getImageBBox(imgname);
+        }
+    }
+
+    /**
+     * Get x position of previous frame. Returns 0 if first frame.
+     */
+    public double getLastX() {
+        return lastx;
+    }
+
+    /**
+     * Get y position of previous frame. Returns 0 if first frame.
+     */
+    public double getLastY() {
+        return lasty;
+    }
+
+
+    /* snap functions */
+
+    /**
+     * Snap object to grid using the default gridsnap margin of
+     * (xspeed*gamespeed-epsilon, yspeed*gamespeed-epsilon),
+     * corresponding to the default is...Aligned margin.
+     */
+    public void snapToGrid() {
+        x = eng.snapToGridX(x, Math.abs(xspeed * gamespeed - 0.001));
+        y = eng.snapToGridY(y, Math.abs(yspeed * gamespeed - 0.001));
+    }
+
+    /**
+     * Snap object to grid.
+     *
+     * @param gridsnapx margin below which to snap, 0.0 is no snap
+     * @param gridsnapy margin below which to snap, 0.0 is no snap
+     */
+    public void snapToGrid(double gridsnapx, double gridsnapy) {
+        x = eng.snapToGridX(x, gridsnapx);
+        y = eng.snapToGridY(y, gridsnapy);
+    }
+    ///** Snap object to grid. */
+    //public void snapToGrid(int gridsnapx, int gridsnapy) {
+    //	JGPoint p = new JGPoint((int)x,(int)y);
+    //	eng.snapToGrid(p,gridsnapx,gridsnapy);
+    //	x = p.x;
+    //	y = p.y;
+    //}
+
+    /**
+     * Snap an object's tile bbox corner to grid; floats are rounded down.
+     * Snaps to bottom or right of object instead of top and left if the resp.
+     * flags are set. Note that bottom and right alignment means that the
+     * object's bounding box is one pixel away from crossing the tile border.
+     *
+     * @param snap_right  snap the right hand side of the tile bbox
+     * @param snap_bottom snap the bottom of the tile bbox
+     */
+    public void snapBBoxToGrid(double gridsnapx, double gridsnapy,
+                               boolean snap_right, boolean snap_bottom) {
+        JGRectangle bbox = getTileBBox();
+        double bx = x + bbox.x;
+        double by = y + bbox.y;
+        if (snap_right) bx += bbox.width;
+        if (snap_bottom) by += bbox.height;
+        double bxs = eng.snapToGridX(bx, gridsnapx);
+        double bys = eng.snapToGridY(by, gridsnapy);
+        bxs -= bbox.x;
+        bys -= bbox.y;
+        if (snap_right) bxs -= bbox.width;
+        if (snap_bottom) bys -= bbox.height;
+        x = bxs;
+        y = bys;
+    }
+
+    /* bg interaction */
+
+    // temp variables used by get*Tiles and isOnScreen/PF
+    JGRectangle temp_bbox_copy = new JGRectangle();
+
+    // variables returned by get*Tiles
+    JGRectangle tiles_copy = null;
+    JGRectangle last_tiles_copy = null;
+    JGRectangle center_tiles_copy = new JGRectangle();
+    JGRectangle last_center_tiles_copy = null;
+    JGPoint center_tile_copy = null;
+    JGPoint tl_tile_copy = null;
+
+    /**
+     * Get the tile index coordinates of all the tiles that the object's
+     * tile bbox overlaps with.  Always returns the same temp object, so no
+     * object creation is necessary.
+     *
+     * @return tile index coordinates, null if no bbox
+     */
+    public JGRectangle getTiles() {
+        //orig: return eng.getTiles(getTileBBox());
+        if (!getTileBBox(temp_bbox_copy)) return null;
+        if (tiles_copy == null) tiles_copy = new JGRectangle();
+        if (eng.getTiles(tiles_copy, temp_bbox_copy))
+            return tiles_copy;
+        return null;
+    }
+
+    /** Get the tile index coordinates of the object's previous tile bbox.
+     * Always returns the same temp object, so no object creation is necessary.
+     * @return tile index coordinates, null if no tile bbox */
 //	public JGRectangle getLastTiles() {
 //		//orig: return eng.getTiles(getLastTileBBox());
 //		// XXX object creation in getLastTileBBox
@@ -827,55 +1029,59 @@ public class JGObject {
 //		return null;
 //	}
 
-	/** get center tiles from bbox and store them in tiles_copy */
-	private JGRectangle getCenterTiles(JGRectangle bbox,JGRectangle tiles_copy){
-		// XXX create a getTileIndexX and Y?
-		//JGPoint p =
-		//	eng.getTileIndex(bbox.x+(bbox.width/2),bbox.y+(bbox.height/2) );
-		int px,py;
-		if (bbox.x >= 0) {
-			px=((bbox.x+(bbox.width/2))
-							/ tilewidth)*tilewidth + tilewidth/2;
-			bbox.x = tilewidth * ( (px-(bbox.width /2)) / tilewidth);
-		} else {
-			px=((bbox.x+(bbox.width/2) - tilewidth+1)
-							/ tilewidth)*tilewidth + tilewidth/2;
-			bbox.x = tilewidth * ( (px-(bbox.width /2) - tilewidth+1)
-														/ tilewidth);
-		}
-		if (bbox.y >= 0) {
-			py=((bbox.y+(bbox.height/2))
-							/ tileheight)*tileheight+ tileheight/2;
-			bbox.y = tileheight* ( (py-(bbox.height/2)) / tileheight);
-		} else {
-			py=((bbox.y+(bbox.height/2) - tileheight+1)
-							/ tileheight)*tileheight + tileheight/2;
-			bbox.y = tileheight * ( (py-(bbox.height /2) - tileheight+1)
-														/ tileheight);
-		}
-		eng.getTiles(tiles_copy, bbox);
-		return tiles_copy;
-	}
-
-	/** Get the tile indices spanning the tiles that the object has the
-	* most overlap with.  The size of the span is
-	* always the same as size of the tile bbox in tiles. For example, if the
-	* tile bbox is 48x32 pixels and the tile size is 32x32 pixels, the size
-	* in tiles is always 1.5x1 tiles, which is rounded up to 2x1 tiles.
-	* Always returns the same temp object, so no object creation is necessary.
-	*
-	* @return  tile index coordinates, null if no tile bbox is defined */
-	public JGRectangle getCenterTiles() {
-		if (!getTileBBox(temp_bbox_copy)) return null;
-		/* find the tile on which the center of the bounding box is located,
-		 * that will be the center of our tile span. */
-		return getCenterTiles(temp_bbox_copy,center_tiles_copy);
-	}
-
-	/** Get the tile indices spanning the tiles that the object's last
-	 * bounding box had the most overlap with.
-	* Always returns the same temp object, so no object creation is necessary.
-	*@return tile index coordinates, null if no tile bbox */
+    /**
+     * get center tiles from bbox and store them in tiles_copy
+     */
+    private JGRectangle getCenterTiles(JGRectangle bbox, JGRectangle tiles_copy) {
+        // XXX create a getTileIndexX and Y?
+        //JGPoint p =
+        //	eng.getTileIndex(bbox.x+(bbox.width/2),bbox.y+(bbox.height/2) );
+        int px, py;
+        if (bbox.x >= 0) {
+            px = ((bbox.x + (bbox.width / 2))
+                    / tilewidth) * tilewidth + tilewidth / 2;
+            bbox.x = tilewidth * ((px - (bbox.width / 2)) / tilewidth);
+        } else {
+            px = ((bbox.x + (bbox.width / 2) - tilewidth + 1)
+                    / tilewidth) * tilewidth + tilewidth / 2;
+            bbox.x = tilewidth * ((px - (bbox.width / 2) - tilewidth + 1)
+                    / tilewidth);
+        }
+        if (bbox.y >= 0) {
+            py = ((bbox.y + (bbox.height / 2))
+                    / tileheight) * tileheight + tileheight / 2;
+            bbox.y = tileheight * ((py - (bbox.height / 2)) / tileheight);
+        } else {
+            py = ((bbox.y + (bbox.height / 2) - tileheight + 1)
+                    / tileheight) * tileheight + tileheight / 2;
+            bbox.y = tileheight * ((py - (bbox.height / 2) - tileheight + 1)
+                    / tileheight);
+        }
+        eng.getTiles(tiles_copy, bbox);
+        return tiles_copy;
+    }
+
+    /**
+     * Get the tile indices spanning the tiles that the object has the
+     * most overlap with.  The size of the span is
+     * always the same as size of the tile bbox in tiles. For example, if the
+     * tile bbox is 48x32 pixels and the tile size is 32x32 pixels, the size
+     * in tiles is always 1.5x1 tiles, which is rounded up to 2x1 tiles.
+     * Always returns the same temp object, so no object creation is necessary.
+     *
+     * @return tile index coordinates, null if no tile bbox is defined
+     */
+    public JGRectangle getCenterTiles() {
+        if (!getTileBBox(temp_bbox_copy)) return null;
+        /* find the tile on which the center of the bounding box is located,
+         * that will be the center of our tile span. */
+        return getCenterTiles(temp_bbox_copy, center_tiles_copy);
+    }
+
+    /** Get the tile indices spanning the tiles that the object's last
+     * bounding box had the most overlap with.
+     * Always returns the same temp object, so no object creation is necessary.
+     *@return tile index coordinates, null if no tile bbox */
 //	public JGRectangle getLastCenterTiles() {
 //		// XXX object creation in getLastTileBBox
 //		JGRectangle bbox=getLastTileBBox();
@@ -885,262 +1091,303 @@ public class JGObject {
 //		return getCenterTiles(bbox,last_center_tiles_copy);
 //	}
 
-	/** Get the top left center tile of the object (that is, the x and y of
-	* getCenterTiles()).  If the object is 1x1 tile in size, you get the
-	* center tile.  If the object is larger, you get the top left tile of the
-	* center tiles.
-	* Always returns the same temp object, so no object creation is necessary.
-	* @return tile index coordinate, null if no tile bbox */
-	public JGPoint getCenterTile() {
-		if (!getTileBBox(temp_bbox_copy)) return null;
-		if (center_tile_copy==null) center_tile_copy = new JGPoint();
-		// XXX center_tiles_copy is used also
-		getCenterTiles(temp_bbox_copy,center_tiles_copy);
-		center_tile_copy.x = center_tiles_copy.x;
-		center_tile_copy.y = center_tiles_copy.y;
-		return center_tile_copy;
-	}
-
-	/** Get the topleftmost tile of the object.
-	* Always returns the same temp object, so no object creation is necessary.
-	* @return tile index coordinate, null if no bbox */
-	public JGPoint getTopLeftTile() {
-		// XXX this global is used also
-		JGRectangle r = getTiles();
-		if (r==null) return null;
-		if (tl_tile_copy==null) tl_tile_copy = new JGPoint();
-		tl_tile_copy.x = r.x;
-		tl_tile_copy.y = r.y;
-		return tl_tile_copy;
-	}
-
-	/** Returns true if both isXAligned() and isYAligned() are true.
-	* @see #isXAligned()
-	* @see #isYAligned() */
-	public boolean isAligned() {
-		return isXAligned() && isYAligned();
-	}
-
-	/** Returns true if x is distance xspeed-epsilon away from being grid
-	* aligned. If an object moves at its current xspeed, this method will
-	* always return true when the object crosses the tile alignment line, and
-	* return false when the object is snapped to grid, and then
-	* moves xspeed*gamespeed away from its aligned position. */
-	public boolean isXAligned() {
-		return eng.isXAligned(x,Math.abs(xspeed*gamespeed-0.001));
-	}
-
-	/** Returns true if y is distance yspeed-epsilon away from being grid
-	* aligned. If an object moves at its current yspeed, this method will
-	* always return true when the object crosses the tile alignment line, and
-	* return false when the object is snapped to grid, and then
-	* moves yspeed*gamespeed away from its aligned position. */
-	public boolean isYAligned() {
-		return eng.isYAligned(y,Math.abs(yspeed*gamespeed-0.001));
-	}
-
-	/** Returns true if x is within margin of being tile grid aligned. Epsilon
-	 * is added to the margin, so that isXAligned(1.0000, 1.0000)
-	 * always returns true. */
-	public boolean isXAligned(double margin) {
-		return eng.isXAligned(x,margin);
-	}
-
-	/** Returns true if y is within margin of being tile grid aligned. Epsilon
-	 * is added to the margin, so that isXAligned(1.0000, 1.0000)
-	 * always returns true. */
-	public boolean isYAligned(double margin) {
-		return eng.isYAligned(y,margin);
-	}
-
-	/** Returns true if the left of the object's tile bbox is within margin of
-	* being tile grid aligned. */
-	public boolean isLeftAligned(double margin) {
-		JGRectangle bbox = getTileBBox();
-		if (bbox!=null) {
-			return eng.isXAligned(bbox.x,margin);
-		} else {
-			return eng.isXAligned(x,margin);
-		}
-	}
-
-	/** Returns true if the top of the object's tile bbox is within margin of
-	* being tile grid aligned. */
-	public boolean isTopAligned(double margin) {
-		JGRectangle bbox = getTileBBox();
-		if (bbox!=null) {
-			return eng.isYAligned(bbox.y,margin);
-		} else {
-			return eng.isYAligned(y,margin);
-		}
-	}
-
-	/** Returns true if the right of the object's tile bbox is within margin of
-	* being tile grid aligned. Note that right aligned means that the bbox is
-	* one pixel away from crossing the tile border. */
-	public boolean isRightAligned(double margin) {
-		JGRectangle bbox = getTileBBox();
-		if (bbox!=null) {
-			return eng.isXAligned(bbox.x+bbox.width,margin);
-		} else {
-			return eng.isXAligned(x,margin);
-		}
-	}
-
-	/** Returns true if the bottom of the object's tile bbox is within margin of
-	* being tile grid aligned. Note that right aligned means that the bbox is
-	* one pixel away from crossing the tile border. */
-	public boolean isBottomAligned(double margin) {
-		JGRectangle bbox = getTileBBox();
-		if (bbox!=null) {
-			return eng.isYAligned(bbox.y+bbox.height,margin);
-		} else {
-			return eng.isYAligned(y,margin);
-		}
-	}
-
-	/** Check collision of this object with other objects, when the object
-	 * position would be offset by xofs,yofs.  Returns 0 when object's bbox is
-	 * not defined.
-	 * @param cid  cid mask of objects to consider, 0=any */
-	public int checkCollision(int cid, double xofs, double yofs) {
-		double oldx=x, oldy=y;
-		x += xofs;
-		y += yofs;
-		int retcid =  eng.checkCollision(cid,this);
-		x = oldx;
-		y = oldy;
-		return retcid;
-	}
+    /**
+     * Get the top left center tile of the object (that is, the x and y of
+     * getCenterTiles()).  If the object is 1x1 tile in size, you get the
+     * center tile.  If the object is larger, you get the top left tile of the
+     * center tiles.
+     * Always returns the same temp object, so no object creation is necessary.
+     *
+     * @return tile index coordinate, null if no tile bbox
+     */
+    public JGPoint getCenterTile() {
+        if (!getTileBBox(temp_bbox_copy)) return null;
+        if (center_tile_copy == null) center_tile_copy = new JGPoint();
+        // XXX center_tiles_copy is used also
+        getCenterTiles(temp_bbox_copy, center_tiles_copy);
+        center_tile_copy.x = center_tiles_copy.x;
+        center_tile_copy.y = center_tiles_copy.y;
+        return center_tile_copy;
+    }
+
+    /**
+     * Get the topleftmost tile of the object.
+     * Always returns the same temp object, so no object creation is necessary.
+     *
+     * @return tile index coordinate, null if no bbox
+     */
+    public JGPoint getTopLeftTile() {
+        // XXX this global is used also
+        JGRectangle r = getTiles();
+        if (r == null) return null;
+        if (tl_tile_copy == null) tl_tile_copy = new JGPoint();
+        tl_tile_copy.x = r.x;
+        tl_tile_copy.y = r.y;
+        return tl_tile_copy;
+    }
+
+    /**
+     * Returns true if both isXAligned() and isYAligned() are true.
+     *
+     * @see #isXAligned()
+     * @see #isYAligned()
+     */
+    public boolean isAligned() {
+        return isXAligned() && isYAligned();
+    }
+
+    /**
+     * Returns true if x is distance xspeed-epsilon away from being grid
+     * aligned. If an object moves at its current xspeed, this method will
+     * always return true when the object crosses the tile alignment line, and
+     * return false when the object is snapped to grid, and then
+     * moves xspeed*gamespeed away from its aligned position.
+     */
+    public boolean isXAligned() {
+        return eng.isXAligned(x, Math.abs(xspeed * gamespeed - 0.001));
+    }
+
+    /**
+     * Returns true if y is distance yspeed-epsilon away from being grid
+     * aligned. If an object moves at its current yspeed, this method will
+     * always return true when the object crosses the tile alignment line, and
+     * return false when the object is snapped to grid, and then
+     * moves yspeed*gamespeed away from its aligned position.
+     */
+    public boolean isYAligned() {
+        return eng.isYAligned(y, Math.abs(yspeed * gamespeed - 0.001));
+    }
+
+    /**
+     * Returns true if x is within margin of being tile grid aligned. Epsilon
+     * is added to the margin, so that isXAligned(1.0000, 1.0000)
+     * always returns true.
+     */
+    public boolean isXAligned(double margin) {
+        return eng.isXAligned(x, margin);
+    }
+
+    /**
+     * Returns true if y is within margin of being tile grid aligned. Epsilon
+     * is added to the margin, so that isXAligned(1.0000, 1.0000)
+     * always returns true.
+     */
+    public boolean isYAligned(double margin) {
+        return eng.isYAligned(y, margin);
+    }
+
+    /**
+     * Returns true if the left of the object's tile bbox is within margin of
+     * being tile grid aligned.
+     */
+    public boolean isLeftAligned(double margin) {
+        JGRectangle bbox = getTileBBox();
+        if (bbox != null) {
+            return eng.isXAligned(bbox.x, margin);
+        } else {
+            return eng.isXAligned(x, margin);
+        }
+    }
+
+    /**
+     * Returns true if the top of the object's tile bbox is within margin of
+     * being tile grid aligned.
+     */
+    public boolean isTopAligned(double margin) {
+        JGRectangle bbox = getTileBBox();
+        if (bbox != null) {
+            return eng.isYAligned(bbox.y, margin);
+        } else {
+            return eng.isYAligned(y, margin);
+        }
+    }
+
+    /**
+     * Returns true if the right of the object's tile bbox is within margin of
+     * being tile grid aligned. Note that right aligned means that the bbox is
+     * one pixel away from crossing the tile border.
+     */
+    public boolean isRightAligned(double margin) {
+        JGRectangle bbox = getTileBBox();
+        if (bbox != null) {
+            return eng.isXAligned(bbox.x + bbox.width, margin);
+        } else {
+            return eng.isXAligned(x, margin);
+        }
+    }
+
+    /**
+     * Returns true if the bottom of the object's tile bbox is within margin of
+     * being tile grid aligned. Note that right aligned means that the bbox is
+     * one pixel away from crossing the tile border.
+     */
+    public boolean isBottomAligned(double margin) {
+        JGRectangle bbox = getTileBBox();
+        if (bbox != null) {
+            return eng.isYAligned(bbox.y + bbox.height, margin);
+        } else {
+            return eng.isYAligned(y, margin);
+        }
+    }
+
+    /**
+     * Check collision of this object with other objects, when the object
+     * position would be offset by xofs,yofs.  Returns 0 when object's bbox is
+     * not defined.
+     *
+     * @param cid cid mask of objects to consider, 0=any
+     */
+    public int checkCollision(int cid, double xofs, double yofs) {
+        double oldx = x, oldy = y;
+        x += xofs;
+        y += yofs;
+        int retcid = eng.checkCollision(cid, this);
+        x = oldx;
+        y = oldy;
+        return retcid;
+    }
 
 	/* something odd going on here: it fails to find the checkBGCollision in
 	 * Engine when I define this one in Object
 	public int checkBGCollision() {
 		return eng.checkBGCollision(getTileBBox());
 	}*/
-	
-	/** Check collision of tiles within given rectangle, return the OR of all
-	* cids found.  This method just calls eng.checkBGCollision; it's here
-	* because JGEngine.checkBGCollision(JGRectangle) is masked when the object
-	* is an inner class of JGEngine.
-	*/
-	public int checkBGCollision(JGRectangle r) {
-		return eng.checkBGCollision(r);
-	}
-
-
-	/** Get OR of Tile Cids of the object's current tile bbox at the current
-	* position, when offset by the given offset. Returns 0 if tile bbox is not
-	* defined. */
-	public int checkBGCollision(double xofs,double yofs) {
-		double oldx=x, oldy=y;
-		x += xofs;
-		y += yofs;
-		JGRectangle bbox = getTileBBox();
-		x = oldx;
-		y = oldy;
-		if (bbox==null) return 0;
-		return checkBGCollision(bbox);
-	}
-
-	/** Margin is the margin beyond which the object is considered offscreen.
-	* The tile bounding box is used as the object's size, if there is none, we
-	* use a zero-size bounding box.  isOnScreen is equal to isOnPF, but is
-	* deprecated because the name is ambiguous.
-	* @deprecated Use isOnPF and isInView according to your situation.
-	* @param marginx pixel margin, may be negative
-	* @param marginy pixel margin, may be negative
-	*/
-	public boolean isOnScreen(int marginx,int marginy) {
-		return isOnPF(marginx,marginy);
-	}
-
-	/** Margin is the margin beyond which the object is considered off-view.
-	* The tile bounding box is used as the object's size, if there is none, we
-	* use a zero-size bounding box.
-	* @param marginx pixel margin, may be negative
-	* @param marginy pixel margin, may be negative
-	*/
-	public boolean isInView(int marginx,int marginy) {
-		if (!getTileBBox(temp_bbox_copy)) {
-			temp_bbox_copy.x = (int)x;
-			temp_bbox_copy.y = (int)y;
-			temp_bbox_copy.width = 0;
-			temp_bbox_copy.height = 0;
-		}
-		if (temp_bbox_copy.x + temp_bbox_copy.width  < viewxofs-marginx)
-			return false;
-		if (temp_bbox_copy.y + temp_bbox_copy.height < viewyofs-marginy)
-			return false;
-		if (temp_bbox_copy.x > viewxofs+viewwidth + marginx)
-			return false;
-		if (temp_bbox_copy.y > viewyofs+viewheight + marginy)
-			return false;
-		return true;
-	}
-
-	/** Margin is the margin beyond which the object is considered off the
-	* playfield.
-	* The tile bounding box is used as the object's size, if there is none, we
-	* use a zero-size bounding box.
-	* @param marginx pixel margin, may be negative
-	* @param marginy pixel margin, may be negative
-	*/
-	public boolean isOnPF(int marginx,int marginy) {
-		if (!getTileBBox(temp_bbox_copy)) {
-			temp_bbox_copy.x = (int)x;
-			temp_bbox_copy.y = (int)y;
-			temp_bbox_copy.width = 0;
-			temp_bbox_copy.height = 0;
-		}
-		if (!pfwrapx) {
-			if (temp_bbox_copy.x+temp_bbox_copy.width  < -marginx) return false;
-			if (temp_bbox_copy.x >pfwidth + marginx) return false;
-		}
-		if (!pfwrapy) {
-			if (temp_bbox_copy.y+temp_bbox_copy.height < -marginy) return false;
-			if (temp_bbox_copy.y > pfheight + marginy) return false;
-		}
-		return true;
-	}
-
-	/* computation */
-
-	/** A Boolean AND shorthand to use for collision;
-	* returns (value&amp;mask) != 0. */
-	public static boolean and(int value, int mask) {
-		return (value&mask) != 0;
-	}
-
-	public double random(double min, double max) {
-		return eng.random(min,max);
-	}
-
-	public double random(double min, double max, double interval) {
-		return eng.random(min,max,interval);
-	}
-
-	public int random(int min, int max, int interval) {
-		return eng.random(min,max,interval);
-	}
-
-
-
-	/** Do automatic animation.  Is automatically called by the JGEngine
-	 * implementation once for every
-	 * moveObjects; normally it is not necessary to call this.  */
-	public void updateAnimation(double gamespeed) {
-		if (anim!=null) {// && eng.canvas.anim_running) {
-			imgname = anim.animate(gamespeed);
-			imgbbox=null;
-		}
-	}
-	/** Signal that a new frame has just been updated; make
-	* snapshot of object state.  Should only be called by the JGEngine
-	* implementation. */
-	public void frameFinished() {
-		lastx=x;
-		lasty=y;
+
+    /**
+     * Check collision of tiles within given rectangle, return the OR of all
+     * cids found.  This method just calls eng.checkBGCollision; it's here
+     * because JGEngine.checkBGCollision(JGRectangle) is masked when the object
+     * is an inner class of JGEngine.
+     */
+    public int checkBGCollision(JGRectangle r) {
+        return eng.checkBGCollision(r);
+    }
+
+
+    /**
+     * Get OR of Tile Cids of the object's current tile bbox at the current
+     * position, when offset by the given offset. Returns 0 if tile bbox is not
+     * defined.
+     */
+    public int checkBGCollision(double xofs, double yofs) {
+        double oldx = x, oldy = y;
+        x += xofs;
+        y += yofs;
+        JGRectangle bbox = getTileBBox();
+        x = oldx;
+        y = oldy;
+        if (bbox == null) return 0;
+        return checkBGCollision(bbox);
+    }
+
+    /**
+     * Margin is the margin beyond which the object is considered offscreen.
+     * The tile bounding box is used as the object's size, if there is none, we
+     * use a zero-size bounding box.  isOnScreen is equal to isOnPF, but is
+     * deprecated because the name is ambiguous.
+     *
+     * @param marginx pixel margin, may be negative
+     * @param marginy pixel margin, may be negative
+     * @deprecated Use isOnPF and isInView according to your situation.
+     */
+    public boolean isOnScreen(int marginx, int marginy) {
+        return isOnPF(marginx, marginy);
+    }
+
+    /**
+     * Margin is the margin beyond which the object is considered off-view.
+     * The tile bounding box is used as the object's size, if there is none, we
+     * use a zero-size bounding box.
+     *
+     * @param marginx pixel margin, may be negative
+     * @param marginy pixel margin, may be negative
+     */
+    public boolean isInView(int marginx, int marginy) {
+        if (!getTileBBox(temp_bbox_copy)) {
+            temp_bbox_copy.x = (int) x;
+            temp_bbox_copy.y = (int) y;
+            temp_bbox_copy.width = 0;
+            temp_bbox_copy.height = 0;
+        }
+        if (temp_bbox_copy.x + temp_bbox_copy.width < viewxofs - marginx)
+            return false;
+        if (temp_bbox_copy.y + temp_bbox_copy.height < viewyofs - marginy)
+            return false;
+        if (temp_bbox_copy.x > viewxofs + viewwidth + marginx)
+            return false;
+        return temp_bbox_copy.y <= viewyofs + viewheight + marginy;
+    }
+
+    /**
+     * Margin is the margin beyond which the object is considered off the
+     * playfield.
+     * The tile bounding box is used as the object's size, if there is none, we
+     * use a zero-size bounding box.
+     *
+     * @param marginx pixel margin, may be negative
+     * @param marginy pixel margin, may be negative
+     */
+    public boolean isOnPF(int marginx, int marginy) {
+        if (!getTileBBox(temp_bbox_copy)) {
+            temp_bbox_copy.x = (int) x;
+            temp_bbox_copy.y = (int) y;
+            temp_bbox_copy.width = 0;
+            temp_bbox_copy.height = 0;
+        }
+        if (!pfwrapx) {
+            if (temp_bbox_copy.x + temp_bbox_copy.width < -marginx) return false;
+            if (temp_bbox_copy.x > pfwidth + marginx) return false;
+        }
+        if (!pfwrapy) {
+            if (temp_bbox_copy.y + temp_bbox_copy.height < -marginy) return false;
+            return temp_bbox_copy.y <= pfheight + marginy;
+        }
+        return true;
+    }
+
+    /* computation */
+
+    /**
+     * A Boolean AND shorthand to use for collision;
+     * returns (value&amp;mask) != 0.
+     */
+    public static boolean and(int value, int mask) {
+        return (value & mask) != 0;
+    }
+
+    public double random(double min, double max) {
+        return eng.random(min, max);
+    }
+
+    public double random(double min, double max, double interval) {
+        return eng.random(min, max, interval);
+    }
+
+    public int random(int min, int max, int interval) {
+        return eng.random(min, max, interval);
+    }
+
+
+    /**
+     * Do automatic animation.  Is automatically called by the JGEngine
+     * implementation once for every
+     * moveObjects; normally it is not necessary to call this.
+     */
+    public void updateAnimation(double gamespeed) {
+        if (anim != null) {// && eng.canvas.anim_running) {
+            imgname = anim.animate(gamespeed);
+            imgbbox = null;
+        }
+    }
+
+    /**
+     * Signal that a new frame has just been updated; make
+     * snapshot of object state.  Should only be called by the JGEngine
+     * implementation.
+     */
+    public void frameFinished() {
+        lastx = x;
+        lasty = y;
 //		if (getBBox(lastbbox_copy)) {
 //			lastbbox = lastbbox_copy;
 //		} else {
@@ -1151,86 +1398,128 @@ public class JGObject {
 //		} else {
 //			lasttilebbox=null;
 //		}
-	}
-
-	/** Modulo x/y position according to wrap settings. Is automatically 
-	* performed by the JGEngine implementation
-	* after each moveObjects.  Normally it is not necessary to call this, but
-	* it may be in special cases.  */
-	public void moduloPos() {
-		// note: there is an inlined version of this code in EngineLogic
-		if (pfwrapx) x = eng.moduloXPos(x);
-		if (pfwrapy) y = eng.moduloYPos(y);
-	}
-
-	/** Suspend object until either resume is called or, if
-	 * resume_in_view is true, when it comes into view.  A suspended object
-	 * does not participate in any move, hit, or paint. */
-	public void suspend() { is_suspended=true; }
-	/** Resume from suspended state, if suspended. */
-	public void resume() { is_suspended=false; }
-
-	/** Check if object is suspended. */
-	public boolean isSuspended() { return is_suspended; }
-
-	/** Set resume condition.
-	* @param resume_in_view resume when in view */
-	public void setResumeMode(boolean resume_in_view) {
-		this.resume_in_view=resume_in_view;
-	}
-
-	/** Check if object is still active, or has already been removed.  Also
-	 * returns false if the object is still pending to be removed.  */
-	public boolean isAlive() { return is_alive; }
-
-	/** Signal to object that remove is done, don't call directly.  This is
-	 * used by the engine to signal that the object should be finalised. */
-	public final void removeDone() {
-		destroy();
-		is_alive=false; 
-	}
-
-	/** Mark object for removal, ignore if already removed. 
-	* The object will be removed at the end of this
-	* moveObjects, checkCollision, or checkBGCollision action, or immediately
-	* if not inside either of these actions. 
-	*/
-	public void remove() {
-		if (isAlive()) eng.removeObject(this); 
-		is_alive=false; 
-	}
-
-	/** Override to implement object disposal code.  This method is called at
-	 * the actual moment of removal. */
-	public void destroy() {}
-
-	/** Override to implement automatic move; default is do nothing.
-	*/
-	public void move() {}
-
-	/** Override to handle collision; default is do nothing.
-	*/
-	public void hit(JGObject obj) {}
-
-	/** Override to handle tile collision; default is do nothing.
-	*/
-	public void hit_bg(int tilecid) {}
-	
-	/** Override to handle tile collision; default is do nothing.
-	* This method is always called when hit_bg(int) is also called, only, extra
-	* information is passed that may be useful.
-	*/
-	public void hit_bg(int tilecid,int tx,int ty, int txsize,int tysize) {}
-
-	/** Override to handle tile collision; default is do nothing.
-	* This method is always called when hit_bg(int) is also called, only it may
-	* be called multiple times, namely once for each tile the object collides
-	* with.  The arguments pass the tile cid and position of that tile.  It is
-	* always called after hit_bg(int) and hit_bg(int,int,int,int,int) have
-	* been called. */
-	public void hit_bg(int tilecid,int tx,int ty) {}
-
-	/** Override to define custom paint actions. */
-	public void paint() {}
+    }
+
+    /**
+     * Modulo x/y position according to wrap settings. Is automatically
+     * performed by the JGEngine implementation
+     * after each moveObjects.  Normally it is not necessary to call this, but
+     * it may be in special cases.
+     */
+    public void moduloPos() {
+        // note: there is an inlined version of this code in EngineLogic
+        if (pfwrapx) x = eng.moduloXPos(x);
+        if (pfwrapy) y = eng.moduloYPos(y);
+    }
+
+    /**
+     * Suspend object until either resume is called or, if
+     * resume_in_view is true, when it comes into view.  A suspended object
+     * does not participate in any move, hit, or paint.
+     */
+    public void suspend() {
+        is_suspended = true;
+    }
+
+    /**
+     * Resume from suspended state, if suspended.
+     */
+    public void resume() {
+        is_suspended = false;
+    }
+
+    /**
+     * Check if object is suspended.
+     */
+    public boolean isSuspended() {
+        return is_suspended;
+    }
+
+    /**
+     * Set resume condition.
+     *
+     * @param resume_in_view resume when in view
+     */
+    public void setResumeMode(boolean resume_in_view) {
+        this.resume_in_view = resume_in_view;
+    }
+
+    /**
+     * Check if object is still active, or has already been removed.  Also
+     * returns false if the object is still pending to be removed.
+     */
+    public boolean isAlive() {
+        return is_alive;
+    }
+
+    /**
+     * Signal to object that remove is done, don't call directly.  This is
+     * used by the engine to signal that the object should be finalised.
+     */
+    public final void removeDone() {
+        destroy();
+        is_alive = false;
+    }
+
+    /**
+     * Mark object for removal, ignore if already removed.
+     * The object will be removed at the end of this
+     * moveObjects, checkCollision, or checkBGCollision action, or immediately
+     * if not inside either of these actions.
+     */
+    public void remove() {
+        if (isAlive()) eng.removeObject(this);
+        is_alive = false;
+    }
+
+    /**
+     * Override to implement object disposal code.  This method is called at
+     * the actual moment of removal.
+     */
+    public void destroy() {
+    }
+
+    /**
+     * Override to implement automatic move; default is do nothing.
+     */
+    public void move() {
+    }
+
+    /**
+     * Override to handle collision; default is do nothing.
+     */
+    public void hit(JGObject obj) {
+    }
+
+    /**
+     * Override to handle tile collision; default is do nothing.
+     */
+    public void hit_bg(int tilecid) {
+    }
+
+    /**
+     * Override to handle tile collision; default is do nothing.
+     * This method is always called when hit_bg(int) is also called, only, extra
+     * information is passed that may be useful.
+     */
+    public void hit_bg(int tilecid, int tx, int ty, int txsize, int tysize) {
+    }
+
+    /**
+     * Override to handle tile collision; default is do nothing.
+     * This method is always called when hit_bg(int) is also called, only it may
+     * be called multiple times, namely once for each tile the object collides
+     * with.  The arguments pass the tile cid and position of that tile.  It is
+     * always called after hit_bg(int) and hit_bg(int,int,int,int,int) have
+     * been called.
+     */
+    public void hit_bg(int tilecid, int tx, int ty) {
+    }
+
+    /**
+     * Override to define custom paint actions.
+     */
+    public void paint() {
+    }
 }
 
diff --git a/app/src/main/java/jgame/JGPoint.java b/app/src/main/java/jgame/JGPoint.java
index 5e311f1..2f181e9 100644
--- a/app/src/main/java/jgame/JGPoint.java
+++ b/app/src/main/java/jgame/JGPoint.java
@@ -1,22 +1,26 @@
 package jgame;
 
-/** Minimal replacement of java.awt.Point. */
+/**
+ * Minimal replacement of java.awt.Point.
+ */
 public class JGPoint {
 
-	public int x=0,y=0;
+    public int x = 0, y = 0;
 
-	public JGPoint () {}
+    public JGPoint() {
+    }
 
-	public JGPoint (JGPoint p) {
-		x = p.x;
-		y = p.y;
-	}
+    public JGPoint(JGPoint p) {
+        x = p.x;
+        y = p.y;
+    }
 
-	public JGPoint (int x,int y) {
-		this.x=x;
-		this.y=y;
-	}
-	public String toString() {
-		return "JGPoint("+x+","+y+")";
-	}
+    public JGPoint(int x, int y) {
+        this.x = x;
+        this.y = y;
+    }
+
+    public String toString() {
+        return "JGPoint(" + x + "," + y + ")";
+    }
 }
diff --git a/app/src/main/java/jgame/JGRectangle.java b/app/src/main/java/jgame/JGRectangle.java
index ab3c380..c0dae93 100644
--- a/app/src/main/java/jgame/JGRectangle.java
+++ b/app/src/main/java/jgame/JGRectangle.java
@@ -1,41 +1,47 @@
 package jgame;
 
-/** Minimal replacement of java.awt.Rectangle. */
+/**
+ * Minimal replacement of java.awt.Rectangle.
+ */
 public class JGRectangle {
 
-	public int x=0,y=0,width=0,height=0;
-
-	public JGRectangle () {}
-
-	public JGRectangle (int x,int y,int width,int height) {
-		this.x=x;
-		this.y=y;
-		this.width=width;
-		this.height=height;
-	}
-
-	public JGRectangle(JGRectangle rec) {
-		this.x = rec.x;
-		this.y = rec.y;
-		this.width = rec.width;
-		this.height= rec.height;
-	}
-
-	/** Copy contents of source rectangle into this rectangle. */
-	public void copyFrom(JGRectangle src) {
-		x=src.x;
-		y=src.y;
-		width=src.width;
-		height=src.height;
-	}
-
-	public boolean intersects(JGRectangle rec) {
-		return    rec.x            < x+width
-		       && rec.x+rec.width  > x
-		       && rec.y            < y+height
-		       && rec.y+rec.height > y;
-	}
-	public String toString() {
-		return "JGRectangle("+x+","+y+","+width+","+height+")";
-	}
+    public int x = 0, y = 0, width = 0, height = 0;
+
+    public JGRectangle() {
+    }
+
+    public JGRectangle(int x, int y, int width, int height) {
+        this.x = x;
+        this.y = y;
+        this.width = width;
+        this.height = height;
+    }
+
+    public JGRectangle(JGRectangle rec) {
+        this.x = rec.x;
+        this.y = rec.y;
+        this.width = rec.width;
+        this.height = rec.height;
+    }
+
+    /**
+     * Copy contents of source rectangle into this rectangle.
+     */
+    public void copyFrom(JGRectangle src) {
+        x = src.x;
+        y = src.y;
+        width = src.width;
+        height = src.height;
+    }
+
+    public boolean intersects(JGRectangle rec) {
+        return rec.x < x + width
+                && rec.x + rec.width > x
+                && rec.y < y + height
+                && rec.y + rec.height > y;
+    }
+
+    public String toString() {
+        return "JGRectangle(" + x + "," + y + "," + width + "," + height + ")";
+    }
 }
diff --git a/app/src/main/java/jgame/JGTimer.java b/app/src/main/java/jgame/JGTimer.java
index bf34d23..4ff2bf9 100644
--- a/app/src/main/java/jgame/JGTimer.java
+++ b/app/src/main/java/jgame/JGTimer.java
@@ -1,90 +1,102 @@
 package jgame;
+
 import jgame.impl.JGEngineInterface;
 
-/** A timer that generates a callback after a certain number of frames.  It
+/**
+ * A timer that generates a callback after a certain number of frames.  It
  * can conveniently be used as a "one liner class", i.e. as an inner class
  * within a context where it can set a variable or call a method. i.e.
- *<code> new JGTimer (10,true) { alarm() { doSomething(); } };</code>
-
+ * <code> new JGTimer (10,true) { alarm() { doSomething(); } };</code>
+ *
  * <P>Timers are updated just before the beginning of a frame.  Any objects
  * they add or delete are immediately updated before the frame starts.
-
-* <p>Timers can be made dependent on certain game states or objects.  If the
-* particular game state is exited or the object is removed at the beginning of
-* the frame, the timer removes itself without invoking the alarm.
-*/
+ *
+ * <p>Timers can be made dependent on certain game states or objects.  If the
+ * particular game state is exited or the object is removed at the beginning of
+ * the frame, the timer removes itself without invoking the alarm.
+ */
 public abstract class JGTimer {
-	int frames=0;
-	double frames_left=0;
-	public boolean running=true;
-	public boolean one_shot;
-	public JGObject parent_obj=null;
-	public String parent_state=null;
-	JGEngineInterface eng;
+    int frames = 0;
+    double frames_left = 0;
+    public boolean running = true;
+    public boolean one_shot;
+    public JGObject parent_obj = null;
+    public String parent_state = null;
+    JGEngineInterface eng;
 
-	/** Create timer; the timer may be one-shot (it runs only once, then
-	 * triggers the alarm and removes itself), or continuous (it continues
-	 * running and triggering the alarm)
-	* @param frames_to_alarm  0 = callback just before next frame.
-	* @param one_shot  true = run only once, false = run repeatedly
-	*/
-	public JGTimer(int frames_to_alarm, boolean one_shot) {
-		set(frames_to_alarm,one_shot);
-		eng = JGObject.default_engine;
-		eng.registerTimer(this);
-	}
+    /**
+     * Create timer; the timer may be one-shot (it runs only once, then
+     * triggers the alarm and removes itself), or continuous (it continues
+     * running and triggering the alarm)
+     *
+     * @param frames_to_alarm 0 = callback just before next frame.
+     * @param one_shot        true = run only once, false = run repeatedly
+     */
+    public JGTimer(int frames_to_alarm, boolean one_shot) {
+        set(frames_to_alarm, one_shot);
+        eng = JGObject.default_engine;
+        eng.registerTimer(this);
+    }
 
-	/** Create timer which has an object as parent.
-	* @param frames_to_alarm  0 = callback just before next frame.
-	* @param one_shot  true = run only once, false = run repeatedly
-	*/
-	public JGTimer(int frames_to_alarm, boolean one_shot, JGObject parent) {
-		set(frames_to_alarm,one_shot);
-		eng = JGObject.default_engine;
-		eng.registerTimer(this);
-		parent_obj = parent;
-	}
+    /**
+     * Create timer which has an object as parent.
+     *
+     * @param frames_to_alarm 0 = callback just before next frame.
+     * @param one_shot        true = run only once, false = run repeatedly
+     */
+    public JGTimer(int frames_to_alarm, boolean one_shot, JGObject parent) {
+        set(frames_to_alarm, one_shot);
+        eng = JGObject.default_engine;
+        eng.registerTimer(this);
+        parent_obj = parent;
+    }
 
-	/** Create timer which has a specific gamestate as parent.
-	* @param frames_to_alarm  0 = callback just before next frame.
-	* @param one_shot  true = run only once, false = run repeatedly
-	*/
-	public JGTimer(int frames_to_alarm, boolean one_shot, String parent) {
-		set(frames_to_alarm,one_shot);
-		eng = JGObject.default_engine;
-		eng.registerTimer(this);
-		parent_state = parent;
-	}
+    /**
+     * Create timer which has a specific gamestate as parent.
+     *
+     * @param frames_to_alarm 0 = callback just before next frame.
+     * @param one_shot        true = run only once, false = run repeatedly
+     */
+    public JGTimer(int frames_to_alarm, boolean one_shot, String parent) {
+        set(frames_to_alarm, one_shot);
+        eng = JGObject.default_engine;
+        eng.registerTimer(this);
+        parent_state = parent;
+    }
 
-	public void set(int frames_to_alarm, boolean one_shot) {
-		frames=frames_to_alarm;
-		frames_left=frames;
-		this.one_shot = one_shot;
-	}
+    public void set(int frames_to_alarm, boolean one_shot) {
+        frames = frames_to_alarm;
+        frames_left = frames;
+        this.one_shot = one_shot;
+    }
 
-	/** Tick function, as called by the engine implementation.
-	* Returns true when the timer has to be removed. */
-	public boolean tick(double speed) {
-		// XXX note that we use inGameStateNextFrame here, because this is an
-		// indication of whether the timer should exist for the upcoming
-		// frame.  However, another timer in the timer set may change the
-		// state, so there's actually a race condition here.
-		if (parent_state!=null
-		&& !eng.inGameStateNextFrame(parent_state)) return true;
-		if (parent_obj!=null && !parent_obj.isAlive()) return true;
-		if (running) {
-			if (frames_left <= 0) {
-				frames_left=frames;
-				alarm();
-				if (one_shot) return true;
-			} else {
-				frames_left -= speed;
-			}
-		}
-		return false;
-	}
+    /**
+     * Tick function, as called by the engine implementation.
+     * Returns true when the timer has to be removed.
+     */
+    public boolean tick(double speed) {
+        // XXX note that we use inGameStateNextFrame here, because this is an
+        // indication of whether the timer should exist for the upcoming
+        // frame.  However, another timer in the timer set may change the
+        // state, so there's actually a race condition here.
+        if (parent_state != null
+                && !eng.inGameStateNextFrame(parent_state)) return true;
+        if (parent_obj != null && !parent_obj.isAlive()) return true;
+        if (running) {
+            if (frames_left <= 0) {
+                frames_left = frames;
+                alarm();
+                return one_shot;
+            } else {
+                frames_left -= speed;
+            }
+        }
+        return false;
+    }
 
-	/** define your alarm action here. */
-	abstract public void alarm();
+    /**
+     * define your alarm action here.
+     */
+    abstract public void alarm();
 }
 
diff --git a/app/src/main/java/jgame/impl/Animation.java b/app/src/main/java/jgame/impl/Animation.java
index c23e9af..8cd772e 100644
--- a/app/src/main/java/jgame/impl/Animation.java
+++ b/app/src/main/java/jgame/impl/Animation.java
@@ -1,83 +1,98 @@
 package jgame.impl;
 
 public class Animation {
-	/* settings;  the public ones may be manipulated freely */
-	String [] frames;
-	public double speed;
-	public int increment=1;
-	public boolean pingpong=false;
-	/* state */
-	int framenr=0;
-	double phase=0.0;
-	boolean running=true;
-	public Animation (String [] frames, double speed) {
-		this.frames=frames;
-		this.speed=speed;
-	}
-	public Animation (String [] frames, double speed, boolean pingpong) {
-		this.frames=frames;
-		this.speed=speed;
-		this.pingpong=pingpong;
-	}
-	public Animation (String [] frames, double speed, boolean pingpong,
-	int increment) {
-		this.frames=frames;
-		this.speed=speed;
-		this.pingpong=pingpong;
-		this.increment=increment;
-	}
-	public void stop() { running=false; }
-	public void start() { running=true; }
-	public void reset() {
-		framenr=0;
-		phase=0.0;
-	}
-	//public Object clone() {
-	//	try {
-	//		return super.clone();
-	//	} catch (CloneNotSupportedException e) { return null; }
-	//}
-	public Animation copy() {
-		Animation cp = new Animation(frames,speed,pingpong);
-		cp.framenr = framenr;
-		cp.phase = phase;
-		cp.running = running;
-		return cp;
-		//return (Animation) clone();
-	}
-	public String getCurrentFrame() {
-		if (framenr < 0 || framenr >= frames.length) {
-			return frames[0];
-		} else {
-			return frames[framenr];
-		}
-	}
-	/** Does one animation step and returns current image.  Note that the
-	 * function returns the frame before the state is being updated. */
-	public String animate(double speedmul) {
-		String ret = getCurrentFrame();
-		if (running) {
-			phase += speed*speedmul;
-			while (phase >= 1.0) {
-				phase -= 1.0;
-				framenr += increment;
-				if (!pingpong) {
-					if (framenr >= frames.length) framenr -= frames.length;
-					if (framenr < 0)              framenr += frames.length;
-				} else {
-					if (framenr >= frames.length) {
-						framenr -= 2*increment;
-						increment = -increment;
-					}
-					if (framenr < 0) {
-						framenr -= 2*increment;
-						increment = -increment;
-					}
-				}
-			}
-		}
-		return ret;
-	}
+    /* settings;  the public ones may be manipulated freely */
+    String[] frames;
+    public double speed;
+    public int increment = 1;
+    public boolean pingpong = false;
+    /* state */
+    int framenr = 0;
+    double phase = 0.0;
+    boolean running = true;
+
+    public Animation(String[] frames, double speed) {
+        this.frames = frames;
+        this.speed = speed;
+    }
+
+    public Animation(String[] frames, double speed, boolean pingpong) {
+        this.frames = frames;
+        this.speed = speed;
+        this.pingpong = pingpong;
+    }
+
+    public Animation(String[] frames, double speed, boolean pingpong,
+                     int increment) {
+        this.frames = frames;
+        this.speed = speed;
+        this.pingpong = pingpong;
+        this.increment = increment;
+    }
+
+    public void stop() {
+        running = false;
+    }
+
+    public void start() {
+        running = true;
+    }
+
+    public void reset() {
+        framenr = 0;
+        phase = 0.0;
+    }
+
+    //public Object clone() {
+    //	try {
+    //		return super.clone();
+    //	} catch (CloneNotSupportedException e) { return null; }
+    //}
+    public Animation copy() {
+        Animation cp = new Animation(frames, speed, pingpong);
+        cp.framenr = framenr;
+        cp.phase = phase;
+        cp.running = running;
+        return cp;
+        //return (Animation) clone();
+    }
+
+    public String getCurrentFrame() {
+        if (framenr < 0 || framenr >= frames.length) {
+            return frames[0];
+        } else {
+            return frames[framenr];
+        }
+    }
+
+    /**
+     * Does one animation step and returns current image.  Note that the
+     * function returns the frame before the state is being updated.
+     */
+    public String animate(double speedmul) {
+        String ret = getCurrentFrame();
+        if (running) {
+            phase += speed * speedmul;
+            while (phase >= 1.0) {
+                phase -= 1.0;
+                framenr += increment;
+                if (!pingpong) {
+                    if (framenr >= frames.length) framenr -= frames.length;
+                    if (framenr < 0) framenr += frames.length;
+                } else {
+                    if (framenr >= frames.length) {
+                        framenr -= 2 * increment;
+                        increment = -increment;
+                    }
+                    if (framenr < 0) {
+                        framenr -= 2 * increment;
+                        increment = -increment;
+                    }
+                }
+            }
+        }
+        return ret;
+    }
 }
 
 
diff --git a/app/src/main/java/jgame/impl/EngineLogic.java b/app/src/main/java/jgame/impl/EngineLogic.java
index 9cc9a05..9dabd1f 100644
--- a/app/src/main/java/jgame/impl/EngineLogic.java
+++ b/app/src/main/java/jgame/impl/EngineLogic.java
@@ -1,1196 +1,1336 @@
 package jgame.impl;
-import jgame.*;
-import java.util.Vector;
-import java.util.Hashtable;
-import java.util.Enumeration;
-import java.util.Random;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Random;
+import java.util.Vector;
 
-/** Contains the platform-independent game logic. */
+import jgame.JGColor;
+import jgame.JGFont;
+import jgame.JGImage;
+import jgame.JGObject;
+import jgame.JGPoint;
+import jgame.JGRectangle;
+import jgame.JGTimer;
+
+/**
+ * Contains the platform-independent game logic.
+ */
 public class EngineLogic {
 
-	public JGImage imageutil;
-
-	Random random;
-
-	/** Platform implementation decides if window is resizeable.  Resizeable
-	* requires the implementation to keep the original unscaled images in
-	* memory.  Turn it off if you are short on memory. */
-	public boolean is_resizeable=true;
-
-	/** make_bitmask indicates what to do with transparent images.
-	* true = make bitmask false=make translucent */
-	boolean make_bitmask;
-
-	/** prescale indicates if: (1) images should be prescaled to screen
-	* resolution or kept at their original size; (2) tiles should be drawn
-	* prescaled. It affects:
-	* scaled_tile*: scaled tile size, or original size
-	* width/height: rounded to whole tile sizes or actual window size
-	* *ofs_scaled: either scaled, or same as *ofs.
-	* Indirectly affected: *_scale_fac canvas_*ofs */
-	boolean prescale;
-
-	public EngineLogic (JGImage imageutil,
-	boolean make_bitmask,boolean prescale) {
-		this.imageutil=imageutil;
-		this.make_bitmask=make_bitmask;
-		this.prescale=prescale;
-		random = new Random();
-		bg_images.addElement(null);
-	}
-
-
-	/** indicates if setCanvasSettings was called. */
-	public boolean view_initialised=false;
-
-	public JGColor fg_color = JGColor.white;
-	public JGColor bg_color = JGColor.black;
-	public JGFont msg_font=null;
-
-	public int outline_thickness=0;
-	public JGColor outline_colour=JGColor.black;
-
-
-	public double fps = 35;
-	public double maxframeskip = 4.0; /* max # of frames to skip  */
-
-	public double gamespeed=1.00000000001;
-
-	/* game state. These vectors are always reused and not reconstructed. */
-
-	/** Engine game state */
-	public Vector gamestate=new Vector(10,20);
-	/** New engine game state to be assigned at the next frame */
-	public Vector gamestate_nextframe=new Vector(10,20);
-	/** New game states which the game has to transition to, and for which
-	 * start[state] have to be called. */
-	public Vector gamestate_new=new Vector(10,20);
-	/** indicates when engine is inside a parallel object update (moveObjects,
-	 * check*Collision) */
-
-
-	boolean in_parallel_upd=false;
-
-
-	private Vector timers = new Vector(20,40);
-
-
-	/** signals that JGame globals are set, and exit code should null globals in
-	* JGObject */
-	public boolean is_inited=false;
-	/** signals that thread should die and canvas should paint exit message */
-	public boolean is_exited=false;
-	public String exit_message="JGEngine exited successfully";
-
-
-	Hashtable animations = new Hashtable();
-
-
-	/* images */
-
-	/** Strings -&gt; JGImages, original size,
-	* nonexistence means there is no image */
-	public Hashtable images_orig = new Hashtable();
-	/** JGPoint sizes of original images */
-	public Hashtable image_orig_size = new Hashtable();
-	/** Strings -&gt; JGImages, screen size, nonexistence indicates image
-	* is not cached and needs to be generated from images_orig */
-	public Hashtable images = new Hashtable();
-
-	/** indicates that image is defined even if it has no Image */
-	public Hashtable images_exists= new Hashtable(); 
-	public Hashtable images_transp = new Hashtable(); 
-	/** Hashtable: name to filename. Indicates that image with given name
-	* is loaded from given filename */
-	public Hashtable images_loaded= new Hashtable(); 
-		/* Integers -> Objects, existence indicates transparency */
-	public Hashtable images_tile = new Hashtable(); /* Integers -> Strings */
-	public Hashtable images_bbox = new Hashtable(); /* Strings -> Rectangles */
-	public Hashtable images_tilecid = new Hashtable(); /* Integers -> Integers */
-
-	public Hashtable imagemaps = new Hashtable(); /* Strings->ImageMaps*/
-
-	public int alpha_thresh=128;
-	public JGColor render_bg_color=null; // null means use bg_color
-
-
-	/* objects */
-
-	/** Note: objects lock is used to synchronise object updating between
-	 * repaint thread and game thread.  The synchronize functions are found in
-	 * Engine.doFrameAll and Canvas.paint */
-	public SortedArray objects=new SortedArray(80);    /* String->JGObject */
-	SortedArray obj_to_remove = new SortedArray(40); /* String */
-	Vector obj_spec_to_remove = new Vector(20,40); /* (String,Int) */
-	SortedArray obj_to_add = new SortedArray(40); /* JGObject */
-
-
-	/* shared playfield dimensions */
-
-	/** Total number of tiles on the playfield. Initially is the same as the
-	* nr of tiles on the visible window (viewnrtilesx/y), but can be
-	* changed to define a playfield larger than the visible window. */
-	public int nrtilesx, nrtilesy;
-	/** Size of one tile */
-	public int tilex,tiley;
-	/** Number of tiles in view (visible window). */
-	public int viewnrtilesx, viewnrtilesy;
-
-	/* scaling preferences */
-
-	public double min_aspect=3.0/4.0, max_aspect=4.0/3.0;
-	public int crop_top=0,crop_left=0,crop_bottom=0,crop_right=0;
-	public boolean smooth_magnify=true;
-
-	/* playfield dimensions from canvas*/
-
-	/** Actual scaled canvas size; that is, the size of the playfield view,
-	 * which may be smaller than the desired size of the game window
-	 * to accommodate for integer-sized scaled tiles. */
-	public int width,height;
-	/** Derived info, used for modulo calculation */
-	public int pfwidth_half,pfheight_half;
-	/** Derived info (playfield size in logical pixels) */
-	public int pfwidth,pfheight;
-
-	/** offset of playfield wrt canvas (may be negative if we crop the
-	 * playfield). */
-	public int canvas_xofs=0,canvas_yofs=0;
-
-	/** Size of one tile, scaled */
-	public int scaledtilex,scaledtiley;
-
-	/** Pending pixel offset of visible view on playfield, to be handled at the
-	 * next frame draw. */
-	public int pendingxofs=0,pendingyofs=0;
-	/** Pixel offset of visible view on playfield. */
-	public int xofs=0,yofs=0;
-	/** Tile offset of top left tile on background image;
-	* is derived from x/yofs */
-	public int tilexofs=-1,tileyofs=-1;
-	/** Derived offset information, useful for scaling. */
-	public int xofs_scaled=0,yofs_scaled=0;
-	/** Derived offset information, useful for modulo. */
-	public int xofs_mid, yofs_mid;
-
-	/** min_scale_fac is min (scalex,scaley). These are 1.0 until width,
-	* height are defined */
-	public double x_scale_fac=1.0, y_scale_fac=1.0, min_scale_fac=1.0;
-
-
-	/* playfield dimensions from engine */
-
-	/** Desired width/height of game window; 0 is not initialised yet. Note
-	 * that the width/height of the canvas may be a little smaller to
-	 * accommodate integer-sized scaled tiles. */
-	public int winwidth=0,winheight=0;
-
-
-	/* background */
-
-	public int [] [] tilemap=null;
-	public int [] [] tilecidmap=null;
-	//public boolean [] [] tilechangedmap=null;
-
-	/** Wrap-around playfield */
-	public boolean pf_wrapx=false,pf_wrapy=false;
-	public int pf_wrapshiftx=0,pf_wrapshifty=0;
-
-	public class BGImage {
-		/** Image name (not tile name) of image to use behind transparent
-		tiles. */
-		public String imgname;
-		public boolean wrapx,wrapy;
-		public JGPoint tiles;
-		public double xofs=0,yofs=0;
-		public BGImage(String imgname, boolean wrapx, boolean wrapy) {
-			this.imgname = imgname;
-			this.wrapx = wrapx;
-			this.wrapy = wrapy;
-			tiles = new JGPoint( (JGPoint)image_orig_size.get(imgname) );
-			tiles.x /= tilex;
-			tiles.y /= tiley;
-		}
-	}
-
-	/** BGImages: images to use behind transparent tiles.  Element 0 is always
-	 * defined.  Null indicates empty image. */
-	public Vector bg_images = new Vector(8,20);
-
-	//public String bg_image=null;
-	//public JGPoint bg_image_tiles=null;
-
-	String out_of_bounds_tile="";
-	int out_of_bounds_cid=0;
-	int preserve_cids=0;
-
-	public int offscreen_margin_x=16,offscreen_margin_y=16;
-
-
-	/** the defined state of the physical cells of background, i.e. (0,0) is
-	 * the top left of background. */
-	public boolean [] [] bg_defined=null;
-
-
-	public int viewWidth() { return viewnrtilesx*tilex; }
-
-	public int viewHeight() { return viewnrtilesy*tiley; }
-
-	public int tileWidth()  { return tilex; }
-
-	public int tileHeight() { return tiley; }
-
-
-	/** Replacement for stringTokenizer.   str will be split into a Vector of
-	 * tokens. Empty tokens are skipped.  splitchar is a single character
-	 * indicating a token boundary (multiple characters are not used here).
-	 * The split characters are not included.
-	*/
-	public static Vector tokenizeString(String str,char splitchar) {
-		Vector tok = new Vector(20,50);
-		int curidx=0,nextidx;
-		while ( (nextidx=str.indexOf(splitchar,curidx)) >= 0) {
-			if (nextidx > curidx) tok.addElement(str.substring(curidx,nextidx));
-			curidx = nextidx+1;
-		}
-		if (curidx < str.length())
-			tok.addElement(str.substring(curidx));
-		return tok;
-	}
-
-	/** Readline as in BufferedReader.  Skips empty lines!
-	*/
-	public static String readline(InputStreamReader in) {
-		int ch;
-		StringBuffer line=null;
-		try {
-			while (true) {
-				ch = in.read();
-				if (ch==-1) {
-					if (line==null) return null;
-					return line.toString();
-				}
-				if (ch==10 || ch==13) {
-					// eol if we read other characters, ignore if not
-					if (line!=null) return line.toString();
-				} else {
-					if (line==null) line=new StringBuffer();
-					line.append((char)ch);
-				}
-			}
-		} catch (IOException e) {
-			if (line==null) return null;
-			return line.toString();
-		}
-	}
-
-
-	/** Generate absolute path from relative path by prepending the package
-	 * name of this class (and converting the "." to "/".  A
-	 * relative path is a path without "/" or an URL protocol at the beginning.
-	 * Absolute paths are not changed. */
-	public String getAbsolutePath(Object pkg_obj,String filename) {
-		if (filename.indexOf("/")==0
-		||   (filename.indexOf("://")>=0 && filename.indexOf("://")<=5) ) {
-			// path starts with "/" or protocol: do not change
-			return filename;
-		} else {
-			// path does not start with "/": prepend package name
-			// with "." in package replaced by fileseparator
-			// this doesn't work as getPackage may return null for applets
-			// String pkgname = getClass().getPackage().getName();
-			String pkgname = pkg_obj.getClass().getName();
-			String pkgname_path="";
-			Vector tokens = tokenizeString(pkgname,'.');
-			//StringTokenizer toker = new StringTokenizer(pkgname,".");
-			for (Enumeration e=tokens.elements();e.hasMoreElements();) {
-				String tok = (String)e.nextElement();
-				if (e.hasMoreElements()) {
-					pkgname_path += tok + "/";
-				}
-			}
-			return "/" + pkgname_path + filename;
-		}
-	}
-
-
-
-
-	/* images */
-
-	/** protected */
-	public boolean existsImage(String imgname) {
-		return images_exists.containsKey(imgname);
-	}
-
-	/** Protected.
-	* @param tileid  tile id number as Integer object (note: 0 is undefined)
-	* @return the image object, null means not defined */
-	public Object getTileImage(Integer tileid) {
-		// we assume that images_tile will not contain id for tileid==0 
-		//if (tileid==0) return null;
-		//Integer tileid_obj = new Integer(tileid);
-		String imgid = (String)images_tile.get(tileid);
-		if (imgid==null) return null;
-		if (!is_resizeable) return (JGImage)images.get(imgid);
-		return getImage(imgid);
-	}
-
-	/** Gets (non-scaled) image's physical size directly. */
-	public JGPoint getImageSize(String imgname) {
-		return (JGPoint)image_orig_size.get(imgname);
-	}
-
-	/** Quick version does not scale image on demand, and does not
-	* give an error when image is not defined.  DEPRECATED. */
-	public JGImage getImageQuick(String imgname) {
-		return (JGImage)images.get(imgname);
-	}
-
-	/** Slow version, (re)scales image on demand if original image is
-	* present. */
-	public JGImage getImage(String imgname) {
-		if (!existsImage(imgname)) throw new JGameError(
-				"Image '"+imgname+"' not defined.",true );
-		JGImage img = (JGImage)images.get(imgname);
-		if (img==null) {
-			img = (JGImage)images_orig.get(imgname);
-			if (img==null) return null;
-			// convert indexed to display-compatible image
-			JGColor render_bg_col = render_bg_color;
-			if (render_bg_col==null) render_bg_col = bg_color;
-			img = img.toDisplayCompatible(alpha_thresh,
-					render_bg_col, true, make_bitmask);
-			JGPoint size = img.getSize();
-			//BufferedImage img2 = JREImage.createCompatibleImage(
-			//		size.width,size.height, Transparency.TRANSLUCENT );
-			//img2.getGraphics().drawImage(img,0,0,null);
-			//img=img2;
-			if (width>0 && height>0) {
-				if (prescale) {
-					JGPoint scaledpos = scalePos(size.x,size.y,false);
-					img = img.scale(scaledpos.x,scaledpos.y);
-					// convert translucent image to bitmask
-					// not necessary?
-					//img = imageutil.toCompatibleBitmask(img,alpha_thresh,
-					//		render_bg_col,false);
-				} // else skip this part for efficiency, even though scalefac
-				// is 1.0.
-				images.put(imgname,img);
-			} else {
-				throw new JGameError("Image width, height <= 0 !",true);
-			}
-		}
-		return img;
-	}
-
-	public JGImage getImageOrig(String imgname) {
-		return (JGImage)images_orig.get(imgname);
-	}
-
-	/** protected */
-	public JGImage getSubImage(String mapname,int imgnr) {
-		ImageMap imgmap = (ImageMap)imagemaps.get(mapname);
-		if (imgmap == null) throw new JGameError(
-				"Image map '"+mapname+"' not found.",true );
-		JGPoint subcoord = imgmap.getImageCoord(imgnr);
-		if (subcoord!=null) {
-			return imgmap.img.crop(subcoord.x,subcoord.y,
-					imgmap.tilex,imgmap.tiley);
-		} else {
-			return null;
-		}
-	}
-
-
-	public void defineMedia(JGEngineInterface eng,String filename) {
-		int lnr=1;
-		int nr_lines=0;
-		filename = getAbsolutePath(eng,filename);
-		try {
-			InputStream instr = getClass().getResourceAsStream(filename);
-			if (instr==null) eng.exitEngine("Cannot open `"+filename+"'.");
-			InputStreamReader in = new InputStreamReader(instr);
-			if (in==null) eng.exitEngine("Cannot open `"+filename+"'.");
-			// count nr of lines in file first
-			while (readline(in) != null) nr_lines++;
-			if (nr_lines==0) eng.exitEngine("Cannot open `"+filename+"'.");
-			// now, read the file
-			in = new InputStreamReader(
-				getClass().getResourceAsStream( filename ) );
-			String line;
-			String [] fields = new String [14];
-			while ( (line = readline(in)) != null) {
-				eng.setProgressBar((double)lnr / (double)nr_lines);
-				int i=0;
-				Vector tokens = tokenizeString(line,'\t');
-				for (Enumeration e=tokens.elements(); e.hasMoreElements(); ) {
-					fields[i++] = (String)e.nextElement();
-				}
-				if (i==8) {
-					defineImageMap(eng,
-						fields[0], fields[1],
-						Integer.parseInt(fields[2]),
-						Integer.parseInt(fields[3]),
-						Integer.parseInt(fields[4]),
-						Integer.parseInt(fields[5]),
-						Integer.parseInt(fields[6]),
-						Integer.parseInt(fields[7]) );
-				} else if (i==9) {
-					defineImage(eng, fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						fields[3],
-						fields[4],
-						Integer.parseInt(fields[5]),
-						Integer.parseInt(fields[6]),
-						Integer.parseInt(fields[7]),
-						Integer.parseInt(fields[8])  );
-				} else if (i==5) {
-					defineImage(eng, fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						fields[3],
-						fields[4], -1,-1,-1,-1  );
-				} else if (i==10) {
-					defineImage(fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						getSubImage(fields[3],
-							Integer.parseInt(fields[4]) ),
-						fields[5],
-						Integer.parseInt(fields[6]),
-						Integer.parseInt(fields[7]),
-						Integer.parseInt(fields[8]),
-						Integer.parseInt(fields[9])  );
-				} else if (i==6) {
-					defineImage(fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						getSubImage(fields[3],
-							Integer.parseInt(fields[4]) ),
-						fields[5], -1,-1,-1,-1  );
-				} else if (i==3) {
-					defineAnimation(fields[0], splitList(fields[1]), 
-						Double.parseDouble(fields[2])  );
-				} else if (i==4) {
-					defineAnimation(fields[0], splitList(fields[1]),
-						Double.parseDouble(fields[2]),
-						fields[3].equals("true"));
-				} else if (i==2) {
-					defineAudioClip(eng,fields[0], fields[1]);
-				}
-				lnr++;
-			}
-		} catch (JGameError e) {
-			eng.exitEngine("Error in "+filename+" line "+lnr+": "+e);
-		} catch (Exception e) {
-			eng.exitEngine("Error in "+filename+" line "+lnr+":\n"
-				+ eng.dbgExceptionToString(e));
-		}
-		
-	}
-
-	/** Split a ';' separated list of words */
-	public static String [] splitList(String liststr) {
-		Vector list = tokenizeString(liststr,';');
-		String [] list_arr = new String [list.size()];
-		int i=0;
-		for (Enumeration e=list.elements(); e.hasMoreElements(); ) {
-			list_arr[i] = (String) e.nextElement();
-			i++;
-		}
-		return list_arr;
-	}
-
-
-
-
-	/** Remove all information associated with image, including any cached
-	* image data. Does not unload any image maps.  XXX not quite finished;
-	* publish this method when finished. */
-	public void undefineImage(String name) {
-		imageutil.purgeImage((String)images_loaded.get(name));
-		images_orig.remove(name);
-		image_orig_size.remove(name);
-		images.remove(name);
-		images_exists.remove(name);
-		images_transp.remove(name);
-		images_loaded.remove(name);
-		images_bbox.remove(name);
-		for (int i=bg_images.size()-1; i>=0; i--) {
-			BGImage bg_image = (BGImage) bg_images.elementAt(i);
-			if (bg_image!=null && bg_image.imgname.equals(name)) {
-				bg_images.setElementAt(null,i);
-			}
-		}
-		// XXX association with tile is not yet removed; as we cannot obtain
-		// the tile name from the image name
-		//Integer tileid = new Integer(tileStrToID(tilename));
-		//Hashtable images_tile = new Hashtable(); /* Integers -> Strings */
-		//Hashtable images_tilecid = new Hashtable(); /* Integers -> Integers */
-	}
-
-	public void defineImage(Object pkg_obj,String name, String tilename,
-	int collisionid, String imgfile, String img_op,
-	int top,int left, int width,int height) {
-		if ( images_loaded.containsKey(name)
-		&&  !images_loaded.get(name).equals(imgfile)) {
-			// if associated file is not the same, undefine old image
-			undefineImage(name);
-		}
-		JGImage img=null;
-		if (!imgfile.equals("null")) {
-			imgfile = getAbsolutePath(pkg_obj,imgfile);
-			img = imageutil.loadImage(imgfile);
-			images_loaded.put(name,imgfile);
-		}
-		defineImage(name,tilename, collisionid, img,
-			img_op, top,left, width,height);
-	}
-
-	/** passing -1 to top,left,width,height indicates these have to be taken
-	* from the image dimensions.
-	*/
-	public void defineImage(String name, String tilename, int collisionid,
-	JGImage img, String img_op,
-	int top,int left, int width,int height) {
-		if (img!=null) {
-			/* do image ops */
-			img_op = img_op.toLowerCase();
-			boolean flipx = img_op.indexOf("x") >= 0;
-			boolean flipy = img_op.indexOf("y") >= 0;
-			boolean rot90  = img_op.indexOf("r") >= 0;
-			boolean rot180 = img_op.indexOf("u") >= 0;
-			boolean rot270 = img_op.indexOf("l") >= 0;
-			//System.out.println("img_op "+img_op+ " "+flipx+" "+flipy);
-			if (flipx || flipy) img = img.flip(flipx,flipy);
-			if (rot90) { img = img.rotate(90); }
-			else if (rot180) { img = img.rotate(180); }
-			else if (rot270) { img = img.rotate(270); }
-			images_orig.put(name,img);
-			image_orig_size.put(name,img.getSize());
-		}
-		images_exists.put(name, "yes");
-		Integer tileid = new Integer(tileStrToID(tilename));
-		if (img==null || !img.isOpaque(alpha_thresh))
-			images_transp.put(tileid, "yes");
-		images_tile.put(tileid, name);
-		images_tilecid.put(tileid, new Integer(collisionid));
-		// width/height < 0 indicate take bounding box from image dims
-		if (width >= 0) {
-			images_bbox.put(name,new JGRectangle(top,left,width,height));
-		} else {
-			JGPoint size;
-			if (img==null) size = new JGPoint(0,0);
-			else           size = img.getSize();
-			images_bbox.put(name,new JGRectangle(0,0,size.x,size.y));
-		}
-		/* pre-load scaled image to prevent hiccups during gameplay*/
-		getImage(name); 
-		if (!is_resizeable) {
-			// throw away unscaled image to save memory
-			images_orig.remove(name);
-		}
-	}
-
-	public void defineImageRotated(Object pkg_obj,String name, String tilename,
-	int collisionid, String srcname, double angle) {
-		//JGImage src = (JGImage)images_orig.get(srcname);
-		//if (src == null) throw new JGameError(
-		//		"Source image '"+srcname+"' not found.",true );
-		if ( images_loaded.containsKey(name) ) {
-			undefineImage(name);
-		}
-		String imgfile = (String)images_loaded.get(srcname);
-		if (imgfile.equals("null")) throw new JGameError(
-				"Source image '"+srcname+"' does not have a filename.",true );
-
-		imgfile = getAbsolutePath(pkg_obj,imgfile);
-		JGImage img = imageutil.loadImage(imgfile);
-		defineImage(name,tilename, collisionid, img.rotateAny(angle),
-			"-", 0,0, -1,-1);
-	}
-
-
-	public void defineImageMap(Object pkg_obj,String mapname, String imgfile,
-		int xofs,int yofs, int tilex,int tiley, int skipx,int skipy) {
-		imgfile = getAbsolutePath(pkg_obj,imgfile);
-		imagemaps.put(mapname, new ImageMap (imageutil, imgfile, xofs,yofs,
-			tilex,tiley, skipx,skipy) );
-	}
-
-	public JGRectangle getImageBBox(String imgname) {
-		return (JGRectangle)images_bbox.get(imgname);
-	}
-
-
-	/*====== image from engine ======*/
-
-	public void defineImage(Object pkg_obj,String imgname, String tilename,
-	int collisionid,String imgfile, String img_op) {
-		defineImage(pkg_obj,imgname,tilename,collisionid,imgfile, img_op,
-		-1,-1,-1,-1);
-	}
-
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgmap, int mapidx, String img_op,
-	int top,int left, int width,int height) {
-		defineImage(imgname,tilename,collisionid,
-			getSubImage(imgmap, mapidx),
-			img_op, top,left,width,height);
-	}
-
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgmap, int mapidx, String img_op) {
-		defineImage(imgname,tilename,collisionid,
-			getSubImage(imgmap, mapidx), img_op, 0,0,-1,-1);
-	}
-
-
-
-
-	/*====== PF/view ======*/
-
-	/** Offset that should be set on next frame draw. Offset is clipped so the
-	* view always fits within playfield.*/
-	void setPendingViewOffset(int xofs,int yofs) {
-		if (!pf_wrapx) {
-			if (xofs < 0) xofs=0;
-			if (xofs > tilex*(nrtilesx-viewnrtilesx))
-				xofs = tilex*(nrtilesx-viewnrtilesx);
-		}
-		if (!pf_wrapy) {
-			if (yofs < 0) yofs=0;
-			if (yofs > tiley*(nrtilesy-viewnrtilesy))
-				yofs = tiley*(nrtilesy-viewnrtilesy);
-		}
-		pendingxofs = xofs;
-		pendingyofs = yofs;
-		// update parallax level 0
-		if (bg_images.size()>=1) {
-			BGImage bgimg = (BGImage) bg_images.elementAt(0);
-			if (bgimg!=null) {
-				bgimg.xofs = xofs;
-				bgimg.yofs = yofs;
-			}
-		}
-	}
-
-	/** Update offset according to pending offset.  Protected. */
-	public void updateViewOffset() {
-		if (pendingxofs!=xofs || pendingyofs!=yofs) {
-			setViewOffset(pendingxofs,pendingyofs);
-		}
-	}
-
-	/** Update all offset-related variables according to given offset.  */
-	void setViewOffset(int xofs,int yofs) {
-		if (bg_defined==null) return;
-		this.xofs = xofs;
-		this.yofs = yofs;
-		int oldtilexofs = tilexofs;
-		int oldtileyofs = tileyofs;
-		tilexofs = divFloor(xofs,tilex) - 1;
-		tileyofs = divFloor(yofs,tiley) - 1;
-		// XXX does scalePos handle negative numbers properly?
-		xofs_scaled = scaleXPos(xofs,false);
-		yofs_scaled = scaleYPos(yofs,false);
-		calcPFWrapCenter();
-		int maxtilexofs = Math.max(tilexofs,oldtilexofs);
-		int maxtileyofs = Math.max(tileyofs,oldtileyofs);
-		int mintilexofs = Math.min(tilexofs,oldtilexofs);
-		int mintileyofs = Math.min(tileyofs,oldtileyofs);
-		//bg_defined = new boolean[viewnrtilesx+3][viewnrtilesy+3];
-		// wipe all rows and columns that the vector
-		// oldtileofs -> tileofs crosses
-		for (int yi=mintileyofs; yi<maxtileyofs; yi++) {
-			for (int xi=0; xi<viewnrtilesx+3; xi++) {
-				bg_defined[xi][moduloFloor(yi,viewnrtilesy+3)]=false;
-			}
-		}
-		for (int xi=mintilexofs; xi<maxtilexofs; xi++) {
-			for (int yi=0; yi<viewnrtilesy+3; yi++) {
-				bg_defined[moduloFloor(xi,viewnrtilesx+3)][yi]=false;
-			}
-		}
-		//bg_defined[xi%(viewnrtilesx+3)][yi%(viewnrtilesy+3)]=true;
-	}
-
-	void calcPFWrapCenter() {
-		xofs_mid = xofs + viewnrtilesx*tilex/2 + pf_wrapshiftx;
-		yofs_mid = yofs + viewnrtilesy*tiley/2 + pf_wrapshifty;
-	}
-
-
-
-	/*====== objects from canvas ======*/
-
-	public void markAddObject(JGObject obj) {
-		obj_to_add.put(obj.getName(),obj);
-	}
-
-	/** Add new object now.  Old object with the same name is replaced
-	 * immediately, and its remove() method called.  Skips calling objects.put
-	 * when skip_actual_add=true.  This is useful if the caller optimises the
-	 * objects.add by adding an entire array at once */
-	void addObject(JGObject obj, boolean skip_actual_add) {
-		int idx = objects.get(obj.getName());
-		if (idx >= 0) {
-			JGObject old_obj = (JGObject)objects.values[idx];
-			// disable object so it doesn't call engine on removal
-			old_obj.removeDone();
-			// ensure any dispose stuff in the object is called
-			old_obj.remove();
-		}
-		if (!skip_actual_add)
-			objects.put(obj.getName(),obj);
-	}
-
-	/** Mark object for removal. */
-	void markRemoveObject(String index) {
-		int idx = objects.get(index);
-		if (idx<0) return;
-		obj_to_remove.put(index,(JGObject)objects.values[idx]);
-	}
-
-	/** Mark object for removal. */
-	void markRemoveObject(JGObject obj) {
-		obj_to_remove.put(obj.getName(),obj);
-	}
-
-	/** Actually remove object now */
-	void doRemoveObject(JGObject obj) {
-		obj.removeDone();
-		objects.remove(obj.getName());
-	}
-
-	/** Mark all objects with given spec for removal. */
-	void markRemoveObjects(String prefix,int cidmask,boolean suspended_obj) {
-		obj_spec_to_remove.addElement(prefix);
-		obj_spec_to_remove.addElement(new Integer(cidmask));
-		obj_spec_to_remove.addElement(new Boolean(suspended_obj));
-	}
-	/** Actually remove objects with given spec, including those in obj_to_add
-	 * list.  Uses obj_to_remove as a temp variable.  If anything is already
-	 * in obj_to_remove, it is left there. If do_remove_list is true, the
-	 * objects are removed and obj_to_remove is cleared.  Otherwise, the
-	 * objects to remove are just added to obj_to_remove. */
-	void doRemoveObjects(String prefix,int cidmask,boolean suspended_obj,
-	boolean do_remove_list) {
-		int firstidx=getFirstObjectIndex(prefix);
-		int lastidx=getLastObjectIndex(prefix);
-		for (int i=firstidx; i<lastidx; i++) {
-			JGObject o = (JGObject) objects.values[i];
-			if (cidmask==0 || (o.colid&cidmask)!=0) {
-				if (suspended_obj || !o.is_suspended) {
-					obj_to_remove.put(objects.keys[i],o);
-				}
-			}
-		}
-		if (do_remove_list) doRemoveList();
-		// if we enumerate backwards, we can remove elements inline without
-		// consistency problems
-		for (int i=obj_to_add.size-1; i>=0; i--) {
-			JGObject o = (JGObject) obj_to_add.values[i];
-			if (prefix==null || obj_to_add.keys[i].startsWith(prefix)) {
-				if (cidmask==0 || (o.colid&cidmask)!=0) {
-					if (suspended_obj || !o.is_suspended) {
-						// Note: remove element inside element enumeration
-						obj_to_add.remove(obj_to_add.keys[i]);
-						o.removeDone();
-					}
-				}
-			}
-		}
-	}
-
-
-	/** protected, remove objects marked for removal. */
-	public void flushRemoveList() {
-		//for (Enumeration e=obj_to_remove.elements(); e.hasMoreElements();) {
-		//	String name = (String)e.nextElement();
-		//	JGObject o = (JGObject)objects.get(name);
-		//	if (o!=null) { // object might have been removed already
-		//		doRemoveObject(o);
-		//	}
-		//}
-		// add all query results from object specs to obj_to_remove
-		// don't enumerate when no elements (which is about 90% of the time)
-		if (obj_spec_to_remove.size()!=0) {
-			for (Enumeration e=obj_spec_to_remove.elements();
-			e.hasMoreElements(); ) {
-				String prefix = (String) e.nextElement();
-				int cid = ((Integer)e.nextElement()).intValue();
-				boolean suspended_obj=((Boolean)e.nextElement()).booleanValue();
-				doRemoveObjects(prefix,cid,suspended_obj,false);
-			}
-			obj_spec_to_remove.removeAllElements();
-		}
-		// remove everything in one go
-		doRemoveList();
-	}
-
-	/** Actually remove objects in obj_to_remove. */
-	void doRemoveList() {
-		for (int i=0; i<obj_to_remove.size; i++) {
-			((JGObject)obj_to_remove.values[i]).removeDone();
-		}
-		objects.remove(obj_to_remove);
-		obj_to_remove.clear();
-	}
-
-	/** Add objects marked for addition. Protected.
-	*/
-	public void flushAddList() {
-		// XXX we have to add one by one because we have to call the dispose
-		// method of the objects that are replaced
-		for (int i=0; i<obj_to_add.size; i++) {
-			addObject((JGObject)obj_to_add.values[i],true);
-		}
-		// actually add objects to array in one go for faster performance
-		objects.put(obj_to_add);
-		obj_to_add.clear();
-	}
-
-	///** Remove objects marked for addition before they can be added.
-	// * Protected.
-	//*/
-	//public void clearAddList() {
-	//	for (int i=0; i<obj_to_add.size; i++) {
-	//		// be sure to mark the object as removed
-	//		((JGObject)obj_to_add.values[i]).removeDone();
-	//	}
-	//	obj_to_add.clear();
-	//}
-
-
-	/* public */
-
-	public boolean existsObject(String index) {
-		return objects.get(index) >= 0;
-	}
-
-	public JGObject getObject(String index) {
-		int idx = objects.get(index);
-		if (idx<0) return null;
-		return (JGObject)objects.values[idx];
-	}
-
-	///** Remove all objects.  All objects are marked for removal, the add
-	//* list is cleared.  */
-	//void clearObjects() {
-	//	for (Enumeration e=objects.keys(); e.hasMoreElements(); ) {
-	//		markRemoveObject((String)e.nextElement());
-	//	}
-	//	clearAddList();
-	//	//clear_objects=true;
-	//}
-
-	public void moveObjects(JGEngineInterface eng,String prefix, int cidmask) {
-		if (in_parallel_upd) throw new JGameError("Recursive call",true);
-		in_parallel_upd=true;
-		int firstidx=getFirstObjectIndex(prefix);
-		int lastidx=getLastObjectIndex(prefix);
-		for (int i=firstidx; i<lastidx; i++) {
-			JGObject o = (JGObject) objects.values[i];
-			if (cidmask!=0 && (o.colid&cidmask)==0) continue;
-			// first, update suspend mode
-			if (o.is_suspended) {
-				if (o.resume_in_view
-				&&o.isInView(offscreen_margin_x,offscreen_margin_y)) o.resume();
-			} else {
-				if (o.expiry==JGObject.suspend_off_view
-				||  o.expiry==JGObject.suspend_off_view_expire_off_pf) {
-					if (!o.isInView(offscreen_margin_x,offscreen_margin_y))
-						o.suspend();
-				}
-			}
-			// move object
-			// we must ensure modulo is correct when object is suspended so
-			// that it will unsuspend properly
-			//o.moduloPos(); // is inlined below
-			if (pf_wrapx) o.x = moduloXPos(o.x);
-			if (pf_wrapy) o.y = moduloYPos(o.y);
-			if (!o.is_suspended) {
-				//o.moduloPos(); // is inlined below
-				if (pf_wrapx) o.x = moduloXPos(o.x);
-				if (pf_wrapy) o.y = moduloYPos(o.y);
-				try {
-					o.move();
-				} catch (JGameError ex) {
-					eng.exitEngine(eng.dbgExceptionToString(ex));
-				} catch (Exception ex) {
-					eng.dbgShowException(o.getName(),ex);
-				}
-				o.updateAnimation(gamespeed);
-				o.x += o.xdir*o.xspeed*gamespeed;
-				o.y += o.ydir*o.yspeed*gamespeed;
-				//o.moduloPos(); // is inlined below
-				if (pf_wrapx) o.x = moduloXPos(o.x);
-				if (pf_wrapy) o.y = moduloYPos(o.y);
-			}
-			// check expiry; object should not expire when suspended
-			if (!o.is_suspended) {
-				int expiry = (int) o.expiry;
-				if (expiry >= 0) {
-					o.expiry -= gamespeed;
-					if (o.expiry < 0) o.remove();
-				} else {
-					if (expiry==JGObject.expire_off_pf
-					||  expiry==JGObject.suspend_off_view_expire_off_pf) {
-						if (!o.isOnPF(offscreen_margin_x,offscreen_margin_y))
-							o.remove();
-					}
-					if (expiry==JGObject.expire_off_view
-					&& !o.isInView(offscreen_margin_x,offscreen_margin_y))
-						o.remove();
-				}
-			}
-		}
-		flushRemoveList();
-		in_parallel_upd=false;
-	}
-
-
-	public void moveObjects(JGEngineInterface eng) {
-		moveObjects(eng,null,0); 
-	}
-
-	/* reused rectangles, used within collision methods */
-
-	JGRectangle tmprect1 = new JGRectangle();
-	JGRectangle tmprect2 = new JGRectangle();
-
-	JGObject [] srcobj = new JGObject[50];
-	JGObject [] dstobj = new JGObject[50];
-	public void checkCollision(JGEngineInterface eng,int srccid,int dstcid) {
-		if (in_parallel_upd) throw new JGameError("Recursive call",true);
-		in_parallel_upd=true;
-		if (objects.size > srcobj.length) {
-			// grow arrays to make objects fit
-			srcobj = new JGObject[objects.size+50];
-			dstobj = new JGObject[objects.size+50];
-		}
-		int srcsize = 0;
-		int dstsize = 0;
-		/* get all matching objects */
-		JGRectangle sr = tmprect1;
-		JGRectangle dr = tmprect2;
-		for (int i=0; i<objects.size; i++) {
-			JGObject o  = (JGObject)objects.values[i];
-			if (o.is_suspended) continue;
-			if (!o.getBBox(sr)) continue;
-			if ((o.colid & srccid) != 0) {
-				srcobj[srcsize++] = o;
-			}
-			if ((o.colid & dstcid) != 0) {
-				dstobj[dstsize++] = o;
-			}
-		}
-		/* check collision */
-		for (int si=0; si<srcsize; si++) {
-			JGObject srco = srcobj[si];
-			if (!srco.getBBox(sr)) continue;
-			for (int di=0; di<dstsize; di++) {
-				JGObject dsto = dstobj[di];
-				if (dsto == srco) continue;
-				if (!dsto.getBBox(dr)) continue;
-				if (sr.intersects(dr)) {
-					try {
-						dsto.hit(srco);
-					} catch (JGameError ex) {
-						eng.exitEngine(eng.dbgExceptionToString(ex));
-					} catch (Exception ex) {
-						eng.dbgShowException(dsto.getName(),ex);
-					}
-				}
-			}
-		}
-		flushRemoveList();
-		in_parallel_upd=false;
-	}
-
-	public int checkCollision(int cidmask, JGObject obj) {
-		JGRectangle bbox = obj.getBBox();
-		if (bbox==null) return 0;
-		int retcid=0;
-		JGRectangle obj_bbox = tmprect1;
-		for (int i=0; i<objects.size; i++) {
-			JGObject o  = (JGObject)objects.values[i];
-			if (o==obj) continue;
-			if (!o.is_suspended) {
-				if (cidmask==0 || (o.colid&cidmask)!=0) {
-					if (!o.getBBox(obj_bbox)) continue;
-					if (bbox.intersects(obj_bbox)) {
-						retcid |= o.colid;
-					}
-				}
-			}
-		}
-		return retcid;
-	}
-
-
-
-	public int checkBGCollision(JGRectangle r) {
-		return getTileCid(getTiles(r));
-	}
-
-	public void checkBGCollision(JGEngineInterface eng,int tilecid,int objcid) {
-		if (in_parallel_upd) throw new JGameError("Recursive call",true);
-		in_parallel_upd=true;
-		if (objects.size > srcobj.length) {
-			// grow arrays to make objects fit
-			srcobj = new JGObject[objects.size+50];
-		}
-		int srcsize = 0;
-		JGRectangle r = tmprect1;
-		/* get all matching objects */
-		for (int i=0; i<objects.size; i++) {
-			JGObject o  = (JGObject)objects.values[i];
-			if (o.is_suspended) continue;
-			if (!o.getTileBBox(r)) continue;
-			if ((o.colid & objcid) != 0) {
-				srcobj[srcsize++] = o;
-			}
-		}
-		/* check collision */
-		JGRectangle tiler = tmprect2;
-		for (int i=0; i<srcsize; i++) {
-			JGObject o = srcobj[i];
-			// tile bbox is always defined
-			o.getTileBBox(r);
-			// fast equivalent of cid=checkBGCollision(r)
-			getTiles(tiler,r);
-			int cid=getTileCid(tiler);
-			if ((cid & tilecid) != 0) {
-				try {
-					o.hit_bg(cid);
-					o.hit_bg(cid,tiler.x,tiler.y,tiler.width,tiler.height);
-					// XXX this might be slow, check its performance
-					for (int y=0; y<tiler.height; y++) {
-						for (int x=0; x<tiler.width; x++) {
-							int thiscid = getTileCid(tiler.x+x, tiler.y+y);
-							if ( (thiscid&tilecid) != 0)
-								o.hit_bg(thiscid, tiler.x+x, tiler.y+y);
-						}
-					}
-				} catch (JGameError ex) {
-					eng.exitEngine(eng.dbgExceptionToString(ex));
-				} catch (Exception ex) {
-					eng.dbgShowException(o.getName(),ex);
-				}
-			}
-		}
-		flushRemoveList();
-		in_parallel_upd=false;
-	}
-
-
-	/* objects from engine */
-
-
-	public Vector getObjects(String prefix,int cidmask,boolean suspended_obj,
-	JGRectangle bbox) {
-		Vector objects_v = new Vector(50,100);
-		int nr_obj=0;
-		JGRectangle obj_bbox = tmprect1;
-		int firstidx=getFirstObjectIndex(prefix);
-		int lastidx=getLastObjectIndex(prefix);
-		for (int i=firstidx; i<lastidx; i++) {
-			JGObject obj  = (JGObject)objects.values[i];
-			if (cidmask==0 || (obj.colid&cidmask)!=0) {
-				if (suspended_obj || !obj.is_suspended) {
-					if (bbox!=null) {
-						if (!obj.getBBox(obj_bbox)) continue;
-						if (bbox.intersects(obj_bbox)) {
-							objects_v.addElement(obj);
-						}
-					} else {
-						objects_v.addElement(obj);
-					}
-				}
-			}
-		}
-		return objects_v;
-	}
-
-
-	public void removeObject(JGObject obj) {
-		if (in_parallel_upd) { // queue remove
-			markRemoveObject(obj);
-		} else { // do remove immediately
-			doRemoveObject(obj);
-		}
-	}
+    public JGImage imageutil;
 
-	public void removeObjects(String prefix,int cidmask) {
-		removeObjects(prefix,cidmask,true);
-	}
+    Random random;
 
-	public void removeObjects(String prefix,int cidmask,boolean suspended_obj) {
-		if (in_parallel_upd) {
-			markRemoveObjects(prefix,cidmask,suspended_obj);
-		} else {
-			doRemoveObjects(prefix,cidmask,suspended_obj,true);
-		}
-	}
-
-
-	public int countObjects(String prefix,int cidmask) {
-		return countObjects(prefix,cidmask,true);
-	}
-
-	public int countObjects(String prefix,int cidmask,boolean suspended_obj) {
-		int nr_obj=0;
-		int firstidx=getFirstObjectIndex(prefix);
-		int lastidx=getLastObjectIndex(prefix);
-		for (int i=firstidx; i<lastidx; i++) {
-			JGObject obj = (JGObject) objects.values[i];
-			if (cidmask==0 || (obj.colid&cidmask)!=0) {
-				if (suspended_obj || !obj.is_suspended) {
-					nr_obj++;
-				}
-			}
-		}
-		return nr_obj;
-	}
-
-
-	int getFirstObjectIndex(String prefix) {
-		if (prefix==null) return 0;
-		int firstidx = objects.get(prefix);
-		if (firstidx<0) firstidx = -1-firstidx;
-		return firstidx;
-	}
-
-	int getLastObjectIndex(String prefix) {
-		if (prefix==null) return objects.size;
-		// XXX theoretically there may be strings with prefix
-		// lexicographically below this one
-		return -1-objects.get(prefix+'\uffff');
-	}
-
-
-
-	/** Do final update actions on objects after all frame updates finished.
-	* Protected. */
-	public void frameFinished() {
-		for (int i=0; i<objects.size; i++) {
-			((JGObject)objects.values[i]).frameFinished();
-		}
-	}
-
-	/*====== BG/tiles ======*/
-
-	/** Repaint those parts of BG which are undefined according to bg_defined.
-	* Handles wraparound if applicable.  If wraparound is on, xofs and yofs
-	* may be any value. */
-	public void repaintBG(JGEngineInterface eng) {
-		if (bg_defined==null) return;
-		// first, convert tilechangedmap entries to bg_defined entries. Note
-		// that one tilechanged may result in multiple bg undefineds, in case
-		// the playfield is smaller than viewnrtiles+3.
+    /**
+     * Platform implementation decides if window is resizeable.  Resizeable
+     * requires the implementation to keep the original unscaled images in
+     * memory.  Turn it off if you are short on memory.
+     */
+    public boolean is_resizeable = true;
+
+    /**
+     * make_bitmask indicates what to do with transparent images.
+     * true = make bitmask false=make translucent
+     */
+    boolean make_bitmask;
+
+    /**
+     * prescale indicates if: (1) images should be prescaled to screen
+     * resolution or kept at their original size; (2) tiles should be drawn
+     * prescaled. It affects:
+     * scaled_tile*: scaled tile size, or original size
+     * width/height: rounded to whole tile sizes or actual window size
+     * *ofs_scaled: either scaled, or same as *ofs.
+     * Indirectly affected: *_scale_fac canvas_*ofs
+     */
+    boolean prescale;
+
+    public EngineLogic(JGImage imageutil,
+                       boolean make_bitmask, boolean prescale) {
+        this.imageutil = imageutil;
+        this.make_bitmask = make_bitmask;
+        this.prescale = prescale;
+        random = new Random();
+        bg_images.addElement(null);
+    }
+
+
+    /**
+     * indicates if setCanvasSettings was called.
+     */
+    public boolean view_initialised = false;
+
+    public JGColor fg_color = JGColor.white;
+    public JGColor bg_color = JGColor.black;
+    public JGFont msg_font = null;
+
+    public int outline_thickness = 0;
+    public JGColor outline_colour = JGColor.black;
+
+
+    public double fps = 35;
+    public double maxframeskip = 4.0; /* max # of frames to skip  */
+
+    public double gamespeed = 1.00000000001;
+
+    /* game state. These vectors are always reused and not reconstructed. */
+
+    /**
+     * Engine game state
+     */
+    public Vector gamestate = new Vector(10, 20);
+    /**
+     * New engine game state to be assigned at the next frame
+     */
+    public Vector gamestate_nextframe = new Vector(10, 20);
+    /**
+     * New game states which the game has to transition to, and for which
+     * start[state] have to be called.
+     */
+    public Vector gamestate_new = new Vector(10, 20);
+    /**
+     * indicates when engine is inside a parallel object update (moveObjects,
+     * check*Collision)
+     */
+
+
+    boolean in_parallel_upd = false;
+
+
+    private final Vector timers = new Vector(20, 40);
+
+
+    /**
+     * signals that JGame globals are set, and exit code should null globals in
+     * JGObject
+     */
+    public boolean is_inited = false;
+    /**
+     * signals that thread should die and canvas should paint exit message
+     */
+    public boolean is_exited = false;
+    public String exit_message = "JGEngine exited successfully";
+
+
+    Hashtable animations = new Hashtable();
+
+
+    /* images */
+
+    /**
+     * Strings -&gt; JGImages, original size,
+     * nonexistence means there is no image
+     */
+    public Hashtable images_orig = new Hashtable();
+    /**
+     * JGPoint sizes of original images
+     */
+    public Hashtable image_orig_size = new Hashtable();
+    /**
+     * Strings -&gt; JGImages, screen size, nonexistence indicates image
+     * is not cached and needs to be generated from images_orig
+     */
+    public Hashtable images = new Hashtable();
+
+    /**
+     * indicates that image is defined even if it has no Image
+     */
+    public Hashtable images_exists = new Hashtable();
+    public Hashtable images_transp = new Hashtable();
+    /**
+     * Hashtable: name to filename. Indicates that image with given name
+     * is loaded from given filename
+     */
+    public Hashtable images_loaded = new Hashtable();
+    /* Integers -> Objects, existence indicates transparency */
+    public Hashtable images_tile = new Hashtable(); /* Integers -> Strings */
+    public Hashtable images_bbox = new Hashtable(); /* Strings -> Rectangles */
+    public Hashtable images_tilecid = new Hashtable(); /* Integers -> Integers */
+
+    public Hashtable imagemaps = new Hashtable(); /* Strings->ImageMaps*/
+
+    public int alpha_thresh = 128;
+    public JGColor render_bg_color = null; // null means use bg_color
+
+
+    /* objects */
+
+    /**
+     * Note: objects lock is used to synchronise object updating between
+     * repaint thread and game thread.  The synchronize functions are found in
+     * Engine.doFrameAll and Canvas.paint
+     */
+    public SortedArray objects = new SortedArray(80);    /* String->JGObject */
+    SortedArray obj_to_remove = new SortedArray(40); /* String */
+    Vector obj_spec_to_remove = new Vector(20, 40); /* (String,Int) */
+    SortedArray obj_to_add = new SortedArray(40); /* JGObject */
+
+
+    /* shared playfield dimensions */
+
+    /**
+     * Total number of tiles on the playfield. Initially is the same as the
+     * nr of tiles on the visible window (viewnrtilesx/y), but can be
+     * changed to define a playfield larger than the visible window.
+     */
+    public int nrtilesx, nrtilesy;
+    /**
+     * Size of one tile
+     */
+    public int tilex, tiley;
+    /**
+     * Number of tiles in view (visible window).
+     */
+    public int viewnrtilesx, viewnrtilesy;
+
+    /* scaling preferences */
+
+    public double min_aspect = 3.0 / 4.0, max_aspect = 4.0 / 3.0;
+    public int crop_top = 0, crop_left = 0, crop_bottom = 0, crop_right = 0;
+    public boolean smooth_magnify = true;
+
+    /* playfield dimensions from canvas*/
+
+    /**
+     * Actual scaled canvas size; that is, the size of the playfield view,
+     * which may be smaller than the desired size of the game window
+     * to accommodate for integer-sized scaled tiles.
+     */
+    public int width, height;
+    /**
+     * Derived info, used for modulo calculation
+     */
+    public int pfwidth_half, pfheight_half;
+    /**
+     * Derived info (playfield size in logical pixels)
+     */
+    public int pfwidth, pfheight;
+
+    /**
+     * offset of playfield wrt canvas (may be negative if we crop the
+     * playfield).
+     */
+    public int canvas_xofs = 0, canvas_yofs = 0;
+
+    /**
+     * Size of one tile, scaled
+     */
+    public int scaledtilex, scaledtiley;
+
+    /**
+     * Pending pixel offset of visible view on playfield, to be handled at the
+     * next frame draw.
+     */
+    public int pendingxofs = 0, pendingyofs = 0;
+    /**
+     * Pixel offset of visible view on playfield.
+     */
+    public int xofs = 0, yofs = 0;
+    /**
+     * Tile offset of top left tile on background image;
+     * is derived from x/yofs
+     */
+    public int tilexofs = -1, tileyofs = -1;
+    /**
+     * Derived offset information, useful for scaling.
+     */
+    public int xofs_scaled = 0, yofs_scaled = 0;
+    /**
+     * Derived offset information, useful for modulo.
+     */
+    public int xofs_mid, yofs_mid;
+
+    /**
+     * min_scale_fac is min (scalex,scaley). These are 1.0 until width,
+     * height are defined
+     */
+    public double x_scale_fac = 1.0, y_scale_fac = 1.0, min_scale_fac = 1.0;
+
+
+    /* playfield dimensions from engine */
+
+    /**
+     * Desired width/height of game window; 0 is not initialised yet. Note
+     * that the width/height of the canvas may be a little smaller to
+     * accommodate integer-sized scaled tiles.
+     */
+    public int winwidth = 0, winheight = 0;
+
+
+    /* background */
+
+    public int[][] tilemap = null;
+    public int[][] tilecidmap = null;
+    //public boolean [] [] tilechangedmap=null;
+
+    /**
+     * Wrap-around playfield
+     */
+    public boolean pf_wrapx = false, pf_wrapy = false;
+    public int pf_wrapshiftx = 0, pf_wrapshifty = 0;
+
+    public class BGImage {
+        /**
+         * Image name (not tile name) of image to use behind transparent
+         * tiles.
+         */
+        public String imgname;
+        public boolean wrapx, wrapy;
+        public JGPoint tiles;
+        public double xofs = 0, yofs = 0;
+
+        public BGImage(String imgname, boolean wrapx, boolean wrapy) {
+            this.imgname = imgname;
+            this.wrapx = wrapx;
+            this.wrapy = wrapy;
+            tiles = new JGPoint((JGPoint) image_orig_size.get(imgname));
+            tiles.x /= tilex;
+            tiles.y /= tiley;
+        }
+    }
+
+    /**
+     * BGImages: images to use behind transparent tiles.  Element 0 is always
+     * defined.  Null indicates empty image.
+     */
+    public Vector bg_images = new Vector(8, 20);
+
+    //public String bg_image=null;
+    //public JGPoint bg_image_tiles=null;
+
+    String out_of_bounds_tile = "";
+    int out_of_bounds_cid = 0;
+    int preserve_cids = 0;
+
+    public int offscreen_margin_x = 16, offscreen_margin_y = 16;
+
+
+    /**
+     * the defined state of the physical cells of background, i.e. (0,0) is
+     * the top left of background.
+     */
+    public boolean[][] bg_defined = null;
+
+
+    public int viewWidth() {
+        return viewnrtilesx * tilex;
+    }
+
+    public int viewHeight() {
+        return viewnrtilesy * tiley;
+    }
+
+    public int tileWidth() {
+        return tilex;
+    }
+
+    public int tileHeight() {
+        return tiley;
+    }
+
+
+    /**
+     * Replacement for stringTokenizer.   str will be split into a Vector of
+     * tokens. Empty tokens are skipped.  splitchar is a single character
+     * indicating a token boundary (multiple characters are not used here).
+     * The split characters are not included.
+     */
+    public static Vector tokenizeString(String str, char splitchar) {
+        Vector tok = new Vector(20, 50);
+        int curidx = 0, nextidx;
+        while ((nextidx = str.indexOf(splitchar, curidx)) >= 0) {
+            if (nextidx > curidx) tok.addElement(str.substring(curidx, nextidx));
+            curidx = nextidx + 1;
+        }
+        if (curidx < str.length())
+            tok.addElement(str.substring(curidx));
+        return tok;
+    }
+
+    /**
+     * Readline as in BufferedReader.  Skips empty lines!
+     */
+    public static String readline(InputStreamReader in) {
+        int ch;
+        StringBuffer line = null;
+        try {
+            while (true) {
+                ch = in.read();
+                if (ch == -1) {
+                    if (line == null) return null;
+                    return line.toString();
+                }
+                if (ch == 10 || ch == 13) {
+                    // eol if we read other characters, ignore if not
+                    if (line != null) return line.toString();
+                } else {
+                    if (line == null) line = new StringBuffer();
+                    line.append((char) ch);
+                }
+            }
+        } catch (IOException e) {
+            if (line == null) return null;
+            return line.toString();
+        }
+    }
+
+
+    /**
+     * Generate absolute path from relative path by prepending the package
+     * name of this class (and converting the "." to "/".  A
+     * relative path is a path without "/" or an URL protocol at the beginning.
+     * Absolute paths are not changed.
+     */
+    public String getAbsolutePath(Object pkg_obj, String filename) {
+        if (filename.indexOf("/") == 0
+                || (filename.indexOf("://") >= 0 && filename.indexOf("://") <= 5)) {
+            // path starts with "/" or protocol: do not change
+            return filename;
+        } else {
+            // path does not start with "/": prepend package name
+            // with "." in package replaced by fileseparator
+            // this doesn't work as getPackage may return null for applets
+            // String pkgname = getClass().getPackage().getName();
+            String pkgname = pkg_obj.getClass().getName();
+            String pkgname_path = "";
+            Vector tokens = tokenizeString(pkgname, '.');
+            //StringTokenizer toker = new StringTokenizer(pkgname,".");
+            for (Enumeration e = tokens.elements(); e.hasMoreElements(); ) {
+                String tok = (String) e.nextElement();
+                if (e.hasMoreElements()) {
+                    pkgname_path += tok + "/";
+                }
+            }
+            return "/" + pkgname_path + filename;
+        }
+    }
+
+
+
+
+    /* images */
+
+    /**
+     * protected
+     */
+    public boolean existsImage(String imgname) {
+        return images_exists.containsKey(imgname);
+    }
+
+    /**
+     * Protected.
+     *
+     * @param tileid tile id number as Integer object (note: 0 is undefined)
+     * @return the image object, null means not defined
+     */
+    public Object getTileImage(Integer tileid) {
+        // we assume that images_tile will not contain id for tileid==0
+        //if (tileid==0) return null;
+        //Integer tileid_obj = new Integer(tileid);
+        String imgid = (String) images_tile.get(tileid);
+        if (imgid == null) return null;
+        if (!is_resizeable) return (JGImage) images.get(imgid);
+        return getImage(imgid);
+    }
+
+    /**
+     * Gets (non-scaled) image's physical size directly.
+     */
+    public JGPoint getImageSize(String imgname) {
+        return (JGPoint) image_orig_size.get(imgname);
+    }
+
+    /**
+     * Quick version does not scale image on demand, and does not
+     * give an error when image is not defined.  DEPRECATED.
+     */
+    public JGImage getImageQuick(String imgname) {
+        return (JGImage) images.get(imgname);
+    }
+
+    /**
+     * Slow version, (re)scales image on demand if original image is
+     * present.
+     */
+    public JGImage getImage(String imgname) {
+        if (!existsImage(imgname)) throw new JGameError(
+                "Image '" + imgname + "' not defined.", true);
+        JGImage img = (JGImage) images.get(imgname);
+        if (img == null) {
+            img = (JGImage) images_orig.get(imgname);
+            if (img == null) return null;
+            // convert indexed to display-compatible image
+            JGColor render_bg_col = render_bg_color;
+            if (render_bg_col == null) render_bg_col = bg_color;
+            img = img.toDisplayCompatible(alpha_thresh,
+                    render_bg_col, true, make_bitmask);
+            JGPoint size = img.getSize();
+            //BufferedImage img2 = JREImage.createCompatibleImage(
+            //		size.width,size.height, Transparency.TRANSLUCENT );
+            //img2.getGraphics().drawImage(img,0,0,null);
+            //img=img2;
+            if (width > 0 && height > 0) {
+                if (prescale) {
+                    JGPoint scaledpos = scalePos(size.x, size.y, false);
+                    img = img.scale(scaledpos.x, scaledpos.y);
+                    // convert translucent image to bitmask
+                    // not necessary?
+                    //img = imageutil.toCompatibleBitmask(img,alpha_thresh,
+                    //		render_bg_col,false);
+                } // else skip this part for efficiency, even though scalefac
+                // is 1.0.
+                images.put(imgname, img);
+            } else {
+                throw new JGameError("Image width, height <= 0 !", true);
+            }
+        }
+        return img;
+    }
+
+    public JGImage getImageOrig(String imgname) {
+        return (JGImage) images_orig.get(imgname);
+    }
+
+    /**
+     * protected
+     */
+    public JGImage getSubImage(String mapname, int imgnr) {
+        ImageMap imgmap = (ImageMap) imagemaps.get(mapname);
+        if (imgmap == null) throw new JGameError(
+                "Image map '" + mapname + "' not found.", true);
+        JGPoint subcoord = imgmap.getImageCoord(imgnr);
+        if (subcoord != null) {
+            return imgmap.img.crop(subcoord.x, subcoord.y,
+                    imgmap.tilex, imgmap.tiley);
+        } else {
+            return null;
+        }
+    }
+
+
+    public void defineMedia(JGEngineInterface eng, String filename) {
+        int lnr = 1;
+        int nr_lines = 0;
+        filename = getAbsolutePath(eng, filename);
+        try {
+            InputStream instr = getClass().getResourceAsStream(filename);
+            if (instr == null) eng.exitEngine("Cannot open `" + filename + "'.");
+            InputStreamReader in = new InputStreamReader(instr);
+            if (in == null) eng.exitEngine("Cannot open `" + filename + "'.");
+            // count nr of lines in file first
+            while (readline(in) != null) nr_lines++;
+            if (nr_lines == 0) eng.exitEngine("Cannot open `" + filename + "'.");
+            // now, read the file
+            in = new InputStreamReader(
+                    getClass().getResourceAsStream(filename));
+            String line;
+            String[] fields = new String[14];
+            while ((line = readline(in)) != null) {
+                eng.setProgressBar((double) lnr / (double) nr_lines);
+                int i = 0;
+                Vector tokens = tokenizeString(line, '\t');
+                for (Enumeration e = tokens.elements(); e.hasMoreElements(); ) {
+                    fields[i++] = (String) e.nextElement();
+                }
+                if (i == 8) {
+                    defineImageMap(eng,
+                            fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            Integer.parseInt(fields[3]),
+                            Integer.parseInt(fields[4]),
+                            Integer.parseInt(fields[5]),
+                            Integer.parseInt(fields[6]),
+                            Integer.parseInt(fields[7]));
+                } else if (i == 9) {
+                    defineImage(eng, fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            fields[3],
+                            fields[4],
+                            Integer.parseInt(fields[5]),
+                            Integer.parseInt(fields[6]),
+                            Integer.parseInt(fields[7]),
+                            Integer.parseInt(fields[8]));
+                } else if (i == 5) {
+                    defineImage(eng, fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            fields[3],
+                            fields[4], -1, -1, -1, -1);
+                } else if (i == 10) {
+                    defineImage(fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            getSubImage(fields[3],
+                                    Integer.parseInt(fields[4])),
+                            fields[5],
+                            Integer.parseInt(fields[6]),
+                            Integer.parseInt(fields[7]),
+                            Integer.parseInt(fields[8]),
+                            Integer.parseInt(fields[9]));
+                } else if (i == 6) {
+                    defineImage(fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            getSubImage(fields[3],
+                                    Integer.parseInt(fields[4])),
+                            fields[5], -1, -1, -1, -1);
+                } else if (i == 3) {
+                    defineAnimation(fields[0], splitList(fields[1]),
+                            Double.parseDouble(fields[2]));
+                } else if (i == 4) {
+                    defineAnimation(fields[0], splitList(fields[1]),
+                            Double.parseDouble(fields[2]),
+                            fields[3].equals("true"));
+                } else if (i == 2) {
+                    defineAudioClip(eng, fields[0], fields[1]);
+                }
+                lnr++;
+            }
+        } catch (JGameError e) {
+            eng.exitEngine("Error in " + filename + " line " + lnr + ": " + e);
+        } catch (Exception e) {
+            eng.exitEngine("Error in " + filename + " line " + lnr + ":\n"
+                    + eng.dbgExceptionToString(e));
+        }
+
+    }
+
+    /**
+     * Split a ';' separated list of words
+     */
+    public static String[] splitList(String liststr) {
+        Vector list = tokenizeString(liststr, ';');
+        String[] list_arr = new String[list.size()];
+        int i = 0;
+        for (Enumeration e = list.elements(); e.hasMoreElements(); ) {
+            list_arr[i] = (String) e.nextElement();
+            i++;
+        }
+        return list_arr;
+    }
+
+
+    /**
+     * Remove all information associated with image, including any cached
+     * image data. Does not unload any image maps.  XXX not quite finished;
+     * publish this method when finished.
+     */
+    public void undefineImage(String name) {
+        imageutil.purgeImage((String) images_loaded.get(name));
+        images_orig.remove(name);
+        image_orig_size.remove(name);
+        images.remove(name);
+        images_exists.remove(name);
+        images_transp.remove(name);
+        images_loaded.remove(name);
+        images_bbox.remove(name);
+        for (int i = bg_images.size() - 1; i >= 0; i--) {
+            BGImage bg_image = (BGImage) bg_images.elementAt(i);
+            if (bg_image != null && bg_image.imgname.equals(name)) {
+                bg_images.setElementAt(null, i);
+            }
+        }
+        // XXX association with tile is not yet removed; as we cannot obtain
+        // the tile name from the image name
+        //Integer tileid = new Integer(tileStrToID(tilename));
+        //Hashtable images_tile = new Hashtable(); /* Integers -> Strings */
+        //Hashtable images_tilecid = new Hashtable(); /* Integers -> Integers */
+    }
+
+    public void defineImage(Object pkg_obj, String name, String tilename,
+                            int collisionid, String imgfile, String img_op,
+                            int top, int left, int width, int height) {
+        if (images_loaded.containsKey(name)
+                && !images_loaded.get(name).equals(imgfile)) {
+            // if associated file is not the same, undefine old image
+            undefineImage(name);
+        }
+        JGImage img = null;
+        if (!imgfile.equals("null")) {
+            imgfile = getAbsolutePath(pkg_obj, imgfile);
+            img = imageutil.loadImage(imgfile);
+            images_loaded.put(name, imgfile);
+        }
+        defineImage(name, tilename, collisionid, img,
+                img_op, top, left, width, height);
+    }
+
+    /**
+     * passing -1 to top,left,width,height indicates these have to be taken
+     * from the image dimensions.
+     */
+    public void defineImage(String name, String tilename, int collisionid,
+                            JGImage img, String img_op,
+                            int top, int left, int width, int height) {
+        if (img != null) {
+            /* do image ops */
+            img_op = img_op.toLowerCase();
+            boolean flipx = img_op.indexOf("x") >= 0;
+            boolean flipy = img_op.indexOf("y") >= 0;
+            boolean rot90 = img_op.indexOf("r") >= 0;
+            boolean rot180 = img_op.indexOf("u") >= 0;
+            boolean rot270 = img_op.indexOf("l") >= 0;
+            //System.out.println("img_op "+img_op+ " "+flipx+" "+flipy);
+            if (flipx || flipy) img = img.flip(flipx, flipy);
+            if (rot90) {
+                img = img.rotate(90);
+            } else if (rot180) {
+                img = img.rotate(180);
+            } else if (rot270) {
+                img = img.rotate(270);
+            }
+            images_orig.put(name, img);
+            image_orig_size.put(name, img.getSize());
+        }
+        images_exists.put(name, "yes");
+        Integer tileid = new Integer(tileStrToID(tilename));
+        if (img == null || !img.isOpaque(alpha_thresh))
+            images_transp.put(tileid, "yes");
+        images_tile.put(tileid, name);
+        images_tilecid.put(tileid, new Integer(collisionid));
+        // width/height < 0 indicate take bounding box from image dims
+        if (width >= 0) {
+            images_bbox.put(name, new JGRectangle(top, left, width, height));
+        } else {
+            JGPoint size;
+            if (img == null) size = new JGPoint(0, 0);
+            else size = img.getSize();
+            images_bbox.put(name, new JGRectangle(0, 0, size.x, size.y));
+        }
+        /* pre-load scaled image to prevent hiccups during gameplay*/
+        getImage(name);
+        if (!is_resizeable) {
+            // throw away unscaled image to save memory
+            images_orig.remove(name);
+        }
+    }
+
+    public void defineImageRotated(Object pkg_obj, String name, String tilename,
+                                   int collisionid, String srcname, double angle) {
+        //JGImage src = (JGImage)images_orig.get(srcname);
+        //if (src == null) throw new JGameError(
+        //		"Source image '"+srcname+"' not found.",true );
+        if (images_loaded.containsKey(name)) {
+            undefineImage(name);
+        }
+        String imgfile = (String) images_loaded.get(srcname);
+        if (imgfile.equals("null")) throw new JGameError(
+                "Source image '" + srcname + "' does not have a filename.", true);
+
+        imgfile = getAbsolutePath(pkg_obj, imgfile);
+        JGImage img = imageutil.loadImage(imgfile);
+        defineImage(name, tilename, collisionid, img.rotateAny(angle),
+                "-", 0, 0, -1, -1);
+    }
+
+
+    public void defineImageMap(Object pkg_obj, String mapname, String imgfile,
+                               int xofs, int yofs, int tilex, int tiley, int skipx, int skipy) {
+        imgfile = getAbsolutePath(pkg_obj, imgfile);
+        imagemaps.put(mapname, new ImageMap(imageutil, imgfile, xofs, yofs,
+                tilex, tiley, skipx, skipy));
+    }
+
+    public JGRectangle getImageBBox(String imgname) {
+        return (JGRectangle) images_bbox.get(imgname);
+    }
+
+
+    /*====== image from engine ======*/
+
+    public void defineImage(Object pkg_obj, String imgname, String tilename,
+                            int collisionid, String imgfile, String img_op) {
+        defineImage(pkg_obj, imgname, tilename, collisionid, imgfile, img_op,
+                -1, -1, -1, -1);
+    }
+
+    public void defineImage(String imgname, String tilename, int collisionid,
+                            String imgmap, int mapidx, String img_op,
+                            int top, int left, int width, int height) {
+        defineImage(imgname, tilename, collisionid,
+                getSubImage(imgmap, mapidx),
+                img_op, top, left, width, height);
+    }
+
+    public void defineImage(String imgname, String tilename, int collisionid,
+                            String imgmap, int mapidx, String img_op) {
+        defineImage(imgname, tilename, collisionid,
+                getSubImage(imgmap, mapidx), img_op, 0, 0, -1, -1);
+    }
+
+
+
+
+    /*====== PF/view ======*/
+
+    /**
+     * Offset that should be set on next frame draw. Offset is clipped so the
+     * view always fits within playfield.
+     */
+    void setPendingViewOffset(int xofs, int yofs) {
+        if (!pf_wrapx) {
+            if (xofs < 0) xofs = 0;
+            if (xofs > tilex * (nrtilesx - viewnrtilesx))
+                xofs = tilex * (nrtilesx - viewnrtilesx);
+        }
+        if (!pf_wrapy) {
+            if (yofs < 0) yofs = 0;
+            if (yofs > tiley * (nrtilesy - viewnrtilesy))
+                yofs = tiley * (nrtilesy - viewnrtilesy);
+        }
+        pendingxofs = xofs;
+        pendingyofs = yofs;
+        // update parallax level 0
+        if (bg_images.size() >= 1) {
+            BGImage bgimg = (BGImage) bg_images.elementAt(0);
+            if (bgimg != null) {
+                bgimg.xofs = xofs;
+                bgimg.yofs = yofs;
+            }
+        }
+    }
+
+    /**
+     * Update offset according to pending offset.  Protected.
+     */
+    public void updateViewOffset() {
+        if (pendingxofs != xofs || pendingyofs != yofs) {
+            setViewOffset(pendingxofs, pendingyofs);
+        }
+    }
+
+    /**
+     * Update all offset-related variables according to given offset.
+     */
+    void setViewOffset(int xofs, int yofs) {
+        if (bg_defined == null) return;
+        this.xofs = xofs;
+        this.yofs = yofs;
+        int oldtilexofs = tilexofs;
+        int oldtileyofs = tileyofs;
+        tilexofs = divFloor(xofs, tilex) - 1;
+        tileyofs = divFloor(yofs, tiley) - 1;
+        // XXX does scalePos handle negative numbers properly?
+        xofs_scaled = scaleXPos(xofs, false);
+        yofs_scaled = scaleYPos(yofs, false);
+        calcPFWrapCenter();
+        int maxtilexofs = Math.max(tilexofs, oldtilexofs);
+        int maxtileyofs = Math.max(tileyofs, oldtileyofs);
+        int mintilexofs = Math.min(tilexofs, oldtilexofs);
+        int mintileyofs = Math.min(tileyofs, oldtileyofs);
+        //bg_defined = new boolean[viewnrtilesx+3][viewnrtilesy+3];
+        // wipe all rows and columns that the vector
+        // oldtileofs -> tileofs crosses
+        for (int yi = mintileyofs; yi < maxtileyofs; yi++) {
+            for (int xi = 0; xi < viewnrtilesx + 3; xi++) {
+                bg_defined[xi][moduloFloor(yi, viewnrtilesy + 3)] = false;
+            }
+        }
+        for (int xi = mintilexofs; xi < maxtilexofs; xi++) {
+            for (int yi = 0; yi < viewnrtilesy + 3; yi++) {
+                bg_defined[moduloFloor(xi, viewnrtilesx + 3)][yi] = false;
+            }
+        }
+        //bg_defined[xi%(viewnrtilesx+3)][yi%(viewnrtilesy+3)]=true;
+    }
+
+    void calcPFWrapCenter() {
+        xofs_mid = xofs + viewnrtilesx * tilex / 2 + pf_wrapshiftx;
+        yofs_mid = yofs + viewnrtilesy * tiley / 2 + pf_wrapshifty;
+    }
+
+
+
+    /*====== objects from canvas ======*/
+
+    public void markAddObject(JGObject obj) {
+        obj_to_add.put(obj.getName(), obj);
+    }
+
+    /**
+     * Add new object now.  Old object with the same name is replaced
+     * immediately, and its remove() method called.  Skips calling objects.put
+     * when skip_actual_add=true.  This is useful if the caller optimises the
+     * objects.add by adding an entire array at once
+     */
+    void addObject(JGObject obj, boolean skip_actual_add) {
+        int idx = objects.get(obj.getName());
+        if (idx >= 0) {
+            JGObject old_obj = (JGObject) objects.values[idx];
+            // disable object so it doesn't call engine on removal
+            old_obj.removeDone();
+            // ensure any dispose stuff in the object is called
+            old_obj.remove();
+        }
+        if (!skip_actual_add)
+            objects.put(obj.getName(), obj);
+    }
+
+    /**
+     * Mark object for removal.
+     */
+    void markRemoveObject(String index) {
+        int idx = objects.get(index);
+        if (idx < 0) return;
+        obj_to_remove.put(index, (JGObject) objects.values[idx]);
+    }
+
+    /**
+     * Mark object for removal.
+     */
+    void markRemoveObject(JGObject obj) {
+        obj_to_remove.put(obj.getName(), obj);
+    }
+
+    /**
+     * Actually remove object now
+     */
+    void doRemoveObject(JGObject obj) {
+        obj.removeDone();
+        objects.remove(obj.getName());
+    }
+
+    /**
+     * Mark all objects with given spec for removal.
+     */
+    void markRemoveObjects(String prefix, int cidmask, boolean suspended_obj) {
+        obj_spec_to_remove.addElement(prefix);
+        obj_spec_to_remove.addElement(new Integer(cidmask));
+        obj_spec_to_remove.addElement(new Boolean(suspended_obj));
+    }
+
+    /**
+     * Actually remove objects with given spec, including those in obj_to_add
+     * list.  Uses obj_to_remove as a temp variable.  If anything is already
+     * in obj_to_remove, it is left there. If do_remove_list is true, the
+     * objects are removed and obj_to_remove is cleared.  Otherwise, the
+     * objects to remove are just added to obj_to_remove.
+     */
+    void doRemoveObjects(String prefix, int cidmask, boolean suspended_obj,
+                         boolean do_remove_list) {
+        int firstidx = getFirstObjectIndex(prefix);
+        int lastidx = getLastObjectIndex(prefix);
+        for (int i = firstidx; i < lastidx; i++) {
+            JGObject o = (JGObject) objects.values[i];
+            if (cidmask == 0 || (o.colid & cidmask) != 0) {
+                if (suspended_obj || !o.is_suspended) {
+                    obj_to_remove.put(objects.keys[i], o);
+                }
+            }
+        }
+        if (do_remove_list) doRemoveList();
+        // if we enumerate backwards, we can remove elements inline without
+        // consistency problems
+        for (int i = obj_to_add.size - 1; i >= 0; i--) {
+            JGObject o = (JGObject) obj_to_add.values[i];
+            if (prefix == null || obj_to_add.keys[i].startsWith(prefix)) {
+                if (cidmask == 0 || (o.colid & cidmask) != 0) {
+                    if (suspended_obj || !o.is_suspended) {
+                        // Note: remove element inside element enumeration
+                        obj_to_add.remove(obj_to_add.keys[i]);
+                        o.removeDone();
+                    }
+                }
+            }
+        }
+    }
+
+
+    /**
+     * protected, remove objects marked for removal.
+     */
+    public void flushRemoveList() {
+        //for (Enumeration e=obj_to_remove.elements(); e.hasMoreElements();) {
+        //	String name = (String)e.nextElement();
+        //	JGObject o = (JGObject)objects.get(name);
+        //	if (o!=null) { // object might have been removed already
+        //		doRemoveObject(o);
+        //	}
+        //}
+        // add all query results from object specs to obj_to_remove
+        // don't enumerate when no elements (which is about 90% of the time)
+        if (obj_spec_to_remove.size() != 0) {
+            for (Enumeration e = obj_spec_to_remove.elements();
+                 e.hasMoreElements(); ) {
+                String prefix = (String) e.nextElement();
+                int cid = ((Integer) e.nextElement()).intValue();
+                boolean suspended_obj = ((Boolean) e.nextElement()).booleanValue();
+                doRemoveObjects(prefix, cid, suspended_obj, false);
+            }
+            obj_spec_to_remove.removeAllElements();
+        }
+        // remove everything in one go
+        doRemoveList();
+    }
+
+    /**
+     * Actually remove objects in obj_to_remove.
+     */
+    void doRemoveList() {
+        for (int i = 0; i < obj_to_remove.size; i++) {
+            ((JGObject) obj_to_remove.values[i]).removeDone();
+        }
+        objects.remove(obj_to_remove);
+        obj_to_remove.clear();
+    }
+
+    /**
+     * Add objects marked for addition. Protected.
+     */
+    public void flushAddList() {
+        // XXX we have to add one by one because we have to call the dispose
+        // method of the objects that are replaced
+        for (int i = 0; i < obj_to_add.size; i++) {
+            addObject((JGObject) obj_to_add.values[i], true);
+        }
+        // actually add objects to array in one go for faster performance
+        objects.put(obj_to_add);
+        obj_to_add.clear();
+    }
+
+    ///** Remove objects marked for addition before they can be added.
+    // * Protected.
+    //*/
+    //public void clearAddList() {
+    //	for (int i=0; i<obj_to_add.size; i++) {
+    //		// be sure to mark the object as removed
+    //		((JGObject)obj_to_add.values[i]).removeDone();
+    //	}
+    //	obj_to_add.clear();
+    //}
+
+
+    /* public */
+
+    public boolean existsObject(String index) {
+        return objects.get(index) >= 0;
+    }
+
+    public JGObject getObject(String index) {
+        int idx = objects.get(index);
+        if (idx < 0) return null;
+        return (JGObject) objects.values[idx];
+    }
+
+    ///** Remove all objects.  All objects are marked for removal, the add
+    //* list is cleared.  */
+    //void clearObjects() {
+    //	for (Enumeration e=objects.keys(); e.hasMoreElements(); ) {
+    //		markRemoveObject((String)e.nextElement());
+    //	}
+    //	clearAddList();
+    //	//clear_objects=true;
+    //}
+
+    public void moveObjects(JGEngineInterface eng, String prefix, int cidmask) {
+        if (in_parallel_upd) throw new JGameError("Recursive call", true);
+        in_parallel_upd = true;
+        int firstidx = getFirstObjectIndex(prefix);
+        int lastidx = getLastObjectIndex(prefix);
+        for (int i = firstidx; i < lastidx; i++) {
+            JGObject o = (JGObject) objects.values[i];
+            if (cidmask != 0 && (o.colid & cidmask) == 0) continue;
+            // first, update suspend mode
+            if (o.is_suspended) {
+                if (o.resume_in_view
+                        && o.isInView(offscreen_margin_x, offscreen_margin_y)) o.resume();
+            } else {
+                if (o.expiry == JGObject.suspend_off_view
+                        || o.expiry == JGObject.suspend_off_view_expire_off_pf) {
+                    if (!o.isInView(offscreen_margin_x, offscreen_margin_y))
+                        o.suspend();
+                }
+            }
+            // move object
+            // we must ensure modulo is correct when object is suspended so
+            // that it will unsuspend properly
+            //o.moduloPos(); // is inlined below
+            if (pf_wrapx) o.x = moduloXPos(o.x);
+            if (pf_wrapy) o.y = moduloYPos(o.y);
+            if (!o.is_suspended) {
+                //o.moduloPos(); // is inlined below
+                if (pf_wrapx) o.x = moduloXPos(o.x);
+                if (pf_wrapy) o.y = moduloYPos(o.y);
+                try {
+                    o.move();
+                } catch (JGameError ex) {
+                    eng.exitEngine(eng.dbgExceptionToString(ex));
+                } catch (Exception ex) {
+                    eng.dbgShowException(o.getName(), ex);
+                }
+                o.updateAnimation(gamespeed);
+                o.x += o.xdir * o.xspeed * gamespeed;
+                o.y += o.ydir * o.yspeed * gamespeed;
+                //o.moduloPos(); // is inlined below
+                if (pf_wrapx) o.x = moduloXPos(o.x);
+                if (pf_wrapy) o.y = moduloYPos(o.y);
+            }
+            // check expiry; object should not expire when suspended
+            if (!o.is_suspended) {
+                int expiry = (int) o.expiry;
+                if (expiry >= 0) {
+                    o.expiry -= gamespeed;
+                    if (o.expiry < 0) o.remove();
+                } else {
+                    if (expiry == JGObject.expire_off_pf
+                            || expiry == JGObject.suspend_off_view_expire_off_pf) {
+                        if (!o.isOnPF(offscreen_margin_x, offscreen_margin_y))
+                            o.remove();
+                    }
+                    if (expiry == JGObject.expire_off_view
+                            && !o.isInView(offscreen_margin_x, offscreen_margin_y))
+                        o.remove();
+                }
+            }
+        }
+        flushRemoveList();
+        in_parallel_upd = false;
+    }
+
+
+    public void moveObjects(JGEngineInterface eng) {
+        moveObjects(eng, null, 0);
+    }
+
+    /* reused rectangles, used within collision methods */
+
+    JGRectangle tmprect1 = new JGRectangle();
+    JGRectangle tmprect2 = new JGRectangle();
+
+    JGObject[] srcobj = new JGObject[50];
+    JGObject[] dstobj = new JGObject[50];
+
+    public void checkCollision(JGEngineInterface eng, int srccid, int dstcid) {
+        if (in_parallel_upd) throw new JGameError("Recursive call", true);
+        in_parallel_upd = true;
+        if (objects.size > srcobj.length) {
+            // grow arrays to make objects fit
+            srcobj = new JGObject[objects.size + 50];
+            dstobj = new JGObject[objects.size + 50];
+        }
+        int srcsize = 0;
+        int dstsize = 0;
+        /* get all matching objects */
+        JGRectangle sr = tmprect1;
+        JGRectangle dr = tmprect2;
+        for (int i = 0; i < objects.size; i++) {
+            JGObject o = (JGObject) objects.values[i];
+            if (o.is_suspended) continue;
+            if (!o.getBBox(sr)) continue;
+            if ((o.colid & srccid) != 0) {
+                srcobj[srcsize++] = o;
+            }
+            if ((o.colid & dstcid) != 0) {
+                dstobj[dstsize++] = o;
+            }
+        }
+        /* check collision */
+        for (int si = 0; si < srcsize; si++) {
+            JGObject srco = srcobj[si];
+            if (!srco.getBBox(sr)) continue;
+            for (int di = 0; di < dstsize; di++) {
+                JGObject dsto = dstobj[di];
+                if (dsto == srco) continue;
+                if (!dsto.getBBox(dr)) continue;
+                if (sr.intersects(dr)) {
+                    try {
+                        dsto.hit(srco);
+                    } catch (JGameError ex) {
+                        eng.exitEngine(eng.dbgExceptionToString(ex));
+                    } catch (Exception ex) {
+                        eng.dbgShowException(dsto.getName(), ex);
+                    }
+                }
+            }
+        }
+        flushRemoveList();
+        in_parallel_upd = false;
+    }
+
+    public int checkCollision(int cidmask, JGObject obj) {
+        JGRectangle bbox = obj.getBBox();
+        if (bbox == null) return 0;
+        int retcid = 0;
+        JGRectangle obj_bbox = tmprect1;
+        for (int i = 0; i < objects.size; i++) {
+            JGObject o = (JGObject) objects.values[i];
+            if (o == obj) continue;
+            if (!o.is_suspended) {
+                if (cidmask == 0 || (o.colid & cidmask) != 0) {
+                    if (!o.getBBox(obj_bbox)) continue;
+                    if (bbox.intersects(obj_bbox)) {
+                        retcid |= o.colid;
+                    }
+                }
+            }
+        }
+        return retcid;
+    }
+
+
+    public int checkBGCollision(JGRectangle r) {
+        return getTileCid(getTiles(r));
+    }
+
+    public void checkBGCollision(JGEngineInterface eng, int tilecid, int objcid) {
+        if (in_parallel_upd) throw new JGameError("Recursive call", true);
+        in_parallel_upd = true;
+        if (objects.size > srcobj.length) {
+            // grow arrays to make objects fit
+            srcobj = new JGObject[objects.size + 50];
+        }
+        int srcsize = 0;
+        JGRectangle r = tmprect1;
+        /* get all matching objects */
+        for (int i = 0; i < objects.size; i++) {
+            JGObject o = (JGObject) objects.values[i];
+            if (o.is_suspended) continue;
+            if (!o.getTileBBox(r)) continue;
+            if ((o.colid & objcid) != 0) {
+                srcobj[srcsize++] = o;
+            }
+        }
+        /* check collision */
+        JGRectangle tiler = tmprect2;
+        for (int i = 0; i < srcsize; i++) {
+            JGObject o = srcobj[i];
+            // tile bbox is always defined
+            o.getTileBBox(r);
+            // fast equivalent of cid=checkBGCollision(r)
+            getTiles(tiler, r);
+            int cid = getTileCid(tiler);
+            if ((cid & tilecid) != 0) {
+                try {
+                    o.hit_bg(cid);
+                    o.hit_bg(cid, tiler.x, tiler.y, tiler.width, tiler.height);
+                    // XXX this might be slow, check its performance
+                    for (int y = 0; y < tiler.height; y++) {
+                        for (int x = 0; x < tiler.width; x++) {
+                            int thiscid = getTileCid(tiler.x + x, tiler.y + y);
+                            if ((thiscid & tilecid) != 0)
+                                o.hit_bg(thiscid, tiler.x + x, tiler.y + y);
+                        }
+                    }
+                } catch (JGameError ex) {
+                    eng.exitEngine(eng.dbgExceptionToString(ex));
+                } catch (Exception ex) {
+                    eng.dbgShowException(o.getName(), ex);
+                }
+            }
+        }
+        flushRemoveList();
+        in_parallel_upd = false;
+    }
+
+
+    /* objects from engine */
+
+
+    public Vector getObjects(String prefix, int cidmask, boolean suspended_obj,
+                             JGRectangle bbox) {
+        Vector objects_v = new Vector(50, 100);
+        int nr_obj = 0;
+        JGRectangle obj_bbox = tmprect1;
+        int firstidx = getFirstObjectIndex(prefix);
+        int lastidx = getLastObjectIndex(prefix);
+        for (int i = firstidx; i < lastidx; i++) {
+            JGObject obj = (JGObject) objects.values[i];
+            if (cidmask == 0 || (obj.colid & cidmask) != 0) {
+                if (suspended_obj || !obj.is_suspended) {
+                    if (bbox != null) {
+                        if (!obj.getBBox(obj_bbox)) continue;
+                        if (bbox.intersects(obj_bbox)) {
+                            objects_v.addElement(obj);
+                        }
+                    } else {
+                        objects_v.addElement(obj);
+                    }
+                }
+            }
+        }
+        return objects_v;
+    }
+
+
+    public void removeObject(JGObject obj) {
+        if (in_parallel_upd) { // queue remove
+            markRemoveObject(obj);
+        } else { // do remove immediately
+            doRemoveObject(obj);
+        }
+    }
+
+    public void removeObjects(String prefix, int cidmask) {
+        removeObjects(prefix, cidmask, true);
+    }
+
+    public void removeObjects(String prefix, int cidmask, boolean suspended_obj) {
+        if (in_parallel_upd) {
+            markRemoveObjects(prefix, cidmask, suspended_obj);
+        } else {
+            doRemoveObjects(prefix, cidmask, suspended_obj, true);
+        }
+    }
+
+
+    public int countObjects(String prefix, int cidmask) {
+        return countObjects(prefix, cidmask, true);
+    }
+
+    public int countObjects(String prefix, int cidmask, boolean suspended_obj) {
+        int nr_obj = 0;
+        int firstidx = getFirstObjectIndex(prefix);
+        int lastidx = getLastObjectIndex(prefix);
+        for (int i = firstidx; i < lastidx; i++) {
+            JGObject obj = (JGObject) objects.values[i];
+            if (cidmask == 0 || (obj.colid & cidmask) != 0) {
+                if (suspended_obj || !obj.is_suspended) {
+                    nr_obj++;
+                }
+            }
+        }
+        return nr_obj;
+    }
+
+
+    int getFirstObjectIndex(String prefix) {
+        if (prefix == null) return 0;
+        int firstidx = objects.get(prefix);
+        if (firstidx < 0) firstidx = -1 - firstidx;
+        return firstidx;
+    }
+
+    int getLastObjectIndex(String prefix) {
+        if (prefix == null) return objects.size;
+        // XXX theoretically there may be strings with prefix
+        // lexicographically below this one
+        return -1 - objects.get(prefix + '\uffff');
+    }
+
+
+    /**
+     * Do final update actions on objects after all frame updates finished.
+     * Protected.
+     */
+    public void frameFinished() {
+        for (int i = 0; i < objects.size; i++) {
+            ((JGObject) objects.values[i]).frameFinished();
+        }
+    }
+
+    /*====== BG/tiles ======*/
+
+    /**
+     * Repaint those parts of BG which are undefined according to bg_defined.
+     * Handles wraparound if applicable.  If wraparound is on, xofs and yofs
+     * may be any value.
+     */
+    public void repaintBG(JGEngineInterface eng) {
+        if (bg_defined == null) return;
+        // first, convert tilechangedmap entries to bg_defined entries. Note
+        // that one tilechanged may result in multiple bg undefineds, in case
+        // the playfield is smaller than viewnrtiles+3.
 //		for (int x=0; x<viewnrtilesx+3; x++) {
 //			int xi = x + tilexofs;
 //			// check if out of playfield bounds, only needed if not wrapping.
@@ -1219,211 +1359,214 @@ public class EngineLogic {
 //				bg_defined[xi_mod][yi_mod]=false;
 //			}
 //		}
-		int nrtilesdrawn=0;
-		// The pre-draw area is the 1-tile thick space surrounding the visible
-		// area, which does not really need to be drawn.  It is used to
-		// pre-draw tiles before they become visible, so that the system can
-		// draw tiles a few at a time when scrolling slowly.  Otherwise it
-		// would have to wait for the view offset to cross a tile boundary, at
-		// which point it would have to draw a whole row/column of tiles at a
-		// time.
-		//int nrpredrawtilesdrawn=0;
-		// The pre-draw quota is the number of tiles that the system should
-		// draw in the pre-draw area when it has nothing to do.
-		// Upper bound for pre-draw quota is a whole row plus column divided
-		// by 2 (so that the work of a diagonal scroll is split into at least
-		// 2 equal batches).  A better estimate for the optimal quota may be
-		// achieved by estimating the expected scroll speed.  For now we
-		// choose a default of (rows+columns)/5.
-		int maxpredrawtiles = (viewnrtilesx+viewnrtilesy)/5;
-		for (int x=0; x<viewnrtilesx+3; x++) {
-			int xi = x + tilexofs;
-			// check if out of playfield bounds, only needed if not wrapping.
-			if (!pf_wrapx && (xi<0 || xi>=nrtilesx)) continue;
-			int xi_mod = moduloFloor(xi,viewnrtilesx+3);
-			int xi_modpf = xi;
-			if (pf_wrapx) xi_modpf = moduloFloor(xi,nrtilesx);
-			// determine loop bounds for tight loop
-			int ylower = tileyofs;
-			int yupper = tileyofs + viewnrtilesy+3;
-			if (!pf_wrapy) {
-				if (yupper<0) continue;
-				if (ylower<0) ylower=0;
-				if (ylower>nrtilesy) continue;
-				if (yupper>nrtilesy) yupper=nrtilesy; // exclusive bound
-			}
-			int divfactor = viewnrtilesy+3;
-			for (int yi=ylower; yi<yupper; yi++) {
-				// check if out of playfield bounds: already done
-				//if (!pf_wrapy && (yi<0 || yi>=nrtilesy)) continue;
-				// check if already defined
-				//int yi_mod = moduloFloor(yi,divfactor);
-				// version with moduloFloor inlined
-				int yi_mod = (yi>=0) ? yi%divfactor
-								     : divfactor-1 - ((-1-yi)%divfactor);
-				if (bg_defined[xi_mod][yi_mod]) continue;
-				int yi_modpf = yi;
-				if (pf_wrapy) yi_modpf = moduloFloor(yi,nrtilesy);
-				//&&  !tilechangedmap[xi_modpf][yi_modpf]) continue;
-				int y = yi - tileyofs;
-				if (x==0||y==0 || x==viewnrtilesx+2 || y==viewnrtilesy+2){
-					// tile is inside the pre-draw area.
-					// don't draw if we already reached quota.
-					if (nrtilesdrawn > maxpredrawtiles) continue;
-					//nrpredrawtilesdrawn++;
-				}
-				eng.drawTile(xi,yi,tilemap[xi_modpf][yi_modpf]);
-				nrtilesdrawn++;
-				bg_defined[xi_mod][yi_mod]=true;
-				//tilechangedmap[xi_modpf][yi_modpf]=false;
-			}
-		}
-		//System.out.println("Nr. tiles updated: "+nrtilesdrawn);
-	}
-
-
-
-	public void setBGImage(String bgimg, int depth, boolean wrapx,
-	boolean wrapy) {
-		while (bg_images.size() < depth+1) bg_images.addElement(null);
-		if (bgimg!=null) {
-			if (!images.containsKey(bgimg) 
-			&&  !images_orig.containsKey(bgimg))
-				throw new JGameError("unknown BG image "+bgimg);
-			BGImage newimg = new BGImage(bgimg,wrapx,wrapy);
-			bg_images.setElementAt(newimg,depth);
-			if (depth==0) {
-				newimg.xofs = xofs;
-				newimg.yofs = yofs;
-			}
-		} else {
-			bg_images.setElementAt(null,depth);
-		}
-		invalidateBGTiles();
-	}
-
-	/** protected */
-	public void initBGTiles(int nrtilesx,int nrtilesy,String filltile) {
-		this.nrtilesx=nrtilesx;
-		this.nrtilesy=nrtilesy;
-		pfwidth = nrtilesx*tilex;
-		pfheight = nrtilesy*tiley;
-		pfwidth_half = pfwidth/2;
-		pfheight_half = pfheight/2;
-		tilemap = new int [nrtilesx][nrtilesy];
-		tilecidmap = new int [nrtilesx][nrtilesy];
-		//tilechangedmap = new boolean [nrtilesx][nrtilesy];
-		bg_defined = new boolean[viewnrtilesx+3][viewnrtilesy+3];
-		fillBG(filltile);
-		setViewOffset(0,0);
-	}
-
-	/** protected */
-	public void invalidateBGTiles() {
-		if (bg_defined==null) return;
-		for (int x=0; x<viewnrtilesx+3; x++) {
-			for (int y=0; y<viewnrtilesy+3; y++) {
-				bg_defined[x][y]=false;
-			}
-		}
-	}
-
-
-	public void setTileSettings(String out_of_bounds_tile,
-	int out_of_bounds_cid,int preserve_cids) {
-		this.out_of_bounds_tile=out_of_bounds_tile;
-		this.out_of_bounds_cid=out_of_bounds_cid;
-		this.preserve_cids=preserve_cids;
-	}
-
-
-	public void fillBG(String filltile) {
-		for (int y=0; y<nrtilesy; y++) {
-			for (int x=0; x<nrtilesx; x++) {
-				setTile(x,y,filltile);
-			}
-		}
-	}
-
-	public void setTileCid(int x,int y,int and_mask,int or_mask) {
-		// inlined tile out of bounds handling
-		if (pf_wrapx) {
-			x = moduloFloor(x,nrtilesx);
-		} else {
-			if (x<0 || x>=nrtilesx) return;
-		}
-		if (pf_wrapy) {
-			y = moduloFloor(y,nrtilesy);
-		} else {
-			if (y<0 || y>=nrtilesy) return;
-		}
-		tilecidmap[x][y] &= and_mask;
-		tilecidmap[x][y] |= or_mask;
-	}
-
-	public void setTile(int x,int y,String tilestr) {
-		// inlined tile out of bounds handling
-		int x_mod=x,y_mod=y;
-		if (pf_wrapx) {
-			x_mod = moduloFloor(x,nrtilesx);
-		} else {
-			if (x<0 || x>=nrtilesx) return;
-		}
-		if (pf_wrapy) {
-			y_mod = moduloFloor(y,nrtilesy);
-		} else {
-			if (y<0 || y>=nrtilesy) return;
-		}
-		int tileid = tileStrToID(tilestr);
-		tilemap[x_mod][y_mod] = tileid;
-		tilecidmap[x_mod][y_mod] &= preserve_cids;
-		tilecidmap[x_mod][y_mod] |= tileintToCid(tileid);
-		// invalidate tile, to be redrawn later
-		// new method of invalidating tile; the tilechanged flag is picked
-		// up by repaintBG.
-		//tilechangedmap[x_mod][y_mod] = true;
-
-		// update bg_defined
-		// check if we are in view
-		// XXX for pf_wrap we also need to modulo tilex/yofs and reverse
-		// bounds if necessary.  For now we just invalidate too many tiles.
-		if (!pf_wrapx) 
-			if (x_mod < tilexofs || x_mod >= tilexofs + viewnrtilesx+3) return;
-		if (!pf_wrapy) 
-			if (y_mod < tileyofs || y_mod >= tileyofs + viewnrtilesy+3) return;
-		// find offset in bg
-		//int x_mod_bg = moduloFloor(x,viewnrtilesx+3);
-		//int y_mod_bg = moduloFloor(y,viewnrtilesy+3);
-		// version with moduloFloor inlined
-		int x_mod_bg = (x >= 0) ? x%(viewnrtilesx+3)
-								: viewnrtilesx+2 - ((-1-x)%(viewnrtilesx+3));
-		int y_mod_bg = (y >= 0) ? y%(viewnrtilesy+3)
-								: viewnrtilesy+2 - ((-1-y)%(viewnrtilesy+3));
-		// in case we wrap and bg is larger than pf, ensure we are within
-		// 0 < x_mod_bg < nrtilesx
-		if (x_mod_bg >= nrtilesx) x_mod_bg -= nrtilesx;
-		if (y_mod_bg >= nrtilesy) y_mod_bg -= nrtilesy;
-		// invalidate tile
-		bg_defined[x_mod_bg][y_mod_bg]=false;
-		// see if we need to undefine multiple tiles, in case of wrap-around
-		// and playfield size smaller than bg size
-		boolean do_doubley=false;
-		if (pf_wrapx) {
-			if (viewnrtilesx+3 - nrtilesx > x_mod_bg) {
-				bg_defined[x_mod_bg+nrtilesx][y_mod_bg]=false;
-				if (pf_wrapy) {
-					if (viewnrtilesy+3 - nrtilesy > y_mod_bg) {
-						bg_defined[x_mod_bg+nrtilesx][y_mod_bg+nrtilesy]=false;
-						do_doubley=true;
-					}
-				}
-			}
-		}
-		if (do_doubley) {
-			bg_defined[x_mod_bg][y_mod_bg+nrtilesy]=false;
-		}
-		// old routine, which finds whether it's in the viewport but fails to
-		// easily find the appropriate bg_defined entry
+        int nrtilesdrawn = 0;
+        // The pre-draw area is the 1-tile thick space surrounding the visible
+        // area, which does not really need to be drawn.  It is used to
+        // pre-draw tiles before they become visible, so that the system can
+        // draw tiles a few at a time when scrolling slowly.  Otherwise it
+        // would have to wait for the view offset to cross a tile boundary, at
+        // which point it would have to draw a whole row/column of tiles at a
+        // time.
+        //int nrpredrawtilesdrawn=0;
+        // The pre-draw quota is the number of tiles that the system should
+        // draw in the pre-draw area when it has nothing to do.
+        // Upper bound for pre-draw quota is a whole row plus column divided
+        // by 2 (so that the work of a diagonal scroll is split into at least
+        // 2 equal batches).  A better estimate for the optimal quota may be
+        // achieved by estimating the expected scroll speed.  For now we
+        // choose a default of (rows+columns)/5.
+        int maxpredrawtiles = (viewnrtilesx + viewnrtilesy) / 5;
+        for (int x = 0; x < viewnrtilesx + 3; x++) {
+            int xi = x + tilexofs;
+            // check if out of playfield bounds, only needed if not wrapping.
+            if (!pf_wrapx && (xi < 0 || xi >= nrtilesx)) continue;
+            int xi_mod = moduloFloor(xi, viewnrtilesx + 3);
+            int xi_modpf = xi;
+            if (pf_wrapx) xi_modpf = moduloFloor(xi, nrtilesx);
+            // determine loop bounds for tight loop
+            int ylower = tileyofs;
+            int yupper = tileyofs + viewnrtilesy + 3;
+            if (!pf_wrapy) {
+                if (yupper < 0) continue;
+                if (ylower < 0) ylower = 0;
+                if (ylower > nrtilesy) continue;
+                if (yupper > nrtilesy) yupper = nrtilesy; // exclusive bound
+            }
+            int divfactor = viewnrtilesy + 3;
+            for (int yi = ylower; yi < yupper; yi++) {
+                // check if out of playfield bounds: already done
+                //if (!pf_wrapy && (yi<0 || yi>=nrtilesy)) continue;
+                // check if already defined
+                //int yi_mod = moduloFloor(yi,divfactor);
+                // version with moduloFloor inlined
+                int yi_mod = (yi >= 0) ? yi % divfactor
+                        : divfactor - 1 - ((-1 - yi) % divfactor);
+                if (bg_defined[xi_mod][yi_mod]) continue;
+                int yi_modpf = yi;
+                if (pf_wrapy) yi_modpf = moduloFloor(yi, nrtilesy);
+                //&&  !tilechangedmap[xi_modpf][yi_modpf]) continue;
+                int y = yi - tileyofs;
+                if (x == 0 || y == 0 || x == viewnrtilesx + 2 || y == viewnrtilesy + 2) {
+                    // tile is inside the pre-draw area.
+                    // don't draw if we already reached quota.
+                    if (nrtilesdrawn > maxpredrawtiles) continue;
+                    //nrpredrawtilesdrawn++;
+                }
+                eng.drawTile(xi, yi, tilemap[xi_modpf][yi_modpf]);
+                nrtilesdrawn++;
+                bg_defined[xi_mod][yi_mod] = true;
+                //tilechangedmap[xi_modpf][yi_modpf]=false;
+            }
+        }
+        //System.out.println("Nr. tiles updated: "+nrtilesdrawn);
+    }
+
+
+    public void setBGImage(String bgimg, int depth, boolean wrapx,
+                           boolean wrapy) {
+        while (bg_images.size() < depth + 1) bg_images.addElement(null);
+        if (bgimg != null) {
+            if (!images.containsKey(bgimg)
+                    && !images_orig.containsKey(bgimg))
+                throw new JGameError("unknown BG image " + bgimg);
+            BGImage newimg = new BGImage(bgimg, wrapx, wrapy);
+            bg_images.setElementAt(newimg, depth);
+            if (depth == 0) {
+                newimg.xofs = xofs;
+                newimg.yofs = yofs;
+            }
+        } else {
+            bg_images.setElementAt(null, depth);
+        }
+        invalidateBGTiles();
+    }
+
+    /**
+     * protected
+     */
+    public void initBGTiles(int nrtilesx, int nrtilesy, String filltile) {
+        this.nrtilesx = nrtilesx;
+        this.nrtilesy = nrtilesy;
+        pfwidth = nrtilesx * tilex;
+        pfheight = nrtilesy * tiley;
+        pfwidth_half = pfwidth / 2;
+        pfheight_half = pfheight / 2;
+        tilemap = new int[nrtilesx][nrtilesy];
+        tilecidmap = new int[nrtilesx][nrtilesy];
+        //tilechangedmap = new boolean [nrtilesx][nrtilesy];
+        bg_defined = new boolean[viewnrtilesx + 3][viewnrtilesy + 3];
+        fillBG(filltile);
+        setViewOffset(0, 0);
+    }
+
+    /**
+     * protected
+     */
+    public void invalidateBGTiles() {
+        if (bg_defined == null) return;
+        for (int x = 0; x < viewnrtilesx + 3; x++) {
+            for (int y = 0; y < viewnrtilesy + 3; y++) {
+                bg_defined[x][y] = false;
+            }
+        }
+    }
+
+
+    public void setTileSettings(String out_of_bounds_tile,
+                                int out_of_bounds_cid, int preserve_cids) {
+        this.out_of_bounds_tile = out_of_bounds_tile;
+        this.out_of_bounds_cid = out_of_bounds_cid;
+        this.preserve_cids = preserve_cids;
+    }
+
+
+    public void fillBG(String filltile) {
+        for (int y = 0; y < nrtilesy; y++) {
+            for (int x = 0; x < nrtilesx; x++) {
+                setTile(x, y, filltile);
+            }
+        }
+    }
+
+    public void setTileCid(int x, int y, int and_mask, int or_mask) {
+        // inlined tile out of bounds handling
+        if (pf_wrapx) {
+            x = moduloFloor(x, nrtilesx);
+        } else {
+            if (x < 0 || x >= nrtilesx) return;
+        }
+        if (pf_wrapy) {
+            y = moduloFloor(y, nrtilesy);
+        } else {
+            if (y < 0 || y >= nrtilesy) return;
+        }
+        tilecidmap[x][y] &= and_mask;
+        tilecidmap[x][y] |= or_mask;
+    }
+
+    public void setTile(int x, int y, String tilestr) {
+        // inlined tile out of bounds handling
+        int x_mod = x, y_mod = y;
+        if (pf_wrapx) {
+            x_mod = moduloFloor(x, nrtilesx);
+        } else {
+            if (x < 0 || x >= nrtilesx) return;
+        }
+        if (pf_wrapy) {
+            y_mod = moduloFloor(y, nrtilesy);
+        } else {
+            if (y < 0 || y >= nrtilesy) return;
+        }
+        int tileid = tileStrToID(tilestr);
+        tilemap[x_mod][y_mod] = tileid;
+        tilecidmap[x_mod][y_mod] &= preserve_cids;
+        tilecidmap[x_mod][y_mod] |= tileintToCid(tileid);
+        // invalidate tile, to be redrawn later
+        // new method of invalidating tile; the tilechanged flag is picked
+        // up by repaintBG.
+        //tilechangedmap[x_mod][y_mod] = true;
+
+        // update bg_defined
+        // check if we are in view
+        // XXX for pf_wrap we also need to modulo tilex/yofs and reverse
+        // bounds if necessary.  For now we just invalidate too many tiles.
+        if (!pf_wrapx)
+            if (x_mod < tilexofs || x_mod >= tilexofs + viewnrtilesx + 3) return;
+        if (!pf_wrapy)
+            if (y_mod < tileyofs || y_mod >= tileyofs + viewnrtilesy + 3) return;
+        // find offset in bg
+        //int x_mod_bg = moduloFloor(x,viewnrtilesx+3);
+        //int y_mod_bg = moduloFloor(y,viewnrtilesy+3);
+        // version with moduloFloor inlined
+        int x_mod_bg = (x >= 0) ? x % (viewnrtilesx + 3)
+                : viewnrtilesx + 2 - ((-1 - x) % (viewnrtilesx + 3));
+        int y_mod_bg = (y >= 0) ? y % (viewnrtilesy + 3)
+                : viewnrtilesy + 2 - ((-1 - y) % (viewnrtilesy + 3));
+        // in case we wrap and bg is larger than pf, ensure we are within
+        // 0 < x_mod_bg < nrtilesx
+        if (x_mod_bg >= nrtilesx) x_mod_bg -= nrtilesx;
+        if (y_mod_bg >= nrtilesy) y_mod_bg -= nrtilesy;
+        // invalidate tile
+        bg_defined[x_mod_bg][y_mod_bg] = false;
+        // see if we need to undefine multiple tiles, in case of wrap-around
+        // and playfield size smaller than bg size
+        boolean do_doubley = false;
+        if (pf_wrapx) {
+            if (viewnrtilesx + 3 - nrtilesx > x_mod_bg) {
+                bg_defined[x_mod_bg + nrtilesx][y_mod_bg] = false;
+                if (pf_wrapy) {
+                    if (viewnrtilesy + 3 - nrtilesy > y_mod_bg) {
+                        bg_defined[x_mod_bg + nrtilesx][y_mod_bg + nrtilesy] = false;
+                        do_doubley = true;
+                    }
+                }
+            }
+        }
+        if (do_doubley) {
+            bg_defined[x_mod_bg][y_mod_bg + nrtilesy] = false;
+        }
+        // old routine, which finds whether it's in the viewport but fails to
+        // easily find the appropriate bg_defined entry
 		/*if (pf_wrapx) {
 			int bg_x1_mod = moduloFloor(tilexofs-1,nrtilesx);
 			int bg_x2_mod = moduloFloor(tilexofs+viewnrtilesx+2,nrtilesx);
@@ -1448,166 +1591,176 @@ public class EngineLogic {
 			if ((y-tileyofs < -1)
 			||  (y-tileyofs >= viewnrtilesy+2)) return;
 		}*/
-		//System.out.print("/x"+x+"y"+y);
-		// XXX modulo is wrong!
-		//x = moduloFloor(x+1, viewnrtilesx+3);
-		//y = moduloFloor(y+1, viewnrtilesy+3);
-		//System.out.print(" x"+x+"y"+y);
-		//bg_defined[x][y] = false;
-		// XXX these are not yet adapted to wraparound
-		// XXX this routine does not work for scrolling!
-		//if ((x-tilexofs < 0)
-		//||  (x-tilexofs >= viewnrtilesx+3) ) return;
-		//if ((y-tileyofs < 0)
-		//||  (y-tileyofs >= viewnrtilesy+3)) return;
-		//drawTile(x,y,tileid);
-	}
-
-
-
-	public int countTiles(int tilecidmask) {
-		int count=0;
-		for (int x=0; x<nrtilesx; x++) {
-			for (int y=0; y<nrtilesy; y++) {
-				if ( (tilecidmap[x][y]&tilecidmask) != 0) count++;
-			}
-		}
-		return count;
-	}
-
-	public int getTileCid(int xidx,int yidx) {
-		if (pf_wrapx) {
-			xidx = moduloFloor(xidx,nrtilesx);
-		} else {
-			if (xidx<0 || xidx>=nrtilesx) return out_of_bounds_cid;
-		}
-		if (pf_wrapy) {
-			yidx = moduloFloor(yidx,nrtilesy);
-		} else {
-			if (yidx<0 || yidx>=nrtilesy) return out_of_bounds_cid;
-		}
-		return tilecidmap[xidx][yidx];
-	}
-
-	public String getTileStr(int xidx,int yidx) {
-		if (pf_wrapx) {
-			xidx = moduloFloor(xidx,nrtilesx);
-		} else {
-			if (xidx<0 || xidx>=nrtilesx) return out_of_bounds_tile;
-		}
-		if (pf_wrapy) {
-			yidx = moduloFloor(yidx,nrtilesy);
-		} else {
-			if (yidx<0 || yidx>=nrtilesy) return out_of_bounds_tile;
-		}
-		return tileIDToStr(tilemap[xidx][yidx]);
-	}
-
-	public int getTileCid(JGRectangle tiler) {
-		int cid=0;
-		for (int x=tiler.x; x<tiler.x+tiler.width; x++)
-			for (int y=tiler.y; y<tiler.y+tiler.height; y++)
-				cid |= getTileCid(x,y);
-		return cid;
-	}
-
-	private int tilestrToCid(String tilestr) {
-		if (tilestr==null || tilestr.length()==0) return 0;
-		Integer tileid = (Integer)
-			images_tilecid.get( new Integer(tileStrToID(tilestr)) );
-		if (tileid==null) {
-			System.out.println("Warning: unknown tile '"+tilestr+"'.");
-			// XXX no reference to dbg
-			//dbgPrint("MAIN","Warning: unknown tile '"+tilestr+"'.");
-			return 0;
-		}
-		return tileid.intValue();
-	}
-
-	private int tileintToCid(int tileint) {
-		if (tileint==0) return 0;
-		Integer tileid = (Integer)
-			images_tilecid.get( new Integer(tileint) );
-		if (tileid==null) {
-			System.out.println("Warning: unknown tile '"+tileint+"'.");
-			// XXX no reference to dbg
-			//dbgPrint("MAIN","Warning: unknown tile '"+tileint+"'.");
-			return 0;
-		}
-		return tileid.intValue();
-	}
-
-	/** Convert tile name to integer ID code (as used internally).  The ID
-	 * code basically encodes the four characters of the string into the bytes
-	 * of the four-byte integer.  The ID code is NOT related to the collision
-	 * ID (CID).
-	* @param tilestr tilename, null or empty string -&gt; ID = 0 */
-	public int tileStrToID(String tilestr) {
-		if (tilestr==null) return 0;
-		switch (tilestr.length()) {
-			case 0: return 0;
-			case 1: return (int)tilestr.charAt(0);
-			case 2: return (int)tilestr.charAt(0)
-			             + (int)tilestr.charAt(1)*256;
-			case 3: return (int)tilestr.charAt(0)
-			             + (int)tilestr.charAt(1)*256
-			             + (int)tilestr.charAt(2)*256*256;
-			case 4: return (int)tilestr.charAt(0)
-			             + (int)tilestr.charAt(1)*256
-			             + (int)tilestr.charAt(2)*256*256
-			             + (int)tilestr.charAt(3)*256*256*256;
-			default:
-				System.out.println(
-					"Warning: string '"+tilestr+" has wrong size.");
-				// XXX no reference to dbg
-				//dbgPrint("Warning: string '"+tilestr+" has wrong size.");
-				return 0;
-		}
-	}
-
-	/** Convert tile ID code to tile name (as used internally).  The ID
-	 * code basically encodes the four characters of the string into the bytes
-	 * of the four-byte integer.  The ID code is NOT related to the collision
-	 * ID (CID).
-	* @param tilestr tile ID, tileid==0 -&gt; tilename = empty string */
-	public String tileIDToStr(int tileid) {
-		if (tileid==0) return "";
-		StringBuffer tilestr = new StringBuffer(""+(char)(tileid&255));
-		if (tileid >= 0x100) tilestr.append( (char)((tileid/0x100)&255));
-		if (tileid >= 0x10000) tilestr.append( (char)((tileid/0x10000)&255));
-		if (tileid>=0x1000000) tilestr.append( (char)((tileid/0x1000000)&255));
-		return tilestr.toString();
-	}
-
-	public boolean getTiles(JGRectangle dest,JGRectangle r) {
-		if (r==null) return false;
-		dest.copyFrom(r);
-		convertToTiles(dest,r);
-		return true;
-	}
-
-	void convertToTiles(JGRectangle dest,JGRectangle r) {
-		if (dest.x >= 0) {
-			dest.x /= tilex;
-			dest.width  = 1 - dest.x + (r.x + r.width  - 1) / tilex;
-		} else {
-			dest.x = (dest.x-tilex+1)/tilex;
-			dest.width  = 1 - dest.x + (r.x + r.width  - 1 - tilex+1) / tilex;
-		}
-		if (dest.y >= 0) {
-			dest.y /= tiley;
-			dest.height = 1 - dest.y + (r.y + r.height - 1) / tiley;
-		} else {
-			dest.y = (dest.y-tiley+1)/tiley;
-			dest.height = 1 - dest.y + (r.y + r.height - 1 - tilex+1) / tiley;
-		}
-	}
-
-	public JGRectangle getTiles(JGRectangle r) {
-		if (r==null) return null;
-		JGRectangle tiler = new JGRectangle(r);
-		convertToTiles(tiler,r);
-		return tiler;
+        //System.out.print("/x"+x+"y"+y);
+        // XXX modulo is wrong!
+        //x = moduloFloor(x+1, viewnrtilesx+3);
+        //y = moduloFloor(y+1, viewnrtilesy+3);
+        //System.out.print(" x"+x+"y"+y);
+        //bg_defined[x][y] = false;
+        // XXX these are not yet adapted to wraparound
+        // XXX this routine does not work for scrolling!
+        //if ((x-tilexofs < 0)
+        //||  (x-tilexofs >= viewnrtilesx+3) ) return;
+        //if ((y-tileyofs < 0)
+        //||  (y-tileyofs >= viewnrtilesy+3)) return;
+        //drawTile(x,y,tileid);
+    }
+
+
+    public int countTiles(int tilecidmask) {
+        int count = 0;
+        for (int x = 0; x < nrtilesx; x++) {
+            for (int y = 0; y < nrtilesy; y++) {
+                if ((tilecidmap[x][y] & tilecidmask) != 0) count++;
+            }
+        }
+        return count;
+    }
+
+    public int getTileCid(int xidx, int yidx) {
+        if (pf_wrapx) {
+            xidx = moduloFloor(xidx, nrtilesx);
+        } else {
+            if (xidx < 0 || xidx >= nrtilesx) return out_of_bounds_cid;
+        }
+        if (pf_wrapy) {
+            yidx = moduloFloor(yidx, nrtilesy);
+        } else {
+            if (yidx < 0 || yidx >= nrtilesy) return out_of_bounds_cid;
+        }
+        return tilecidmap[xidx][yidx];
+    }
+
+    public String getTileStr(int xidx, int yidx) {
+        if (pf_wrapx) {
+            xidx = moduloFloor(xidx, nrtilesx);
+        } else {
+            if (xidx < 0 || xidx >= nrtilesx) return out_of_bounds_tile;
+        }
+        if (pf_wrapy) {
+            yidx = moduloFloor(yidx, nrtilesy);
+        } else {
+            if (yidx < 0 || yidx >= nrtilesy) return out_of_bounds_tile;
+        }
+        return tileIDToStr(tilemap[xidx][yidx]);
+    }
+
+    public int getTileCid(JGRectangle tiler) {
+        int cid = 0;
+        for (int x = tiler.x; x < tiler.x + tiler.width; x++)
+            for (int y = tiler.y; y < tiler.y + tiler.height; y++)
+                cid |= getTileCid(x, y);
+        return cid;
+    }
+
+    private int tilestrToCid(String tilestr) {
+        if (tilestr == null || tilestr.length() == 0) return 0;
+        Integer tileid = (Integer)
+                images_tilecid.get(new Integer(tileStrToID(tilestr)));
+        if (tileid == null) {
+            System.out.println("Warning: unknown tile '" + tilestr + "'.");
+            // XXX no reference to dbg
+            //dbgPrint("MAIN","Warning: unknown tile '"+tilestr+"'.");
+            return 0;
+        }
+        return tileid.intValue();
+    }
+
+    private int tileintToCid(int tileint) {
+        if (tileint == 0) return 0;
+        Integer tileid = (Integer)
+                images_tilecid.get(new Integer(tileint));
+        if (tileid == null) {
+            System.out.println("Warning: unknown tile '" + tileint + "'.");
+            // XXX no reference to dbg
+            //dbgPrint("MAIN","Warning: unknown tile '"+tileint+"'.");
+            return 0;
+        }
+        return tileid.intValue();
+    }
+
+    /**
+     * Convert tile name to integer ID code (as used internally).  The ID
+     * code basically encodes the four characters of the string into the bytes
+     * of the four-byte integer.  The ID code is NOT related to the collision
+     * ID (CID).
+     *
+     * @param tilestr tilename, null or empty string -&gt; ID = 0
+     */
+    public int tileStrToID(String tilestr) {
+        if (tilestr == null) return 0;
+        switch (tilestr.length()) {
+            case 0:
+                return 0;
+            case 1:
+                return (int) tilestr.charAt(0);
+            case 2:
+                return (int) tilestr.charAt(0)
+                        + (int) tilestr.charAt(1) * 256;
+            case 3:
+                return (int) tilestr.charAt(0)
+                        + (int) tilestr.charAt(1) * 256
+                        + (int) tilestr.charAt(2) * 256 * 256;
+            case 4:
+                return (int) tilestr.charAt(0)
+                        + (int) tilestr.charAt(1) * 256
+                        + (int) tilestr.charAt(2) * 256 * 256
+                        + (int) tilestr.charAt(3) * 256 * 256 * 256;
+            default:
+                System.out.println(
+                        "Warning: string '" + tilestr + " has wrong size.");
+                // XXX no reference to dbg
+                //dbgPrint("Warning: string '"+tilestr+" has wrong size.");
+                return 0;
+        }
+    }
+
+    /**
+     * Convert tile ID code to tile name (as used internally).  The ID
+     * code basically encodes the four characters of the string into the bytes
+     * of the four-byte integer.  The ID code is NOT related to the collision
+     * ID (CID).
+     *
+     * @param tilestr tile ID, tileid==0 -&gt; tilename = empty string
+     */
+    public String tileIDToStr(int tileid) {
+        if (tileid == 0) return "";
+        StringBuffer tilestr = new StringBuffer("" + (char) (tileid & 255));
+        if (tileid >= 0x100) tilestr.append((char) ((tileid / 0x100) & 255));
+        if (tileid >= 0x10000) tilestr.append((char) ((tileid / 0x10000) & 255));
+        if (tileid >= 0x1000000) tilestr.append((char) ((tileid / 0x1000000) & 255));
+        return tilestr.toString();
+    }
+
+    public boolean getTiles(JGRectangle dest, JGRectangle r) {
+        if (r == null) return false;
+        dest.copyFrom(r);
+        convertToTiles(dest, r);
+        return true;
+    }
+
+    void convertToTiles(JGRectangle dest, JGRectangle r) {
+        if (dest.x >= 0) {
+            dest.x /= tilex;
+            dest.width = 1 - dest.x + (r.x + r.width - 1) / tilex;
+        } else {
+            dest.x = (dest.x - tilex + 1) / tilex;
+            dest.width = 1 - dest.x + (r.x + r.width - 1 - tilex + 1) / tilex;
+        }
+        if (dest.y >= 0) {
+            dest.y /= tiley;
+            dest.height = 1 - dest.y + (r.y + r.height - 1) / tiley;
+        } else {
+            dest.y = (dest.y - tiley + 1) / tiley;
+            dest.height = 1 - dest.y + (r.y + r.height - 1 - tilex + 1) / tiley;
+        }
+    }
+
+    public JGRectangle getTiles(JGRectangle r) {
+        if (r == null) return null;
+        JGRectangle tiler = new JGRectangle(r);
+        convertToTiles(tiler, r);
+        return tiler;
 		/*if (tiler.x >= 0) {
 			tiler.x /= tilex;
 		} else {
@@ -1621,539 +1774,570 @@ public class EngineLogic {
 		tiler.width  = 1 - tiler.x + (r.x + r.width  - 1) / tilex;
 		tiler.height = 1 - tiler.y + (r.y + r.height - 1) / tiley;
 		return tiler;*/
-	}
-
-
-
-
-	/* background methods from engine */
-
-
-	public void setTileCid(int x,int y,int value) {
-		setTileCid(x,y,0,value);
-	}
-
-	public void orTileCid(int x,int y,int or_mask) {
-		setTileCid(x,y,-1,or_mask);
-	}
-
-	public void andTileCid(int x,int y,int and_mask) {
-		setTileCid(x,y,and_mask,0);
-	}
-
-	public void setTile(JGPoint tileidx,String tilename) {
-		setTile(tileidx.x,tileidx.y,tilename);
-	}
-
-	public void setTiles(int xofs,int yofs,String [] tilemap) {
-		for (int y=0; y<tilemap.length; y++) {
-			for (int x=0; x<tilemap[y].length(); x++) {
-				setTile(x+xofs,y+yofs,
-					new String(tilemap[y].substring(x,x+1)) );
-			}
-		}
-	}
-
-	public void setTilesMulti(int xofs,int yofs,String [] tilemap) {
-		for (int y=0; y<tilemap.length; y++) {
-			Vector tokens = tokenizeString(tilemap[y],' ');
-			//StringTokenizer toker = new StringTokenizer(tilemap[y]," ");
-			int x=0;
-			for (Enumeration e=tokens.elements(); e.hasMoreElements(); ) {
-				setTile(x+xofs,y+yofs, (String)e.nextElement());
-				x++;
-			}
-		}
-	}
-
-	public int getTileCidAtCoord(double x,double y) {
-		int xidx = (int)x / tilex;
-		int yidx = (int)y / tiley;
-		return getTileCid(xidx,yidx);
-	}
-	public int getTileCid(JGPoint center, int xofs, int yofs) {
-		return getTileCid(center.x+xofs, center.y+yofs);
-	}
-
-	public String getTileStrAtCoord(double x,double y) {
-		int xidx = (int)x / tilex;
-		int yidx = (int)y / tiley;
-		return getTileStr(xidx,yidx);
-	}
-
-	public String getTileStr(JGPoint center, int xofs, int yofs) {
-		return getTileStr(center.x+xofs, center.y+yofs);
-	}
-
-
-
-
-	public void drawImageString(JGEngineInterface eng,
-	String string, double x, double y, int align,
-	String imgmap, int char_offset, int spacing,boolean pf_relative) {
-		ImageMap map = (ImageMap) imagemaps.get(imgmap);
-		if (map==null) throw new JGameError(
-				"Font image map '"+imgmap+"' not found.",true );
-		if (align==0) {
-			x -= (map.tilex+spacing) * string.length()/2;
-		} else if (align==1) {
-			x -= (map.tilex+spacing) * string.length();
-		}
-		//Image img = map.getScaledImage();
-		StringBuffer lettername_buf = new StringBuffer(imgmap+"# ");
-		int lastchar = lettername_buf.length()-1;
-		String lettername=null;
-		for (int i=0; i<string.length(); i++) {
-			int imgnr = -char_offset+string.charAt(i);
-			//String lettername = imgmap+"#"+string.charAt(i);
-			lettername_buf.setCharAt(lastchar,string.charAt(i));
-			lettername=lettername_buf.toString();
-			if (!existsImage(lettername)) {
-				defineImage(lettername, "FONT", 0,
-					getSubImage(imgmap,imgnr),
-					"-", 0,0,0,0);
-			}
-			JGImage letter = getImage(lettername);
-			eng.drawImage(x,y,lettername,pf_relative);
-			//eng.drawImage(buf_gfx, x,y,lettername,pf_relative);
-			x += map.tilex + spacing;
-		}
-	}
-
-
-
-
-	/*====== math ======*/
-
-	// XXX replace moduloX/YPos by versions without complexity!
-
-	public double moduloXPos(double x) {
-		while (x - xofs_mid > pfwidth_half)  { x -= pfwidth_half*2;  }
-		while (x - xofs_mid < -pfwidth_half) { x += pfwidth_half*2;  }
-		return x;
-	}
-
-	public double moduloYPos(double y) {
-		while (y - yofs_mid > pfheight_half)  { y -= pfheight_half*2;  }
-		while (y - yofs_mid < -pfheight_half) { y += pfheight_half*2;  }
-		return y;
-	}
-
-	/** Div which always rounds downwards, also for negative numbers. It is
-	 * the counterpart of moduloFloor. */
-	public int divFloor(int pos,int div) {
-		return (int)Math.floor((double)pos / (double)div);
-	}
-
-	/** Modulo according to a regular modulo space, resulting in a value
-	 * that is always greater than 0, float version. It is the counterpart
-	 * of divFloor. */
-	public double moduloFloor(double pos,int div) {
-		return pos - div*Math.floor(pos/div);
-	}
-
-	/** Modulo according to a regular modulo space, resulting in a value
-	 * that is always greater than 0. */
-	public int moduloFloor(int pos,int modulo) {
-		//int result;
-		if (pos >= 0) return pos%modulo;
-		return modulo-1 - ((-1-pos)%modulo);
-		//return (modulo - ((-pos)%modulo))%modulo;
-		//System.out.println(pos+" modulo "+modulo+" = "+result);
-		//return result;
-	}
-
-
-	/** The scale methods also take care of wraparound modulo calculations.
-	 * This is only applicable to pf_relative positions.  The modulo semantics
-	 * is that of moduloPos. */
-
-	public int scaleXPos(double x,boolean pf_relative) {
-		if (!pf_relative) {
-			return(int)
-				Math.floor(x_scale_fac * x);
-		} else {
-			if (pf_wrapx) x = moduloXPos(x);
-			return(int)
-				Math.floor(x_scale_fac * x)
-				- xofs_scaled;
-		}
-	}
-
-	public int scaleYPos(double y,boolean pf_relative) {
-		if (!pf_relative) {
-			return(int)
-				Math.floor(y_scale_fac * y);
-		} else {
-			if (pf_wrapy) y = moduloYPos(y);
-			return(int)
-				Math.floor(y_scale_fac * y)
-				- yofs_scaled;
-		}
-	}
-
-	public JGPoint scalePos(double x, double y, boolean pf_relative) {
-		//XXX inline scaleXPos/scaleYPos
-		return new JGPoint(scaleXPos(x,pf_relative),scaleYPos(y,pf_relative));
-	}
-
-	/** returns null if r is null */
-	public JGRectangle scalePos(double x,double y,double width,double height,
-	boolean pf_relative) {
-		// XXX that's a lot of object creation
-		JGPoint topleft = scalePos(x,y,pf_relative);
-		JGPoint botright = scalePos(x+width, y+height, pf_relative);
-		// XXX a rectangle on the wrap border is a singular case
-		// XXX rounding is not pixel-perfect for this case
-		if (botright.x < topleft.x) 
-			botright.x = topleft.x + scaleXPos(width,pf_relative);
-		if (botright.y < topleft.y) 
-			botright.y = topleft.y + scaleYPos(height,pf_relative);
-		return new JGRectangle(topleft.x, topleft.y,
-			botright.x-topleft.x - 1, botright.y-topleft.y - 1);
-	}
-
-	/** returns null if r is null */
-	public JGRectangle scalePos(JGRectangle r, boolean pf_relative) {
-		if (r==null) return null;
-		return scalePos(r.x, r.y, r.width, r.height, pf_relative);
-	}
-
-
-	/* misc */
-
-
-
-	/** Initialise some derived pf dimension variables. Also clears the tile
-	* map if !is_inited.  Clears the resized image cache if is_inited and
-	* is_resizeable.
-	*/
-	public void initPF() {
-		int allowed_width = winwidth + crop_left + crop_right;
-		int allowed_height = winheight + crop_top + crop_bottom;
-		if (!prescale) {
-			// canvas_x/yofs are zero for !prescale, so should x/y_excess be
-			allowed_width = winwidth;
-			allowed_height = winheight;
-		}
-		// calculate scaledtilex/y and width/height according to aspect ratio
-		// constraints
-		scaledtilex = allowed_width / viewnrtilesx;
-		scaledtiley = allowed_height / viewnrtilesy;
-		double aspectratio = (scaledtilex / (double)scaledtiley)
-				/ (tilex / (double)tiley);
-		if (aspectratio < min_aspect) {
-			// y is too large
-			scaledtiley = (int)(scaledtilex / min_aspect);
-		} else if (aspectratio > max_aspect) {
-			// x is too large
-			scaledtilex = (int)(max_aspect * scaledtiley);
-		}
-		width = scaledtilex*viewnrtilesx;
-		height = scaledtiley*viewnrtilesy;
-		if (!prescale) {
-			// for !prescale, set scaledtilex/y to tilex/y
-			scaledtilex = tilex;
-			scaledtiley = tiley;
-		}
-		x_scale_fac = width  / (double)(tilex*viewnrtilesx);
-		y_scale_fac = height / (double)(tiley*viewnrtilesy);
-		min_scale_fac = Math.min( x_scale_fac, y_scale_fac );
-		// now, calculate the offsets. 
-		//if (prescale) {
-			int x_excess = width-winwidth;
-			int y_excess = height-winheight;
-			// balance is a number between -1 (shift left) and 1 (shift right)
-			double xbalance=0,ybalance=0;
-			if (crop_left+crop_right>0 && x_excess>0)
-				xbalance = (crop_right-crop_left)/(crop_left+crop_right);
-			if (crop_top+crop_bottom>0 && y_excess>0)
-				ybalance = (crop_bottom-crop_top)/(crop_top+crop_bottom);
-			canvas_xofs = (int)(-x_excess*(0.5 - 0.5*xbalance));
-			canvas_yofs = (int)(-y_excess*(0.5 - 0.5*ybalance));
-		//} // else use default offsets of 0.0
-		if (!is_inited) {
-			initBGTiles(nrtilesx, nrtilesy, "");
-		} else {
-			if (is_resizeable) {
-				// clear resized images so that they are reconstructed
-				// from images_orig
-				// XXX maybe pre-load images to prevent hiccups?
-				images = new Hashtable();
-			}
-		}
-	}
-
-
-
-	public void setViewOffset(int xofs,int yofs,boolean centered) {
-		if (centered) {
-			xofs -= viewWidth()/2;
-			yofs -= viewHeight()/2;
-		}
-		setPendingViewOffset(xofs,yofs);
-		JGObject.updateEngineSettings();
-	}
-
-	public void setBGImgOffset(int depth, double xofs, double yofs,
-	boolean centered) { 
-		if (centered) {
-			xofs -= viewWidth()/2;
-			yofs -= viewHeight()/2;
-		}
-		if (bg_images.size() < depth) 
-			throw new JGameError("Parallax depth "+depth+" not defined.");
-		BGImage bgimg = (BGImage)bg_images.elementAt(depth);
-		bgimg.xofs = xofs;
-		bgimg.yofs = yofs;
-	}
-
-
-	public void setPFSize(int nrtilesx,int nrtilesy) {
-		initBGTiles(nrtilesx,nrtilesy,"");
-		JGObject.updateEngineSettings();
-	}
-
-	public void setPFWrap(boolean wrapx,boolean wrapy,int shiftx,int shifty) {
-		pf_wrapx = wrapx;
-		pf_wrapy = wrapy;
-		pf_wrapshiftx = shiftx;
-		pf_wrapshifty = shifty;
-		// ensure offset is properly clipped
-		setViewOffset(pendingxofs,pendingyofs,false);
-		calcPFWrapCenter();	
-		JGObject.updateEngineSettings();
-	}
-
-
-	public void setFrameRate(double fps, double maxframeskip) {
-		this.fps = fps;
-		this.maxframeskip = maxframeskip;
-	}
-
-	public void setRenderSettings(int alpha_thresh,JGColor render_bg_col) {
-		this.alpha_thresh=alpha_thresh;
-		this.render_bg_color=render_bg_col;
-	}
-
-
-	public void setOffscreenMargin(int xmargin,int ymargin) {
-		offscreen_margin_x = xmargin;
-		offscreen_margin_y = ymargin;
-	}
-
-	public void setGameSpeed(double speed) {
-		gamespeed = speed + 0.00000000001;
-		JGObject.updateEngineSettings();
-	}
-
-
-
-	/* timers */
-
-	public void removeAllTimers() { timers.removeAllElements(); }
-
-	public void registerTimer(JGTimer timer) { timers.addElement(timer); }
-
-	/** protected */
-	public void tickTimers() {
-		for (int i=timers.size()-1; i>=0; i--) {
-			JGTimer timer = (JGTimer)timers.elementAt(i);
-			if (timer.tick(gamespeed)) {
-				timers.removeElement(timer);
-			}
-		}
-	}
-
-
-
-	/* game state */
-
-	public void setGameState(String state) {
-		boolean already_in_state = inGameStateNextFrame(state);
-		gamestate_nextframe.removeAllElements();
-		gamestate_nextframe.addElement(state);
-		gamestate_new.removeAllElements();
-		if (!already_in_state) gamestate_new.addElement(state);
-	}
-
-	public void addGameState(String state) {
-		if (!inGameStateNextFrame(state)) {
-			gamestate_nextframe.addElement(state);
-			gamestate_new.addElement(state);
-		}
-	}
-
-	public void removeGameState(String state) {
-		gamestate_nextframe.removeElement(state);
-		gamestate_new.removeElement(state);
-	}
-
-	public void clearGameState() { gamestate_nextframe.removeAllElements(); }
-
-
-	public boolean inGameState(String state) {
-		for (int i=gamestate.size()-1; i>=0; i--) {
-			if ( ((String)gamestate.elementAt(i)).equals(state) ) return true;
-		}
-		return false;
-	}
-
-	public boolean inGameStateNextFrame(String state) {
-		for (int i=gamestate_nextframe.size()-1; i>=0; i--) {
-			if ( ((String)gamestate_nextframe.elementAt(i)).equals(state) )
-				return true;
-		}
-		return false;
-	}
-
-
-	/*====== animation ======*/
-
-	public void defineAnimation (String id,
-	String [] frames, double speed) {
-		animations.put(id, new Animation(frames,speed));
-	}
-
-	public void defineAnimation (String id,
-	String [] frames, double speed, boolean pingpong) {
-		animations.put(id, new Animation(frames,speed,pingpong));
-	}
-
-	public Animation getAnimation(String id) {
-		return (Animation) animations.get(id);
-	}
-
-
-	/* computation */
-
-	public boolean and(int value, int mask) {
-		return (value&mask) != 0;
-	}
-
-	public double random(double min, double max) {
-		return min + random.nextDouble()*(max-min);
-	}
-
-	public double random(double min, double max, double interval) {
-		int steps = (int)Math.floor(0.00001 + (max-min)/interval);
-		return min + ( (int)(random.nextDouble()*(steps+0.99)) )*interval;
-	}
-
-	public int random(int min, int max, int interval) {
-		int steps = (max-min)/interval;
-		return min + ( (int)(random.nextDouble()*(steps+0.99)) )*interval;
-	}
-
-	public JGPoint getTileIndex(double x, double y) {
-		return new JGPoint(
-			(int)Math.floor( x / (double)tilex ),
-			(int)Math.floor( y / (double)tiley )  );
-	}
-
-	public JGPoint getTileCoord(int tilex, int tiley) {
-		return new JGPoint( tilex*tileWidth(), tiley*tileHeight() );
-	}
-
-	public JGPoint getTileCoord(JGPoint tileidx) {
-		return new JGPoint( tileidx.x*tileWidth(), tileidx.y*tileHeight() );
-	}
-
-	public double snapToGridX(double x, double gridsnapx) {
-		if (gridsnapx <= 0.0) return x;
-		int xaligned = tilex*(int)
-			Math.floor(((x + tilex/2.0) / (double)tilex));
-		double gridofsx = Math.abs(x - xaligned);
-		if (gridofsx <= gridsnapx+0.0002) return xaligned;
-		return x;
-	}
-
-	public double snapToGridY(double y, double gridsnapy) {
-		if (gridsnapy <= 0.0) return y;
-		int yaligned = tiley*(int)
-			Math.floor(((y + tiley/2.0) / (double)tiley));
-		double gridofsy = Math.abs(y - yaligned);
-		if (gridofsy <= gridsnapy+0.0002) return yaligned;
-		return y;
-	}
-
-	public void snapToGrid(JGPoint p,int gridsnapx,int gridsnapy) {
-		if (gridsnapx==0 && gridsnapy==0) return;
-		int xaligned = tilex*(int)
-			Math.floor(((p.x + tilex/2.0) / (double)tilex));
-		int yaligned = tiley*(int)
-			Math.floor(((p.y + tiley/2.0) / (double)tiley));
-		int gridofsx = Math.abs(p.x - xaligned);
-		int gridofsy = Math.abs(p.y - yaligned);
-		if (gridofsx <= gridsnapx) p.x = xaligned;
-		if (gridofsy <= gridsnapy) p.y = yaligned;
-	}
-
-	public boolean isXAligned(double x,double margin) {
-		if (margin<0) margin=0.0;
-		int xaligned = tilex*(int)(((int)x + tilex/2)
-			/ tilex);
-		return Math.abs(x - xaligned) <= margin+0.00005;
-	}
-
-	public boolean isYAligned(double y,double margin) {
-		if (margin<0) margin=0.0;
-		int yaligned = tiley*(int)(((int)y + tiley/2)
-			/ tiley);
-		return Math.abs(y - yaligned) <= margin+0.00005;
-	}
-
-	public double getXAlignOfs(double x) {
-		int xaligned = tilex*(int)(((int)x + tilex/2)
-			/ tilex);
-		return x - xaligned;
-	}
-
-	public double getYAlignOfs(double y) {
-		int yaligned = tiley*(int)(((int)y + tiley/2)
-			/ tiley);
-		return y - yaligned;
-	}
-
-	// XXX please test these two methods
-
-	public double getXDist(double x1, double x2) {
-		if (pf_wrapx) {
-			double x1mod = moduloFloor(x1,pfwidth);
-			double x2mod = moduloFloor(x2,pfwidth);
-			return Math.min(Math.abs(x1mod-x2mod),
-				Math.abs(x1mod+pfwidth-x2mod) );
-		} else {
-			return Math.abs(x1-x2);
-		}
-	}
-
-	public double getYDist(double y1, double y2) {
-		if (pf_wrapy) {
-			int pfheight = pfheight_half*2;
-			double y1mod = moduloFloor(y1,pfheight);
-			double y2mod = moduloFloor(y2,pfheight);
-			return Math.min(Math.abs(y1mod-y2mod),
-				Math.abs(y1mod+pfheight-y2mod) );
-		} else {
-			return Math.abs(y1-y2);
-		}
-	}
-
-
-	/*=== audio ===*/
-
-	/** clipid -} filename */
-	public Hashtable audioclips = new Hashtable();
-	/** Associate given clipid with a filename.  Files are loaded from the
-	* resource path.  Java 1.2+ supports at least: midi and wav files. */
-
-	public void defineAudioClip(Object pkg_obj,String clipid,String filename) {
-		filename = getAbsolutePath(pkg_obj,filename);
-		audioclips.put(clipid,filename);
-		// XXX we should replace the old clip.
-		//replace requires all old audioclip instances to be deleted.
-	}
+    }
+
+
+
+
+    /* background methods from engine */
+
+
+    public void setTileCid(int x, int y, int value) {
+        setTileCid(x, y, 0, value);
+    }
+
+    public void orTileCid(int x, int y, int or_mask) {
+        setTileCid(x, y, -1, or_mask);
+    }
+
+    public void andTileCid(int x, int y, int and_mask) {
+        setTileCid(x, y, and_mask, 0);
+    }
+
+    public void setTile(JGPoint tileidx, String tilename) {
+        setTile(tileidx.x, tileidx.y, tilename);
+    }
+
+    public void setTiles(int xofs, int yofs, String[] tilemap) {
+        for (int y = 0; y < tilemap.length; y++) {
+            for (int x = 0; x < tilemap[y].length(); x++) {
+                setTile(x + xofs, y + yofs,
+                        tilemap[y].substring(x, x + 1));
+            }
+        }
+    }
+
+    public void setTilesMulti(int xofs, int yofs, String[] tilemap) {
+        for (int y = 0; y < tilemap.length; y++) {
+            Vector tokens = tokenizeString(tilemap[y], ' ');
+            //StringTokenizer toker = new StringTokenizer(tilemap[y]," ");
+            int x = 0;
+            for (Enumeration e = tokens.elements(); e.hasMoreElements(); ) {
+                setTile(x + xofs, y + yofs, (String) e.nextElement());
+                x++;
+            }
+        }
+    }
+
+    public int getTileCidAtCoord(double x, double y) {
+        int xidx = (int) x / tilex;
+        int yidx = (int) y / tiley;
+        return getTileCid(xidx, yidx);
+    }
+
+    public int getTileCid(JGPoint center, int xofs, int yofs) {
+        return getTileCid(center.x + xofs, center.y + yofs);
+    }
+
+    public String getTileStrAtCoord(double x, double y) {
+        int xidx = (int) x / tilex;
+        int yidx = (int) y / tiley;
+        return getTileStr(xidx, yidx);
+    }
+
+    public String getTileStr(JGPoint center, int xofs, int yofs) {
+        return getTileStr(center.x + xofs, center.y + yofs);
+    }
+
+
+    public void drawImageString(JGEngineInterface eng,
+                                String string, double x, double y, int align,
+                                String imgmap, int char_offset, int spacing, boolean pf_relative) {
+        ImageMap map = (ImageMap) imagemaps.get(imgmap);
+        if (map == null) throw new JGameError(
+                "Font image map '" + imgmap + "' not found.", true);
+        if (align == 0) {
+            x -= (map.tilex + spacing) * string.length() / 2;
+        } else if (align == 1) {
+            x -= (map.tilex + spacing) * string.length();
+        }
+        //Image img = map.getScaledImage();
+        StringBuffer lettername_buf = new StringBuffer(imgmap + "# ");
+        int lastchar = lettername_buf.length() - 1;
+        String lettername = null;
+        for (int i = 0; i < string.length(); i++) {
+            int imgnr = -char_offset + string.charAt(i);
+            //String lettername = imgmap+"#"+string.charAt(i);
+            lettername_buf.setCharAt(lastchar, string.charAt(i));
+            lettername = lettername_buf.toString();
+            if (!existsImage(lettername)) {
+                defineImage(lettername, "FONT", 0,
+                        getSubImage(imgmap, imgnr),
+                        "-", 0, 0, 0, 0);
+            }
+            JGImage letter = getImage(lettername);
+            eng.drawImage(x, y, lettername, pf_relative);
+            //eng.drawImage(buf_gfx, x,y,lettername,pf_relative);
+            x += map.tilex + spacing;
+        }
+    }
+
+
+
+
+    /*====== math ======*/
+
+    // XXX replace moduloX/YPos by versions without complexity!
+
+    public double moduloXPos(double x) {
+        while (x - xofs_mid > pfwidth_half) {
+            x -= pfwidth_half * 2;
+        }
+        while (x - xofs_mid < -pfwidth_half) {
+            x += pfwidth_half * 2;
+        }
+        return x;
+    }
+
+    public double moduloYPos(double y) {
+        while (y - yofs_mid > pfheight_half) {
+            y -= pfheight_half * 2;
+        }
+        while (y - yofs_mid < -pfheight_half) {
+            y += pfheight_half * 2;
+        }
+        return y;
+    }
+
+    /**
+     * Div which always rounds downwards, also for negative numbers. It is
+     * the counterpart of moduloFloor.
+     */
+    public int divFloor(int pos, int div) {
+        return (int) Math.floor((double) pos / (double) div);
+    }
+
+    /**
+     * Modulo according to a regular modulo space, resulting in a value
+     * that is always greater than 0, float version. It is the counterpart
+     * of divFloor.
+     */
+    public double moduloFloor(double pos, int div) {
+        return pos - div * Math.floor(pos / div);
+    }
+
+    /**
+     * Modulo according to a regular modulo space, resulting in a value
+     * that is always greater than 0.
+     */
+    public int moduloFloor(int pos, int modulo) {
+        //int result;
+        if (pos >= 0) return pos % modulo;
+        return modulo - 1 - ((-1 - pos) % modulo);
+        //return (modulo - ((-pos)%modulo))%modulo;
+        //System.out.println(pos+" modulo "+modulo+" = "+result);
+        //return result;
+    }
+
+
+    /**
+     * The scale methods also take care of wraparound modulo calculations.
+     * This is only applicable to pf_relative positions.  The modulo semantics
+     * is that of moduloPos.
+     */
+
+    public int scaleXPos(double x, boolean pf_relative) {
+        if (!pf_relative) {
+            return (int)
+                    Math.floor(x_scale_fac * x);
+        } else {
+            if (pf_wrapx) x = moduloXPos(x);
+            return (int)
+                    Math.floor(x_scale_fac * x)
+                    - xofs_scaled;
+        }
+    }
+
+    public int scaleYPos(double y, boolean pf_relative) {
+        if (!pf_relative) {
+            return (int)
+                    Math.floor(y_scale_fac * y);
+        } else {
+            if (pf_wrapy) y = moduloYPos(y);
+            return (int)
+                    Math.floor(y_scale_fac * y)
+                    - yofs_scaled;
+        }
+    }
+
+    public JGPoint scalePos(double x, double y, boolean pf_relative) {
+        //XXX inline scaleXPos/scaleYPos
+        return new JGPoint(scaleXPos(x, pf_relative), scaleYPos(y, pf_relative));
+    }
+
+    /**
+     * returns null if r is null
+     */
+    public JGRectangle scalePos(double x, double y, double width, double height,
+                                boolean pf_relative) {
+        // XXX that's a lot of object creation
+        JGPoint topleft = scalePos(x, y, pf_relative);
+        JGPoint botright = scalePos(x + width, y + height, pf_relative);
+        // XXX a rectangle on the wrap border is a singular case
+        // XXX rounding is not pixel-perfect for this case
+        if (botright.x < topleft.x)
+            botright.x = topleft.x + scaleXPos(width, pf_relative);
+        if (botright.y < topleft.y)
+            botright.y = topleft.y + scaleYPos(height, pf_relative);
+        return new JGRectangle(topleft.x, topleft.y,
+                botright.x - topleft.x - 1, botright.y - topleft.y - 1);
+    }
+
+    /**
+     * returns null if r is null
+     */
+    public JGRectangle scalePos(JGRectangle r, boolean pf_relative) {
+        if (r == null) return null;
+        return scalePos(r.x, r.y, r.width, r.height, pf_relative);
+    }
+
+
+    /* misc */
+
+
+    /**
+     * Initialise some derived pf dimension variables. Also clears the tile
+     * map if !is_inited.  Clears the resized image cache if is_inited and
+     * is_resizeable.
+     */
+    public void initPF() {
+        int allowed_width = winwidth + crop_left + crop_right;
+        int allowed_height = winheight + crop_top + crop_bottom;
+        if (!prescale) {
+            // canvas_x/yofs are zero for !prescale, so should x/y_excess be
+            allowed_width = winwidth;
+            allowed_height = winheight;
+        }
+        // calculate scaledtilex/y and width/height according to aspect ratio
+        // constraints
+        scaledtilex = allowed_width / viewnrtilesx;
+        scaledtiley = allowed_height / viewnrtilesy;
+        double aspectratio = (scaledtilex / (double) scaledtiley)
+                / (tilex / (double) tiley);
+        if (aspectratio < min_aspect) {
+            // y is too large
+            scaledtiley = (int) (scaledtilex / min_aspect);
+        } else if (aspectratio > max_aspect) {
+            // x is too large
+            scaledtilex = (int) (max_aspect * scaledtiley);
+        }
+        width = scaledtilex * viewnrtilesx;
+        height = scaledtiley * viewnrtilesy;
+        if (!prescale) {
+            // for !prescale, set scaledtilex/y to tilex/y
+            scaledtilex = tilex;
+            scaledtiley = tiley;
+        }
+        x_scale_fac = width / (double) (tilex * viewnrtilesx);
+        y_scale_fac = height / (double) (tiley * viewnrtilesy);
+        min_scale_fac = Math.min(x_scale_fac, y_scale_fac);
+        // now, calculate the offsets.
+        //if (prescale) {
+        int x_excess = width - winwidth;
+        int y_excess = height - winheight;
+        // balance is a number between -1 (shift left) and 1 (shift right)
+        double xbalance = 0, ybalance = 0;
+        if (crop_left + crop_right > 0 && x_excess > 0)
+            xbalance = (crop_right - crop_left) / (crop_left + crop_right);
+        if (crop_top + crop_bottom > 0 && y_excess > 0)
+            ybalance = (crop_bottom - crop_top) / (crop_top + crop_bottom);
+        canvas_xofs = (int) (-x_excess * (0.5 - 0.5 * xbalance));
+        canvas_yofs = (int) (-y_excess * (0.5 - 0.5 * ybalance));
+        //} // else use default offsets of 0.0
+        if (!is_inited) {
+            initBGTiles(nrtilesx, nrtilesy, "");
+        } else {
+            if (is_resizeable) {
+                // clear resized images so that they are reconstructed
+                // from images_orig
+                // XXX maybe pre-load images to prevent hiccups?
+                images = new Hashtable();
+            }
+        }
+    }
+
+
+    public void setViewOffset(int xofs, int yofs, boolean centered) {
+        if (centered) {
+            xofs -= viewWidth() / 2;
+            yofs -= viewHeight() / 2;
+        }
+        setPendingViewOffset(xofs, yofs);
+        JGObject.updateEngineSettings();
+    }
+
+    public void setBGImgOffset(int depth, double xofs, double yofs,
+                               boolean centered) {
+        if (centered) {
+            xofs -= viewWidth() / 2;
+            yofs -= viewHeight() / 2;
+        }
+        if (bg_images.size() < depth)
+            throw new JGameError("Parallax depth " + depth + " not defined.");
+        BGImage bgimg = (BGImage) bg_images.elementAt(depth);
+        bgimg.xofs = xofs;
+        bgimg.yofs = yofs;
+    }
+
+
+    public void setPFSize(int nrtilesx, int nrtilesy) {
+        initBGTiles(nrtilesx, nrtilesy, "");
+        JGObject.updateEngineSettings();
+    }
+
+    public void setPFWrap(boolean wrapx, boolean wrapy, int shiftx, int shifty) {
+        pf_wrapx = wrapx;
+        pf_wrapy = wrapy;
+        pf_wrapshiftx = shiftx;
+        pf_wrapshifty = shifty;
+        // ensure offset is properly clipped
+        setViewOffset(pendingxofs, pendingyofs, false);
+        calcPFWrapCenter();
+        JGObject.updateEngineSettings();
+    }
+
+
+    public void setFrameRate(double fps, double maxframeskip) {
+        this.fps = fps;
+        this.maxframeskip = maxframeskip;
+    }
+
+    public void setRenderSettings(int alpha_thresh, JGColor render_bg_col) {
+        this.alpha_thresh = alpha_thresh;
+        this.render_bg_color = render_bg_col;
+    }
+
+
+    public void setOffscreenMargin(int xmargin, int ymargin) {
+        offscreen_margin_x = xmargin;
+        offscreen_margin_y = ymargin;
+    }
+
+    public void setGameSpeed(double speed) {
+        gamespeed = speed + 0.00000000001;
+        JGObject.updateEngineSettings();
+    }
+
+
+
+    /* timers */
+
+    public void removeAllTimers() {
+        timers.removeAllElements();
+    }
+
+    public void registerTimer(JGTimer timer) {
+        timers.addElement(timer);
+    }
+
+    /**
+     * protected
+     */
+    public void tickTimers() {
+        for (int i = timers.size() - 1; i >= 0; i--) {
+            JGTimer timer = (JGTimer) timers.elementAt(i);
+            if (timer.tick(gamespeed)) {
+                timers.removeElement(timer);
+            }
+        }
+    }
+
+
+
+    /* game state */
+
+    public void setGameState(String state) {
+        boolean already_in_state = inGameStateNextFrame(state);
+        gamestate_nextframe.removeAllElements();
+        gamestate_nextframe.addElement(state);
+        gamestate_new.removeAllElements();
+        if (!already_in_state) gamestate_new.addElement(state);
+    }
+
+    public void addGameState(String state) {
+        if (!inGameStateNextFrame(state)) {
+            gamestate_nextframe.addElement(state);
+            gamestate_new.addElement(state);
+        }
+    }
+
+    public void removeGameState(String state) {
+        gamestate_nextframe.removeElement(state);
+        gamestate_new.removeElement(state);
+    }
+
+    public void clearGameState() {
+        gamestate_nextframe.removeAllElements();
+    }
+
+
+    public boolean inGameState(String state) {
+        for (int i = gamestate.size() - 1; i >= 0; i--) {
+            if (((String) gamestate.elementAt(i)).equals(state)) return true;
+        }
+        return false;
+    }
+
+    public boolean inGameStateNextFrame(String state) {
+        for (int i = gamestate_nextframe.size() - 1; i >= 0; i--) {
+            if (((String) gamestate_nextframe.elementAt(i)).equals(state))
+                return true;
+        }
+        return false;
+    }
+
+
+    /*====== animation ======*/
+
+    public void defineAnimation(String id,
+                                String[] frames, double speed) {
+        animations.put(id, new Animation(frames, speed));
+    }
+
+    public void defineAnimation(String id,
+                                String[] frames, double speed, boolean pingpong) {
+        animations.put(id, new Animation(frames, speed, pingpong));
+    }
+
+    public Animation getAnimation(String id) {
+        return (Animation) animations.get(id);
+    }
+
+
+    /* computation */
+
+    public boolean and(int value, int mask) {
+        return (value & mask) != 0;
+    }
+
+    public double random(double min, double max) {
+        return min + random.nextDouble() * (max - min);
+    }
+
+    public double random(double min, double max, double interval) {
+        int steps = (int) Math.floor(0.00001 + (max - min) / interval);
+        return min + ((int) (random.nextDouble() * (steps + 0.99))) * interval;
+    }
+
+    public int random(int min, int max, int interval) {
+        int steps = (max - min) / interval;
+        return min + ((int) (random.nextDouble() * (steps + 0.99))) * interval;
+    }
+
+    public JGPoint getTileIndex(double x, double y) {
+        return new JGPoint(
+                (int) Math.floor(x / (double) tilex),
+                (int) Math.floor(y / (double) tiley));
+    }
+
+    public JGPoint getTileCoord(int tilex, int tiley) {
+        return new JGPoint(tilex * tileWidth(), tiley * tileHeight());
+    }
+
+    public JGPoint getTileCoord(JGPoint tileidx) {
+        return new JGPoint(tileidx.x * tileWidth(), tileidx.y * tileHeight());
+    }
+
+    public double snapToGridX(double x, double gridsnapx) {
+        if (gridsnapx <= 0.0) return x;
+        int xaligned = tilex * (int)
+                Math.floor(((x + tilex / 2.0) / (double) tilex));
+        double gridofsx = Math.abs(x - xaligned);
+        if (gridofsx <= gridsnapx + 0.0002) return xaligned;
+        return x;
+    }
+
+    public double snapToGridY(double y, double gridsnapy) {
+        if (gridsnapy <= 0.0) return y;
+        int yaligned = tiley * (int)
+                Math.floor(((y + tiley / 2.0) / (double) tiley));
+        double gridofsy = Math.abs(y - yaligned);
+        if (gridofsy <= gridsnapy + 0.0002) return yaligned;
+        return y;
+    }
+
+    public void snapToGrid(JGPoint p, int gridsnapx, int gridsnapy) {
+        if (gridsnapx == 0 && gridsnapy == 0) return;
+        int xaligned = tilex * (int)
+                Math.floor(((p.x + tilex / 2.0) / (double) tilex));
+        int yaligned = tiley * (int)
+                Math.floor(((p.y + tiley / 2.0) / (double) tiley));
+        int gridofsx = Math.abs(p.x - xaligned);
+        int gridofsy = Math.abs(p.y - yaligned);
+        if (gridofsx <= gridsnapx) p.x = xaligned;
+        if (gridofsy <= gridsnapy) p.y = yaligned;
+    }
+
+    public boolean isXAligned(double x, double margin) {
+        if (margin < 0) margin = 0.0;
+        int xaligned = tilex * (int) (((int) x + tilex / 2)
+                / tilex);
+        return Math.abs(x - xaligned) <= margin + 0.00005;
+    }
+
+    public boolean isYAligned(double y, double margin) {
+        if (margin < 0) margin = 0.0;
+        int yaligned = tiley * (int) (((int) y + tiley / 2)
+                / tiley);
+        return Math.abs(y - yaligned) <= margin + 0.00005;
+    }
+
+    public double getXAlignOfs(double x) {
+        int xaligned = tilex * (int) (((int) x + tilex / 2)
+                / tilex);
+        return x - xaligned;
+    }
+
+    public double getYAlignOfs(double y) {
+        int yaligned = tiley * (int) (((int) y + tiley / 2)
+                / tiley);
+        return y - yaligned;
+    }
+
+    // XXX please test these two methods
+
+    public double getXDist(double x1, double x2) {
+        if (pf_wrapx) {
+            double x1mod = moduloFloor(x1, pfwidth);
+            double x2mod = moduloFloor(x2, pfwidth);
+            return Math.min(Math.abs(x1mod - x2mod),
+                    Math.abs(x1mod + pfwidth - x2mod));
+        } else {
+            return Math.abs(x1 - x2);
+        }
+    }
+
+    public double getYDist(double y1, double y2) {
+        if (pf_wrapy) {
+            int pfheight = pfheight_half * 2;
+            double y1mod = moduloFloor(y1, pfheight);
+            double y2mod = moduloFloor(y2, pfheight);
+            return Math.min(Math.abs(y1mod - y2mod),
+                    Math.abs(y1mod + pfheight - y2mod));
+        } else {
+            return Math.abs(y1 - y2);
+        }
+    }
+
+
+    /*=== audio ===*/
+
+    /**
+     * clipid -} filename
+     */
+    public Hashtable audioclips = new Hashtable();
+
+    /**
+     * Associate given clipid with a filename.  Files are loaded from the
+     * resource path.  Java 1.2+ supports at least: midi and wav files.
+     */
+
+    public void defineAudioClip(Object pkg_obj, String clipid, String filename) {
+        filename = getAbsolutePath(pkg_obj, filename);
+        audioclips.put(clipid, filename);
+        // XXX we should replace the old clip.
+        //replace requires all old audioclip instances to be deleted.
+    }
 
 
 }
diff --git a/app/src/main/java/jgame/impl/ImageMap.java b/app/src/main/java/jgame/impl/ImageMap.java
index 452c566..9dd211f 100644
--- a/app/src/main/java/jgame/impl/ImageMap.java
+++ b/app/src/main/java/jgame/impl/ImageMap.java
@@ -1,35 +1,42 @@
 package jgame.impl;
-import jgame.*;
+
+import jgame.JGImage;
+import jgame.JGPoint;
+
 public class ImageMap {
-	JGImage imageutil;
-	public JGImage img;
-	//public Image scaled_img=null;
-	public int xofs,yofs;
-	public int tilex,tiley;
-	public int skipx,skipy;
-	public ImageMap (JGImage imageutil,
-	String imgfile, int xofs,int yofs,
-	int tilex,int tiley, int skipx,int skipy) {
-		this.imageutil=imageutil;
-		img = imageutil.loadImage(imgfile);
-		this.xofs=xofs;
-		this.yofs=yofs;
-		this.tilex=tilex;
-		this.tiley=tiley;
-		this.skipx=skipx;
-		this.skipy=skipy;
-	}
-	//public int getHeight() { return img.getHeight(this); }
-	/** returns null when image was not loaded */
-	public JGPoint getImageCoord(int imgnr) {
-		if (img==null) return null;
-		JGPoint size = img.getSize();
-		int imgs_per_line = (size.x - xofs + skipx) / (tilex+skipx);
-		int ynr = imgnr / imgs_per_line;
-		int xnr = imgnr % imgs_per_line;
-		return new JGPoint(
-			xofs + xnr*(tilex+skipx),
-			yofs + ynr*(tiley+skipy) );
-	}
+    JGImage imageutil;
+    public JGImage img;
+    //public Image scaled_img=null;
+    public int xofs, yofs;
+    public int tilex, tiley;
+    public int skipx, skipy;
+
+    public ImageMap(JGImage imageutil,
+                    String imgfile, int xofs, int yofs,
+                    int tilex, int tiley, int skipx, int skipy) {
+        this.imageutil = imageutil;
+        img = imageutil.loadImage(imgfile);
+        this.xofs = xofs;
+        this.yofs = yofs;
+        this.tilex = tilex;
+        this.tiley = tiley;
+        this.skipx = skipx;
+        this.skipy = skipy;
+    }
+    //public int getHeight() { return img.getHeight(this); }
+
+    /**
+     * returns null when image was not loaded
+     */
+    public JGPoint getImageCoord(int imgnr) {
+        if (img == null) return null;
+        JGPoint size = img.getSize();
+        int imgs_per_line = (size.x - xofs + skipx) / (tilex + skipx);
+        int ynr = imgnr / imgs_per_line;
+        int xnr = imgnr % imgs_per_line;
+        return new JGPoint(
+                xofs + xnr * (tilex + skipx),
+                yofs + ynr * (tiley + skipy));
+    }
 }
 
diff --git a/app/src/main/java/jgame/impl/JGEngineInterface.java b/app/src/main/java/jgame/impl/JGEngineInterface.java
index 4fafd04..26c7f4e 100644
--- a/app/src/main/java/jgame/impl/JGEngineInterface.java
+++ b/app/src/main/java/jgame/impl/JGEngineInterface.java
@@ -1,8 +1,15 @@
 package jgame.impl;
-import jgame.*;
-import jgame.impl.Animation;
+
 import java.util.Vector;
 
+import jgame.JGColor;
+import jgame.JGFont;
+import jgame.JGImage;
+import jgame.JGObject;
+import jgame.JGPoint;
+import jgame.JGRectangle;
+import jgame.JGTimer;
+
 // the dependences we should get rid of
 //import java.awt.Point;
 //import java.awt.Rectangle;
@@ -11,12 +18,14 @@ import java.util.Vector;
 //import java.awt.Color;
 //import java.awt.Cursor;
 
-/** Interface defining all platform-independent methods in JGEngine.  It is
+/**
+ * Interface defining all platform-independent methods in JGEngine.  It is
  * primarily used as an internal interface for JGObjects, JGTimers, etc to the
- * different engine implementations.  */
+ * different engine implementations.
+ */
 public interface JGEngineInterface {
 
-	// backend interface
+    // backend interface
 /*
 	// XXX should not be public
 	public void registerTimer(JGTimer timer);
@@ -88,1487 +97,2011 @@ public interface JGEngineInterface {
 	public Rectangle getImageBBox(String imgname);
 */
 
-	public static final String JGameVersionString = "3.6";
-
-
-	/** Cursor keys for both regular and mobile keyboard. */
-	public static final int KeyUp=38,KeyDown=40,KeyLeft=37,KeyRight=39;
-	/** On a mobile, the cursor control Fire is the same as shift. */
-	public static final int KeyShift=16;
-	/** Fire stands for a mobile key, indicating the fire button of the cursor
-	 * controls.  It is equivalent to KeyShift. */
-	public static final int KeyFire=16;
-	public static final int KeyCtrl=17;
-	public static final int KeyAlt=18;
-	public static final int KeyEsc=27;
-	/** On a mobile, pressing "*" also triggers KeyEnter. */
-	public static final int KeyEnter=10;
-	/** The mobile Star key, equal to '*'. */
-	public static final int KeyStar='*';
-	/** The mobile Pound key, equal to '#'. */
-	public static final int KeyPound='#';
-	public static final int KeyBackspace=8; /* is it different sometimes? */
-	public static final int KeyTab=9;
-	/** Keymap equivalent of mouse button. */
-	public static final int KeyMouse1=256, KeyMouse2=257, KeyMouse3=258;
-
-
-
-	/** Keycode of cursor key. */
-	//public static final int KeyUp=38,KeyDown=40,KeyLeft=37,KeyRight=39;
-	//public static final int KeyShift=16;
-	//public static final int KeyCtrl=17;
-	//public static final int KeyAlt=18;
-	//public static final int KeyEsc=27;
-	//public static final int KeyEnter=10;
-	//public static final int KeyBackspace=127;
-	////public static final int KeyBackspace=KeyEvent.VK_BACK_SPACE;
-	//public static final int KeyTab=8;
-	////public static final int KeyTab=KeyEvent.VK_TAB;
-	/** Keymap equivalent of mouse button. */
-	//public static final int KeyMouse1=256, KeyMouse2=257, KeyMouse3=258;
-
-
-
-	/** Set progress bar position in the load screen.
-	* @param pos  a number between 0 and 1 */
-	public void setProgressBar(double pos);
-
-	/** Set progress message, default "Loading files..." */
-	public void setProgressMessage(String msg);
-
-	/** Set author message, default "JGame [version]"  */
-	public void setAuthorMessage(String msg);
-
-	/* images */
-
-	// public but not in interface
-	//public ImageUtil imageutil = new ImageUtil(this);
-
-
-	/** Gets (scaled) image directly. Is usually not necessary. Returns
-	* null if image is a null image; throws error if image is not defined.  */
-	public JGImage getImage(String imgname);
-
-	/** Gets (non-scaled) image's physical size directly.  The object returned
-	 * may be a reference to an internal variable, do not change it! */
-	public JGPoint getImageSize(String imgname);
-
-	/** If an image with name already exists, it is removed from memory.
-	* @param imgfile  filespec, loaded as resource
-	*/
-	/** Define new sprite/tile image from a file.  If an image with this 
-	* id is already defined, it is removed from any caches, so that the old
-	* image is really unloaded.  This can be used to load large (background)
-	* images on demand, rather than have them all in memory.  Note that the
-	* unloading does not work for images defined from image maps. Defining
-	* an image with the same name and filename twice does not cause the image
-	* to be reloaded, but keeps the old image.
-	*
-	* @param name  image id
-	* @param tilename  tile id (1-4 characters)
-	* @param collisionid  cid to use for tile collision matching
-	* @param imgfile  filespec in resource path; "null" means no file
-	* @param top  collision bounding box dimensions
-	* @param left  collision bounding box dimensions
-	* @param width  collision bounding box dimensions
-	* @param height  collision bounding box dimensions
-	*/
-	public void defineImage(String name, String tilename, int collisionid,
-	String imgfile, String img_op,
-	int top,int left, int width,int height);
-
-	/** Define new image by rotating an already loaded image.  This method
-	 * does not yet work for images defined from image maps! The destination
-	 * image is always a square which is large enough to fit the source image
-	 * at any angle. Its dimension is calculated as: max(width, height,
-	 * 0.75*(width+height)).  The source image is rendered to its center.  
-	 * <p> If an image with this id is already defined,
-	 * it is removed from any caches, so that the old image is really
-	 * unloaded.  This can be used to load large (background) images on
-	 * demand, rather than have them all in memory.  Note that the unloading
-	 * does not work for images defined from image maps.
-	* @param imgname  image id
-	* @param tilename  tile id (1-4 characters)
-	* @param collisionid  cid to use for tile collision matching
-	* @param srcimg image id of (already loaded) source image
-	* @param angle  the angle in radians by which to rotate
-	*/
-	public void defineImageRotated(String imgname, String tilename,
-	int collisionid, String srcimg, double angle);
-
-	/** Define image map, a large image containing a number of smaller images
-	* to use for sprites or fonts.  The images must be in a regularly spaced
-	* matrix.  One may define multiple image maps with the same image but
-	* different matrix specs. 
-	* @param mapname  id of image map
-	* @param imgfile  filespec in resource path
-	* @param xofs  x offset of first image 
-	* @param yofs  y offset of first image
-	* @param tilex  width of an image
-	* @param tiley  height of an image
-	* @param skipx  nr of pixels to skip between successive images
-	* @param skipy  nr of pixels to skip between successive images vertically.
-	*/
-	public void defineImageMap(String mapname, String imgfile,
-	int xofs,int yofs, int tilex,int tiley, int skipx,int skipy);
-
-	/** Gets the collision bounding box of an image. */
-	public JGRectangle getImageBBox(String imgname);
-
-
-	/*====== image from engine ======*/
-
-	/** Define new sprite/tile image from a file, with collision bounding box
-	* equal to the image's dimensions. If an image with this 
-	* id is already defined, it is removed from any caches, so that the old
-	* image is really unloaded.  This can be used to load large (background)
-	* images on demand, rather than have them all in memory.  Note that the
-	* unloading does not work for images defined from image maps. Defining
-	* an image with the same name and filename twice does not cause the image
-	* to be reloaded, but keeps the old image.
-	*
-	* @param imgname  image id
-	* @param tilename  tile id (1-4 characters)
-	* @param collisionid  cid to use for tile collision matching
-	* @param imgfile  filespec in resource path; "null" means no file
-	*/
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgfile, String img_op);
-
-	/** Define new sprite/tile image from map.
-	* @param imgname  image id
-	* @param tilename  tile id (1-4 characters)
-	* @param collisionid  cid to use for tile collision matching
-	* @param imgmap  id of image map
-	* @param mapidx  index of image in map, 0=first
-	* @param top  collision bounding box dimensions
-	* @param left  collision bounding box dimensions
-	* @param width  collision bounding box dimensions
-	* @param height  collision bounding box dimensions
-	*/
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgmap, int mapidx, String img_op,
-	int top,int left, int width,int height);
-
-	/** Define new sprite/tile image from map, with collision bounding box
-	* equal to the image's dimensions.
-	* @param imgname  image id
-	* @param tilename  tile id (1-4 characters)
-	* @param collisionid  cid to use for tile collision matching
-	* @param imgmap  id of image map
-	* @param mapidx  index of image in map, 0=first
-	*/
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgmap, int mapidx, String img_op);
-
-	/** Load a set of imagemap, image, animation, and audio clip definitions
-	* from a file.
-	* The file contains one image / imagemap / animation definition / audio
-	* clip
-	* on each line, with the fields separated by one or more tabs.  Lines not
-	* matching the required number of fields are ignored.
-	* The fields have the same order as in defineImage, defineImageMap, 
-	* defineAnimation, and defineAudioClip. For example:
-	* <p>
-	* <code>defineImage("mytile", "#", 1,"gfx/myimage.gif", "-");</code>
-	* <p>
-	* is equivalent to the following line in the table:
-	* <p>
-	* <code>mytile &nbsp;&nbsp;&nbsp; # &nbsp;&nbsp;&nbsp;  1
-	* &nbsp;&nbsp;&nbsp; gfx/myimage.gif &nbsp;&nbsp;&nbsp; -</code>
-	* <p>
-	* with the whitespace between the fields consisting of one or more tabs.
-	* The defineAnimation methods take an array of names as the second
-	* argument.  This is represented in table format as the names separated by
-	* semicolon ';' characters.  So:
-	* <P>
-	* <code>defineAnimation("anim",new String[]{"frame0","frame1",...},0.5);
-	* </code><p>
-	* is equivalent to:
-	* <p>
-	* <code>anim &nbsp;&nbsp;&nbsp; frame0;frame1;... &nbsp;&nbsp;&nbsp; 0.5
-	* </code>
-	**/
-	public void defineMedia(String filename);
-
-
-
-	/*====== BG/tiles ======*/
-
-
-	/** Set image to display behind transparent tiles.  Image size must be a
-	 * multiple of the tile size. Passing null turns off background image; the
-	 * background colour will be used instead.
-	 * @param bgimg  image name, null=turn off background image */
-	public void setBGImage(String bgimg);
-
-
-	/** Set image to display at a particular parallax scroll level.  Only
-	* some platforms support parallax scrolling.  On other platforms, only the
-	* level 0 image is displayed, with its offset equal to the view
-	* offset.  Level 0 corresponds to the top level; setBGImage(String) is
-	* equivalent to setBGImage(String,0,true,true).   The level 0 image
-	* follows the view offset by default, higher levels are initialised to
-	* offset (0,0) by default.
-	* @param bgimg  image name, null=turn off image at this level
-	* @param depth  depth level, 0=topmost
-	* @param wrapx  image should wrap in x direction
-	* @param wrapy  image should wrap in y direction
-	*/
-	public void setBGImage(int depth, String bgimg,boolean wrapx,boolean wrapy);
-
-
-	/** Define background tile settings.  Default is setBGCidSettings("",0,0).
-	* @param out_of_bounds_tile  tile string to use outside of screen bounds
-	* @param out_of_bounds_cid  cid to use outside of screen boundaries
-	* @param preserve_cids  cid mask to preserve when setting tiles */
-	public void setTileSettings(String out_of_bounds_tile,
-	int out_of_bounds_cid,int preserve_cids);
-
-	/** Fill the background with the given tile.
-	* @param filltile null means use background colour */
-	public void fillBG(String filltile);
-
-
-	/*====== objects from canvas ======*/
-
-	/** Add new object, will become active next frame, do not call directly.
-	* This method is normally called automatically by the JGObject
-	* constructor.  You should not need to call this directly.*/
-	public void markAddObject(JGObject obj);
-
-
-	/** Get object if it exists.
-	*/
-	public boolean existsObject(String index);
-
-	/** Get object if it exists, null if not.
-	*/
-	public JGObject getObject(String index);
-
-	/** Call the move() methods of those objects matching the given name
-	 * prefix and collision id mask.
-	* @param cidmask collision id mask, 0 means ignore
-	* @param prefix  ID prefix, null means ignore  */
-	public void moveObjects(String prefix, int cidmask);
-
-	/** Call the move() methods of all registered objects. */
-	public void moveObjects();
-
-
-
-	/** Calls all colliders of objects that match dstcid that collide with
-	* objects that match srccid.
-	*/
-	public void checkCollision(int srccid,int dstcid);
-
-	/** Checks collision of objects with given cid mask with given object. 
-	* Suspended objects are not counted (same as checkCollision(int,int)).
-	* This method should be a more efficient way to check for object overlap
-	* than getObjects, though it's still not very efficient.
-	* @param cidmask  cid mask of objects to consider, 0 means any
-	* @return the OR of the CIDs of all object overlapping r
-	*/
-	public int checkCollision(int cidmask, JGObject obj);
-
-	/** Check collision of tiles within given rectangle, return the OR of all
-	* cids found.
-	* @param r  bounding box in pixel coordinates
-	*/
-	public int checkBGCollision(JGRectangle r);
-
-	/** Calls all bg colliders of objects that match objid that collide with
-	* tiles that match tileid.
-	*/
-	public void checkBGCollision(int tilecid,int objcid);
-
-	/* objects from engine */
-
-	/** Query the object list for objects matching the given name prefix, CID
-	* mask, and collide with the given bounding box.  If suspended_obj is
-	* true, suspended objects are also included.  The list of objects
-	* returned match all the supplied criteria.  This is an inefficient
-	* method, use sparingly.
-	* @param cidmask collision id mask, 0 means ignore
-	* @param prefix  ID prefix, null means ignore  
-	* @param suspended_obj  also count suspended objects
-	* @param bbox  collision bounding box, null means ignore */
-	public Vector getObjects(String prefix,int cidmask,boolean suspended_obj,
-	JGRectangle bbox);
-
-	/** Remove one particular object. The actual removal is done after the
-	* current moveObjects or check*Collision ends, or immediately if done
-	* from within the main doFrame loop.*/
-	public void removeObject(JGObject obj);
-
-	/** Remove all objects which have the given name prefix and/or match the
-	* given cidmask.  It also removes suspended objects.
-	* The actual matching and removal is done after the
-	* current moveObjects or check*Collision ends, or immediately if done
-	* from within the main doFrame loop.  It also removes any matching
-	* objects which are pending to be added the next frame.  
-	* @param cidmask collision id mask, 0 means ignore
-	* @param prefix  ID prefix, null means ignore  */
-	public void removeObjects(String prefix,int cidmask);
-
-	/** Remove all objects which have the given name prefix and/or match the
-	* given cidmask.  You can specify whether to remove suspended objects or
-	* not.  The actual matching and removal is done after the
-	* current moveObjects or check*Collision ends, or immediately if done
-	* from within the main doFrame loop.  It also removes any matching
-	* objects which are pending to be added the next frame.
-	* @param cidmask collision id mask, 0 means ignore
-	* @param prefix  ID prefix, null means ignore
-	* @param suspended_obj  also count suspended objects */
-	public void removeObjects(String prefix,int cidmask,boolean suspended_obj);
-
-	/** Count how many objects there are with both the given name prefix and
-	* have colid&amp;cidmask != 0.  Either criterion can be left out. 
-	* It also counts suspended objects.  Actually
-	* searches the object array, so it may be inefficient to use it a lot of
-	* times.   
-	* @param cidmask collision id mask, 0 means ignore
-	* @param prefix  ID prefix, null means ignore  */
-	public int countObjects(String prefix,int cidmask);
-
-	/** Count how many objects there are with both the given name prefix and
-	* have colid&amp;cidmask != 0.  Either criterion can be left out.  You can
-	* specify whether to count suspended objects or not.  Actually
-	* searches the object array, so it may be inefficient to use it a lot of
-	* times. 
-	* @param cidmask collision id mask, 0 means ignore
-	* @param prefix  ID prefix, null means ignore  
-	* @param suspended_obj  also count suspended objects */
-	public int countObjects(String prefix,int cidmask,boolean suspended_obj);
-
-
-	/*====== tiles ======*/
-
-	/** Set the cid of a single tile using and and or mask. */
-	public void setTileCid(int x,int y,int and_mask,int or_mask);
-
-	/** Set a single tile.
-	*/
-	public void setTile(int x,int y,String tilestr);
-
-	/** Count number of tiles with given mask. Actually searches all tiles, so
-	 * it's inefficient and should be used sparingly (such as, determine
-	 * the number of something at the beginning of a game). */
-	public int countTiles(int tilecidmask);
-
-	/** Get collision id of tile at given tile index position. Moduloes the
-	* given position if wraparound */
-	public int getTileCid(int xidx,int yidx);
-
-	/** get string id of tile at given index position.
-	* Moduloes the given position if wraparound */
-	public String getTileStr(int xidx,int yidx);
-
-	/** Get the OR of the cids at the tile indexes given by tiler */
-	public int getTileCid(JGRectangle tiler);
-
-	/** Get tile index range of all tiles overlapping given rectangle of pixel
-	* coordinates. 
-	* Get tile position range of all tiles overlapping given rectangle.
-	* Returns null is rectangle is null.
-	* @param r   rectangle in pixel coordinates, null is none
-	* @return  tile indices */
-	public JGRectangle getTiles(JGRectangle r);
-
-	/** Get tile index range of all tiles overlapping given rectangle of pixel
-	* coordinates, version without object creation.
-	* Get tile position range of all tiles overlapping given rectangle.
-	* Returns false is rectangle is null.
-	* @param r   rectangle in pixel coordinates, null is none
-	* @param dest  rectangle to copy tile range into
-	* @return true if rectangle exists, false if null */
-	public boolean getTiles(JGRectangle dest,JGRectangle r);
-
-	/* background methods from engine */
-
-	/** Draw tile directly on background, do not call this
-	 * directly, use setTile instead.  */
-	public void drawTile(int xi,int yi,int tileid);
-
-	/** Set the cid of a single tile to the given value, leaving the actual
-	 * tile. */
-	public void setTileCid(int x,int y,int value);
-
-	/** Modify the cid of a single tile by ORing a bit mask, leaving the actual
-	 * tile. */
-	public void orTileCid(int x,int y,int or_mask);
-
-	/** Modify the cid of a single tile by ANDing a bit mask, leaving the actual
-	 * tile. */
-	public void andTileCid(int x,int y,int and_mask);
-
-	/** Set a single tile.
-	*/
-	public void setTile(JGPoint tileidx,String tilename);
-
-	/** Set a block of tiles according to the single-letter tile names in the
-	* nxm character array tilemap.  
-	*/
-	public void setTiles(int xofs,int yofs,String [] tilemap);
-
-	/** Set a block of tiles according to the tile names in the nxm element
-	* array tilemap.  The tile names may be multiple characters.  Each String
-	* in the tilemap consists of a list of tile names separated by spaces. So:
-	* <code> "x aa ab abc"</code> stands for a sequence of four tiles, "x",
-	* "aa", "ab", and "abc".
-	*/
-	public void setTilesMulti(int xofs,int yofs,String [] tilemap);
-
-	/** Get collision id of the tile at given pixel coordinates.
-	*/
-	public int getTileCidAtCoord(double x,double y);
-
-	/** Get the tile cid of the point that is (xofs,yofs) from the tile index
-	 * coordinate center. */
-	public int getTileCid(JGPoint center, int xofs, int yofs);
-
-	/** Get string id of the tile at given pixel coordinates.
-	*/
-	public String getTileStrAtCoord(double x,double y);
-
-	/** Get the tile string of the point that is (xofs,yofs) from the tile
-	* index coordinate center. */
-	public String getTileStr(JGPoint center, int xofs, int yofs);
-
-	/** Convert tile name to integer ID code (as used internally).  The ID
-	* code basically encodes the four characters of the string into the bytes
-	* of the four-byte integer.  The ID code is NOT related to the collision
-	* ID (CID).
-	* @param tilestr tilename, null or empty string -&gt; ID = 0 */
-	public int tileStrToID(String tilestr);
-
-	/** Convert tile ID code to tile name (as used internally).  The ID
-	 * code basically encodes the four characters of the string into the bytes
-	 * of the four-byte integer.  The ID code is NOT related to the collision
-	 * ID (CID).
-	* @param tileid tile ID, tileid==0 -&gt; tilename = empty string */
-	public String tileIDToStr(int tileid);
-
-	/*====== math ======*/
-
-
-	/** A modulo that moduloes symmetrically, relative to the
-	 * middle of the view.  That is, the returned x/ypos falls within
-	 * -pfwidth/height_half and pfwidth/height_half of x/yofs_mid */
-	public double moduloXPos(double x);
-
-	/** A modulo that moduloes symmetrically, relative to the
-	 * middle of the view.  That is, the returned x/ypos falls within
-	 * -pfwidth/height_half and pfwidth/height_half of x/yofs_mid */
-	public double moduloYPos(double y);
-
-
-	/** Show bounding boxes around the objects: the image bounding box
-	 * (getBBox) , the tile span (getTiles), and the center tiles
-	 * (getCenterTiles).  */
-	public void dbgShowBoundingBox(boolean enabled);
-
-	/** Show the game state in the bottom right corner of the screen. The
-	 * message font and foreground colour are used to draw the text. */
-	public void dbgShowGameState(boolean enabled);
-
-	/** Indicates whether to show full exception stack traces or just the
-	 * first lines.  Default is false.  */
-	public void dbgShowFullStackTrace(boolean enabled);
-
-	/** Output messages on playfield instead of console. Default is true.
-	 * Messages printed by an object are displayed close to that object.
-	 * Messages printed by the main program are shown at the bottom of the
-	 * screen.  The debug message font is used to display the messages.
-	 * <p>A message that is generated in this frame is shown in the foreground
-	 * colour at the appropriate source.  If the source did not generate a
-	 * message, the last printed message remains visible, and is shown in
-	 * debug colour 1.  If an object prints a message, and then dies, the
-	 * message will remain for a period of time after the object is gone.
-	 * These messages are shown in debug colour 2.
-	 */
-	public void dbgShowMessagesInPf(boolean enabled);
-
-	/** Set the number of frames a debug message of a removed object should
-	 * remain on the playfield. */
-	public void dbgSetMessageExpiry(int ticks);
-
-	/** Set the font for displaying debug messages. */
-	public void dbgSetMessageFont(JGFont font);
-
-	/** Set debug color 1, used for printing debug information. */
-	public void dbgSetDebugColor1(JGColor col);
-
-	/** Set debug color 2, used for printing debug information. */
-	public void dbgSetDebugColor2(JGColor col);
-
-
-	/** Print a debug message, with the main program being the source. */
-	public void dbgPrint(String msg);
-
-	/** Print a debug message from a specific source, which is either the main
-	 * program or a JGObject.
-	* @param source  may be object ID or "MAIN" for the main program. */
-	public void dbgPrint(String source,String msg);
-
-	/** Print the relevant information of an exception as a debug message.
-	* @param source  may be object ID or "MAIN" for the main program. */
-	public void dbgShowException(String source, Throwable e);
-
-	/**Convert the relevant information of an exception to a multiline String.*/
-	public String dbgExceptionToString(Throwable e);
-
-	/** Exit, optionally reporting an exit message.  The exit message can be
-	 * used to report fatal errors.  In case of an application or midlet, the
-	 * program exits.  In case of an applet, destroy is called, and the exit
-	 * message is displayed on the playfield.
-	 * @param msg an exit message, null means none */
-	public void exitEngine(String msg);
-
-
-	/** Init engine as component to be embedded in a frame or panel;
-	* call this in your engine constructor.
-	 * @param width  canvas width
-	 * @param height canvas height */
-	public void initEngineComponent(int width,int height);
-
-	/** Init engine as applet; call this in your engine constructor.  Applet
-	 * init() will start the game.
-	 */
-	public void initEngineApplet();
-
-	/** Init engine as application.  Passing (0,0) for width, height will
-	 * result in a full-screen window without decoration.  Passing another
-	 * value results in a regular window with decoration.
-	 * @param width  real screen width, 0 = use screen size
-	 * @param height real screen height, 0 = use screen size */
-	public void initEngine(int width,int height);
-
-	/** Set canvas dimensions and message colours/fonts.  You must call this
-	 * in initCanvas().
-	 * @param nrtilesx  nr of tiles horizontally
-	 * @param nrtilesy  nr of tiles vertically
-	 * @param tilex  width of one tile
-	 * @param tiley  height of one tile
-	 * @param fgcolor pen/text colour, null for default white
-	 * @param bgcolor background colour, null for default black
-	 * @param msgfont font for messages and text drawing, null for default */
-	public void setCanvasSettings(int nrtilesx,int nrtilesy,int tilex,int tiley,
-	JGColor fgcolor, JGColor bgcolor, JGFont msgfont);
-
-	/** Set scaling preferences for translating the virtual playfield to the
-	 * actual display. You can only call this in initCanvas().
-	 * You can set the allowed aspect ratio and the crop margin here.
-	 * Aspect ratio is defined as
-	 * the ratio (actual_tile_width / actual_tile_height)
-	 * / (virtual_tile_width / virtual_tile_height).  So, if the tile size of
-	 * the scaled display is (3,2) pixels, and the original was (4,4) pixels,
-	 * the aspect ratio is 1.5.  Default values for min_aspect_ratio and
-	 * max_aspect_ratio are resp 0.75 and 1.333. Setting both to 1.0 means
-	 * you always get a square aspect ratio.
-	 * <P>
-	 * Crop margin can be used if you wish to allow the scaling algorithm to
-	 * take just a few pixels off your playfield in order to make a wider tile
-	 * size fit.  The tile size is always integer,
-	 * so even a best-fit scaled tile size may leave an unused border around
-	 * the playfield, which may be undesirable for small screens.
-	 * Cropping just a few pixels off the playfield may be just
-	 * enough to make the tiles 1 pixel larger.  	 
-	 * Setting a crop to a value greater than zero means you
-	 * allow the playfield to fall off the canvas for the amount of actual
-	 * pixels specified, in order to make a larger tile size fit.  
-	 * Default crop margin is 0.
-	 * <P>
-	 *
-	 * @param min_aspect_ratio minimum width:height ratio allowed
-	 * @param max_aspect_ratio maximum width:height ratio allowed
-	 * @param crop_top number of pixels to crop at top
-	 * @param crop_left number of pixels to crop at left size
-	 * @param crop_bottom number of pixels to crop at bottom
-	 * @param crop_right number of pixels to crop at right size
-	 */
-	public void setScalingPreferences(double min_aspect_ratio, double
-	max_aspect_ratio,int crop_top,int crop_left,int crop_bottom,int crop_right);
-
-	/** Magnification can be set to smooth or blocky.  For platforms that
-	 * enable smooth magnification (OpenGL), smoothing may look too blurry when
-	 * magnifying by a large amount, so blocky magnification may actually look
-	 * more charming.
-	 * @param smooth_magnify smooth images when magnifying
-	 */
-	public void setSmoothing(boolean smooth_magnify);
-
-	/** Call this to get focus. */
-	public void requestGameFocus();
-
-	/** Are we running as an applet or as an application? */
-	public boolean isApplet();
-
-	/** Are we running as a midlet? */
-	public boolean isMidlet();
-
-	/** Are we running with an OpenGL backend? */
-	public boolean isOpenGL();
-
-	/** Are we running on Android? */
-	public boolean isAndroid();
-
-	/** Get the virtual width in pixels (not the scaled screen width) */
-	public int viewWidth();
-	/** Get the virtual height in pixels (not the scaled screen height) */
-	public int viewHeight();
-
-	/** Get the number of tiles of view window in X direction */
-	public int viewTilesX();
-	/** Get the number of tiles of view window in Y direction */
-	public int viewTilesY();
-
-	/** Get view offset as it will be at the next frame draw, in case we are
-	 * not inside a frame draw, or the view offset as it is, when we are. */
-	public int viewXOfs();
-	/** Get view offset as it will be at the next frame draw, in case we are
-	 * not inside a frame draw, or the view offset as it is, when we are. */
-	public int viewYOfs();
-
-	//public int viewTileXOfs();
-	//public int viewTileYOfs();
-
-	/** Get the virtual width in pixels (not the scaled screen width) */
-	public int pfWidth();
-	/** Get the virtual height in pixels (not the scaled screen height) */
-	public int pfHeight();
-
-	/** Get the number of tiles in X direction */
-	public int pfTilesX();
-	/** Get the number of tiles in Y direction */
-	public int pfTilesY();
-
-	/** Is playfield X wrap enabled? */
-	public boolean pfWrapX();
-	/** Is playfield Y wrap enabled? */
-	public boolean pfWrapY();
-
-	/** Get the tile width in (virtual) pixels. */
-	public int tileWidth();
-	/** Get the tile height in (virtual) pixels. */
-	public int tileHeight();
-
-	/** Get the real display width on this device. */
-	public int displayWidth();
-	/** Get the real display height on this device. */
-	public int displayHeight();
-
-
-	/** Override to define your own initialisations before the engine
-	* initialises.  This method is meant for doing initialisations after the
-	* applet has been initialised (in case we're an applet) but before the
-	* engine initialises.  This can be considered a replacement of the
-	* regular constructor, making it independent of whether we're an applet
-	* or application.  Typically you only need to call setCanvasSettings here,
-	* and, optionally, setScalingPreferences().
-	* This is the place where you can read applet parameters and initialise
-	* accordingly.  In case you want to adapt to the real display dimensions,
-	* you can get them using displayWidth/Height at this point.
-	*/
-	abstract public void initCanvas();
-
-	/** Override to define your own initialisations after the engine
-	* initialised.  This method is called by the game thread after
-	* initEngine(), initEngineApplet(), or initEngineComponent() was called. */
-	abstract public void initGame();
-
-	/** Signal that the engine should start running. May be called by the web
-	 * browser. */
-	public void start();
-	/** signal that the engine should stop running and wait. May be called by
-	* the web browser.*/
-	public void stop();
-
-	/** Called when midlet is first initialised, or unpaused.  Midlet version
-	 * of init() when called for the first time, and start() for subsequent
-	 * calls. */
-	public void startApp();
-
-	/** Called by the application manager to pause app. Basically
-	* the midlet version of stop(), behaves the same as stop(). */
-	public void pauseApp();
-
-	/** Called by the application manager to exit app. Basically the
-	* midlet version of destroy(), behaves the same as destroy(). */
-	public void destroyApp(boolean unconditional);
-
-	/** True if engine is running, false if paused. */
-	public boolean isRunning();
-
-	/** Make engine call start() when a key is pressed.  This can be used to
-	* determine a start criterion when halting the engine from within using
-	* stop().
-	* @param key  keycode to wake up on, -1=any key or mouse, 0=none */
-	public void wakeUpOnKey(int key);
-
-	/** Destroy function for deinitialising the engine properly.  This is
-	* called by the applet viewer to dispose the applet.  Use exitEngine to
-	* destroy the applet and exit the system.  */
-	public void destroy();
-
-	/** 	 
-	* @return  frame rate in frames per second */
-	public double getFrameRate();
-
-	/** 	 
-	* @return  max successive frames to skip */
-	public double getFrameSkip();
-
-	/**
-	* @return true = video synced mode enabled
-	*/
-	public boolean getVideoSyncedUpdate();
-
-	/** Change offset of playfield view.  The offset will become active 
-	 * at the next frame draw.  If the view would be out of the
-	 * playfield's bounds, the offset is corrected so that it is inside them.
-	 * The offset of the parallax level 0 background image is set to the
-	 * offset as well, the other levels remain unchanged.
-	 * @param centered  center view on (xofs, yofs), topleft otherwise
-	 */
-	public void setViewOffset(int xofs,int yofs,boolean centered);
-
-	/** Change (absolute) offset of BG image independently of view offset.
-	 * Only supported by parallax scrolling platforms.  Note that parallax
-	 * level 0 follows the view offset, so a call to this method to set
-	 * level 0 should be done after calling setViewOffset.
-	 * @param depth  depth level of image to set
-	 * @param centered  center view on (xofs, yofs), topleft otherwise
-	 */
-	public void setBGImgOffset(int depth, double xofs, double yofs,
-	boolean centered);
-
-	/** Zoom/rotate view.  Can be used to create special effects, like
-	 * speed-dependent zoom, explosion shake, etc.  Only works in OpenGL.  If
-	 * you zoom out too far, parts that are beyond the borders of the
-	 * defined view may get exposed, the appearance of which is undefined.
-	 * This also happens when you rotate, so you will also need to zoom in 
-	 * to ensure this
-	 * does not happen.  Everything that is drawn relative to the playfield is
-	 * zoomed/rotated, everything that is not is unaffected.  Game logic is
-	 * unaffected.  
-	 * <P> Mouse coordinates are inverse projected through
-	 * the last set zoom/rotate setting, so that a playfield relative
-	 * pixel drawn at the logical mouse coordinates coincides with the 
-	 * physical position of the mouse pointer. If you don't want this, you can
-	 * set zoom/rotate to (1,0), read the mouse position, then set zoom/rotate
-	 * to the desired value.  
-	 * <P> The zoom/rotate setting used for actual drawing
-	 * is the last value set at the end of the doFrame phase.  Should not be
-	 * called during the paintFrame phase.
-	 * @param zoom  zoom factor, 1.0 is normal size
-	 * @param rotate  angle in radians
-	 */
-	public void setViewZoomRotate(double zoom, double rotate);
-
-	/** Set the playfield size to be any size larger or equal to the view
-	 * size. 
-	 * @param nrtilesx number of tiles, &gt;= viewTilesX()
-	 * @param nrtilesy number of tiles, &gt;= viewTilesY() */
-	public void setPFSize(int nrtilesx,int nrtilesy);
-
-	/** Set playfield wraparound setting.  When wraparound is enabled, the
-	 * playfield theoretically behaves as if it is infinitely long or high,
-	 * with tiles and objects repeating periodically, with playfield size
-	 * being the period.  Tile coordinates in a wrapped playfield are
-	 * effectively modulo the playfield size.  Object coordinates are wrapped
-	 * symmetrically to the view offset, that is, they are kept within
-	 * -playfieldsize, +playfieldsize of the center of the view offset. This
-	 * ensures that regular coordinate comparison and collision usually work
-	 * as expected, without having to actually model the infinite repetition
-	 * of the objects in the wrap direction.  The shiftx and shifty can be
-	 * used to shift the object's wrap center by some pixels, to ensure they
-	 * enter and leave the sides / top-bottom of the screen neatly when the
-	 * playfield is not larger than the view.  For this case, use the
-	 * following formula: ensure the playfield is slightly larger than the
-	 * view (namely, one sprite length), and set the shift to sprite length/2.
-	 */
-	public void setPFWrap(boolean wrapx,boolean wrapy,int shiftx,int shifty);
-
-	/** Set frame rate in frames per second, and maximum number of frames that
-	 * may be skipped before displaying a frame again. Default is 35 frames
-	 * per second, with a maxframeskip of 4.
-	 * @param fps  frames per second, useful range 2...80
-	 * @param maxframeskip  max successive frames to skip, useful range 0..10*/
-	public void setFrameRate(double fps, double maxframeskip);
-
-	/** Enable/disable video synced update (jogl only).
-	 * This method has no effect on non-jogl platforms,
-	 * where it is always disabled.  The game state update becomes synced with
-	 * the screen refresh rate.  Frame rate is no longer fixed, but depends on
-	 * the machine the game is running on.  Gamespeed is set at the beginning
-	 * of each frame to compensate for this.  Gamespeed is 1 when actual frame
-	 * rate == frame rate set with setFrameRate, less than 1 if frame rate
-	 * greater than setFrameRate, more than 1 if frame rate less than
-	 * setFrameRate.  There is a hard upper and lower bound for gamespeed, to
-	 * ensure it does not attain wild values under rare conditions.  Lower
-	 * bound for game speed is determined by a fixed upper bound for the
-	 * expected screen refresh rate, 95 hz.  Upper bound for game speed is
-	 * determined by the frameskip setting.  */
-	public void setVideoSyncedUpdate(boolean value);
-
-	/** Set game speed variable, default is 1.0.  Game speed affects certain
-	 * parts of the game engine automatically to offload some of the work
-	 * involved of adapting a game to different speeds.  These are the
-	 * following: it is used as JGTimer tick increment, animation increment,
-	 * JGObject expiry increment, and is used as multiplier for object
-	 * x/yspeed, and for the default margins of is...Aligned and snapToGrid. */
-	public void setGameSpeed(double speed);
-
-	/** Get game speed variable.  This can be used if you have other stuff in
-	 * your game that is affected by game speed, besides the standard game
-	 * speed adaptation done by the engine. */
-	public double getGameSpeed();
-
-	/** Configure image rendering.  alpha_thresh is used to determine how a
-	 * translucent image is converted to a bitmask image.  Alpha values below
-	 * the threshold are set to 0, the others to 255. render_bg_col is used to
-	 * render transparency for scaled images; it is the background colour that
-	 * interpolations between transparent and non-transparent pixels are
-	 * rendered to.  Currently, this has an effect in Jdk1.2 only. The default
-	 * render_bg_col is null, meaning the global background colour is used.
-	 * @param alpha_thresh  bitmask threshold, 0...255, default=128
-	 * @param render_bg_col bg colour for render, null=use background colour
-	 */
-	public void setRenderSettings(int alpha_thresh,JGColor render_bg_col);
-
-	/** Set margin used for testing if object should expire or suspend when
-	* off-view or off-playfield. Default is 16,16. */
-	public void setOffscreenMargin(int xmargin,int ymargin);
-
-	/** Get offscreen X margin.
-	* @see #setOffscreenMargin(int,int) */
-	public int getOffscreenMarginX();
-	/** Get offscreen Y margin.
-	* @see #setOffscreenMargin(int,int) */
-	public int getOffscreenMarginY();
-
-
-	/** Set global background colour, which is displayed in borders, and behind
-	* transparent tiles if no BGImage is defined. */
-	public void setBGColor(JGColor bgcolor);
-
-	/** Set global foreground colour, used for printing text and status
-	 * messages.  It is also the default colour for painting */
-	public void setFGColor(JGColor fgcolor);
-
-	/** Set the (unscaled) message font, used for displaying status messages.
-	* It is also the default font for painting.  */
-	public void setMsgFont(JGFont msgfont);
-
-	/** Set foreground and background colour, and message font in one go;
-	* passing a null means ignore that argument. */
-	public void setColorsFont(JGColor fgcolor,JGColor bgcolor,JGFont msgfont);
-
-	/** Set parameters of outline surrounding text (for example, used to
-	 *  increase contrast).
-	 * @param thickness 0 = turn off outline */
-	public void setTextOutline(int thickness,JGColor colour);
-
-	/** Platform-independent cursor. */
-	public static int NO_CURSOR        = -1;
-	/** Platform-independent cursor. */
-	public static int DEFAULT_CURSOR   = 0;
-	/** Platform-independent cursor. */
-	public static int CROSSHAIR_CURSOR = 1;
-	/** Platform-independent cursor. */
-	public static int HAND_CURSOR      = 2;
-	/** Platform-independent cursor. */
-	public static int WAIT_CURSOR      = 3;
-
-	/** Set mouse cursor to a platform-independent standard cursor. */
-	public void setMouseCursor(int cursor);
-
-	/** Set mouse cursor, platform dependent. null (platform-independent)
-	* means hide cursor. */
-	public void setMouseCursor(Object cursor);
-
-	/** Remove all JGTimers still ticking in the system. */
-	public void removeAllTimers();
-
-	/** Register a timer with the engine, don't call directly.  This is called
-	 * automatically by the JGTimer constructor. */
-	public void registerTimer(JGTimer timer);
-
-
-	/** Set the game's main state on the next frame.  Methods with the names
-	 * doFrame&lt;state&gt; and paintFrame&lt;state&gt; will be called in
-	 * addition to doFrame() and paintFrame(). Before the next frame,
-	 * start&lt;state&gt; is called once.  Note that setGameState may actually
-	 * set a state that's already set, in which case start&lt;state&gt; is not
-	 * called. Also, if the setGameState is superseded by another setGameState
-	 * within the same frame, the first setGameState is ignored. */
-	public void setGameState(String state);
-
-	/** Add the given state to the game's existing state on the next frame.
-	* The methods
-	* doFrame&lt;state&gt; and paintFrame&lt;state&gt; will be called <i>in
-	* addition to</i> the methods of any states already set. 
-	* Before the next frame,
-	* start&lt;state&gt; is called once.  Note that addGameState may actually
-	* set a state that's already set, in which case start&lt;state&gt; is not
-	* called.  
-	*/
-	public void addGameState(String state);
-
-	/** Remove the given state from the game's existing state on the next
-	* frame. */
-	public void removeGameState(String state);
-
-	/** Set the game's main state to none, on the next frame.
-	* Only doFrame() and paintFrame() will be called each frame. */
-	public void clearGameState();
-
-
-	/** Check if game is in given state. */
-	public boolean inGameState(String state);
-
-	/** Check if game will be in given state the next frame. */
-	public boolean inGameStateNextFrame(String state);
-
-	/** Is called every frame.  Override to define frame action.  Default is
-	 * do nothing. */
-	public void doFrame();
-
-	/** Is called when the engine's default screen painting is finished,
-	* and custom painting actions may be carried out. Can be used to display
-	* status information or special graphics.  Default is do nothing. */
-	public void paintFrame();
-
-	/** Get the graphics context for drawing on the buffer during a
-	 * paintFrame().  Returns null when not inside paintFrame. */
-	//public Graphics getBufferGraphics();
-
-	/** Get scale factor of real screen width wrt virtual screen width */
-	public double getXScaleFactor();
-	/** Get scale factor of real screen height wrt virtual screen height */
-	public double getYScaleFactor();
-	/** Get minimum of the x and y scale factors */
-	public double getMinScaleFactor();
-
-	/* some convenience functions for drawing during repaint and paintFrame()*/
-
-	/** Set current drawing colour. */
-	public void setColor(JGColor col);
-
-	/** Set current font, scale the font to screen size. */
-	public void setFont(JGFont font);
-
-	/** Set current font, scale the font to screen size. */
-	//public void setFont(Graphics g,JGFont font);
-
-	/** Set the line thickness */
-	public void setStroke(double thickness);
-
-	/** Set blend mode, for platforms that support blending.
-	* Blend functions supported are based on the alpha of the object
-	* being drawn (the drawing source).  Source and destination alpha
-	* multiplier are specified separately. These are one of:
-	* always 1 (encoded as 0), alpha (encoded as 1), and 1-alpha (encoded as
-	* -1).   Default is (1,-1).
-	* @param src_func  source multiply factor, 0=one, 1=alpha, -1 = one - alpha
-	* @param dst_func  destination multiply factor, 0=one, 1=alpha, -1 = one - alpha
-	*/
-	public void setBlendMode(int src_func, int dst_func);
-
-	/** Get height of given font in pixels. */
-	public double getFontHeight(JGFont font);
-	/** Get height of given font or current font in pixels. */
-	//double getFontHeight(Graphics g,JGFont font);
-
-
-	/* convert all coordinates to double?? */
-
-	/** DrawLine combined with thickness/colour setting. The line is drawn
-	 * relative to the playfield coordinates. */
-	public void drawLine(double x1,double y1,double x2,double y2,
-	double thickness, JGColor color);
-	/** Draw a line with current thickness and colour. The line is drawn
-	 * relative to the playfield coordinates. */
-	public void drawLine(double x1,double y1,double x2,double y2);
-
-	/** Draw a line with current thickness and colour.
-	* @param pf_relative coordinates are relative to playfield, otherwise view*/
-	public void drawLine(double x1,double y1,double x2,double y2,
-	boolean pf_relative);
-
-	/** Draw convex polygon.  For filled polygons, it is possible to draw a
-	 * colour gradient, namely a "fan" of colours (specified by col),
-	 * spreading from the first point to each successive point in the polygon.
-	 * For line polygons, a gradient is drawn between successive line
-	 * segments.
-	 * On non-OpenGL platforms, the fill gradient is drawn as a fan of plain
-	 * colours, with colour 0 and 1 ignored, the line gradient as plain
-	 * coloured lines.
-	 *
-	* @param x  x coordinates of the points
-	* @param y  y coordinates of the points
-	* @param col  colour of each point, null means use default colour
-	* @param len number of points
-	* @param pf_relative coordinates are relative to playfield, otherwise view
-	*/
-	public void drawPolygon(double [] x,double [] y, JGColor [] col, int len,
-	boolean filled, boolean pf_relative);
-
-	/** Set colour/thickness and draw rectangle.  Coordinates are relative to
-	* playfield.
-	* @param centered indicates (x,y) is center instead of topleft.
-	*/
-	public void drawRect(double x,double y,double width,double height, boolean filled,
-	boolean centered, double thickness, JGColor color);
-
-	/** Draw rectangle in default colour and thickness.  Coordinates are
-	* relative to playfield.
-	* @param centered indicates (x,y) is center instead of topleft.
-	*/
-	public void drawRect(double x,double y,double width,double height, boolean filled,
-	boolean centered);
-
-	/** Draw rectangle in default colour and thickness.
-	* @param centered indicates (x,y) is center instead of topleft.
-	* @param pf_relative coordinates are relative to playfield, otherwise view
-	*/
-	public void drawRect(double x,double y,double width,double height, boolean filled,
-	boolean centered, boolean pf_relative);
-
-	/** Draw shaded rectangle.  On non-opengl platforms, rectangle is drawn in
-	 * default colour.
-	 * @param shadecol colors topleft,topright,botright,botleft corners
-	*/
-	public void drawRect(double x,double y,double width,double height,
-	boolean filled, boolean centered,boolean pf_relative,
-	JGColor [] shadecol);
-
-	/** Draw shaded or patterned rectangle.  On non-opengl platforms,
-	* rectangle is drawn in default colour.
-	* @param shadecol colors topleft,topright,botright,botleft corners
-	*/
-	public void drawRect(double x,double y,double width,double height,
-	boolean filled, boolean centered,boolean pf_relative,
-	JGColor [] shadecol,String tileimage);
-
-	/** Set thickness/colour and draw oval.  Coordinates are relative to
-	* playfield.
-	* @param centered indicates (x,y) is center instead of topleft.
-	*/
-	public void drawOval(double x,double y,double width,double height, boolean filled,
-	boolean centered, double thickness, JGColor color);
-
-	/** Draw oval with default thickness and colour. Coordinates are relative
-	* to playfield.
-	* @param centered indicates (x,y) is center instead of topleft.
-	*/
-	public void drawOval(double x,double y, double width,double height,boolean filled,
-	boolean centered);
-
-	/** Draw oval with default thickness and colour. 
-	* @param centered indicates (x,y) is center instead of topleft.
-	* @param pf_relative coordinates are relative to playfield, otherwise view
-	*/
-	public void drawOval(double x,double y, double width,double height,boolean filled,
-	boolean centered, boolean pf_relative);
-
-	/** Draw image with given ID. Coordinates are relative to playfield. */
-	public void drawImage(double x,double y,String imgname);
-
-	/** Draw image with given ID. 
-	* @param pf_relative coordinates are relative to playfield, otherwise view*/
-	public void drawImage(double x,double y,String imgname,boolean pf_relative);
-
-	/** Extended version of drawImage for OpenGL or Android.
-	 * On platforms without support for accelerated blending, rotation,
-	 * scaling, this call is equivalent to drawImage(x,y,imgname,pf_relative).
-	 *
-	 * rotation and scaling are centered around the image center.
-	 *
-	 * @param blend_col colour to blend with image, null=(alpha,alpha,alpha)
-	 * @param alpha  alpha (blending) value, 0=transparent, 1=opaque
-	 * @param rot  rotation of object in degrees (radians)
-	 * @param scale  scaling of object (1 = normal size).
-	 */
-	public void drawImage(double x,double y,String imgname, JGColor blend_col,
-	double alpha, double rot, double scale, boolean pf_relative);
-
-
-	/** Draw image with given ID, new version.
-	* Coordinates are relative to playfield. */
-	public void drawImage(String imgname,double x,double y);
-
-	/** Draw image with given ID, new version. 
-	* @param pf_relative coordinates are relative to playfield, otherwise view*/
-	public void drawImage(String imgname,double x,double y,boolean pf_relative);
-
-	/** Extended version of drawImage for OpenGL or Android, new version.
-	 * On platforms without support for accelerated blending, rotation,
-	 * scaling, this call is equivalent to drawImage(x,y,imgname,pf_relative).
-	 *
-	 * rotation and scaling are centered around the image center.
-	 *
-	 * @param blend_col colour to blend with image, null=(alpha,alpha,alpha)
-	 * @param alpha  alpha (blending) value, 0=transparent, 1=opaque
-	 * @param rot  rotation of object in degrees (radians)
-	 * @param scale  scaling of object (1 = normal size).
-	 */
-	public void drawImage(String imgname, double x,double y,
-	boolean pf_relative,JGColor blend_col,
-	double alpha, double rot, double scale);
-
-
-	/** Draws string so that (x,y) is the topleft coordinate (align=-1), the
-	 * top middle coordinate (align=0), or the top right coordinate (align=1).
-	 * Use given font and colour; filling in null for either means ignore.
-	 * Unlike the other draw functions, for strings, coordinates are relative
-	 * to view by default.  An outline is drawn around the text when defined
-	 * by setTextOutline.
-	 * @param align  text alignment, -1=left, 0=center, 1=right */
-	public void drawString(String str, double x, double y, int align,
-	JGFont font, JGColor color);
-
-	/** Draws string so that (x,y) is the topleft coordinate (align=-1), the
-	 * top middle coordinate (align=0), or the top right coordinate (align=1).
-	 * Use current font and colour.
-	 * Unlike the other draw functions, for strings, coordinates are relative
-	 * to view by default. An outline is drawn around the text when defined
-	 * by setTextOutline.
-	 * @param align  text alignment, -1=left, 0=center, 1=right */
-	public void drawString(String str, double x, double y, int align);
-
-	/** Draws string so that (x,y) is the topleft coordinate (align=-1), the
-	* top middle coordinate (align=0), or the top right coordinate (align=1).
-	* Use current font and colour. An outline is drawn around the text when
-	* defined by setTextOutline.
-	* @param align  text alignment, -1=left, 0=center, 1=right
-	* @param pf_relative coordinates are relative to playfield, otherwise view*/
-	public void drawString(String str, double x, double y, int align,
-	boolean pf_relative);
-
-	/** Internal function for writing on both buffer and screen.  Coordinates
-	 * are always relative to view. */
-	//void drawString(Graphics g, String str, double x, double y, int align,
-	//boolean pf_relative);
-
-	/** Draws a single line of text using an image map as font;
-	* text alignment is same as drawString.  Typically, an image font only
-	* defines the ASCII character range 32-96.  In this case, set char_offset
-	* to 32, and use only the uppercase letters.  Coordinates are relative to
-	* view.
-	* @param align  text alignment, -1=left, 0=center, 1=right
-	* @param imgmap  name of image map
-	* @param char_offset  ASCII code of first image of image map
-	* @param spacing  number of pixels to skip between letters
-	*/
-	public void drawImageString(String string, double x, double y, int align,
-	String imgmap, int char_offset, int spacing);
-
-	/** Draws a single line of text using an image map as font;
-	* text alignment is same as drawString.  Typically, an image font only
-	* defines the ASCII character range 32-96.  In this case, set char_offset
-	* to 32, and use only the uppercase letters.
-	* @param align  text alignment, -1=left, 0=center, 1=right
-	* @param imgmap  name of image map
-	* @param char_offset  ASCII code of first image of image map
-	* @param spacing  number of pixels to skip between letters
-	* @param pf_relative coordinates are relative to playfield, otherwise view
-	*/
-	public void drawImageString(String string, double x, double y, int align,
-	String imgmap, int char_offset, int spacing,boolean pf_relative);
-
-	/** Get current mouse position in logical coordinates, inverse projected
-	 * through last set view zoom/rotate setting.  */
-	public JGPoint getMousePos();
-	/** Get current mouse X position */
-	public int getMouseX();
-	/** Get current mouse Y position */
-	public int getMouseY();
-
-	/** Get state of button.
-	* @param nr  1=button 1 ... 3 = button 3
-	* @return true=pressed, false=released */
-	public boolean getMouseButton(int nr);
-	/** Set state of button to released.
-	* @param nr  1=button 1 ... 3 = button 3 */
-	public void clearMouseButton(int nr);
-	/** Set state of button to pressed.
-	* @param nr  1=button 1 ... 3 = button 3 */
-	public void setMouseButton(int nr);
-	/** Check if mouse is inside game window */
-	public boolean getMouseInside();
-
-	/** Get the key status of the given key. */
-	public boolean getKey(int key);
-	/** Set the key status of a key to released. */
-	public void clearKey(int key);
-	/** Set the key status of a key to pressed. */
-	public void setKey(int key);
-
-	/** Get the keycode of the key that was pressed last, 0=none. */
-	public int getLastKey();
-	/** Get the keycode of the key that was pressed last, 0=none. */
-	public char getLastKeyChar();
-	/** Clear the lastkey status. */
-	public void clearLastKey();
-
-	/** Get a printable string describing the key. */
-	public String getKeyDesc(int key);
-
-	/** Obtain key code from printable string describing the key, the inverse
-	 * of getKeyDesc. The string is trimmed and lowercased. */
-	public int getKeyCode(String keydesc);
-
-	/** returns true if device has accelerometer (currently only android) */
-	public boolean hasAccelerometer();
-
-	/** get accelerometer vector X coordinate */
-	public double getAccelX();
-	/** get accelerometer vector Y coordinate */
-	public double getAccelY();
-	/** get accelerometer vector Z coordinate (positive = towards user) */
-	public double getAccelZ();
-
-	/** get double[3] vector representing acceleration */
-	public double [] getAccelVec();
-
-	/*====== animation ======*/
-
-	/** Define new animation sequence. Speed must be &gt;= 0.
-	* @param id  the name by which the animation is known
-	* @param frames  an array of image names that should be played in sequence
-	* @param speed the sequence speed: the number of animation steps per frame
-	*/
-	public void defineAnimation (String id,
-	String [] frames, double speed);
-
-	/** Define new animation sequence. Speed must be &gt;= 0.
-	* @param id  the name by which the animation is known
-	* @param frames  an array of image names that should be played in sequence
-	* @param speed the sequence speed: the number of animation steps per frame
-	* @param pingpong  true=play the images in forward order, then in reverse
-	*/
-	public void defineAnimation (String id,
-	String [] frames, double speed, boolean pingpong);
-
-	/** Get animation definition, don't call directly.  This is used by
-	 * JGObjects to get animations. */
-	public Animation getAnimation(String id);
-
-
-	/*== file op ==*/
-
-	/** Returns path to writable location for a file with the given name.
-	 * Basically it uses [user.home] / .jgame / [filename], with "/" being the
-	 * system path separator.  In case [user.home] / .jgame does not exist, it
-	 * is created.  In case .jgame is not a directory, null is returned.  In
-	 * case the file does not exist yet, an empty file is created.
-	 * @return path to writable file, or null if not possible
-	 */
-	public String getConfigPath(String filename);
-
-	/** Execute or go to URL (action depends on file type). 
-	* @return  0 if fail; 1 if success; -1 if the status is unknown
-	*/
-	public int invokeUrl(String url,String target);
-
-	/* computation */
-
-	/** A Boolean AND shorthand to use for collision;
-	* returns (value&amp;mask) != 0. */
-	public boolean and(int value, int mask);
-
-	/** A floating-point random number between min and max */
-	public double random(double min, double max);
-
-	/** Generates discrete random number between min and max inclusive, with
-	 * steps of interval.  Epsilon is added to max to ensure there are no
-	 * rounding error problems with the interval.  So, random(0.0, 4.2, 2.1)
-	 * generates either 0.0, 2.1, or 4.2 with uniform probabilities.  If max
-	 * is halfway between interval steps, max is treated as exclusive.  So,
-	 * random(0.0,5.0,2.1) generates 0.0, 2.1, 4.2 with uniform probabilities.
-	 * If you need integer ranges, be sure to use the integer version to avoid
-	 * rounding problems. */
-	public double random(double min, double max, double interval);
-
-	/** Generates discrete random number between min and max inclusive, with
-	 * steps of interval, integer version.  If max is halfway between two
-	 * interval steps, it is treated as exclusive. */
-	public int random(int min, int max, int interval);
-
-	/** Replacement for Math.atan2 for the sake of MIDP portability.  The JRE
-	 * implementation simply uses Math.atan2, for MIDP a short and fast
-	 * Math.atan2 replacement is used, with average numerical error less than
-	 * 0.001 radians, maximum error 0.005 radians. */
-	public double atan2(double y,double x);
-
-
-	/** Get tile index of the tile the coordinate is on.*/
-	public JGPoint getTileIndex(double x, double y);
-
-	/** Get pixel coordinate corresponding to the top left of the tile at the
-	* given index */
-	public JGPoint getTileCoord(int tilex, int tiley);
-
-	/** Get pixel coordinate corresponding to the top left of the tile at the
-	* given index */
-	public JGPoint getTileCoord(JGPoint tileidx);
-
-	/** Snap to grid, double version. Epsilon is added to the gridsnap value,
-	* so that isXAligned(x,margin) always implies that snapToGridX(x,margin)
-	* will snap.
-	* @param x  position to snap
-	* @param gridsnapx  snap margin, 0.0 means no snap   */
-	public double snapToGridX(double x, double gridsnapx);
-
-	/** Snap to grid, double version. Epsilon is added to the gridsnap value,
-	* so that isYAligned(y,margin) always implies that snapToGridY(y,margin)
-	* will snap.
-	* @param y  position to snap
-	* @param gridsnapy  snap margin, 0.0 means no snap   */
-	public double snapToGridY(double y, double gridsnapy);
-
-	/** Snap p to grid in case p is close enough to the grid lines. Note: this
-	 * function only handles integers so it should not be used to snap an
-	 * object position.  */
-	public void snapToGrid(JGPoint p,int gridsnapx,int gridsnapy);
-
-	/** Returns true if x falls within margin of the tile snap grid. Epsilon
-	 * is added to the margin, so that isXAligned(1.0000, 1.0000)
-	 * always returns true. */
-	public boolean isXAligned(double x,double margin);
-
-	/** Returns true if y falls within margin of the tile snap grid. Epsilon
-	 * is added to the margin, so that isYAligned(1.0000, 1.0000)
-	 * always returns true. */
-	public boolean isYAligned(double y,double margin);
-
-	/** Returns the difference between position and the closest tile-aligned
-	 * position. */
-	public double getXAlignOfs(double x);
-
-	/** Returns the difference between position and the closest tile-aligned
-	 * position. */
-	public double getYAlignOfs(double y);
-
-	// XXX please test these two methods
-
-	/** Calculates length of the shortest path between x1 and x2,
-	* with x1, x2 being playfield coordinates,
-	* taking into account the wrap setting. */
-	public double getXDist(double x1, double x2);
-
-	/** Calculates length of the shortest path between y1 and y2,
-	* with y1, y2 being playfield coordinates,
-	* taking into account the wrap setting. */
-	public double getYDist(double y1, double y2);
-
-
-
-	/*===== audio =====*/
-
-
-	/** Enable audio, restart any audio loops. */
-	public void enableAudio();
-
-	/** Disable audio, stop all currently playing audio.  Audio commands will
-	* be ignored, except that audio loops (music, ambient sounds) are
-	* remembered and will be restarted once audio is enabled again. */
-	public void disableAudio();
-
-	/** Associate given clipid with a filename.  Files are loaded from the
-	* resource path.  Java 1.2+ supports at least: midi and wav files. */
-	public void defineAudioClip(String clipid,String filename);
-
-	/** Returns the audioclip that was last played, null if audio was stopped
-	* with stopAudio.	Note the clip does not actually have to be playing; it
-	* might have finished playing already. */
-	public String lastPlayedAudio(String channel);
-
-	/** Play audio clip on unnamed channel, which means it will not replace
-	* another clip, and cannot be stopped.  The clip is not looped.  When
-	* this method is called multiple times with the same sample within the
-	* same frame, it is played only once. */
-	public void playAudio(String clipid);
-
-	/** Play clip on channel with given name.  Will replace any other clip
-	 * already playing on the channel.  Will restart if the clip is already
-	 * playing <i>and</i> either this call or the already playing one are
-	 * <i>not</i> specified as looping.  If both are looping, the looped sound
-	 * will continue without restarting.  If you want the looping sound to be
-	 * restarted, call stopAudio first.  Note the channel "music" is reserved
-	 * for enabling/disabling music separately in future versions.  */
-	public void playAudio(String channel,String clipid,boolean loop);
-
-	/** Stop one audio channel. */
-	public void stopAudio(String channel);
-
-	/** Stop all audio channels. */
-	public void stopAudio();
-
-
-	/*===== store =====*/
-
-	/** Writes integer to store under given ID */
-	public void storeWriteInt(String id,int value);
-
-	/** Writes double to store under given ID */
-	public void storeWriteDouble(String id,double value);
-
-	/** Writes string to store under given ID */
-	public void storeWriteString(String id,String value);
-
-	/** Remove record if it exists */
-	public void storeRemove(String id);
-
-	/** Checks if item exists in store */
-	public boolean storeExists(String id);
-
-	/** Reads int from store, use undef if ID not found */
-	public int storeReadInt(String id,int undef);
-
-	/** Reads double from store, use undef if ID not found */
-	public double storeReadDouble(String id,double undef);
-
-	/** Reads String from store, use undef if ID not found */
-	public String storeReadString(String id,String undef);
-
-	/*====== options ======*/
-
-	/** Adds title to be displayed above subsequent items.  Default title of
-	 * initial items is "Preferences".  Call this before defining any items to
-	 * override the default title. */
-	public void optsAddTitle(String title);
-
-	/** adds (int or float) number that can be configured with a slider.
-	* Type is double if decimals!=0, int otherwise.
-	* @param decimals number is int if 0
-	**/
-	public void optsAddNumber(String varname,String title,String desc,
-	int decimals, double lower,double upper,double step, double initial);
-
-	/** Adds boolean that can be configured with a checkbox. Actual type is
-	 * int (0 or 1) */
-	public void optsAddBoolean(String varname,String title,String desc,
-	boolean initial);
-
-	/** Adds enum that can be configured with radio buttons. Actual type is
-	 * int, 0 for first item, 1 for second item, etc. */
-	public void optsAddEnum(String varname,String title,String desc,
-	String [] values, int initial);
-
-	/** Adds "key" option that can be configured by selecting a key or button
-	* on the device.  Actual type is int. */
-	public void optsAddKey(String varname,String title,String desc,int initial);
-
-	/** Adds String that can be configured by typing text. */
-	public void optsAddString(String varname,String title,String desc,
-	int maxlen, boolean isPassword, String initial);
-
-	/** Clear all previous option definitions. */
-	public void optsClear();
+    String JGameVersionString = "3.6";
+
+
+    /**
+     * Cursor keys for both regular and mobile keyboard.
+     */
+    int KeyUp = 38, KeyDown = 40, KeyLeft = 37, KeyRight = 39;
+    /**
+     * On a mobile, the cursor control Fire is the same as shift.
+     */
+    int KeyShift = 16;
+    /**
+     * Fire stands for a mobile key, indicating the fire button of the cursor
+     * controls.  It is equivalent to KeyShift.
+     */
+    int KeyFire = 16;
+    int KeyCtrl = 17;
+    int KeyAlt = 18;
+    int KeyEsc = 27;
+    /**
+     * On a mobile, pressing "*" also triggers KeyEnter.
+     */
+    int KeyEnter = 10;
+    /**
+     * The mobile Star key, equal to '*'.
+     */
+    int KeyStar = '*';
+    /**
+     * The mobile Pound key, equal to '#'.
+     */
+    int KeyPound = '#';
+    int KeyBackspace = 8; /* is it different sometimes? */
+    int KeyTab = 9;
+    /**
+     * Keymap equivalent of mouse button.
+     */
+    int KeyMouse1 = 256, KeyMouse2 = 257, KeyMouse3 = 258;
+
+
+    /** Keycode of cursor key. */
+    //public static final int KeyUp=38,KeyDown=40,KeyLeft=37,KeyRight=39;
+    //public static final int KeyShift=16;
+    //public static final int KeyCtrl=17;
+    //public static final int KeyAlt=18;
+    //public static final int KeyEsc=27;
+    //public static final int KeyEnter=10;
+    //public static final int KeyBackspace=127;
+    ////public static final int KeyBackspace=KeyEvent.VK_BACK_SPACE;
+    //public static final int KeyTab=8;
+    ////public static final int KeyTab=KeyEvent.VK_TAB;
+    /** Keymap equivalent of mouse button. */
+    //public static final int KeyMouse1=256, KeyMouse2=257, KeyMouse3=258;
+
+
+    /**
+     * Set progress bar position in the load screen.
+     *
+     * @param pos a number between 0 and 1
+     */
+    void setProgressBar(double pos);
+
+    /**
+     * Set progress message, default "Loading files..."
+     */
+    void setProgressMessage(String msg);
+
+    /**
+     * Set author message, default "JGame [version]"
+     */
+    void setAuthorMessage(String msg);
+
+    /* images */
+
+    // public but not in interface
+    //public ImageUtil imageutil = new ImageUtil(this);
+
+
+    /**
+     * Gets (scaled) image directly. Is usually not necessary. Returns
+     * null if image is a null image; throws error if image is not defined.
+     */
+    JGImage getImage(String imgname);
+
+    /**
+     * Gets (non-scaled) image's physical size directly.  The object returned
+     * may be a reference to an internal variable, do not change it!
+     */
+    JGPoint getImageSize(String imgname);
+
+    /** If an image with name already exists, it is removed from memory.
+     * @param imgfile  filespec, loaded as resource
+     */
+    /**
+     * Define new sprite/tile image from a file.  If an image with this
+     * id is already defined, it is removed from any caches, so that the old
+     * image is really unloaded.  This can be used to load large (background)
+     * images on demand, rather than have them all in memory.  Note that the
+     * unloading does not work for images defined from image maps. Defining
+     * an image with the same name and filename twice does not cause the image
+     * to be reloaded, but keeps the old image.
+     *
+     * @param name        image id
+     * @param tilename    tile id (1-4 characters)
+     * @param collisionid cid to use for tile collision matching
+     * @param imgfile     filespec in resource path; "null" means no file
+     * @param top         collision bounding box dimensions
+     * @param left        collision bounding box dimensions
+     * @param width       collision bounding box dimensions
+     * @param height      collision bounding box dimensions
+     */
+    void defineImage(String name, String tilename, int collisionid,
+                     String imgfile, String img_op,
+                     int top, int left, int width, int height);
+
+    /**
+     * Define new image by rotating an already loaded image.  This method
+     * does not yet work for images defined from image maps! The destination
+     * image is always a square which is large enough to fit the source image
+     * at any angle. Its dimension is calculated as: max(width, height,
+     * 0.75*(width+height)).  The source image is rendered to its center.
+     * <p> If an image with this id is already defined,
+     * it is removed from any caches, so that the old image is really
+     * unloaded.  This can be used to load large (background) images on
+     * demand, rather than have them all in memory.  Note that the unloading
+     * does not work for images defined from image maps.
+     *
+     * @param imgname     image id
+     * @param tilename    tile id (1-4 characters)
+     * @param collisionid cid to use for tile collision matching
+     * @param srcimg      image id of (already loaded) source image
+     * @param angle       the angle in radians by which to rotate
+     */
+    void defineImageRotated(String imgname, String tilename,
+                            int collisionid, String srcimg, double angle);
+
+    /**
+     * Define image map, a large image containing a number of smaller images
+     * to use for sprites or fonts.  The images must be in a regularly spaced
+     * matrix.  One may define multiple image maps with the same image but
+     * different matrix specs.
+     *
+     * @param mapname id of image map
+     * @param imgfile filespec in resource path
+     * @param xofs    x offset of first image
+     * @param yofs    y offset of first image
+     * @param tilex   width of an image
+     * @param tiley   height of an image
+     * @param skipx   nr of pixels to skip between successive images
+     * @param skipy   nr of pixels to skip between successive images vertically.
+     */
+    void defineImageMap(String mapname, String imgfile,
+                        int xofs, int yofs, int tilex, int tiley, int skipx, int skipy);
+
+    /**
+     * Gets the collision bounding box of an image.
+     */
+    JGRectangle getImageBBox(String imgname);
+
+
+    /*====== image from engine ======*/
+
+    /**
+     * Define new sprite/tile image from a file, with collision bounding box
+     * equal to the image's dimensions. If an image with this
+     * id is already defined, it is removed from any caches, so that the old
+     * image is really unloaded.  This can be used to load large (background)
+     * images on demand, rather than have them all in memory.  Note that the
+     * unloading does not work for images defined from image maps. Defining
+     * an image with the same name and filename twice does not cause the image
+     * to be reloaded, but keeps the old image.
+     *
+     * @param imgname     image id
+     * @param tilename    tile id (1-4 characters)
+     * @param collisionid cid to use for tile collision matching
+     * @param imgfile     filespec in resource path; "null" means no file
+     */
+    void defineImage(String imgname, String tilename, int collisionid,
+                     String imgfile, String img_op);
+
+    /**
+     * Define new sprite/tile image from map.
+     *
+     * @param imgname     image id
+     * @param tilename    tile id (1-4 characters)
+     * @param collisionid cid to use for tile collision matching
+     * @param imgmap      id of image map
+     * @param mapidx      index of image in map, 0=first
+     * @param top         collision bounding box dimensions
+     * @param left        collision bounding box dimensions
+     * @param width       collision bounding box dimensions
+     * @param height      collision bounding box dimensions
+     */
+    void defineImage(String imgname, String tilename, int collisionid,
+                     String imgmap, int mapidx, String img_op,
+                     int top, int left, int width, int height);
+
+    /**
+     * Define new sprite/tile image from map, with collision bounding box
+     * equal to the image's dimensions.
+     *
+     * @param imgname     image id
+     * @param tilename    tile id (1-4 characters)
+     * @param collisionid cid to use for tile collision matching
+     * @param imgmap      id of image map
+     * @param mapidx      index of image in map, 0=first
+     */
+    void defineImage(String imgname, String tilename, int collisionid,
+                     String imgmap, int mapidx, String img_op);
+
+    /**
+     * Load a set of imagemap, image, animation, and audio clip definitions
+     * from a file.
+     * The file contains one image / imagemap / animation definition / audio
+     * clip
+     * on each line, with the fields separated by one or more tabs.  Lines not
+     * matching the required number of fields are ignored.
+     * The fields have the same order as in defineImage, defineImageMap,
+     * defineAnimation, and defineAudioClip. For example:
+     * <p>
+     * <code>defineImage("mytile", "#", 1,"gfx/myimage.gif", "-");</code>
+     * <p>
+     * is equivalent to the following line in the table:
+     * <p>
+     * <code>mytile &nbsp;&nbsp;&nbsp; # &nbsp;&nbsp;&nbsp;  1
+     * &nbsp;&nbsp;&nbsp; gfx/myimage.gif &nbsp;&nbsp;&nbsp; -</code>
+     * <p>
+     * with the whitespace between the fields consisting of one or more tabs.
+     * The defineAnimation methods take an array of names as the second
+     * argument.  This is represented in table format as the names separated by
+     * semicolon ';' characters.  So:
+     * <p>
+     * <code>defineAnimation("anim",new String[]{"frame0","frame1",...},0.5);
+     * </code><p>
+     * is equivalent to:
+     * <p>
+     * <code>anim &nbsp;&nbsp;&nbsp; frame0;frame1;... &nbsp;&nbsp;&nbsp; 0.5
+     * </code>
+     **/
+    void defineMedia(String filename);
+
+
+
+    /*====== BG/tiles ======*/
+
+
+    /**
+     * Set image to display behind transparent tiles.  Image size must be a
+     * multiple of the tile size. Passing null turns off background image; the
+     * background colour will be used instead.
+     *
+     * @param bgimg image name, null=turn off background image
+     */
+    void setBGImage(String bgimg);
+
+
+    /**
+     * Set image to display at a particular parallax scroll level.  Only
+     * some platforms support parallax scrolling.  On other platforms, only the
+     * level 0 image is displayed, with its offset equal to the view
+     * offset.  Level 0 corresponds to the top level; setBGImage(String) is
+     * equivalent to setBGImage(String,0,true,true).   The level 0 image
+     * follows the view offset by default, higher levels are initialised to
+     * offset (0,0) by default.
+     *
+     * @param bgimg image name, null=turn off image at this level
+     * @param depth depth level, 0=topmost
+     * @param wrapx image should wrap in x direction
+     * @param wrapy image should wrap in y direction
+     */
+    void setBGImage(int depth, String bgimg, boolean wrapx, boolean wrapy);
+
+
+    /**
+     * Define background tile settings.  Default is setBGCidSettings("",0,0).
+     *
+     * @param out_of_bounds_tile tile string to use outside of screen bounds
+     * @param out_of_bounds_cid  cid to use outside of screen boundaries
+     * @param preserve_cids      cid mask to preserve when setting tiles
+     */
+    void setTileSettings(String out_of_bounds_tile,
+                         int out_of_bounds_cid, int preserve_cids);
+
+    /**
+     * Fill the background with the given tile.
+     *
+     * @param filltile null means use background colour
+     */
+    void fillBG(String filltile);
+
+
+    /*====== objects from canvas ======*/
+
+    /**
+     * Add new object, will become active next frame, do not call directly.
+     * This method is normally called automatically by the JGObject
+     * constructor.  You should not need to call this directly.
+     */
+    void markAddObject(JGObject obj);
+
+
+    /**
+     * Get object if it exists.
+     */
+    boolean existsObject(String index);
+
+    /**
+     * Get object if it exists, null if not.
+     */
+    JGObject getObject(String index);
+
+    /**
+     * Call the move() methods of those objects matching the given name
+     * prefix and collision id mask.
+     *
+     * @param cidmask collision id mask, 0 means ignore
+     * @param prefix  ID prefix, null means ignore
+     */
+    void moveObjects(String prefix, int cidmask);
+
+    /**
+     * Call the move() methods of all registered objects.
+     */
+    void moveObjects();
+
+
+    /**
+     * Calls all colliders of objects that match dstcid that collide with
+     * objects that match srccid.
+     */
+    void checkCollision(int srccid, int dstcid);
+
+    /**
+     * Checks collision of objects with given cid mask with given object.
+     * Suspended objects are not counted (same as checkCollision(int,int)).
+     * This method should be a more efficient way to check for object overlap
+     * than getObjects, though it's still not very efficient.
+     *
+     * @param cidmask cid mask of objects to consider, 0 means any
+     * @return the OR of the CIDs of all object overlapping r
+     */
+    int checkCollision(int cidmask, JGObject obj);
+
+    /**
+     * Check collision of tiles within given rectangle, return the OR of all
+     * cids found.
+     *
+     * @param r bounding box in pixel coordinates
+     */
+    int checkBGCollision(JGRectangle r);
+
+    /**
+     * Calls all bg colliders of objects that match objid that collide with
+     * tiles that match tileid.
+     */
+    void checkBGCollision(int tilecid, int objcid);
+
+    /* objects from engine */
+
+    /**
+     * Query the object list for objects matching the given name prefix, CID
+     * mask, and collide with the given bounding box.  If suspended_obj is
+     * true, suspended objects are also included.  The list of objects
+     * returned match all the supplied criteria.  This is an inefficient
+     * method, use sparingly.
+     *
+     * @param cidmask       collision id mask, 0 means ignore
+     * @param prefix        ID prefix, null means ignore
+     * @param suspended_obj also count suspended objects
+     * @param bbox          collision bounding box, null means ignore
+     */
+    Vector getObjects(String prefix, int cidmask, boolean suspended_obj,
+                      JGRectangle bbox);
+
+    /**
+     * Remove one particular object. The actual removal is done after the
+     * current moveObjects or check*Collision ends, or immediately if done
+     * from within the main doFrame loop.
+     */
+    void removeObject(JGObject obj);
+
+    /**
+     * Remove all objects which have the given name prefix and/or match the
+     * given cidmask.  It also removes suspended objects.
+     * The actual matching and removal is done after the
+     * current moveObjects or check*Collision ends, or immediately if done
+     * from within the main doFrame loop.  It also removes any matching
+     * objects which are pending to be added the next frame.
+     *
+     * @param cidmask collision id mask, 0 means ignore
+     * @param prefix  ID prefix, null means ignore
+     */
+    void removeObjects(String prefix, int cidmask);
+
+    /**
+     * Remove all objects which have the given name prefix and/or match the
+     * given cidmask.  You can specify whether to remove suspended objects or
+     * not.  The actual matching and removal is done after the
+     * current moveObjects or check*Collision ends, or immediately if done
+     * from within the main doFrame loop.  It also removes any matching
+     * objects which are pending to be added the next frame.
+     *
+     * @param cidmask       collision id mask, 0 means ignore
+     * @param prefix        ID prefix, null means ignore
+     * @param suspended_obj also count suspended objects
+     */
+    void removeObjects(String prefix, int cidmask, boolean suspended_obj);
+
+    /**
+     * Count how many objects there are with both the given name prefix and
+     * have colid&amp;cidmask != 0.  Either criterion can be left out.
+     * It also counts suspended objects.  Actually
+     * searches the object array, so it may be inefficient to use it a lot of
+     * times.
+     *
+     * @param cidmask collision id mask, 0 means ignore
+     * @param prefix  ID prefix, null means ignore
+     */
+    int countObjects(String prefix, int cidmask);
+
+    /**
+     * Count how many objects there are with both the given name prefix and
+     * have colid&amp;cidmask != 0.  Either criterion can be left out.  You can
+     * specify whether to count suspended objects or not.  Actually
+     * searches the object array, so it may be inefficient to use it a lot of
+     * times.
+     *
+     * @param cidmask       collision id mask, 0 means ignore
+     * @param prefix        ID prefix, null means ignore
+     * @param suspended_obj also count suspended objects
+     */
+    int countObjects(String prefix, int cidmask, boolean suspended_obj);
+
+
+    /*====== tiles ======*/
+
+    /**
+     * Set the cid of a single tile using and and or mask.
+     */
+    void setTileCid(int x, int y, int and_mask, int or_mask);
+
+    /**
+     * Set a single tile.
+     */
+    void setTile(int x, int y, String tilestr);
+
+    /**
+     * Count number of tiles with given mask. Actually searches all tiles, so
+     * it's inefficient and should be used sparingly (such as, determine
+     * the number of something at the beginning of a game).
+     */
+    int countTiles(int tilecidmask);
+
+    /**
+     * Get collision id of tile at given tile index position. Moduloes the
+     * given position if wraparound
+     */
+    int getTileCid(int xidx, int yidx);
+
+    /**
+     * get string id of tile at given index position.
+     * Moduloes the given position if wraparound
+     */
+    String getTileStr(int xidx, int yidx);
+
+    /**
+     * Get the OR of the cids at the tile indexes given by tiler
+     */
+    int getTileCid(JGRectangle tiler);
+
+    /**
+     * Get tile index range of all tiles overlapping given rectangle of pixel
+     * coordinates.
+     * Get tile position range of all tiles overlapping given rectangle.
+     * Returns null is rectangle is null.
+     *
+     * @param r rectangle in pixel coordinates, null is none
+     * @return tile indices
+     */
+    JGRectangle getTiles(JGRectangle r);
+
+    /**
+     * Get tile index range of all tiles overlapping given rectangle of pixel
+     * coordinates, version without object creation.
+     * Get tile position range of all tiles overlapping given rectangle.
+     * Returns false is rectangle is null.
+     *
+     * @param r    rectangle in pixel coordinates, null is none
+     * @param dest rectangle to copy tile range into
+     * @return true if rectangle exists, false if null
+     */
+    boolean getTiles(JGRectangle dest, JGRectangle r);
+
+    /* background methods from engine */
+
+    /**
+     * Draw tile directly on background, do not call this
+     * directly, use setTile instead.
+     */
+    void drawTile(int xi, int yi, int tileid);
+
+    /**
+     * Set the cid of a single tile to the given value, leaving the actual
+     * tile.
+     */
+    void setTileCid(int x, int y, int value);
+
+    /**
+     * Modify the cid of a single tile by ORing a bit mask, leaving the actual
+     * tile.
+     */
+    void orTileCid(int x, int y, int or_mask);
+
+    /**
+     * Modify the cid of a single tile by ANDing a bit mask, leaving the actual
+     * tile.
+     */
+    void andTileCid(int x, int y, int and_mask);
+
+    /**
+     * Set a single tile.
+     */
+    void setTile(JGPoint tileidx, String tilename);
+
+    /**
+     * Set a block of tiles according to the single-letter tile names in the
+     * nxm character array tilemap.
+     */
+    void setTiles(int xofs, int yofs, String[] tilemap);
+
+    /**
+     * Set a block of tiles according to the tile names in the nxm element
+     * array tilemap.  The tile names may be multiple characters.  Each String
+     * in the tilemap consists of a list of tile names separated by spaces. So:
+     * <code> "x aa ab abc"</code> stands for a sequence of four tiles, "x",
+     * "aa", "ab", and "abc".
+     */
+    void setTilesMulti(int xofs, int yofs, String[] tilemap);
+
+    /**
+     * Get collision id of the tile at given pixel coordinates.
+     */
+    int getTileCidAtCoord(double x, double y);
+
+    /**
+     * Get the tile cid of the point that is (xofs,yofs) from the tile index
+     * coordinate center.
+     */
+    int getTileCid(JGPoint center, int xofs, int yofs);
+
+    /**
+     * Get string id of the tile at given pixel coordinates.
+     */
+    String getTileStrAtCoord(double x, double y);
+
+    /**
+     * Get the tile string of the point that is (xofs,yofs) from the tile
+     * index coordinate center.
+     */
+    String getTileStr(JGPoint center, int xofs, int yofs);
+
+    /**
+     * Convert tile name to integer ID code (as used internally).  The ID
+     * code basically encodes the four characters of the string into the bytes
+     * of the four-byte integer.  The ID code is NOT related to the collision
+     * ID (CID).
+     *
+     * @param tilestr tilename, null or empty string -&gt; ID = 0
+     */
+    int tileStrToID(String tilestr);
+
+    /**
+     * Convert tile ID code to tile name (as used internally).  The ID
+     * code basically encodes the four characters of the string into the bytes
+     * of the four-byte integer.  The ID code is NOT related to the collision
+     * ID (CID).
+     *
+     * @param tileid tile ID, tileid==0 -&gt; tilename = empty string
+     */
+    String tileIDToStr(int tileid);
+
+    /*====== math ======*/
+
+
+    /**
+     * A modulo that moduloes symmetrically, relative to the
+     * middle of the view.  That is, the returned x/ypos falls within
+     * -pfwidth/height_half and pfwidth/height_half of x/yofs_mid
+     */
+    double moduloXPos(double x);
+
+    /**
+     * A modulo that moduloes symmetrically, relative to the
+     * middle of the view.  That is, the returned x/ypos falls within
+     * -pfwidth/height_half and pfwidth/height_half of x/yofs_mid
+     */
+    double moduloYPos(double y);
+
+
+    /**
+     * Show bounding boxes around the objects: the image bounding box
+     * (getBBox) , the tile span (getTiles), and the center tiles
+     * (getCenterTiles).
+     */
+    void dbgShowBoundingBox(boolean enabled);
+
+    /**
+     * Show the game state in the bottom right corner of the screen. The
+     * message font and foreground colour are used to draw the text.
+     */
+    void dbgShowGameState(boolean enabled);
+
+    /**
+     * Indicates whether to show full exception stack traces or just the
+     * first lines.  Default is false.
+     */
+    void dbgShowFullStackTrace(boolean enabled);
+
+    /**
+     * Output messages on playfield instead of console. Default is true.
+     * Messages printed by an object are displayed close to that object.
+     * Messages printed by the main program are shown at the bottom of the
+     * screen.  The debug message font is used to display the messages.
+     * <p>A message that is generated in this frame is shown in the foreground
+     * colour at the appropriate source.  If the source did not generate a
+     * message, the last printed message remains visible, and is shown in
+     * debug colour 1.  If an object prints a message, and then dies, the
+     * message will remain for a period of time after the object is gone.
+     * These messages are shown in debug colour 2.
+     */
+    void dbgShowMessagesInPf(boolean enabled);
+
+    /**
+     * Set the number of frames a debug message of a removed object should
+     * remain on the playfield.
+     */
+    void dbgSetMessageExpiry(int ticks);
+
+    /**
+     * Set the font for displaying debug messages.
+     */
+    void dbgSetMessageFont(JGFont font);
+
+    /**
+     * Set debug color 1, used for printing debug information.
+     */
+    void dbgSetDebugColor1(JGColor col);
+
+    /**
+     * Set debug color 2, used for printing debug information.
+     */
+    void dbgSetDebugColor2(JGColor col);
+
+
+    /**
+     * Print a debug message, with the main program being the source.
+     */
+    void dbgPrint(String msg);
+
+    /**
+     * Print a debug message from a specific source, which is either the main
+     * program or a JGObject.
+     *
+     * @param source may be object ID or "MAIN" for the main program.
+     */
+    void dbgPrint(String source, String msg);
+
+    /**
+     * Print the relevant information of an exception as a debug message.
+     *
+     * @param source may be object ID or "MAIN" for the main program.
+     */
+    void dbgShowException(String source, Throwable e);
+
+    /**
+     * Convert the relevant information of an exception to a multiline String.
+     */
+    String dbgExceptionToString(Throwable e);
+
+    /**
+     * Exit, optionally reporting an exit message.  The exit message can be
+     * used to report fatal errors.  In case of an application or midlet, the
+     * program exits.  In case of an applet, destroy is called, and the exit
+     * message is displayed on the playfield.
+     *
+     * @param msg an exit message, null means none
+     */
+    void exitEngine(String msg);
+
+
+    /**
+     * Init engine as component to be embedded in a frame or panel;
+     * call this in your engine constructor.
+     *
+     * @param width  canvas width
+     * @param height canvas height
+     */
+    void initEngineComponent(int width, int height);
+
+    /**
+     * Init engine as applet; call this in your engine constructor.  Applet
+     * init() will start the game.
+     */
+    void initEngineApplet();
+
+    /**
+     * Init engine as application.  Passing (0,0) for width, height will
+     * result in a full-screen window without decoration.  Passing another
+     * value results in a regular window with decoration.
+     *
+     * @param width  real screen width, 0 = use screen size
+     * @param height real screen height, 0 = use screen size
+     */
+    void initEngine(int width, int height);
+
+    /**
+     * Set canvas dimensions and message colours/fonts.  You must call this
+     * in initCanvas().
+     *
+     * @param nrtilesx nr of tiles horizontally
+     * @param nrtilesy nr of tiles vertically
+     * @param tilex    width of one tile
+     * @param tiley    height of one tile
+     * @param fgcolor  pen/text colour, null for default white
+     * @param bgcolor  background colour, null for default black
+     * @param msgfont  font for messages and text drawing, null for default
+     */
+    void setCanvasSettings(int nrtilesx, int nrtilesy, int tilex, int tiley,
+                           JGColor fgcolor, JGColor bgcolor, JGFont msgfont);
+
+    /**
+     * Set scaling preferences for translating the virtual playfield to the
+     * actual display. You can only call this in initCanvas().
+     * You can set the allowed aspect ratio and the crop margin here.
+     * Aspect ratio is defined as
+     * the ratio (actual_tile_width / actual_tile_height)
+     * / (virtual_tile_width / virtual_tile_height).  So, if the tile size of
+     * the scaled display is (3,2) pixels, and the original was (4,4) pixels,
+     * the aspect ratio is 1.5.  Default values for min_aspect_ratio and
+     * max_aspect_ratio are resp 0.75 and 1.333. Setting both to 1.0 means
+     * you always get a square aspect ratio.
+     * <p>
+     * Crop margin can be used if you wish to allow the scaling algorithm to
+     * take just a few pixels off your playfield in order to make a wider tile
+     * size fit.  The tile size is always integer,
+     * so even a best-fit scaled tile size may leave an unused border around
+     * the playfield, which may be undesirable for small screens.
+     * Cropping just a few pixels off the playfield may be just
+     * enough to make the tiles 1 pixel larger.
+     * Setting a crop to a value greater than zero means you
+     * allow the playfield to fall off the canvas for the amount of actual
+     * pixels specified, in order to make a larger tile size fit.
+     * Default crop margin is 0.
+     * <p>
+     *
+     * @param min_aspect_ratio minimum width:height ratio allowed
+     * @param max_aspect_ratio maximum width:height ratio allowed
+     * @param crop_top         number of pixels to crop at top
+     * @param crop_left        number of pixels to crop at left size
+     * @param crop_bottom      number of pixels to crop at bottom
+     * @param crop_right       number of pixels to crop at right size
+     */
+    void setScalingPreferences(double min_aspect_ratio, double
+            max_aspect_ratio, int crop_top, int crop_left, int crop_bottom, int crop_right);
+
+    /**
+     * Magnification can be set to smooth or blocky.  For platforms that
+     * enable smooth magnification (OpenGL), smoothing may look too blurry when
+     * magnifying by a large amount, so blocky magnification may actually look
+     * more charming.
+     *
+     * @param smooth_magnify smooth images when magnifying
+     */
+    void setSmoothing(boolean smooth_magnify);
+
+    /**
+     * Call this to get focus.
+     */
+    void requestGameFocus();
+
+    /**
+     * Are we running as an applet or as an application?
+     */
+    boolean isApplet();
+
+    /**
+     * Are we running as a midlet?
+     */
+    boolean isMidlet();
+
+    /**
+     * Are we running with an OpenGL backend?
+     */
+    boolean isOpenGL();
+
+    /**
+     * Are we running on Android?
+     */
+    boolean isAndroid();
+
+    /**
+     * Get the virtual width in pixels (not the scaled screen width)
+     */
+    int viewWidth();
+
+    /**
+     * Get the virtual height in pixels (not the scaled screen height)
+     */
+    int viewHeight();
+
+    /**
+     * Get the number of tiles of view window in X direction
+     */
+    int viewTilesX();
+
+    /**
+     * Get the number of tiles of view window in Y direction
+     */
+    int viewTilesY();
+
+    /**
+     * Get view offset as it will be at the next frame draw, in case we are
+     * not inside a frame draw, or the view offset as it is, when we are.
+     */
+    int viewXOfs();
+
+    /**
+     * Get view offset as it will be at the next frame draw, in case we are
+     * not inside a frame draw, or the view offset as it is, when we are.
+     */
+    int viewYOfs();
+
+    //public int viewTileXOfs();
+    //public int viewTileYOfs();
+
+    /**
+     * Get the virtual width in pixels (not the scaled screen width)
+     */
+    int pfWidth();
+
+    /**
+     * Get the virtual height in pixels (not the scaled screen height)
+     */
+    int pfHeight();
+
+    /**
+     * Get the number of tiles in X direction
+     */
+    int pfTilesX();
+
+    /**
+     * Get the number of tiles in Y direction
+     */
+    int pfTilesY();
+
+    /**
+     * Is playfield X wrap enabled?
+     */
+    boolean pfWrapX();
+
+    /**
+     * Is playfield Y wrap enabled?
+     */
+    boolean pfWrapY();
+
+    /**
+     * Get the tile width in (virtual) pixels.
+     */
+    int tileWidth();
+
+    /**
+     * Get the tile height in (virtual) pixels.
+     */
+    int tileHeight();
+
+    /**
+     * Get the real display width on this device.
+     */
+    int displayWidth();
+
+    /**
+     * Get the real display height on this device.
+     */
+    int displayHeight();
+
+
+    /**
+     * Override to define your own initialisations before the engine
+     * initialises.  This method is meant for doing initialisations after the
+     * applet has been initialised (in case we're an applet) but before the
+     * engine initialises.  This can be considered a replacement of the
+     * regular constructor, making it independent of whether we're an applet
+     * or application.  Typically you only need to call setCanvasSettings here,
+     * and, optionally, setScalingPreferences().
+     * This is the place where you can read applet parameters and initialise
+     * accordingly.  In case you want to adapt to the real display dimensions,
+     * you can get them using displayWidth/Height at this point.
+     */
+    void initCanvas();
+
+    /**
+     * Override to define your own initialisations after the engine
+     * initialised.  This method is called by the game thread after
+     * initEngine(), initEngineApplet(), or initEngineComponent() was called.
+     */
+    void initGame();
+
+    /**
+     * Signal that the engine should start running. May be called by the web
+     * browser.
+     */
+    void start();
+
+    /**
+     * signal that the engine should stop running and wait. May be called by
+     * the web browser.
+     */
+    void stop();
+
+    /**
+     * Called when midlet is first initialised, or unpaused.  Midlet version
+     * of init() when called for the first time, and start() for subsequent
+     * calls.
+     */
+    void startApp();
+
+    /**
+     * Called by the application manager to pause app. Basically
+     * the midlet version of stop(), behaves the same as stop().
+     */
+    void pauseApp();
+
+    /**
+     * Called by the application manager to exit app. Basically the
+     * midlet version of destroy(), behaves the same as destroy().
+     */
+    void destroyApp(boolean unconditional);
+
+    /**
+     * True if engine is running, false if paused.
+     */
+    boolean isRunning();
+
+    /**
+     * Make engine call start() when a key is pressed.  This can be used to
+     * determine a start criterion when halting the engine from within using
+     * stop().
+     *
+     * @param key keycode to wake up on, -1=any key or mouse, 0=none
+     */
+    void wakeUpOnKey(int key);
+
+    /**
+     * Destroy function for deinitialising the engine properly.  This is
+     * called by the applet viewer to dispose the applet.  Use exitEngine to
+     * destroy the applet and exit the system.
+     */
+    void destroy();
+
+    /**
+     * @return frame rate in frames per second
+     */
+    double getFrameRate();
+
+    /**
+     * @return max successive frames to skip
+     */
+    double getFrameSkip();
+
+    /**
+     * @return true = video synced mode enabled
+     */
+    boolean getVideoSyncedUpdate();
+
+    /**
+     * Change offset of playfield view.  The offset will become active
+     * at the next frame draw.  If the view would be out of the
+     * playfield's bounds, the offset is corrected so that it is inside them.
+     * The offset of the parallax level 0 background image is set to the
+     * offset as well, the other levels remain unchanged.
+     *
+     * @param centered center view on (xofs, yofs), topleft otherwise
+     */
+    void setViewOffset(int xofs, int yofs, boolean centered);
+
+    /**
+     * Change (absolute) offset of BG image independently of view offset.
+     * Only supported by parallax scrolling platforms.  Note that parallax
+     * level 0 follows the view offset, so a call to this method to set
+     * level 0 should be done after calling setViewOffset.
+     *
+     * @param depth    depth level of image to set
+     * @param centered center view on (xofs, yofs), topleft otherwise
+     */
+    void setBGImgOffset(int depth, double xofs, double yofs,
+                        boolean centered);
+
+    /**
+     * Zoom/rotate view.  Can be used to create special effects, like
+     * speed-dependent zoom, explosion shake, etc.  Only works in OpenGL.  If
+     * you zoom out too far, parts that are beyond the borders of the
+     * defined view may get exposed, the appearance of which is undefined.
+     * This also happens when you rotate, so you will also need to zoom in
+     * to ensure this
+     * does not happen.  Everything that is drawn relative to the playfield is
+     * zoomed/rotated, everything that is not is unaffected.  Game logic is
+     * unaffected.
+     * <P> Mouse coordinates are inverse projected through
+     * the last set zoom/rotate setting, so that a playfield relative
+     * pixel drawn at the logical mouse coordinates coincides with the
+     * physical position of the mouse pointer. If you don't want this, you can
+     * set zoom/rotate to (1,0), read the mouse position, then set zoom/rotate
+     * to the desired value.
+     * <P> The zoom/rotate setting used for actual drawing
+     * is the last value set at the end of the doFrame phase.  Should not be
+     * called during the paintFrame phase.
+     *
+     * @param zoom   zoom factor, 1.0 is normal size
+     * @param rotate angle in radians
+     */
+    void setViewZoomRotate(double zoom, double rotate);
+
+    /**
+     * Set the playfield size to be any size larger or equal to the view
+     * size.
+     *
+     * @param nrtilesx number of tiles, &gt;= viewTilesX()
+     * @param nrtilesy number of tiles, &gt;= viewTilesY()
+     */
+    void setPFSize(int nrtilesx, int nrtilesy);
+
+    /**
+     * Set playfield wraparound setting.  When wraparound is enabled, the
+     * playfield theoretically behaves as if it is infinitely long or high,
+     * with tiles and objects repeating periodically, with playfield size
+     * being the period.  Tile coordinates in a wrapped playfield are
+     * effectively modulo the playfield size.  Object coordinates are wrapped
+     * symmetrically to the view offset, that is, they are kept within
+     * -playfieldsize, +playfieldsize of the center of the view offset. This
+     * ensures that regular coordinate comparison and collision usually work
+     * as expected, without having to actually model the infinite repetition
+     * of the objects in the wrap direction.  The shiftx and shifty can be
+     * used to shift the object's wrap center by some pixels, to ensure they
+     * enter and leave the sides / top-bottom of the screen neatly when the
+     * playfield is not larger than the view.  For this case, use the
+     * following formula: ensure the playfield is slightly larger than the
+     * view (namely, one sprite length), and set the shift to sprite length/2.
+     */
+    void setPFWrap(boolean wrapx, boolean wrapy, int shiftx, int shifty);
+
+    /**
+     * Set frame rate in frames per second, and maximum number of frames that
+     * may be skipped before displaying a frame again. Default is 35 frames
+     * per second, with a maxframeskip of 4.
+     *
+     * @param fps          frames per second, useful range 2...80
+     * @param maxframeskip max successive frames to skip, useful range 0..10
+     */
+    void setFrameRate(double fps, double maxframeskip);
+
+    /**
+     * Enable/disable video synced update (jogl only).
+     * This method has no effect on non-jogl platforms,
+     * where it is always disabled.  The game state update becomes synced with
+     * the screen refresh rate.  Frame rate is no longer fixed, but depends on
+     * the machine the game is running on.  Gamespeed is set at the beginning
+     * of each frame to compensate for this.  Gamespeed is 1 when actual frame
+     * rate == frame rate set with setFrameRate, less than 1 if frame rate
+     * greater than setFrameRate, more than 1 if frame rate less than
+     * setFrameRate.  There is a hard upper and lower bound for gamespeed, to
+     * ensure it does not attain wild values under rare conditions.  Lower
+     * bound for game speed is determined by a fixed upper bound for the
+     * expected screen refresh rate, 95 hz.  Upper bound for game speed is
+     * determined by the frameskip setting.
+     */
+    void setVideoSyncedUpdate(boolean value);
+
+    /**
+     * Set game speed variable, default is 1.0.  Game speed affects certain
+     * parts of the game engine automatically to offload some of the work
+     * involved of adapting a game to different speeds.  These are the
+     * following: it is used as JGTimer tick increment, animation increment,
+     * JGObject expiry increment, and is used as multiplier for object
+     * x/yspeed, and for the default margins of is...Aligned and snapToGrid.
+     */
+    void setGameSpeed(double speed);
+
+    /**
+     * Get game speed variable.  This can be used if you have other stuff in
+     * your game that is affected by game speed, besides the standard game
+     * speed adaptation done by the engine.
+     */
+    double getGameSpeed();
+
+    /**
+     * Configure image rendering.  alpha_thresh is used to determine how a
+     * translucent image is converted to a bitmask image.  Alpha values below
+     * the threshold are set to 0, the others to 255. render_bg_col is used to
+     * render transparency for scaled images; it is the background colour that
+     * interpolations between transparent and non-transparent pixels are
+     * rendered to.  Currently, this has an effect in Jdk1.2 only. The default
+     * render_bg_col is null, meaning the global background colour is used.
+     *
+     * @param alpha_thresh  bitmask threshold, 0...255, default=128
+     * @param render_bg_col bg colour for render, null=use background colour
+     */
+    void setRenderSettings(int alpha_thresh, JGColor render_bg_col);
+
+    /**
+     * Set margin used for testing if object should expire or suspend when
+     * off-view or off-playfield. Default is 16,16.
+     */
+    void setOffscreenMargin(int xmargin, int ymargin);
+
+    /**
+     * Get offscreen X margin.
+     *
+     * @see #setOffscreenMargin(int, int)
+     */
+    int getOffscreenMarginX();
+
+    /**
+     * Get offscreen Y margin.
+     *
+     * @see #setOffscreenMargin(int, int)
+     */
+    int getOffscreenMarginY();
+
+
+    /**
+     * Set global background colour, which is displayed in borders, and behind
+     * transparent tiles if no BGImage is defined.
+     */
+    void setBGColor(JGColor bgcolor);
+
+    /**
+     * Set global foreground colour, used for printing text and status
+     * messages.  It is also the default colour for painting
+     */
+    void setFGColor(JGColor fgcolor);
+
+    /**
+     * Set the (unscaled) message font, used for displaying status messages.
+     * It is also the default font for painting.
+     */
+    void setMsgFont(JGFont msgfont);
+
+    /**
+     * Set foreground and background colour, and message font in one go;
+     * passing a null means ignore that argument.
+     */
+    void setColorsFont(JGColor fgcolor, JGColor bgcolor, JGFont msgfont);
+
+    /**
+     * Set parameters of outline surrounding text (for example, used to
+     * increase contrast).
+     *
+     * @param thickness 0 = turn off outline
+     */
+    void setTextOutline(int thickness, JGColor colour);
+
+    /**
+     * Platform-independent cursor.
+     */
+    int NO_CURSOR = -1;
+    /**
+     * Platform-independent cursor.
+     */
+    int DEFAULT_CURSOR = 0;
+    /**
+     * Platform-independent cursor.
+     */
+    int CROSSHAIR_CURSOR = 1;
+    /**
+     * Platform-independent cursor.
+     */
+    int HAND_CURSOR = 2;
+    /**
+     * Platform-independent cursor.
+     */
+    int WAIT_CURSOR = 3;
+
+    /**
+     * Set mouse cursor to a platform-independent standard cursor.
+     */
+    void setMouseCursor(int cursor);
+
+    /**
+     * Set mouse cursor, platform dependent. null (platform-independent)
+     * means hide cursor.
+     */
+    void setMouseCursor(Object cursor);
+
+    /**
+     * Remove all JGTimers still ticking in the system.
+     */
+    void removeAllTimers();
+
+    /**
+     * Register a timer with the engine, don't call directly.  This is called
+     * automatically by the JGTimer constructor.
+     */
+    void registerTimer(JGTimer timer);
+
+
+    /**
+     * Set the game's main state on the next frame.  Methods with the names
+     * doFrame&lt;state&gt; and paintFrame&lt;state&gt; will be called in
+     * addition to doFrame() and paintFrame(). Before the next frame,
+     * start&lt;state&gt; is called once.  Note that setGameState may actually
+     * set a state that's already set, in which case start&lt;state&gt; is not
+     * called. Also, if the setGameState is superseded by another setGameState
+     * within the same frame, the first setGameState is ignored.
+     */
+    void setGameState(String state);
+
+    /**
+     * Add the given state to the game's existing state on the next frame.
+     * The methods
+     * doFrame&lt;state&gt; and paintFrame&lt;state&gt; will be called <i>in
+     * addition to</i> the methods of any states already set.
+     * Before the next frame,
+     * start&lt;state&gt; is called once.  Note that addGameState may actually
+     * set a state that's already set, in which case start&lt;state&gt; is not
+     * called.
+     */
+    void addGameState(String state);
+
+    /**
+     * Remove the given state from the game's existing state on the next
+     * frame.
+     */
+    void removeGameState(String state);
+
+    /**
+     * Set the game's main state to none, on the next frame.
+     * Only doFrame() and paintFrame() will be called each frame.
+     */
+    void clearGameState();
+
+
+    /**
+     * Check if game is in given state.
+     */
+    boolean inGameState(String state);
+
+    /**
+     * Check if game will be in given state the next frame.
+     */
+    boolean inGameStateNextFrame(String state);
+
+    /**
+     * Is called every frame.  Override to define frame action.  Default is
+     * do nothing.
+     */
+    void doFrame();
+
+    /**
+     * Is called when the engine's default screen painting is finished,
+     * and custom painting actions may be carried out. Can be used to display
+     * status information or special graphics.  Default is do nothing.
+     */
+    void paintFrame();
+
+    /** Get the graphics context for drawing on the buffer during a
+     * paintFrame().  Returns null when not inside paintFrame. */
+    //public Graphics getBufferGraphics();
+
+    /**
+     * Get scale factor of real screen width wrt virtual screen width
+     */
+    double getXScaleFactor();
+
+    /**
+     * Get scale factor of real screen height wrt virtual screen height
+     */
+    double getYScaleFactor();
+
+    /**
+     * Get minimum of the x and y scale factors
+     */
+    double getMinScaleFactor();
+
+    /* some convenience functions for drawing during repaint and paintFrame()*/
+
+    /**
+     * Set current drawing colour.
+     */
+    void setColor(JGColor col);
+
+    /**
+     * Set current font, scale the font to screen size.
+     */
+    void setFont(JGFont font);
+
+    /** Set current font, scale the font to screen size. */
+    //public void setFont(Graphics g,JGFont font);
+
+    /**
+     * Set the line thickness
+     */
+    void setStroke(double thickness);
+
+    /**
+     * Set blend mode, for platforms that support blending.
+     * Blend functions supported are based on the alpha of the object
+     * being drawn (the drawing source).  Source and destination alpha
+     * multiplier are specified separately. These are one of:
+     * always 1 (encoded as 0), alpha (encoded as 1), and 1-alpha (encoded as
+     * -1).   Default is (1,-1).
+     *
+     * @param src_func source multiply factor, 0=one, 1=alpha, -1 = one - alpha
+     * @param dst_func destination multiply factor, 0=one, 1=alpha, -1 = one - alpha
+     */
+    void setBlendMode(int src_func, int dst_func);
+
+    /**
+     * Get height of given font in pixels.
+     */
+    double getFontHeight(JGFont font);
+    /** Get height of given font or current font in pixels. */
+    //double getFontHeight(Graphics g,JGFont font);
+
+
+    /* convert all coordinates to double?? */
+
+    /**
+     * DrawLine combined with thickness/colour setting. The line is drawn
+     * relative to the playfield coordinates.
+     */
+    void drawLine(double x1, double y1, double x2, double y2,
+                  double thickness, JGColor color);
+
+    /**
+     * Draw a line with current thickness and colour. The line is drawn
+     * relative to the playfield coordinates.
+     */
+    void drawLine(double x1, double y1, double x2, double y2);
+
+    /**
+     * Draw a line with current thickness and colour.
+     *
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawLine(double x1, double y1, double x2, double y2,
+                  boolean pf_relative);
+
+    /**
+     * Draw convex polygon.  For filled polygons, it is possible to draw a
+     * colour gradient, namely a "fan" of colours (specified by col),
+     * spreading from the first point to each successive point in the polygon.
+     * For line polygons, a gradient is drawn between successive line
+     * segments.
+     * On non-OpenGL platforms, the fill gradient is drawn as a fan of plain
+     * colours, with colour 0 and 1 ignored, the line gradient as plain
+     * coloured lines.
+     *
+     * @param x           x coordinates of the points
+     * @param y           y coordinates of the points
+     * @param col         colour of each point, null means use default colour
+     * @param len         number of points
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawPolygon(double[] x, double[] y, JGColor[] col, int len,
+                     boolean filled, boolean pf_relative);
+
+    /**
+     * Set colour/thickness and draw rectangle.  Coordinates are relative to
+     * playfield.
+     *
+     * @param centered indicates (x,y) is center instead of topleft.
+     */
+    void drawRect(double x, double y, double width, double height, boolean filled,
+                  boolean centered, double thickness, JGColor color);
+
+    /**
+     * Draw rectangle in default colour and thickness.  Coordinates are
+     * relative to playfield.
+     *
+     * @param centered indicates (x,y) is center instead of topleft.
+     */
+    void drawRect(double x, double y, double width, double height, boolean filled,
+                  boolean centered);
+
+    /**
+     * Draw rectangle in default colour and thickness.
+     *
+     * @param centered    indicates (x,y) is center instead of topleft.
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawRect(double x, double y, double width, double height, boolean filled,
+                  boolean centered, boolean pf_relative);
+
+    /**
+     * Draw shaded rectangle.  On non-opengl platforms, rectangle is drawn in
+     * default colour.
+     *
+     * @param shadecol colors topleft,topright,botright,botleft corners
+     */
+    void drawRect(double x, double y, double width, double height,
+                  boolean filled, boolean centered, boolean pf_relative,
+                  JGColor[] shadecol);
+
+    /**
+     * Draw shaded or patterned rectangle.  On non-opengl platforms,
+     * rectangle is drawn in default colour.
+     *
+     * @param shadecol colors topleft,topright,botright,botleft corners
+     */
+    void drawRect(double x, double y, double width, double height,
+                  boolean filled, boolean centered, boolean pf_relative,
+                  JGColor[] shadecol, String tileimage);
+
+    /**
+     * Set thickness/colour and draw oval.  Coordinates are relative to
+     * playfield.
+     *
+     * @param centered indicates (x,y) is center instead of topleft.
+     */
+    void drawOval(double x, double y, double width, double height, boolean filled,
+                  boolean centered, double thickness, JGColor color);
+
+    /**
+     * Draw oval with default thickness and colour. Coordinates are relative
+     * to playfield.
+     *
+     * @param centered indicates (x,y) is center instead of topleft.
+     */
+    void drawOval(double x, double y, double width, double height, boolean filled,
+                  boolean centered);
+
+    /**
+     * Draw oval with default thickness and colour.
+     *
+     * @param centered    indicates (x,y) is center instead of topleft.
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawOval(double x, double y, double width, double height, boolean filled,
+                  boolean centered, boolean pf_relative);
+
+    /**
+     * Draw image with given ID. Coordinates are relative to playfield.
+     */
+    void drawImage(double x, double y, String imgname);
+
+    /**
+     * Draw image with given ID.
+     *
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawImage(double x, double y, String imgname, boolean pf_relative);
+
+    /**
+     * Extended version of drawImage for OpenGL or Android.
+     * On platforms without support for accelerated blending, rotation,
+     * scaling, this call is equivalent to drawImage(x,y,imgname,pf_relative).
+     * <p>
+     * rotation and scaling are centered around the image center.
+     *
+     * @param blend_col colour to blend with image, null=(alpha,alpha,alpha)
+     * @param alpha     alpha (blending) value, 0=transparent, 1=opaque
+     * @param rot       rotation of object in degrees (radians)
+     * @param scale     scaling of object (1 = normal size).
+     */
+    void drawImage(double x, double y, String imgname, JGColor blend_col,
+                   double alpha, double rot, double scale, boolean pf_relative);
+
+
+    /**
+     * Draw image with given ID, new version.
+     * Coordinates are relative to playfield.
+     */
+    void drawImage(String imgname, double x, double y);
+
+    /**
+     * Draw image with given ID, new version.
+     *
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawImage(String imgname, double x, double y, boolean pf_relative);
+
+    /**
+     * Extended version of drawImage for OpenGL or Android, new version.
+     * On platforms without support for accelerated blending, rotation,
+     * scaling, this call is equivalent to drawImage(x,y,imgname,pf_relative).
+     * <p>
+     * rotation and scaling are centered around the image center.
+     *
+     * @param blend_col colour to blend with image, null=(alpha,alpha,alpha)
+     * @param alpha     alpha (blending) value, 0=transparent, 1=opaque
+     * @param rot       rotation of object in degrees (radians)
+     * @param scale     scaling of object (1 = normal size).
+     */
+    void drawImage(String imgname, double x, double y,
+                   boolean pf_relative, JGColor blend_col,
+                   double alpha, double rot, double scale);
+
+
+    /**
+     * Draws string so that (x,y) is the topleft coordinate (align=-1), the
+     * top middle coordinate (align=0), or the top right coordinate (align=1).
+     * Use given font and colour; filling in null for either means ignore.
+     * Unlike the other draw functions, for strings, coordinates are relative
+     * to view by default.  An outline is drawn around the text when defined
+     * by setTextOutline.
+     *
+     * @param align text alignment, -1=left, 0=center, 1=right
+     */
+    void drawString(String str, double x, double y, int align,
+                    JGFont font, JGColor color);
+
+    /**
+     * Draws string so that (x,y) is the topleft coordinate (align=-1), the
+     * top middle coordinate (align=0), or the top right coordinate (align=1).
+     * Use current font and colour.
+     * Unlike the other draw functions, for strings, coordinates are relative
+     * to view by default. An outline is drawn around the text when defined
+     * by setTextOutline.
+     *
+     * @param align text alignment, -1=left, 0=center, 1=right
+     */
+    void drawString(String str, double x, double y, int align);
+
+    /**
+     * Draws string so that (x,y) is the topleft coordinate (align=-1), the
+     * top middle coordinate (align=0), or the top right coordinate (align=1).
+     * Use current font and colour. An outline is drawn around the text when
+     * defined by setTextOutline.
+     *
+     * @param align       text alignment, -1=left, 0=center, 1=right
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawString(String str, double x, double y, int align,
+                    boolean pf_relative);
+
+    /** Internal function for writing on both buffer and screen.  Coordinates
+     * are always relative to view. */
+    //void drawString(Graphics g, String str, double x, double y, int align,
+    //boolean pf_relative);
+
+    /**
+     * Draws a single line of text using an image map as font;
+     * text alignment is same as drawString.  Typically, an image font only
+     * defines the ASCII character range 32-96.  In this case, set char_offset
+     * to 32, and use only the uppercase letters.  Coordinates are relative to
+     * view.
+     *
+     * @param align       text alignment, -1=left, 0=center, 1=right
+     * @param imgmap      name of image map
+     * @param char_offset ASCII code of first image of image map
+     * @param spacing     number of pixels to skip between letters
+     */
+    void drawImageString(String string, double x, double y, int align,
+                         String imgmap, int char_offset, int spacing);
+
+    /**
+     * Draws a single line of text using an image map as font;
+     * text alignment is same as drawString.  Typically, an image font only
+     * defines the ASCII character range 32-96.  In this case, set char_offset
+     * to 32, and use only the uppercase letters.
+     *
+     * @param align       text alignment, -1=left, 0=center, 1=right
+     * @param imgmap      name of image map
+     * @param char_offset ASCII code of first image of image map
+     * @param spacing     number of pixels to skip between letters
+     * @param pf_relative coordinates are relative to playfield, otherwise view
+     */
+    void drawImageString(String string, double x, double y, int align,
+                         String imgmap, int char_offset, int spacing, boolean pf_relative);
+
+    /**
+     * Get current mouse position in logical coordinates, inverse projected
+     * through last set view zoom/rotate setting.
+     */
+    JGPoint getMousePos();
+
+    /**
+     * Get current mouse X position
+     */
+    int getMouseX();
+
+    /**
+     * Get current mouse Y position
+     */
+    int getMouseY();
+
+    /**
+     * Get state of button.
+     *
+     * @param nr 1=button 1 ... 3 = button 3
+     * @return true=pressed, false=released
+     */
+    boolean getMouseButton(int nr);
+
+    /**
+     * Set state of button to released.
+     *
+     * @param nr 1=button 1 ... 3 = button 3
+     */
+    void clearMouseButton(int nr);
+
+    /**
+     * Set state of button to pressed.
+     *
+     * @param nr 1=button 1 ... 3 = button 3
+     */
+    void setMouseButton(int nr);
+
+    /**
+     * Check if mouse is inside game window
+     */
+    boolean getMouseInside();
+
+    /**
+     * Get the key status of the given key.
+     */
+    boolean getKey(int key);
+
+    /**
+     * Set the key status of a key to released.
+     */
+    void clearKey(int key);
+
+    /**
+     * Set the key status of a key to pressed.
+     */
+    void setKey(int key);
+
+    /**
+     * Get the keycode of the key that was pressed last, 0=none.
+     */
+    int getLastKey();
+
+    /**
+     * Get the keycode of the key that was pressed last, 0=none.
+     */
+    char getLastKeyChar();
+
+    /**
+     * Clear the lastkey status.
+     */
+    void clearLastKey();
+
+    /**
+     * Get a printable string describing the key.
+     */
+    String getKeyDesc(int key);
+
+    /**
+     * Obtain key code from printable string describing the key, the inverse
+     * of getKeyDesc. The string is trimmed and lowercased.
+     */
+    int getKeyCode(String keydesc);
+
+    /**
+     * returns true if device has accelerometer (currently only android)
+     */
+    boolean hasAccelerometer();
+
+    /**
+     * get accelerometer vector X coordinate
+     */
+    double getAccelX();
+
+    /**
+     * get accelerometer vector Y coordinate
+     */
+    double getAccelY();
+
+    /**
+     * get accelerometer vector Z coordinate (positive = towards user)
+     */
+    double getAccelZ();
+
+    /**
+     * get double[3] vector representing acceleration
+     */
+    double[] getAccelVec();
+
+    /*====== animation ======*/
+
+    /**
+     * Define new animation sequence. Speed must be &gt;= 0.
+     *
+     * @param id     the name by which the animation is known
+     * @param frames an array of image names that should be played in sequence
+     * @param speed  the sequence speed: the number of animation steps per frame
+     */
+    void defineAnimation(String id,
+                         String[] frames, double speed);
+
+    /**
+     * Define new animation sequence. Speed must be &gt;= 0.
+     *
+     * @param id       the name by which the animation is known
+     * @param frames   an array of image names that should be played in sequence
+     * @param speed    the sequence speed: the number of animation steps per frame
+     * @param pingpong true=play the images in forward order, then in reverse
+     */
+    void defineAnimation(String id,
+                         String[] frames, double speed, boolean pingpong);
+
+    /**
+     * Get animation definition, don't call directly.  This is used by
+     * JGObjects to get animations.
+     */
+    Animation getAnimation(String id);
+
+
+    /*== file op ==*/
+
+    /**
+     * Returns path to writable location for a file with the given name.
+     * Basically it uses [user.home] / .jgame / [filename], with "/" being the
+     * system path separator.  In case [user.home] / .jgame does not exist, it
+     * is created.  In case .jgame is not a directory, null is returned.  In
+     * case the file does not exist yet, an empty file is created.
+     *
+     * @return path to writable file, or null if not possible
+     */
+    String getConfigPath(String filename);
+
+    /**
+     * Execute or go to URL (action depends on file type).
+     *
+     * @return 0 if fail; 1 if success; -1 if the status is unknown
+     */
+    int invokeUrl(String url, String target);
+
+    /* computation */
+
+    /**
+     * A Boolean AND shorthand to use for collision;
+     * returns (value&amp;mask) != 0.
+     */
+    boolean and(int value, int mask);
+
+    /**
+     * A floating-point random number between min and max
+     */
+    double random(double min, double max);
+
+    /**
+     * Generates discrete random number between min and max inclusive, with
+     * steps of interval.  Epsilon is added to max to ensure there are no
+     * rounding error problems with the interval.  So, random(0.0, 4.2, 2.1)
+     * generates either 0.0, 2.1, or 4.2 with uniform probabilities.  If max
+     * is halfway between interval steps, max is treated as exclusive.  So,
+     * random(0.0,5.0,2.1) generates 0.0, 2.1, 4.2 with uniform probabilities.
+     * If you need integer ranges, be sure to use the integer version to avoid
+     * rounding problems.
+     */
+    double random(double min, double max, double interval);
+
+    /**
+     * Generates discrete random number between min and max inclusive, with
+     * steps of interval, integer version.  If max is halfway between two
+     * interval steps, it is treated as exclusive.
+     */
+    int random(int min, int max, int interval);
+
+    /**
+     * Replacement for Math.atan2 for the sake of MIDP portability.  The JRE
+     * implementation simply uses Math.atan2, for MIDP a short and fast
+     * Math.atan2 replacement is used, with average numerical error less than
+     * 0.001 radians, maximum error 0.005 radians.
+     */
+    double atan2(double y, double x);
+
+
+    /**
+     * Get tile index of the tile the coordinate is on.
+     */
+    JGPoint getTileIndex(double x, double y);
+
+    /**
+     * Get pixel coordinate corresponding to the top left of the tile at the
+     * given index
+     */
+    JGPoint getTileCoord(int tilex, int tiley);
+
+    /**
+     * Get pixel coordinate corresponding to the top left of the tile at the
+     * given index
+     */
+    JGPoint getTileCoord(JGPoint tileidx);
+
+    /**
+     * Snap to grid, double version. Epsilon is added to the gridsnap value,
+     * so that isXAligned(x,margin) always implies that snapToGridX(x,margin)
+     * will snap.
+     *
+     * @param x         position to snap
+     * @param gridsnapx snap margin, 0.0 means no snap
+     */
+    double snapToGridX(double x, double gridsnapx);
+
+    /**
+     * Snap to grid, double version. Epsilon is added to the gridsnap value,
+     * so that isYAligned(y,margin) always implies that snapToGridY(y,margin)
+     * will snap.
+     *
+     * @param y         position to snap
+     * @param gridsnapy snap margin, 0.0 means no snap
+     */
+    double snapToGridY(double y, double gridsnapy);
+
+    /**
+     * Snap p to grid in case p is close enough to the grid lines. Note: this
+     * function only handles integers so it should not be used to snap an
+     * object position.
+     */
+    void snapToGrid(JGPoint p, int gridsnapx, int gridsnapy);
+
+    /**
+     * Returns true if x falls within margin of the tile snap grid. Epsilon
+     * is added to the margin, so that isXAligned(1.0000, 1.0000)
+     * always returns true.
+     */
+    boolean isXAligned(double x, double margin);
+
+    /**
+     * Returns true if y falls within margin of the tile snap grid. Epsilon
+     * is added to the margin, so that isYAligned(1.0000, 1.0000)
+     * always returns true.
+     */
+    boolean isYAligned(double y, double margin);
+
+    /**
+     * Returns the difference between position and the closest tile-aligned
+     * position.
+     */
+    double getXAlignOfs(double x);
+
+    /**
+     * Returns the difference between position and the closest tile-aligned
+     * position.
+     */
+    double getYAlignOfs(double y);
+
+    // XXX please test these two methods
+
+    /**
+     * Calculates length of the shortest path between x1 and x2,
+     * with x1, x2 being playfield coordinates,
+     * taking into account the wrap setting.
+     */
+    double getXDist(double x1, double x2);
+
+    /**
+     * Calculates length of the shortest path between y1 and y2,
+     * with y1, y2 being playfield coordinates,
+     * taking into account the wrap setting.
+     */
+    double getYDist(double y1, double y2);
+
+
+
+    /*===== audio =====*/
+
+
+    /**
+     * Enable audio, restart any audio loops.
+     */
+    void enableAudio();
+
+    /**
+     * Disable audio, stop all currently playing audio.  Audio commands will
+     * be ignored, except that audio loops (music, ambient sounds) are
+     * remembered and will be restarted once audio is enabled again.
+     */
+    void disableAudio();
+
+    /**
+     * Associate given clipid with a filename.  Files are loaded from the
+     * resource path.  Java 1.2+ supports at least: midi and wav files.
+     */
+    void defineAudioClip(String clipid, String filename);
+
+    /**
+     * Returns the audioclip that was last played, null if audio was stopped
+     * with stopAudio.	Note the clip does not actually have to be playing; it
+     * might have finished playing already.
+     */
+    String lastPlayedAudio(String channel);
+
+    /**
+     * Play audio clip on unnamed channel, which means it will not replace
+     * another clip, and cannot be stopped.  The clip is not looped.  When
+     * this method is called multiple times with the same sample within the
+     * same frame, it is played only once.
+     */
+    void playAudio(String clipid);
+
+    /**
+     * Play clip on channel with given name.  Will replace any other clip
+     * already playing on the channel.  Will restart if the clip is already
+     * playing <i>and</i> either this call or the already playing one are
+     * <i>not</i> specified as looping.  If both are looping, the looped sound
+     * will continue without restarting.  If you want the looping sound to be
+     * restarted, call stopAudio first.  Note the channel "music" is reserved
+     * for enabling/disabling music separately in future versions.
+     */
+    void playAudio(String channel, String clipid, boolean loop);
+
+    /**
+     * Stop one audio channel.
+     */
+    void stopAudio(String channel);
+
+    /**
+     * Stop all audio channels.
+     */
+    void stopAudio();
+
+
+    /*===== store =====*/
+
+    /**
+     * Writes integer to store under given ID
+     */
+    void storeWriteInt(String id, int value);
+
+    /**
+     * Writes double to store under given ID
+     */
+    void storeWriteDouble(String id, double value);
+
+    /**
+     * Writes string to store under given ID
+     */
+    void storeWriteString(String id, String value);
+
+    /**
+     * Remove record if it exists
+     */
+    void storeRemove(String id);
+
+    /**
+     * Checks if item exists in store
+     */
+    boolean storeExists(String id);
+
+    /**
+     * Reads int from store, use undef if ID not found
+     */
+    int storeReadInt(String id, int undef);
+
+    /**
+     * Reads double from store, use undef if ID not found
+     */
+    double storeReadDouble(String id, double undef);
+
+    /**
+     * Reads String from store, use undef if ID not found
+     */
+    String storeReadString(String id, String undef);
+
+    /*====== options ======*/
+
+    /**
+     * Adds title to be displayed above subsequent items.  Default title of
+     * initial items is "Preferences".  Call this before defining any items to
+     * override the default title.
+     */
+    void optsAddTitle(String title);
+
+    /**
+     * adds (int or float) number that can be configured with a slider.
+     * Type is double if decimals!=0, int otherwise.
+     *
+     * @param decimals number is int if 0
+     **/
+    void optsAddNumber(String varname, String title, String desc,
+                       int decimals, double lower, double upper, double step, double initial);
+
+    /**
+     * Adds boolean that can be configured with a checkbox. Actual type is
+     * int (0 or 1)
+     */
+    void optsAddBoolean(String varname, String title, String desc,
+                        boolean initial);
+
+    /**
+     * Adds enum that can be configured with radio buttons. Actual type is
+     * int, 0 for first item, 1 for second item, etc.
+     */
+    void optsAddEnum(String varname, String title, String desc,
+                     String[] values, int initial);
+
+    /**
+     * Adds "key" option that can be configured by selecting a key or button
+     * on the device.  Actual type is int.
+     */
+    void optsAddKey(String varname, String title, String desc, int initial);
+
+    /**
+     * Adds String that can be configured by typing text.
+     */
+    void optsAddString(String varname, String title, String desc,
+                       int maxlen, boolean isPassword, String initial);
+
+    /**
+     * Clear all previous option definitions.
+     */
+    void optsClear();
 
 }
 
diff --git a/app/src/main/java/jgame/impl/JGameError.java b/app/src/main/java/jgame/impl/JGameError.java
index ef0a7cc..ec7c432 100644
--- a/app/src/main/java/jgame/impl/JGameError.java
+++ b/app/src/main/java/jgame/impl/JGameError.java
@@ -1,19 +1,28 @@
 package jgame.impl;
-/** Exception used for passing error conditions within JGame */
+
+/**
+ * Exception used for passing error conditions within JGame
+ */
 public class JGameError extends Error {
-	String msg;
-	boolean fatal=false;
+    String msg;
+    boolean fatal = false;
 
-	/** Construct non-fatal error */
-	public JGameError(String message) {
-		msg=message;
-	}
+    /**
+     * Construct non-fatal error
+     */
+    public JGameError(String message) {
+        msg = message;
+    }
 
-	/** Construct fatal or non-fatal error */
-	public JGameError(String message, boolean fatal) {
-		msg=message;
-		this.fatal=fatal;
-	}
+    /**
+     * Construct fatal or non-fatal error
+     */
+    public JGameError(String message, boolean fatal) {
+        msg = message;
+        this.fatal = fatal;
+    }
 
-	public String toString() { return msg; }
+    public String toString() {
+        return msg;
+    }
 }
diff --git a/app/src/main/java/jgame/impl/SortedArray.java b/app/src/main/java/jgame/impl/SortedArray.java
index 0b46df0..2b6d840 100644
--- a/app/src/main/java/jgame/impl/SortedArray.java
+++ b/app/src/main/java/jgame/impl/SortedArray.java
@@ -2,164 +2,164 @@ package jgame.impl;
 
 import java.util.Random;
 
-/** Data structure that can be used as replacement for Hashtable&lt;String&gt;
+/**
+ * Data structure that can be used as replacement for Hashtable&lt;String&gt;
  * for fast sorted enumeration of its elements.  It can get and put like a
  * Hashtable.  Get uses binary search, and is a little, but not much,  slower
  * than Hashtable.get.  Put and remove are expensive as they require shifting
  * the array (algorithm duration is linear wrt the array size).  It is
  * possible to put or remove multiple elements at a time (using a second
  * SortedArray), which is faster.
-
+ *
  * <P> Array enumeration is done by simply traversing the keys and/or values
  * array, which are filled with elements from 0 to size, exclusive.  This is
  * about 10 times faster than using the Hashtable.getElements/getKeys
  * enumerators, and the elements are sorted (in ascending order).
-
+ *
  * <P> SortedArray grows automatically to accommodate the required elements.
  * It starts with given initialcapacity and grows with increments
  * initialcapacity each time the capacity is exceeded.
-
  */
 public class SortedArray {
 
-	int capacity;
-	int growspeed;
+    int capacity;
+    int growspeed;
 
-	public int size=0;
-	public String [] keys;
-	public Object [] values;
+    public int size = 0;
+    public String[] keys;
+    public Object[] values;
 
-	public SortedArray(int initialcapacity) {
-		capacity=initialcapacity;
-		growspeed = initialcapacity;
-		keys = new String [capacity];
-		values = new Object [capacity];
-	}
+    public SortedArray(int initialcapacity) {
+        capacity = initialcapacity;
+        growspeed = initialcapacity;
+        keys = new String[capacity];
+        values = new Object[capacity];
+    }
 
-	public void clear() {
-		clear(0);
-	}
+    public void clear() {
+        clear(0);
+    }
 
-	void clear(int startidx) {
-		for (int i=startidx; i<size; i++) {
-			keys[i]=null;
-			values[i]=null;
-		}
-		size=startidx; 
-	}
+    void clear(int startidx) {
+        for (int i = startidx; i < size; i++) {
+            keys[i] = null;
+            values[i] = null;
+        }
+        size = startidx;
+    }
 
-	public void put(SortedArray elem) {
-		// go through elem, and
-		// (1) put the elements of which keys are already present
-		// (2) store the indexes of the elements of which keys are not present
-		int [] idxes = new int[elem.size];
-		int oldsize=size;
-		int newsize=size;
-		for (int i=elem.size-1; i>=0; i--) {
-			int idx = get(elem.keys[i]);
-			//System.out.println("IDX:"+idx);
-			if (idx >= 0) {
-				keys[idx]=elem.keys[i];
-				values[idx]=elem.values[i];
-				// set size to last idx found, so that get() doesn't search the
-				// last part
-				size=idx;
-			} else {
-				size = -1-idx;
-				newsize++;
-			}
-			idxes[i]=-1-idx;
-		}
-		// restore old size, so grow doesn't get confused
-		size = oldsize;
-		// now, shift the array to store the remaining elements
-		if (newsize > capacity) grow(newsize-oldsize);
-		int oldi=oldsize-1;
-		int newi=newsize-1;
-		for (int i=elem.size-1; i>=0; i--) {
-			if (idxes[i]<0) continue;
-			//System.out.println("idx:"+idxes[i]);
-			while (oldi>=idxes[i]) {
-				keys[newi]=keys[oldi];
-				values[newi--]=values[oldi--];
-			}
-			keys[newi]=elem.keys[i];
-			values[newi--]=elem.values[i];
-		}
-		size=newsize;
-		//checkSanity();
-	}
+    public void put(SortedArray elem) {
+        // go through elem, and
+        // (1) put the elements of which keys are already present
+        // (2) store the indexes of the elements of which keys are not present
+        int[] idxes = new int[elem.size];
+        int oldsize = size;
+        int newsize = size;
+        for (int i = elem.size - 1; i >= 0; i--) {
+            int idx = get(elem.keys[i]);
+            //System.out.println("IDX:"+idx);
+            if (idx >= 0) {
+                keys[idx] = elem.keys[i];
+                values[idx] = elem.values[i];
+                // set size to last idx found, so that get() doesn't search the
+                // last part
+                size = idx;
+            } else {
+                size = -1 - idx;
+                newsize++;
+            }
+            idxes[i] = -1 - idx;
+        }
+        // restore old size, so grow doesn't get confused
+        size = oldsize;
+        // now, shift the array to store the remaining elements
+        if (newsize > capacity) grow(newsize - oldsize);
+        int oldi = oldsize - 1;
+        int newi = newsize - 1;
+        for (int i = elem.size - 1; i >= 0; i--) {
+            if (idxes[i] < 0) continue;
+            //System.out.println("idx:"+idxes[i]);
+            while (oldi >= idxes[i]) {
+                keys[newi] = keys[oldi];
+                values[newi--] = values[oldi--];
+            }
+            keys[newi] = elem.keys[i];
+            values[newi--] = elem.values[i];
+        }
+        size = newsize;
+        //checkSanity();
+    }
 
-	public void put(String key,Object value) {
-		int idx = get(key);
-		if (idx>=0) {
-			keys[idx] = key;
-			values[idx] = value;
-			return;
-		}
-		if (size+1 > capacity) grow(1);
-		size++;
-		idx = -1-idx;
-		for (int i=size-1; i>idx; i--) {
-			keys[i] = keys[i-1];
-			values[i] = values[i-1];
-		}
-		keys[idx] = key;
-		values[idx] = value;
-		//checkSanity();
-	}
+    public void put(String key, Object value) {
+        int idx = get(key);
+        if (idx >= 0) {
+            keys[idx] = key;
+            values[idx] = value;
+            return;
+        }
+        if (size + 1 > capacity) grow(1);
+        size++;
+        idx = -1 - idx;
+        for (int i = size - 1; i > idx; i--) {
+            keys[i] = keys[i - 1];
+            values[i] = values[i - 1];
+        }
+        keys[idx] = key;
+        values[idx] = value;
+        //checkSanity();
+    }
 
-	void grow(int amount) {
-		capacity += amount+growspeed;
-		String [] newkeys = new String[capacity];
-		Object [] newvalues = new Object [capacity];
-		for (int i=0; i<size; i++) {
-			newkeys[i] = keys[i];
-			newvalues[i] = values[i];
-		}
-		keys = newkeys;
-		values = newvalues;
-	}
+    void grow(int amount) {
+        capacity += amount + growspeed;
+        String[] newkeys = new String[capacity];
+        Object[] newvalues = new Object[capacity];
+        for (int i = 0; i < size; i++) {
+            newkeys[i] = keys[i];
+            newvalues[i] = values[i];
+        }
+        keys = newkeys;
+        values = newvalues;
+    }
 
-	public void remove(String key) {
-		int idx = get(key);
-		if (idx>=0) {
-			values[idx]=null;
-			removeNullValues(idx);
-		}
-		//checkSanity();
-	}
+    public void remove(String key) {
+        int idx = get(key);
+        if (idx >= 0) {
+            values[idx] = null;
+            removeNullValues(idx);
+        }
+        //checkSanity();
+    }
 
-	public void remove(SortedArray elem) {
-		int lowidx=size;
-		int oldsize=size;
-		for (int i=elem.size-1; i>=0; i--) {
-			int idx = get(elem.keys[i]);
-			if (idx>=0) {
-				values[idx]=null;
-				lowidx=idx;
-				size=idx;
-			} else {
-				size=-1-idx;
-			}
-		}
-		size=oldsize;
-		//lowidx points to the lowest index of the nulled value indexes
-		if (lowidx<size) removeNullValues(lowidx);
-		//checkSanity();
-	}
+    public void remove(SortedArray elem) {
+        int lowidx = size;
+        int oldsize = size;
+        for (int i = elem.size - 1; i >= 0; i--) {
+            int idx = get(elem.keys[i]);
+            if (idx >= 0) {
+                values[idx] = null;
+                lowidx = idx;
+                size = idx;
+            } else {
+                size = -1 - idx;
+            }
+        }
+        size = oldsize;
+        //lowidx points to the lowest index of the nulled value indexes
+        if (lowidx < size) removeNullValues(lowidx);
+        //checkSanity();
+    }
 
-	void removeNullValues(int firstidx) {
-		for (int i=firstidx; i<size; i++) {
-			if (values[i]!=null) {
-				keys[firstidx] = keys[i];
-				values[firstidx++] = values[i];
-			}
-		}
-		clear(firstidx);
-	}
+    void removeNullValues(int firstidx) {
+        for (int i = firstidx; i < size; i++) {
+            if (values[i] != null) {
+                keys[firstidx] = keys[i];
+                values[firstidx++] = values[i];
+            }
+        }
+        clear(firstidx);
+    }
 
-	public int get(String key) {
+    public int get(String key) {
 		/*
 		// algorithm 2 (wikipedia)
 		int low = 0;
@@ -193,83 +193,87 @@ public class SortedArray {
 				return mid;
 		}
 		return -1;*/
-		// algorithm 1 returning position to insert a new value
-		int low = 0;
-		int high = size-1;
-		int cmp=0;
-		while (low <= high) {
-			int mid = (low + high) / 2;
-			cmp = keys[mid].compareTo(key);
-			if (cmp>0) {
-				high = mid - 1;
-			} else if (cmp<0) {
-				low = mid + 1;
-			} else {
-				return mid;
-			}
-		}
-		return -1-low;
-   }
+        // algorithm 1 returning position to insert a new value
+        int low = 0;
+        int high = size - 1;
+        int cmp = 0;
+        while (low <= high) {
+            int mid = (low + high) / 2;
+            cmp = keys[mid].compareTo(key);
+            if (cmp > 0) {
+                high = mid - 1;
+            } else if (cmp < 0) {
+                low = mid + 1;
+            } else {
+                return mid;
+            }
+        }
+        return -1 - low;
+    }
 
-	public String toString() {
-		String res="SortedArray";
-		for (int i=0; i<size; i++) {
-			res += "{"+keys[i]+"/"+values[i]+"},";
-		}
-		return res;
-	}
+    public String toString() {
+        String res = "SortedArray";
+        for (int i = 0; i < size; i++) {
+            res += "{" + keys[i] + "/" + values[i] + "},";
+        }
+        return res;
+    }
 
-	/** do some sanity checks */
-	void checkSanity() {
-		for (int i=0; i<size; i++) {
-			if (keys[i] == null || values[i] == null) {
-				System.err.println("####### Sanity check failed! ######");
-				System.err.println(toString());
-				throw new Error("Assertion failure!");
-			}
-		}
-	}
+    /**
+     * do some sanity checks
+     */
+    void checkSanity() {
+        for (int i = 0; i < size; i++) {
+            if (keys[i] == null || values[i] == null) {
+                System.err.println("####### Sanity check failed! ######");
+                System.err.println(toString());
+                throw new Error("Assertion failure!");
+            }
+        }
+    }
 
-	/** test method */
-	public static void main(String [] args) {
-		System.out.println("Testing SortedArray ...");
-		Object dummyobject = "dummy";
-		SortedArray arr_accum = new SortedArray(20);
-		Random random = new Random();
-		for (int n=0; n<1000; n++) {
-			// create two random sorted arrays and combine them
-			SortedArray arr1 = new SortedArray(21);
-			SortedArray arr2 = new SortedArray(22);
-			// second array has more collisions
-			for (int i=0; i<100; i++) {
-				arr2.put("key"+(int)(100+20*random.nextDouble()), dummyobject);
-				arr2.remove("key"+(int)(100+20*random.nextDouble()));
-			}
-			// first array has few collisions
-			for (int i=0; i<100; i++) {
-				arr1.put("key"+(int)(100+100*random.nextDouble()), dummyobject);
-				arr1.remove("key"+(int)(100+100*random.nextDouble()));
-			}
-			arr1.checkSanity();
-			arr2.checkSanity();
-			arr1.remove(arr2);
-			arr1.checkSanity();
-			SortedArray arr_added = new SortedArray(23);
-			arr_added.put(arr2);
-			arr_added.put(arr1);
-			arr_added.checkSanity();
-			arr_added.remove(arr2);
-			arr_added.checkSanity();
-			arr_added.remove(arr1);
-			arr_added.checkSanity();
-			arr_accum.put(arr1);
-			arr_accum.remove(arr2);
-			arr_accum.checkSanity();
-			//System.out.println("Array 1:" + arr1+"\n");
-			//System.out.println("Array 2:" + arr2+"\n");
-			//System.out.println("Combined:" + arr_added+"\n");
-		}
-	}
+    /**
+     * test method
+     */
+    public static void main(String[] args) {
+        System.out.println("Testing SortedArray ...");
+        Object dummyobject = "dummy";
+        SortedArray arr_accum = new SortedArray(20);
+        Random random = new Random();
+        for (int n = 0; n < 1000; n++) {
+            // create two random sorted arrays and combine them
+            SortedArray arr1 = new SortedArray(21);
+            SortedArray arr2 = new SortedArray(22);
+            // second array has more collisions
+            for (int i = 0; i < 100; i++) {
+                arr2.put("key" + (int) (100 + 20 * random.nextDouble()), dummyobject);
+                arr2.remove("key" + (int) (100 + 20 * random.nextDouble()));
+            }
+            // first array has few collisions
+            for (int i = 0; i < 100; i++) {
+                arr1.put("key" + (int) (100 + 100 * random.nextDouble()), dummyobject);
+                arr1.remove("key" + (int) (100 + 100 * random.nextDouble()));
+            }
+            arr1.checkSanity();
+            arr2.checkSanity();
+            arr1.remove(arr2);
+            arr1.checkSanity();
+            SortedArray arr_added = new SortedArray(23);
+            arr_added.put(arr2);
+            arr_added.put(arr1);
+            arr_added.checkSanity();
+            arr_added.remove(arr2);
+            arr_added.checkSanity();
+            arr_added.remove(arr1);
+            arr_added.checkSanity();
+            arr_accum.put(arr1);
+            arr_accum.remove(arr2);
+            arr_accum.checkSanity();
+            //System.out.println("Array 1:" + arr1+"\n");
+            //System.out.println("Array 2:" + arr2+"\n");
+            //System.out.println("Combined:" + arr_added+"\n");
+        }
+    }
 
 }
 
diff --git a/app/src/main/java/jgame/platform/AndroidImage.java b/app/src/main/java/jgame/platform/AndroidImage.java
index 0326b30..12edc63 100644
--- a/app/src/main/java/jgame/platform/AndroidImage.java
+++ b/app/src/main/java/jgame/platform/AndroidImage.java
@@ -1,179 +1,195 @@
 package jgame.platform;
-import jgame.*;
-import jgame.impl.JGameError;
-//import android.graphics.Bitmap;
-import android.graphics.*;
+
 import android.content.res.AssetManager;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.PixelFormat;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.Hashtable;
+
+import jgame.JGColor;
+import jgame.JGImage;
+import jgame.JGPoint;
 
 
-/** Image functionality */
+/**
+ * Image functionality
+ */
 class AndroidImage implements JGImage {
 
-	//static Hashtable loadedimages = new Hashtable(); /* filenames => Images */
+    //static Hashtable loadedimages = new Hashtable(); /* filenames => Images */
 
-	Bitmap img=null;
+    Bitmap img = null;
 
-	//BitmapFactory.Options opaquebitmapopts = null;
+    //BitmapFactory.Options opaquebitmapopts = null;
 
-	// colour which semi transparent pixels in scaled image should render to
-	static JGColor bg_col=JGColor.black;
+    // colour which semi transparent pixels in scaled image should render to
+    static JGColor bg_col = JGColor.black;
 
-	// true means image is certainly opaque, false means image may be
-	// transparent
-	boolean is_opaque=false;
+    // true means image is certainly opaque, false means image may be
+    // transparent
+    boolean is_opaque = false;
 
-	/** Create new image and define any known settings. */
-	public AndroidImage (Bitmap img,JGColor bg_color,boolean is_opaque) {
-		this.img=img; 
-		bg_col=bg_color;
-		this.is_opaque=is_opaque;
-	}
+    /**
+     * Create new image and define any known settings.
+     */
+    public AndroidImage(Bitmap img, JGColor bg_color, boolean is_opaque) {
+        this.img = img;
+        bg_col = bg_color;
+        this.is_opaque = is_opaque;
+    }
 
-	/** Create new image */
-	public AndroidImage (Bitmap img) { this.img=img; }
+    /**
+     * Create new image
+     */
+    public AndroidImage(Bitmap img) {
+        this.img = img;
+    }
 
-	/** Create handle to image functions. */
-	public AndroidImage () {
-		//opaquebitmapopts = new BitmapFactory.Options();
-		//opaquebitmapopts.inPreferredConfig =
-		//	getPreferredBitmapFormat(JGEngine.displayformat);
-	}
+    /**
+     * Create handle to image functions.
+     */
+    public AndroidImage() {
+        //opaquebitmapopts = new BitmapFactory.Options();
+        //opaquebitmapopts.inPreferredConfig =
+        //	getPreferredBitmapFormat(JGEngine.displayformat);
+    }
 
-	/* static in spirit*/
+    /* static in spirit*/
 
-	public JGImage loadImage(String imgfile) {
-		return loadImage(JGEngine.assets,imgfile);
-	}
+    public JGImage loadImage(String imgfile) {
+        return loadImage(JGEngine.assets, imgfile);
+    }
 
-	/** load image from assets directory
-	 * @param assets the assets manager used to load the file
-	 */
-	private AndroidImage loadImage(AssetManager assets, String filename) {
-		Bitmap bitmap = null;
-		if (assets!= null) {
-			InputStream is;
-			try {
-				is = assets.open(filename);
-				bitmap = BitmapFactory.decodeStream(is);
-				is.close();
-			} catch (IOException e) {
-				throw new Error("Asset '"+filename+"' not found");
-			}
-		}
-		return new AndroidImage(bitmap);
-	}
+    /**
+     * load image from assets directory
+     *
+     * @param assets the assets manager used to load the file
+     */
+    private AndroidImage loadImage(AssetManager assets, String filename) {
+        Bitmap bitmap = null;
+        if (assets != null) {
+            InputStream is;
+            try {
+                is = assets.open(filename);
+                bitmap = BitmapFactory.decodeStream(is);
+                is.close();
+            } catch (IOException e) {
+                throw new Error("Asset '" + filename + "' not found");
+            }
+        }
+        return new AndroidImage(bitmap);
+    }
 
-	public void purgeImage(String imgfile) {
-		//if (loadedimages.containsKey(imgfile)) loadedimages.remove(imgfile);
-	}
+    public void purgeImage(String imgfile) {
+        //if (loadedimages.containsKey(imgfile)) loadedimages.remove(imgfile);
+    }
 
 
-	/* object-related methods */
+    /* object-related methods */
 
-	JGPoint size=null;
-	public JGPoint getSize() {
-		if (size!=null) return size;
-		size=new JGPoint(img.getWidth(),img.getHeight());
-		return size;
-	}
+    JGPoint size = null;
 
-	public boolean isOpaque(int alpha_thresh) {
-		return is_opaque; 
-	}
+    public JGPoint getSize() {
+        if (size != null) return size;
+        size = new JGPoint(img.getWidth(), img.getHeight());
+        return size;
+    }
 
-	public JGImage rotate(int angle) {
-		JGPoint size = getSize();
-		int [] buffer = new int [size.x * size.y];
-		img.getPixels(buffer, 0,size.x, 0,0, size.x,size.y);
-		int [] rotate = new int [size.x * size.y];
-		int angletype = (angle/90) & 3;
-		if (angletype==0) return this;
-		if (angletype==1) {
-			/* 1 2 3 4    9 5 1
-			 * 5 6 7 8 => a 6 2
-			 * 9 a b c    b 7 3 
-			 *            c 8 4 */
-			for(int y = 0; y < size.y; y++) {
-				for(int x = 0; x < size.x; x++) {
-					rotate[x*size.y + (size.y-1-y) ] =
-							buffer[(y*size.x)+x];
-				}
-			}
-			return new AndroidImage(
-			Bitmap.createBitmap(rotate,size.y,size.x,Bitmap.Config.ARGB_8888)
-			);
-		}
-		if (angletype==3) {
-			/* 1 2 3 4    4 8 c
-			 * 5 6 7 8 => 3 7 b
-			 * 9 a b c    2 6 a 
-			 *            1 5 9 */
-			for(int y = 0; y < size.y; y++) {
-				for(int x = 0; x < size.x; x++) {
-					rotate[(size.x-x-1)*size.y + y] =
-							buffer[(y*size.x)+x];
-				}
-			}
-			return new AndroidImage(
-			Bitmap.createBitmap(rotate,size.y,size.x,Bitmap.Config.ARGB_8888)
-			);
-		}
-		if (angletype==2) {
-			/* 1 2 3 4    c b a 9
-			 * 5 6 7 8 => 8 7 6 5
-			 * 9 a b c    4 3 2 1 */
-			for(int y = 0; y < size.y; y++) {
-				for(int x = 0; x < size.x; x++) {
-					rotate[((size.y-y-1)*size.x)+(size.x-x-1)] =
-							buffer[(y*size.x)+x];
-				}
-			}
-		}
-		return new AndroidImage(
-			Bitmap.createBitmap(rotate,size.x,size.y,Bitmap.Config.ARGB_8888)
-		);
-	}
+    public boolean isOpaque(int alpha_thresh) {
+        return is_opaque;
+    }
 
-	public JGImage flip(boolean horiz,boolean vert) {
-		if (!horiz && !vert) return this;
-		JGPoint size = getSize();
-		int [] buffer = new int [size.x * size.y];
-		img.getPixels(buffer, 0,size.x, 0,0, size.x,size.y);
-		int [] flipbuf = new int [size.x * size.y];
-		if (vert && !horiz) {
-			for(int y = 0; y < size.y; y++) {
-				for(int x = 0; x < size.x; x++) {
-					flipbuf[(size.y-y-1)*size.x + x] =
-							buffer[(y*size.x)+x];
-				}
-			}
-		} else if (horiz && !vert) {
-			for(int y = 0; y < size.y; y++) {
-				for(int x = 0; x < size.x; x++) {
-					flipbuf[y*size.x + (size.x-x-1)] =
-							buffer[(y*size.x)+x];
-				}
-			}
-		} else if (horiz && vert) {
-			for(int y = 0; y < size.y; y++) {
-				for(int x = 0; x < size.x; x++) {
-					flipbuf[(size.y-y-1)*size.x + (size.x-x-1)] =
-							buffer[(y*size.x)+x];
-				}
-			}
-		}
-		return new AndroidImage(
-			Bitmap.createBitmap(flipbuf,size.x,size.y,Bitmap.Config.ARGB_8888)
-		);
-	}
+    public JGImage rotate(int angle) {
+        JGPoint size = getSize();
+        int[] buffer = new int[size.x * size.y];
+        img.getPixels(buffer, 0, size.x, 0, 0, size.x, size.y);
+        int[] rotate = new int[size.x * size.y];
+        int angletype = (angle / 90) & 3;
+        if (angletype == 0) return this;
+        if (angletype == 1) {
+            /* 1 2 3 4    9 5 1
+             * 5 6 7 8 => a 6 2
+             * 9 a b c    b 7 3
+             *            c 8 4 */
+            for (int y = 0; y < size.y; y++) {
+                for (int x = 0; x < size.x; x++) {
+                    rotate[x * size.y + (size.y - 1 - y)] =
+                            buffer[(y * size.x) + x];
+                }
+            }
+            return new AndroidImage(
+                    Bitmap.createBitmap(rotate, size.y, size.x, Bitmap.Config.ARGB_8888)
+            );
+        }
+        if (angletype == 3) {
+            /* 1 2 3 4    4 8 c
+             * 5 6 7 8 => 3 7 b
+             * 9 a b c    2 6 a
+             *            1 5 9 */
+            for (int y = 0; y < size.y; y++) {
+                for (int x = 0; x < size.x; x++) {
+                    rotate[(size.x - x - 1) * size.y + y] =
+                            buffer[(y * size.x) + x];
+                }
+            }
+            return new AndroidImage(
+                    Bitmap.createBitmap(rotate, size.y, size.x, Bitmap.Config.ARGB_8888)
+            );
+        }
+        if (angletype == 2) {
+            /* 1 2 3 4    c b a 9
+             * 5 6 7 8 => 8 7 6 5
+             * 9 a b c    4 3 2 1 */
+            for (int y = 0; y < size.y; y++) {
+                for (int x = 0; x < size.x; x++) {
+                    rotate[((size.y - y - 1) * size.x) + (size.x - x - 1)] =
+                            buffer[(y * size.x) + x];
+                }
+            }
+        }
+        return new AndroidImage(
+                Bitmap.createBitmap(rotate, size.x, size.y, Bitmap.Config.ARGB_8888)
+        );
+    }
 
-	public JGImage scale(int width, int height) {
-		return new
-			AndroidImage(Bitmap.createScaledBitmap(img,width,height,true));
+    public JGImage flip(boolean horiz, boolean vert) {
+        if (!horiz && !vert) return this;
+        JGPoint size = getSize();
+        int[] buffer = new int[size.x * size.y];
+        img.getPixels(buffer, 0, size.x, 0, 0, size.x, size.y);
+        int[] flipbuf = new int[size.x * size.y];
+        if (vert && !horiz) {
+            for (int y = 0; y < size.y; y++) {
+                for (int x = 0; x < size.x; x++) {
+                    flipbuf[(size.y - y - 1) * size.x + x] =
+                            buffer[(y * size.x) + x];
+                }
+            }
+        } else if (horiz && !vert) {
+            for (int y = 0; y < size.y; y++) {
+                for (int x = 0; x < size.x; x++) {
+                    flipbuf[y * size.x + (size.x - x - 1)] =
+                            buffer[(y * size.x) + x];
+                }
+            }
+        } else if (horiz && vert) {
+            for (int y = 0; y < size.y; y++) {
+                for (int x = 0; x < size.x; x++) {
+                    flipbuf[(size.y - y - 1) * size.x + (size.x - x - 1)] =
+                            buffer[(y * size.x) + x];
+                }
+            }
+        }
+        return new AndroidImage(
+                Bitmap.createBitmap(flipbuf, size.x, size.y, Bitmap.Config.ARGB_8888)
+        );
+    }
+
+    public JGImage scale(int width, int height) {
+        return new
+                AndroidImage(Bitmap.createScaledBitmap(img, width, height, true));
 //		int [] pix = new int [img.getWidth()*img.getHeight()];
 //		int srcwidth = img.getWidth();
 //		int srcheight = img.getHeight();
@@ -219,10 +235,10 @@ class AndroidImage implements JGImage {
 //		return new AndroidImage(
 //			Bitmap.createRGBImage(dstpix,width,height,!is_opaque),
 //			bg_col,is_opaque);
-	}
+    }
 
-	public JGImage rotateAny(double angle) {
-		return new AndroidImage(img);
+    public JGImage rotateAny(double angle) {
+        return new AndroidImage(img);
 //		int sw = img.getWidth();
 //		int sh = img.getHeight();
 //		int bg_pix=(((bg_col.r<<16) + (bg_col.g<<8) + bg_col.b)>>2)&0x3f3f3f3f;
@@ -314,18 +330,18 @@ class AndroidImage implements JGImage {
 //		// clean up temp data before creating image to avoid peak memory use
 //		srcData = null;
 //		return new AndroidImage(Bitmap.createRGBImage(dstData, dw, dh, !is_opaque));
-	}
+    }
 
-	public JGImage crop(int x,int y, int width,int height) {
-		return new AndroidImage(Bitmap.createBitmap(img, x, y, width, height,
-			null, true) );
+    public JGImage crop(int x, int y, int width, int height) {
+        return new AndroidImage(Bitmap.createBitmap(img, x, y, width, height,
+                null, true));
 //		return new AndroidImage(Bitmap.createImage(img,
 //			x,y, width,height, Sprite.TRANS_NONE),bg_col,is_opaque);
-	}
+    }
 
-	public JGImage toDisplayCompatible(int thresh,JGColor bg_col,
-	boolean fast,boolean bitmask) {
-		return new AndroidImage(img);
+    public JGImage toDisplayCompatible(int thresh, JGColor bg_col,
+                                       boolean fast, boolean bitmask) {
+        return new AndroidImage(img);
 //		this.bg_col=bg_col;
 //		int [] pix = new int [img.getWidth()*img.getHeight()];
 //		int srcwidth = img.getWidth();
@@ -345,13 +361,14 @@ class AndroidImage implements JGImage {
 //		}
 //		return new AndroidImage(Bitmap.createRGBImage(pix,srcwidth,srcheight,
 //				is_transparent),bg_col,!is_transparent);
-	}
-	// not useful: cannot retrieve display format
-	public static Bitmap.Config getPreferredBitmapFormat(int displayformat) {
-		if (displayformat == PixelFormat.RGB_565)
-			return Bitmap.Config.RGB_565;
-		else
-			return Bitmap.Config.ARGB_8888;
-	}
+    }
+
+    // not useful: cannot retrieve display format
+    public static Bitmap.Config getPreferredBitmapFormat(int displayformat) {
+        if (displayformat == PixelFormat.RGB_565)
+            return Bitmap.Config.RGB_565;
+        else
+            return Bitmap.Config.ARGB_8888;
+    }
 
 }
diff --git a/app/src/main/java/jgame/platform/JGActivity.java b/app/src/main/java/jgame/platform/JGActivity.java
index e43acb0..c404ff5 100644
--- a/app/src/main/java/jgame/platform/JGActivity.java
+++ b/app/src/main/java/jgame/platform/JGActivity.java
@@ -1,188 +1,188 @@
 package jgame.platform;
-import android.app.*;
-import android.os.Bundle;
-import android.content.res.AssetManager;
-
-import android.hardware.*;
-import android.view.*;
-import android.graphics.*;
-import android.graphics.drawable.Drawable;
 
-import android.content.Intent;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
 import android.content.DialogInterface;
+import android.content.Intent;
+import android.hardware.SensorManager;
 import android.net.Uri;
-
-import java.util.*;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.MenuItem;
 
 
 public class JGActivity extends Activity {
 
-	JGEngine eng;
-
-	class UrlInvoker implements Runnable {
-		String url;
-		public UrlInvoker(String url) {
-			this.url = url;
-		}
-		public void run() {
-			// XXX currently resets the application state
-			Intent i = new Intent(Intent.ACTION_VIEW);
-			//i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-			i.setData(Uri.parse(url));
-			startActivity(i);
-		}
-	}
-
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		eng = JGEngine.current_engine;
-		eng.initActivity(this);
-	}
-
-	@Override
-	protected void onResume() {
-		// Ideally a game should implement onResume() and onPause()
-		// to take appropriate action when the activity looses focus
-		super.onResume();
-		eng.start();
-		eng.sensormanager.registerListener(eng.canvas, eng.accelerometer,
-			SensorManager.SENSOR_DELAY_FASTEST);
-
-	}
-
-	@Override
-	protected void onPause() {
-		// Ideally a game should implement onResume() and onPause()
-		// to take appropriate action when the activity looses focus
-		super.onPause();
-		eng.stop();
-		eng.sensormanager.unregisterListener(eng.canvas);
-	}
-
-	public static final int SOUNDDIALOG=0;
-	public static final int ACCELDIALOG=1;
-
-	protected Dialog onCreateDialog(int id) {
-		//if (eng==null || !(eng instanceof StdGame)) return null;
-		//if (!((StdGame)eng).audio_dialog_at_startup) return null;
-		if (id == SOUNDDIALOG) {
-			AlertDialog.Builder builder = new AlertDialog.Builder(this);
-			builder.setMessage("Enable sound?");
-			//builder.setCancelable(false);
-			builder.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
-				public void onClick(DialogInterface dialog, int id) {
-					if (eng!=null && eng instanceof StdGame) {
-						((StdGame)eng).audioenabled=true;
-					}
-				}
-			});
-			builder.setNegativeButton("No", new DialogInterface.OnClickListener() {
-				public void onClick(DialogInterface dialog, int id) {
-					if (eng!=null && eng instanceof StdGame) {
-						((StdGame)eng).audioenabled=false;
-					}
-					//dialog.cancel();
-				}
-			});
-			AlertDialog alert = builder.create();
-			return alert;
-		} else { // ACCELDIALOG
-			AlertDialog.Builder builder = new AlertDialog.Builder(this);
-			builder.setMessage("Hold your phone in the desired 'zero' orientation and press OK.");
-			//builder.setCancelable(false);
-			builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
-				public void onClick(DialogInterface dialog, int id) {
-					if (eng!=null && eng instanceof StdGame) {
-						((StdGame)eng).accelzerovector = eng.getAccelVec();
-					}
-				}
-			});
-			AlertDialog alert = builder.create();
-			return alert;
-		}
-	}
-
-	static final int MAINGROUP = Menu.FIRST;
-
-	static final int RESUME = Menu.FIRST;
-	static final int QUITGAME   = Menu.FIRST+1;
-	static final int SETACCEL   = Menu.FIRST+2;
-	static final int SETTINGS   = Menu.FIRST+3;
-	static final int SETTINGS_SUBMENU   = Menu.FIRST+4;
+    JGEngine eng;
+
+    class UrlInvoker implements Runnable {
+        String url;
+
+        public UrlInvoker(String url) {
+            this.url = url;
+        }
+
+        public void run() {
+            // XXX currently resets the application state
+            Intent i = new Intent(Intent.ACTION_VIEW);
+            //i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            i.setData(Uri.parse(url));
+            startActivity(i);
+        }
+    }
+
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        eng = JGEngine.current_engine;
+        eng.initActivity(this);
+    }
+
+    @Override
+    protected void onResume() {
+        // Ideally a game should implement onResume() and onPause()
+        // to take appropriate action when the activity looses focus
+        super.onResume();
+        eng.start();
+        eng.sensormanager.registerListener(eng.canvas, eng.accelerometer,
+                SensorManager.SENSOR_DELAY_FASTEST);
+
+    }
+
+    @Override
+    protected void onPause() {
+        // Ideally a game should implement onResume() and onPause()
+        // to take appropriate action when the activity looses focus
+        super.onPause();
+        eng.stop();
+        eng.sensormanager.unregisterListener(eng.canvas);
+    }
+
+    public static final int SOUNDDIALOG = 0;
+    public static final int ACCELDIALOG = 1;
+
+    protected Dialog onCreateDialog(int id) {
+        //if (eng==null || !(eng instanceof StdGame)) return null;
+        //if (!((StdGame)eng).audio_dialog_at_startup) return null;
+        if (id == SOUNDDIALOG) {
+            AlertDialog.Builder builder = new AlertDialog.Builder(this);
+            builder.setMessage("Enable sound?");
+            //builder.setCancelable(false);
+            builder.setPositiveButton("Yes", new DialogInterface.OnClickListener() {
+                public void onClick(DialogInterface dialog, int id) {
+                    if (eng != null && eng instanceof StdGame) {
+                        ((StdGame) eng).audioenabled = true;
+                    }
+                }
+            });
+            builder.setNegativeButton("No", new DialogInterface.OnClickListener() {
+                public void onClick(DialogInterface dialog, int id) {
+                    if (eng != null && eng instanceof StdGame) {
+                        ((StdGame) eng).audioenabled = false;
+                    }
+                    //dialog.cancel();
+                }
+            });
+            AlertDialog alert = builder.create();
+            return alert;
+        } else { // ACCELDIALOG
+            AlertDialog.Builder builder = new AlertDialog.Builder(this);
+            builder.setMessage("Hold your phone in the desired 'zero' orientation and press OK.");
+            //builder.setCancelable(false);
+            builder.setPositiveButton("OK", new DialogInterface.OnClickListener() {
+                public void onClick(DialogInterface dialog, int id) {
+                    if (eng != null && eng instanceof StdGame) {
+                        ((StdGame) eng).accelzerovector = eng.getAccelVec();
+                    }
+                }
+            });
+            AlertDialog alert = builder.create();
+            return alert;
+        }
+    }
+
+    static final int MAINGROUP = Menu.FIRST;
+
+    static final int RESUME = Menu.FIRST;
+    static final int QUITGAME = Menu.FIRST + 1;
+    static final int SETACCEL = Menu.FIRST + 2;
+    static final int SETTINGS = Menu.FIRST + 3;
+    static final int SETTINGS_SUBMENU = Menu.FIRST + 4;
 
     private static final int REQUEST_CODE_PREFERENCES = 1;
 
-	// standard menu
-	@Override
-	public boolean onCreateOptionsMenu(Menu menu) {
-		menu.add(Menu.NONE, RESUME, Menu.NONE, "Resume");
-		menu.add(Menu.NONE, QUITGAME, Menu.NONE, "Quit To Menu");
-		// XXX StdGame specific
-		if (eng instanceof StdGame && eng.hasAccelerometer()) {
-			if ( ((StdGame)eng).accel_set_zero_menu) {
-				menu.add(Menu.NONE, SETACCEL, Menu.NONE,
-					"Calibrate accelerometer");
-			}
-		}
-		if (eng.settings_array.size() > 0) {
-			menu.add(Menu.NONE, SETTINGS, Menu.NONE, "Settings");
-		}
-		//MenuInflater inflater = getMenuInflater();
-		//inflater.inflate(R.menu.menu, menu);
-		return true;
-	}
-	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-		eng.start();
-		switch (item.getItemId()) {
-			case RESUME:
-				// nothing extra needs to be done
-			break;
-			case QUITGAME:
-				// XXX StdGame specific
-				// we should have a quit signal in the api or something
-				if (eng instanceof StdGame) {
-					((StdGame)eng).gameOver();
-				}
-				//finish();
-			break;
-			case SETACCEL:
-				eng.canvas.post(new Runnable() {
-					public void run() {
-						showDialog(ACCELDIALOG);
-					}
-				});
-			break;
-			case SETTINGS:
-				System.err.println("Settings menu");
-				Intent launchPreferencesIntent = new Intent().setClass(this,
-					JGPreferences.class);
-				// Make it a subactivity so we know when it returns
-				startActivityForResult(launchPreferencesIntent,
-					REQUEST_CODE_PREFERENCES);
-			break;
-			//default:
-			//if (item.getItemId() >= SETTINGS_SUBMENU) {
-			//	Settings s = eng.settings.get(new Integer(id));
-			//}
-		}
-		return true;
-	}
-
-
-	@Override
-	protected void onActivityResult(int requestCode, int resultCode,
-	Intent data) {
-		super.onActivityResult(requestCode, resultCode, data);
-		// The preferences returned if the request code is what we had given
-		// earlier in startSubActivity
-		if (requestCode == REQUEST_CODE_PREFERENCES) {
-			// Read a sample value they have set
-			//updateCounterText();
-		}
-	}
+    // standard menu
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        menu.add(Menu.NONE, RESUME, Menu.NONE, "Resume");
+        menu.add(Menu.NONE, QUITGAME, Menu.NONE, "Quit To Menu");
+        // XXX StdGame specific
+        if (eng instanceof StdGame && eng.hasAccelerometer()) {
+            if (((StdGame) eng).accel_set_zero_menu) {
+                menu.add(Menu.NONE, SETACCEL, Menu.NONE,
+                        "Calibrate accelerometer");
+            }
+        }
+        if (eng.settings_array.size() > 0) {
+            menu.add(Menu.NONE, SETTINGS, Menu.NONE, "Settings");
+        }
+        //MenuInflater inflater = getMenuInflater();
+        //inflater.inflate(R.menu.menu, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        eng.start();
+        switch (item.getItemId()) {
+            case RESUME:
+                // nothing extra needs to be done
+                break;
+            case QUITGAME:
+                // XXX StdGame specific
+                // we should have a quit signal in the api or something
+                if (eng instanceof StdGame) {
+                    ((StdGame) eng).gameOver();
+                }
+                //finish();
+                break;
+            case SETACCEL:
+                eng.canvas.post(new Runnable() {
+                    public void run() {
+                        showDialog(ACCELDIALOG);
+                    }
+                });
+                break;
+            case SETTINGS:
+                System.err.println("Settings menu");
+                Intent launchPreferencesIntent = new Intent().setClass(this,
+                        JGPreferences.class);
+                // Make it a subactivity so we know when it returns
+                startActivityForResult(launchPreferencesIntent,
+                        REQUEST_CODE_PREFERENCES);
+                break;
+            //default:
+            //if (item.getItemId() >= SETTINGS_SUBMENU) {
+            //	Settings s = eng.settings.get(new Integer(id));
+            //}
+        }
+        return true;
+    }
+
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode,
+                                    Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        // The preferences returned if the request code is what we had given
+        // earlier in startSubActivity
+        if (requestCode == REQUEST_CODE_PREFERENCES) {
+            // Read a sample value they have set
+            //updateCounterText();
+        }
+    }
 
 //    private void updateCounterText() {
 //        // Since we're in the same package, we can use this context to get
@@ -193,16 +193,15 @@ public class JGActivity extends Activity {
 //   }
 
 
+    @Override
+    public boolean onMenuOpened(int featureId, Menu menu) {
+        eng.stop();
+        return true;
+    }
 
-
-	@Override
-	public boolean onMenuOpened(int featureId, Menu menu) {
-		eng.stop();
-		return true;
-	}
-	@Override
-	public void onOptionsMenuClosed (Menu menu) {
-		eng.start();
-	}
+    @Override
+    public void onOptionsMenuClosed(Menu menu) {
+        eng.start();
+    }
 }
 
diff --git a/app/src/main/java/jgame/platform/JGEngine.java b/app/src/main/java/jgame/platform/JGEngine.java
index aa1241d..b3b898e 100644
--- a/app/src/main/java/jgame/platform/JGEngine.java
+++ b/app/src/main/java/jgame/platform/JGEngine.java
@@ -1,220 +1,238 @@
 package jgame.platform;
 
-import jgame.*;
-import jgame.impl.*;
-
-import java.io.*;
-//import javax.microedition.midlet.MIDlet;
-//import javax.microedition.lcdui.Display;
-//import javax.microedition.lcdui.*;
-//import javax.microedition.media.*;
-//import javax.microedition.media.control.*;
-
-import java.util.Vector;
-import java.util.Hashtable;
-import java.util.Enumeration;
-//import javax.microedition.lcdui.Font;
-//import javax.microedition.lcdui.Image;
-//import javax.microedition.lcdui.Graphics;
-//import javax.microedition.lcdui.game.Sprite;
-//import javax.microedition.lcdui.game.GameCanvas;
-
-//import javax.microedition.rms.*;
-
-import java.io.IOException;
-//import javax.microedition.io.ConnectionNotFoundException;
-
 import android.app.Activity;
 import android.app.Application;
-import android.os.Bundle;
-import android.content.res.AssetManager;
+import android.content.SharedPreferences;
 import android.content.res.AssetFileDescriptor;
-
-import android.hardware.*;
-import android.view.*;
-import android.graphics.*;
-import android.graphics.drawable.Drawable;
-
-import android.content.Intent;
-import android.net.Uri;
-
+import android.content.res.AssetManager;
+import android.graphics.Bitmap;
+import android.graphics.BitmapShader;
+import android.graphics.Canvas;
+import android.graphics.LightingColorFilter;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.Shader;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
 import android.media.AudioManager;
-import android.media.MediaPlayer;
 import android.media.SoundPool;
+import android.preference.CheckBoxPreference;
+import android.preference.EditTextPreference;
+import android.preference.ListPreference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceManager;
+import android.view.Display;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.Surface;
+import android.view.View;
+import android.view.WindowManager;
 
-import android.preference.*;
-import android.content.SharedPreferences;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.Vector;
+
+import jgame.JGColor;
+import jgame.JGFont;
+import jgame.JGImage;
+import jgame.JGObject;
+import jgame.JGPoint;
+import jgame.JGRectangle;
+import jgame.JGTimer;
+import jgame.impl.Animation;
+import jgame.impl.EngineLogic;
+import jgame.impl.ImageMap;
+import jgame.impl.JGEngineInterface;
+import jgame.impl.JGameError;
 
 // XXX is end coord of drawRect inclusive or exclusive?
 
 public abstract class JGEngine extends Application
-implements JGEngineInterface  {
-
-	/*=== main objects ===*/
-
-	static JGEngine current_engine=null;
-
-	static AssetManager assets;
-
-	static int displayformat;
-
-	AndroidImage imageutil = new AndroidImage();
-
-	EngineLogic el = new EngineLogic(imageutil,true,true);
-
-	Thread gamethread=null;
-
-	Display display;
-
-	public void setProgressBar(double pos) {
-		// XXX check out if the load screen gets updated properly if we don't
-		// use defineMedia
-		progress_bar=pos;
-		canvas.drawAll();
-	}
-
-	public void setProgressMessage(String msg) {
-		progress_message=msg;
-		canvas.drawAll();
-	}
-
-	public void setAuthorMessage(String msg) {
-		author_message=msg;
-		canvas.drawAll();
-	}
-
-
+        implements JGEngineInterface {
 
+    /*=== main objects ===*/
 
-	/*=== android specific stuff ===*/
+    static JGEngine current_engine = null;
 
-	JGView canvas;
+    static AssetManager assets;
 
-	Canvas bufg=null;
-	Paint bufpainter = new Paint();
-	Paint imagepainter = new Paint();
-	Paint simpleimagepainter = new Paint();
-	Bitmap background=null;
-	Canvas bgg=null;
-	Paint bgpainter = new Paint();
+    static int displayformat;
 
+    AndroidImage imageutil = new AndroidImage();
 
-	SensorManager sensormanager;
-	Sensor accelerometer;
+    EngineLogic el = new EngineLogic(imageutil, true, true);
 
-	// android application
+    Thread gamethread = null;
 
-	@Override
-	public void onCreate() {
-		super.onCreate();
-		current_engine = this;
-	}
+    Display display;
 
-	JGActivity currentact = null;
+    public void setProgressBar(double pos) {
+        // XXX check out if the load screen gets updated properly if we don't
+        // use defineMedia
+        progress_bar = pos;
+        canvas.drawAll();
+    }
 
-	// called by JGActivity when created
-	void initActivity(JGActivity act) {
-		currentact = act;
-		//setContentView(R.layout.main);
-		assets = act.getAssets();
-		canvas = new JGView(act);
-		act.setContentView(canvas);
-		canvas.requestFocus();
-		//renderer = new GLAccelRenderer(glsview,false);
-		//glsview.setRenderer(renderer);
-		//setContentView(glsview);
-		sensormanager = (SensorManager)act.getSystemService(SENSOR_SERVICE);
-		accelerometer = sensormanager.getDefaultSensor(
-				Sensor.TYPE_ACCELEROMETER);
-		WindowManager mWindowManager = (WindowManager)
-				act.getSystemService(WINDOW_SERVICE);
+    public void setProgressMessage(String msg) {
+        progress_message = msg;
+        canvas.drawAll();
+    }
 
-		display = mWindowManager.getDefaultDisplay();
-		// does not work as advertised, always returns -1
-		//displayformat = getWindow().getAttributes().format;
-		displayformat = display.getPixelFormat();
-		System.err.println("Display format = "+displayformat);
-		System.err.println("RGB_565 = "+PixelFormat.RGB_565);
-		System.err.println("RGB_888 = "+PixelFormat.RGB_888);
-	}
+    public void setAuthorMessage(String msg) {
+        author_message = msg;
+        canvas.drawAll();
+    }
 
-	// android activity
-
-	/** for displaying progress info */
-	String progress_message="Loading files ...";
-	/** for displaying progress bar, value between 0.0 - 1.0 */
-	public double progress_bar=0.0;
-
-	String author_message="JGame "+JGameVersionString;
-
-	boolean is_initialised=false;
-
-
-	class JGView extends View implements SensorEventListener {
-		public JGView(Activity c) {
-			super(c);
-			bufpainter.setAntiAlias(true);
-			bgpainter.setAntiAlias(true);
-			bufpainter.setARGB(255, 255, 255, 255);
-			bgpainter.setARGB(255, 255, 255, 255);
-			setKeepScreenOn(true);
-			setFocusable(true); // receive key events
-		}
-
-		/* standard view methods */
-
-		/** Canvas size is known: the cue to init the engine. */
-		@Override 
-		protected void onSizeChanged(int w, int h, int oldw,
-		int oldh) {
-			init();
-		}
-		
-		@Override protected void onDraw(Canvas g) { try {
-			if (el.is_exited) {
-				//paintExitMessage(g);
-				return;
-			}
-			bufg = g;
-			int clipx = 0;
-			if (el.canvas_xofs > 0) clipx = el.canvas_xofs;
-			int clipy = 0;
-			if (el.canvas_yofs > 0) clipy = el.canvas_yofs;
-			int clipwidth = getWidth();
-			if (el.width < clipwidth) clipwidth = el.width;
-			int clipheight = getHeight();
-			if (el.height < clipheight) clipheight = el.height;
-			g.clipRect(clipx,clipy, clipx+clipwidth,clipy+clipheight);
-			if (!is_initialised) {
-				setFont(bufpainter,el.msg_font);
-				setColor(bufpainter,el.fg_color);
-				JGImage splash = el.existsImage("splash_image") ?
-						el.getImage("splash_image")  :  null;
-				if (splash!=null) {
-					JGPoint splash_size=getImageSize("splash_image");
-					drawImage(bufg,viewWidth()/2-splash_size.x/2,
-						Math.max(0,viewHeight()/4-splash_size.y/2),
-						"splash_image",
-						false);
-				}
-				drawString(bufg,progress_message,
-					viewWidth()/2,3*viewHeight()/5,0,false);
-				//if (canvas.progress_message!=null) {
-					//drawString(bufg,canvas.progress_message,
-					//		viewWidth()/2,2*viewHeight()/3,0);
-				//}
-				// paint the right hand side black in case the bar decreases
-				setColor(bufpainter,el.bg_color);
-				drawRect(bufg,(int)(viewWidth()*(0.1+0.8*progress_bar)),
-						(int)(viewHeight()*0.75),
-						(int)(viewWidth()*0.8*(1.0-progress_bar)),
-						(int)(viewHeight()*0.05), true,false, false,null,null);
-				// left hand side of bar
-				setColor(bufpainter,el.fg_color);
-				drawRect(bufg,(int)(viewWidth()*0.1), (int)(viewHeight()*0.75),
-						(int)(viewWidth()*0.8*progress_bar),
-						(int)(viewHeight()*0.05), true,false, false,null,null);
-				// length stripes
+
+
+
+    /*=== android specific stuff ===*/
+
+    JGView canvas;
+
+    Canvas bufg = null;
+    Paint bufpainter = new Paint();
+    Paint imagepainter = new Paint();
+    Paint simpleimagepainter = new Paint();
+    Bitmap background = null;
+    Canvas bgg = null;
+    Paint bgpainter = new Paint();
+
+
+    SensorManager sensormanager;
+    Sensor accelerometer;
+
+    // android application
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        current_engine = this;
+    }
+
+    JGActivity currentact = null;
+
+    // called by JGActivity when created
+    void initActivity(JGActivity act) {
+        currentact = act;
+        //setContentView(R.layout.main);
+        assets = act.getAssets();
+        canvas = new JGView(act);
+        act.setContentView(canvas);
+        canvas.requestFocus();
+        //renderer = new GLAccelRenderer(glsview,false);
+        //glsview.setRenderer(renderer);
+        //setContentView(glsview);
+        sensormanager = (SensorManager) act.getSystemService(SENSOR_SERVICE);
+        accelerometer = sensormanager.getDefaultSensor(
+                Sensor.TYPE_ACCELEROMETER);
+        WindowManager mWindowManager = (WindowManager)
+                act.getSystemService(WINDOW_SERVICE);
+
+        display = mWindowManager.getDefaultDisplay();
+        // does not work as advertised, always returns -1
+        //displayformat = getWindow().getAttributes().format;
+        displayformat = display.getPixelFormat();
+        System.err.println("Display format = " + displayformat);
+        System.err.println("RGB_565 = " + PixelFormat.RGB_565);
+        System.err.println("RGB_888 = " + PixelFormat.RGB_888);
+    }
+
+    // android activity
+
+    /**
+     * for displaying progress info
+     */
+    String progress_message = "Loading files ...";
+    /**
+     * for displaying progress bar, value between 0.0 - 1.0
+     */
+    public double progress_bar = 0.0;
+
+    String author_message = "JGame " + JGameVersionString;
+
+    boolean is_initialised = false;
+
+
+    class JGView extends View implements SensorEventListener {
+        public JGView(Activity c) {
+            super(c);
+            bufpainter.setAntiAlias(true);
+            bgpainter.setAntiAlias(true);
+            bufpainter.setARGB(255, 255, 255, 255);
+            bgpainter.setARGB(255, 255, 255, 255);
+            setKeepScreenOn(true);
+            setFocusable(true); // receive key events
+        }
+
+        /* standard view methods */
+
+        /**
+         * Canvas size is known: the cue to init the engine.
+         */
+        @Override
+        protected void onSizeChanged(int w, int h, int oldw,
+                                     int oldh) {
+            init();
+        }
+
+        @Override
+        protected void onDraw(Canvas g) {
+            try {
+                if (el.is_exited) {
+                    //paintExitMessage(g);
+                    return;
+                }
+                bufg = g;
+                int clipx = 0;
+                if (el.canvas_xofs > 0) clipx = el.canvas_xofs;
+                int clipy = 0;
+                if (el.canvas_yofs > 0) clipy = el.canvas_yofs;
+                int clipwidth = getWidth();
+                if (el.width < clipwidth) clipwidth = el.width;
+                int clipheight = getHeight();
+                if (el.height < clipheight) clipheight = el.height;
+                g.clipRect(clipx, clipy, clipx + clipwidth, clipy + clipheight);
+                if (!is_initialised) {
+                    setFont(bufpainter, el.msg_font);
+                    setColor(bufpainter, el.fg_color);
+                    JGImage splash = el.existsImage("splash_image") ?
+                            el.getImage("splash_image") : null;
+                    if (splash != null) {
+                        JGPoint splash_size = getImageSize("splash_image");
+                        drawImage(bufg, viewWidth() / 2 - splash_size.x / 2,
+                                Math.max(0, viewHeight() / 4 - splash_size.y / 2),
+                                "splash_image",
+                                false);
+                    }
+                    drawString(bufg, progress_message,
+                            viewWidth() / 2, 3 * viewHeight() / 5, 0, false);
+                    //if (canvas.progress_message!=null) {
+                    //drawString(bufg,canvas.progress_message,
+                    //		viewWidth()/2,2*viewHeight()/3,0);
+                    //}
+                    // paint the right hand side black in case the bar decreases
+                    setColor(bufpainter, el.bg_color);
+                    drawRect(bufg, (int) (viewWidth() * (0.1 + 0.8 * progress_bar)),
+                            (int) (viewHeight() * 0.75),
+                            (int) (viewWidth() * 0.8 * (1.0 - progress_bar)),
+                            (int) (viewHeight() * 0.05), true, false, false, null, null);
+                    // left hand side of bar
+                    setColor(bufpainter, el.fg_color);
+                    drawRect(bufg, (int) (viewWidth() * 0.1), (int) (viewHeight() * 0.75),
+                            (int) (viewWidth() * 0.8 * progress_bar),
+                            (int) (viewHeight() * 0.05), true, false, false, null, null);
+                    // length stripes
 				/*drawRect(bufg,(int)(viewWidth()*0.1), (int)(viewHeight()*0.6),
 						(int)(viewWidth()*0.8),
 						(int)(viewHeight()*0.008), true,false, false);
@@ -222,100 +240,104 @@ implements JGEngineInterface  {
 						(int)(viewHeight()*(0.6+0.046)),
 						(int)(viewWidth()*0.8),
 						(int)(viewHeight()*0.008), true,false, false);*/
-				drawString(bufg,author_message,
-					viewWidth()-16,viewHeight()-getFontHeight(el.msg_font)-10,
-					1,false);
-				return;
-			}
-			//bufg.setClip(Math.max(0,el.canvas_xofs),Math.max(0,el.canvas_yofs),
-			//	Math.min(el.width,el.winwidth),
-			//	Math.min(el.height,el.winheight) );
-			// block update thread
-			synchronized (el.objects) {
-				// paint any part of bg which is not yet defined
-				el.repaintBG(JGEngine.this);
-				/* clear buffer */
-				buf_gfx = bufg; // enable objects to draw on buffer gfx.
-				// Draw background to buffer.
-				// this part is the same across jre and midp.  Move it to
-				// EngineLogic?
-				//bufg.drawImage(background,-scaledtilex,-scaledtiley,this);
-				int tilexshift=el.moduloFloor(el.tilexofs+1,el.viewnrtilesx+3);
-				int tileyshift=el.moduloFloor(el.tileyofs+1,el.viewnrtilesy+3);
-				int sx1 = tilexshift+1;
-				int sy1 = tileyshift+1;
-				int sx2 = el.viewnrtilesx+3;
-				int sy2 = el.viewnrtilesy+3;
-				if (sx2-sx1 > el.viewnrtilesx) sx2 = sx1 + el.viewnrtilesx;
-				if (sy2-sy1 > el.viewnrtilesy) sy2 = sy1 + el.viewnrtilesy;
-				int bufmidx = sx2-sx1;
-				int bufmidy = sy2-sy1;
-				copyBGToBuf(bufg,sx1,sy1, sx2,sy2, 0,0);
-				sx1 = 0;
-				sy1 = 0;
-				sx2 = tilexshift-1;
-				sy2 = tileyshift-1;
-				copyBGToBuf(bufg,sx1,sy1, sx2,sy2, bufmidx,bufmidy);
-				sx1 = 0;
-				sy1 = tileyshift+1;
-				sx2 = tilexshift-1;
-				sy2 = el.viewnrtilesy+3;
-				if (sy2-sy1 > el.viewnrtilesy) sy2 = sy1 + el.viewnrtilesy;
-				copyBGToBuf(bufg,sx1,sy1, sx2,sy2, bufmidx,0);
-				sx1 = tilexshift+1;
-				sy1 = 0;
-				sx2 = el.viewnrtilesx+3;
-				sy2 = tileyshift-1;
-				if (sx2-sx1 > el.viewnrtilesx) sx2 = sx1 + el.viewnrtilesx;
-				copyBGToBuf(bufg,sx1,sy1, sx2,sy2, 0,bufmidy);
-				for (int i=0; i<el.objects.size; i++) {
-					drawObject(bufg, (JGObject)el.objects.values[i]);
-				}
-				buf_gfx = null; // we're finished with the object drawing
-				/* draw status */
-				paintFrame(bufg);
-			}
-		} catch (JGameError e) {
-			e.printStackTrace();
-			exitEngine("Error during paint:\n"
-					+dbgExceptionToString(e) );
-		} }
-
-
-		@Override
-		public boolean onTouchEvent(MotionEvent me) {
-			int action = me.getAction();
-			double x = me.getX();
-			double y = me.getY();
-			// on a multitouch, touches after the first touch are also
-			// considered mouse-down flanks.
-			boolean press = action == MotionEvent.ACTION_DOWN
-						 || action == MotionEvent.ACTION_POINTER_DOWN;
-			boolean down = press || action == MotionEvent.ACTION_MOVE;
-			mouseposd_x = (x-el.canvas_xofs)/el.x_scale_fac;
-			mouseposd_y = (y-el.canvas_yofs)/el.y_scale_fac;
-			mousepos.x = (int)mouseposd_x;
-			mousepos.y = (int)mouseposd_y;
-			if (press) { // || !mouseinside) { // if press does not register
-				mousebutton[1] = true;
-				keymap[256] = true;
-			}
-			if (action == MotionEvent.ACTION_UP) {
-				mouseinside = false;
-				mousebutton[1] = false;
-				keymap[256] = false;
-			} else {
-				mouseinside = true;
-			}
-			return true;
-		}
-
-		/** Code taken from TouchPaint example. Can't test this yet.
-		* Sensitivity should be a setting. Unclear how to test button press. */
-		@Override public boolean onTrackballEvent(MotionEvent event) {
-			int N = event.getHistorySize();
-			final float scaleX = event.getXPrecision();
-			final float scaleY = event.getYPrecision();
+                    drawString(bufg, author_message,
+                            viewWidth() - 16, viewHeight() - getFontHeight(el.msg_font) - 10,
+                            1, false);
+                    return;
+                }
+                //bufg.setClip(Math.max(0,el.canvas_xofs),Math.max(0,el.canvas_yofs),
+                //	Math.min(el.width,el.winwidth),
+                //	Math.min(el.height,el.winheight) );
+                // block update thread
+                synchronized (el.objects) {
+                    // paint any part of bg which is not yet defined
+                    el.repaintBG(JGEngine.this);
+                    /* clear buffer */
+                    buf_gfx = bufg; // enable objects to draw on buffer gfx.
+                    // Draw background to buffer.
+                    // this part is the same across jre and midp.  Move it to
+                    // EngineLogic?
+                    //bufg.drawImage(background,-scaledtilex,-scaledtiley,this);
+                    int tilexshift = el.moduloFloor(el.tilexofs + 1, el.viewnrtilesx + 3);
+                    int tileyshift = el.moduloFloor(el.tileyofs + 1, el.viewnrtilesy + 3);
+                    int sx1 = tilexshift + 1;
+                    int sy1 = tileyshift + 1;
+                    int sx2 = el.viewnrtilesx + 3;
+                    int sy2 = el.viewnrtilesy + 3;
+                    if (sx2 - sx1 > el.viewnrtilesx) sx2 = sx1 + el.viewnrtilesx;
+                    if (sy2 - sy1 > el.viewnrtilesy) sy2 = sy1 + el.viewnrtilesy;
+                    int bufmidx = sx2 - sx1;
+                    int bufmidy = sy2 - sy1;
+                    copyBGToBuf(bufg, sx1, sy1, sx2, sy2, 0, 0);
+                    sx1 = 0;
+                    sy1 = 0;
+                    sx2 = tilexshift - 1;
+                    sy2 = tileyshift - 1;
+                    copyBGToBuf(bufg, sx1, sy1, sx2, sy2, bufmidx, bufmidy);
+                    sx1 = 0;
+                    sy1 = tileyshift + 1;
+                    sx2 = tilexshift - 1;
+                    sy2 = el.viewnrtilesy + 3;
+                    if (sy2 - sy1 > el.viewnrtilesy) sy2 = sy1 + el.viewnrtilesy;
+                    copyBGToBuf(bufg, sx1, sy1, sx2, sy2, bufmidx, 0);
+                    sx1 = tilexshift + 1;
+                    sy1 = 0;
+                    sx2 = el.viewnrtilesx + 3;
+                    sy2 = tileyshift - 1;
+                    if (sx2 - sx1 > el.viewnrtilesx) sx2 = sx1 + el.viewnrtilesx;
+                    copyBGToBuf(bufg, sx1, sy1, sx2, sy2, 0, bufmidy);
+                    for (int i = 0; i < el.objects.size; i++) {
+                        drawObject(bufg, (JGObject) el.objects.values[i]);
+                    }
+                    buf_gfx = null; // we're finished with the object drawing
+                    /* draw status */
+                    paintFrame(bufg);
+                }
+            } catch (JGameError e) {
+                e.printStackTrace();
+                exitEngine("Error during paint:\n"
+                        + dbgExceptionToString(e));
+            }
+        }
+
+
+        @Override
+        public boolean onTouchEvent(MotionEvent me) {
+            int action = me.getAction();
+            double x = me.getX();
+            double y = me.getY();
+            // on a multitouch, touches after the first touch are also
+            // considered mouse-down flanks.
+            boolean press = action == MotionEvent.ACTION_DOWN
+                    || action == MotionEvent.ACTION_POINTER_DOWN;
+            boolean down = press || action == MotionEvent.ACTION_MOVE;
+            mouseposd_x = (x - el.canvas_xofs) / el.x_scale_fac;
+            mouseposd_y = (y - el.canvas_yofs) / el.y_scale_fac;
+            mousepos.x = (int) mouseposd_x;
+            mousepos.y = (int) mouseposd_y;
+            if (press) { // || !mouseinside) { // if press does not register
+                mousebutton[1] = true;
+                keymap[256] = true;
+            }
+            if (action == MotionEvent.ACTION_UP) {
+                mouseinside = false;
+                mousebutton[1] = false;
+                keymap[256] = false;
+            } else {
+                mouseinside = true;
+            }
+            return true;
+        }
+
+        /**
+         * Code taken from TouchPaint example. Can't test this yet.
+         * Sensitivity should be a setting. Unclear how to test button press.
+         */
+        @Override
+        public boolean onTrackballEvent(MotionEvent event) {
+            int N = event.getHistorySize();
+            final float scaleX = event.getXPrecision();
+            final float scaleY = event.getYPrecision();
 			/*for (int i=0; i<N; i++) {
 				drawPoint(baseX+event.getHistoricalX(i)*scaleX,
 						baseY+event.getHistoricalY(i)*scaleY,
@@ -325,1866 +347,2296 @@ implements JGEngineInterface  {
 			drawPoint(baseX+event.getX()*scaleX, baseY+event.getY()*scaleY,
 					event.getPressure(), event.getSize());
 			*/
-			return true;
-		}
-
-		@Override
-		public boolean onKeyDown(int keyCode, KeyEvent msg) {
-			// not sure how to handle shift key
-			handleKey(keyCode,msg,true);
-			return true;
-		}
-
-		@Override
-		public boolean onKeyUp(int keyCode, KeyEvent msg) {
-			handleKey(keyCode,msg,false);
-			return true;
-		}
-
-		private void handleKey(int key,KeyEvent msg,boolean state) {
-			int keychar = msg.getUnicodeChar(0);
-			int modkeychar = msg.getUnicodeChar();
-			if (state) lastkeychar = (char)-1; // not defined
-			char key_to_set = 0;
-			// it appears not all KEYCODE_* are defined in older versions of
-			// Android, so we just use the numeric constants
-			switch (key) {
-			case 19 : //KeyEvent.KEYCODE_DPAD_UP :
-				key_to_set = KeyUp;
-			break;
-			case 20 : //KeyEvent.KEYCODE_DPAD_DOWN :
-				key_to_set = KeyDown;
-			break;
-			case 21 : //KeyEvent.KEYCODE_DPAD_LEFT :
-				key_to_set = KeyLeft;
-			break;
-			case 22 : //KeyEvent.KEYCODE_DPAD_RIGHT :
-				key_to_set = KeyRight;
-			break;
-			case 59 : //KeyEvent.KEYCODE_SHIFT_LEFT :
-			case 60 : //KeyEvent.KEYCODE_SHIFT_RIGHT :
-				key_to_set = KeyShift;
-			break;
-			case 57 : //KeyEvent.KEYCODE_ALT_LEFT :
-			case 58 : //KeyEvent.KEYCODE_ALT_RIGHT :
-				key_to_set = KeyAlt;
-			break;
-			case 113 : //KeyEvent.KEYCODE_CTRL_LEFT :
-			case 114 : //KeyEvent.KEYCODE_CTRL_RIGHT :
-				key_to_set = KeyCtrl;
-			break;
-			case 111 : //KeyEvent.KEYCODE_ESCAPE :
-				key_to_set = KeyEsc;
-				if (state) lastkeychar = 27;
-			break;
-			case 66 : //KeyEvent.KEYCODE_ENTER :
-			case 160 : //KeyEvent.KEYCODE_NUMPAD_ENTER :
-				key_to_set = KeyEnter;
-				if (state) lastkeychar = 10;
-			break;
-			case 67 : //KeyEvent.KEYCODE_DEL :
-				key_to_set = KeyBackspace;
-				if (state) lastkeychar = 8;
-			break;
-			case 61 : //KeyEvent.KEYCODE_TAB :
-				key_to_set = KeyTab;
-				if (state) lastkeychar = 9;
-			break;
-			default:
-				if (keychar>='a' && keychar<='z') {
-					key_to_set = (char)(keychar - 'a' + 'A');
-					if (state) lastkeychar = (char)modkeychar;
-				} else if (keychar>=32 && keychar<=127) {	
-					key_to_set = (char)keychar;
-					if (state) lastkeychar = (char)modkeychar;
-				}
-			}
-			if (key_to_set!=0) {
-				keymap[key_to_set] = state;
-				if (state) lastkey = key_to_set;
-			}
-			if (wakeup_key==-1 || keymap[wakeup_key]) {
-				if (!running) {
-					start();
-					// key is cleared when it is used as wakeup key
-					if (wakeup_key!=-1) keymap[wakeup_key]=false;
-				}
-			}
-
-		}
-	
-		/* sensorlistener */
-
-		public void onAccuracyChanged(Sensor sensor, int accuracy) {
-		}
-
-		public void onSensorChanged(SensorEvent event) {
-			if (event.sensor.getType() != Sensor.TYPE_ACCELEROMETER)
-				return;
-			float x=0,y=0,z=1;
-			switch (display.getOrientation()) {
-				case Surface.ROTATION_0:
-					x = event.values[0];
-					y = event.values[1];
-					break;
-				case Surface.ROTATION_90:
-					x = -event.values[1];
-					y = event.values[0];
-					break;
-				case Surface.ROTATION_180:
-					x = -event.values[0];
-					y = -event.values[1];
-					break;
-				case Surface.ROTATION_270:
-					x = event.values[1];
-					y = -event.values[0];
-					break;
-			}
-			z = event.values[2];
-			// handle values
-			accelvec[0] = -x;
-			accelvec[1] = y;
-			accelvec[2] = z;
-		}
-
-
+            return true;
+        }
+
+        @Override
+        public boolean onKeyDown(int keyCode, KeyEvent msg) {
+            // not sure how to handle shift key
+            handleKey(keyCode, msg, true);
+            return true;
+        }
+
+        @Override
+        public boolean onKeyUp(int keyCode, KeyEvent msg) {
+            handleKey(keyCode, msg, false);
+            return true;
+        }
+
+        private void handleKey(int key, KeyEvent msg, boolean state) {
+            int keychar = msg.getUnicodeChar(0);
+            int modkeychar = msg.getUnicodeChar();
+            if (state) lastkeychar = (char) -1; // not defined
+            char key_to_set = 0;
+            // it appears not all KEYCODE_* are defined in older versions of
+            // Android, so we just use the numeric constants
+            switch (key) {
+                case 19: //KeyEvent.KEYCODE_DPAD_UP :
+                    key_to_set = KeyUp;
+                    break;
+                case 20: //KeyEvent.KEYCODE_DPAD_DOWN :
+                    key_to_set = KeyDown;
+                    break;
+                case 21: //KeyEvent.KEYCODE_DPAD_LEFT :
+                    key_to_set = KeyLeft;
+                    break;
+                case 22: //KeyEvent.KEYCODE_DPAD_RIGHT :
+                    key_to_set = KeyRight;
+                    break;
+                case 59: //KeyEvent.KEYCODE_SHIFT_LEFT :
+                case 60: //KeyEvent.KEYCODE_SHIFT_RIGHT :
+                    key_to_set = KeyShift;
+                    break;
+                case 57: //KeyEvent.KEYCODE_ALT_LEFT :
+                case 58: //KeyEvent.KEYCODE_ALT_RIGHT :
+                    key_to_set = KeyAlt;
+                    break;
+                case 113: //KeyEvent.KEYCODE_CTRL_LEFT :
+                case 114: //KeyEvent.KEYCODE_CTRL_RIGHT :
+                    key_to_set = KeyCtrl;
+                    break;
+                case 111: //KeyEvent.KEYCODE_ESCAPE :
+                    key_to_set = KeyEsc;
+                    if (state) lastkeychar = 27;
+                    break;
+                case 66: //KeyEvent.KEYCODE_ENTER :
+                case 160: //KeyEvent.KEYCODE_NUMPAD_ENTER :
+                    key_to_set = KeyEnter;
+                    if (state) lastkeychar = 10;
+                    break;
+                case 67: //KeyEvent.KEYCODE_DEL :
+                    key_to_set = KeyBackspace;
+                    if (state) lastkeychar = 8;
+                    break;
+                case 61: //KeyEvent.KEYCODE_TAB :
+                    key_to_set = KeyTab;
+                    if (state) lastkeychar = 9;
+                    break;
+                default:
+                    if (keychar >= 'a' && keychar <= 'z') {
+                        key_to_set = (char) (keychar - 'a' + 'A');
+                        if (state) lastkeychar = (char) modkeychar;
+                    } else if (keychar >= 32 && keychar <= 127) {
+                        key_to_set = (char) keychar;
+                        if (state) lastkeychar = (char) modkeychar;
+                    }
+            }
+            if (key_to_set != 0) {
+                keymap[key_to_set] = state;
+                if (state) lastkey = key_to_set;
+            }
+            if (wakeup_key == -1 || keymap[wakeup_key]) {
+                if (!running) {
+                    start();
+                    // key is cleared when it is used as wakeup key
+                    if (wakeup_key != -1) keymap[wakeup_key] = false;
+                }
+            }
+
+        }
+
+        /* sensorlistener */
+
+        public void onAccuracyChanged(Sensor sensor, int accuracy) {
+        }
+
+        public void onSensorChanged(SensorEvent event) {
+            if (event.sensor.getType() != Sensor.TYPE_ACCELEROMETER)
+                return;
+            float x = 0, y = 0, z = 1;
+            switch (display.getOrientation()) {
+                case Surface.ROTATION_0:
+                    x = event.values[0];
+                    y = event.values[1];
+                    break;
+                case Surface.ROTATION_90:
+                    x = -event.values[1];
+                    y = event.values[0];
+                    break;
+                case Surface.ROTATION_180:
+                    x = -event.values[0];
+                    y = -event.values[1];
+                    break;
+                case Surface.ROTATION_270:
+                    x = event.values[1];
+                    y = -event.values[0];
+                    break;
+            }
+            z = event.values[2];
+            // handle values
+            accelvec[0] = -x;
+            accelvec[1] = y;
+            accelvec[2] = z;
+        }
+
+
+        void setInitialised() {
+            is_initialised = true;
+            //initpainter=null;
+        }
+
+
+        public void clearCanvas() {
+            // fill canvas with black
+            //if (bufg==null) bufg = getGraphics();
+            //bufg.setClip(0,0,getWidth(),getHeight());
+            //setColor(bufg,JGColor.black);
+            //bufg.fillRect(0,0,getWidth(),getHeight());
+        }
+
+        public void drawAll() {
+            postInvalidate();
+        }
+    }
+
+    /*=== jre applet emulation ===*/
+
+    /**
+     * Is there an android equivalent?
+     */
+    public String getParameter(String name) {
+        return null;
+    }
+
+
+    /**
+     * The current android entry point; size is determined by environment.
+     */
+    public void initEngineApplet() {
+    }
+
+    /**
+     * Not implemented yet.
+     */
+    public void initEngine(int width, int height) {
+        exitEngine("Use initEngineApplet");
+    }
+
+    /**
+     * Not implemented yet.
+     */
+    public void initEngineComponent(int width, int height) {
+        exitEngine("Use initEngineApplet");
+    }
+
+    /**
+     * Call setCanvasSettings here.
+     */
+    public abstract void initCanvas();
+
+
+    /**
+     * initialise engine, or resize view is el.is_inited is true
+     */
+    void init() {
+        boolean do_full_init = !el.is_inited;
+        if (do_full_init) {
+            storeInit();
+        }
+        // canvas size might change, we don't support this yet
+        el.winwidth = canvas.getWidth();
+        el.winheight = canvas.getHeight();
+        // get all the dimensions
+        if (do_full_init) {
+            initCanvas();
+            if (!el.view_initialised) {
+                exitEngine("Canvas settings not initialised, use setCanvasSettings().");
+            }
+        }
+        // init vars
+        //canvas = new JGCanvas(el.winwidth,el.winheight);
+        el.initPF();
+        if (do_full_init) {
+            clearKeymap();
+            // set canvas padding color  (probably we need to draw an el.bg_color
+            // rectangle)
+            // determine default font size (unscaled)
+            el.msg_font = new JGFont("Helvetica", 0,
+                    (int) (25.0 / (640.0 / (el.tilex * el.nrtilesx))));
+            if (!JGObject.setEngine(this)) {
+                exitEngine("Another JGEngine is already running!");
+            }
+            el.is_inited = true;
+        }
+        // do something like setInitPainter here to init the loading screen
+        // create background
+        // XXX find display compatible bit depth
+        background = Bitmap.createBitmap(el.width + 3 * el.scaledtilex,
+                el.height + 3 * el.scaledtiley,
+                AndroidImage.getPreferredBitmapFormat(displayformat));
+        bgg = new Canvas();
+        bgg.setBitmap(background);
+        imagepainter.setAntiAlias(el.smooth_magnify);
+        imagepainter.setFilterBitmap(el.smooth_magnify);
+        simpleimagepainter.setAntiAlias(el.smooth_magnify);
+        simpleimagepainter.setFilterBitmap(el.smooth_magnify);
+        el.invalidateBGTiles();
+        if (do_full_init) {
+            gamethread = new Thread(new JGEngineThread());
+            gamethread.start();
+        }
+    }
+
+    private void clearKeymap() {
+        for (int i = 0; i < 256 + 3; i++) keymap[i] = false;
+    }
+
+
+    abstract public void initGame();
+
+    public void start() {
+        // restart audio if possible?
+        running = true;
+    }
+
+    public void stop() {
+        // more rigorous than disableAudio but we can't be sure if the stop is
+        // permanent (likely it is).
+        stopAudio();
+        running = false;
+    }
+
+    public boolean isRunning() {
+        return running;
+    }
+
+    public void wakeUpOnKey(int key) {
+        wakeup_key = key;
+    }
+
+    public void destroyApp(boolean unconditional) {
+        destroy();
+    }
+
+    public void startApp() {
+    }
+
+    public void pauseApp() {
+    }
+
+    /**
+     * We should not call destroy in android because the app should keep
+     * running all the time.
+     */
+    public void destroy() {
+        // stop all samples (audio not implemented yet)
+        stopAudio();
+        // kill game thread
+        el.is_exited = true;
+        if (gamethread != null) {
+            gamethread.interrupt();
+            //try {
+            //	gamethread.join(2000); // give up after 2 sec
+            //} catch (InterruptedException e) {
+            //	e.printStackTrace();
+            //	// give up
+            //}
+        }
+        // close files?? that appears to be unnecessary
+        // reset global variables
+        if (el.is_inited) {
+            JGObject.setEngine(null);
+        }
+        System.out.println("JGame engine disposed.");
+    }
+
+
+    /**
+     * exitEngine with error means fatal error. exitEngine without error
+     * means quit to desktop. In Android, this means the app will continue,
+     * only the the current activity will finish.
+     */
+    public void exitEngine(String msg) {
+        // stop all samples (audio not implemented yet)
+        stopAudio();
+        if (msg != null) {
+            System.err.println(msg);
+            el.exit_message = msg;
+            // display error to user
+        } else {
+            //System.err.println("Exiting JGEngine.");
+            //destroy();
+            currentact.finish();
+        }
+    }
+
+
+    public void setCanvasSettings(int nrtilesx, int nrtilesy, int tilex, int tiley,
+                                  JGColor fgcolor, JGColor bgcolor, JGFont msgfont) {
+        el.nrtilesx = nrtilesx;
+        el.nrtilesy = nrtilesy;
+        el.viewnrtilesx = nrtilesx;
+        el.viewnrtilesy = nrtilesy;
+        el.tilex = tilex;
+        el.tiley = tiley;
+        setColorsFont(fgcolor, bgcolor, msgfont);
+        el.view_initialised = true;
+    }
+
+    public void setScalingPreferences(double min_aspect_ratio, double
+            max_aspect_ratio, int crop_top, int crop_left, int crop_bottom, int crop_right) {
+        el.min_aspect = min_aspect_ratio;
+        el.max_aspect = max_aspect_ratio;
+        el.crop_top = crop_top;
+        el.crop_left = crop_left;
+        el.crop_bottom = crop_bottom;
+        el.crop_right = crop_right;
+    }
+
+    public void setSmoothing(boolean smooth_magnify) {
+        el.smooth_magnify = smooth_magnify;
+        imagepainter.setAntiAlias(smooth_magnify);
+        imagepainter.setFilterBitmap(smooth_magnify);
+        simpleimagepainter.setAntiAlias(smooth_magnify);
+        simpleimagepainter.setFilterBitmap(smooth_magnify);
+
+    }
+
+
+    /**
+     * Engine thread, executing game action.
+     */
+    class JGEngineThread implements Runnable {
+        private long target_time = 0; /* time at which next frame should start */
+        private int frames_skipped = 0;
+
+        public JGEngineThread() {
+        }
+
+        public void run() {
+            try {
+                try {
+                    initGame();
+                    Thread.sleep(500);
+                } catch (Throwable e) {
+                    e.printStackTrace();
+                    throw new JGameError("Exception during initGame(): " + e);
+                }
+                canvas.setInitialised();
+                canvas.clearCanvas();
+                target_time = System.currentTimeMillis() + (long) (1000.0 / el.fps);
+                while (!el.is_exited) {
+                    //canvas.updateKeyState();
+                    //if ((debugflags&MSGSINPF_DEBUG)!=0) refreshDbgFrameLogs();
+                    long cur_time = System.currentTimeMillis();
+                    if (!running) {
+                        // wait in portions of 1/2 sec until running is set;
+                        // reset target time
+                        Thread.sleep(500);
+                        target_time = cur_time + (long) (1000.0 / el.fps);
+                    } else if (cur_time < target_time + 900.0 / el.fps) {
+                        // we lag behind less than 0.9 frame
+                        // -> do full frame.
+                        synchronized (el.objects) {
+                            doFrameAll();
+                            el.updateViewOffset();
+                        }
+                        canvas.drawAll();
+                        frames_skipped = 0;
+                        if (cur_time + 3 < target_time) {
+                            //we even have some time left -> sleep it away
+                            Thread.sleep(target_time - cur_time);
+                        } else {
+                            // we don't, just yield to give input handler and
+                            // painter some time
+                            Thread.yield();
+                        }
+                        target_time += (1000.0 / el.fps);
+                        //} else if (cur_time >
+                        //target_time + (long)(1000.0*el.maxframeskip/el.fps)) {
+                        //	// we lag behind more than the max # frames ->
+                        //	// draw full frame and reset target time
+                        //	synchronized (el.objects) {
+                        //		doFrameAll();
+                        //		el.updateViewOffset();
+                        //	}
+                        //	canvas.drawAll();
+                        //	frames_skipped=0;
+                        //	// yield to give input handler + painter some time
+                        //	Thread.yield();
+                        //	target_time=cur_time + (long)(1000.0/el.fps);
+                    } else {
+                        // we lag behind a little -> frame skip
+                        synchronized (el.objects) {
+                            doFrameAll();
+                            el.updateViewOffset();
+                        }
+                        // if we skip too many frames in succession, draw a frame
+                        if ((++frames_skipped) > el.maxframeskip) {
+                            //canvas.repaint();
+                            canvas.drawAll();
+                            frames_skipped = 0;
+                            target_time = cur_time + (long) (1000.0 / el.fps);
+                        } else {
+                            target_time += (long) (1000.0 / el.fps);
+                        }
+                        // yield to give input handler some time
+                        Thread.yield();
+                    }
+                }
+            } catch (InterruptedException e) {
+                /* exit thread when interrupted */
+                System.out.println("JGame thread exited.");
+            } catch (Exception e) {
+                dbgShowException("MAIN", e);
+            } catch (JGameError e) {
+                e.printStackTrace();
+                exitEngine("Error in main:\n" + dbgExceptionToString(e));
+            }
+        }
+    }
+
+
+
+
+    /*====== variables from engine ======*/
+
+
+    /**
+     * Should engine thread run or halt? Set by start() / stop()
+     */
+    boolean running = true;
+
+
+    Canvas buf_gfx = null;
+
+
+    /*====== platform-dependent variables ======*/
+
+
+    /* keyboard */
+
+    /**
+     * The codes 256-258 are the mouse buttons
+     */
+    boolean[] keymap = new boolean[256 + 3];
+    int lastkey = 0;
+    char lastkeychar = 0;
+    int wakeup_key = 0;
+
+
+
+    /*====== images ======*/
+
+
+    public JGImage getImage(String imgname) {
+        return el.getImage(imgname);
+    }
+
+
+    public JGPoint getImageSize(String imgname) {
+        return el.getImageSize(imgname);
+    }
+
+    public void defineMedia(String filename) {
+        //	el.defineMedia(this,filename);
+        //}
+        //public void defineMedia(JGEngineInterface eng,String filename) {
+        // getResourceAsStream does not work in android
+        int lnr = 1;
+        int nr_lines = 0;
+        try {
+            InputStream instr = getAssets().open(filename);
+            //InputStream instr = getClass().getResourceAsStream(filename);
+            if (instr == null) exitEngine("Cannot open `" + filename + "'.");
+            InputStreamReader in = new InputStreamReader(instr);
+            if (in == null) exitEngine("Cannot open `" + filename + "'.");
+            // count nr of lines in file first
+            while (EngineLogic.readline(in) != null) nr_lines++;
+            if (nr_lines == 0) exitEngine("Cannot open `" + filename + "'.");
+            // now, read the file
+            in = new InputStreamReader(getAssets().open(filename));
+            String line;
+            String[] fields = new String[14];
+            while ((line = EngineLogic.readline(in)) != null) {
+                setProgressBar((double) lnr / (double) nr_lines);
+                int i = 0;
+                Vector tokens = EngineLogic.tokenizeString(line, '\t');
+                for (Enumeration e = tokens.elements(); e.hasMoreElements(); ) {
+                    fields[i++] = (String) e.nextElement();
+                }
+                if (i == 8) {
+                    defineImageMap(this,
+                            fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            Integer.parseInt(fields[3]),
+                            Integer.parseInt(fields[4]),
+                            Integer.parseInt(fields[5]),
+                            Integer.parseInt(fields[6]),
+                            Integer.parseInt(fields[7]));
+                } else if (i == 9) {
+                    defineImage(fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            fields[3],
+                            fields[4],
+                            Integer.parseInt(fields[5]),
+                            Integer.parseInt(fields[6]),
+                            Integer.parseInt(fields[7]),
+                            Integer.parseInt(fields[8]));
+                } else if (i == 5) {
+                    defineImage(fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            fields[3],
+                            fields[4], -1, -1, -1, -1);
+                } else if (i == 10) {
+                    el.defineImage(fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            el.getSubImage(fields[3],
+                                    Integer.parseInt(fields[4])),
+                            fields[5],
+                            Integer.parseInt(fields[6]),
+                            Integer.parseInt(fields[7]),
+                            Integer.parseInt(fields[8]),
+                            Integer.parseInt(fields[9]));
+                } else if (i == 6) {
+                    el.defineImage(fields[0], fields[1],
+                            Integer.parseInt(fields[2]),
+                            el.getSubImage(fields[3],
+                                    Integer.parseInt(fields[4])),
+                            fields[5], -1, -1, -1, -1);
+                } else if (i == 3) {
+                    defineAnimation(fields[0], EngineLogic.splitList(fields[1]),
+                            Double.parseDouble(fields[2]));
+                } else if (i == 4) {
+                    defineAnimation(fields[0], EngineLogic.splitList(fields[1]),
+                            Double.parseDouble(fields[2]),
+                            fields[3].equals("true"));
+                } else if (i == 2) {
+                    defineAudioClip(fields[0], fields[1]);
+                }
+                lnr++;
+            }
+        } catch (JGameError e) {
+            exitEngine("Error in " + filename + " line " + lnr + ": " + e);
+        } catch (Exception e) {
+            exitEngine("Error in " + filename + " line " + lnr + ":\n"
+                    + dbgExceptionToString(e));
+        }
+
+    }
+
+    public void defineImage(String name, String tilename, int collisionid,
+                            String imgfile, String img_op,
+                            int top, int left, int width, int height) {
+        //el.
+        defineImage(this, name, tilename, collisionid, imgfile, img_op,
+                top, left, width, height);
+    }
+
+    public void defineImage(String imgname, String tilename, int collisionid,
+                            String imgfile, String img_op) {
+        //el.
+        defineImage(this, imgname, tilename, collisionid, imgfile, img_op,
+                -1, -1, -1, -1);
+    }
+
+    public void defineImage(String imgname, String tilename, int collisionid,
+                            String imgmap, int mapidx, String img_op,
+                            int top, int left, int width, int height) {
+        //el.
+        defineImage(imgname, tilename, collisionid, imgmap, mapidx,
+                img_op, top, left, width, height);
+    }
+
+    public void defineImage(String imgname, String tilename, int collisionid,
+                            String imgmap, int mapidx, String img_op) {
+        el.defineImage(imgname, tilename, collisionid, imgmap, mapidx, img_op);
+    }
+
+    public void defineImageRotated(String name, String tilename,
+                                   int collisionid, String srcname, double angle) {
+        el.defineImageRotated(this, name, tilename, collisionid, srcname, angle);
+    }
+
+
+    public void defineImageMap(String mapname, String imgfile,
+                               int xofs, int yofs, int tilex, int tiley, int skipx, int skipy) {
+        //el.
+        defineImageMap(this, mapname, imgfile, xofs, yofs, tilex, tiley,
+                skipx, skipy);
+    }
+
+    // replaces enginelogic.defineImage because path should not be prepended
+    // XXX defineImageRotated also affected
+    public void defineImage(Object pkg_obj, String name, String tilename,
+                            int collisionid, String imgfile, String img_op,
+                            int top, int left, int width, int height) {
+        if (el.images_loaded.containsKey(name)
+                && !el.images_loaded.get(name).equals(imgfile)) {
+            // if associated file is not the same, undefine old image
+            el.undefineImage(name);
+        }
+        JGImage img = null;
+        if (!imgfile.equals("null")) {
+            //imgfile = getAbsolutePath(pkg_obj,imgfile);
+            img = el.imageutil.loadImage(imgfile);
+            el.images_loaded.put(name, imgfile);
+        }
+        el.defineImage(name, tilename, collisionid, img,
+                img_op, top, left, width, height);
+    }
+
+    // again the path problem
+    public void defineImageMap(Object pkg_obj, String mapname, String imgfile,
+                               int xofs, int yofs, int tilex, int tiley, int skipx, int skipy) {
+        //imgfile = getAbsolutePath(pkg_obj,imgfile);
+        el.imagemaps.put(mapname, new ImageMap(el.imageutil, imgfile, xofs, yofs,
+                tilex, tiley, skipx, skipy));
+    }
+
+
+    public JGRectangle getImageBBox(String imgname) {
+        return el.getImageBBox(imgname);
+    }
+
+
+    /*====== PF/view ======*/
+
+
+    /*====== objects from canvas ======*/
+
+    public void markAddObject(JGObject obj) {
+        el.markAddObject(obj);
+    }
+
+    public boolean existsObject(String index) {
+        return el.existsObject(index);
+    }
+
+    public JGObject getObject(String index) {
+        return el.getObject(index);
+    }
+
+    public void moveObjects(String prefix, int cidmask) {
+        el.moveObjects(this, prefix, cidmask);
+    }
+
+    public void moveObjects() {
+        el.moveObjects(this);
+    }
+
+    public void checkCollision(int srccid, int dstcid) {
+        el.checkCollision(this, srccid, dstcid);
+    }
+
+    public int checkCollision(int cidmask, JGObject obj) {
+        return el.checkCollision(cidmask, obj);
+    }
+
+    public int checkBGCollision(JGRectangle r) {
+        return el.checkBGCollision(r);
+    }
+
+    public void checkBGCollision(int tilecid, int objcid) {
+        el.checkBGCollision(this, tilecid, objcid);
+    }
+
+    /* objects from engine */
+
+    public Vector getObjects(String prefix, int cidmask, boolean suspended_obj,
+                             JGRectangle bbox) {
+        return el.getObjects(prefix, cidmask, suspended_obj,
+                bbox);
+    }
+
+    public void removeObject(JGObject obj) {
+        el.removeObject(obj);
+    }
+
+    public void removeObjects(String prefix, int cidmask) {
+        el.removeObjects(prefix, cidmask);
+    }
+
+    public void removeObjects(String prefix, int cidmask, boolean suspended_obj) {
+        el.removeObjects(prefix, cidmask, suspended_obj);
+    }
+
+    public int countObjects(String prefix, int cidmask) {
+        return el.countObjects(prefix, cidmask);
+    }
+
+    public int countObjects(String prefix, int cidmask, boolean suspended_obj) {
+        return el.countObjects(prefix, cidmask, suspended_obj);
+    }
+
+
+    void drawObject(Canvas g, JGObject o) {
+        if (!o.is_suspended) {
+            drawImage(g, (int) o.x, (int) o.y, o.getImageName(), true);
+            try {
+                o.paint();
+            } catch (JGameError ex) {
+                ex.printStackTrace();
+                exitEngine(dbgExceptionToString(ex));
+            } catch (Exception e) {
+                dbgShowException(o.getName(), e);
+            }
+        }
+        // debug functionality not implemented in midp
+    }
+
+
+
+    /*====== BG/tiles ======*/
+
+    public void setBGImage(String bgimg) {
+        el.setBGImage(bgimg, 0, true, true);
+    }
+
+    public void setBGImage(int depth, String bgimg, boolean wrapx, boolean wrapy) {
+        el.setBGImage(bgimg, depth, wrapx, wrapy);
+    }
+
+
+    public void setTileSettings(String out_of_bounds_tile,
+                                int out_of_bounds_cid, int preserve_cids) {
+        el.setTileSettings(out_of_bounds_tile, out_of_bounds_cid, preserve_cids);
+    }
+
+    public void fillBG(String filltile) {
+        el.fillBG(filltile);
+    }
+
+    public void setTileCid(int x, int y, int and_mask, int or_mask) {
+        el.setTileCid(x, y, and_mask, or_mask);
+    }
+
+    public void setTile(int x, int y, String tilestr) {
+        el.setTile(x, y, tilestr);
+    }
+
+    void setColor(Paint p, JGColor col) {
+        p.setColor((col.alpha << 24) | (col.r << 16) | (col.g << 8) | col.b);
+    }
+
+
+    /**
+     * xi,yi are tile indexes relative to the tileofs, that is, the top left
+     * of the bg, + 1. They must be within both the tilemap and the view.
+     */
+    public void drawTile(int xi, int yi, int tileid) {
+        if (background == null || bgg == null) return;
+        // determine position within bg
+        int x = el.moduloFloor(xi + 1, el.viewnrtilesx + 3) * el.scaledtilex;
+        int y = el.moduloFloor(yi + 1, el.viewnrtilesy + 3) * el.scaledtiley;
+        // draw
+        Integer tileid_obj = new Integer(tileid);
+        AndroidImage img = (AndroidImage) el.getTileImage(tileid_obj);
+        // define background behind tile in case the tile is null or
+        // transparent.
+        if (img == null || el.images_transp.containsKey(tileid_obj)) {
+            EngineLogic.BGImage bg_image = (EngineLogic.BGImage)
+                    el.bg_images.elementAt(0);
+            if (bg_image == null) {
+                setColor(bgpainter, el.bg_color);
+                bgg.drawRect(new Rect(x, y, x + el.scaledtilex, y + el.scaledtiley),
+                        bgpainter);
+            } else {
+                int xtile = el.moduloFloor(xi, bg_image.tiles.x);
+                int ytile = el.moduloFloor(yi, bg_image.tiles.y);
+                bgg.drawBitmap(
+                        ((AndroidImage) el.getImage(bg_image.imgname)).img,
+                        new Rect(xtile * el.scaledtilex, ytile * el.scaledtiley,
+                                (xtile + 1) * el.scaledtilex, (ytile + 1) * el.scaledtiley),
+                        new Rect(x, y, x + el.scaledtilex, y + el.scaledtiley),
+                        bgpainter);
+            }
+        }
+        if (img != null) {
+            bgg.drawBitmap(img.img, x, y, bgpainter);
+        }
+        //System.out.println("Drawn tile"+tileid);
+    }
+
+
+    public int countTiles(int tilecidmask) {
+        return el.countTiles(tilecidmask);
+    }
+
+    public int getTileCid(int xidx, int yidx) {
+        return el.getTileCid(xidx, yidx);
+    }
+
+    public String getTileStr(int xidx, int yidx) {
+        return el.getTileStr(xidx, yidx);
+    }
+
+    public int getTileCid(JGRectangle tiler) {
+        return el.getTileCid(tiler);
+    }
+
+    public JGRectangle getTiles(JGRectangle r) {
+        return el.getTiles(r);
+    }
+
+    public boolean getTiles(JGRectangle dest, JGRectangle r) {
+        return el.getTiles(dest, r);
+    }
+
+
+    public void setTileCid(int x, int y, int value) {
+        el.setTileCid(x, y, value);
+    }
+
+    public void orTileCid(int x, int y, int or_mask) {
+        el.orTileCid(x, y, or_mask);
+    }
+
+    public void andTileCid(int x, int y, int and_mask) {
+        el.andTileCid(x, y, and_mask);
+    }
+
+    public void setTile(JGPoint tileidx, String tilename) {
+        el.setTile(tileidx, tilename);
+    }
+
+    public void setTiles(int xofs, int yofs, String[] tilemap) {
+        el.setTiles(xofs, yofs, tilemap);
+    }
+
+    public void setTilesMulti(int xofs, int yofs, String[] tilemap) {
+        el.setTilesMulti(xofs, yofs, tilemap);
+    }
+
+    public int getTileCidAtCoord(double x, double y) {
+        return el.getTileCidAtCoord(x, y);
+    }
+
+    public int getTileCid(JGPoint center, int xofs, int yofs) {
+        return el.getTileCid(center, xofs, yofs);
+    }
+
+    public String getTileStrAtCoord(double x, double y) {
+        return el.getTileStrAtCoord(x, y);
+    }
+
+    public String getTileStr(JGPoint center, int xofs, int yofs) {
+        return el.getTileStr(center, xofs, yofs);
+    }
+
+    public int tileStrToID(String tilestr) {
+        return el.tileStrToID(tilestr);
+    }
+
+    public String tileIDToStr(int tileid) {
+        return el.tileIDToStr(tileid);
+    }
+
+
+    /**
+     * dx1 and dy1 are coordinates on canvas buffer, without canvas_ofs.
+     */
+    void copyBGToBuf(Canvas bufg, int sx1, int sy1, int sx2, int sy2,
+                     int dx1, int dy1) {
+        //dx1 += el.canvas_xofs;
+        //dy1 += el.canvas_yofs;
+        //System.out.println("("+sx1+","+sy1+")-("+sx2+","+sy2+")");
+        if (sx2 <= sx1 || sy2 <= sy1) return;
+        int barrelx = el.scaleXPos(el.moduloFloor(el.xofs, el.tilex), false);
+        int barrely = el.scaleYPos(el.moduloFloor(el.yofs, el.tiley), false);
+        int barreldx = (sx1 == 0) ? barrelx : 0;
+        int barreldy = (sy1 == 0) ? barrely : 0;
+        barrelx = (sx1 == 0) ? 0 : barrelx;
+        barrely = (sy1 == 0) ? 0 : barrely;
+        int dx2 = dx1 + sx2 - sx1;
+        int dy2 = dy1 + sy2 - sy1;
+        // ensure source coordinates are not out of the bounds of the source
+        // image
+        int sx1e = barrelx + sx1 * el.scaledtilex;
+        int sy1e = barrely + sy1 * el.scaledtiley;
+        int sx2e = barrelx + sx2 * el.scaledtilex;
+        int sx2max = (el.viewnrtilesx + 3) * el.scaledtilex;
+        if (sx2e > sx2max) sx2e = sx2max;
+        int sy2e = barrely + sy2 * el.scaledtiley;
+        int sy2max = (el.viewnrtilesy + 3) * el.scaledtiley;
+        if (sy2e > sy2max) sy2e = sy2max;
+        //void drawRegion(Image src, int x_src, int y_src, int width, int height, int transform, int x_dest, int y_dest, int anchor)
+        bufg.drawBitmap(background,
+                new Rect(sx1e, sy1e, sx2e, sy2e),
+                //barrelx+sx1*el.scaledtilex, barrely+sy1*el.scaledtiley,
+                //(sx2-sx1)*el.scaledtilex, (sy2-sy1)*el.scaledtiley,
+                new Rect(dx1 * el.scaledtilex - barreldx + el.canvas_xofs,
+                        dy1 * el.scaledtiley - barreldy + el.canvas_yofs,
+                        dx1 * el.scaledtilex - barreldx + el.canvas_xofs + sx2e - sx1e,
+                        dy1 * el.scaledtiley - barreldy + el.canvas_yofs + sy2e - sy1e),
+                simpleimagepainter);
+        //bufg.drawImage(background,
+        //	dx1*el.scaledtilex-barreldx, dy1*el.scaledtiley-barreldy,
+        //	dx2*el.scaledtilex-barreldx, dy2*el.scaledtiley-barreldy,
+        //	barrelx+sx1*el.scaledtilex, barrely+sy1*el.scaledtiley,
+        //	barrelx+sx2*el.scaledtilex, barrely+sy2*el.scaledtiley,
+        //	this);
+    }
+
+
+
+    /*====== math ======*/
+
+
+    public double moduloXPos(double x) {
+        return el.moduloXPos(x);
+    }
+
+    public double moduloYPos(double y) {
+        return el.moduloYPos(y);
+    }
+
+
+    /*====== debug ======*/
+
+    public void dbgShowBoundingBox(boolean enabled) {
+    }
+
+    public void dbgShowGameState(boolean enabled) {
+    }
+
+    public void dbgShowFullStackTrace(boolean enabled) {
+    }
+
+    public void dbgShowMessagesInPf(boolean enabled) {
+    }
+
+    public void dbgSetMessageExpiry(int ticks) {
+    }
+
+    public void dbgSetMessageFont(JGFont font) {
+    }
+
+    public void dbgSetDebugColor1(JGColor col) {
+    }
+
+    public void dbgSetDebugColor2(JGColor col) {
+    }
+
+    public void dbgPrint(String msg) {
+        dbgPrint("MAIN", msg);
+    }
+
+    public void dbgPrint(String source, String msg) {
+        System.out.println(source + ": " + msg);
+    }
+
+    public void dbgShowException(String source, Throwable e) {
+        e.printStackTrace();
+        //dbgPrint(source,st.toString());
+    }
+
+    public String dbgExceptionToString(Throwable e) {
+        return e.toString();
+    }
+
+
+    //public void setCanvasSettings(int nrtilesx,int nrtilesy,int tilex,int tiley,
+    //Color fgcolor, Color bgcolor, Font msgfont) {
+    //	el.setCanvasSettings(nrtilesx,nrtilesy,tilex,tiley,
+    //		fgcolor, bgcolor, msgfont);
+    //}
+
+    public void requestGameFocus() {
+    }
+
+    // note: these get and set methods do not delegate calls
 
-		void setInitialised() {
-			is_initialised=true; 
-			//initpainter=null;
-		}
+    public boolean isApplet() {
+        return false;
+    }
 
+    public boolean isMidlet() {
+        return false;
+    }
 
+    public boolean isAndroid() {
+        return true;
+    }
 
-		public void clearCanvas() {
-			// fill canvas with black
-			//if (bufg==null) bufg = getGraphics();
-			//bufg.setClip(0,0,getWidth(),getHeight());
-			//setColor(bufg,JGColor.black);
-			//bufg.fillRect(0,0,getWidth(),getHeight());
-		}
+    public boolean isOpenGL() {
+        return false;
+    }
 
-		public void drawAll() {
-			postInvalidate();
-		}
-	}
-
-	/*=== jre applet emulation ===*/
-
-	/** Is there an android equivalent?
-	 */
-	public String getParameter(String name) { return null; }
-
-
-
-	/** The current android entry point; size is determined by environment. */
-	public void initEngineApplet() { }
-
-	/** Not implemented yet. */
-	public void initEngine(int width,int height) {
-		exitEngine("Use initEngineApplet");
-	}
-	/** Not implemented yet. */
-	public void initEngineComponent(int width,int height) {
-		exitEngine("Use initEngineApplet");
-	}
-
-	/** Call setCanvasSettings here. */
-	public abstract void initCanvas();
-
-
-
-	/** initialise engine, or resize view is el.is_inited is true */
-	void init() {
-		boolean do_full_init = !el.is_inited;
-		if (do_full_init) {
-			storeInit();
-		}
-		// canvas size might change, we don't support this yet
-		el.winwidth = canvas.getWidth();
-		el.winheight= canvas.getHeight();
-		// get all the dimensions
-		if (do_full_init) {
-			initCanvas();
-			if (!el.view_initialised) {
-				exitEngine("Canvas settings not initialised, use setCanvasSettings().");
-			}
-		}
-		// init vars
-		//canvas = new JGCanvas(el.winwidth,el.winheight);
-		el.initPF();
-		if (do_full_init) {
-			clearKeymap();
-			// set canvas padding color  (probably we need to draw an el.bg_color
-			// rectangle)
-			// determine default font size (unscaled)
-			el.msg_font = new JGFont("Helvetica",0,
-				(int)(25.0/(640.0/(el.tilex * el.nrtilesx))));
-			if (!JGObject.setEngine(this)) {
-				exitEngine("Another JGEngine is already running!");
-			}
-			el.is_inited=true;
-		}
-		// do something like setInitPainter here to init the loading screen
-		// create background 
-		// XXX find display compatible bit depth
-		background = Bitmap.createBitmap(el.width+3*el.scaledtilex,
-				el.height+3*el.scaledtiley, 
-				AndroidImage.getPreferredBitmapFormat(displayformat));
-		bgg = new Canvas();
-		bgg.setBitmap(background);
-		imagepainter.setAntiAlias(el.smooth_magnify);
-		imagepainter.setFilterBitmap(el.smooth_magnify);
-		simpleimagepainter.setAntiAlias(el.smooth_magnify);
-		simpleimagepainter.setFilterBitmap(el.smooth_magnify);
-		el.invalidateBGTiles();
-		if (do_full_init) {
-			gamethread = new Thread(new JGEngineThread());
-			gamethread.start();
-		}
-	}
-
-	private void clearKeymap() {
-		for (int i=0; i<256+3; i++) keymap[i]=false;
-	}
-
-
-	abstract public void initGame();
-
-	public void start() {
-		// restart audio if possible?
-		running=true; 
-	}
-
-	public void stop() {
-		// more rigorous than disableAudio but we can't be sure if the stop is
-		// permanent (likely it is).
-		stopAudio();
-		running=false; 
-	}
-
-	public boolean isRunning() { return running; }
-
-	public void wakeUpOnKey(int key) { wakeup_key=key; }
-
-	public void destroyApp(boolean unconditional) { destroy(); }
-	public void startApp() { }
-	public void pauseApp() { }
-
-	/** We should not call destroy in android because the app should keep
-	 * running all the time. */
-	public void destroy() {
-		// stop all samples (audio not implemented yet)
-		stopAudio();
-		// kill game thread
-		el.is_exited=true;
-		if (gamethread!=null) {
-			gamethread.interrupt();
-			//try {
-			//	gamethread.join(2000); // give up after 2 sec
-			//} catch (InterruptedException e) {
-			//	e.printStackTrace();
-			//	// give up
-			//}
-		}
-		// close files?? that appears to be unnecessary
-		// reset global variables
-		if (el.is_inited) {
-			JGObject.setEngine(null);
-		}
-		System.out.println("JGame engine disposed.");
-	}
-
-
-	/** exitEngine with error means fatal error. exitEngine without error
-	 * means quit to desktop. In Android, this means the app will continue,
-	 * only the the current activity will finish. */
-	public void exitEngine(String msg) {
-		// stop all samples (audio not implemented yet)
-		stopAudio();
-		if (msg!=null) {
-			System.err.println(msg);
-			el.exit_message=msg;
-			// display error to user
-		} else {
-			//System.err.println("Exiting JGEngine.");
-			//destroy();
-			currentact.finish();
-		}
-	}
-
-
-
-	public void setCanvasSettings(int nrtilesx,int nrtilesy,int tilex,int tiley,
-	JGColor fgcolor, JGColor bgcolor, JGFont msgfont) {
-		el.nrtilesx=nrtilesx;
-		el.nrtilesy=nrtilesy;
-		el.viewnrtilesx=nrtilesx;
-		el.viewnrtilesy=nrtilesy;
-		el.tilex=tilex;
-		el.tiley=tiley;
-		setColorsFont(fgcolor,bgcolor,msgfont);
-		el.view_initialised=true;
-	}
-
-	public void setScalingPreferences(double min_aspect_ratio, double
-	max_aspect_ratio,int crop_top,int crop_left,int crop_bottom,int crop_right){
-		el.min_aspect = min_aspect_ratio;
-		el.max_aspect = max_aspect_ratio;
-		el.crop_top = crop_top;
-		el.crop_left= crop_left;
-		el.crop_bottom = crop_bottom;
-		el.crop_right = crop_right;
-	}
-
-	public void setSmoothing(boolean smooth_magnify) {
-		el.smooth_magnify = smooth_magnify;
-		imagepainter.setAntiAlias(smooth_magnify);
-		imagepainter.setFilterBitmap(smooth_magnify);
-		simpleimagepainter.setAntiAlias(smooth_magnify);
-		simpleimagepainter.setFilterBitmap(smooth_magnify);
-
-	}
-
-
-	/** Engine thread, executing game action. */
-	class JGEngineThread implements Runnable {
-		private long target_time=0; /* time at which next frame should start */
-		private int frames_skipped=0;
-		public JGEngineThread () {}
-		public void run() { try {
-			try {
-				initGame();
-				Thread.sleep(500);
-			} catch (Throwable e) {
-				e.printStackTrace();
-				throw new JGameError("Exception during initGame(): "+e);
-			}
-			canvas.setInitialised();
-			canvas.clearCanvas();
-			target_time = System.currentTimeMillis()+(long)(1000.0/el.fps);
-			while (!el.is_exited) {
-				//canvas.updateKeyState();
-				//if ((debugflags&MSGSINPF_DEBUG)!=0) refreshDbgFrameLogs();
-				long cur_time = System.currentTimeMillis();
-				if (!running) {
-					// wait in portions of 1/2 sec until running is set;
-					// reset target time
-					Thread.sleep(500);
-					target_time = cur_time+(long)(1000.0/el.fps);
-				} else if (cur_time < target_time + 900.0/el.fps) {
-					// we lag behind less than 0.9 frame
-					// -> do full frame.
-					synchronized (el.objects) {
-						doFrameAll();
-						el.updateViewOffset();
-					}
-					canvas.drawAll();
-					frames_skipped=0;
-					if (cur_time+3 < target_time) {
-						//we even have some time left -> sleep it away
-						Thread.sleep(target_time-cur_time);
-					} else {
-						// we don't, just yield to give input handler and
-						// painter some time
-						Thread.yield();
-					}
-					target_time += (1000.0/el.fps);
-				//} else if (cur_time >
-				//target_time + (long)(1000.0*el.maxframeskip/el.fps)) {
-				//	// we lag behind more than the max # frames ->
-				//	// draw full frame and reset target time
-				//	synchronized (el.objects) {
-				//		doFrameAll();
-				//		el.updateViewOffset();
-				//	}
-				//	canvas.drawAll();
-				//	frames_skipped=0;
-				//	// yield to give input handler + painter some time
-				//	Thread.yield();
-				//	target_time=cur_time + (long)(1000.0/el.fps);
-				} else {
-					// we lag behind a little -> frame skip
-					synchronized (el.objects) {
-						doFrameAll();
-						el.updateViewOffset();
-					}
-					// if we skip too many frames in succession, draw a frame
-					if ((++frames_skipped) > el.maxframeskip) {
-						//canvas.repaint();
-						canvas.drawAll();
-						frames_skipped=0;
-						target_time=cur_time + (long)(1000.0/el.fps);
-					} else {
-						target_time += (long)(1000.0/el.fps);
-					}
-					// yield to give input handler some time
-					Thread.yield();
-				}
-			}
-		} catch (InterruptedException e) {
-			/* exit thread when interrupted */
-			System.out.println("JGame thread exited.");
-		} catch (Exception e) {
-			dbgShowException("MAIN",e);
-		} catch (JGameError e) {
-			e.printStackTrace();
-			exitEngine("Error in main:\n"+dbgExceptionToString(e));
-		} }
-	}
-
-
-
-
-	/*====== variables from engine ======*/
-
-
-	/** Should engine thread run or halt? Set by start() / stop()*/
-	boolean running=true;
-
-
-	Canvas buf_gfx=null;
-
-
-	/*====== platform-dependent variables ======*/
-
-
-	/* keyboard */
-
-	/** The codes 256-258 are the mouse buttons */
-	boolean [] keymap = new boolean [256+3];
-	int lastkey=0;
-	char lastkeychar=0;
-	int wakeup_key=0;
-
-
-
-	/*====== images ======*/
-
-
-
-	public JGImage getImage(String imgname) {
-		return el.getImage(imgname);
-	}
-
-
-	public JGPoint getImageSize(String imgname) {
-		return el.getImageSize(imgname);
-	}
-
-	public void defineMedia(String filename) {
-	//	el.defineMedia(this,filename);
-	//}
-	//public void defineMedia(JGEngineInterface eng,String filename) {
-		// getResourceAsStream does not work in android
-		int lnr=1;
-		int nr_lines=0;
-		try {
-			InputStream instr = getAssets().open(filename);
-			//InputStream instr = getClass().getResourceAsStream(filename);
-			if (instr==null) exitEngine("Cannot open `"+filename+"'.");
-			InputStreamReader in = new InputStreamReader(instr);
-			if (in==null) exitEngine("Cannot open `"+filename+"'.");
-			// count nr of lines in file first
-			while (EngineLogic.readline(in) != null) nr_lines++;
-			if (nr_lines==0) exitEngine("Cannot open `"+filename+"'.");
-			// now, read the file
-			in = new InputStreamReader(getAssets().open(filename));
-			String line;
-			String [] fields = new String [14];
-			while ( (line = EngineLogic.readline(in)) != null) {
-				setProgressBar((double)lnr / (double)nr_lines);
-				int i=0;
-				Vector tokens = EngineLogic.tokenizeString(line,'\t');
-				for (Enumeration e=tokens.elements(); e.hasMoreElements(); ) {
-					fields[i++] = (String)e.nextElement();
-				}
-				if (i==8) {
-					defineImageMap(this,
-						fields[0], fields[1],
-						Integer.parseInt(fields[2]),
-						Integer.parseInt(fields[3]),
-						Integer.parseInt(fields[4]),
-						Integer.parseInt(fields[5]),
-						Integer.parseInt(fields[6]),
-						Integer.parseInt(fields[7]) );
-				} else if (i==9) {
-					defineImage(fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						fields[3],
-						fields[4],
-						Integer.parseInt(fields[5]),
-						Integer.parseInt(fields[6]),
-						Integer.parseInt(fields[7]),
-						Integer.parseInt(fields[8])  );
-				} else if (i==5) {
-					defineImage(fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						fields[3],
-						fields[4], -1,-1,-1,-1  );
-				} else if (i==10) {
-					el.defineImage(fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						el.getSubImage(fields[3],
-							Integer.parseInt(fields[4]) ),
-						fields[5],
-						Integer.parseInt(fields[6]),
-						Integer.parseInt(fields[7]),
-						Integer.parseInt(fields[8]),
-						Integer.parseInt(fields[9])  );
-				} else if (i==6) {
-					el.defineImage(fields[0],fields[1],
-						Integer.parseInt(fields[2]),
-						el.getSubImage(fields[3],
-							Integer.parseInt(fields[4]) ),
-						fields[5], -1,-1,-1,-1  );
-				} else if (i==3) {
-					defineAnimation(fields[0], EngineLogic.splitList(fields[1]), 
-						Double.parseDouble(fields[2])  );
-				} else if (i==4) {
-					defineAnimation(fields[0], el.splitList(fields[1]),
-						Double.parseDouble(fields[2]),
-						fields[3].equals("true"));
-				} else if (i==2) {
-					defineAudioClip(fields[0], fields[1]);
-				}
-				lnr++;
-			}
-		} catch (JGameError e) {
-			exitEngine("Error in "+filename+" line "+lnr+": "+e);
-		} catch (Exception e) {
-			exitEngine("Error in "+filename+" line "+lnr+":\n"
-				+ dbgExceptionToString(e));
-		}
-		
-	}
-
-	public void defineImage(String name, String tilename, int collisionid,
-	String imgfile, String img_op,
-	int top,int left, int width,int height) {
-		//el.
-		defineImage(this,name,tilename,collisionid,imgfile,img_op,
-			top,left, width,height);
-	}
-
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgfile, String img_op) {
-		//el.
-		defineImage(this,imgname,tilename,collisionid,imgfile, img_op,
-			-1,-1,-1,-1);
-	}
-
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgmap, int mapidx, String img_op,
-	int top,int left, int width,int height) {
-		//el.
-		defineImage(imgname,tilename,collisionid,  imgmap, mapidx,
-			img_op, top,left,width,height );
-	}
-
-	public void defineImage(String imgname, String tilename, int collisionid,
-	String imgmap, int mapidx, String img_op) {
-		el.defineImage(imgname,tilename,collisionid, imgmap, mapidx, img_op);
-	}
-
-	public void defineImageRotated(String name, String tilename,
-	int collisionid, String srcname, double angle) {
-		el.defineImageRotated(this,name,tilename,collisionid, srcname, angle);
-	}
-
-
-	public void defineImageMap(String mapname, String imgfile,
-	int xofs,int yofs, int tilex,int tiley, int skipx,int skipy) {
-		//el.
-		defineImageMap(this,mapname,imgfile, xofs,yofs, tilex,tiley,
-			skipx,skipy);
-	}
-
-	// replaces enginelogic.defineImage because path should not be prepended
-	// XXX defineImageRotated also affected
-	public void defineImage(Object pkg_obj,String name, String tilename,
-	int collisionid, String imgfile, String img_op,
-	int top,int left, int width,int height) {
-		if ( el.images_loaded.containsKey(name)
-		&&  !el.images_loaded.get(name).equals(imgfile)) {
-			// if associated file is not the same, undefine old image
-			el.undefineImage(name);
-		}
-		JGImage img=null;
-		if (!imgfile.equals("null")) {
-			//imgfile = getAbsolutePath(pkg_obj,imgfile);
-			img = el.imageutil.loadImage(imgfile);
-			el.images_loaded.put(name,imgfile);
-		}
-		el.defineImage(name,tilename, collisionid, img,
-			img_op, top,left, width,height);
-	}
-	// again the path problem
-	public void defineImageMap(Object pkg_obj,String mapname, String imgfile,
-		int xofs,int yofs, int tilex,int tiley, int skipx,int skipy) {
-		//imgfile = getAbsolutePath(pkg_obj,imgfile);
-		el.imagemaps.put(mapname, new ImageMap (el.imageutil,imgfile, xofs,yofs,
-			tilex,tiley, skipx,skipy) );
-	}
-
-
-	public JGRectangle getImageBBox(String imgname) {
-		return el.getImageBBox(imgname);
-	}
-
-
-	/*====== PF/view ======*/
-
-
-	/*====== objects from canvas ======*/
-
-	public void markAddObject(JGObject obj) {
-		el.markAddObject(obj);
-	}
-
-	public boolean existsObject(String index) {
-		return el.existsObject(index);
-	}
-
-	public JGObject getObject(String index) {
-		return el.getObject(index);
-	}
-
-	public void moveObjects(String prefix, int cidmask) {
-		el.moveObjects(this,prefix, cidmask);
-	}
-
-	public void moveObjects() {
-		el.moveObjects(this);
-	}
-
-	public void checkCollision(int srccid,int dstcid) {
-		el.checkCollision(this,srccid,dstcid);
-	}
-
-	public int checkCollision(int cidmask, JGObject obj) {
-		return el.checkCollision(cidmask,obj);
-	}
-
-	public int checkBGCollision(JGRectangle r) {
-		return el.checkBGCollision(r);
-	}
-
-	public void checkBGCollision(int tilecid,int objcid) {
-		el.checkBGCollision(this,tilecid,objcid);
-	}
-
-	/* objects from engine */
-
-	public Vector getObjects(String prefix,int cidmask,boolean suspended_obj,
-	JGRectangle bbox) {
-		return el.getObjects(prefix,cidmask,suspended_obj,
-			bbox);
-	}
-
-	public void removeObject(JGObject obj) {
-		el.removeObject(obj);
-	}
-
-	public void removeObjects(String prefix,int cidmask) {
-		el.removeObjects(prefix,cidmask);
-	}
-
-	public void removeObjects(String prefix,int cidmask,boolean suspended_obj) {
-		el.removeObjects(prefix,cidmask,suspended_obj);
-	}
-	public int countObjects(String prefix,int cidmask) {
-		return el.countObjects(prefix,cidmask);
-	}
-
-	public int countObjects(String prefix,int cidmask,boolean suspended_obj) {
-		return el.countObjects(prefix,cidmask,suspended_obj);
-	}
-
-
-	void drawObject(Canvas g, JGObject o) {
-		if (!o.is_suspended) {
-			drawImage(g,(int)o.x,(int)o.y,o.getImageName(),true);
-			try {
-				o.paint();
-			} catch (JGameError ex) {
-				ex.printStackTrace();
-				exitEngine(dbgExceptionToString(ex));
-			} catch (Exception e) {
-				dbgShowException(o.getName(),e);
-			}
-		}
-		// debug functionality not implemented in midp
-	}
-
-
-
-	/*====== BG/tiles ======*/
-
-	public void setBGImage(String bgimg) {
-		el.setBGImage(bgimg,0,true,true);
-	}
-
-	public void setBGImage(int depth, String bgimg,boolean wrapx,boolean wrapy){
-		el.setBGImage(bgimg,depth,wrapx,wrapy);
-	}
-
-
-	public void setTileSettings(String out_of_bounds_tile,
-	int out_of_bounds_cid,int preserve_cids) {
-		el.setTileSettings(out_of_bounds_tile,out_of_bounds_cid,preserve_cids);
-	}
-
-	public void fillBG(String filltile) {
-		el.fillBG(filltile);
-	}
-
-	public void setTileCid(int x,int y,int and_mask,int or_mask) {
-		el.setTileCid(x,y,and_mask,or_mask);
-	}
-
-	public void setTile(int x,int y,String tilestr) {
-		el.setTile(x,y,tilestr);
-	}
-
-	void setColor(Paint p,JGColor col) {
-		p.setColor((col.alpha<<24) | (col.r<<16) | (col.g<<8)  | col.b);
-	}
-
-
-	/** xi,yi are tile indexes relative to the tileofs, that is, the top left
-	 * of the bg, + 1. They must be within both the tilemap and the view. */
-	public void drawTile(int xi,int yi,int tileid) {
-		if (background==null || bgg==null) return;
-		// determine position within bg
-		int x = el.moduloFloor(xi+1,el.viewnrtilesx+3) * el.scaledtilex;
-		int y = el.moduloFloor(yi+1,el.viewnrtilesy+3) * el.scaledtiley;
-		// draw
-		Integer tileid_obj = new Integer(tileid);
-		AndroidImage img = (AndroidImage)el.getTileImage(tileid_obj);
-		// define background behind tile in case the tile is null or
-		// transparent.
-		if (img==null||el.images_transp.containsKey(tileid_obj)) {
-			EngineLogic.BGImage bg_image = (EngineLogic.BGImage)
-				el.bg_images.elementAt(0);
-			if (bg_image==null) {
-				setColor(bgpainter,el.bg_color);
-				bgg.drawRect(new Rect(x,y,x+el.scaledtilex,y+el.scaledtiley),
-					bgpainter);
-			} else {
-				int xtile = el.moduloFloor(xi,bg_image.tiles.x);
-				int ytile = el.moduloFloor(yi,bg_image.tiles.y);
-				bgg.drawBitmap(
-					((AndroidImage)el.getImage(bg_image.imgname)).img,
-					new Rect(xtile*el.scaledtilex, ytile*el.scaledtiley, 
-						(xtile+1)*el.scaledtilex, (ytile+1)*el.scaledtiley),
-					new Rect(x,y, x+el.scaledtilex, y+el.scaledtiley),
-					bgpainter);
-			}
-		}
-		if (img!=null) {
-			bgg.drawBitmap(img.img,x,y,bgpainter);
-		}
-		//System.out.println("Drawn tile"+tileid);
-	}
-
-
-
-	public int countTiles(int tilecidmask) {
-		return el.countTiles(tilecidmask);
-	}
-
-	public int getTileCid(int xidx,int yidx) {
-		return el.getTileCid(xidx,yidx);
-	}
-
-	public String getTileStr(int xidx,int yidx) {
-		return el.getTileStr(xidx,yidx);
-	}
-
-	public int getTileCid(JGRectangle tiler) {
-		return el.getTileCid(tiler);
-	}
-
-	public JGRectangle getTiles(JGRectangle r) {
-		return el.getTiles(r);
-	}
-
-	public boolean getTiles(JGRectangle dest,JGRectangle r) {
-		return el.getTiles(dest,r);
-	}
-
-
-
-	public void setTileCid(int x,int y,int value) {
-		el.setTileCid(x,y,value);
-	}
-
-	public void orTileCid(int x,int y,int or_mask) {
-		el.orTileCid(x,y,or_mask);
-	}
-
-	public void andTileCid(int x,int y,int and_mask) {
-		el.andTileCid(x,y,and_mask);
-	}
-
-	public void setTile(JGPoint tileidx,String tilename) {
-		el.setTile(tileidx,tilename);
-	}
+    public int viewWidth() {
+        return el.viewnrtilesx * el.tilex;
+    }
 
-	public void setTiles(int xofs,int yofs,String [] tilemap) {
-		el.setTiles(xofs,yofs,tilemap);
-	}
+    public int viewHeight() {
+        return el.viewnrtilesy * el.tiley;
+    }
 
-	public void setTilesMulti(int xofs,int yofs,String [] tilemap) {
-		el.setTilesMulti(xofs,yofs,tilemap);
-	}
+    public int viewTilesX() {
+        return el.viewnrtilesx;
+    }
 
-	public int getTileCidAtCoord(double x,double y) {
-		return el.getTileCidAtCoord(x,y);
-	}
-	public int getTileCid(JGPoint center, int xofs, int yofs) {
-		return el.getTileCid(center, xofs, yofs);
-	}
+    public int viewTilesY() {
+        return el.viewnrtilesy;
+    }
 
-	public String getTileStrAtCoord(double x,double y) {
-		return el.getTileStrAtCoord(x,y);
-	}
+    public int viewXOfs() {
+        return el.pendingxofs;
+    }
 
-	public String getTileStr(JGPoint center, int xofs, int yofs) {
-		return el.getTileStr(center, xofs,yofs);
-	}
+    public int viewYOfs() {
+        return el.pendingyofs;
+    }
 
-	public int tileStrToID(String tilestr) {
-		return el.tileStrToID(tilestr);
-	}
+    //public int viewTileXOfs() { return canvas.tilexofs; }
+    //public int viewTileYOfs() { return canvas.tileyofs; }
 
-	public String tileIDToStr(int tileid) {
-		return el.tileIDToStr(tileid);
-	}
+    public int pfWidth() {
+        return el.nrtilesx * el.tilex;
+    }
 
+    public int pfHeight() {
+        return el.nrtilesy * el.tiley;
+    }
 
+    public int pfTilesX() {
+        return el.nrtilesx;
+    }
 
+    public int pfTilesY() {
+        return el.nrtilesy;
+    }
 
-	/** dx1 and dy1 are coordinates on canvas buffer, without canvas_ofs. */
-	void copyBGToBuf(Canvas bufg, int sx1,int sy1,int sx2,int sy2,
-	int dx1,int dy1) {
-		//dx1 += el.canvas_xofs;
-		//dy1 += el.canvas_yofs;
-		//System.out.println("("+sx1+","+sy1+")-("+sx2+","+sy2+")");
-		if (sx2<=sx1 || sy2<=sy1) return;
-		int barrelx = el.scaleXPos(el.moduloFloor(el.xofs,el.tilex),false);
-		int barrely = el.scaleYPos(el.moduloFloor(el.yofs,el.tiley),false);
-		int barreldx = (sx1==0) ? barrelx : 0;
-		int barreldy = (sy1==0) ? barrely : 0;
-		barrelx = (sx1==0) ? 0 : barrelx;
-		barrely = (sy1==0) ? 0 : barrely;
-		int dx2 = dx1 + sx2-sx1;
-		int dy2 = dy1 + sy2-sy1;
-		// ensure source coordinates are not out of the bounds of the source
-		// image
-		int sx1e = barrelx+sx1*el.scaledtilex;
-		int sy1e = barrely+sy1*el.scaledtiley;
-		int sx2e = barrelx+sx2*el.scaledtilex;
-		int sx2max = (el.viewnrtilesx+3)*el.scaledtilex;
-		if (sx2e > sx2max) sx2e = sx2max;
-		int sy2e = barrely+sy2*el.scaledtiley;
-		int sy2max = (el.viewnrtilesy+3)*el.scaledtiley;
-		if (sy2e > sy2max) sy2e = sy2max;
-		//void drawRegion(Image src, int x_src, int y_src, int width, int height, int transform, int x_dest, int y_dest, int anchor)
-		bufg.drawBitmap(background,
-			new Rect(sx1e,sy1e, sx2e, sy2e),
-			//barrelx+sx1*el.scaledtilex, barrely+sy1*el.scaledtiley,
-			//(sx2-sx1)*el.scaledtilex, (sy2-sy1)*el.scaledtiley,
-			new Rect(dx1*el.scaledtilex-barreldx + el.canvas_xofs,
-				dy1*el.scaledtiley-barreldy + el.canvas_yofs,
-				dx1*el.scaledtilex-barreldx + el.canvas_xofs + sx2e-sx1e,
-				dy1*el.scaledtiley-barreldy + el.canvas_yofs + sy2e-sy1e),
-			simpleimagepainter);
-		//bufg.drawImage(background,
-		//	dx1*el.scaledtilex-barreldx, dy1*el.scaledtiley-barreldy,
-		//	dx2*el.scaledtilex-barreldx, dy2*el.scaledtiley-barreldy,
-		//	barrelx+sx1*el.scaledtilex, barrely+sy1*el.scaledtiley,
-		//	barrelx+sx2*el.scaledtilex, barrely+sy2*el.scaledtiley,
-		//	this);
-	}
+    public boolean pfWrapX() {
+        return el.pf_wrapx;
+    }
 
+    public boolean pfWrapY() {
+        return el.pf_wrapy;
+    }
 
+    public int tileWidth() {
+        return el.tilex;
+    }
 
-	/*====== math ======*/
+    public int tileHeight() {
+        return el.tiley;
+    }
 
+    public int displayWidth() {
+        return el.winwidth;
+    }
 
-	public double moduloXPos(double x) {
-		return el.moduloXPos(x);
-	}
+    public int displayHeight() {
+        return el.winheight;
+    }
 
-	public double moduloYPos(double y) {
-		return el.moduloYPos(y);
-	}
+    public double getFrameRate() {
+        return el.fps;
+    }
 
+    public double getGameSpeed() {
+        return el.gamespeed;
+    }
+
+    public double getFrameSkip() {
+        return el.maxframeskip;
+    }
 
-	/*====== debug ======*/
-
-	public void dbgShowBoundingBox(boolean enabled) {}
-
-	public void dbgShowGameState(boolean enabled) {}
-
-	public void dbgShowFullStackTrace(boolean enabled) {}
-
-	public void dbgShowMessagesInPf(boolean enabled) {}
-
-	public void dbgSetMessageExpiry(int ticks) {}
-
-	public void dbgSetMessageFont(JGFont font) { }
-
-	public void dbgSetDebugColor1(JGColor col) { }
-
-	public void dbgSetDebugColor2(JGColor col) { }
-
-	public void dbgPrint(String msg) { dbgPrint("MAIN",msg); }
-
-	public void dbgPrint(String source,String msg) {
-		System.out.println(source+": "+msg);
-	}
-
-	public void dbgShowException(String source, Throwable e) {
-		e.printStackTrace();
-		//dbgPrint(source,st.toString());
-	}
-
-	public String dbgExceptionToString(Throwable e) {
-		return e.toString();
-	}
-
-
-	//public void setCanvasSettings(int nrtilesx,int nrtilesy,int tilex,int tiley,
-	//Color fgcolor, Color bgcolor, Font msgfont) {
-	//	el.setCanvasSettings(nrtilesx,nrtilesy,tilex,tiley,
-	//		fgcolor, bgcolor, msgfont);
-	//}
-
-	public void requestGameFocus() { }
-
-	// note: these get and set methods do not delegate calls
-
-	public boolean isApplet() { return false; }
-
-	public boolean isMidlet() { return false; }
-
-	public boolean isAndroid() { return true; }
-
-	public boolean isOpenGL() { return false; }
-
-	public int viewWidth() { return el.viewnrtilesx*el.tilex; }
-	public int viewHeight() { return el.viewnrtilesy*el.tiley; }
-
-	public int viewTilesX() { return el.viewnrtilesx; }
-	public int viewTilesY() { return el.viewnrtilesy; }
-
-	public int viewXOfs() { return el.pendingxofs; }
-	public int viewYOfs() { return el.pendingyofs; }
-
-	//public int viewTileXOfs() { return canvas.tilexofs; }
-	//public int viewTileYOfs() { return canvas.tileyofs; }
-
-	public int pfWidth() { return el.nrtilesx*el.tilex; }
-	public int pfHeight() { return el.nrtilesy*el.tiley; }
-
-	public int pfTilesX() { return el.nrtilesx; }
-	public int pfTilesY() { return el.nrtilesy; }
-
-	public boolean pfWrapX() { return el.pf_wrapx; }
-	public boolean pfWrapY() { return el.pf_wrapy; }
-
-	public int tileWidth()  { return el.tilex; }
-	public int tileHeight() { return el.tiley; }
-
-	public int displayWidth() { return el.winwidth; }
-	public int displayHeight() { return el.winheight; }
-
-	public double getFrameRate() { return el.fps; }
-
-	public double getGameSpeed() { return el.gamespeed; }
-
-	public double getFrameSkip() { return el.maxframeskip; }
-
-	public boolean getVideoSyncedUpdate() { return false; }
-
-	public int getOffscreenMarginX() { return el.offscreen_margin_x; }
-	public int getOffscreenMarginY() { return el.offscreen_margin_y; }
-
-	public double getXScaleFactor() { return el.x_scale_fac; }
-	public double getYScaleFactor() { return el.y_scale_fac; }
-	public double getMinScaleFactor() { return el.min_scale_fac; }
-
-
-
-	public void setViewOffset(int xofs,int yofs,boolean centered) {
-		el.setViewOffset(xofs,yofs,centered);
-	}
-
-	public void setBGImgOffset(int depth, double xofs, double yofs,
-	boolean centered) { }
-
-	public void setViewZoomRotate(double zoom, double rotate) { }
-
-	public void setPFSize(int nrtilesx,int nrtilesy) {
-		el.setPFSize(nrtilesx,nrtilesy);
-	}
-
-	public void setPFWrap(boolean wrapx,boolean wrapy,int shiftx,int shifty) {
-		el.setPFWrap(wrapx,wrapy,shiftx,shifty);
-	}
-
-
-	public void setFrameRate(double fps, double maxframeskip) {
-		el.setFrameRate(fps, maxframeskip);
-	}
-
-	public void setVideoSyncedUpdate(boolean value) {}
-
-	public void setGameSpeed(double gamespeed) {
-		el.setGameSpeed(gamespeed);
-	}
-
-	public void setRenderSettings(int alpha_thresh,JGColor render_bg_col) {
-		el.setRenderSettings(alpha_thresh,render_bg_col);
-	}
-
-	public void setOffscreenMargin(int xmargin,int ymargin) {
-		el.setOffscreenMargin(xmargin,ymargin);
-	}
-
-
-	/** Set global background colour, which is displayed in borders, and behind
-	* transparent tiles if no BGImage is defined. */
-	public void setBGColor(JGColor bgcolor) {
-		el.bg_color=bgcolor;
-	}
-
-	/** Set global foreground colour, used for printing text and status
-	 * messages.  It is also the default colour for painting */
-	public void setFGColor(JGColor fgcolor) { el.fg_color=fgcolor;  }
-
-	/** Set the (unscaled) message font, used for displaying status messages.
-	* It is also the default font for painting.  */
-	public void setMsgFont(JGFont msgfont) { el.msg_font = msgfont; }
-
-	/** Set foreground and background colour, and message font in one go;
-	* passing a null means ignore that argument. */
-	public void setColorsFont(JGColor fgcolor,JGColor bgcolor,JGFont msgfont) {
-		if (msgfont!=null) el.msg_font = msgfont;
-		if (fgcolor!=null) el.fg_color = fgcolor;
-		if (bgcolor!=null) setBGColor(bgcolor);
-	}
-
-	/** Set parameters of outline surrounding text (for example, used to
-	 *  increase contrast).
-	 * @param thickness 0 = turn off outline */
-	public void setTextOutline(int thickness,JGColor colour) {
-		// curiously, I've seen the init screen draw in-between these two
-		// statements.  Check of if that's what really happened
-		el.outline_colour=colour;
-		el.outline_thickness=thickness;
-	}
-
-	/** Unimplemented, does nothing. */
-	public void setMouseCursor(int cursor) {}
-
-	/** Unimplemented, does nothing. */
-	public void setMouseCursor(Object cursor) {}
-
-
-	/* timers */
-
-	public void removeAllTimers() {
-		el.removeAllTimers();
-	}
-
-	public void registerTimer(JGTimer timer) {
-		el.registerTimer(timer);
-	}
-
-	/* game state */
-
-	public void setGameState(String state) {
-		el.setGameState(state);
-	}
-
-	public void addGameState(String state) {
-		el.addGameState(state);
-	}
-
-	public void removeGameState(String state) {
-		el.removeGameState(state);
-	}
-
-	public void clearGameState() {
-		el.clearGameState();
-	}
-
-
-	public boolean inGameState(String state) {
-		return el.inGameState(state);
-	}
-
-	public boolean inGameStateNextFrame(String state) {
-		return el.inGameStateNextFrame(state);
-	}
-
-	/** Do some administration, call doFrame. */
-	private void doFrameAll() {
-		//audioNewFrame();
-		// the first flush is needed to remove any objects that were created
-		// in the main routine after the last moveObjects or checkCollision
-		el.flushRemoveList();
-		el.flushAddList();
-		// tick timers before doing state transitions, because timers may
-		// initiate new transitions.
-		el.tickTimers();
-		el.flushRemoveList();
-		el.flushAddList();
-		// the game state transition starts here
-		el.gamestate.removeAllElements();
-		int maxi = el.gamestate_nextframe.size();
-		for (int i=0; i<maxi; i++) {
-			el.gamestate.addElement(el.gamestate_nextframe.elementAt(i));
-		}
-		// we assume that state transitions will not initiate new state
-		// transitions!
-		invokeGameStateMethods("start",el.gamestate_new);
-		el.gamestate_new.removeAllElements();
-		el.flushRemoveList();
-		el.flushAddList();
-		try {
-			doFrame();
-		} catch (JGameError ex) {
-			ex.printStackTrace();
-			exitEngine(dbgExceptionToString(ex));
-		} catch (Exception ex) {
-			dbgShowException("MAIN",ex);
-		}
-		invokeGameStateMethods("doFrame",el.gamestate);
-		el.frameFinished();
-	}
-
-	private void invokeGameStateMethods(String prefix,Vector states) {
-		int maxi = states.size();
-		for (int i=0; i<maxi; i++) {
-			String state = (String) states.elementAt(i);
-			tryMethod(prefix,state);
-		}
-	}
-
-	Hashtable methodidx=null;
-
-	String [] stateprefixes = new String [] {
-		"start", "doFrame", "paintFrame"
-	};
-
-	String [] statesuffixes = new String [] {
-		"Loader",
-		"Title",
-		"SelectLevel",
-		"Highscores",
-		"InGame",
-		"StartLevel",
-		"StartGame",
-		"LevelDone",
-		"LifeLost",
-		"GameOver",
-		"EnterHighscore",
-		"Paused",
-	};
-
-
-	/** Try to invoke parameterless method in this object, used for game state
-	 * methods.  In MIDP, we don't have
-	 * reflection, so we only support a fixed number of methods.  Override
-	 * this to add new methods. */
-	public void tryMethod(String prefix,String suffix) {
-		int prefidx,sufidx;
-		for (prefidx=0; prefidx<stateprefixes.length; prefidx++) {
-			if (stateprefixes[prefidx].equals(prefix)) break;
-		}
-		for (sufidx=0; sufidx<statesuffixes.length; sufidx++) {
-			if (statesuffixes[sufidx].equals(suffix)) break;
-		}
-		if (sufidx>=statesuffixes.length)
-			exitEngine("Game state "+suffix+" not supported!");
-		int idx = statesuffixes.length*prefidx + sufidx;
-		//if (methodidx==null) {
-		//	methodidx = new Hashtable();
-		//	for (int i=0; i<statemethods.length; i++) {
-		//		methodidx.put(statemethods[i],new Integer(i));
-		//	}
-		//}
-		//Integer idx_int = (Integer)methodidx.get(name);
-		//if (idx_int==null)
-		//	exitEngine("Game state method "+name+" not supported!");
-		switch (idx) {
-		case 0: startLoader(); break;
-		case 1: startTitle(); break;
-		case 2: startSelectLevel(); break;
-		case 3: startHighscores(); break;
-		case 4: startInGame(); break;
-		case 5: startStartLevel(); break;
-		case 6: startStartGame(); break;
-		case 7: startLevelDone(); break;
-		case 8: startLifeLost(); break;
-		case 9: startGameOver(); break;
-		case 10: startEnterHighscore(); break;
-		case 11: startEnterHighscore(); break;
-		case 12: doFrameLoader(); break;
-		case 13: doFrameTitle(); break;
-		case 14: doFrameSelectLevel(); break;
-		case 15: doFrameHighscores(); break;
-		case 16: doFrameInGame(); break;
-		case 17: doFrameStartLevel(); break;
-		case 18: doFrameStartGame(); break;
-		case 19: doFrameLevelDone(); break;
-		case 20: doFrameLifeLost(); break;
-		case 21: doFrameGameOver(); break;
-		case 22: doFrameEnterHighscore(); break;
-		case 23: doFramePaused(); break;
-		case 24: paintFrameLoader(); break;
-		case 25: paintFrameTitle(); break;
-		case 26: paintFrameSelectLevel(); break;
-		case 27: paintFrameHighscores(); break;
-		case 28: paintFrameInGame(); break;
-		case 29: paintFrameStartLevel(); break;
-		case 30: paintFrameStartGame(); break;
-		case 31: paintFrameLevelDone(); break;
-		case 32: paintFrameLifeLost(); break;
-		case 33: paintFrameGameOver(); break;
-		case 34: paintFrameEnterHighscore(); break;
-		case 35: paintFramePaused(); break;
-		default:exitEngine("Game state method "+prefix+suffix+" not supported");
-		}
-	}
-
-	/** Predefined game state method, implementation is empty. */
-	public void startLoader() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startTitle() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startSelectLevel() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startHighscores() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startInGame() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startStartLevel() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startStartGame() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startLevelDone() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startLifeLost() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startGameOver() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startEnterHighscore() {}
-	/** Predefined game state method, implementation is empty. */
-	public void startPaused() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameLoader() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameTitle() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameSelectLevel() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameHighscores() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameInGame() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameStartLevel() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameStartGame() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameLevelDone() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameLifeLost() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameGameOver() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFrameEnterHighscore() {}
-	/** Predefined game state method, implementation is empty. */
-	public void doFramePaused() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameLoader() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameTitle() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameSelectLevel() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameHighscores() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameInGame() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameStartLevel() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameStartGame() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameLevelDone() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameLifeLost() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameGameOver() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFrameEnterHighscore() {}
-	/** Predefined game state method, implementation is empty. */
-	public void paintFramePaused() {}
-	
-
-
-	public void doFrame() {}
-
-	void paintFrame(Canvas g) {
-		buf_gfx=g;
-		setColor(bufpainter,el.fg_color);
-		setFont(el.msg_font);
-		try {
-			paintFrame();
-		} catch (JGameError ex) {
-			ex.printStackTrace();
-			exitEngine(dbgExceptionToString(ex));
-		} catch (Exception ex) {
-			dbgShowException("MAIN",ex);
-		}
-		invokeGameStateMethods("paintFrame",el.gamestate);
-		//if ((debugflags&GAMESTATE_DEBUG)!=0) {
-		//	String state="{";
-		//	for (Enumeration e=el.gamestate.elements(); e.hasMoreElements(); ) {
-		//		state += (String)e.nextElement();
-		//		if (e.hasMoreElements()) state +=",";
-		//	}
-		//	state += "}";
-		//	setFont(el.msg_font);
-		//	setColor(g,el.fg_color);
-		//	drawString(state,el.viewWidth(),
-		//			el.viewHeight()-(int)getFontHeight(g,el.msg_font), 1);
-		//}
-		//if ((debugflags&MSGSINPF_DEBUG)!=0) paintDbgFrameLogs(buf_gfx);
-		buf_gfx=null;
-	}
-
-	public void paintFrame() {}
-
-	public Canvas getBufferGraphics() { return buf_gfx; }
-
-	/* some convenience functions for drawing during repaint and paintFrame()*/
-
-	public void setColor(JGColor col) {
-		// XXX setColor cannot check if graphics is available
-		//if (buf_gfx!=null) 
-		setColor(bufpainter,col);
-	}
-
-	public void setFont(JGFont font) { setFont(bufpainter,font); }
-
-	public void setFont(Paint p,JGFont jgfont) {
-		double fontsize = jgfont.size*el.min_scale_fac;
-		p.setTextSize((int)fontsize);
-		//Font font = new Font(jgfont.name,jgfont.style,(int)jgfont.size);
-		//if (g!=null) {
-		//	double origsize = font.getSize2D();
-		//	font=font.deriveFont((float)(origsize*el.min_scale_fac));
-		//	g.setFont(font);
-		//}
-	}
-
-	public void setStroke(double thickness) {
-		bufpainter.setStrokeWidth((float)(thickness*el.min_scale_fac));
-	}
-
-	public void setBlendMode(int src_func, int dst_func) { }
-
-	public double getFontHeight(JGFont jgfont) {
-		// TODO get actual size?
-		return jgfont.size*el.min_scale_fac;
-	}
-
-	void drawImage(Canvas g,double x,double y,String imgname,
-	boolean pf_relative) {
-		//drawImage(x,y,imgname,null,1.0,0.0,1.0,pf_relative);
-		if (g==null) return;
-		if (imgname==null) return;
-		x = el.scaleXPos(x,pf_relative) + el.canvas_xofs;
-		y = el.scaleYPos(y,pf_relative) + el.canvas_yofs;
-		AndroidImage img = (AndroidImage)el.getImage(imgname);
-		if (img!=null)
-			g.drawBitmap(img.img,(int)x,(int)y,simpleimagepainter);
-	}
-
-
-	public void drawLine(double x1,double y1,double x2,double y2,
-	double thickness, JGColor color) {
-		if (color!=null) setColor(color);
-		setStroke(thickness);
-		drawLine(x1,y1,x2,y2,true);
-	}
-	public void drawLine(double x1,double y1,double x2,double y2) {
-		drawLine(x1,y1,x2,y2,true);
-	}
-
-	public void drawLine(double x1,double y1,double x2,double y2,
-	boolean pf_relative) {
-		if (buf_gfx==null) return;
-		buf_gfx.drawLine(
-			el.scaleXPos(x1,pf_relative) + el.canvas_xofs,
-			el.scaleYPos(y1,pf_relative) + el.canvas_yofs,
-			el.scaleXPos(x2,pf_relative) + el.canvas_xofs,
-			el.scaleYPos(y2,pf_relative) + el.canvas_yofs, bufpainter );
-	}
-
-	private int [] xpos = new int[3];
-	private int [] ypos = new int[3];
-	public void drawPolygon(double [] x,double [] y, JGColor [] col,int len,
-	boolean filled, boolean pf_relative) {
-		if (buf_gfx==null) return;
-		xpos[0] = el.scaleXPos(x[0],pf_relative) + el.canvas_xofs;
-		ypos[0] = el.scaleYPos(y[0],pf_relative) + el.canvas_yofs;
-		xpos[1] = el.scaleXPos(x[1],pf_relative) + el.canvas_xofs;
-		ypos[1] = el.scaleYPos(y[1],pf_relative) + el.canvas_yofs;
-		if (!filled) {
-			// draw first and last line segment
-			xpos[2] = el.scaleXPos(x[len-1],pf_relative) + el.canvas_xofs;
-			ypos[2] = el.scaleYPos(y[len-1],pf_relative) + el.canvas_yofs;
-			if (col!=null) setColor(bufpainter,col[1]);
-			buf_gfx.drawLine(xpos[0],ypos[0],xpos[1],ypos[1], bufpainter);
-			if (col!=null) setColor(bufpainter,col[0]);
-			buf_gfx.drawLine(xpos[2],ypos[2],xpos[0],ypos[0], bufpainter);
-		}
-		if (filled) {
-			bufpainter.setStyle(Paint.Style.FILL);
-		} else {
-			bufpainter.setStyle(Paint.Style.STROKE);
-		}
-		for (int i=2; i<len; i++) {
-			xpos[2] = el.scaleXPos(x[i],pf_relative) + el.canvas_xofs;
-			ypos[2] = el.scaleYPos(y[i],pf_relative) + el.canvas_yofs;
-			if (col!=null) setColor(bufpainter,col[i]);
-			if (filled) {
-				bufpainter.setStyle(Paint.Style.FILL);
-				fillTriangle(buf_gfx,xpos[0],ypos[0],xpos[1],ypos[1],xpos[2],ypos[2]);
-			} else {
-				buf_gfx.drawLine(xpos[1],ypos[1],xpos[2],ypos[2], bufpainter);
-			}
-			xpos[1] = xpos[2];
-			ypos[1] = ypos[2];
-		}
-		bufpainter.setStyle(Paint.Style.STROKE);
-	}
-
-	private void fillTriangle(Canvas g,int x1,int y1,int x2,int y2,
-	int x3,int y3) {
-		Path p = new Path();
-		p.moveTo(x1,y1);
-		p.lineTo(x2,y2);
-		p.lineTo(x3,y3);
-		g.drawPath(p,bufpainter);
-	}
-
-	public void drawRect(double x,double y,double width,double height, boolean filled,
-	boolean centered, double thickness, JGColor color) {
-		if (color!=null) setColor(color);
-		setStroke(thickness);
-		drawRect(buf_gfx,x,y,width,height,filled,centered,true,null,null);
-	}
-
-	public void drawRect(double x,double y,double width,double height, boolean filled,
-	boolean centered) {
-		drawRect(buf_gfx,x,y,width,height,filled,centered,true,null,null);
-	}
-
-	public void drawRect(double x,double y,double width,double height, boolean filled,
-	boolean centered, boolean pf_relative) {
-		drawRect(buf_gfx,x,y,width,height,filled,centered,pf_relative,null,null);
-	}
-
-	public void drawRect(double x,double y,double width,double height,
-	boolean filled, boolean centered,boolean pf_relative,
-	JGColor [] shadecol) {
-		drawRect(buf_gfx,x,y,width,height,filled,centered,pf_relative,shadecol,null);
-	}
-
-	public void drawRect(double x,double y,double width,double height,
-	boolean filled, boolean centered,boolean pf_relative,
-	JGColor [] shadecol,String tileimage) {
-		drawRect(buf_gfx,x,y,width,height,filled,centered,pf_relative,shadecol,tileimage);
-	}
-
-	void drawRect(Canvas g,double x,double y,double width,double height,
-	boolean filled, boolean centered,boolean pf_relative,
-	JGColor [] shadecol,String tileimage) {
-		if (centered) {
-			x -= (width/2);
-			y -= (height/2);
-		}
-		JGRectangle r = el.scalePos(x, y, width, height, pf_relative);
-		r.x += el.canvas_xofs;
-		r.y += el.canvas_yofs;
-		if (tileimage!=null) {
-			Bitmap b = ((AndroidImage)el.getImage(tileimage)).img;
-			Matrix m = new Matrix();
-			m.setTranslate(r.x,r.y);
-			Shader sh=new BitmapShader(b,Shader.TileMode.REPEAT,Shader.TileMode.REPEAT);
-			sh.setLocalMatrix(m);
-			bufpainter.setShader(sh);
-		}
-		if (filled || tileimage!=null) {
-			bufpainter.setStyle(Paint.Style.FILL);
-		} else {
-			bufpainter.setStyle(Paint.Style.STROKE);
-		}
-		g.drawRect(new Rect(r.x,r.y,r.x+r.width,r.y+r.height),bufpainter);
-		// reset state
-		bufpainter.setShader(null);
-		bufpainter.setStyle(Paint.Style.STROKE);
-	}
-
-	public void drawOval(double x,double y,double width,double height, boolean filled,
-	boolean centered, double thickness, JGColor color) {
-		if (color!=null) setColor(color);
-		setStroke(thickness);
-		drawOval(x,y,width,height,filled,centered,true);
-	}
-
-	public void drawOval(double x,double y, double width,double height,boolean filled,
-	boolean centered) {
-		drawOval(x,y,width,height,filled,centered,true);
-	}
-
-	public void drawOval(double x,double y, double width,double height,boolean filled,
-	boolean centered, boolean pf_relative) {
-		if (buf_gfx==null) return;
-		x = el.scaleXPos(x,pf_relative) + el.canvas_xofs + 0.5;
-		y = el.scaleYPos(y,pf_relative) + el.canvas_yofs + 0.5;
-		width  = el.scaleXPos(width,false);
-		height = el.scaleYPos(height,false);
-		if (centered) {
-			x -= (width/2.0);
-			y -= (height/2.0);
-		}
-		if (filled) {
-			bufpainter.setStyle(Paint.Style.FILL);
-		} else {
-			bufpainter.setStyle(Paint.Style.STROKE);
-		}
-		buf_gfx.drawOval(new RectF(
-			(int)x,(int)y, (int)x+(int)width, (int)y+(int)height),
-			bufpainter);
-		// reset state
-		bufpainter.setStyle(Paint.Style.STROKE);
-	}
-
-	/* new versions of drawImage */
-
-	public void drawImage(String imgname,double x,double y) {
-		drawImage(x,y,imgname);
-	}
-
-	public void drawImage(String imgname,double x,double y,boolean pf_relative){
-		drawImage(x,y,imgname,pf_relative);
-	}
-
-	public void drawImage(String imgname, double x,double y,
-	boolean pf_relative,JGColor blend_col,
-	double alpha, double rot, double scale) {
-		drawImage(x,y,imgname,blend_col,alpha,rot,scale,pf_relative);
-	}
-
-
-
-	public void drawImage(double x,double y,String imgname) {
-		if (buf_gfx==null) return;
-		drawImage(buf_gfx,x,y,imgname,true);
-	}
-
-	public void drawImage(double x,double y,String imgname,boolean pf_relative) {
-		if (buf_gfx==null) return;
-		drawImage(buf_gfx,x,y,imgname,pf_relative);
-	}
-
-	// static variables to avoid object creations
-	JGPoint drawImage_size=new JGPoint(0,0);
-	Matrix drawImage_m=new Matrix();
-	public void drawImage(double x,double y,String imgname, JGColor blend_col,
-	double alpha, double rot, double scale, boolean pf_relative) {
-		if (buf_gfx==null) return;
-		if (blend_col==null && alpha==1.0 && rot==0.0 && scale==1.0) {
-			drawImage(buf_gfx,x,y,imgname,pf_relative);
-			return;
-		}
-		if (imgname==null) return;
-		int alpha_int = (int)Math.floor(255.95*alpha);
-		imagepainter.setColor((alpha_int<<24) | 0xffffff);
-		if (blend_col!=null) {
-			imagepainter.setColorFilter(
-				new LightingColorFilter(
-					(blend_col.r<<16) | (blend_col.g<<8)  | blend_col.b, 0) );
-			//imagepainter.setColor( (alpha_int<<24)
-			//	| (blend_col.r<<16) | (blend_col.g<<8)  | blend_col.b);
-		} else {
-			imagepainter.setColorFilter(null);
-		}
-		x = el.scaleXPos(x,pf_relative) + el.canvas_xofs;
-		y = el.scaleYPos(y,pf_relative) + el.canvas_yofs;
-		AndroidImage img = (AndroidImage)el.getImageOrig(imgname);
-		JGPoint origsize = img.getSize();
-		//System.err.println(" "+origsize.x+" "+origsize.y);
-		drawImage_size.x = el.scaleXPos(origsize.x,false);
-		drawImage_size.y = el.scaleYPos(origsize.y,false);
-		// size of scaled image
-		double txsize_s = drawImage_size.x*scale;
-		double tysize_s = drawImage_size.y*scale;
-		// determine topleft of scaled image
-		//System.err.println(""+drawImage_size.x+" "+drawImage_size.y+" "+txsize_s+" "+tysize_s);
-		//x -= (txsize_s - drawImage_size.x)/2;
-		//y -= (tysize_s - drawImage_size.y)/2;
-		float pivotx = (float)(origsize.x/2.0);
-		float pivoty = (float)(origsize.y/2.0);
-		drawImage_m.reset();
-		drawImage_m.setRotate((float)((-rot*180)/Math.PI),pivotx,pivoty);
-		drawImage_m.postScale((float)scale,(float)scale, pivotx,pivoty);
-		drawImage_m.postScale((float)el.x_scale_fac,(float)el.y_scale_fac, 0,0);
-		drawImage_m.postTranslate((float)x,
-			(float)y);
-		if (img!=null)
-			buf_gfx.drawBitmap(img.img,drawImage_m,imagepainter);
-	}
-
-	public void drawString(String str, double x, double y, int align,
-	JGFont font, JGColor color) {
-		if (font!=null) setFont(font);
-		if (color!=null) setColor(color);
-		drawString(buf_gfx, str, x,y, align, false);
-	}
-
-	public void drawString(String str, double x, double y, int align) {
-		drawString(buf_gfx, str, x,y, align, false);
-	}
-
-	public void drawString(String str, double x, double y, int align,
-	boolean pf_relative) {
-		drawString(buf_gfx, str, x,y, align, pf_relative);
-	}
-
-	/** Internal function for writing on both buffer and screen.  Coordinates
-	 * are always relative to view. */
-	void drawString(Canvas g, String str, double x, double y, int align,
-	boolean pf_relative) {
-		if (g==null) return;
-		if (str.equals("")) return;
-		x = el.scaleXPos(x,pf_relative) + el.canvas_xofs;
-		y = el.scaleYPos(y,pf_relative) + el.canvas_yofs;
-		y -= bufpainter.ascent();
-		Paint.Align palign = Paint.Align.CENTER;
-		if (align==-1) palign = Paint.Align.LEFT;
-		if (align== 1) palign = Paint.Align.RIGHT;
-		bufpainter.setTextAlign(palign);
-		if (el.outline_thickness>0) {
-			int origcol = bufpainter.getColor();
-			setColor(el.outline_colour);
-			int real_thickness=Math.max(
-				el.scaleXPos(el.outline_thickness,false),1 );
-			for (int i=-real_thickness; i<=real_thickness; i++) {
-				if (i==0) continue;
-				g.drawText(str,0,str.length(),(int)x+i,(int)y,bufpainter);
-			}
-			for (int i=-real_thickness; i<=real_thickness; i++) {
-				if (i==0) continue;
-				g.drawText(str,0,str.length(),(int)x,(int)y+i,bufpainter);
-			}
-			bufpainter.setColor(origcol);
-		}
-		// stroke width make text bolder so we set it to 0
-		float origwidth = bufpainter.getStrokeWidth();
-		bufpainter.setStrokeWidth(0);
-		g.drawText(str,0,str.length(),(int)x,(int)y,bufpainter);
-		bufpainter.setStrokeWidth(origwidth);
-	}
-
-	public void drawImageString(String string, double x, double y, int align,
-	String imgmap, int char_offset, int spacing) {
-		el.drawImageString(this,string,x,y,align,imgmap,char_offset,spacing,
-			false);
-	}
-
-	public void drawImageString(String string, double x, double y, int align,
-	String imgmap, int char_offset, int spacing,boolean pf_relative) {
-		el.drawImageString(this,string,x,y,align,imgmap,char_offset,spacing,
-		pf_relative);
-	}
-
-	/* input */
-
-	/** Android has mouse semantics based on touch screen. They are the same
-	 * as MIDP. Touch screens have only press, drag, and release (no mouse
-	 * move without button press).  There is only one "button", button 1.
-	 * Mouseinside is set to false when finger/stylus is not on the touch
-	 * screen.
-	 */
-
-	JGPoint mousepos = new JGPoint(0,0);
-	double mouseposd_x=0,mouseposd_y=0;
-	boolean [] mousebutton = new boolean[] {false,false,false,false};
-	boolean mouseinside=false;
-
-	double [] accelvec = new double [] {0,0,1};
-
-	/** XXX: does not produce a clone of mousepos, for efficiency reasons! */
-	public JGPoint getMousePos() { return mousepos; }
-	public int getMouseX() { return mousepos.x; }
-	public int getMouseY() { return mousepos.y; }
-	// XXX android only as yet
-	public double getMouseXD() { return mouseposd_x; }
-	public double getMouseYD() { return mouseposd_y; }
-
-	public boolean getMouseButton(int nr) { return mousebutton[nr]; }
-	public void clearMouseButton(int nr) { mousebutton[nr]=false; }
-	public void setMouseButton(int nr) { mousebutton[nr]=true; }
-	public boolean getMouseInside() { return mouseinside; }
-
-	public boolean getKey(int key) { return keymap[key]; }
-	public void clearKey(int key) { keymap[key]=false; }
-	public void setKey(int key) { keymap[key]=true; }
-
-	public int getLastKey() { return lastkey; }
-	public char getLastKeyChar() { return lastkeychar; }
-	public void clearLastKey() {
-		lastkey=0;
-		lastkeychar=0;
-	}
-
-	/* maybe move the translations? Should they be system dependent? */
-
-	/** Get a printable string describing the key. Non-static version for the
-	 * sake of the interface. */
-	public String getKeyDesc(int key) { return getKeyDescStatic(key); }
-	/** Get a printable string describing the key. */
-	public static String getKeyDescStatic(int key) {
-		if (key==32) return "#";
-		if (key==0) return "(none)";
-		if (key==KeyEnter) return "*";
-		if (key==KeyStar) return "*";
-		if (key==' ') return "#";
-		if (key==KeyPound) return "#";
-		//if (key==KeyEsc) return "escape";
-		if (key==KeyUp) return "cursor up";
-		if (key==KeyDown) return "cursor down";
-		if (key==KeyLeft) return "cursor left";
-		if (key==KeyRight) return "cursor right";
-		if (key==KeyShift) return "fire";
-		//if (key==KeyAlt) return "alt";
-		//if (key==KeyCtrl) return "control";
-		//if (key==KeyMouse1) return "left mouse button";
-		//if (key==KeyMouse2) return "middle mouse button";
-		//if (key==KeyMouse3) return "right mouse button";
-		//if (key==27) return "escape";
-		if (key >= 33 && key <= 95)
-			return new String(new char[] {(char)key});
-		return "keycode "+key;
-	}
-
-	/** Obtain key code from printable string describing the key, the inverse
-	 * of getKeyDesc. The string is trimmed and lowercased. Non-static version
-	 * for the sake of the interface. */
-	public int getKeyCode(String keydesc) { return getKeyCodeStatic(keydesc); }
-	/** Obtain key code from printable string describing the key, the inverse
-	 * of getKeyDesc. The string is trimmed and lowercased. */
-	public static int getKeyCodeStatic(String keydesc) {
-		// tab, enter, backspace, insert, delete, home, end, pageup, pagedown
-		// escape
-		keydesc = keydesc.toLowerCase().trim();
-		//if (keydesc.equals("space")) {
-		//	return 32;
-		//} else if (keydesc.equals("escape")) {
-		//	return KeyEsc;
-		//} else 
-		if (keydesc.equals("(none)")) {
-			return 0;
-		//} else if (keydesc.equals("enter")) {
-		//	return KeyEnter;
-		} else if (keydesc.equals("cursor up")) {
-			return KeyUp;
-		} else if (keydesc.equals("cursor down")) {
-			return KeyDown;
-		} else if (keydesc.equals("cursor left")) {
-			return KeyLeft;
-		} else if (keydesc.equals("cursor right")) {
-			return KeyRight;
-		//} else if (keydesc.equals("shift")) {
-		//	return KeyShift;
-		} else if (keydesc.equals("fire")) {
-			return KeyFire;
-		} else if (keydesc.equals("star")) {
-			return '*';
-		} else if (keydesc.equals("pound")) {
-			return '#';
-		//} else if (keydesc.equals("alt")) {
-		//	return KeyAlt;
-		//} else if (keydesc.equals("control")) {
-		//	return KeyCtrl;
-		//} else if (keydesc.equals("left mouse button")) {
-		//	return KeyMouse1;
-		//} else if (keydesc.equals("middle mouse button")) {
-		//	return KeyMouse2;
-		//} else if (keydesc.equals("right mouse button")) {
-		//	return KeyMouse3;
-		} else if (keydesc.startsWith("keycode")) {
-			return Integer.parseInt(keydesc.substring(7));
-		} else if (keydesc.length() == 1) {
-			return keydesc.charAt(0);
-		}
-		return 0;
-	}
-
-	public boolean hasAccelerometer() { return true; }
-
-	public double getAccelX() {
-		return accelvec[0];
-	}
-	public double getAccelY() {
-		return accelvec[1];
-	}
-	public double getAccelZ() {
-		return accelvec[2];
-	}
-
-	public double [] getAccelVec() {
-		return new double[] { accelvec[0],accelvec[1],accelvec[2] };
-	}
-
-
-	/*====== animation ======*/
-
-	public void defineAnimation (String id,
-	String [] frames, double speed) {
-		el.defineAnimation(id,frames,speed);
-	}
-
-	public void defineAnimation (String id,
-	String [] frames, double speed, boolean pingpong) {
-		el.defineAnimation(id,frames, speed, pingpong);
-	}
-
-	public Animation getAnimation(String id) {
-		return el.getAnimation(id);
-	}
-
-	public String getConfigPath(String filename) {
-		return null;
-		// not implemented yet.  midp should use the special configuration
-		// features for this.
-	}
-
-	public int invokeUrl(String url,String target) {
-		// XXX application state is reset
-		canvas.post(currentact.new UrlInvoker(url));
-		return -1;
-	}
+    public boolean getVideoSyncedUpdate() {
+        return false;
+    }
+
+    public int getOffscreenMarginX() {
+        return el.offscreen_margin_x;
+    }
+
+    public int getOffscreenMarginY() {
+        return el.offscreen_margin_y;
+    }
+
+    public double getXScaleFactor() {
+        return el.x_scale_fac;
+    }
+
+    public double getYScaleFactor() {
+        return el.y_scale_fac;
+    }
+
+    public double getMinScaleFactor() {
+        return el.min_scale_fac;
+    }
+
+
+    public void setViewOffset(int xofs, int yofs, boolean centered) {
+        el.setViewOffset(xofs, yofs, centered);
+    }
+
+    public void setBGImgOffset(int depth, double xofs, double yofs,
+                               boolean centered) {
+    }
+
+    public void setViewZoomRotate(double zoom, double rotate) {
+    }
+
+    public void setPFSize(int nrtilesx, int nrtilesy) {
+        el.setPFSize(nrtilesx, nrtilesy);
+    }
+
+    public void setPFWrap(boolean wrapx, boolean wrapy, int shiftx, int shifty) {
+        el.setPFWrap(wrapx, wrapy, shiftx, shifty);
+    }
+
+
+    public void setFrameRate(double fps, double maxframeskip) {
+        el.setFrameRate(fps, maxframeskip);
+    }
+
+    public void setVideoSyncedUpdate(boolean value) {
+    }
+
+    public void setGameSpeed(double gamespeed) {
+        el.setGameSpeed(gamespeed);
+    }
+
+    public void setRenderSettings(int alpha_thresh, JGColor render_bg_col) {
+        el.setRenderSettings(alpha_thresh, render_bg_col);
+    }
+
+    public void setOffscreenMargin(int xmargin, int ymargin) {
+        el.setOffscreenMargin(xmargin, ymargin);
+    }
+
+
+    /**
+     * Set global background colour, which is displayed in borders, and behind
+     * transparent tiles if no BGImage is defined.
+     */
+    public void setBGColor(JGColor bgcolor) {
+        el.bg_color = bgcolor;
+    }
+
+    /**
+     * Set global foreground colour, used for printing text and status
+     * messages.  It is also the default colour for painting
+     */
+    public void setFGColor(JGColor fgcolor) {
+        el.fg_color = fgcolor;
+    }
+
+    /**
+     * Set the (unscaled) message font, used for displaying status messages.
+     * It is also the default font for painting.
+     */
+    public void setMsgFont(JGFont msgfont) {
+        el.msg_font = msgfont;
+    }
+
+    /**
+     * Set foreground and background colour, and message font in one go;
+     * passing a null means ignore that argument.
+     */
+    public void setColorsFont(JGColor fgcolor, JGColor bgcolor, JGFont msgfont) {
+        if (msgfont != null) el.msg_font = msgfont;
+        if (fgcolor != null) el.fg_color = fgcolor;
+        if (bgcolor != null) setBGColor(bgcolor);
+    }
+
+    /**
+     * Set parameters of outline surrounding text (for example, used to
+     * increase contrast).
+     *
+     * @param thickness 0 = turn off outline
+     */
+    public void setTextOutline(int thickness, JGColor colour) {
+        // curiously, I've seen the init screen draw in-between these two
+        // statements.  Check of if that's what really happened
+        el.outline_colour = colour;
+        el.outline_thickness = thickness;
+    }
+
+    /**
+     * Unimplemented, does nothing.
+     */
+    public void setMouseCursor(int cursor) {
+    }
+
+    /**
+     * Unimplemented, does nothing.
+     */
+    public void setMouseCursor(Object cursor) {
+    }
+
+
+    /* timers */
+
+    public void removeAllTimers() {
+        el.removeAllTimers();
+    }
+
+    public void registerTimer(JGTimer timer) {
+        el.registerTimer(timer);
+    }
+
+    /* game state */
+
+    public void setGameState(String state) {
+        el.setGameState(state);
+    }
+
+    public void addGameState(String state) {
+        el.addGameState(state);
+    }
+
+    public void removeGameState(String state) {
+        el.removeGameState(state);
+    }
+
+    public void clearGameState() {
+        el.clearGameState();
+    }
+
+
+    public boolean inGameState(String state) {
+        return el.inGameState(state);
+    }
+
+    public boolean inGameStateNextFrame(String state) {
+        return el.inGameStateNextFrame(state);
+    }
+
+    /**
+     * Do some administration, call doFrame.
+     */
+    private void doFrameAll() {
+        //audioNewFrame();
+        // the first flush is needed to remove any objects that were created
+        // in the main routine after the last moveObjects or checkCollision
+        el.flushRemoveList();
+        el.flushAddList();
+        // tick timers before doing state transitions, because timers may
+        // initiate new transitions.
+        el.tickTimers();
+        el.flushRemoveList();
+        el.flushAddList();
+        // the game state transition starts here
+        el.gamestate.removeAllElements();
+        int maxi = el.gamestate_nextframe.size();
+        for (int i = 0; i < maxi; i++) {
+            el.gamestate.addElement(el.gamestate_nextframe.elementAt(i));
+        }
+        // we assume that state transitions will not initiate new state
+        // transitions!
+        invokeGameStateMethods("start", el.gamestate_new);
+        el.gamestate_new.removeAllElements();
+        el.flushRemoveList();
+        el.flushAddList();
+        try {
+            doFrame();
+        } catch (JGameError ex) {
+            ex.printStackTrace();
+            exitEngine(dbgExceptionToString(ex));
+        } catch (Exception ex) {
+            dbgShowException("MAIN", ex);
+        }
+        invokeGameStateMethods("doFrame", el.gamestate);
+        el.frameFinished();
+    }
+
+    private void invokeGameStateMethods(String prefix, Vector states) {
+        int maxi = states.size();
+        for (int i = 0; i < maxi; i++) {
+            String state = (String) states.elementAt(i);
+            tryMethod(prefix, state);
+        }
+    }
+
+    Hashtable methodidx = null;
+
+    String[] stateprefixes = new String[]{
+            "start", "doFrame", "paintFrame"
+    };
+
+    String[] statesuffixes = new String[]{
+            "Loader",
+            "Title",
+            "SelectLevel",
+            "Highscores",
+            "InGame",
+            "StartLevel",
+            "StartGame",
+            "LevelDone",
+            "LifeLost",
+            "GameOver",
+            "EnterHighscore",
+            "Paused",
+    };
+
+
+    /**
+     * Try to invoke parameterless method in this object, used for game state
+     * methods.  In MIDP, we don't have
+     * reflection, so we only support a fixed number of methods.  Override
+     * this to add new methods.
+     */
+    public void tryMethod(String prefix, String suffix) {
+        int prefidx, sufidx;
+        for (prefidx = 0; prefidx < stateprefixes.length; prefidx++) {
+            if (stateprefixes[prefidx].equals(prefix)) break;
+        }
+        for (sufidx = 0; sufidx < statesuffixes.length; sufidx++) {
+            if (statesuffixes[sufidx].equals(suffix)) break;
+        }
+        if (sufidx >= statesuffixes.length)
+            exitEngine("Game state " + suffix + " not supported!");
+        int idx = statesuffixes.length * prefidx + sufidx;
+        //if (methodidx==null) {
+        //	methodidx = new Hashtable();
+        //	for (int i=0; i<statemethods.length; i++) {
+        //		methodidx.put(statemethods[i],new Integer(i));
+        //	}
+        //}
+        //Integer idx_int = (Integer)methodidx.get(name);
+        //if (idx_int==null)
+        //	exitEngine("Game state method "+name+" not supported!");
+        switch (idx) {
+            case 0:
+                startLoader();
+                break;
+            case 1:
+                startTitle();
+                break;
+            case 2:
+                startSelectLevel();
+                break;
+            case 3:
+                startHighscores();
+                break;
+            case 4:
+                startInGame();
+                break;
+            case 5:
+                startStartLevel();
+                break;
+            case 6:
+                startStartGame();
+                break;
+            case 7:
+                startLevelDone();
+                break;
+            case 8:
+                startLifeLost();
+                break;
+            case 9:
+                startGameOver();
+                break;
+            case 10:
+                startEnterHighscore();
+                break;
+            case 11:
+                startEnterHighscore();
+                break;
+            case 12:
+                doFrameLoader();
+                break;
+            case 13:
+                doFrameTitle();
+                break;
+            case 14:
+                doFrameSelectLevel();
+                break;
+            case 15:
+                doFrameHighscores();
+                break;
+            case 16:
+                doFrameInGame();
+                break;
+            case 17:
+                doFrameStartLevel();
+                break;
+            case 18:
+                doFrameStartGame();
+                break;
+            case 19:
+                doFrameLevelDone();
+                break;
+            case 20:
+                doFrameLifeLost();
+                break;
+            case 21:
+                doFrameGameOver();
+                break;
+            case 22:
+                doFrameEnterHighscore();
+                break;
+            case 23:
+                doFramePaused();
+                break;
+            case 24:
+                paintFrameLoader();
+                break;
+            case 25:
+                paintFrameTitle();
+                break;
+            case 26:
+                paintFrameSelectLevel();
+                break;
+            case 27:
+                paintFrameHighscores();
+                break;
+            case 28:
+                paintFrameInGame();
+                break;
+            case 29:
+                paintFrameStartLevel();
+                break;
+            case 30:
+                paintFrameStartGame();
+                break;
+            case 31:
+                paintFrameLevelDone();
+                break;
+            case 32:
+                paintFrameLifeLost();
+                break;
+            case 33:
+                paintFrameGameOver();
+                break;
+            case 34:
+                paintFrameEnterHighscore();
+                break;
+            case 35:
+                paintFramePaused();
+                break;
+            default:
+                exitEngine("Game state method " + prefix + suffix + " not supported");
+        }
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startLoader() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startTitle() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startSelectLevel() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startHighscores() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startInGame() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startStartLevel() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startStartGame() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startLevelDone() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startLifeLost() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startGameOver() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startEnterHighscore() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void startPaused() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameLoader() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameTitle() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameSelectLevel() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameHighscores() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameInGame() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameStartLevel() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameStartGame() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameLevelDone() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameLifeLost() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameGameOver() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFrameEnterHighscore() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void doFramePaused() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameLoader() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameTitle() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameSelectLevel() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameHighscores() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameInGame() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameStartLevel() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameStartGame() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameLevelDone() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameLifeLost() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameGameOver() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFrameEnterHighscore() {
+    }
+
+    /**
+     * Predefined game state method, implementation is empty.
+     */
+    public void paintFramePaused() {
+    }
+
+
+    public void doFrame() {
+    }
+
+    void paintFrame(Canvas g) {
+        buf_gfx = g;
+        setColor(bufpainter, el.fg_color);
+        setFont(el.msg_font);
+        try {
+            paintFrame();
+        } catch (JGameError ex) {
+            ex.printStackTrace();
+            exitEngine(dbgExceptionToString(ex));
+        } catch (Exception ex) {
+            dbgShowException("MAIN", ex);
+        }
+        invokeGameStateMethods("paintFrame", el.gamestate);
+        //if ((debugflags&GAMESTATE_DEBUG)!=0) {
+        //	String state="{";
+        //	for (Enumeration e=el.gamestate.elements(); e.hasMoreElements(); ) {
+        //		state += (String)e.nextElement();
+        //		if (e.hasMoreElements()) state +=",";
+        //	}
+        //	state += "}";
+        //	setFont(el.msg_font);
+        //	setColor(g,el.fg_color);
+        //	drawString(state,el.viewWidth(),
+        //			el.viewHeight()-(int)getFontHeight(g,el.msg_font), 1);
+        //}
+        //if ((debugflags&MSGSINPF_DEBUG)!=0) paintDbgFrameLogs(buf_gfx);
+        buf_gfx = null;
+    }
+
+    public void paintFrame() {
+    }
+
+    public Canvas getBufferGraphics() {
+        return buf_gfx;
+    }
+
+    /* some convenience functions for drawing during repaint and paintFrame()*/
+
+    public void setColor(JGColor col) {
+        // XXX setColor cannot check if graphics is available
+        //if (buf_gfx!=null)
+        setColor(bufpainter, col);
+    }
+
+    public void setFont(JGFont font) {
+        setFont(bufpainter, font);
+    }
+
+    public void setFont(Paint p, JGFont jgfont) {
+        double fontsize = jgfont.size * el.min_scale_fac;
+        p.setTextSize((int) fontsize);
+        //Font font = new Font(jgfont.name,jgfont.style,(int)jgfont.size);
+        //if (g!=null) {
+        //	double origsize = font.getSize2D();
+        //	font=font.deriveFont((float)(origsize*el.min_scale_fac));
+        //	g.setFont(font);
+        //}
+    }
+
+    public void setStroke(double thickness) {
+        bufpainter.setStrokeWidth((float) (thickness * el.min_scale_fac));
+    }
+
+    public void setBlendMode(int src_func, int dst_func) {
+    }
+
+    public double getFontHeight(JGFont jgfont) {
+        // TODO get actual size?
+        return jgfont.size * el.min_scale_fac;
+    }
+
+    void drawImage(Canvas g, double x, double y, String imgname,
+                   boolean pf_relative) {
+        //drawImage(x,y,imgname,null,1.0,0.0,1.0,pf_relative);
+        if (g == null) return;
+        if (imgname == null) return;
+        x = el.scaleXPos(x, pf_relative) + el.canvas_xofs;
+        y = el.scaleYPos(y, pf_relative) + el.canvas_yofs;
+        AndroidImage img = (AndroidImage) el.getImage(imgname);
+        if (img != null)
+            g.drawBitmap(img.img, (int) x, (int) y, simpleimagepainter);
+    }
+
+
+    public void drawLine(double x1, double y1, double x2, double y2,
+                         double thickness, JGColor color) {
+        if (color != null) setColor(color);
+        setStroke(thickness);
+        drawLine(x1, y1, x2, y2, true);
+    }
+
+    public void drawLine(double x1, double y1, double x2, double y2) {
+        drawLine(x1, y1, x2, y2, true);
+    }
+
+    public void drawLine(double x1, double y1, double x2, double y2,
+                         boolean pf_relative) {
+        if (buf_gfx == null) return;
+        buf_gfx.drawLine(
+                el.scaleXPos(x1, pf_relative) + el.canvas_xofs,
+                el.scaleYPos(y1, pf_relative) + el.canvas_yofs,
+                el.scaleXPos(x2, pf_relative) + el.canvas_xofs,
+                el.scaleYPos(y2, pf_relative) + el.canvas_yofs, bufpainter);
+    }
+
+    private final int[] xpos = new int[3];
+    private final int[] ypos = new int[3];
+
+    public void drawPolygon(double[] x, double[] y, JGColor[] col, int len,
+                            boolean filled, boolean pf_relative) {
+        if (buf_gfx == null) return;
+        xpos[0] = el.scaleXPos(x[0], pf_relative) + el.canvas_xofs;
+        ypos[0] = el.scaleYPos(y[0], pf_relative) + el.canvas_yofs;
+        xpos[1] = el.scaleXPos(x[1], pf_relative) + el.canvas_xofs;
+        ypos[1] = el.scaleYPos(y[1], pf_relative) + el.canvas_yofs;
+        if (!filled) {
+            // draw first and last line segment
+            xpos[2] = el.scaleXPos(x[len - 1], pf_relative) + el.canvas_xofs;
+            ypos[2] = el.scaleYPos(y[len - 1], pf_relative) + el.canvas_yofs;
+            if (col != null) setColor(bufpainter, col[1]);
+            buf_gfx.drawLine(xpos[0], ypos[0], xpos[1], ypos[1], bufpainter);
+            if (col != null) setColor(bufpainter, col[0]);
+            buf_gfx.drawLine(xpos[2], ypos[2], xpos[0], ypos[0], bufpainter);
+        }
+        if (filled) {
+            bufpainter.setStyle(Paint.Style.FILL);
+        } else {
+            bufpainter.setStyle(Paint.Style.STROKE);
+        }
+        for (int i = 2; i < len; i++) {
+            xpos[2] = el.scaleXPos(x[i], pf_relative) + el.canvas_xofs;
+            ypos[2] = el.scaleYPos(y[i], pf_relative) + el.canvas_yofs;
+            if (col != null) setColor(bufpainter, col[i]);
+            if (filled) {
+                bufpainter.setStyle(Paint.Style.FILL);
+                fillTriangle(buf_gfx, xpos[0], ypos[0], xpos[1], ypos[1], xpos[2], ypos[2]);
+            } else {
+                buf_gfx.drawLine(xpos[1], ypos[1], xpos[2], ypos[2], bufpainter);
+            }
+            xpos[1] = xpos[2];
+            ypos[1] = ypos[2];
+        }
+        bufpainter.setStyle(Paint.Style.STROKE);
+    }
+
+    private void fillTriangle(Canvas g, int x1, int y1, int x2, int y2,
+                              int x3, int y3) {
+        Path p = new Path();
+        p.moveTo(x1, y1);
+        p.lineTo(x2, y2);
+        p.lineTo(x3, y3);
+        g.drawPath(p, bufpainter);
+    }
+
+    public void drawRect(double x, double y, double width, double height, boolean filled,
+                         boolean centered, double thickness, JGColor color) {
+        if (color != null) setColor(color);
+        setStroke(thickness);
+        drawRect(buf_gfx, x, y, width, height, filled, centered, true, null, null);
+    }
+
+    public void drawRect(double x, double y, double width, double height, boolean filled,
+                         boolean centered) {
+        drawRect(buf_gfx, x, y, width, height, filled, centered, true, null, null);
+    }
+
+    public void drawRect(double x, double y, double width, double height, boolean filled,
+                         boolean centered, boolean pf_relative) {
+        drawRect(buf_gfx, x, y, width, height, filled, centered, pf_relative, null, null);
+    }
+
+    public void drawRect(double x, double y, double width, double height,
+                         boolean filled, boolean centered, boolean pf_relative,
+                         JGColor[] shadecol) {
+        drawRect(buf_gfx, x, y, width, height, filled, centered, pf_relative, shadecol, null);
+    }
+
+    public void drawRect(double x, double y, double width, double height,
+                         boolean filled, boolean centered, boolean pf_relative,
+                         JGColor[] shadecol, String tileimage) {
+        drawRect(buf_gfx, x, y, width, height, filled, centered, pf_relative, shadecol, tileimage);
+    }
+
+    void drawRect(Canvas g, double x, double y, double width, double height,
+                  boolean filled, boolean centered, boolean pf_relative,
+                  JGColor[] shadecol, String tileimage) {
+        if (centered) {
+            x -= (width / 2);
+            y -= (height / 2);
+        }
+        JGRectangle r = el.scalePos(x, y, width, height, pf_relative);
+        r.x += el.canvas_xofs;
+        r.y += el.canvas_yofs;
+        if (tileimage != null) {
+            Bitmap b = ((AndroidImage) el.getImage(tileimage)).img;
+            Matrix m = new Matrix();
+            m.setTranslate(r.x, r.y);
+            Shader sh = new BitmapShader(b, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);
+            sh.setLocalMatrix(m);
+            bufpainter.setShader(sh);
+        }
+        if (filled || tileimage != null) {
+            bufpainter.setStyle(Paint.Style.FILL);
+        } else {
+            bufpainter.setStyle(Paint.Style.STROKE);
+        }
+        g.drawRect(new Rect(r.x, r.y, r.x + r.width, r.y + r.height), bufpainter);
+        // reset state
+        bufpainter.setShader(null);
+        bufpainter.setStyle(Paint.Style.STROKE);
+    }
+
+    public void drawOval(double x, double y, double width, double height, boolean filled,
+                         boolean centered, double thickness, JGColor color) {
+        if (color != null) setColor(color);
+        setStroke(thickness);
+        drawOval(x, y, width, height, filled, centered, true);
+    }
+
+    public void drawOval(double x, double y, double width, double height, boolean filled,
+                         boolean centered) {
+        drawOval(x, y, width, height, filled, centered, true);
+    }
+
+    public void drawOval(double x, double y, double width, double height, boolean filled,
+                         boolean centered, boolean pf_relative) {
+        if (buf_gfx == null) return;
+        x = el.scaleXPos(x, pf_relative) + el.canvas_xofs + 0.5;
+        y = el.scaleYPos(y, pf_relative) + el.canvas_yofs + 0.5;
+        width = el.scaleXPos(width, false);
+        height = el.scaleYPos(height, false);
+        if (centered) {
+            x -= (width / 2.0);
+            y -= (height / 2.0);
+        }
+        if (filled) {
+            bufpainter.setStyle(Paint.Style.FILL);
+        } else {
+            bufpainter.setStyle(Paint.Style.STROKE);
+        }
+        buf_gfx.drawOval(new RectF(
+                        (int) x, (int) y, (int) x + (int) width, (int) y + (int) height),
+                bufpainter);
+        // reset state
+        bufpainter.setStyle(Paint.Style.STROKE);
+    }
+
+    /* new versions of drawImage */
+
+    public void drawImage(String imgname, double x, double y) {
+        drawImage(x, y, imgname);
+    }
+
+    public void drawImage(String imgname, double x, double y, boolean pf_relative) {
+        drawImage(x, y, imgname, pf_relative);
+    }
+
+    public void drawImage(String imgname, double x, double y,
+                          boolean pf_relative, JGColor blend_col,
+                          double alpha, double rot, double scale) {
+        drawImage(x, y, imgname, blend_col, alpha, rot, scale, pf_relative);
+    }
+
+
+    public void drawImage(double x, double y, String imgname) {
+        if (buf_gfx == null) return;
+        drawImage(buf_gfx, x, y, imgname, true);
+    }
+
+    public void drawImage(double x, double y, String imgname, boolean pf_relative) {
+        if (buf_gfx == null) return;
+        drawImage(buf_gfx, x, y, imgname, pf_relative);
+    }
+
+    // static variables to avoid object creations
+    JGPoint drawImage_size = new JGPoint(0, 0);
+    Matrix drawImage_m = new Matrix();
+
+    public void drawImage(double x, double y, String imgname, JGColor blend_col,
+                          double alpha, double rot, double scale, boolean pf_relative) {
+        if (buf_gfx == null) return;
+        if (blend_col == null && alpha == 1.0 && rot == 0.0 && scale == 1.0) {
+            drawImage(buf_gfx, x, y, imgname, pf_relative);
+            return;
+        }
+        if (imgname == null) return;
+        int alpha_int = (int) Math.floor(255.95 * alpha);
+        imagepainter.setColor((alpha_int << 24) | 0xffffff);
+        if (blend_col != null) {
+            imagepainter.setColorFilter(
+                    new LightingColorFilter(
+                            (blend_col.r << 16) | (blend_col.g << 8) | blend_col.b, 0));
+            //imagepainter.setColor( (alpha_int<<24)
+            //	| (blend_col.r<<16) | (blend_col.g<<8)  | blend_col.b);
+        } else {
+            imagepainter.setColorFilter(null);
+        }
+        x = el.scaleXPos(x, pf_relative) + el.canvas_xofs;
+        y = el.scaleYPos(y, pf_relative) + el.canvas_yofs;
+        AndroidImage img = (AndroidImage) el.getImageOrig(imgname);
+        JGPoint origsize = img.getSize();
+        //System.err.println(" "+origsize.x+" "+origsize.y);
+        drawImage_size.x = el.scaleXPos(origsize.x, false);
+        drawImage_size.y = el.scaleYPos(origsize.y, false);
+        // size of scaled image
+        double txsize_s = drawImage_size.x * scale;
+        double tysize_s = drawImage_size.y * scale;
+        // determine topleft of scaled image
+        //System.err.println(""+drawImage_size.x+" "+drawImage_size.y+" "+txsize_s+" "+tysize_s);
+        //x -= (txsize_s - drawImage_size.x)/2;
+        //y -= (tysize_s - drawImage_size.y)/2;
+        float pivotx = (float) (origsize.x / 2.0);
+        float pivoty = (float) (origsize.y / 2.0);
+        drawImage_m.reset();
+        drawImage_m.setRotate((float) ((-rot * 180) / Math.PI), pivotx, pivoty);
+        drawImage_m.postScale((float) scale, (float) scale, pivotx, pivoty);
+        drawImage_m.postScale((float) el.x_scale_fac, (float) el.y_scale_fac, 0, 0);
+        drawImage_m.postTranslate((float) x,
+                (float) y);
+        if (img != null)
+            buf_gfx.drawBitmap(img.img, drawImage_m, imagepainter);
+    }
+
+    public void drawString(String str, double x, double y, int align,
+                           JGFont font, JGColor color) {
+        if (font != null) setFont(font);
+        if (color != null) setColor(color);
+        drawString(buf_gfx, str, x, y, align, false);
+    }
+
+    public void drawString(String str, double x, double y, int align) {
+        drawString(buf_gfx, str, x, y, align, false);
+    }
+
+    public void drawString(String str, double x, double y, int align,
+                           boolean pf_relative) {
+        drawString(buf_gfx, str, x, y, align, pf_relative);
+    }
+
+    /**
+     * Internal function for writing on both buffer and screen.  Coordinates
+     * are always relative to view.
+     */
+    void drawString(Canvas g, String str, double x, double y, int align,
+                    boolean pf_relative) {
+        if (g == null) return;
+        if (str.equals("")) return;
+        x = el.scaleXPos(x, pf_relative) + el.canvas_xofs;
+        y = el.scaleYPos(y, pf_relative) + el.canvas_yofs;
+        y -= bufpainter.ascent();
+        Paint.Align palign = Paint.Align.CENTER;
+        if (align == -1) palign = Paint.Align.LEFT;
+        if (align == 1) palign = Paint.Align.RIGHT;
+        bufpainter.setTextAlign(palign);
+        if (el.outline_thickness > 0) {
+            int origcol = bufpainter.getColor();
+            setColor(el.outline_colour);
+            int real_thickness = Math.max(
+                    el.scaleXPos(el.outline_thickness, false), 1);
+            for (int i = -real_thickness; i <= real_thickness; i++) {
+                if (i == 0) continue;
+                g.drawText(str, 0, str.length(), (int) x + i, (int) y, bufpainter);
+            }
+            for (int i = -real_thickness; i <= real_thickness; i++) {
+                if (i == 0) continue;
+                g.drawText(str, 0, str.length(), (int) x, (int) y + i, bufpainter);
+            }
+            bufpainter.setColor(origcol);
+        }
+        // stroke width make text bolder so we set it to 0
+        float origwidth = bufpainter.getStrokeWidth();
+        bufpainter.setStrokeWidth(0);
+        g.drawText(str, 0, str.length(), (int) x, (int) y, bufpainter);
+        bufpainter.setStrokeWidth(origwidth);
+    }
+
+    public void drawImageString(String string, double x, double y, int align,
+                                String imgmap, int char_offset, int spacing) {
+        el.drawImageString(this, string, x, y, align, imgmap, char_offset, spacing,
+                false);
+    }
+
+    public void drawImageString(String string, double x, double y, int align,
+                                String imgmap, int char_offset, int spacing, boolean pf_relative) {
+        el.drawImageString(this, string, x, y, align, imgmap, char_offset, spacing,
+                pf_relative);
+    }
+
+    /* input */
+
+    /**
+     * Android has mouse semantics based on touch screen. They are the same
+     * as MIDP. Touch screens have only press, drag, and release (no mouse
+     * move without button press).  There is only one "button", button 1.
+     * Mouseinside is set to false when finger/stylus is not on the touch
+     * screen.
+     */
+
+    JGPoint mousepos = new JGPoint(0, 0);
+    double mouseposd_x = 0, mouseposd_y = 0;
+    boolean[] mousebutton = new boolean[]{false, false, false, false};
+    boolean mouseinside = false;
+
+    double[] accelvec = new double[]{0, 0, 1};
+
+    /**
+     * XXX: does not produce a clone of mousepos, for efficiency reasons!
+     */
+    public JGPoint getMousePos() {
+        return mousepos;
+    }
+
+    public int getMouseX() {
+        return mousepos.x;
+    }
+
+    public int getMouseY() {
+        return mousepos.y;
+    }
+
+    // XXX android only as yet
+    public double getMouseXD() {
+        return mouseposd_x;
+    }
+
+    public double getMouseYD() {
+        return mouseposd_y;
+    }
+
+    public boolean getMouseButton(int nr) {
+        return mousebutton[nr];
+    }
+
+    public void clearMouseButton(int nr) {
+        mousebutton[nr] = false;
+    }
+
+    public void setMouseButton(int nr) {
+        mousebutton[nr] = true;
+    }
+
+    public boolean getMouseInside() {
+        return mouseinside;
+    }
+
+    public boolean getKey(int key) {
+        return keymap[key];
+    }
+
+    public void clearKey(int key) {
+        keymap[key] = false;
+    }
+
+    public void setKey(int key) {
+        keymap[key] = true;
+    }
+
+    public int getLastKey() {
+        return lastkey;
+    }
+
+    public char getLastKeyChar() {
+        return lastkeychar;
+    }
+
+    public void clearLastKey() {
+        lastkey = 0;
+        lastkeychar = 0;
+    }
+
+    /* maybe move the translations? Should they be system dependent? */
+
+    /**
+     * Get a printable string describing the key. Non-static version for the
+     * sake of the interface.
+     */
+    public String getKeyDesc(int key) {
+        return getKeyDescStatic(key);
+    }
+
+    /**
+     * Get a printable string describing the key.
+     */
+    public static String getKeyDescStatic(int key) {
+        if (key == 32) return "#";
+        if (key == 0) return "(none)";
+        if (key == KeyEnter) return "*";
+        if (key == KeyStar) return "*";
+        if (key == ' ') return "#";
+        if (key == KeyPound) return "#";
+        //if (key==KeyEsc) return "escape";
+        if (key == KeyUp) return "cursor up";
+        if (key == KeyDown) return "cursor down";
+        if (key == KeyLeft) return "cursor left";
+        if (key == KeyRight) return "cursor right";
+        if (key == KeyShift) return "fire";
+        //if (key==KeyAlt) return "alt";
+        //if (key==KeyCtrl) return "control";
+        //if (key==KeyMouse1) return "left mouse button";
+        //if (key==KeyMouse2) return "middle mouse button";
+        //if (key==KeyMouse3) return "right mouse button";
+        //if (key==27) return "escape";
+        if (key >= 33 && key <= 95)
+            return new String(new char[]{(char) key});
+        return "keycode " + key;
+    }
+
+    /**
+     * Obtain key code from printable string describing the key, the inverse
+     * of getKeyDesc. The string is trimmed and lowercased. Non-static version
+     * for the sake of the interface.
+     */
+    public int getKeyCode(String keydesc) {
+        return getKeyCodeStatic(keydesc);
+    }
+
+    /**
+     * Obtain key code from printable string describing the key, the inverse
+     * of getKeyDesc. The string is trimmed and lowercased.
+     */
+    public static int getKeyCodeStatic(String keydesc) {
+        // tab, enter, backspace, insert, delete, home, end, pageup, pagedown
+        // escape
+        keydesc = keydesc.toLowerCase().trim();
+        //if (keydesc.equals("space")) {
+        //	return 32;
+        //} else if (keydesc.equals("escape")) {
+        //	return KeyEsc;
+        //} else
+        if (keydesc.equals("(none)")) {
+            return 0;
+            //} else if (keydesc.equals("enter")) {
+            //	return KeyEnter;
+        } else if (keydesc.equals("cursor up")) {
+            return KeyUp;
+        } else if (keydesc.equals("cursor down")) {
+            return KeyDown;
+        } else if (keydesc.equals("cursor left")) {
+            return KeyLeft;
+        } else if (keydesc.equals("cursor right")) {
+            return KeyRight;
+            //} else if (keydesc.equals("shift")) {
+            //	return KeyShift;
+        } else if (keydesc.equals("fire")) {
+            return KeyFire;
+        } else if (keydesc.equals("star")) {
+            return '*';
+        } else if (keydesc.equals("pound")) {
+            return '#';
+            //} else if (keydesc.equals("alt")) {
+            //	return KeyAlt;
+            //} else if (keydesc.equals("control")) {
+            //	return KeyCtrl;
+            //} else if (keydesc.equals("left mouse button")) {
+            //	return KeyMouse1;
+            //} else if (keydesc.equals("middle mouse button")) {
+            //	return KeyMouse2;
+            //} else if (keydesc.equals("right mouse button")) {
+            //	return KeyMouse3;
+        } else if (keydesc.startsWith("keycode")) {
+            return Integer.parseInt(keydesc.substring(7));
+        } else if (keydesc.length() == 1) {
+            return keydesc.charAt(0);
+        }
+        return 0;
+    }
+
+    public boolean hasAccelerometer() {
+        return true;
+    }
+
+    public double getAccelX() {
+        return accelvec[0];
+    }
+
+    public double getAccelY() {
+        return accelvec[1];
+    }
+
+    public double getAccelZ() {
+        return accelvec[2];
+    }
+
+    public double[] getAccelVec() {
+        return new double[]{accelvec[0], accelvec[1], accelvec[2]};
+    }
+
+
+    /*====== animation ======*/
+
+    public void defineAnimation(String id,
+                                String[] frames, double speed) {
+        el.defineAnimation(id, frames, speed);
+    }
+
+    public void defineAnimation(String id,
+                                String[] frames, double speed, boolean pingpong) {
+        el.defineAnimation(id, frames, speed, pingpong);
+    }
+
+    public Animation getAnimation(String id) {
+        return el.getAnimation(id);
+    }
+
+    public String getConfigPath(String filename) {
+        return null;
+        // not implemented yet.  midp should use the special configuration
+        // features for this.
+    }
+
+    public int invokeUrl(String url, String target) {
+        // XXX application state is reset
+        canvas.post(currentact.new UrlInvoker(url));
+        return -1;
+    }
 
 //	void paintExitMessage(Canvas g) { try {
 //		setFont(g,debugmessage_font);
@@ -2216,502 +2668,522 @@ implements JGEngineInterface  {
 
 
 
-	/* computation */
+    /* computation */
 
-	public boolean and(int value, int mask) {
-		return el.and(value, mask);
-	}
+    public boolean and(int value, int mask) {
+        return el.and(value, mask);
+    }
 
-	public double random(double min, double max) {
-		return el.random(min, max);
-	}
+    public double random(double min, double max) {
+        return el.random(min, max);
+    }
 
-	public double random(double min, double max, double interval) {
-		return el.random(min, max, interval);
-	}
+    public double random(double min, double max, double interval) {
+        return el.random(min, max, interval);
+    }
 
-	public int random(int min, int max, int interval) {
-		return el.random(min, max, interval);
-	}
+    public int random(int min, int max, int interval) {
+        return el.random(min, max, interval);
+    }
 
-	public double atan2(double y,double x) {
-		return Math.atan2(y,x);
-	}
+    public double atan2(double y, double x) {
+        return Math.atan2(y, x);
+    }
 
-	public JGPoint getTileIndex(double x, double y) {
-		return el.getTileIndex(x, y);
-	}
+    public JGPoint getTileIndex(double x, double y) {
+        return el.getTileIndex(x, y);
+    }
 
-	public JGPoint getTileCoord(int tilex, int tiley) {
-		return el.getTileCoord(tilex, tiley);
-	}
+    public JGPoint getTileCoord(int tilex, int tiley) {
+        return el.getTileCoord(tilex, tiley);
+    }
 
-	public JGPoint getTileCoord(JGPoint tileidx) {
-		return el.getTileCoord(tileidx);
-	}
+    public JGPoint getTileCoord(JGPoint tileidx) {
+        return el.getTileCoord(tileidx);
+    }
 
-	public double snapToGridX(double x, double gridsnapx) {
-		return el.snapToGridX(x, gridsnapx);
-	}
-
-	public double snapToGridY(double y, double gridsnapy) {
-		return el.snapToGridY(y, gridsnapy);
-	}
-
-	public void snapToGrid(JGPoint p,int gridsnapx,int gridsnapy) {
-		el.snapToGrid(p,gridsnapx,gridsnapy);
-	}
-
-	public boolean isXAligned(double x,double margin) {
-		return el.isXAligned(x,margin);
-	}
-
-	public boolean isYAligned(double y,double margin) {
-		return el.isYAligned(y,margin);
-	}
-
-	public double getXAlignOfs(double x) {
-		return el.getXAlignOfs(x);
-	}
-
-	public double getYAlignOfs(double y) {
-		return el.getYAlignOfs(y);
-	}
-
-	// XXX please test these two methods
-
-	public double getXDist(double x1, double x2) {
-		return el.getXDist(x1, x2);
-	}
-
-	public double getYDist(double y1, double y2) {
-		return el.getYDist(y1, y2);
-	}
-
-	// android sound is handled through soundpool which matches the jgame
-	// system closely. We make sure the audio api is not touched until a sound
-	// is actually played.
-
-	boolean audioenabled=true;
-
-	// create on demand
-	SoundPool soundpool = null;
-
-	int cursound=-1; // -1 indicates no sound
-
-	Hashtable clipidtosoundid = new Hashtable(); /* String->Int */
-
-	Hashtable channelidtostreamid = new Hashtable(); /* String->Int */
-
-	Hashtable streamidtoclipid = new Hashtable(); /* Int->String */
-
-	//MediaPlayer player=null;
-
-	private void ensureSoundpoolExists() {
-		if (soundpool == null) {
-			soundpool = new SoundPool(8,AudioManager.STREAM_MUSIC,0);
-		}
-	}
-
-	public void enableAudio() {
-		if (audioenabled) return;
-		audioenabled=true;
-		resumeAudio();
-	}
-	void resumeAudio() {
-		ensureSoundpoolExists();
-		for (Enumeration e=channelidtostreamid.elements();e.hasMoreElements();){
-			Integer streamid = (Integer)e.nextElement();
-			soundpool.resume(streamid.intValue());
-		}
-		// android 2.2 only
-		//soundpool.autoResume();
-	}
-
-	public void disableAudio() {
-		if (!audioenabled) return;
-		audioenabled=false;
-		pauseAudio();
-	}
-	void pauseAudio() {
-		ensureSoundpoolExists();
-		for (Enumeration e=channelidtostreamid.elements();e.hasMoreElements();){
-			Integer streamid = (Integer)e.nextElement();
-			soundpool.pause(streamid.intValue());
-		}
-		// android 2.2 only
-		//soundpool.autoPause();
-	}
-
-	public void defineAudioClip(String clipid,String filename) {
-		ensureSoundpoolExists();
-		// getAbsolutePath should not prepend package path
-		el.audioclips.put(clipid,filename);
-		//el.defineAudioClip(this,clipid,filename);
-		try {
-			AssetFileDescriptor fd = assets.openFd(filename);
-			int soundid = soundpool.load(fd, 1/*priority*/);
-			clipidtosoundid.put(clipid,new Integer(soundid));
-		} catch (IOException e) {
-			throw new Error("Sound asset '"+filename+"' could not be loaded");
-		}
-	}
-
-	public String lastPlayedAudio(String channel) {
-		Integer streamid = (Integer)channelidtostreamid.get(channel);
-		return (String)streamidtoclipid.get(streamid);
-	}
-
-	public void playAudio(String clipid) {
-		playAudio(null,clipid,false);
-	}
-	public void playAudio(String channel,String clipid,boolean loop) {
-		ensureSoundpoolExists();
-		if (!audioenabled) return;
-		// stop previous sound on channel
-		if (channel!=null) {
-			Integer prevstreamid = (Integer)channelidtostreamid.get(channel);
-			if (prevstreamid!=null) {
-				soundpool.stop(prevstreamid.intValue());
-			}
-		}
-		int soundid = ((Integer)clipidtosoundid.get(clipid)).intValue();
-		int streamid = soundpool.play(soundid,0.9f, 0.9f,
-			loop ? 1 : 0,
-			loop ? -1 : 0,
-			1.0f);
-		if (channel!=null) {
-			channelidtostreamid.put(channel,new Integer(streamid));
-		}
-		// this code opens asset using mediaplayer. current problems:
-		// sound cut off too early
-		//String filename = (String)el.audioclips.get(clipid);
-		//try {
-			//AssetFileDescriptor fd = assets.openFd(filename);
-			//player = new MediaPlayer();
-			//player.setDataSource(fd.getFileDescriptor(),
-			//	fd.getStartOffset(), fd.getLength() );
-			//fd.close();
-			//player.prepare();
-			//player.start();
-		//} catch (IOException e) {
-		//	throw new Error("Asset '"+filename+"' not found");
-		//}
-
-	}
-	public void stopAudio() {
-		for (Enumeration e=channelidtostreamid.keys();e.hasMoreElements();){
-			String channelid = (String)e.nextElement();
-			stopAudio(channelid);
-		}
-		// stop mediaplayer
-		//if (player!=null) {
-		//	player.stop();
-		//	player.release();
-		//	player=null;
-		//}
-	}
-	public void stopAudio(String channel) {
-		ensureSoundpoolExists();
-		Integer streamid = (Integer)channelidtostreamid.get(channel);
-		if (streamid==null) return;
-		soundpool.stop(streamid.intValue());
-	}
-
-	/** I found SharedPreferences already contains some predefined values
-	 * (such as "volume") so we prefix all keys with a special prefix. */
-	final static String STORE_PREFIX = "JG_";
-
-
-	private void storeInit() {
-		// nothing needs to be done
-	}
-
-	void storeWriteBoolean(String id,boolean value) {
-		SharedPreferences.Editor spe =
-			PreferenceManager.getDefaultSharedPreferences(currentact).edit();
-		spe.putBoolean(STORE_PREFIX+id, value);
-		spe.commit();
-	}
-
-	public void storeWriteInt(String id,int value) {
-		SharedPreferences.Editor spe =
-			PreferenceManager.getDefaultSharedPreferences(currentact).edit();
-		spe.putInt(STORE_PREFIX+id, value);
-		spe.commit();
-	}
-
-	public void storeWriteDouble(String id,double value) {
-		SharedPreferences.Editor spe =
-			PreferenceManager.getDefaultSharedPreferences(currentact).edit();
-		spe.putFloat(STORE_PREFIX+id, (float)value);
-		spe.commit();
-	}
-
-	public void storeWriteString(String id,String value) {
-		SharedPreferences.Editor spe =
-			PreferenceManager.getDefaultSharedPreferences(currentact).edit();
-		spe.putString(STORE_PREFIX+id, value);
-		spe.commit();
-	}
-
-	public void storeRemove(String id) {
-		SharedPreferences.Editor spe =
-			PreferenceManager.getDefaultSharedPreferences(currentact).edit();
-		spe.remove(STORE_PREFIX+id);
-		spe.commit();
-	}
-
-	public boolean storeExists(String id) {
-		SharedPreferences sp =
-			PreferenceManager.getDefaultSharedPreferences(currentact);
-		return sp.contains(STORE_PREFIX+id);
-	}
-
-	public int storeReadInt(String id,int undef) {
-		SharedPreferences sp =
-			PreferenceManager.getDefaultSharedPreferences(currentact);
-		try {
-			return sp.getInt(STORE_PREFIX+id, undef);
-		} catch (ClassCastException e1) {
-			try {
-				return sp.getBoolean(STORE_PREFIX+id, false) ? 1 : 0;
-			} catch (ClassCastException e2) {
-				try {
-					return (int)sp.getFloat(STORE_PREFIX+id, (float)undef);
-				} catch (ClassCastException e3) {
-					return (int)Float.parseFloat(sp.getString(STORE_PREFIX+id,
-						"0"));
-				}
-			}
-		}
-	}
-
-	public double storeReadDouble(String id,double undef) {
-		SharedPreferences sp =
-			PreferenceManager.getDefaultSharedPreferences(currentact);
-		try {
-			return sp.getFloat(STORE_PREFIX+id, (float)undef);
-		} catch (ClassCastException e1) {
-			try {
-				return sp.getBoolean(STORE_PREFIX+id, false) ? 1 : 0;
-			} catch (ClassCastException e2) {
-				try {
-					return sp.getInt(STORE_PREFIX+id, (int)undef);
-				} catch (ClassCastException e3) {
-					return (int)Float.parseFloat(sp.getString(STORE_PREFIX+id,
-						"0"));
-				}
-			}
-		}
-	}
-
-	public String storeReadString(String id,String undef) {
-		SharedPreferences sp =
-			PreferenceManager.getDefaultSharedPreferences(currentact);
-		try {
-			return sp.getString(STORE_PREFIX+id, undef);
-		} catch (ClassCastException e1) {
-			try {
-				return sp.getBoolean(STORE_PREFIX+id, false) ? "1" : "0";
-			} catch (ClassCastException e2) {
-				try {
-					return ""+sp.getInt(STORE_PREFIX+id, 0);
-				} catch (ClassCastException e3) {
-					return ""+sp.getFloat(STORE_PREFIX+id, 0);
-				}
-			}
-		}
-	}
-
-	/*====== options ======*/
-
-	/** The Android implementation uses the standard settings objects, which
-	 * use types that do not quite match the JGame types.  This is solved by
-	 * using automatic type coercion when reading settings and a typecast when
-	 * the settings menu is created. */
-
-	/** Integer (setting ID) - Setting */
-	Hashtable settings_hash = new Hashtable();
-	Vector settings_array = new Vector(20,20);
-
-	private void addSetting(Object key,Setting s) {
-		settings_hash.put(key,s);
-		settings_array.add(s);
-	}
-
-	public void optsAddTitle(String title) {
-		settings_array.addElement(new SettingsTitle(title));
-	}
-
-	public void optsAddNumber(String varname,String title,String desc,
-	int decimals,double lower,double upper,double step, double initial) {
-		//if (decimals==0) {
-		//	if (!storeExists(varname)) storeWriteInt(varname,(int)initial);
-		//} else {
-			if (!storeExists(varname)) storeWriteDouble(varname,initial);
-		//}
-		addSetting(new Integer(Setting.next_id),
-			new NumberSetting(varname,title,desc,decimals,lower,upper,step) );
-	}
-
-	public void optsAddBoolean(String varname,String title,String desc,
-	boolean initial) {
-		if (!storeExists(varname)) storeWriteBoolean(varname,initial);
-		addSetting(new Integer(Setting.next_id),
-			new BooleanSetting(varname,title,desc));
-	}
-
-	public void optsAddEnum(String varname,String title,String desc,
-	String [] values, int initial) {
-		if (!storeExists(varname)) storeWriteString(varname,""+initial);
-		addSetting(new Integer(Setting.next_id),
-			new EnumSetting(varname,title,desc,values));
-	}
-
-	public void optsAddKey(String varname,String title,String desc,int initial){
-		if (!storeExists(varname)) storeWriteInt(varname,initial);
-		addSetting(new Integer(Setting.next_id),
-			new KeySetting(varname,title,desc));
-	}
-
-	public void optsAddString(String varname,String title,String desc,
-	int maxlen, boolean isPassword, String initial) {
-		if (!storeExists(varname)) storeWriteString(varname,initial);
-		addSetting(new Integer(Setting.next_id),
-			new StringSetting(varname,title,desc,maxlen,isPassword));
-	}
-
-	public void optsClear() {
-		settings_hash = new Hashtable();
-		settings_array = new Vector(20,20);
-	}
+    public double snapToGridX(double x, double gridsnapx) {
+        return el.snapToGridX(x, gridsnapx);
+    }
+
+    public double snapToGridY(double y, double gridsnapy) {
+        return el.snapToGridY(y, gridsnapy);
+    }
+
+    public void snapToGrid(JGPoint p, int gridsnapx, int gridsnapy) {
+        el.snapToGrid(p, gridsnapx, gridsnapy);
+    }
+
+    public boolean isXAligned(double x, double margin) {
+        return el.isXAligned(x, margin);
+    }
+
+    public boolean isYAligned(double y, double margin) {
+        return el.isYAligned(y, margin);
+    }
+
+    public double getXAlignOfs(double x) {
+        return el.getXAlignOfs(x);
+    }
+
+    public double getYAlignOfs(double y) {
+        return el.getYAlignOfs(y);
+    }
+
+    // XXX please test these two methods
+
+    public double getXDist(double x1, double x2) {
+        return el.getXDist(x1, x2);
+    }
+
+    public double getYDist(double y1, double y2) {
+        return el.getYDist(y1, y2);
+    }
+
+    // android sound is handled through soundpool which matches the jgame
+    // system closely. We make sure the audio api is not touched until a sound
+    // is actually played.
+
+    boolean audioenabled = true;
+
+    // create on demand
+    SoundPool soundpool = null;
+
+    int cursound = -1; // -1 indicates no sound
+
+    Hashtable clipidtosoundid = new Hashtable(); /* String->Int */
+
+    Hashtable channelidtostreamid = new Hashtable(); /* String->Int */
+
+    Hashtable streamidtoclipid = new Hashtable(); /* Int->String */
+
+    //MediaPlayer player=null;
+
+    private void ensureSoundpoolExists() {
+        if (soundpool == null) {
+            soundpool = new SoundPool(8, AudioManager.STREAM_MUSIC, 0);
+        }
+    }
+
+    public void enableAudio() {
+        if (audioenabled) return;
+        audioenabled = true;
+        resumeAudio();
+    }
+
+    void resumeAudio() {
+        ensureSoundpoolExists();
+        for (Enumeration e = channelidtostreamid.elements(); e.hasMoreElements(); ) {
+            Integer streamid = (Integer) e.nextElement();
+            soundpool.resume(streamid.intValue());
+        }
+        // android 2.2 only
+        //soundpool.autoResume();
+    }
+
+    public void disableAudio() {
+        if (!audioenabled) return;
+        audioenabled = false;
+        pauseAudio();
+    }
+
+    void pauseAudio() {
+        ensureSoundpoolExists();
+        for (Enumeration e = channelidtostreamid.elements(); e.hasMoreElements(); ) {
+            Integer streamid = (Integer) e.nextElement();
+            soundpool.pause(streamid.intValue());
+        }
+        // android 2.2 only
+        //soundpool.autoPause();
+    }
+
+    public void defineAudioClip(String clipid, String filename) {
+        ensureSoundpoolExists();
+        // getAbsolutePath should not prepend package path
+        el.audioclips.put(clipid, filename);
+        //el.defineAudioClip(this,clipid,filename);
+        try {
+            AssetFileDescriptor fd = assets.openFd(filename);
+            int soundid = soundpool.load(fd, 1/*priority*/);
+            clipidtosoundid.put(clipid, new Integer(soundid));
+        } catch (IOException e) {
+            throw new Error("Sound asset '" + filename + "' could not be loaded");
+        }
+    }
+
+    public String lastPlayedAudio(String channel) {
+        Integer streamid = (Integer) channelidtostreamid.get(channel);
+        return (String) streamidtoclipid.get(streamid);
+    }
+
+    public void playAudio(String clipid) {
+        playAudio(null, clipid, false);
+    }
+
+    public void playAudio(String channel, String clipid, boolean loop) {
+        ensureSoundpoolExists();
+        if (!audioenabled) return;
+        // stop previous sound on channel
+        if (channel != null) {
+            Integer prevstreamid = (Integer) channelidtostreamid.get(channel);
+            if (prevstreamid != null) {
+                soundpool.stop(prevstreamid.intValue());
+            }
+        }
+        int soundid = ((Integer) clipidtosoundid.get(clipid)).intValue();
+        int streamid = soundpool.play(soundid, 0.9f, 0.9f,
+                loop ? 1 : 0,
+                loop ? -1 : 0,
+                1.0f);
+        if (channel != null) {
+            channelidtostreamid.put(channel, new Integer(streamid));
+        }
+        // this code opens asset using mediaplayer. current problems:
+        // sound cut off too early
+        //String filename = (String)el.audioclips.get(clipid);
+        //try {
+        //AssetFileDescriptor fd = assets.openFd(filename);
+        //player = new MediaPlayer();
+        //player.setDataSource(fd.getFileDescriptor(),
+        //	fd.getStartOffset(), fd.getLength() );
+        //fd.close();
+        //player.prepare();
+        //player.start();
+        //} catch (IOException e) {
+        //	throw new Error("Asset '"+filename+"' not found");
+        //}
+
+    }
+
+    public void stopAudio() {
+        for (Enumeration e = channelidtostreamid.keys(); e.hasMoreElements(); ) {
+            String channelid = (String) e.nextElement();
+            stopAudio(channelid);
+        }
+        // stop mediaplayer
+        //if (player!=null) {
+        //	player.stop();
+        //	player.release();
+        //	player=null;
+        //}
+    }
+
+    public void stopAudio(String channel) {
+        ensureSoundpoolExists();
+        Integer streamid = (Integer) channelidtostreamid.get(channel);
+        if (streamid == null) return;
+        soundpool.stop(streamid.intValue());
+    }
+
+    /**
+     * I found SharedPreferences already contains some predefined values
+     * (such as "volume") so we prefix all keys with a special prefix.
+     */
+    final static String STORE_PREFIX = "JG_";
+
+
+    private void storeInit() {
+        // nothing needs to be done
+    }
+
+    void storeWriteBoolean(String id, boolean value) {
+        SharedPreferences.Editor spe =
+                PreferenceManager.getDefaultSharedPreferences(currentact).edit();
+        spe.putBoolean(STORE_PREFIX + id, value);
+        spe.commit();
+    }
+
+    public void storeWriteInt(String id, int value) {
+        SharedPreferences.Editor spe =
+                PreferenceManager.getDefaultSharedPreferences(currentact).edit();
+        spe.putInt(STORE_PREFIX + id, value);
+        spe.commit();
+    }
+
+    public void storeWriteDouble(String id, double value) {
+        SharedPreferences.Editor spe =
+                PreferenceManager.getDefaultSharedPreferences(currentact).edit();
+        spe.putFloat(STORE_PREFIX + id, (float) value);
+        spe.commit();
+    }
+
+    public void storeWriteString(String id, String value) {
+        SharedPreferences.Editor spe =
+                PreferenceManager.getDefaultSharedPreferences(currentact).edit();
+        spe.putString(STORE_PREFIX + id, value);
+        spe.commit();
+    }
+
+    public void storeRemove(String id) {
+        SharedPreferences.Editor spe =
+                PreferenceManager.getDefaultSharedPreferences(currentact).edit();
+        spe.remove(STORE_PREFIX + id);
+        spe.commit();
+    }
+
+    public boolean storeExists(String id) {
+        SharedPreferences sp =
+                PreferenceManager.getDefaultSharedPreferences(currentact);
+        return sp.contains(STORE_PREFIX + id);
+    }
+
+    public int storeReadInt(String id, int undef) {
+        SharedPreferences sp =
+                PreferenceManager.getDefaultSharedPreferences(currentact);
+        try {
+            return sp.getInt(STORE_PREFIX + id, undef);
+        } catch (ClassCastException e1) {
+            try {
+                return sp.getBoolean(STORE_PREFIX + id, false) ? 1 : 0;
+            } catch (ClassCastException e2) {
+                try {
+                    return (int) sp.getFloat(STORE_PREFIX + id, (float) undef);
+                } catch (ClassCastException e3) {
+                    return (int) Float.parseFloat(sp.getString(STORE_PREFIX + id,
+                            "0"));
+                }
+            }
+        }
+    }
+
+    public double storeReadDouble(String id, double undef) {
+        SharedPreferences sp =
+                PreferenceManager.getDefaultSharedPreferences(currentact);
+        try {
+            return sp.getFloat(STORE_PREFIX + id, (float) undef);
+        } catch (ClassCastException e1) {
+            try {
+                return sp.getBoolean(STORE_PREFIX + id, false) ? 1 : 0;
+            } catch (ClassCastException e2) {
+                try {
+                    return sp.getInt(STORE_PREFIX + id, (int) undef);
+                } catch (ClassCastException e3) {
+                    return (int) Float.parseFloat(sp.getString(STORE_PREFIX + id,
+                            "0"));
+                }
+            }
+        }
+    }
+
+    public String storeReadString(String id, String undef) {
+        SharedPreferences sp =
+                PreferenceManager.getDefaultSharedPreferences(currentact);
+        try {
+            return sp.getString(STORE_PREFIX + id, undef);
+        } catch (ClassCastException e1) {
+            try {
+                return sp.getBoolean(STORE_PREFIX + id, false) ? "1" : "0";
+            } catch (ClassCastException e2) {
+                try {
+                    return "" + sp.getInt(STORE_PREFIX + id, 0);
+                } catch (ClassCastException e3) {
+                    return "" + sp.getFloat(STORE_PREFIX + id, 0);
+                }
+            }
+        }
+    }
+
+    /*====== options ======*/
+
+    /** The Android implementation uses the standard settings objects, which
+     * use types that do not quite match the JGame types.  This is solved by
+     * using automatic type coercion when reading settings and a typecast when
+     * the settings menu is created. */
+
+    /**
+     * Integer (setting ID) - Setting
+     */
+    Hashtable settings_hash = new Hashtable();
+    Vector settings_array = new Vector(20, 20);
+
+    private void addSetting(Object key, Setting s) {
+        settings_hash.put(key, s);
+        settings_array.add(s);
+    }
+
+    public void optsAddTitle(String title) {
+        settings_array.addElement(new SettingsTitle(title));
+    }
+
+    public void optsAddNumber(String varname, String title, String desc,
+                              int decimals, double lower, double upper, double step, double initial) {
+        //if (decimals==0) {
+        //	if (!storeExists(varname)) storeWriteInt(varname,(int)initial);
+        //} else {
+        if (!storeExists(varname)) storeWriteDouble(varname, initial);
+        //}
+        addSetting(new Integer(Setting.next_id),
+                new NumberSetting(varname, title, desc, decimals, lower, upper, step));
+    }
+
+    public void optsAddBoolean(String varname, String title, String desc,
+                               boolean initial) {
+        if (!storeExists(varname)) storeWriteBoolean(varname, initial);
+        addSetting(new Integer(Setting.next_id),
+                new BooleanSetting(varname, title, desc));
+    }
+
+    public void optsAddEnum(String varname, String title, String desc,
+                            String[] values, int initial) {
+        if (!storeExists(varname)) storeWriteString(varname, "" + initial);
+        addSetting(new Integer(Setting.next_id),
+                new EnumSetting(varname, title, desc, values));
+    }
+
+    public void optsAddKey(String varname, String title, String desc, int initial) {
+        if (!storeExists(varname)) storeWriteInt(varname, initial);
+        addSetting(new Integer(Setting.next_id),
+                new KeySetting(varname, title, desc));
+    }
+
+    public void optsAddString(String varname, String title, String desc,
+                              int maxlen, boolean isPassword, String initial) {
+        if (!storeExists(varname)) storeWriteString(varname, initial);
+        addSetting(new Integer(Setting.next_id),
+                new StringSetting(varname, title, desc, maxlen, isPassword));
+    }
+
+    public void optsClear() {
+        settings_hash = new Hashtable();
+        settings_array = new Vector(20, 20);
+    }
 
 }
 
 abstract class Setting {
-	public static int next_id=JGActivity.SETTINGS_SUBMENU;
-	public String varname;
-	public String title,desc;
-	public int id=0;
-	public Setting(String varname,String title,String desc) {
-		this.varname = varname;
-		this.title = title;
-		this.desc = desc;
-		id = next_id;
-	}
-	abstract void addMenuItem(JGEngine eng,PreferenceActivity context,
-	PreferenceCategory cat);
+    public static int next_id = JGActivity.SETTINGS_SUBMENU;
+    public String varname;
+    public String title, desc;
+    public int id = 0;
+
+    public Setting(String varname, String title, String desc) {
+        this.varname = varname;
+        this.title = title;
+        this.desc = desc;
+        id = next_id;
+    }
+
+    abstract void addMenuItem(JGEngine eng, PreferenceActivity context,
+                              PreferenceCategory cat);
 }
 
 class SettingsTitle {
-	public String titledesc;
-	public SettingsTitle(String titledesc) {
-		this.titledesc = titledesc;
-	}
+    public String titledesc;
+
+    public SettingsTitle(String titledesc) {
+        this.titledesc = titledesc;
+    }
 }
 
 class NumberSetting extends Setting {
-	public int decimals;
-	public double lower,upper, step;
-	public NumberSetting(String varname,String title,String desc,int decimals,
-	double lower,double upper,double step) {
-		super(varname,title,desc);
-		this.decimals = decimals;
-		this.lower = lower;
-		this.upper = upper;
-		this.step = step;
-		next_id++;
-	}
-	void addMenuItem(JGEngine eng,PreferenceActivity context,PreferenceCategory cat) {
-		SeekBarPreference sbpref = new SeekBarPreference(context,this);
-		sbpref.setKey(JGEngine.STORE_PREFIX+varname);
-		sbpref.setTitle(title);
-		sbpref.setSummary(desc);
-		//sbpref.setMax((int)upper);
-		cat.addPreference(sbpref);
-	}
+    public int decimals;
+    public double lower, upper, step;
+
+    public NumberSetting(String varname, String title, String desc, int decimals,
+                         double lower, double upper, double step) {
+        super(varname, title, desc);
+        this.decimals = decimals;
+        this.lower = lower;
+        this.upper = upper;
+        this.step = step;
+        next_id++;
+    }
+
+    void addMenuItem(JGEngine eng, PreferenceActivity context, PreferenceCategory cat) {
+        SeekBarPreference sbpref = new SeekBarPreference(context, this);
+        sbpref.setKey(JGEngine.STORE_PREFIX + varname);
+        sbpref.setTitle(title);
+        sbpref.setSummary(desc);
+        //sbpref.setMax((int)upper);
+        cat.addPreference(sbpref);
+    }
 }
 
 class BooleanSetting extends Setting {
-	public BooleanSetting(String varname,String title,String desc) {
-		super(varname,title,desc);
-		next_id++;
-	}
-	void addMenuItem(JGEngine eng,PreferenceActivity context,
-	PreferenceCategory cat) {
-		// make sure key is of right type
-		// XXX is a race condition possible?
-		eng.storeWriteBoolean(JGEngine.STORE_PREFIX+varname,
-			eng.storeReadInt(JGEngine.STORE_PREFIX+varname,0)!=0 );
-		// Toggle preference
-		CheckBoxPreference togglePref = new CheckBoxPreference(context);
-		togglePref.setKey(JGEngine.STORE_PREFIX+varname);
-		togglePref.setTitle(title);
-		togglePref.setSummary(desc);
-		cat.addPreference(togglePref);
-	}
+    public BooleanSetting(String varname, String title, String desc) {
+        super(varname, title, desc);
+        next_id++;
+    }
+
+    void addMenuItem(JGEngine eng, PreferenceActivity context,
+                     PreferenceCategory cat) {
+        // make sure key is of right type
+        // XXX is a race condition possible?
+        eng.storeWriteBoolean(JGEngine.STORE_PREFIX + varname,
+                eng.storeReadInt(JGEngine.STORE_PREFIX + varname, 0) != 0);
+        // Toggle preference
+        CheckBoxPreference togglePref = new CheckBoxPreference(context);
+        togglePref.setKey(JGEngine.STORE_PREFIX + varname);
+        togglePref.setTitle(title);
+        togglePref.setSummary(desc);
+        cat.addPreference(togglePref);
+    }
 }
 
 class EnumSetting extends Setting {
-	public String [] values;
-	public EnumSetting(String varname,String title,String desc,String[] values){
-		super(varname,title,desc);
-		this.values = values;
-		next_id += values.length;
-	}
-	void addMenuItem(JGEngine eng,PreferenceActivity context,
-	PreferenceCategory cat) {
-   		String [] valueidxes = new String [values.length];
-		for (int i=0; i<values.length; i++) {
-			valueidxes[i] = ""+i;
-		}
-		// make sure key is of right type
-		// XXX is a race condition possible?
-		eng.storeWriteString(JGEngine.STORE_PREFIX+varname,
-			eng.storeReadString(JGEngine.STORE_PREFIX+varname,"") );
-		// List preference
-		ListPreference listPref = new ListPreference(context);
-		listPref.setEntries(values);
-		listPref.setEntryValues(valueidxes);
-		listPref.setDialogTitle(title);
-		listPref.setKey(JGEngine.STORE_PREFIX+varname);
-		listPref.setTitle(title);
-		listPref.setSummary(desc);
-		cat.addPreference(listPref);
-	}
+    public String[] values;
+
+    public EnumSetting(String varname, String title, String desc, String[] values) {
+        super(varname, title, desc);
+        this.values = values;
+        next_id += values.length;
+    }
+
+    void addMenuItem(JGEngine eng, PreferenceActivity context,
+                     PreferenceCategory cat) {
+        String[] valueidxes = new String[values.length];
+        for (int i = 0; i < values.length; i++) {
+            valueidxes[i] = "" + i;
+        }
+        // make sure key is of right type
+        // XXX is a race condition possible?
+        eng.storeWriteString(JGEngine.STORE_PREFIX + varname,
+                eng.storeReadString(JGEngine.STORE_PREFIX + varname, ""));
+        // List preference
+        ListPreference listPref = new ListPreference(context);
+        listPref.setEntries(values);
+        listPref.setEntryValues(valueidxes);
+        listPref.setDialogTitle(title);
+        listPref.setKey(JGEngine.STORE_PREFIX + varname);
+        listPref.setTitle(title);
+        listPref.setSummary(desc);
+        cat.addPreference(listPref);
+    }
 }
 
 class KeySetting extends Setting {
-	public KeySetting(String varname,String title,String desc) {
-		super(varname,title,desc);
-		next_id++;
-	}
-	void addMenuItem(JGEngine eng,PreferenceActivity context,
-	PreferenceCategory cat) {
-		// XXX not implemented yet!
-	}
+    public KeySetting(String varname, String title, String desc) {
+        super(varname, title, desc);
+        next_id++;
+    }
+
+    void addMenuItem(JGEngine eng, PreferenceActivity context,
+                     PreferenceCategory cat) {
+        // XXX not implemented yet!
+    }
 }
 
 class StringSetting extends Setting {
-	public int maxlen;
-	public boolean isPassword;
-	public StringSetting(String varname,String title,String desc,int maxlen,
-	boolean isPassword) {
-		super(varname,title,desc);
-		this.maxlen = maxlen;
-		this.isPassword = isPassword;
-		next_id++;
-	}
-	void addMenuItem(JGEngine eng,PreferenceActivity context,
-	PreferenceCategory cat) {
-		// Edit text preference
-		EditTextPreference editTextPref = new EditTextPreference(context);
-		editTextPref.setDialogTitle(title);
-		editTextPref.setKey(JGEngine.STORE_PREFIX+varname);
-		editTextPref.setTitle(title);
-		editTextPref.setSummary(desc);
-		cat.addPreference(editTextPref);
-	}
+    public int maxlen;
+    public boolean isPassword;
+
+    public StringSetting(String varname, String title, String desc, int maxlen,
+                         boolean isPassword) {
+        super(varname, title, desc);
+        this.maxlen = maxlen;
+        this.isPassword = isPassword;
+        next_id++;
+    }
+
+    void addMenuItem(JGEngine eng, PreferenceActivity context,
+                     PreferenceCategory cat) {
+        // Edit text preference
+        EditTextPreference editTextPref = new EditTextPreference(context);
+        editTextPref.setDialogTitle(title);
+        editTextPref.setKey(JGEngine.STORE_PREFIX + varname);
+        editTextPref.setTitle(title);
+        editTextPref.setSummary(desc);
+        cat.addPreference(editTextPref);
+    }
 }
 
diff --git a/app/src/main/java/jgame/platform/JGPreferences.java b/app/src/main/java/jgame/platform/JGPreferences.java
index 445cfc3..c404489 100644
--- a/app/src/main/java/jgame/platform/JGPreferences.java
+++ b/app/src/main/java/jgame/platform/JGPreferences.java
@@ -1,31 +1,21 @@
 package jgame.platform;
-import android.app.*;
-import android.os.Bundle;
-import android.content.res.AssetManager;
-
-import android.hardware.*;
-import android.view.*;
-import android.graphics.*;
-import android.graphics.drawable.Drawable;
-
-import android.content.Intent;
-import android.content.DialogInterface;
-import android.net.Uri;
 
-import java.util.*;
+import android.os.Bundle;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceScreen;
 
-import android.content.SharedPreferences;
-import android.preference.*;
+import java.util.Enumeration;
 
 
 public class JGPreferences extends PreferenceActivity {
 
-	JGEngine eng;
+    JGEngine eng;
 
-	@Override
-	protected void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		eng = JGEngine.current_engine;
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        eng = JGEngine.current_engine;
 
         setPreferenceScreen(createPreferenceHierarchy());
     }
@@ -34,22 +24,22 @@ public class JGPreferences extends PreferenceActivity {
         // Root
         PreferenceScreen root = getPreferenceManager().createPreferenceScreen(this);
         PreferenceCategory currentPrefCat = new PreferenceCategory(this);
-		currentPrefCat.setTitle("Preferences");
-		boolean catAdded=false;
-		for (Enumeration e=eng.settings_array.elements();e.hasMoreElements();) {
-			Object el = e.nextElement();
-			if (el instanceof SettingsTitle) {
-		        currentPrefCat = new PreferenceCategory(this);
-				currentPrefCat.setTitle(((SettingsTitle)el).titledesc);
-				catAdded=false;
-			} else {
-				if (!catAdded) {
-        			root.addPreference(currentPrefCat);
-					catAdded=true;
-				}
-				((Setting)el).addMenuItem(eng,this,currentPrefCat);
-			}
-		}
+        currentPrefCat.setTitle("Preferences");
+        boolean catAdded = false;
+        for (Enumeration e = eng.settings_array.elements(); e.hasMoreElements(); ) {
+            Object el = e.nextElement();
+            if (el instanceof SettingsTitle) {
+                currentPrefCat = new PreferenceCategory(this);
+                currentPrefCat.setTitle(((SettingsTitle) el).titledesc);
+                catAdded = false;
+            } else {
+                if (!catAdded) {
+                    root.addPreference(currentPrefCat);
+                    catAdded = true;
+                }
+                ((Setting) el).addMenuItem(eng, this, currentPrefCat);
+            }
+        }
 
 
 //        // Launch preferences
@@ -117,20 +107,20 @@ public class JGPreferences extends PreferenceActivity {
     }
 
 
-	@Override
-	protected void onResume() {
-		// Ideally a game should implement onResume() and onPause()
-		// to take appropriate action when the activity looses focus
-		super.onResume();
+    @Override
+    protected void onResume() {
+        // Ideally a game should implement onResume() and onPause()
+        // to take appropriate action when the activity looses focus
+        super.onResume();
 
-	}
+    }
 
-	@Override
-	protected void onPause() {
-		// Ideally a game should implement onResume() and onPause()
-		// to take appropriate action when the activity looses focus
-		super.onPause();
-	}
+    @Override
+    protected void onPause() {
+        // Ideally a game should implement onResume() and onPause()
+        // to take appropriate action when the activity looses focus
+        super.onPause();
+    }
 
 }
 
diff --git a/app/src/main/java/jgame/platform/SeekBarPreference.java b/app/src/main/java/jgame/platform/SeekBarPreference.java
index a8a7b13..4996928 100644
--- a/app/src/main/java/jgame/platform/SeekBarPreference.java
+++ b/app/src/main/java/jgame/platform/SeekBarPreference.java
@@ -1,124 +1,128 @@
 package jgame.platform;
 
 import android.content.Context;
-import android.util.AttributeSet;
+import android.preference.DialogPreference;
 import android.view.Gravity;
 import android.view.View;
-import android.view.ViewGroup;
-import android.preference.DialogPreference;
+import android.widget.LinearLayout;
 import android.widget.SeekBar;
 import android.widget.TextView;
-import android.widget.LinearLayout;
 
 
 public class SeekBarPreference extends DialogPreference
-implements SeekBar.OnSeekBarChangeListener {
-	//private static final String androidns="http://schemas.android.com/apk/res/android";
-
-	private SeekBar mSeekBar;
-	private TextView mSplashText,mValueText;
-	private Context mContext;
-
-	private String mDialogMessage="mDialogMessage", suffix="";
-	private int intmax,intstep;
-	private double value;
-	private double defaultvalue=0; // should not be necessary
-	private NumberSetting param;
-		//public int decimals;
-		//public double lower,upper, step;
-
-	private void calcSeekBarParam() {
-		intstep = (int)Math.round(param.step*Math.pow(10,param.decimals));
-		intmax = convertToInt(param.upper);
-	}
-
-	private int convertToInt(double val) {
-		return (int)Math.round((val-param.lower)*Math.pow(10,param.decimals));
-	}
-
-	private float convertToFloat(int val) {
-		return (float)(param.lower + val/(Math.pow(10,param.decimals)));
-	}
-
-	public SeekBarPreference(Context context,NumberSetting param) { 
-		super(context,null); 
-		mContext = context;
-		this.param = param;
-		this.mDialogMessage = param.title;
-		// XXX suffix not passed, so unused as yet
-		setPersistent(true);
-	}
-
-	/*public SeekBarPreference(Context context, AttributeSet attrs) { 
-		super(context,attrs); 
-		mContext = context;
-
-		mDialogMessage = attrs.getAttributeValue(androidns,"dialogMessage");
-		mSuffix = attrs.getAttributeValue(androidns,"text");
-		mDefault = attrs.getAttributeIntValue(androidns,"defaultValue", 0);
-		mMax = attrs.getAttributeIntValue(androidns,"max", 100);
-
-	}*/
-	@Override 
-	protected View onCreateDialogView() {
-		LinearLayout.LayoutParams params;
-		LinearLayout layout = new LinearLayout(mContext);
-		layout.setOrientation(LinearLayout.VERTICAL);
-		layout.setPadding(6,6,6,6);
-
-		mSplashText = new TextView(mContext);
-		if (mDialogMessage != null)
-			mSplashText.setText(mDialogMessage);
-		layout.addView(mSplashText);
-
-		mValueText = new TextView(mContext);
-		mValueText.setGravity(Gravity.CENTER_HORIZONTAL);
-		mValueText.setTextSize(32);
-		params = new LinearLayout.LayoutParams(
-				LinearLayout.LayoutParams.FILL_PARENT, 
-				LinearLayout.LayoutParams.WRAP_CONTENT);
-		layout.addView(mValueText, params);
-
-		mSeekBar = new SeekBar(mContext);
-		mSeekBar.setOnSeekBarChangeListener(this);
-		layout.addView(mSeekBar, new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT));
-
-		if (shouldPersist())
-			value = getPersistedFloat((float)defaultvalue);
-		calcSeekBarParam();
-		mSeekBar.setMax(intmax);
-		mSeekBar.setProgress(convertToInt(value));
-		return layout;
-	}
-
-	@Override 
-	protected void onBindDialogView(View v) {
-		super.onBindDialogView(v);
-		calcSeekBarParam();
-		mSeekBar.setMax(intmax);
-		mSeekBar.setProgress(convertToInt(value));
-	}
-	@Override
-	protected void onSetInitialValue(boolean restore, Object defaultValue) {
-		super.onSetInitialValue(restore, defaultValue);
-		if (restore) {
-			value = shouldPersist() ?
-				getPersistedFloat((float)defaultvalue) : defaultvalue;
-		} else {
-			value = (Float)defaultValue;
-		}
-	}
-
-	public void onProgressChanged(SeekBar seek, int value, boolean fromTouch) {
-		mValueText.setText(convertToFloat(value) + suffix);
-		callChangeListener(new Float(this.value));
-		this.value = convertToFloat(value);
-		if (shouldPersist()) {
-			persistFloat((float)this.value);
-		}
-	}
-	public void onStartTrackingTouch(SeekBar seek) {}
-	public void onStopTrackingTouch(SeekBar seek) {}
+        implements SeekBar.OnSeekBarChangeListener {
+    //private static final String androidns="http://schemas.android.com/apk/res/android";
+
+    private SeekBar mSeekBar;
+    private TextView mSplashText, mValueText;
+    private final Context mContext;
+
+    private String mDialogMessage = "mDialogMessage";
+    private final String suffix = "";
+    private int intmax, intstep;
+    private double value;
+    private final double defaultvalue = 0; // should not be necessary
+    private final NumberSetting param;
+    //public int decimals;
+    //public double lower,upper, step;
+
+    private void calcSeekBarParam() {
+        intstep = (int) Math.round(param.step * Math.pow(10, param.decimals));
+        intmax = convertToInt(param.upper);
+    }
+
+    private int convertToInt(double val) {
+        return (int) Math.round((val - param.lower) * Math.pow(10, param.decimals));
+    }
+
+    private float convertToFloat(int val) {
+        return (float) (param.lower + val / (Math.pow(10, param.decimals)));
+    }
+
+    public SeekBarPreference(Context context, NumberSetting param) {
+        super(context, null);
+        mContext = context;
+        this.param = param;
+        this.mDialogMessage = param.title;
+        // XXX suffix not passed, so unused as yet
+        setPersistent(true);
+    }
+
+    /*public SeekBarPreference(Context context, AttributeSet attrs) {
+        super(context,attrs);
+        mContext = context;
+
+        mDialogMessage = attrs.getAttributeValue(androidns,"dialogMessage");
+        mSuffix = attrs.getAttributeValue(androidns,"text");
+        mDefault = attrs.getAttributeIntValue(androidns,"defaultValue", 0);
+        mMax = attrs.getAttributeIntValue(androidns,"max", 100);
+
+    }*/
+    @Override
+    protected View onCreateDialogView() {
+        LinearLayout.LayoutParams params;
+        LinearLayout layout = new LinearLayout(mContext);
+        layout.setOrientation(LinearLayout.VERTICAL);
+        layout.setPadding(6, 6, 6, 6);
+
+        mSplashText = new TextView(mContext);
+        if (mDialogMessage != null)
+            mSplashText.setText(mDialogMessage);
+        layout.addView(mSplashText);
+
+        mValueText = new TextView(mContext);
+        mValueText.setGravity(Gravity.CENTER_HORIZONTAL);
+        mValueText.setTextSize(32);
+        params = new LinearLayout.LayoutParams(
+                LinearLayout.LayoutParams.FILL_PARENT,
+                LinearLayout.LayoutParams.WRAP_CONTENT);
+        layout.addView(mValueText, params);
+
+        mSeekBar = new SeekBar(mContext);
+        mSeekBar.setOnSeekBarChangeListener(this);
+        layout.addView(mSeekBar, new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT));
+
+        if (shouldPersist())
+            value = getPersistedFloat((float) defaultvalue);
+        calcSeekBarParam();
+        mSeekBar.setMax(intmax);
+        mSeekBar.setProgress(convertToInt(value));
+        return layout;
+    }
+
+    @Override
+    protected void onBindDialogView(View v) {
+        super.onBindDialogView(v);
+        calcSeekBarParam();
+        mSeekBar.setMax(intmax);
+        mSeekBar.setProgress(convertToInt(value));
+    }
+
+    @Override
+    protected void onSetInitialValue(boolean restore, Object defaultValue) {
+        super.onSetInitialValue(restore, defaultValue);
+        if (restore) {
+            value = shouldPersist() ?
+                    getPersistedFloat((float) defaultvalue) : defaultvalue;
+        } else {
+            value = (Float) defaultValue;
+        }
+    }
+
+    public void onProgressChanged(SeekBar seek, int value, boolean fromTouch) {
+        mValueText.setText(convertToFloat(value) + suffix);
+        callChangeListener(new Float(this.value));
+        this.value = convertToFloat(value);
+        if (shouldPersist()) {
+            persistFloat((float) this.value);
+        }
+    }
+
+    public void onStartTrackingTouch(SeekBar seek) {
+    }
+
+    public void onStopTrackingTouch(SeekBar seek) {
+    }
 
 }
 
diff --git a/app/src/main/java/jgame/platform/StdGame.java b/app/src/main/java/jgame/platform/StdGame.java
index d4e7327..b603690 100644
--- a/app/src/main/java/jgame/platform/StdGame.java
+++ b/app/src/main/java/jgame/platform/StdGame.java
@@ -1,675 +1,846 @@
 package jgame.platform;
-import jgame.*;
-import java.io.*;
-
-/** A basic framework for a game.  It supports an animation and game timer,
-* object creation at fixed intervals, score, lives, levels, configurable keys.
-* There are title, start-level, next-level, death, and game-over sequences.
-* Todo: highscores, key configuration file and GUI.
-
-* <p>To initialise this class, use the regular initEngine (from main), or
-* initEngineApplet (from parameterless constructor).  You can supply the width
-* and height of the window as command line arguments by calling
-* parseSizeArgs(args) from your main().  Define initGame() as usual.  StdGame
-* does all its logic in the doFrame method, so you should ensure that it is
-* called (i.e. call super.doFrame() if you choose to override doFrame).  The
-* game will automatically start in the "Title" gamestate when it finds that
-* it isn't in this state in the first call to doFrame().  You can also set the
-* "Title" state in initGame if you even want the first frame to be in
-* "Title".
-
-* <p>The class uses the following state machine, using JGEngine's state
-* machine mechanism:
-
-* <p><i>Title</i>: displays title screen.  Transition to
-* {StartLevel,StartGame} when the key_startgame is pressed.  Before the
-* transition, initNewGame(), defineLevel(), and initNewLife() are called.
-
-* <p><i>InGame</i>: game is playing.  Transition to LifeLost when lifeLost()
-* is called from within the game.  Transition to LevelDone when levelDone() is
-* called from within the game.  Transition to GameOver when gameOver() is
-* called (i.e. to quit game).  The gametime timer indicates how many ticks the
-* game has been running since the beginning of the level.
-
-* <p>StdGame supports a set of standard game sequences, which are represented
-* as game states: StartLevel/StartGame, LevelDone, LifeLost, GameOver.  These
-* can be configured so they add the InGame state to the sequence state (i.e.
-* the game is in both states simultaneously).  This can be used to animate the
-* game while playing the corresponding sequence.  This is off by default.  The
-* seqtimer timer is set to 0 at the beginning of each sequence, and increments
-* during the sequence to indicate how many ticks the sequence has been
-* playing.  The number of ticks that the sequence should take can be
-* configured, or the sequence can be skipped altogether by setting ticks to 0.
-
-* <p><i>StartGame</i>: start game sequence is played.  Transition to InGame
-* after a certain time has elapsed or the continuegame key is pressed. 
-
-* <p><i>StartLevel</i>: start level sequence is played.  Transition to InGame
-* after a certain time has elapsed or the continuegame key is pressed.  Is always
-* active in combination with StartGame; it's just an indication that StartGame
-* is also a start of a new level.
-
-* <p><i>LevelDone</i>: next level sequence is played.  Transition to
-* StartLevel/StartGame after a certain time has elapsed or the continuegame key
-* is pressed.  Before the transition, resp. incrementLevel() and defineLevel()
-* are called.
-
-* <p><i>LifeLost</i>:  player has just died, a death sequence is played.
-* Transition to either GameOver or StartGame after a certain time has elapsed
-* or the continuegame key is pressed, dependent of whether there are lives left.
-* Before the transition to StartGame, decrementLives() and initNewLife are
-* called.
-
-* <p><i>GameOver</i>: game over sequence is played.  Transition to Title after
-* a certain time or the continuegame key is pressed.
-
-* <p>Built in are also game exit (through the key_quitgame, which is Escape by
-* default), pause game (through the key_pausegame, which defaults to 'P'), and
-* program exit (key_quitprogram, default Escape).
-*/
-public abstract class StdGame extends JGEngine {
-
-	// XXX can levelDone and lifeLost be triggered simultaneously? (ramjet)
-
-	/* settings */
-
-	/** Flag indicating that audio is enabled */
-	public boolean audioenabled=false;
-
-	/** Flag indicating that sound enable dialog should be shown at startup */
-	public boolean audio_dialog_at_startup=true;
-
-	/** flag indicating that accelerometer set zero point menu should be
-	 * active. */
-	public boolean accel_set_zero_menu=false;
-
-	/** Key for starting the game, default = space. */
-	public int key_startgame = ' ';
-	/** Key for invoking the game settings window, default = enter. */
-	public int key_gamesettings = KeyEnter;
-	/** Key for continuing the game when in a sequence, default = space. */
-	public int key_continuegame = ' ';
-	/** Key for quitting the current game, default = escape. */
-	public int key_quitgame = KeyEsc;
-	/** Key for quitting the program, default = escape. */
-	public int key_quitprogram = KeyEsc;
-	/** Key for pausing the game, default = P. */
-	public int key_pausegame = 'P';
-	/** Key for moving, default = cursors. NOTE: not all Android physical
-	 * keyboards have cursor keys */
-	public int key_left=KeyLeft, key_right=KeyRight,
-	           key_up  =KeyUp,    key_down=KeyDown;
-	/** Key for moving diagonally, default = none. */
-	//public int key_upleft=0, key_downleft=0,
-	//           key_upright=0, key_downright=0;
-	/** Key for firing (in case there are no separate directional fire keys),
-	* default=Z. */
-	public int key_fire      = 'Z';
-	/** Key for directional firing, default = WSAD keys */
-	public int key_fireleft = 'A', key_fireright= 'D',
-	           key_fireup   = 'W', key_firedown = 'S';
-	/** Key for special action, default=X */
-	public int key_action      = 'X';
-	/** Key for diagonal firing, default = none */
-	//public int key_fireupleft =0, key_firedownleft=0,
-	//           key_fireupright=0, key_firedownright=0;
-	/** Keys for special actions.  Default = action[0]=ctrl, action[1]=alt */
-	//public int [] key_action = new int [] 
-	//{ KeyCtrl,KeyAlt, 0,0,0, 0,0,0,0,0 };
-
-	/** Game timer.  Is reset to 0 at the beginning of each level, increments
-	 * with gamespeed during InGame. */
-	public double gametime=0;
-	/** Sequence timer.  Is reset to 0 at the start of the Title, Highscores,
-	* EnterHighscore, StartLevel, StartGame,
-	* LevelDone, LifeLost, GameOver sequences.  Increments with gamespeed
-	* always.  Can be used to time animations for these sequences. */
-	public double seqtimer=0;
-	/** Animation timer.  Always increments with gamespeed.
-	* Can be used to time animations etc. */
-	public double timer=0;
-	/** Player score; starts at 0 at beginning of game. */
-	public int score=0;
-	/** Difficulty level; starts at 0 at beginning of game.  Can be
-	 * incremented each time a level is complete. Can be used to determine game
-	 * difficulty settings throughout the game.  */
-	public int level=0;
-	/** Game stage, which is usually the same as level, but typically goes on
-	* counting, while level may stop increasing at a certain value.
-	* Can be used to vary graphic sets, display stage number, etc. */
-	public int stage=0;
-	/** Lives count, 0 means game over.  */
-	public int lives=0;
-	/** Initial value for lives; default=4 */
-	public int initial_lives=4;
-
-	/** Number of ticks to stay in StartLevel/StartGame state, 0 = skip */
-	public int startgame_ticks=80;
-	/** Number of ticks to stay in LevelDone state, 0 = skip */
-	public int leveldone_ticks=80;
-	/** Number of ticks to stay in LifeLost state, 0 = skip */
-	public int lifelost_ticks=80;
-	/** Number of ticks to stay in GameOver state, 0 = skip */
-	public int gameover_ticks=120;
-
-	/** Indicates whether the InGame state should be retained when in the
-	 * corresponding sequence state. */
-	public boolean startgame_ingame=false, leveldone_ingame=false,
-	               lifelost_ingame=false, gameover_ingame=false;
-
-	/** Horizontal margins to be used by status displays, default 12 pixels. */
-	public int status_l_margin=12,status_r_margin=12;
-
-	/** Font to use to display score */
-	public JGFont status_font = new JGFont("Courier",0,12);
-	/** Color to use to display score */
-	public JGColor status_color = JGColor.white;
-	/** Image to use to display lives */
-	public String lives_img = null;
-
-	/** Font to use to display title and messages */
-	public JGFont title_font = new JGFont("Courier",0,18);
-	/** Color to use to display title and messages */
-	public JGColor title_color = JGColor.white;
-	/** Color to use to display background effects behind title and messages */
-	public JGColor title_bg_color = JGColor.blue;
-
-	/** indicates that engine has just started and has not produced a single
-	 * frame. */
-	boolean just_inited=true;
-
-	/** Set the status display variables in one go. */
-	public void setStatusDisplay(JGFont status_font,JGColor status_color,
-	String lives_img) {
-		this.status_font=status_font;
-		this.status_color=status_color;
-		this.lives_img=lives_img;
-	}
-	/** Set all sequence variables in one go. */
-	public void setSequences(boolean startgame_ingame,int startgame_ticks,
-	boolean leveldone_ingame, int leveldone_ticks,
-	boolean lifelost_ingame, int lifelost_ticks,
-	boolean gameover_ingame, int gameover_ticks) {
-		this.startgame_ingame=startgame_ingame;
-		this.leveldone_ingame=leveldone_ingame;
-		this.lifelost_ingame=lifelost_ingame;
-		this.gameover_ingame=gameover_ingame;
-		this.startgame_ticks=startgame_ticks;
-		this.leveldone_ticks=leveldone_ticks;
-		this.lifelost_ticks=lifelost_ticks;
-		this.gameover_ticks=gameover_ticks;
-	}
-
-	/** Highscore table, null (default) means not defined.  Use setHighscores
-	 * to define the table. If defined, the game will handle highscores by
-	 * means of the states Highscores and EnterHighscore.  */
-	public Highscore [] highscores=null;
-
-	/** Maximum length of name typed by user. */
-	public int highscore_maxnamelen=15;
-
-	/** Player's name being entered in EnterHighscore; is reset to the empty
-	 * string before the EnterHighscore state is entered.  Is altered by
-	 * doFrameEnterHighscore. */
-	public String playername="";
-
-
-	/** Time to wait in title screen before showing highscores. */
-	public int highscore_waittime=500;
-	/** Time to show highscores before going back to title screen. */
-	public int highscore_showtime=600;
-	/** Font to use to display highscores */
-	public JGFont highscore_font = new JGFont("Courier",0,16);
-	/** Color to use to display highscores */
-	public JGColor highscore_color = JGColor.white;
-	/** Font to use to display highscore title information */
-	public JGFont highscore_title_font = new JGFont("Courier",0,16);
-	/** Color to use to display highscore title information */
-	public JGColor highscore_title_color = JGColor.white;
-	/** Title string to display above highscores */
-	public String highscore_title="Highest Scores";
-	/** String to display above highscore entry screen. */
-	public String highscore_entry="You have a high score!";
-
-
-	private YesNoDialog sound_dialog;
-
-
-	class YesNoDialog {
-		public boolean selection;
-		public boolean selected;
-	}
-
-	double [] accelzerovector = new double[] {0,0,1};
-
-	/** get accelerometer zero vector */
-	public double [] getAccelZeroVector() {
-		return accelzerovector;
-	}
-	/** get zero vector corrected acceleration vector (slow) */
-	public double [] getAccelZeroCorrected() {
-		// getAccelVec clones vector, so we do not have to copy it again
-		double [] ret = getAccelVec();
-		//for (int i=0; i<3; i++) ret[i] -= accelzerovector[i];
-		//return ret;
-		// 3D method: rotate by the difference between (0,0,1) and the
-		// accelzerovector.
-		// find rotation as axis-angle
-		// axis = normal of {0,0,1} and accelzerovector
-		// angle = angle between {0,0,1} and accelzerovector
-		double [] norm = getNormal(new double [][] {
-			accelzerovector, {0,0,0},  {0,0,1}} );
-		// norm is zero when accelzerovector coincides with {0,0,1}
-		if (length3(norm) < 0.02) return ret;
-		//System.out.println("######"+norm[0]+" "+norm[1]+" "+norm[2]);
-		double ang = atan3(accelzerovector, new double []  {0,0,1});
-		// perform rotation
-		double [][] rotm = getRotateMatrix3x3(ang,norm[0],norm[1],norm[2]);
-		return rotateVector(ret,rotm);
-	}
-
-	// 3D functions from vesselviewer.Math3D
-
-	/** Normal of two vectors given by three points, namely, P2-P1 and P1-P0
-	 * (P1 can be considered the origin).
-	* Vector is not normalised! */
-	static double [] getNormal(double [][] p) {
-		return new double [] {
-				(p[2][1]-p[1][1]) * (p[1][2]-p[0][2])
-			  - (p[2][2]-p[1][2]) * (p[1][1]-p[0][1]),
-				(p[2][2]-p[1][2]) * (p[1][0]-p[0][0])
-			  - (p[2][0]-p[1][0]) * (p[1][2]-p[0][2]),
-				(p[2][0]-p[1][0]) * (p[1][1]-p[0][1])
-			  - (p[2][1]-p[1][1]) * (p[1][0]-p[0][0]) };
-	}
-
-	// unused
-	/** get angle between vector and (0,0,1) */
-	static double atan3(double [] p) {
-		double len = length3(p);
-		if (len==0) return 0;
-		return Math.acos(p[2]/len);
-	}
-
-	/** get angle between two vectors
-	* http://www.mcasco.com/qa_ab3dv.html */
-	public static double atan3(double [] p1, double [] p2) {
-		double lenprod = length3(p1)*length3(p2);
-		if (lenprod==0) return 0;
-		double dotprod = p1[0]*p2[0] + p1[1]*p2[1] + p1[2]*p2[2];
-		return Math.acos(dotprod/lenprod);
-	}
-
-	/** Get rotate matrix openGL style (vector + angle) */
-	static double [][] getRotateMatrix3x3(double ang, double x,double y,double z){
-		double [] [] m = new double[3][3];
-		double norm = Math.sqrt(x*x + y*y + z*z);
-		x /= norm;
-		y /= norm;
-		z /= norm;
-		double c = Math.cos(ang);
-		double s = Math.sin(ang);
-		// see http://pyopengl.sourceforge.net/documentation/manual/glRotate.3G.html
-		m[0][0] = x*x*(1-c) + c;
-		m[0][1] = x*y*(1-c) - z*s;
-		m[0][2] = x*z*(1-c) + y*s;
-
-		m[1][0] = y*x*(1-c) + z*s;
-		m[1][1] = y*y*(1-c) + c;
-		m[1][2] = y*z*(1-c) - x*s;
-
-		m[2][0] = x*z*(1-c) - y*s;
-		m[2][1] = y*z*(1-c) + x*s;
-		m[2][2] = z*z*(1-c) + c;
-		return m;
-	}
-
-	public static double length3(double [] p) {
-		return Math.sqrt(p[0]*p[0] + p[1]*p[1] + p[2]*p[2]);
-	}
-
-	/** multiply vector by rotation matrix */
-	static double[] rotateVector(double [] vec, double [][] m) {
-		double [] rot = new double [3];
-		rot[0] = m[0][0]*vec[0] + m[0][1]*vec[1] + m[0][2]*vec[2];
-		rot[1] = m[1][0]*vec[0] + m[1][1]*vec[1] + m[1][2]*vec[2];
-		rot[2] = m[2][0]*vec[0] + m[2][1]*vec[1] + m[2][2]*vec[2];
-		return rot;
-	}
-
-
-
-
-
-	/** Define highscore table. */ 
-	public void setHighscores(int nr_highscores, Highscore default_hisc,
-	int maxnamelen) {
-		highscores = new Highscore [nr_highscores];
-		for (int i=0; i<nr_highscores; i++)
-			// XXX maybe clone?
-			highscores[i] = default_hisc;
-		highscore_maxnamelen=maxnamelen;
-	}
-
-	/** Set highscore display settings. */ 
-	public void setHighscoreDisplay(int waittime,int showtime, JGFont font,
-	JGColor color, String title, String entry, JGFont titlefont, JGColor titlecolor) {
-		highscore_waittime=waittime;
-		highscore_showtime=showtime;
-		highscore_font=font;
-		highscore_color=color;
-		highscore_title=title;
-		highscore_entry=entry;
-		highscore_title_font=titlefont;
-		highscore_title_color=titlecolor;
-	}
-
-	public static JGPoint parseSizeArgs(String [] args,int arg_ofs) {
-		// dummy implementation
-		return null;
-	}
-
-	/* special state functions */
-
-	/** Initialise the game when a new game is started.  Default sets level,
-	 * stage, score to 0, and lives to initial_lives. */
-	//public void initNewGame() { initNewGame(0); }
-	/** Initialise the game when a new game is started.  Default sets
-	 * stage, score to 0, and lives to initial_lives. Level is set to supplied
-	 * argument. */
-	public void initNewGame(int level_selected) {
-		level=level_selected;
-		stage=level;
-		score=0;
-		lives=initial_lives;
-	}
-	/** Initialise play specifically after a new life is introduced (that is,
-	 * at game start and after the player has died.  This is typically used to
-	 * reinitialise the player.  If you want a specific initialisation at
-	 * both the beginning of the level or after the player death, use
-	 * startInGame(). Default is do nothing. */
-	public void initNewLife() {}
-
-	/** Initialise a level.  Default is do nothing. */
-	public void defineLevel() {}
-
-	/** Code for losing a life before transition from LifeLost to InGame is
-	 * made.  Default is decrement lives.
-	 */
-	public void decrementLives() {
-		lives--;
-	}
-	/** Code for incrementing a level before transition from LevelDone to
-	* InGame is made.  Default is increment level and stage. */
-	public void incrementLevel() {
-		level++;
-		stage++;
-	}
-
-	/** Start game at level 0 */
-	public void startGame() {
-		startGame(0);
-	}
-	/** Start game at given level */
-	public void startGame(int level_selected) {
-		gametime=0;
-		initNewGame(level_selected);
-		defineLevel();
-		initNewLife();
-		// code duplicated in levelDone
-		clearKey(key_continuegame);
-		seqtimer=0;
-		if (startgame_ticks > 0) {
-			setGameState("StartLevel");
-			addGameState("StartGame");
-			if (startgame_ingame) addGameState("InGame");
-			new JGTimer(startgame_ticks,true,"StartLevel") {
-				public void alarm() { setGameState("InGame"); } };
-		} else {
-			setGameState("InGame");
-		}
-	}
-
-	/* state transition functions */
-
-	/** Call to make state transition to LifeLost.  Is ignored when in
-	 * another state than InGame or {InGame,StartLevel/StartGame}.
-	 * After the LifeLost
-	 * sequence, goes to InGame or GameOver, depending on lives left. */
-	public final void lifeLost() {
-		if (!inGameState("InGame") || inGameState("LevelDone")
-		|| inGameState("LifeLost") || inGameState("GameOver") ) return;
-		//	System.err.println(
-		//	"Warning: lifeLost() called from other state than InGame." );
-		//}
-		clearKey(key_continuegame);
-		removeGameState("StartLevel");
-		removeGameState("StartGame");
-		seqtimer=0;
-		if (lifelost_ticks > 0) {
-			if (lifelost_ingame) addGameState("LifeLost");
-			else                 setGameState("LifeLost");
-			new JGTimer(lifelost_ticks,true,"LifeLost") { public void alarm() {
-				endLifeLost();
-			} };
-		} else {
-			endLifeLost();
-		}
-	}
-	private void endLifeLost() {
-		clearKey(key_continuegame);
-		decrementLives();
-		if (lives <= 0) {
-			gameOver();
-		} else {
-			initNewLife();
-			seqtimer=0;
-			if (startgame_ticks > 0) {
-				// force call to startInGame()
-				setGameState("StartGame");
-				if (startgame_ingame) addGameState("InGame");
-				new JGTimer(startgame_ticks,true,"StartGame") {
-					public void alarm() { setGameState("InGame"); } };
-			} else {
-				// force call to startInGame()
-				clearGameState();
-				setGameState("InGame");
-			}
-		}
-	}
-	/** Call to make state transition to LevelDone.  Is ignored when state is
-	 * not InGame or {Ingame,StartLevel/StartGame}. After the LevelDone
-	 * sequence, it sets gametime to 0, calls
-	 * incrementLevel and defineLevel, and goes to StartLevel/StartGame. */
-	public final void levelDone() {
-		if (!inGameState("InGame") || inGameState("LevelDone")
-		|| inGameState("LifeLost") || inGameState("GameOver") ) return;
-		//	System.err.println(
-		//	"Warning: levelDone() called from other state than InGame." );
-		//}
-		clearKey(key_continuegame);
-		removeGameState("StartLevel");
-		removeGameState("StartGame");
-		seqtimer=0;
-		if (leveldone_ticks > 0) {
-			if (leveldone_ingame) addGameState("LevelDone");
-			else                  setGameState("LevelDone");
-			new JGTimer(leveldone_ticks,true,"LevelDone") {public void alarm() {
-				levelDoneToStartLevel();
-			} };
-		} else {
-			levelDoneToStartLevel();
-		}
-	}
-	private void levelDoneToStartLevel() {
-		clearKey(key_continuegame);
-		gametime=0;
-		incrementLevel();
-		defineLevel();
-		seqtimer=0;
-		if (startgame_ticks > 0) {
-			// force call to startInGame
-			setGameState("StartLevel");
-			addGameState("StartGame");
-			if (startgame_ingame) addGameState("InGame");
-			new JGTimer(startgame_ticks,true,"StartLevel") {
-				public void alarm() { setGameState("InGame"); } };
-		} else {
-			// force call to startInGame
-			clearGameState();
-			setGameState("InGame");
-		}
-	}
-	/** Call to make straight transition to GameOver; is called automatically
-	* by lifeLost when appropriate.  Is ignored when game state is not
-	* {InGame}, {Ingame,Start*}, or LifeLost.  Will go to Title after GameOver
-	* sequence.
-	*/
-	public final void gameOver() {
-		// XXX hmm. we should check out these conditions
-		if ( inGameState("GameOver")
-		||  (!inGameState("InGame") && !inGameState("LifeLost")) ) return;
-		//	System.err.println( "Warning: gameOver() called from other state"
-		//		+" than InGame or LifeLost." );
-		//}
-		clearKey(key_continuegame);
-		removeGameState("StartLevel");
-		removeGameState("StartGame");
-		removeGameState("LifeLost");
-		seqtimer=0;
-		if (gameover_ticks > 0) {
-			if (gameover_ingame) addGameState("GameOver");
-			else                 setGameState("GameOver");
-			new JGTimer(gameover_ticks,true,"GameOver") {
-				public void alarm() { gotoTitle(); } };
-		} else {
-			gotoTitle();
-		}
-	}
-	/** Go to title or to highscore entry screen. */
-	private void gotoTitle() {
-		seqtimer=0;
-		clearKey(key_startgame);
-		// disabled until highscores are functional
-		//if (highscores!=null
-		//&&  Highscore.findPos(highscores,score)>=0 ) {
-		//	setGameState("EnterHighscore");
-		//} else {
-			setGameState("Title");
-		//}
-	}
-
-	/* initAppConfig not implemented */
-
-	/** The main doFrame takes care of all the standard game actions.  If you
-	* override it, you should typically call super.doFrame().  doFrame
-	* increments timer, increments gametime when in InGame, quits game when
-	* key_quitgame is pressed in InGame. In Title, it waits for the user to
-	* press the key_startgame, then sets gametime to 0, calls initNewGame,
-	* defineLevel, and goes to StartLevel. It also handles the continue_game
-	* key inside the sequences, and the gamesettings and quitprogram keys in
-	* Title.  It also ensures the audioenabled flag is passed to engine. */
-	public void doFrame() {
-		// pass audioenabled
-		//if (sound_dialog!=null && sound_dialog.selected) {
-		//	audioenabled = sound_dialog.selection;
-		//}
-		if (audioenabled) { enableAudio(); } else { disableAudio(); }
-		// handle pause mode
-		if (inGameState("Paused")) {
-			clearKey(key_pausegame);
-			// stop and remove game state on the next frame
-			removeGameState("Paused");
-			stop();
-		}
-		if (getKey(key_pausegame) && !inGameState("EnterHighscore")) {
-			addGameState("Paused");
-			clearKey(key_pausegame);
-			wakeUpOnKey(key_pausegame);
-		}
-		// handle general actions
-		timer += getGameSpeed();
-		seqtimer += getGameSpeed();
-		if (just_inited) {
-			if (audio_dialog_at_startup) {
-				canvas.post(new Runnable() {
-					public void run() {
-						currentact.showDialog(0);
-					}
-				});
-			} else {
-				audioenabled=true;
-			}
-			//sound_dialog=new YesNoDialog(this,"Sound Options","Enable Sound?");
-			//Display.getDisplay(this).setCurrent(sound_dialog.yesNoAlert);
-
-			setGameState("Title");
-			just_inited=false;
-			// init appconfig not implemented
-			// load highscores
-			//try {
-				// we don't load highscores yet
-				//Highscore [] loadedhisc = Highscore.load(new FileInputStream(
-				//		getConfigPath(getClass().getName()+".hsc") ) );
-				//if (loadedhisc.length > 0) { // empty file, ignore
-				//	highscores=loadedhisc;
-				//}
-			//} catch (Exception e) {
-				//do nothing, keep old highscores (which should be the
-				//default highscores)
-			//}
-		} else if (inGameState("InGame")) {
-			gametime+=getGameSpeed();
-			if (getKey(key_quitgame)) gameOver();
-		} else if (inGameState("Title")||inGameState("Highscores")) {
-			if (getKey(key_quitprogram) && !isApplet()) {
-				clearKey(key_quitprogram);
-				exitEngine(null);
-			}
-			//if (getKey(key_gamesettings) ) { //&& appconfig!=null) {
-				//appconfig.openGui();
-				//clearKey(key_gamesettings);
- 				//pause application until config window is closed
-				//appconfig.waitCloseGui();
-				//stop();
-			//}
-			if (getKey(key_startgame)) {
-				startGame();
-			}
-			// disabled until highscores are functional
-			//if (highscores!=null) {
-			//	if (getKey(key_continuegame)) {
-			//		clearKey(key_continuegame);
-			//		seqtimer=0;
-			//		if (inGameState("Title")) setGameState("Highscores");
-			//		else                      setGameState("Title");
-			//	}
-			//	if (inGameState("Title") && seqtimer>=highscore_waittime) {
-			//		seqtimer=0;
-			//		setGameState("Highscores");
-			//	} else
-			//	if (inGameState("Highscores") && seqtimer>=highscore_showtime) {
-			//		seqtimer=0;
-			//		setGameState("Title");
-			//	}
-			//}
-		} else if (inGameState("StartGame")) {
-			if (getKey(key_continuegame)) setGameState("InGame");
-		} else if (inGameState("LevelDone")) {
-			if (getKey(key_continuegame)) levelDoneToStartLevel();
-		} else if (inGameState("LifeLost")) {
-			if (getKey(key_continuegame)) endLifeLost();
-		} else if (inGameState("GameOver")) {
-			if (getKey(key_continuegame)) gotoTitle();
-		}
-	}
 
-	/* default doFrame... actions; note we still have to define the others.*/
+import jgame.Highscore;
+import jgame.JGColor;
+import jgame.JGFont;
+import jgame.JGPoint;
+import jgame.JGTimer;
+
+/**
+ * A basic framework for a game.  It supports an animation and game timer,
+ * object creation at fixed intervals, score, lives, levels, configurable keys.
+ * There are title, start-level, next-level, death, and game-over sequences.
+ * Todo: highscores, key configuration file and GUI.
+ *
+ * <p>To initialise this class, use the regular initEngine (from main), or
+ * initEngineApplet (from parameterless constructor).  You can supply the width
+ * and height of the window as command line arguments by calling
+ * parseSizeArgs(args) from your main().  Define initGame() as usual.  StdGame
+ * does all its logic in the doFrame method, so you should ensure that it is
+ * called (i.e. call super.doFrame() if you choose to override doFrame).  The
+ * game will automatically start in the "Title" gamestate when it finds that
+ * it isn't in this state in the first call to doFrame().  You can also set the
+ * "Title" state in initGame if you even want the first frame to be in
+ * "Title".
+ *
+ * <p>The class uses the following state machine, using JGEngine's state
+ * machine mechanism:
+ *
+ * <p><i>Title</i>: displays title screen.  Transition to
+ * {StartLevel,StartGame} when the key_startgame is pressed.  Before the
+ * transition, initNewGame(), defineLevel(), and initNewLife() are called.
+ *
+ * <p><i>InGame</i>: game is playing.  Transition to LifeLost when lifeLost()
+ * is called from within the game.  Transition to LevelDone when levelDone() is
+ * called from within the game.  Transition to GameOver when gameOver() is
+ * called (i.e. to quit game).  The gametime timer indicates how many ticks the
+ * game has been running since the beginning of the level.
+ *
+ * <p>StdGame supports a set of standard game sequences, which are represented
+ * as game states: StartLevel/StartGame, LevelDone, LifeLost, GameOver.  These
+ * can be configured so they add the InGame state to the sequence state (i.e.
+ * the game is in both states simultaneously).  This can be used to animate the
+ * game while playing the corresponding sequence.  This is off by default.  The
+ * seqtimer timer is set to 0 at the beginning of each sequence, and increments
+ * during the sequence to indicate how many ticks the sequence has been
+ * playing.  The number of ticks that the sequence should take can be
+ * configured, or the sequence can be skipped altogether by setting ticks to 0.
+ *
+ * <p><i>StartGame</i>: start game sequence is played.  Transition to InGame
+ * after a certain time has elapsed or the continuegame key is pressed.
+ *
+ * <p><i>StartLevel</i>: start level sequence is played.  Transition to InGame
+ * after a certain time has elapsed or the continuegame key is pressed.  Is always
+ * active in combination with StartGame; it's just an indication that StartGame
+ * is also a start of a new level.
+ *
+ * <p><i>LevelDone</i>: next level sequence is played.  Transition to
+ * StartLevel/StartGame after a certain time has elapsed or the continuegame key
+ * is pressed.  Before the transition, resp. incrementLevel() and defineLevel()
+ * are called.
+ *
+ * <p><i>LifeLost</i>:  player has just died, a death sequence is played.
+ * Transition to either GameOver or StartGame after a certain time has elapsed
+ * or the continuegame key is pressed, dependent of whether there are lives left.
+ * Before the transition to StartGame, decrementLives() and initNewLife are
+ * called.
+ *
+ * <p><i>GameOver</i>: game over sequence is played.  Transition to Title after
+ * a certain time or the continuegame key is pressed.
+ *
+ * <p>Built in are also game exit (through the key_quitgame, which is Escape by
+ * default), pause game (through the key_pausegame, which defaults to 'P'), and
+ * program exit (key_quitprogram, default Escape).
+ */
+public abstract class StdGame extends JGEngine {
 
-	/** Default lets user type name into the variable playername.  If enter is
-	* pressed, highscore is put in table and saved to disk.
-	*/
-	public void doFrameEnterHighscore() {
+    // XXX can levelDone and lifeLost be triggered simultaneously? (ramjet)
+
+    /* settings */
+
+    /**
+     * Flag indicating that audio is enabled
+     */
+    public boolean audioenabled = false;
+
+    /**
+     * Flag indicating that sound enable dialog should be shown at startup
+     */
+    public boolean audio_dialog_at_startup = true;
+
+    /**
+     * flag indicating that accelerometer set zero point menu should be
+     * active.
+     */
+    public boolean accel_set_zero_menu = false;
+
+    /**
+     * Key for starting the game, default = space.
+     */
+    public int key_startgame = ' ';
+    /**
+     * Key for invoking the game settings window, default = enter.
+     */
+    public int key_gamesettings = KeyEnter;
+    /**
+     * Key for continuing the game when in a sequence, default = space.
+     */
+    public int key_continuegame = ' ';
+    /**
+     * Key for quitting the current game, default = escape.
+     */
+    public int key_quitgame = KeyEsc;
+    /**
+     * Key for quitting the program, default = escape.
+     */
+    public int key_quitprogram = KeyEsc;
+    /**
+     * Key for pausing the game, default = P.
+     */
+    public int key_pausegame = 'P';
+    /**
+     * Key for moving, default = cursors. NOTE: not all Android physical
+     * keyboards have cursor keys
+     */
+    public int key_left = KeyLeft, key_right = KeyRight,
+            key_up = KeyUp, key_down = KeyDown;
+    /** Key for moving diagonally, default = none. */
+    //public int key_upleft=0, key_downleft=0,
+    //           key_upright=0, key_downright=0;
+    /**
+     * Key for firing (in case there are no separate directional fire keys),
+     * default=Z.
+     */
+    public int key_fire = 'Z';
+    /**
+     * Key for directional firing, default = WSAD keys
+     */
+    public int key_fireleft = 'A', key_fireright = 'D',
+            key_fireup = 'W', key_firedown = 'S';
+    /**
+     * Key for special action, default=X
+     */
+    public int key_action = 'X';
+    /** Key for diagonal firing, default = none */
+    //public int key_fireupleft =0, key_firedownleft=0,
+    //           key_fireupright=0, key_firedownright=0;
+    /** Keys for special actions.  Default = action[0]=ctrl, action[1]=alt */
+    //public int [] key_action = new int []
+    //{ KeyCtrl,KeyAlt, 0,0,0, 0,0,0,0,0 };
+
+    /**
+     * Game timer.  Is reset to 0 at the beginning of each level, increments
+     * with gamespeed during InGame.
+     */
+    public double gametime = 0;
+    /**
+     * Sequence timer.  Is reset to 0 at the start of the Title, Highscores,
+     * EnterHighscore, StartLevel, StartGame,
+     * LevelDone, LifeLost, GameOver sequences.  Increments with gamespeed
+     * always.  Can be used to time animations for these sequences.
+     */
+    public double seqtimer = 0;
+    /**
+     * Animation timer.  Always increments with gamespeed.
+     * Can be used to time animations etc.
+     */
+    public double timer = 0;
+    /**
+     * Player score; starts at 0 at beginning of game.
+     */
+    public int score = 0;
+    /**
+     * Difficulty level; starts at 0 at beginning of game.  Can be
+     * incremented each time a level is complete. Can be used to determine game
+     * difficulty settings throughout the game.
+     */
+    public int level = 0;
+    /**
+     * Game stage, which is usually the same as level, but typically goes on
+     * counting, while level may stop increasing at a certain value.
+     * Can be used to vary graphic sets, display stage number, etc.
+     */
+    public int stage = 0;
+    /**
+     * Lives count, 0 means game over.
+     */
+    public int lives = 0;
+    /**
+     * Initial value for lives; default=4
+     */
+    public int initial_lives = 4;
+
+    /**
+     * Number of ticks to stay in StartLevel/StartGame state, 0 = skip
+     */
+    public int startgame_ticks = 80;
+    /**
+     * Number of ticks to stay in LevelDone state, 0 = skip
+     */
+    public int leveldone_ticks = 80;
+    /**
+     * Number of ticks to stay in LifeLost state, 0 = skip
+     */
+    public int lifelost_ticks = 80;
+    /**
+     * Number of ticks to stay in GameOver state, 0 = skip
+     */
+    public int gameover_ticks = 120;
+
+    /**
+     * Indicates whether the InGame state should be retained when in the
+     * corresponding sequence state.
+     */
+    public boolean startgame_ingame = false, leveldone_ingame = false,
+            lifelost_ingame = false, gameover_ingame = false;
+
+    /**
+     * Horizontal margins to be used by status displays, default 12 pixels.
+     */
+    public int status_l_margin = 12, status_r_margin = 12;
+
+    /**
+     * Font to use to display score
+     */
+    public JGFont status_font = new JGFont("Courier", 0, 12);
+    /**
+     * Color to use to display score
+     */
+    public JGColor status_color = JGColor.white;
+    /**
+     * Image to use to display lives
+     */
+    public String lives_img = null;
+
+    /**
+     * Font to use to display title and messages
+     */
+    public JGFont title_font = new JGFont("Courier", 0, 18);
+    /**
+     * Color to use to display title and messages
+     */
+    public JGColor title_color = JGColor.white;
+    /**
+     * Color to use to display background effects behind title and messages
+     */
+    public JGColor title_bg_color = JGColor.blue;
+
+    /**
+     * indicates that engine has just started and has not produced a single
+     * frame.
+     */
+    boolean just_inited = true;
+
+    /**
+     * Set the status display variables in one go.
+     */
+    public void setStatusDisplay(JGFont status_font, JGColor status_color,
+                                 String lives_img) {
+        this.status_font = status_font;
+        this.status_color = status_color;
+        this.lives_img = lives_img;
+    }
+
+    /**
+     * Set all sequence variables in one go.
+     */
+    public void setSequences(boolean startgame_ingame, int startgame_ticks,
+                             boolean leveldone_ingame, int leveldone_ticks,
+                             boolean lifelost_ingame, int lifelost_ticks,
+                             boolean gameover_ingame, int gameover_ticks) {
+        this.startgame_ingame = startgame_ingame;
+        this.leveldone_ingame = leveldone_ingame;
+        this.lifelost_ingame = lifelost_ingame;
+        this.gameover_ingame = gameover_ingame;
+        this.startgame_ticks = startgame_ticks;
+        this.leveldone_ticks = leveldone_ticks;
+        this.lifelost_ticks = lifelost_ticks;
+        this.gameover_ticks = gameover_ticks;
+    }
+
+    /**
+     * Highscore table, null (default) means not defined.  Use setHighscores
+     * to define the table. If defined, the game will handle highscores by
+     * means of the states Highscores and EnterHighscore.
+     */
+    public Highscore[] highscores = null;
+
+    /**
+     * Maximum length of name typed by user.
+     */
+    public int highscore_maxnamelen = 15;
+
+    /**
+     * Player's name being entered in EnterHighscore; is reset to the empty
+     * string before the EnterHighscore state is entered.  Is altered by
+     * doFrameEnterHighscore.
+     */
+    public String playername = "";
+
+
+    /**
+     * Time to wait in title screen before showing highscores.
+     */
+    public int highscore_waittime = 500;
+    /**
+     * Time to show highscores before going back to title screen.
+     */
+    public int highscore_showtime = 600;
+    /**
+     * Font to use to display highscores
+     */
+    public JGFont highscore_font = new JGFont("Courier", 0, 16);
+    /**
+     * Color to use to display highscores
+     */
+    public JGColor highscore_color = JGColor.white;
+    /**
+     * Font to use to display highscore title information
+     */
+    public JGFont highscore_title_font = new JGFont("Courier", 0, 16);
+    /**
+     * Color to use to display highscore title information
+     */
+    public JGColor highscore_title_color = JGColor.white;
+    /**
+     * Title string to display above highscores
+     */
+    public String highscore_title = "Highest Scores";
+    /**
+     * String to display above highscore entry screen.
+     */
+    public String highscore_entry = "You have a high score!";
+
+
+    private YesNoDialog sound_dialog;
+
+
+    class YesNoDialog {
+        public boolean selection;
+        public boolean selected;
+    }
+
+    double[] accelzerovector = new double[]{0, 0, 1};
+
+    /**
+     * get accelerometer zero vector
+     */
+    public double[] getAccelZeroVector() {
+        return accelzerovector;
+    }
+
+    /**
+     * get zero vector corrected acceleration vector (slow)
+     */
+    public double[] getAccelZeroCorrected() {
+        // getAccelVec clones vector, so we do not have to copy it again
+        double[] ret = getAccelVec();
+        //for (int i=0; i<3; i++) ret[i] -= accelzerovector[i];
+        //return ret;
+        // 3D method: rotate by the difference between (0,0,1) and the
+        // accelzerovector.
+        // find rotation as axis-angle
+        // axis = normal of {0,0,1} and accelzerovector
+        // angle = angle between {0,0,1} and accelzerovector
+        double[] norm = getNormal(new double[][]{
+                accelzerovector, {0, 0, 0}, {0, 0, 1}});
+        // norm is zero when accelzerovector coincides with {0,0,1}
+        if (length3(norm) < 0.02) return ret;
+        //System.out.println("######"+norm[0]+" "+norm[1]+" "+norm[2]);
+        double ang = atan3(accelzerovector, new double[]{0, 0, 1});
+        // perform rotation
+        double[][] rotm = getRotateMatrix3x3(ang, norm[0], norm[1], norm[2]);
+        return rotateVector(ret, rotm);
+    }
+
+    // 3D functions from vesselviewer.Math3D
+
+    /**
+     * Normal of two vectors given by three points, namely, P2-P1 and P1-P0
+     * (P1 can be considered the origin).
+     * Vector is not normalised!
+     */
+    static double[] getNormal(double[][] p) {
+        return new double[]{
+                (p[2][1] - p[1][1]) * (p[1][2] - p[0][2])
+                        - (p[2][2] - p[1][2]) * (p[1][1] - p[0][1]),
+                (p[2][2] - p[1][2]) * (p[1][0] - p[0][0])
+                        - (p[2][0] - p[1][0]) * (p[1][2] - p[0][2]),
+                (p[2][0] - p[1][0]) * (p[1][1] - p[0][1])
+                        - (p[2][1] - p[1][1]) * (p[1][0] - p[0][0])};
+    }
+
+    // unused
+
+    /**
+     * get angle between vector and (0,0,1)
+     */
+    static double atan3(double[] p) {
+        double len = length3(p);
+        if (len == 0) return 0;
+        return Math.acos(p[2] / len);
+    }
+
+    /**
+     * get angle between two vectors
+     * http://www.mcasco.com/qa_ab3dv.html
+     */
+    public static double atan3(double[] p1, double[] p2) {
+        double lenprod = length3(p1) * length3(p2);
+        if (lenprod == 0) return 0;
+        double dotprod = p1[0] * p2[0] + p1[1] * p2[1] + p1[2] * p2[2];
+        return Math.acos(dotprod / lenprod);
+    }
+
+    /**
+     * Get rotate matrix openGL style (vector + angle)
+     */
+    static double[][] getRotateMatrix3x3(double ang, double x, double y, double z) {
+        double[][] m = new double[3][3];
+        double norm = Math.sqrt(x * x + y * y + z * z);
+        x /= norm;
+        y /= norm;
+        z /= norm;
+        double c = Math.cos(ang);
+        double s = Math.sin(ang);
+        // see http://pyopengl.sourceforge.net/documentation/manual/glRotate.3G.html
+        m[0][0] = x * x * (1 - c) + c;
+        m[0][1] = x * y * (1 - c) - z * s;
+        m[0][2] = x * z * (1 - c) + y * s;
+
+        m[1][0] = y * x * (1 - c) + z * s;
+        m[1][1] = y * y * (1 - c) + c;
+        m[1][2] = y * z * (1 - c) - x * s;
+
+        m[2][0] = x * z * (1 - c) - y * s;
+        m[2][1] = y * z * (1 - c) + x * s;
+        m[2][2] = z * z * (1 - c) + c;
+        return m;
+    }
+
+    public static double length3(double[] p) {
+        return Math.sqrt(p[0] * p[0] + p[1] * p[1] + p[2] * p[2]);
+    }
+
+    /**
+     * multiply vector by rotation matrix
+     */
+    static double[] rotateVector(double[] vec, double[][] m) {
+        double[] rot = new double[3];
+        rot[0] = m[0][0] * vec[0] + m[0][1] * vec[1] + m[0][2] * vec[2];
+        rot[1] = m[1][0] * vec[0] + m[1][1] * vec[1] + m[1][2] * vec[2];
+        rot[2] = m[2][0] * vec[0] + m[2][1] * vec[1] + m[2][2] * vec[2];
+        return rot;
+    }
+
+
+    /**
+     * Define highscore table.
+     */
+    public void setHighscores(int nr_highscores, Highscore default_hisc,
+                              int maxnamelen) {
+        highscores = new Highscore[nr_highscores];
+        for (int i = 0; i < nr_highscores; i++)
+            // XXX maybe clone?
+            highscores[i] = default_hisc;
+        highscore_maxnamelen = maxnamelen;
+    }
+
+    /**
+     * Set highscore display settings.
+     */
+    public void setHighscoreDisplay(int waittime, int showtime, JGFont font,
+                                    JGColor color, String title, String entry, JGFont titlefont, JGColor titlecolor) {
+        highscore_waittime = waittime;
+        highscore_showtime = showtime;
+        highscore_font = font;
+        highscore_color = color;
+        highscore_title = title;
+        highscore_entry = entry;
+        highscore_title_font = titlefont;
+        highscore_title_color = titlecolor;
+    }
+
+    public static JGPoint parseSizeArgs(String[] args, int arg_ofs) {
+        // dummy implementation
+        return null;
+    }
+
+    /* special state functions */
+
+    /** Initialise the game when a new game is started.  Default sets level,
+     * stage, score to 0, and lives to initial_lives. */
+    //public void initNewGame() { initNewGame(0); }
+
+    /**
+     * Initialise the game when a new game is started.  Default sets
+     * stage, score to 0, and lives to initial_lives. Level is set to supplied
+     * argument.
+     */
+    public void initNewGame(int level_selected) {
+        level = level_selected;
+        stage = level;
+        score = 0;
+        lives = initial_lives;
+    }
+
+    /**
+     * Initialise play specifically after a new life is introduced (that is,
+     * at game start and after the player has died.  This is typically used to
+     * reinitialise the player.  If you want a specific initialisation at
+     * both the beginning of the level or after the player death, use
+     * startInGame(). Default is do nothing.
+     */
+    public void initNewLife() {
+    }
+
+    /**
+     * Initialise a level.  Default is do nothing.
+     */
+    public void defineLevel() {
+    }
+
+    /**
+     * Code for losing a life before transition from LifeLost to InGame is
+     * made.  Default is decrement lives.
+     */
+    public void decrementLives() {
+        lives--;
+    }
+
+    /**
+     * Code for incrementing a level before transition from LevelDone to
+     * InGame is made.  Default is increment level and stage.
+     */
+    public void incrementLevel() {
+        level++;
+        stage++;
+    }
+
+    /**
+     * Start game at level 0
+     */
+    public void startGame() {
+        startGame(0);
+    }
+
+    /**
+     * Start game at given level
+     */
+    public void startGame(int level_selected) {
+        gametime = 0;
+        initNewGame(level_selected);
+        defineLevel();
+        initNewLife();
+        // code duplicated in levelDone
+        clearKey(key_continuegame);
+        seqtimer = 0;
+        if (startgame_ticks > 0) {
+            setGameState("StartLevel");
+            addGameState("StartGame");
+            if (startgame_ingame) addGameState("InGame");
+            new JGTimer(startgame_ticks, true, "StartLevel") {
+                public void alarm() {
+                    setGameState("InGame");
+                }
+            };
+        } else {
+            setGameState("InGame");
+        }
+    }
+
+    /* state transition functions */
+
+    /**
+     * Call to make state transition to LifeLost.  Is ignored when in
+     * another state than InGame or {InGame,StartLevel/StartGame}.
+     * After the LifeLost
+     * sequence, goes to InGame or GameOver, depending on lives left.
+     */
+    public final void lifeLost() {
+        if (!inGameState("InGame") || inGameState("LevelDone")
+                || inGameState("LifeLost") || inGameState("GameOver")) return;
+        //	System.err.println(
+        //	"Warning: lifeLost() called from other state than InGame." );
+        //}
+        clearKey(key_continuegame);
+        removeGameState("StartLevel");
+        removeGameState("StartGame");
+        seqtimer = 0;
+        if (lifelost_ticks > 0) {
+            if (lifelost_ingame) addGameState("LifeLost");
+            else setGameState("LifeLost");
+            new JGTimer(lifelost_ticks, true, "LifeLost") {
+                public void alarm() {
+                    endLifeLost();
+                }
+            };
+        } else {
+            endLifeLost();
+        }
+    }
+
+    private void endLifeLost() {
+        clearKey(key_continuegame);
+        decrementLives();
+        if (lives <= 0) {
+            gameOver();
+        } else {
+            initNewLife();
+            seqtimer = 0;
+            if (startgame_ticks > 0) {
+                // force call to startInGame()
+                setGameState("StartGame");
+                if (startgame_ingame) addGameState("InGame");
+                new JGTimer(startgame_ticks, true, "StartGame") {
+                    public void alarm() {
+                        setGameState("InGame");
+                    }
+                };
+            } else {
+                // force call to startInGame()
+                clearGameState();
+                setGameState("InGame");
+            }
+        }
+    }
+
+    /**
+     * Call to make state transition to LevelDone.  Is ignored when state is
+     * not InGame or {Ingame,StartLevel/StartGame}. After the LevelDone
+     * sequence, it sets gametime to 0, calls
+     * incrementLevel and defineLevel, and goes to StartLevel/StartGame.
+     */
+    public final void levelDone() {
+        if (!inGameState("InGame") || inGameState("LevelDone")
+                || inGameState("LifeLost") || inGameState("GameOver")) return;
+        //	System.err.println(
+        //	"Warning: levelDone() called from other state than InGame." );
+        //}
+        clearKey(key_continuegame);
+        removeGameState("StartLevel");
+        removeGameState("StartGame");
+        seqtimer = 0;
+        if (leveldone_ticks > 0) {
+            if (leveldone_ingame) addGameState("LevelDone");
+            else setGameState("LevelDone");
+            new JGTimer(leveldone_ticks, true, "LevelDone") {
+                public void alarm() {
+                    levelDoneToStartLevel();
+                }
+            };
+        } else {
+            levelDoneToStartLevel();
+        }
+    }
+
+    private void levelDoneToStartLevel() {
+        clearKey(key_continuegame);
+        gametime = 0;
+        incrementLevel();
+        defineLevel();
+        seqtimer = 0;
+        if (startgame_ticks > 0) {
+            // force call to startInGame
+            setGameState("StartLevel");
+            addGameState("StartGame");
+            if (startgame_ingame) addGameState("InGame");
+            new JGTimer(startgame_ticks, true, "StartLevel") {
+                public void alarm() {
+                    setGameState("InGame");
+                }
+            };
+        } else {
+            // force call to startInGame
+            clearGameState();
+            setGameState("InGame");
+        }
+    }
+
+    /**
+     * Call to make straight transition to GameOver; is called automatically
+     * by lifeLost when appropriate.  Is ignored when game state is not
+     * {InGame}, {Ingame,Start*}, or LifeLost.  Will go to Title after GameOver
+     * sequence.
+     */
+    public final void gameOver() {
+        // XXX hmm. we should check out these conditions
+        if (inGameState("GameOver")
+                || (!inGameState("InGame") && !inGameState("LifeLost"))) return;
+        //	System.err.println( "Warning: gameOver() called from other state"
+        //		+" than InGame or LifeLost." );
+        //}
+        clearKey(key_continuegame);
+        removeGameState("StartLevel");
+        removeGameState("StartGame");
+        removeGameState("LifeLost");
+        seqtimer = 0;
+        if (gameover_ticks > 0) {
+            if (gameover_ingame) addGameState("GameOver");
+            else setGameState("GameOver");
+            new JGTimer(gameover_ticks, true, "GameOver") {
+                public void alarm() {
+                    gotoTitle();
+                }
+            };
+        } else {
+            gotoTitle();
+        }
+    }
+
+    /**
+     * Go to title or to highscore entry screen.
+     */
+    private void gotoTitle() {
+        seqtimer = 0;
+        clearKey(key_startgame);
+        // disabled until highscores are functional
+        //if (highscores!=null
+        //&&  Highscore.findPos(highscores,score)>=0 ) {
+        //	setGameState("EnterHighscore");
+        //} else {
+        setGameState("Title");
+        //}
+    }
+
+    /* initAppConfig not implemented */
+
+    /**
+     * The main doFrame takes care of all the standard game actions.  If you
+     * override it, you should typically call super.doFrame().  doFrame
+     * increments timer, increments gametime when in InGame, quits game when
+     * key_quitgame is pressed in InGame. In Title, it waits for the user to
+     * press the key_startgame, then sets gametime to 0, calls initNewGame,
+     * defineLevel, and goes to StartLevel. It also handles the continue_game
+     * key inside the sequences, and the gamesettings and quitprogram keys in
+     * Title.  It also ensures the audioenabled flag is passed to engine.
+     */
+    public void doFrame() {
+        // pass audioenabled
+        //if (sound_dialog!=null && sound_dialog.selected) {
+        //	audioenabled = sound_dialog.selection;
+        //}
+        if (audioenabled) {
+            enableAudio();
+        } else {
+            disableAudio();
+        }
+        // handle pause mode
+        if (inGameState("Paused")) {
+            clearKey(key_pausegame);
+            // stop and remove game state on the next frame
+            removeGameState("Paused");
+            stop();
+        }
+        if (getKey(key_pausegame) && !inGameState("EnterHighscore")) {
+            addGameState("Paused");
+            clearKey(key_pausegame);
+            wakeUpOnKey(key_pausegame);
+        }
+        // handle general actions
+        timer += getGameSpeed();
+        seqtimer += getGameSpeed();
+        if (just_inited) {
+            if (audio_dialog_at_startup) {
+                canvas.post(new Runnable() {
+                    public void run() {
+                        currentact.showDialog(0);
+                    }
+                });
+            } else {
+                audioenabled = true;
+            }
+            //sound_dialog=new YesNoDialog(this,"Sound Options","Enable Sound?");
+            //Display.getDisplay(this).setCurrent(sound_dialog.yesNoAlert);
+
+            setGameState("Title");
+            just_inited = false;
+            // init appconfig not implemented
+            // load highscores
+            //try {
+            // we don't load highscores yet
+            //Highscore [] loadedhisc = Highscore.load(new FileInputStream(
+            //		getConfigPath(getClass().getName()+".hsc") ) );
+            //if (loadedhisc.length > 0) { // empty file, ignore
+            //	highscores=loadedhisc;
+            //}
+            //} catch (Exception e) {
+            //do nothing, keep old highscores (which should be the
+            //default highscores)
+            //}
+        } else if (inGameState("InGame")) {
+            gametime += getGameSpeed();
+            if (getKey(key_quitgame)) gameOver();
+        } else if (inGameState("Title") || inGameState("Highscores")) {
+            if (getKey(key_quitprogram) && !isApplet()) {
+                clearKey(key_quitprogram);
+                exitEngine(null);
+            }
+            //if (getKey(key_gamesettings) ) { //&& appconfig!=null) {
+            //appconfig.openGui();
+            //clearKey(key_gamesettings);
+            //pause application until config window is closed
+            //appconfig.waitCloseGui();
+            //stop();
+            //}
+            if (getKey(key_startgame)) {
+                startGame();
+            }
+            // disabled until highscores are functional
+            //if (highscores!=null) {
+            //	if (getKey(key_continuegame)) {
+            //		clearKey(key_continuegame);
+            //		seqtimer=0;
+            //		if (inGameState("Title")) setGameState("Highscores");
+            //		else                      setGameState("Title");
+            //	}
+            //	if (inGameState("Title") && seqtimer>=highscore_waittime) {
+            //		seqtimer=0;
+            //		setGameState("Highscores");
+            //	} else
+            //	if (inGameState("Highscores") && seqtimer>=highscore_showtime) {
+            //		seqtimer=0;
+            //		setGameState("Title");
+            //	}
+            //}
+        } else if (inGameState("StartGame")) {
+            if (getKey(key_continuegame)) setGameState("InGame");
+        } else if (inGameState("LevelDone")) {
+            if (getKey(key_continuegame)) levelDoneToStartLevel();
+        } else if (inGameState("LifeLost")) {
+            if (getKey(key_continuegame)) endLifeLost();
+        } else if (inGameState("GameOver")) {
+            if (getKey(key_continuegame)) gotoTitle();
+        }
+    }
+
+    /* default doFrame... actions; note we still have to define the others.*/
+
+    /**
+     * Default lets user type name into the variable playername.  If enter is
+     * pressed, highscore is put in table and saved to disk.
+     */
+    public void doFrameEnterHighscore() {
 		/* this method needs to be replaced.
 		char key = getLastKeyChar();
 		clearLastKey();
@@ -688,238 +859,308 @@ public abstract class StdGame extends JGEngine {
 		if (key>=32 && key<127 && playername.length()<highscore_maxnamelen)
 			playername += key;
 		*/
-	}
-
-
-	/* default start... functions */
-
-	/** Initialise the title screen.  This is a standard state transition
-	* function. Default is do nothing. */
-	public void startTitle() {}
-
-	/** Initialise the highscore display.  This is a standard state transition
-	* function. Default is do nothing. */
-	public void startHighscores() {}
-
-	/** Initialisation at the start of the in-game action. This is a
-	* standard state transition function.  Note that it is always called after
-	* StartLevel and LifeLost, even if startgame_ingame and
-	* lifelost_ingame are set.  Default is do nothing. */
-	public void startInGame() {}
-
-	/** Initialise start-level sequence. This is a
-	* standard state transition function.  Default is do nothing. */
-	public void startStartLevel() {}
-
-	/** Initialise start-game sequence. This is a
-	* standard state transition function.  Default is do nothing. */
-	public void startStartGame() {}
-
-	/** Initialise next-level sequence. This is a
-	* standard state transition function.  Default is do nothing. */
-	public void startLevelDone() {}
-
-	/** Initialise death sequence. This is a
-	* standard state transition function.  Default is do nothing. */
-	public void startLifeLost() {}
-
-	/** Initialise game over sequence. This is a
-	* standard state transition function. Default is do nothing. */
-	public void startGameOver() {}
-
-	/** Initialise enter-highscore screen.  This is a standard state
-	 * transition function.  Default is clear lastkey and set playername to
-	 * the empty string.*/
-	public void startEnterHighscore() {
-		clearLastKey();
-		playername="";
-	}
-	/* default paint functions */
-
-	// only regenerate strings to display if the variables changed.
-	// toString and concatenation take a lot of time.
-	String scorestr="",livesstr="";
-	int oldscore=-1,oldlives=-1;
-	/** Default paintFrame displays score at top left, lives at top right.
-	* When lives_img is set, it uses that image to display lives. */
-	public void paintFrame() {
-		if (score!=oldscore) {
-			scorestr = "Score "+score;
-			oldscore = score;
-		}
-		if (lives!=oldlives) {
-			livesstr = "Lives "+lives;
-			oldlives = lives;
-		}
-		setFont(status_font);
-		setColor(status_color);
-		drawString(scorestr,status_l_margin,0,-1);
-		if (lives_img==null) {
-			drawString(livesstr,viewWidth()-status_r_margin,0,1);
-		} else {
-			drawCount(lives-1, lives_img, viewWidth()-status_r_margin,0,
-				- getImageSize(lives_img).x-2 );
-		}
-	}
-	/** Default displays class name as title, and "press [key_startgame] to
-	 * start" below it. */
-	public void paintFrameTitle() {
-		drawString(getClass().getName().substring(getClass().getName()
-			.lastIndexOf('.' )+1 ),
-			viewWidth()/2,viewHeight()/3,0,title_font,title_color);
-		drawString("Press "+getKeyDesc(key_startgame)+" to start",
-			viewWidth()/2,6*viewHeight()/10,0,title_font,title_color);
-		drawString("Press "+getKeyDesc(key_quitprogram)+" to quit",
-			viewWidth()/2,7*viewHeight()/10,0,title_font,title_color);
-		// settings not (yet) supported
-		//drawString("Press "+getKeyDesc(key_gamesettings)+" for settings",
-		//	viewWidth()/2,7*viewHeight()/10,0,title_font,title_color);
-	}
-	/** The game is halted in pause mode, but the paintFrame is still done to
-	* refresh the screen.  Default behaviour of paintFramePaused() is display
-	* "Paused", "Press [key_pausegame] to continue" using title_font,
-	* title_color */
-	public void paintFramePaused() {
-		setColor(title_bg_color);
-		// XXX note: original height was
-		// 5*viewHeight()/36+(int)getFontHeight(title_font)
-		drawRect(viewWidth()/20,15*viewHeight()/36,18*viewWidth()/20,
-			6*viewHeight()/36+(int)getFontHeight(title_font), true,false,false);
-		drawString("Paused",viewWidth()/2,16*viewHeight()/36,0,
-			title_font,title_color);
-		drawString("Press "+getKeyDesc(key_pausegame)+" to continue",
-			viewWidth()/2,19*viewHeight()/36,0, title_font,title_color);
-	}
-	/** Default displays "Level "+(stage+1). */
-	public void paintFrameStartLevel() {
-		drawString("Level "+(stage+1),
-			viewWidth()/2,3*viewHeight()/5,0,title_font,title_color);
-	}
-	/** Default displays "Start !". */
-	public void paintFrameStartGame() {
-		drawString("Start !",
-			viewWidth()/2,viewHeight()/3,0,title_font,title_color);
-	}
-	/** Default displays "Level Done !". */
-	public void paintFrameLevelDone() {
-		drawString("Level Done !",
-			viewWidth()/2,viewHeight()/3,0,title_font,title_color);
-	}
-	/** Default displays "Life Lost !". */
-	public void paintFrameLifeLost() {
-		drawString("Life Lost !",
-			viewWidth()/2,viewHeight()/3,0,title_font,title_color);
-	}
-	/** Default displays "Game Over!". */
-	public void paintFrameGameOver() {
-		drawString("Game Over !",
-			viewWidth()/2,viewHeight()/3,0,title_font,title_color);
-	}
-
-	/** Default displays highscore_entry, and the player's score and
-	 * playername currently being entered. */
-	public void paintFrameEnterHighscore() {
-		drawString(highscore_entry,
-			viewWidth()/2,viewHeight()/3,0,highscore_title_font,
-				highscore_title_color);
-		drawString(""+score,
-			viewWidth()/2,viewHeight()/2,0,highscore_font,highscore_color);
-		drawString(playername+"|",
-			viewWidth()/2,2*viewHeight()/3,0,highscore_font,highscore_color);
-	}
-
-	/** Default displays the highscore list. Fields are not yet supported.  */
-	public void paintFrameHighscores() {
-		drawString(highscore_title,
-			viewWidth()/2,viewHeight()/7,0,highscore_title_font,
-			highscore_title_color);
-		double yinc = 0.7*viewHeight()/highscores.length;
-		double ypos = 0.6*viewHeight() - yinc*(highscores.length/2.0);
-		for (int i=0; i<highscores.length; i++) {
-			drawString(""+highscores[i].score,
-				0.22*viewWidth(), ypos + i*yinc,
-					1,highscore_font,highscore_color);
-			drawString(highscores[i].name,
-				0.8*viewWidth(), ypos + i*yinc,
-					1,highscore_font,highscore_color);
-		}
-	}
-
-	/* handy game functions */
-
-	/** Returns true every increment ticks, but only when gametime is between
-	* min_time and max_time. */
-	public boolean checkTime(int min_time,int max_time,int increment) {
-		return gametime>min_time && gametime<max_time
-		       && (((int)gametime-1)%increment)<(int)getGameSpeed();
-	}
-	/** Returns true every increment ticks. */
-	public boolean checkTime(int increment) {
-		return (((int)gametime-1)%increment)<(int)getGameSpeed();
-	}
-
-	/* handy draw and effects functions */
-
-	/** Draw a row of objects to indicate the value count.  This is typically
-	 * used to indicate lives left. */
-	public void drawCount(int count, String image,int x,int y,int increment_x) {
-		if (increment_x < 0) x += increment_x;
-		for (int i=0; i<count; i++)
-			drawImage(x + i*increment_x, y, image, false);
-	}
-	/** Draw a string with letters that move up and down individually. */
-	public void drawWavyString(String s, int x,int y,int align,int increment_x,
-	double tmr,double amplitude, double pos_phaseshift, double timer_phaseshift,
-	JGFont font, JGColor col) {
-		setFont(font);
-		setColor(col);
-		if (align==0) {
-			x -= increment_x*s.length()/2;
-		} else if (align==1) {
-			x -= increment_x*s.length();
-		}
-		for (int i=0; i<s.length(); i++)
-			drawString(s.substring(i,i+1), x + i*increment_x,
-				y + (int)(amplitude * 
-				-Math.cos(Math.PI*(pos_phaseshift*i + tmr*timer_phaseshift))
-				), 0);
-	}
-
-	/** Draw a String that zooms in and out. Alignment is always center. Note
-	 * that tmr = 0 will start the font zooming in. */
-	//public void drawZoomString(String s,int x,int y,
-	//int tmr, double min_size_fac, double speed, Font font, JGColor col) {
-	//	drawString(s,x,y,0,zoomed,col);
-	//}
-
-	/** Get font for zooming text in and out. Note that tmr = 0 will start
-	* the font zooming in from the farthest position. */
-	public JGFont getZoomingFont(JGFont basejgfont, double tmr,
-	double min_size_fac, double speed) {
-		// dummy implementation
-		return basejgfont;
-	}
-
-	/** Get a colour from a colour cycle. */
-	public JGColor cycleColor(JGColor [] cycle, double tmr, double speed) {
-		return cycle[ ( (int)(tmr*speed) ) % cycle.length ];
-	}
-
-	/** Walk across the screen, standing still momentarily at a specific
-	* position. */
-	public int posWalkForwards(int begin_pos, int end_pos, double tmr,
-	int end_time,int standstill_pos,int standstill_time,int standstill_count){
-		if (tmr < standstill_time) {
-			double step = (standstill_pos - begin_pos)/(double)standstill_time;
-			return begin_pos + (int)(tmr*step);
-		} else if (tmr>=standstill_time&&tmr<standstill_time+standstill_count){
-			return standstill_pos;
-		} else if (tmr >= standstill_time+standstill_count && tmr < end_time) {
-			int beg2_time = standstill_time + standstill_count;
-			double step=(end_pos-standstill_pos)/(double)(end_time - beg2_time);
-			return standstill_pos + (int)((tmr-beg2_time) * step);
-		} else {
-			return end_pos;
-		}
-	}
+    }
+
+
+    /* default start... functions */
+
+    /**
+     * Initialise the title screen.  This is a standard state transition
+     * function. Default is do nothing.
+     */
+    public void startTitle() {
+    }
+
+    /**
+     * Initialise the highscore display.  This is a standard state transition
+     * function. Default is do nothing.
+     */
+    public void startHighscores() {
+    }
+
+    /**
+     * Initialisation at the start of the in-game action. This is a
+     * standard state transition function.  Note that it is always called after
+     * StartLevel and LifeLost, even if startgame_ingame and
+     * lifelost_ingame are set.  Default is do nothing.
+     */
+    public void startInGame() {
+    }
+
+    /**
+     * Initialise start-level sequence. This is a
+     * standard state transition function.  Default is do nothing.
+     */
+    public void startStartLevel() {
+    }
+
+    /**
+     * Initialise start-game sequence. This is a
+     * standard state transition function.  Default is do nothing.
+     */
+    public void startStartGame() {
+    }
+
+    /**
+     * Initialise next-level sequence. This is a
+     * standard state transition function.  Default is do nothing.
+     */
+    public void startLevelDone() {
+    }
+
+    /**
+     * Initialise death sequence. This is a
+     * standard state transition function.  Default is do nothing.
+     */
+    public void startLifeLost() {
+    }
+
+    /**
+     * Initialise game over sequence. This is a
+     * standard state transition function. Default is do nothing.
+     */
+    public void startGameOver() {
+    }
+
+    /**
+     * Initialise enter-highscore screen.  This is a standard state
+     * transition function.  Default is clear lastkey and set playername to
+     * the empty string.
+     */
+    public void startEnterHighscore() {
+        clearLastKey();
+        playername = "";
+    }
+    /* default paint functions */
+
+    // only regenerate strings to display if the variables changed.
+    // toString and concatenation take a lot of time.
+    String scorestr = "", livesstr = "";
+    int oldscore = -1, oldlives = -1;
+
+    /**
+     * Default paintFrame displays score at top left, lives at top right.
+     * When lives_img is set, it uses that image to display lives.
+     */
+    public void paintFrame() {
+        if (score != oldscore) {
+            scorestr = "Score " + score;
+            oldscore = score;
+        }
+        if (lives != oldlives) {
+            livesstr = "Lives " + lives;
+            oldlives = lives;
+        }
+        setFont(status_font);
+        setColor(status_color);
+        drawString(scorestr, status_l_margin, 0, -1);
+        if (lives_img == null) {
+            drawString(livesstr, viewWidth() - status_r_margin, 0, 1);
+        } else {
+            drawCount(lives - 1, lives_img, viewWidth() - status_r_margin, 0,
+                    -getImageSize(lives_img).x - 2);
+        }
+    }
+
+    /**
+     * Default displays class name as title, and "press [key_startgame] to
+     * start" below it.
+     */
+    public void paintFrameTitle() {
+        drawString(getClass().getName().substring(getClass().getName()
+                        .lastIndexOf('.') + 1),
+                viewWidth() / 2, viewHeight() / 3, 0, title_font, title_color);
+        drawString("Press " + getKeyDesc(key_startgame) + " to start",
+                viewWidth() / 2, 6 * viewHeight() / 10, 0, title_font, title_color);
+        drawString("Press " + getKeyDesc(key_quitprogram) + " to quit",
+                viewWidth() / 2, 7 * viewHeight() / 10, 0, title_font, title_color);
+        // settings not (yet) supported
+        //drawString("Press "+getKeyDesc(key_gamesettings)+" for settings",
+        //	viewWidth()/2,7*viewHeight()/10,0,title_font,title_color);
+    }
+
+    /**
+     * The game is halted in pause mode, but the paintFrame is still done to
+     * refresh the screen.  Default behaviour of paintFramePaused() is display
+     * "Paused", "Press [key_pausegame] to continue" using title_font,
+     * title_color
+     */
+    public void paintFramePaused() {
+        setColor(title_bg_color);
+        // XXX note: original height was
+        // 5*viewHeight()/36+(int)getFontHeight(title_font)
+        drawRect(viewWidth() / 20, 15 * viewHeight() / 36, 18 * viewWidth() / 20,
+                6 * viewHeight() / 36 + (int) getFontHeight(title_font), true, false, false);
+        drawString("Paused", viewWidth() / 2, 16 * viewHeight() / 36, 0,
+                title_font, title_color);
+        drawString("Press " + getKeyDesc(key_pausegame) + " to continue",
+                viewWidth() / 2, 19 * viewHeight() / 36, 0, title_font, title_color);
+    }
+
+    /**
+     * Default displays "Level "+(stage+1).
+     */
+    public void paintFrameStartLevel() {
+        drawString("Level " + (stage + 1),
+                viewWidth() / 2, 3 * viewHeight() / 5, 0, title_font, title_color);
+    }
+
+    /**
+     * Default displays "Start !".
+     */
+    public void paintFrameStartGame() {
+        drawString("Start !",
+                viewWidth() / 2, viewHeight() / 3, 0, title_font, title_color);
+    }
+
+    /**
+     * Default displays "Level Done !".
+     */
+    public void paintFrameLevelDone() {
+        drawString("Level Done !",
+                viewWidth() / 2, viewHeight() / 3, 0, title_font, title_color);
+    }
+
+    /**
+     * Default displays "Life Lost !".
+     */
+    public void paintFrameLifeLost() {
+        drawString("Life Lost !",
+                viewWidth() / 2, viewHeight() / 3, 0, title_font, title_color);
+    }
+
+    /**
+     * Default displays "Game Over!".
+     */
+    public void paintFrameGameOver() {
+        drawString("Game Over !",
+                viewWidth() / 2, viewHeight() / 3, 0, title_font, title_color);
+    }
+
+    /**
+     * Default displays highscore_entry, and the player's score and
+     * playername currently being entered.
+     */
+    public void paintFrameEnterHighscore() {
+        drawString(highscore_entry,
+                viewWidth() / 2, viewHeight() / 3, 0, highscore_title_font,
+                highscore_title_color);
+        drawString("" + score,
+                viewWidth() / 2, viewHeight() / 2, 0, highscore_font, highscore_color);
+        drawString(playername + "|",
+                viewWidth() / 2, 2 * viewHeight() / 3, 0, highscore_font, highscore_color);
+    }
+
+    /**
+     * Default displays the highscore list. Fields are not yet supported.
+     */
+    public void paintFrameHighscores() {
+        drawString(highscore_title,
+                viewWidth() / 2, viewHeight() / 7, 0, highscore_title_font,
+                highscore_title_color);
+        double yinc = 0.7 * viewHeight() / highscores.length;
+        double ypos = 0.6 * viewHeight() - yinc * (highscores.length / 2.0);
+        for (int i = 0; i < highscores.length; i++) {
+            drawString("" + highscores[i].score,
+                    0.22 * viewWidth(), ypos + i * yinc,
+                    1, highscore_font, highscore_color);
+            drawString(highscores[i].name,
+                    0.8 * viewWidth(), ypos + i * yinc,
+                    1, highscore_font, highscore_color);
+        }
+    }
+
+    /* handy game functions */
+
+    /**
+     * Returns true every increment ticks, but only when gametime is between
+     * min_time and max_time.
+     */
+    public boolean checkTime(int min_time, int max_time, int increment) {
+        return gametime > min_time && gametime < max_time
+                && (((int) gametime - 1) % increment) < (int) getGameSpeed();
+    }
+
+    /**
+     * Returns true every increment ticks.
+     */
+    public boolean checkTime(int increment) {
+        return (((int) gametime - 1) % increment) < (int) getGameSpeed();
+    }
+
+    /* handy draw and effects functions */
+
+    /**
+     * Draw a row of objects to indicate the value count.  This is typically
+     * used to indicate lives left.
+     */
+    public void drawCount(int count, String image, int x, int y, int increment_x) {
+        if (increment_x < 0) x += increment_x;
+        for (int i = 0; i < count; i++)
+            drawImage(x + i * increment_x, y, image, false);
+    }
+
+    /**
+     * Draw a string with letters that move up and down individually.
+     */
+    public void drawWavyString(String s, int x, int y, int align, int increment_x,
+                               double tmr, double amplitude, double pos_phaseshift, double timer_phaseshift,
+                               JGFont font, JGColor col) {
+        setFont(font);
+        setColor(col);
+        if (align == 0) {
+            x -= increment_x * s.length() / 2;
+        } else if (align == 1) {
+            x -= increment_x * s.length();
+        }
+        for (int i = 0; i < s.length(); i++)
+            drawString(s.substring(i, i + 1), x + i * increment_x,
+                    y + (int) (amplitude *
+                            -Math.cos(Math.PI * (pos_phaseshift * i + tmr * timer_phaseshift))
+                    ), 0);
+    }
+
+    /** Draw a String that zooms in and out. Alignment is always center. Note
+     * that tmr = 0 will start the font zooming in. */
+    //public void drawZoomString(String s,int x,int y,
+    //int tmr, double min_size_fac, double speed, Font font, JGColor col) {
+    //	drawString(s,x,y,0,zoomed,col);
+    //}
+
+    /**
+     * Get font for zooming text in and out. Note that tmr = 0 will start
+     * the font zooming in from the farthest position.
+     */
+    public JGFont getZoomingFont(JGFont basejgfont, double tmr,
+                                 double min_size_fac, double speed) {
+        // dummy implementation
+        return basejgfont;
+    }
+
+    /**
+     * Get a colour from a colour cycle.
+     */
+    public JGColor cycleColor(JGColor[] cycle, double tmr, double speed) {
+        return cycle[((int) (tmr * speed)) % cycle.length];
+    }
+
+    /**
+     * Walk across the screen, standing still momentarily at a specific
+     * position.
+     */
+    public int posWalkForwards(int begin_pos, int end_pos, double tmr,
+                               int end_time, int standstill_pos, int standstill_time, int standstill_count) {
+        if (tmr < standstill_time) {
+            double step = (standstill_pos - begin_pos) / (double) standstill_time;
+            return begin_pos + (int) (tmr * step);
+        } else if (tmr >= standstill_time && tmr < standstill_time + standstill_count) {
+            return standstill_pos;
+        } else if (tmr >= standstill_time + standstill_count && tmr < end_time) {
+            int beg2_time = standstill_time + standstill_count;
+            double step = (end_pos - standstill_pos) / (double) (end_time - beg2_time);
+            return standstill_pos + (int) ((tmr - beg2_time) * step);
+        } else {
+            return end_pos;
+        }
+    }
 }
