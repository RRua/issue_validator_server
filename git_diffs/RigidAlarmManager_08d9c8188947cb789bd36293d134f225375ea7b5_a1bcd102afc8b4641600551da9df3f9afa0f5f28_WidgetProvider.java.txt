diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/GlobalObjects.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/Reddinator.java
similarity index 94%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/GlobalObjects.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/Reddinator.java
index cd72dc4..bd00470 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/GlobalObjects.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/Reddinator.java
@@ -1,308 +1,312 @@
-/*
- * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
- * This file is part of Reddinator.
- *
- * Reddinator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * Reddinator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
- */
-package au.com.wallaceit.reddinator;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.Application;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.Typeface;
-import android.net.Uri;
-import android.os.Bundle;
-import android.preference.PreferenceManager;
-import android.util.TypedValue;
-import android.view.View;
-import android.widget.LinearLayout;
-import android.widget.TextView;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.ArrayList;
-
-import static au.com.wallaceit.reddinator.R.layout.dialog_info;
-
-public class GlobalObjects extends Application {
-
-    private ArrayList<JSONObject> mSubredditList; // cached popular subreddits
-    final static int LOADTYPE_LOAD = 0;
-    final static int LOADTYPE_LOADMORE = 1;
-    final static int LOADTYPE_REFRESH_VIEW = 3;
-    private int loadtype = 0; // tells the service what to do when notifyAppDataChanged is fired
-    private boolean bypassCache = false; // tells the factory to bypass the cache when creating a new remoteviewsfacotry
-    public RedditData mRedditData;
-    public ThemeManager mThemeManager;
-    private SubredditManager mSubManager;
-    private SharedPreferences mSharedPreferences;
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        if (mSubredditList == null) {
-            mSubredditList = new ArrayList<>();
-        }
-        mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(GlobalObjects.this.getApplicationContext());
-        mRedditData = new RedditData(GlobalObjects.this.getApplicationContext());
-        mThemeManager = new ThemeManager(GlobalObjects.this.getApplicationContext(), mSharedPreferences);
-    }
-
-    // app feed update from view reddit activity; if the user voted, that data is stored here for the MainActivity to access in on resume
-    Bundle itemupdate;
-
-    public Bundle getItemUpdate() {
-        if (itemupdate == null) {
-            return null;
-        }
-        Bundle tempdata = itemupdate;
-        itemupdate = null; // prevent duplicate updates
-        return tempdata;
-    }
-
-    public void setItemUpdate(int position, String id, String val) {
-        itemupdate = new Bundle();
-        itemupdate.putInt("position", position);
-        itemupdate.putString("id", id);
-        itemupdate.putString("val", val);
-    }
-
-    // methods for setting/getting vote statuses, this keeps vote status persistent accross apps and widgets
-    public void setItemVote(SharedPreferences prefs, int widgetId, int position, String id, String val) {
-        try {
-            JSONArray data = new JSONArray(prefs.getString("feeddata-" + (widgetId == 0 ? "app" : widgetId), "[]"));
-            JSONObject record = data.getJSONObject(position).getJSONObject("data");
-            if (record.getString("name").equals(id)) {
-                data.getJSONObject(position).getJSONObject("data").put("likes", val);
-                // commit to shared prefs
-                SharedPreferences.Editor mEditor = prefs.edit();
-                mEditor.putString("feeddata-" + (widgetId == 0 ? "app" : widgetId), data.toString());
-                mEditor.apply();
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-    }
-
-    // set get current feeds from cache
-    public void setFeed(SharedPreferences prefs, int widgetId, JSONArray feeddata) {
-        SharedPreferences.Editor mEditor = prefs.edit();
-        mEditor.putString("feeddata-" + (widgetId == 0 ? "app" : widgetId), feeddata.toString());
-        mEditor.apply();
-    }
-
-    public JSONArray getFeed(SharedPreferences prefs, int widgetId) {
-        JSONArray data;
-        try {
-            data = new JSONArray(prefs.getString("feeddata-" + (widgetId == 0 ? "app" : widgetId), "[]"));
-        } catch (JSONException e) {
-            data = new JSONArray();
-            e.printStackTrace();
-        }
-        return data;
-    }
-
-    public JSONObject getFeedObject(SharedPreferences prefs, int widgetId, int position, String redditId) {
-        try {
-            JSONArray data = new JSONArray(prefs.getString("feeddata-" + (widgetId == 0 ? "app" : widgetId), "[]"));
-            JSONObject item = data.getJSONObject(position).getJSONObject("data");
-            if (item.getString("name").equals(redditId)) {
-                return item;
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-        return null;
-    }
-
-    // cached popular subreddits
-    public boolean isSrlistCached() {
-        return !mSubredditList.isEmpty();
-    }
-
-    public void putSrList(ArrayList<JSONObject> list) {
-        mSubredditList.clear();
-        mSubredditList.addAll(list);
-    }
-
-    public ArrayList<JSONObject> getSrList() {
-        return mSubredditList;
-    }
-
-    // subreddit list, settings & filter management
-    public SubredditManager getSubredditManager(){
-        if (mSubManager==null)
-            mSubManager = new SubredditManager(mSharedPreferences);
-
-        return mSubManager;
-    }
-
-    public int loadAccountSubreddits() throws RedditData.RedditApiException {
-
-        final JSONArray list= mRedditData.getMySubreddits();
-        getSubredditManager().setSubreddits(list);
-        return list.length();
-    }
-
-    public int loadAccountMultis() throws RedditData.RedditApiException {
-
-        JSONArray list = mRedditData.getMyMultis();
-        getSubredditManager().addMultis(list, true);
-        return list.length();
-    }
-
-    // widget data loadtype functions; a bypass for androids restrictive widget api
-    public int getLoadType() {
-        return loadtype;
-    }
-
-    public void setLoadMore() {
-        loadtype = LOADTYPE_LOADMORE;
-    }
-
-    public void setLoad() {
-        loadtype = LOADTYPE_LOAD;
-    }
-
-    public void setRefreshView() {
-        loadtype = LOADTYPE_REFRESH_VIEW;
-    }
-
-    // data cache functions
-    public boolean getBypassCache() {
-        return bypassCache;
-    }
-
-    public void setBypassCache(boolean bypassed) {
-        bypassCache = bypassed;
-    }
-
-    public void showAlertDialog(Context context, String title, String message) {
-        new AlertDialog.Builder(context)
-                .setTitle(title)
-                .setMessage(message)
-                .setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
-                    public void onClick(DialogInterface dialog, int which) {
-                        dialog.dismiss();
-                    }
-                })
-                .setIcon(android.R.drawable.ic_dialog_alert)
-                .show();
-    }
-
-    public String getRedditMobileSite(boolean beta){
-        if (beta){
-            return "https://m.reddit.com";
-        } else {
-            return "https://i.reddit.com";
-        }
-    }
-
-    public String getDefaultMobileSite(){
-        return getRedditMobileSite(mSharedPreferences.getBoolean("redditmobilepref", false));
-    }
-
-    public String getDefaultCommentsMobileSite(){
-        return getRedditMobileSite(mSharedPreferences.getBoolean("mobilecommentspref", true));
-    }
-
-    public static Bitmap getFontBitmap(Context context, String text, int color, int fontSize, int[] shadow) {
-        fontSize = convertDiptoPix(context, fontSize);
-        int pad = (fontSize / 9);
-        Paint paint = new Paint();
-        Typeface typeface = Typeface.createFromAsset(context.getAssets(), "fonts/fontawesome-webfont.ttf");
-        paint.setAntiAlias(true);
-        paint.setTypeface(typeface);
-        paint.setColor(color);
-        paint.setTextSize(fontSize);
-        paint.setShadowLayer(shadow[0], shadow[1], shadow[2], shadow[3]);
-
-        int textWidth = (int) (paint.measureText(text) + pad * 2);
-        int height = (int) (fontSize / 0.75);
-        Bitmap bitmap = Bitmap.createBitmap(textWidth, height, Bitmap.Config.ARGB_4444);
-        Canvas canvas = new Canvas(bitmap);
-        canvas.drawText(text, (float) pad, fontSize, paint);
-        return bitmap;
-    }
-
-    public static int convertDiptoPix(Context context, float dip) {
-        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip, context.getResources().getDisplayMetrics());
-    }
-
-    public static PackageInfo getPackageInfo(Context context){
-        PackageInfo pInfo = null;
-        try {
-            pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-
-        } catch (PackageManager.NameNotFoundException e) {
-            e.printStackTrace();
-        }
-        return pInfo;
-    }
-
-    public static void doShowWelcomeDialog(final Activity context){
-        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
-        boolean aboutDismissed = preferences.getBoolean("welcomeDialogShown-"+getPackageInfo(context).versionName, false);
-        if (!aboutDismissed){
-            showInfoDialog(context, false);
-        }
-    }
-
-    public static void showInfoDialog(final Activity context, final boolean isInfo){
-        LinearLayout aboutView = (LinearLayout) context.getLayoutInflater().inflate(dialog_info, null);
-        ((TextView) aboutView.findViewById(R.id.version)).setText("version "+getPackageInfo(context).versionName);
-        aboutView.findViewById(R.id.github).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/micwallace/reddinator"));
-                context.startActivity(intent);
-            }
-        });
-        aboutView.findViewById(R.id.donate).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=RFUQJ6EP5FLD2"));
-                context.startActivity(intent);
-            }
-        });
-        aboutView.findViewById(R.id.gold).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.reddit.com/gold?goldtype=gift&months=1&thing=t3_33zpng"));
-                context.startActivity(intent);
-            }
-        });
-        AlertDialog.Builder builder = new AlertDialog.Builder(context);
-        builder.setMessage(isInfo?"About":"Welcome to Reddinator").setView(aboutView)
-        .setPositiveButton("OK", new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialogInterface, int i) {
-                if (!isInfo)
-                    PreferenceManager.getDefaultSharedPreferences(context).edit().putBoolean("welcomeDialogShown-" + getPackageInfo(context).versionName, true).apply();
-                dialogInterface.dismiss();
-            }
-        }).show();
-    }
-}
+/*
+ * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
+ * This file is part of Reddinator.
+ *
+ * Reddinator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Reddinator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
+ */
+package au.com.wallaceit.reddinator;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Application;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Typeface;
+import android.net.Uri;
+import android.os.Bundle;
+import android.preference.PreferenceManager;
+import android.util.TypedValue;
+import android.view.View;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+
+import au.com.wallaceit.reddinator.core.RedditData;
+import au.com.wallaceit.reddinator.core.SubredditManager;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+
+import static au.com.wallaceit.reddinator.R.layout.dialog_info;
+
+public class Reddinator extends Application {
+
+    private ArrayList<JSONObject> mSubredditList; // cached popular subreddits
+    public final static int LOADTYPE_LOAD = 0;
+    public final static int LOADTYPE_LOADMORE = 1;
+    public final static int LOADTYPE_REFRESH_VIEW = 3;
+    private int loadtype = 0; // tells the service what to do when notifyAppDataChanged is fired
+    private boolean bypassCache = false; // tells the factory to bypass the cache when creating a new remoteviewsfacotry
+    public RedditData mRedditData;
+    public ThemeManager mThemeManager;
+    private SubredditManager mSubManager;
+    private SharedPreferences mSharedPreferences;
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        if (mSubredditList == null) {
+            mSubredditList = new ArrayList<>();
+        }
+        mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(Reddinator.this.getApplicationContext());
+        mRedditData = new RedditData(Reddinator.this.getApplicationContext());
+        mThemeManager = new ThemeManager(Reddinator.this.getApplicationContext(), mSharedPreferences);
+    }
+
+    // app feed update from view reddit activity; if the user voted, that data is stored here for the MainActivity to access in on resume
+    Bundle itemupdate;
+
+    public Bundle getItemUpdate() {
+        if (itemupdate == null) {
+            return null;
+        }
+        Bundle tempdata = itemupdate;
+        itemupdate = null; // prevent duplicate updates
+        return tempdata;
+    }
+
+    public void setItemUpdate(int position, String id, String val) {
+        itemupdate = new Bundle();
+        itemupdate.putInt("position", position);
+        itemupdate.putString("id", id);
+        itemupdate.putString("val", val);
+    }
+
+    // methods for setting/getting vote statuses, this keeps vote status persistent accross apps and widgets
+    public void setItemVote(SharedPreferences prefs, int widgetId, int position, String id, String val) {
+        try {
+            JSONArray data = new JSONArray(prefs.getString("feeddata-" + (widgetId == 0 ? "app" : widgetId), "[]"));
+            JSONObject record = data.getJSONObject(position).getJSONObject("data");
+            if (record.getString("name").equals(id)) {
+                data.getJSONObject(position).getJSONObject("data").put("likes", val);
+                // commit to shared prefs
+                SharedPreferences.Editor mEditor = prefs.edit();
+                mEditor.putString("feeddata-" + (widgetId == 0 ? "app" : widgetId), data.toString());
+                mEditor.apply();
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+    }
+
+    // set get current feeds from cache
+    public void setFeed(SharedPreferences prefs, int widgetId, JSONArray feeddata) {
+        SharedPreferences.Editor mEditor = prefs.edit();
+        mEditor.putString("feeddata-" + (widgetId == 0 ? "app" : widgetId), feeddata.toString());
+        mEditor.apply();
+    }
+
+    public JSONArray getFeed(SharedPreferences prefs, int widgetId) {
+        JSONArray data;
+        try {
+            data = new JSONArray(prefs.getString("feeddata-" + (widgetId == 0 ? "app" : widgetId), "[]"));
+        } catch (JSONException e) {
+            data = new JSONArray();
+            e.printStackTrace();
+        }
+        return data;
+    }
+
+    public JSONObject getFeedObject(SharedPreferences prefs, int widgetId, int position, String redditId) {
+        try {
+            JSONArray data = new JSONArray(prefs.getString("feeddata-" + (widgetId == 0 ? "app" : widgetId), "[]"));
+            JSONObject item = data.getJSONObject(position).getJSONObject("data");
+            if (item.getString("name").equals(redditId)) {
+                return item;
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    // cached popular subreddits
+    public boolean isSrlistCached() {
+        return !mSubredditList.isEmpty();
+    }
+
+    public void putSrList(ArrayList<JSONObject> list) {
+        mSubredditList.clear();
+        mSubredditList.addAll(list);
+    }
+
+    public ArrayList<JSONObject> getSrList() {
+        return mSubredditList;
+    }
+
+    // subreddit list, settings & filter management
+    public SubredditManager getSubredditManager(){
+        if (mSubManager==null)
+            mSubManager = new SubredditManager(mSharedPreferences);
+
+        return mSubManager;
+    }
+
+    public int loadAccountSubreddits() throws RedditData.RedditApiException {
+
+        final JSONArray list= mRedditData.getMySubreddits();
+        getSubredditManager().setSubreddits(list);
+        return list.length();
+    }
+
+    public int loadAccountMultis() throws RedditData.RedditApiException {
+
+        JSONArray list = mRedditData.getMyMultis();
+        getSubredditManager().addMultis(list, true);
+        return list.length();
+    }
+
+    // widget data loadtype functions; a bypass for androids restrictive widget api
+    public int getLoadType() {
+        return loadtype;
+    }
+
+    public void setLoadMore() {
+        loadtype = LOADTYPE_LOADMORE;
+    }
+
+    public void setLoad() {
+        loadtype = LOADTYPE_LOAD;
+    }
+
+    public void setRefreshView() {
+        loadtype = LOADTYPE_REFRESH_VIEW;
+    }
+
+    // data cache functions
+    public boolean getBypassCache() {
+        return bypassCache;
+    }
+
+    public void setBypassCache(boolean bypassed) {
+        bypassCache = bypassed;
+    }
+
+    public void showAlertDialog(Context context, String title, String message) {
+        new AlertDialog.Builder(context)
+                .setTitle(title)
+                .setMessage(message)
+                .setPositiveButton(android.R.string.yes, new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int which) {
+                        dialog.dismiss();
+                    }
+                })
+                .setIcon(android.R.drawable.ic_dialog_alert)
+                .show();
+    }
+
+    public String getRedditMobileSite(boolean beta){
+        if (beta){
+            return "https://m.reddit.com";
+        } else {
+            return "https://i.reddit.com";
+        }
+    }
+
+    public String getDefaultMobileSite(){
+        return getRedditMobileSite(mSharedPreferences.getBoolean("redditmobilepref", false));
+    }
+
+    public String getDefaultCommentsMobileSite(){
+        return getRedditMobileSite(mSharedPreferences.getBoolean("mobilecommentspref", true));
+    }
+
+    public static Bitmap getFontBitmap(Context context, String text, int color, int fontSize, int[] shadow) {
+        fontSize = convertDiptoPix(context, fontSize);
+        int pad = (fontSize / 9);
+        Paint paint = new Paint();
+        Typeface typeface = Typeface.createFromAsset(context.getAssets(), "fonts/fontawesome-webfont.ttf");
+        paint.setAntiAlias(true);
+        paint.setTypeface(typeface);
+        paint.setColor(color);
+        paint.setTextSize(fontSize);
+        paint.setShadowLayer(shadow[0], shadow[1], shadow[2], shadow[3]);
+
+        int textWidth = (int) (paint.measureText(text) + pad * 2);
+        int height = (int) (fontSize / 0.75);
+        Bitmap bitmap = Bitmap.createBitmap(textWidth, height, Bitmap.Config.ARGB_4444);
+        Canvas canvas = new Canvas(bitmap);
+        canvas.drawText(text, (float) pad, fontSize, paint);
+        return bitmap;
+    }
+
+    public static int convertDiptoPix(Context context, float dip) {
+        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip, context.getResources().getDisplayMetrics());
+    }
+
+    public static PackageInfo getPackageInfo(Context context){
+        PackageInfo pInfo = null;
+        try {
+            pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+
+        } catch (PackageManager.NameNotFoundException e) {
+            e.printStackTrace();
+        }
+        return pInfo;
+    }
+
+    public static void doShowWelcomeDialog(final Activity context){
+        SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
+        boolean aboutDismissed = preferences.getBoolean("welcomeDialogShown-"+getPackageInfo(context).versionName, false);
+        if (!aboutDismissed){
+            showInfoDialog(context, false);
+        }
+    }
+
+    public static void showInfoDialog(final Activity context, final boolean isInfo){
+        LinearLayout aboutView = (LinearLayout) context.getLayoutInflater().inflate(dialog_info, null);
+        ((TextView) aboutView.findViewById(R.id.version)).setText("version "+getPackageInfo(context).versionName);
+        aboutView.findViewById(R.id.github).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/micwallace/reddinator"));
+                context.startActivity(intent);
+            }
+        });
+        aboutView.findViewById(R.id.donate).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=RFUQJ6EP5FLD2"));
+                context.startActivity(intent);
+            }
+        });
+        aboutView.findViewById(R.id.gold).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.reddit.com/gold?goldtype=gift&months=1&thing=t3_33zpng"));
+                context.startActivity(intent);
+            }
+        });
+        AlertDialog.Builder builder = new AlertDialog.Builder(context);
+        builder.setMessage(isInfo?"About":"Welcome to Reddinator").setView(aboutView)
+        .setPositiveButton("OK", new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialogInterface, int i) {
+                if (!isInfo)
+                    PreferenceManager.getDefaultSharedPreferences(context).edit().putBoolean("welcomeDialogShown-" + getPackageInfo(context).versionName, true).apply();
+                dialogInterface.dismiss();
+            }
+        }).show();
+    }
+}
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/MainActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/MainActivity.java
similarity index 97%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/MainActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/MainActivity.java
index c29a98d..f8c4c85 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/MainActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/MainActivity.java
@@ -16,7 +16,7 @@
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
 
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.app.ActionBar;
 import android.app.Activity;
@@ -60,11 +60,17 @@ import java.net.URL;
 import java.net.URLConnection;
 import java.util.HashMap;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.RedditData;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+import au.com.wallaceit.reddinator.service.WidgetProvider;
+
 public class MainActivity extends Activity {
 
     private Context context;
     private SharedPreferences prefs;
-    private GlobalObjects global;
+    private Reddinator global;
     private ReddinatorListAdapter listAdapter;
     private AbsListView listView;
     private View appView;
@@ -80,7 +86,7 @@ public class MainActivity extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         context = MainActivity.this;
-        global = ((GlobalObjects) context.getApplicationContext());
+        global = ((Reddinator) context.getApplicationContext());
         prefs = PreferenceManager.getDefaultSharedPreferences(context);
         setContentView(R.layout.activity_main);
         // Setup actionbar
@@ -272,7 +278,7 @@ public class MainActivity extends Activity {
     public class ReddinatorListAdapter extends BaseAdapter {
 
         private JSONArray data;
-        private GlobalObjects global;
+        private Reddinator global;
         private SharedPreferences mSharedPreferences;
         private String titleFontSize = "16";
         private HashMap<String, Integer> themeColors;
@@ -282,7 +288,7 @@ public class MainActivity extends Activity {
         private boolean showItemSubreddit = false;
         private Bitmap[] images;
 
-        protected ReddinatorListAdapter(GlobalObjects gobjects, SharedPreferences prefs) {
+        protected ReddinatorListAdapter(Reddinator gobjects, SharedPreferences prefs) {
 
             global = gobjects;
             mSharedPreferences = prefs;
@@ -308,8 +314,8 @@ public class MainActivity extends Activity {
             int[] shadow = new int[]{3, 3, 3, themeColors.get("icon_shadow")};
             // load images
             images = new Bitmap[]{
-                    GlobalObjects.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_star.character()), themeColors.get("votes_icon"), 12, shadow),
-                    GlobalObjects.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_comment.character()), themeColors.get("comments_icon"), 12, shadow)
+                    Reddinator.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_star.character()), themeColors.get("votes_icon"), 12, shadow),
+                    Reddinator.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_comment.character()), themeColors.get("comments_icon"), 12, shadow)
             };
 
             // get font size preference
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/OAuthView.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/OAuthView.java
similarity index 95%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/OAuthView.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/OAuthView.java
index 7c7bcb6..21698c9 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/OAuthView.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/OAuthView.java
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.annotation.SuppressLint;
 import android.app.ActionBar;
@@ -34,17 +34,22 @@ import android.webkit.WebView;
 import android.webkit.WebViewClient;
 import android.widget.Toast;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.RedditData;
+import au.com.wallaceit.reddinator.service.MailCheckReceiver;
+
 public class OAuthView extends Activity {
     WebView wv;
     WebViewClient wvclient;
     Activity mActivity;
-    GlobalObjects global;
+    Reddinator global;
 
     @SuppressLint("SetJavaScriptEnabled")
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        global = ((GlobalObjects) OAuthView.this.getApplicationContext());
+        global = ((Reddinator) OAuthView.this.getApplicationContext());
 
         String oauthstate = this.getIntent().getStringExtra("oauthstate");
         // request loading bar
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/PrefsActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/PrefsActivity.java
similarity index 94%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/PrefsActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/PrefsActivity.java
index 6d9ef79..cd41033 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/PrefsActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/PrefsActivity.java
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.app.ActionBar;
 import android.appwidget.AppWidgetManager;
@@ -34,6 +34,12 @@ import android.widget.Toast;
 
 import java.util.LinkedHashMap;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.service.MailCheckReceiver;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+import au.com.wallaceit.reddinator.service.WidgetProvider;
+
 public class PrefsActivity extends PreferenceActivity implements SharedPreferences.OnSharedPreferenceChangeListener {
     public int mAppWidgetId;
     private SharedPreferences mSharedPreferences;
@@ -43,7 +49,7 @@ public class PrefsActivity extends PreferenceActivity implements SharedPreferenc
     //int mFirstTimeSetup = 0;
     private String mMailRefresh = "";
     boolean isfromappview = false;
-    private GlobalObjects global;
+    private Reddinator global;
     private boolean themeChanged = false;
     private PreferenceCategory appearanceCat;
     private ListPreference themePref;
@@ -59,13 +65,13 @@ public class PrefsActivity extends PreferenceActivity implements SharedPreferenc
         }
         getListView().setBackgroundColor(Color.WHITE);
         mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(PrefsActivity.this);
-        global = ((GlobalObjects) PrefsActivity.this.getApplicationContext());
+        global = ((Reddinator) PrefsActivity.this.getApplicationContext());
         // Load the preferences from an XML resource
         addPreferencesFromResource(R.xml.preferences);
 
         SharedPreferences mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(PrefsActivity.this);
         String token = mSharedPreferences.getString("oauthtoken", "");
-        if (token!=null && !token.equals("")){
+        if (!token.equals("")){
             // Load the account preferences when logged in
             addPreferencesFromResource(R.xml.account_preferences);
             Preference logoutbtn = findPreference("logout");
@@ -211,7 +217,7 @@ public class PrefsActivity extends PreferenceActivity implements SharedPreferenc
         AppWidgetManager mgr = AppWidgetManager.getInstance(PrefsActivity.this);
         int[] appWidgetIds = mgr.getAppWidgetIds(new ComponentName(PrefsActivity.this, WidgetProvider.class));
         WidgetProvider.updateAppWidgets(PrefsActivity.this, mgr, appWidgetIds, false);
-        GlobalObjects global = ((GlobalObjects) PrefsActivity.this.getApplicationContext());
+        Reddinator global = ((Reddinator) PrefsActivity.this.getApplicationContext());
         if (global != null) {
             global.setRefreshView();
         }
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubmitActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/SubmitActivity.java
similarity index 89%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/SubmitActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/SubmitActivity.java
index 384ce37..19d820f 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubmitActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/SubmitActivity.java
@@ -1,4 +1,4 @@
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.annotation.TargetApi;
 import android.app.ActionBar;
@@ -34,10 +34,19 @@ import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.RedditData;
+import au.com.wallaceit.reddinator.ui.SimpleTabsAdapter;
+import au.com.wallaceit.reddinator.ui.SimpleTabsWidget;
+import au.com.wallaceit.reddinator.ui.SubAutoCompleteAdapter;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+import au.com.wallaceit.reddinator.service.WidgetProvider;
+
 
 public class SubmitActivity extends Activity {
 
-    private GlobalObjects global;
+    private Reddinator global;
     private AutoCompleteTextView subreddit;
     private TextView charsLeft;
     private TextView submitText;
@@ -50,7 +59,7 @@ public class SubmitActivity extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_submit);
-        global = (GlobalObjects) getApplicationContext();
+        global = (Reddinator) getApplicationContext();
 
         subreddit = (AutoCompleteTextView) findViewById(R.id.subreddit);
         subreddit.setAdapter(new SubAutoCompleteAdapter(this, R.layout.autocomplete_list_item));
@@ -127,8 +136,11 @@ public class SubmitActivity extends Activity {
                 if (!global.mRedditData.isLoggedIn()){
                     global.mRedditData.initiateLogin(SubmitActivity.this);
                 } else {
-                    if (validateInput())
-                        (new SubmitTask()).execute();
+                    if (validateInput()) {
+                        boolean isLink = link.isShown();
+                        String data = isLink ? link.getText().toString() : text.getText().toString();
+                        (new SubmitTask(subreddit.getText().toString(), title.getText().toString(), data, isLink)).execute();
+                    }
                 }
             }
         });
@@ -215,18 +227,23 @@ public class SubmitActivity extends Activity {
         String errorText;
         ProgressDialog progressDialog;
         boolean isLink;
-
-        public SubmitTask(){
+        String subreddit;
+        String title;
+        String data;
+
+        public SubmitTask(String subreddit, String title, String data, boolean isLink){
+            this.isLink = isLink;
+            this.title = title;
+            this.data = data;
+            this.subreddit = subreddit;
             progressDialog = ProgressDialog.show(SubmitActivity.this, "", ("Submitting..."), true);
         }
 
         @Override
         protected Boolean doInBackground(String... strings) {
 
-            isLink = link.isShown();
             try {
-                jsonResult = global.mRedditData.submit(subreddit.getText().toString(), isLink, title.getText().toString(), isLink?link.getText().toString():text.getText().toString());
-
+                jsonResult = global.mRedditData.submit(subreddit, isLink, title, data);
                 return true;
             } catch (RedditData.RedditApiException e) {
                 e.printStackTrace();
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubredditSelectActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/SubredditSelectActivity.java
similarity index 97%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/SubredditSelectActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/SubredditSelectActivity.java
index 79af64a..58156f5 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubredditSelectActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/SubredditSelectActivity.java
@@ -1,1398 +1,1407 @@
-/*
- * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
- * This file is part of Reddinator.
- *
- * Reddinator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * Reddinator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
- */
-package au.com.wallaceit.reddinator;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.ActionBar;
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.ProgressDialog;
-import android.appwidget.AppWidgetManager;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.SharedPreferences.Editor;
-import android.graphics.Color;
-import android.graphics.PorterDuff;
-import android.os.AsyncTask;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.StrictMode;
-import android.preference.PreferenceManager;
-import android.support.v4.view.ViewPager;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.WindowManager;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.AutoCompleteTextView;
-import android.widget.BaseAdapter;
-import android.widget.Button;
-import android.widget.EditText;
-import android.widget.IconTextView;
-import android.widget.LinearLayout;
-import android.widget.ListView;
-import android.widget.RemoteViews;
-import android.widget.Spinner;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.joanzapata.android.iconify.IconDrawable;
-import com.joanzapata.android.iconify.Iconify;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashMap;
-
-public class SubredditSelectActivity extends Activity {
-    private ArrayList<String> subredditList;
-    private ArrayAdapter<String> subsAdapter;
-    private MyMultisAdapter mMultiAdapter;
-    private SharedPreferences mSharedPreferences;
-    private GlobalObjects global;
-    private Button sortBtn;
-    private boolean widgetFirstTimeSetup = false;
-    private boolean needsThemeUpdate = false;
-    private boolean needsFeedUpdate = false;
-    private boolean needsFeedViewUpdate = false;
-    private int mAppWidgetId;
-    private SimpleTabsWidget tabs;
-    private Button refreshButton;
-    private Button addButton;
-
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.subredditselect);
-
-        // load personal list from saved prefereces, if null use default and save
-        mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(SubredditSelectActivity.this);
-        global = ((GlobalObjects) SubredditSelectActivity.this.getApplicationContext());
-
-        // get subreddit list and set adapter
-        subredditList = global.getSubredditManager().getSubredditNames();
-        subsAdapter = new MySubredditsAdapter(this, subredditList);
-        ListView subListView = (ListView) findViewById(R.id.sublist);
-        subListView.setAdapter(subsAdapter);
-        subListView.setTextFilterEnabled(true);
-        subListView.setOnItemClickListener(new OnItemClickListener() {
-            public void onItemClick(AdapterView<?> parent, View view,
-                                    int position, long id) {
-                String subreddit = ((TextView) view.findViewById(R.id.subreddit_name)).getText().toString();
-                global.getSubredditManager().setFeedSubreddit(mAppWidgetId, subreddit);
-                updateFeedAndFinish();
-                //System.out.println(sreddit+" selected");
-            }
-        });
-        subsAdapter.sort(new Comparator<String>() {
-            @Override
-            public int compare(String s, String t1) {
-                return s.compareToIgnoreCase(t1);
-            }
-        });
-        // get multi list and set adapter
-        mMultiAdapter = new MyMultisAdapter(this);
-        ListView multiListView = (ListView) findViewById(R.id.multilist);
-        multiListView.setAdapter(mMultiAdapter);
-        multiListView.setTextFilterEnabled(true);
-        multiListView.setOnItemClickListener(new OnItemClickListener() {
-            public void onItemClick(AdapterView<?> parent, View view,
-                                    int position, long id) {
-                if (position==mMultiAdapter.getCount()-1){
-                    LinearLayout layout = (LinearLayout) getLayoutInflater().inflate(R.layout.dialog_multi_add, parent, false);
-                    final EditText name = (EditText) layout.findViewById(R.id.new_multi_name);
-                    AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
-                    builder.setTitle("Create A Multi").setView(layout)
-                    .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            dialogInterface.dismiss();
-                        }
-                    }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialogInterface, int i) {
-                            if (name.getText().toString().equals("")){
-                                Toast.makeText(SubredditSelectActivity.this, "Please enter a name for the multi", Toast.LENGTH_LONG).show();
-                                return;
-                            }
-                            new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_CREATE).execute(name.getText().toString());
-                            dialogInterface.dismiss();
-                        }
-                    }).show();
-                } else {
-                    JSONObject multiObj = mMultiAdapter.getItem(position);
-                    try {
-                        String name = multiObj.getString("display_name");
-                        String path = multiObj.getString("path");
-                        global.getSubredditManager().setFeed(mAppWidgetId, name, path, true);
-                        updateFeedAndFinish();
-                    } catch (JSONException e) {
-                        e.printStackTrace();
-                        Toast.makeText(SubredditSelectActivity.this, "Error setting multi.", Toast.LENGTH_LONG).show();
-                    }
-                }
-            }
-        });
-
-        Intent intent = getIntent();
-        Bundle extras = intent.getExtras();
-        if (extras != null) {
-            mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID);
-            if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
-                mAppWidgetId = 0; // Id of 4 zeros indicates its the app view, not a widget, that is being updated
-            } else {
-                String action = getIntent().getAction();
-                widgetFirstTimeSetup = action!=null && action.equals("android.appwidget.action.APPWIDGET_CONFIGURE");
-            }
-        } else {
-            mAppWidgetId = 0;
-        }
-
-        final ViewPager pager = (ViewPager) findViewById(R.id.pager);
-        pager.setAdapter(new SimpleTabsAdapter(new String[]{"My Subreddits", "My Multis"}, new int[]{R.id.sublist, R.id.multilist}, SubredditSelectActivity.this, null));
-
-        LinearLayout tabsLayout = (LinearLayout) findViewById(R.id.tab_widget);
-        tabs = new SimpleTabsWidget(SubredditSelectActivity.this, tabsLayout);
-        tabs.setViewPager(pager);
-
-        addButton = (Button) findViewById(R.id.addsrbutton);
-        addButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View arg0) {
-                Intent intent = new Intent(SubredditSelectActivity.this, ViewAllSubredditsActivity.class);
-                startActivityForResult(intent, 1);
-            }
-        });
-        refreshButton = (Button) findViewById(R.id.refreshloginbutton);
-        refreshButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View arg0) {
-                if (global.mRedditData.isLoggedIn()) {
-                    if (pager.getCurrentItem()==1) {
-                        refreshMultireddits();
-                    } else {
-                        refreshSubreddits();
-                    }
-                } else {
-                    global.mRedditData.initiateLogin(SubredditSelectActivity.this);
-                }
-            }
-        });
-        // sort button
-        sortBtn = (Button) findViewById(R.id.sortselect);
-        String sortTxt = "Sort:  " + mSharedPreferences.getString("sort-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), "hot");
-        sortBtn.setText(sortTxt);
-        sortBtn.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View arg0) {
-                showSortDialog();
-            }
-        });
-
-        ActionBar actionBar = getActionBar();
-        if (actionBar != null) {
-            actionBar.setDisplayHomeAsUpEnabled(true);
-        }
-
-        // set theme colors
-        setThemeColors();
-
-        GlobalObjects.doShowWelcomeDialog(SubredditSelectActivity.this);
-    }
-
-    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
-    private void setThemeColors(){
-        ThemeManager.Theme theme = global.mThemeManager.getActiveTheme("appthemepref");
-        int headerColor = Color.parseColor(theme.getValue("header_color"));
-        findViewById(R.id.srtoolbar).setBackgroundColor(headerColor);
-        sortBtn.getBackground().setColorFilter(headerColor, PorterDuff.Mode.ADD);
-        addButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.ADD);
-        refreshButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.ADD);
-        tabs.setBackgroundColor(headerColor);
-        tabs.setInidicatorColor(Color.parseColor(theme.getValue("tab_indicator")));
-        tabs.setTextColor(Color.parseColor(theme.getValue("header_text")));
-        int buttonIconColor = Color.parseColor("#666666");
-        refreshButton.setTextColor(buttonIconColor);
-        addButton.setTextColor(buttonIconColor);
-        sortBtn.setCompoundDrawables(new IconDrawable(this, Iconify.IconValue.fa_sort).color(buttonIconColor).sizeDp(24), null, null, null);
-        if (global.mRedditData.isLoggedIn()) {
-            refreshButton.setCompoundDrawables(new IconDrawable(SubredditSelectActivity.this, Iconify.IconValue.fa_refresh).color(buttonIconColor).sizeDp(24), null, null, null);
-            refreshButton.setText(R.string.refresh);
-        } else {
-            refreshButton.setCompoundDrawables(new IconDrawable(SubredditSelectActivity.this, Iconify.IconValue.fa_key).color(buttonIconColor).sizeDp(24), null, null, null);
-            refreshButton.setText(R.string.login);
-        }
-        refreshButton.setCompoundDrawablePadding(6);
-    }
-
-    @Override
-    protected void onStart() {
-        super.onStart();
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode==1 && data!=null) {
-            try {
-                JSONObject subreddit = new JSONObject(data.getStringExtra("subredditObj"));
-                String name = subreddit.getString("display_name");
-                switch (resultCode) {
-                    case ViewAllSubredditsActivity.RESULT_ADD_SUBREDDIT:
-                        if (global.mRedditData.isLoggedIn() && (!name.equals("Front Page") && !name.equals("all"))) {
-                            new SubscriptionEditTask(SubscriptionEditTask.ACTION_SUBSCRIBE).execute(subreddit);
-                        } else {
-                            global.getSubredditManager().addSubreddit(subreddit);
-                            subredditList.add(name);
-                            refreshSubredditsList();
-                        }
-                        break;
-                    case ViewAllSubredditsActivity.RESULT_SET_SUBREDDIT:
-                        global.getSubredditManager().setFeedSubreddit(mAppWidgetId, name);
-                        updateFeedAndFinish();
-                        break;
-
-                    case ViewAllSubredditsActivity.RESULT_ADD_TO_MULTI:
-                        new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_SUB_ADD).execute(data.getStringExtra("multipath"), name);
-                        break;
-                }
-            } catch (JSONException e) {
-                e.printStackTrace();
-                Toast.makeText(SubredditSelectActivity.this, "Error reading subreddit data", Toast.LENGTH_LONG).show();
-            }
-            return;
-        }
-        if (requestCode==2 && resultCode==3){
-            needsThemeUpdate = true;
-            setThemeColors();
-        }
-    }
-
-    private void updateFeedAndFinish() {
-        if (widgetFirstTimeSetup) {
-            finishWidgetSetup();
-            return;
-        }
-        if (mAppWidgetId != 0) {
-            // refresh widget and close activity (NOTE: put in function)
-            AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(SubredditSelectActivity.this);
-            RemoteViews views = new RemoteViews(getPackageName(), R.layout.widget);
-            views.setTextViewText(R.id.subreddittxt, global.getSubredditManager().getCurrentFeedName(mAppWidgetId));
-            views.setViewVisibility(R.id.srloader, View.VISIBLE);
-            views.setViewVisibility(R.id.erroricon, View.INVISIBLE);
-            // bypass cache if service not loaded
-            global.setBypassCache(true);
-            appWidgetManager.partiallyUpdateAppWidget(mAppWidgetId, views);
-            appWidgetManager.notifyAppWidgetViewDataChanged(mAppWidgetId, R.id.listview);
-        } else {
-            Intent intent = new Intent();
-            intent.putExtra("themeupdate", needsThemeUpdate);
-            setResult(2, intent); // update feed prefs + reload feed
-        }
-        finish();
-    }
-
-    private void finishWidgetSetup(){
-        // for first time setup, widget provider receives this intent in onWidgetOptionsChanged();
-        Intent resultValue = new Intent();
-        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
-        setResult(RESULT_OK, resultValue);
-        finish();
-    }
-
-    // save changes on back press
-    public void onBackPressed() {
-        if (widgetFirstTimeSetup) {
-            finishWidgetSetup();
-            return;
-        }
-        // check if sort has changed
-        if (needsFeedUpdate || needsFeedViewUpdate || needsThemeUpdate) {
-            if (mAppWidgetId != 0) {
-                AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(SubredditSelectActivity.this);
-                RemoteViews views = new RemoteViews(getPackageName(), R.layout.widget);
-                views.setViewVisibility(R.id.srloader, View.VISIBLE);
-                views.setViewVisibility(R.id.erroricon, View.INVISIBLE);
-                // bypass the cached entrys only if the sorting preference has changed
-                if (needsFeedUpdate) {
-                    global.setBypassCache(true);
-                } else {
-                    global.setRefreshView();
-                }
-                if (needsThemeUpdate){
-                    WidgetProvider.updateAppWidgets(SubredditSelectActivity.this, appWidgetManager, new int[]{mAppWidgetId}, false);
-                } else {
-                    appWidgetManager.partiallyUpdateAppWidget(mAppWidgetId, views);
-                }
-                appWidgetManager.notifyAppWidgetViewDataChanged(mAppWidgetId, R.id.listview);
-            } else {
-                Intent intent = new Intent();
-                intent.putExtra("themeupdate", needsThemeUpdate);
-                if (needsFeedUpdate) {
-                    setResult(2, intent); // reload feed and prefs
-                } else {
-                    setResult(1, intent); // tells main activity to update feed prefs
-                }
-                if (needsThemeUpdate){
-                    global.setRefreshView();
-                    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(SubredditSelectActivity.this);
-                    int[] widgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(SubredditSelectActivity.this, WidgetProvider.class));
-                    WidgetProvider.updateAppWidgets(SubredditSelectActivity.this, appWidgetManager, widgetIds, false);
-                    appWidgetManager.notifyAppWidgetViewDataChanged(widgetIds, R.id.listview);
-                }
-            }
-        } else {
-            setResult(0);
-        }
-        finish();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu){
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.subreddit_select_menu, menu);
-        // set options menu view
-        int iconColor;
-        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-            iconColor = Color.parseColor("#8F8F8F");
-        } else {
-            iconColor = Color.parseColor("#DBDBDB");
-        }
-        (menu.findItem(R.id.menu_submit)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_pencil).color(iconColor).actionBarSize());
-        (menu.findItem(R.id.menu_feedprefs)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_list_alt).color(iconColor).actionBarSize());
-        if (mAppWidgetId==0) {
-            (menu.findItem(R.id.menu_widgettheme)).setVisible(false);
-        }
-        (menu.findItem(R.id.menu_widgettheme)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_paint_brush).color(iconColor).actionBarSize());
-        (menu.findItem(R.id.menu_thememanager)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_cogs).color(iconColor).actionBarSize());
-        (menu.findItem(R.id.menu_account)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_reddit_square).color(iconColor).actionBarSize());
-        (menu.findItem(R.id.menu_prefs)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_wrench).color(iconColor).actionBarSize());
-        (menu.findItem(R.id.menu_about)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_info_circle).color(iconColor).actionBarSize());
-
-        return super.onCreateOptionsMenu(menu);
-    }
-
-    @Override
-    public boolean onMenuOpened(int featureId, Menu menu)
-    {
-        if(featureId == Window.FEATURE_ACTION_BAR && menu != null){
-            if(menu.getClass().getSimpleName().equals("MenuBuilder")){
-                try{
-                    Method m = menu.getClass().getDeclaredMethod(
-                            "setOptionalIconsVisible", Boolean.TYPE);
-                    m.setAccessible(true);
-                    m.invoke(menu, true);
-                }
-                catch(NoSuchMethodException e){
-                    System.out.println("Could not display action icons in menu");
-                }
-                catch(Exception e){
-                    throw new RuntimeException(e);
-                }
-            }
-        }
-        return super.onMenuOpened(featureId, menu);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case android.R.id.home:
-                onBackPressed();
-                break;
-
-            case R.id.menu_feedprefs:
-                showFeedPrefsDialog();
-                break;
-
-            case R.id.menu_widgettheme:
-                showWidgetThemeDialog();
-                break;
-
-            case R.id.menu_thememanager:
-                Intent intent = new Intent(SubredditSelectActivity.this, ThemesActivity.class);
-                startActivityForResult(intent, 2);
-                break;
-
-            case R.id.menu_account:
-                Intent accnIntent = new Intent(SubredditSelectActivity.this, WebViewActivity.class);
-                accnIntent.putExtra("url", global.getDefaultMobileSite()+"/user/"+global.mRedditData.getUsername()+"/");
-                startActivity(accnIntent);
-                break;
-
-            case R.id.menu_submit:
-                Intent submitIntent = new Intent(SubredditSelectActivity.this, SubmitActivity.class);
-                startActivity(submitIntent);
-                break;
-
-            case R.id.menu_prefs:
-                Intent intent2 = new Intent(SubredditSelectActivity.this, PrefsActivity.class);
-                startActivityForResult(intent2, 2);
-                break;
-
-            case R.id.menu_about:
-                GlobalObjects.showInfoDialog(this, true);
-                break;
-
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-        return true;
-    }
-
-    // show sort select dialog
-    private void showSortDialog() {
-        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
-        builder.setTitle("Pick a sort, any sort");
-        builder.setItems(R.array.reddit_sorts, new DialogInterface.OnClickListener() {
-            public void onClick(DialogInterface dialog, int which) {
-                Editor prefsedit = mSharedPreferences.edit();
-                String sort = "hot"; // default if fails
-                // find index
-                switch (which) {
-                    case 0:
-                        sort = "hot";
-                        break;
-                    case 1:
-                        sort = "new";
-                        break;
-                    case 2:
-                        sort = "rising";
-                        break;
-                    case 3:
-                        sort = "controversial";
-                        break;
-                    case 4:
-                        sort = "top";
-                        break;
-                }
-                prefsedit.putString("sort-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), sort);
-                prefsedit.apply();
-                // set new text in button
-                String sorttxt = "Sort:  " + sort;
-                sortBtn.setText(sorttxt);
-                needsFeedUpdate = true; // mark feed for updating
-                dialog.dismiss();
-            }
-        });
-        builder.show();
-    }
-
-    private void showFeedPrefsDialog(){
-        final CharSequence[] names = {"Thumbnails", "Thumbs On Top", "Hide Post Info"};
-        final boolean[] initvalue = {mSharedPreferences.getBoolean("thumbnails-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), true), mSharedPreferences.getBoolean("bigthumbs-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), false), mSharedPreferences.getBoolean("hideinf-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), false)};
-        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
-        builder.setTitle("Feed Options");
-        builder.setMultiChoiceItems(names, initvalue, new DialogInterface.OnMultiChoiceClickListener() {
-            public void onClick(DialogInterface dialogInterface, int item, boolean state) {
-                Editor prefsedit = mSharedPreferences.edit();
-                switch (item) {
-                    case 0:
-                        prefsedit.putBoolean("thumbnails-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), state);
-                        break;
-                    case 1:
-                        prefsedit.putBoolean("bigthumbs-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), state);
-                        break;
-                    case 2:
-                        prefsedit.putBoolean("hideinf-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), state);
-                        break;
-                }
-                prefsedit.apply();
-                needsFeedViewUpdate = true;
-            }
-        });
-        builder.setPositiveButton("Close", new DialogInterface.OnClickListener() {
-            public void onClick(DialogInterface dialog, int id) {
-                dialog.cancel();
-            }
-        });
-        builder.create().show();
-    }
-
-    private void showWidgetThemeDialog(){
-
-        // set themes list
-        LinkedHashMap<String, String> themeList = global.mThemeManager.getThemeList(ThemeManager.LISTMODE_ALL);
-        themeList.put("app_select", "Use App theme");
-        final String[] keys = themeList.keySet().toArray(new String[themeList.keySet().size()]);
-        String curTheme = mSharedPreferences.getString("widgettheme-"+mAppWidgetId, "app_select");
-        int curIndex = 0;
-        for (int i=0; i<keys.length; i++){
-            if (keys[i].equals(curTheme)) {
-                curIndex = i;
-                break;
-            }
-        }
-        AlertDialog.Builder builder = new AlertDialog.Builder(this);
-        builder.setTitle("Select Widget Theme")
-        .setSingleChoiceItems(themeList.values().toArray(new String[themeList.values().size()]), curIndex,
-            new DialogInterface.OnClickListener() {
-                @Override
-                public void onClick(DialogInterface dialogInterface, int i) {
-                    needsThemeUpdate = true;
-                    SharedPreferences.Editor editor = mSharedPreferences.edit();
-                    editor.putString("widgettheme-" + mAppWidgetId, keys[i]);
-                    System.out.println(keys[i]);
-                    editor.apply();
-                    dialogInterface.cancel();
-                }
-            }
-        ).setPositiveButton("Close", new DialogInterface.OnClickListener() {
-            public void onClick(DialogInterface dialog, int id) {
-                dialog.cancel();
-            }
-        }).show();
-    }
-
-    // import personal subreddits
-    private void refreshSubreddits() {
-
-        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
-        StrictMode.setThreadPolicy(policy);
-        final ProgressDialog sdialog = ProgressDialog.show(SubredditSelectActivity.this, "Refreshing Subreddits", "One moment...", true);
-        Thread t = new Thread() {
-            public void run() {
-
-                final int listLength;
-                try {
-                    listLength = global.loadAccountSubreddits();
-                } catch (final RedditData.RedditApiException e) {
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        public void run() {
-                            sdialog.dismiss();
-                            // check login required
-                            if (e.isAuthError())
-                                global.mRedditData.initiateLogin(SubredditSelectActivity.this);
-                            // show error
-                            Toast.makeText(SubredditSelectActivity.this, e.getMessage(), Toast.LENGTH_LONG).show();
-                        }
-                    });
-                    return;
-                }
-                runOnUiThread(new Runnable() {
-                    public void run() {
-                        sdialog.dismiss();
-                        if (listLength==0) {
-                            Toast.makeText(SubredditSelectActivity.this, "No subscriptions in your account, \nSuscribe to some subreddits", Toast.LENGTH_LONG).show();
-                        }
-                        refreshSubredditsList();
-                    }
-                });
-            }
-        };
-        t.start();
-    }
-
-    private void refreshMultireddits() {
-
-        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
-        StrictMode.setThreadPolicy(policy);
-        final ProgressDialog sdialog = ProgressDialog.show(SubredditSelectActivity.this, "Refreshing Multis", "One moment...", true);
-        Thread t = new Thread() {
-            public void run() {
-
-                final int listLength;
-                try {
-                    listLength = global.loadAccountMultis();
-                } catch (final RedditData.RedditApiException e) {
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        public void run() {
-                            sdialog.dismiss();
-                            // check login required
-                            if (e.isAuthError())
-                                global.mRedditData.initiateLogin(SubredditSelectActivity.this);
-                            // show error
-                            Toast.makeText(SubredditSelectActivity.this, e.getMessage(), Toast.LENGTH_LONG).show();
-                        }
-                    });
-                    return;
-                }
-                runOnUiThread(new Runnable() {
-                    public void run() {
-                        sdialog.dismiss();
-                        if (listLength == 0) {
-                            Toast.makeText(SubredditSelectActivity.this, "No multis in your account \nClick the add multi button to create some", Toast.LENGTH_LONG).show();
-                        }
-                        mMultiAdapter.refreshMultis();
-                    }
-                });
-            }
-        };
-        t.start();
-    }
-
-    private void refreshSubredditsList(){
-        subredditList = global.getSubredditManager().getSubredditNames();
-        subsAdapter.clear();
-        subsAdapter.addAll(subredditList);
-        subsAdapter.notifyDataSetChanged();
-        subsAdapter.sort(new Comparator<String>() {
-            @Override
-            public int compare(String s, String t1) {
-                return s.compareToIgnoreCase(t1);
-            }
-        });
-    }
-
-    // list adapter
-    class MySubredditsAdapter extends ArrayAdapter<String> {
-        private LayoutInflater inflater;
-
-        public MySubredditsAdapter(Context context, ArrayList<String> objects) {
-            super(context, R.layout.myredditlistitem, R.id.subreddit_name, objects);
-            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        }
-
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-            super.getView(position, convertView, parent);
-            ViewHolder viewHolder;
-            if (convertView == null || convertView.getTag() == null) {
-                // inflate new view
-                convertView = inflater.inflate(R.layout.myredditlistitem, parent, false);
-                viewHolder = new ViewHolder();
-                viewHolder.name = (TextView) convertView.findViewById(R.id.subreddit_name);
-                viewHolder.deleteIcon = (IconTextView) convertView.findViewById(R.id.subreddit_delete_btn);
-                viewHolder.filterIcon = (IconTextView) convertView.findViewById(R.id.subreddit_filter_btn);
-            } else {
-                viewHolder = (ViewHolder) convertView.getTag();
-            }
-            // setup the row
-            viewHolder.name.setText(getItem(position));
-            viewHolder.deleteIcon.setOnClickListener(new OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    final String sreddit = ((TextView) ((View) v.getParent()).findViewById(R.id.subreddit_name)).getText().toString();
-                    if (global.mRedditData.isLoggedIn() && (!sreddit.equals("Front Page") && !sreddit.equals("all"))) {
-                        new AlertDialog.Builder(SubredditSelectActivity.this).setTitle("Unsubscribe")
-                                .setMessage("Are you sure you want to unsubscribe from " + sreddit + "?")
-                                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-                                    @Override
-                                    public void onClick(DialogInterface dialogInterface, int i) {
-                                    }
-                                }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
-                            @Override
-                            public void onClick(DialogInterface dialogInterface, int i) {
-                                new SubscriptionEditTask(SubscriptionEditTask.ACTION_UNSUBSCRIBE).execute(sreddit);
-                            }
-                        }).show();
-                    } else {
-                        global.getSubredditManager().removeSubreddit(sreddit);
-                        subredditList.remove(sreddit);
-                        refreshSubredditsList();
-                    }
-                }
-            });
-            if (getItem(position).equals("all")){
-                viewHolder.filterIcon.setVisibility(View.VISIBLE);
-                viewHolder.filterIcon.setOnClickListener(new OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        showFilterEditDialog();
-                    }
-                });
-            } else{
-                viewHolder.filterIcon.setVisibility(View.GONE);
-            }
-
-            convertView.setTag(viewHolder);
-
-            return convertView;
-        }
-
-        class ViewHolder {
-            TextView name;
-            IconTextView deleteIcon;
-            IconTextView filterIcon;
-        }
-    }
-
-    class MyMultisAdapter extends BaseAdapter {
-        private LayoutInflater inflater;
-        private ArrayList<JSONObject> multiList;
-
-        public MyMultisAdapter(Context context) {
-            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-            refreshMultis();
-        }
-
-        public void refreshMultis(){
-            multiList = global.getSubredditManager().getMultiList();
-            Collections.sort(multiList, new Comparator<JSONObject>() {
-                @Override
-                public int compare(JSONObject s, JSONObject t1) {
-                    try {
-                        return s.getString("display_name").compareToIgnoreCase(t1.getString("display_name"));
-                    } catch (JSONException e) {
-                        e.printStackTrace();
-                        return 0;
-                    }
-                }
-            });
-            this.notifyDataSetChanged();
-        }
-
-        @Override
-        public View getView(int position, View convertView, final ViewGroup parent) {
-            //super.getView(position, convertView, parent);
-            ViewHolder viewHolder;
-            if (convertView == null || convertView.getTag() == null) {
-                // inflate new view
-                viewHolder = new ViewHolder();
-                if (position==multiList.size()) {
-                    convertView = inflater.inflate(R.layout.mymultilistitem_add, parent, false);
-                } else {
-                    convertView = inflater.inflate(R.layout.mymultilistitem, parent, false);
-                    viewHolder.name = (TextView) convertView.findViewById(R.id.multireddit_name);
-                    viewHolder.deleteIcon = (IconTextView) convertView.findViewById(R.id.multi_delete_btn);
-                    viewHolder.editIcon = (IconTextView) convertView.findViewById(R.id.multi_edit_btn);
-                }
-                //viewHolder.subsIcon = (IconTextView) convertView.findViewById(R.id.multi_editsubs_btn);
-            } else {
-                viewHolder = (ViewHolder) convertView.getTag();
-            }
-            if (position<multiList.size()) {
-                JSONObject multiObj = getItem(position);
-                final String displayName, path;
-                final boolean canEdit;
-                try {
-                    displayName = multiObj.getString("display_name");
-                    path = multiObj.getString("path");
-                    canEdit = multiObj.getBoolean("can_edit");
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                    return convertView;
-                }
-                // setup the row
-                viewHolder.name.setText(displayName);
-                viewHolder.deleteIcon.setOnClickListener(new OnClickListener() {
-                    @Override
-                    public void onClick(View v) {
-                        if (canEdit) {
-                            showMultiDeleteDialog(path);
-                        } else {
-                            global.getSubredditManager().removeMulti(path);
-                            subsAdapter.notifyDataSetChanged();
-                        }
-                    }
-                });
-                if (canEdit) {
-                    viewHolder.editIcon.setVisibility(View.VISIBLE);
-                    //viewHolder.subsIcon.setVisibility(View.VISIBLE);
-                    viewHolder.editIcon.setOnClickListener(new OnClickListener() {
-                        @Override
-                        public void onClick(View view) {
-                            showMultiEditDialog(path);
-                        }
-                    });
-                    // will use for viewing subreddits list when not editable; later!
-                    /*viewHolder.subsIcon.setOnClickListener(new OnClickListener() {
-                        @Override
-                        public void onClick(View view) {
-                            showMultiEditDialog(path);
-                        }
-                    });*/
-                }
-            }
-
-            convertView.setTag(viewHolder);
-
-            return convertView;
-        }
-
-        @Override
-        public int getCount() {
-            return multiList.size()+1;
-        }
-
-        @Override
-        public int getViewTypeCount(){
-            return 2;
-        }
-
-        @Override
-        public int getItemViewType(int position){
-            if (position==multiList.size())
-                return 1;
-            return 0;
-        }
-
-        public JSONObject getItem(int position){
-           return multiList.get(position);
-        }
-
-        @Override
-        public long getItemId(int i) {
-            return 0;
-        }
-
-        class ViewHolder {
-            TextView name;
-            IconTextView deleteIcon;
-            IconTextView editIcon;
-            //IconTextView subsIcon;
-        }
-    }
-
-    private void showMultiDeleteDialog(final String multiPath){
-        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
-        builder.setTitle("Delete Multi").setMessage("Are you sure you want to delete this multi from your account?");
-        builder.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialogInterface, int i) {
-                dialogInterface.dismiss();
-            }
-        }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialogInterface, int i) {
-                dialogInterface.dismiss();
-                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_DELETE).execute(multiPath);
-            }
-        }).show();
-    }
-
-    private void showMultiRenameDialog(final String multiPath){
-        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
-        final EditText nameInput = new EditText(SubredditSelectActivity.this);
-        nameInput.setHint("new multi name");
-        builder.setTitle("Rename Multi").setView(nameInput)
-        .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialogInterface, int i) {
-                dialogInterface.dismiss();
-            }
-        }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
-            @Override
-            public void onClick(DialogInterface dialogInterface, int i) {
-                dialogInterface.dismiss();
-                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_RENAME).execute(multiPath, nameInput.getText().toString().replaceAll("\\s+",""));
-            }
-        }).show();
-    }
-
-    private SubsListAdapter multiSubsAdapter;
-    private AlertDialog multiDialog;
-    private TextView multiName;
-    private void showMultiEditDialog(final String multiPath){
-        JSONObject multiObj = global.getSubredditManager().getMultiData(multiPath);
-
-        @SuppressLint("InflateParams")
-        LinearLayout dialogView =  (LinearLayout)  getLayoutInflater().inflate(R.layout.dialog_multi_edit, null); // passing null okay for dialog
-        final Button saveButton = (Button) dialogView.findViewById(R.id.multi_save_button);
-        final Button renameButton = (Button) dialogView.findViewById(R.id.multi_rename_button);
-        multiName = (TextView) dialogView.findViewById(R.id.multi_pname);
-        final EditText displayName = (EditText) dialogView.findViewById(R.id.multi_name);
-        final EditText description = (EditText) dialogView.findViewById(R.id.multi_description);
-        final EditText color = (EditText) dialogView.findViewById(R.id.multi_color);
-        final Spinner icon = (Spinner) dialogView.findViewById(R.id.multi_icon);
-        final Spinner visibility = (Spinner) dialogView.findViewById(R.id.multi_visibility);
-        final Spinner weighting = (Spinner) dialogView.findViewById(R.id.multi_weighting);
-
-        ArrayAdapter<CharSequence> iconAdapter = ArrayAdapter.createFromResource(SubredditSelectActivity.this, R.array.multi_icons, android.R.layout.simple_spinner_item);
-        iconAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-        icon.setAdapter(iconAdapter);
-        ArrayAdapter<CharSequence> visibilityAdapter = ArrayAdapter.createFromResource(SubredditSelectActivity.this, R.array.multi_visibility, android.R.layout.simple_spinner_item);
-        visibilityAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-        visibility.setAdapter(visibilityAdapter);
-        ArrayAdapter<CharSequence> weightsAdapter = ArrayAdapter.createFromResource(SubredditSelectActivity.this, R.array.multi_weights, android.R.layout.simple_spinner_item);
-        weightsAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
-        weighting.setAdapter(weightsAdapter);
-
-        try {
-            multiName.setText(multiObj.getString("name"));
-            displayName.setText(multiObj.getString("display_name"));
-            description.setText(multiObj.getString("description_md"));
-            color.setText(multiObj.getString("key_color"));
-            String iconName = multiObj.getString("icon_name");
-            icon.setSelection(iconAdapter.getPosition(iconName.equals("")?"none":iconName));
-            visibility.setSelection(iconAdapter.getPosition(multiObj.getString("visibility")));
-            weighting.setSelection(iconAdapter.getPosition(multiObj.getString("weighting_scheme")));
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-
-        ViewPager pager = (ViewPager) dialogView.findViewById(R.id.multi_pager);
-        LinearLayout tabsWidget = (LinearLayout) dialogView.findViewById(R.id.multi_tab_widget);
-        pager.setAdapter(new SimpleTabsAdapter(new String[]{"Subreddits", "Settings"}, new int[]{R.id.multi_subreddits, R.id.multi_settings}, SubredditSelectActivity.this, dialogView));
-        SimpleTabsWidget simpleTabsWidget = new SimpleTabsWidget(SubredditSelectActivity.this, tabsWidget);
-        simpleTabsWidget.setViewPager(pager);
-        ThemeManager.Theme theme = global.mThemeManager.getActiveTheme("appthemepref");
-        int headerColor = Color.parseColor(theme.getValue("header_color"));
-        int headerText = Color.parseColor(theme.getValue("header_text"));
-        simpleTabsWidget.setBackgroundColor(headerColor);
-        simpleTabsWidget.setTextColor(headerText);
-        simpleTabsWidget.setInidicatorColor(Color.parseColor(theme.getValue("tab_indicator")));
-
-        ListView subList = (ListView) dialogView.findViewById(R.id.multi_subredditList);
-        multiSubsAdapter = new SubsListAdapter(SubredditSelectActivity.this, multiPath);
-        subList.setAdapter(multiSubsAdapter);
-        renameButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.MULTIPLY);
-        renameButton.setTextColor(headerText);
-        renameButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                showMultiRenameDialog(multiPath);
-            }
-        });
-
-                saveButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.MULTIPLY);
-        saveButton.setTextColor(headerText);
-        saveButton.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                System.out.println("Save multi");
-                JSONObject multiObj = new JSONObject();
-                try {
-                    multiObj.put("decription_md", description.getText().toString());
-                    multiObj.put("display_name", displayName.getText().toString());
-                    multiObj.put("icon_name", icon.getSelectedItem().toString().equals("none")?"":icon.getSelectedItem().toString());
-                    multiObj.put("key_color", color.getText().toString());
-                    multiObj.put("subreddits", global.getSubredditManager().getMultiData(multiPath).getJSONArray("subreddits"));
-                    multiObj.put("visibility", visibility.getSelectedItem().toString());
-                    multiObj.put("weighting_scheme", weighting.getSelectedItem().toString());
-
-                    new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_EDIT).execute(multiPath, multiObj);
-
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-
-        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
-
-        multiDialog = builder.setView(dialogView).show();
-    }
-
-    private void showFilterEditDialog(){
-
-        @SuppressLint("InflateParams")
-        LinearLayout dialogView =  (LinearLayout)  getLayoutInflater().inflate(R.layout.dialog_filter, null); // passing null okay for dialog
-
-        ThemeManager.Theme theme = global.mThemeManager.getActiveTheme("appthemepref");
-        int headerColor = Color.parseColor(theme.getValue("header_color"));
-        int headerText = Color.parseColor(theme.getValue("header_text"));
-        dialogView.findViewById(R.id.filter_header).setBackgroundColor(headerColor);
-        ((TextView) dialogView.findViewById(R.id.filter_headert1)).setTextColor(headerText);
-        ((TextView) dialogView.findViewById(R.id.filter_headert2)).setTextColor(headerText);
-
-        ListView subList = (ListView) dialogView.findViewById(R.id.filter_subredditList);
-        final SubsListAdapter filterSubsAdapter = new SubsListAdapter(SubredditSelectActivity.this, null);
-        subList.setAdapter(filterSubsAdapter);
-
-        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
-        builder.setView(dialogView)
-                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialogInterface, int i) {
-                        dialogInterface.dismiss();
-                    }
-                })
-                .setPositiveButton("OK", new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialogInterface, int i) {
-                        dialogInterface.dismiss();
-                        global.getSubredditManager().setAllFilter(filterSubsAdapter.getSubsList());
-                        needsFeedUpdate = true; // mark feed for updating
-                    }
-                }).show().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
-    }
-
-    class SubsListAdapter extends BaseAdapter {
-        private final int MODE_MULTI = 1;
-        private int mode = 0;
-        private LayoutInflater inflater;
-        private ArrayList<String> subsList;
-        private String multiPath;
-        private SubAutoCompleteAdapter autoCompleteAdapter;
-
-        public SubsListAdapter(Context context, String multiPath) {
-            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-            autoCompleteAdapter = new SubAutoCompleteAdapter(context, R.layout.autocomplete_list_item);
-            if (multiPath!=null) {
-                this.multiPath = multiPath;
-                mode = MODE_MULTI;
-            }
-            refreshList();
-        }
-
-        public void refreshList(){
-            if (mode==MODE_MULTI) {
-                subsList = global.getSubredditManager().getMultiSubreddits(multiPath);
-            } else {
-                subsList = global.getSubredditManager().getAllFilter();
-            }
-            Collections.sort(subsList, new Comparator<String>() {
-                @Override
-                public int compare(String s, String t1) {
-                    return s.compareToIgnoreCase(t1);
-                }
-            });
-            this.notifyDataSetChanged();
-        }
-
-        @Override
-        public View getView(int position, View convertView, final ViewGroup parent) {
-            //super.getView(position, convertView, parent);
-            final ViewHolder viewHolder;
-            if (convertView == null || convertView.getTag() == null) {
-                // inflate new view
-                if (position== subsList.size()) {
-                    convertView = inflater.inflate(R.layout.multi_sublist_add_item, parent, false);
-                    viewHolder = new ViewHolder();
-                    viewHolder.nameInput = (AutoCompleteTextView) convertView.findViewById(R.id.subreddit_name);
-                    viewHolder.addIcon = (IconTextView) convertView.findViewById(R.id.multi_sub_add);
-                    viewHolder.searchIcon = (IconTextView) convertView.findViewById(R.id.multi_sub_search);
-                } else {
-                    convertView = inflater.inflate(R.layout.multi_sublist_item, parent, false);
-                    viewHolder = new ViewHolder();
-                    viewHolder.name = (TextView) convertView.findViewById(R.id.subreddit_name);
-                    viewHolder.removeIcon = (IconTextView) convertView.findViewById(R.id.multi_sub_remove);
-                }
-            } else {
-                viewHolder = (ViewHolder) convertView.getTag();
-            }
-            // setup the row
-            if (position== subsList.size()) {
-                viewHolder.nameInput.setAdapter(autoCompleteAdapter);
-                viewHolder.nameInput.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-                    @Override
-                    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
-                        String subreddit = viewHolder.nameInput.getText().toString();
-                        performAdd(subreddit);
-                        viewHolder.nameInput.setText("");
-                    }
-                });
-                viewHolder.addIcon.setOnClickListener(new OnClickListener() {
-                    @Override
-                    public void onClick(View view) {
-                        String subreddit = viewHolder.nameInput.getText().toString();
-                        if (subreddit.equals("")){
-                            Toast.makeText(SubredditSelectActivity.this, "Please enter a subreddit name", Toast.LENGTH_SHORT).show();
-                            return;
-                        }
-                        performAdd(subreddit);
-                        viewHolder.nameInput.setText("");
-                    }
-                });
-                if (mode==MODE_MULTI) {
-                    viewHolder.searchIcon.setVisibility(View.VISIBLE);
-                    viewHolder.searchIcon.setOnClickListener(new OnClickListener() {
-                        @Override
-                        public void onClick(View view) {
-                            Intent intent = new Intent(SubredditSelectActivity.this, ViewAllSubredditsActivity.class);
-                            intent.setAction(ViewAllSubredditsActivity.ACTION_ADD_MULTI_SUB);
-                            intent.putExtra("multipath", multiPath);
-                            startActivityForResult(intent, 1);
-                        }
-                    });
-                } else {
-                    // search isn't implemented here yet, you could if you want to but I don't see much point
-                    viewHolder.searchIcon.setVisibility(View.GONE);
-                }
-            } else {
-                final String subreddit = getItem(position);
-                viewHolder.name.setText(subreddit);
-                viewHolder.removeIcon.setOnClickListener(new OnClickListener() {
-                    @Override
-                    public void onClick(View view) {
-                        performRemove(subreddit);
-                    }
-                });
-            }
-            convertView.setTag(viewHolder);
-
-            return convertView;
-        }
-
-        private ArrayList<String> getSubsList(){
-            return subsList;
-        }
-
-        private void performAdd(String subreddit){
-            System.out.println("Adding Sub: " + subreddit);
-            if (mode==MODE_MULTI) {
-                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_SUB_ADD).execute(multiPath, subreddit);
-            } else {
-                subsList.add(subreddit);
-                notifyDataSetChanged();
-            }
-        }
-
-        private void performRemove(String subreddit){
-            System.out.println("Removing Sub: "+subreddit);
-            if (mode==MODE_MULTI) {
-                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_SUB_REMOVE).execute(multiPath, subreddit);
-            } else {
-                subsList.remove(subreddit);
-                notifyDataSetChanged();
-            }
-        }
-
-        @Override
-        public int getViewTypeCount(){
-            return 2;
-        }
-
-        @Override
-        public int getItemViewType(int position){
-            if (position== subsList.size())
-                return 1;
-            return 0;
-        }
-
-        @Override
-        public int getCount(){
-            return subsList.size()+1;
-        }
-
-        @Override
-        public String getItem(int i) {
-            return subsList.get(i);
-        }
-
-        @Override
-        public long getItemId(int i) {
-            return 0;
-        }
-
-        class ViewHolder {
-            TextView name;
-            AutoCompleteTextView nameInput;
-            IconTextView addIcon;
-            IconTextView removeIcon;
-            IconTextView searchIcon;
-        }
-
-    }
-
-    class SubscriptionEditTask extends AsyncTask<Object, Long, Boolean> {
-        public static final int ACTION_MULTI_COPY = 0;
-        public static final int ACTION_MULTI_CREATE = 1;
-        public static final int ACTION_MULTI_EDIT = 2;
-        public static final int ACTION_MULTI_SUB_ADD = 3;
-        public static final int ACTION_MULTI_SUB_REMOVE = 4;
-        public static final int ACTION_MULTI_DELETE = 5;
-        public static final int ACTION_MULTI_RENAME = 6;
-        public static final int ACTION_SUBSCRIBE = 7;
-        public static final int ACTION_UNSUBSCRIBE = 8;
-        private JSONObject result;
-        private Exception exception;
-        private int action;
-        private Object[] params;
-        ProgressDialog progressDialog;
-
-        public SubscriptionEditTask(int action){
-            String loadingMessage = "";
-            switch (action) {
-                case ACTION_SUBSCRIBE:
-                    loadingMessage = "Subscribing...";
-                    break;
-                case ACTION_UNSUBSCRIBE:
-                    loadingMessage = "Unsubscribing...";
-                    break;
-                case ACTION_MULTI_COPY:
-                    loadingMessage = "Copying Multi...";
-                    break;
-                case ACTION_MULTI_CREATE:
-                    loadingMessage = "Creating Multi...";
-                    break;
-                case ACTION_MULTI_EDIT:
-                case ACTION_MULTI_RENAME:
-                case ACTION_MULTI_SUB_ADD:
-                case ACTION_MULTI_SUB_REMOVE:
-                    loadingMessage = "Updating Multi...";
-                    break;
-                case ACTION_MULTI_DELETE:
-                    loadingMessage = "Deleting Multi...";
-                    break;
-            }
-            progressDialog = ProgressDialog.show(SubredditSelectActivity.this, loadingMessage, loadingMessage, true);
-            this.action = action;
-        }
-
-        @Override
-        protected Boolean doInBackground(Object... strParams) {
-            this.params = strParams;
-            String id;
-            try {
-                switch (action){
-                    case ACTION_SUBSCRIBE:
-                        id = ((JSONObject) strParams[0]).getString("name");
-                        result = global.mRedditData.subscribe(id, true);
-                        break;
-
-                    case ACTION_UNSUBSCRIBE:
-                        id = global.getSubredditManager().getSubredditData(strParams[0].toString()).getString("name");
-                        result = global.mRedditData.subscribe(id, false);
-                        break;
-
-                    case ACTION_MULTI_COPY:
-                        result = global.mRedditData.copyMulti(strParams[0].toString(), strParams[1].toString());
-                        break;
-
-                    case ACTION_MULTI_CREATE:
-                        try {
-                            JSONObject multiObj = new JSONObject();
-                            multiObj.put("display_name", strParams[0].toString());
-                            multiObj.put("decription_md", "");
-                            multiObj.put("icon_name", "");
-                            multiObj.put("key_color", "#CEE3F8");
-                            multiObj.put("subreddits", new JSONArray());
-                            multiObj.put("visibility", "private");
-                            multiObj.put("weighting_scheme", "classic");
-                            result = global.mRedditData.createMulti(strParams[0].toString(), multiObj);
-                        } catch (JSONException e) {
-                            e.printStackTrace();
-                            return false;
-                        }
-                        break;
-
-                    case ACTION_MULTI_EDIT:
-                        result = global.mRedditData.editMulti(strParams[0].toString(), (JSONObject) strParams[1]);
-                        break;
-
-                    case ACTION_MULTI_SUB_ADD:
-                        result = global.mRedditData.addMultiSubreddit(strParams[0].toString(), strParams[1].toString());
-                        break;
-
-                    case ACTION_MULTI_SUB_REMOVE:
-                        global.mRedditData.removeMultiSubreddit(strParams[0].toString(), strParams[1].toString());
-                        break;
-
-                    case ACTION_MULTI_DELETE:
-                        global.mRedditData.deleteMulti(strParams[0].toString());
-                        break;
-
-                    case ACTION_MULTI_RENAME:
-                        result = global.mRedditData.renameMulti(strParams[0].toString(), strParams[1].toString());
-                        break;
-                }
-                return true;
-            } catch (RedditData.RedditApiException e) {
-                e.printStackTrace();
-                exception = e;
-            } catch (JSONException e) {
-                e.printStackTrace();
-            }
-            return false;
-        }
-
-        @Override
-        protected void onPostExecute(Boolean result) {
-            progressDialog.dismiss();
-            ArrayList<String> subreddits;
-            if (result) {
-                //if (this.result!=null)
-                    //System.out.println("resultData: "+this.result.toString());
-                switch (action) {
-                    case ACTION_SUBSCRIBE:
-                        global.getSubredditManager().addSubreddit((JSONObject) params[0]);
-                        try {
-                            subredditList.add(0, ((JSONObject) params[0]).getString("display_name"));
-                        } catch (JSONException e) {
-                            e.printStackTrace();
-                        }
-                        refreshSubredditsList();
-                        break;
-                    case ACTION_UNSUBSCRIBE:
-                        global.getSubredditManager().removeSubreddit(params[0].toString());
-                        subredditList.remove(params[0].toString());
-                        refreshSubredditsList();
-                        break;
-                    case ACTION_MULTI_COPY:
-
-                        break;
-                    case ACTION_MULTI_CREATE:
-                        try {
-                            if (this.result==null) return;
-                            JSONObject multiObj = this.result.getJSONObject("data");
-                            String path = multiObj.getString("path");
-                            global.getSubredditManager().setMultiData(path, multiObj);
-                            showMultiEditDialog(path);
-                        } catch (JSONException e) {
-                            e.printStackTrace();
-                        }
-                        mMultiAdapter.refreshMultis();
-                        break;
-                    case ACTION_MULTI_EDIT:
-                        try {
-                            if (this.result==null) return;
-                            JSONObject multiObj = this.result.getJSONObject("data");
-                            global.getSubredditManager().setMultiData(params[0].toString(), multiObj);
-                        } catch (JSONException e) {
-                            e.printStackTrace();
-                        }
-                        multiDialog.dismiss();
-                        mMultiAdapter.refreshMultis();
-                        break;
-                    case ACTION_MULTI_SUB_ADD:
-                        subreddits = global.getSubredditManager().getMultiSubreddits(params[0].toString());
-                        subreddits.add(params[1].toString());
-                        global.getSubredditManager().setMultiSubs(params[0].toString(), subreddits);
-                        multiSubsAdapter.refreshList();
-                        break;
-                    case ACTION_MULTI_SUB_REMOVE:
-                        subreddits = global.getSubredditManager().getMultiSubreddits(params[0].toString());
-                        subreddits.remove(params[1].toString());
-                        global.getSubredditManager().setMultiSubs(params[0].toString(), subreddits);
-                        multiSubsAdapter.refreshList();
-                        break;
-                    case ACTION_MULTI_DELETE:
-                        global.getSubredditManager().removeMulti(params[0].toString());
-                        mMultiAdapter.refreshMultis();
-                        break;
-                    case ACTION_MULTI_RENAME:
-                        global.getSubredditManager().removeMulti(params[0].toString());
-                        try {
-                            JSONObject multiObj = this.result.getJSONObject("data");
-                            String path = multiObj.getString("path");
-                            global.getSubredditManager().setMultiData(path, multiObj);
-                            multiName.setText(multiObj.getString("name"));
-                        } catch (JSONException e) {
-                            e.printStackTrace();
-                        }
-                        mMultiAdapter.refreshMultis();
-                        break;
-                }
-            } else {
-                // check login required
-                if (exception instanceof RedditData.RedditApiException && ((RedditData.RedditApiException)exception).isAuthError())
-                    global.mRedditData.initiateLogin(SubredditSelectActivity.this);
-                // show error
-                Toast.makeText(SubredditSelectActivity.this, exception.getMessage(), Toast.LENGTH_LONG).show();
-            }
-        }
-    }
-}
+/*
+ * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
+ * This file is part of Reddinator.
+ *
+ * Reddinator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Reddinator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
+ */
+package au.com.wallaceit.reddinator.activity;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.ActionBar;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.ProgressDialog;
+import android.appwidget.AppWidgetManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.graphics.Color;
+import android.graphics.PorterDuff;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.StrictMode;
+import android.preference.PreferenceManager;
+import android.support.v4.view.ViewPager;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ArrayAdapter;
+import android.widget.AutoCompleteTextView;
+import android.widget.BaseAdapter;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.IconTextView;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.RemoteViews;
+import android.widget.Spinner;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.joanzapata.android.iconify.IconDrawable;
+import com.joanzapata.android.iconify.Iconify;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.LinkedHashMap;
+
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.RedditData;
+import au.com.wallaceit.reddinator.ui.SimpleTabsAdapter;
+import au.com.wallaceit.reddinator.ui.SimpleTabsWidget;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+import au.com.wallaceit.reddinator.service.WidgetProvider;
+import au.com.wallaceit.reddinator.ui.SubAutoCompleteAdapter;
+
+public class SubredditSelectActivity extends Activity {
+    private ArrayList<String> subredditList;
+    private ArrayAdapter<String> subsAdapter;
+    private MyMultisAdapter mMultiAdapter;
+    private SharedPreferences mSharedPreferences;
+    private Reddinator global;
+    private Button sortBtn;
+    private boolean widgetFirstTimeSetup = false;
+    private boolean needsThemeUpdate = false;
+    private boolean needsFeedUpdate = false;
+    private boolean needsFeedViewUpdate = false;
+    private int mAppWidgetId;
+    private SimpleTabsWidget tabs;
+    private Button refreshButton;
+    private Button addButton;
+
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.subredditselect);
+
+        // load personal list from saved prefereces, if null use default and save
+        mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(SubredditSelectActivity.this);
+        global = ((Reddinator) SubredditSelectActivity.this.getApplicationContext());
+
+        // get subreddit list and set adapter
+        subredditList = global.getSubredditManager().getSubredditNames();
+        subsAdapter = new MySubredditsAdapter(this, subredditList);
+        ListView subListView = (ListView) findViewById(R.id.sublist);
+        subListView.setAdapter(subsAdapter);
+        subListView.setTextFilterEnabled(true);
+        subListView.setOnItemClickListener(new OnItemClickListener() {
+            public void onItemClick(AdapterView<?> parent, View view,
+                                    int position, long id) {
+                String subreddit = ((TextView) view.findViewById(R.id.subreddit_name)).getText().toString();
+                global.getSubredditManager().setFeedSubreddit(mAppWidgetId, subreddit);
+                updateFeedAndFinish();
+                //System.out.println(sreddit+" selected");
+            }
+        });
+        subsAdapter.sort(new Comparator<String>() {
+            @Override
+            public int compare(String s, String t1) {
+                return s.compareToIgnoreCase(t1);
+            }
+        });
+        // get multi list and set adapter
+        mMultiAdapter = new MyMultisAdapter(this);
+        ListView multiListView = (ListView) findViewById(R.id.multilist);
+        multiListView.setAdapter(mMultiAdapter);
+        multiListView.setTextFilterEnabled(true);
+        multiListView.setOnItemClickListener(new OnItemClickListener() {
+            public void onItemClick(AdapterView<?> parent, View view,
+                                    int position, long id) {
+                if (position==mMultiAdapter.getCount()-1){
+                    LinearLayout layout = (LinearLayout) getLayoutInflater().inflate(R.layout.dialog_multi_add, parent, false);
+                    final EditText name = (EditText) layout.findViewById(R.id.new_multi_name);
+                    AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
+                    builder.setTitle("Create A Multi").setView(layout)
+                    .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            dialogInterface.dismiss();
+                        }
+                    }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
+                        @Override
+                        public void onClick(DialogInterface dialogInterface, int i) {
+                            if (name.getText().toString().equals("")){
+                                Toast.makeText(SubredditSelectActivity.this, "Please enter a name for the multi", Toast.LENGTH_LONG).show();
+                                return;
+                            }
+                            new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_CREATE).execute(name.getText().toString());
+                            dialogInterface.dismiss();
+                        }
+                    }).show();
+                } else {
+                    JSONObject multiObj = mMultiAdapter.getItem(position);
+                    try {
+                        String name = multiObj.getString("display_name");
+                        String path = multiObj.getString("path");
+                        global.getSubredditManager().setFeed(mAppWidgetId, name, path, true);
+                        updateFeedAndFinish();
+                    } catch (JSONException e) {
+                        e.printStackTrace();
+                        Toast.makeText(SubredditSelectActivity.this, "Error setting multi.", Toast.LENGTH_LONG).show();
+                    }
+                }
+            }
+        });
+
+        Intent intent = getIntent();
+        Bundle extras = intent.getExtras();
+        if (extras != null) {
+            mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID);
+            if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {
+                mAppWidgetId = 0; // Id of 4 zeros indicates its the app view, not a widget, that is being updated
+            } else {
+                String action = getIntent().getAction();
+                widgetFirstTimeSetup = action!=null && action.equals("android.appwidget.action.APPWIDGET_CONFIGURE");
+            }
+        } else {
+            mAppWidgetId = 0;
+        }
+
+        final ViewPager pager = (ViewPager) findViewById(R.id.pager);
+        pager.setAdapter(new SimpleTabsAdapter(new String[]{"My Subreddits", "My Multis"}, new int[]{R.id.sublist, R.id.multilist}, SubredditSelectActivity.this, null));
+
+        LinearLayout tabsLayout = (LinearLayout) findViewById(R.id.tab_widget);
+        tabs = new SimpleTabsWidget(SubredditSelectActivity.this, tabsLayout);
+        tabs.setViewPager(pager);
+
+        addButton = (Button) findViewById(R.id.addsrbutton);
+        addButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View arg0) {
+                Intent intent = new Intent(SubredditSelectActivity.this, ViewAllSubredditsActivity.class);
+                startActivityForResult(intent, 1);
+            }
+        });
+        refreshButton = (Button) findViewById(R.id.refreshloginbutton);
+        refreshButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View arg0) {
+                if (global.mRedditData.isLoggedIn()) {
+                    if (pager.getCurrentItem()==1) {
+                        refreshMultireddits();
+                    } else {
+                        refreshSubreddits();
+                    }
+                } else {
+                    global.mRedditData.initiateLogin(SubredditSelectActivity.this);
+                }
+            }
+        });
+        // sort button
+        sortBtn = (Button) findViewById(R.id.sortselect);
+        String sortTxt = "Sort:  " + mSharedPreferences.getString("sort-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), "hot");
+        sortBtn.setText(sortTxt);
+        sortBtn.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View arg0) {
+                showSortDialog();
+            }
+        });
+
+        ActionBar actionBar = getActionBar();
+        if (actionBar != null) {
+            actionBar.setDisplayHomeAsUpEnabled(true);
+        }
+
+        // set theme colors
+        setThemeColors();
+
+        Reddinator.doShowWelcomeDialog(SubredditSelectActivity.this);
+    }
+
+    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
+    private void setThemeColors(){
+        ThemeManager.Theme theme = global.mThemeManager.getActiveTheme("appthemepref");
+        int headerColor = Color.parseColor(theme.getValue("header_color"));
+        findViewById(R.id.srtoolbar).setBackgroundColor(headerColor);
+        sortBtn.getBackground().setColorFilter(headerColor, PorterDuff.Mode.ADD);
+        addButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.ADD);
+        refreshButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.ADD);
+        tabs.setBackgroundColor(headerColor);
+        tabs.setInidicatorColor(Color.parseColor(theme.getValue("tab_indicator")));
+        tabs.setTextColor(Color.parseColor(theme.getValue("header_text")));
+        int buttonIconColor = Color.parseColor("#666666");
+        refreshButton.setTextColor(buttonIconColor);
+        addButton.setTextColor(buttonIconColor);
+        sortBtn.setCompoundDrawables(new IconDrawable(this, Iconify.IconValue.fa_sort).color(buttonIconColor).sizeDp(24), null, null, null);
+        if (global.mRedditData.isLoggedIn()) {
+            refreshButton.setCompoundDrawables(new IconDrawable(SubredditSelectActivity.this, Iconify.IconValue.fa_refresh).color(buttonIconColor).sizeDp(24), null, null, null);
+            refreshButton.setText(R.string.refresh);
+        } else {
+            refreshButton.setCompoundDrawables(new IconDrawable(SubredditSelectActivity.this, Iconify.IconValue.fa_key).color(buttonIconColor).sizeDp(24), null, null, null);
+            refreshButton.setText(R.string.login);
+        }
+        refreshButton.setCompoundDrawablePadding(6);
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (requestCode==1 && data!=null) {
+            try {
+                JSONObject subreddit = new JSONObject(data.getStringExtra("subredditObj"));
+                String name = subreddit.getString("display_name");
+                switch (resultCode) {
+                    case ViewAllSubredditsActivity.RESULT_ADD_SUBREDDIT:
+                        if (global.mRedditData.isLoggedIn() && (!name.equals("Front Page") && !name.equals("all"))) {
+                            new SubscriptionEditTask(SubscriptionEditTask.ACTION_SUBSCRIBE).execute(subreddit);
+                        } else {
+                            global.getSubredditManager().addSubreddit(subreddit);
+                            subredditList.add(name);
+                            refreshSubredditsList();
+                        }
+                        break;
+                    case ViewAllSubredditsActivity.RESULT_SET_SUBREDDIT:
+                        global.getSubredditManager().setFeedSubreddit(mAppWidgetId, name);
+                        updateFeedAndFinish();
+                        break;
+
+                    case ViewAllSubredditsActivity.RESULT_ADD_TO_MULTI:
+                        new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_SUB_ADD).execute(data.getStringExtra("multipath"), name);
+                        break;
+                }
+            } catch (JSONException e) {
+                e.printStackTrace();
+                Toast.makeText(SubredditSelectActivity.this, "Error reading subreddit data", Toast.LENGTH_LONG).show();
+            }
+            return;
+        }
+        if (requestCode==2 && resultCode==3){
+            needsThemeUpdate = true;
+            setThemeColors();
+        }
+    }
+
+    private void updateFeedAndFinish() {
+        if (widgetFirstTimeSetup) {
+            finishWidgetSetup();
+            return;
+        }
+        if (mAppWidgetId != 0) {
+            // refresh widget and close activity (NOTE: put in function)
+            AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(SubredditSelectActivity.this);
+            RemoteViews views = new RemoteViews(getPackageName(), R.layout.widget);
+            views.setTextViewText(R.id.subreddittxt, global.getSubredditManager().getCurrentFeedName(mAppWidgetId));
+            views.setViewVisibility(R.id.srloader, View.VISIBLE);
+            views.setViewVisibility(R.id.erroricon, View.INVISIBLE);
+            // bypass cache if service not loaded
+            global.setBypassCache(true);
+            appWidgetManager.partiallyUpdateAppWidget(mAppWidgetId, views);
+            appWidgetManager.notifyAppWidgetViewDataChanged(mAppWidgetId, R.id.listview);
+        } else {
+            Intent intent = new Intent();
+            intent.putExtra("themeupdate", needsThemeUpdate);
+            setResult(2, intent); // update feed prefs + reload feed
+        }
+        finish();
+    }
+
+    private void finishWidgetSetup(){
+        // for first time setup, widget provider receives this intent in onWidgetOptionsChanged();
+        Intent resultValue = new Intent();
+        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
+        setResult(RESULT_OK, resultValue);
+        finish();
+    }
+
+    // save changes on back press
+    public void onBackPressed() {
+        if (widgetFirstTimeSetup) {
+            finishWidgetSetup();
+            return;
+        }
+        // check if sort has changed
+        if (needsFeedUpdate || needsFeedViewUpdate || needsThemeUpdate) {
+            if (mAppWidgetId != 0) {
+                AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(SubredditSelectActivity.this);
+                RemoteViews views = new RemoteViews(getPackageName(), R.layout.widget);
+                views.setViewVisibility(R.id.srloader, View.VISIBLE);
+                views.setViewVisibility(R.id.erroricon, View.INVISIBLE);
+                // bypass the cached entrys only if the sorting preference has changed
+                if (needsFeedUpdate) {
+                    global.setBypassCache(true);
+                } else {
+                    global.setRefreshView();
+                }
+                if (needsThemeUpdate){
+                    WidgetProvider.updateAppWidgets(SubredditSelectActivity.this, appWidgetManager, new int[]{mAppWidgetId}, false);
+                } else {
+                    appWidgetManager.partiallyUpdateAppWidget(mAppWidgetId, views);
+                }
+                appWidgetManager.notifyAppWidgetViewDataChanged(mAppWidgetId, R.id.listview);
+            } else {
+                Intent intent = new Intent();
+                intent.putExtra("themeupdate", needsThemeUpdate);
+                if (needsFeedUpdate) {
+                    setResult(2, intent); // reload feed and prefs
+                } else {
+                    setResult(1, intent); // tells main activity to update feed prefs
+                }
+                if (needsThemeUpdate){
+                    global.setRefreshView();
+                    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(SubredditSelectActivity.this);
+                    int[] widgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(SubredditSelectActivity.this, WidgetProvider.class));
+                    WidgetProvider.updateAppWidgets(SubredditSelectActivity.this, appWidgetManager, widgetIds, false);
+                    appWidgetManager.notifyAppWidgetViewDataChanged(widgetIds, R.id.listview);
+                }
+            }
+        } else {
+            setResult(0);
+        }
+        finish();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu){
+        MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.subreddit_select_menu, menu);
+        // set options menu view
+        int iconColor;
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            iconColor = Color.parseColor("#8F8F8F");
+        } else {
+            iconColor = Color.parseColor("#DBDBDB");
+        }
+        (menu.findItem(R.id.menu_submit)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_pencil).color(iconColor).actionBarSize());
+        (menu.findItem(R.id.menu_feedprefs)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_list_alt).color(iconColor).actionBarSize());
+        if (mAppWidgetId==0) {
+            (menu.findItem(R.id.menu_widgettheme)).setVisible(false);
+        }
+        (menu.findItem(R.id.menu_widgettheme)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_paint_brush).color(iconColor).actionBarSize());
+        (menu.findItem(R.id.menu_thememanager)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_cogs).color(iconColor).actionBarSize());
+        (menu.findItem(R.id.menu_account)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_reddit_square).color(iconColor).actionBarSize());
+        (menu.findItem(R.id.menu_prefs)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_wrench).color(iconColor).actionBarSize());
+        (menu.findItem(R.id.menu_about)).setIcon(new IconDrawable(this, Iconify.IconValue.fa_info_circle).color(iconColor).actionBarSize());
+
+        return super.onCreateOptionsMenu(menu);
+    }
+
+    @Override
+    public boolean onMenuOpened(int featureId, Menu menu)
+    {
+        if(featureId == Window.FEATURE_ACTION_BAR && menu != null){
+            if(menu.getClass().getSimpleName().equals("MenuBuilder")){
+                try{
+                    Method m = menu.getClass().getDeclaredMethod(
+                            "setOptionalIconsVisible", Boolean.TYPE);
+                    m.setAccessible(true);
+                    m.invoke(menu, true);
+                }
+                catch(NoSuchMethodException e){
+                    System.out.println("Could not display action icons in menu");
+                }
+                catch(Exception e){
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+        return super.onMenuOpened(featureId, menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case android.R.id.home:
+                onBackPressed();
+                break;
+
+            case R.id.menu_feedprefs:
+                showFeedPrefsDialog();
+                break;
+
+            case R.id.menu_widgettheme:
+                showWidgetThemeDialog();
+                break;
+
+            case R.id.menu_thememanager:
+                Intent intent = new Intent(SubredditSelectActivity.this, ThemesActivity.class);
+                startActivityForResult(intent, 2);
+                break;
+
+            case R.id.menu_account:
+                Intent accnIntent = new Intent(SubredditSelectActivity.this, WebViewActivity.class);
+                accnIntent.putExtra("url", global.getDefaultMobileSite()+"/user/"+global.mRedditData.getUsername()+"/");
+                startActivity(accnIntent);
+                break;
+
+            case R.id.menu_submit:
+                Intent submitIntent = new Intent(SubredditSelectActivity.this, SubmitActivity.class);
+                startActivity(submitIntent);
+                break;
+
+            case R.id.menu_prefs:
+                Intent intent2 = new Intent(SubredditSelectActivity.this, PrefsActivity.class);
+                startActivityForResult(intent2, 2);
+                break;
+
+            case R.id.menu_about:
+                Reddinator.showInfoDialog(this, true);
+                break;
+
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+        return true;
+    }
+
+    // show sort select dialog
+    private void showSortDialog() {
+        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
+        builder.setTitle("Pick a sort, any sort");
+        builder.setItems(R.array.reddit_sorts, new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int which) {
+                Editor prefsedit = mSharedPreferences.edit();
+                String sort = "hot"; // default if fails
+                // find index
+                switch (which) {
+                    case 0:
+                        sort = "hot";
+                        break;
+                    case 1:
+                        sort = "new";
+                        break;
+                    case 2:
+                        sort = "rising";
+                        break;
+                    case 3:
+                        sort = "controversial";
+                        break;
+                    case 4:
+                        sort = "top";
+                        break;
+                }
+                prefsedit.putString("sort-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), sort);
+                prefsedit.apply();
+                // set new text in button
+                String sorttxt = "Sort:  " + sort;
+                sortBtn.setText(sorttxt);
+                needsFeedUpdate = true; // mark feed for updating
+                dialog.dismiss();
+            }
+        });
+        builder.show();
+    }
+
+    private void showFeedPrefsDialog(){
+        final CharSequence[] names = {"Thumbnails", "Thumbs On Top", "Hide Post Info"};
+        final boolean[] initvalue = {mSharedPreferences.getBoolean("thumbnails-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), true), mSharedPreferences.getBoolean("bigthumbs-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), false), mSharedPreferences.getBoolean("hideinf-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), false)};
+        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
+        builder.setTitle("Feed Options");
+        builder.setMultiChoiceItems(names, initvalue, new DialogInterface.OnMultiChoiceClickListener() {
+            public void onClick(DialogInterface dialogInterface, int item, boolean state) {
+                Editor prefsedit = mSharedPreferences.edit();
+                switch (item) {
+                    case 0:
+                        prefsedit.putBoolean("thumbnails-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), state);
+                        break;
+                    case 1:
+                        prefsedit.putBoolean("bigthumbs-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), state);
+                        break;
+                    case 2:
+                        prefsedit.putBoolean("hideinf-" + (mAppWidgetId == 0 ? "app" : mAppWidgetId), state);
+                        break;
+                }
+                prefsedit.apply();
+                needsFeedViewUpdate = true;
+            }
+        });
+        builder.setPositiveButton("Close", new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int id) {
+                dialog.cancel();
+            }
+        });
+        builder.create().show();
+    }
+
+    private void showWidgetThemeDialog(){
+
+        // set themes list
+        LinkedHashMap<String, String> themeList = global.mThemeManager.getThemeList(ThemeManager.LISTMODE_ALL);
+        themeList.put("app_select", "Use App theme");
+        final String[] keys = themeList.keySet().toArray(new String[themeList.keySet().size()]);
+        String curTheme = mSharedPreferences.getString("widgettheme-"+mAppWidgetId, "app_select");
+        int curIndex = 0;
+        for (int i=0; i<keys.length; i++){
+            if (keys[i].equals(curTheme)) {
+                curIndex = i;
+                break;
+            }
+        }
+        AlertDialog.Builder builder = new AlertDialog.Builder(this);
+        builder.setTitle("Select Widget Theme")
+        .setSingleChoiceItems(themeList.values().toArray(new String[themeList.values().size()]), curIndex,
+            new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialogInterface, int i) {
+                    needsThemeUpdate = true;
+                    SharedPreferences.Editor editor = mSharedPreferences.edit();
+                    editor.putString("widgettheme-" + mAppWidgetId, keys[i]);
+                    System.out.println(keys[i]);
+                    editor.apply();
+                    dialogInterface.cancel();
+                }
+            }
+        ).setPositiveButton("Close", new DialogInterface.OnClickListener() {
+            public void onClick(DialogInterface dialog, int id) {
+                dialog.cancel();
+            }
+        }).show();
+    }
+
+    // import personal subreddits
+    private void refreshSubreddits() {
+
+        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
+        StrictMode.setThreadPolicy(policy);
+        final ProgressDialog sdialog = ProgressDialog.show(SubredditSelectActivity.this, "Refreshing Subreddits", "One moment...", true);
+        Thread t = new Thread() {
+            public void run() {
+
+                final int listLength;
+                try {
+                    listLength = global.loadAccountSubreddits();
+                } catch (final RedditData.RedditApiException e) {
+                    e.printStackTrace();
+                    runOnUiThread(new Runnable() {
+                        public void run() {
+                            sdialog.dismiss();
+                            // check login required
+                            if (e.isAuthError())
+                                global.mRedditData.initiateLogin(SubredditSelectActivity.this);
+                            // show error
+                            Toast.makeText(SubredditSelectActivity.this, e.getMessage(), Toast.LENGTH_LONG).show();
+                        }
+                    });
+                    return;
+                }
+                runOnUiThread(new Runnable() {
+                    public void run() {
+                        sdialog.dismiss();
+                        if (listLength==0) {
+                            Toast.makeText(SubredditSelectActivity.this, "No subscriptions in your account, \nSuscribe to some subreddits", Toast.LENGTH_LONG).show();
+                        }
+                        refreshSubredditsList();
+                    }
+                });
+            }
+        };
+        t.start();
+    }
+
+    private void refreshMultireddits() {
+
+        StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder().permitAll().build();
+        StrictMode.setThreadPolicy(policy);
+        final ProgressDialog sdialog = ProgressDialog.show(SubredditSelectActivity.this, "Refreshing Multis", "One moment...", true);
+        Thread t = new Thread() {
+            public void run() {
+
+                final int listLength;
+                try {
+                    listLength = global.loadAccountMultis();
+                } catch (final RedditData.RedditApiException e) {
+                    e.printStackTrace();
+                    runOnUiThread(new Runnable() {
+                        public void run() {
+                            sdialog.dismiss();
+                            // check login required
+                            if (e.isAuthError())
+                                global.mRedditData.initiateLogin(SubredditSelectActivity.this);
+                            // show error
+                            Toast.makeText(SubredditSelectActivity.this, e.getMessage(), Toast.LENGTH_LONG).show();
+                        }
+                    });
+                    return;
+                }
+                runOnUiThread(new Runnable() {
+                    public void run() {
+                        sdialog.dismiss();
+                        if (listLength == 0) {
+                            Toast.makeText(SubredditSelectActivity.this, "No multis in your account \nClick the add multi button to create some", Toast.LENGTH_LONG).show();
+                        }
+                        mMultiAdapter.refreshMultis();
+                    }
+                });
+            }
+        };
+        t.start();
+    }
+
+    private void refreshSubredditsList(){
+        subredditList = global.getSubredditManager().getSubredditNames();
+        subsAdapter.clear();
+        subsAdapter.addAll(subredditList);
+        subsAdapter.notifyDataSetChanged();
+        subsAdapter.sort(new Comparator<String>() {
+            @Override
+            public int compare(String s, String t1) {
+                return s.compareToIgnoreCase(t1);
+            }
+        });
+    }
+
+    // list adapter
+    class MySubredditsAdapter extends ArrayAdapter<String> {
+        private LayoutInflater inflater;
+
+        public MySubredditsAdapter(Context context, ArrayList<String> objects) {
+            super(context, R.layout.myredditlistitem, R.id.subreddit_name, objects);
+            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            super.getView(position, convertView, parent);
+            ViewHolder viewHolder;
+            if (convertView == null || convertView.getTag() == null) {
+                // inflate new view
+                convertView = inflater.inflate(R.layout.myredditlistitem, parent, false);
+                viewHolder = new ViewHolder();
+                viewHolder.name = (TextView) convertView.findViewById(R.id.subreddit_name);
+                viewHolder.deleteIcon = (IconTextView) convertView.findViewById(R.id.subreddit_delete_btn);
+                viewHolder.filterIcon = (IconTextView) convertView.findViewById(R.id.subreddit_filter_btn);
+            } else {
+                viewHolder = (ViewHolder) convertView.getTag();
+            }
+            // setup the row
+            viewHolder.name.setText(getItem(position));
+            viewHolder.deleteIcon.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    final String sreddit = ((TextView) ((View) v.getParent()).findViewById(R.id.subreddit_name)).getText().toString();
+                    if (global.mRedditData.isLoggedIn() && (!sreddit.equals("Front Page") && !sreddit.equals("all"))) {
+                        new AlertDialog.Builder(SubredditSelectActivity.this).setTitle("Unsubscribe")
+                                .setMessage("Are you sure you want to unsubscribe from " + sreddit + "?")
+                                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+                                    @Override
+                                    public void onClick(DialogInterface dialogInterface, int i) {
+                                    }
+                                }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialogInterface, int i) {
+                                new SubscriptionEditTask(SubscriptionEditTask.ACTION_UNSUBSCRIBE).execute(sreddit);
+                            }
+                        }).show();
+                    } else {
+                        global.getSubredditManager().removeSubreddit(sreddit);
+                        subredditList.remove(sreddit);
+                        refreshSubredditsList();
+                    }
+                }
+            });
+            if (getItem(position).equals("all")){
+                viewHolder.filterIcon.setVisibility(View.VISIBLE);
+                viewHolder.filterIcon.setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        showFilterEditDialog();
+                    }
+                });
+            } else{
+                viewHolder.filterIcon.setVisibility(View.GONE);
+            }
+
+            convertView.setTag(viewHolder);
+
+            return convertView;
+        }
+
+        class ViewHolder {
+            TextView name;
+            IconTextView deleteIcon;
+            IconTextView filterIcon;
+        }
+    }
+
+    class MyMultisAdapter extends BaseAdapter {
+        private LayoutInflater inflater;
+        private ArrayList<JSONObject> multiList;
+
+        public MyMultisAdapter(Context context) {
+            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+            refreshMultis();
+        }
+
+        public void refreshMultis(){
+            multiList = global.getSubredditManager().getMultiList();
+            Collections.sort(multiList, new Comparator<JSONObject>() {
+                @Override
+                public int compare(JSONObject s, JSONObject t1) {
+                    try {
+                        return s.getString("display_name").compareToIgnoreCase(t1.getString("display_name"));
+                    } catch (JSONException e) {
+                        e.printStackTrace();
+                        return 0;
+                    }
+                }
+            });
+            this.notifyDataSetChanged();
+        }
+
+        @Override
+        public View getView(int position, View convertView, final ViewGroup parent) {
+            //super.getView(position, convertView, parent);
+            ViewHolder viewHolder;
+            if (convertView == null || convertView.getTag() == null) {
+                // inflate new view
+                viewHolder = new ViewHolder();
+                if (position==multiList.size()) {
+                    convertView = inflater.inflate(R.layout.mymultilistitem_add, parent, false);
+                } else {
+                    convertView = inflater.inflate(R.layout.mymultilistitem, parent, false);
+                    viewHolder.name = (TextView) convertView.findViewById(R.id.multireddit_name);
+                    viewHolder.deleteIcon = (IconTextView) convertView.findViewById(R.id.multi_delete_btn);
+                    viewHolder.editIcon = (IconTextView) convertView.findViewById(R.id.multi_edit_btn);
+                }
+                //viewHolder.subsIcon = (IconTextView) convertView.findViewById(R.id.multi_editsubs_btn);
+            } else {
+                viewHolder = (ViewHolder) convertView.getTag();
+            }
+            if (position<multiList.size()) {
+                JSONObject multiObj = getItem(position);
+                final String displayName, path;
+                final boolean canEdit;
+                try {
+                    displayName = multiObj.getString("display_name");
+                    path = multiObj.getString("path");
+                    canEdit = multiObj.getBoolean("can_edit");
+                } catch (JSONException e) {
+                    e.printStackTrace();
+                    return convertView;
+                }
+                // setup the row
+                viewHolder.name.setText(displayName);
+                viewHolder.deleteIcon.setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        if (canEdit) {
+                            showMultiDeleteDialog(path);
+                        } else {
+                            global.getSubredditManager().removeMulti(path);
+                            subsAdapter.notifyDataSetChanged();
+                        }
+                    }
+                });
+                if (canEdit) {
+                    viewHolder.editIcon.setVisibility(View.VISIBLE);
+                    //viewHolder.subsIcon.setVisibility(View.VISIBLE);
+                    viewHolder.editIcon.setOnClickListener(new OnClickListener() {
+                        @Override
+                        public void onClick(View view) {
+                            showMultiEditDialog(path);
+                        }
+                    });
+                    // will use for viewing subreddits list when not editable; later!
+                    /*viewHolder.subsIcon.setOnClickListener(new OnClickListener() {
+                        @Override
+                        public void onClick(View view) {
+                            showMultiEditDialog(path);
+                        }
+                    });*/
+                }
+            }
+
+            convertView.setTag(viewHolder);
+
+            return convertView;
+        }
+
+        @Override
+        public int getCount() {
+            return multiList.size()+1;
+        }
+
+        @Override
+        public int getViewTypeCount(){
+            return 2;
+        }
+
+        @Override
+        public int getItemViewType(int position){
+            if (position==multiList.size())
+                return 1;
+            return 0;
+        }
+
+        public JSONObject getItem(int position){
+           return multiList.get(position);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return 0;
+        }
+
+        class ViewHolder {
+            TextView name;
+            IconTextView deleteIcon;
+            IconTextView editIcon;
+            //IconTextView subsIcon;
+        }
+    }
+
+    private void showMultiDeleteDialog(final String multiPath){
+        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
+        builder.setTitle("Delete Multi").setMessage("Are you sure you want to delete this multi from your account?");
+        builder.setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialogInterface, int i) {
+                dialogInterface.dismiss();
+            }
+        }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialogInterface, int i) {
+                dialogInterface.dismiss();
+                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_DELETE).execute(multiPath);
+            }
+        }).show();
+    }
+
+    private void showMultiRenameDialog(final String multiPath){
+        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
+        final EditText nameInput = new EditText(SubredditSelectActivity.this);
+        nameInput.setHint("new multi name");
+        builder.setTitle("Rename Multi").setView(nameInput)
+        .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialogInterface, int i) {
+                dialogInterface.dismiss();
+            }
+        }).setPositiveButton("OK", new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialogInterface, int i) {
+                dialogInterface.dismiss();
+                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_RENAME).execute(multiPath, nameInput.getText().toString().replaceAll("\\s+",""));
+            }
+        }).show();
+    }
+
+    private SubsListAdapter multiSubsAdapter;
+    private AlertDialog multiDialog;
+    private TextView multiName;
+    private void showMultiEditDialog(final String multiPath){
+        JSONObject multiObj = global.getSubredditManager().getMultiData(multiPath);
+
+        @SuppressLint("InflateParams")
+        LinearLayout dialogView =  (LinearLayout)  getLayoutInflater().inflate(R.layout.dialog_multi_edit, null); // passing null okay for dialog
+        final Button saveButton = (Button) dialogView.findViewById(R.id.multi_save_button);
+        final Button renameButton = (Button) dialogView.findViewById(R.id.multi_rename_button);
+        multiName = (TextView) dialogView.findViewById(R.id.multi_pname);
+        final EditText displayName = (EditText) dialogView.findViewById(R.id.multi_name);
+        final EditText description = (EditText) dialogView.findViewById(R.id.multi_description);
+        final EditText color = (EditText) dialogView.findViewById(R.id.multi_color);
+        final Spinner icon = (Spinner) dialogView.findViewById(R.id.multi_icon);
+        final Spinner visibility = (Spinner) dialogView.findViewById(R.id.multi_visibility);
+        final Spinner weighting = (Spinner) dialogView.findViewById(R.id.multi_weighting);
+
+        ArrayAdapter<CharSequence> iconAdapter = ArrayAdapter.createFromResource(SubredditSelectActivity.this, R.array.multi_icons, android.R.layout.simple_spinner_item);
+        iconAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        icon.setAdapter(iconAdapter);
+        ArrayAdapter<CharSequence> visibilityAdapter = ArrayAdapter.createFromResource(SubredditSelectActivity.this, R.array.multi_visibility, android.R.layout.simple_spinner_item);
+        visibilityAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        visibility.setAdapter(visibilityAdapter);
+        ArrayAdapter<CharSequence> weightsAdapter = ArrayAdapter.createFromResource(SubredditSelectActivity.this, R.array.multi_weights, android.R.layout.simple_spinner_item);
+        weightsAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
+        weighting.setAdapter(weightsAdapter);
+
+        try {
+            multiName.setText(multiObj.getString("name"));
+            displayName.setText(multiObj.getString("display_name"));
+            description.setText(multiObj.getString("description_md"));
+            color.setText(multiObj.getString("key_color"));
+            String iconName = multiObj.getString("icon_name");
+            icon.setSelection(iconAdapter.getPosition(iconName.equals("")?"none":iconName));
+            visibility.setSelection(iconAdapter.getPosition(multiObj.getString("visibility")));
+            weighting.setSelection(iconAdapter.getPosition(multiObj.getString("weighting_scheme")));
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+
+        ViewPager pager = (ViewPager) dialogView.findViewById(R.id.multi_pager);
+        LinearLayout tabsWidget = (LinearLayout) dialogView.findViewById(R.id.multi_tab_widget);
+        pager.setAdapter(new SimpleTabsAdapter(new String[]{"Subreddits", "Settings"}, new int[]{R.id.multi_subreddits, R.id.multi_settings}, SubredditSelectActivity.this, dialogView));
+        SimpleTabsWidget simpleTabsWidget = new SimpleTabsWidget(SubredditSelectActivity.this, tabsWidget);
+        simpleTabsWidget.setViewPager(pager);
+        ThemeManager.Theme theme = global.mThemeManager.getActiveTheme("appthemepref");
+        int headerColor = Color.parseColor(theme.getValue("header_color"));
+        int headerText = Color.parseColor(theme.getValue("header_text"));
+        simpleTabsWidget.setBackgroundColor(headerColor);
+        simpleTabsWidget.setTextColor(headerText);
+        simpleTabsWidget.setInidicatorColor(Color.parseColor(theme.getValue("tab_indicator")));
+
+        ListView subList = (ListView) dialogView.findViewById(R.id.multi_subredditList);
+        multiSubsAdapter = new SubsListAdapter(SubredditSelectActivity.this, multiPath);
+        subList.setAdapter(multiSubsAdapter);
+        renameButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.MULTIPLY);
+        renameButton.setTextColor(headerText);
+        renameButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                showMultiRenameDialog(multiPath);
+            }
+        });
+
+                saveButton.getBackground().setColorFilter(headerColor, PorterDuff.Mode.MULTIPLY);
+        saveButton.setTextColor(headerText);
+        saveButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                System.out.println("Save multi");
+                JSONObject multiObj = new JSONObject();
+                try {
+                    multiObj.put("decription_md", description.getText().toString());
+                    multiObj.put("display_name", displayName.getText().toString());
+                    multiObj.put("icon_name", icon.getSelectedItem().toString().equals("none")?"":icon.getSelectedItem().toString());
+                    multiObj.put("key_color", color.getText().toString());
+                    multiObj.put("subreddits", global.getSubredditManager().getMultiData(multiPath).getJSONArray("subreddits"));
+                    multiObj.put("visibility", visibility.getSelectedItem().toString());
+                    multiObj.put("weighting_scheme", weighting.getSelectedItem().toString());
+
+                    new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_EDIT).execute(multiPath, multiObj);
+
+                } catch (JSONException e) {
+                    e.printStackTrace();
+                }
+            }
+        });
+
+        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
+
+        multiDialog = builder.setView(dialogView).show();
+    }
+
+    private void showFilterEditDialog(){
+
+        @SuppressLint("InflateParams")
+        LinearLayout dialogView =  (LinearLayout)  getLayoutInflater().inflate(R.layout.dialog_filter, null); // passing null okay for dialog
+
+        ThemeManager.Theme theme = global.mThemeManager.getActiveTheme("appthemepref");
+        int headerColor = Color.parseColor(theme.getValue("header_color"));
+        int headerText = Color.parseColor(theme.getValue("header_text"));
+        dialogView.findViewById(R.id.filter_header).setBackgroundColor(headerColor);
+        ((TextView) dialogView.findViewById(R.id.filter_headert1)).setTextColor(headerText);
+        ((TextView) dialogView.findViewById(R.id.filter_headert2)).setTextColor(headerText);
+
+        ListView subList = (ListView) dialogView.findViewById(R.id.filter_subredditList);
+        final SubsListAdapter filterSubsAdapter = new SubsListAdapter(SubredditSelectActivity.this, null);
+        subList.setAdapter(filterSubsAdapter);
+
+        AlertDialog.Builder builder = new AlertDialog.Builder(SubredditSelectActivity.this);
+        builder.setView(dialogView)
+                .setNegativeButton("Cancel", new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialogInterface, int i) {
+                        dialogInterface.dismiss();
+                    }
+                })
+                .setPositiveButton("OK", new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialogInterface, int i) {
+                        dialogInterface.dismiss();
+                        global.getSubredditManager().setAllFilter(filterSubsAdapter.getSubsList());
+                        needsFeedUpdate = true; // mark feed for updating
+                    }
+                }).show().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
+    }
+
+    class SubsListAdapter extends BaseAdapter {
+        private final int MODE_MULTI = 1;
+        private int mode = 0;
+        private LayoutInflater inflater;
+        private ArrayList<String> subsList;
+        private String multiPath;
+        private SubAutoCompleteAdapter autoCompleteAdapter;
+
+        public SubsListAdapter(Context context, String multiPath) {
+            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+            autoCompleteAdapter = new SubAutoCompleteAdapter(context, R.layout.autocomplete_list_item);
+            if (multiPath!=null) {
+                this.multiPath = multiPath;
+                mode = MODE_MULTI;
+            }
+            refreshList();
+        }
+
+        public void refreshList(){
+            if (mode==MODE_MULTI) {
+                subsList = global.getSubredditManager().getMultiSubreddits(multiPath);
+            } else {
+                subsList = global.getSubredditManager().getAllFilter();
+            }
+            Collections.sort(subsList, new Comparator<String>() {
+                @Override
+                public int compare(String s, String t1) {
+                    return s.compareToIgnoreCase(t1);
+                }
+            });
+            this.notifyDataSetChanged();
+        }
+
+        @Override
+        public View getView(int position, View convertView, final ViewGroup parent) {
+            //super.getView(position, convertView, parent);
+            final ViewHolder viewHolder;
+            if (convertView == null || convertView.getTag() == null) {
+                // inflate new view
+                if (position== subsList.size()) {
+                    convertView = inflater.inflate(R.layout.multi_sublist_add_item, parent, false);
+                    viewHolder = new ViewHolder();
+                    viewHolder.nameInput = (AutoCompleteTextView) convertView.findViewById(R.id.subreddit_name);
+                    viewHolder.addIcon = (IconTextView) convertView.findViewById(R.id.multi_sub_add);
+                    viewHolder.searchIcon = (IconTextView) convertView.findViewById(R.id.multi_sub_search);
+                } else {
+                    convertView = inflater.inflate(R.layout.multi_sublist_item, parent, false);
+                    viewHolder = new ViewHolder();
+                    viewHolder.name = (TextView) convertView.findViewById(R.id.subreddit_name);
+                    viewHolder.removeIcon = (IconTextView) convertView.findViewById(R.id.multi_sub_remove);
+                }
+            } else {
+                viewHolder = (ViewHolder) convertView.getTag();
+            }
+            // setup the row
+            if (position== subsList.size()) {
+                viewHolder.nameInput.setAdapter(autoCompleteAdapter);
+                viewHolder.nameInput.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+                    @Override
+                    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
+                        String subreddit = viewHolder.nameInput.getText().toString();
+                        performAdd(subreddit);
+                        viewHolder.nameInput.setText("");
+                    }
+                });
+                viewHolder.addIcon.setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View view) {
+                        String subreddit = viewHolder.nameInput.getText().toString();
+                        if (subreddit.equals("")){
+                            Toast.makeText(SubredditSelectActivity.this, "Please enter a subreddit name", Toast.LENGTH_SHORT).show();
+                            return;
+                        }
+                        performAdd(subreddit);
+                        viewHolder.nameInput.setText("");
+                    }
+                });
+                if (mode==MODE_MULTI) {
+                    viewHolder.searchIcon.setVisibility(View.VISIBLE);
+                    viewHolder.searchIcon.setOnClickListener(new OnClickListener() {
+                        @Override
+                        public void onClick(View view) {
+                            Intent intent = new Intent(SubredditSelectActivity.this, ViewAllSubredditsActivity.class);
+                            intent.setAction(ViewAllSubredditsActivity.ACTION_ADD_MULTI_SUB);
+                            intent.putExtra("multipath", multiPath);
+                            startActivityForResult(intent, 1);
+                        }
+                    });
+                } else {
+                    // search isn't implemented here yet, you could if you want to but I don't see much point
+                    viewHolder.searchIcon.setVisibility(View.GONE);
+                }
+            } else {
+                final String subreddit = getItem(position);
+                viewHolder.name.setText(subreddit);
+                viewHolder.removeIcon.setOnClickListener(new OnClickListener() {
+                    @Override
+                    public void onClick(View view) {
+                        performRemove(subreddit);
+                    }
+                });
+            }
+            convertView.setTag(viewHolder);
+
+            return convertView;
+        }
+
+        private ArrayList<String> getSubsList(){
+            return subsList;
+        }
+
+        private void performAdd(String subreddit){
+            System.out.println("Adding Sub: " + subreddit);
+            if (mode==MODE_MULTI) {
+                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_SUB_ADD).execute(multiPath, subreddit);
+            } else {
+                subsList.add(subreddit);
+                notifyDataSetChanged();
+            }
+        }
+
+        private void performRemove(String subreddit){
+            System.out.println("Removing Sub: "+subreddit);
+            if (mode==MODE_MULTI) {
+                new SubscriptionEditTask(SubscriptionEditTask.ACTION_MULTI_SUB_REMOVE).execute(multiPath, subreddit);
+            } else {
+                subsList.remove(subreddit);
+                notifyDataSetChanged();
+            }
+        }
+
+        @Override
+        public int getViewTypeCount(){
+            return 2;
+        }
+
+        @Override
+        public int getItemViewType(int position){
+            if (position== subsList.size())
+                return 1;
+            return 0;
+        }
+
+        @Override
+        public int getCount(){
+            return subsList.size()+1;
+        }
+
+        @Override
+        public String getItem(int i) {
+            return subsList.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return 0;
+        }
+
+        class ViewHolder {
+            TextView name;
+            AutoCompleteTextView nameInput;
+            IconTextView addIcon;
+            IconTextView removeIcon;
+            IconTextView searchIcon;
+        }
+
+    }
+
+    class SubscriptionEditTask extends AsyncTask<Object, Long, Boolean> {
+        public static final int ACTION_MULTI_COPY = 0;
+        public static final int ACTION_MULTI_CREATE = 1;
+        public static final int ACTION_MULTI_EDIT = 2;
+        public static final int ACTION_MULTI_SUB_ADD = 3;
+        public static final int ACTION_MULTI_SUB_REMOVE = 4;
+        public static final int ACTION_MULTI_DELETE = 5;
+        public static final int ACTION_MULTI_RENAME = 6;
+        public static final int ACTION_SUBSCRIBE = 7;
+        public static final int ACTION_UNSUBSCRIBE = 8;
+        private JSONObject result;
+        private Exception exception;
+        private int action;
+        private Object[] params;
+        ProgressDialog progressDialog;
+
+        public SubscriptionEditTask(int action){
+            String loadingMessage = "";
+            switch (action) {
+                case ACTION_SUBSCRIBE:
+                    loadingMessage = "Subscribing...";
+                    break;
+                case ACTION_UNSUBSCRIBE:
+                    loadingMessage = "Unsubscribing...";
+                    break;
+                case ACTION_MULTI_COPY:
+                    loadingMessage = "Copying Multi...";
+                    break;
+                case ACTION_MULTI_CREATE:
+                    loadingMessage = "Creating Multi...";
+                    break;
+                case ACTION_MULTI_EDIT:
+                case ACTION_MULTI_RENAME:
+                case ACTION_MULTI_SUB_ADD:
+                case ACTION_MULTI_SUB_REMOVE:
+                    loadingMessage = "Updating Multi...";
+                    break;
+                case ACTION_MULTI_DELETE:
+                    loadingMessage = "Deleting Multi...";
+                    break;
+            }
+            progressDialog = ProgressDialog.show(SubredditSelectActivity.this, loadingMessage, loadingMessage, true);
+            this.action = action;
+        }
+
+        @Override
+        protected Boolean doInBackground(Object... strParams) {
+            this.params = strParams;
+            String id;
+            try {
+                switch (action){
+                    case ACTION_SUBSCRIBE:
+                        id = ((JSONObject) strParams[0]).getString("name");
+                        result = global.mRedditData.subscribe(id, true);
+                        break;
+
+                    case ACTION_UNSUBSCRIBE:
+                        id = global.getSubredditManager().getSubredditData(strParams[0].toString()).getString("name");
+                        result = global.mRedditData.subscribe(id, false);
+                        break;
+
+                    case ACTION_MULTI_COPY:
+                        result = global.mRedditData.copyMulti(strParams[0].toString(), strParams[1].toString());
+                        break;
+
+                    case ACTION_MULTI_CREATE:
+                        try {
+                            JSONObject multiObj = new JSONObject();
+                            multiObj.put("display_name", strParams[0].toString());
+                            multiObj.put("decription_md", "");
+                            multiObj.put("icon_name", "");
+                            multiObj.put("key_color", "#CEE3F8");
+                            multiObj.put("subreddits", new JSONArray());
+                            multiObj.put("visibility", "private");
+                            multiObj.put("weighting_scheme", "classic");
+                            result = global.mRedditData.createMulti(strParams[0].toString(), multiObj);
+                        } catch (JSONException e) {
+                            e.printStackTrace();
+                            return false;
+                        }
+                        break;
+
+                    case ACTION_MULTI_EDIT:
+                        result = global.mRedditData.editMulti(strParams[0].toString(), (JSONObject) strParams[1]);
+                        break;
+
+                    case ACTION_MULTI_SUB_ADD:
+                        result = global.mRedditData.addMultiSubreddit(strParams[0].toString(), strParams[1].toString());
+                        break;
+
+                    case ACTION_MULTI_SUB_REMOVE:
+                        global.mRedditData.removeMultiSubreddit(strParams[0].toString(), strParams[1].toString());
+                        break;
+
+                    case ACTION_MULTI_DELETE:
+                        global.mRedditData.deleteMulti(strParams[0].toString());
+                        break;
+
+                    case ACTION_MULTI_RENAME:
+                        result = global.mRedditData.renameMulti(strParams[0].toString(), strParams[1].toString());
+                        break;
+                }
+                return true;
+            } catch (RedditData.RedditApiException e) {
+                e.printStackTrace();
+                exception = e;
+            } catch (JSONException e) {
+                e.printStackTrace();
+            }
+            return false;
+        }
+
+        @Override
+        protected void onPostExecute(Boolean result) {
+            progressDialog.dismiss();
+            ArrayList<String> subreddits;
+            if (result) {
+                //if (this.result!=null)
+                    //System.out.println("resultData: "+this.result.toString());
+                switch (action) {
+                    case ACTION_SUBSCRIBE:
+                        global.getSubredditManager().addSubreddit((JSONObject) params[0]);
+                        try {
+                            subredditList.add(0, ((JSONObject) params[0]).getString("display_name"));
+                        } catch (JSONException e) {
+                            e.printStackTrace();
+                        }
+                        refreshSubredditsList();
+                        break;
+                    case ACTION_UNSUBSCRIBE:
+                        global.getSubredditManager().removeSubreddit(params[0].toString());
+                        subredditList.remove(params[0].toString());
+                        refreshSubredditsList();
+                        break;
+                    case ACTION_MULTI_COPY:
+
+                        break;
+                    case ACTION_MULTI_CREATE:
+                        try {
+                            if (this.result==null) return;
+                            JSONObject multiObj = this.result.getJSONObject("data");
+                            String path = multiObj.getString("path");
+                            global.getSubredditManager().setMultiData(path, multiObj);
+                            showMultiEditDialog(path);
+                        } catch (JSONException e) {
+                            e.printStackTrace();
+                        }
+                        mMultiAdapter.refreshMultis();
+                        break;
+                    case ACTION_MULTI_EDIT:
+                        try {
+                            if (this.result==null) return;
+                            JSONObject multiObj = this.result.getJSONObject("data");
+                            global.getSubredditManager().setMultiData(params[0].toString(), multiObj);
+                        } catch (JSONException e) {
+                            e.printStackTrace();
+                        }
+                        multiDialog.dismiss();
+                        mMultiAdapter.refreshMultis();
+                        break;
+                    case ACTION_MULTI_SUB_ADD:
+                        subreddits = global.getSubredditManager().getMultiSubreddits(params[0].toString());
+                        subreddits.add(params[1].toString());
+                        global.getSubredditManager().setMultiSubs(params[0].toString(), subreddits);
+                        multiSubsAdapter.refreshList();
+                        break;
+                    case ACTION_MULTI_SUB_REMOVE:
+                        subreddits = global.getSubredditManager().getMultiSubreddits(params[0].toString());
+                        subreddits.remove(params[1].toString());
+                        global.getSubredditManager().setMultiSubs(params[0].toString(), subreddits);
+                        multiSubsAdapter.refreshList();
+                        break;
+                    case ACTION_MULTI_DELETE:
+                        global.getSubredditManager().removeMulti(params[0].toString());
+                        mMultiAdapter.refreshMultis();
+                        break;
+                    case ACTION_MULTI_RENAME:
+                        global.getSubredditManager().removeMulti(params[0].toString());
+                        try {
+                            JSONObject multiObj = this.result.getJSONObject("data");
+                            String path = multiObj.getString("path");
+                            global.getSubredditManager().setMultiData(path, multiObj);
+                            multiName.setText(multiObj.getString("name"));
+                        } catch (JSONException e) {
+                            e.printStackTrace();
+                        }
+                        mMultiAdapter.refreshMultis();
+                        break;
+                }
+            } else {
+                // check login required
+                if (exception instanceof RedditData.RedditApiException && ((RedditData.RedditApiException)exception).isAuthError())
+                    global.mRedditData.initiateLogin(SubredditSelectActivity.this);
+                // show error
+                Toast.makeText(SubredditSelectActivity.this, exception.getMessage(), Toast.LENGTH_LONG).show();
+            }
+        }
+    }
+}
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/ThemeEditorActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ThemeEditorActivity.java
similarity index 97%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/ThemeEditorActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ThemeEditorActivity.java
index a109925..dbe1314 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/ThemeEditorActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ThemeEditorActivity.java
@@ -1,4 +1,4 @@
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.app.ActionBar;
 import android.app.AlertDialog;
@@ -27,9 +27,13 @@ import org.json.JSONException;
 
 import java.util.UUID;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+
 
 public class ThemeEditorActivity extends ListActivity {
-    private GlobalObjects global;
+    private Reddinator global;
     private String themeId = "";
     private ThemeManager.Theme theme;
     private boolean themeChanged = false;
@@ -38,7 +42,7 @@ public class ThemeEditorActivity extends ListActivity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        global = ((GlobalObjects) ThemeEditorActivity.this.getApplicationContext());
+        global = ((Reddinator) ThemeEditorActivity.this.getApplicationContext());
         if (getIntent().hasExtra("themeId")) {
             // edit existing theme
             themeId = getIntent().getStringExtra("themeId");
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/ThemesActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ThemesActivity.java
similarity index 95%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/ThemesActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ThemesActivity.java
index c47e875..a33c5a5 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/ThemesActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ThemesActivity.java
@@ -1,4 +1,4 @@
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.app.ActionBar;
 import android.app.AlertDialog;
@@ -21,16 +21,20 @@ import com.joanzapata.android.iconify.Iconify;
 
 import java.util.HashMap;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+
 
 public class ThemesActivity extends ListActivity {
-    GlobalObjects global;
+    Reddinator global;
     HashMap<String, String> themesList;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        global = ((GlobalObjects) ThemesActivity.this.getApplicationContext());
+        global = ((Reddinator) ThemesActivity.this.getApplicationContext());
         themesList = global.mThemeManager.getThemeList(ThemeManager.LISTMODE_CUSTOM);
 
         setContentView(R.layout.activity_themes);
@@ -98,7 +102,7 @@ public class ThemesActivity extends ListActivity {
                 builder.show();
                 break;
             case R.id.menu_about:
-                GlobalObjects.showInfoDialog(this, true);
+                Reddinator.showInfoDialog(this, true);
                 break;
             default:
                 return super.onOptionsItemSelected(item);
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/ViewAllSubredditsActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ViewAllSubredditsActivity.java
similarity index 96%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/ViewAllSubredditsActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ViewAllSubredditsActivity.java
index 34cd41a..81bdc2b 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/ViewAllSubredditsActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ViewAllSubredditsActivity.java
@@ -1,357 +1,361 @@
-/*
- * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
- * This file is part of Reddinator.
- *
- * Reddinator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * Reddinator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
- */
-package au.com.wallaceit.reddinator;
-
-import android.app.ActionBar;
-import android.app.AlertDialog;
-import android.app.ListActivity;
-import android.app.ProgressDialog;
-import android.content.Context;
-import android.content.Intent;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.ViewGroup;
-import android.view.inputmethod.EditorInfo;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemClickListener;
-import android.widget.BaseAdapter;
-import android.widget.EditText;
-import android.widget.IconTextView;
-import android.widget.ListView;
-import android.widget.TextView;
-import android.widget.TextView.OnEditorActionListener;
-import android.widget.Toast;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.util.ArrayList;
-
-public class ViewAllSubredditsActivity extends ListActivity {
-    public static final int RESULT_ADD_TO_MULTI = 3;
-    public static final int RESULT_SET_SUBREDDIT = 2;
-    public static final int RESULT_ADD_SUBREDDIT = 1;
-    public static final String ACTION_ADD_MULTI_SUB = "ADD_MULTI_SUBREDDIT";
-    private String action;
-    private GlobalObjects global;
-    private ArrayList<JSONObject> sreddits = new ArrayList<>();
-    private ArrayList<JSONObject> defaultsreddits;
-    private JSONArray srjson;
-    private SubredditsAdapter listadapter;
-    private EditText searchbox;
-    private TextView emptyview;
-
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        action = getIntent().getAction();
-        global = ((GlobalObjects) getApplicationContext());
-        ActionBar actionBar = getActionBar();
-        if (actionBar != null) {
-            actionBar.setDisplayHomeAsUpEnabled(true);
-        }
-        setContentView(R.layout.viewallsubreddit);
-        // setup list view
-        ListView listview = getListView();
-        listview.setTextFilterEnabled(true);
-        listview.setEmptyView(findViewById(R.id.subredditload));
-        listview.setOnItemClickListener(new OnItemClickListener() {
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-                returnResult(sreddits.get(position), false);
-            }
-        });
-        // get empty view text for easy access later
-        emptyview = (TextView) findViewById(R.id.poploadtxt);
-        // setup search buttons
-        searchbox = (EditText) this.findViewById(R.id.searchbox);
-        searchbox.setOnEditorActionListener(new OnEditorActionListener() {
-            @Override
-            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
-                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
-                    search(v.getText().toString());
-                }
-                return true;
-            }
-
-        });
-        IconTextView searchbtn = (IconTextView) this.findViewById(R.id.searchbutton);
-        searchbtn.setOnClickListener(new OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                String query = searchbox.getText().toString();
-                if (!query.equals("")) {
-                    search(query);
-                } else {
-                    new AlertDialog.Builder(ViewAllSubredditsActivity.this).setTitle("No Query").setMessage("Please enter something to search for").show();
-                }
-            }
-        });
-        loadDefaults();
-        // get list data
-        listadapter = new SubredditsAdapter(this);
-        if (global.isSrlistCached()) {
-            if (action==null || !action.equals(ACTION_ADD_MULTI_SUB)) {
-                sreddits.addAll(defaultsreddits);
-            }
-            sreddits.addAll(global.getSrList());
-        } else {
-            loadPopularSubreddits();
-        }
-        listview.setAdapter(listadapter);
-    }
-
-    private boolean cancelrevert = false;
-
-    public void onBackPressed() {
-        // System.out.println("onBackPressed()");
-        if (searchbox.getText().toString().equals("")) {
-            this.finish();
-        } else {
-            if (global.isSrlistCached()) {
-                sreddits.clear();
-                if (action==null || !action.equals(ACTION_ADD_MULTI_SUB)) {
-                    sreddits.addAll(defaultsreddits);
-                }
-                sreddits.addAll(global.getSrList());
-                listadapter.notifyDataSetChanged();
-            } else {
-                emptyview.setText("Loading popular...");
-                sreddits.clear();
-                listadapter.notifyDataSetChanged();
-                if (dlpopulartask == null) {
-                    loadPopularSubreddits();
-                } else {
-                    cancelrevert = true;
-                }
-            }
-            searchbox.setText("");
-        }
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case android.R.id.home:
-                onBackPressed();
-                return true;
-        }
-        return false;
-    }
-
-    protected void onResume() {
-        //System.out.println("onResume()");
-        super.onResume();
-    }
-
-    private void loadDefaults(){
-        defaultsreddits = new ArrayList<>();
-        try {
-            defaultsreddits.add(new JSONObject("{\"display_name\"=\"Front Page\", \"public_description\"=\"Your reddit front page\"}")); // slap the front page on there
-            defaultsreddits.add(new JSONObject("{\"display_name\"=\"all\", \"public_description\"=\"The best of reddit\"}")); // and an all
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-    }
-
-    private void loadPopularSubreddits() {
-        dlpopulartask = new DLTask();
-        dlpopulartask.execute("");
-    }
-
-    private void search(final String query) {
-        //System.out.println("Searching: " + query);
-        if (dlpopulartask != null) {
-            dlpopulartask.cancel(true);
-        }
-        // use a thread for searching
-        final ProgressDialog sdialog = ProgressDialog.show(ViewAllSubredditsActivity.this, "", ("Searching..."), true);
-        Thread t = new Thread() {
-            public void run() {
-                // get all popular subreddits
-                try {
-                    srjson = global.mRedditData.getSubredditSearch(query);
-                } catch (final RedditData.RedditApiException e) {
-                    e.printStackTrace();
-                    runOnUiThread(new Runnable() {
-                        public void run() {
-                            Toast.makeText(ViewAllSubredditsActivity.this, e.getMessage(), Toast.LENGTH_LONG).show();
-                            sdialog.dismiss();
-                        }
-                    });
-                    return;
-                }
-                //System.out.println("search complete");
-                runOnUiThread(new Runnable() {
-                    public void run() {
-                        // put into arraylist
-                        sreddits.clear();
-                        int i = 0;
-                        while (i < srjson.length()) {
-                            try {
-                                sreddits.add(srjson.getJSONObject(i).getJSONObject("data"));
-                            } catch (JSONException e) {
-                                e.printStackTrace();
-                            }
-                            i++;
-                        }
-                        listadapter.notifyDataSetChanged();
-                        if (sreddits.size() == 0) {
-                            // set no result text in no items view
-                            emptyview.setText("No subreddits found");
-                        }
-                        sdialog.dismiss();
-                    }
-                });
-
-            }
-        };
-        t.start();
-    }
-
-    private void returnResult(JSONObject subObj, boolean addAction){
-        Intent intent = new Intent();
-        intent.putExtra("subredditObj", subObj.toString());
-        if (action!=null && action.equals(ACTION_ADD_MULTI_SUB)){
-            intent.putExtra("multipath", getIntent().getStringExtra("multipath"));
-            setResult(RESULT_ADD_TO_MULTI, intent);
-        } else {
-            if (addAction) {
-                setResult(RESULT_ADD_SUBREDDIT, intent);
-            } else {
-                setResult(RESULT_SET_SUBREDDIT, intent);
-            }
-        }
-        finish();
-    }
-
-    class SubredditsAdapter extends BaseAdapter {
-        private LayoutInflater inflater;
-
-        public SubredditsAdapter(Context context) {
-            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        }
-
-        @Override
-        public int getCount() {
-            return sreddits.size();
-        }
-
-        @Override
-        public Object getItem(int i) {
-            return sreddits.get(i);
-        }
-
-        @Override
-        public long getItemId(int i) {
-            return 0;
-        }
-
-        @Override
-        public View getView(final int position, View row, ViewGroup parent) {
-            ViewHolder viewHolder = new ViewHolder();
-            if (row == null || row.getTag() == null) {
-                // inflate new view
-                row = inflater.inflate(R.layout.subreddititem, parent, false);
-                viewHolder.name = (TextView) row.findViewById(R.id.subreddit_name);
-                viewHolder.description = (TextView) row.findViewById(R.id.subreddit_description);
-                viewHolder.addIcon = (IconTextView) row.findViewById(R.id.subreddit_add_btn);
-            } else {
-                viewHolder = (ViewHolder) row.getTag();
-            }
-            // setup the row
-            final String name;
-            String description;
-            try {
-                name = sreddits.get(position).getString("display_name");
-                description = sreddits.get(position).getString("public_description");
-            } catch (JSONException e) {
-                e.printStackTrace();
-                return row;
-            }
-            viewHolder.name.setText(name);
-            viewHolder.description.setText(description);
-            viewHolder.addIcon.setOnClickListener(new OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    returnResult(sreddits.get(position), true);
-                }
-            });
-            row.setTag(viewHolder);
-
-            return row;
-        }
-
-        class ViewHolder {
-            TextView name;
-            TextView description;
-            IconTextView addIcon;
-        }
-    }
-
-    private DLTask dlpopulartask;
-
-    private class DLTask extends AsyncTask<String, Integer, ArrayList<JSONObject>> {
-        RedditData.RedditApiException exception;
-        @Override
-        protected ArrayList<JSONObject> doInBackground(String... string) {
-            // load popular subreddits
-            try {
-                srjson = global.mRedditData.getSubreddits();
-            } catch (RedditData.RedditApiException e) {
-                e.printStackTrace();
-                exception = e;
-                return null;
-            }
-            if (srjson == null) {
-                return new ArrayList<>();
-            }
-            // put into arraylist
-            ArrayList<JSONObject> popreddits = new ArrayList<>();
-            int i = 0;
-            while (i < srjson.length()) {
-                try {
-                    popreddits.add(srjson.getJSONObject(i).getJSONObject("data"));
-                } catch (JSONException e) {
-                    e.printStackTrace();
-                }
-                i++;
-            }
-            global.putSrList(popreddits);
-            return popreddits;
-        }
-
-        protected void onPostExecute(ArrayList<JSONObject> resultlist) {
-            if (resultlist==null){
-                Toast.makeText(ViewAllSubredditsActivity.this, "Error loading subreddits: " + exception.getMessage(), Toast.LENGTH_LONG).show();
-                return;
-            }
-            if (!this.isCancelled() || cancelrevert) {
-                if (action==null || !action.equals(ACTION_ADD_MULTI_SUB)) {
-                    sreddits.addAll(defaultsreddits);
-                }
-                sreddits.addAll(resultlist);
-                listadapter.notifyDataSetChanged();
-            }
-        }
-    }
-}
+/*
+ * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
+ * This file is part of Reddinator.
+ *
+ * Reddinator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Reddinator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
+ */
+package au.com.wallaceit.reddinator.activity;
+
+import android.app.ActionBar;
+import android.app.AlertDialog;
+import android.app.ListActivity;
+import android.app.ProgressDialog;
+import android.content.Context;
+import android.content.Intent;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.view.inputmethod.EditorInfo;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.BaseAdapter;
+import android.widget.EditText;
+import android.widget.IconTextView;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.TextView.OnEditorActionListener;
+import android.widget.Toast;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.ArrayList;
+
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.RedditData;
+
+public class ViewAllSubredditsActivity extends ListActivity {
+    public static final int RESULT_ADD_TO_MULTI = 3;
+    public static final int RESULT_SET_SUBREDDIT = 2;
+    public static final int RESULT_ADD_SUBREDDIT = 1;
+    public static final String ACTION_ADD_MULTI_SUB = "ADD_MULTI_SUBREDDIT";
+    private String action;
+    private Reddinator global;
+    private ArrayList<JSONObject> sreddits = new ArrayList<>();
+    private ArrayList<JSONObject> defaultsreddits;
+    private JSONArray srjson;
+    private SubredditsAdapter listadapter;
+    private EditText searchbox;
+    private TextView emptyview;
+
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        action = getIntent().getAction();
+        global = ((Reddinator) getApplicationContext());
+        ActionBar actionBar = getActionBar();
+        if (actionBar != null) {
+            actionBar.setDisplayHomeAsUpEnabled(true);
+        }
+        setContentView(R.layout.viewallsubreddit);
+        // setup list view
+        ListView listview = getListView();
+        listview.setTextFilterEnabled(true);
+        listview.setEmptyView(findViewById(R.id.subredditload));
+        listview.setOnItemClickListener(new OnItemClickListener() {
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                returnResult(sreddits.get(position), false);
+            }
+        });
+        // get empty view text for easy access later
+        emptyview = (TextView) findViewById(R.id.poploadtxt);
+        // setup search buttons
+        searchbox = (EditText) this.findViewById(R.id.searchbox);
+        searchbox.setOnEditorActionListener(new OnEditorActionListener() {
+            @Override
+            public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+                if (actionId == EditorInfo.IME_ACTION_SEARCH) {
+                    search(v.getText().toString());
+                }
+                return true;
+            }
+
+        });
+        IconTextView searchbtn = (IconTextView) this.findViewById(R.id.searchbutton);
+        searchbtn.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                String query = searchbox.getText().toString();
+                if (!query.equals("")) {
+                    search(query);
+                } else {
+                    new AlertDialog.Builder(ViewAllSubredditsActivity.this).setTitle("No Query").setMessage("Please enter something to search for").show();
+                }
+            }
+        });
+        loadDefaults();
+        // get list data
+        listadapter = new SubredditsAdapter(this);
+        if (global.isSrlistCached()) {
+            if (action==null || !action.equals(ACTION_ADD_MULTI_SUB)) {
+                sreddits.addAll(defaultsreddits);
+            }
+            sreddits.addAll(global.getSrList());
+        } else {
+            loadPopularSubreddits();
+        }
+        listview.setAdapter(listadapter);
+    }
+
+    private boolean cancelrevert = false;
+
+    public void onBackPressed() {
+        // System.out.println("onBackPressed()");
+        if (searchbox.getText().toString().equals("")) {
+            this.finish();
+        } else {
+            if (global.isSrlistCached()) {
+                sreddits.clear();
+                if (action==null || !action.equals(ACTION_ADD_MULTI_SUB)) {
+                    sreddits.addAll(defaultsreddits);
+                }
+                sreddits.addAll(global.getSrList());
+                listadapter.notifyDataSetChanged();
+            } else {
+                emptyview.setText("Loading popular...");
+                sreddits.clear();
+                listadapter.notifyDataSetChanged();
+                if (dlpopulartask == null) {
+                    loadPopularSubreddits();
+                } else {
+                    cancelrevert = true;
+                }
+            }
+            searchbox.setText("");
+        }
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case android.R.id.home:
+                onBackPressed();
+                return true;
+        }
+        return false;
+    }
+
+    protected void onResume() {
+        //System.out.println("onResume()");
+        super.onResume();
+    }
+
+    private void loadDefaults(){
+        defaultsreddits = new ArrayList<>();
+        try {
+            defaultsreddits.add(new JSONObject("{\"display_name\"=\"Front Page\", \"public_description\"=\"Your reddit front page\"}")); // slap the front page on there
+            defaultsreddits.add(new JSONObject("{\"display_name\"=\"all\", \"public_description\"=\"The best of reddit\"}")); // and an all
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void loadPopularSubreddits() {
+        dlpopulartask = new DLTask();
+        dlpopulartask.execute("");
+    }
+
+    private void search(final String query) {
+        //System.out.println("Searching: " + query);
+        if (dlpopulartask != null) {
+            dlpopulartask.cancel(true);
+        }
+        // use a thread for searching
+        final ProgressDialog sdialog = ProgressDialog.show(ViewAllSubredditsActivity.this, "", ("Searching..."), true);
+        Thread t = new Thread() {
+            public void run() {
+                // get all popular subreddits
+                try {
+                    srjson = global.mRedditData.getSubredditSearch(query);
+                } catch (final RedditData.RedditApiException e) {
+                    e.printStackTrace();
+                    runOnUiThread(new Runnable() {
+                        public void run() {
+                            Toast.makeText(ViewAllSubredditsActivity.this, e.getMessage(), Toast.LENGTH_LONG).show();
+                            sdialog.dismiss();
+                        }
+                    });
+                    return;
+                }
+                //System.out.println("search complete");
+                runOnUiThread(new Runnable() {
+                    public void run() {
+                        // put into arraylist
+                        sreddits.clear();
+                        int i = 0;
+                        while (i < srjson.length()) {
+                            try {
+                                sreddits.add(srjson.getJSONObject(i).getJSONObject("data"));
+                            } catch (JSONException e) {
+                                e.printStackTrace();
+                            }
+                            i++;
+                        }
+                        listadapter.notifyDataSetChanged();
+                        if (sreddits.size() == 0) {
+                            // set no result text in no items view
+                            emptyview.setText("No subreddits found");
+                        }
+                        sdialog.dismiss();
+                    }
+                });
+
+            }
+        };
+        t.start();
+    }
+
+    private void returnResult(JSONObject subObj, boolean addAction){
+        Intent intent = new Intent();
+        intent.putExtra("subredditObj", subObj.toString());
+        if (action!=null && action.equals(ACTION_ADD_MULTI_SUB)){
+            intent.putExtra("multipath", getIntent().getStringExtra("multipath"));
+            setResult(RESULT_ADD_TO_MULTI, intent);
+        } else {
+            if (addAction) {
+                setResult(RESULT_ADD_SUBREDDIT, intent);
+            } else {
+                setResult(RESULT_SET_SUBREDDIT, intent);
+            }
+        }
+        finish();
+    }
+
+    class SubredditsAdapter extends BaseAdapter {
+        private LayoutInflater inflater;
+
+        public SubredditsAdapter(Context context) {
+            inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        }
+
+        @Override
+        public int getCount() {
+            return sreddits.size();
+        }
+
+        @Override
+        public Object getItem(int i) {
+            return sreddits.get(i);
+        }
+
+        @Override
+        public long getItemId(int i) {
+            return 0;
+        }
+
+        @Override
+        public View getView(final int position, View row, ViewGroup parent) {
+            ViewHolder viewHolder = new ViewHolder();
+            if (row == null || row.getTag() == null) {
+                // inflate new view
+                row = inflater.inflate(R.layout.subreddititem, parent, false);
+                viewHolder.name = (TextView) row.findViewById(R.id.subreddit_name);
+                viewHolder.description = (TextView) row.findViewById(R.id.subreddit_description);
+                viewHolder.addIcon = (IconTextView) row.findViewById(R.id.subreddit_add_btn);
+            } else {
+                viewHolder = (ViewHolder) row.getTag();
+            }
+            // setup the row
+            final String name;
+            String description;
+            try {
+                name = sreddits.get(position).getString("display_name");
+                description = sreddits.get(position).getString("public_description");
+            } catch (JSONException e) {
+                e.printStackTrace();
+                return row;
+            }
+            viewHolder.name.setText(name);
+            viewHolder.description.setText(description);
+            viewHolder.addIcon.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    returnResult(sreddits.get(position), true);
+                }
+            });
+            row.setTag(viewHolder);
+
+            return row;
+        }
+
+        class ViewHolder {
+            TextView name;
+            TextView description;
+            IconTextView addIcon;
+        }
+    }
+
+    private DLTask dlpopulartask;
+
+    private class DLTask extends AsyncTask<String, Integer, ArrayList<JSONObject>> {
+        RedditData.RedditApiException exception;
+        @Override
+        protected ArrayList<JSONObject> doInBackground(String... string) {
+            // load popular subreddits
+            try {
+                srjson = global.mRedditData.getSubreddits();
+            } catch (RedditData.RedditApiException e) {
+                e.printStackTrace();
+                exception = e;
+                return null;
+            }
+            if (srjson == null) {
+                return new ArrayList<>();
+            }
+            // put into arraylist
+            ArrayList<JSONObject> popreddits = new ArrayList<>();
+            int i = 0;
+            while (i < srjson.length()) {
+                try {
+                    popreddits.add(srjson.getJSONObject(i).getJSONObject("data"));
+                } catch (JSONException e) {
+                    e.printStackTrace();
+                }
+                i++;
+            }
+            global.putSrList(popreddits);
+            return popreddits;
+        }
+
+        protected void onPostExecute(ArrayList<JSONObject> resultlist) {
+            if (resultlist==null){
+                Toast.makeText(ViewAllSubredditsActivity.this, "Error loading subreddits: " + exception.getMessage(), Toast.LENGTH_LONG).show();
+                return;
+            }
+            if (!this.isCancelled() || cancelrevert) {
+                if (action==null || !action.equals(ACTION_ADD_MULTI_SUB)) {
+                    sreddits.addAll(defaultsreddits);
+                }
+                sreddits.addAll(resultlist);
+                listadapter.notifyDataSetChanged();
+            }
+        }
+    }
+}
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/ViewRedditActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ViewRedditActivity.java
similarity index 97%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/ViewRedditActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ViewRedditActivity.java
index b9d7181..df8ae00 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/ViewRedditActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/ViewRedditActivity.java
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.annotation.TargetApi;
 import android.app.ActionBar;
@@ -59,9 +59,19 @@ import org.json.JSONObject;
 import java.lang.reflect.Method;
 import java.util.Date;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.service.MailCheckService;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.core.RedditData;
+import au.com.wallaceit.reddinator.ui.SimpleTabsWidget;
+import au.com.wallaceit.reddinator.ui.TabCommentsFragment;
+import au.com.wallaceit.reddinator.ui.TabWebFragment;
+import au.com.wallaceit.reddinator.core.ThemeManager;
+import au.com.wallaceit.reddinator.service.WidgetProvider;
+
 public class ViewRedditActivity extends FragmentActivity {
 
-    private GlobalObjects global;
+    private Reddinator global;
     private SharedPreferences prefs;
     private MenuItem upvote;
     private MenuItem downvote;
@@ -86,7 +96,7 @@ public class ViewRedditActivity extends FragmentActivity {
     @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        global = ((GlobalObjects) ViewRedditActivity.this.getApplicationContext());
+        global = ((Reddinator) ViewRedditActivity.this.getApplicationContext());
         prefs = PreferenceManager.getDefaultSharedPreferences(ViewRedditActivity.this);
         // set window flags
         getWindow().requestFeature(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);
@@ -334,7 +344,7 @@ public class ViewRedditActivity extends FragmentActivity {
                 break;
 
             case R.id.menu_about:
-                GlobalObjects.showInfoDialog(this, true);
+                Reddinator.showInfoDialog(this, true);
                 break;
 
             default:
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/WebViewActivity.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/WebViewActivity.java
similarity index 96%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/WebViewActivity.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/activity/WebViewActivity.java
index 4dff326..3012c39 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/WebViewActivity.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/activity/WebViewActivity.java
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.activity;
 
 import android.annotation.SuppressLint;
 import android.app.ActionBar;
@@ -42,11 +42,14 @@ import com.joanzapata.android.iconify.Iconify;
 
 import java.lang.reflect.Method;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+
 public class WebViewActivity extends Activity {
     WebView wv;
     WebViewClient wvclient;
     Activity mActivity;
-    GlobalObjects global;
+    Reddinator global;
     SharedPreferences prefs;
 
     public static final String ACTION_CLEAR_INBOX_COUNT= "clearInboxCount";
@@ -55,7 +58,7 @@ public class WebViewActivity extends Activity {
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        global = ((GlobalObjects) WebViewActivity.this.getApplicationContext());
+        global = ((Reddinator) WebViewActivity.this.getApplicationContext());
         // request loading bar
         getWindow().requestFeature(Window.FEATURE_PROGRESS);
         getWindow().setFeatureInt(Window.FEATURE_PROGRESS, Window.PROGRESS_VISIBILITY_ON);
@@ -180,7 +183,7 @@ public class WebViewActivity extends Activity {
                 break;
 
             case R.id.menu_about:
-                GlobalObjects.showInfoDialog(this, true);
+                Reddinator.showInfoDialog(this, true);
                 break;
 
             default:
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/RedditData.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/core/RedditData.java
similarity index 96%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/RedditData.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/core/RedditData.java
index 43f0b2f..762183a 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/RedditData.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/core/RedditData.java
@@ -1,824 +1,826 @@
-/*
- * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
- * This file is part of Reddinator.
- *
- * Reddinator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * Reddinator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
- */
-package au.com.wallaceit.reddinator;
-
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.net.Uri;
-import android.preference.PreferenceManager;
-import android.util.Base64;
-
-import com.squareup.okhttp.FormEncodingBuilder;
-import com.squareup.okhttp.Interceptor;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.Request;
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.Response;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-
-public class RedditData {
-    private SharedPreferences sharedPrefs;
-    private OkHttpClient httpClient;
-    private static final String STANDARD_ENDPOINT = "https://www.reddit.com";
-    private static final String OAUTH_ENDPOINT = "https://oauth.reddit.com";
-    public static final String OAUTH_CLIENTID = "wY63YAHgSPSh5w";
-    public static final String OAUTH_SCOPES = "mysubreddits,vote,read,submit,edit,identity,subscribe";
-    public static final String OAUTH_REDIRECT = "oauth://reddinator.wallaceit.com.au";
-    private String userAgent;
-    private JSONObject oauthToken = null;
-    private String oauthstate = null; // random string for secure oauth flow
-    private String username;
-    private int inboxCount = 0;
-    private long lastUpdateTime = 0;
-
-    RedditData(Context context) {
-        // set user agent
-        userAgent = "android:au.com.wallaceit.reddinator:v";
-        try {
-            PackageInfo manager = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
-            userAgent += manager.versionName;
-        } catch (PackageManager.NameNotFoundException e) {
-            e.printStackTrace();
-        }
-        userAgent += " (by /u/micwallace)";
-        // load account
-        sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);
-        String tokenStr = sharedPrefs.getString("oauthtoken", "");
-        username = sharedPrefs.getString("username", "");
-        inboxCount = sharedPrefs.getInt("inbox_count", 0);
-        lastUpdateTime = sharedPrefs.getLong("last_info_update", 0);
-        if (tokenStr!=null && !tokenStr.equals("")) {
-            try {
-                oauthToken = new JSONObject(tokenStr);
-            } catch (JSONException e) {
-                e.printStackTrace();
-                oauthToken = null;
-            }
-        }
-    }
-
-    // ACCOUNT CONTROL
-    public void initiateLogin(Context context) {
-        Intent loginintent = new Intent(context, OAuthView.class);
-        oauthstate = UUID.randomUUID().toString();
-        loginintent.putExtra("oauthstate", oauthstate);
-        context.startActivity(loginintent);
-    }
-
-    public void purgeAccountData() {
-        oauthToken = null;
-        username = null;
-        saveUserData();
-    }
-
-    // NON-AUTHED REQUESTS
-    public JSONArray getSubreddits() throws RedditApiException {
-        JSONArray subreddits;
-        String url = STANDARD_ENDPOINT + "/subreddits/popular.json?limit=50";
-        try {
-            subreddits = redditApiGet(url, false).getJSONObject("data").getJSONArray("children");
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-        return subreddits;
-    }
-
-    public JSONArray getSubredditSearch(String query) throws RedditApiException {
-        JSONArray subreddits;
-        String url = STANDARD_ENDPOINT + "/subreddits/search.json?q=" + Uri.encode(query);
-        try {
-            subreddits = redditApiGet(url, false).getJSONObject("data").getJSONArray("children");
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-        return subreddits;
-    }
-
-    public JSONArray searchRedditNames(String query) throws RedditApiException {
-        JSONArray names;
-        String url = (isLoggedIn() ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + "/api/search_reddit_names.json?include_over_18=true&query=" + Uri.encode(query);
-        try {
-            names = redditApiPost(url).getJSONArray("names");
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-        return names;
-    }
-
-    public JSONObject getSubmitText(String subreddit) throws RedditApiException {
-
-        String url = STANDARD_ENDPOINT + "/r/"+subreddit+"/api/submit_text/.json";
-        return redditApiGet(url, false);
-    }
-
-    public JSONArray getRedditFeed(String feedPath, String sort, int limit, String afterid) throws RedditApiException {
-        boolean loggedIn = isLoggedIn();
-        String url = (loggedIn ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + feedPath + "/" + sort + ".json?limit=" + String.valueOf(limit) + (!afterid.equals("0") ? "&after=" + afterid : "");
-        JSONObject result;
-        JSONArray feed;
-
-        result = redditApiGet(url, true); // use oauth if logged in
-        try {
-            feed = result.getJSONObject("data").getJSONArray("children");
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-        return feed;
-    }
-
-    public JSONArray getCommentsFeed(String permalink, String sort, int limit) throws RedditApiException {
-        boolean loggedIn = isLoggedIn();
-        String url = (loggedIn ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + permalink + ".json?api_type=json&sort=" + sort + "&limit=" + String.valueOf(limit);
-
-        return redditApiGetArray(url, loggedIn);
-    }
-
-    public JSONArray getChildComments(String moreId, String articleId, String children, String sort) throws RedditApiException {
-        boolean loggedIn = isLoggedIn();
-        String url = (loggedIn ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + "/api/morechildren.json?api_type=json&sort=" + sort + "&id=" + moreId + "&link_id=" + articleId + "&children=" + children;
-
-        JSONArray feed = new JSONArray();
-
-        try {
-            JSONObject result = redditApiGet(url, true); // use oauth if logged in
-            if (result != null) {
-                feed = result.getJSONObject("json").getJSONObject("data").getJSONArray("things");
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-        return feed;
-    }
-
-    // AUTHED CALLS
-    public String getUsername(){
-        return username;
-    }
-
-    public int getInboxCount(){
-        return inboxCount;
-    }
-
-    public long getLastUserUpdateTime(){ return lastUpdateTime; }
-
-    public void clearStoredInboxCount(){
-        inboxCount = 0;
-        SharedPreferences.Editor edit = sharedPrefs.edit();
-        edit.putInt("inbox_count", inboxCount);
-        edit.apply();
-    }
-
-    // updates internally tracked user info and saves it to preference. This is also used for saving oauth token for the first time.
-    public void updateUserInfo() throws RedditApiException {
-        JSONObject userInfo = getUserInfo();
-        try {
-            username = userInfo.getString("name");
-            inboxCount = userInfo.getInt("inbox_count");
-            lastUpdateTime = (new Date()).getTime();
-        } catch (JSONException e) {
-            e.printStackTrace();
-            return;
-        }
-        saveUserData();
-    }
-
-    private JSONObject getUserInfo() throws RedditApiException {
-
-        checkLogin();
-
-        JSONObject resultjson;
-        String url = OAUTH_ENDPOINT + "/api/v1/me";
-        try {
-            resultjson = redditApiGet(url, true);
-
-            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
-                throw new RedditApiException("API error: "+resultjson.getJSONArray("errors").getJSONArray(0).getString(1));
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-
-        return resultjson;
-    }
-
-    public boolean vote(String id, int direction) throws RedditApiException {
-
-        checkLogin();
-
-        JSONObject resultjson;
-        String url = OAUTH_ENDPOINT + "/api/vote?id=" + id + "&dir=" + String.valueOf(direction) + "&api_type=json";
-        try {
-            resultjson = redditApiPost(url);
-
-            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
-                JSONArray errors = resultjson.getJSONArray("errors");
-                JSONArray firsterror = (JSONArray) errors.get(0);
-                if (firsterror.get(0).equals("USER_REQUIRED")) {
-                    oauthToken = null; // bearer token invalid, nullify
-                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
-                }
-                return false;
-            } else {
-                return true;
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-    }
-
-    public JSONObject postComment(String parentId, String text) throws RedditApiException {
-
-        checkLogin();
-
-        JSONObject resultjson;
-
-        try {
-            String url = OAUTH_ENDPOINT + "/api/comment?thing_id=" + parentId + "&text=" + URLEncoder.encode(text, "UTF-8") + "&api_type=json";
-
-            resultjson = redditApiPost(url).getJSONObject("json");
-            System.out.println(resultjson.toString());
-            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
-                JSONArray errors = resultjson.getJSONArray("errors");
-                JSONArray firsterror = (JSONArray) errors.get(0);
-                if (firsterror.get(0).equals("USER_REQUIRED")) {
-                    oauthToken = null; // bearer token invalid, nullify
-                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
-                }
-                throw new RedditApiException("API Error: "+firsterror.get(1), true);
-            } else {
-                return resultjson.getJSONObject("data").getJSONArray("things").getJSONObject(0).getJSONObject("data");
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Encoding error: "+e.getMessage());
-        }
-    }
-
-    public JSONObject editComment(String thingId, String text) throws RedditApiException {
-
-        checkLogin();
-
-        JSONObject resultjson;
-
-        try {
-            String url = OAUTH_ENDPOINT + "/api/editusertext?thing_id=" + thingId + "&text=" + URLEncoder.encode(text, "UTF-8") + "&api_type=json";
-
-            resultjson = redditApiPost(url).getJSONObject("json");
-
-            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
-                JSONArray errors = resultjson.getJSONArray("errors");
-                JSONArray firsterror = (JSONArray) errors.get(0);
-                if (firsterror.get(0).equals("USER_REQUIRED")) {
-                    oauthToken = null; // bearer token invalid, nullify
-                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
-                }
-                throw new RedditApiException("API Error: "+firsterror.get(1), true);
-            } else {
-                return resultjson.getJSONObject("data").getJSONArray("things").getJSONObject(0).getJSONObject("data");
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Encoding error: "+e.getMessage());
-        }
-    }
-
-    public boolean deleteComment(String thingId) throws RedditApiException {
-        checkLogin();
-
-        JSONObject resultjson;
-
-        try {
-            String url = OAUTH_ENDPOINT + "/api/del?id=" + thingId;
-
-            resultjson = redditApiPost(url);
-
-            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
-                JSONArray errors = resultjson.getJSONArray("errors");
-                JSONArray firsterror = (JSONArray) errors.get(0);
-                if (firsterror.get(0).equals("USER_REQUIRED")) {
-                    oauthToken = null; // bearer token invalid, nullify
-                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
-                }
-                throw new RedditApiException("API Error: "+firsterror.get(1), true);
-            } else {
-                return true;
-            }
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-    }
-
-    public JSONArray getMySubreddits() throws RedditApiException {
-        checkLogin();
-
-        String url = OAUTH_ENDPOINT + "/subreddits/mine/subscriber.json?limit=100&show=all";
-        JSONArray resultjson;
-        try {
-            resultjson = redditApiGet(url, true).getJSONObject("data").getJSONArray("children");
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Parsing error: "+e.getMessage());
-        }
-        return resultjson;
-    }
-
-    public JSONObject subscribe(String subId, boolean subscribe) throws RedditApiException {
-        checkLogin();
-
-        String url = OAUTH_ENDPOINT + "/api/subscribe?sr="+ subId +"&action="+(subscribe?"sub":"unsub");
-
-        return redditApiPost(url);
-    }
-
-    public JSONArray getMyMultis() throws RedditApiException {
-        checkLogin();
-
-        String url = OAUTH_ENDPOINT + "/api/multi/mine";
-
-        return redditApiGetArray(url, true);
-    }
-
-    public JSONObject copyMulti(String name, String fromPath) throws RedditApiException {
-        checkLogin();
-
-        String url;
-        try {
-            url = OAUTH_ENDPOINT + "/api/multi/copy?display_name="+ URLEncoder.encode(name, "UTF-8")+"&from="+fromPath+"&to=/user/"+username+"/m/"+URLEncoder.encode(name.toLowerCase().replaceAll("\\s+", ""), "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Encoding error: "+e.getMessage());
-        }
-
-        return redditApiPost(url);
-    }
-
-    public JSONObject createMulti(String name, JSONObject multiObj) throws RedditApiException {
-        checkLogin();
-
-        String url;
-        try {
-            url = OAUTH_ENDPOINT + "/api/multi/user/"+username+"/m/"+name+"?model="+URLEncoder.encode(multiObj.toString(), "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Encoding error: "+e.getMessage());
-        }
-
-        return redditApiPost(url);
-    }
-
-    public JSONObject editMulti(String multiPath, JSONObject multiObj) throws RedditApiException {
-        checkLogin();
-
-        String url;
-        try {
-            url = OAUTH_ENDPOINT + "/api/multi"+multiPath+"?model="+URLEncoder.encode(multiObj.toString(), "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Encoding error: "+e.getMessage());
-        }
-
-        return redditApiPut(url);
-    }
-
-    public void deleteMulti(String multiPath) throws RedditApiException {
-        checkLogin();
-
-        String url = OAUTH_ENDPOINT + "/api/multi"+multiPath;
-
-        redditApiDelete(url);
-    }
-
-    public JSONObject renameMulti(String multiPath, String newName) throws RedditApiException {
-        checkLogin();
-
-        String url = OAUTH_ENDPOINT + "/api/multi/rename/?from="+multiPath+"&to=/user/"+username+"/m/"+newName;
-
-        return redditApiPost(url);
-    }
-
-    public JSONObject addMultiSubreddit(String multiPath, String subredditName) throws RedditApiException {
-        checkLogin();
-
-        String url;
-        try {
-            url = OAUTH_ENDPOINT + "/api/multi"+multiPath+"/r/"+subredditName+"?srname="+URLEncoder.encode(subredditName, "UTF-8")+"&model="+URLEncoder.encode("{\"name\":\""+subredditName+"\"}", "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Encoding error: "+e.getMessage());
-        }
-
-        return redditApiPut(url);
-    }
-
-    public void removeMultiSubreddit(String multiPath, String subredditName) throws RedditApiException {
-        checkLogin();
-
-        String url;
-        try {
-            url = OAUTH_ENDPOINT + "/api/multi"+multiPath+"/r/"+subredditName+"?srname="+URLEncoder.encode(subredditName, "UTF-8")+"&model="+URLEncoder.encode("{\"name\":\""+subredditName+"\"}", "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Encoding error: "+e.getMessage());
-        }
-
-        redditApiDelete(url);
-    }
-
-    public JSONObject submit(String subreddit, boolean isLink, String title, String content) throws RedditApiException {
-        checkLogin();
-
-        try {
-            content = URLEncoder.encode(content,"UTF-8");
-            String url = OAUTH_ENDPOINT + "/api/submit?api_type=json&extension=json&then=comments&sr=" + URLEncoder.encode(subreddit, "UTF-8") + "&kind=" + (isLink?"link":"self") + "&title=" + URLEncoder.encode(title, "UTF-8") + "&" + (isLink?"url="+content:"text="+content);
-
-            return redditApiPost(url).getJSONObject("json");
-
-        } catch (JSONException | UnsupportedEncodingException e) {
-            throw new RedditApiException(e.getMessage());
-        }
-    }
-
-    // COMM FUNCTIONS
-    // Create Http/s client
-    private boolean createHttpClient() {
-        httpClient = new OkHttpClient();
-        httpClient.setConnectTimeout(10, TimeUnit.SECONDS);
-        httpClient.setReadTimeout(10, TimeUnit.SECONDS);
-        httpClient.networkInterceptors().add(new Interceptor() {
-            @Override
-            public Response intercept(Chain chain) throws IOException {
-                Request originalRequest = chain.request();
-                Request requestWithUserAgent = originalRequest.newBuilder()
-                        .removeHeader("User-Agent")
-                        .addHeader("User-Agent", userAgent)
-                        .build();
-                return chain.proceed(requestWithUserAgent);
-            }
-        });
-
-        return true;
-    }
-
-    private JSONArray redditApiGetArray(String url, boolean useAuth) throws RedditApiException {
-        JSONArray jArr;
-        try {
-            String json = redditApiRequest(url, "GET", useAuth ? REQUEST_MODE_AUTHED : REQUEST_MODE_UNAUTHED, null);
-            jArr = new JSONArray(json);
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Error: "+e.getMessage());
-        }
-        return jArr;
-    }
-
-    private JSONObject redditApiGet(String url, boolean useAuth) throws RedditApiException {
-        JSONObject jObj;
-        try {
-            String json = redditApiRequest(url, "GET", useAuth?REQUEST_MODE_AUTHED:REQUEST_MODE_UNAUTHED, null);
-            jObj = new JSONObject(json);
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Error: "+e.getMessage());
-        }
-        return jObj;
-    }
-
-    private JSONObject redditApiPost(String url) throws RedditApiException {
-        JSONObject jObj;
-        try {
-            String json = redditApiRequest(url, "POST", REQUEST_MODE_AUTHED, null);
-            jObj = new JSONObject(json);
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Error: "+e.getMessage());
-        }
-        return jObj;
-    }
-
-    private JSONObject redditApiPut(String url) throws RedditApiException {
-        JSONObject jObj;
-        try {
-            String json = redditApiRequest(url, "PUT", REQUEST_MODE_AUTHED, null);
-            jObj = new JSONObject(json);
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Error: "+e.getMessage());
-        }
-        return jObj;
-    }
-
-    private void redditApiDelete(String url) throws RedditApiException {
-
-        redditApiRequest(url, "DELETE", REQUEST_MODE_AUTHED, null);
-    }
-
-    private JSONObject redditApiOauthRequest(String url, HashMap<String, String> data) throws RedditApiException {
-        JSONObject jObj;
-        try {
-            String json = redditApiRequest(url, "POST", REQUEST_MODE_OAUTHREQ, data);
-            jObj = new JSONObject(json);
-        } catch (JSONException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Error: "+e.getMessage());
-        }
-        return jObj;
-    }
-
-    private static final int REQUEST_MODE_UNAUTHED = 0;
-    private static final int REQUEST_MODE_AUTHED = 1;
-    private static final int REQUEST_MODE_OAUTHREQ = 2;
-    private static final MediaType POST_ENCODED = MediaType.parse("application/x-www-form-urlencoded; charset=utf-8");
-    private String redditApiRequest(String urlStr, String method, int oauthMode, HashMap<String, String> formData) throws RedditApiException {
-        String json;
-        // create client if null
-        if (httpClient == null) {
-            createHttpClient();
-        }
-        try {
-            Request.Builder httpRequest = new Request.Builder().url(urlStr);
-            RequestBody httpRequestBody;
-            String requestStr = "";
-            if (formData!=null) {
-                FormEncodingBuilder formBuilder = new FormEncodingBuilder();
-                Iterator iterator = formData.keySet().iterator();
-                String key;
-                while (iterator.hasNext()){
-                    key = (String) iterator.next();
-                    formBuilder.add(key, formData.get(key));
-                }
-                httpRequestBody = formBuilder.build();
-            } else {
-                if (!method.equals("GET")) {
-                    int queryIndex = urlStr.indexOf("?");
-                    if (queryIndex!=-1)
-                        urlStr = urlStr.substring(queryIndex);
-                    requestStr = URLEncoder.encode(urlStr, "UTF-8");
-                }
-                httpRequestBody = RequestBody.create(POST_ENCODED, requestStr);
-            }
-
-            switch (method){
-                case "POST":
-                    httpRequest.post(httpRequestBody);
-                    break;
-                case "PUT":
-                    httpRequest.put(httpRequestBody);
-                    break;
-                case "DELETE":
-                    httpRequest.delete(httpRequestBody);
-                    break;
-                case "GET":
-                default:
-                    httpRequest.get();
-                    break;
-            }
-            if (oauthMode==REQUEST_MODE_OAUTHREQ) {
-                // For oauth token retrieval and refresh
-                httpRequest.addHeader("Authorization", "Basic " + Base64.encodeToString((OAUTH_CLIENTID + ":").getBytes(), Base64.URL_SAFE | Base64.NO_WRAP));
-            } else if (isLoggedIn() && oauthMode==REQUEST_MODE_AUTHED) {
-                if (isTokenExpired()) {
-                    refreshToken();
-                }
-                // add auth headers
-                String tokenStr = getTokenValue("token_type") + " " + getTokenValue("access_token");
-                httpRequest.addHeader("Authorization", tokenStr);
-            }
-
-            Response response = httpClient.newCall(httpRequest.build()).execute();
-            json = response.body().string();
-            int errorCode = response.code();
-            if (errorCode<200 && errorCode>202) {
-                String errorMsg = getErrorText(json);
-                throw new RedditApiException("Error "+String.valueOf(errorCode)+": "+(errorMsg.equals("")?response.message():errorMsg)+(errorCode==403?" (Authorization with Reddit required)":""), errorCode==403, errorCode);
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-            throw new RedditApiException("Error: "+e.getMessage());
-        }
-
-        return json;
-    }
-
-    private String getErrorText(String response){
-        String errorMsg = "";
-        if (response!=null) {
-            if (response.indexOf("{")==0)
-            try {
-                JSONObject errorJson = new JSONObject(response);
-                if (errorJson.has("errors")) {
-                    JSONArray errorArr = errorJson.getJSONArray("errors");
-                    if (errorArr.length()>0)
-                        errorArr.getJSONArray(0).getString(1);
-                }
-                return errorMsg;
-            } catch (JSONException e) {
-                e.printStackTrace();
-            }
-            // attempt to get html error message (often returned by 403)
-            /*System.err.println(response);
-            final Pattern patternh2 = Pattern.compile("<h2>(.+?)</h2>");
-            final Pattern patternh3 = Pattern.compile("<h3>(.+?)</h3>");
-            Matcher matcher = patternh2.matcher(response);
-            if (matcher.matches()) {
-                errorMsg = matcher.group(1);
-                matcher = patternh3.matcher(response);
-                if (matcher.group(1)!=null && !matcher.group(1).equals(""))
-                    errorMsg += ", " + matcher.group(1);
-            }*/
-        }
-        return errorMsg;
-    }
-
-    private void checkLogin() throws RedditApiException {
-        if (!isLoggedIn()) {
-            throw new RedditApiException("Reddit Login Required", true);
-        }
-    }
-
-    class RedditApiException extends Exception {
-        private boolean isLoginError = false;
-        private int httpErrorCode = 200;
-        //Constructor that accepts a message
-        public RedditApiException(String message) {
-            super(message);
-        }
-
-        public RedditApiException(String message, boolean isLoginError) {
-            super(message);
-            this.isLoginError = isLoginError;
-        }
-
-        public RedditApiException(String message, boolean isLoginError, int httpErrorCode) {
-            super(message);
-            this.isLoginError = isLoginError;
-            this.httpErrorCode = httpErrorCode;
-        }
-
-        public int getHttpErrorCode() { return httpErrorCode; }
-
-        public boolean isAuthError(){
-            return isLoginError;
-        }
-    }
-
-    // OAUTH FUNCTIONS
-    public boolean isLoggedIn() {
-        return oauthToken != null;
-    }
-
-    private boolean isTokenExpired() {
-        Long now = (System.currentTimeMillis() / 1000L);
-        Long expiry = (long) 0;
-        try {
-            expiry = oauthToken.getLong("expires_at");
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-        return expiry < now;
-    }
-
-    private String getTokenValue(String key) {
-        String token = "";
-        try {
-            token = oauthToken.getString(key);
-        } catch (JSONException e) {
-            e.printStackTrace();
-        }
-        return token;
-    }
-
-    public void retrieveToken(String code, String state) throws RedditApiException {
-        if (!state.equals(oauthstate)) {
-            throw new RedditApiException("OAuth Error: Invalid state");
-        }
-        String url = "https://www.reddit.com/api/v1/access_token";
-        JSONObject resultjson;
-        HashMap<String, String> params = new HashMap<>();
-        params.put("grant_type", "authorization_code");
-        params.put("code", code);
-        params.put("redirect_uri", OAUTH_REDIRECT);
-        resultjson = redditApiOauthRequest(url, params);
-        if (resultjson.has("access_token")) {
-            // login successful, set new token and save
-            oauthToken = resultjson;
-            try {
-                Long epoch = (System.currentTimeMillis() / 1000L);
-                Long expires_at = epoch + Integer.parseInt(oauthToken.getString("expires_in"));
-                oauthToken.put("expires_at", expires_at);
-            } catch (JSONException e) {
-                e.printStackTrace();
-                throw new RedditApiException("OAuth Error: "+e.getMessage());
-            }
-            // try to retrieve user info & save, if exception thrown, just make sure we save token
-            try {
-                updateUserInfo();
-            } catch (RedditApiException e) {
-                e.printStackTrace();
-                saveUserData();
-            }
-            //System.out.println("oauth request result: OK");
-            return;
-        }
-        // throw error
-        throwOAuthError(resultjson);
-    }
-
-    private void refreshToken() throws RedditApiException {
-        String url = "https://www.reddit.com/api/v1/access_token";
-        JSONObject resultjson;
-        HashMap<String, String> params = new HashMap<>();
-        params.put("grant_type", "refresh_token");
-        params.put("refresh_token", getTokenValue("refresh_token"));
-        resultjson = redditApiOauthRequest(url, params);
-        if (resultjson.has("access_token")) {
-            // login successful, update token and save
-            try {
-                oauthToken.put("access_token", resultjson.get("access_token"));
-                oauthToken.put("token_type", resultjson.get("token_type"));
-                Long expires_in = resultjson.getLong("expires_in") - 30;
-                Long epoch = (System.currentTimeMillis() / 1000L);
-                oauthToken.put("expires_in", expires_in);
-                oauthToken.put("expires_at", (epoch + expires_in));
-            } catch (JSONException e) {
-                e.printStackTrace();
-                throw new RedditApiException("OAuth Error: "+e.getMessage());
-            }
-            // save oauth token
-            saveUserData();
-            //System.out.println("oauth refresh result: OK");
-            return;
-        }
-        // set error result
-        throwOAuthError(resultjson);
-    }
-
-    private void throwOAuthError(JSONObject resultjson) throws RedditApiException {
-        String error;
-        if (resultjson.has("error")){
-            try {
-                error = resultjson.getString("error");
-            } catch (JSONException e) {
-                e.printStackTrace();
-                error = "Unknown Error D-:";
-            }
-        } else {
-            error = "Unknown Error D-:";
-        }
-        throw new RedditApiException("OAuth Error: "+error);
-    }
-
-    public void saveUserData() {
-        SharedPreferences.Editor edit = sharedPrefs.edit();
-        edit.putString("oauthtoken", oauthToken == null ? "" : oauthToken.toString());
-        edit.putString("username", username);
-        edit.putInt("inbox_count", inboxCount);
-        edit.putLong("last_info_update", lastUpdateTime);
-        edit.apply();
-    }
-
-}
+/*
+ * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
+ * This file is part of Reddinator.
+ *
+ * Reddinator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Reddinator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
+ */
+package au.com.wallaceit.reddinator.core;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.preference.PreferenceManager;
+import android.util.Base64;
+
+import com.squareup.okhttp.FormEncodingBuilder;
+import com.squareup.okhttp.Interceptor;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import au.com.wallaceit.reddinator.activity.OAuthView;
+
+public class RedditData {
+    private SharedPreferences sharedPrefs;
+    private OkHttpClient httpClient;
+    private static final String STANDARD_ENDPOINT = "https://www.reddit.com";
+    private static final String OAUTH_ENDPOINT = "https://oauth.reddit.com";
+    public static final String OAUTH_CLIENTID = "wY63YAHgSPSh5w";
+    public static final String OAUTH_SCOPES = "mysubreddits,vote,read,submit,edit,identity,subscribe";
+    public static final String OAUTH_REDIRECT = "oauth://reddinator.wallaceit.com.au";
+    private String userAgent;
+    private JSONObject oauthToken = null;
+    private String oauthstate = null; // random string for secure oauth flow
+    private String username;
+    private int inboxCount = 0;
+    private long lastUpdateTime = 0;
+
+    public RedditData(Context context) {
+        // set user agent
+        userAgent = "android:au.com.wallaceit.reddinator:v";
+        try {
+            PackageInfo manager = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
+            userAgent += manager.versionName;
+        } catch (PackageManager.NameNotFoundException e) {
+            e.printStackTrace();
+        }
+        userAgent += " (by /u/micwallace)";
+        // load account
+        sharedPrefs = PreferenceManager.getDefaultSharedPreferences(context);
+        String tokenStr = sharedPrefs.getString("oauthtoken", "");
+        username = sharedPrefs.getString("username", "");
+        inboxCount = sharedPrefs.getInt("inbox_count", 0);
+        lastUpdateTime = sharedPrefs.getLong("last_info_update", 0);
+        if (!tokenStr.equals("")) {
+            try {
+                oauthToken = new JSONObject(tokenStr);
+            } catch (JSONException e) {
+                e.printStackTrace();
+                oauthToken = null;
+            }
+        }
+    }
+
+    // ACCOUNT CONTROL
+    public void initiateLogin(Context context) {
+        Intent loginintent = new Intent(context, OAuthView.class);
+        oauthstate = UUID.randomUUID().toString();
+        loginintent.putExtra("oauthstate", oauthstate);
+        context.startActivity(loginintent);
+    }
+
+    public void purgeAccountData() {
+        oauthToken = null;
+        username = null;
+        saveUserData();
+    }
+
+    // NON-AUTHED REQUESTS
+    public JSONArray getSubreddits() throws RedditApiException {
+        JSONArray subreddits;
+        String url = STANDARD_ENDPOINT + "/subreddits/popular.json?limit=50";
+        try {
+            subreddits = redditApiGet(url, false).getJSONObject("data").getJSONArray("children");
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+        return subreddits;
+    }
+
+    public JSONArray getSubredditSearch(String query) throws RedditApiException {
+        JSONArray subreddits;
+        String url = STANDARD_ENDPOINT + "/subreddits/search.json?q=" + Uri.encode(query);
+        try {
+            subreddits = redditApiGet(url, false).getJSONObject("data").getJSONArray("children");
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+        return subreddits;
+    }
+
+    public JSONArray searchRedditNames(String query) throws RedditApiException {
+        JSONArray names;
+        String url = (isLoggedIn() ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + "/api/search_reddit_names.json?include_over_18=true&query=" + Uri.encode(query);
+        try {
+            names = redditApiPost(url).getJSONArray("names");
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+        return names;
+    }
+
+    public JSONObject getSubmitText(String subreddit) throws RedditApiException {
+
+        String url = STANDARD_ENDPOINT + "/r/"+subreddit+"/api/submit_text/.json";
+        return redditApiGet(url, false);
+    }
+
+    public JSONArray getRedditFeed(String feedPath, String sort, int limit, String afterid) throws RedditApiException {
+        boolean loggedIn = isLoggedIn();
+        String url = (loggedIn ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + feedPath + "/" + sort + ".json?limit=" + String.valueOf(limit) + (!afterid.equals("0") ? "&after=" + afterid : "");
+        JSONObject result;
+        JSONArray feed;
+
+        result = redditApiGet(url, true); // use oauth if logged in
+        try {
+            feed = result.getJSONObject("data").getJSONArray("children");
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+        return feed;
+    }
+
+    public JSONArray getCommentsFeed(String permalink, String sort, int limit) throws RedditApiException {
+        boolean loggedIn = isLoggedIn();
+        String url = (loggedIn ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + permalink + ".json?api_type=json&sort=" + sort + "&limit=" + String.valueOf(limit);
+
+        return redditApiGetArray(url, loggedIn);
+    }
+
+    public JSONArray getChildComments(String moreId, String articleId, String children, String sort) throws RedditApiException {
+        boolean loggedIn = isLoggedIn();
+        String url = (loggedIn ? OAUTH_ENDPOINT : STANDARD_ENDPOINT) + "/api/morechildren.json?api_type=json&sort=" + sort + "&id=" + moreId + "&link_id=" + articleId + "&children=" + children;
+
+        JSONArray feed = new JSONArray();
+
+        try {
+            JSONObject result = redditApiGet(url, true); // use oauth if logged in
+            if (result != null) {
+                feed = result.getJSONObject("json").getJSONObject("data").getJSONArray("things");
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+        return feed;
+    }
+
+    // AUTHED CALLS
+    public String getUsername(){
+        return username;
+    }
+
+    public int getInboxCount(){
+        return inboxCount;
+    }
+
+    public long getLastUserUpdateTime(){ return lastUpdateTime; }
+
+    public void clearStoredInboxCount(){
+        inboxCount = 0;
+        SharedPreferences.Editor edit = sharedPrefs.edit();
+        edit.putInt("inbox_count", inboxCount);
+        edit.apply();
+    }
+
+    // updates internally tracked user info and saves it to preference. This is also used for saving oauth token for the first time.
+    public void updateUserInfo() throws RedditApiException {
+        JSONObject userInfo = getUserInfo();
+        try {
+            username = userInfo.getString("name");
+            inboxCount = userInfo.getInt("inbox_count");
+            lastUpdateTime = (new Date()).getTime();
+        } catch (JSONException e) {
+            e.printStackTrace();
+            return;
+        }
+        saveUserData();
+    }
+
+    private JSONObject getUserInfo() throws RedditApiException {
+
+        checkLogin();
+
+        JSONObject resultjson;
+        String url = OAUTH_ENDPOINT + "/api/v1/me";
+        try {
+            resultjson = redditApiGet(url, true);
+
+            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
+                throw new RedditApiException("API error: "+resultjson.getJSONArray("errors").getJSONArray(0).getString(1));
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+
+        return resultjson;
+    }
+
+    public boolean vote(String id, int direction) throws RedditApiException {
+
+        checkLogin();
+
+        JSONObject resultjson;
+        String url = OAUTH_ENDPOINT + "/api/vote?id=" + id + "&dir=" + String.valueOf(direction) + "&api_type=json";
+        try {
+            resultjson = redditApiPost(url);
+
+            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
+                JSONArray errors = resultjson.getJSONArray("errors");
+                JSONArray firsterror = (JSONArray) errors.get(0);
+                if (firsterror.get(0).equals("USER_REQUIRED")) {
+                    oauthToken = null; // bearer token invalid, nullify
+                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
+                }
+                return false;
+            } else {
+                return true;
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+    }
+
+    public JSONObject postComment(String parentId, String text) throws RedditApiException {
+
+        checkLogin();
+
+        JSONObject resultjson;
+
+        try {
+            String url = OAUTH_ENDPOINT + "/api/comment?thing_id=" + parentId + "&text=" + URLEncoder.encode(text, "UTF-8") + "&api_type=json";
+
+            resultjson = redditApiPost(url).getJSONObject("json");
+            System.out.println(resultjson.toString());
+            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
+                JSONArray errors = resultjson.getJSONArray("errors");
+                JSONArray firsterror = (JSONArray) errors.get(0);
+                if (firsterror.get(0).equals("USER_REQUIRED")) {
+                    oauthToken = null; // bearer token invalid, nullify
+                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
+                }
+                throw new RedditApiException("API Error: "+firsterror.get(1), true);
+            } else {
+                return resultjson.getJSONObject("data").getJSONArray("things").getJSONObject(0).getJSONObject("data");
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Encoding error: "+e.getMessage());
+        }
+    }
+
+    public JSONObject editComment(String thingId, String text) throws RedditApiException {
+
+        checkLogin();
+
+        JSONObject resultjson;
+
+        try {
+            String url = OAUTH_ENDPOINT + "/api/editusertext?thing_id=" + thingId + "&text=" + URLEncoder.encode(text, "UTF-8") + "&api_type=json";
+
+            resultjson = redditApiPost(url).getJSONObject("json");
+
+            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
+                JSONArray errors = resultjson.getJSONArray("errors");
+                JSONArray firsterror = (JSONArray) errors.get(0);
+                if (firsterror.get(0).equals("USER_REQUIRED")) {
+                    oauthToken = null; // bearer token invalid, nullify
+                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
+                }
+                throw new RedditApiException("API Error: "+firsterror.get(1), true);
+            } else {
+                return resultjson.getJSONObject("data").getJSONArray("things").getJSONObject(0).getJSONObject("data");
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Encoding error: "+e.getMessage());
+        }
+    }
+
+    public boolean deleteComment(String thingId) throws RedditApiException {
+        checkLogin();
+
+        JSONObject resultjson;
+
+        try {
+            String url = OAUTH_ENDPOINT + "/api/del?id=" + thingId;
+
+            resultjson = redditApiPost(url);
+
+            if (resultjson.has("errors") && resultjson.getJSONArray("errors").length()>0) {
+                JSONArray errors = resultjson.getJSONArray("errors");
+                JSONArray firsterror = (JSONArray) errors.get(0);
+                if (firsterror.get(0).equals("USER_REQUIRED")) {
+                    oauthToken = null; // bearer token invalid, nullify
+                    throw new RedditApiException("Authentication Error, Reddit Login Required", true); // creds invalid re-authenticate.
+                }
+                throw new RedditApiException("API Error: "+firsterror.get(1), true);
+            } else {
+                return true;
+            }
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+    }
+
+    public JSONArray getMySubreddits() throws RedditApiException {
+        checkLogin();
+
+        String url = OAUTH_ENDPOINT + "/subreddits/mine/subscriber.json?limit=100&show=all";
+        JSONArray resultjson;
+        try {
+            resultjson = redditApiGet(url, true).getJSONObject("data").getJSONArray("children");
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Parsing error: "+e.getMessage());
+        }
+        return resultjson;
+    }
+
+    public JSONObject subscribe(String subId, boolean subscribe) throws RedditApiException {
+        checkLogin();
+
+        String url = OAUTH_ENDPOINT + "/api/subscribe?sr="+ subId +"&action="+(subscribe?"sub":"unsub");
+
+        return redditApiPost(url);
+    }
+
+    public JSONArray getMyMultis() throws RedditApiException {
+        checkLogin();
+
+        String url = OAUTH_ENDPOINT + "/api/multi/mine";
+
+        return redditApiGetArray(url, true);
+    }
+
+    public JSONObject copyMulti(String name, String fromPath) throws RedditApiException {
+        checkLogin();
+
+        String url;
+        try {
+            url = OAUTH_ENDPOINT + "/api/multi/copy?display_name="+ URLEncoder.encode(name, "UTF-8")+"&from="+fromPath+"&to=/user/"+username+"/m/"+URLEncoder.encode(name.toLowerCase().replaceAll("\\s+", ""), "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Encoding error: "+e.getMessage());
+        }
+
+        return redditApiPost(url);
+    }
+
+    public JSONObject createMulti(String name, JSONObject multiObj) throws RedditApiException {
+        checkLogin();
+
+        String url;
+        try {
+            url = OAUTH_ENDPOINT + "/api/multi/user/"+username+"/m/"+name+"?model="+URLEncoder.encode(multiObj.toString(), "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Encoding error: "+e.getMessage());
+        }
+
+        return redditApiPost(url);
+    }
+
+    public JSONObject editMulti(String multiPath, JSONObject multiObj) throws RedditApiException {
+        checkLogin();
+
+        String url;
+        try {
+            url = OAUTH_ENDPOINT + "/api/multi"+multiPath+"?model="+URLEncoder.encode(multiObj.toString(), "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Encoding error: "+e.getMessage());
+        }
+
+        return redditApiPut(url);
+    }
+
+    public void deleteMulti(String multiPath) throws RedditApiException {
+        checkLogin();
+
+        String url = OAUTH_ENDPOINT + "/api/multi"+multiPath;
+
+        redditApiDelete(url);
+    }
+
+    public JSONObject renameMulti(String multiPath, String newName) throws RedditApiException {
+        checkLogin();
+
+        String url = OAUTH_ENDPOINT + "/api/multi/rename/?from="+multiPath+"&to=/user/"+username+"/m/"+newName;
+
+        return redditApiPost(url);
+    }
+
+    public JSONObject addMultiSubreddit(String multiPath, String subredditName) throws RedditApiException {
+        checkLogin();
+
+        String url;
+        try {
+            url = OAUTH_ENDPOINT + "/api/multi"+multiPath+"/r/"+subredditName+"?srname="+URLEncoder.encode(subredditName, "UTF-8")+"&model="+URLEncoder.encode("{\"name\":\""+subredditName+"\"}", "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Encoding error: "+e.getMessage());
+        }
+
+        return redditApiPut(url);
+    }
+
+    public void removeMultiSubreddit(String multiPath, String subredditName) throws RedditApiException {
+        checkLogin();
+
+        String url;
+        try {
+            url = OAUTH_ENDPOINT + "/api/multi"+multiPath+"/r/"+subredditName+"?srname="+URLEncoder.encode(subredditName, "UTF-8")+"&model="+URLEncoder.encode("{\"name\":\""+subredditName+"\"}", "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Encoding error: "+e.getMessage());
+        }
+
+        redditApiDelete(url);
+    }
+
+    public JSONObject submit(String subreddit, boolean isLink, String title, String content) throws RedditApiException {
+        checkLogin();
+
+        try {
+            content = URLEncoder.encode(content,"UTF-8");
+            String url = OAUTH_ENDPOINT + "/api/submit?api_type=json&extension=json&then=comments&sr=" + URLEncoder.encode(subreddit, "UTF-8") + "&kind=" + (isLink?"link":"self") + "&title=" + URLEncoder.encode(title, "UTF-8") + "&" + (isLink?"url="+content:"text="+content);
+
+            return redditApiPost(url).getJSONObject("json");
+
+        } catch (JSONException | UnsupportedEncodingException e) {
+            throw new RedditApiException(e.getMessage());
+        }
+    }
+
+    // COMM FUNCTIONS
+    // Create Http/s client
+    private boolean createHttpClient() {
+        httpClient = new OkHttpClient();
+        httpClient.setConnectTimeout(10, TimeUnit.SECONDS);
+        httpClient.setReadTimeout(10, TimeUnit.SECONDS);
+        httpClient.networkInterceptors().add(new Interceptor() {
+            @Override
+            public Response intercept(Chain chain) throws IOException {
+                Request originalRequest = chain.request();
+                Request requestWithUserAgent = originalRequest.newBuilder()
+                        .removeHeader("User-Agent")
+                        .addHeader("User-Agent", userAgent)
+                        .build();
+                return chain.proceed(requestWithUserAgent);
+            }
+        });
+
+        return true;
+    }
+
+    private JSONArray redditApiGetArray(String url, boolean useAuth) throws RedditApiException {
+        JSONArray jArr;
+        try {
+            String json = redditApiRequest(url, "GET", useAuth ? REQUEST_MODE_AUTHED : REQUEST_MODE_UNAUTHED, null);
+            jArr = new JSONArray(json);
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Error: "+e.getMessage());
+        }
+        return jArr;
+    }
+
+    private JSONObject redditApiGet(String url, boolean useAuth) throws RedditApiException {
+        JSONObject jObj;
+        try {
+            String json = redditApiRequest(url, "GET", useAuth?REQUEST_MODE_AUTHED:REQUEST_MODE_UNAUTHED, null);
+            jObj = new JSONObject(json);
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Error: "+e.getMessage());
+        }
+        return jObj;
+    }
+
+    private JSONObject redditApiPost(String url) throws RedditApiException {
+        JSONObject jObj;
+        try {
+            String json = redditApiRequest(url, "POST", REQUEST_MODE_AUTHED, null);
+            jObj = new JSONObject(json);
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Error: "+e.getMessage());
+        }
+        return jObj;
+    }
+
+    private JSONObject redditApiPut(String url) throws RedditApiException {
+        JSONObject jObj;
+        try {
+            String json = redditApiRequest(url, "PUT", REQUEST_MODE_AUTHED, null);
+            jObj = new JSONObject(json);
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Error: "+e.getMessage());
+        }
+        return jObj;
+    }
+
+    private void redditApiDelete(String url) throws RedditApiException {
+
+        redditApiRequest(url, "DELETE", REQUEST_MODE_AUTHED, null);
+    }
+
+    private JSONObject redditApiOauthRequest(String url, HashMap<String, String> data) throws RedditApiException {
+        JSONObject jObj;
+        try {
+            String json = redditApiRequest(url, "POST", REQUEST_MODE_OAUTHREQ, data);
+            jObj = new JSONObject(json);
+        } catch (JSONException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Error: "+e.getMessage());
+        }
+        return jObj;
+    }
+
+    private static final int REQUEST_MODE_UNAUTHED = 0;
+    private static final int REQUEST_MODE_AUTHED = 1;
+    private static final int REQUEST_MODE_OAUTHREQ = 2;
+    private static final MediaType POST_ENCODED = MediaType.parse("application/x-www-form-urlencoded; charset=utf-8");
+    private String redditApiRequest(String urlStr, String method, int oauthMode, HashMap<String, String> formData) throws RedditApiException {
+        String json;
+        // create client if null
+        if (httpClient == null) {
+            createHttpClient();
+        }
+        try {
+            Request.Builder httpRequest = new Request.Builder().url(urlStr);
+            RequestBody httpRequestBody;
+            String requestStr = "";
+            if (formData!=null) {
+                FormEncodingBuilder formBuilder = new FormEncodingBuilder();
+                Iterator iterator = formData.keySet().iterator();
+                String key;
+                while (iterator.hasNext()){
+                    key = (String) iterator.next();
+                    formBuilder.add(key, formData.get(key));
+                }
+                httpRequestBody = formBuilder.build();
+            } else {
+                if (!method.equals("GET")) {
+                    int queryIndex = urlStr.indexOf("?");
+                    if (queryIndex!=-1)
+                        urlStr = urlStr.substring(queryIndex);
+                    requestStr = URLEncoder.encode(urlStr, "UTF-8");
+                }
+                httpRequestBody = RequestBody.create(POST_ENCODED, requestStr);
+            }
+
+            switch (method){
+                case "POST":
+                    httpRequest.post(httpRequestBody);
+                    break;
+                case "PUT":
+                    httpRequest.put(httpRequestBody);
+                    break;
+                case "DELETE":
+                    httpRequest.delete(httpRequestBody);
+                    break;
+                case "GET":
+                default:
+                    httpRequest.get();
+                    break;
+            }
+            if (oauthMode==REQUEST_MODE_OAUTHREQ) {
+                // For oauth token retrieval and refresh
+                httpRequest.addHeader("Authorization", "Basic " + Base64.encodeToString((OAUTH_CLIENTID + ":").getBytes(), Base64.URL_SAFE | Base64.NO_WRAP));
+            } else if (isLoggedIn() && oauthMode==REQUEST_MODE_AUTHED) {
+                if (isTokenExpired()) {
+                    refreshToken();
+                }
+                // add auth headers
+                String tokenStr = getTokenValue("token_type") + " " + getTokenValue("access_token");
+                httpRequest.addHeader("Authorization", tokenStr);
+            }
+
+            Response response = httpClient.newCall(httpRequest.build()).execute();
+            json = response.body().string();
+            int errorCode = response.code();
+            if (errorCode<200 && errorCode>202) {
+                String errorMsg = getErrorText(json);
+                throw new RedditApiException("Error "+String.valueOf(errorCode)+": "+(errorMsg.equals("")?response.message():errorMsg)+(errorCode==403?" (Authorization with Reddit required)":""), errorCode==403, errorCode);
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new RedditApiException("Error: "+e.getMessage());
+        }
+
+        return json;
+    }
+
+    private String getErrorText(String response){
+        String errorMsg = "";
+        if (response!=null) {
+            if (response.indexOf("{")==0)
+            try {
+                JSONObject errorJson = new JSONObject(response);
+                if (errorJson.has("errors")) {
+                    JSONArray errorArr = errorJson.getJSONArray("errors");
+                    if (errorArr.length()>0)
+                        errorArr.getJSONArray(0).getString(1);
+                }
+                return errorMsg;
+            } catch (JSONException e) {
+                e.printStackTrace();
+            }
+            // attempt to get html error message (often returned by 403)
+            /*System.err.println(response);
+            final Pattern patternh2 = Pattern.compile("<h2>(.+?)</h2>");
+            final Pattern patternh3 = Pattern.compile("<h3>(.+?)</h3>");
+            Matcher matcher = patternh2.matcher(response);
+            if (matcher.matches()) {
+                errorMsg = matcher.group(1);
+                matcher = patternh3.matcher(response);
+                if (matcher.group(1)!=null && !matcher.group(1).equals(""))
+                    errorMsg += ", " + matcher.group(1);
+            }*/
+        }
+        return errorMsg;
+    }
+
+    private void checkLogin() throws RedditApiException {
+        if (!isLoggedIn()) {
+            throw new RedditApiException("Reddit Login Required", true);
+        }
+    }
+
+    public class RedditApiException extends Exception {
+        private boolean isLoginError = false;
+        private int httpErrorCode = 200;
+        //Constructor that accepts a message
+        public RedditApiException(String message) {
+            super(message);
+        }
+
+        public RedditApiException(String message, boolean isLoginError) {
+            super(message);
+            this.isLoginError = isLoginError;
+        }
+
+        public RedditApiException(String message, boolean isLoginError, int httpErrorCode) {
+            super(message);
+            this.isLoginError = isLoginError;
+            this.httpErrorCode = httpErrorCode;
+        }
+
+        public int getHttpErrorCode() { return httpErrorCode; }
+
+        public boolean isAuthError(){
+            return isLoginError;
+        }
+    }
+
+    // OAUTH FUNCTIONS
+    public boolean isLoggedIn() {
+        return oauthToken != null;
+    }
+
+    private boolean isTokenExpired() {
+        Long now = (System.currentTimeMillis() / 1000L);
+        Long expiry = (long) 0;
+        try {
+            expiry = oauthToken.getLong("expires_at");
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+        return expiry < now;
+    }
+
+    private String getTokenValue(String key) {
+        String token = "";
+        try {
+            token = oauthToken.getString(key);
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+        return token;
+    }
+
+    public void retrieveToken(String code, String state) throws RedditApiException {
+        if (!state.equals(oauthstate)) {
+            throw new RedditApiException("OAuth Error: Invalid state");
+        }
+        String url = "https://www.reddit.com/api/v1/access_token";
+        JSONObject resultjson;
+        HashMap<String, String> params = new HashMap<>();
+        params.put("grant_type", "authorization_code");
+        params.put("code", code);
+        params.put("redirect_uri", OAUTH_REDIRECT);
+        resultjson = redditApiOauthRequest(url, params);
+        if (resultjson.has("access_token")) {
+            // login successful, set new token and save
+            oauthToken = resultjson;
+            try {
+                Long epoch = (System.currentTimeMillis() / 1000L);
+                Long expires_at = epoch + Integer.parseInt(oauthToken.getString("expires_in"));
+                oauthToken.put("expires_at", expires_at);
+            } catch (JSONException e) {
+                e.printStackTrace();
+                throw new RedditApiException("OAuth Error: "+e.getMessage());
+            }
+            // try to retrieve user info & save, if exception thrown, just make sure we save token
+            try {
+                updateUserInfo();
+            } catch (RedditApiException e) {
+                e.printStackTrace();
+                saveUserData();
+            }
+            //System.out.println("oauth request result: OK");
+            return;
+        }
+        // throw error
+        throwOAuthError(resultjson);
+    }
+
+    private void refreshToken() throws RedditApiException {
+        String url = "https://www.reddit.com/api/v1/access_token";
+        JSONObject resultjson;
+        HashMap<String, String> params = new HashMap<>();
+        params.put("grant_type", "refresh_token");
+        params.put("refresh_token", getTokenValue("refresh_token"));
+        resultjson = redditApiOauthRequest(url, params);
+        if (resultjson.has("access_token")) {
+            // login successful, update token and save
+            try {
+                oauthToken.put("access_token", resultjson.get("access_token"));
+                oauthToken.put("token_type", resultjson.get("token_type"));
+                Long expires_in = resultjson.getLong("expires_in") - 30;
+                Long epoch = (System.currentTimeMillis() / 1000L);
+                oauthToken.put("expires_in", expires_in);
+                oauthToken.put("expires_at", (epoch + expires_in));
+            } catch (JSONException e) {
+                e.printStackTrace();
+                throw new RedditApiException("OAuth Error: "+e.getMessage());
+            }
+            // save oauth token
+            saveUserData();
+            //System.out.println("oauth refresh result: OK");
+            return;
+        }
+        // set error result
+        throwOAuthError(resultjson);
+    }
+
+    private void throwOAuthError(JSONObject resultjson) throws RedditApiException {
+        String error;
+        if (resultjson.has("error")){
+            try {
+                error = resultjson.getString("error");
+            } catch (JSONException e) {
+                e.printStackTrace();
+                error = "Unknown Error D-:";
+            }
+        } else {
+            error = "Unknown Error D-:";
+        }
+        throw new RedditApiException("OAuth Error: "+error);
+    }
+
+    public void saveUserData() {
+        SharedPreferences.Editor edit = sharedPrefs.edit();
+        edit.putString("oauthtoken", oauthToken == null ? "" : oauthToken.toString());
+        edit.putString("username", username);
+        edit.putInt("inbox_count", inboxCount);
+        edit.putLong("last_info_update", lastUpdateTime);
+        edit.apply();
+    }
+
+}
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubredditManager.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/core/SubredditManager.java
similarity index 99%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/SubredditManager.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/core/SubredditManager.java
index 2861f8a..42bd72c 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubredditManager.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/core/SubredditManager.java
@@ -19,7 +19,7 @@
  *
  * Subreddit Manager Provides a global interface for modifying the user subreddit & multi lists.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.core;
 
 import android.content.SharedPreferences;
 
@@ -123,7 +123,7 @@ public class SubredditManager {
 
     public JSONArray filterFeed(JSONArray feedArray){
         String allFilter = prefs.getString("allFilter", "");
-        if (allFilter==null || allFilter.equals(""))
+        if (allFilter.equals(""))
             return feedArray; // no filters applied
 
         JSONArray filtered = new JSONArray();
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/ThemeManager.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/core/ThemeManager.java
similarity index 97%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/ThemeManager.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/core/ThemeManager.java
index a6f23ff..a13c187 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/ThemeManager.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/core/ThemeManager.java
@@ -18,7 +18,7 @@
  * Created by michael on 2/05/15.
  */
 
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.core;
 
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -42,9 +42,9 @@ public class ThemeManager {
     private JSONObject themes;
     private JSONArray themeOrder;
     private JSONObject customThemes;
-    static final int LISTMODE_ALL= 0;
-    static final int LISTMODE_CUSTOM= 1;
-    static final int LISTMODE_DEFAULT= 2;
+    public static final int LISTMODE_ALL= 0;
+    public static final int LISTMODE_CUSTOM= 1;
+    public static final int LISTMODE_DEFAULT= 2;
     private Theme defaultValues;
 
     public ThemeManager(Context context, SharedPreferences preferences){
@@ -140,7 +140,7 @@ public class ThemeManager {
 
         String themeKey = prefs.getString(themePrefKey, "app_select");
 
-        boolean appSelect = themeKey==null || themeKey.equals("app_select");
+        boolean appSelect = themeKey.equals("app_select");
         if (appSelect || (!themes.has(themeKey) && !customThemes.has(themeKey)))
             return getTheme(prefs.getString("appthemepref", "reddit_classic"));
 
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/BootReceiver.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/BootReceiver.java
similarity index 96%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/BootReceiver.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/service/BootReceiver.java
index aa4a038..27bc812 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/BootReceiver.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/BootReceiver.java
@@ -16,7 +16,7 @@
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
 
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.service;
 
 import android.appwidget.AppWidgetManager;
 import android.content.BroadcastReceiver;
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/MailCheckReceiver.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/MailCheckReceiver.java
similarity index 94%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/MailCheckReceiver.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/service/MailCheckReceiver.java
index a6e55ea..ce74989 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/MailCheckReceiver.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/MailCheckReceiver.java
@@ -16,7 +16,7 @@
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
 
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.service;
 
 import android.app.AlarmManager;
 import android.app.PendingIntent;
@@ -27,6 +27,8 @@ import android.content.SharedPreferences;
 import android.net.Uri;
 import android.preference.PreferenceManager;
 
+import au.com.wallaceit.reddinator.R;
+
 public class MailCheckReceiver extends BroadcastReceiver {
 
     public static String CHECK_ACTION = "reddinator.background.mailcheck";
@@ -43,7 +45,7 @@ public class MailCheckReceiver extends BroadcastReceiver {
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
         int refreshRate = Integer.valueOf(prefs.getString(context.getString(R.string.background_mail_pref), "43200000"));
         String token = prefs.getString("oauthtoken", "");
-        boolean loggedIn = (token!=null && !token.equals(""));
+        boolean loggedIn = (!token.equals(""));
         if (refreshRate == 0 || !loggedIn) {
             alarmManager.cancel(updateIntent); // cancel if disabled or not logged in
         } else {
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/MailCheckService.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/MailCheckService.java
similarity index 92%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/MailCheckService.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/service/MailCheckService.java
index 4e2f602..250cb36 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/MailCheckService.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/MailCheckService.java
@@ -16,7 +16,7 @@
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
 
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.service;
 
 import android.app.Notification;
 import android.app.NotificationManager;
@@ -29,11 +29,16 @@ import android.os.AsyncTask;
 import android.os.IBinder;
 import android.support.v4.app.NotificationCompat;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.activity.WebViewActivity;
+import au.com.wallaceit.reddinator.core.RedditData;
+
 public class MailCheckService extends Service {
     public static String MAIL_CHECK_COMPLETE = "reddinator.mail.check.complete";
     public static String ACTIVITY_CHECK_ACTION = "reddinator.mail.check";
     public static String NOTIFY_CHECK_ACTION = "reddinator.mail.check.notify";
-    private GlobalObjects global;
+    private Reddinator global;
     private String action;
 
     public static void checkMail(Context context, String action){
@@ -44,7 +49,7 @@ public class MailCheckService extends Service {
 
     @Override
     public void onCreate(){
-        global = ((GlobalObjects) getApplicationContext());
+        global = ((Reddinator) getApplicationContext());
     }
 
     @Override
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/WidgetProvider.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/WidgetProvider.java
similarity index 92%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/WidgetProvider.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/service/WidgetProvider.java
index 0d13574..a096928 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/WidgetProvider.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/WidgetProvider.java
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.service;
 
 import android.annotation.TargetApi;
 import android.app.AlarmManager;
@@ -39,6 +39,12 @@ import com.joanzapata.android.iconify.Iconify;
 
 import java.util.HashMap;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.activity.PrefsActivity;
+import au.com.wallaceit.reddinator.activity.SubredditSelectActivity;
+import au.com.wallaceit.reddinator.activity.ViewRedditActivity;
+
 @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
 public class WidgetProvider extends AppWidgetProvider {
     public static String ITEM_URL = "ITEM_URL";
@@ -60,7 +66,7 @@ public class WidgetProvider extends AppWidgetProvider {
 
     @SuppressWarnings("deprecation")
     public static void updateAppWidgets(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds, boolean scrolltotop) {
-        GlobalObjects global = (GlobalObjects) context.getApplicationContext();
+        Reddinator global = (Reddinator) context.getApplicationContext();
         // Perform this loop procedure for each App Widget that belongs to this provider
         for (int appWidgetId : appWidgetIds) {
             // CONFIG BUTTON
@@ -117,10 +123,10 @@ public class WidgetProvider extends AppWidgetProvider {
 
             int iconColor = themeColors.get("default_icon");
             int[] shadow = new int[]{3, 3, 3, themeColors.get("icon_shadow")};
-            views.setImageViewBitmap(R.id.prefsbutton, GlobalObjects.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_wrench.character()), iconColor, 28, shadow));
-            views.setImageViewBitmap(R.id.refreshbutton, GlobalObjects.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_refresh.character()), iconColor, 28, shadow));
-            views.setImageViewBitmap(R.id.srcaret, GlobalObjects.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_caret_down.character()), iconColor, 16, shadow));
-            views.setImageViewBitmap(R.id.erroricon, GlobalObjects.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_exclamation_triangle.character()), Color.parseColor("#E06B6C"), 28, shadow));
+            views.setImageViewBitmap(R.id.prefsbutton, Reddinator.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_wrench.character()), iconColor, 28, shadow));
+            views.setImageViewBitmap(R.id.refreshbutton, Reddinator.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_refresh.character()), iconColor, 28, shadow));
+            views.setImageViewBitmap(R.id.srcaret, Reddinator.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_caret_down.character()), iconColor, 16, shadow));
+            views.setImageViewBitmap(R.id.erroricon, Reddinator.getFontBitmap(context, String.valueOf(Iconify.IconValue.fa_exclamation_triangle.character()), Color.parseColor("#E06B6C"), 28, shadow));
             // views.setViewVisibility(R.id.srloader, View.VISIBLE); // loader is hidden by default (to stop it displaying on screen rotation) so we need to show it when updating.
             // set current feed title
             String curFeed = global.getSubredditManager().getCurrentFeedName(appWidgetId);
@@ -281,14 +287,14 @@ public class WidgetProvider extends AppWidgetProvider {
 
     private void setLoadMore(Context context) {
         // set the loadmore indicator in global object, we also set bypass cache in case a new remoteviewsfactory is created
-        GlobalObjects global = ((GlobalObjects) context.getApplicationContext());
+        Reddinator global = ((Reddinator) context.getApplicationContext());
         global.setBypassCache(true);
         global.setLoadMore();
     }
 
     private void setNoCache(Context context) {
         // the bypass cache indicator is used when the last remoteviewfactory has been terminated. A new one is created so we need to tell it not to load the cached data
-        GlobalObjects global = ((GlobalObjects) context.getApplicationContext());
+        Reddinator global = ((Reddinator) context.getApplicationContext());
         global.setBypassCache(true);
     }
 }
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/WidgetService.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/WidgetService.java
similarity index 94%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/WidgetService.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/service/WidgetService.java
index ed7768a..94cc3e5 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/WidgetService.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/service/WidgetService.java
@@ -15,7 +15,7 @@
  * You should have received a copy of the GNU General Public License
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.service;
 
 import android.appwidget.AppWidgetManager;
 import android.content.Context;
@@ -47,6 +47,10 @@ import java.net.URL;
 import java.net.URLConnection;
 import java.util.HashMap;
 
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.core.RedditData;
+
 public class WidgetService extends RemoteViewsService {
     @Override
     public RemoteViewsFactory onGetViewFactory(Intent intent) {
@@ -58,7 +62,7 @@ class ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
     private Context mContext = null;
     private int appWidgetId;
     private JSONArray data;
-    private GlobalObjects global;
+    private Reddinator global;
     private SharedPreferences mSharedPreferences;
     private String titleFontSize = "16";
     private HashMap<String, Integer> themeColors;
@@ -72,7 +76,7 @@ class ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
     public ListRemoteViewsFactory(Context context, Intent intent) {
         this.mContext = context;
         appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, AppWidgetManager.INVALID_APPWIDGET_ID);
-        global = ((GlobalObjects) context.getApplicationContext());
+        global = ((Reddinator) context.getApplicationContext());
         mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
         //System.out.println("New view factory created for widget ID:"+appWidgetId);
         // Set thread network policy to prevent network on main thread exceptions.
@@ -81,7 +85,7 @@ class ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
         // if this is a user request (apart from 'loadmore') or an auto update, do not attempt to load cache.
         // when a user clicks load more and a new view factory needs to be created we don't want to bypass cache, we want to load the cached items
         int loadType = global.getLoadType();
-        if (!global.getBypassCache() || loadType == GlobalObjects.LOADTYPE_LOADMORE) {
+        if (!global.getBypassCache() || loadType == Reddinator.LOADTYPE_LOADMORE) {
             // load cached data
             data = global.getFeed(mSharedPreferences, appWidgetId);
             if (data.length() != 0) {
@@ -92,7 +96,7 @@ class ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
                     lastItemId = "0"; // Could not get last item ID; perform a reload next time and show error view :(
                     e.printStackTrace();
                 }
-                if (loadType == GlobalObjects.LOADTYPE_LOAD) {
+                if (loadType == Reddinator.LOADTYPE_LOAD) {
                     loadCached = true; // this isn't a loadmore request, the cache is loaded and we're done
                     //System.out.println("Cache loaded, no user request received.");
                 }
@@ -119,8 +123,8 @@ class ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
         //int iconColor = Color.parseColor(themeColors[6]);
         int[] shadow = new int[]{3, 4, 4, themeColors.get("icon_shadow")};
         images = new Bitmap[]{
-                GlobalObjects.getFontBitmap(mContext, String.valueOf(Iconify.IconValue.fa_star.character()), themeColors.get("votes_icon"), 12, shadow),
-                GlobalObjects.getFontBitmap(mContext, String.valueOf(Iconify.IconValue.fa_comment.character()), themeColors.get("comments_icon"), 12, shadow)
+                Reddinator.getFontBitmap(mContext, String.valueOf(Iconify.IconValue.fa_star.character()), themeColors.get("votes_icon"), 12, shadow),
+                Reddinator.getFontBitmap(mContext, String.valueOf(Iconify.IconValue.fa_comment.character()), themeColors.get("comments_icon"), 12, shadow)
         };
         titleFontSize = mSharedPreferences.getString("titlefontpref", "16");
 
@@ -356,12 +360,12 @@ class ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {
 
         int loadType = global.getLoadType();
         if (!loadCached) {
-            loadCached = (loadType == GlobalObjects.LOADTYPE_REFRESH_VIEW); // see if its just a call to refresh view and set var accordingly but only check it if load cached is not already set true in the above constructor
+            loadCached = (loadType == Reddinator.LOADTYPE_REFRESH_VIEW); // see if its just a call to refresh view and set var accordingly but only check it if load cached is not already set true in the above constructor
         }
         //System.out.println("Loading type "+loadtype);
         if (!loadCached) {
             // refresh data
-            if (loadType == GlobalObjects.LOADTYPE_LOADMORE && !lastItemId.equals("0")) { // do not attempt a "loadmore" if we don't have a valid item ID; this would append items to the list, instead perform a full reload
+            if (loadType == Reddinator.LOADTYPE_LOADMORE && !lastItemId.equals("0")) { // do not attempt a "loadmore" if we don't have a valid item ID; this would append items to the list, instead perform a full reload
                 global.setLoad();
                 loadMoreReddits();
             } else {
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/SimpleTabsAdapter.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SimpleTabsAdapter.java
similarity index 95%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/SimpleTabsAdapter.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SimpleTabsAdapter.java
index ebf5a2d..84fde22 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/SimpleTabsAdapter.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SimpleTabsAdapter.java
@@ -17,7 +17,7 @@
  *
  * Created by michael on 14/05/15.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.ui;
 
 import android.app.Activity;
 import android.content.Context;
@@ -25,7 +25,7 @@ import android.support.v4.view.PagerAdapter;
 import android.view.View;
 import android.view.ViewGroup;
 
-class SimpleTabsAdapter extends PagerAdapter {
+public class SimpleTabsAdapter extends PagerAdapter {
 
     private View layout = null;
     private String[] labels;
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/SimpleTabsWidget.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SimpleTabsWidget.java
similarity index 98%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/SimpleTabsWidget.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SimpleTabsWidget.java
index 58d05f8..6db0106 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/SimpleTabsWidget.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SimpleTabsWidget.java
@@ -17,7 +17,7 @@
  *
  * Created by michael on 12/05/15.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.ui;
 
 import android.content.Context;
 import android.graphics.Color;
@@ -31,6 +31,8 @@ import android.widget.TextView;
 
 import java.util.ArrayList;
 
+import au.com.wallaceit.reddinator.R;
+
 public class SimpleTabsWidget {
     LayoutInflater inflater;
     LinearLayout tabWidget;
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubAutoCompleteAdapter.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SubAutoCompleteAdapter.java
similarity index 90%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/SubAutoCompleteAdapter.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SubAutoCompleteAdapter.java
index 39afb08..f425656 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/SubAutoCompleteAdapter.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/SubAutoCompleteAdapter.java
@@ -17,7 +17,7 @@
  *
  * Created by michael on 14/05/15.
  */
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.ui;
 
 import android.content.Context;
 import android.widget.ArrayAdapter;
@@ -28,13 +28,16 @@ import android.widget.Toast;
 import org.json.JSONArray;
 import org.json.JSONException;
 
-class SubAutoCompleteAdapter extends ArrayAdapter<String> implements Filterable {
-    GlobalObjects global;
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.core.RedditData;
+
+public class SubAutoCompleteAdapter extends ArrayAdapter<String> implements Filterable {
+    Reddinator global;
     JSONArray suggestions = new JSONArray();
 
     public SubAutoCompleteAdapter(Context context, int resource) {
         super(context, resource);
-        global = (GlobalObjects) context.getApplicationContext();
+        global = (Reddinator) context.getApplicationContext();
     }
 
     @Override
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/TabCommentsFragment.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/TabCommentsFragment.java
similarity index 97%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/TabCommentsFragment.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/ui/TabCommentsFragment.java
index 7c7f0ac..8fdd826 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/TabCommentsFragment.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/TabCommentsFragment.java
@@ -16,7 +16,7 @@
  * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
  */
 
-package au.com.wallaceit.reddinator;
+package au.com.wallaceit.reddinator.ui;
 
 import android.annotation.SuppressLint;
 import android.content.Context;
@@ -43,12 +43,18 @@ import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import au.com.wallaceit.reddinator.Reddinator;
+import au.com.wallaceit.reddinator.activity.ViewRedditActivity;
+import au.com.wallaceit.reddinator.activity.WebViewActivity;
+import au.com.wallaceit.reddinator.core.RedditData;
+import au.com.wallaceit.reddinator.service.WidgetProvider;
+
 public class TabCommentsFragment extends Fragment {
     private Context mContext;
     public WebView mWebView;
     private boolean mFirstTime = true;
     private LinearLayout ll;
-    private GlobalObjects global;
+    private Reddinator global;
     public String articleId;
     public String permalink;
     private String currentSort = "best";
@@ -56,7 +62,7 @@ public class TabCommentsFragment extends Fragment {
     CommentsVoteTask commentsVoteTask;
     CommentTask commentTask;
 
-    static TabCommentsFragment init(boolean load) {
+    public static TabCommentsFragment init(boolean load) {
         TabCommentsFragment commentsTab = new TabCommentsFragment();
         Bundle args = new Bundle();
         args.putBoolean("load", load);
@@ -83,7 +89,7 @@ public class TabCommentsFragment extends Fragment {
         super.onCreate(savedInstanceState);
         mContext = this.getActivity();
         SharedPreferences mSharedPreferences = PreferenceManager.getDefaultSharedPreferences(mContext);
-        global = (GlobalObjects) mContext.getApplicationContext();
+        global = (Reddinator) mContext.getApplicationContext();
         final boolean load = getArguments().getBoolean("load");
 
         // get needed activity values
diff --git a/reddinator/src/main/java/au/com/wallaceit/reddinator/TabWebFragment.java b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/TabWebFragment.java
similarity index 96%
rename from reddinator/src/main/java/au/com/wallaceit/reddinator/TabWebFragment.java
rename to reddinator/src/main/java/au/com/wallaceit/reddinator/ui/TabWebFragment.java
index 3829256..2b2aad1 100644
--- a/reddinator/src/main/java/au/com/wallaceit/reddinator/TabWebFragment.java
+++ b/reddinator/src/main/java/au/com/wallaceit/reddinator/ui/TabWebFragment.java
@@ -1,216 +1,218 @@
-/*
- * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
- * This file is part of Reddinator.
- *
- * Reddinator is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * Reddinator is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
- */
-package au.com.wallaceit.reddinator;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.ActionBar;
-import android.app.Activity;
-import android.content.Context;
-import android.os.Build;
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.Window;
-import android.view.WindowManager;
-import android.webkit.CookieManager;
-import android.webkit.WebChromeClient;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-import android.widget.FrameLayout;
-import android.widget.LinearLayout;
-
-public class TabWebFragment extends Fragment {
-    /**
-     * (non-Javadoc)
-     *
-     * @see android.support.v4.app.Fragment#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)
-     */
-    private Context mContext;
-    public WebView mWebView;
-    private boolean mFirstTime = true;
-    private LinearLayout ll;
-    //private Bundle WVState;
-    public View mFullSView;
-    private LinearLayout mTabcontainer;
-    private FrameLayout mVideoFrame;
-    private WebChromeClient.CustomViewCallback mFullSCallback;
-    public WebChromeClient mChromeClient;
-    private Activity mActivity;
-    private String url;
-
-    static TabWebFragment init(String url, int fontsize, boolean load) {
-        TabWebFragment webTab = new TabWebFragment();
-        // Supply val input as an argument.
-        Bundle args = new Bundle();
-        args.putString("url", url);
-        args.putInt("fontsize", fontsize);
-        args.putBoolean("load", load);
-        webTab.setArguments(args);
-        return webTab;
-    }
-
-    @Override
-    public void onActivityCreated(Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-        //mWebView.restoreState(savedInstanceState);
-    }
-
-    boolean loaded = false;
-    public void load(){
-        if (!loaded) {
-            mWebView.loadUrl(url);
-            loaded = true;
-        }
-    }
-
-
-    @SuppressLint("SetJavaScriptEnabled")
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        mContext = this.getActivity();
-        if (container == null) {
-            return null;
-        }
-        if (mFirstTime) {
-            final boolean load = getArguments().getBoolean("load");
-            int fontsize = getArguments().getInt("fontsize");
-            url = getArguments().getString("url");
-            // setup progressbar
-            mActivity = this.getActivity();
-            mActivity.getWindow().setFeatureInt(Window.FEATURE_PROGRESS, Window.PROGRESS_VISIBILITY_ON);
-            ll = (LinearLayout) inflater.inflate(R.layout.webtab, container, false);
-            mWebView = (WebView) ll.findViewById(R.id.webView1);
-            // fixes for webview not taking keyboard input on some devices
-            mWebView.getSettings().setLoadWithOverviewMode(true);
-            mWebView.getSettings().setUseWideViewPort(true);
-            mWebView.getSettings().setJavaScriptEnabled(true); // enable ecmascript
-            mWebView.getSettings().setDomStorageEnabled(true); // some video sites require dom storage
-            mWebView.getSettings().setSupportZoom(true);
-            mWebView.getSettings().setBuiltInZoomControls(true);
-            mWebView.getSettings().setDisplayZoomControls(false);
-            mWebView.getSettings().setDefaultFontSize(fontsize);
-            // enable cookies
-            CookieManager.getInstance().setAcceptCookie(true);
-            mChromeClient = newchromeclient;
-
-            mWebView.setWebChromeClient(mChromeClient);
-            mWebView.setWebViewClient(new WebViewClient() {
-                boolean clearhistory = true;
-
-                @Override
-                public void onPageFinished(WebView view, String url) {
-                    if (clearhistory) {
-                        clearhistory = false;
-                        mWebView.clearHistory();
-                    }
-                    super.onPageFinished(view, url);
-                }
-            });
-            if (load) load();
-            mFirstTime = false;
-            //System.out.println("Created fragment");
-        } else {
-            ((ViewGroup) ll.getParent()).removeView(ll);
-        }
-
-        return ll;
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        //mWebView.saveState(outState);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        //mWebView.saveState(WVState);
-    }
-
-    // web chrome client
-    WebChromeClient newchromeclient = new WebChromeClient() {
-        ActionBar actionBar;
-        public void onProgressChanged(WebView view, int progress) {
-            boolean voteinprogress = ((ViewRedditActivity) mActivity).voteInProgress();
-            //Make the bar disappear after URL is loaded, and changes string to Loading...
-            if (!voteinprogress) mActivity.setTitle("Loading..."); // supress if vote in progress
-            mActivity.setProgress(progress * 100); //Make the bar disappear after URL is loaded
-            // Return the app name after finish loading
-            if (progress == 100) {
-                if (!voteinprogress)
-                    mActivity.setTitle(R.string.app_name); // dont reset title if vote in prog. voting function will do that.
-            }
-            actionBar = mActivity.getActionBar();
-        }
-
-        FrameLayout.LayoutParams LayoutParameters = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);
-
-        @TargetApi(Build.VERSION_CODES.KITKAT)
-        @Override
-        public void onShowCustomView(View view, CustomViewCallback callback) {
-            // if a view already exists then immediately terminate the new one
-            if (mFullSView != null) {
-                callback.onCustomViewHidden();
-                return;
-            }
-            // get main view and hide
-            mTabcontainer = (LinearLayout) ((Activity) mContext).findViewById(R.id.redditview);
-            mTabcontainer.setVisibility(View.GONE);
-            // create custom view to show
-            mVideoFrame = new FrameLayout(mContext);
-            mVideoFrame.setLayoutParams(LayoutParameters);
-            mVideoFrame.setBackgroundResource(android.R.color.black);
-            mVideoFrame.addView(view);
-            mVideoFrame.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar
-                    | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar
-                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
-            view.setLayoutParams(LayoutParameters);
-            mFullSView = view;
-            mFullSCallback = callback;
-            actionBar.hide();
-            ((Activity) mContext).getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-            mVideoFrame.setVisibility(View.VISIBLE);
-
-            ((Activity) mContext).setContentView(mVideoFrame);
-        }
-
-        @Override
-        public void onHideCustomView() {
-            if (mFullSView != null) {
-                // Hide the custom view.
-                mFullSView.setVisibility(View.GONE);
-                // Remove the custom view from its container.  
-                mVideoFrame.removeView(mFullSView);
-                mFullSView = null;
-                mVideoFrame.setVisibility(View.GONE);
-                mFullSCallback.onCustomViewHidden();
-                // remove fullscreen
-                actionBar.show();
-                ((Activity) mContext).getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
-                mTabcontainer.setVisibility(View.VISIBLE);
-                ((Activity) mContext).setContentView(mTabcontainer);
-            }
-        }
-    };
-}
+/*
+ * Copyright 2013 Michael Boyde Wallace (http://wallaceit.com.au)
+ * This file is part of Reddinator.
+ *
+ * Reddinator is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Reddinator is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Reddinator (COPYING). If not, see <http://www.gnu.org/licenses/>.
+ */
+package au.com.wallaceit.reddinator.ui;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.ActionBar;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.Window;
+import android.view.WindowManager;
+import android.webkit.CookieManager;
+import android.webkit.WebChromeClient;
+import android.webkit.WebView;
+import android.webkit.WebViewClient;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+
+import au.com.wallaceit.reddinator.R;
+import au.com.wallaceit.reddinator.activity.ViewRedditActivity;
+
+public class TabWebFragment extends Fragment {
+    /**
+     * (non-Javadoc)
+     *
+     * @see android.support.v4.app.Fragment#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)
+     */
+    private Context mContext;
+    public WebView mWebView;
+    private boolean mFirstTime = true;
+    private LinearLayout ll;
+    //private Bundle WVState;
+    public View mFullSView;
+    private LinearLayout mTabcontainer;
+    private FrameLayout mVideoFrame;
+    private WebChromeClient.CustomViewCallback mFullSCallback;
+    public WebChromeClient mChromeClient;
+    private Activity mActivity;
+    private String url;
+
+    public static TabWebFragment init(String url, int fontsize, boolean load) {
+        TabWebFragment webTab = new TabWebFragment();
+        // Supply val input as an argument.
+        Bundle args = new Bundle();
+        args.putString("url", url);
+        args.putInt("fontsize", fontsize);
+        args.putBoolean("load", load);
+        webTab.setArguments(args);
+        return webTab;
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+        //mWebView.restoreState(savedInstanceState);
+    }
+
+    boolean loaded = false;
+    public void load(){
+        if (!loaded) {
+            mWebView.loadUrl(url);
+            loaded = true;
+        }
+    }
+
+
+    @SuppressLint("SetJavaScriptEnabled")
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        mContext = this.getActivity();
+        if (container == null) {
+            return null;
+        }
+        if (mFirstTime) {
+            final boolean load = getArguments().getBoolean("load");
+            int fontsize = getArguments().getInt("fontsize");
+            url = getArguments().getString("url");
+            // setup progressbar
+            mActivity = this.getActivity();
+            mActivity.getWindow().setFeatureInt(Window.FEATURE_PROGRESS, Window.PROGRESS_VISIBILITY_ON);
+            ll = (LinearLayout) inflater.inflate(R.layout.webtab, container, false);
+            mWebView = (WebView) ll.findViewById(R.id.webView1);
+            // fixes for webview not taking keyboard input on some devices
+            mWebView.getSettings().setLoadWithOverviewMode(true);
+            mWebView.getSettings().setUseWideViewPort(true);
+            mWebView.getSettings().setJavaScriptEnabled(true); // enable ecmascript
+            mWebView.getSettings().setDomStorageEnabled(true); // some video sites require dom storage
+            mWebView.getSettings().setSupportZoom(true);
+            mWebView.getSettings().setBuiltInZoomControls(true);
+            mWebView.getSettings().setDisplayZoomControls(false);
+            mWebView.getSettings().setDefaultFontSize(fontsize);
+            // enable cookies
+            CookieManager.getInstance().setAcceptCookie(true);
+            mChromeClient = newchromeclient;
+
+            mWebView.setWebChromeClient(mChromeClient);
+            mWebView.setWebViewClient(new WebViewClient() {
+                boolean clearhistory = true;
+
+                @Override
+                public void onPageFinished(WebView view, String url) {
+                    if (clearhistory) {
+                        clearhistory = false;
+                        mWebView.clearHistory();
+                    }
+                    super.onPageFinished(view, url);
+                }
+            });
+            if (load) load();
+            mFirstTime = false;
+            //System.out.println("Created fragment");
+        } else {
+            ((ViewGroup) ll.getParent()).removeView(ll);
+        }
+
+        return ll;
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        //mWebView.saveState(outState);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        //mWebView.saveState(WVState);
+    }
+
+    // web chrome client
+    WebChromeClient newchromeclient = new WebChromeClient() {
+        ActionBar actionBar;
+        public void onProgressChanged(WebView view, int progress) {
+            boolean voteinprogress = ((ViewRedditActivity) mActivity).voteInProgress();
+            //Make the bar disappear after URL is loaded, and changes string to Loading...
+            if (!voteinprogress) mActivity.setTitle("Loading..."); // supress if vote in progress
+            mActivity.setProgress(progress * 100); //Make the bar disappear after URL is loaded
+            // Return the app name after finish loading
+            if (progress == 100) {
+                if (!voteinprogress)
+                    mActivity.setTitle(R.string.app_name); // dont reset title if vote in prog. voting function will do that.
+            }
+            actionBar = mActivity.getActionBar();
+        }
+
+        FrameLayout.LayoutParams LayoutParameters = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT);
+
+        @TargetApi(Build.VERSION_CODES.KITKAT)
+        @Override
+        public void onShowCustomView(View view, CustomViewCallback callback) {
+            // if a view already exists then immediately terminate the new one
+            if (mFullSView != null) {
+                callback.onCustomViewHidden();
+                return;
+            }
+            // get main view and hide
+            mTabcontainer = (LinearLayout) ((Activity) mContext).findViewById(R.id.redditview);
+            mTabcontainer.setVisibility(View.GONE);
+            // create custom view to show
+            mVideoFrame = new FrameLayout(mContext);
+            mVideoFrame.setLayoutParams(LayoutParameters);
+            mVideoFrame.setBackgroundResource(android.R.color.black);
+            mVideoFrame.addView(view);
+            mVideoFrame.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION // hide nav bar
+                    | View.SYSTEM_UI_FLAG_FULLSCREEN // hide status bar
+                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
+            view.setLayoutParams(LayoutParameters);
+            mFullSView = view;
+            mFullSCallback = callback;
+            actionBar.hide();
+            ((Activity) mContext).getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+            mVideoFrame.setVisibility(View.VISIBLE);
+
+            ((Activity) mContext).setContentView(mVideoFrame);
+        }
+
+        @Override
+        public void onHideCustomView() {
+            if (mFullSView != null) {
+                // Hide the custom view.
+                mFullSView.setVisibility(View.GONE);
+                // Remove the custom view from its container.  
+                mVideoFrame.removeView(mFullSView);
+                mFullSView = null;
+                mVideoFrame.setVisibility(View.GONE);
+                mFullSCallback.onCustomViewHidden();
+                // remove fullscreen
+                actionBar.show();
+                ((Activity) mContext).getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+                mTabcontainer.setVisibility(View.VISIBLE);
+                ((Activity) mContext).setContentView(mTabcontainer);
+            }
+        }
+    };
+}
