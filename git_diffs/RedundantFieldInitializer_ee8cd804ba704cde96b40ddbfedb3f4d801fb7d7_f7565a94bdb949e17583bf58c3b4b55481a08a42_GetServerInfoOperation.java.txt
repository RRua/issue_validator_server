diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncAdapter.java b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncAdapter.java
deleted file mode 100644
index 120bb91..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncAdapter.java
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync;
-
-import static java.lang.System.currentTimeMillis;
-
-import android.accounts.Account;
-import android.accounts.AccountManager;
-import android.content.AbstractThreadedSyncAdapter;
-import android.content.ContentProviderClient;
-import android.content.Context;
-import android.content.SyncResult;
-import android.content.res.Resources;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.util.Log;
-import android.widget.Toast;
-
-import androidx.annotation.StringRes;
-
-import com.bytesforge.linkasanote.R;
-import com.bytesforge.linkasanote.data.Favorite;
-import com.bytesforge.linkasanote.data.Link;
-import com.bytesforge.linkasanote.data.Note;
-import com.bytesforge.linkasanote.data.source.cloud.CloudItem;
-import com.bytesforge.linkasanote.data.source.local.LocalFavorites;
-import com.bytesforge.linkasanote.data.source.local.LocalLinks;
-import com.bytesforge.linkasanote.data.source.local.LocalNotes;
-import com.bytesforge.linkasanote.data.source.local.LocalSyncResults;
-import com.bytesforge.linkasanote.settings.Settings;
-import com.bytesforge.linkasanote.utils.CloudUtils;
-import com.google.common.base.Joiner;
-import com.owncloud.android.lib.common.OwnCloudClient;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import io.reactivex.Single;
-
-public class SyncAdapter extends AbstractThreadedSyncAdapter {
-
-    private static final String TAG = SyncAdapter.class.getSimpleName();
-
-    public static final int SYNC_STATUS_UNKNOWN = 0;
-    public static final int SYNC_STATUS_SYNCED = 1;
-    public static final int SYNC_STATUS_UNSYNCED = 2;
-    public static final int SYNC_STATUS_ERROR = 3;
-    public static final int SYNC_STATUS_CONFLICT = 4;
-
-    public static final String SYNC_MANUAL_MODE = "MANUAL_MODE";
-
-    private final Context context;
-    private final Settings settings;
-    private final SyncNotifications syncNotifications;
-    private final LocalSyncResults localSyncResults;
-    private final LocalLinks<Link> localLinks;
-    private final CloudItem<Link> cloudLinks;
-    private final LocalFavorites<Favorite> localFavorites;
-    private final CloudItem<Favorite> cloudFavorites;
-    private final LocalNotes<Note> localNotes;
-    private final CloudItem<Note> cloudNotes;
-    private final AccountManager accountManager;
-    private final Resources resources;
-    private boolean manualMode;
-
-    // NOTE: Note should contain linkId to notify related Link
-    public SyncAdapter(
-            Context context, Settings settings, boolean autoInitialize,
-            AccountManager accountManager, SyncNotifications syncNotifications,
-            LocalSyncResults localSyncResults,
-            LocalLinks<Link> localLinks, CloudItem<Link> cloudLinks,
-            LocalFavorites<Favorite> localFavorites, CloudItem<Favorite> cloudFavorites,
-            LocalNotes<Note> localNotes, CloudItem<Note> cloudNotes) {
-        super(context, autoInitialize);
-        this.context = context;
-        this.settings = settings;
-        this.accountManager = accountManager;
-        this.syncNotifications = syncNotifications;
-        this.localSyncResults = localSyncResults;
-        this.localLinks = localLinks;
-        this.cloudLinks = cloudLinks;
-        this.localFavorites = localFavorites;
-        this.cloudFavorites = cloudFavorites;
-        this.localNotes = localNotes;
-        this.cloudNotes = cloudNotes;
-        resources = context.getResources();
-    }
-
-    @Override
-    public void onPerformSync(
-            Account account, Bundle extras, String authority,
-            ContentProviderClient provider, SyncResult syncResult) {
-        manualMode = extras.getBoolean(SYNC_MANUAL_MODE, false);
-        long started = currentTimeMillis();
-        syncNotifications.setAccountName(CloudUtils.getAccountName(account));
-
-        OwnCloudClient ocClient = CloudUtils.getOwnCloudClient(account, context);
-        if (ocClient == null) {
-            syncNotifications.notifyFailedSynchronization(
-                    resources.getString(R.string.sync_adapter_title_failed_login),
-                    resources.getString(R.string.sync_adapter_text_failed_login));
-            return;
-        }
-
-        //Start
-        syncNotifications.sendSyncBroadcast(
-                SyncNotifications.ACTION_SYNC, SyncNotifications.STATUS_SYNC_START);
-        boolean updated = CloudUtils.updateUserProfile(account, ocClient, accountManager);
-        if (!updated) {
-            syncNotifications.notifyFailedSynchronization(
-                    resources.getString(R.string.sync_adapter_title_failed_cloud),
-                    resources.getString(R.string.sync_adapter_text_failed_cloud_profile));
-            return;
-        }
-        int numRows = localSyncResults.cleanup().blockingGet();
-        Log.d(TAG, "onPerformSync(): cleanupSyncResults() [" + numRows + "]");
-
-        boolean fatalError;
-        SyncItemResult favoritesSyncResult, linksSyncResult = null, notesSyncResult = null;
-
-        // Favorites
-        syncNotifications.sendSyncBroadcast(
-                SyncNotifications.ACTION_SYNC_FAVORITES, SyncNotifications.STATUS_SYNC_START);
-        SyncItem<Favorite> syncFavorites = new SyncItem<>(ocClient, localFavorites, cloudFavorites,
-                syncNotifications, SyncNotifications.ACTION_SYNC_FAVORITES,
-                settings.isSyncUploadToEmpty(), settings.isSyncProtectLocal(), started);
-        favoritesSyncResult = syncFavorites.sync();
-        settings.updateLastFavoritesSyncTime();
-        syncNotifications.sendSyncBroadcast(
-                SyncNotifications.ACTION_SYNC_FAVORITES, SyncNotifications.STATUS_SYNC_STOP);
-        fatalError = favoritesSyncResult.isFatal();
-
-        // Links
-        if (!fatalError) {
-            syncNotifications.sendSyncBroadcast(
-                    SyncNotifications.ACTION_SYNC_LINKS, SyncNotifications.STATUS_SYNC_START);
-            SyncItem<Link> syncLinks = new SyncItem<>(ocClient, localLinks, cloudLinks,
-                    syncNotifications, SyncNotifications.ACTION_SYNC_LINKS,
-                    settings.isSyncUploadToEmpty(), settings.isSyncProtectLocal(), started);
-            linksSyncResult = syncLinks.sync();
-            settings.updateLastLinksSyncTime();
-            syncNotifications.sendSyncBroadcast(
-                    SyncNotifications.ACTION_SYNC_LINKS, SyncNotifications.STATUS_SYNC_STOP);
-            fatalError = linksSyncResult.isFatal();
-        }
-
-        // Notes
-        if (!fatalError) {
-            syncNotifications.sendSyncBroadcast(
-                    SyncNotifications.ACTION_SYNC_NOTES, SyncNotifications.STATUS_SYNC_START);
-            SyncItem<Note> syncNotes = new SyncItem<>(ocClient, localNotes, cloudNotes,
-                    syncNotifications, SyncNotifications.ACTION_SYNC_NOTES,
-                    settings.isSyncUploadToEmpty(), settings.isSyncProtectLocal(), started);
-            notesSyncResult = syncNotes.sync();
-            settings.updateLastNotesSyncTime();
-            settings.updateLastLinksSyncTime(); // NOTE: because there are related links
-            syncNotifications.sendSyncBroadcast(
-                    SyncNotifications.ACTION_SYNC_NOTES, SyncNotifications.STATUS_SYNC_STOP);
-            fatalError = notesSyncResult.isFatal();
-        }
-
-        // Stop
-        boolean success = !fatalError && favoritesSyncResult.isSuccess()
-                && linksSyncResult.isSuccess() && notesSyncResult.isSuccess();
-        saveLastSyncStatus(success);
-        syncNotifications.sendSyncBroadcast(
-                SyncNotifications.ACTION_SYNC, SyncNotifications.STATUS_SYNC_STOP);
-
-        // Error notifications
-        if (fatalError) {
-            SyncItemResult fatalResult = favoritesSyncResult;
-            if (linksSyncResult != null) fatalResult = linksSyncResult;
-            if (notesSyncResult != null) fatalResult = notesSyncResult;
-
-            if (fatalResult.isDbAccessError()) {
-                syncNotifications.notifyFailedSynchronization(
-                        resources.getString(R.string.sync_adapter_title_failed_database),
-                        resources.getString(R.string.sync_adapter_text_failed_database));
-            } else if (fatalResult.isSourceNotReady()) {
-                syncNotifications.notifyFailedSynchronization(
-                        resources.getString(R.string.sync_adapter_title_failed_cloud),
-                        resources.getString(R.string.sync_adapter_text_failed_cloud_access));
-            }
-        } else {
-            // Fail
-            List<String> failSources = new ArrayList<>();
-            int linkFailsCount = linksSyncResult.getFailsCount();
-            if (linkFailsCount > 0) {
-                failSources.add(resources.getQuantityString(
-                        R.plurals.count_links,
-                        linkFailsCount, linkFailsCount));
-            }
-            int favoriteFailsCount = favoritesSyncResult.getFailsCount();
-            if (favoriteFailsCount > 0) {
-                failSources.add(resources.getQuantityString(
-                        R.plurals.count_favorites,
-                        favoriteFailsCount, favoriteFailsCount));
-            }
-            int noteFailsCount = notesSyncResult.getFailsCount();
-            if (noteFailsCount > 0) {
-                failSources.add(resources.getQuantityString(
-                        R.plurals.count_notes,
-                        noteFailsCount, noteFailsCount));
-            }
-            if (!failSources.isEmpty()) {
-                syncNotifications.notifyFailedSynchronization(resources.getString(
-                        R.string.sync_adapter_text_failed, Joiner.on(", ").join(failSources)));
-            }
-        }
-    }
-
-    private void saveLastSyncStatus(boolean success) {
-        int syncStatus;
-        if (success) {
-            boolean conflictedStatus = localLinks.isConflicted()
-                    .flatMap(conflicted -> conflicted ? Single.just(true) : localFavorites.isConflicted())
-                    .flatMap(conflicted -> conflicted ? Single.just(true) : localNotes.isConflicted())
-                    .blockingGet();
-            boolean unsyncedStatus = localLinks.isUnsynced()
-                    .flatMap(unsynced -> unsynced ? Single.just(true) : localFavorites.isUnsynced())
-                    .flatMap(unsynced -> unsynced ? Single.just(true) : localNotes.isUnsynced())
-                    .blockingGet();
-            if (conflictedStatus) {
-                syncStatus = SYNC_STATUS_CONFLICT;
-                if (manualMode) {
-                    showToast(R.string.toast_sync_conflict, Toast.LENGTH_LONG);
-                }
-            } else if (unsyncedStatus) {
-                // NOTE: normally it should not be happened, but the chance is not zero
-                syncStatus = SYNC_STATUS_UNSYNCED;
-                if (manualMode) {
-                    showToast(R.string.toast_sync_unsynced, Toast.LENGTH_LONG);
-                }
-            } else {
-                syncStatus = SYNC_STATUS_SYNCED;
-                if (manualMode) {
-                    showToast(R.string.toast_sync_success, Toast.LENGTH_SHORT);
-                }
-            }
-        } else {
-            syncStatus = SYNC_STATUS_ERROR;
-            if (manualMode) {
-                showToast(R.string.toast_sync_error, Toast.LENGTH_LONG);
-            }
-        }
-        settings.setSyncStatus(syncStatus);
-    }
-
-    private void showToast(@StringRes final int toastId, final int duration) {
-        Handler handler = new Handler(Looper.getMainLooper());
-        handler.post(() -> Toast.makeText(context, toastId, duration).show());
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncAdapter.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncAdapter.kt
new file mode 100644
index 0000000..2f3f89c
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncAdapter.kt
@@ -0,0 +1,342 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import android.content.*
+import android.content.res.Resources
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import android.os.*
+import android.util.Log
+import com.bytesforge.linkasanote.data.Link
+import com.bytesforge.linkasanote.data.Note
+import com.bytesforge.linkasanote.settings.Settings
+import com.google.common.base.Joiner
+import io.reactivex.Single
+import java.util.ArrayList
+
+class SyncAdapter(
+    private val context: Context?, private val settings: Settings?, autoInitialize: Boolean,
+    private val accountManager: AccountManager?, private val syncNotifications: SyncNotifications,
+    private val localSyncResults: LocalSyncResults?,
+    localLinks: LocalLinks<Link>?, cloudLinks: CloudItem<Link>?,
+    localFavorites: LocalFavorites<Favorite>?, cloudFavorites: CloudItem<Favorite>?,
+    localNotes: LocalNotes<Note>?, cloudNotes: CloudItem<Note>?
+) : AbstractThreadedSyncAdapter(
+    context, autoInitialize
+) {
+    private val localLinks: LocalLinks<Link>
+    private val cloudLinks: CloudItem<Link>
+    private val localFavorites: LocalFavorites<Favorite>
+    private val cloudFavorites: CloudItem<Favorite>
+    private val localNotes: LocalNotes<Note>
+    private val cloudNotes: CloudItem<Note>
+    private val resources: Resources
+    private var manualMode = false
+    override fun onPerformSync(
+        account: Account, extras: Bundle, authority: String,
+        provider: ContentProviderClient, syncResult: SyncResult
+    ) {
+        manualMode = extras.getBoolean(SYNC_MANUAL_MODE, false)
+        val started = System.currentTimeMillis()
+        syncNotifications.setAccountName(CloudUtils.getAccountName(account))
+        val ocClient = CloudUtils.getOwnCloudClient(account, context)
+        if (ocClient == null) {
+            syncNotifications.notifyFailedSynchronization(
+                resources.getString(R.string.sync_adapter_title_failed_login),
+                resources.getString(R.string.sync_adapter_text_failed_login)
+            )
+            return
+        }
+
+        //Start
+        syncNotifications.sendSyncBroadcast(
+            SyncNotifications.Companion.ACTION_SYNC, SyncNotifications.Companion.STATUS_SYNC_START
+        )
+        val updated = CloudUtils.updateUserProfile(account, ocClient, accountManager)
+        if (!updated) {
+            syncNotifications.notifyFailedSynchronization(
+                resources.getString(R.string.sync_adapter_title_failed_cloud),
+                resources.getString(R.string.sync_adapter_text_failed_cloud_profile)
+            )
+            return
+        }
+        val numRows = localSyncResults!!.cleanup().blockingGet()
+        Log.d(TAG, "onPerformSync(): cleanupSyncResults() [$numRows]")
+        var fatalError: Boolean
+        val favoritesSyncResult: SyncItemResult
+        var linksSyncResult: SyncItemResult? = null
+        var notesSyncResult: SyncItemResult? = null
+
+        // Favorites
+        syncNotifications.sendSyncBroadcast(
+            SyncNotifications.Companion.ACTION_SYNC_FAVORITES,
+            SyncNotifications.Companion.STATUS_SYNC_START
+        )
+        val syncFavorites = SyncItem(
+            ocClient, localFavorites, cloudFavorites,
+            syncNotifications, SyncNotifications.Companion.ACTION_SYNC_FAVORITES,
+            settings!!.isSyncUploadToEmpty, settings.isSyncProtectLocal, started
+        )
+        favoritesSyncResult = syncFavorites.sync()
+        settings.updateLastFavoritesSyncTime()
+        syncNotifications.sendSyncBroadcast(
+            SyncNotifications.Companion.ACTION_SYNC_FAVORITES,
+            SyncNotifications.Companion.STATUS_SYNC_STOP
+        )
+        fatalError = favoritesSyncResult.isFatal
+
+        // Links
+        if (!fatalError) {
+            syncNotifications.sendSyncBroadcast(
+                SyncNotifications.Companion.ACTION_SYNC_LINKS,
+                SyncNotifications.Companion.STATUS_SYNC_START
+            )
+            val syncLinks = SyncItem(
+                ocClient, localLinks, cloudLinks,
+                syncNotifications, SyncNotifications.Companion.ACTION_SYNC_LINKS,
+                settings.isSyncUploadToEmpty, settings.isSyncProtectLocal, started
+            )
+            linksSyncResult = syncLinks.sync()
+            settings.updateLastLinksSyncTime()
+            syncNotifications.sendSyncBroadcast(
+                SyncNotifications.Companion.ACTION_SYNC_LINKS,
+                SyncNotifications.Companion.STATUS_SYNC_STOP
+            )
+            fatalError = linksSyncResult.isFatal
+        }
+
+        // Notes
+        if (!fatalError) {
+            syncNotifications.sendSyncBroadcast(
+                SyncNotifications.Companion.ACTION_SYNC_NOTES,
+                SyncNotifications.Companion.STATUS_SYNC_START
+            )
+            val syncNotes = SyncItem(
+                ocClient, localNotes, cloudNotes,
+                syncNotifications, SyncNotifications.Companion.ACTION_SYNC_NOTES,
+                settings.isSyncUploadToEmpty, settings.isSyncProtectLocal, started
+            )
+            notesSyncResult = syncNotes.sync()
+            settings.updateLastNotesSyncTime()
+            settings.updateLastLinksSyncTime() // NOTE: because there are related links
+            syncNotifications.sendSyncBroadcast(
+                SyncNotifications.Companion.ACTION_SYNC_NOTES,
+                SyncNotifications.Companion.STATUS_SYNC_STOP
+            )
+            fatalError = notesSyncResult.isFatal
+        }
+
+        // Stop
+        val success = (!fatalError && favoritesSyncResult.isSuccess
+                && linksSyncResult!!.isSuccess && notesSyncResult!!.isSuccess)
+        saveLastSyncStatus(success)
+        syncNotifications.sendSyncBroadcast(
+            SyncNotifications.Companion.ACTION_SYNC, SyncNotifications.Companion.STATUS_SYNC_STOP
+        )
+
+        // Error notifications
+        if (fatalError) {
+            var fatalResult = favoritesSyncResult
+            if (linksSyncResult != null) fatalResult = linksSyncResult
+            if (notesSyncResult != null) fatalResult = notesSyncResult
+            if (fatalResult.isDbAccessError) {
+                syncNotifications.notifyFailedSynchronization(
+                    resources.getString(R.string.sync_adapter_title_failed_database),
+                    resources.getString(R.string.sync_adapter_text_failed_database)
+                )
+            } else if (fatalResult.isSourceNotReady) {
+                syncNotifications.notifyFailedSynchronization(
+                    resources.getString(R.string.sync_adapter_title_failed_cloud),
+                    resources.getString(R.string.sync_adapter_text_failed_cloud_access)
+                )
+            }
+        } else {
+            // Fail
+            val failSources: MutableList<String> = ArrayList()
+            val linkFailsCount = linksSyncResult.getFailsCount()
+            if (linkFailsCount > 0) {
+                failSources.add(
+                    resources.getQuantityString(
+                        R.plurals.count_links,
+                        linkFailsCount, linkFailsCount
+                    )
+                )
+            }
+            val favoriteFailsCount = favoritesSyncResult.failsCount
+            if (favoriteFailsCount > 0) {
+                failSources.add(
+                    resources.getQuantityString(
+                        R.plurals.count_favorites,
+                        favoriteFailsCount, favoriteFailsCount
+                    )
+                )
+            }
+            val noteFailsCount = notesSyncResult.getFailsCount()
+            if (noteFailsCount > 0) {
+                failSources.add(
+                    resources.getQuantityString(
+                        R.plurals.count_notes,
+                        noteFailsCount, noteFailsCount
+                    )
+                )
+            }
+            if (!failSources.isEmpty()) {
+                syncNotifications.notifyFailedSynchronization(
+                    resources.getString(
+                        R.string.sync_adapter_text_failed, Joiner.on(", ").join(failSources)
+                    )
+                )
+            }
+        }
+    }
+
+    private fun saveLastSyncStatus(success: Boolean) {
+        val syncStatus: Int
+        if (success) {
+            val conflictedStatus = localLinks.isConflicted
+                .flatMap { conflicted: Boolean -> if (conflicted) Single.just(true) else localFavorites.isConflicted }
+                .flatMap { conflicted: Boolean -> if (conflicted) Single.just(true) else localNotes.isConflicted }
+                .blockingGet()
+            val unsyncedStatus = localLinks.isUnsynced
+                .flatMap { unsynced: Boolean -> if (unsynced) Single.just(true) else localFavorites.isUnsynced }
+                .flatMap { unsynced: Boolean -> if (unsynced) Single.just(true) else localNotes.isUnsynced }
+                .blockingGet()
+            if (conflictedStatus) {
+                syncStatus = SYNC_STATUS_CONFLICT
+                if (manualMode) {
+                    showToast(R.string.toast_sync_conflict, Toast.LENGTH_LONG)
+                }
+            } else if (unsyncedStatus) {
+                // NOTE: normally it should not be happened, but the chance is not zero
+                syncStatus = SYNC_STATUS_UNSYNCED
+                if (manualMode) {
+                    showToast(R.string.toast_sync_unsynced, Toast.LENGTH_LONG)
+                }
+            } else {
+                syncStatus = SYNC_STATUS_SYNCED
+                if (manualMode) {
+                    showToast(R.string.toast_sync_success, Toast.LENGTH_SHORT)
+                }
+            }
+        } else {
+            syncStatus = SYNC_STATUS_ERROR
+            if (manualMode) {
+                showToast(R.string.toast_sync_error, Toast.LENGTH_LONG)
+            }
+        }
+        settings!!.syncStatus = syncStatus
+    }
+
+    private fun showToast(@StringRes toastId: Int, duration: Int) {
+        val handler = Handler(Looper.getMainLooper())
+        handler.post { Toast.makeText(context, toastId, duration).show() }
+    }
+
+    companion object {
+        private val TAG = SyncAdapter::class.java.simpleName
+        const val SYNC_STATUS_UNKNOWN = 0
+        const val SYNC_STATUS_SYNCED = 1
+        const val SYNC_STATUS_UNSYNCED = 2
+        const val SYNC_STATUS_ERROR = 3
+        const val SYNC_STATUS_CONFLICT = 4
+        const val SYNC_MANUAL_MODE = "MANUAL_MODE"
+    }
+
+    // NOTE: Note should contain linkId to notify related Link
+    init {
+        this.localLinks = localLinks!!
+        this.cloudLinks = cloudLinks!!
+        this.localFavorites = localFavorites!!
+        this.cloudFavorites = cloudFavorites!!
+        this.localNotes = localNotes!!
+        this.cloudNotes = cloudNotes!!
+        resources = context!!.resources
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItem.java b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItem.java
deleted file mode 100644
index 99f51d4..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItem.java
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import android.database.sqlite.SQLiteConstraintException;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.VisibleForTesting;
-
-import com.bytesforge.linkasanote.data.Item;
-import com.bytesforge.linkasanote.data.source.cloud.CloudItem;
-import com.bytesforge.linkasanote.data.source.local.LocalContract;
-import com.bytesforge.linkasanote.data.source.local.LocalItems;
-import com.bytesforge.linkasanote.sync.files.JsonFile;
-import com.bytesforge.linkasanote.utils.CommonUtils;
-import com.owncloud.android.lib.common.OwnCloudClient;
-import com.owncloud.android.lib.common.operations.RemoteOperationResult;
-
-import java.util.HashSet;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
-
-public class SyncItem<T extends Item> {
-
-    private static final String TAG = SyncItem.class.getSimpleName();
-    private static final String TAG_E = SyncItem.class.getCanonicalName();
-
-    private final LocalItems<T> localItems;
-    private final CloudItem<T> cloudItem;
-    private final SyncNotifications syncNotifications;
-    private final OwnCloudClient ocClient;
-    private final String notificationAction;
-    private final boolean uploadToEmpty;
-    private final boolean protectLocal;
-    private final long started;
-
-    private int uploaded;
-    private int downloaded;
-
-    private SyncItemResult syncResult;
-
-    public SyncItem(
-            @NonNull OwnCloudClient ocClient,
-            @NonNull LocalItems<T> localItems, @NonNull CloudItem<T> cloudItem,
-            @NonNull SyncNotifications syncNotifications, @NonNull String notificationAction,
-            boolean uploadToEmpty, boolean protectLocal, long started) {
-        this.ocClient = checkNotNull(ocClient);
-        this.localItems = checkNotNull(localItems);
-        this.cloudItem = checkNotNull(cloudItem);
-        this.syncNotifications = checkNotNull(syncNotifications);
-        this.notificationAction = checkNotNull(notificationAction);
-        this.uploadToEmpty = uploadToEmpty;
-        this.protectLocal = protectLocal;
-        this.started = started;
-        syncResult = new SyncItemResult(SyncItemResult.Status.FAILS_COUNT);
-        uploaded = 0;
-        downloaded = 0;
-    }
-
-    @NonNull
-    public SyncItemResult sync() {
-        final String dataStorageETag = cloudItem.getDataSourceETag(ocClient);
-        if (dataStorageETag == null) {
-            return new SyncItemResult(SyncItemResult.Status.SOURCE_NOT_READY);
-        }
-        boolean isCloudChanged = cloudItem.isCloudDataSourceChanged(dataStorageETag);
-        syncItems(isCloudChanged);
-
-        if (syncResult.isSuccess()) {
-            cloudItem.updateLastSyncedETag(dataStorageETag);
-        }
-        return syncResult;
-    }
-
-    private void syncItems(boolean isCloudChanged) {
-        if (!isCloudChanged) {
-            localItems.getUnsynced()
-                    .subscribe(
-                            item -> syncItem(item, item.getETag()),
-                            throwable -> setDbAccessError());
-            return;
-        }
-        final Map<String, String> cloudDataSourceMap = cloudItem.getDataSourceMap(ocClient);
-        if (cloudDataSourceMap.isEmpty() && uploadToEmpty) {
-            int numRows = localItems.resetSyncState().blockingGet();
-            if (numRows > 0) {
-                Log.d(TAG, "Cloud storage loss is detected, starting to upload [" + numRows + "]");
-            }
-        }
-        // Sync Local
-        localItems.getAll()
-                .subscribe(item -> {
-                    String cloudETag = cloudDataSourceMap.get(item.getId());
-                    syncItem(item, cloudETag);
-                }, throwable -> {
-                    CommonUtils.logStackTrace(TAG_E, throwable);
-                    setDbAccessError();
-                });
-        if (syncResult.isDbAccessError()) return;
-
-        // OPTIMIZATION: Local Map can be taken from previous step
-        final Set<String> localIds = new HashSet<>();
-        localItems.getIds()
-                .subscribe(
-                        localIds::add,
-                        throwable -> setDbAccessError());
-        if (syncResult.isDbAccessError()) return;
-
-        // New cloud records
-        // OPTIMIZATION: Cloud Map can be updated in the previous step
-        final Set<String> cloudIds = cloudItem.getDataSourceMap(ocClient).keySet();
-        for (String cloudId : cloudIds) {
-            if (localIds.contains(cloudId)) {
-                continue;
-            }
-            T cloudItem = download(cloudId);
-            if (cloudItem == null) {
-                continue;
-            }
-            syncNotifications.sendSyncBroadcast(notificationAction,
-                    SyncNotifications.STATUS_DOWNLOADED, cloudId, ++downloaded);
-            boolean notifyChanged = save(cloudItem);
-            if (notifyChanged) {
-                syncNotifications.sendSyncBroadcast(notificationAction,
-                        SyncNotifications.STATUS_CREATED, cloudId);
-            }
-        }
-    }
-
-    private void syncItem(final T item, final String cloudETag) {
-        // NOTE: some updates on the conflicted state may cause constraint violation, so let it be resolved first
-        if (item.isConflicted()) return;
-
-        final String itemId = item.getId();
-        final String itemETag = item.getETag();
-        boolean notifyChanged = false;
-        int statusChanged = SyncNotifications.STATUS_UPDATED;
-        if (itemETag == null) { // New
-            // duplicated && conflicted can be ignored
-            if (item.isDeleted()) {
-                // DELETE local
-                Log.e(TAG, "The records never synced must be deleted immediately [" + itemId + "]");
-                notifyChanged = deleteLocal(item);
-                statusChanged = SyncNotifications.STATUS_DELETED;
-            } else { // synced is ignored (!synced)
-                // UPLOAD
-                // NOTE: local unsynced will replace cloud with the same ID (acceptable behaviour)
-                notifyChanged = upload(item);
-            }
-        } else if (itemETag.equals(cloudETag)) { // Green light
-            // conflicted can be ignored
-            if (!item.isSynced()) {
-                if (item.isDeleted()) {
-                    // DELETE cloud
-                    notifyChanged = deleteCloud(item);
-                    statusChanged = SyncNotifications.STATUS_DELETED;
-                } else if (!item.isDuplicated()) {
-                    // UPLOAD
-                    notifyChanged = upload(item);
-                }
-            }
-        } else if (cloudETag == null) { // Was deleted on cloud
-            if (item.isSynced()) {
-                if (protectLocal) {
-                    // SET conflicted (as if it has been changed)
-                    SyncState state = new SyncState(SyncState.State.CONFLICTED_UPDATE);
-                    notifyChanged = update(item, state);
-                } else {
-                    // DELETE local
-                    notifyChanged = deleteLocal(item);
-                    statusChanged = SyncNotifications.STATUS_DELETED;
-                }
-            } else {
-                if (item.isDeleted()) {
-                    // DELETE local
-                    notifyChanged = deleteLocal(item);
-                    statusChanged = SyncNotifications.STATUS_DELETED;
-                } else {
-                    // SET conflicted
-                    SyncState state = new SyncState(SyncState.State.CONFLICTED_UPDATE);
-                    notifyChanged = update(item, state);
-                }
-            }
-        } else { // Was changed on cloud
-            // duplicated && conflicted can be ignored
-            // DOWNLOAD (with synced state by default)
-            T cloudItem = download(itemId);
-            if (cloudItem != null) {
-                syncNotifications.sendSyncBroadcast(notificationAction,
-                        SyncNotifications.STATUS_DOWNLOADED, itemId, ++downloaded);
-                if (item.isSynced() && !item.isDeleted()) {
-                    // SAVE local
-                    notifyChanged = save(cloudItem);
-                } else { // !synced || deleted
-                    if (item.equals(cloudItem)) {
-                        if (item.isDeleted()) {
-                            // DELETE cloud
-                            notifyChanged = deleteCloud(item);
-                            statusChanged = SyncNotifications.STATUS_DELETED;
-                        } else {
-                            // UPDATE state
-                            assert cloudItem.getETag() != null;
-                            SyncState state = new SyncState(
-                                    cloudItem.getETag(), SyncState.State.SYNCED);
-                            // NOTE: record may be in conflicted state
-                            notifyChanged = update(item, state);
-                        }
-                    } else {
-                        // SET (or confirm) conflicted
-                        SyncState state;
-                        if (item.isDeleted()) {
-                            state = new SyncState(SyncState.State.CONFLICTED_DELETE);
-                        } else {
-                            state = new SyncState(SyncState.State.CONFLICTED_UPDATE);
-                        }
-                        notifyChanged = update(item, state);
-                    }
-                }
-            }
-        }
-        if (notifyChanged) {
-            syncNotifications.sendSyncBroadcast(notificationAction, statusChanged, itemId);
-        }
-    }
-
-    // NOTE: any cloud item can violate the DB constraints
-    private boolean save(@NonNull final T item) { // downloaded
-        checkNotNull(item);
-        String itemId = item.getId();
-        // Primary record
-        try {
-            boolean success = localItems.save(item).blockingGet();
-            if (success) {
-                localItems.logSyncResult(started, itemId,
-                        LocalContract.SyncResultEntry.Result.DOWNLOADED).blockingGet();
-                String relatedId = item.getRelatedId();
-                if (relatedId != null) {
-                    localItems.logSyncResult(started, relatedId,
-                            LocalContract.SyncResultEntry.Result.RELATED).blockingGet();
-                }
-            }
-            return success;
-        } catch (NullPointerException e) {
-            syncResult.incFailsCount();
-            localItems.logSyncResult(started, itemId,
-                    LocalContract.SyncResultEntry.Result.ERROR).blockingGet();
-            return false;
-        } catch (SQLiteConstraintException e) {
-            // NOTE: will try to resolve it further
-        }
-        // Duplicated record
-        try {
-            boolean success = localItems.saveDuplicated(item).blockingGet();
-            if (success) {
-                localItems.logSyncResult(started, itemId,
-                        LocalContract.SyncResultEntry.Result.DOWNLOADED).blockingGet();
-                String relatedId = item.getRelatedId();
-                if (relatedId != null) {
-                    localItems.logSyncResult(started, relatedId,
-                            LocalContract.SyncResultEntry.Result.RELATED).blockingGet();
-                }
-            }
-            return success;
-        } catch (NullPointerException | SQLiteConstraintException e) {
-            syncResult.incFailsCount();
-            localItems.logSyncResult(started, itemId,
-                    LocalContract.SyncResultEntry.Result.ERROR).blockingGet();
-        }
-        return false;
-    }
-
-    private boolean deleteLocal(@NonNull final T item) {
-        checkNotNull(item);
-        final String itemId = item.getId();
-        final String relatedId = item.getRelatedId();
-        Log.d(TAG, itemId + ": DELETE local");
-
-        boolean success = localItems.delete(itemId).blockingGet();
-        if (success) {
-            localItems.logSyncResult(started, itemId,
-                    LocalContract.SyncResultEntry.Result.DELETED).blockingGet();
-            if (relatedId != null) {
-                localItems.logSyncResult(started, relatedId,
-                        LocalContract.SyncResultEntry.Result.RELATED).blockingGet();
-            }
-        }
-        return success;
-    }
-
-    private boolean deleteCloud(@NonNull final T item) {
-        checkNotNull(item);
-        final String itemId = item.getId();
-        Log.d(TAG, itemId + ": DELETE cloud");
-
-        RemoteOperationResult result = cloudItem.delete(itemId, ocClient).blockingGet();
-        return result.isSuccess() && deleteLocal(item);
-    }
-
-    private boolean update(@NonNull final T item, @NonNull final SyncState state) {
-        checkNotNull(item);
-        checkNotNull(state);
-        final String itemId = item.getId();
-        final String relatedId = item.getRelatedId();
-        Log.d(TAG, itemId + ": UPDATE");
-
-        boolean success = localItems.update(itemId, state).blockingGet();
-        if (success) {
-            LocalContract.SyncResultEntry.Result result;
-            if (state.isConflicted()) {
-                result = LocalContract.SyncResultEntry.Result.CONFLICT;
-            } else {
-                result = LocalContract.SyncResultEntry.Result.SYNCED;
-            }
-            localItems.logSyncResult(started, itemId, result).blockingGet();
-            if (relatedId != null) {
-                localItems.logSyncResult(started, relatedId,
-                        LocalContract.SyncResultEntry.Result.RELATED).blockingGet();
-            }
-        }
-        return success;
-    }
-
-    private boolean upload(@NonNull final T item) {
-        checkNotNull(item);
-        final String itemId = item.getId();
-        final String relatedId = item.getRelatedId();
-        Log.d(TAG, item.getId() + ": UPLOAD");
-
-        boolean success = false;
-        RemoteOperationResult result = cloudItem.upload(item, ocClient).blockingGet();
-        if (result == null) {
-            syncResult.incFailsCount();
-            localItems.logSyncResult(started, itemId,
-                    LocalContract.SyncResultEntry.Result.ERROR).blockingGet();
-            return false;
-        }
-        if (result.isSuccess()) {
-            syncNotifications.sendSyncBroadcast(notificationAction,
-                    SyncNotifications.STATUS_UPLOADED, itemId, ++uploaded);
-            JsonFile jsonFile = (JsonFile) result.getData().get(0);
-            SyncState state = new SyncState(jsonFile.getETag(), SyncState.State.SYNCED);
-            success = localItems.update(itemId, state).blockingGet();
-            if (success) {
-                localItems.logSyncResult(started, itemId,
-                        LocalContract.SyncResultEntry.Result.UPLOADED).blockingGet();
-                if (relatedId != null) {
-                    localItems.logSyncResult(started, relatedId,
-                            LocalContract.SyncResultEntry.Result.RELATED).blockingGet();
-                }
-            }
-        } else if (result.getCode() == RemoteOperationResult.ResultCode.SYNC_CONFLICT) {
-            SyncState state = new SyncState(SyncState.State.CONFLICTED_UPDATE);
-            success = update(item, state);
-        }
-        return success;
-    }
-
-    private T download(@NonNull String itemId) {
-        checkNotNull(itemId);
-        Log.d(TAG, itemId + ": DOWNLOAD");
-
-        try {
-            // Note: will be logged in save() or update()
-            return cloudItem.download(itemId, ocClient).blockingGet();
-        } catch (NullPointerException | NoSuchElementException e) {
-            syncResult.incFailsCount();
-            localItems.logSyncResult(started, itemId,
-                    LocalContract.SyncResultEntry.Result.ERROR).blockingGet();
-            return null; // NOTE: an unexpected error, file have to be in place here
-        }
-    }
-
-    private void setDbAccessError() {
-        syncResult = new SyncItemResult(SyncItemResult.Status.DB_ACCESS_ERROR);
-    }
-
-    @VisibleForTesting
-    public int getFailsCount() {
-        return syncResult.getFailsCount();
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItem.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItem.kt
new file mode 100644
index 0000000..244a8c0
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItem.kt
@@ -0,0 +1,501 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import android.content.Intent
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.content.ContentValues
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import android.content.AbstractThreadedSyncAdapter
+import android.content.ContentProviderClient
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import android.util.Log
+import com.bytesforge.linkasanote.data.Item
+import com.google.common.base.Preconditions
+import java.lang.NullPointerException
+import java.util.HashSet
+import java.util.NoSuchElementException
+
+class SyncItem<T : Item?>(
+    ocClient: OwnCloudClient,
+    localItems: LocalItems<T>, cloudItem: CloudItem<T>,
+    syncNotifications: SyncNotifications, notificationAction: String,
+    uploadToEmpty: Boolean, protectLocal: Boolean, started: Long
+) {
+    private val localItems: LocalItems<T>
+    private val cloudItem: CloudItem<T>
+    private val syncNotifications: SyncNotifications
+    private val ocClient: OwnCloudClient
+    private val notificationAction: String
+    private val uploadToEmpty: Boolean
+    private val protectLocal: Boolean
+    private val started: Long
+    private var uploaded: Int
+    private var downloaded: Int
+    private var syncResult: SyncItemResult
+    fun sync(): SyncItemResult {
+        val dataStorageETag = cloudItem.getDataSourceETag(ocClient)
+            ?: return SyncItemResult(SyncItemResult.Status.SOURCE_NOT_READY)
+        val isCloudChanged = cloudItem.isCloudDataSourceChanged(dataStorageETag)
+        syncItems(isCloudChanged)
+        if (syncResult.isSuccess) {
+            cloudItem.updateLastSyncedETag(dataStorageETag)
+        }
+        return syncResult
+    }
+
+    private fun syncItems(isCloudChanged: Boolean) {
+        if (!isCloudChanged) {
+            localItems.unsynced
+                .subscribe(
+                    { item: T -> syncItem(item, item!!.eTag) }
+                ) { throwable: Throwable? -> setDbAccessError() }
+            return
+        }
+        val cloudDataSourceMap = cloudItem.getDataSourceMap(ocClient)
+        if (cloudDataSourceMap.isEmpty() && uploadToEmpty) {
+            val numRows = localItems.resetSyncState().blockingGet()
+            if (numRows > 0) {
+                Log.d(TAG, "Cloud storage loss is detected, starting to upload [$numRows]")
+            }
+        }
+        // Sync Local
+        localItems.all
+            .subscribe({ item: T ->
+                val cloudETag = cloudDataSourceMap[item!!.id]
+                syncItem(item, cloudETag)
+            }) { throwable: Throwable? ->
+                CommonUtils.logStackTrace(TAG_E, throwable!!)
+                setDbAccessError()
+            }
+        if (syncResult.isDbAccessError) return
+
+        // OPTIMIZATION: Local Map can be taken from previous step
+        val localIds: MutableSet<String> = HashSet()
+        localItems.ids
+            .subscribe(
+                { e: String -> localIds.add(e) }
+            ) { throwable: Throwable? -> setDbAccessError() }
+        if (syncResult.isDbAccessError) return
+
+        // New cloud records
+        // OPTIMIZATION: Cloud Map can be updated in the previous step
+        val cloudIds: Set<String> = cloudItem.getDataSourceMap(ocClient).keys
+        for (cloudId in cloudIds) {
+            if (localIds.contains(cloudId)) {
+                continue
+            }
+            val cloudItem = download(cloudId) ?: continue
+            syncNotifications.sendSyncBroadcast(
+                notificationAction,
+                SyncNotifications.Companion.STATUS_DOWNLOADED, cloudId, ++downloaded
+            )
+            val notifyChanged = save(cloudItem)
+            if (notifyChanged) {
+                syncNotifications.sendSyncBroadcast(
+                    notificationAction,
+                    SyncNotifications.Companion.STATUS_CREATED, cloudId
+                )
+            }
+        }
+    }
+
+    private fun syncItem(item: T, cloudETag: String?) {
+        // NOTE: some updates on the conflicted state may cause constraint violation, so let it be resolved first
+        if (item!!.isConflicted) return
+        val itemId = item.id
+        val itemETag = item.eTag
+        var notifyChanged = false
+        var statusChanged: Int = SyncNotifications.Companion.STATUS_UPDATED
+        if (itemETag == null) { // New
+            // duplicated && conflicted can be ignored
+            if (item.isDeleted) {
+                // DELETE local
+                Log.e(TAG, "The records never synced must be deleted immediately [$itemId]")
+                notifyChanged = deleteLocal(item)
+                statusChanged = SyncNotifications.Companion.STATUS_DELETED
+            } else { // synced is ignored (!synced)
+                // UPLOAD
+                // NOTE: local unsynced will replace cloud with the same ID (acceptable behaviour)
+                notifyChanged = upload(item)
+            }
+        } else if (itemETag == cloudETag) { // Green light
+            // conflicted can be ignored
+            if (!item.isSynced) {
+                if (item.isDeleted) {
+                    // DELETE cloud
+                    notifyChanged = deleteCloud(item)
+                    statusChanged = SyncNotifications.Companion.STATUS_DELETED
+                } else if (!item.isDuplicated) {
+                    // UPLOAD
+                    notifyChanged = upload(item)
+                }
+            }
+        } else if (cloudETag == null) { // Was deleted on cloud
+            if (item.isSynced) {
+                if (protectLocal) {
+                    // SET conflicted (as if it has been changed)
+                    val state = SyncState(SyncState.State.CONFLICTED_UPDATE)
+                    notifyChanged = update(item, state)
+                } else {
+                    // DELETE local
+                    notifyChanged = deleteLocal(item)
+                    statusChanged = SyncNotifications.Companion.STATUS_DELETED
+                }
+            } else {
+                if (item.isDeleted) {
+                    // DELETE local
+                    notifyChanged = deleteLocal(item)
+                    statusChanged = SyncNotifications.Companion.STATUS_DELETED
+                } else {
+                    // SET conflicted
+                    val state = SyncState(SyncState.State.CONFLICTED_UPDATE)
+                    notifyChanged = update(item, state)
+                }
+            }
+        } else { // Was changed on cloud
+            // duplicated && conflicted can be ignored
+            // DOWNLOAD (with synced state by default)
+            val cloudItem = download(itemId)
+            if (cloudItem != null) {
+                syncNotifications.sendSyncBroadcast(
+                    notificationAction,
+                    SyncNotifications.Companion.STATUS_DOWNLOADED, itemId, ++downloaded
+                )
+                if (item.isSynced && !item.isDeleted) {
+                    // SAVE local
+                    notifyChanged = save(cloudItem)
+                } else { // !synced || deleted
+                    if (item == cloudItem) {
+                        if (item.isDeleted) {
+                            // DELETE cloud
+                            notifyChanged = deleteCloud(item)
+                            statusChanged = SyncNotifications.Companion.STATUS_DELETED
+                        } else {
+                            // UPDATE state
+                            assert(cloudItem.eTag != null)
+                            val state = SyncState(
+                                cloudItem.eTag!!, SyncState.State.SYNCED
+                            )
+                            // NOTE: record may be in conflicted state
+                            notifyChanged = update(item, state)
+                        }
+                    } else {
+                        // SET (or confirm) conflicted
+                        val state: SyncState
+                        state = if (item.isDeleted) {
+                            SyncState(SyncState.State.CONFLICTED_DELETE)
+                        } else {
+                            SyncState(SyncState.State.CONFLICTED_UPDATE)
+                        }
+                        notifyChanged = update(item, state)
+                    }
+                }
+            }
+        }
+        if (notifyChanged) {
+            syncNotifications.sendSyncBroadcast(notificationAction, statusChanged, itemId)
+        }
+    }
+
+    // NOTE: any cloud item can violate the DB constraints
+    private fun save(item: T): Boolean { // downloaded
+        Preconditions.checkNotNull(item)
+        val itemId = item!!.id
+        // Primary record
+        try {
+            val success = localItems.save(item).blockingGet()
+            if (success) {
+                localItems.logSyncResult(
+                    started, itemId,
+                    SyncResultEntry.Result.DOWNLOADED
+                ).blockingGet()
+                val relatedId = item.relatedId
+                if (relatedId != null) {
+                    localItems.logSyncResult(
+                        started, relatedId,
+                        SyncResultEntry.Result.RELATED
+                    ).blockingGet()
+                }
+            }
+            return success
+        } catch (e: NullPointerException) {
+            syncResult.incFailsCount()
+            localItems.logSyncResult(
+                started, itemId,
+                SyncResultEntry.Result.ERROR
+            ).blockingGet()
+            return false
+        } catch (e: SQLiteConstraintException) {
+            // NOTE: will try to resolve it further
+        }
+        // Duplicated record
+        try {
+            val success = localItems.saveDuplicated(item).blockingGet()
+            if (success) {
+                localItems.logSyncResult(
+                    started, itemId,
+                    SyncResultEntry.Result.DOWNLOADED
+                ).blockingGet()
+                val relatedId = item.relatedId
+                if (relatedId != null) {
+                    localItems.logSyncResult(
+                        started, relatedId,
+                        SyncResultEntry.Result.RELATED
+                    ).blockingGet()
+                }
+            }
+            return success
+        } catch (e: NullPointerException) {
+            syncResult.incFailsCount()
+            localItems.logSyncResult(
+                started, itemId,
+                SyncResultEntry.Result.ERROR
+            ).blockingGet()
+        } catch (e: SQLiteConstraintException) {
+            syncResult.incFailsCount()
+            localItems.logSyncResult(
+                started, itemId,
+                SyncResultEntry.Result.ERROR
+            ).blockingGet()
+        }
+        return false
+    }
+
+    private fun deleteLocal(item: T): Boolean {
+        Preconditions.checkNotNull(item)
+        val itemId = item!!.id
+        val relatedId = item.relatedId
+        Log.d(TAG, "$itemId: DELETE local")
+        val success = localItems.delete(itemId).blockingGet()
+        if (success) {
+            localItems.logSyncResult(
+                started, itemId,
+                SyncResultEntry.Result.DELETED
+            ).blockingGet()
+            if (relatedId != null) {
+                localItems.logSyncResult(
+                    started, relatedId,
+                    SyncResultEntry.Result.RELATED
+                ).blockingGet()
+            }
+        }
+        return success
+    }
+
+    private fun deleteCloud(item: T): Boolean {
+        Preconditions.checkNotNull(item)
+        val itemId = item!!.id
+        Log.d(TAG, "$itemId: DELETE cloud")
+        val result = cloudItem.delete(itemId, ocClient).blockingGet()
+        return result.isSuccess && deleteLocal(item)
+    }
+
+    private fun update(item: T, state: SyncState): Boolean {
+        Preconditions.checkNotNull(item)
+        Preconditions.checkNotNull(state)
+        val itemId = item!!.id
+        val relatedId = item.relatedId
+        Log.d(TAG, "$itemId: UPDATE")
+        val success = localItems.update(itemId, state).blockingGet()
+        if (success) {
+            val result: SyncResultEntry.Result
+            result = if (state.isConflicted) {
+                SyncResultEntry.Result.CONFLICT
+            } else {
+                SyncResultEntry.Result.SYNCED
+            }
+            localItems.logSyncResult(started, itemId, result).blockingGet()
+            if (relatedId != null) {
+                localItems.logSyncResult(
+                    started, relatedId,
+                    SyncResultEntry.Result.RELATED
+                ).blockingGet()
+            }
+        }
+        return success
+    }
+
+    private fun upload(item: T): Boolean {
+        Preconditions.checkNotNull(item)
+        val itemId = item!!.id
+        val relatedId = item.relatedId
+        Log.d(TAG, item.id + ": UPLOAD")
+        var success = false
+        val result = cloudItem.upload(item, ocClient).blockingGet()
+        if (result == null) {
+            syncResult.incFailsCount()
+            localItems.logSyncResult(
+                started, itemId,
+                SyncResultEntry.Result.ERROR
+            ).blockingGet()
+            return false
+        }
+        if (result.isSuccess) {
+            syncNotifications.sendSyncBroadcast(
+                notificationAction,
+                SyncNotifications.Companion.STATUS_UPLOADED, itemId, ++uploaded
+            )
+            val jsonFile = result.data[0] as JsonFile
+            val state = SyncState(jsonFile.eTag, SyncState.State.SYNCED)
+            success = localItems.update(itemId, state).blockingGet()
+            if (success) {
+                localItems.logSyncResult(
+                    started, itemId,
+                    SyncResultEntry.Result.UPLOADED
+                ).blockingGet()
+                if (relatedId != null) {
+                    localItems.logSyncResult(
+                        started, relatedId,
+                        SyncResultEntry.Result.RELATED
+                    ).blockingGet()
+                }
+            }
+        } else if (result.code == RemoteOperationResult.ResultCode.SYNC_CONFLICT) {
+            val state = SyncState(SyncState.State.CONFLICTED_UPDATE)
+            success = update(item, state)
+        }
+        return success
+    }
+
+    private fun download(itemId: String): T? {
+        Preconditions.checkNotNull(itemId)
+        Log.d(TAG, "$itemId: DOWNLOAD")
+        return try {
+            // Note: will be logged in save() or update()
+            cloudItem.download(itemId, ocClient).blockingGet()
+        } catch (e: NullPointerException) {
+            syncResult.incFailsCount()
+            localItems.logSyncResult(
+                started, itemId,
+                SyncResultEntry.Result.ERROR
+            ).blockingGet()
+            null // NOTE: an unexpected error, file have to be in place here
+        } catch (e: NoSuchElementException) {
+            syncResult.incFailsCount()
+            localItems.logSyncResult(
+                started, itemId,
+                SyncResultEntry.Result.ERROR
+            ).blockingGet()
+            null
+        }
+    }
+
+    private fun setDbAccessError() {
+        syncResult = SyncItemResult(SyncItemResult.Status.DB_ACCESS_ERROR)
+    }
+
+    @get:VisibleForTesting
+    val failsCount: Int
+        get() = syncResult.failsCount
+
+    companion object {
+        private val TAG = SyncItem::class.java.simpleName
+        private val TAG_E = SyncItem::class.java.canonicalName
+    }
+
+    init {
+        this.ocClient = Preconditions.checkNotNull(ocClient)
+        this.localItems = Preconditions.checkNotNull(localItems)
+        this.cloudItem = Preconditions.checkNotNull(cloudItem)
+        this.syncNotifications = Preconditions.checkNotNull(syncNotifications)
+        this.notificationAction = Preconditions.checkNotNull(notificationAction)
+        this.uploadToEmpty = uploadToEmpty
+        this.protectLocal = protectLocal
+        this.started = started
+        syncResult = SyncItemResult(SyncItemResult.Status.FAILS_COUNT)
+        uploaded = 0
+        downloaded = 0
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItemResult.java b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItemResult.java
deleted file mode 100644
index 8e7aba5..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItemResult.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync;
-
-class SyncItemResult {
-
-    public enum Status {FAILS_COUNT, DB_ACCESS_ERROR, SOURCE_NOT_READY}
-
-    private final Status status;
-    private int failsCount;
-
-    public SyncItemResult(Status status) {
-        this.status = status;
-        failsCount = 0;
-    }
-
-    public boolean isDbAccessError() {
-        return status == Status.DB_ACCESS_ERROR;
-    }
-
-    public boolean isSourceNotReady() {
-        return status == Status.SOURCE_NOT_READY;
-    }
-
-    public int getFailsCount() {
-        return failsCount;
-    }
-
-    public void incFailsCount() {
-        failsCount++;
-    }
-
-    public boolean isSuccess() {
-        return status == Status.FAILS_COUNT && failsCount == 0;
-    }
-
-    public boolean isFatal() {
-        return status == Status.DB_ACCESS_ERROR || status == Status.SOURCE_NOT_READY;
-    }
-}
-
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItemResult.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItemResult.kt
new file mode 100644
index 0000000..494e83e
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncItemResult.kt
@@ -0,0 +1,124 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import android.content.Intent
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.content.ContentValues
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import android.content.AbstractThreadedSyncAdapter
+import android.content.ContentProviderClient
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+
+class SyncItemResult(private val status: Status) {
+    enum class Status {
+        FAILS_COUNT, DB_ACCESS_ERROR, SOURCE_NOT_READY
+    }
+
+    var failsCount = 0
+        private set
+    val isDbAccessError: Boolean
+        get() = status == Status.DB_ACCESS_ERROR
+    val isSourceNotReady: Boolean
+        get() = status == Status.SOURCE_NOT_READY
+
+    fun incFailsCount() {
+        failsCount++
+    }
+
+    val isSuccess: Boolean
+        get() = status == Status.FAILS_COUNT && failsCount == 0
+    val isFatal: Boolean
+        get() = status == Status.DB_ACCESS_ERROR || status == Status.SOURCE_NOT_READY
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncNotifications.java b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncNotifications.java
deleted file mode 100644
index fb50edb..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncNotifications.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import android.app.Notification;
-import android.app.NotificationChannel;
-import android.app.NotificationManager;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.os.Build;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.core.app.NotificationCompat;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.ContextCompat;
-
-import com.bytesforge.linkasanote.BuildConfig;
-import com.bytesforge.linkasanote.R;
-
-public class SyncNotifications {
-    private static final String TAG = SyncNotifications.class.getSimpleName();
-
-    private static final String CHANNEL_NAME_SYNC = "sync_channel";
-
-    public static final String ACTION_SYNC = BuildConfig.APPLICATION_ID + ".ACTION_SYNC";
-    public static final String ACTION_SYNC_LINKS =
-            BuildConfig.APPLICATION_ID + ".ACTION_SYNC_LINKS";
-    public static final String ACTION_SYNC_FAVORITES =
-            BuildConfig.APPLICATION_ID + ".ACTION_SYNC_FAVORITES";
-    public static final String ACTION_SYNC_NOTES =
-            BuildConfig.APPLICATION_ID + ".ACTION_SYNC_NOTES";
-
-    public static final String EXTRA_ACCOUNT_NAME = "ACCOUNT_NAME";
-    public static final String EXTRA_STATUS = "STATUS";
-    public static final String EXTRA_ID = "ID";
-    public static final String EXTRA_COUNT = "COUNT";
-
-    public static final int STATUS_SYNC_START = 10;
-    public static final int STATUS_SYNC_STOP = 11;
-    public static final int STATUS_CREATED = 20;
-    public static final int STATUS_UPDATED = 21;
-    public static final int STATUS_DELETED = 22;
-    public static final int STATUS_UPLOADED = 30;
-    public static final int STATUS_DOWNLOADED = 31;
-
-    private static final int NOTIFICATION_SYNC = 0;
-
-    private final Context context;
-    private final NotificationManagerCompat notificationManager;
-    private String accountName;
-
-    public SyncNotifications(Context context) {
-        this.context = context;
-        notificationManager = NotificationManagerCompat.from(context);
-        initChannels(this.context);
-    }
-
-    public void sendSyncBroadcast(String action, int status) {
-        sendSyncBroadcast(action, status, null, -1);
-    }
-
-    public void sendSyncBroadcast(String action, int status, String id) {
-        sendSyncBroadcast(action, status, id, -1);
-    }
-
-    public void sendSyncBroadcast(String action, int status, String id, int count) {
-        checkNotNull(accountName);
-        Intent intent = new Intent(action);
-        intent.putExtra(EXTRA_ACCOUNT_NAME, accountName);
-        if (status >= 0) intent.putExtra(EXTRA_STATUS, status);
-        if (id != null) intent.putExtra(EXTRA_ID, id);
-        if (count >= 0) intent.putExtra(EXTRA_COUNT, count);
-
-        context.sendBroadcast(intent);
-    }
-
-    public void notifyFailedSynchronization(@NonNull String text) {
-        checkNotNull(text);
-        notifyFailedSynchronization(null, text);
-    }
-
-    private void initChannels(Context context) {
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) return;
-
-        NotificationManager notificationManager =
-                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-        if (notificationManager == null) {
-            Log.e(TAG, "Error while retrieving Notification Service");
-            return;
-        }
-        NotificationChannel channel = new NotificationChannel(
-                CHANNEL_NAME_SYNC,
-                context.getString(R.string.sync_adapter_sync_channel_name),
-                NotificationManager.IMPORTANCE_DEFAULT);
-        channel.setDescription(context.getString(R.string.sync_adapter_sync_channel_description));
-        notificationManager.createNotificationChannel(channel);
-    }
-
-    public void notifyFailedSynchronization(String title, @NonNull String text) {
-        checkNotNull(text);
-        //notificationManager.cancel(NOTIFICATION_SYNC);
-        String defaultTitle = context.getString(R.string.sync_adapter_title_failed_default);
-        String notificationTitle = title == null ? defaultTitle : defaultTitle + ": " + title;
-
-        int color = ContextCompat.getColor(context, R.color.color_primary);
-        Notification notification = new NotificationCompat.Builder(context, CHANNEL_NAME_SYNC)
-                .setSmallIcon(R.drawable.ic_error_white)
-                .setLargeIcon(getLauncherBitmap())
-                .setColor(color)
-                .setTicker(notificationTitle)
-                .setContentTitle(notificationTitle)
-                .setContentText(text)
-                .build();
-        notificationManager.notify(NOTIFICATION_SYNC, notification);
-    }
-
-    private Bitmap getLauncherBitmap() {
-        Drawable logo = ContextCompat.getDrawable(context, R.mipmap.ic_launcher);
-        if (logo instanceof BitmapDrawable) {
-            return ((BitmapDrawable) logo).getBitmap();
-        }
-        return null;
-    }
-
-    public void setAccountName(String accountName) {
-        this.accountName = accountName;
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncNotifications.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncNotifications.kt
new file mode 100644
index 0000000..71f5f04
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncNotifications.kt
@@ -0,0 +1,189 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import android.content.*
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import android.os.*
+import android.util.Log
+import com.bytesforge.linkasanote.BuildConfig
+import com.google.common.base.Preconditions
+
+class SyncNotifications(private val context: Context?) {
+    private val notificationManager: NotificationManagerCompat
+    private var accountName: String? = null
+    @JvmOverloads
+    fun sendSyncBroadcast(action: String?, status: Int, id: String? = null, count: Int = -1) {
+        Preconditions.checkNotNull(accountName)
+        val intent = Intent(action)
+        intent.putExtra(EXTRA_ACCOUNT_NAME, accountName)
+        if (status >= 0) intent.putExtra(EXTRA_STATUS, status)
+        if (id != null) intent.putExtra(EXTRA_ID, id)
+        if (count >= 0) intent.putExtra(EXTRA_COUNT, count)
+        context!!.sendBroadcast(intent)
+    }
+
+    fun notifyFailedSynchronization(text: String) {
+        Preconditions.checkNotNull(text)
+        notifyFailedSynchronization(null, text)
+    }
+
+    private fun initChannels(context: Context?) {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) return
+        val notificationManager =
+            context!!.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
+        if (notificationManager == null) {
+            Log.e(TAG, "Error while retrieving Notification Service")
+            return
+        }
+        val channel = NotificationChannel(
+            CHANNEL_NAME_SYNC,
+            context.getString(R.string.sync_adapter_sync_channel_name),
+            NotificationManager.IMPORTANCE_DEFAULT
+        )
+        channel.description = context.getString(R.string.sync_adapter_sync_channel_description)
+        notificationManager.createNotificationChannel(channel)
+    }
+
+    fun notifyFailedSynchronization(title: String?, text: String) {
+        Preconditions.checkNotNull(text)
+        //notificationManager.cancel(NOTIFICATION_SYNC);
+        val defaultTitle = context!!.getString(R.string.sync_adapter_title_failed_default)
+        val notificationTitle = if (title == null) defaultTitle else "$defaultTitle: $title"
+        val color = ContextCompat.getColor(context, R.color.color_primary)
+        val notification = NotificationCompat.Builder(context, CHANNEL_NAME_SYNC)
+            .setSmallIcon(R.drawable.ic_error_white)
+            .setLargeIcon(launcherBitmap)
+            .setColor(color)
+            .setTicker(notificationTitle)
+            .setContentTitle(notificationTitle)
+            .setContentText(text)
+            .build()
+        notificationManager.notify(NOTIFICATION_SYNC, notification)
+    }
+
+    private val launcherBitmap: Bitmap?
+        private get() {
+            val logo = ContextCompat.getDrawable(context!!, R.mipmap.ic_launcher)
+            return if (logo is BitmapDrawable) {
+                logo.bitmap
+            } else null
+        }
+
+    fun setAccountName(accountName: String?) {
+        this.accountName = accountName
+    }
+
+    companion object {
+        private val TAG = SyncNotifications::class.java.simpleName
+        private const val CHANNEL_NAME_SYNC = "sync_channel"
+        const val ACTION_SYNC = BuildConfig.APPLICATION_ID + ".ACTION_SYNC"
+        const val ACTION_SYNC_LINKS = BuildConfig.APPLICATION_ID + ".ACTION_SYNC_LINKS"
+        const val ACTION_SYNC_FAVORITES = BuildConfig.APPLICATION_ID + ".ACTION_SYNC_FAVORITES"
+        const val ACTION_SYNC_NOTES = BuildConfig.APPLICATION_ID + ".ACTION_SYNC_NOTES"
+        const val EXTRA_ACCOUNT_NAME = "ACCOUNT_NAME"
+        const val EXTRA_STATUS = "STATUS"
+        const val EXTRA_ID = "ID"
+        const val EXTRA_COUNT = "COUNT"
+        const val STATUS_SYNC_START = 10
+        const val STATUS_SYNC_STOP = 11
+        const val STATUS_CREATED = 20
+        const val STATUS_UPDATED = 21
+        const val STATUS_DELETED = 22
+        const val STATUS_UPLOADED = 30
+        const val STATUS_DOWNLOADED = 31
+        private const val NOTIFICATION_SYNC = 0
+    }
+
+    init {
+        notificationManager = NotificationManagerCompat.from(context!!)
+        initChannels(context)
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncService.java b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncService.java
deleted file mode 100644
index 6569c80..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncService.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync;
-
-import android.accounts.AccountManager;
-import android.app.Service;
-import android.content.Context;
-import android.content.Intent;
-import android.os.IBinder;
-
-import androidx.annotation.Nullable;
-
-import com.bytesforge.linkasanote.LaanoApplication;
-import com.bytesforge.linkasanote.data.Favorite;
-import com.bytesforge.linkasanote.data.Link;
-import com.bytesforge.linkasanote.data.Note;
-import com.bytesforge.linkasanote.data.source.cloud.CloudItem;
-import com.bytesforge.linkasanote.data.source.local.LocalFavorites;
-import com.bytesforge.linkasanote.data.source.local.LocalLinks;
-import com.bytesforge.linkasanote.data.source.local.LocalNotes;
-import com.bytesforge.linkasanote.data.source.local.LocalSyncResults;
-import com.bytesforge.linkasanote.settings.Settings;
-
-import javax.inject.Inject;
-
-public class SyncService extends Service {
-
-    // NOTE: the application context is used here, so no way to leak it somehow
-    private static SyncAdapter syncAdapter = null;
-    private static final Object syncAdapterLock = new Object();
-
-    @Inject
-    Context context;
-
-    @Inject
-    Settings settings;
-
-    @Inject
-    AccountManager accountManager;
-
-    @Inject
-    LocalSyncResults localSyncResults;
-
-    @Inject
-    LocalLinks<Link> localLinks;
-
-    @Inject
-    CloudItem<Link> cloudLinks;
-
-    @Inject
-    LocalFavorites<Favorite> localFavorites;
-
-    @Inject
-    CloudItem<Favorite> cloudFavorites;
-
-    @Inject
-    LocalNotes<Note> localNotes;
-
-    @Inject
-    CloudItem<Note> cloudNotes;
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        LaanoApplication application = (LaanoApplication) getApplication();
-        application.getApplicationComponent().inject(this);
-
-        synchronized (syncAdapterLock) {
-            if (syncAdapter == null) {
-                SyncNotifications syncNotifications = new SyncNotifications(context);
-                syncAdapter = new SyncAdapter(
-                        context, settings, true, accountManager, syncNotifications,
-                        localSyncResults,
-                        localLinks, cloudLinks,
-                        localFavorites, cloudFavorites,
-                        localNotes, cloudNotes);
-            }
-        }
-    }
-
-    @Nullable
-    @Override
-    public IBinder onBind(Intent intent) {
-        return syncAdapter.getSyncAdapterBinder();
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncService.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncService.kt
new file mode 100644
index 0000000..cf0ec3b
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncService.kt
@@ -0,0 +1,172 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import android.app.Service
+import android.content.*
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import com.bytesforge.linkasanote.data.Link
+import com.bytesforge.linkasanote.data.Note
+import com.bytesforge.linkasanote.settings.Settings
+
+class SyncService : Service() {
+    @JvmField
+    @Inject
+    var context: Context? = null
+
+    @JvmField
+    @Inject
+    var settings: Settings? = null
+
+    @JvmField
+    @Inject
+    var accountManager: AccountManager? = null
+
+    @JvmField
+    @Inject
+    var localSyncResults: LocalSyncResults? = null
+
+    @JvmField
+    @Inject
+    var localLinks: LocalLinks<Link>? = null
+
+    @JvmField
+    @Inject
+    var cloudLinks: CloudItem<Link>? = null
+
+    @JvmField
+    @Inject
+    var localFavorites: LocalFavorites<Favorite>? = null
+
+    @JvmField
+    @Inject
+    var cloudFavorites: CloudItem<Favorite>? = null
+
+    @JvmField
+    @Inject
+    var localNotes: LocalNotes<Note>? = null
+
+    @JvmField
+    @Inject
+    var cloudNotes: CloudItem<Note>? = null
+    override fun onCreate() {
+        super.onCreate()
+        val application = application as LaanoApplication
+        application.applicationComponent.inject(this)
+        synchronized(syncAdapterLock) {
+            if (syncAdapter == null) {
+                val syncNotifications = SyncNotifications(context)
+                syncAdapter = SyncAdapter(
+                    context, settings, true, accountManager, syncNotifications,
+                    localSyncResults,
+                    localLinks, cloudLinks,
+                    localFavorites, cloudFavorites,
+                    localNotes, cloudNotes
+                )
+            }
+        }
+    }
+
+    override fun onBind(intent: Intent): IBinder? {
+        return syncAdapter!!.syncAdapterBinder
+    }
+
+    companion object {
+        // NOTE: the application context is used here, so no way to leak it somehow
+        private var syncAdapter: SyncAdapter? = null
+        private val syncAdapterLock = Any()
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncState.java b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncState.java
deleted file mode 100644
index 77e86ba..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncState.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.bytesforge.linkasanote.data.source.local.BaseEntry;
-import com.google.common.base.Objects;
-
-public class SyncState implements Parcelable {
-
-    private final long rowId;
-
-    private final int duplicated;
-    private final boolean conflicted;
-    private final boolean deleted;
-    private final boolean synced;
-
-    @Nullable
-    private String eTag;
-
-    public static final Creator<SyncState> CREATOR = new Creator<SyncState>() {
-
-        @Override
-        public SyncState createFromParcel(Parcel source) {
-            return new SyncState(source);
-        }
-
-        @Override
-        public SyncState[] newArray(int size) {
-            return new SyncState[size];
-        }
-    };
-
-    @Override
-    public int describeContents() {
-        return super.hashCode();
-    }
-
-    @Override
-    public void writeToParcel(Parcel dest, int flags) {
-        dest.writeLong(rowId);
-        dest.writeString(eTag);
-        dest.writeInt(duplicated);
-        dest.writeInt(conflicted ? 1 : 0);
-        dest.writeInt(deleted ? 1 : 0);
-        dest.writeInt(synced ? 1 : 0);
-    }
-
-    public enum State {
-        UNSYNCED, SYNCED, DELETED, CONFLICTED_UPDATE, CONFLICTED_DELETE}
-
-    public SyncState() {
-        // UNSYNCED
-        this(-1, null, 0, false, false, false);
-    }
-
-    private SyncState(
-            long rowId, @Nullable String eTag,
-            int duplicated, boolean conflicted, boolean deleted, boolean synced) {
-        this.rowId = rowId;
-        this.eTag = eTag;
-        this.duplicated = duplicated;
-        this.conflicted = conflicted;
-        this.deleted = deleted;
-        this.synced = synced;
-    }
-
-    protected SyncState(Parcel source) {
-        rowId = source.readLong();
-        eTag = source.readString();
-        duplicated = source.readInt();
-        conflicted = source.readInt() != 0;
-        deleted = source.readInt() != 0;
-        synced = source.readInt() != 0;
-    }
-
-    public SyncState(SyncState syncState, @NonNull final State state) {
-        checkNotNull(state);
-        if (syncState == null) {
-            syncState = new SyncState();
-        }
-        rowId = syncState.getRowId();
-        eTag = syncState.getETag();
-        duplicated = syncState.getDuplicated();
-        switch (state) {
-            case UNSYNCED: // cds
-                conflicted = syncState.isConflicted();
-                deleted = syncState.isDeleted();
-                synced = false;
-                break;
-            case SYNCED: // cdS
-                conflicted = syncState.isConflicted();
-                deleted = false;
-                synced = true;
-                break;
-            case DELETED: // cDs, cDS successfully deleted (delete record)
-                conflicted = syncState.isConflicted();
-                deleted = true;
-                synced = false;
-                break;
-            case CONFLICTED_UPDATE: // Cds, CdS successfully resolved (syncedState)
-                // NOTE: Local record was updated and Cloud one was modified or deleted
-                conflicted = true;
-                deleted = false;
-                synced = false;
-                break;
-            case CONFLICTED_DELETE: // CDs, CDS successfully resolved (syncedState)
-                // NOTE: Local record was deleted and Cloud one was modified
-                conflicted = true;
-                deleted = true;
-                synced = false;
-                break;
-            default:
-                throw new IllegalArgumentException("Unexpected state was provided [" + state.name() + "]");
-        }
-    }
-
-    public SyncState(State state) {
-        this((SyncState) null, state);
-    }
-
-    public SyncState(@Nullable String eTag, int duplicated) {
-        if (eTag == null) {
-            throw new IllegalArgumentException("Duplicate conflict state must be constructed with valid eTag");
-        }
-        if (duplicated <= 0) {
-            throw new IllegalArgumentException("Cannot setup duplicate conflict state for primary record");
-        }
-        rowId = -1;
-        this.eTag = eTag;
-        // CONFLICTED_DUPLICATE: CdS && duplicated > 0, duplicated = 0 resolved (otherState)
-        this.duplicated = duplicated;
-        conflicted = true;
-        deleted = false;
-        synced = true;
-    }
-
-    public SyncState(@NonNull String eTag, State state) {
-        this(state);
-        this.eTag = checkNotNull(eTag);
-    }
-
-    public ContentValues getContentValues() {
-        ContentValues values = new ContentValues();
-
-        // NOTE: rowId must not be here
-        if (eTag != null) {
-            // NOTE: lets DB maintain the default value
-            values.put(BaseEntry.COLUMN_NAME_ETAG, eTag);
-        }
-        values.put(BaseEntry.COLUMN_NAME_DUPLICATED, duplicated);
-        values.put(BaseEntry.COLUMN_NAME_CONFLICTED, conflicted);
-        values.put(BaseEntry.COLUMN_NAME_DELETED, deleted);
-        values.put(BaseEntry.COLUMN_NAME_SYNCED, synced);
-
-        return values;
-    }
-
-    public static SyncState from(Cursor cursor) {
-        long rowId = cursor.getLong(cursor.getColumnIndexOrThrow(BaseEntry._ID));
-
-        String eTag = cursor.getString(cursor.getColumnIndexOrThrow(
-                BaseEntry.COLUMN_NAME_ETAG));
-        int duplicated = cursor.getInt(cursor.getColumnIndexOrThrow(
-                BaseEntry.COLUMN_NAME_DUPLICATED));
-        boolean conflicted = cursor.getInt(cursor.getColumnIndexOrThrow(
-                BaseEntry.COLUMN_NAME_CONFLICTED)) == 1;
-        boolean deleted = cursor.getInt(cursor.getColumnIndexOrThrow(
-                BaseEntry.COLUMN_NAME_DELETED)) == 1;
-        boolean synced = cursor.getInt(cursor.getColumnIndexOrThrow(
-                BaseEntry.COLUMN_NAME_SYNCED)) == 1;
-
-        return new SyncState(rowId, eTag, duplicated, conflicted, deleted, synced);
-    }
-
-    public static SyncState from(ContentValues values) {
-        long rowId = values.getAsLong(BaseEntry._ID);
-
-        String eTag = values.getAsString(BaseEntry.COLUMN_NAME_ETAG);
-        int duplicated = values.getAsInteger(BaseEntry.COLUMN_NAME_DUPLICATED);
-        boolean conflicted = values.getAsBoolean(BaseEntry.COLUMN_NAME_CONFLICTED);
-        boolean deleted = values.getAsBoolean(BaseEntry.COLUMN_NAME_DELETED);
-        boolean synced = values.getAsBoolean(BaseEntry.COLUMN_NAME_SYNCED);
-
-        return new SyncState(rowId, eTag, duplicated, conflicted, deleted, synced);
-    }
-
-    public long getRowId() {
-        return rowId;
-    }
-
-    @Nullable
-    public String getETag() {
-        return eTag;
-    }
-
-    public int getDuplicated() {
-        return duplicated;
-    }
-
-    public boolean isDuplicated() {
-        return duplicated != 0;
-    }
-
-    public boolean isConflicted() {
-        return conflicted;
-    }
-
-    public boolean isDeleted() {
-        return deleted;
-    }
-
-    public boolean isSynced() {
-        return synced;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hashCode(rowId, eTag, duplicated, conflicted, deleted, synced);
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/SyncState.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncState.kt
new file mode 100644
index 0000000..43ff723
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/SyncState.kt
@@ -0,0 +1,289 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import android.content.Intent
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.content.ContentValues
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.Favorite
+import android.content.AbstractThreadedSyncAdapter
+import android.content.ContentProviderClient
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import android.database.Cursor
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import com.bytesforge.linkasanote.data.source.local.*
+import com.google.common.base.Objects
+import com.google.common.base.Preconditions
+import java.lang.IllegalArgumentException
+
+class SyncState : Parcelable {
+    val rowId: Long
+    val duplicated: Int
+    val isConflicted: Boolean
+    val isDeleted: Boolean
+    val isSynced: Boolean
+    var eTag: String?
+        private set
+
+    override fun describeContents(): Int {
+        return super.hashCode()
+    }
+
+    override fun writeToParcel(dest: Parcel, flags: Int) {
+        dest.writeLong(rowId)
+        dest.writeString(eTag)
+        dest.writeInt(duplicated)
+        dest.writeInt(if (isConflicted) 1 else 0)
+        dest.writeInt(if (isDeleted) 1 else 0)
+        dest.writeInt(if (isSynced) 1 else 0)
+    }
+
+    enum class State {
+        UNSYNCED, SYNCED, DELETED, CONFLICTED_UPDATE, CONFLICTED_DELETE
+    }
+
+    constructor() : this(-1, null, 0, false, false, false) {
+        // UNSYNCED
+    }
+
+    private constructor(
+        rowId: Long, eTag: String?,
+        duplicated: Int, conflicted: Boolean, deleted: Boolean, synced: Boolean
+    ) {
+        this.rowId = rowId
+        this.eTag = eTag
+        this.duplicated = duplicated
+        isConflicted = conflicted
+        isDeleted = deleted
+        isSynced = synced
+    }
+
+    protected constructor(source: Parcel) {
+        rowId = source.readLong()
+        eTag = source.readString()
+        duplicated = source.readInt()
+        isConflicted = source.readInt() != 0
+        isDeleted = source.readInt() != 0
+        isSynced = source.readInt() != 0
+    }
+
+    constructor(syncState: SyncState?, state: State) {
+        var syncState = syncState
+        Preconditions.checkNotNull(state)
+        if (syncState == null) {
+            syncState = SyncState()
+        }
+        rowId = syncState.rowId
+        eTag = syncState.eTag
+        duplicated = syncState.duplicated
+        when (state) {
+            State.UNSYNCED -> {
+                isConflicted = syncState.isConflicted
+                isDeleted = syncState.isDeleted
+                isSynced = false
+            }
+            State.SYNCED -> {
+                isConflicted = syncState.isConflicted
+                isDeleted = false
+                isSynced = true
+            }
+            State.DELETED -> {
+                isConflicted = syncState.isConflicted
+                isDeleted = true
+                isSynced = false
+            }
+            State.CONFLICTED_UPDATE -> {
+                // NOTE: Local record was updated and Cloud one was modified or deleted
+                isConflicted = true
+                isDeleted = false
+                isSynced = false
+            }
+            State.CONFLICTED_DELETE -> {
+                // NOTE: Local record was deleted and Cloud one was modified
+                isConflicted = true
+                isDeleted = true
+                isSynced = false
+            }
+            else -> throw IllegalArgumentException("Unexpected state was provided [" + state.name + "]")
+        }
+    }
+
+    constructor(state: State) : this(null as SyncState?, state) {}
+    constructor(eTag: String?, duplicated: Int) {
+        requireNotNull(eTag) { "Duplicate conflict state must be constructed with valid eTag" }
+        require(duplicated > 0) { "Cannot setup duplicate conflict state for primary record" }
+        rowId = -1
+        this.eTag = eTag
+        // CONFLICTED_DUPLICATE: CdS && duplicated > 0, duplicated = 0 resolved (otherState)
+        this.duplicated = duplicated
+        isConflicted = true
+        isDeleted = false
+        isSynced = true
+    }
+
+    constructor(eTag: String, state: State) : this(state) {
+        this.eTag = Preconditions.checkNotNull(eTag)
+    }// NOTE: lets DB maintain the default value
+
+    // NOTE: rowId must not be here
+    val contentValues: ContentValues
+        get() {
+            val values = ContentValues()
+
+            // NOTE: rowId must not be here
+            if (eTag != null) {
+                // NOTE: lets DB maintain the default value
+                values.put(BaseEntry.COLUMN_NAME_ETAG, eTag)
+            }
+            values.put(BaseEntry.COLUMN_NAME_DUPLICATED, duplicated)
+            values.put(BaseEntry.COLUMN_NAME_CONFLICTED, isConflicted)
+            values.put(BaseEntry.COLUMN_NAME_DELETED, isDeleted)
+            values.put(BaseEntry.COLUMN_NAME_SYNCED, isSynced)
+            return values
+        }
+
+    fun isDuplicated(): Boolean {
+        return duplicated != 0
+    }
+
+    override fun hashCode(): Int {
+        return Objects.hashCode(rowId, eTag, duplicated, isConflicted, isDeleted, isSynced)
+    }
+
+    companion object {
+        val CREATOR: Parcelable.Creator<SyncState> = object : Parcelable.Creator<SyncState?> {
+            override fun createFromParcel(source: Parcel): SyncState? {
+                return SyncState(source)
+            }
+
+            override fun newArray(size: Int): Array<SyncState?> {
+                return arrayOfNulls(size)
+            }
+        }
+
+        fun from(cursor: Cursor): SyncState {
+            val rowId = cursor.getLong(cursor.getColumnIndexOrThrow(BaseEntry._ID))
+            val eTag = cursor.getString(
+                cursor.getColumnIndexOrThrow(
+                    BaseEntry.COLUMN_NAME_ETAG
+                )
+            )
+            val duplicated = cursor.getInt(
+                cursor.getColumnIndexOrThrow(
+                    BaseEntry.COLUMN_NAME_DUPLICATED
+                )
+            )
+            val conflicted = cursor.getInt(
+                cursor.getColumnIndexOrThrow(
+                    BaseEntry.COLUMN_NAME_CONFLICTED
+                )
+            ) == 1
+            val deleted = cursor.getInt(
+                cursor.getColumnIndexOrThrow(
+                    BaseEntry.COLUMN_NAME_DELETED
+                )
+            ) == 1
+            val synced = cursor.getInt(
+                cursor.getColumnIndexOrThrow(
+                    BaseEntry.COLUMN_NAME_SYNCED
+                )
+            ) == 1
+            return SyncState(rowId, eTag, duplicated, conflicted, deleted, synced)
+        }
+
+        @JvmStatic
+        fun from(values: ContentValues): SyncState {
+            val rowId = values.getAsLong(BaseEntry._ID)
+            val eTag = values.getAsString(BaseEntry.COLUMN_NAME_ETAG)
+            val duplicated = values.getAsInteger(BaseEntry.COLUMN_NAME_DUPLICATED)
+            val conflicted = values.getAsBoolean(BaseEntry.COLUMN_NAME_CONFLICTED)
+            val deleted = values.getAsBoolean(BaseEntry.COLUMN_NAME_DELETED)
+            val synced = values.getAsBoolean(BaseEntry.COLUMN_NAME_SYNCED)
+            return SyncState(rowId, eTag, duplicated, conflicted, deleted, synced)
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/files/JsonFile.java b/app/src/main/java/com/bytesforge/linkasanote/sync/files/JsonFile.java
deleted file mode 100644
index ed5f6a8..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/files/JsonFile.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync.files;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import android.net.Uri;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.bytesforge.linkasanote.utils.CloudUtils;
-import com.bytesforge.linkasanote.utils.UuidUtils;
-import com.google.common.base.Objects;
-
-import java.io.File;
-
-public class JsonFile implements Parcelable, Comparable<JsonFile> {
-
-    private static final String MIME_TYPE = "application/json";
-    private static final String FILE_EXTENSION = ".json";
-
-    public static final String PATH_SEPARATOR = "/";
-
-    private long length;
-    private String localPath;
-    private String remotePath;
-    private String eTag;
-
-    public static final Creator<JsonFile> CREATOR = new Creator<JsonFile>() {
-
-        @Override
-        public JsonFile createFromParcel(Parcel in) {
-            return new JsonFile(in);
-        }
-
-        @Override
-        public JsonFile[] newArray(int size) {
-            return new JsonFile[size];
-        }
-    };
-
-    public JsonFile(@NonNull String remotePath) {
-        checkNotNull(remotePath);
-
-        if (!remotePath.startsWith(PATH_SEPARATOR)) {
-            throw new IllegalArgumentException(
-                    "Remote path must be absolute [" + remotePath + "]");
-        }
-        length = 0;
-        localPath = null;
-        this.remotePath = remotePath;
-        eTag = null;
-    }
-
-    public JsonFile(@NonNull String localPath, @NonNull String remotePath) {
-        this(remotePath);
-        checkNotNull(localPath);
-
-        this.localPath = localPath;
-        File localFile = new File(localPath);
-        length = localFile.length();
-    }
-
-    protected JsonFile(Parcel in) {
-        length = in.readLong();
-        localPath = in.readString();
-        remotePath = in.readString();
-        eTag = in.readString();
-    }
-
-    @Override
-    public int describeContents() {
-        return super.hashCode();
-    }
-
-    @Override
-    public void writeToParcel(Parcel dest, int flags) {
-        dest.writeLong(length);
-        dest.writeString(localPath);
-        dest.writeString(remotePath);
-        dest.writeString(eTag);
-    }
-
-    @Override
-    public int compareTo(@NonNull JsonFile obj) {
-        return getRemotePath().compareToIgnoreCase(obj.getRemotePath());
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) return true;
-        if (obj == null || getClass() != obj.getClass()) return false;
-
-        JsonFile file = (JsonFile) obj;
-        return Objects.equal(remotePath, file.remotePath)
-                && Objects.equal(length, file.length);
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hashCode(length, localPath, remotePath, eTag);
-    }
-
-    // Getters & Setters
-
-    public String getRemotePath() {
-        return remotePath;
-    }
-
-    public String getLocalPath() {
-        return localPath;
-    }
-
-    public void setLocalPath(String localPath) {
-        this.localPath = localPath;
-    }
-
-    public void setLength(long length) {
-        this.length = length;
-    }
-
-    public String getMimeType() {
-        return MIME_TYPE;
-    }
-
-    public String getETag() {
-        return eTag;
-    }
-
-    public void setETag(String eTag) {
-        this.eTag = eTag;
-    }
-
-    @NonNull
-    public static String getFileName(@NonNull String id) {
-        return checkNotNull(id) + FILE_EXTENSION;
-    }
-
-    @NonNull
-    public static String getTempFileName(@NonNull String id) {
-        return checkNotNull(id) + "." + CloudUtils.getApplicationId();
-    }
-
-    @Nullable
-    public static String getId(String mimeType, String filePath) {
-        if (mimeType == null || filePath == null) return null;
-        if (!mimeType.equals(MIME_TYPE)) return null;
-
-        String id = Uri.parse(filePath).getLastPathSegment();
-        if (id != null && id.endsWith(FILE_EXTENSION)) {
-            id = id.substring(0, id.length() - FILE_EXTENSION.length());
-        } else {
-            return null;
-        }
-        if (UuidUtils.isKeyValidUuid(id)) {
-            return id;
-        }
-        return null;
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/files/JsonFile.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/files/JsonFile.kt
new file mode 100644
index 0000000..acc324b
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/files/JsonFile.kt
@@ -0,0 +1,211 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync.files
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import android.content.Intent
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.content.ContentValues
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import android.content.AbstractThreadedSyncAdapter
+import android.content.ContentProviderClient
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import android.net.Uri
+import com.google.common.base.Objects
+import com.google.common.base.Preconditions
+import java.io.File
+
+class JsonFile : Parcelable, Comparable<JsonFile> {
+    private var length: Long
+    var localPath: String?
+
+    // Getters & Setters
+    var remotePath: String?
+        private set
+    var eTag: String?
+
+    constructor(remotePath: String) {
+        Preconditions.checkNotNull(remotePath)
+        require(remotePath.startsWith(PATH_SEPARATOR)) { "Remote path must be absolute [$remotePath]" }
+        length = 0
+        localPath = null
+        this.remotePath = remotePath
+        eTag = null
+    }
+
+    constructor(localPath: String, remotePath: String) : this(remotePath) {
+        Preconditions.checkNotNull(localPath)
+        this.localPath = localPath
+        val localFile = File(localPath)
+        length = localFile.length()
+    }
+
+    protected constructor(`in`: Parcel) {
+        length = `in`.readLong()
+        localPath = `in`.readString()
+        remotePath = `in`.readString()
+        eTag = `in`.readString()
+    }
+
+    override fun describeContents(): Int {
+        return super.hashCode()
+    }
+
+    override fun writeToParcel(dest: Parcel, flags: Int) {
+        dest.writeLong(length)
+        dest.writeString(localPath)
+        dest.writeString(remotePath)
+        dest.writeString(eTag)
+    }
+
+    override fun compareTo(obj: JsonFile): Int {
+        return remotePath!!.compareTo(obj.remotePath!!, ignoreCase = true)
+    }
+
+    override fun equals(obj: Any?): Boolean {
+        if (this === obj) return true
+        if (obj == null || javaClass != obj.javaClass) return false
+        val file = obj as JsonFile
+        return (Objects.equal(remotePath, file.remotePath)
+                && Objects.equal(length, file.length))
+    }
+
+    override fun hashCode(): Int {
+        return Objects.hashCode(length, localPath, remotePath, eTag)
+    }
+
+    fun setLength(length: Long) {
+        this.length = length
+    }
+
+    companion object {
+        val mimeType = "application/json"
+            get() = Companion.field
+        private const val FILE_EXTENSION = ".json"
+        const val PATH_SEPARATOR = "/"
+        val CREATOR: Parcelable.Creator<JsonFile> = object : Parcelable.Creator<JsonFile?> {
+            override fun createFromParcel(`in`: Parcel): JsonFile? {
+                return JsonFile(`in`)
+            }
+
+            override fun newArray(size: Int): Array<JsonFile?> {
+                return arrayOfNulls(size)
+            }
+        }
+
+        @JvmStatic
+        fun getFileName(id: String): String {
+            return Preconditions.checkNotNull(id).toString() + FILE_EXTENSION
+        }
+
+        @JvmStatic
+        fun getTempFileName(id: String): String {
+            return Preconditions.checkNotNull(id).toString() + "." + CloudUtils.getApplicationId()
+        }
+
+        @JvmStatic
+        fun getId(mimeType: String?, filePath: String?): String? {
+            if (mimeType == null || filePath == null) return null
+            if (mimeType != Companion.mimeType) return null
+            var id = Uri.parse(filePath).lastPathSegment
+            id = if (id != null && id.endsWith(FILE_EXTENSION)) {
+                id.substring(0, id.length - FILE_EXTENSION.length)
+            } else {
+                return null
+            }
+            return if (UuidUtils.isKeyValidUuid(id)) {
+                id
+            } else null
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/OperationsService.java b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/OperationsService.java
deleted file mode 100644
index a35498f..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/OperationsService.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync.operations;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import android.accounts.Account;
-import android.accounts.AccountsException;
-import android.app.Service;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Binder;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
-import android.os.Process;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.VisibleForTesting;
-
-import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource;
-import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation;
-import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation;
-import com.google.common.base.Objects;
-import com.owncloud.android.lib.common.OwnCloudAccount;
-import com.owncloud.android.lib.common.OwnCloudClient;
-import com.owncloud.android.lib.common.OwnCloudClientManagerFactory;
-import com.owncloud.android.lib.common.operations.OnRemoteOperationListener;
-import com.owncloud.android.lib.common.operations.RemoteOperation;
-import com.owncloud.android.lib.common.operations.RemoteOperationResult;
-import com.owncloud.android.lib.resources.status.OwnCloudVersion;
-
-import java.io.IOException;
-import java.security.InvalidParameterException;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicInteger;
-
-public class OperationsService extends Service {
-
-    private static final String TAG = OperationsService.class.getSimpleName();
-    private AtomicInteger operationId = new AtomicInteger(0);
-
-    public static final String ACTION_GET_SERVER_INFO = "GET_SERVER_INFO";
-    public static final String ACTION_CHECK_CREDENTIALS = "CHECK_CREDENTIALS";
-    public static final String EXTRA_ACCOUNT = "ACCOUNT";
-    public static final String EXTRA_CREDENTIALS = "CREDENTIALS";
-    public static final String EXTRA_SERVER_URL = "SERVER_URL";
-    public static final String EXTRA_SERVER_VERSION = "SERVER_VERSION";
-
-    private final IBinder binder = new OperationsBinder();
-    private OperationsHandler operationsHandler;
-
-    private OwnCloudClient ocClient; // Cache
-    private final ConcurrentLinkedQueue<OperationItem> pendingOperations =
-            new ConcurrentLinkedQueue<>();
-
-    private static class Target {
-        public Account account = null;
-        public Uri serverUrl = null;
-
-        public Target(Account account, Uri serverUrl) {
-            this.account = account;
-            this.serverUrl = serverUrl;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (this == obj) return true;
-            if (obj == null || getClass() != obj.getClass()) return false;
-
-            Target target = (Target) obj;
-            return Objects.equal(account, target.account)
-                    && Objects.equal(serverUrl, target.serverUrl);
-        }
-    }
-
-    private static class OperationItem {
-        public final Target target;
-        public final RemoteOperation operation;
-        public final OnRemoteOperationListener listener;
-        public final Handler handler;
-
-        public OperationItem(
-                @NonNull Target target, @NonNull RemoteOperation operation,
-                OnRemoteOperationListener listener, Handler handler) {
-            this.target = checkNotNull(target);
-            this.operation = checkNotNull(operation);
-            this.listener = listener;
-            this.handler = handler;
-        }
-
-        private boolean hasListener() {
-            return (listener != null && handler != null);
-        }
-
-        public void dispatchResult(@NonNull final RemoteOperationResult result) {
-            if (hasListener()) {
-                handler.post(() -> listener.onRemoteOperationFinish(operation, result));
-            }
-        }
-    }
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        HandlerThread thread = new HandlerThread(
-                "Operations thread", Process.THREAD_PRIORITY_BACKGROUND);
-        thread.start();
-        operationsHandler = new OperationsHandler(thread.getLooper(), this);
-    }
-
-    @Nullable
-    @Override
-    public IBinder onBind(Intent intent) {
-        return binder;
-    }
-
-    public class OperationsBinder extends Binder {
-
-        public OperationsService getService() {
-            return OperationsService.this;
-        }
-    }
-
-    private class OperationsHandler extends Handler {
-
-        private OperationsService service;
-        private Target lastTarget;
-
-        public OperationsHandler(Looper looper, @NonNull OperationsService service) {
-            super(looper);
-            this.service = checkNotNull(service);
-            lastTarget = null;
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            OperationItem operationItem;
-            synchronized (pendingOperations) {
-                operationItem = pendingOperations.poll();
-            }
-            if (operationItem != null) {
-                RemoteOperationResult result = executeOperationItem(operationItem);
-                operationItem.dispatchResult(result);
-            }
-            Log.d(TAG, "End of processing message with id " + msg.arg1);
-        }
-
-        private RemoteOperationResult executeOperationItem(OperationItem item) {
-            RemoteOperationResult result;
-            try {
-                RemoteOperation operation = item.operation;
-                OwnCloudAccount account;
-                if (lastTarget == null || !lastTarget.equals(item.target)) {
-                    lastTarget = item.target;
-                    if (lastTarget.account != null) {
-                        account = new OwnCloudAccount(lastTarget.account, service);
-                    } else {
-                        account = new OwnCloudAccount(lastTarget.serverUrl, null);
-                    }
-                    ocClient = OwnCloudClientManagerFactory.getDefaultSingleton()
-                            .getClientFor(account, service);
-                }
-                result = CloudDataSource.executeRemoteOperation(operation, ocClient).blockingGet();
-            } catch (AccountsException | IOException e) {
-                result = new RemoteOperationResult(e);
-            }
-            return result;
-        }
-    }
-
-    public long queueOperation(Intent intent, OnRemoteOperationListener listener, Handler handler) {
-        Log.d(TAG, "Queuing message with id " + operationId);
-
-        OperationItem operationItem = buildOperation(intent, listener, handler);
-        pendingOperations.add(operationItem);
-
-        Message msg = operationsHandler.obtainMessage();
-        msg.arg1 = operationId.getAndIncrement();
-        operationsHandler.sendMessage(msg);
-
-        return operationItem.operation.hashCode();
-    }
-
-    @NonNull
-    private OperationItem buildOperation(
-            Intent intent, OnRemoteOperationListener listener, Handler handler) {
-        RemoteOperation operation;
-
-        if (!intent.hasExtra(EXTRA_ACCOUNT) && !intent.hasExtra(EXTRA_SERVER_URL)) {
-            throw new InvalidParameterException(
-                    "At least one of the following EXTRA must be specified: ACCOUNT, SERVER_URL");
-        }
-        Account account = intent.getParcelableExtra(EXTRA_ACCOUNT);
-        String serverUrl = intent.getStringExtra(EXTRA_SERVER_URL);
-        Target target = new Target(
-                account, (serverUrl == null) ? null : Uri.parse(serverUrl));
-
-        String action = intent.getAction();
-        switch (action) {
-            case ACTION_GET_SERVER_INFO:
-                operation = new GetServerInfoOperation(serverUrl, OperationsService.this);
-                break;
-            case ACTION_CHECK_CREDENTIALS:
-                Bundle credentials = intent.getBundleExtra(EXTRA_CREDENTIALS);
-                OwnCloudVersion serverVersion = new OwnCloudVersion(
-                        intent.getStringExtra(EXTRA_SERVER_VERSION));
-                operation = new CheckCredentialsOperation(credentials, serverVersion);
-                break;
-            default:
-                throw new UnsupportedOperationException("OperationItem not supported: " + action);
-        }
-        return new OperationItem(target, operation, listener, handler);
-    }
-
-    @VisibleForTesting
-    int getPendingOperationsQueueSize() {
-        return pendingOperations.size();
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/OperationsService.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/OperationsService.kt
new file mode 100644
index 0000000..d3512cc
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/OperationsService.kt
@@ -0,0 +1,283 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync.operations
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.content.Intent
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.content.ContentValues
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import android.content.AbstractThreadedSyncAdapter
+import android.content.ContentProviderClient
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import android.app.Service
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import android.net.Uri
+import android.os.*
+import android.util.Log
+import com.google.common.base.Objects
+import com.google.common.base.Preconditions
+import java.io.IOException
+import java.lang.UnsupportedOperationException
+import java.security.InvalidParameterException
+import java.util.concurrent.ConcurrentLinkedQueue
+import java.util.concurrent.atomic.AtomicInteger
+
+class OperationsService : Service() {
+    private val operationId = AtomicInteger(0)
+    private val binder: IBinder = OperationsBinder()
+    private var operationsHandler: OperationsHandler? = null
+    private var ocClient // Cache
+            : OwnCloudClient? = null
+    private val pendingOperations = ConcurrentLinkedQueue<OperationItem>()
+
+    private class Target(account: Account?, serverUrl: Uri?) {
+        var account: Account? = null
+        var serverUrl: Uri? = null
+        override fun equals(obj: Any?): Boolean {
+            if (this === obj) return true
+            if (obj == null || javaClass != obj.javaClass) return false
+            val target = obj as Target
+            return (Objects.equal(account, target.account)
+                    && Objects.equal(serverUrl, target.serverUrl))
+        }
+
+        init {
+            this.account = account
+            this.serverUrl = serverUrl
+        }
+    }
+
+    private class OperationItem(
+        target: Target, operation: RemoteOperation,
+        listener: OnRemoteOperationListener?, handler: Handler?
+    ) {
+        val target: Target
+        val operation: RemoteOperation
+        val listener: OnRemoteOperationListener?
+        val handler: Handler?
+        private fun hasListener(): Boolean {
+            return listener != null && handler != null
+        }
+
+        fun dispatchResult(result: RemoteOperationResult) {
+            if (hasListener()) {
+                handler!!.post { listener!!.onRemoteOperationFinish(operation, result) }
+            }
+        }
+
+        init {
+            this.target = Preconditions.checkNotNull(target)
+            this.operation = Preconditions.checkNotNull(operation)
+            this.listener = listener
+            this.handler = handler
+        }
+    }
+
+    override fun onCreate() {
+        super.onCreate()
+        val thread = HandlerThread(
+            "Operations thread", Process.THREAD_PRIORITY_BACKGROUND
+        )
+        thread.start()
+        operationsHandler = OperationsHandler(thread.looper, this)
+    }
+
+    override fun onBind(intent: Intent): IBinder? {
+        return binder
+    }
+
+    inner class OperationsBinder : Binder() {
+        val service: OperationsService
+            get() = this@OperationsService
+    }
+
+    private inner class OperationsHandler(looper: Looper?, service: OperationsService) : Handler(
+        looper!!
+    ) {
+        private val service: OperationsService
+        private var lastTarget: Target?
+        override fun handleMessage(msg: Message) {
+            super.handleMessage(msg)
+            var operationItem: OperationItem?
+            synchronized(pendingOperations) { operationItem = pendingOperations.poll() }
+            if (operationItem != null) {
+                val result = executeOperationItem(operationItem!!)
+                operationItem!!.dispatchResult(result)
+            }
+            Log.d(TAG, "End of processing message with id " + msg.arg1)
+        }
+
+        private fun executeOperationItem(item: OperationItem): RemoteOperationResult {
+            var result: RemoteOperationResult
+            try {
+                val operation = item.operation
+                val account: OwnCloudAccount
+                if (lastTarget == null || lastTarget != item.target) {
+                    lastTarget = item.target
+                    account = if (lastTarget!!.account != null) {
+                        OwnCloudAccount(lastTarget!!.account, service)
+                    } else {
+                        OwnCloudAccount(lastTarget!!.serverUrl, null)
+                    }
+                    ocClient = OwnCloudClientManagerFactory.getDefaultSingleton()
+                        .getClientFor(account, service)
+                }
+                result = CloudDataSource.executeRemoteOperation(operation, ocClient!!).blockingGet()
+            } catch (e: AccountsException) {
+                result = RemoteOperationResult(e)
+            } catch (e: IOException) {
+                result = RemoteOperationResult(e)
+            }
+            return result
+        }
+
+        init {
+            this.service = Preconditions.checkNotNull(service)
+            lastTarget = null
+        }
+    }
+
+    fun queueOperation(
+        intent: Intent,
+        listener: OnRemoteOperationListener,
+        handler: Handler
+    ): Long {
+        Log.d(TAG, "Queuing message with id $operationId")
+        val operationItem = buildOperation(intent, listener, handler)
+        pendingOperations.add(operationItem)
+        val msg = operationsHandler!!.obtainMessage()
+        msg.arg1 = operationId.getAndIncrement()
+        operationsHandler!!.sendMessage(msg)
+        return operationItem.operation.hashCode().toLong()
+    }
+
+    private fun buildOperation(
+        intent: Intent, listener: OnRemoteOperationListener, handler: Handler
+    ): OperationItem {
+        val operation: RemoteOperation
+        if (!intent.hasExtra(EXTRA_ACCOUNT) && !intent.hasExtra(EXTRA_SERVER_URL)) {
+            throw InvalidParameterException(
+                "At least one of the following EXTRA must be specified: ACCOUNT, SERVER_URL"
+            )
+        }
+        val account = intent.getParcelableExtra<Account>(EXTRA_ACCOUNT)
+        val serverUrl = intent.getStringExtra(EXTRA_SERVER_URL)
+        val target = Target(
+            account, if (serverUrl == null) null else Uri.parse(serverUrl)
+        )
+        val action = intent.action
+        operation = when (action) {
+            ACTION_GET_SERVER_INFO -> GetServerInfoOperation(
+                serverUrl,
+                this@OperationsService
+            )
+            ACTION_CHECK_CREDENTIALS -> {
+                val credentials = intent.getBundleExtra(EXTRA_CREDENTIALS)
+                val serverVersion = OwnCloudVersion(
+                    intent.getStringExtra(EXTRA_SERVER_VERSION)
+                )
+                CheckCredentialsOperation(credentials, serverVersion)
+            }
+            else -> throw UnsupportedOperationException("OperationItem not supported: $action")
+        }
+        return OperationItem(target, operation, listener, handler)
+    }
+
+    @get:VisibleForTesting
+    val pendingOperationsQueueSize: Int
+        get() = pendingOperations.size
+
+    companion object {
+        private val TAG = OperationsService::class.java.simpleName
+        const val ACTION_GET_SERVER_INFO = "GET_SERVER_INFO"
+        const val ACTION_CHECK_CREDENTIALS = "CHECK_CREDENTIALS"
+        const val EXTRA_ACCOUNT = "ACCOUNT"
+        const val EXTRA_CREDENTIALS = "CREDENTIALS"
+        const val EXTRA_SERVER_URL = "SERVER_URL"
+        const val EXTRA_SERVER_VERSION = "SERVER_VERSION"
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/CheckCredentialsOperation.java b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/CheckCredentialsOperation.java
deleted file mode 100644
index 639b38e..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/CheckCredentialsOperation.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync.operations.nextcloud;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import android.os.Bundle;
-
-import androidx.annotation.NonNull;
-
-import com.owncloud.android.lib.common.OwnCloudClient;
-import com.owncloud.android.lib.common.OwnCloudCredentials;
-import com.owncloud.android.lib.common.OwnCloudCredentialsFactory;
-import com.owncloud.android.lib.common.network.RedirectionPath;
-import com.owncloud.android.lib.common.operations.RemoteOperation;
-import com.owncloud.android.lib.common.operations.RemoteOperationResult;
-import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation;
-import com.owncloud.android.lib.resources.status.OwnCloudVersion;
-import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation;
-
-public class CheckCredentialsOperation extends RemoteOperation {
-
-    public static final String ACCOUNT_USERNAME = "USERNAME";
-    public static final String ACCOUNT_PASSWORD = "PASSWORD";
-
-    private static final String ROOT_PATH = "/";
-
-    private final String username;
-    private final String password;
-    private final OwnCloudVersion serverVersion;
-
-    public CheckCredentialsOperation(Bundle credentials, OwnCloudVersion serverVersion) {
-        username = credentials.getString(ACCOUNT_USERNAME);
-        password = credentials.getString(ACCOUNT_PASSWORD);
-        this.serverVersion = serverVersion;
-    }
-
-    @Override
-    protected RemoteOperationResult run(@NonNull OwnCloudClient ocClient) {
-        checkNotNull(ocClient);
-
-        OwnCloudCredentials credentials =
-                OwnCloudCredentialsFactory.newBasicCredentials(username, password);
-        ocClient.setCredentials(credentials);
-        ocClient.setOwnCloudVersion(serverVersion);
-        ocClient.setFollowRedirects(true);
-
-        ExistenceCheckRemoteOperation checkOperation =
-                new ExistenceCheckRemoteOperation(ROOT_PATH, false);
-        RemoteOperationResult result = checkOperation.execute(ocClient);
-        if (checkOperation.wasRedirected()) {
-            RedirectionPath path = checkOperation.getRedirectionPath();
-            String location = path.getLastPermanentLocation();
-            result.setLastPermanentLocation(location);
-        }
-        if (result.isSuccess()) {
-            // NOTE: user display name is updated during synchronization
-            GetRemoteUserInfoOperation infoOperation = new GetRemoteUserInfoOperation();
-            result = infoOperation.execute(ocClient);
-        }
-        if (result.isSuccess()) {
-            result.getData().add(credentials);
-        }
-        return result;
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/CheckCredentialsOperation.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/CheckCredentialsOperation.kt
new file mode 100644
index 0000000..7ddb4c5
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/CheckCredentialsOperation.kt
@@ -0,0 +1,145 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync.operations.nextcloud
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import android.content.Intent
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.content.ContentValues
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import android.content.AbstractThreadedSyncAdapter
+import android.content.ContentProviderClient
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import com.google.common.base.Preconditions
+
+class CheckCredentialsOperation(credentials: Bundle?, serverVersion: OwnCloudVersion) :
+    RemoteOperation() {
+    private val username: String?
+    private val password: String?
+    private val serverVersion: OwnCloudVersion
+    override fun run(ocClient: OwnCloudClient): RemoteOperationResult {
+        Preconditions.checkNotNull(ocClient)
+        val credentials = OwnCloudCredentialsFactory.newBasicCredentials(username, password)
+        ocClient.credentials = credentials
+        ocClient.ownCloudVersion = serverVersion
+        ocClient.isFollowRedirects = true
+        val checkOperation = ExistenceCheckRemoteOperation(ROOT_PATH, false)
+        var result = checkOperation.execute(ocClient)
+        if (checkOperation.wasRedirected()) {
+            val path = checkOperation.redirectionPath
+            val location = path.lastPermanentLocation
+            result.lastPermanentLocation = location
+        }
+        if (result.isSuccess) {
+            // NOTE: user display name is updated during synchronization
+            val infoOperation = GetRemoteUserInfoOperation()
+            result = infoOperation.execute(ocClient)
+        }
+        if (result.isSuccess) {
+            result.data.add(credentials)
+        }
+        return result
+    }
+
+    companion object {
+        const val ACCOUNT_USERNAME = "USERNAME"
+        const val ACCOUNT_PASSWORD = "PASSWORD"
+        private const val ROOT_PATH = "/"
+    }
+
+    init {
+        username = credentials!!.getString(ACCOUNT_USERNAME)
+        password = credentials.getString(ACCOUNT_PASSWORD)
+        this.serverVersion = serverVersion
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/GetServerInfoOperation.java b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/GetServerInfoOperation.java
deleted file mode 100644
index e91d47a..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/GetServerInfoOperation.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync.operations.nextcloud;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import android.content.Context;
-
-import androidx.annotation.NonNull;
-
-import com.owncloud.android.lib.common.OwnCloudClient;
-import com.owncloud.android.lib.common.operations.RemoteOperation;
-import com.owncloud.android.lib.common.operations.RemoteOperationResult;
-import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation;
-import com.owncloud.android.lib.resources.status.OwnCloudVersion;
-
-import java.util.ArrayList;
-
-
-public class GetServerInfoOperation extends RemoteOperation {
-
-    private String serverUrl;
-    private ServerInfo serverInfo = new ServerInfo();
-
-    @NonNull
-    private Context context;
-
-    public GetServerInfoOperation(String url, @NonNull Context context) {
-        serverUrl = url;
-        this.context = checkNotNull(context);
-    }
-
-    @Override
-    protected RemoteOperationResult run(@NonNull OwnCloudClient ocClient) {
-        checkNotNull(ocClient);
-
-        GetRemoteStatusOperation statusOperation = new GetRemoteStatusOperation(context);
-        RemoteOperationResult result = statusOperation.execute(ocClient);
-        if (result.isSuccess()) {
-            serverInfo.version = (OwnCloudVersion) result.getData().get(0);
-            serverInfo.isSecure = (result.getCode() == RemoteOperationResult.ResultCode.OK_SSL);
-            serverInfo.baseUrl = serverUrl;
-
-            ArrayList<Object> data = new ArrayList<>();
-            data.add(serverInfo);
-            result.setData(data);
-        }
-        return result;
-    }
-
-    public static class ServerInfo {
-
-        public OwnCloudVersion version = null;
-        public String baseUrl = null;
-        public boolean isSecure = false;
-
-        public boolean isSet() {
-            return version != null && baseUrl != null;
-        }
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/GetServerInfoOperation.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/GetServerInfoOperation.kt
new file mode 100644
index 0000000..276be85
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/GetServerInfoOperation.kt
@@ -0,0 +1,135 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync.operations.nextcloud
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import android.content.*
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import com.google.common.base.Preconditions
+import java.util.ArrayList
+
+class GetServerInfoOperation(private val serverUrl: String?, context: Context) : RemoteOperation() {
+    private val serverInfo = ServerInfo()
+    private val context: Context
+    override fun run(ocClient: OwnCloudClient): RemoteOperationResult {
+        Preconditions.checkNotNull(ocClient)
+        val statusOperation = GetRemoteStatusOperation(context)
+        val result = statusOperation.execute(ocClient)
+        if (result.isSuccess) {
+            serverInfo.version = result.data[0] as OwnCloudVersion
+            serverInfo.isSecure = result.code == RemoteOperationResult.ResultCode.OK_SSL
+            serverInfo.baseUrl = serverUrl
+            val data = ArrayList<Any>()
+            data.add(serverInfo)
+            result.data = data
+        }
+        return result
+    }
+
+    class ServerInfo {
+        @JvmField
+        var version: OwnCloudVersion? = null
+        @JvmField
+        var baseUrl: String? = null
+        @JvmField
+        var isSecure = false
+        val isSet: Boolean
+            get() = version != null && baseUrl != null
+    }
+
+    init {
+        this.context = Preconditions.checkNotNull(context)
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/UploadFileOperation.java b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/UploadFileOperation.java
deleted file mode 100644
index 51d9712..0000000
--- a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/UploadFileOperation.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * LaaNo Android application
- *
- * @author Aleksandr Borisenko <developer@laano.net>
- * Copyright (C) 2017 Aleksandr Borisenko
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.bytesforge.linkasanote.sync.operations.nextcloud;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static java.lang.System.currentTimeMillis;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource;
-import com.bytesforge.linkasanote.sync.files.JsonFile;
-import com.owncloud.android.lib.common.OwnCloudClient;
-import com.owncloud.android.lib.common.network.WebdavUtils;
-import com.owncloud.android.lib.common.operations.RemoteOperation;
-import com.owncloud.android.lib.common.operations.RemoteOperationResult;
-import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation;
-import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation;
-import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation;
-import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation;
-import com.owncloud.android.lib.resources.files.model.RemoteFile;
-
-import org.apache.commons.httpclient.Header;
-import org.apache.commons.httpclient.methods.PutMethod;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
-
-public class UploadFileOperation extends RemoteOperation {
-
-    private static final String TAG = UploadFileOperation.class.getSimpleName();
-
-    private static final String NEXTCLOUD_HEADER_PREFIX = "OC-".toLowerCase();
-    private static final String NEXTCLOUD_FILE_ID_HEADER = NEXTCLOUD_HEADER_PREFIX + "FileId".toLowerCase();
-    private static final String NEXTCLOUD_E_TAG_HEADER = NEXTCLOUD_HEADER_PREFIX + "ETag".toLowerCase();
-
-    private JsonFile file;
-
-    public UploadFileOperation(@NonNull JsonFile file) {
-        this.file = checkNotNull(file);
-    }
-
-    @Override
-    protected RemoteOperationResult run(OwnCloudClient ocClient) {
-        File localFile = new File(file.getLocalPath());
-        if (!localFile.exists()) {
-            return new RemoteOperationResult(RemoteOperationResult.ResultCode.LOCAL_FILE_NOT_FOUND);
-        }
-        RemoteOperationResult result = createRemoteParent(file.getRemotePath(), ocClient);
-        if (!result.isSuccess()) return result;
-
-        EnhancedUploadFileRemoteOperation uploadOperation = new EnhancedUploadFileRemoteOperation(
-                file.getLocalPath(), file.getRemotePath(), file.getMimeType());
-        result = uploadOperation.execute(ocClient);
-        ArrayList<Object> data = new ArrayList<>();
-        data.add(file);
-        result.setData(data);
-        if (result.isSuccess()) {
-            String eTag = uploadOperation.getETag();
-            file.setETag(eTag);
-        } else {
-            file.setETag(null);
-            return new RemoteOperationResult(RemoteOperationResult.ResultCode.SYNC_CONFLICT);
-        }
-        return result;
-    }
-
-    private RemoteOperationResult createRemoteParent(String remotePath, OwnCloudClient ocClient) {
-        String remoteParent = new File(remotePath).getParent();
-        ExistenceCheckRemoteOperation existenceOperation =
-                new ExistenceCheckRemoteOperation(remoteParent, false);
-        RemoteOperationResult result = existenceOperation.execute(ocClient);
-        if (result.getCode() == RemoteOperationResult.ResultCode.FILE_NOT_FOUND) {
-            CreateFolderRemoteOperation createOperation =
-                    new CreateFolderRemoteOperation(remoteParent, true);
-            result = createOperation.execute(ocClient);
-        }
-        return result;
-    }
-
-    private class EnhancedUploadFileRemoteOperation extends UploadFileRemoteOperation {
-
-        private OwnCloudClient ocClient;
-        private String fileId;
-        private String eTag;
-
-        public EnhancedUploadFileRemoteOperation(
-                String localPath, String remotePath, String mimeType) {
-            super(localPath, remotePath, mimeType, Long.toString(currentTimeMillis() / 1000));
-        }
-
-        @Nullable
-        public String getETag() {
-            if (eTag != null) return eTag;
-
-            requestNextcloudFileAttributes();
-            return eTag;
-        }
-
-        @Nullable
-        public String getFileId() {
-            if (fileId != null) return fileId;
-
-            requestNextcloudFileAttributes();
-            return fileId;
-        }
-
-        private void requestNextcloudFileAttributes() {
-            ReadFileRemoteOperation operation = new ReadFileRemoteOperation(this.remotePath);
-            RemoteOperationResult result =
-                    CloudDataSource.executeRemoteOperation(operation, ocClient)
-                            .blockingGet();
-            if (result.isSuccess()) {
-                RemoteFile file = (RemoteFile) result.getData().get(0);
-                fileId = file.getRemoteId();
-                eTag = file.getEtag();
-            }
-        }
-
-        @Override
-        public RemoteOperationResult execute(@NonNull OwnCloudClient ocClient) {
-            checkNotNull(ocClient);
-
-            this.ocClient = ocClient;
-            RemoteOperationResult result = super.execute(ocClient);
-            // TODO: make sure this replacement of this.putMethod is working well
-            PutMethod putMethod = new PutMethod(
-                    ocClient.getWebdavUri() + WebdavUtils.encodePath(this.remotePath));
-            Map<String, String> nextcloudHeaders =
-                    extractNextcloudResponseHeaders(putMethod.getResponseHeaders());
-            if (nextcloudHeaders != null) {
-                fileId = nextcloudHeaders.get(NEXTCLOUD_FILE_ID_HEADER);
-                eTag = nextcloudHeaders.get(NEXTCLOUD_E_TAG_HEADER);
-            }
-            return result;
-        }
-
-        @Nullable
-        private Map<String, String> extractNextcloudResponseHeaders(@Nullable Header[] headers) {
-            if (headers == null) return null;
-
-            Map<String, String> nextcloudHeaders = new HashMap<>();
-            for (Header header : headers) {
-                String name = header.getName().toLowerCase();
-                if (name.startsWith(NEXTCLOUD_HEADER_PREFIX)) {
-                    String value = header.getValue().replaceAll("^\"|\"$", "");
-                    nextcloudHeaders.put(name, value);
-                }
-            }
-            return nextcloudHeaders.size() <= 0 ? null : nextcloudHeaders;
-        }
-    }
-}
diff --git a/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/UploadFileOperation.kt b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/UploadFileOperation.kt
new file mode 100644
index 0000000..9aa5869
--- /dev/null
+++ b/app/src/main/java/com/bytesforge/linkasanote/sync/operations/nextcloud/UploadFileOperation.kt
@@ -0,0 +1,225 @@
+/*
+ * LaaNo Android application
+ *
+ * @author Aleksandr Borisenko <developer@laano.net>
+ * Copyright (C) 2017 Aleksandr Borisenko
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.bytesforge.linkasanote.sync.operations.nextcloud
+
+import com.bytesforge.linkasanote.settings.Settings.isSyncUploadToEmpty
+import com.bytesforge.linkasanote.settings.Settings.isSyncProtectLocal
+import com.bytesforge.linkasanote.settings.Settings.updateLastFavoritesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastLinksSyncTime
+import com.bytesforge.linkasanote.settings.Settings.updateLastNotesSyncTime
+import com.bytesforge.linkasanote.settings.Settings.syncStatus
+import android.os.Parcelable
+import com.bytesforge.linkasanote.sync.files.JsonFile
+import android.os.Parcel
+import com.bytesforge.linkasanote.utils.CloudUtils
+import com.bytesforge.linkasanote.utils.UuidUtils
+import com.owncloud.android.lib.common.operations.RemoteOperation
+import com.owncloud.android.lib.common.OwnCloudClient
+import com.owncloud.android.lib.common.operations.RemoteOperationResult
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation.EnhancedUploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ExistenceCheckRemoteOperation
+import com.owncloud.android.lib.resources.files.CreateFolderRemoteOperation
+import com.owncloud.android.lib.resources.files.UploadFileRemoteOperation
+import com.owncloud.android.lib.resources.files.ReadFileRemoteOperation
+import com.bytesforge.linkasanote.data.source.cloud.CloudDataSource
+import com.owncloud.android.lib.resources.files.model.RemoteFile
+import com.owncloud.android.lib.common.network.WebdavUtils
+import com.bytesforge.linkasanote.sync.operations.nextcloud.UploadFileOperation
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation.ServerInfo
+import com.owncloud.android.lib.resources.status.GetRemoteStatusOperation
+import com.owncloud.android.lib.resources.status.OwnCloudVersion
+import android.os.Bundle
+import com.owncloud.android.lib.common.OwnCloudCredentials
+import com.owncloud.android.lib.common.OwnCloudCredentialsFactory
+import com.bytesforge.linkasanote.sync.operations.nextcloud.CheckCredentialsOperation
+import com.owncloud.android.lib.common.network.RedirectionPath
+import com.owncloud.android.lib.resources.users.GetRemoteUserInfoOperation
+import android.os.IBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsBinder
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationsHandler
+import com.bytesforge.linkasanote.sync.operations.OperationsService.OperationItem
+import android.accounts.Account
+import com.owncloud.android.lib.common.operations.OnRemoteOperationListener
+import android.os.HandlerThread
+import android.content.Intent
+import com.bytesforge.linkasanote.sync.operations.OperationsService
+import android.os.Looper
+import com.owncloud.android.lib.common.OwnCloudAccount
+import com.owncloud.android.lib.common.OwnCloudClientManagerFactory
+import android.accounts.AccountsException
+import com.bytesforge.linkasanote.sync.operations.nextcloud.GetServerInfoOperation
+import com.bytesforge.linkasanote.data.source.local.LocalItems
+import com.bytesforge.linkasanote.data.source.cloud.CloudItem
+import com.bytesforge.linkasanote.sync.SyncNotifications
+import com.bytesforge.linkasanote.sync.SyncItemResult
+import com.bytesforge.linkasanote.sync.SyncItem
+import com.bytesforge.linkasanote.utils.CommonUtils
+import com.bytesforge.linkasanote.data.source.local.LocalContract
+import android.database.sqlite.SQLiteConstraintException
+import com.bytesforge.linkasanote.data.source.local.LocalContract.SyncResultEntry
+import android.content.ContentValues
+import android.accounts.AccountManager
+import com.bytesforge.linkasanote.data.source.local.LocalSyncResults
+import com.bytesforge.linkasanote.data.source.local.LocalLinks
+import com.bytesforge.linkasanote.data.source.local.LocalFavorites
+import com.bytesforge.linkasanote.data.Favorite
+import com.bytesforge.linkasanote.data.source.local.LocalNotes
+import android.content.AbstractThreadedSyncAdapter
+import android.content.ContentProviderClient
+import com.bytesforge.linkasanote.sync.SyncAdapter
+import com.bytesforge.linkasanote.R
+import io.reactivex.SingleSource
+import android.widget.Toast
+import androidx.annotation.StringRes
+import javax.inject.Inject
+import com.bytesforge.linkasanote.LaanoApplication
+import com.bytesforge.linkasanote.sync.SyncService
+import androidx.core.app.NotificationManagerCompat
+import kotlin.jvm.JvmOverloads
+import android.app.NotificationManager
+import android.app.NotificationChannel
+import androidx.core.content.ContextCompat
+import androidx.core.app.NotificationCompat
+import android.graphics.Bitmap
+import android.graphics.drawable.Drawable
+import android.graphics.drawable.BitmapDrawable
+import com.google.common.base.Preconditions
+import org.apache.commons.httpclient.Header
+import org.apache.commons.httpclient.methods.PutMethod
+import java.io.File
+import java.util.ArrayList
+import java.util.HashMap
+
+class UploadFileOperation(file: JsonFile) : RemoteOperation() {
+    private val file: JsonFile
+    override fun run(ocClient: OwnCloudClient): RemoteOperationResult {
+        val localFile = File(file.localPath)
+        if (!localFile.exists()) {
+            return RemoteOperationResult(RemoteOperationResult.ResultCode.LOCAL_FILE_NOT_FOUND)
+        }
+        var result = createRemoteParent(file.remotePath, ocClient)
+        if (!result.isSuccess) return result
+        val uploadOperation = EnhancedUploadFileRemoteOperation(
+            file.localPath, file.remotePath, file.mimeType
+        )
+        result = uploadOperation.execute(ocClient)
+        val data = ArrayList<Any>()
+        data.add(file)
+        result.data = data
+        if (result.isSuccess) {
+            val eTag = uploadOperation.getETag()
+            file.eTag = eTag
+        } else {
+            file.eTag = null
+            return RemoteOperationResult(RemoteOperationResult.ResultCode.SYNC_CONFLICT)
+        }
+        return result
+    }
+
+    private fun createRemoteParent(
+        remotePath: String?,
+        ocClient: OwnCloudClient
+    ): RemoteOperationResult {
+        val remoteParent = File(remotePath).parent
+        val existenceOperation = ExistenceCheckRemoteOperation(remoteParent, false)
+        var result = existenceOperation.execute(ocClient)
+        if (result.code == RemoteOperationResult.ResultCode.FILE_NOT_FOUND) {
+            val createOperation = CreateFolderRemoteOperation(remoteParent, true)
+            result = createOperation.execute(ocClient)
+        }
+        return result
+    }
+
+    private inner class EnhancedUploadFileRemoteOperation(
+        localPath: String?, remotePath: String?, mimeType: String?
+    ) : UploadFileRemoteOperation(
+        localPath, remotePath, mimeType, java.lang.Long.toString(
+            System.currentTimeMillis() / 1000
+        )
+    ) {
+        private var ocClient: OwnCloudClient? = null
+        private var fileId: String? = null
+        private var eTag: String? = null
+        fun getETag(): String? {
+            if (eTag != null) return eTag
+            requestNextcloudFileAttributes()
+            return eTag
+        }
+
+        fun getFileId(): String? {
+            if (fileId != null) return fileId
+            requestNextcloudFileAttributes()
+            return fileId
+        }
+
+        private fun requestNextcloudFileAttributes() {
+            val operation = ReadFileRemoteOperation(remotePath)
+            val result = CloudDataSource.executeRemoteOperation(operation, ocClient!!)
+                .blockingGet()
+            if (result.isSuccess) {
+                val file = result.data[0] as RemoteFile
+                fileId = file.remoteId
+                eTag = file.etag
+            }
+        }
+
+        override fun execute(ocClient: OwnCloudClient): RemoteOperationResult {
+            Preconditions.checkNotNull(ocClient)
+            this.ocClient = ocClient
+            val result = super.execute(ocClient)
+            // TODO: make sure this replacement of this.putMethod is working well
+            val putMethod = PutMethod(
+                ocClient.webdavUri.toString() + WebdavUtils.encodePath(
+                    remotePath
+                )
+            )
+            val nextcloudHeaders = extractNextcloudResponseHeaders(putMethod.responseHeaders)
+            if (nextcloudHeaders != null) {
+                fileId = nextcloudHeaders[NEXTCLOUD_FILE_ID_HEADER]
+                eTag = nextcloudHeaders[NEXTCLOUD_E_TAG_HEADER]
+            }
+            return result
+        }
+
+        private fun extractNextcloudResponseHeaders(headers: Array<Header>?): Map<String, String>? {
+            if (headers == null) return null
+            val nextcloudHeaders: MutableMap<String, String> = HashMap()
+            for (header in headers) {
+                val name = header.name.toLowerCase()
+                if (name.startsWith(NEXTCLOUD_HEADER_PREFIX)) {
+                    val value = header.value.replace("^\"|\"$".toRegex(), "")
+                    nextcloudHeaders[name] = value
+                }
+            }
+            return if (nextcloudHeaders.size <= 0) null else nextcloudHeaders
+        }
+    }
+
+    companion object {
+        private val TAG = UploadFileOperation::class.java.simpleName
+        private val NEXTCLOUD_HEADER_PREFIX = "OC-".toLowerCase()
+        private val NEXTCLOUD_FILE_ID_HEADER = NEXTCLOUD_HEADER_PREFIX + "FileId".toLowerCase()
+        private val NEXTCLOUD_E_TAG_HEADER = NEXTCLOUD_HEADER_PREFIX + "ETag".toLowerCase()
+    }
+
+    init {
+        this.file = Preconditions.checkNotNull(file)
+    }
+}
\ No newline at end of file
