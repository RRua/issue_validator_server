M	.editorconfig
M	.gitattributes
M	.gitignore
M	README.md
M	app/assets/emojis/activity-0.png
M	app/assets/emojis/flags-0.png
D	app/assets/emojis/flags-1.png
M	app/assets/emojis/food-0.png
M	app/assets/emojis/nature-0.png
M	app/assets/emojis/objects-0.png
M	app/assets/emojis/people-0.png
M	app/assets/emojis/people-1.png
D	app/assets/emojis/people-10.png
M	app/assets/emojis/people-2.png
M	app/assets/emojis/people-3.png
M	app/assets/emojis/people-4.png
M	app/assets/emojis/people-5.png
M	app/assets/emojis/people-6.png
M	app/assets/emojis/people-7.png
M	app/assets/emojis/people-8.png
M	app/assets/emojis/people-9.png
M	app/assets/emojis/search-index/be.csv
M	app/assets/emojis/search-index/ca.csv
M	app/assets/emojis/search-index/cs.csv
M	app/assets/emojis/search-index/de.csv
M	app/assets/emojis/search-index/diversities.csv
M	app/assets/emojis/search-index/en.csv
M	app/assets/emojis/search-index/es.csv
M	app/assets/emojis/search-index/fr.csv
D	app/assets/emojis/search-index/gsw.csv
M	app/assets/emojis/search-index/hu.csv
M	app/assets/emojis/search-index/it.csv
M	app/assets/emojis/search-index/nl.csv
M	app/assets/emojis/search-index/no.csv
M	app/assets/emojis/search-index/orders.csv
M	app/assets/emojis/search-index/pl.csv
M	app/assets/emojis/search-index/pt.csv
M	app/assets/emojis/search-index/ru.csv
M	app/assets/emojis/search-index/sk.csv
M	app/assets/emojis/search-index/tr.csv
M	app/assets/emojis/search-index/uk.csv
D	app/assets/emojis/smileys-0.png
D	app/assets/emojis/smileys-1.png
M	app/assets/emojis/symbols-0.png
M	app/assets/emojis/travel-0.png
M	app/assets/license.html
M	app/build.gradle
M	app/jni/Android.mk
M	app/jni/Application.mk
D	app/libs/agcp-1.9.1.303.jar
D	app/libs/arm64-v8a/libjnidispatch.so
D	app/libs/armeabi-v7a/libjnidispatch.so
D	app/libs/x86/libjnidispatch.so
D	app/libs/x86_64/libjnidispatch.so
M	app/proguard-project.txt
M	app/src/androidTest/java/ch/threema/app/PermissionRuleUtils.kt
D	app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt
M	app/src/androidTest/java/ch/threema/app/ThreemaTestRunner.java
M	app/src/androidTest/java/ch/threema/app/backuprestore/csv/BackupServiceTest.java
D	app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt
D	app/src/androidTest/java/ch/threema/app/contacts/MarkContactAsDeletedBackgroundTaskTest.kt
D	app/src/androidTest/java/ch/threema/app/contacts/ReflectedContactSyncTaskTest.kt
D	app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt
M	app/src/androidTest/java/ch/threema/app/groupmanagement/GroupControlTest.kt
M	app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt
M	app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt
M	app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt
M	app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSyncRequestTest.kt
M	app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupTextTest.kt
D	app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt
D	app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt
D	app/src/androidTest/java/ch/threema/app/protocol/IdentityBlockedStepsTest.kt
M	app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java
D	app/src/androidTest/java/ch/threema/app/services/systemupdate/SystemUpdateHelpersTest.kt
D	app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt
M	app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java
D	app/src/androidTest/java/ch/threema/app/utils/BackgroundExecutorTest.kt
D	app/src/androidTest/java/ch/threema/app/utils/BundledMessagesSendStepsTest.kt
M	app/src/androidTest/java/ch/threema/app/utils/LinkifyUtilTest.kt
M	app/src/androidTest/java/ch/threema/app/utils/TextUtilTest.java
M	app/src/androidTest/java/ch/threema/app/webclient/converter/MessageTest.java
D	app/src/androidTest/java/ch/threema/data/TestDatabaseService.kt
D	app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt
D	app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt
D	app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt
D	app/src/androidTest/java/ch/threema/storage/DatabaseNonceStoreTest.kt
M	app/src/androidTest/java/ch/threema/storage/SQLDHSessionStoreTest.java
D	app/src/androidTest/java/ch/threema/storage/TaskArchiveFactoryTest.kt
D	app/src/blue/AndroidManifest.xml
D	app/src/blue/ic_launcher-web.png
D	app/src/blue/java/ch/threema/app/activities/DownloadApkActivity.java
D	app/src/blue/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/blue/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/blue/java/ch/threema/app/utils/DownloadUtil.java
D	app/src/blue/res/drawable-hdpi/ic_notification_multi.png
D	app/src/blue/res/drawable-hdpi/ic_notification_small.png
D	app/src/blue/res/drawable-hdpi/logo_main_white.png
D	app/src/blue/res/drawable-mdpi/ic_notification_multi.png
D	app/src/blue/res/drawable-mdpi/ic_notification_small.png
D	app/src/blue/res/drawable-mdpi/logo_main_white.png
D	app/src/blue/res/drawable-v24/ic_launcher_foreground.xml
D	app/src/blue/res/drawable-v24/ic_launcher_monochrome.xml
D	app/src/blue/res/drawable-xhdpi/anim_01_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_02_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_03_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_04_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_05_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_06_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_07_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_08_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_09_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_10_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_11_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_12_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_13_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_14_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_15_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_16_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_17_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_18_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_19_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_20_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_21_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_22_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_23_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_24_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_25_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_26_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_27_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_28_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_29_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_30_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_31_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_32_400ms.png
D	app/src/blue/res/drawable-xhdpi/anim_33_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_34_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_35_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_36_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_37_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_38_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_39_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_40_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_41_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_42_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_43_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_44_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_45_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_46_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_47_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_48_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_49_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_50_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_51_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_52_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_53_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_54_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_55_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_56_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_70_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_71_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_72_1200ms.png
D	app/src/blue/res/drawable-xhdpi/anim_73_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_74_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_75_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_76_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_77_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_78_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_79_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_80_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_81_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_82_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_83_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_84_1400ms.png
D	app/src/blue/res/drawable-xhdpi/anim_85_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_86_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_87_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_88_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_89_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_90_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_91_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_92_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_93_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_94_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_95_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_96_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_97_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_98_40ms.png
D	app/src/blue/res/drawable-xhdpi/anim_99_1400ms.png
D	app/src/blue/res/drawable-xhdpi/ic_notification_multi.png
D	app/src/blue/res/drawable-xhdpi/ic_notification_multi_color.png
D	app/src/blue/res/drawable-xhdpi/ic_notification_small.png
D	app/src/blue/res/drawable-xhdpi/logo_main_white.png
D	app/src/blue/res/drawable-xxhdpi/ic_notification_multi.png
D	app/src/blue/res/drawable-xxhdpi/ic_notification_multi_color.png
D	app/src/blue/res/drawable-xxhdpi/ic_notification_small.png
D	app/src/blue/res/drawable-xxhdpi/logo_main_white.png
D	app/src/blue/res/drawable-xxxhdpi/ic_notification_multi.png
D	app/src/blue/res/drawable-xxxhdpi/ic_notification_small.png
D	app/src/blue/res/drawable-xxxhdpi/logo_main_white.png
D	app/src/blue/res/drawable/ic_badge_work.xml
D	app/src/blue/res/drawable/ic_finger_with_circles.xml
D	app/src/blue/res/drawable/logo_main.xml
D	app/src/blue/res/layout-land/activity_verification_level.xml
D	app/src/blue/res/layout/activity_enter_serial.xml
D	app/src/blue/res/layout/activity_verification_level.xml
D	app/src/blue/res/layout/header_contact_section_work.xml
D	app/src/blue/res/layout/toolbar_home.xml
D	app/src/blue/res/mipmap-hdpi/ic_launcher.png
D	app/src/blue/res/mipmap-mdpi/ic_launcher.png
D	app/src/blue/res/mipmap-xhdpi/ic_launcher.png
D	app/src/blue/res/mipmap-xxhdpi/ic_launcher.png
D	app/src/blue/res/mipmap-xxxhdpi/ic_launcher.png
D	app/src/blue/res/values-de/strings.xml
D	app/src/blue/res/values-night/colors.xml
D	app/src/blue/res/values/colors.xml
D	app/src/blue/res/values/colors_theme.xml
D	app/src/blue/res/values/firebase_messaging.xml
D	app/src/blue/res/values/ic_launcher_colors.xml
D	app/src/blue/res/values/strings.xml
D	app/src/blue/res/xml/app_restrictions.xml
D	app/src/blue/res/xml/contacts.xml
D	app/src/blue/res/xml/file_paths.xml
M	app/src/foss_based/assets/emojis/activity-0.png
M	app/src/foss_based/assets/emojis/flags-0.png
D	app/src/foss_based/assets/emojis/flags-1.png
M	app/src/foss_based/assets/emojis/food-0.png
M	app/src/foss_based/assets/emojis/nature-0.png
M	app/src/foss_based/assets/emojis/objects-0.png
M	app/src/foss_based/assets/emojis/people-0.png
M	app/src/foss_based/assets/emojis/people-1.png
D	app/src/foss_based/assets/emojis/people-10.png
M	app/src/foss_based/assets/emojis/people-2.png
M	app/src/foss_based/assets/emojis/people-3.png
M	app/src/foss_based/assets/emojis/people-4.png
M	app/src/foss_based/assets/emojis/people-5.png
M	app/src/foss_based/assets/emojis/people-6.png
M	app/src/foss_based/assets/emojis/people-7.png
M	app/src/foss_based/assets/emojis/people-8.png
M	app/src/foss_based/assets/emojis/people-9.png
D	app/src/foss_based/assets/emojis/smileys-0.png
D	app/src/foss_based/assets/emojis/smileys-1.png
M	app/src/foss_based/assets/emojis/symbols-0.png
M	app/src/foss_based/assets/emojis/travel-0.png
M	app/src/foss_based/assets/license.html
M	app/src/google_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
M	app/src/google_services_based/java/ch/threema/app/push/PushService.java
M	app/src/google_services_based/java/ch/threema/app/services/VoiceActionService.java
M	app/src/google_services_based/java/com/google/android/vending/licensing/LicenseChecker.java
D	app/src/green/java/ch/threema/app/activities/DownloadApkActivity.java
D	app/src/green/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/green/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/green/java/ch/threema/app/utils/DownloadUtil.java
D	app/src/green/res/drawable-v24/ic_launcher_foreground.xml
D	app/src/green/res/mipmap-hdpi/ic_launcher.png
D	app/src/green/res/mipmap-mdpi/ic_launcher.png
D	app/src/green/res/mipmap-xhdpi/ic_launcher.png
D	app/src/green/res/mipmap-xxhdpi/ic_launcher.png
D	app/src/green/res/mipmap-xxxhdpi/ic_launcher.png
D	app/src/green/res/values/firebase_messaging.xml
D	app/src/green/res/values/ic_launcher_colors.xml
M	app/src/hms/java/ch/threema/app/activities/DownloadApkActivity.java
D	app/src/hms/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/hms/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/hms_services_based/java/ch/threema/app/push/HmsTokenUtil.kt
M	app/src/hms_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
M	app/src/hms_services_based/java/ch/threema/app/push/PushService.java
M	app/src/hms_work/java/ch/threema/app/activities/DownloadApkActivity.java
D	app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
M	app/src/libre/java/ch/threema/app/activities/DownloadApkActivity.java
D	app/src/libre/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/libre/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
M	app/src/libre/play/listings/de/full-description.txt
D	app/src/libre/play/listings/de/graphics/feature-graphic/1.png
D	app/src/main/java/ch/threema/app/BuildFlavor.kt
D	app/src/main/java/ch/threema/app/activities/BlockedContactsActivity.java
D	app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt
D	app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt
D	app/src/main/java/ch/threema/app/activities/MessageDetailsViewModel.kt
D	app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.kt
D	app/src/main/java/ch/threema/app/activities/StateFlowViewModel.kt
D	app/src/main/java/ch/threema/app/activities/WorkIntroActivity.kt
D	app/src/main/java/ch/threema/app/adapters/decorators/AnimatedImageDrawableDecorator.java
D	app/src/main/java/ch/threema/app/adapters/decorators/DeletedChatAdapterDecorator.kt
D	app/src/main/java/ch/threema/app/asynctasks/AddContactBackgroundTask.kt
D	app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt
D	app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateWorkContactBackgroundTask.kt
D	app/src/main/java/ch/threema/app/asynctasks/EmptyOrDeleteConversationsAsyncTask.java
D	app/src/main/java/ch/threema/app/asynctasks/MarkContactAsDeletedBackgroundTask.kt
D	app/src/main/java/ch/threema/app/asynctasks/SendToSupportBackgroundTask.kt
D	app/src/main/java/ch/threema/app/compose/common/ThemedText.kt
D	app/src/main/java/ch/threema/app/compose/common/anim/AnimatedVisibilityNow.kt
D	app/src/main/java/ch/threema/app/compose/common/anim/ExpandingBox.kt
D	app/src/main/java/ch/threema/app/compose/common/extensions/DimensionExt.kt
D	app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt
D	app/src/main/java/ch/threema/app/compose/common/interop/InteropEmojiConversationTextView.kt
D	app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryItem.kt
D	app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryList.kt
D	app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryViewModel.kt
D	app/src/main/java/ch/threema/app/compose/edithistory/VerticalTimelineItem.kt
D	app/src/main/java/ch/threema/app/compose/message/AckDecIndicator.kt
D	app/src/main/java/ch/threema/app/compose/message/CombinedMessageDetailsList.kt
D	app/src/main/java/ch/threema/app/compose/message/DeliveryIcon.kt
D	app/src/main/java/ch/threema/app/compose/message/MessageBubble.kt
D	app/src/main/java/ch/threema/app/compose/message/MessageDetails.kt
D	app/src/main/java/ch/threema/app/compose/message/MessageDetailsRow.kt
D	app/src/main/java/ch/threema/app/compose/message/MessageStateIndicator.kt
D	app/src/main/java/ch/threema/app/compose/message/MessageTimestamps.kt
D	app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt
D	app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPalette.kt
D	app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteDark.kt
D	app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteLight.kt
D	app/src/main/java/ch/threema/app/compose/theme/color/CustomColor.kt
D	app/src/main/java/ch/threema/app/connection/CspD2mDualConnectionSupplier.kt
D	app/src/main/java/ch/threema/app/debug/PatternLibraryActivity.kt
D	app/src/main/java/ch/threema/app/dialogs/ResendGroupMessageDialog.kt
D	app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt
D	app/src/main/java/ch/threema/app/globalsearch/GlobalSearchViewModel.kt
D	app/src/main/java/ch/threema/app/listeners/EditMessageListener.kt
D	app/src/main/java/ch/threema/app/listeners/MessageDeletedForAllListener.kt
D	app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt
D	app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt
D	app/src/main/java/ch/threema/app/messagereceiver/SendingPermissionValidationResult.kt
D	app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt
D	app/src/main/java/ch/threema/app/multidevice/LinkedDevicesAdapter.kt
D	app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt
D	app/src/main/java/ch/threema/app/multidevice/MultiDeviceException.kt
D	app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt
D	app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt
D	app/src/main/java/ch/threema/app/multidevice/PersistedMultiDeviceProperties.kt
D	app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingDataCollector.kt
D	app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingException.kt
D	app/src/main/java/ch/threema/app/multidevice/linking/DeviceLinkingStatus.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceConnectingFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceEmojiSelectionView.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFailureFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceLinkingProgressFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceMessageFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceScanQrFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceSuccessFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceVerifyFragment.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardActivity.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/LinkNewDeviceWizardViewModel.kt
D	app/src/main/java/ch/threema/app/multidevice/wizard/RendezvousEmojis.kt
D	app/src/main/java/ch/threema/app/notifications/ForwardSecurityNotificationManager.kt
D	app/src/main/java/ch/threema/app/notifications/NotificationChannels.kt
D	app/src/main/java/ch/threema/app/notifications/NotificationGroups.kt
D	app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt
D	app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt
D	app/src/main/java/ch/threema/app/processors/IncomingMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/IncomingReflectedMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/IncomingCspMessageSubTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallAnswerTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallHangupTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallIceCandidateTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallOfferTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/calls/IncomingCallRingingTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingContactRequestProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingDeleteProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/contactcontrol/IncomingSetProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactConversationMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactDeleteMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactEditMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactFileMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollSetupTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingContactPollVoteTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupConversationMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupDeleteMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupEditMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupFileMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollSetupTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/conversation/IncomingGroupPollVoteTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingEmptyTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityAcceptTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityEnvelopeTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityInitTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityRejectTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/fs/IncomingForwardSecurityTerminateTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupCallControlTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinRequestTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupJoinResponseMessage.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupLeaveTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupMessageUtils.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupNameTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSetupTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/groupcontrol/IncomingGroupSyncRequestTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingDeliveryReceiptTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingGroupDeliveryReceiptTask.kt
D	app/src/main/java/ch/threema/app/processors/incomingcspmessage/statusupdates/IncomingTypingIndicatorTask.kt
D	app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedd2dsync/ReflectedContactSyncTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedIncomingMessageUpdateTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedmessageupdate/ReflectedOutgoingMessageUpdateTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactRequestProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingContactSetProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeleteProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingDeliveryReceiptTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingFileTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupDeliveryReceiptTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupFileTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingGroupTextTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingMessageTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingPlaceholderTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/ReflectedOutgoingTextTask.kt
D	app/src/main/java/ch/threema/app/processors/reflectedoutgoingmessage/groupcall/ReflectedOutgoingGroupCallStartTask.kt
D	app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt
D	app/src/main/java/ch/threema/app/protocol/IdentityBlockedSteps.kt
D	app/src/main/java/ch/threema/app/services/ApiService.kt
D	app/src/main/java/ch/threema/app/services/ServerMessageService.kt
D	app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java
D	app/src/main/java/ch/threema/app/services/notification/ConversationNotificationGroup.kt
D	app/src/main/java/ch/threema/app/services/notification/NotificationActionService.java
D	app/src/main/java/ch/threema/app/services/notification/NotificationSchema.kt
D	app/src/main/java/ch/threema/app/services/notification/NotificationService.java
D	app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java
D	app/src/main/java/ch/threema/app/services/systemupdate/FSDatabaseUpgradeToVersion4.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateHelpers.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion100.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion101.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion102.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion103.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion104.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion86.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion87.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion88.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion89.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion90.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion91.java
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion92.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion93.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion94.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion95.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion96.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion97.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion98.kt
D	app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion99.kt
D	app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt
D	app/src/main/java/ch/threema/app/tasks/ComposableTask.kt
D	app/src/main/java/ch/threema/app/tasks/DeleteAndTerminateFSSessionsTask.kt
D	app/src/main/java/ch/threema/app/tasks/DeleteDeviceGroupTask.kt
D	app/src/main/java/ch/threema/app/tasks/DeleteMessageUtils.kt
D	app/src/main/java/ch/threema/app/tasks/DeviceLinkingTask.kt
D	app/src/main/java/ch/threema/app/tasks/DropDeviceTask.kt
D	app/src/main/java/ch/threema/app/tasks/EditMessageUtils.kt
D	app/src/main/java/ch/threema/app/tasks/FSRefreshStepsTask.kt
D	app/src/main/java/ch/threema/app/tasks/ForwardSecurityStateLogTask.kt
D	app/src/main/java/ch/threema/app/tasks/GetDevicesInfoTask.kt
D	app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt
D	app/src/main/java/ch/threema/app/tasks/OnFSFeatureMaskDowngradedTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutboundD2mMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutboundIncomingContactMessageUpdateReadTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutboundIncomingGroupMessageUpdateReadTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupCallStartTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupLeaveTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupNameTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetupTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt
D	app/src/main/java/ch/threema/app/tasks/PersistableTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectContactSyncCreateTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectContactSyncTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectContactSyncUpdateTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectUserProfileNicknameSyncTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectUserProfilePictureSyncTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithAllowListSyncTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTask.kt
D	app/src/main/java/ch/threema/app/tasks/ReflectUserProfileShareWithPolicySyncTaskBase.kt
D	app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt
D	app/src/main/java/ch/threema/app/tasks/SendPushTokenTask.kt
D	app/src/main/java/ch/threema/app/tasks/TaskArchiverImpl.kt
D	app/src/main/java/ch/threema/app/tasks/TaskCreator.kt
D	app/src/main/java/ch/threema/app/ui/CustomTextSelectionCallback.kt
D	app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt
D	app/src/main/java/ch/threema/app/ui/MovingPopupWindow.kt
D	app/src/main/java/ch/threema/app/ui/QuotePopup.kt
D	app/src/main/java/ch/threema/app/utils/ApplicationExitInfoUtil.kt
D	app/src/main/java/ch/threema/app/utils/ArrayExtensions.kt
D	app/src/main/java/ch/threema/app/utils/ConversationUtil.kt
D	app/src/main/java/ch/threema/app/utils/ExifInterfaceUtils.java
D	app/src/main/java/ch/threema/app/utils/GroupFeatureSupport.kt
D	app/src/main/java/ch/threema/app/utils/LazyProperty.kt
D	app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt
D	app/src/main/java/ch/threema/app/utils/RuntimeAssertions.kt
D	app/src/main/java/ch/threema/app/utils/StreamUtil.kt
D	app/src/main/java/ch/threema/app/utils/StringExtensions.kt
D	app/src/main/java/ch/threema/app/utils/WorkManagerUtil.kt
D	app/src/main/java/ch/threema/app/utils/compose/ComposeExtensions.kt
D	app/src/main/java/ch/threema/app/utils/executor/BackgroundExecutor.kt
D	app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallServiceBinder.kt
D	app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt
D	app/src/main/java/ch/threema/data/ModelCache.kt
D	app/src/main/java/ch/threema/data/WeakValueMap.kt
D	app/src/main/java/ch/threema/data/models/BaseModel.kt
D	app/src/main/java/ch/threema/data/models/ContactModel.kt
D	app/src/main/java/ch/threema/data/models/EditHistoryEntryData.kt
D	app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt
D	app/src/main/java/ch/threema/data/models/GroupModel.kt
D	app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt
D	app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt
D	app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt
D	app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt
D	app/src/main/java/ch/threema/data/repositories/RepositoryToken.kt
D	app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt
D	app/src/main/java/ch/threema/data/storage/DbTypes.kt
D	app/src/main/java/ch/threema/data/storage/EditHistoryDao.kt
D	app/src/main/java/ch/threema/data/storage/EditHistoryDaoImpl.kt
D	app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt
D	app/src/main/java/ch/threema/logging/LibthreemaLogger.kt
D	app/src/main/java/ch/threema/storage/DatabaseNonceStore.kt
D	app/src/main/java/ch/threema/storage/factories/EditHistoryEntryModelFactory.kt
D	app/src/main/java/ch/threema/storage/factories/IncomingGroupSyncRequestLogModelFactory.kt
D	app/src/main/java/ch/threema/storage/factories/OutgoingGroupSyncRequestLogModelFactory.java
D	app/src/main/java/ch/threema/storage/factories/RejectedGroupMessageFactory.kt
D	app/src/main/java/ch/threema/storage/factories/TaskArchiveFactory.kt
D	app/src/main/java/ch/threema/storage/models/IncomingGroupSyncRequestLogModel.kt
D	app/src/main/java/ch/threema/storage/models/OutgoingGroupSyncRequestLogModel.java
D	app/src/main/res-rendezvous/drawable/emoji_party_popper.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f308.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f30b.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f319.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f332.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f33b.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f33f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f344.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f345.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f349.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f34b.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f34e.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f352.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f353.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f36a.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f36b.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f380.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f388.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3af.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3b3.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3b7.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3b8.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3c0.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3d0.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3d3.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3d5_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3db_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3dd_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f3f5_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f408_200d_2b1b.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f40b.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f414.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f418.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f41a.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f41f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f429.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f42a.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f42c.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f42d.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f42e.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f430.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f434.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f435.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f436.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f437.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f438.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f43c.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f43f_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f440.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f451.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f457.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f463.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4a5.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4a7.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4ab.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4ac.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4bc.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4cb.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4d6.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4dd.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4e6.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4ee.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4f6.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f4f8.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f511.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f512.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f514.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f517.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f525.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f52c.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f54a_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f56f_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f578_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f579_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f5a8_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f5fa_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f680.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f682.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f69a.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f69c.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f6bd.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f6e4_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f6f0_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f7e8.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f947.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f951.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f955.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f962.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f966.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f986.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f989.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f98a.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f992.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f998.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9a2.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9a4.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9a9.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9ac.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9ad.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9c2.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9ca.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9e9.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9f8.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1f9f9.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fa83.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fa91.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fa9d.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1faa3.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fab2.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fab6.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fad0.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fad8.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_1fae7.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_25b6_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2600_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2602_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2603_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2615.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2618_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2660_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2665_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2692_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2693.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2696_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_26ab.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_26f3.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2728.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2744_fe0f.xml
D	app/src/main/res-rendezvous/drawable/ic_emoji_2b50.xml
D	app/src/main/res/anim/quote_slide_down.xml
D	app/src/main/res/anim/quote_slide_up.xml
D	app/src/main/res/color/bubble_receive_text_colorstatelist.xml
D	app/src/main/res/color/bubble_send_text_colorstatelist.xml
D	app/src/main/res/color/bubble_text_deleted_colorstatelist.xml
D	app/src/main/res/color/wizard_button_text_inverse_consumer.xml
D	app/src/main/res/drawable/emoji_category_smileys.xml
D	app/src/main/res/drawable/ic_app_icon_consumer.xml
D	app/src/main/res/drawable/ic_error.xml
D	app/src/main/res/drawable/ic_ink_highlighter_outline.xml
D	app/src/main/res/drawable/ic_multi_device.xml
D	app/src/main/res/drawable/ic_multi_device_128dp.xml
D	app/src/main/res/drawable/ic_webp.xml
D	app/src/main/res/drawable/logo_main_consumer.xml
D	app/src/main/res/drawable/work_intro_consumer_notice_background.xml
D	app/src/main/res/layout/activity_link_new_device_bottom_sheet.xml
D	app/src/main/res/layout/activity_linked_devices.xml
D	app/src/main/res/layout/activity_message_details.xml
D	app/src/main/res/layout/activity_work_intro.xml
D	app/src/main/res/layout/conversation_list_item_deleted_recv.xml
D	app/src/main/res/layout/conversation_list_item_deleted_send.xml
D	app/src/main/res/layout/fragment_link_new_device_message.xml
D	app/src/main/res/layout/fragment_link_new_device_progress.xml
D	app/src/main/res/layout/fragment_link_new_device_scan_qr.xml
D	app/src/main/res/layout/fragment_link_new_device_verify.xml
D	app/src/main/res/layout/item_linked_devices_list.xml
D	app/src/main/res/layout/notice_select_media_permission.xml
D	app/src/main/res/layout/popup_quote.xml
D	app/src/main/res/layout/view_emoji_selection.xml
D	app/src/main/res/layout/work_intro_consumer_notice.xml
D	app/src/main/res/layout/work_intro_login.xml
D	app/src/main/res/menu/action_edit_message.xml
D	app/src/main/res/menu/activity_global_search.xml
D	app/src/main/res/menu/activity_message_details.xml
D	app/src/main/res/values-be-rBY/colorpicker_strings.xml
D	app/src/main/res/values-ca/colorpicker_strings.xml
D	app/src/main/res/values-cs/colorpicker_strings.xml
D	app/src/main/res/values-cs/rendezvous_emoji_strings.xml
D	app/src/main/res/values-de/rendezvous_emoji_strings.xml
D	app/src/main/res/values-es/rendezvous_emoji_strings.xml
D	app/src/main/res/values-fr/rendezvous_emoji_strings.xml
D	app/src/main/res/values-gsw/colorpicker_strings.xml
D	app/src/main/res/values-gsw/poi_strings.xml
D	app/src/main/res/values-gsw/qrscanner_strings.xml
D	app/src/main/res/values-gsw/strings.xml
D	app/src/main/res/values-gsw/voicemessage_strings.xml
D	app/src/main/res/values-gsw/voip_strings.xml
D	app/src/main/res/values-gsw/webclient_strings.xml
D	app/src/main/res/values-it/rendezvous_emoji_strings.xml
D	app/src/main/res/values-ja/colorpicker_strings.xml
D	app/src/main/res/values-ja/rendezvous_emoji_strings.xml
D	app/src/main/res/values-nl-rNL/rendezvous_emoji_strings.xml
D	app/src/main/res/values-no/colorpicker_strings.xml
D	app/src/main/res/values-pl/rendezvous_emoji_strings.xml
D	app/src/main/res/values-pt-rBR/rendezvous_emoji_strings.xml
D	app/src/main/res/values-rm/colorpicker_strings.xml
D	app/src/main/res/values-ru/rendezvous_emoji_strings.xml
D	app/src/main/res/values-sk/colorpicker_strings.xml
D	app/src/main/res/values-sk/rendezvous_emoji_strings.xml
D	app/src/main/res/values-tr/colorpicker_strings.xml
D	app/src/main/res/values-tr/rendezvous_emoji_strings.xml
D	app/src/main/res/values-uk/colorpicker_strings.xml
D	app/src/main/res/values-uk/rendezvous_emoji_strings.xml
D	app/src/main/res/values-zh-rCN/colorpicker_strings.xml
D	app/src/main/res/values-zh-rCN/rendezvous_emoji_strings.xml
D	app/src/main/res/values-zh-rTW/colorpicker_strings.xml
D	app/src/main/res/values-zh-rTW/rendezvous_emoji_strings.xml
D	app/src/main/res/values/colorpicker_strings.xml
D	app/src/main/res/values/rendezvous_emoji_strings.xml
D	app/src/none/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/none/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsDark.kt
D	app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsLight.kt
D	app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
D	app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
D	app/src/test/java/ch/threema/app/connection/CspD2mDualConnectionSupplierTest.kt
D	app/src/test/java/ch/threema/app/logging/ThreemaLoggerTest.kt
D	app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java
D	app/src/test/java/ch/threema/app/utils/BackupUtilsTest.kt
D	app/src/test/java/ch/threema/app/utils/StreamUtilTest.kt
D	app/src/test/java/ch/threema/app/utils/WorkManagerUtilTest.kt
D	app/src/test/java/ch/threema/data/ContactModelJavaTest.java
D	app/src/test/java/ch/threema/data/ContactModelTest.kt
D	app/src/test/java/ch/threema/data/GroupModelJavaTest.java
D	app/src/test/java/ch/threema/data/GroupModelTest.kt
D	app/src/test/java/ch/threema/data/WeakValueMapTest.kt
D	domain/compile-proto.sh
D	domain/libthreema/Cargo.lock
D	domain/libthreema/Cargo.toml
D	domain/libthreema/lib/Cargo.toml
D	domain/libthreema/lib/build.rs
D	domain/libthreema/lib/src/bindings/mod.rs
D	domain/libthreema/lib/src/bindings/uniffi/crypto.rs
D	domain/libthreema/lib/src/bindings/uniffi/d2d_rendezvous.rs
D	domain/libthreema/lib/src/bindings/uniffi/id_backup.rs
D	domain/libthreema/lib/src/bindings/uniffi/logging.rs
D	domain/libthreema/lib/src/bindings/uniffi/mod.rs
D	domain/libthreema/lib/src/bindings/wasm/d2d_rendezvous.rs
D	domain/libthreema/lib/src/bindings/wasm/logging.rs
D	domain/libthreema/lib/src/bindings/wasm/mod.rs
D	domain/libthreema/lib/src/common.rs
D	domain/libthreema/lib/src/crypto.rs
D	domain/libthreema/lib/src/d2d_rendezvous/frame.rs
D	domain/libthreema/lib/src/d2d_rendezvous/mod.rs
D	domain/libthreema/lib/src/d2d_rendezvous/rxdak.rs
D	domain/libthreema/lib/src/d2d_rendezvous/rxdtk.rs
D	domain/libthreema/lib/src/d2d_rendezvous/rxdxk.rs
D	domain/libthreema/lib/src/id_backup/argon_chacha_poly_scheme.rs
D	domain/libthreema/lib/src/id_backup/legacy_scheme.rs
D	domain/libthreema/lib/src/id_backup/mod.rs
D	domain/libthreema/lib/src/lib.rs
D	domain/libthreema/lib/src/sync.rs
D	domain/libthreema/lib/src/time.rs
D	domain/libthreema/lib/uniffi.toml
D	domain/libthreema/macros/Cargo.toml
D	domain/libthreema/macros/src/lib.rs
D	domain/libthreema/macros/tests/concat_bytes.rs
D	domain/libthreema/macros/tests/fail/01-incorrect-length.rs
D	domain/libthreema/macros/tests/fail/01-incorrect-length.stderr
D	domain/libthreema/macros/tests/fail/02-not-u8.rs
D	domain/libthreema/macros/tests/fail/02-not-u8.stderr
D	domain/libthreema/rust-toolchain.toml
D	domain/libthreema/threema-protocols/src/common.proto
D	domain/libthreema/threema-protocols/src/csp-e2e-fs.proto
D	domain/libthreema/threema-protocols/src/csp-e2e.proto
D	domain/libthreema/threema-protocols/src/csp.struct.yml
D	domain/libthreema/threema-protocols/src/directory.openapi.yml
D	domain/libthreema/threema-protocols/src/extra.struct.yml
D	domain/libthreema/threema-protocols/src/group-call.proto
D	domain/libthreema/threema-protocols/src/group-call.struct.yml
D	domain/libthreema/threema-protocols/src/md-d2d-history.proto
D	domain/libthreema/threema-protocols/src/md-d2d-join.proto
D	domain/libthreema/threema-protocols/src/md-d2d-rendezvous.proto
D	domain/libthreema/threema-protocols/src/md-d2d-sync.proto
D	domain/libthreema/threema-protocols/src/md-d2d.proto
D	domain/libthreema/threema-protocols/src/md-d2m.proto
D	domain/libthreema/threema-protocols/src/md-d2m.struct.yml
D	domain/libthreema/threema-protocols/src/md.md
D	domain/libthreema/threema-protocols/src/mdm-parameters.md
D	domain/libthreema/threema-protocols/src/o2o-call.proto
D	domain/libthreema/threema-protocols/src/oppf.schema.yml
D	domain/libthreema/threema-protocols/src/safe-backup.schema.yml
D	domain/libthreema/threema-protocols/src/url-payloads.proto
D	domain/libthreema/threema-protocols/version.txt
D	domain/libthreema/tools/uniffi-bindgen/Cargo.toml
D	domain/libthreema/tools/uniffi-bindgen/uniffi-bindgen.rs
D	domain/protocol/src/common.proto
D	domain/protocol/src/csp-e2e-fs.proto
D	domain/protocol/src/csp-e2e.proto
D	domain/protocol/src/csp.struct.yml
D	domain/protocol/src/directory.openapi.yml
D	domain/protocol/src/extra.struct.yml
D	domain/protocol/src/group-call.proto
D	domain/protocol/src/group-call.struct.yml
D	domain/protocol/src/md-d2d-history.proto
D	domain/protocol/src/md-d2d-join.proto
D	domain/protocol/src/md-d2d-rendezvous.proto
D	domain/protocol/src/md-d2d-sync.proto
D	domain/protocol/src/md-d2d.proto
D	domain/protocol/src/md-d2m.proto
D	domain/protocol/src/md-d2m.struct.yml
D	domain/protocol/src/md.md
D	domain/protocol/src/mdm-parameters.md
D	domain/protocol/src/o2o-call.proto
D	domain/protocol/src/oppf.schema.yml
D	domain/protocol/src/safe-backup.schema.yml
D	domain/protocol/src/url-payloads.proto
D	domain/protocol/version.txt
D	domain/src/main/java/ch/threema/base/concurrent/TrulySingleThreadExecutorThreadFactory.kt
D	domain/src/main/java/ch/threema/base/crypto/NonceStore.kt
D	domain/src/main/java/ch/threema/base/utils/Base64UrlSafe.kt
D	domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt
D	domain/src/main/java/ch/threema/base/utils/SecureRandomUtil.kt
D	domain/src/main/java/ch/threema/base/utils/TimeMeasureUtil.kt
D	domain/src/main/java/ch/threema/base/utils/UnsignedHelper.java
D	domain/src/main/java/ch/threema/domain/models/Contact.kt
D	domain/src/main/java/ch/threema/domain/protocol/D2mProtocolDefines.kt
D	domain/src/main/java/ch/threema/domain/protocol/X509TrustManagerFactory.java
D	domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.kt
D	domain/src/main/java/ch/threema/domain/protocol/blob/BlobScope.kt
D	domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnection.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnectionProvider.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionState.java
D	domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionStateListener.java
D	domain/src/main/java/ch/threema/domain/protocol/connection/ConvertibleServerConnection.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/PayloadProcessingException.java
D	domain/src/main/java/ch/threema/domain/protocol/connection/ReconnectableServerConnection.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnection.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDependencies.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDispatcher.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionException.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspConnection.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspController.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspControllers.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/DeviceCookieManager.java
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/ProtocolExtension.java
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProvider.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProviderImpl.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/CspSocket.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/HostResolver.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ProxyAwareSocketFactory.java
D	domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/SocketFactory.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mController.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mControllers.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mSession.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mCloseCode.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mServerAddressProvider.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocket.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseException.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseListener.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseReason.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/data/ByteContainer.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/data/D2mProtocolVersion.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/data/TypedMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/data/csp.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/data/data.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/AuthLayer.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/CspFrameLayer.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/D2mFrameLayer.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/EndToEndLayer.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/MultiplexLayer.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/ServerConnectionLayers.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/layer/layers.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/pipe.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/socket/BaseSocket.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocket.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocketCloseReason.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/util/ConnectionLoggingUtil.kt
D	domain/src/main/java/ch/threema/domain/protocol/connection/util/ServerConnectionController.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/MessageTooLongException.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessageData.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessageData.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageFlags.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotSetupInterface.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.kt
D	domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt
D	domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt
D	domain/src/main/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPath.kt
D	domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousConnection.kt
D	domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousException.kt
D	domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPath.kt
D	domain/src/main/java/ch/threema/domain/protocol/rendezvous/RendezvousPathProvider.kt
D	domain/src/main/java/ch/threema/domain/protocol/rendezvous/WebSocketRendezvousPath.kt
D	domain/src/main/java/ch/threema/domain/protocol/rendezvous/messages.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/LocalTaskQueue.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/QueueSendCompleteListener.java
D	domain/src/main/java/ch/threema/domain/taskmanager/Task.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/TaskArchiver.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerDispatcher.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerProvider.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/TaskQueue.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/TriggerSource.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/codec.kt
D	domain/src/main/java/ch/threema/domain/taskmanager/reflect.kt
D	domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.kt
D	domain/src/test/java/ch/threema/base/utils/Base64UrlSafeTest.kt
D	domain/src/test/java/ch/threema/base/utils/ByteArrayUtilsKtTest.kt
D	domain/src/test/java/ch/threema/base/utils/UnsignedHelperTest.java
D	domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt
D	domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/connection/ServerConnectionTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/connection/layer/MultiplexLayerTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/connection/socket/CspSocketTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/FileMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessageTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/rendezvous/MultiplexedRendezvousPathTest.kt
D	domain/src/test/java/ch/threema/domain/protocol/taskmanager/TaskExecutionTest.kt
D	domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.kt
D	domain/src/test/java/ch/threema/testutils/Assertions.kt
D	domain/src/testFixtures/java/ch/threema/domain/helpers/DecryptTaskCodec.kt
D	domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt
D	domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryDHSessionStore.java
D	domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.kt
D	domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt
D	domain/src/testFixtures/java/ch/threema/domain/helpers/TransactionAckTaskCodec.kt
D	domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt
D	scripts/rustup-init.sh
D	test-helpers/.gitignore
D	test-helpers/build.gradle.kts
D	test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt
diff --git a/app/src/androidTest/java/ch/threema/app/PermissionRuleUtils.kt b/app/src/androidTest/java/ch/threema/app/PermissionRuleUtils.kt
index 03c97867..af71d089 100644
--- a/app/src/androidTest/java/ch/threema/app/PermissionRuleUtils.kt
+++ b/app/src/androidTest/java/ch/threema/app/PermissionRuleUtils.kt
@@ -21,7 +21,6 @@
 
 package ch.threema.app
 
-import android.Manifest
 import android.os.Build
 import androidx.test.rule.GrantPermissionRule
 
@@ -31,7 +30,7 @@ import androidx.test.rule.GrantPermissionRule
  */
 fun getNotificationPermissionRule(): GrantPermissionRule {
     return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-        GrantPermissionRule.grant(Manifest.permission.POST_NOTIFICATIONS)
+        GrantPermissionRule.grant(android.Manifest.permission.POST_NOTIFICATIONS)
     } else {
         GrantPermissionRule.grant()
     }
@@ -47,58 +46,8 @@ fun getReadWriteExternalStoragePermissionRule(): GrantPermissionRule {
         GrantPermissionRule.grant()
     } else {
         GrantPermissionRule.grant(
-            Manifest.permission.READ_EXTERNAL_STORAGE,
-            Manifest.permission.WRITE_EXTERNAL_STORAGE
+            android.Manifest.permission.READ_EXTERNAL_STORAGE,
+            android.Manifest.permission.WRITE_EXTERNAL_STORAGE
         )
     }
 }
-
-/**
- * Get the permission to read images and videos from android 13, and read/write external storage on
- * older android versions.
- */
-fun getReadImagesVideosPermissionRule(): GrantPermissionRule {
-    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-        GrantPermissionRule.grant(
-            Manifest.permission.READ_MEDIA_IMAGES,
-            Manifest.permission.READ_MEDIA_VIDEO
-        )
-    } else {
-        GrantPermissionRule.grant(
-            Manifest.permission.READ_EXTERNAL_STORAGE,
-            Manifest.permission.WRITE_EXTERNAL_STORAGE
-        )
-    }
-}
-
-/**
- * Get the microphone permission rule.
- */
-fun getMicrophonePermissionRule(): GrantPermissionRule =
-    GrantPermissionRule.grant(Manifest.permission.RECORD_AUDIO)
-
-/**
- * Get [Manifest.permission.BLUETOOTH] or [Manifest.permission.BLUETOOTH_CONNECT] permission rule
- * depending on the android version.
- */
-fun getBluetoothPermissionRule(): GrantPermissionRule {
-    return GrantPermissionRule.grant(
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
-            Manifest.permission.BLUETOOTH_CONNECT
-        } else {
-            Manifest.permission.BLUETOOTH
-        }
-    )
-}
-
-/**
- * Get the [Manifest.permission.READ_PHONE_STATE] permission rule on android 12 or higher and an
- * empty permission rule on older versions.
- */
-fun getReadPhoneStatePermissionRule(): GrantPermissionRule {
-    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
-        GrantPermissionRule.grant(Manifest.permission.READ_PHONE_STATE)
-    } else {
-        GrantPermissionRule.grant()
-    }
-}
diff --git a/app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt b/app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt
deleted file mode 100644
index 7fc24d46..00000000
--- a/app/src/androidTest/java/ch/threema/app/TestCoreServiceManager.kt
+++ /dev/null
@@ -1,41 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app
-
-import ch.threema.app.managers.CoreServiceManager
-import ch.threema.app.multidevice.MultiDeviceManagerImpl
-import ch.threema.app.stores.PreferenceStoreInterface
-import ch.threema.app.tasks.TaskArchiverImpl
-import ch.threema.app.utils.DeviceCookieManagerImpl
-import ch.threema.domain.models.AppVersion
-import ch.threema.domain.taskmanager.TaskManager
-import ch.threema.storage.DatabaseServiceNew
-
-class TestCoreServiceManager(
-    override val version: AppVersion,
-    override val databaseService: DatabaseServiceNew,
-    override val preferenceStore: PreferenceStoreInterface,
-    override val taskArchiver: TaskArchiverImpl,
-    override val deviceCookieManager: DeviceCookieManagerImpl,
-    override val taskManager: TaskManager,
-    override val multiDeviceManager: MultiDeviceManagerImpl,
-): CoreServiceManager
diff --git a/app/src/androidTest/java/ch/threema/app/ThreemaTestRunner.java b/app/src/androidTest/java/ch/threema/app/ThreemaTestRunner.java
index 1c475272..7865b1a6 100644
--- a/app/src/androidTest/java/ch/threema/app/ThreemaTestRunner.java
+++ b/app/src/androidTest/java/ch/threema/app/ThreemaTestRunner.java
@@ -25,11 +25,13 @@ import android.app.Application;
 import android.content.Context;
 import android.os.Bundle;
 
+import androidx.multidex.MultiDex;
 import androidx.test.runner.AndroidJUnitRunner;
 
 public class ThreemaTestRunner extends AndroidJUnitRunner {
 	@Override
 	public void onCreate(Bundle arguments) {
+		MultiDex.install(getTargetContext());
 		super.onCreate(arguments);
 	}
 
diff --git a/app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt b/app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt
deleted file mode 100644
index 73675bda..00000000
--- a/app/src/androidTest/java/ch/threema/app/contacts/AddOrUpdateContactBackgroundTaskTest.kt
+++ /dev/null
@@ -1,419 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.contacts
-
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.asynctasks.AddContactRestrictionPolicy
-import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask
-import ch.threema.app.asynctasks.AlreadyVerified
-import ch.threema.app.asynctasks.ContactExists
-import ch.threema.app.asynctasks.Failed
-import ch.threema.app.asynctasks.ContactAddResult
-import ch.threema.app.asynctasks.ContactModified
-import ch.threema.app.asynctasks.Success
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.executor.BackgroundExecutor
-import ch.threema.data.TestDatabaseService
-import ch.threema.data.repositories.ContactModelRepository
-import ch.threema.data.repositories.ModelRepositories
-import ch.threema.domain.models.IdentityState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.protocol.SSLSocketFactoryFactory
-import ch.threema.domain.protocol.api.APIConnector
-import ch.threema.domain.protocol.api.APIConnector.FetchIdentityResult
-import ch.threema.domain.protocol.api.APIConnector.HttpConnectionException
-import ch.threema.storage.models.ContactModel
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import com.neilalexander.jnacl.NaCl
-import kotlinx.coroutines.runBlocking
-import org.junit.Assert.assertArrayEquals
-import org.junit.Before
-import java.net.HttpURLConnection
-import kotlin.test.Test
-import kotlin.test.assertEquals
-import kotlin.test.assertTrue
-import kotlin.test.assertFalse
-import kotlin.test.fail
-
-class AddOrUpdateContactBackgroundTaskTest {
-
-    private val backgroundExecutor = BackgroundExecutor()
-    private lateinit var databaseService: TestDatabaseService
-    private lateinit var contactModelRepository: ContactModelRepository
-
-    @Before
-    fun before() {
-        databaseService = TestDatabaseService()
-        contactModelRepository = ModelRepositories(databaseService).contacts
-    }
-
-    @Test
-    fun testAddSuccessful() {
-        val newIdentity = "01234567"
-
-        testAddingContact(
-            { identity ->
-                FetchIdentityResult().also {
-                    it.identity = identity
-                    it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                    it.featureMask = 12
-                    it.type = 0
-                    it.state = IdentityState.ACTIVE
-                }
-            },
-            {
-                assertTrue(it is Success)
-                assertEquals(newIdentity, it.contactModel.identity)
-                val data = it.contactModel.data.value!!
-                assertEquals(newIdentity, data.identity)
-                assertArrayEquals(ByteArray(NaCl.PUBLICKEYBYTES), data.publicKey)
-                assertEquals(12u, data.featureMask)
-                assertEquals(IdentityType.NORMAL, data.identityType)
-                assertEquals(ContactModel.State.ACTIVE, data.activityState)
-                assertEquals(VerificationLevel.UNVERIFIED, data.verificationLevel)
-            }
-        )
-    }
-
-    @Test
-    fun testAddSuccessfulVerified() {
-        val newIdentity = "01234567"
-
-        testAddingContact(
-            { identity ->
-                FetchIdentityResult().also {
-                    it.identity = identity
-                    it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                    it.featureMask = 127
-                    it.type = 1
-                    it.state = IdentityState.INACTIVE
-                }
-            },
-            {
-                assertTrue(it is Success)
-                assertEquals(newIdentity, it.contactModel.identity)
-                val data = it.contactModel.data.value!!
-                assertEquals(newIdentity, data.identity)
-                assertArrayEquals(ByteArray(NaCl.PUBLICKEYBYTES), data.publicKey)
-                assertEquals(127u, data.featureMask)
-                assertEquals(IdentityType.WORK, data.identityType)
-                assertEquals(ContactModel.State.INACTIVE, data.activityState)
-                assertEquals(VerificationLevel.FULLY_VERIFIED, data.verificationLevel)
-            },
-            publicKey = ByteArray(NaCl.PUBLICKEYBYTES),
-        )
-    }
-
-    @Test
-    fun testAddMyIdentity() {
-        val myIdentity = "00000000"
-        testAddingContact(
-            { identity ->
-                FetchIdentityResult().also {
-                    it.identity = identity
-                    it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                    it.featureMask = 127
-                    it.type = 1
-                    it.state = IdentityState.INACTIVE
-                }
-            },
-            {
-                assertTrue(it is Failed)
-            },
-            newIdentity = myIdentity,
-            myIdentity = myIdentity,
-        )
-    }
-
-    @Test
-    fun testAddPublicKeyMismatch() {
-        testAddingContact(
-            { identity ->
-                FetchIdentityResult().also {
-                    it.identity = identity
-                    it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                    it.featureMask = 12
-                    it.type = 0
-                    it.state = IdentityState.ACTIVE
-                }
-            },
-            {
-                assertTrue(it is Failed)
-            },
-            publicKey = ByteArray(NaCl.PUBLICKEYBYTES).also { it.fill(1) }
-        )
-    }
-
-    @Test
-    fun testAddInvalidId() {
-        testAddingContact(
-            {
-                throw HttpConnectionException(HttpURLConnection.HTTP_NOT_FOUND, Exception())
-            },
-            {
-                assertTrue(it is Failed)
-            }
-        )
-    }
-
-    @Test
-    fun testAddExistingContact() {
-        val apiConnectorResult: (identity: String) -> FetchIdentityResult = { identity ->
-            FetchIdentityResult().also {
-                it.identity = identity
-                it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                it.featureMask = 12
-                it.type = 0
-                it.state = IdentityState.ACTIVE
-            }
-        }
-
-        // The first time adding the contact should succeed
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is Success)
-            }
-        )
-
-        // The second time adding the contact should fail
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is ContactExists)
-            }
-        )
-    }
-
-    @Test
-    fun testVerifyTwice() {
-        val publicKey = ByteArray(NaCl.PUBLICKEYBYTES).apply { fill(2) }
-
-        val apiConnectorResult: (identity: String) -> FetchIdentityResult = { identity ->
-            FetchIdentityResult().also {
-                it.identity = identity
-                it.publicKey = publicKey
-                it.featureMask = 12
-                it.type = 0
-                it.state = IdentityState.ACTIVE
-            }
-        }
-
-        // The first time adding the contact should succeed
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is Success)
-            },
-            publicKey = publicKey,
-        )
-
-        // The second time adding the contact should fail
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is AlreadyVerified)
-            },
-            publicKey = publicKey
-        )
-    }
-
-    @Test
-    fun testAddGroupContact() {
-        val newIdentity = "01234567"
-
-        val apiConnectorResult: (identity: String) -> FetchIdentityResult = { identity ->
-            FetchIdentityResult().also {
-                it.identity = identity
-                it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                it.featureMask = 12
-                it.type = 0
-                it.state = IdentityState.ACTIVE
-            }
-        }
-
-        // The first time adding the contact should succeed
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is Success)
-            },
-            newIdentity = newIdentity
-        )
-
-        val contactModel = contactModelRepository.getByIdentity(newIdentity)!!
-
-        // Downgrade the contact to a group contact
-        contactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.GROUP)
-
-        // Assert that the acquaintance level change worked
-        assertEquals(AcquaintanceLevel.GROUP, contactModel.data.value!!.acquaintanceLevel)
-
-        // When adding the contact again, it should be converted back to a direct contact
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is ContactModified)
-                assertTrue(it.acquaintanceLevelChanged)
-                assertFalse(it.verificationLevelChanged)
-                assertEquals(AcquaintanceLevel.DIRECT, contactModel.data.value!!.acquaintanceLevel)
-            },
-            newIdentity = newIdentity
-        )
-    }
-
-    @Test
-    fun testVerificationLevelUpgrade() {
-        val newIdentity = "01234567"
-
-        val apiConnectorResult: (identity: String) -> FetchIdentityResult = { identity ->
-            FetchIdentityResult().also {
-                it.identity = identity
-                it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                it.featureMask = 12
-                it.type = 0
-                it.state = IdentityState.ACTIVE
-            }
-        }
-
-        // The first time adding the contact should succeed
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is Success)
-            },
-            newIdentity = newIdentity
-        )
-
-        val contactModel = contactModelRepository.getByIdentity(newIdentity)!!
-
-        // Assert that the verification level is unverified
-        assertEquals(VerificationLevel.UNVERIFIED, contactModel.data.value!!.verificationLevel)
-
-        // When adding the contact again, it should be converted back to a direct contact
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is ContactModified)
-                assertTrue(it.verificationLevelChanged)
-                assertFalse(it.acquaintanceLevelChanged)
-                assertEquals(VerificationLevel.FULLY_VERIFIED, contactModel.data.value!!.verificationLevel)
-            },
-            newIdentity = newIdentity,
-            publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-        )
-    }
-
-    @Test
-    fun testAddAndVerifyGroupContact() {
-        val newIdentity = "01234567"
-
-        val apiConnectorResult: (identity: String) -> FetchIdentityResult = { identity ->
-            FetchIdentityResult().also {
-                it.identity = identity
-                it.publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-                it.featureMask = 12
-                it.type = 0
-                it.state = IdentityState.ACTIVE
-            }
-        }
-
-        // The first time adding the contact should succeed
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is Success)
-            },
-            newIdentity = newIdentity
-        )
-
-        val contactModel = contactModelRepository.getByIdentity(newIdentity)!!
-
-        // Assert that the verification level is unverified
-        assertEquals(VerificationLevel.UNVERIFIED, contactModel.data.value!!.verificationLevel)
-
-        // Downgrade the contact to acquaintance level group
-        contactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.GROUP)
-        assertEquals(AcquaintanceLevel.GROUP, contactModel.data.value!!.acquaintanceLevel)
-
-        // When adding the contact again, it should be converted back to a direct contact
-        testAddingContact(
-            apiConnectorResult,
-            {
-                assertTrue(it is ContactModified)
-                assertTrue(it.acquaintanceLevelChanged)
-                assertTrue(it.verificationLevelChanged)
-                assertEquals(AcquaintanceLevel.DIRECT, contactModel.data.value!!.acquaintanceLevel)
-                assertEquals(VerificationLevel.FULLY_VERIFIED, contactModel.data.value!!.verificationLevel)
-            },
-            newIdentity = newIdentity,
-            publicKey = ByteArray(NaCl.PUBLICKEYBYTES)
-        )
-    }
-
-    private fun testAddingContact(
-        fetchIdentity: (identity: String) -> FetchIdentityResult,
-        runOnFinished: (result: ContactAddResult) -> Unit,
-        newIdentity: String = "01234567",
-        myIdentity: String = "00000000",
-        publicKey: ByteArray? = null,
-    ) {
-        val apiConnector = getTestApiConnector {
-            if (it != newIdentity) {
-                fail("Wrong identity is fetched: $it")
-            }
-
-            fetchIdentity(it)
-        }
-
-        val contactAdded = backgroundExecutor.executeDeferred(object : AddOrUpdateContactBackgroundTask(
-            newIdentity,
-            myIdentity,
-            apiConnector,
-            contactModelRepository,
-            AddContactRestrictionPolicy.CHECK,
-            ThreemaApplication.getAppContext(),
-            publicKey,
-        ) {
-            override fun onFinished(result: ContactAddResult) {
-                runOnFinished(result)
-            }
-        })
-
-        // Assert that the test is not stopped before running the background task completely
-        runBlocking {
-            contactAdded.await()
-        }
-    }
-
-    private fun getTestApiConnector(onIdentityFetchCalled: (identity: String) -> FetchIdentityResult): APIConnector {
-        val sslSocketFactoryFactory = SSLSocketFactoryFactory { host: String? ->
-            ConfigUtils.getSSLSocketFactory(host)
-        }
-
-        return object : APIConnector(false, null, false, sslSocketFactoryFactory) {
-            override fun fetchIdentity(identity: String) = onIdentityFetchCalled(identity)
-        }
-    }
-
-}
diff --git a/app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt b/app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt
deleted file mode 100644
index 031dbcc7..00000000
--- a/app/src/androidTest/java/ch/threema/app/edithistory/EditHistoryTest.kt
+++ /dev/null
@@ -1,391 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.edithistory
-
-import androidx.test.core.app.launchActivity
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import androidx.test.filters.LargeTest
-import ch.threema.app.DangerousTest
-import ch.threema.app.activities.HomeActivity
-import ch.threema.app.asynctasks.EmptyOrDeleteConversationsAsyncTask
-import ch.threema.app.processors.MessageProcessorProvider
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.GroupService
-import ch.threema.app.services.MessageService
-import ch.threema.data.storage.EditHistoryDao
-import ch.threema.data.storage.EditHistoryDaoImpl
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.DeleteMessage
-import ch.threema.domain.protocol.csp.messages.DeleteMessageData
-import ch.threema.domain.protocol.csp.messages.EditMessage
-import ch.threema.domain.protocol.csp.messages.EditMessageData
-import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
-import ch.threema.domain.protocol.csp.messages.GroupEditMessage
-import ch.threema.domain.protocol.csp.messages.GroupTextMessage
-import ch.threema.domain.protocol.csp.messages.TextMessage
-import ch.threema.storage.factories.GroupMessageModelFactory
-import ch.threema.storage.factories.MessageModelFactory
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.GroupMessageModel
-import ch.threema.storage.models.MessageModel
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.test.runTest
-import org.junit.Test
-import org.junit.runner.RunWith
-import java.util.Date
-import kotlin.test.assertEquals
-
-@RunWith(AndroidJUnit4::class)
-@LargeTest
-@DangerousTest
-class EditHistoryTest : MessageProcessorProvider() {
-
-    private val messageService: MessageService by lazy { serviceManager.messageService }
-    private val contactService: ContactService by lazy { serviceManager.contactService }
-    private val groupService: GroupService by lazy { serviceManager.groupService }
-    private val messageModelFactory: MessageModelFactory by lazy { serviceManager.databaseServiceNew.messageModelFactory }
-    private val groupMessageModelFactory: GroupMessageModelFactory by lazy { serviceManager.databaseServiceNew.groupMessageModelFactory }
-    private val editHistoryDao: EditHistoryDao by lazy { EditHistoryDaoImpl(serviceManager.databaseServiceNew) }
-
-    @Test
-    fun testHistoryDeletedOnContactMessageDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageService.remove(messageModel)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnGroupMessageDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveGroupTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageService.remove(messageModel)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnIncomingContactMessageRemoteDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.receiveDelete()
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnIncomingGroupMessageRemoteDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveGroupTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.receiveDelete()
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnOutgoingContactMessageRemoteDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = sendContactTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.sendEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.sendDelete()
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnOutgoingGroupMessageRemoteDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = sendGroupTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.sendEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.sendDelete()
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnEmptyContactChat() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.emptyOrDeleteChat(EmptyOrDeleteConversationsAsyncTask.Mode.EMPTY)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnEmptyGroupChat() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveGroupTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.emptyOrDeleteChat(EmptyOrDeleteConversationsAsyncTask.Mode.EMPTY)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnDeleteContactChat() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.emptyOrDeleteChat(EmptyOrDeleteConversationsAsyncTask.Mode.DELETE)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnDeleteGroupChat() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveGroupTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        messageModel.emptyOrDeleteChat(EmptyOrDeleteConversationsAsyncTask.Mode.DELETE)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnContactDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        contactService.remove(contactA.contactModel)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    @Test
-    fun testHistoryDeletedOnGroupDelete() = runTest {
-        launchActivity<HomeActivity>()
-
-        val messageModel = receiveGroupTextMessage()
-
-        messageModel.assertHistorySize(0)
-
-        messageModel.receiveEdit()
-
-        messageModel.assertHistorySize(1)
-
-        groupService.leaveOrDissolveAndRemoveFromLocal(groupA.groupModel)
-
-        messageModel.assertHistorySize(0)
-    }
-
-    private suspend fun AbstractMessageModel.emptyOrDeleteChat(mode: EmptyOrDeleteConversationsAsyncTask.Mode) {
-        val receiver = messageService.getMessageReceiver(this)
-        val deferred = CompletableDeferred<Unit>()
-        @Suppress("DEPRECATION")
-        EmptyOrDeleteConversationsAsyncTask(
-            mode,
-            arrayOf(receiver),
-            serviceManager.conversationService,
-            serviceManager.groupService,
-            serviceManager.distributionListService,
-            null, null
-        ) { deferred.complete(Unit) }.execute()
-        deferred.await()
-    }
-
-    private suspend fun receiveTextMessage(): MessageModel {
-        val message = TextMessage().apply {
-            text = "Original Text"
-            fromIdentity = contactA.identity
-            toIdentity = myContact.identity
-            messageId = MessageId()
-        }
-
-        processMessage(message, contactA.identityStore)
-
-        return messageModelFactory.getByApiMessageIdAndIdentity(message.messageId, message.fromIdentity)!!
-    }
-
-    private suspend fun MessageModel.receiveEdit() {
-        val editMessage = EditMessage(EditMessageData(
-            MessageId.fromString(apiMessageId).messageIdLong,
-            "$body Edited"
-        )).apply {
-            fromIdentity = identity
-            toIdentity = myContact.identity
-        }
-        processMessage(editMessage, contactA.identityStore)
-    }
-
-    private suspend fun MessageModel.receiveDelete() {
-        val deleteMessage = DeleteMessage(
-            DeleteMessageData(MessageId.fromString(apiMessageId).messageIdLong)
-        ).apply {
-            fromIdentity = identity
-            toIdentity = myContact.identity
-        }
-        processMessage(deleteMessage, contactA.identityStore)
-    }
-
-    private suspend fun receiveGroupTextMessage(): GroupMessageModel {
-        val message = GroupTextMessage().apply {
-            text = "Original Text"
-            apiGroupId = groupA.apiGroupId
-            groupCreator = groupA.groupCreator.identity
-            fromIdentity = contactA.identity
-            toIdentity = myContact.identity
-            messageId = MessageId()
-        }
-
-        processMessage(message, contactA.identityStore)
-
-        return groupMessageModelFactory.getByApiMessageIdAndIdentity(message.messageId, message.fromIdentity)!!
-    }
-
-    private suspend fun GroupMessageModel.receiveEdit() {
-        val editMessage = GroupEditMessage(EditMessageData(
-            MessageId.fromString(apiMessageId).messageIdLong,
-            "$body Edited"
-        )).apply {
-            apiGroupId = groupA.apiGroupId
-            groupCreator = groupA.groupCreator.identity
-            fromIdentity = identity
-            toIdentity = myContact.identity
-        }
-        processMessage(editMessage, contactA.identityStore)
-    }
-
-    private suspend fun GroupMessageModel.receiveDelete() {
-        val deleteMessage = GroupDeleteMessage(
-            DeleteMessageData(MessageId.fromString(apiMessageId).messageIdLong)
-        ).apply {
-            apiGroupId = groupA.apiGroupId
-            groupCreator = groupA.groupCreator.identity
-            fromIdentity = identity
-            toIdentity = myContact.identity
-        }
-        processMessage(deleteMessage, contactA.identityStore)
-    }
-
-    private fun sendContactTextMessage(): MessageModel {
-        val receiver = contactService.createReceiver(contactA.contactModel)
-        val message = messageService.sendText("Text", receiver) as MessageModel
-        return message
-    }
-
-    private fun AbstractMessageModel.sendEdit() {
-        val receiver = messageService.getMessageReceiver(this)
-        messageService.sendEditedMessageText(this, "$body Edited", Date(), receiver)
-    }
-
-    private fun AbstractMessageModel.sendDelete() {
-        val receiver = messageService.getMessageReceiver(this)
-        messageService.sendDeleteMessage(this, receiver)
-    }
-
-    private fun sendGroupTextMessage(): GroupMessageModel {
-        val receiver = groupService.createReceiver(groupA.groupModel)
-        val message = messageService.sendText("Text", receiver) as GroupMessageModel
-
-        return message
-    }
-
-    private fun <T : AbstractMessageModel> T.assertHistorySize(size: Int) {
-        assertEquals(
-            size,
-            editHistoryDao.findAllByMessageUid(uid).size
-        )
-    }
-}
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/GroupControlTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/GroupControlTest.kt
index 1c183cf8..56265f74 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/GroupControlTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/GroupControlTest.kt
@@ -21,6 +21,8 @@
 
 package ch.threema.app.groupmanagement
 
+import android.Manifest
+import android.os.Build
 import androidx.test.core.app.ActivityScenario
 import androidx.test.core.app.launchActivity
 import androidx.test.espresso.Espresso
@@ -28,29 +30,161 @@ import androidx.test.espresso.NoMatchingViewException
 import androidx.test.espresso.action.ViewActions
 import androidx.test.espresso.intent.Intents
 import androidx.test.espresso.matcher.ViewMatchers
+import androidx.test.rule.GrantPermissionRule
 import ch.threema.app.R
+import ch.threema.app.ThreemaApplication
 import ch.threema.app.activities.HomeActivity
-import ch.threema.app.processors.MessageProcessorProvider
+import ch.threema.app.managers.ServiceManager
+import ch.threema.app.services.FileService
+import ch.threema.app.testutils.TestHelpers
+import ch.threema.app.testutils.TestHelpers.TestContact
 import ch.threema.app.testutils.TestHelpers.TestGroup
+import ch.threema.base.crypto.NonceFactory
+import ch.threema.base.crypto.NonceStoreInterface
+import ch.threema.domain.helpers.InMemoryContactStore
+import ch.threema.domain.models.GroupId
+import ch.threema.domain.protocol.csp.coders.MessageBox
+import ch.threema.domain.protocol.csp.coders.MessageCoder
+import ch.threema.domain.protocol.csp.connection.MessageQueue
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
+import ch.threema.domain.protocol.csp.messages.AbstractMessage
+import ch.threema.domain.protocol.csp.messages.GroupCreateMessage
 import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
+import ch.threema.domain.protocol.csp.messages.GroupRequestSyncMessage
+import ch.threema.domain.stores.ContactStore
 import ch.threema.domain.stores.IdentityStoreInterface
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runTest
+import ch.threema.storage.DatabaseServiceNew
+import ch.threema.storage.models.GroupMemberModel
+import org.junit.After
 import org.junit.Assert.assertArrayEquals
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Rule
 import org.junit.Test
+import java.lang.reflect.Field
 
 /**
  * A collection of basic data and utility functions to test group control messages. If the common
  * group receive steps should not be executed for a certain message type, the common group step
  * receive methods should be overridden.
  */
-@ExperimentalCoroutinesApi
-abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProvider() {
+abstract class GroupControlTest<T : AbstractGroupMessage> {
+
+    protected val myContact: TestContact = TestHelpers.TEST_CONTACT
+    protected val contactA = TestContact("12345678")
+    protected val contactB = TestContact("ABCDEFGH")
+    protected val contactC = TestContact("SX96PM5A")
+
+    protected val myGroup = TestGroup(GroupId(0), myContact, listOf(myContact, contactA), "MyGroup")
+    protected val myGroupWithProfilePicture = TestGroup(GroupId(1), myContact, listOf(myContact, contactA), "MyGroupWithPicture", byteArrayOf(0, 1, 2, 3))
+    protected val groupA = TestGroup(GroupId(2), contactA, listOf(myContact, contactA), "GroupA")
+    protected val groupB = TestGroup(GroupId(3), contactB, listOf(myContact, contactB), "GroupB")
+    protected val groupAB = TestGroup(GroupId(4), contactA, listOf(myContact, contactA, contactB), "GroupAB")
+    protected val groupAUnknown = TestGroup(GroupId(5), contactA, listOf(myContact, contactA, contactB), "GroupAUnknown")
+    protected val groupALeft = TestGroup(GroupId(6), contactA, listOf(contactA, contactB), "GroupALeft")
+    protected val myUnknownGroup = TestGroup(GroupId(7), myContact, listOf(myContact, contactA), "MyUnknownGroup")
+    protected val myLeftGroup = TestGroup(GroupId(8), myContact, listOf(contactA), "MyLeftGroup")
+    protected val newAGroup = TestGroup(GroupId(9), contactA, listOf(myContact, contactA, contactB), "NewAGroup")
+
+    protected val serviceManager: ServiceManager = ThreemaApplication.requireServiceManager()
+    private val contactStore: ContactStore = InMemoryContactStore().apply {
+        addContact(myContact.contact, true)
+        addContact(contactA.contact, true)
+        addContact(contactB.contact, true)
+        addContact(contactC.contact, true)
+    }
+
+    private val mutableSentMessages: MutableList<AbstractMessage> = mutableListOf()
+    protected val sentMessages: List<AbstractMessage> = mutableSentMessages
+
+    protected val initialContacts = listOf(myContact, contactA, contactB, contactC)
+
+    protected val initialGroups =
+        listOf(myGroup, myGroupWithProfilePicture, groupA, groupB, groupAB, groupALeft, myLeftGroup)
+
+    @JvmField
+    @Rule
+    val grantPermissionRule: GrantPermissionRule =
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+            GrantPermissionRule.grant(Manifest.permission.POST_NOTIFICATIONS)
+        } else {
+            GrantPermissionRule.grant()
+        }
+
+    /**
+     * Asserts that the correct identity is set up and fills the database with the initial data.
+     */
+    @Before
+    fun setup() {
+        assert(myContact.identity == TestHelpers.ensureIdentity(ThreemaApplication.requireServiceManager()))
+
+        setMessageQueue()
+
+        serviceManager.connection.stop()
+
+        cleanup()
+
+        fillDatabase()
+    }
+
+    /**
+     * Clean the data after the tests. This includes the deletion of the database entries, the
+     * avatar files, and the blocked contacts.
+     */
+    @After
+    fun cleanup() {
+        // Clear conversations
+        serviceManager.conversationService.getAll(true).forEach {
+            serviceManager.conversationService.clear(it)
+        }
+
+        // Delete database
+        serviceManager.databaseServiceNew.apply {
+            contactModelFactory.deleteAll()
+            messageModelFactory.deleteAll()
+            groupCallModelFactory.deleteAll()
+            groupInviteModelFactory.deleteAll()
+            groupBallotModelFactory.deleteAll()
+            groupMessagePendingMessageIdModelFactory.deleteAll()
+            groupMemberModelFactory.deleteAll()
+            groupMessageModelFactory.deleteAll()
+            // Remove group models from group service to empty the group service cache
+            serviceManager.groupService.removeAll()
+            distributionListModelFactory.deleteAll()
+            distributionListMemberModelFactory.deleteAll()
+            distributionListMessageModelFactory.deleteAll()
+            groupRequestSyncLogModelFactory.deleteAll()
+            ballotModelFactory.deleteAll()
+            ballotChoiceModelFactory.deleteAll()
+            ballotVoteModelFactory.deleteAll()
+            identityBallotModelFactory.deleteAll()
+            webClientSessionModelFactory.deleteAll()
+            conversationTagFactory.deleteAll()
+            outgoingGroupJoinRequestModelFactory.deleteAll()
+            incomingGroupJoinRequestModelFactory.deleteAll()
+            serverMessageModelFactory.deleteAll()
+        }
+
+        // Remove files
+        serviceManager.fileService.removeAllAvatars()
+
+        // Unblock contacts
+        serviceManager.blackListService.removeAll()
+    }
+
+    /**
+     * Fills basic data into the database. This is executed before each test. Override this if other
+     * database entries are needed.
+     */
+    open fun fillDatabase() {
+        val databaseService = serviceManager.databaseServiceNew
+        val fileService = serviceManager.fileService
+
+        initialContacts.forEach { addContactToDatabase(it, databaseService, true) }
+
+        initialGroups.forEach { addGroupToDatabase(it, databaseService, fileService) }
+    }
 
     /**
      * Create a message of the tested group message type. This is used to create a message that will
@@ -63,6 +197,8 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
 
         val scenario = launchActivity<HomeActivity>()
 
+        Thread.sleep(200)
+
         do {
             var switchedToMessages = false
             try {
@@ -75,21 +211,36 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
 
         Intents.release()
 
+        Thread.sleep(200)
+
         return scenario
     }
 
+    /**
+     * Send a message from a user with the provided identity store.
+     */
+    protected fun processMessage(message: AbstractMessage, identityStore: IdentityStoreInterface) {
+        val messageBox = createMessageBox(message, identityStore)
+
+        // Process the group message
+        val processingResult = serviceManager.messageProcessor.processIncomingMessage(messageBox)
+        assertTrue(processingResult.wasProcessed())
+
+        // Give the listeners enough time to fire the event
+        Thread.sleep(200)
+    }
+
     /**
      * Check step 2.1 of the common group receive steps: The group could not be found and the user
      * is the creator of the group (as alleged by the message). The message should be discarded.
      */
     @Test
-    open fun testCommonGroupReceiveStep2_1() = runTest {
+    open fun testCommonGroupReceiveStep2_1() {
         val (message, identityStore) = getMyUnknownGroupMessage()
         setupAndProcessMessage(message, identityStore)
 
         // Nothing is expected to be sent
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
+        assertEquals(0, sentMessages.size)
     }
 
     /**
@@ -97,18 +248,16 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
      * is not the creator. In this case, a group sync request should be sent.
      */
     @Test
-    open fun testCommonGroupReceiveStep2_2() = runTest {
+    open fun testCommonGroupReceiveStep2_2() {
         val (message, identityStore) = getUnknownGroupMessage()
         setupAndProcessMessage(message, identityStore)
 
-        val firstMessage = sentMessagesInsideTask.poll() as GroupSyncRequestMessage
+        assertEquals(1, sentMessages.size)
+        val firstMessage = sentMessages.first() as GroupRequestSyncMessage
         assertEquals(message.groupCreator, firstMessage.toIdentity)
         assertEquals(message.toIdentity, firstMessage.fromIdentity)
         assertEquals(message.apiGroupId, firstMessage.apiGroupId)
         assertEquals(message.groupCreator, firstMessage.groupCreator)
-
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
     }
 
     /**
@@ -117,20 +266,18 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
      * sent back to the sender.
      */
     @Test
-    open fun testCommonGroupReceiveStep3_1() = runTest {
+    open fun testCommonGroupReceiveStep3_1() {
         val (message, identityStore) = getMyLeftGroupMessage()
         setupAndProcessMessage(message, identityStore)
 
         // Check that empty sync is sent.
-        val firstMessage = sentMessagesInsideTask.poll() as GroupSetupMessage
+        assertEquals(1, sentMessages.size)
+        val firstMessage = sentMessages.first() as GroupCreateMessage
         assertEquals(message.fromIdentity, firstMessage.toIdentity)
         assertEquals(myContact.identity, firstMessage.fromIdentity)
         assertEquals(message.apiGroupId, firstMessage.apiGroupId)
         assertEquals(message.groupCreator, firstMessage.groupCreator)
         assertArrayEquals(emptyArray<String>(), firstMessage.members)
-
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
     }
 
     /**
@@ -138,33 +285,30 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
      * not the creator of the group. In this case, a group leave should be sent back to the sender.
      */
     @Test
-    open fun testCommonGroupReceiveStep3_2() = runTest {
+    open fun testCommonGroupReceiveStep3_2() {
         // First, test the common group receive steps for a message from the group creator
         val (firstIncomingMessage, firstIdentityStore) = getLeftGroupMessageFromCreator()
         setupAndProcessMessage(firstIncomingMessage, firstIdentityStore)
 
         // Check that a group leave is sent back to the sender
-        val firstSentMessage = sentMessagesInsideTask.poll() as GroupLeaveMessage
+        assertEquals(1, sentMessages.size)
+        val firstSentMessage = sentMessages.first() as GroupLeaveMessage
         assertEquals(firstIncomingMessage.fromIdentity, firstSentMessage.toIdentity)
         assertEquals(myContact.identity, firstSentMessage.fromIdentity)
         assertEquals(firstIncomingMessage.apiGroupId, firstSentMessage.apiGroupId)
         assertEquals(firstIncomingMessage.groupCreator, firstSentMessage.groupCreator)
 
-        assertTrue(sentMessagesInsideTask.isEmpty())
-
         // Second, test the common group receive steps for a message from a group member
         val (secondIncomingMessage, secondIdentityStore) = getLeftGroupMessage()
         setupAndProcessMessage(secondIncomingMessage, secondIdentityStore)
 
         // Check that a group leave is sent back to the sender
-        val secondSentMessage = sentMessagesInsideTask.poll() as GroupLeaveMessage
+        assertEquals(2, sentMessages.size)
+        val secondSentMessage = sentMessages[1] as GroupLeaveMessage
         assertEquals(secondIncomingMessage.fromIdentity, secondSentMessage.toIdentity)
         assertEquals(myContact.identity, secondSentMessage.fromIdentity)
         assertEquals(secondIncomingMessage.apiGroupId, secondSentMessage.apiGroupId)
         assertEquals(secondIncomingMessage.groupCreator, secondSentMessage.groupCreator)
-
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
     }
 
     /**
@@ -173,20 +317,18 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
      * should be sent back to the sender.
      */
     @Test
-    open fun testCommonGroupReceiveStep4_1() = runTest {
+    open fun testCommonGroupReceiveStep4_1() {
         val (message, identityStore) = getSenderNotMemberOfMyGroupMessage()
         setupAndProcessMessage(message, identityStore)
 
         // Check that a group setup with empty member list is sent back to the sender
-        val firstMessage = sentMessagesInsideTask.poll() as GroupSetupMessage
+        assertEquals(1, sentMessages.size)
+        val firstMessage = sentMessages.first() as GroupCreateMessage
         assertEquals(message.fromIdentity, firstMessage.toIdentity)
         assertEquals(myContact.identity, firstMessage.fromIdentity)
         assertEquals(message.apiGroupId, firstMessage.apiGroupId)
         assertEquals(message.groupCreator, firstMessage.groupCreator)
         assertArrayEquals(emptyArray<String>(), firstMessage.members)
-
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
     }
 
     /**
@@ -194,24 +336,46 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
      * the user is not the creator of the group. The message should be discarded.
      */
     @Test
-    open fun testCommonGroupReceiveStep4_2() = runTest {
+    open fun testCommonGroupReceiveStep4_2() {
         val (message, identityStore) = getSenderNotMemberMessage()
         setupAndProcessMessage(message, identityStore)
 
-        // Check that a group sync request has been sent to the creator of the group
-        val firstMessage = sentMessagesInsideTask.poll() as GroupSyncRequestMessage
-        assertEquals(message.groupCreator, firstMessage.toIdentity)
-        assertEquals(myContact.identity, firstMessage.fromIdentity)
-        assertEquals(message.apiGroupId, firstMessage.apiGroupId)
-        assertEquals(message.groupCreator, firstMessage.groupCreator)
+        // Check that no message is sent
+        assertEquals(0, sentMessages.size)
+    }
 
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
+    private fun addContactToDatabase(
+        testContact: TestContact,
+        databaseService: DatabaseServiceNew,
+        addHidden: Boolean = false,
+    ) {
+        databaseService.contactModelFactory.createOrUpdate(
+            testContact.contactModel.setIsHidden(addHidden)
+        )
+    }
+
+    private fun addGroupToDatabase(
+        testGroup: TestGroup,
+        databaseService: DatabaseServiceNew,
+        fileService: FileService,
+    ) {
+        val groupModel = testGroup.groupModel
+        databaseService.groupModelFactory.createOrUpdate(groupModel)
+        testGroup.setLocalGroupId(groupModel.id)
+        testGroup.members.forEach { member ->
+            val memberModel = GroupMemberModel()
+                .setGroupId(groupModel.id)
+                .setIdentity(member.identity)
+            databaseService.groupMemberModelFactory.createOrUpdate(memberModel)
+        }
+        if (testGroup.profilePicture != null) {
+            fileService.writeGroupAvatar(groupModel, testGroup.profilePicture)
+        }
     }
 
-    private suspend fun setupAndProcessMessage(
+    private fun setupAndProcessMessage(
         message: AbstractGroupMessage,
-        identityStore: IdentityStoreInterface,
+        identityStore: IdentityStoreInterface
     ) {
         // Start home activity and navigate to chat section
         launchActivity<HomeActivity>()
@@ -227,9 +391,6 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
      */
     private fun getMyUnknownGroupMessage() = createMessageForGroup().apply {
         enrich(myUnknownGroup)
-        // Set from identity to a different identity than myself. Note that this may have an effect
-        // on the group creator for messages that are wrapped in a group-creator-container.
-        fromIdentity = contactA.identity
     } to myUnknownGroup.groupCreator.identityStore
 
     /**
@@ -272,8 +433,8 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
      */
     private fun getSenderNotMemberOfMyGroupMessage() = createMessageForGroup().apply {
         enrich(myGroup)
-        fromIdentity = contactC.identity
-    } to contactC.identityStore
+        fromIdentity = contactB.identity
+    } to contactB.identityStore
 
     /**
      * Get a group message from a sender that is no member of the group.
@@ -291,6 +452,48 @@ abstract class GroupControlTest<T : AbstractGroupMessage> : MessageProcessorProv
         toIdentity = myContact.identity
     }
 
+    /**
+     * Create a message box from a user with the given identity store.
+     */
+    private fun createMessageBox(
+        msg: AbstractMessage,
+        identityStore: IdentityStoreInterface,
+    ): MessageBox {
+        val nonceFactory = NonceFactory(object : NonceStoreInterface {
+            override fun exists(nonce: ByteArray) = false
+            override fun store(nonce: ByteArray) = true
+        })
+
+        val messageCoder = MessageCoder(contactStore, identityStore)
+        return messageCoder.encode(msg, nonceFactory)
+    }
+
+    private fun setMessageQueue() {
+        val messageQueue = object :
+            MessageQueue(contactStore, myContact.identityStore, serviceManager.connection) {
+            override fun enqueue(message: AbstractMessage): MessageBox {
+                mutableSentMessages.add(message)
+                return MessageBox()
+            }
+        }
+
+        replaceMessageQueue(messageQueue, serviceManager)
+        replaceMessageQueue(messageQueue, serviceManager.contactService)
+        replaceMessageQueue(messageQueue, serviceManager.messageService)
+        replaceMessageQueue(messageQueue, serviceManager.groupJoinResponseService)
+        replaceMessageQueue(messageQueue, serviceManager.outgoingGroupJoinRequestService)
+        replaceMessageQueue(messageQueue, serviceManager.groupMessagingService)
+        serviceManager.forwardSecurityMessageProcessor?.let {
+            replaceMessageQueue(messageQueue, it)
+        }
+    }
+
+    private fun replaceMessageQueue(messageQueue: MessageQueue, c: Any) {
+        val messageQueueField: Field = c.javaClass.getDeclaredField("messageQueue")
+        messageQueueField.isAccessible = true
+        messageQueueField.set(c, messageQueue)
+    }
+
     protected fun <T> Iterable<T>.replace(original: T, new: T) =
         map { if (it == original) new else it }
 }
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt
index 40bfa7ac..62ded3cc 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupLeaveTest.kt
@@ -31,24 +31,21 @@ import ch.threema.app.managers.ListenerManager
 import ch.threema.app.testutils.TestHelpers.TestContact
 import ch.threema.app.testutils.TestHelpers.TestGroup
 import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
+import ch.threema.domain.protocol.csp.messages.GroupRequestSyncMessage
 import ch.threema.storage.models.GroupModel
 import junit.framework.TestCase.assertEquals
 import junit.framework.TestCase.assertFalse
 import junit.framework.TestCase.assertTrue
 import junit.framework.TestCase.fail
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-
-import kotlinx.coroutines.test.runTest
 import org.junit.After
 import org.junit.Assert.assertArrayEquals
+import org.junit.Ignore
 import org.junit.Test
 import org.junit.runner.RunWith
 
 /**
  * Tests that incoming group leave messages are handled correctly.
  */
-@ExperimentalCoroutinesApi
 @RunWith(AndroidJUnit4::class)
 @LargeTest
 @DangerousTest
@@ -58,7 +55,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * Test that contact A leaving my group works as expected.
      */
     @Test
-    fun testValidLeaveInMyGroup() = runTest {
+    fun testValidLeaveInMyGroup() {
         assertSuccessfulLeave(myGroup, contactA, true)
     }
 
@@ -66,7 +63,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * Test that contact B leaving groupAB works as expected.
      */
     @Test
-    fun testValidLeave() = runTest {
+    fun testValidLeave() {
         assertSuccessfulLeave(groupAB, contactB)
     }
 
@@ -74,7 +71,8 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * Test that the creator of a group cannot leave the group.
      */
     @Test
-    fun testLeaveFromCreator() = runTest {
+    @Ignore("TODO(ANDR-2385): ignore group leave messages from group creators")
+    fun testLeaveFromSender() {
         assertUnsuccessfulLeave(groupA, contactA)
         assertUnsuccessfulLeave(groupB, contactB)
     }
@@ -84,7 +82,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * not change anything).
      */
     @Test
-    fun testLeaveOfMyNonExistingGroup() = runTest {
+    fun testLeaveOfMyNonExistingGroup() {
         assertUnsuccessfulLeave(myUnknownGroup, contactA, emptyList())
     }
 
@@ -93,7 +91,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * no effect.
      */
     @Test
-    fun testLeaveOfNonExistingGroup() = runTest {
+    fun testLeaveOfNonExistingGroup() {
         assertUnsuccessfulLeave(groupAUnknown, contactB, emptyList(), true)
     }
 
@@ -102,7 +100,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * does not change anything).
      */
     @Test
-    fun testLeaveOfLeftGroup() = runTest {
+    fun testLeaveOfLeftGroup() {
         assertUnsuccessfulLeave(groupALeft, contactB, null, true)
     }
 
@@ -111,7 +109,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * changed).
      */
     @Test
-    fun testLeaveOfMyLeftGroup() = runTest {
+    fun testLeaveOfMyLeftGroup() {
         assertUnsuccessfulLeave(myLeftGroup, contactA)
     }
 
@@ -120,7 +118,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
      * effect.
      */
     @Test
-    fun testLeaveOfNonMember() = runTest {
+    fun testLeaveOfNonMember() {
         assertUnsuccessfulLeave(groupA, contactB)
     }
 
@@ -155,7 +153,7 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
         // The common group receive steps are not executed for group leave messages
     }
 
-    private suspend fun assertSuccessfulLeave(group: TestGroup, contact: TestContact, expectStateChange: Boolean = false) {
+    private fun assertSuccessfulLeave(group: TestGroup, contact: TestContact, expectStateChange: Boolean = false) {
         launchActivity<HomeActivity>()
 
         serviceManager.groupService.resetCache(group.groupModel.id)
@@ -185,10 +183,10 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
             serviceManager.groupService.getGroupMemberModels(group.groupModel).map { it.identity })
 
         // Assert that no message has been sent as a response to a group leave
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
     }
 
-    private suspend fun assertUnsuccessfulLeave(
+    private fun assertUnsuccessfulLeave(
         group: TestGroup,
         contact: TestContact,
         expectedMembers: List<String>? = null,
@@ -225,15 +223,15 @@ class IncomingGroupLeaveTest : GroupControlTest<GroupLeaveMessage>() {
 
         if (shouldSendSyncRequest) {
             // Should send sync request to the group creator
-            assertEquals(1, sentMessagesInsideTask.size)
-            val sentMessage = sentMessagesInsideTask.first() as GroupSyncRequestMessage
+            assertEquals(1, sentMessages.size)
+            val sentMessage = sentMessages.first() as GroupRequestSyncMessage
             assertEquals(myContact.identity, sentMessage.fromIdentity)
             assertEquals(group.groupCreator.identity, sentMessage.toIdentity)
             assertEquals(group.apiGroupId, sentMessage.apiGroupId)
             assertEquals(group.groupCreator.identity, sentMessage.groupCreator)
         } else {
             // Assert that no message has been sent as a response to the leave message
-            assertEquals(0, sentMessagesInsideTask.size)
+            assertEquals(0, sentMessages.size)
         }
     }
 
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt
index fd339db3..6fef4110 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupNameTest.kt
@@ -29,11 +29,10 @@ import ch.threema.app.managers.ListenerManager
 import ch.threema.app.testutils.TestHelpers.TestContact
 import ch.threema.app.testutils.TestHelpers.TestGroup
 import ch.threema.domain.models.GroupId
-import ch.threema.domain.protocol.csp.messages.GroupNameMessage
+import ch.threema.domain.protocol.csp.messages.GroupRenameMessage
 import ch.threema.storage.models.GroupModel
 import junit.framework.TestCase.*
 import kotlinx.coroutines.*
-import kotlinx.coroutines.test.runTest
 import org.junit.After
 import org.junit.Assert.assertArrayEquals
 import org.junit.Test
@@ -43,22 +42,20 @@ import java.util.*
 /**
  * Tests that incoming group name messages are handled correctly.
  */
-@ExperimentalCoroutinesApi
 @RunWith(AndroidJUnit4::class)
 @LargeTest
 @DangerousTest
-class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
+class IncomingGroupNameTest : GroupConversationListTest<GroupRenameMessage>() {
 
-    override fun createMessageForGroup(): GroupNameMessage {
-        return GroupNameMessage()
-            .apply { groupName = "New Group Name" }
+    override fun createMessageForGroup(): GroupRenameMessage {
+        return GroupRenameMessage().apply { groupName = "New Group Name" }
     }
 
     /**
      * Tests that a (valid) group rename message really changes the group name.
      */
     @Test
-    fun testValidGroupRename() = runTest {
+    fun testValidGroupRename() {
         // Start home activity and navigate to chat section
         val activityScenario = startScenario()
 
@@ -94,7 +91,7 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
      * does not lead to a group name change.
      */
     @Test
-    fun testInvalidGroupRenameSender() = runTest {
+    fun testInvalidGroupRenameSender() {
         // Start home activity and navigate to chat section
         val activityScenario = startScenario()
 
@@ -124,8 +121,7 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
     }
 
     override fun testCommonGroupReceiveStep2_1() {
-        // Don't test this as a group name message always comes from the group creator which would
-        // be this user in this test
+        runWithoutGroupRename { super.testCommonGroupReceiveStep2_1() }
     }
 
     override fun testCommonGroupReceiveStep2_2() {
@@ -166,7 +162,7 @@ class IncomingGroupNameTest : GroupConversationListTest<GroupNameMessage>() {
         groupCreatorIdentity: String,
         apiGroupId: GroupId,
         fromContact: TestContact,
-    ) = GroupNameMessage().apply {
+    ) = GroupRenameMessage().apply {
         groupName = newGroupName
         groupCreator = groupCreatorIdentity
         fromIdentity = fromContact.identity
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt
index 5381b658..7dbbd417 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSetupTest.kt
@@ -28,12 +28,10 @@ import ch.threema.app.listeners.GroupListener
 import ch.threema.app.managers.ListenerManager
 import ch.threema.app.testutils.TestHelpers.TestContact
 import ch.threema.app.testutils.TestHelpers.TestGroup
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
+import ch.threema.domain.protocol.csp.messages.GroupCreateMessage
 import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
 import ch.threema.storage.models.GroupModel
 import junit.framework.TestCase
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runTest
 import org.junit.After
 import org.junit.Assert
 import org.junit.Assert.assertEquals
@@ -47,19 +45,18 @@ import org.junit.runner.RunWith
  * Runs different tests that verify that incoming group setup messages are handled according to the
  * protocol.
  */
-@ExperimentalCoroutinesApi
 @RunWith(AndroidJUnit4::class)
 @LargeTest
 @DangerousTest
-class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
+class IncomingGroupSetupTest : GroupConversationListTest<GroupCreateMessage>() {
 
-    override fun createMessageForGroup() = GroupSetupMessage()
+    override fun createMessageForGroup() = GroupCreateMessage()
 
     /**
      * Test a group setup message of an unknown group where the user is not not a member.
      */
     @Test
-    fun testUnknownGroupNotMember() = runTest {
+    fun testUnknownGroupNotMember() {
         val scenario = startScenario()
 
         // Assert initial group conversations
@@ -86,7 +83,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         assertGroupConversations(scenario, initialGroups)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Assert that no action has been triggered
         setupTracker.assertAllNewMembersAdded()
@@ -99,7 +96,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
      * Test a group setup message of an unknown group that has no members.
      */
     @Test
-    fun testUnknownEmptyGroup() = runTest {
+    fun testUnknownEmptyGroup() {
         val scenario = startScenario()
 
         // Assert initial group conversations
@@ -126,7 +123,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         assertGroupConversations(scenario, initialGroups)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Assert that no action has been triggered
         setupTracker.assertAllNewMembersAdded()
@@ -139,14 +136,14 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
      * Test a group setup message of a blocked contact.
      */
     @Test
-    fun testBlocked() = runTest {
+    fun testBlocked() {
         val scenario = startScenario()
 
         // Assert initial group conversations
         assertGroupConversations(scenario, initialGroups)
 
-        serviceManager.blockedContactsService.add(contactA.identity)
-        serviceManager.blockedContactsService.add(contactB.identity)
+        serviceManager.blackListService.add(contactA.identity)
+        serviceManager.blackListService.add(contactB.identity)
 
         val setupTracker = GroupSetupTracker(
             newAGroup,
@@ -168,12 +165,12 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
 
         // Assert that a group leave message is sent to the created and all provided members
         // including those that are blocked
-        assertEquals(2, sentMessagesInsideTask.size)
-        val first = sentMessagesInsideTask.first() as GroupLeaveMessage
+        assertEquals(2, sentMessages.size)
+        val first = sentMessages.first() as GroupLeaveMessage
         assertEquals(myContact.identity, first.fromIdentity)
         assertEquals(newAGroup.apiGroupId, first.apiGroupId)
         assertEquals(newAGroup.groupCreator.identity, first.groupCreator)
-        val second = sentMessagesInsideTask.last() as GroupLeaveMessage
+        val second = sentMessages.last() as GroupLeaveMessage
         assertEquals(myContact.identity, second.fromIdentity)
         assertEquals(newAGroup.apiGroupId, second.apiGroupId)
         assertEquals(newAGroup.groupCreator.identity, second.groupCreator)
@@ -194,7 +191,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
      * Test a group setup message of a group where the user is not a member anymore.
      */
     @Test
-    fun testKicked() = runTest {
+    fun testKicked() {
         val scenario = startScenario()
 
         // Assert initial group conversations
@@ -221,7 +218,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         assertGroupConversations(scenario, initialGroups)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Assert that the user has been kicked and the members are updated
         setupTracker.assertAllNewMembersAdded()
@@ -234,7 +231,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
      * Test a group setup message of a group where the members changed.
      */
     @Test
-    fun testMembersChanged() = runTest {
+    fun testMembersChanged() {
         val scenario = startScenario()
 
         // Assert initial group conversations
@@ -262,7 +259,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         assertGroupConversations(scenario, initialGroups)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Assert that the members have changed
         setupTracker.assertAllNewMembersAdded()
@@ -275,7 +272,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
      * Test a group setup message of a newly created group.
      */
     @Test
-    fun testNewGroup() = runTest {
+    fun testNewGroup() {
         val scenario = startScenario()
 
         // Assert initial group conversations
@@ -309,7 +306,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         assertGroupConversations(scenario, initialGroups + newGroup)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Assert that the group has been created and the new members are set correctly
         setupTracker.assertAllNewMembersAdded()
@@ -322,7 +319,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
      * Test two group setup messages that remove and then add the user.
      */
     @Test
-    fun testRemoveJoin() = runTest {
+    fun testRemoveJoin() {
         val scenario = startScenario()
 
         // Assert initial group conversations
@@ -346,7 +343,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         processMessage(removeMessage, groupAB.groupCreator.identityStore)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Create the group setup message (now again with this user)
         val addMessage = createGroupSetupMessage(groupAB)
@@ -356,7 +353,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         processMessage(addMessage, groupAB.groupCreator.identityStore)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Assert that the user has been kicked and added again
         setupTracker.assertAllNewMembersAdded()
@@ -366,7 +363,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
     }
 
     @Test
-    fun testGroupContainingInvalidIDs() = runTest {
+    fun testGroupContainingInvalidIDs() {
         val scenario = startScenario()
 
         // Assert initial group conversations
@@ -403,7 +400,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         assertGroupConversations(scenario, initialGroups + newGroup)
 
         // Assert that no message is sent
-        assertEquals(0, sentMessagesInsideTask.size)
+        assertEquals(0, sentMessages.size)
 
         // Assert that the group has been created and the new members are set correctly
         setupTracker.assertAllNewMembersAdded()
@@ -412,8 +409,7 @@ class IncomingGroupSetupTest : GroupConversationListTest<GroupSetupMessage>() {
         setupTracker.stop()
     }
 
-    private fun createGroupSetupMessage(testGroup: TestGroup) = GroupSetupMessage()
-        .apply {
+    private fun createGroupSetupMessage(testGroup: TestGroup) = GroupCreateMessage().apply {
         apiGroupId = testGroup.apiGroupId
         groupCreator = testGroup.groupCreator.identity
         fromIdentity = testGroup.groupCreator.identity
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSyncRequestTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSyncRequestTest.kt
index 7e7b27b5..7e50097f 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSyncRequestTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupSyncRequestTest.kt
@@ -28,12 +28,10 @@ import ch.threema.app.DangerousTest
 import ch.threema.app.activities.HomeActivity
 import ch.threema.app.testutils.TestHelpers.TestContact
 import ch.threema.app.testutils.TestHelpers.TestGroup
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeleteProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.GroupNameMessage
-import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runTest
+import ch.threema.domain.protocol.csp.messages.GroupCreateMessage
+import ch.threema.domain.protocol.csp.messages.GroupDeletePhotoMessage
+import ch.threema.domain.protocol.csp.messages.GroupRenameMessage
+import ch.threema.domain.protocol.csp.messages.GroupRequestSyncMessage
 import org.junit.Assert.assertArrayEquals
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
@@ -43,39 +41,35 @@ import org.junit.runner.RunWith
 /**
  * Tests that incoming group sync request messages are handled correctly.
  */
-@OptIn(ExperimentalCoroutinesApi::class)
 @RunWith(AndroidJUnit4::class)
 @LargeTest
 @DangerousTest
-class IncomingGroupSyncRequestTest : GroupControlTest<GroupSyncRequestMessage>() {
+class IncomingGroupSyncRequestTest : GroupControlTest<GroupRequestSyncMessage>() {
 
-    override fun createMessageForGroup() = GroupSyncRequestMessage()
+    override fun createMessageForGroup() = GroupRequestSyncMessage()
 
     @Test
-    fun testValidSyncRequest() = runTest {
+    fun testValidSyncRequest() {
         assertValidGroupSyncRequest(myGroup, contactA)
-
-        // Assert that the same group sync request will be ignored if a group sync request from the
-        // same sender for the same group has already been handled in the last hour.
-        assertIgnoredGroupSyncRequest(myGroup, contactA)
-
-        // Assert that a group sync request in the same group but from a different member is still
-        // answered.
-        assertValidGroupSyncRequest(myGroup, contactB)
     }
 
     @Test
-    fun testSyncRequestToMember() = runTest {
+    fun testSyncRequestToMember() {
         assertIgnoredGroupSyncRequest(groupAB, contactB)
     }
 
     @Test
-    fun testSyncRequestFromNonMember() = runTest {
-        assertLeftGroupSyncRequest(myGroup, contactC)
+    fun testSyncRequestFromNonMember() {
+        assertLeftGroupSyncRequest(myGroup, contactB)
     }
 
     @Test
-    fun testSyncRequestToLeftGroup() = runTest {
+    fun testSyncRequestFromMyself() {
+        assertIgnoredGroupSyncRequest(myGroup, myContact)
+    }
+
+    @Test
+    fun testSyncRequestToLeftGroup() {
         assertLeftGroupSyncRequest(myLeftGroup, contactA)
     }
 
@@ -103,12 +97,11 @@ class IncomingGroupSyncRequestTest : GroupControlTest<GroupSyncRequestMessage>()
         // Common group receive steps are not executed for group sync request messages
     }
 
-    private suspend fun assertValidGroupSyncRequest(group: TestGroup, contact: TestContact) {
+    private fun assertValidGroupSyncRequest(group: TestGroup, contact: TestContact) {
         launchActivity<HomeActivity>()
 
         // Create group sync request message
-        val groupSyncRequestMessage = GroupSyncRequestMessage()
-            .apply {
+        val groupRequestSyncMessage = GroupRequestSyncMessage().apply {
             fromIdentity = contact.identity
             toIdentity = myContact.identity
             apiGroupId = group.apiGroupId
@@ -116,10 +109,12 @@ class IncomingGroupSyncRequestTest : GroupControlTest<GroupSyncRequestMessage>()
         }
 
         // Process sync request message
-        processMessage(groupSyncRequestMessage, contact.identityStore)
+        processMessage(groupRequestSyncMessage, contact.identityStore)
+
+        assertEquals(3, sentMessages.size)
 
         // Check that the first sent message (setup) is correct
-        val setupMessage = sentMessagesInsideTask.poll() as GroupSetupMessage
+        val setupMessage = sentMessages[0] as GroupCreateMessage
         assertArrayEquals(group.members.map { it.identity }.toTypedArray(), setupMessage.members)
         assertEquals(myContact.contact.identity, setupMessage.fromIdentity)
         assertEquals(contact.identity, setupMessage.toIdentity)
@@ -127,7 +122,7 @@ class IncomingGroupSyncRequestTest : GroupControlTest<GroupSyncRequestMessage>()
         assertEquals(group.apiGroupId, setupMessage.apiGroupId)
 
         // Check that the second sent message (rename) is correct
-        val renameMessage = sentMessagesInsideTask.poll() as GroupNameMessage
+        val renameMessage = sentMessages[1] as GroupRenameMessage
         assertEquals(group.groupName, renameMessage.groupName)
         assertEquals(myContact.identity, renameMessage.fromIdentity)
         assertEquals(contact.identity, renameMessage.toIdentity)
@@ -137,49 +132,45 @@ class IncomingGroupSyncRequestTest : GroupControlTest<GroupSyncRequestMessage>()
         assertTrue("Groups with photo are not supported for testing", group.profilePicture == null)
 
         // Check that the third sent message (set/delete photo) is correct
-        val deletePhotoMessage = sentMessagesInsideTask.poll() as GroupDeleteProfilePictureMessage
+        val deletePhotoMessage = sentMessages[2] as GroupDeletePhotoMessage
         assertEquals(myContact.identity, deletePhotoMessage.fromIdentity)
         assertEquals(contact.identity, deletePhotoMessage.toIdentity)
         assertEquals(group.groupCreator.identity, deletePhotoMessage.groupCreator)
         assertEquals(group.apiGroupId, deletePhotoMessage.apiGroupId)
-
-        assertTrue(sentMessagesInsideTask.isEmpty())
     }
 
-    private suspend fun assertIgnoredGroupSyncRequest(group: TestGroup, contact: TestContact) {
+    private fun assertIgnoredGroupSyncRequest(group: TestGroup, contact: TestContact) {
         launchActivity<HomeActivity>()
 
         // Create group sync request message
-        val groupSyncRequestMessage = GroupSyncRequestMessage()
-            .apply {
+        val groupRequestSyncMessage = GroupRequestSyncMessage().apply {
             fromIdentity = contact.identity
             toIdentity = myContact.identity
             apiGroupId = group.apiGroupId
             groupCreator = group.groupCreator.identity
         }
 
-        processMessage(groupSyncRequestMessage, contact.identityStore)
+        processMessage(groupRequestSyncMessage, contact.identityStore)
 
-        assertTrue(sentMessagesInsideTask.isEmpty())
+        assertEquals(0, sentMessages.size)
     }
 
-    private suspend fun assertLeftGroupSyncRequest(group: TestGroup, contact: TestContact) {
+    private fun assertLeftGroupSyncRequest(group: TestGroup, contact: TestContact) {
         launchActivity<HomeActivity>()
 
         // Create group sync request message
-        val groupSyncRequestMessage = GroupSyncRequestMessage()
-            .apply {
+        val groupRequestSyncMessage = GroupRequestSyncMessage().apply {
             fromIdentity = contact.identity
             toIdentity = myContact.identity
             apiGroupId = group.apiGroupId
             groupCreator = group.groupCreator.identity
         }
 
-        processMessage(groupSyncRequestMessage, contact.identityStore)
+        processMessage(groupRequestSyncMessage, contact.identityStore)
 
         // Check that a setup message has been sent with empty members list
-        assertEquals(1, sentMessagesInsideTask.size)
-        val setupMessage = sentMessagesInsideTask.first() as GroupSetupMessage
+        assertEquals(1, sentMessages.size)
+        val setupMessage = sentMessages.first() as GroupCreateMessage
         assertArrayEquals(emptyArray(), setupMessage.members)
         assertEquals(myContact.contact.identity, setupMessage.fromIdentity)
         assertEquals(contact.identity, setupMessage.toIdentity)
diff --git a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupTextTest.kt b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupTextTest.kt
index 4779745c..5ba1505f 100644
--- a/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupTextTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/groupmanagement/IncomingGroupTextTest.kt
@@ -25,38 +25,15 @@ import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.filters.LargeTest
 import ch.threema.app.DangerousTest
 import ch.threema.domain.protocol.csp.messages.GroupTextMessage
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.runBlocking
-import org.junit.Assert
-import org.junit.Test
 import org.junit.runner.RunWith
 
 /**
  * Tests that the common group receive steps are executed for a group text message.
  */
-@OptIn(ExperimentalCoroutinesApi::class)
 @RunWith(AndroidJUnit4::class)
 @LargeTest
 @DangerousTest
 class IncomingGroupTextTest : GroupControlTest<GroupTextMessage>() {
-
-    @Test
-    fun testForwardSecureTextMessages() = runBlocking {
-        val firstMessage = GroupTextMessage()
-        firstMessage.fromIdentity = contactA.identity
-        firstMessage.toIdentity = myContact.identity
-        firstMessage.text = "First"
-        firstMessage.groupCreator = groupA.groupCreator.identity
-        firstMessage.apiGroupId = groupA.apiGroupId
-
-        // We enforce forward secure messages in the TestTaskCodec and forward security status
-        // listener. Therefore it is sufficient to test that processing a message succeeds.
-        processMessage(firstMessage, contactA.identityStore)
-
-        Assert.assertTrue(sentMessagesInsideTask.isEmpty())
-        Assert.assertTrue(sentMessagesNewTask.isEmpty())
-    }
-
     override fun createMessageForGroup(): GroupTextMessage {
         return GroupTextMessage().apply { text = "Group text message" }
     }
diff --git a/app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt b/app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt
deleted file mode 100644
index a037721e..00000000
--- a/app/src/androidTest/java/ch/threema/app/processors/IncomingMessageProcessorTest.kt
+++ /dev/null
@@ -1,264 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors
-
-import ch.threema.app.DangerousTest
-import ch.threema.app.testutils.TestHelpers.TestContact
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.ProtocolDefines.DELIVERYRECEIPT_MSGREAD
-import ch.threema.domain.protocol.csp.ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED
-import ch.threema.domain.protocol.csp.ProtocolDefines.DELIVERYRECEIPT_MSGUSERACK
-import ch.threema.domain.protocol.csp.ProtocolDefines.DELIVERYRECEIPT_MSGUSERDEC
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
-import ch.threema.domain.protocol.csp.messages.LocationMessage
-import ch.threema.domain.protocol.csp.messages.TextMessage
-import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
-import ch.threema.domain.protocol.csp.messages.ballot.BallotData
-import ch.threema.domain.protocol.csp.messages.ballot.BallotDataChoice
-import ch.threema.domain.protocol.csp.messages.ballot.BallotDataChoiceBuilder
-import ch.threema.domain.protocol.csp.messages.ballot.BallotId
-import ch.threema.domain.protocol.csp.messages.ballot.BallotVote
-import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage
-import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage
-import junit.framework.TestCase.assertEquals
-import junit.framework.TestCase.assertTrue
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.test.runTest
-import org.junit.Assert.assertArrayEquals
-import org.junit.Assert.fail
-import org.junit.Test
-import java.util.Date
-
-@OptIn(ExperimentalCoroutinesApi::class)
-@DangerousTest
-class IncomingMessageProcessorTest : MessageProcessorProvider() {
-
-    @Test
-    fun testIncomingTextMessage() = runTest {
-        assertSuccessfulMessageProcessing(
-            TextMessage().also { it.text = "Hello!" }.enrich(),
-            contactA
-        )
-    }
-
-    @Test
-    fun testIncomingLocationMessage() = runTest {
-        assertSuccessfulMessageProcessing(LocationMessage().also {
-            it.longitude = 0.0
-            it.longitude = 0.0
-        }.enrich(), contactA)
-
-        assertSuccessfulMessageProcessing(LocationMessage().enrich(), contactA)
-    }
-
-    @Test
-    fun testIncomingPoll() = runTest {
-        val ballotId = BallotId()
-        val ballotCreator = contactA.identity
-
-        val ballotData = BallotData().also { data ->
-            data.description = "This describes the ballot!"
-            data.assessmentType = BallotData.AssessmentType.SINGLE
-            data.type = BallotData.Type.INTERMEDIATE
-            List<BallotDataChoice>(10) { index ->
-                BallotDataChoiceBuilder()
-                    .setId(index)
-                    .setDescription("This is choice $index!")
-                    .setSortKey(index)
-                    .build()
-            }.forEach { data.addChoice(it) }
-            data.displayType = BallotData.DisplayType.LIST_MODE
-            data.state = BallotData.State.OPEN
-        }
-
-        val pollSetupMessage = PollSetupMessage().also {
-            it.ballotCreator = ballotCreator
-            it.ballotId = ballotId
-            it.data = ballotData
-        }.enrich()
-
-        // Test a valid ballot setup message that opens a poll
-        assertSuccessfulMessageProcessing(pollSetupMessage, contactA)
-
-        val pollVoteMessage = PollVoteMessage().also { voteMessage ->
-            voteMessage.ballotId = ballotId
-            voteMessage.ballotCreator = ballotCreator
-            voteMessage.ballotVotes.addAll(List(5) { index ->
-                BallotVote().also {
-                    it.id = index
-                    it.value = 0
-                }
-            })
-        }.enrich()
-
-        assertSuccessfulMessageProcessing(pollVoteMessage, contactA)
-    }
-
-    @Test
-    fun testIncomingDeliveryReceipt() = runTest {
-        val messageId = MessageId()
-
-        // Test 'received'
-        assertSuccessfulMessageProcessing(
-            DeliveryReceiptMessage().also {
-                it.receiptType = DELIVERYRECEIPT_MSGRECEIVED
-                it.receiptMessageIds = arrayOf(messageId)
-                it.messageId = MessageId(0)
-            }.enrich(), contactA
-        )
-
-        // Test 'read'
-        assertSuccessfulMessageProcessing(
-            DeliveryReceiptMessage().also {
-                it.receiptType = DELIVERYRECEIPT_MSGREAD
-                it.receiptMessageIds = arrayOf(messageId)
-            }.enrich(), contactA
-        )
-
-        // Test 'userack'
-        assertSuccessfulMessageProcessing(
-            DeliveryReceiptMessage().also {
-                it.receiptType = DELIVERYRECEIPT_MSGUSERACK
-                it.receiptMessageIds = arrayOf(messageId)
-            }.enrich(), contactA
-        )
-
-        // Test 'userdec'
-        assertSuccessfulMessageProcessing(
-            DeliveryReceiptMessage().also {
-                it.receiptType = DELIVERYRECEIPT_MSGUSERDEC
-                it.receiptMessageIds = arrayOf(messageId)
-            }.enrich(), contactA
-        )
-
-        // Test 'received' with two times the same message id
-        assertSuccessfulMessageProcessing(
-            DeliveryReceiptMessage().also {
-                it.receiptType = DELIVERYRECEIPT_MSGRECEIVED
-                it.receiptMessageIds = arrayOf(messageId, messageId)
-                it.messageId = MessageId(0)
-            }.enrich(), contactA
-        )
-
-        // Test 'received' with many message ids
-        assertSuccessfulMessageProcessing(
-            DeliveryReceiptMessage().also {
-                it.receiptType = DELIVERYRECEIPT_MSGRECEIVED
-                it.receiptMessageIds = Array(100) { MessageId() }
-                it.messageId = MessageId(0)
-            }.enrich(), contactA
-        )
-    }
-
-    @Test
-    fun testIncomingTypingIndicator() = runTest {
-        assertSuccessfulMessageProcessing(
-            TypingIndicatorMessage().also { it.isTyping = true }.enrich(),
-            contactA
-        )
-        assertSuccessfulMessageProcessing(
-            TypingIndicatorMessage().also { it.isTyping = false }.enrich(),
-            contactA
-        )
-    }
-
-    @Test
-    fun testInvalidMessage() = runTest {
-        val badMessage = TextMessage().also {
-            it.fromIdentity = contactA.identity
-            it.toIdentity = myContact.identity
-            it.messageId = MessageId()
-            it.date = Date()
-            it.text = "" // Bad message; cannot be decoded due to invalid length
-        }
-
-        // Processing the message should not result in a crash, it should just ack the message
-        // towards the server, discard it and no delivery receipt should be sent
-        processMessage(badMessage, contactA.identityStore)
-
-        // Assert that no messages are sent (also no delivery receipt, as it is an invalid message)
-        assertTrue(sentMessagesNewTask.isEmpty())
-        assertTrue(sentMessagesInsideTask.isEmpty())
-    }
-
-    @Test
-    fun testMessageToSomeoneElse() = runTest {
-        val messageToB = TextMessage().also {
-            it.fromIdentity = contactA.identity
-            it.toIdentity = contactB.identity
-            it.messageId = MessageId()
-            it.date = Date()
-            it.text = "This message is for contact B!"
-        }
-
-        assertFailingMessageProcessing(messageToB, contactA)
-    }
-
-    private suspend fun assertSuccessfulMessageProcessing(
-        message: AbstractMessage,
-        fromContact: TestContact,
-    ) {
-        val messageId = message.messageId
-        processMessage(
-            message.also { it.fromIdentity = fromContact.identity },
-            fromContact.identityStore
-        )
-
-        val expectDeliveryReceiptSent = message.sendAutomaticDeliveryReceipt()
-                && !message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_DELIVERY_RECEIPTS)
-        if (expectDeliveryReceiptSent) {
-            val deliveryReceiptMessage = sentMessagesInsideTask.poll()
-            if (deliveryReceiptMessage is DeliveryReceiptMessage) {
-                assertArrayEquals(messageId.messageId, deliveryReceiptMessage.receiptMessageIds[0].messageId)
-                assertEquals(DELIVERYRECEIPT_MSGRECEIVED, deliveryReceiptMessage.receiptType)
-            } else {
-                fail("Instead of delivery receipt we got $deliveryReceiptMessage")
-            }
-        }
-
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
-    }
-
-    private suspend fun assertFailingMessageProcessing(
-        message: AbstractMessage,
-        fromContact: TestContact,
-    ) {
-        processMessage(
-            message.also { it.fromIdentity = fromContact.identity },
-            fromContact.identityStore
-        )
-
-        assertTrue(sentMessagesInsideTask.isEmpty())
-        assertTrue(sentMessagesNewTask.isEmpty())
-    }
-
-    private fun AbstractMessage.enrich(): AbstractMessage {
-        toIdentity = myContact.identity
-        date = Date()
-        messageId = MessageId()
-        return this
-    }
-
-}
diff --git a/app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt b/app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt
deleted file mode 100644
index 9b85350e..00000000
--- a/app/src/androidTest/java/ch/threema/app/processors/MessageProcessorProvider.kt
+++ /dev/null
@@ -1,532 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors
-
-import android.Manifest
-import android.content.Intent
-import android.os.Build
-import androidx.test.platform.app.InstrumentationRegistry
-import androidx.test.rule.GrantPermissionRule
-import ch.threema.app.TestCoreServiceManager
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.multidevice.MultiDeviceManagerImpl
-import ch.threema.app.services.FileService
-import ch.threema.app.services.LifetimeService
-import ch.threema.app.tasks.TaskArchiverImpl
-import ch.threema.app.testutils.TestHelpers
-import ch.threema.app.testutils.TestHelpers.TestContact
-import ch.threema.app.testutils.TestHelpers.TestGroup
-import ch.threema.app.utils.DeviceCookieManagerImpl
-import ch.threema.app.utils.ForwardSecurityStatusSender
-import ch.threema.base.crypto.NonceFactory
-import ch.threema.base.crypto.NonceStore
-import ch.threema.domain.fs.DHSession
-import ch.threema.domain.helpers.DecryptTaskCodec
-import ch.threema.domain.helpers.InMemoryContactStore
-import ch.threema.domain.helpers.InMemoryDHSessionStore
-import ch.threema.domain.helpers.InMemoryNonceStore
-import ch.threema.domain.models.Contact
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.protocol.ThreemaFeature
-import ch.threema.domain.protocol.connection.ConnectionState
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.protocol.csp.coders.MessageCoder
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.TextMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataInit
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.stores.ContactStore
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.QueueSendCompleteListener
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.domain.taskmanager.TaskManager
-import ch.threema.domain.taskmanager.toCspMessage
-import ch.threema.storage.DatabaseServiceNew
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.GroupMemberModel
-import junit.framework.TestCase.assertEquals
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.Deferred
-import kotlinx.coroutines.runBlocking
-import org.junit.After
-import org.junit.Before
-import org.junit.Rule
-import org.junit.rules.Timeout
-import java.io.File
-import java.util.Queue
-import java.util.concurrent.ConcurrentLinkedQueue
-
-open class MessageProcessorProvider {
-
-    protected val myContact: TestContact = TestHelpers.TEST_CONTACT
-    protected val contactA = TestContact("12345678")
-    protected val contactB = TestContact("ABCDEFGH")
-    protected val contactC = TestContact("TESTTEST")
-
-    protected val myGroup = TestGroup(GroupId(0), myContact, listOf(myContact, contactA, contactB), "MyGroup")
-    protected val myGroupWithProfilePicture =
-        TestGroup(
-            GroupId(1),
-            myContact,
-            listOf(myContact, contactA),
-            "MyGroupWithPicture",
-            byteArrayOf(0, 1, 2, 3)
-        )
-    protected val groupA =
-        TestGroup(GroupId(2), contactA, listOf(myContact, contactA), "GroupA")
-    protected val groupB =
-        TestGroup(GroupId(3), contactB, listOf(myContact, contactB), "GroupB")
-    protected val groupAB =
-        TestGroup(GroupId(4), contactA, listOf(myContact, contactA, contactB), "GroupAB")
-    protected val groupAUnknown =
-        TestGroup(GroupId(5), contactA, listOf(myContact, contactA, contactB), "GroupAUnknown")
-    protected val groupALeft =
-        TestGroup(GroupId(6), contactA, listOf(contactA, contactB), "GroupALeft")
-    protected val myUnknownGroup =
-        TestGroup(GroupId(7), myContact, listOf(myContact, contactA), "MyUnknownGroup")
-    protected val myLeftGroup =
-        TestGroup(GroupId(8), myContact, listOf(contactA), "MyLeftGroup")
-    protected val newAGroup =
-        TestGroup(GroupId(9), contactA, listOf(myContact, contactA, contactB), "NewAGroup")
-
-    protected val serviceManager: ServiceManager = ThreemaApplication.requireServiceManager()
-    private val contactStore: ContactStore = InMemoryContactStore().apply {
-        addContact(myContact.contact)
-        addContact(contactA.contact)
-        addContact(contactB.contact)
-        addContact(contactC.contact)
-    }
-
-    private val identityMap = listOf(
-        myContact.identity to myContact.identityStore,
-        contactA.identity to contactA.identityStore,
-        contactB.identity to contactB.identityStore,
-        contactC.identity to contactC.identityStore,
-    ).toMap()
-
-    private val forwardSecurityStatusListener = object : ForwardSecurityStatusSender(serviceManager.contactService, serviceManager.messageService, null) {
-        override fun messageWithoutFSReceived(
-            contact: Contact,
-            session: DHSession,
-            message: AbstractMessage
-        ) {
-            throw AssertionError("We do not accept messages without forward security")
-        }
-    }
-
-    private val forwardSecurityMessageProcessorMap = listOf(
-        myContact.identity to serviceManager.forwardSecurityMessageProcessor,
-        contactA.identity to ForwardSecurityMessageProcessor(
-            InMemoryDHSessionStore(),
-            contactStore,
-            contactA.identityStore,
-            NonceFactory(InMemoryNonceStore()),
-            forwardSecurityStatusListener
-        ),
-        contactB.identity to ForwardSecurityMessageProcessor(
-            InMemoryDHSessionStore(),
-            contactStore,
-            contactB.identityStore, NonceFactory(InMemoryNonceStore()),
-            forwardSecurityStatusListener
-        ),
-        contactC.identity to ForwardSecurityMessageProcessor(
-            InMemoryDHSessionStore(),
-            contactStore,
-            contactC.identityStore,
-            NonceFactory(InMemoryNonceStore()),
-            forwardSecurityStatusListener
-        ),
-    ).toMap()
-
-    /**
-     * Do not use this field in tests! This is only to restore the original task manager in the
-     * service manager after the test.
-     */
-    private lateinit var originalTaskManager: TaskManager
-
-    /**
-     * The local task codec is used for running tasks directly in the tests. We can use this to
-     * check that messages are being sent inside the directly run task. Note that the test task
-     * codec automatically enqueues server acks for outgoing message and decrypts outgoing
-     * forward security messages.
-     */
-    private val localTaskCodec =
-        DecryptTaskCodec(contactStore, identityMap, forwardSecurityMessageProcessorMap)
-
-    /**
-     * The global task codec is used when new tasks are created.
-     */
-    private val globalTaskCodec =
-        DecryptTaskCodec(contactStore, identityMap, forwardSecurityMessageProcessorMap)
-
-    private val globalTaskQueue: Queue<QueueEntry<*>> = ConcurrentLinkedQueue()
-
-    private data class QueueEntry<R>(
-        private val task: Task<R, TaskCodec>,
-        private val done: CompletableDeferred<R>,
-        private val taskCodec: TaskCodec,
-    ) {
-        fun run() = runBlocking {
-            done.complete(task.invoke(taskCodec))
-        }
-    }
-
-    protected val sentMessagesInsideTask: Queue<AbstractMessage> =
-        localTaskCodec.outboundAbstractMessages
-
-    protected val sentMessagesNewTask: Queue<AbstractMessage> =
-        globalTaskCodec.outboundAbstractMessages
-
-    protected val initialContacts = listOf(myContact, contactA, contactB, contactC)
-
-    protected val initialGroups =
-        listOf(myGroup, myGroupWithProfilePicture, groupA, groupB, groupAB, groupALeft, myLeftGroup)
-
-    @Rule
-    @JvmField
-    val timeout: Timeout = Timeout.seconds(300)
-
-    @JvmField
-    @Rule
-    val grantPermissionRule: GrantPermissionRule =
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-            GrantPermissionRule.grant(Manifest.permission.POST_NOTIFICATIONS)
-        } else {
-            GrantPermissionRule.grant()
-        }
-
-    /**
-     * Asserts that the correct identity is set up and fills the database with the initial data.
-     */
-    @Before
-    fun setup() {
-        assert(myContact.identity == TestHelpers.ensureIdentity(ThreemaApplication.requireServiceManager()))
-
-        // Delete persisted tasks as they are not needed for tests
-        serviceManager.databaseServiceNew.taskArchiveFactory.deleteAll()
-
-        // Then stop connection
-        serviceManager.connection.stop()
-
-        // Replace original task manager (save a copy of it)
-        originalTaskManager = serviceManager.taskManager
-
-        val mockTaskManager = object : TaskManager {
-            override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> {
-                val deferred = CompletableDeferred<R>()
-                globalTaskQueue.add(QueueEntry(task, deferred, globalTaskCodec))
-                return deferred
-            }
-
-            override fun hasPendingTasks(): Boolean = false
-
-            @Deprecated(
-                "We should only be able to send and receive messages from within tasks.",
-                replaceWith = ReplaceWith("TaskManager#schedule")
-            )
-            override fun getMigrationTaskHandle(): ActiveTaskCodec = globalTaskCodec
-
-            override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
-                // Nothing to do
-            }
-
-            override fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener) {
-                // Nothing to do
-            }
-        }
-
-        setTaskManager(mockTaskManager)
-
-        disableLifetimeService()
-
-        clearData()
-
-        fillDatabase()
-
-        val nonceFactory = NonceFactory(InMemoryNonceStore())
-
-        val myForwardSecurityMessageProcessor = serviceManager.forwardSecurityMessageProcessor
-        initialContacts.filter { it != myContact }.forEach {
-            val textMessage = TextMessage().apply {
-                toIdentity = it.identity
-                fromIdentity = myContact.identity
-                text = "Text"
-            }
-            // Making the message triggers an fs init message. We do not need to send the
-            // encapsulated message as we only want to initiate a new fs session. Therefore we just
-            // need to send the first message, which is the init.
-            val result =
-                myForwardSecurityMessageProcessor.makeMessage(it.contact, textMessage, globalTaskCodec)
-
-            // Commit the dh session state
-            myForwardSecurityMessageProcessor.commitSessionState(result)
-
-            // Process the init message
-            val initCspMessage = result
-                .outgoingMessages
-                .first()
-                .apply { toIdentity = it.contact.identity }
-                .toCspMessage(myContact.identityStore, contactStore, nonceFactory, nonceFactory.next(false))
-
-            val initMessageBox = MessageBox.parseBinary(initCspMessage.toOutgoingMessageData().data)
-            val init = MessageCoder(contactStore, it.identityStore).decode(initMessageBox) as ForwardSecurityEnvelopeMessage
-            runBlocking {
-                forwardSecurityMessageProcessorMap[it.identity]!!.processInit(
-                    myContact.contact,
-                    init.data as ForwardSecurityDataInit,
-                    globalTaskCodec
-                )
-            }
-
-            // Note that we do not need to explicitly process the accept as this is already done by
-            // decapsulating the message. The message is decapsulated as soon as it is put into the
-            // global task handle. Processing an init immediately sends out an accept message.
-        }
-    }
-
-    /**
-     * Clean the data after the tests. This includes the deletion of the database entries, the
-     * avatar files, and the blocked contacts.
-     */
-    @After
-    fun cleanup() {
-        clearData()
-
-        if (this::originalTaskManager.isInitialized) {
-            setTaskManager(originalTaskManager)
-        }
-
-        // We need to start the connection again, as some tests require a running connection
-        serviceManager.connection.start()
-
-        // Wait until the connection has been established. If we do not wait for the connection, the
-        // next test may fail due to a race condition that occurs when the connection is started and
-        // almost immediately stopped again.
-        while (serviceManager.connection.connectionState != ConnectionState.LOGGEDIN) {
-            Thread.sleep(50)
-        }
-    }
-
-    private fun clearData() {
-        // Clear conversations
-        serviceManager.conversationService.getAll(true).forEach {
-            serviceManager.conversationService.empty(it, true)
-        }
-
-        // Delete database
-        serviceManager.databaseServiceNew.apply {
-            contactModelFactory.deleteAll()
-            messageModelFactory.deleteAll()
-            groupCallModelFactory.deleteAll()
-            groupInviteModelFactory.deleteAll()
-            groupBallotModelFactory.deleteAll()
-            groupMemberModelFactory.deleteAll()
-            groupMessageModelFactory.deleteAll()
-            // Remove group models from group service to empty the group service cache
-            serviceManager.groupService.removeAll()
-            distributionListModelFactory.deleteAll()
-            distributionListMemberModelFactory.deleteAll()
-            distributionListMessageModelFactory.deleteAll()
-            outgoingGroupSyncRequestLogModelFactory.deleteAll()
-            incomingGroupSyncRequestLogModelFactory.deleteAll()
-            ballotModelFactory.deleteAll()
-            ballotChoiceModelFactory.deleteAll()
-            ballotVoteModelFactory.deleteAll()
-            identityBallotModelFactory.deleteAll()
-            webClientSessionModelFactory.deleteAll()
-            conversationTagFactory.deleteAll()
-            outgoingGroupJoinRequestModelFactory.deleteAll()
-            incomingGroupJoinRequestModelFactory.deleteAll()
-            serverMessageModelFactory.deleteAll()
-            taskArchiveFactory.deleteAll()
-        }
-
-        // Delete dh sessions
-        initialContacts.forEach {
-            serviceManager.dhSessionStore.deleteAllDHSessions(myContact.identity, it.identity)
-        }
-
-        // Remove files
-        serviceManager.fileService.removeAllAvatars()
-        serviceManager.fileService.remove(
-            File(
-                InstrumentationRegistry.getInstrumentation().context.filesDir,
-                "taskArchive"
-            ), true
-        )
-
-        // Unblock contacts
-        serviceManager.blockedContactsService.removeAll()
-    }
-
-    private fun setTaskManager(taskManager: TaskManager) {
-        val serviceManager = ThreemaApplication.requireServiceManager()
-        val coreServiceManager = TestCoreServiceManager(
-            ThreemaApplication.getAppVersion(),
-            serviceManager.databaseServiceNew,
-            serviceManager.preferenceStore,
-            TaskArchiverImpl(serviceManager.databaseServiceNew.taskArchiveFactory),
-            serviceManager.deviceCookieManager as DeviceCookieManagerImpl,
-            taskManager,
-            serviceManager.multiDeviceManager as MultiDeviceManagerImpl
-        )
-
-        val field = ServiceManager::class.java.getDeclaredField("coreServiceManager")
-        field.isAccessible = true
-        field.set(ThreemaApplication.getServiceManager(), coreServiceManager)
-    }
-
-    private fun disableLifetimeService() {
-        val field = ServiceManager::class.java.getDeclaredField("lifetimeService")
-        field.isAccessible = true
-        field.set(ThreemaApplication.getServiceManager(), object : LifetimeService {
-            override fun acquireConnection(sourceTag: String, unpauseable: Boolean) = Unit
-            override fun acquireConnection(source: String) = Unit
-            override fun acquireUnpauseableConnection(source: String) = Unit
-            override fun releaseConnection(sourceTag: String) = Unit
-            override fun releaseConnectionLinger(sourceTag: String, timeoutMs: Long) = Unit
-            override fun ensureConnection() = Unit
-            override fun alarm(intent: Intent?) = Unit
-            override fun isActive(): Boolean = true
-            override fun pause() = Unit
-            override fun unpause() = Unit
-            override fun addListener(listener: LifetimeService.LifetimeServiceListener?) = Unit
-        })
-    }
-
-    /**
-     * Fills basic data into the database. This is executed before each test. Override this if other
-     * database entries are needed.
-     */
-    open fun fillDatabase() {
-        val databaseService = serviceManager.databaseServiceNew
-        val contactStore = serviceManager.contactStore
-        val fileService = serviceManager.fileService
-
-        initialContacts.forEach { addContactToDatabase(it, databaseService, contactStore, AcquaintanceLevel.GROUP) }
-
-        initialGroups.forEach { addGroupToDatabase(it, databaseService, fileService) }
-    }
-
-    private fun addContactToDatabase(
-        testContact: TestContact,
-        databaseService: DatabaseServiceNew,
-        contactStore: ContactStore,
-        acquaintanceLevel: AcquaintanceLevel = AcquaintanceLevel.DIRECT,
-    ) {
-        databaseService.contactModelFactory.createOrUpdate(
-            testContact.contactModel.setAcquaintanceLevel(acquaintanceLevel)
-                .setFeatureMask(ThreemaFeature.FORWARD_SECURITY)
-        )
-
-        contactStore.addCachedContact(testContact.contact)
-    }
-
-    private fun addGroupToDatabase(
-        testGroup: TestGroup,
-        databaseService: DatabaseServiceNew,
-        fileService: FileService,
-    ) {
-        val groupModel = testGroup.groupModel
-        databaseService.groupModelFactory.createOrUpdate(groupModel)
-        testGroup.setLocalGroupId(groupModel.id)
-        testGroup.members.forEach { member ->
-            val memberModel = GroupMemberModel()
-                .setGroupId(groupModel.id)
-                .setIdentity(member.identity)
-            databaseService.groupMemberModelFactory.createOrUpdate(memberModel)
-        }
-        if (testGroup.profilePicture != null) {
-            fileService.writeGroupAvatar(groupModel, testGroup.profilePicture)
-        }
-    }
-
-    /**
-     * Send a message from a user with the provided identity store.
-     */
-    protected suspend fun processMessage(
-        message: AbstractMessage,
-        identityStore: IdentityStoreInterface,
-    ) {
-        val messageBox = createMessageBox(
-            message,
-            identityStore,
-            forwardSecurityMessageProcessorMap[message.fromIdentity]!!
-        )
-
-        // Process the group message
-        val messageProcessor = serviceManager.let {
-            IncomingMessageProcessorImpl(
-                it.messageService,
-                it.nonceFactory,
-                it.forwardSecurityMessageProcessor,
-                it.contactService,
-                it.contactStore,
-                it.identityStore,
-                it.blockedContactsService,
-                it.preferenceService,
-                it
-            )
-        }
-        messageProcessor.processIncomingMessage(messageBox, localTaskCodec)
-
-        // Assert that this message has been acked towards the server
-        assertEquals(
-            message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK),
-            !localTaskCodec.ackedIncomingMessages.contains(message.messageId)
-        )
-
-        while (globalTaskQueue.isNotEmpty()) {
-            globalTaskQueue.poll()?.run()
-        }
-    }
-
-    /**
-     * Create a message box from a user with the given identity store.
-     */
-    private fun createMessageBox(
-        msg: AbstractMessage,
-        identityStore: IdentityStoreInterface,
-        forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    ): MessageBox {
-        val nonceFactory = NonceFactory(object : NonceStore {
-            override fun exists(nonce: ByteArray) = false
-            override fun store(nonce: ByteArray) = true
-            override fun getAllHashedNonces() = listOf<ByteArray>()
-        })
-
-        val encapsulated = forwardSecurityMessageProcessor.makeMessage(
-            contactStore.getContactForIdentityIncludingCache(
-                msg.toIdentity
-            )!!, msg, globalTaskCodec
-        ).outgoingMessages.last()
-
-        val messageCoder = MessageCoder(contactStore, identityStore)
-        return messageCoder.encode(encapsulated, nonceFactory.next(false), nonceFactory)
-    }
-
-}
diff --git a/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java b/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java
index f7d9723a..0b4d9bdd 100644
--- a/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java
+++ b/app/src/androidTest/java/ch/threema/app/service/GroupInviteServiceTest.java
@@ -253,7 +253,7 @@ public class GroupInviteServiceTest {
 			}
 
 			@Override
-			public boolean sendFeatureMask() {
+			public boolean sendFlags() {
 				return false;
 			}
 
@@ -271,11 +271,6 @@ public class GroupInviteServiceTest {
 			public void checkRevocationKey(boolean force) {
 
 			}
-
-			@Override
-			public void setForwardSecurityEnabled(boolean isFsEnabled) {
-
-			}
 		};
 		try {
 			this.groupService = ThreemaApplication.getServiceManager().getGroupService();
diff --git a/app/src/androidTest/java/ch/threema/app/services/systemupdate/SystemUpdateHelpersTest.kt b/app/src/androidTest/java/ch/threema/app/services/systemupdate/SystemUpdateHelpersTest.kt
deleted file mode 100644
index 42a76cd0..00000000
--- a/app/src/androidTest/java/ch/threema/app/services/systemupdate/SystemUpdateHelpersTest.kt
+++ /dev/null
@@ -1,57 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-import org.junit.Before
-import org.junit.Test
-import kotlin.test.assertFalse
-import kotlin.test.assertTrue
-
-class SystemUpdateHelpersTest {
-    private var inMemoryDatabase: SQLiteDatabase = SQLiteDatabase.create(null)
-
-    @Before
-    fun setUp() {
-        this.inMemoryDatabase.execSQL("CREATE TABLE IF NOT EXISTS testtable (hello TEXT, world INTEGER)")
-    }
-
-    @Test
-    fun testFieldExistNonExistingTable() {
-        assertFalse {
-            fieldExists(this.inMemoryDatabase, "non_existing_table", "non_existing_field")
-        }
-    }
-
-    @Test
-    fun testFieldExistExistingTable() {
-        assertFalse {
-            fieldExists(this.inMemoryDatabase, "testtable", "non_existing_field")
-        }
-        assertTrue {
-            fieldExists(this.inMemoryDatabase, "testtable", "hello")
-        }
-        assertTrue {
-            fieldExists(this.inMemoryDatabase, "testtable", "world")
-        }
-    }
-}
diff --git a/app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt b/app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt
deleted file mode 100644
index de2d2841..00000000
--- a/app/src/androidTest/java/ch/threema/app/tasks/PersistableTasksTest.kt
+++ /dev/null
@@ -1,281 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.ThreemaApplication
-import ch.threema.domain.models.Contact
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import com.neilalexander.jnacl.NaCl
-import junit.framework.TestCase.assertEquals
-import junit.framework.TestCase.assertNotNull
-import junit.framework.TestCase.fail
-import kotlinx.serialization.json.Json
-import org.junit.Test
-
-/**
- * These tests are useful to detect when a task cannot be created out of a persisted representation
- * of the task. If any of these tests fails, then it is probably because there were some changes in
- * the serialized task data. Tasks that cannot be created due to the changed serialized
- * representation will be dropped.
- */
-class PersistableTasksTest {
-    private val serviceManager = ThreemaApplication.requireServiceManager()
-
-    @Test
-    fun testContactDeliveryReceiptMessageTask() {
-        assertValidEncoding(
-            OutgoingContactDeliveryReceiptMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask.OutgoingDeliveryReceiptMessageData\",\"receiptType\":1,\"messageIds\":[\"0000000000000000\"],\"date\":\"1234567890\",\"toIdentity\":\"01234567\"}"
-        )
-    }
-
-    @Test
-    fun testFileMessageTask() {
-        assertValidEncoding(
-            OutgoingFileMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingFileMessageTask.OutgoingFileMessageData\",\"messageModelId\":1,\"receiverType\":0,\"recipientIdentities\":[\"01234567\"],\"thumbnailBlobId\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}"
-        )
-    }
-
-    @Test
-    fun testGroupDeleteProfilePictureTask() {
-        assertValidEncoding(
-            OutgoingGroupDeleteProfilePictureTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupDeleteProfilePictureTask.OutgoingGroupDeleteProfilePictureData\",\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\",\"receiverIdentities\":[\"01234567\"],\"messageId\":[0,0,0,0,0,0,0,0]}"
-        )
-    }
-
-    @Test
-    fun testGroupDeliveryReceiptMessageTask() {
-        assertValidEncoding(
-            OutgoingGroupDeliveryReceiptMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupDeliveryReceiptMessageTask.OutgoingGroupDeliveryReceiptMessageData\",\"messageModelId\":0,\"recipientIdentities\":[\"01234567\",\"01234567\"],\"receiptType\":0}"
-        )
-    }
-
-    @Test
-    fun testGroupLeaveTask() {
-        assertValidEncoding(
-            OutgoingGroupLeaveTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupLeaveTask.OutgoingGroupLeaveData\",\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\",\"receiverIdentities\":[\"01234567\"],\"messageId\":[0,0,0,0,0,0,0,0]}"
-        )
-    }
-
-    @Test
-    fun testGroupNameTask() {
-        assertValidEncoding(
-            OutgoingGroupNameTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupNameTask.OutgoingGroupNameData\",\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\",\"groupName\":\"groupName\",\"receiverIdentities\":[\"01234567\"],\"messageId\":[0,0,0,0,0,0,0,0]}"
-        )
-    }
-
-    @Test
-    fun testGroupProfilePictureTask() {
-        assertValidEncoding(
-            OutgoingGroupProfilePictureTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupProfilePictureTask.OutgoingGroupProfilePictureData\",\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\",\"receiverIdentities\":[\"01234567\"],\"messageId\":[0,0,0,0,0,0,0,0]}"
-        )
-    }
-
-    @Test
-    fun testGroupSetupTask() {
-        assertValidEncoding(
-            OutgoingGroupSetupTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupSetupTask.OutgoingGroupSetupData\",\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\",\"memberIdentities\":[\"01234567\"],\"receiverIdentities\":[\"01234567\"],\"messageId\":[0,0,0,0,0,0,0,0]}"
-        )
-    }
-
-    @Test
-    fun testGroupSyncRequestTask() {
-        assertValidEncoding(
-            OutgoingGroupSyncRequestTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupSyncRequestTask.OutgoingGroupSyncRequestData\",\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\",\"messageId\":[0,0,0,0,0,0,0,0]}"
-        )
-    }
-
-    @Test
-    fun testGroupSyncTask() {
-        assertValidEncoding(
-            OutgoingGroupSyncTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupSyncTask.OutgoingGroupSyncData\",\"groupId\":[0,0,0,0,0,0,0,0],\"creatorIdentity\":\"01234567\",\"receiverIdentities\":[\"01234567\"]}"
-        )
-    }
-
-    @Test
-    fun testLocationMessageTask() {
-        assertValidEncoding(
-            OutgoingLocationMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingLocationMessageTask.OutgoingLocationMessageTaskData\",\"messageModelId\":0,\"recipientIdentities\":[\"01234567\",\"01234567\"],\"receiverType\":0}"
-        )
-    }
-
-    @Test
-    fun testPollSetupMessageTask() {
-        assertValidEncoding(
-            OutgoingPollSetupMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingPollSetupMessageTask.OutgoingPollSetupMessageData\",\"messageModelId\":0,\"recipientIdentities\":[\"01234567\",\"01234567\"],\"receiverType\":0,\"ballotId\":[-58,11,102,-122,-119,-102,19,-10],\"ballotData\":\"{\\\"d\\\":\\\"description\\\",\\\"s\\\":0,\\\"a\\\":0,\\\"t\\\":1,\\\"o\\\":0,\\\"u\\\":0,\\\"c\\\":[{\\\"i\\\":0,\\\"n\\\":\\\"desc\\\",\\\"o\\\":0,\\\"r\\\":[0],\\\"t\\\":0}],\\\"p\\\":[\\\"01234567\\\"]}\"}"
-        )
-    }
-
-    @Test
-    fun testPollVoteContactMessageTask() {
-        assertValidEncoding(
-            OutgoingPollVoteContactMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingPollVoteContactMessageTask.OutgoingPollVoteContactMessageData\",\"messageId\":\"0000000000000000\",\"ballotId\":[-127,-79,80,-109,-98,62,-3,81],\"ballotCreator\":\"01234567\",\"ballotVotes\":[{\"first\":0,\"second\":0}],\"toIdentity\":\"01234567\"}"
-        )
-    }
-
-    @Test
-    fun testPollVoteGroupMessageTask() {
-        assertValidEncoding(
-            OutgoingPollVoteGroupMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingPollVoteGroupMessageTask.OutgoingPollVoteGroupMessageData\",\"messageId\":\"0000000000000000\",\"recipientIdentities\":[\"01234567\",\"01234567\"],\"ballotId\":[52,64,-6,18,2,-71,124,-19],\"ballotCreator\":\"01234567\",\"ballotVotes\":[{\"first\":0,\"second\":0}],\"ballotType\":\"INTERMEDIATE\",\"apiGroupId\":\"0000000000000000\",\"groupCreator\":\"01234567\"}"
-        )
-    }
-
-    @Test
-    fun testTextMessageTask() {
-        assertValidEncoding(
-            OutgoingTextMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingTextMessageTask.OutgoingTextMessageData\",\"messageModelId\":0,\"recipientIdentities\":[\"01234567\",\"01234567\"],\"receiverType\":0}"
-        )
-    }
-
-    @Test
-    fun testSendProfilePictureTask() {
-        assertValidEncoding(
-            SendProfilePictureTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.SendProfilePictureTask.SendProfilePictureData\",\"toIdentity\":\"01234567\"}"
-        )
-    }
-
-    @Test
-    fun testSendPushTokenTask() {
-        assertValidEncoding(
-            SendPushTokenTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.SendPushTokenTask.SendPushTokenData\",\"token\":\"token\",\"tokenType\":0}"
-        )
-    }
-
-    @Test
-    fun testOutgoingContactRequestProfilePictureTask() {
-        assertValidEncoding(
-            OutgoingContactRequestProfilePictureTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingContactRequestProfilePictureTask.OutgoingContactRequestProfilePictureData\",\"toIdentity\":\"01234567\"}"
-        )
-    }
-
-    @Test
-    fun testDeleteAndTerminateFSSessionsTask() {
-        // Add the contact '01234567' so that restoring the tasks works
-        serviceManager.contactStore.addCachedContact(Contact("01234567", ByteArray(NaCl.PUBLICKEYBYTES)))
-
-        assertValidEncoding(
-            DeleteAndTerminateFSSessionsTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.DeleteAndTerminateFSSessionsTask.DeleteAndTerminateFSSessionsTaskData\",\"identity\":\"01234567\",\"cause\":\"RESET\"}"
-        )
-        assertValidEncoding(
-            DeleteAndTerminateFSSessionsTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.DeleteAndTerminateFSSessionsTask.DeleteAndTerminateFSSessionsTaskData\",\"identity\":\"01234567\",\"cause\":\"UNKNOWN_SESSION\"}"
-        )
-        assertValidEncoding(
-            DeleteAndTerminateFSSessionsTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.DeleteAndTerminateFSSessionsTask.DeleteAndTerminateFSSessionsTaskData\",\"identity\":\"01234567\",\"cause\":\"DISABLED_BY_LOCAL\"}"
-        )
-        assertValidEncoding(
-            DeleteAndTerminateFSSessionsTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.DeleteAndTerminateFSSessionsTask.DeleteAndTerminateFSSessionsTaskData\",\"identity\":\"01234567\",\"cause\":\"DISABLED_BY_REMOTE\"}"
-        )
-    }
-
-    @Test
-    fun testApplicationUpdateStepsTask() {
-        assertValidEncoding(
-            ApplicationUpdateStepsTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.ApplicationUpdateStepsTask.ApplicationUpdateStepsData\"}"
-        )
-    }
-
-    @Test
-    fun testFSRefreshStepsTask() {
-        assertValidEncoding(
-            FSRefreshStepsTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.FSRefreshStepsTask.FSRefreshStepsTaskData\",\"contactIdentities\":[\"01234567\"]}"
-        )
-    }
-
-    @Test
-    fun testOutgoingDropDeviceTask() {
-        assertValidEncoding(
-            OutgoingDropDeviceTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingDropDeviceTask.OutgoingDropDeviceData\",\"deviceId\":0}"
-        )
-    }
-
-    @Test
-    fun testOutgoingContactEditMessageTask() {
-        assertValidEncoding(
-            OutgoingContactEditMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingContactEditMessageTask.OutgoingContactEditMessageData\",\"toIdentity\":\"01234567\",\"messageModelId\":0, \"messageId\":[0,0,0,0,0,0,0,0], \"editedText\":\"test\", \"editedAt\":0}"
-        )
-    }
-
-    @Test
-    fun testOutgoingGroupEditMessageTask() {
-        assertValidEncoding(
-            OutgoingGroupEditMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupEditMessageTask.OutgoingGroupEditMessageData\",\"messageModelId\":0, \"messageId\":[0,0,0,0,0,0,0,0], \"editedText\":\"test\", \"editedAt\":0,\"recipientIdentities\":[\"01234567\",\"01234567\"]}"
-        )
-    }
-
-    @Test
-    fun testOutgoingContactDeleteMessageTask() {
-        assertValidEncoding(
-            OutgoingContactDeleteMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingContactDeleteMessageTask.OutgoingContactDeleteMessageData\",\"toIdentity\":\"01234567\",\"messageModelId\":0, \"messageId\":[0,0,0,0,0,0,0,0], \"deletedAt\":0}"
-        )
-    }
-
-    @Test
-    fun testOutgoingGroupDeleteMessageTask() {
-        assertValidEncoding(
-            OutgoingGroupDeleteMessageTask::class.java,
-            "{\"type\":\"ch.threema.app.tasks.OutgoingGroupDeleteMessageTask.OutgoingGroupDeleteMessageData\",\"messageModelId\":0,\"messageId\":[0,0,0,0,0,0,0,0],\"deletedAt\":0,\"recipientIdentities\":[\"01234567\",\"01234567\"]}"
-        )
-    }
-
-    private fun <T> assertValidEncoding(expectedTaskClass: Class<T>, encodedTask: String) {
-        val decodedTask = encodedTask.decodeToTask()
-        assertNotNull(decodedTask)
-        assertEquals(expectedTaskClass, decodedTask!!::class.java)
-    }
-
-    private fun String.decodeToTask(): Task<*, TaskCodec>? {
-        return try {
-            Json.decodeFromString<SerializableTaskData>(this).createTask(serviceManager)
-        } catch (e: Exception) {
-            fail("Task data decoding error for task '$this'. Error: $e")
-            null
-        }
-    }
-}
diff --git a/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java b/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java
index 390ae900..ac582e57 100644
--- a/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java
+++ b/app/src/androidTest/java/ch/threema/app/testutils/TestHelpers.java
@@ -46,7 +46,6 @@ import ch.threema.base.utils.Utils;
 import ch.threema.domain.helpers.InMemoryIdentityStore;
 import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.GroupId;
-import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
@@ -86,7 +85,7 @@ public class TestHelpers {
 
 		@NonNull
 		public Contact getContact() {
-			return new Contact(this.identity, this.publicKey, VerificationLevel.UNVERIFIED);
+			return new Contact(this.identity, this.publicKey);
 		}
 
 		@NonNull
diff --git a/app/src/androidTest/java/ch/threema/app/utils/BackgroundExecutorTest.kt b/app/src/androidTest/java/ch/threema/app/utils/BackgroundExecutorTest.kt
deleted file mode 100644
index c0539822..00000000
--- a/app/src/androidTest/java/ch/threema/app/utils/BackgroundExecutorTest.kt
+++ /dev/null
@@ -1,169 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-import android.os.Looper
-import ch.threema.app.utils.executor.BackgroundExecutor
-import ch.threema.app.utils.executor.BackgroundTask
-import kotlinx.coroutines.runBlocking
-import org.junit.Assert
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.Timeout
-
-class BackgroundExecutorTest {
-
-    @Rule
-    @JvmField
-    val timeout: Timeout = Timeout.seconds(10)
-
-    private val executor = BackgroundExecutor()
-
-    @Test
-    fun testCorrectThreads() {
-        val initialThread = Thread.currentThread()
-
-        executor.execute(object : BackgroundTask<Unit> {
-            override fun runBefore() {
-                Assert.assertEquals(initialThread.id, Thread.currentThread().id)
-            }
-
-            override fun runInBackground() {
-                val currentThreadId = Thread.currentThread().id
-                Assert.assertNotEquals(initialThread.id, currentThreadId)
-                Assert.assertNotEquals(Looper.getMainLooper().thread.id, currentThreadId)
-            }
-
-            override fun runAfter(result: Unit) {
-                Assert.assertEquals(Looper.getMainLooper().thread.id, Thread.currentThread().id)
-            }
-        })
-    }
-
-    @Test
-    fun testReturnValue() {
-        executor.execute(object : BackgroundTask<Int> {
-            override fun runInBackground() = 42
-            override fun runAfter(result: Int) = Assert.assertEquals(42, result)
-        })
-    }
-
-    @Test
-    fun testOrder() = runBlocking {
-        val methodExecutionList = mutableListOf<Int>()
-        val expected = arrayOf(0, 1, 2, 3, 4, 5)
-
-        executor.executeDeferred(object : BackgroundTask<Unit> {
-            override fun runBefore() {
-                methodExecutionList.add(0)
-                Thread.sleep(500)
-                methodExecutionList.add(1)
-            }
-
-            override fun runInBackground() {
-                methodExecutionList.add(2)
-                Thread.sleep(300)
-                methodExecutionList.add(3)
-            }
-
-            override fun runAfter(result: Unit) {
-                methodExecutionList.add(4)
-                Thread.sleep(200)
-                methodExecutionList.add(5)
-
-                // Sleep again to test that the completable is completed after the runAfter method
-                // is run.
-                Thread.sleep(500)
-            }
-        }).await()
-
-        Assert.assertArrayEquals(
-            expected,
-            methodExecutionList.toTypedArray()
-        )
-    }
-
-    @Test
-    fun testFailingBefore() {
-        val deferred = executor.executeDeferred(object : BackgroundTask<Unit> {
-            override fun runBefore() {
-                throw IllegalStateException()
-            }
-
-            override fun runInBackground() {
-                // This should never be executed as run before failed
-                Assert.fail()
-            }
-
-            override fun runAfter(result: Unit) {
-                // This should never be executed as run before failed
-                Assert.fail()
-            }
-        })
-
-        Assert.assertThrows(IllegalStateException::class.java) {
-            runBlocking {
-                deferred.await()
-            }
-        }
-    }
-
-    @Test
-    fun testFailingBackground() {
-        val deferred = executor.executeDeferred(object : BackgroundTask<Unit> {
-            override fun runInBackground() {
-                throw IllegalStateException()
-            }
-
-            override fun runAfter(result: Unit) {
-                // This should never be executed as run in background failed
-                Assert.fail()
-            }
-        })
-
-        Assert.assertThrows(IllegalStateException::class.java) {
-            runBlocking {
-                deferred.await()
-            }
-        }
-    }
-
-    @Test
-    fun testFailingAfter() {
-        val deferred = executor.executeDeferred(object : BackgroundTask<Unit> {
-            override fun runInBackground() {
-                // Nothing to do
-            }
-
-            override fun runAfter(result: Unit) {
-                throw IllegalStateException()
-            }
-        })
-
-        Assert.assertThrows(IllegalStateException::class.java) {
-            runBlocking {
-                deferred.await()
-            }
-        }
-    }
-
-}
diff --git a/app/src/androidTest/java/ch/threema/app/utils/LinkifyUtilTest.kt b/app/src/androidTest/java/ch/threema/app/utils/LinkifyUtilTest.kt
index 69592bde..f3adaa6f 100644
--- a/app/src/androidTest/java/ch/threema/app/utils/LinkifyUtilTest.kt
+++ b/app/src/androidTest/java/ch/threema/app/utils/LinkifyUtilTest.kt
@@ -21,7 +21,8 @@
 
 package ch.threema.app.utils
 
-import android.text.Spanned
+import android.text.Spannable
+import android.text.SpannableString
 import android.text.style.URLSpan
 import android.widget.TextView
 import androidx.test.platform.app.InstrumentationRegistry
@@ -34,14 +35,14 @@ class LinkifyUtilTest {
      * Get the spannable and a list of the URL spans as a pair. If there is no spannable, a pair
      * containing of null and an empty list is returned.
      */
-    private fun getSpanPair(text: String, includePhoneNumbers: Boolean = true): Pair<Spanned?, List<URLSpan>> {
+    private fun getSpanPair(text: String, includePhoneNumbers: Boolean = true): Pair<Spannable?, List<URLSpan>> {
         val textView = TextView(InstrumentationRegistry.getInstrumentation().context)
         textView.text = text
         InstrumentationRegistry.getInstrumentation().runOnMainSync{
             LinkifyUtil.getInstance().linkifyText(textView, includePhoneNumbers)
         }
         val spannableText = textView.text
-        if (spannableText !is Spanned) {
+        if (spannableText !is SpannableString) {
             return null to listOf()
         }
         val spans = spannableText.getSpans(0, text.length + 1, URLSpan::class.java).toList()
diff --git a/app/src/androidTest/java/ch/threema/app/utils/TextUtilTest.java b/app/src/androidTest/java/ch/threema/app/utils/TextUtilTest.java
index d65a2680..0f1e4f28 100644
--- a/app/src/androidTest/java/ch/threema/app/utils/TextUtilTest.java
+++ b/app/src/androidTest/java/ch/threema/app/utils/TextUtilTest.java
@@ -62,7 +62,7 @@ public class TextUtilTest {
 	}
 
 	@Test
-	public void testCheckBadPasswordWarnList() {
+	public void testCheckBadPasswordBlacklisted() {
 		final Context context = ThreemaApplication.getAppContext();
 		assertTrue(TextUtil.checkBadPassword(context, "1Rainbow"));
 		assertTrue(TextUtil.checkBadPassword(context, "apples123"));
diff --git a/app/src/androidTest/java/ch/threema/data/TestDatabaseService.kt b/app/src/androidTest/java/ch/threema/data/TestDatabaseService.kt
deleted file mode 100644
index 8f04133a..00000000
--- a/app/src/androidTest/java/ch/threema/data/TestDatabaseService.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data
-
-import androidx.test.core.app.ApplicationProvider
-import ch.threema.app.services.UpdateSystemServiceImpl
-import ch.threema.storage.DatabaseServiceNew
-
-/**
- * An in-memory database used in android tests.
- */
-class TestDatabaseService() : DatabaseServiceNew(
-    ApplicationProvider.getApplicationContext(),
-    null,
-    "test-database-key",
-    UpdateSystemServiceImpl()
-)
diff --git a/app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt b/app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt
deleted file mode 100644
index d60f81ac..00000000
--- a/app/src/androidTest/java/ch/threema/data/repositories/ContactModelRepositoryTest.kt
+++ /dev/null
@@ -1,337 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-import androidx.test.ext.junit.runners.AndroidJUnit4
-import ch.threema.data.TestDatabaseService
-import ch.threema.data.models.ModelDeletedException
-import ch.threema.domain.models.ContactSyncState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.ReadReceiptPolicy
-import ch.threema.domain.models.TypingIndicatorPolicy
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.models.WorkVerificationLevel
-import ch.threema.storage.models.ContactModel
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
-import ch.threema.testhelpers.nonSecureRandomArray
-import ch.threema.testhelpers.randomIdentity
-import com.neilalexander.jnacl.NaCl
-import junit.framework.TestCase.assertNotNull
-import kotlinx.coroutines.runBlocking
-import org.junit.Assert.assertArrayEquals
-import org.junit.Assert.assertThrows
-import org.junit.Before
-import org.junit.runner.RunWith
-import java.util.Date
-import kotlin.test.Test
-import kotlin.test.assertContentEquals
-import kotlin.test.assertEquals
-import kotlin.test.assertFailsWith
-import kotlin.test.assertFalse
-import kotlin.test.assertNull
-import kotlin.test.assertTrue
-
-@RunWith(AndroidJUnit4::class)
-class ContactModelRepositoryTest {
-    private lateinit var databaseService: TestDatabaseService
-    private lateinit var contactModelRepository: ContactModelRepository
-
-    private enum class TestTriggerSource {
-        FROM_LOCAL,
-        FROM_REMOTE,
-    }
-
-    private val initialValuesSet = setOf(
-        InitialValues(),
-        InitialValues(publicKey = ByteArray(NaCl.PUBLICKEYBYTES) { it.toByte() }),
-        InitialValues(date = Date(42)),
-        InitialValues(identityType = IdentityType.WORK),
-        InitialValues(acquaintanceLevel = AcquaintanceLevel.GROUP),
-        InitialValues(activityState = State.INACTIVE),
-        InitialValues(featureMask = 64.toULong()),
-    )
-
-    @Before
-    fun before() {
-        this.databaseService = TestDatabaseService()
-        this.contactModelRepository = ModelRepositories(databaseService).contacts
-    }
-
-    @Test
-    fun createFromLocal() {
-        initialValuesSet.forEach { testCreateFromLocalOrRemote(it, TestTriggerSource.FROM_LOCAL) }
-    }
-
-    @Test
-    fun createFromRemote() {
-        initialValuesSet.forEach { testCreateFromLocalOrRemote(it, TestTriggerSource.FROM_REMOTE) }
-    }
-
-    @Test
-    fun createFromLocalTwice() {
-        initialValuesSet.forEach {
-            testCreateFromLocalOrRemoteTwice(it, TestTriggerSource.FROM_LOCAL)
-        }
-    }
-
-    @Test
-    fun createFromRemoteTwice() {
-        initialValuesSet.forEach {
-            testCreateFromLocalOrRemoteTwice(it, TestTriggerSource.FROM_REMOTE)
-        }
-    }
-
-    @Test
-    fun createFromSync() {
-        // TODO(ANDR-2835): Create contact from sync
-    }
-
-    @Test
-    fun getByIdentityNotFound() {
-        val model = contactModelRepository.getByIdentity("ABCDEFGH")
-        assertNull(model)
-    }
-
-    @Test
-    fun getByIdentityExisting() {
-        val identity = randomIdentity()
-        val publicKey = nonSecureRandomArray(32)
-
-        // Create contact using "old model"
-        databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, publicKey))
-
-        // Fetch contact using "new model"
-        val model = contactModelRepository.getByIdentity(identity)
-        assertNotNull(model!!)
-        assertTrue { model.identity == identity }
-        assertTrue { model.data.value?.identity == identity }
-        assertContentEquals(publicKey, model.data.value?.publicKey)
-    }
-
-    @Test
-    fun deleteByIdentityNonExisting() {
-        // If model does not exist, no exception is thrown
-        contactModelRepository.deleteByIdentity("ABCDEFGH")
-        contactModelRepository.deleteByIdentity("ABCDEFGH")
-    }
-
-    @Test
-    fun deleteByIdentityExistingNotCached() {
-        // Create contact using "old model"
-        val identity = randomIdentity()
-        databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, nonSecureRandomArray(32)))
-
-        // Delete through repository
-        contactModelRepository.deleteByIdentity(identity)
-
-        // Ensure that contact is gone
-        val model = contactModelRepository.getByIdentity(identity)
-        assertNull(model)
-    }
-
-    @Test
-    fun deleteByIdentityExistingCached() {
-        // Create contact using "old model"
-        val identity = randomIdentity()
-        databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, nonSecureRandomArray(32)))
-
-        // Fetch model to ensure it's cached
-        val modelBeforeDeletion = contactModelRepository.getByIdentity(identity)
-        assertNotNull(modelBeforeDeletion)
-
-        // Delete through repository
-        contactModelRepository.deleteByIdentity(identity)
-
-        // Ensure that contact is gone
-        val modelAfterDeletion = contactModelRepository.getByIdentity(identity)
-        assertNull(modelAfterDeletion)
-    }
-
-    @Test
-    fun deleteExisting() {
-        // Create contact using "old model"
-        val identity = randomIdentity()
-        databaseService.contactModelFactory.createOrUpdate(ContactModel(identity, nonSecureRandomArray(32)))
-
-        // Fetch model
-        val model = contactModelRepository.getByIdentity(identity)
-        assertNotNull(model!!)
-
-        // Data is present, mutating model is possible
-        assertNotNull(model.data.value)
-        model.setNicknameFromSync("testnick")
-
-        // Delete through repository
-        contactModelRepository.delete(model)
-
-        // Data is gone, mutating model throws exception
-        assertNull(model.data.value)
-        assertFailsWith(ModelDeletedException::class) {
-            model.setNicknameFromSync("testnick")
-        }
-
-        // Ensure that contact is not cached anymore
-        val modelAfterDeletion = contactModelRepository.getByIdentity(identity)
-        assertNull(modelAfterDeletion)
-    }
-
-    private fun testCreateFromLocalOrRemote(
-        initialValues: InitialValues,
-        triggerSource: TestTriggerSource,
-    ) {
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
-
-        val newModel = runBlocking {
-            when (triggerSource) {
-                TestTriggerSource.FROM_LOCAL -> contactModelRepository.createFromLocal(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
-
-                TestTriggerSource.FROM_REMOTE -> contactModelRepository.createFromRemote(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
-
-            }
-        }
-
-        // TODO(ANDR-3003): Test that transaction has been executed
-
-        val queriedModel = contactModelRepository.getByIdentity(initialValues.identity)
-        assertEquals(newModel, queriedModel)
-
-        assertDefaultValues(newModel, initialValues)
-
-        contactModelRepository.deleteByIdentity(initialValues.identity)
-
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
-    }
-
-    private fun testCreateFromLocalOrRemoteTwice(
-        initialValues: InitialValues,
-        triggerSource: TestTriggerSource,
-    ) {
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
-
-        val runCreation = when (triggerSource) {
-            TestTriggerSource.FROM_LOCAL -> suspend {
-                contactModelRepository.createFromLocal(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
-            }
-
-            TestTriggerSource.FROM_REMOTE -> suspend {
-                contactModelRepository.createFromRemote(
-                    initialValues.identity,
-                    initialValues.publicKey,
-                    initialValues.date,
-                    initialValues.identityType,
-                    initialValues.acquaintanceLevel,
-                    initialValues.activityState,
-                    initialValues.featureMask,
-                )
-            }
-
-        }
-
-        // Insert it for the first time
-        val newModel = runBlocking {
-            runCreation()
-        }
-
-        // TODO(ANDR-3003): Test that transaction has been executed
-
-        val queriedModel = contactModelRepository.getByIdentity(initialValues.identity)
-        assertEquals(newModel, queriedModel)
-
-        assertDefaultValues(newModel, initialValues)
-
-        // Insert for the second time and assert that an exception is thrown
-        assertThrows(ContactCreateException::class.java) { runBlocking { runCreation() } }
-
-        contactModelRepository.deleteByIdentity(initialValues.identity)
-
-        assertNull(contactModelRepository.getByIdentity(initialValues.identity))
-    }
-
-    private data class InitialValues(
-        val identity: String = "ABCDEFGH",
-        val publicKey: ByteArray = ByteArray(NaCl.PUBLICKEYBYTES),
-        val date: Date = Date(),
-        val identityType: IdentityType = IdentityType.NORMAL,
-        val acquaintanceLevel: AcquaintanceLevel = AcquaintanceLevel.DIRECT,
-        val activityState: State = State.ACTIVE,
-        val featureMask: ULong = 4.toULong(),
-    )
-
-    private fun assertDefaultValues(
-        contactModel: ch.threema.data.models.ContactModel,
-        initialValues: InitialValues,
-    ) {
-        assertEquals(initialValues.identity, contactModel.identity)
-        val data = contactModel.data.value!!
-
-        // Assert that the given properties match
-        assertArrayEquals(initialValues.publicKey, data.publicKey)
-        assertEquals(initialValues.date.time, data.createdAt.time)
-        assertEquals(initialValues.identityType, data.identityType)
-        assertEquals(initialValues.acquaintanceLevel, data.acquaintanceLevel)
-        assertEquals(initialValues.activityState, data.activityState)
-        assertEquals(initialValues.featureMask, data.featureMask)
-
-        // Assert that the rest is set to the default values
-        assertEquals("", data.firstName)
-        assertEquals("", data.lastName)
-        assertNull(data.nickname)
-        assertEquals(VerificationLevel.UNVERIFIED, data.verificationLevel)
-        assertEquals(WorkVerificationLevel.NONE, data.workVerificationLevel)
-        assertEquals(ContactSyncState.INITIAL, data.syncState)
-        assertEquals(ReadReceiptPolicy.DEFAULT, data.readReceiptPolicy)
-        assertEquals(TypingIndicatorPolicy.DEFAULT, data.typingIndicatorPolicy)
-        assertNull(data.androidContactLookupKey)
-        assertNull(data.localAvatarExpires)
-        assertFalse(data.isRestored)
-        assertNull(data.profilePictureBlobId)
-        assertEquals(
-            ContactModel(data.identity, data.publicKey).idColorIndex.toUByte(),
-            data.colorIndex
-        )
-    }
-}
diff --git a/app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt b/app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt
deleted file mode 100644
index 0249f491..00000000
--- a/app/src/androidTest/java/ch/threema/data/repositories/EditHistoryRepositoryTest.kt
+++ /dev/null
@@ -1,115 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-import ch.threema.data.TestDatabaseService
-import ch.threema.data.storage.EditHistoryDao
-import ch.threema.data.storage.EditHistoryDaoImpl
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.GroupMessageModel
-import ch.threema.storage.models.MessageModel
-import ch.threema.storage.models.MessageType
-import org.junit.Assert
-import org.junit.Before
-import org.junit.Test
-import java.util.UUID
-
-class EditHistoryRepositoryTest {
-    private lateinit var databaseService: TestDatabaseService
-    private lateinit var editHistoryRepository: EditHistoryRepository
-    private lateinit var editHistoryDao: EditHistoryDao
-
-    @Before
-    fun before() {
-        databaseService = TestDatabaseService()
-        editHistoryRepository = ModelRepositories(databaseService).editHistory
-        editHistoryDao = EditHistoryDaoImpl(databaseService)
-    }
-
-    @Test
-    fun testContactMessageHistoryForeignKeyConstraint() {
-        val contactMessage = MessageModel().enrich()
-
-        Assert.assertThrows(EditHistoryEntryCreateException::class.java) {
-            editHistoryRepository.createEntry(contactMessage)
-        }
-
-        databaseService.messageModelFactory.create(contactMessage)
-
-        contactMessage.assertEditHistorySize(0)
-
-        contactMessage.body = "Edited"
-
-        editHistoryRepository.createEntry(contactMessage)
-        databaseService.messageModelFactory.update(contactMessage)
-
-        contactMessage.assertEditHistorySize(1)
-
-        databaseService.messageModelFactory.delete(contactMessage)
-
-        contactMessage.assertEditHistorySize(0)
-    }
-
-    @Test
-    fun testGroupMessageHistoryForeignKeyConstraint() {
-        val groupMessage = GroupMessageModel().enrich()
-
-        Assert.assertThrows(EditHistoryEntryCreateException::class.java) {
-            editHistoryRepository.createEntry(groupMessage)
-        }
-
-        databaseService.groupMessageModelFactory.create(groupMessage)
-
-        groupMessage.assertEditHistorySize(0)
-
-        groupMessage.body = "Edited"
-
-        editHistoryRepository.createEntry(groupMessage)
-        databaseService.groupMessageModelFactory.update(groupMessage)
-
-        groupMessage.assertEditHistorySize(1)
-
-        databaseService.groupMessageModelFactory.delete(groupMessage)
-
-        groupMessage.assertEditHistorySize(0)
-    }
-
-    /**
-     * Assert that the expected amount of entries exists for this message.
-     * Note that this queries the database directly since there might still be some entries cached.
-     * For example if a message is deleted, the history entries will also be deleted due to the foreign
-     * key constraints. The will still remain in the cache until the application is restarted.
-     * This is not a problem, because the message history cannot be displayed when the message was deleted.
-     */
-    private fun AbstractMessageModel.assertEditHistorySize(expectedSize: Int) {
-        val actualSize = editHistoryDao.findAllByMessageUid(uid).size
-
-        Assert.assertEquals(expectedSize, actualSize)
-    }
-
-    private fun <T : AbstractMessageModel> T.enrich(text: String = "Text"): T {
-        type = MessageType.TEXT
-        uid = UUID.randomUUID().toString()
-        body = text
-        return this
-    }
-}
diff --git a/app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt b/app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt
deleted file mode 100644
index 773a7acc..00000000
--- a/app/src/androidTest/java/ch/threema/data/repositories/GroupModelRepositoryTest.kt
+++ /dev/null
@@ -1,184 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-import ch.threema.data.TestDatabaseService
-import ch.threema.data.models.GroupIdentity
-import ch.threema.data.models.GroupModelDataFactory
-import ch.threema.data.storage.DatabaseBackend
-import ch.threema.data.storage.DbGroup
-import ch.threema.data.storage.SqliteDatabaseBackend
-import ch.threema.domain.models.GroupId
-import ch.threema.storage.models.GroupModel
-import org.junit.Assert
-import org.junit.Before
-import org.junit.Test
-import java.util.Date
-import kotlin.test.assertEquals
-import kotlin.test.assertNull
-import kotlin.test.assertTrue
-
-class GroupModelRepositoryTest {
-    private lateinit var databaseService: TestDatabaseService
-    private lateinit var databaseBackend: DatabaseBackend
-    private lateinit var groupModelRepository: GroupModelRepository
-
-    private fun createTestDbGroup(groupIdentity: GroupIdentity): DbGroup {
-        return DbGroup(
-            groupIdentity.creatorIdentity,
-            groupIdentity.groupIdHexString,
-            "Group",
-            Date(),
-            Date(),
-            null,
-            deleted = false,
-            isArchived = false,
-            0.toUByte(),
-            "Description",
-            Date(),
-            setOf("AAAAAAAA", "BBBBBBBB"),
-        )
-    }
-
-    @Before
-    fun before() {
-        this.databaseService = TestDatabaseService()
-        this.databaseBackend = SqliteDatabaseBackend(databaseService)
-        this.groupModelRepository = ModelRepositories(databaseService).groups
-    }
-
-    @Test
-    fun getByGroupIdentityNotFound() {
-        val groupIdentity = GroupIdentity("AAAAAAAA", 42)
-        val model = groupModelRepository.getByGroupIdentity(groupIdentity)
-        assertNull(model)
-    }
-
-    @Test
-    fun getByCreatorIdentityAndIdNotFound() {
-        val model = groupModelRepository.getByCreatorIdentityAndId("AAAAAAAA", GroupId(42))
-        assertNull(model)
-    }
-
-    @Test
-    fun getByGroupIdentityExisting() {
-        val groupIdentity = GroupIdentity("TESTTEST", 42)
-
-        // Create group using the "old" model
-        databaseService.groupModelFactory.create(
-            GroupModel()
-                .setCreatorIdentity(groupIdentity.creatorIdentity)
-                .setApiGroupId(GroupId(groupIdentity.groupId))
-                .setCreatedAt(Date())
-        )
-
-        // Fetch group using the "new" model
-        val model = groupModelRepository.getByGroupIdentity(groupIdentity)!!
-        assertTrue { model.groupIdentity == groupIdentity }
-    }
-
-    @Test
-    fun getByCreatorIdentityAndIdExisting() {
-        val creatorIdentity = "TESTTEST"
-        val groupId = GroupId(-42)
-
-        // Create group using the "old" model
-        databaseService.groupModelFactory.create(
-            GroupModel()
-                .setCreatorIdentity(creatorIdentity)
-                .setApiGroupId(groupId)
-                .setCreatedAt(Date())
-        )
-
-        // Fetch group using the "new" model
-        val model = groupModelRepository.getByCreatorIdentityAndId(creatorIdentity, groupId)!!
-        val groupIdentity = GroupIdentity(creatorIdentity, groupId.toLong())
-        assertTrue { model.groupIdentity == groupIdentity }
-    }
-
-    @Test
-    fun testGetByLocalId() {
-        val groupIdentity = GroupIdentity("TESTTEST", 42)
-        val testGroup = createTestDbGroup(groupIdentity)
-        databaseBackend.createGroup(testGroup)
-
-        // This should work because the database is initially empty and the local group id starts
-        // with 1.
-        val fetchedGroup = groupModelRepository.getByLocalGroupDbId(1)
-        assertEquals(GroupModelDataFactory.toDataType(testGroup), fetchedGroup?.data?.value)
-    }
-
-    @Test
-    fun testGetByCreatorIdentityAndGroupId() {
-        val groupIdentity = GroupIdentity("TESTTEST", 42)
-        val testGroup = createTestDbGroup(groupIdentity)
-        databaseBackend.createGroup(testGroup)
-
-        val fetchedGroup = groupModelRepository.getByCreatorIdentityAndId(
-            groupIdentity.creatorIdentity,
-            GroupId(groupIdentity.groupId),
-        )
-        assertEquals(GroupModelDataFactory.toDataType(testGroup), fetchedGroup?.data?.value)
-    }
-
-    @Test
-    fun testGetByGroupIdentity() {
-        val groupIdentityDefault = GroupIdentity("TESTTEST", 42)
-        val defaultGroup = createTestDbGroup(groupIdentityDefault)
-        testInsertAndGet(groupIdentityDefault, defaultGroup)
-
-        val groupIdentityEmpty = GroupIdentity("TESTTEST", 43)
-        val emptyGroup = createTestDbGroup(groupIdentityEmpty).copy(members = emptySet())
-        testInsertAndGet(groupIdentityEmpty, emptyGroup)
-
-        val groupIdentityDatesNull = GroupIdentity("TESTTEST", 44)
-        val datesNullGroup = createTestDbGroup(groupIdentityDatesNull).copy(
-            synchronizedAt = null,
-            lastUpdate = null,
-            groupDescriptionChangedAt = null
-        )
-        testInsertAndGet(groupIdentityDatesNull, datesNullGroup)
-    }
-
-    @Test
-    fun testMemberSetModification() {
-        val groupIdentity = GroupIdentity("TESTTEST", 42)
-        val defaultGroup = createTestDbGroup(groupIdentity)
-        testInsertAndGet(groupIdentity, defaultGroup)
-
-        val testData = groupModelRepository.getByGroupIdentity(groupIdentity)!!.data.value!!
-        Assert.assertThrows(UnsupportedOperationException::class.java) {
-            // Casting the set to a mutable set will work, but adding a new member to the set should
-            // result in a runtime exception. Note that this is mainly in java code a problem, as
-            // there is no cast needed to add a new member. Of course, it will result in a runtime
-            // exception as well.
-            (testData.members as MutableSet).add("01234567")
-        }
-    }
-
-    private fun testInsertAndGet(groupIdentity: GroupIdentity, testGroup: DbGroup) {
-        databaseBackend.createGroup(testGroup)
-
-        val fetchedGroup = groupModelRepository.getByGroupIdentity(groupIdentity)
-        assertEquals(GroupModelDataFactory.toDataType(testGroup), fetchedGroup?.data?.value)
-    }
-}
diff --git a/app/src/androidTest/java/ch/threema/storage/SQLDHSessionStoreTest.java b/app/src/androidTest/java/ch/threema/storage/SQLDHSessionStoreTest.java
index 96550d0b..c0d78aa6 100644
--- a/app/src/androidTest/java/ch/threema/storage/SQLDHSessionStoreTest.java
+++ b/app/src/androidTest/java/ch/threema/storage/SQLDHSessionStoreTest.java
@@ -21,26 +21,20 @@
 
 package ch.threema.storage;
 
-import org.hamcrest.MatcherAssert;
-import org.hamcrest.Matchers;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.List;
 
 import androidx.test.core.app.ApplicationProvider;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.domain.fs.DHSession;
 import ch.threema.domain.fs.DHSessionId;
 import ch.threema.domain.helpers.DummyUsers;
-import ch.threema.domain.helpers.UnusedTaskCodec;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
 import ch.threema.domain.stores.DHSessionStoreException;
-import ch.threema.domain.taskmanager.TaskCodec;
 
 public class SQLDHSessionStoreTest {
 
@@ -51,7 +45,6 @@ public class SQLDHSessionStoreTest {
 	private SQLDHSessionStore store;
 	private DHSession initiatorDHSession;
 	private DHSession responderDHSession;
-	private final TaskCodec taskCodec = new UnusedTaskCodec();
 
 	@Before
 	public void setup() {
@@ -95,7 +88,7 @@ public class SQLDHSessionStoreTest {
 
 		// Delete any stored initiator session to start with a clean slate
 		store.deleteAllDHSessions(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity());
-		Assert.assertNull(this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), taskCodec));
+		Assert.assertNull(this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity()));
 
 		// Insert an initiator DH session in 2DH mode
 		Assert.assertNotNull(this.initiatorDHSession.getMyRatchet2DH());
@@ -103,12 +96,12 @@ public class SQLDHSessionStoreTest {
 		store.storeDHSession(this.initiatorDHSession);
 
 		// Retrieve the session again and ensure that the details match
-		Assert.assertEquals(this.initiatorDHSession, this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), taskCodec));
+		Assert.assertEquals(this.initiatorDHSession, this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity()));
 
 		// Turn 2DH ratchets once (need to do this here, as responder sessions are always 4DH)
 		this.initiatorDHSession.getMyRatchet2DH().turn();
 		store.storeDHSession(this.initiatorDHSession);
-		Assert.assertEquals(this.initiatorDHSession, this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), taskCodec));
+		Assert.assertEquals(this.initiatorDHSession, this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity()));
 
 		// Now Bob sends his ephemeral public key back to Alice
 		this.initiatorDHSession.processAccept(
@@ -121,7 +114,7 @@ public class SQLDHSessionStoreTest {
 		// initiatorDHSession has now been upgraded to 4DH - store and retrieve it again
 		Assert.assertNotNull(this.initiatorDHSession.getMyRatchet4DH());
 		store.storeDHSession(this.initiatorDHSession);
-		DHSession bestSession = this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), taskCodec);
+		DHSession bestSession = this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity());
 		Assert.assertNotNull(bestSession);
 		Assert.assertEquals(this.initiatorDHSession, bestSession);
 
@@ -130,7 +123,7 @@ public class SQLDHSessionStoreTest {
 
 		// Delete initiator DH session
 		store.deleteDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), this.initiatorDHSession.getId());
-		Assert.assertNull(this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), taskCodec));
+		Assert.assertNull(this.store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity()));
 	}
 
 	@Test
@@ -140,7 +133,7 @@ public class SQLDHSessionStoreTest {
 
 		// Store and retrieve the responder session
 		store.storeDHSession(this.responderDHSession);
-		Assert.assertEquals(this.responderDHSession, this.store.getBestDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), taskCodec));
+		Assert.assertEquals(this.responderDHSession, this.store.getBestDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity()));
 
 		// Turn the 4DH ratchets once, store, retrieve and compare again
 		Assert.assertNotNull(this.responderDHSession.getMyRatchet4DH());
@@ -148,14 +141,14 @@ public class SQLDHSessionStoreTest {
 		this.responderDHSession.getMyRatchet4DH().turn();
 		this.responderDHSession.getPeerRatchet4DH().turn();
 		store.storeDHSession(this.responderDHSession);
-		Assert.assertEquals(this.responderDHSession, this.store.getBestDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), taskCodec));
+		Assert.assertEquals(this.responderDHSession, this.store.getBestDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity()));
 
 		// Try to retrieve a responder session with a random session ID
-		Assert.assertNull(this.store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), new DHSessionId(), taskCodec));
+		Assert.assertNull(this.store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), new DHSessionId()));
 
 		// Delete DH session
 		store.deleteDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId());
-		Assert.assertNull(this.store.getBestDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), taskCodec));
+		Assert.assertNull(this.store.getBestDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity()));
 	}
 
 	@Test
@@ -170,7 +163,7 @@ public class SQLDHSessionStoreTest {
 		store.storeDHSession(this.responderDHSession);
 
 		// There should still be a 2DH ratchet at this point
-		DHSession retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId(), taskCodec);
+		DHSession retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId());
 		Assert.assertNotNull(retrievedSession);
 		Assert.assertNotNull(retrievedSession.getPeerRatchet2DH());
 
@@ -182,7 +175,7 @@ public class SQLDHSessionStoreTest {
 		store.storeDHSession(this.responderDHSession);
 
 		// Ensure that the 2DH ratchet is really gone
-		retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId(), taskCodec);
+		retrievedSession = store.getDHSession(DummyUsers.BOB.getIdentity(), DummyUsers.ALICE.getIdentity(), this.responderDHSession.getId());
 		Assert.assertNotNull(retrievedSession);
 		Assert.assertNull(retrievedSession.getPeerRatchet2DH());
 	}
@@ -199,39 +192,6 @@ public class SQLDHSessionStoreTest {
 		}
 	}
 
-	@Test
-	public void testGetAllSessions() throws DHSessionStoreException {
-		// Create sessions and its id's hashes
-		List<DHSession> dhSessions = new ArrayList<>();
-		for (int i = 0; i < 5; i++) {
-			dhSessions.add(new DHSession(
-				DummyUsers.getContactForUser(DummyUsers.BOB),
-				DummyUsers.getIdentityStoreForUser(DummyUsers.ALICE)
-			));
-		}
-		List<Integer> dhSessionIdHashes = new ArrayList<>(dhSessions.size());
-		for (DHSession session : dhSessions) {
-			dhSessionIdHashes.add(session.getId().hashCode());
-		}
-
-		// Store the sessions
-		for (DHSession session : dhSessions) {
-			store.storeDHSession(session);
-		}
-
-		// Load the sessions again and calculate the hashes
-		List<DHSession> storedDHSessions = store.getAllDHSessions(
-			DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), taskCodec
-		);
-		List<Integer> storedDHSessionIdHashes = new ArrayList<>(storedDHSessions.size());
-		for (DHSession session : storedDHSessions) {
-			storedDHSessionIdHashes.add(session.getId().hashCode());
-		}
-
-		// Assert that the hashes match (note that the ordering does not matter)
-		MatcherAssert.assertThat(storedDHSessionIdHashes, Matchers.containsInAnyOrder(dhSessionIdHashes.toArray()));
-	}
-
 	private void testRaceConditionOnce() throws DHSession.MissingEphemeralPrivateKeyException, DHSessionStoreException, BadMessageException {
 		createSessions();
 
@@ -273,7 +233,7 @@ public class SQLDHSessionStoreTest {
 		} else {
 			lowestSessionId = this.initiatorDHSession.getId();
 		}
-		DHSession bestSession = store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity(), taskCodec);
+		DHSession bestSession = store.getBestDHSession(DummyUsers.ALICE.getIdentity(), DummyUsers.BOB.getIdentity());
 		Assert.assertNotNull(bestSession);
 		Assert.assertEquals(lowestSessionId, bestSession.getId());
 	}
diff --git a/app/src/androidTest/java/ch/threema/storage/TaskArchiveFactoryTest.kt b/app/src/androidTest/java/ch/threema/storage/TaskArchiveFactoryTest.kt
deleted file mode 100644
index 0825c29c..00000000
--- a/app/src/androidTest/java/ch/threema/storage/TaskArchiveFactoryTest.kt
+++ /dev/null
@@ -1,101 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage
-
-import ch.threema.app.ThreemaApplication
-import ch.threema.storage.factories.TaskArchiveFactory
-import junit.framework.TestCase.assertEquals
-import org.junit.After
-import org.junit.Before
-import org.junit.Test
-
-class TaskArchiveFactoryTest {
-    private lateinit var taskArchiveFactory: TaskArchiveFactory
-
-    @Before
-    fun setup() {
-        taskArchiveFactory = ThreemaApplication.requireServiceManager().databaseServiceNew.taskArchiveFactory
-        taskArchiveFactory.deleteAll()
-    }
-
-    @After
-    fun tearDown() {
-        taskArchiveFactory.deleteAll()
-    }
-
-    @Test
-    fun testAdd() {
-        val encodedTasks = listOf(
-            "encoded task 1",
-            "encoded task 2",
-            "encoded task 3",
-        )
-        encodedTasks.forEach { taskArchiveFactory.insert(it) }
-        assertEquals(encodedTasks, taskArchiveFactory.getAll())
-    }
-
-    @Test
-    fun testRemove() {
-        val encodedTasks = listOf(
-            "oldestTask",
-            "firstRemoved",
-            "task1",
-            "task",
-            "task2",
-            "task",
-        )
-        encodedTasks.forEach { taskArchiveFactory.insert(it) }
-        assertEquals(encodedTasks, taskArchiveFactory.getAll())
-
-        taskArchiveFactory.remove("does not exist, so it should not have an effect")
-        assertEquals(encodedTasks, taskArchiveFactory.getAll())
-
-        taskArchiveFactory.remove("firstRemoved")
-        assertEquals(listOf("task1", "task", "task2", "task"), taskArchiveFactory.getAll())
-
-        taskArchiveFactory.removeOne("task")
-        assertEquals(listOf("task1", "task2", "task"), taskArchiveFactory.getAll())
-
-        taskArchiveFactory.removeOne("task2")
-        assertEquals(listOf("task1", "task"), taskArchiveFactory.getAll())
-
-        taskArchiveFactory.remove("task1")
-        assertEquals(listOf("task"), taskArchiveFactory.getAll())
-
-        taskArchiveFactory.remove("task")
-        assertEquals(emptyList<String>(), taskArchiveFactory.getAll())
-
-        taskArchiveFactory.remove("does not exist anymore, so it should not have an effect")
-        assertEquals(emptyList<String>(), taskArchiveFactory.getAll())
-    }
-
-    @Test
-    fun testTrim() {
-        val encodedTasks = listOf(
-            "encoded task 1",
-            "encoded task 2",
-            "encoded task 3",
-        )
-        encodedTasks.forEach { taskArchiveFactory.insert(" $it\n\n") }
-        assertEquals(encodedTasks, taskArchiveFactory.getAll())
-    }
-}
diff --git a/app/src/blue/java/ch/threema/app/activities/DownloadApkActivity.java b/app/src/blue/java/ch/threema/app/activities/DownloadApkActivity.java
deleted file mode 100644
index 414c8956..00000000
--- a/app/src/blue/java/ch/threema/app/activities/DownloadApkActivity.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities;
-
-import android.os.Bundle;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.Nullable;
-import androidx.appcompat.app.AppCompatActivity;
-import ch.threema.base.utils.LoggingUtil;
-
-public class DownloadApkActivity extends AppCompatActivity {
-	public static final String EXTRA_FORCE_UPDATE_DIALOG = "";
-	// stub
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("DownloadApkActivity");
-
-	@Override
-	protected void onCreate(@Nullable Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		logger.error("This activity may not be used in this build variant");
-
-		finish();
-	}
-}
diff --git a/app/src/blue/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/blue/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index ebffc29b..00000000
--- a/app/src/blue/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFFA4C8FF)
-    override val onPrimary = Color(0xFF00315E)
-    override val primaryContainer = Color(0xFF004784)
-    override val onPrimaryContainer = Color(0xFFD4E3FF)
-    override val secondary = Color(0xFFBCC7DC)
-    override val onSecondary = Color(0xFF263141)
-    override val secondaryContainer = Color(0xFF3D434E)
-    override val onSecondaryContainer = Color(0xFFDAE1EF)
-    override val tertiary = Color(0xFFD9BDE2)
-    override val onTertiary = Color(0xFF3D2946)
-    override val tertiaryContainer = Color(0xFF543F5E)
-    override val onTertiaryContainer = Color(0xFFF6D9FF)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C1E)
-    override val onBackground = Color(0xFFE3E2E6)
-    override val surface = Color(0xFF1A1C1E)
-    override val onSurface = Color(0xFFE3E2E6)
-    override val surfaceVariant = Color(0xFF282E35)
-    override val onSurfaceVariant = Color(0xFFC3C6CF)
-    override val outline = Color(0xFF8D9199)
-    override val outlineVariant = Color(0xFF43474E)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE3E2E6)
-    override val inverseOnSurface = Color(0xFF1A1C1E)
-    override val inversePrimary = Color(0xFF005FAD)
-}
diff --git a/app/src/blue/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/blue/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 1154bdb4..00000000
--- a/app/src/blue/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF005FAD)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFD4E3FF)
-    override val onPrimaryContainer = Color(0xFF001C3A)
-    override val secondary = Color(0xFF545F71)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE9F5FE)
-    override val onSecondaryContainer = Color(0xFF111C2B)
-    override val tertiary = Color(0xFF6D5676)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFF6D9FF)
-    override val onTertiaryContainer = Color(0xFF271430)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFDFCFF)
-    override val onBackground = Color(0xFF1A1C1E)
-    override val surface = Color(0xFFFDFCFF)
-    override val onSurface = Color(0xFF1A1C1E)
-    override val surfaceVariant = Color(0xFFE2EBF6)
-    override val onSurfaceVariant = Color(0xFF43474E)
-    override val outline = Color(0xFF73777F)
-    override val outlineVariant = Color(0xFFC3C6CF)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F3033)
-    override val inverseOnSurface = Color(0xFFF1F0F4)
-    override val inversePrimary = Color(0xFFA4C8FF)
-}
diff --git a/app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index 9c780b33..00000000
--- a/app/src/blue/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F2F2)
-)
diff --git a/app/src/blue/java/ch/threema/app/utils/DownloadUtil.java b/app/src/blue/java/ch/threema/app/utils/DownloadUtil.java
deleted file mode 100644
index 431b8c77..00000000
--- a/app/src/blue/java/ch/threema/app/utils/DownloadUtil.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils;
-
-import android.content.Context;
-
-public class DownloadUtil {
-	// stub, download happens through f-droid store
-	public static void deleteOldAPKs(Context context) {	}
-}
diff --git a/app/src/google_services_based/java/ch/threema/app/push/PushRegistrationWorker.java b/app/src/google_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
index 2653f608..59268d7c 100644
--- a/app/src/google_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
+++ b/app/src/google_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
@@ -83,7 +83,7 @@ public class PushRegistrationWorker extends Worker {
 					logger.info("Received FCM registration token");
 					String error = null;
 					try {
-						PushUtil.sendTokenToServer(token, ProtocolDefines.PUSHTOKEN_TYPE_FCM);
+						PushUtil.sendTokenToServer(appContext, token, ProtocolDefines.PUSHTOKEN_TYPE_GCM);
 					} catch (ThreemaException e) {
 						logger.error("Exception", e);
 						error = e.getMessage();
diff --git a/app/src/google_services_based/java/ch/threema/app/push/PushService.java b/app/src/google_services_based/java/ch/threema/app/push/PushService.java
index 2e6f28bd..b416b765 100644
--- a/app/src/google_services_based/java/ch/threema/app/push/PushService.java
+++ b/app/src/google_services_based/java/ch/threema/app/push/PushService.java
@@ -56,7 +56,7 @@ public class PushService extends FirebaseMessagingService {
 	public void onNewToken(@NonNull String token) {
 		logger.info("New FCM token received");
 		try {
-			PushUtil.sendTokenToServer(token, ProtocolDefines.PUSHTOKEN_TYPE_FCM);
+			PushUtil.sendTokenToServer(this, token, ProtocolDefines.PUSHTOKEN_TYPE_GCM);
 		} catch (ThreemaException e) {
 			logger.error("onNewToken, could not send token to server ", e);
 		}
@@ -66,7 +66,7 @@ public class PushService extends FirebaseMessagingService {
 		try {
 			FirebaseMessaging.getInstance().deleteToken();
 			Tasks.await(FirebaseInstallations.getInstance().delete());
-			PushUtil.sendTokenToServer("", ProtocolDefines.PUSHTOKEN_TYPE_NONE);
+			PushUtil.sendTokenToServer(context,"", ProtocolDefines.PUSHTOKEN_TYPE_NONE);
 		} catch (ThreemaException | ExecutionException | InterruptedException e) {
 			logger.warn("Could not delete FCM token", e);
 			return e.getMessage();
diff --git a/app/src/google_services_based/java/ch/threema/app/services/VoiceActionService.java b/app/src/google_services_based/java/ch/threema/app/services/VoiceActionService.java
index 24808738..661d9d9d 100644
--- a/app/src/google_services_based/java/ch/threema/app/services/VoiceActionService.java
+++ b/app/src/google_services_based/java/ch/threema/app/services/VoiceActionService.java
@@ -38,20 +38,16 @@ import java.util.Collections;
 
 import androidx.annotation.RequiresApi;
 import androidx.core.app.NotificationCompat;
-import androidx.core.app.ServiceCompat;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.messagereceiver.MessageReceiver;
-import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.ui.MediaItem;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.storage.models.ContactModel;
 
-import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_REMOTE_MESSAGING;
-
 public class VoiceActionService extends SearchActionVerificationClientService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("VoiceActionService");
 	private static final String TAG = "VoiceActionService";
@@ -65,14 +61,9 @@ public class VoiceActionService extends SearchActionVerificationClientService {
 	private static final String CHANNEL_ID_GOOGLE_ASSISTANT = "Voice_Actions";
 	private static final int NOTIFICATION_ID = 10000;
 
-	private static final int FG_SERVICE_TYPE =
-		Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE
-			? FOREGROUND_SERVICE_TYPE_REMOTE_MESSAGING
-			: 0;
-
 	@Override
 	public void performAction(Intent intent, boolean isVerified, Bundle options) {
-		logger.debug("performAction: intent - {}, isVerified - {}", intent, isVerified);
+		logger.debug(String.format("performAction: intent - %s, isVerified - %s", intent, isVerified));
 
 		this.instantiate();
 
@@ -96,11 +87,7 @@ public class VoiceActionService extends SearchActionVerificationClientService {
 						.setPriority(NotificationCompat.PRIORITY_MIN)
 						.setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
 						.setLocalOnly(true);
-		ServiceCompat.startForeground(
-			this,
-			NOTIFICATION_ID,
-			notificationBuilder.build(),
-			FG_SERVICE_TYPE);
+		this.startForeground(NOTIFICATION_ID, notificationBuilder.build());
 	}
 
 	@RequiresApi(Build.VERSION_CODES.O)
@@ -164,7 +151,7 @@ public class VoiceActionService extends SearchActionVerificationClientService {
 				String identity = bundle.getString("com.google.android.voicesearch.extra.RECIPIENT_CONTACT_CHAT_ID");
 				String message = bundle.getString("android.intent.extra.TEXT");
 
-				if (!TestUtil.isEmptyOrNull(identity, message)) {
+				if (!TestUtil.empty(identity, message)) {
 					ContactModel contactModel = contactService.getByIdentity(identity);
 
 					if (contactModel != null) {
diff --git a/app/src/google_services_based/java/com/google/android/vending/licensing/LicenseChecker.java b/app/src/google_services_based/java/com/google/android/vending/licensing/LicenseChecker.java
index a82aa722..cbeb65b9 100644
--- a/app/src/google_services_based/java/com/google/android/vending/licensing/LicenseChecker.java
+++ b/app/src/google_services_based/java/com/google/android/vending/licensing/LicenseChecker.java
@@ -37,11 +37,13 @@
 
 package com.google.android.vending.licensing;
 
+import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager.NameNotFoundException;
+import android.net.Uri;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.IBinder;
@@ -214,6 +216,24 @@ public class LicenseChecker implements ServiceConnection {
         }
     }
 
+    /**
+     * Triggers the last deep link licensing URL returned from the server, which redirects users to a
+     * page which enables them to gain access to the app. If no such URL is returned by the server, it
+     * will go to the details page of the app in the Play Store.
+     */
+    public void followLastLicensingUrl(Context context) {
+        String licensingUrl = mPolicy.getLicensingUrl();
+        if (licensingUrl == null) {
+            licensingUrl = "https://play.google.com/store/apps/details?id=" + context.getPackageName();
+        }
+        Intent marketIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(licensingUrl));
+        marketIntent.setPackage("com.android.vending");
+        if (!(context instanceof Activity)) {
+            marketIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+        }
+        context.startActivity(marketIntent);
+    }
+
     private void runChecks() {
         LicenseValidator validator;
         while ((validator = mPendingChecks.poll()) != null) {
diff --git a/app/src/green/java/ch/threema/app/activities/DownloadApkActivity.java b/app/src/green/java/ch/threema/app/activities/DownloadApkActivity.java
deleted file mode 100644
index 414c8956..00000000
--- a/app/src/green/java/ch/threema/app/activities/DownloadApkActivity.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities;
-
-import android.os.Bundle;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.Nullable;
-import androidx.appcompat.app.AppCompatActivity;
-import ch.threema.base.utils.LoggingUtil;
-
-public class DownloadApkActivity extends AppCompatActivity {
-	public static final String EXTRA_FORCE_UPDATE_DIALOG = "";
-	// stub
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("DownloadApkActivity");
-
-	@Override
-	protected void onCreate(@Nullable Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		logger.error("This activity may not be used in this build variant");
-
-		finish();
-	}
-}
diff --git a/app/src/green/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/green/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index 1f22f96c..00000000
--- a/app/src/green/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFF34C955)
-    override val onPrimary = Color(0xFF003910)
-    override val primaryContainer = Color(0xFF00531B)
-    override val onPrimaryContainer = Color(0xFFA2EDA8)
-    override val secondary = Color(0xFFB9CCB5)
-    override val onSecondary = Color(0xFF243424)
-    override val secondaryContainer = Color(0xFF444843)
-    override val onSecondaryContainer = Color(0xFFDFE9DD)
-    override val tertiary = Color(0xFFA1D1AB)
-    override val onTertiary = Color(0xFF003C1A)
-    override val tertiaryContainer = Color(0xFF1F4D53)
-    override val onTertiaryContainer = Color(0xFFBCEBF2)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C19)
-    override val onBackground = Color(0xFFE2E3DD)
-    override val surface = Color(0xFF1A1C19)
-    override val onSurface = Color(0xFFE2E3DD)
-    override val surfaceVariant = Color(0xFF203022)
-    override val onSurfaceVariant = Color(0xFFC2C9BD)
-    override val outline = Color(0xFF8C9389)
-    override val outlineVariant = Color(0xFF424940)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE2E3DD)
-    override val inverseOnSurface = Color(0xFF1A1C19)
-    override val inversePrimary = Color(0xFF006E26)
-}
diff --git a/app/src/green/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/green/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 0a89c13f..00000000
--- a/app/src/green/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF05A63F)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFBCEECA)
-    override val onPrimaryContainer = Color(0xFF002106)
-    override val secondary = Color(0xFF526350)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE8F6EA)
-    override val onSecondaryContainer = Color(0xFF101F10)
-    override val tertiary = Color(0xFF04370E)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFBCEBF2)
-    override val onTertiaryContainer = Color(0xFF001F23)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFEFFFE)
-    override val onBackground = Color(0xFF1A1C19)
-    override val surface = Color(0xFFFEFFFE)
-    override val onSurface = Color(0xFF1A1C19)
-    override val surfaceVariant = Color(0xFFE0E4DD)
-    override val onSurfaceVariant = Color(0xFF424940)
-    override val outline = Color(0xFF72796F)
-    override val outlineVariant = Color(0xFFC4C8C1)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F312D)
-    override val inverseOnSurface = Color(0xFFF0F1EB)
-    override val inversePrimary = Color(0xFF009C32)
-}
diff --git a/app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index f5271acf..00000000
--- a/app/src/green/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F4F1)
-)
diff --git a/app/src/green/java/ch/threema/app/utils/DownloadUtil.java b/app/src/green/java/ch/threema/app/utils/DownloadUtil.java
deleted file mode 100644
index 26fb9755..00000000
--- a/app/src/green/java/ch/threema/app/utils/DownloadUtil.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils;
-
-import android.content.Context;
-
-public class DownloadUtil {
-	// stub
-	public static void deleteOldAPKs(Context context) {	}
-}
diff --git a/app/src/hms/java/ch/threema/app/activities/DownloadApkActivity.java b/app/src/hms/java/ch/threema/app/activities/DownloadApkActivity.java
index 414c8956..e0d5a143 100644
--- a/app/src/hms/java/ch/threema/app/activities/DownloadApkActivity.java
+++ b/app/src/hms/java/ch/threema/app/activities/DownloadApkActivity.java
@@ -21,26 +21,9 @@
 
 package ch.threema.app.activities;
 
-import android.os.Bundle;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.Nullable;
 import androidx.appcompat.app.AppCompatActivity;
-import ch.threema.base.utils.LoggingUtil;
 
 public class DownloadApkActivity extends AppCompatActivity {
 	public static final String EXTRA_FORCE_UPDATE_DIALOG = "";
 	// stub
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("DownloadApkActivity");
-
-	@Override
-	protected void onCreate(@Nullable Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		logger.error("This activity may not be used in this build variant");
-
-		finish();
-	}
 }
diff --git a/app/src/hms/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/hms/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index 1f22f96c..00000000
--- a/app/src/hms/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFF34C955)
-    override val onPrimary = Color(0xFF003910)
-    override val primaryContainer = Color(0xFF00531B)
-    override val onPrimaryContainer = Color(0xFFA2EDA8)
-    override val secondary = Color(0xFFB9CCB5)
-    override val onSecondary = Color(0xFF243424)
-    override val secondaryContainer = Color(0xFF444843)
-    override val onSecondaryContainer = Color(0xFFDFE9DD)
-    override val tertiary = Color(0xFFA1D1AB)
-    override val onTertiary = Color(0xFF003C1A)
-    override val tertiaryContainer = Color(0xFF1F4D53)
-    override val onTertiaryContainer = Color(0xFFBCEBF2)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C19)
-    override val onBackground = Color(0xFFE2E3DD)
-    override val surface = Color(0xFF1A1C19)
-    override val onSurface = Color(0xFFE2E3DD)
-    override val surfaceVariant = Color(0xFF203022)
-    override val onSurfaceVariant = Color(0xFFC2C9BD)
-    override val outline = Color(0xFF8C9389)
-    override val outlineVariant = Color(0xFF424940)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE2E3DD)
-    override val inverseOnSurface = Color(0xFF1A1C19)
-    override val inversePrimary = Color(0xFF006E26)
-}
diff --git a/app/src/hms/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/hms/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 0a89c13f..00000000
--- a/app/src/hms/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF05A63F)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFBCEECA)
-    override val onPrimaryContainer = Color(0xFF002106)
-    override val secondary = Color(0xFF526350)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE8F6EA)
-    override val onSecondaryContainer = Color(0xFF101F10)
-    override val tertiary = Color(0xFF04370E)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFBCEBF2)
-    override val onTertiaryContainer = Color(0xFF001F23)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFEFFFE)
-    override val onBackground = Color(0xFF1A1C19)
-    override val surface = Color(0xFFFEFFFE)
-    override val onSurface = Color(0xFF1A1C19)
-    override val surfaceVariant = Color(0xFFE0E4DD)
-    override val onSurfaceVariant = Color(0xFF424940)
-    override val outline = Color(0xFF72796F)
-    override val outlineVariant = Color(0xFFC4C8C1)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F312D)
-    override val inverseOnSurface = Color(0xFFF0F1EB)
-    override val inversePrimary = Color(0xFF009C32)
-}
diff --git a/app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index f5271acf..00000000
--- a/app/src/hms/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F4F1)
-)
diff --git a/app/src/hms_services_based/java/ch/threema/app/push/HmsTokenUtil.kt b/app/src/hms_services_based/java/ch/threema/app/push/HmsTokenUtil.kt
deleted file mode 100644
index 1ca8cadd..00000000
--- a/app/src/hms_services_based/java/ch/threema/app/push/HmsTokenUtil.kt
+++ /dev/null
@@ -1,79 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.push
-
-import android.content.Context
-import ch.threema.base.utils.LoggingUtil
-import com.huawei.agconnect.AGConnectOptionsBuilder
-
-private val logger = LoggingUtil.getThreemaLogger("HmsTokenUtil")
-
-object HmsTokenUtil {
-
-    const val TOKEN_SCOPE = "HCM"
-
-    private const val APP_ID_CONFIG_FIELD = "client/app_id"
-
-    /**
-     * Obtain the app ID from the agconnect-services.json file.
-     *
-     * @return The app id or null if it could not be obtained
-     */
-    @JvmStatic
-    fun getHmsAppId(context: Context): String? {
-        return try {
-            AGConnectOptionsBuilder()
-                .build(context)
-                .getString(APP_ID_CONFIG_FIELD)
-        } catch (e: Exception) {
-            logger.error("Could not obtain HMS app id", e)
-            null
-        }
-    }
-
-    /**
-     * Prepend the provided hms app id to the push token delimited by "|" so the token can be used
-     * by the chat server to send pushes.
-     */
-    @JvmStatic
-    fun prependHmsAppId(appId: String?, token: String?): String? {
-        return if (appId != null && token != null) {
-            "$appId|$token"
-        } else {
-            null
-        }
-    }
-
-    /**
-     * Obtain the the hms app id and prepend it to the push token delimited by "|" so the token can
-     * be used by the chat server to send pushes.
-     *
-     * @param context The application context
-     * @param token The token that has to be formatted
-     * @return The formatted token, or null if the token is null or the app id could not be obtained
-     */
-    @JvmStatic
-    fun obtainAndPrependHmsAppId(context: Context, token: String?): String? {
-        val appId = getHmsAppId(context)
-        return prependHmsAppId(appId, token)
-    }
-}
diff --git a/app/src/hms_services_based/java/ch/threema/app/push/PushRegistrationWorker.java b/app/src/hms_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
index b21bc2ce..1a9b5e9d 100644
--- a/app/src/hms_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
+++ b/app/src/hms_services_based/java/ch/threema/app/push/PushRegistrationWorker.java
@@ -23,13 +23,11 @@ package ch.threema.app.push;
 
 import android.content.Context;
 
+import com.huawei.agconnect.AGConnectOptionsBuilder;
 import com.huawei.hms.aaid.HmsInstanceId;
 
 import org.slf4j.Logger;
 
-import java.util.Objects;
-import java.util.Optional;
-
 import androidx.annotation.NonNull;
 import androidx.work.Data;
 import androidx.work.Worker;
@@ -39,53 +37,74 @@ import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 
 public class PushRegistrationWorker extends Worker {
-    private final Logger logger = LoggingUtil.getThreemaLogger("PushRegistrationWorker");
-
-    private final Context appContext;
-
-    /**
-     * Note: This constructor is called by the WorkManager, so don't add additional parameters!
-     */
-    public PushRegistrationWorker(@NonNull Context appContext, @NonNull WorkerParameters workerParams) {
-        super(appContext, workerParams);
-        this.appContext = appContext;
-    }
-
-    @NonNull
-    @Override
-    public Result doWork() {
-        Data workerFlags = getInputData();
-        final boolean clearToken = workerFlags.getBoolean(PushUtil.EXTRA_CLEAR_TOKEN, false);
-        final boolean withCallback = workerFlags.getBoolean(PushUtil.EXTRA_WITH_CALLBACK, false);
-        logger.debug("doWork HMS token registration clear {} withCallback {}", clearToken, withCallback);
-
-        String error = null;
-
-        try {
-            String appId = Objects.requireNonNull(HmsTokenUtil.getHmsAppId(appContext), "HMS App ID must not be null");
-            if (clearToken) {
-                // Delete the token
-                HmsInstanceId.getInstance(appContext).deleteToken(appId, HmsTokenUtil.TOKEN_SCOPE);
-                PushUtil.sendTokenToServer("", ProtocolDefines.PUSHTOKEN_TYPE_NONE);
-                logger.info("HMS token successfully deleted");
-            } else {
-                // Note that this will only work in release builds as the app signature is tested by huawei
-                String token = HmsInstanceId.getInstance(appContext).getToken(appId, HmsTokenUtil.TOKEN_SCOPE);
-                String formattedToken = Objects.requireNonNull(HmsTokenUtil.prependHmsAppId(appId, token));
-                logger.info("Received HMS registration token");
-                PushUtil.sendTokenToServer(formattedToken, ProtocolDefines.PUSHTOKEN_TYPE_HMS);
-            }
-        } catch (Exception e) {
-            logger.error("Exception during push registration", e);
-            error = Optional.ofNullable(e.getMessage())
-                .orElse("Exception during push registration");
-        }
-
-        if (withCallback) {
-            PushUtil.signalRegistrationFinished(error, clearToken);
-        }
-
-        // required by the Worker interface but is not used for any error handling in the push registration process
-        return Result.success();
-    }
+	private final Logger logger = LoggingUtil.getThreemaLogger("PushRegistrationWorker");
+
+	public static String TOKEN_SCOPE = "HCM";
+	public static String APP_ID_CONFIG_FIELD = "client/app_id";
+
+	private final Context appContext;
+
+	/**
+	 * Constructor for the PushRegistrationWorker.
+	 *
+	 * Note: This constructor is called by the WorkManager, so don't add additional parameters!
+	 */
+	public PushRegistrationWorker(@NonNull Context appContext, @NonNull WorkerParameters workerParams) {
+		super(appContext, workerParams);
+		this.appContext = appContext;
+	}
+
+	@NonNull
+	@Override
+	public Result doWork() {
+		Data workerFlags = getInputData();
+		final boolean clearToken = workerFlags.getBoolean(PushUtil.EXTRA_CLEAR_TOKEN, false);
+		final boolean withCallback = workerFlags.getBoolean(PushUtil.EXTRA_WITH_CALLBACK, false);
+		logger.debug("doWork HMS token registration clear {} withCallback {}", clearToken, withCallback);
+
+		String error = null;
+		if (clearToken) {
+			try {
+
+				String appId = getAppId(appContext);
+
+				// Delete the token.
+				HmsInstanceId.getInstance(appContext).deleteToken(appId, TOKEN_SCOPE);
+				PushUtil.sendTokenToServer(appContext,"", ProtocolDefines.PUSHTOKEN_TYPE_NONE);
+				logger.info("HMS token successfully deleted");
+			} catch (Exception e) {
+				logger.error("Exception", e);
+				error = e.getMessage();
+			}
+		}
+        else {
+			try {
+				String appId = getAppId(appContext);
+
+				// Note that this will only work in release builds as the app signature is tested by huawei
+				String token = HmsInstanceId.getInstance(appContext).getToken(appId, TOKEN_SCOPE);
+				logger.info("Received HMS registration token");
+				PushUtil.sendTokenToServer(appContext, appId + '|' +token, ProtocolDefines.PUSHTOKEN_TYPE_HMS);
+			} catch (Exception e) {
+				logger.error("Exception", e);
+				error = e.getMessage();
+			}
+
+		}
+
+		if (withCallback) {
+			PushUtil.signalRegistrationFinished(error, clearToken);
+		}
+
+		// required by the Worker interface but is not used for any error handling in the push registration process
+		return Result.success();
+	}
+
+	/**
+	 * Obtain the app ID from the agconnect-service.json file.
+	 */
+	private String getAppId(Context context) {
+		return new AGConnectOptionsBuilder().build(context).getString(APP_ID_CONFIG_FIELD);
+	}
+
 }
diff --git a/app/src/hms_services_based/java/ch/threema/app/push/PushService.java b/app/src/hms_services_based/java/ch/threema/app/push/PushService.java
index 1f59c0e4..d05c43e5 100644
--- a/app/src/hms_services_based/java/ch/threema/app/push/PushService.java
+++ b/app/src/hms_services_based/java/ch/threema/app/push/PushService.java
@@ -24,6 +24,7 @@ package ch.threema.app.push;
 import android.content.Context;
 import android.text.format.DateUtils;
 
+import com.huawei.agconnect.AGConnectOptionsBuilder;
 import com.huawei.hms.aaid.HmsInstanceId;
 import com.huawei.hms.api.ConnectionResult;
 import com.huawei.hms.api.HuaweiMobileServicesUtil;
@@ -35,9 +36,8 @@ import org.slf4j.Logger;
 
 import java.util.Date;
 import java.util.Map;
-import java.util.Objects;
 
-import androidx.annotation.Nullable;
+import androidx.annotation.NonNull;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.utils.PushUtil;
 import ch.threema.app.utils.RuntimeUtil;
@@ -45,32 +45,29 @@ import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 
+import static ch.threema.app.push.PushRegistrationWorker.APP_ID_CONFIG_FIELD;
+import static ch.threema.app.push.PushRegistrationWorker.TOKEN_SCOPE;
+
 public class PushService extends HmsMessageService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("PushService");
 
-	public static void deleteToken(Context context) {
-		logger.info("Delete HMS push token");
+	@Override
+	public void onNewToken(@NonNull String token) {
+		logger.info("New HMS token received");
 		try {
-			String appId = Objects.requireNonNull(HmsTokenUtil.getHmsAppId(context));
-			HmsInstanceId.getInstance(ThreemaApplication.getAppContext()).deleteToken(appId, HmsTokenUtil.TOKEN_SCOPE);
-			PushUtil.sendTokenToServer("", ProtocolDefines.PUSHTOKEN_TYPE_NONE);
-		} catch (ApiException | ThreemaException | NullPointerException e) {
-			logger.error("Could not delete hms token", e);
+			PushUtil.sendTokenToServer(this, token, ProtocolDefines.PUSHTOKEN_TYPE_HMS);
+		} catch (ThreemaException e) {
+			logger.error("onNewToken, could not send token to server ", e);
 		}
 	}
 
-	@Override
-	public void onNewToken(@Nullable String token) {
-		logger.info("New HMS token received");
+	public static void deleteToken(Context context) {
+		String appId = new AGConnectOptionsBuilder().build(context).getString(APP_ID_CONFIG_FIELD);
 		try {
-			String formattedToken = HmsTokenUtil.obtainAndPrependHmsAppId(getApplicationContext(), token);
-			if (formattedToken != null) {
-				PushUtil.sendTokenToServer(formattedToken, ProtocolDefines.PUSHTOKEN_TYPE_HMS);
-			} else {
-				logger.warn("Could not send new token to server: app id could not be prepended or token is null");
-			}
-		} catch (ThreemaException e) {
-			logger.error("Could not send token to server ", e);
+			HmsInstanceId.getInstance(ThreemaApplication.getAppContext()).deleteToken(appId, TOKEN_SCOPE);
+			PushUtil.sendTokenToServer(context,"", ProtocolDefines.PUSHTOKEN_TYPE_NONE);
+		} catch (ApiException | ThreemaException e) {
+			logger.error("Could not delete hms token", e);
 		}
 	}
 
@@ -86,10 +83,10 @@ public class PushService extends HmsMessageService {
 		// Log message sent time
 		try {
 			Date sentDate = new Date(remoteMessage.getSentTime());
-			logger.info("*** Message sent     :  {}", sentDate);
-			logger.info("*** Message received : {}", new Date());
-			logger.info("*** Original priority: {}", remoteMessage.getOriginalUrgency());
-			logger.info("*** Current priority: {}", remoteMessage.getUrgency());
+			logger.info("*** Message sent     : " + sentDate.toString(), true);
+			logger.info("*** Message received : " + new Date().toString(), true);
+			logger.info("*** Original priority: " + remoteMessage.getOriginalUrgency());
+			logger.info("*** Current priority: " + remoteMessage.getUrgency());
 		} catch (Exception ignore) {
 		}
 
@@ -107,7 +104,6 @@ public class PushService extends HmsMessageService {
 
 	/**
 	 * check for specific google services
-	 * @noinspection unused
 	 */
 	public static boolean playServicesInstalled(Context context) {
 		return false;
diff --git a/app/src/hms_work/java/ch/threema/app/activities/DownloadApkActivity.java b/app/src/hms_work/java/ch/threema/app/activities/DownloadApkActivity.java
index 414c8956..e0d5a143 100644
--- a/app/src/hms_work/java/ch/threema/app/activities/DownloadApkActivity.java
+++ b/app/src/hms_work/java/ch/threema/app/activities/DownloadApkActivity.java
@@ -21,26 +21,9 @@
 
 package ch.threema.app.activities;
 
-import android.os.Bundle;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.Nullable;
 import androidx.appcompat.app.AppCompatActivity;
-import ch.threema.base.utils.LoggingUtil;
 
 public class DownloadApkActivity extends AppCompatActivity {
 	public static final String EXTRA_FORCE_UPDATE_DIALOG = "";
 	// stub
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("DownloadApkActivity");
-
-	@Override
-	protected void onCreate(@Nullable Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		logger.error("This activity may not be used in this build variant");
-
-		finish();
-	}
 }
diff --git a/app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index ebffc29b..00000000
--- a/app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFFA4C8FF)
-    override val onPrimary = Color(0xFF00315E)
-    override val primaryContainer = Color(0xFF004784)
-    override val onPrimaryContainer = Color(0xFFD4E3FF)
-    override val secondary = Color(0xFFBCC7DC)
-    override val onSecondary = Color(0xFF263141)
-    override val secondaryContainer = Color(0xFF3D434E)
-    override val onSecondaryContainer = Color(0xFFDAE1EF)
-    override val tertiary = Color(0xFFD9BDE2)
-    override val onTertiary = Color(0xFF3D2946)
-    override val tertiaryContainer = Color(0xFF543F5E)
-    override val onTertiaryContainer = Color(0xFFF6D9FF)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C1E)
-    override val onBackground = Color(0xFFE3E2E6)
-    override val surface = Color(0xFF1A1C1E)
-    override val onSurface = Color(0xFFE3E2E6)
-    override val surfaceVariant = Color(0xFF282E35)
-    override val onSurfaceVariant = Color(0xFFC3C6CF)
-    override val outline = Color(0xFF8D9199)
-    override val outlineVariant = Color(0xFF43474E)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE3E2E6)
-    override val inverseOnSurface = Color(0xFF1A1C1E)
-    override val inversePrimary = Color(0xFF005FAD)
-}
diff --git a/app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 1154bdb4..00000000
--- a/app/src/hms_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF005FAD)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFD4E3FF)
-    override val onPrimaryContainer = Color(0xFF001C3A)
-    override val secondary = Color(0xFF545F71)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE9F5FE)
-    override val onSecondaryContainer = Color(0xFF111C2B)
-    override val tertiary = Color(0xFF6D5676)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFF6D9FF)
-    override val onTertiaryContainer = Color(0xFF271430)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFDFCFF)
-    override val onBackground = Color(0xFF1A1C1E)
-    override val surface = Color(0xFFFDFCFF)
-    override val onSurface = Color(0xFF1A1C1E)
-    override val surfaceVariant = Color(0xFFE2EBF6)
-    override val onSurfaceVariant = Color(0xFF43474E)
-    override val outline = Color(0xFF73777F)
-    override val outlineVariant = Color(0xFFC3C6CF)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F3033)
-    override val inverseOnSurface = Color(0xFFF1F0F4)
-    override val inversePrimary = Color(0xFFA4C8FF)
-}
diff --git a/app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index 9c780b33..00000000
--- a/app/src/hms_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F2F2)
-)
diff --git a/app/src/libre/java/ch/threema/app/activities/DownloadApkActivity.java b/app/src/libre/java/ch/threema/app/activities/DownloadApkActivity.java
index befb0d4e..88c25898 100644
--- a/app/src/libre/java/ch/threema/app/activities/DownloadApkActivity.java
+++ b/app/src/libre/java/ch/threema/app/activities/DownloadApkActivity.java
@@ -21,26 +21,9 @@
 
 package ch.threema.app.activities;
 
-import android.os.Bundle;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.Nullable;
 import androidx.appcompat.app.AppCompatActivity;
-import ch.threema.base.utils.LoggingUtil;
 
 public class DownloadApkActivity extends AppCompatActivity {
 	public static final String EXTRA_FORCE_UPDATE_DIALOG = "";
 	// stub, download happens through f-droid store
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("DownloadApkActivity");
-
-	@Override
-	protected void onCreate(@Nullable Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		logger.error("This activity may not be used in this build variant");
-
-		finish();
-	}
 }
diff --git a/app/src/libre/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/libre/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index 1f22f96c..00000000
--- a/app/src/libre/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFF34C955)
-    override val onPrimary = Color(0xFF003910)
-    override val primaryContainer = Color(0xFF00531B)
-    override val onPrimaryContainer = Color(0xFFA2EDA8)
-    override val secondary = Color(0xFFB9CCB5)
-    override val onSecondary = Color(0xFF243424)
-    override val secondaryContainer = Color(0xFF444843)
-    override val onSecondaryContainer = Color(0xFFDFE9DD)
-    override val tertiary = Color(0xFFA1D1AB)
-    override val onTertiary = Color(0xFF003C1A)
-    override val tertiaryContainer = Color(0xFF1F4D53)
-    override val onTertiaryContainer = Color(0xFFBCEBF2)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C19)
-    override val onBackground = Color(0xFFE2E3DD)
-    override val surface = Color(0xFF1A1C19)
-    override val onSurface = Color(0xFFE2E3DD)
-    override val surfaceVariant = Color(0xFF203022)
-    override val onSurfaceVariant = Color(0xFFC2C9BD)
-    override val outline = Color(0xFF8C9389)
-    override val outlineVariant = Color(0xFF424940)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE2E3DD)
-    override val inverseOnSurface = Color(0xFF1A1C19)
-    override val inversePrimary = Color(0xFF006E26)
-}
diff --git a/app/src/libre/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/libre/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 0a89c13f..00000000
--- a/app/src/libre/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF05A63F)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFBCEECA)
-    override val onPrimaryContainer = Color(0xFF002106)
-    override val secondary = Color(0xFF526350)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE8F6EA)
-    override val onSecondaryContainer = Color(0xFF101F10)
-    override val tertiary = Color(0xFF04370E)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFBCEBF2)
-    override val onTertiaryContainer = Color(0xFF001F23)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFEFFFE)
-    override val onBackground = Color(0xFF1A1C19)
-    override val surface = Color(0xFFFEFFFE)
-    override val onSurface = Color(0xFF1A1C19)
-    override val surfaceVariant = Color(0xFFE0E4DD)
-    override val onSurfaceVariant = Color(0xFF424940)
-    override val outline = Color(0xFF72796F)
-    override val outlineVariant = Color(0xFFC4C8C1)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F312D)
-    override val inverseOnSurface = Color(0xFFF0F1EB)
-    override val inversePrimary = Color(0xFF009C32)
-}
diff --git a/app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index f5271acf..00000000
--- a/app/src/libre/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F4F1)
-)
diff --git a/app/src/main/java/ch/threema/app/BuildFlavor.kt b/app/src/main/java/ch/threema/app/BuildFlavor.kt
deleted file mode 100644
index 4ba1cbd5..00000000
--- a/app/src/main/java/ch/threema/app/BuildFlavor.kt
+++ /dev/null
@@ -1,164 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app
-
-sealed class BuildFlavor(
-    val gradleName: String,
-    val licenseType: LicenseType,
-    val buildEnvironment: BuildEnvironment,
-    private val displayName: String,
-) {
-
-    companion object {
-        @JvmStatic
-        val current: BuildFlavor by lazy {
-            when (BuildConfig.FLAVOR) {
-                None.gradleName -> None
-                StoreGoogle.gradleName -> StoreGoogle
-                StoreThreema.gradleName -> StoreThreema
-                StoreGoogleWork.gradleName -> StoreGoogleWork
-                Green.gradleName -> Green
-                SandboxWork.gradleName -> SandboxWork
-                OnPrem.gradleName -> OnPrem
-                Blue.gradleName -> Blue
-                Hms.gradleName -> Hms
-                HmsWork.gradleName -> HmsWork
-                Libre.gradleName -> Libre
-                else -> throw IllegalStateException("Unhandled build flavor " + BuildConfig.FLAVOR)
-            }
-        }
-    }
-
-    enum class LicenseType {
-        NONE, GOOGLE, SERIAL, GOOGLE_WORK, HMS, HMS_WORK, ONPREM
-    }
-
-    enum class BuildEnvironment {
-        LIVE, SANDBOX, ONPREM
-    }
-
-    data object None : BuildFlavor(
-        gradleName = "none",
-        licenseType = LicenseType.NONE,
-        buildEnvironment = BuildEnvironment.LIVE,
-        displayName = "DEV"
-    )
-
-    data object StoreGoogle : BuildFlavor(
-        gradleName = "store_google",
-        licenseType = LicenseType.GOOGLE,
-        buildEnvironment = BuildEnvironment.LIVE,
-        displayName = "Google Play"
-    )
-
-    data object StoreThreema : BuildFlavor(
-        gradleName = "store_threema",
-        licenseType = LicenseType.SERIAL,
-        buildEnvironment = BuildEnvironment.LIVE,
-        displayName = "Threema Shop",
-    )
-
-    data object StoreGoogleWork : BuildFlavor(
-        gradleName = "store_google_work",
-        licenseType = LicenseType.GOOGLE_WORK,
-        buildEnvironment = BuildEnvironment.LIVE,
-        displayName = "Work",
-    )
-
-    data object Green : BuildFlavor(
-        gradleName = "green",
-        licenseType = LicenseType.NONE,
-        buildEnvironment = BuildEnvironment.SANDBOX,
-        displayName = "Green",
-    )
-
-    data object SandboxWork : BuildFlavor(
-        gradleName = "sandbox_work",
-        licenseType = LicenseType.GOOGLE_WORK,
-        buildEnvironment = BuildEnvironment.SANDBOX,
-        displayName = "Sandbox Work",
-    )
-
-    data object OnPrem : BuildFlavor(
-        gradleName = "onprem",
-        licenseType = LicenseType.ONPREM,
-        buildEnvironment = BuildEnvironment.ONPREM,
-        displayName = "OnPrem",
-    )
-
-    data object Blue : BuildFlavor(
-        gradleName = "blue",
-        licenseType = LicenseType.GOOGLE_WORK,
-        buildEnvironment = BuildEnvironment.SANDBOX,
-        displayName = "Blue",
-    )
-
-    data object Hms : BuildFlavor(
-        gradleName = "hms",
-        licenseType = LicenseType.HMS,
-        buildEnvironment = BuildEnvironment.LIVE,
-        displayName = "HMS",
-    )
-
-    data object HmsWork : BuildFlavor(
-        gradleName = "hms_work",
-        licenseType = LicenseType.HMS_WORK,
-        buildEnvironment = BuildEnvironment.LIVE,
-        displayName = "HMS Work",
-    )
-
-    data object Libre : BuildFlavor(
-        gradleName = "libre",
-        licenseType = LicenseType.SERIAL,
-        buildEnvironment = BuildEnvironment.LIVE,
-        displayName = "Libre",
-    )
-
-    val fullDisplayName: String by lazy {
-        displayName + if (BuildConfig.DEBUG) " (DEBUG)" else ""
-    }
-
-    /**
-     * Return whether the self-updater is supported or not.
-     */
-    val maySelfUpdate: Boolean
-        get() = this is StoreThreema
-
-    /**
-     * Return whether this build flavor always uses Threema Push.
-     */
-    val forceThreemaPush: Boolean
-        get() = this is Libre
-
-    /**
-     * Return whether this build flavor is "libre", meaning that it contains
-     * no proprietary services.
-     */
-    val isLibre
-        get() = this is Libre
-
-    /**
-     * Return whether this build flavor uses the sandbox build environment.
-     */
-    val isSandbox: Boolean
-        get() = buildEnvironment == BuildEnvironment.SANDBOX
-}
diff --git a/app/src/main/java/ch/threema/app/ThreemaApplication.java b/app/src/main/java/ch/threema/app/ThreemaApplication.java
index fc5f77b6..063bbad9 100644
--- a/app/src/main/java/ch/threema/app/ThreemaApplication.java
+++ b/app/src/main/java/ch/threema/app/ThreemaApplication.java
@@ -21,10 +21,6 @@
 
 package ch.threema.app;
 
-import static android.app.NotificationManager.ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED;
-import static android.app.NotificationManager.EXTRA_BLOCKED_STATE;
-import static android.app.NotificationManager.EXTRA_NOTIFICATION_CHANNEL_GROUP_ID;
-
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
@@ -49,25 +45,6 @@ import android.provider.ContactsContract;
 import android.text.format.DateUtils;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.WorkerThread;
-import androidx.appcompat.app.AppCompatDelegate;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.ContextCompat;
-import androidx.lifecycle.DefaultLifecycleObserver;
-import androidx.lifecycle.LifecycleOwner;
-import androidx.lifecycle.ProcessLifecycleOwner;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import androidx.preference.PreferenceManager;
-import androidx.work.Constraints;
-import androidx.work.ExistingPeriodicWorkPolicy;
-import androidx.work.ExistingWorkPolicy;
-import androidx.work.NetworkType;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.PeriodicWorkRequest;
-import androidx.work.WorkManager;
-
 import com.datatheorem.android.trustkit.TrustKit;
 import com.datatheorem.android.trustkit.reporting.BackgroundReporter;
 import com.google.android.material.color.DynamicColors;
@@ -92,21 +69,34 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
+import androidx.appcompat.app.AppCompatDelegate;
+import androidx.core.app.NotificationManagerCompat;
+import androidx.core.content.ContextCompat;
+import androidx.lifecycle.DefaultLifecycleObserver;
+import androidx.lifecycle.LifecycleOwner;
+import androidx.lifecycle.ProcessLifecycleOwner;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import androidx.preference.PreferenceManager;
+import androidx.work.Constraints;
+import androidx.work.ExistingPeriodicWorkPolicy;
+import androidx.work.NetworkType;
+import androidx.work.PeriodicWorkRequest;
+import androidx.work.WorkManager;
 import ch.threema.app.backuprestore.csv.BackupService;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.grouplinks.IncomingGroupJoinRequestListener;
 import ch.threema.app.listeners.BallotVoteListener;
 import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.listeners.ContactSettingsListener;
-import ch.threema.app.listeners.ContactTypingListener;
 import ch.threema.app.listeners.ConversationListener;
 import ch.threema.app.listeners.DistributionListListener;
 import ch.threema.app.listeners.GroupListener;
 import ch.threema.app.listeners.MessageListener;
-import ch.threema.app.listeners.NewSyncedContactsListener;
 import ch.threema.app.listeners.ServerMessageListener;
 import ch.threema.app.listeners.SynchronizeContactsListener;
-import ch.threema.app.managers.CoreServiceManager;
 import ch.threema.app.managers.CoreServiceManagerImpl;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
@@ -123,10 +113,8 @@ import ch.threema.app.services.AvatarCacheService;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.ConversationService;
 import ch.threema.app.services.DeadlineListService;
-import ch.threema.app.services.FileService;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.MessageService;
-import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SynchronizeContactsService;
 import ch.threema.app.services.ThreemaPushService;
@@ -134,16 +122,18 @@ import ch.threema.app.services.UpdateSystemService;
 import ch.threema.app.services.UpdateSystemServiceImpl;
 import ch.threema.app.services.UserService;
 import ch.threema.app.services.ballot.BallotService;
+import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.stores.IdentityStore;
 import ch.threema.app.stores.PreferenceStore;
 import ch.threema.app.tasks.MessageQueueMigrationTask;
+import ch.threema.app.utils.ApplicationExitInfoUtil;
+import ch.threema.app.utils.BallotUtil;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ConnectionIndicatorUtil;
 import ch.threema.app.utils.ConversationNotificationUtil;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.LinuxSecureRandom;
 import ch.threema.app.utils.LoggingUEH;
-import ch.threema.app.utils.ApplicationExitInfoUtil;
 import ch.threema.app.utils.PushUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShortcutUtil;
@@ -155,7 +145,6 @@ import ch.threema.app.voip.Config;
 import ch.threema.app.voip.listeners.VoipCallEventListener;
 import ch.threema.app.voip.managers.VoipListenerManager;
 import ch.threema.app.webclient.listeners.WebClientServiceListener;
-import ch.threema.app.webclient.listeners.WebClientWakeUpListener;
 import ch.threema.app.webclient.manager.WebClientListenerManager;
 import ch.threema.app.webclient.services.SessionAndroidService;
 import ch.threema.app.webclient.services.SessionWakeUpServiceImpl;
@@ -166,15 +155,19 @@ import ch.threema.app.workers.ContactUpdateWorker;
 import ch.threema.app.workers.ShareTargetUpdateWorker;
 import ch.threema.app.workers.WorkSyncWorker;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.data.repositories.ModelRepositories;
 import ch.threema.domain.models.AppVersion;
-import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.protocol.connection.ConnectionState;
+import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.stores.DHSessionStoreInterface;
+import ch.threema.libthreema.LibthreemaKt;
+import ch.threema.libthreema.LogLevel;
 import ch.threema.localcrypto.MasterKey;
 import ch.threema.localcrypto.MasterKeyLockedException;
+import ch.threema.logging.LibthreemaLogger;
 import ch.threema.logging.backend.DebugLogFileBackend;
 import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
@@ -195,170 +188,174 @@ import ch.threema.storage.models.data.status.GroupStatusDataModel;
 import ch.threema.storage.models.data.status.VoipStatusDataModel;
 import ch.threema.storage.models.group.IncomingGroupJoinRequestModel;
 
-public class ThreemaApplication extends Application implements DefaultLifecycleObserver {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("ThreemaApplication");
-
-	public static final String INTENT_DATA_CONTACT = "identity";
-	public static final String INTENT_DATA_CONTACT_READONLY = "readonly";
-	public static final String INTENT_DATA_TEXT = "text";
-	public static final String INTENT_DATA_ID_BACKUP = "idbackup";
-	public static final String INTENT_DATA_ID_BACKUP_PW = "idbackuppw";
-	public static final String INTENT_DATA_PASSPHRASE_CHECK = "check";
-	public static final String INTENT_DATA_IS_FORWARD = "is_forward";
-	public static final String INTENT_DATA_TIMESTAMP = "timestamp";
-	public static final String INTENT_DATA_EDITFOCUS = "editfocus";
-	public static final String INTENT_DATA_GROUP = "group";
-	public static final String INTENT_DATA_GROUP_API = "group_api";
-	public static final String INTENT_DATA_GROUP_LINK = "group_link";
-	public static final String INTENT_DATA_DISTRIBUTION_LIST = "distribution_list";
-	public static final String INTENT_DATA_ARCHIVE_FILTER = "archiveFilter";
-	public static final String INTENT_DATA_QRCODE = "qrcodestring";
-	public static final String INTENT_DATA_QRCODE_TYPE_OK = "qrcodetypeok";
-	public static final String INTENT_DATA_MESSAGE_ID = "messageid";
-	public static final String INTENT_DATA_INCOMING_GROUP_REQUEST = "groupRequest";
-	public static final String INTENT_DATA_GROUP_REQUEST_NOTIFICATION_ID = "groupRequestNotificationId";
-	public static final String EXTRA_VOICE_REPLY = "voicereply";
-	public static final String EXTRA_OUTPUT_FILE = "output";
-	public static final String EXTRA_ORIENTATION = "rotate";
-	public static final String EXTRA_FLIP = "flip";
-	public static final String INTENT_DATA_CHECK_ONLY = "check";
-	public static final String INTENT_DATA_ANIM_CENTER = "itemPos";
-	public static final String INTENT_DATA_PICK_FROM_CAMERA = "useCam";
-	public static final String INTENT_PUSH_REGISTRATION_COMPLETE = "registrationComplete";
-	public static final String INTENT_DATA_PIN = "ppin";
-	public static final String INTENT_DATA_HIDE_RECENTS = "hiderec";
-	public static final String INTENT_ACTION_FORWARD = "ch.threema.app.intent.FORWARD";
-	public static final String INTENT_ACTION_SHORTCUT_ADDED = BuildConfig.APPLICATION_ID + ".intent.SHORTCUT_ADDED";
-
-	public static final String CONFIRM_TAG_CLOSE_BALLOT = "cb";
-
-	// Notification IDs
-	public static final int PASSPHRASE_SERVICE_NOTIFICATION_ID = 587;
-	public static final int NEW_MESSAGE_NOTIFICATION_ID = 723;
-	public static final int MASTER_KEY_LOCKED_NOTIFICATION_ID = 724;
-	public static final int NEW_MESSAGE_LOCKED_NOTIFICATION_ID = 725;
-	public static final int NEW_MESSAGE_PIN_LOCKED_NOTIFICATION_ID = 726;
-	public static final int SAFE_FAILED_NOTIFICATION_ID = 727;
-	public static final int SERVER_MESSAGE_NOTIFICATION_ID = 730;
-	public static final int UNSENT_MESSAGE_NOTIFICATION_ID = 732;
-	public static final int WORK_SYNC_NOTIFICATION_ID = 735;
-	public static final int NEW_SYNCED_CONTACTS_NOTIFICATION_ID = 736;
-	public static final int WEB_RESUME_FAILED_NOTIFICATION_ID = 737;
-	public static final int VOICE_MSG_PLAYER_NOTIFICATION_ID = 749;
-	public static final int INCOMING_CALL_NOTIFICATION_ID = 800;
-	public static final int INCOMING_GROUP_CALL_NOTIFICATION_ID = 803;
-
-	private static final String THREEMA_APPLICATION_LISTENER_TAG = "al";
-	public static final String AES_KEY_FILE = "key.dat";
-	public static final String ECHO_USER_IDENTITY = "ECHOECHO";
-	public static final String PHONE_LINKED_PLACEHOLDER = "***";
-	public static final String EMAIL_LINKED_PLACEHOLDER = "***@***";
-
-	public static final String ACTIVITY_CONNECTION_TAG = "threemaApplication";
-	private static final long ACTIVITY_CONNECTION_LIFETIME = 60000;
-
-	public static final int MAX_BLOB_SIZE_MB = 100;
-	public static final int MAX_BLOB_SIZE = MAX_BLOB_SIZE_MB * 1024 * 1024;
-	public static final int MIN_PIN_LENGTH = 4;
-	public static final int MAX_PIN_LENGTH = 8;
-	public static final int MIN_GROUP_MEMBERS_COUNT = 1;
-	public static final int MIN_PW_LENGTH_BACKUP = 8;
-	public static final int MAX_PW_LENGTH_BACKUP = 256;
-	public static final int MIN_PW_LENGTH_ID_EXPORT_LEGACY = 4; // extremely ancient versions of the app on some platform accepted four-letter passwords when generating ID exports
-
-	@Deprecated // Use WORKER_CONTACT_UPDATE_PERIODIC_NAME instead.
-	private static final String WORKER_IDENTITY_STATES_PERIODIC_NAME = "IdentityStates";
-	private static final String WORKER_CONTACT_UPDATE_PERIODIC_NAME = "PeriodicContactUpdate";
-	public static final String WORKER_SHARE_TARGET_UPDATE = "ShareTargetUpdate";
-	public static final String WORKER_WORK_SYNC = "WorkSync";
-	public static final String WORKER_PERIODIC_WORK_SYNC = "PeriodicWorkSync";
-	public static final String WORKER_THREEMA_SAFE_UPLOAD = "SafeUpload";
-	public static final String WORKER_PERIODIC_THREEMA_SAFE_UPLOAD = "PeriodicSafeUpload";
-	public static final String WORKER_CONNECTIVITY_CHANGE = "ConnectivityChange";
-	public static final String WORKER_AUTO_DELETE = "AutoDelete";
-	public static final String WORKER_AUTOSTART = "Autostart";
-
-	public static final Lock onAndroidContactChangeLock = new ReentrantLock();
-
-	private static final String EXIT_REASON_LOGGING_TIMESTAMP = "exit_reason_timestamp";
-
-	private static Context context;
-
-	private static volatile ServiceManager serviceManager;
-	private static volatile AppVersion appVersion;
-	private static volatile MasterKey masterKey;
-
-	private static Date lastLoggedIn;
-	private static boolean isDeviceIdle;
-	public static boolean isResumed = false;
-
-	private static HashMap<String, String> messageDrafts = new HashMap<>();
-	private static HashMap<String, String> quoteDrafts = new HashMap<>();
-
-	public static final ExecutorService sendMessageExecutorService = Executors.newFixedThreadPool(4);
-	public static final ExecutorService sendMessageSingleThreadExecutorService = Executors.newSingleThreadExecutor();
-	public static final ExecutorService voiceMessageThumbnailExecutorService = Executors.newFixedThreadPool(4);
-
-	private static boolean checkAppReplacingState(Context context) {
-		// workaround https://code.google.com/p/android/issues/detail?id=56296
-		if (context.getResources() == null) {
-			logger.debug("App is currently installing. Killing it.");
-			android.os.Process.killProcess(android.os.Process.myPid());
-
-			return false;
-		}
-
-		return true;
-	}
-
-	private void logStackTrace(StackTraceElement[] stackTraceElements) {
-		for (int i = 1; i < stackTraceElements.length; i++) {
-			logger.info("\tat " + stackTraceElements[i]);
-		}
-	}
-
-	private static void showNotesGroupNotice(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
-		if (oldState != newState) {
-			try {
-				GroupService groupService = serviceManager.getGroupService();
-				MessageService messageService = serviceManager.getMessageService();
-				GroupStatusDataModel.GroupStatusType type = null;
-
-				if (newState == GroupService.NOTES) {
-					type = GroupStatusDataModel.GroupStatusType.IS_NOTES_GROUP;
-				} else if (newState == GroupService.PEOPLE && oldState != GroupService.UNDEFINED) {
-					type = GroupStatusDataModel.GroupStatusType.IS_PEOPLE_GROUP;
-				}
-
-				if (type != null) {
-					messageService.createGroupStatus(
-						groupService.createReceiver(groupModel),
-						type,
-						null,
-						null,
-						null
-					);
-				}
-			} catch (ThreemaException e) {
-				logger.error("Exception", e);
-			}
-		}
-	}
+import static android.app.NotificationManager.ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED;
+import static android.app.NotificationManager.EXTRA_BLOCKED_STATE;
+import static android.app.NotificationManager.EXTRA_NOTIFICATION_CHANNEL_GROUP_ID;
 
-	@Override
-	public void onCreate() {
-		long startupTime = System.currentTimeMillis();
+public class ThreemaApplication extends Application implements DefaultLifecycleObserver {
+    private static final Logger logger = LoggingUtil.getThreemaLogger("ThreemaApplication");
+
+    public static final String INTENT_DATA_CONTACT = "identity";
+    public static final String INTENT_DATA_CONTACT_READONLY = "readonly";
+    public static final String INTENT_DATA_TEXT = "text";
+    public static final String INTENT_DATA_ID_BACKUP = "idbackup";
+    public static final String INTENT_DATA_ID_BACKUP_PW = "idbackuppw";
+    public static final String INTENT_DATA_PASSPHRASE_CHECK = "check";
+    public static final String INTENT_DATA_IS_FORWARD = "is_forward";
+    public static final String INTENT_DATA_TIMESTAMP = "timestamp";
+    public static final String INTENT_DATA_EDITFOCUS = "editfocus";
+    public static final String INTENT_DATA_GROUP = "group";
+    public static final String INTENT_DATA_GROUP_API = "group_api";
+    public static final String INTENT_DATA_GROUP_LINK = "group_link";
+    public static final String INTENT_DATA_DISTRIBUTION_LIST = "distribution_list";
+    public static final String INTENT_DATA_ARCHIVE_FILTER = "archiveFilter";
+    public static final String INTENT_DATA_QRCODE = "qrcodestring";
+    public static final String INTENT_DATA_QRCODE_TYPE_OK = "qrcodetypeok";
+    public static final String INTENT_DATA_MESSAGE_ID = "messageid";
+    public static final String INTENT_DATA_INCOMING_GROUP_REQUEST = "groupRequest";
+    public static final String INTENT_DATA_GROUP_REQUEST_NOTIFICATION_ID = "groupRequestNotificationId";
+    public static final String EXTRA_VOICE_REPLY = "voicereply";
+    public static final String EXTRA_OUTPUT_FILE = "output";
+    public static final String EXTRA_ORIENTATION = "rotate";
+    public static final String EXTRA_FLIP = "flip";
+    public static final String INTENT_DATA_CHECK_ONLY = "check";
+    public static final String INTENT_DATA_ANIM_CENTER = "itemPos";
+    public static final String INTENT_DATA_PICK_FROM_CAMERA = "useCam";
+    public static final String INTENT_PUSH_REGISTRATION_COMPLETE = "registrationComplete";
+    public static final String INTENT_DATA_PIN = "ppin";
+    public static final String INTENT_DATA_HIDE_RECENTS = "hiderec";
+    public static final String INTENT_ACTION_FORWARD = "ch.threema.app.intent.FORWARD";
+    public static final String INTENT_ACTION_SHORTCUT_ADDED = BuildConfig.APPLICATION_ID + ".intent.SHORTCUT_ADDED";
+
+    public static final String CONFIRM_TAG_CLOSE_BALLOT = "cb";
+
+    // Notification IDs
+    public static final int PASSPHRASE_SERVICE_NOTIFICATION_ID = 587;
+    public static final int NEW_MESSAGE_NOTIFICATION_ID = 723;
+    public static final int MASTER_KEY_LOCKED_NOTIFICATION_ID = 724;
+    public static final int NEW_MESSAGE_LOCKED_NOTIFICATION_ID = 725;
+    public static final int NEW_MESSAGE_PIN_LOCKED_NOTIFICATION_ID = 726;
+    public static final int SAFE_FAILED_NOTIFICATION_ID = 727;
+    public static final int SERVER_MESSAGE_NOTIFICATION_ID = 730;
+    public static final int UNSENT_MESSAGE_NOTIFICATION_ID = 732;
+    public static final int WORK_SYNC_NOTIFICATION_ID = 735;
+    public static final int NEW_SYNCED_CONTACTS_NOTIFICATION_ID = 736;
+    public static final int WEB_RESUME_FAILED_NOTIFICATION_ID = 737;
+    public static final int VOICE_MSG_PLAYER_NOTIFICATION_ID = 749;
+    public static final int INCOMING_CALL_NOTIFICATION_ID = 800;
+    public static final int INCOMING_GROUP_CALL_NOTIFICATION_ID = 803;
+
+    private static final String THREEMA_APPLICATION_LISTENER_TAG = "al";
+    public static final String AES_KEY_FILE = "key.dat";
+    public static final String ECHO_USER_IDENTITY = "ECHOECHO";
+    public static final String PHONE_LINKED_PLACEHOLDER = "***";
+    public static final String EMAIL_LINKED_PLACEHOLDER = "***@***";
+
+    public static final String ACTIVITY_CONNECTION_TAG = "threemaApplication";
+    private static final long ACTIVITY_CONNECTION_LIFETIME = 60000;
+
+    public static final int MAX_BLOB_SIZE_MB = 100;
+    public static final int MAX_BLOB_SIZE = MAX_BLOB_SIZE_MB * 1024 * 1024;
+    public static final int MIN_PIN_LENGTH = 4;
+    public static final int MAX_PIN_LENGTH = 8;
+    public static final int MIN_GROUP_MEMBERS_COUNT = 1;
+    public static final int MIN_PW_LENGTH_BACKUP = 8;
+    public static final int MAX_PW_LENGTH_BACKUP = 256;
+    public static final int MIN_PW_LENGTH_ID_EXPORT_LEGACY = 4; // extremely ancient versions of the app on some platform accepted four-letter passwords when generating ID exports
+
+    @Deprecated // Use WORKER_CONTACT_UPDATE_PERIODIC_NAME instead.
+    public static final String WORKER_IDENTITY_STATES_PERIODIC_NAME = "IdentityStates";
+    public static final String WORKER_CONTACT_UPDATE_PERIODIC_NAME = "PeriodicContactUpdate";
+    public static final String WORKER_SHARE_TARGET_UPDATE = "ShareTargetUpdate";
+    public static final String WORKER_WORK_SYNC = "WorkSync";
+    public static final String WORKER_PERIODIC_WORK_SYNC = "PeriodicWorkSync";
+    public static final String WORKER_THREEMA_SAFE_UPLOAD = "SafeUpload";
+    public static final String WORKER_PERIODIC_THREEMA_SAFE_UPLOAD = "PeriodicSafeUpload";
+    public static final String WORKER_CONNECTIVITY_CHANGE = "ConnectivityChange";
+    public static final String WORKER_AUTO_DELETE = "AutoDelete";
+    public static final String WORKER_AUTOSTART = "Autostart";
+
+    public static final Lock onAndroidContactChangeLock = new ReentrantLock();
+
+    private static final String EXIT_REASON_LOGGING_TIMESTAMP = "exit_reason_timestamp";
+
+    private static Context context;
+
+    private static volatile ServiceManager serviceManager;
+    private static volatile AppVersion appVersion;
+    private static volatile MasterKey masterKey;
+
+    private static Date lastLoggedIn;
+    private static boolean isDeviceIdle;
+    public static boolean isResumed = false;
+
+    private static HashMap<String, String> messageDrafts = new HashMap<>();
+    private static HashMap<String, String> quoteDrafts = new HashMap<>();
+
+    public static final ExecutorService sendMessageExecutorService = Executors.newFixedThreadPool(4);
+    public static final ExecutorService sendMessageSingleThreadExecutorService = Executors.newSingleThreadExecutor();
+    public static final ExecutorService voiceMessageThumbnailExecutorService = Executors.newFixedThreadPool(4);
+
+    private static boolean checkAppReplacingState(Context context) {
+        // workaround https://code.google.com/p/android/issues/detail?id=56296
+        if (context.getResources() == null) {
+            logger.debug("App is currently installing. Killing it.");
+            android.os.Process.killProcess(android.os.Process.myPid());
+
+            return false;
+        }
+
+        return true;
+    }
+
+    private void logStackTrace(StackTraceElement[] stackTraceElements) {
+        for (int i = 1; i < stackTraceElements.length; i++) {
+            logger.info("\tat " + stackTraceElements[i]);
+        }
+    }
+
+    private static void showNotesGroupNotice(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
+        if (oldState != newState) {
+            try {
+                GroupService groupService = serviceManager.getGroupService();
+                MessageService messageService = serviceManager.getMessageService();
+                GroupStatusDataModel.GroupStatusType type = null;
+
+                if (newState == GroupService.NOTES) {
+                    type = GroupStatusDataModel.GroupStatusType.IS_NOTES_GROUP;
+                } else if (newState == GroupService.PEOPLE && oldState != GroupService.UNDEFINED) {
+                    type = GroupStatusDataModel.GroupStatusType.IS_PEOPLE_GROUP;
+                }
 
-		if (BuildConfig.DEBUG && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
-			StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
-				.detectLeakedSqlLiteObjects()
-				.detectLeakedClosableObjects()
-				.penaltyLog()
-				.penaltyListener(Executors.newSingleThreadExecutor(), v -> {
-					logger.info("STRICTMODE VMPolicy: " + v.getCause());
-					logStackTrace(v.getStackTrace());
-				})
-				.build());
+                if (type != null) {
+                    messageService.createGroupStatus(
+                        groupService.createReceiver(groupModel),
+                        type,
+                        null,
+                        null,
+                        null
+                    );
+                }
+            } catch (ThreemaException e) {
+                logger.error("Exception", e);
+            }
+        }
+    }
+
+    @Override
+    public void onCreate() {
+        long startupTime = System.currentTimeMillis();
+
+        if (BuildConfig.DEBUG && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+            StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+                .detectLeakedSqlLiteObjects()
+                .detectLeakedClosableObjects()
+                .penaltyLog()
+                .penaltyListener(Executors.newSingleThreadExecutor(), v -> {
+                    logger.info("STRICTMODE VMPolicy: " + v.getCause());
+                    logStackTrace(v.getStackTrace());
+                })
+                .build());
 /*
 			StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
 				.detectAll()   // or .detectAll() for all detectable problems
@@ -368,526 +365,537 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 					logStackTrace(v.getStackTrace());
 				})
 				.build());
-*/		}
+*/
+        }
+
+        super.onCreate();
 
-		super.onCreate();
+        applyDynamicColorsIfEnabled();
 
-		applyDynamicColorsIfEnabled();
+        // always log database migration
+        setupLogging(null);
 
-		// always log database migration
-		setupLogging(null);
+        AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM);
 
-		AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM);
+        context = getApplicationContext();
 
-		context = getApplicationContext();
+		LibthreemaKt.init(LogLevel.TRACE, new LibthreemaLogger());
 
 		if (!checkAppReplacingState(context)) {
 			return;
 		}
 
-		// Initialize TrustKit for CA pinning
-		if (!ConfigUtils.isOnPremBuild()) {
-			TrustKit.initializeWithNetworkSecurityConfiguration(this);
-		}
-
-		// Set unhandled exception logger
-		Thread.setDefaultUncaughtExceptionHandler(new LoggingUEH());
+        // Initialize TrustKit for CA pinning
+        if (!ConfigUtils.isOnPremBuild()) {
+            TrustKit.initializeWithNetworkSecurityConfiguration(this);
+        }
 
-		ProcessLifecycleOwner.get().getLifecycle().addObserver(this);
+        // Set unhandled exception logger
+        Thread.setDefaultUncaughtExceptionHandler(new LoggingUEH());
 
-		// Instantiate our own SecureRandom implementation to make sure this gets used everywhere
-		new LinuxSecureRandom();
+        ProcessLifecycleOwner.get().getLifecycle().addObserver(this);
 
-		// Prepare app version object
-		appVersion = new AppVersion(
-				ConfigUtils.getAppVersion(),
-				"A",
-				Locale.getDefault().getLanguage(),
-				Locale.getDefault().getCountry(),
-				Build.MODEL,
-				Build.VERSION.RELEASE
-		);
+        // Instantiate our own SecureRandom implementation to make sure this gets used everywhere
+        new LinuxSecureRandom();
 
-		// Create master key
-		File filesDir = getAppContext().getFilesDir();
-		if (filesDir != null) {
-			filesDir.mkdirs();
+        // Prepare app version object
+        appVersion = new AppVersion(
+            ConfigUtils.getAppVersion(),
+            "A",
+            Locale.getDefault().getLanguage(),
+            Locale.getDefault().getCountry(),
+            Build.MODEL,
+            Build.VERSION.RELEASE
+        );
 
-			if (filesDir.exists() && filesDir.isDirectory()) {
-				File masterKeyFile = new File(filesDir, AES_KEY_FILE);
+        // Create master key
+        File filesDir = getAppContext().getFilesDir();
+        if (filesDir != null) {
+            filesDir.mkdirs();
 
-				try {
-					boolean reset = !masterKeyFile.exists();
-
-					if (reset) {
-						/*
-						 *
-						 * IMPORTANT
-						 *
-						 * If the MasterKey file does not exists, remove every file that is encrypted with this
-						 * non-existing MasterKey file
-						 *
-						 * 1. Database
-						 * 2. Settings
-						 * 3. Message Queue
-						 *
-						 * TODO: move this into a separate method/file
-						 *
-						 */
-						//remove database, its encrypted with the wrong master key
-
-						logger.info("master key is missing or does not match. rename database files.");
-
-						File databaseFile = getAppContext().getDatabasePath(DatabaseServiceNew.DEFAULT_DATABASE_NAME_V4);
-						if (databaseFile.exists()) {
-							File databaseBackup = new File(databaseFile.getPath() + ".backup");
-							if (!databaseFile.renameTo(databaseBackup)) {
-								FileUtil.deleteFileOrWarn(databaseFile, "threema4 database", logger);
-							}
-						}
+            if (filesDir.exists() && filesDir.isDirectory()) {
+                File masterKeyFile = new File(filesDir, AES_KEY_FILE);
 
-						databaseFile = getAppContext().getDatabasePath(DatabaseNonceStore.DATABASE_NAME_V4);
-						if (databaseFile.exists()) {
-							FileUtil.deleteFileOrWarn(databaseFile, "nonce4 database", logger);
-						}
+                try {
+                    boolean reset = !masterKeyFile.exists();
+
+                    if (reset) {
+                        /*
+                         *
+                         * IMPORTANT
+                         *
+                         * If the MasterKey file does not exists, remove every file that is encrypted with this
+                         * non-existing MasterKey file
+                         *
+                         * 1. Database
+                         * 2. Settings
+                         * 3. Message Queue
+                         *
+                         * TODO(ANDR-XXXX): move this into a separate method/file
+                         *
+                         */
+                        //remove database, its encrypted with the wrong master key
+
+                        logger.info("master key is missing or does not match. rename database files.");
+
+                        File databaseFile = getAppContext().getDatabasePath(DatabaseServiceNew.DEFAULT_DATABASE_NAME_V4);
+                        if (databaseFile.exists()) {
+                            File databaseBackup = new File(databaseFile.getPath() + ".backup");
+                            if (!databaseFile.renameTo(databaseBackup)) {
+                                FileUtil.deleteFileOrWarn(databaseFile, "threema4 database", logger);
+                            }
+                        }
 
-						databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
-						if (databaseFile.exists()) {
-							FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
-						}
+                        databaseFile = getAppContext().getDatabasePath(DatabaseNonceStore.DATABASE_NAME_V4);
+                        if (databaseFile.exists()) {
+                            FileUtil.deleteFileOrWarn(databaseFile, "nonce4 database", logger);
+                        }
 
-						//remove all settings!
-						logger.info("initialize: remove preferences");
-						PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
-						preferenceStore.clear();
-					} else {
-						logger.info("OK, masterKeyFile exists");
-					}
+                        databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
+                        if (databaseFile.exists()) {
+                            FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
+                        }
 
-					masterKey = new MasterKey(masterKeyFile, null, true);
+                        //remove all settings!
+                        logger.info("initialize: remove preferences");
+                        PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
+                        preferenceStore.clear();
+                    } else {
+                        logger.info("OK, masterKeyFile exists");
+                    }
 
-					if (!masterKey.isLocked()) {
-						reset();
-					} else {
-						setupDayNightMode();
-					}
-				} catch (IOException e) {
-					logger.error("IOException", e);
-				}
+                    masterKey = new MasterKey(masterKeyFile, null, true);
 
-				// Register "Connectivity Action" broadcast receiver.
-				// This is called when a change in network connectivity has occurred.
-				// Note: This is deprecated on API 28+!
-				getAppContext().registerReceiver(
-					new ConnectivityChangeReceiver(),
-					new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)
-				);
+                    if (!masterKey.isLocked()) {
+                        reset();
+                    } else {
+                        setupDayNightMode();
+                    }
+                } catch (IOException e) {
+                    logger.error("IOException", e);
+                }
 
-				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-					// Register "Device Idle Mode Changed" broadcast receiver.
-					// This is called when the state of isDeviceIdleMode() changes. This broadcast
-					// is only sent to registered receivers.
-					getAppContext().registerReceiver(new BroadcastReceiver() {
-						@TargetApi(Build.VERSION_CODES.M)
-						@Override
-						public void onReceive(Context context, Intent intent) {
-							final PowerManager powerManager = (PowerManager) context
-								.getApplicationContext()
-								.getSystemService(Context.POWER_SERVICE);
-							if (powerManager != null && powerManager.isDeviceIdleMode()) {
-								logger.info("*** Device going to deep sleep");
-
-								isDeviceIdle = true;
-
-								try {
-									// Pause connection
-									serviceManager.getLifetimeService().pause();
-								} catch (Exception e) {
-									logger.error("Exception while pausing connection", e);
-								}
-
-								if (BackupService.isRunning()) {
-									context.stopService(new Intent(context, BackupService.class));
-								}
-							} else {
-								logger.info("*** Device waking up");
-								if (serviceManager != null) {
-									new Thread(() -> {
-										try {
-											serviceManager.getLifetimeService().unpause();
-										} catch (Exception e) {
-											logger.error("Exception while unpausing connection", e);
-										}
-									}, "device_wakup").start();
-									isDeviceIdle = false;
-								} else {
-									logger.info("Service manager unavailable");
-									if (masterKey != null && !masterKey.isLocked()) {
-										reset();
-									}
-								}
-							}
-						}
-					}, new IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
-				}
+                // Register "Connectivity Action" broadcast receiver.
+                // This is called when a change in network connectivity has occurred.
+                // Note: This is deprecated on API 28+!
+                getAppContext().registerReceiver(
+                    new ConnectivityChangeReceiver(),
+                    new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)
+                );
+
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+                    // Register "Device Idle Mode Changed" broadcast receiver.
+                    // This is called when the state of isDeviceIdleMode() changes. This broadcast
+                    // is only sent to registered receivers.
+                    getAppContext().registerReceiver(new BroadcastReceiver() {
+                        @TargetApi(Build.VERSION_CODES.M)
+                        @Override
+                        public void onReceive(Context context, Intent intent) {
+                            final PowerManager powerManager = (PowerManager) context
+                                .getApplicationContext()
+                                .getSystemService(Context.POWER_SERVICE);
+                            if (powerManager != null && powerManager.isDeviceIdleMode()) {
+                                logger.info("*** Device going to deep sleep");
+
+                                isDeviceIdle = true;
+
+                                try {
+                                    // Pause connection
+                                    serviceManager.getLifetimeService().pause();
+                                } catch (Exception e) {
+                                    logger.error("Exception while pausing connection", e);
+                                }
+
+                                if (BackupService.isRunning()) {
+                                    context.stopService(new Intent(context, BackupService.class));
+                                }
+                            } else {
+                                logger.info("*** Device waking up");
+                                if (serviceManager != null) {
+                                    new Thread(() -> {
+                                        try {
+                                            serviceManager.getLifetimeService().unpause();
+                                        } catch (Exception e) {
+                                            logger.error("Exception while unpausing connection", e);
+                                        }
+                                    }, "device_wakup").start();
+                                    isDeviceIdle = false;
+                                } else {
+                                    logger.info("Service manager unavailable");
+                                    if (masterKey != null && !masterKey.isLocked()) {
+                                        reset();
+                                    }
+                                }
+                            }
+                        }
+                    }, new IntentFilter(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED));
+                }
 
-				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
-					// Register "Notification Channel Group Block State Changed" broadcast receiver.
-					// This is called when a NotificationChannelGroup is blocked or unblocked.
-					// This broadcast is only sent to the app that owns the channel group that has changed.
-					getAppContext().registerReceiver(new BroadcastReceiver() {
-						@Override
-						public void onReceive(Context context, Intent intent) {
-							try {
-								boolean blockedState = intent.getBooleanExtra(EXTRA_BLOCKED_STATE, false);
-								String groupName = intent.getStringExtra(EXTRA_NOTIFICATION_CHANNEL_GROUP_ID);
-								logger.info(
-									"*** Channel group {} blocked: {}",
-									groupName != null ? groupName : "<not specified>",
-									blockedState
-								);
-							} catch (Exception e) {
-								logger.error("Could not get data from intent", e);
-							}
-						}
-					}, new IntentFilter(ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED));
-				}
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
+                    // Register "Notification Channel Group Block State Changed" broadcast receiver.
+                    // This is called when a NotificationChannelGroup is blocked or unblocked.
+                    // This broadcast is only sent to the app that owns the channel group that has changed.
+                    getAppContext().registerReceiver(new BroadcastReceiver() {
+                        @Override
+                        public void onReceive(Context context, Intent intent) {
+                            try {
+                                boolean blockedState = intent.getBooleanExtra(EXTRA_BLOCKED_STATE, false);
+                                String groupName = intent.getStringExtra(EXTRA_NOTIFICATION_CHANNEL_GROUP_ID);
+                                logger.info(
+                                    "*** Channel group {} blocked: {}",
+                                    groupName != null ? groupName : "<not specified>",
+                                    blockedState
+                                );
+                            } catch (Exception e) {
+                                logger.error("Could not get data from intent", e);
+                            }
+                        }
+                    }, new IntentFilter(ACTION_NOTIFICATION_CHANNEL_GROUP_BLOCK_STATE_CHANGED));
+                }
 
-				// Add a local broadcast receiver to receive PinningFailureReports
-				PinningFailureReportBroadcastReceiver receiver = new PinningFailureReportBroadcastReceiver();
-				LocalBroadcastManager.getInstance(context).registerReceiver(receiver, new IntentFilter(BackgroundReporter.REPORT_VALIDATION_EVENT));
+                // Add a local broadcast receiver to receive PinningFailureReports
+                PinningFailureReportBroadcastReceiver receiver = new PinningFailureReportBroadcastReceiver();
+                LocalBroadcastManager.getInstance(context).registerReceiver(receiver, new IntentFilter(BackgroundReporter.REPORT_VALIDATION_EVENT));
 
-				// Register a broadcast receiver for changes in app restrictions
-				if (ConfigUtils.isWorkRestricted()) {
-					getAppContext().registerReceiver(new BroadcastReceiver() {
-						@Override
-						public void onReceive(Context context, Intent intent) {
-							logger.info("Restrictions have changed. Updating workers");
+                // Register a broadcast receiver for changes in app restrictions
+                if (ConfigUtils.isWorkRestricted()) {
+                    getAppContext().registerReceiver(new BroadcastReceiver() {
+                        @Override
+                        public void onReceive(Context context, Intent intent) {
+                            logger.info("Restrictions have changed. Updating workers");
 
 							AppRestrictionService.getInstance().reload();
 							try {
-								OneTimeWorkRequest workRequest = WorkSyncWorker.Companion.buildOneTimeWorkRequest(true, true, null);
-								WorkManager.getInstance(ThreemaApplication.getAppContext()).enqueueUniqueWork(WORKER_WORK_SYNC, ExistingWorkPolicy.REPLACE, workRequest);
+								WorkSyncWorker.Companion.performOneTimeWorkSync(
+									ThreemaApplication.getAppContext(),
+									true,
+									true,
+									null
+								);
 							} catch (IllegalStateException e) {
 								logger.error("Unable to schedule work sync one time work", e);
 							}
-
-							if (!AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext())) {
-								AutoDeleteWorker.Companion.cancelAutoDelete(getAppContext());
-							}
+							AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext());
 						}
 					}, new IntentFilter(Intent.ACTION_APPLICATION_RESTRICTIONS_CHANGED));
 				}
 
-				// register a receiver for shortcuts that have been added to the launcher
-				ContextCompat.registerReceiver(this, new ShortcutAddedReceiver(), new IntentFilter(INTENT_ACTION_SHORTCUT_ADDED), ContextCompat.RECEIVER_NOT_EXPORTED);
+                // register a receiver for shortcuts that have been added to the launcher
+                ContextCompat.registerReceiver(this, new ShortcutAddedReceiver(), new IntentFilter(INTENT_ACTION_SHORTCUT_ADDED), ContextCompat.RECEIVER_NOT_EXPORTED);
 
-				// Start the Threema Push Service (if enabled in config)
-				ThreemaPushService.tryStart(logger, getAppContext());
-			}
-		}
+                // Start the Threema Push Service (if enabled in config)
+                ThreemaPushService.tryStart(logger, getAppContext());
+            }
+        }
 
-		logger.info("Startup time {}s", (System.currentTimeMillis() - startupTime) / DateUtils.SECOND_IN_MILLIS);
-	}
+        logger.info("Startup time {}s", (System.currentTimeMillis() - startupTime) / DateUtils.SECOND_IN_MILLIS);
+    }
 
 	private void applyDynamicColorsIfEnabled() {
 		if (DynamicColors.isDynamicColorAvailable()) {
 			SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);
 			if (sharedPreferences != null && sharedPreferences.getBoolean("pref_dynamic_color", false)) {
-				DynamicColorsOptions dynamicColorsOptions = new DynamicColorsOptions.Builder().setPrecondition(new DynamicColors.Precondition() {
-					@Override
-					public boolean shouldApplyDynamicColors(@NonNull Activity activity, int theme) {
-						SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext());
-						return sharedPreferences != null && sharedPreferences.getBoolean("pref_dynamic_color", false);
-					}
+				DynamicColorsOptions dynamicColorsOptions = new DynamicColorsOptions.Builder().setPrecondition((activity, theme) -> {
+					SharedPreferences sharedPreferences1 = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext());
+					return sharedPreferences1 != null && sharedPreferences1.getBoolean("pref_dynamic_color", false);
 				}).build();
 
-				DynamicColors.applyToActivitiesIfAvailable(this, dynamicColorsOptions);
-			}
-		}
-	}
-
-	@Override
-	public void onStart(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now visible");
-	}
-
-	@Override
-	public void onStop(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now stopped");
-	}
-
-	@Override
-	public void onCreate(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now created");
-	}
-
-	@Override
-	public void onResume(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now resumed");
-		isResumed = true;
-
-		if (serviceManager != null) {
-			serviceManager.getLifetimeService().acquireConnection(ACTIVITY_CONNECTION_TAG);
-			logger.info("Connection now acquired");
-		} else {
-			logger.info("Service manager is null");
-		}
-	}
-
-	@Override
-	public void onPause(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now paused");
-		isResumed = false;
-
-		if (serviceManager != null) {
-			serviceManager.getLifetimeService().releaseConnectionLinger(ACTIVITY_CONNECTION_TAG, ACTIVITY_CONNECTION_LIFETIME);
-		}
-	}
-
-	@Override
-	public void onDestroy(@NonNull LifecycleOwner owner) {
-		logger.info("*** Lifecycle: App now destroyed");
-	}
-
-	@Override
-	public void onLowMemory() {
-		logger.info("*** App is low on memory");
-
-		super.onLowMemory();
-		try {
-			if (serviceManager != null) {
-				serviceManager.getAvatarCacheService().clear();
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	@SuppressLint("SwitchIntDef")
-	@Override
-	public void onTrimMemory(int level) {
-		logger.info("onTrimMemory (level={})", level);
-
-		super.onTrimMemory(level);
-
-		/* save our master key now if necessary, as we may get killed and if the user was still in the
-	     * initial setup procedure, this can lead to trouble as the database may already be there
-	     * but we may no longer be able to access it due to missing master key
-		 */
-		try {
-			if (getMasterKey() != null && !getMasterKey().isProtected()) {
-				if (serviceManager != null && serviceManager.getPreferenceService().getWizardRunning()) {
-					getMasterKey().setPassphrase(null);
-				}
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	@Nullable
-	public static ServiceManager getServiceManager() {
-		return serviceManager;
-	}
-
-	@NonNull
-	public static ServiceManager requireServiceManager() throws NullPointerException {
-		return Objects.requireNonNull(serviceManager);
-	}
-
-	public static MasterKey getMasterKey() {
-		return masterKey;
-	}
-
-	public static void putMessageDraft(String chatId, CharSequence value, @Nullable AbstractMessageModel quotedMessageModel) {
-		if (value == null || value.toString().trim().length() < 1) {
-			messageDrafts.remove(chatId);
-			quoteDrafts.remove(chatId);
-		} else {
-			messageDrafts.put(chatId, value.toString());
-			if (quotedMessageModel != null) {
-				quoteDrafts.put(chatId, quotedMessageModel.getApiMessageId());
-			} else {
-				quoteDrafts.remove(chatId);
-			}
-		}
-		try {
-			PreferenceService preferenceService = requireServiceManager().getPreferenceService();
-			preferenceService.setMessageDrafts(messageDrafts);
-			preferenceService.setQuoteDrafts(quoteDrafts);
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	public static String getMessageDraft(String chatId) {
-		if (messageDrafts.containsKey(chatId)) {
-			return messageDrafts.get(chatId);
-		}
-		return null;
-	}
-
-	public static String getQuoteDraft(String chatId) {
-		if (quoteDrafts.containsKey(chatId)) {
-			return quoteDrafts.get(chatId);
-		}
-		return null;
-	}
-
-	private static void retrieveMessageDraftsFromStorage() {
-		try {
-			messageDrafts = getServiceManager().getPreferenceService().getMessageDrafts();
-			quoteDrafts = getServiceManager().getPreferenceService().getQuoteDrafts();
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-	}
-
-	@SuppressLint("ApplySharedPref")
-	private static void resetPreferences(SharedPreferences prefs) {
-		// Fix master key preference state if necessary (could be wrong if user kills app
-		// while disabling master key passphrase).
-		if (masterKey.isProtected() && prefs != null && !prefs.getBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), false)) {
-			logger.debug("Master key is protected, but switch preference is disabled - fixing");
-			prefs.edit().putBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), true).commit();
-		}
-
-		// If device is in AEC exclusion list and the user did not choose a preference yet,
-		// update the shared preference.
-		if (prefs != null && prefs.getString(getAppContext().getString(R.string.preferences__voip_echocancel), "none").equals("none")) {
-			// Determine whether device is excluded from hardware AEC
-			final String modelInfo = Build.MANUFACTURER + ";" + Build.MODEL;
-			boolean exclude = !Config.allowHardwareAec();
-
-			// Set default preference
-			final SharedPreferences.Editor editor = prefs.edit();
-			if (exclude) {
-				logger.debug("Device {} is on AEC exclusion list, switching to software echo cancellation", modelInfo);
-				editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "sw");
-			} else {
-				logger.debug("Device {} is not on AEC exclusion list", modelInfo);
-				editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "hw");
-			}
-			editor.commit();
-		}
-
-		try {
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_chat, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_privacy, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_appearance, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_notifications, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_media, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_calls, true);
-			PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_advanced_options, true);
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-
-		setupDayNightMode();
-	}
-
-	/**
-	 * Setup day / night theme for application depending on preferences
-	 */
-	private static void setupDayNightMode() {
-		AppCompatDelegate.setDefaultNightMode(ConfigUtils.getAppThemePrefs());
-	}
-
-	private static void setupLogging(PreferenceStore preferenceStore) {
-		// check if a THREEMA_MESSAGE_LOG exist on the
-		final File forceMessageLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_MESSAGE_LOG");
-		final File forceDebugLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_DEBUG_LOG");
-
-		// enable message logging if necessary
-		if (preferenceStore == null || preferenceStore.getBoolean(getAppContext().getString(R.string.preferences__message_log_switch))
-			|| forceMessageLog.exists() || forceDebugLog.exists()) {
-			DebugLogFileBackend.setEnabled(true);
-		} else {
-			DebugLogFileBackend.setEnabled(false);
-		}
+                DynamicColors.applyToActivitiesIfAvailable(this, dynamicColorsOptions);
+            }
+        }
+    }
+
+    @Override
+    public void onStart(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now visible");
+    }
+
+    @Override
+    public void onStop(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now stopped");
+    }
+
+    @Override
+    public void onCreate(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now created");
+    }
+
+    @Override
+    public void onResume(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now resumed");
+        isResumed = true;
+
+        if (serviceManager != null) {
+            serviceManager.getLifetimeService().acquireConnection(ACTIVITY_CONNECTION_TAG);
+            logger.info("Connection now acquired");
+        } else {
+            logger.info("Service manager is null");
+        }
+    }
+
+    @Override
+    public void onPause(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now paused");
+        isResumed = false;
+
+        if (serviceManager != null) {
+            serviceManager.getLifetimeService().releaseConnectionLinger(ACTIVITY_CONNECTION_TAG, ACTIVITY_CONNECTION_LIFETIME);
+        }
+    }
+
+    @Override
+    public void onDestroy(@NonNull LifecycleOwner owner) {
+        logger.info("*** Lifecycle: App now destroyed");
+    }
+
+    @Override
+    public void onLowMemory() {
+        logger.info("*** App is low on memory");
+
+        super.onLowMemory();
+        try {
+            if (serviceManager != null) {
+                serviceManager.getAvatarCacheService().clear();
+            }
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    @SuppressLint("SwitchIntDef")
+    @Override
+    public void onTrimMemory(int level) {
+        logger.info("onTrimMemory (level={})", level);
+
+        super.onTrimMemory(level);
+
+        /* save our master key now if necessary, as we may get killed and if the user was still in the
+         * initial setup procedure, this can lead to trouble as the database may already be there
+         * but we may no longer be able to access it due to missing master key
+         */
+        try {
+            if (getMasterKey() != null && !getMasterKey().isProtected()) {
+                if (serviceManager != null && serviceManager.getPreferenceService().getWizardRunning()) {
+                    getMasterKey().setPassphrase(null);
+                }
+            }
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    @Nullable
+    public static ServiceManager getServiceManager() {
+        return serviceManager;
+    }
+
+    @NonNull
+    public static ServiceManager requireServiceManager() throws NullPointerException {
+        return Objects.requireNonNull(serviceManager);
+    }
+
+    public static MasterKey getMasterKey() {
+        return masterKey;
+    }
+
+    public static void putMessageDraft(String chatId, CharSequence value, @Nullable AbstractMessageModel quotedMessageModel) {
+        if (value == null || value.toString().trim().length() < 1) {
+            messageDrafts.remove(chatId);
+            quoteDrafts.remove(chatId);
+        } else {
+            messageDrafts.put(chatId, value.toString());
+            if (quotedMessageModel != null) {
+                quoteDrafts.put(chatId, quotedMessageModel.getApiMessageId());
+            } else {
+                quoteDrafts.remove(chatId);
+            }
+        }
+        try {
+            PreferenceService preferenceService = requireServiceManager().getPreferenceService();
+            preferenceService.setMessageDrafts(messageDrafts);
+            preferenceService.setQuoteDrafts(quoteDrafts);
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    public static String getMessageDraft(String chatId) {
+        if (messageDrafts.containsKey(chatId)) {
+            return messageDrafts.get(chatId);
+        }
+        return null;
+    }
+
+    public static String getQuoteDraft(String chatId) {
+        if (quoteDrafts.containsKey(chatId)) {
+            return quoteDrafts.get(chatId);
+        }
+        return null;
+    }
+
+    private static void retrieveMessageDraftsFromStorage() {
+        try {
+            messageDrafts = getServiceManager().getPreferenceService().getMessageDrafts();
+            quoteDrafts = getServiceManager().getPreferenceService().getQuoteDrafts();
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    @SuppressLint("ApplySharedPref")
+    private static void resetPreferences(SharedPreferences prefs) {
+        // Fix master key preference state if necessary (could be wrong if user kills app
+        // while disabling master key passphrase).
+        if (masterKey.isProtected() && prefs != null && !prefs.getBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), false)) {
+            logger.debug("Master key is protected, but switch preference is disabled - fixing");
+            prefs.edit().putBoolean(getAppContext().getString(R.string.preferences__masterkey_switch), true).commit();
+        }
+
+        // If device is in AEC exclusion list and the user did not choose a preference yet,
+        // update the shared preference.
+        if (prefs != null && prefs.getString(getAppContext().getString(R.string.preferences__voip_echocancel), "none").equals("none")) {
+            // Determine whether device is excluded from hardware AEC
+            final String modelInfo = Build.MANUFACTURER + ";" + Build.MODEL;
+            boolean exclude = !Config.allowHardwareAec();
+
+            // Set default preference
+            final SharedPreferences.Editor editor = prefs.edit();
+            if (exclude) {
+                logger.debug("Device {} is on AEC exclusion list, switching to software echo cancellation", modelInfo);
+                editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "sw");
+            } else {
+                logger.debug("Device {} is not on AEC exclusion list", modelInfo);
+                editor.putString(getAppContext().getString(R.string.preferences__voip_echocancel), "hw");
+            }
+            editor.commit();
+        }
+
+        try {
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_chat, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_privacy, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_appearance, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_notifications, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_media, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_calls, true);
+            PreferenceManager.setDefaultValues(getAppContext(), R.xml.preference_advanced_options, true);
+        } catch (Exception e) {
+            logger.error("Exception", e);
+        }
+
+        setupDayNightMode();
+    }
+
+    /**
+     * Setup day / night theme for application depending on preferences
+     */
+    private static void setupDayNightMode() {
+        AppCompatDelegate.setDefaultNightMode(ConfigUtils.getAppThemePrefs());
+    }
+
+    private static void setupLogging(PreferenceStore preferenceStore) {
+        // check if a THREEMA_MESSAGE_LOG exist on the
+        final File forceMessageLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_MESSAGE_LOG");
+        final File forceDebugLog = new File(Environment.getExternalStorageDirectory() + "/ENABLE_THREEMA_DEBUG_LOG");
+
+        // enable message logging if necessary
+        if (preferenceStore == null || preferenceStore.getBoolean(getAppContext().getString(R.string.preferences__message_log_switch))
+            || forceMessageLog.exists() || forceDebugLog.exists()) {
+            DebugLogFileBackend.setEnabled(true);
+        } else {
+            DebugLogFileBackend.setEnabled(false);
+        }
+
+        // temporary - testing native crash in CompletableFuture while loading emojis
+        if (preferenceStore != null) {
+            final File forceAndroidEmojis = new File(Environment.getExternalStorageDirectory() + "/FORCE_SYSTEM_EMOJIS");
+            if (forceAndroidEmojis.exists()) {
+                preferenceStore.save(getAppContext().getString(R.string.preferences__emoji_style), "1");
+            }
+        }
+    }
 
-		// temporary - testing native crash in CompletableFuture while loading emojis
-		if (preferenceStore != null) {
-			final File forceAndroidEmojis = new File(Environment.getExternalStorageDirectory() + "/FORCE_SYSTEM_EMOJIS");
-			if (forceAndroidEmojis.exists()) {
-				preferenceStore.save(getAppContext().getString(R.string.preferences__emoji_style), "1");
-			}
-		}
-	}
+    public static synchronized void reset() {
 
-	public static synchronized void reset() {
+        //set default preferences
+        SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getAppContext());
+        resetPreferences(sharedPreferences);
 
-		//set default preferences
-		SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getAppContext());
-		resetPreferences(sharedPreferences);
+        // init state bitmap cache singleton
+        StateBitmapUtil.init(getAppContext());
 
-		// init state bitmap cache singleton
-		StateBitmapUtil.init(getAppContext());
+        // init connection state colors
+        ConnectionIndicatorUtil.init(getAppContext());
 
-		// init connection state colors
-		ConnectionIndicatorUtil.init(getAppContext());
+        try {
+            // Load preference store
+            PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
 
-		try {
-			// Load preference store
-			PreferenceStore preferenceStore = new PreferenceStore(getAppContext(), masterKey);
+            // Set logging to "always on"
+            setupLogging(null);
 
-			// Set logging to "always on"
-			setupLogging(null);
+            // Make database key from master key
+            String databaseKey = "x\"" + Utils.byteArrayToHexString(masterKey.getKey()) + "\"";
 
-			// Make database key from master key
-			String databaseKey = "x\"" + Utils.byteArrayToHexString(masterKey.getKey()) + "\"";
+            UpdateSystemService updateSystemService = new UpdateSystemServiceImpl();
 
-			UpdateSystemService updateSystemService = new UpdateSystemServiceImpl();
+            // Instantiate database service
+            System.loadLibrary("sqlcipher");
+            DatabaseServiceNew databaseServiceNew = new DatabaseServiceNew(getAppContext(), databaseKey, updateSystemService);
+            databaseServiceNew.executeNull();
 
-			// Instantiate database service
-			System.loadLibrary("sqlcipher");
-			DatabaseServiceNew databaseServiceNew = new DatabaseServiceNew(getAppContext(), databaseKey, updateSystemService);
-			databaseServiceNew.executeNull();
+            // We create the DH session store here and execute a null operation on it to prevent
+            // the app from being launched when the database is downgraded.
+            DHSessionStoreInterface dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
+            try {
+                dhSessionStore.executeNull();
+            } catch (Exception e) {
+                logger.error("Could not execute a statement on the database", e);
+                // The database file seems to be corrupt, therefore we delete the file
+                File databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
+                if (databaseFile.exists()) {
+                    FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
+                }
+                dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
+            }
 
-			// We create the DH session store here and execute a null operation on it to prevent
-			// the app from being launched when the database is downgraded.
-			DHSessionStoreInterface dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
-			try {
-				dhSessionStore.executeNull();
-			} catch (Exception e) {
-				logger.error("Could not execute a statement on the database", e);
-				// The database file seems to be corrupt, therefore we delete the file
-				File databaseFile = getAppContext().getDatabasePath(SQLDHSessionStore.DATABASE_NAME);
-				if (databaseFile.exists()) {
-					FileUtil.deleteFileOrWarn(databaseFile, "sql dh session database", logger);
-				}
-				dhSessionStore = new SQLDHSessionStore(context, masterKey.getKey(), updateSystemService);
-			}
+			IdentityStore identityStore = new IdentityStore(preferenceStore);
 
 			// Instantiate core service manager. Note that the task manager should only be used to
 			// schedule tasks once the service manager is set.
-			final CoreServiceManager coreServiceManager = new CoreServiceManagerImpl(
+			final CoreServiceManagerImpl coreServiceManager = new CoreServiceManagerImpl(
 				appVersion,
 				databaseServiceNew,
-				preferenceStore
+				preferenceStore,
+				identityStore,
+					() -> {
+						DatabaseNonceStore databaseNonceStore = new DatabaseNonceStore(getAppContext(), identityStore);
+						databaseNonceStore.executeNull();
+						logger.info("Nonce count (csp): {}", databaseNonceStore.getCount(NonceScope.CSP));
+						logger.info("Nonce count (d2d): {}", databaseNonceStore.getCount(NonceScope.D2D));
+						return databaseNonceStore;
+					}
 			);
 
 			// Instantiate model repositories
-			final ModelRepositories modelRepositories = new ModelRepositories(databaseServiceNew);
+			final ModelRepositories modelRepositories = new ModelRepositories(coreServiceManager);
 
-			logger.info("*** App launched");
-			logVersion();
+            logger.info("*** App launched");
+            logVersion();
 
-			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
-				ActivityManager activityManager = (ActivityManager) getAppContext().getSystemService(Context.ACTIVITY_SERVICE);
-				try {
-					List<ApplicationExitInfo> applicationExitInfos = activityManager.getHistoricalProcessExitReasons(null, 0, 0);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
+                ActivityManager activityManager = (ActivityManager) getAppContext().getSystemService(Context.ACTIVITY_SERVICE);
+                try {
+                    List<ApplicationExitInfo> applicationExitInfos = activityManager.getHistoricalProcessExitReasons(null, 0, 0);
 
-					if (applicationExitInfos.size() > 0) {
-						for (ApplicationExitInfo exitInfo : applicationExitInfos) {
-							long timestampOfLastLog = 0L;
-							if (sharedPreferences != null) {
-								timestampOfLastLog = sharedPreferences.getLong(EXIT_REASON_LOGGING_TIMESTAMP, timestampOfLastLog);
-							}
+                    if (applicationExitInfos.size() > 0) {
+                        for (ApplicationExitInfo exitInfo : applicationExitInfos) {
+                            long timestampOfLastLog = 0L;
+                            if (sharedPreferences != null) {
+                                timestampOfLastLog = sharedPreferences.getLong(EXIT_REASON_LOGGING_TIMESTAMP, timestampOfLastLog);
+                            }
 
-							if (exitInfo.getTimestamp() > timestampOfLastLog) {
-								SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm:ss.SSS", Locale.US);
+                            if (exitInfo.getTimestamp() > timestampOfLastLog) {
+                                SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM-dd HH:mm:ss.SSS", Locale.US);
                                 logger.info(
                                     "*** App last exited at {} with reason: {}, description: {}, status: {}",
                                     simpleDateFormat.format(exitInfo.getTimestamp()),
@@ -895,44 +903,41 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
                                     exitInfo.getDescription(),
                                     ApplicationExitInfoUtil.getStatusText(exitInfo)
                                 );
-								if (exitInfo.getReason() == ApplicationExitInfo.REASON_ANR) {
-									try {
-										InputStream traceInputStream = exitInfo.getTraceInputStream();
-										if (traceInputStream != null) {
-											BufferedReader r = new BufferedReader(new InputStreamReader(traceInputStream));
-											StringBuilder s = new StringBuilder();
-											for (String line; (line = r.readLine()) != null; ) {
-												s.append(line).append('\n');
-											}
-											logger.info(s.toString());
-										}
-									} catch (IOException e) {
-										logger.error("Error getting ANR trace", e);
-									}
-								}
-							}
-						}
-
-						if (sharedPreferences != null) {
-							sharedPreferences.edit().putLong(EXIT_REASON_LOGGING_TIMESTAMP, System.currentTimeMillis()).apply();
-						}
-					}
-				} catch (IllegalArgumentException e) {
-					logger.error("Unable to get reason of last exit", e);
-				}
-			}
+                                if (exitInfo.getReason() == ApplicationExitInfo.REASON_ANR) {
+                                    try {
+                                        InputStream traceInputStream = exitInfo.getTraceInputStream();
+                                        if (traceInputStream != null) {
+                                            BufferedReader r = new BufferedReader(new InputStreamReader(traceInputStream));
+                                            StringBuilder s = new StringBuilder();
+                                            for (String line; (line = r.readLine()) != null; ) {
+                                                s.append(line).append('\n');
+                                            }
+                                            logger.info(s.toString());
+                                        }
+                                    } catch (IOException e) {
+                                        logger.error("Error getting ANR trace", e);
+                                    }
+                                }
+                            }
+                        }
 
-			// Set up logging
-			setupLogging(preferenceStore);
+                        if (sharedPreferences != null) {
+                            sharedPreferences.edit().putLong(EXIT_REASON_LOGGING_TIMESTAMP, System.currentTimeMillis()).apply();
+                        }
+                    }
+                } catch (IllegalArgumentException e) {
+                    logger.error("Unable to get reason of last exit", e);
+                }
+            }
 
-			IdentityStore identityStore = new IdentityStore(preferenceStore);
+            // Set up logging
+            setupLogging(preferenceStore);
 
 			try {
 				// Instantiate service manager
 				serviceManager = new ServiceManager(
 					modelRepositories,
 					dhSessionStore,
-					identityStore,
 					masterKey,
 					coreServiceManager,
 					updateSystemService
@@ -942,97 +947,97 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 				return;
 			}
 
-			serviceManager.getTaskManager().schedule(new MessageQueueMigrationTask(
-					context,
-					identityStore.getIdentity(),
-					serviceManager.getMessageService(),
-					serviceManager.getGroupService(),
-					serviceManager.getDatabaseServiceNew().getMessageModelFactory(),
-					serviceManager.getDatabaseServiceNew().getGroupMessageModelFactory()
-				)
-			);
-
-			ServerConnection connection = serviceManager.getConnection();
-
-			// Whenever the connection is established, check whether the
-			// push token needs to be updated.
-			connection.addConnectionStateListener((newConnectionState) -> {
-				if (newConnectionState == ConnectionState.LOGGEDIN) {
-					final Context appContext = getAppContext();
-					if (PushService.servicesInstalled(appContext)) {
-						if (PushUtil.isPushEnabled(appContext)) {
-							if (PushUtil.pushTokenNeedsRefresh(appContext)) {
-								PushUtil.enqueuePushTokenUpdate(appContext, false, false);
-							} else {
-								logger.debug("Push token is still fresh. No update needed");
-							}
-						}
-					}
-				}
-			});
+            serviceManager.getTaskManager().schedule(new MessageQueueMigrationTask(
+                    context,
+                    identityStore.getIdentity(),
+                    serviceManager.getMessageService(),
+                    serviceManager.getGroupService(),
+                    serviceManager.getDatabaseServiceNew().getMessageModelFactory(),
+                    serviceManager.getDatabaseServiceNew().getGroupMessageModelFactory()
+                )
+            );
+
+            ServerConnection connection = serviceManager.getConnection();
+
+            // Whenever the connection is established, check whether the
+            // push token needs to be updated.
+            connection.addConnectionStateListener((newConnectionState) -> {
+                if (newConnectionState == ConnectionState.LOGGEDIN) {
+                    final Context appContext = getAppContext();
+                    if (PushService.servicesInstalled(appContext)) {
+                        if (PushUtil.isPushEnabled(appContext)) {
+                            if (PushUtil.pushTokenNeedsRefresh(appContext)) {
+                                PushUtil.enqueuePushTokenUpdate(appContext, false, false);
+                            } else {
+                                logger.debug("Push token is still fresh. No update needed");
+                            }
+                        }
+                    }
+                }
+            });
 
-			// get application restrictions
-			if (ConfigUtils.isWorkBuild()) {
-				AppRestrictionService.getInstance()
-					.reload();
-			}
+            // get application restrictions
+            if (ConfigUtils.isWorkBuild()) {
+                AppRestrictionService.getInstance()
+                    .reload();
+            }
 
-			connection.addConnectionStateListener(connectionState -> {
-				logger.info("ServerConnection state changed: {}", connectionState);
+            connection.addConnectionStateListener(connectionState -> {
+                logger.info("ServerConnection state changed: {}", connectionState);
 
-				if (connectionState == ConnectionState.LOGGEDIN) {
-					lastLoggedIn = new Date();
-				}
-			});
+                if (connectionState == ConnectionState.LOGGEDIN) {
+                    lastLoggedIn = new Date();
+                }
+            });
 
-			/* cancel any "new message" notification */
-			NotificationManagerCompat.from(getAppContext()).cancel(NEW_MESSAGE_LOCKED_NOTIFICATION_ID);
+            /* cancel any "new message" notification */
+            NotificationManagerCompat.from(getAppContext()).cancel(NEW_MESSAGE_LOCKED_NOTIFICATION_ID);
 
 			/* trigger a connection now, just to be sure we're up-to-date and any broken connection
 			   (e.g. from before a reboot) is preempted.
 			 */
-			serviceManager.getLifetimeService().acquireConnection("resetConnection");
-			serviceManager.getLifetimeService().releaseConnectionLinger("resetConnection", ACTIVITY_CONNECTION_LIFETIME);
-			configureListeners();
+            serviceManager.getLifetimeService().acquireConnection("resetConnection");
+            serviceManager.getLifetimeService().releaseConnectionLinger("resetConnection", ACTIVITY_CONNECTION_LIFETIME);
+            configureListeners();
 
-			// Mark all file messages with state 'uploading' as failed. This is because the file
-			// upload is not continued after app restarts. When the state has been changed to
-			// failed, a resend button is displayed on the message. We only need to do this in the
-			// uploading state as in sending state a persistent task is already scheduled and the
-			// message will be sent when a connection is available.
-			databaseServiceNew
-					.getMessageModelFactory()
-					.markUnscheduledFileMessagesAsFailed();
+            // Mark all file messages with state 'uploading' as failed. This is because the file
+            // upload is not continued after app restarts. When the state has been changed to
+            // failed, a resend button is displayed on the message. We only need to do this in the
+            // uploading state as in sending state a persistent task is already scheduled and the
+            // message will be sent when a connection is available.
+            databaseServiceNew
+                .getMessageModelFactory()
+                .markUnscheduledFileMessagesAsFailed();
 
-			databaseServiceNew
-					.getGroupMessageModelFactory()
-					.markUnscheduledFileMessagesAsFailed();
+            databaseServiceNew
+                .getGroupMessageModelFactory()
+                .markUnscheduledFileMessagesAsFailed();
 
-			databaseServiceNew
-					.getDistributionListMessageModelFactory()
-					.markUnscheduledFileMessagesAsFailed();
+            databaseServiceNew
+                .getDistributionListMessageModelFactory()
+                .markUnscheduledFileMessagesAsFailed();
 
-			retrieveMessageDraftsFromStorage();
+            retrieveMessageDraftsFromStorage();
 
-			// process webclient wakeups
-			SessionWakeUpServiceImpl.getInstance().processPendingWakeupsAsync();
+            // process webclient wakeups
+            SessionWakeUpServiceImpl.getInstance().processPendingWakeupsAsync();
 
-			// start threema safe scheduler
-			serviceManager.getThreemaSafeService().schedulePeriodicUpload();
+            // start threema safe scheduler
+            serviceManager.getThreemaSafeService().schedulePeriodicUpload();
+
+			PreferenceService preferenceService = serviceManager.getPreferenceService();
 
 			new Thread(() -> {
 				// schedule work synchronization
-				scheduleWorkSync(preferenceStore);
+				WorkSyncWorker.Companion.schedulePeriodicWorkSync(getAppContext(), preferenceService);
 				// schedule identity states / feature masks etc.
-				scheduleContactUpdateSync(preferenceStore);
+				ContactUpdateWorker.schedulePeriodicSync(getAppContext(), preferenceService);
 				// schedule shortcut update
 				if (preferenceStore.getBoolean(getAppContext().getString(R.string.preferences__direct_share))) {
 					scheduleShareTargetShortcutUpdate();
 				}
 				// schedule auto delete
-				if (!AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext())) {
-					AutoDeleteWorker.Companion.cancelAutoDelete(getAppContext());
-				}
+				AutoDeleteWorker.Companion.scheduleAutoDelete(getAppContext());
 			}, "scheduleSync").start();
 		} catch (MasterKeyLockedException | SQLiteException e) {
 			logger.error("Exception opening database", e);
@@ -1042,408 +1047,334 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 		}
 	}
 
-	public static void logVersion() {
-		String commitHash = BuildConfig.DEBUG
-			? ", Commit: " + BuildConfig.GIT_HASH
-			: "";
-		logger.info(
-			"*** App Version. Device/Android Version/Flavor: {} Version: {} Build: {}{}",
-			ConfigUtils.getDeviceInfo(false),
-			BuildConfig.VERSION_NAME,
-			ConfigUtils.getBuildNumber(getAppContext()),
-			commitHash
-		);
-	}
-
-	private static long getSchedulePeriodMs(PreferenceStore preferenceStore, int key) {
-		Integer schedulePeriod = preferenceStore.getInt(getAppContext().getString(key));
-		if (schedulePeriod == null || schedulePeriod == 0) {
-			schedulePeriod = (int) DateUtils.DAY_IN_MILLIS;
-		} else {
-			schedulePeriod *= (int) DateUtils.SECOND_IN_MILLIS;
-		}
-		return (long) schedulePeriod;
-	}
-
-	@WorkerThread
-	private static boolean scheduleContactUpdateSync(PreferenceStore preferenceStore) {
-		long schedulePeriod = getSchedulePeriodMs(preferenceStore, R.string.preferences__identity_states_check_interval);
-
-		logger.info("Initializing contact update sync. Requested schedule period: {} ms", schedulePeriod);
-
-		try {
-			WorkManager workManager = WorkManager.getInstance(context);
-
-			if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(
-				workManager,
-				WORKER_CONTACT_UPDATE_PERIODIC_NAME,
-				schedulePeriod
-			)) {
-				logger.debug("Scheduling new job");
-
-				// Cancel the work with the old name as the IdentityStatesWorker class does not
-				// exist anymore.
-				workManager.cancelUniqueWork(WORKER_IDENTITY_STATES_PERIODIC_NAME);
-
-				// schedule the start of the service according to schedule period
-				Constraints constraints = new Constraints.Builder()
-					.setRequiredNetworkType(NetworkType.CONNECTED)
-					.build();
-
-				PeriodicWorkRequest workRequest = new PeriodicWorkRequest.Builder(ContactUpdateWorker.class, schedulePeriod, TimeUnit.MILLISECONDS)
-					.setConstraints(constraints)
-					.addTag(String.valueOf(schedulePeriod))
-					.setInitialDelay(1000, TimeUnit.MILLISECONDS)
-					.build();
-
-				workManager.enqueueUniquePeriodicWork(WORKER_CONTACT_UPDATE_PERIODIC_NAME, ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE, workRequest);
-				return true;
-			}
-		} catch (IllegalStateException e) {
-			logger.error("Unable to initialize WorkManager", e);
-		}
-		return false;
-	}
-
-	private static boolean scheduleWorkSync(PreferenceStore preferenceStore) {
-		if (!ConfigUtils.isWorkBuild()) {
-			return false;
-		}
-
-		long schedulePeriodMs = getSchedulePeriodMs(preferenceStore, R.string.preferences__work_sync_check_interval);
-		logger.info("Scheduling periodic work sync. Schedule period: {}", schedulePeriodMs);
-
-		try {
-			WorkManager workManager = WorkManager.getInstance(context);
-			ExistingPeriodicWorkPolicy policy = WorkManagerUtil.shouldScheduleNewWorkManagerInstance(workManager, WORKER_PERIODIC_WORK_SYNC, schedulePeriodMs) ?
-				ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE :
-				ExistingPeriodicWorkPolicy.KEEP;
-			logger.info("{}: {} existing periodic work", WORKER_PERIODIC_WORK_SYNC, policy);
-			PeriodicWorkRequest workRequest = WorkSyncWorker.Companion.buildPeriodicWorkRequest(schedulePeriodMs);
-			workManager.enqueueUniquePeriodicWork(WORKER_PERIODIC_WORK_SYNC, policy, workRequest);
-		} catch (IllegalStateException e) {
-			logger.error("Unable to schedule periodic work sync work", e);
-			return false;
-		}
-
-		return true;
-	}
+    public static void logVersion() {
+        String commitHash = BuildConfig.DEBUG
+            ? ", Commit: " + BuildConfig.GIT_HASH
+            : "";
+        logger.info(
+            "*** App Version. Device/Android Version/Flavor: {} Version: {} Build: {}{}",
+            ConfigUtils.getDeviceInfo(false),
+            BuildConfig.VERSION_NAME,
+            ConfigUtils.getBuildNumber(getAppContext()),
+            commitHash
+        );
+    }
 
 	@WorkerThread
 	public static boolean scheduleShareTargetShortcutUpdate() {
 		logger.info("Scheduling share target shortcut update work");
 
-		long schedulePeriod = DateUtils.MINUTE_IN_MILLIS * 15;
+        long schedulePeriod = DateUtils.MINUTE_IN_MILLIS * 15;
 
-		try {
-			WorkManager workManager = WorkManager.getInstance(context);
+        try {
+            WorkManager workManager = WorkManager.getInstance(context);
 
-			if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(
-				workManager,
-				WORKER_SHARE_TARGET_UPDATE,
-				schedulePeriod
-			)) {
-				logger.debug("Create new worker");
+            if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(
+                workManager,
+                WORKER_SHARE_TARGET_UPDATE,
+                schedulePeriod
+            )) {
+                logger.debug("Create new worker");
 
-				// schedule the start of the service according to schedule period
-				Constraints constraints = new Constraints.Builder()
-					.setRequiredNetworkType(NetworkType.CONNECTED)
-					.build();
+                // schedule the start of the service according to schedule period
+                Constraints constraints = new Constraints.Builder()
+                    .setRequiredNetworkType(NetworkType.CONNECTED)
+                    .build();
 
-				PeriodicWorkRequest workRequest = new PeriodicWorkRequest.Builder(ShareTargetUpdateWorker.class, schedulePeriod, TimeUnit.MILLISECONDS)
-					.setConstraints(constraints)
-					.addTag(String.valueOf(schedulePeriod))
-					.setInitialDelay(3, TimeUnit.MINUTES)
-					.build();
+                PeriodicWorkRequest workRequest = new PeriodicWorkRequest.Builder(ShareTargetUpdateWorker.class, schedulePeriod, TimeUnit.MILLISECONDS)
+                    .setConstraints(constraints)
+                    .addTag(String.valueOf(schedulePeriod))
+                    .setInitialDelay(3, TimeUnit.MINUTES)
+                    .build();
 
-				workManager.enqueueUniquePeriodicWork(WORKER_SHARE_TARGET_UPDATE, ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE, workRequest);
-			} else {
-				logger.debug("Reusing existing worker");
-			}
-		} catch (IllegalStateException e) {
-			logger.error("Unable to schedule share target update work", e);
-			return false;
-		}
+                workManager.enqueueUniquePeriodicWork(WORKER_SHARE_TARGET_UPDATE, ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE, workRequest);
+            } else {
+                logger.debug("Reusing existing worker");
+            }
+        } catch (IllegalStateException e) {
+            logger.error("Unable to schedule share target update work", e);
+            return false;
+        }
 
-		return true;
-	}
+        return true;
+    }
 
-	private static void showConversationNotification(AbstractMessageModel newMessage, boolean updateExisting) {
-		try {
+    private static void showConversationNotification(AbstractMessageModel newMessage, boolean updateExisting) {
+        try {
             if (!newMessage.isOutbox()
                 && !newMessage.isStatusMessage()
                 && !newMessage.isRead()) {
 
-				NotificationService notificationService = serviceManager.getNotificationService();
-				ContactService contactService = serviceManager.getContactService();
-				GroupService groupService = serviceManager.getGroupService();
-				DeadlineListService hiddenChatsListService = serviceManager.getHiddenChatsListService();
-
-				if (TestUtil.required(notificationService, contactService, groupService)) {
-					if (newMessage.getType() != MessageType.GROUP_CALL_STATUS) {
-						notificationService.showConversationNotification(ConversationNotificationUtil.convert(
-								getAppContext(),
-								newMessage,
-								contactService,
-								groupService,
-								hiddenChatsListService),
-							updateExisting);
-					}
+                NotificationService notificationService = serviceManager.getNotificationService();
+                ContactService contactService = serviceManager.getContactService();
+                GroupService groupService = serviceManager.getGroupService();
+                DeadlineListService hiddenChatsListService = serviceManager.getHiddenChatsListService();
+
+                if (TestUtil.required(notificationService, contactService, groupService)) {
+                    if (newMessage.getType() != MessageType.GROUP_CALL_STATUS) {
+                        notificationService.showConversationNotification(ConversationNotificationUtil.convert(
+                                getAppContext(),
+                                newMessage,
+                                contactService,
+                                groupService,
+                                hiddenChatsListService),
+                            updateExisting);
+                    }
 
-					// update widget on incoming message
-					WidgetUtil.updateWidgets(serviceManager.getContext());
-				}
-			}
-		} catch (ThreemaException e) {
-			logger.error("Exception", e);
-		}
-	}
+                    // update widget on incoming message
+                    WidgetUtil.updateWidgets(serviceManager.getContext());
+                }
+            }
+        } catch (ThreemaException e) {
+            logger.error("Exception", e);
+        }
+    }
+
+    private static void configureListeners() {
+        ListenerManager.groupListeners.add(new GroupListener() {
+            @Override
+            public void onCreate(GroupModel newGroupModel) {
+                try {
+                    serviceManager.getConversationService().refresh(newGroupModel);
+                    serviceManager.getMessageService().createGroupStatus(
+                        serviceManager.getGroupService().createReceiver(newGroupModel),
+                        GroupStatusDataModel.GroupStatusType.CREATED,
+                        null,
+                        null,
+                        null
+                    );
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-	private static void configureListeners() {
-		ListenerManager.groupListeners.add(new GroupListener() {
-			@Override
-			public void onCreate(GroupModel newGroupModel) {
-				try {
-					serviceManager.getConversationService().refresh(newGroupModel);
-					serviceManager.getMessageService().createGroupStatus(
-						serviceManager.getGroupService().createReceiver(newGroupModel),
-						GroupStatusDataModel.GroupStatusType.CREATED,
-						null,
-						null,
-						null
-					);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
-
-			@Override
-			public void onRename(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
-						serviceManager.getConversationService().refresh(groupModel);
-						String groupName = groupModel.getName();
-						if (groupName == null) {
-							groupName = "";
-						}
-						serviceManager.getMessageService().createGroupStatus(
-							messageReceiver,
-							GroupStatusDataModel.GroupStatusType.RENAMED,
-							null,
-							null,
-							groupName
-						);
-						ShortcutUtil.updatePinnedShortcut(messageReceiver);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onRename(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
+                        serviceManager.getConversationService().refresh(groupModel);
+                        String groupName = groupModel.getName();
+                        if (groupName == null) {
+                            groupName = "";
+                        }
+                        serviceManager.getMessageService().createGroupStatus(
+                            messageReceiver,
+                            GroupStatusDataModel.GroupStatusType.RENAMED,
+                            null,
+                            null,
+                            groupName
+                        );
+                        ShortcutUtil.updatePinnedShortcut(messageReceiver);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
-			@Override
-			public void onUpdatePhoto(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
-						serviceManager.getConversationService().refresh(groupModel);
-						serviceManager.getMessageService().createGroupStatus(
-							messageReceiver,
-							GroupStatusDataModel.GroupStatusType.PROFILE_PICTURE_UPDATED,
-							null,
-							null,
-							null
-						);
-						ShortcutUtil.updatePinnedShortcut(messageReceiver);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onUpdatePhoto(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        GroupMessageReceiver messageReceiver = serviceManager.getGroupService().createReceiver(groupModel);
+                        serviceManager.getConversationService().refresh(groupModel);
+                        serviceManager.getMessageService().createGroupStatus(
+                            messageReceiver,
+                            GroupStatusDataModel.GroupStatusType.PROFILE_PICTURE_UPDATED,
+                            null,
+                            null,
+                            null
+                        );
+                        ShortcutUtil.updatePinnedShortcut(messageReceiver);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
-			@Override
-			public void onRemove(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						final MessageReceiver receiver = serviceManager.getGroupService().createReceiver(groupModel);
-						serviceManager.getBallotService().remove(receiver);
-						serviceManager.getConversationService().empty(groupModel);
-						serviceManager.getNotificationService().cancel(new GroupMessageReceiver(groupModel, null, null, serviceManager));
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onRemove(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        final MessageReceiver receiver = serviceManager.getGroupService().createReceiver(groupModel);
+                        serviceManager.getBallotService().remove(receiver);
+                        serviceManager.getConversationService().empty(groupModel);
+                        serviceManager.getNotificationService().cancel(new GroupMessageReceiver(groupModel, null, null, serviceManager));
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
 			@Override
-			public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+			public void onNewMember(GroupModel group, String newIdentity) {
 				try {
 					final GroupMessageReceiver receiver = serviceManager.getGroupService().createReceiver(group);
 					final String myIdentity = serviceManager.getUserService().getIdentity();
 
-					if (!TestUtil.isEmptyOrNull(myIdentity)) {
-						serviceManager.getMessageService().createGroupStatus(
-							receiver,
-							GroupStatusDataModel.GroupStatusType.MEMBER_ADDED,
-							newIdentity,
-							null,
-							null
-						);
-					}
-				} catch (ThreemaException x) {
-					logger.error("Could not create group state after new member was added", x);
-				}
+                    if (!TestUtil.isEmptyOrNull(myIdentity)) {
+                        serviceManager.getMessageService().createGroupStatus(
+                            receiver,
+                            GroupStatusDataModel.GroupStatusType.MEMBER_ADDED,
+                            newIdentity,
+                            null,
+                            null
+                        );
+                    }
+                } catch (ThreemaException x) {
+                    logger.error("Could not create group state after new member was added", x);
+                }
 
-				//reset avatar to recreate it!
-				try {
-					serviceManager.getAvatarCacheService()
-							.reset(group);
-				} catch (FileSystemNotPresentException e) {
-					logger.error("Could not reset avatar cache", e);
-				}
-			}
+                //reset avatar to recreate it!
+                try {
+                    serviceManager.getAvatarCacheService()
+                        .reset(group);
+                } catch (FileSystemNotPresentException e) {
+                    logger.error("Could not reset avatar cache", e);
+                }
+            }
 
 			@Override
-			public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+			public void onMemberLeave(GroupModel group, String identity) {
 				try {
 					GroupService groupService = serviceManager.getGroupService();
 					final GroupMessageReceiver receiver = groupService.createReceiver(group);
 
-					serviceManager.getMessageService().createGroupStatus(
-						receiver,
-						GroupStatusDataModel.GroupStatusType.MEMBER_LEFT,
-						identity,
-						null,
-						null
-					);
-
-					BallotService ballotService = serviceManager.getBallotService();
-					ballotService.removeVotes(receiver, identity);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+                    serviceManager.getMessageService().createGroupStatus(
+                        receiver,
+                        GroupStatusDataModel.GroupStatusType.MEMBER_LEFT,
+                        identity,
+                        null,
+                        null
+                    );
+
+                    BallotService ballotService = serviceManager.getBallotService();
+                    ballotService.removeVotes(receiver, identity);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
 			@Override
-			public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+			public void onMemberKicked(GroupModel group, String identity) {
 				final String myIdentity = serviceManager.getUserService().getIdentity();
 
-				if (myIdentity != null && myIdentity.equals(identity)) {
-					// my own member status has changed
-					try {
-						serviceManager.getNotificationService().cancelGroupCallNotification(group.getId());
-						serviceManager.getConversationService().refresh(group);
-					} catch (Exception e) {
-						logger.error("Exception", e);
-					}
-				}
-				try {
-					final GroupMessageReceiver receiver = serviceManager.getGroupService().createReceiver(group);
-
-					serviceManager.getMessageService().createGroupStatus(
-						receiver,
-						GroupStatusDataModel.GroupStatusType.MEMBER_KICKED,
-						identity,
-						null,
-						null
-					);
-
-					BallotService ballotService = serviceManager.getBallotService();
-					ballotService.removeVotes(receiver, identity);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+                if (myIdentity != null && myIdentity.equals(identity)) {
+                    // my own member status has changed
+                    try {
+                        serviceManager.getNotificationService().cancelGroupCallNotification(group.getId());
+                        serviceManager.getConversationService().refresh(group);
+                    } catch (Exception e) {
+                        logger.error("Exception", e);
+                    }
+                }
+                try {
+                    final GroupMessageReceiver receiver = serviceManager.getGroupService().createReceiver(group);
+
+                    serviceManager.getMessageService().createGroupStatus(
+                        receiver,
+                        GroupStatusDataModel.GroupStatusType.MEMBER_KICKED,
+                        identity,
+                        null,
+                        null
+                    );
+
+                    BallotService ballotService = serviceManager.getBallotService();
+                    ballotService.removeVotes(receiver, identity);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-			@Override
-			public void onUpdate(GroupModel groupModel) {
-				try {
-					serviceManager.getConversationService().refresh(groupModel);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+            @Override
+            public void onUpdate(GroupModel groupModel) {
+                try {
+                    serviceManager.getConversationService().refresh(groupModel);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-			@Override
-			public void onLeave(GroupModel groupModel) {
-				new Thread(() -> {
-					try {
-						serviceManager.getConversationService().refresh(groupModel);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onLeave(GroupModel groupModel) {
+                new Thread(() -> {
+                    try {
+                        serviceManager.getConversationService().refresh(groupModel);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
-			@Override
-			public void onGroupStateChanged(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
-				logger.debug("onGroupStateChanged: {} -> {}", oldState, newState);
+            @Override
+            public void onGroupStateChanged(GroupModel groupModel, @GroupService.GroupState int oldState, @GroupService.GroupState int newState) {
+                logger.debug("onGroupStateChanged: {} -> {}", oldState, newState);
 
-				showNotesGroupNotice(groupModel, oldState, newState);
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+                showNotesGroupNotice(groupModel, oldState, newState);
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.distributionListListeners.add(new DistributionListListener() {
-			@Override
-			public void onCreate(DistributionListModel distributionListModel) {
-				try {
-					serviceManager.getConversationService().refresh(distributionListModel);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
+        ListenerManager.distributionListListeners.add(new DistributionListListener() {
+            @Override
+            public void onCreate(DistributionListModel distributionListModel) {
+                try {
+                    serviceManager.getConversationService().refresh(distributionListModel);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
 
-			@Override
-			public void onModify(DistributionListModel distributionListModel) {
-				new Thread(() -> {
-					try {
-						serviceManager.getConversationService().refresh(distributionListModel);
-						ShortcutUtil.updatePinnedShortcut(serviceManager.getDistributionListService().createReceiver(distributionListModel));
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+            @Override
+            public void onModify(DistributionListModel distributionListModel) {
+                new Thread(() -> {
+                    try {
+                        serviceManager.getConversationService().refresh(distributionListModel);
+                        ShortcutUtil.updatePinnedShortcut(serviceManager.getDistributionListService().createReceiver(distributionListModel));
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
 
-			@Override
-			public void onRemove(DistributionListModel distributionListModel) {
-				new Thread(() -> {
-					try {
-						serviceManager.getConversationService().empty(distributionListModel);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onRemove(DistributionListModel distributionListModel) {
+                new Thread(() -> {
+                    try {
+                        serviceManager.getConversationService().empty(distributionListModel);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.messageListeners.add(new MessageListener() {
-			@Override
-			public void onNew(AbstractMessageModel newMessage) {
-				logger.debug("MessageListener.onNewMessage");
+        ListenerManager.messageListeners.add(new MessageListener() {
+            @Override
+            public void onNew(AbstractMessageModel newMessage) {
+                logger.debug("MessageListener.onNewMessage");
                 ConversationService conversationService;
                 try {
-                     conversationService = serviceManager.getConversationService();
+                    conversationService = serviceManager.getConversationService();
                 } catch (ThreemaException e) {
                     logger.error("Could not get conversation service", e);
                     return;
                 }
-				if (!newMessage.isStatusMessage()) {
+                if (!newMessage.isStatusMessage()) {
                     ConversationModel conversationModel = conversationService.refresh(newMessage);
                     if (conversationModel != null) {
                         // Show notification only if there is a conversation
                         showConversationNotification(newMessage, false);
                     }
-				} else if (newMessage.getType() == MessageType.GROUP_CALL_STATUS) {
+                } else if (newMessage.getType() == MessageType.GROUP_CALL_STATUS) {
                     conversationService.refresh(newMessage);
                 }
-			}
+            }
 
-			@Override
-			public void onModified(List<AbstractMessageModel> modifiedMessageModels) {
-				logger.debug("MessageListener.onModified");
-				for (final AbstractMessageModel modifiedMessageModel : modifiedMessageModels) {
+            @Override
+            public void onModified(List<AbstractMessageModel> modifiedMessageModels) {
+                logger.debug("MessageListener.onModified");
+                for (final AbstractMessageModel modifiedMessageModel : modifiedMessageModels) {
                     if (modifiedMessageModel.isStatusMessage()) {
                         continue;
                     }
@@ -1461,47 +1392,47 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
                         logger.error("Exception", e);
                     }
                 }
-			}
+            }
 
-			@Override
-			public void onRemoved(AbstractMessageModel removedMessageModel) {
-				logger.debug("MessageListener.onRemoved");
-				if (!removedMessageModel.isStatusMessage()) {
-					try {
-						serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}
-			}
+            @Override
+            public void onRemoved(AbstractMessageModel removedMessageModel) {
+                logger.debug("MessageListener.onRemoved");
+                if (!removedMessageModel.isStatusMessage()) {
+                    try {
+                        serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }
+            }
 
-			@Override
-			public void onRemoved(List<AbstractMessageModel> removedMessageModels) {
-				logger.debug("MessageListener.onRemoved multi");
-				for (final AbstractMessageModel removedMessageModel : removedMessageModels) {
-					if (!removedMessageModel.isStatusMessage()) {
-						try {
-							serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
-						} catch (ThreemaException e) {
-							logger.error("Exception", e);
-						}
-					}
-				}
-			}
+            @Override
+            public void onRemoved(List<AbstractMessageModel> removedMessageModels) {
+                logger.debug("MessageListener.onRemoved multi");
+                for (final AbstractMessageModel removedMessageModel : removedMessageModels) {
+                    if (!removedMessageModel.isStatusMessage()) {
+                        try {
+                            serviceManager.getConversationService().refreshWithDeletedMessage(removedMessageModel);
+                        } catch (ThreemaException e) {
+                            logger.error("Exception", e);
+                        }
+                    }
+                }
+            }
 
-			@Override
-			public void onProgressChanged(AbstractMessageModel messageModel, int newProgress) {
-				// Ignore
-			}
+            @Override
+            public void onProgressChanged(AbstractMessageModel messageModel, int newProgress) {
+                // Ignore
+            }
 
-			@Override
-			public void onResendDismissed(@NonNull AbstractMessageModel messageModel) {
-				// Ignore
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onResendDismissed(@NonNull AbstractMessageModel messageModel) {
+                // Ignore
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.editMessageListener.add(message -> showConversationNotification(message, true));
-		ListenerManager.messageDeletedForAllListener.add(message -> showConversationNotification(message, true));
+        ListenerManager.editMessageListener.add(message -> showConversationNotification(message, true));
+        ListenerManager.messageDeletedForAllListener.add(message -> showConversationNotification(message, true));
 
         ListenerManager.groupJoinResponseListener.add((outgoingGroupJoinRequestModel, status) ->
             serviceManager.getNotificationService()
@@ -1510,32 +1441,32 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
                 ));
 
 
-		ListenerManager.incomingGroupJoinRequestListener.add(new IncomingGroupJoinRequestListener() {
-			@Override
-			public void onReceived(IncomingGroupJoinRequestModel incomingGroupJoinRequestModel, GroupModel groupModel) {
-				NotificationService notificationService = serviceManager.getNotificationService();
+        ListenerManager.incomingGroupJoinRequestListener.add(new IncomingGroupJoinRequestListener() {
+            @Override
+            public void onReceived(IncomingGroupJoinRequestModel incomingGroupJoinRequestModel, GroupModel groupModel) {
+                NotificationService notificationService = serviceManager.getNotificationService();
                 notificationService.showGroupJoinRequestNotification(incomingGroupJoinRequestModel, groupModel);
             }
 
-			@Override
-			public void onRespond() {
-				// don't bother here
-			}
-		});
+            @Override
+            public void onRespond() {
+                // don't bother here
+            }
+        });
 
-		ListenerManager.serverMessageListeners.add(new ServerMessageListener() {
-			@Override
-			public void onAlert(ServerMessageModel serverMessage) {
-				NotificationService notificationService = serviceManager.getNotificationService();
+        ListenerManager.serverMessageListeners.add(new ServerMessageListener() {
+            @Override
+            public void onAlert(ServerMessageModel serverMessage) {
+                NotificationService notificationService = serviceManager.getNotificationService();
                 notificationService.showServerMessage(serverMessage);
             }
 
-			@Override
-			public void onError(ServerMessageModel serverMessage) {
-				NotificationService notificationService = serviceManager.getNotificationService();
+            @Override
+            public void onError(ServerMessageModel serverMessage) {
+                NotificationService notificationService = serviceManager.getNotificationService();
                 notificationService.showServerMessage(serverMessage);
             }
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
 		ListenerManager.contactListeners.add(new ContactListener() {
 			@Override
@@ -1544,252 +1475,240 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 				if (modifiedContactModel == null) {
 					return;
 				}
-				if (modifiedContactModel.getAcquaintanceLevel() == ContactModel.AcquaintanceLevel.GROUP) {
-					this.onRemoved(modifiedContactModel.getIdentity());
-					return;
-				}
 				new Thread(() -> {
 					try {
 						final ConversationService conversationService = serviceManager.getConversationService();
 						final ContactService contactService = serviceManager.getContactService();
 
-						// Remove contact from cache
-						contactService.removeFromCache(identity);
+                        // Remove contact from cache
+                        contactService.removeFromCache(identity);
 
-						// Refresh conversation cache
-						conversationService.updateContactConversation(modifiedContactModel);
-						conversationService.refresh(modifiedContactModel);
+                        // Refresh conversation cache
+                        conversationService.updateContactConversation(modifiedContactModel);
+                        conversationService.refresh(modifiedContactModel);
 
-						ShortcutUtil.updatePinnedShortcut(contactService.createReceiver(modifiedContactModel));
-					} catch (ThreemaException e) {
-						logger.error("Exception", e);
-					}
-				}).start();
-			}
+                        ShortcutUtil.updatePinnedShortcut(contactService.createReceiver(modifiedContactModel));
+                    } catch (ThreemaException e) {
+                        logger.error("Exception", e);
+                    }
+                }).start();
+            }
 
 			@Override
-			public void onAvatarChanged(ContactModel contactModel) {
+			public void onAvatarChanged(final @NonNull String identity) {
 				new Thread(() -> {
 					try {
-						ShortcutUtil.updatePinnedShortcut(serviceManager.getContactService().createReceiver(contactModel));
+                        ContactService contactService = serviceManager.getContactService();
+                        ContactModel contactModel = contactService.getByIdentity(identity);
+                        if (contactModel != null) {
+                            ShortcutUtil.updatePinnedShortcut(contactService.createReceiver(contactModel));
+                        }
 					} catch (ThreemaException e) {
 						logger.error("Exception", e);
 					}
 				}).start();
 			}
-
-			@Override
-			public void onRemoved(@NonNull final String identity) {
-				new Thread(() -> {
-					try {
-						// Remove stale contact model from contact service cache
-						serviceManager.getContactService().removeFromCache(identity);
-
-						// Empty and delete associated conversation
-						serviceManager.getConversationService().delete(identity);
-
-						// Cancel notifications
-						serviceManager.getNotificationService().cancel(identity);
-
-						// Remove custom avatar (ANDR-353)
-						FileService f = serviceManager.getFileService();
-						f.removeContactAvatar(identity);
-						f.removeContactPhoto(identity);
-					} catch (ThreemaException e) {
-						logger.error("Error while handling removed contact", e);
-					}
-				}).start();
-			}
 		}, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.contactSettingsListeners.add(new ContactSettingsListener() {
-			@Override
-			public void onSortingChanged() {
-				//do nothing!
-			}
+        ListenerManager.contactSettingsListeners.add(new ContactSettingsListener() {
+            @Override
+            public void onSortingChanged() {
+                //do nothing!
+            }
 
-			@Override
-			public void onNameFormatChanged() {
-				//do nothing
-			}
+            @Override
+            public void onNameFormatChanged() {
+                //do nothing
+            }
 
 			@Override
 			public void onAvatarSettingChanged() {
 				//reset the avatar cache!
 				if (serviceManager != null) {
 					try {
-						AvatarCacheService avatarCacheService = null;
-						avatarCacheService = serviceManager.getAvatarCacheService();
-                        avatarCacheService.clear();
-                    } catch (FileSystemNotPresentException e) {
+						AvatarCacheService s = serviceManager.getAvatarCacheService();
+						s.clear();
+					} catch (FileSystemNotPresentException e) {
 						logger.error("Exception", e);
 					}
 				}
 			}
 
-			@Override
-			public void onInactiveContactsSettingChanged() {
+            @Override
+            public void onInactiveContactsSettingChanged() {
 
-			}
+            }
 
-			@Override
-			public void onNotificationSettingChanged(String uid) {
+            @Override
+            public void onNotificationSettingChanged(String uid) {
 
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.conversationListeners.add(new ConversationListener() {
-			@Override
-			public void onNew(ConversationModel conversationModel) {}
+        ListenerManager.conversationListeners.add(new ConversationListener() {
+            @Override
+            public void onNew(ConversationModel conversationModel) {
+            }
 
-			@Override
-			public void onModified(ConversationModel modifiedConversationModel, Integer oldPosition) {}
+            @Override
+            public void onModified(ConversationModel modifiedConversationModel, Integer oldPosition) {
+            }
 
 			@Override
 			public void onRemoved(ConversationModel conversationModel) {
 				//remove notification!
 				NotificationService notificationService = serviceManager.getNotificationService();
-                notificationService.cancel(conversationModel);
-            }
+				notificationService.cancel(conversationModel);
+			}
 
-			@Override
-			public void onModifiedAll() {}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onModifiedAll() {
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.ballotVoteListeners.add(new BallotVoteListener() {
-			@Override
-			public void onSelfVote(BallotModel ballotModel) { }
+        ListenerManager.ballotVoteListeners.add(new BallotVoteListener() {
+            @Override
+            public void onSelfVote(BallotModel ballotModel) {
+            }
 
-			@Override
-			public void onVoteChanged(BallotModel ballotModel, String votingIdentity, boolean isFirstVote) {
-				//add group state
+            @Override
+            public void onVoteChanged(BallotModel ballotModel, String votingIdentity, boolean isFirstVote) {
+                //add group state
 
-				//DISABLED
-				ServiceManager s = ThreemaApplication.getServiceManager();
-				if(s != null) {
-					try {
-						BallotService ballotService = s.getBallotService();
-						ContactService contactService = s.getContactService();
-						GroupService groupService = s.getGroupService();
-						MessageService messageService = s.getMessageService();
-						UserService userService = s.getUserService();
-
-						if(TestUtil.required(ballotModel, contactService, groupService, messageService, userService)
-								//disabled, show status message at every participant
-								/*&& BallotUtil.isMine(ballotModel, userService)*/) {
-							LinkBallotModel b = ballotService.getLinkedBallotModel(ballotModel);
-							if(b != null) {
-								GroupStatusDataModel.GroupStatusType type = null;
-								MessageReceiver<? extends AbstractMessageModel> receiver = null;
-								if (b instanceof GroupBallotModel) {
-									GroupModel groupModel = groupService.getById(((GroupBallotModel) b).getGroupId());
-
-									//its a group ballot,write status
-									receiver = groupService.createReceiver(groupModel);
-									// reset archived status
-									groupService.setIsArchived(groupModel, false);
-
-								} else if (b instanceof IdentityBallotModel) {
-									String identity = ((IdentityBallotModel) b).getIdentity();
-
-									//not implemented
-									receiver = contactService.createReceiver(contactService.getByIdentity(identity));
-									// reset archived status
-									contactService.setIsArchived(identity, false);
-								}
-
-								if (ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE) {
-									// Only show status message for first vote from a voter on private voting
-									if (isFirstVote) {
-										// On private voting, only show default update msg!
-										type = GroupStatusDataModel.GroupStatusType.RECEIVED_VOTE;
-									}
-								} else if (receiver != null) {
-									if (isFirstVote) {
-										type = GroupStatusDataModel.GroupStatusType.FIRST_VOTE;
-									} else {
-										type = GroupStatusDataModel.GroupStatusType.MODIFIED_VOTE;
-									}
-								}
-
-								if (type != null && receiver instanceof GroupMessageReceiver) {
-									messageService.createGroupStatus(
-										(GroupMessageReceiver) receiver,
-										type,
-										votingIdentity,
-										ballotModel.getName(),
-										null
-									);
-								}
-
-								//now check if every participant has voted
-								if (isFirstVote
-									&& ballotService.getPendingParticipants(ballotModel.getId()).isEmpty()
-									&& receiver instanceof GroupMessageReceiver
-								) {
-									messageService.createGroupStatus(
-										(GroupMessageReceiver) receiver,
-										GroupStatusDataModel.GroupStatusType.VOTES_COMPLETE,
-										null,
-										ballotModel.getName(),
-										null
-									);
-								}
-							}
-						}
-					} catch (ThreemaException x) {
-						logger.error("Exception", x);
-					}
-				}
-			}
+                //DISABLED
+                ServiceManager s = ThreemaApplication.getServiceManager();
+                if (s != null) {
+                    try {
+                        BallotService ballotService = s.getBallotService();
+                        ContactService contactService = s.getContactService();
+                        GroupService groupService = s.getGroupService();
+                        MessageService messageService = s.getMessageService();
+                        UserService userService = s.getUserService();
+
+                        if (TestUtil.required(ballotModel, contactService, groupService, messageService, userService)) {
+                            LinkBallotModel linkBallotModel = ballotService.getLinkedBallotModel(ballotModel);
+                            if (linkBallotModel != null) {
+                                GroupStatusDataModel.GroupStatusType type = null;
+                                MessageReceiver<? extends AbstractMessageModel> receiver = null;
+                                if (linkBallotModel instanceof GroupBallotModel) {
+                                    GroupModel groupModel = groupService.getById(((GroupBallotModel) linkBallotModel).getGroupId());
+
+                                    // its a group ballot,write status
+                                    receiver = groupService.createReceiver(groupModel);
+                                    // reset archived status
+                                    groupService.setIsArchived(groupModel, false);
+
+                                } else if (linkBallotModel instanceof IdentityBallotModel) {
+                                    String identity = ((IdentityBallotModel) linkBallotModel).getIdentity();
+
+                                    // not implemented
+                                    receiver = contactService.createReceiver(contactService.getByIdentity(identity));
+                                    // reset archived status
+                                    contactService.setIsArchived(identity, false);
+                                }
+
+                                if (ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE) {
+                                    // Only show status message for first vote from a voter on private voting
+                                    if (isFirstVote) {
+                                        // On private voting, only show default update msg!
+                                        type = GroupStatusDataModel.GroupStatusType.RECEIVED_VOTE;
+                                    }
+                                } else if (receiver != null) {
+                                    if (isFirstVote) {
+                                        type = GroupStatusDataModel.GroupStatusType.FIRST_VOTE;
+                                    } else {
+                                        type = GroupStatusDataModel.GroupStatusType.MODIFIED_VOTE;
+                                    }
+                                }
+
+                                if (
+                                    linkBallotModel instanceof GroupBallotModel
+                                        && (type == GroupStatusDataModel.GroupStatusType.FIRST_VOTE
+                                        || type == GroupStatusDataModel.GroupStatusType.MODIFIED_VOTE)
+                                        && !BallotUtil.isMine(ballotModel, userService)
+                                ) {
+                                    // Only show votes (and vote changes) to the creator of the ballot in a group
+                                    return;
+                                }
+
+                                if (type != null && receiver instanceof GroupMessageReceiver) {
+                                    messageService.createGroupStatus(
+                                        (GroupMessageReceiver) receiver,
+                                        type,
+                                        votingIdentity,
+                                        ballotModel.getName(),
+                                        null
+                                    );
+                                }
+
+                                // now check if every participant has voted
+                                if (isFirstVote
+                                    && ballotService.getPendingParticipants(ballotModel.getId()).isEmpty()
+                                    && receiver instanceof GroupMessageReceiver
+                                ) {
+                                    messageService.createGroupStatus(
+                                        (GroupMessageReceiver) receiver,
+                                        GroupStatusDataModel.GroupStatusType.VOTES_COMPLETE,
+                                        null,
+                                        ballotModel.getName(),
+                                        null
+                                    );
+                                }
+                            }
+                        }
+                    } catch (ThreemaException x) {
+                        logger.error("Exception", x);
+                    }
+                }
+            }
 
-			@Override
-			public void onVoteRemoved(BallotModel ballotModel, String votingIdentity) {
-				//ignore
-			}
+            @Override
+            public void onVoteRemoved(BallotModel ballotModel, String votingIdentity) {
+                //ignore
+            }
 
-			@Override
-			public boolean handle(BallotModel ballotModel) {
-				//handle all
-				return true;
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public boolean handle(BallotModel ballotModel) {
+                //handle all
+                return true;
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		final ContentObserver contentObserverChangeContactNames = new ContentObserver(null) {
-			private boolean isRunning = false;
+        final ContentObserver contentObserverChangeContactNames = new ContentObserver(null) {
+            private boolean isRunning = false;
 
-			@Override
-			public boolean deliverSelfNotifications() {
-				return super.deliverSelfNotifications();
-			}
+            @Override
+            public boolean deliverSelfNotifications() {
+                return super.deliverSelfNotifications();
+            }
 
-			@Override
-			public void onChange(boolean selfChange) {
-				super.onChange(selfChange);
+            @Override
+            public void onChange(boolean selfChange) {
+                super.onChange(selfChange);
 
-				if (!selfChange && serviceManager != null && !isRunning) {
-					this.isRunning = true;
-					onAndroidContactChangeLock.lock();
+                if (!selfChange && serviceManager != null && !isRunning) {
+                    this.isRunning = true;
+                    onAndroidContactChangeLock.lock();
 
-					boolean cont;
-					//check if a sync is in progress.. wait!
-					try {
-						SynchronizeContactsService synchronizeContactService = serviceManager.getSynchronizeContactsService();
-						cont = !synchronizeContactService.isSynchronizationInProgress();
-					} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
-						logger.error("Exception", e);
-						//do nothing
-						cont = false;
-					}
+                    boolean cont;
+                    //check if a sync is in progress.. wait!
+                    try {
+                        SynchronizeContactsService synchronizeContactService = serviceManager.getSynchronizeContactsService();
+                        cont = !synchronizeContactService.isSynchronizationInProgress();
+                    } catch (MasterKeyLockedException | FileSystemNotPresentException e) {
+                        logger.error("Exception", e);
+                        //do nothing
+                        cont = false;
+                    }
 
 					if (cont) {
 						PreferenceService preferencesService = serviceManager.getPreferenceService();
 						if (preferencesService.isSyncContacts()) {
 							try {
 								ContactService c = serviceManager.getContactService();
-                                //update contact names if changed!
-                                c.updateAllContactNamesFromAndroidContacts();
-                            } catch (MasterKeyLockedException | FileSystemNotPresentException e) {
+								//update contact names if changed!
+								c.updateAllContactNamesFromAndroidContacts();
+							} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
 								logger.error("Exception", e);
 							}
 						}
@@ -1800,288 +1719,277 @@ public class ThreemaApplication extends Application implements DefaultLifecycleO
 			}
 		};
 
-		ListenerManager.synchronizeContactsListeners.add(new SynchronizeContactsListener() {
-			@Override
-			public void onStarted(SynchronizeContactsRoutine startedRoutine) {
-				//disable contact observer
-				serviceManager.getContext().getContentResolver().unregisterContentObserver(contentObserverChangeContactNames);
-			}
+        ListenerManager.synchronizeContactsListeners.add(new SynchronizeContactsListener() {
+            @Override
+            public void onStarted(SynchronizeContactsRoutine startedRoutine) {
+                //disable contact observer
+                serviceManager.getContext().getContentResolver().unregisterContentObserver(contentObserverChangeContactNames);
+            }
 
-			@Override
-			public void onFinished(SynchronizeContactsRoutine finishedRoutine) {
-				//enable contact observer
-				serviceManager.getContext().getContentResolver().registerContentObserver(
-						ContactsContract.Contacts.CONTENT_URI,
-						false,
-						contentObserverChangeContactNames);
-			}
+            @Override
+            public void onFinished(SynchronizeContactsRoutine finishedRoutine) {
+                //enable contact observer
+                serviceManager.getContext().getContentResolver().registerContentObserver(
+                    ContactsContract.Contacts.CONTENT_URI,
+                    false,
+                    contentObserverChangeContactNames);
+            }
 
-			@Override
-			public void onError(SynchronizeContactsRoutine finishedRoutine) {
-				//enable contact observer
-				serviceManager.getContext().getContentResolver().registerContentObserver(
-						ContactsContract.Contacts.CONTENT_URI,
-						false,
-						contentObserverChangeContactNames);
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
+            @Override
+            public void onError(SynchronizeContactsRoutine finishedRoutine) {
+                //enable contact observer
+                serviceManager.getContext().getContentResolver().registerContentObserver(
+                    ContactsContract.Contacts.CONTENT_URI,
+                    false,
+                    contentObserverChangeContactNames);
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
 
-		ListenerManager.contactTypingListeners.add(new ContactTypingListener() {
-			@Override
-			public void onContactIsTyping(ContactModel fromContact, boolean isTyping) {
-				//update the conversations
-				try {
-					serviceManager.getConversationService()
-							.setIsTyping(fromContact, isTyping);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
+		ListenerManager.contactTypingListeners.add((fromContact, isTyping) -> {
+			//update the conversations
+			try {
+				serviceManager.getConversationService()
+						.setIsTyping(fromContact, isTyping);
+			} catch (ThreemaException e) {
+				logger.error("Exception", e);
 			}
 		});
 
-		ListenerManager.newSyncedContactListener.add(new NewSyncedContactsListener() {
-			@Override
-			public void onNew(List<ContactModel> contactModels) {
-				NotificationService notificationService = serviceManager.getNotificationService();
-				notificationService.showNewSyncedContactsNotification(contactModels);
-			}
+		ListenerManager.newSyncedContactListener.add(contactModels -> {
+			NotificationService notificationService = serviceManager.getNotificationService();
+			notificationService.showNewSyncedContactsNotification(contactModels);
 		});
 
-		WebClientListenerManager.serviceListener.add(new WebClientServiceListener() {
-			@Override
-			public void onEnabled() {
-				SessionWakeUpServiceImpl.getInstance()
-					.processPendingWakeupsAsync();
-			}
+        WebClientListenerManager.serviceListener.add(new WebClientServiceListener() {
+            @Override
+            public void onEnabled() {
+                SessionWakeUpServiceImpl.getInstance()
+                    .processPendingWakeupsAsync();
+            }
 
-			@Override
-			public void onStarted(
-				@NonNull final WebClientSessionModel model,
-				@NonNull final byte[] permanentKey,
-				@NonNull final String browser
-			) {
-				logger.info( "WebClientListenerManager: onStarted", true);
-
-				RuntimeUtil.runOnUiThread(() -> {
-					String toastText = getAppContext().getString(R.string.webclient_new_connection_toast);
-					if(model.getLabel() != null) {
-						toastText += " (" + model.getLabel() +")";
-					}
-					Toast.makeText(getAppContext(), toastText, Toast.LENGTH_LONG).show();
-
-					final Intent intent = new Intent(context, SessionAndroidService.class);
-
-					if (SessionAndroidService.isRunning()) {
-						intent.setAction(SessionAndroidService.ACTION_UPDATE);
-						logger.info( "sending ACTION_UPDATE to SessionAndroidService");
-						context.startService(intent);
-					} else {
-						logger.info( "SessionAndroidService not running...starting");
-						intent.setAction(SessionAndroidService.ACTION_START);
-						logger.info( "sending ACTION_START to SessionAndroidService");
-						if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
-							// Starting on version S, foreground services cannot be started from the background.
-							// When battery optimizations are disabled (recommended for Threema Web), then no
-							// exception is thrown. Otherwise we just log it.
-							try {
-								ContextCompat.startForegroundService(context, intent);
-							} catch (ForegroundServiceStartNotAllowedException exception) {
-								logger.error("Couldn't start foreground service", exception);
-							}
-						} else {
-							ContextCompat.startForegroundService(context, intent);
-						}
-					}
-				});
-			}
+            @Override
+            public void onStarted(
+                @NonNull final WebClientSessionModel model,
+                @NonNull final byte[] permanentKey,
+                @NonNull final String browser
+            ) {
+                logger.info("WebClientListenerManager: onStarted", true);
+
+                RuntimeUtil.runOnUiThread(() -> {
+                    String toastText = getAppContext().getString(R.string.webclient_new_connection_toast);
+                    if (model.getLabel() != null) {
+                        toastText += " (" + model.getLabel() + ")";
+                    }
+                    Toast.makeText(getAppContext(), toastText, Toast.LENGTH_LONG).show();
+
+                    final Intent intent = new Intent(context, SessionAndroidService.class);
+
+                    if (SessionAndroidService.isRunning()) {
+                        intent.setAction(SessionAndroidService.ACTION_UPDATE);
+                        logger.info("sending ACTION_UPDATE to SessionAndroidService");
+                        context.startService(intent);
+                    } else {
+                        logger.info("SessionAndroidService not running...starting");
+                        intent.setAction(SessionAndroidService.ACTION_START);
+                        logger.info("sending ACTION_START to SessionAndroidService");
+                        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.S) {
+                            // Starting on version S, foreground services cannot be started from the background.
+                            // When battery optimizations are disabled (recommended for Threema Web), then no
+                            // exception is thrown. Otherwise we just log it.
+                            try {
+                                ContextCompat.startForegroundService(context, intent);
+                            } catch (ForegroundServiceStartNotAllowedException exception) {
+                                logger.error("Couldn't start foreground service", exception);
+                            }
+                        } else {
+                            ContextCompat.startForegroundService(context, intent);
+                        }
+                    }
+                });
+            }
 
-			@Override
-			public void onStateChanged(
-				@NonNull final WebClientSessionModel model,
-				@NonNull final WebClientSessionState oldState,
-				@NonNull final WebClientSessionState newState
-			) {
-				logger.info( "WebClientListenerManager: onStateChanged");
-
-				if (newState == WebClientSessionState.DISCONNECTED) {
-					RuntimeUtil.runOnUiThread(() -> {
-						logger.info("updating SessionAndroidService");
-						if (SessionAndroidService.isRunning()) {
-							final Intent intent = new Intent(context, SessionAndroidService.class);
-							intent.setAction(SessionAndroidService.ACTION_UPDATE);
-							logger.info("sending ACTION_UPDATE to SessionAndroidService");
-							context.startService(intent);
-						} else {
-							logger.info("SessionAndroidService not running...not updating");
-						}
-					});
-				}
-			}
+            @Override
+            public void onStateChanged(
+                @NonNull final WebClientSessionModel model,
+                @NonNull final WebClientSessionState oldState,
+                @NonNull final WebClientSessionState newState
+            ) {
+                logger.info("WebClientListenerManager: onStateChanged");
+
+                if (newState == WebClientSessionState.DISCONNECTED) {
+                    RuntimeUtil.runOnUiThread(() -> {
+                        logger.info("updating SessionAndroidService");
+                        if (SessionAndroidService.isRunning()) {
+                            final Intent intent = new Intent(context, SessionAndroidService.class);
+                            intent.setAction(SessionAndroidService.ACTION_UPDATE);
+                            logger.info("sending ACTION_UPDATE to SessionAndroidService");
+                            context.startService(intent);
+                        } else {
+                            logger.info("SessionAndroidService not running...not updating");
+                        }
+                    });
+                }
+            }
 
-			@Override
-			public void onStopped(@NonNull final WebClientSessionModel model, @NonNull final DisconnectContext reason) {
-				logger.info( "WebClientListenerManager: onStopped");
-
-				RuntimeUtil.runOnUiThread(() -> {
-					if (SessionAndroidService.isRunning()) {
-						final Intent intent = new Intent(context, SessionAndroidService.class);
-						intent.setAction(SessionAndroidService.ACTION_STOP);
-						logger.info( "sending ACTION_STOP to SessionAndroidService");
-						context.startService(intent);
-					} else {
-						logger.info( "SessionAndroidService not running...not stopping");
-					}
-				});
-			}
-		});
+            @Override
+            public void onStopped(@NonNull final WebClientSessionModel model, @NonNull final DisconnectContext reason) {
+                logger.info("WebClientListenerManager: onStopped");
+
+                RuntimeUtil.runOnUiThread(() -> {
+                    if (SessionAndroidService.isRunning()) {
+                        final Intent intent = new Intent(context, SessionAndroidService.class);
+                        intent.setAction(SessionAndroidService.ACTION_STOP);
+                        logger.info("sending ACTION_STOP to SessionAndroidService");
+                        context.startService(intent);
+                    } else {
+                        logger.info("SessionAndroidService not running...not stopping");
+                    }
+                });
+            }
+        });
 
 		//called if a fcm message with a newer session received
-		WebClientListenerManager.wakeUpListener.add(new WebClientWakeUpListener() {
-			@Override
-			public void onProtocolError() {
-				RuntimeUtil.runOnUiThread(
-					() -> Toast.makeText(getAppContext(), R.string.webclient_protocol_version_to_old, Toast.LENGTH_LONG).show()
-				);
-			}
-		});
-
-		VoipListenerManager.callEventListener.add(new VoipCallEventListener() {
-			private final Logger logger = LoggingUtil.getThreemaLogger("VoipCallEventListener");
-
-			@Override
-			public void onRinging(String peerIdentity) {
-				this.logger.debug("onRinging {}", peerIdentity);
-			}
-
-			@Override
-			public void onStarted(String peerIdentity, boolean outgoing) {
-				final String direction = outgoing ? "to" : "from";
-				this.logger.info("Call {} {} started", direction, peerIdentity);
-			}
-
-			@Override
-			public void onFinished(long callId, @NonNull String peerIdentity, boolean outgoing, int duration) {
-				final String direction = outgoing ? "to" : "from";
-				this.logger.info("Call {} {} finished", direction, peerIdentity);
-				this.saveStatus(peerIdentity,
-						outgoing,
-						VoipStatusDataModel.createFinished(callId, duration),
-						true);
-			}
-
-			@Override
-			public void onRejected(long callId, String peerIdentity, boolean outgoing, byte reason) {
-				final String direction = outgoing ? "to" : "from";
-				this.logger.info("Call {} {} rejected (reason {})", direction, peerIdentity, reason);
-				this.saveStatus(peerIdentity,
-						// on rejected incoming, the outgoing was rejected!
-						!outgoing,
-						VoipStatusDataModel.createRejected(callId, reason),
-						true);
-			}
-
-			@Override
-			public void onMissed(long callId, String peerIdentity, boolean accepted, @Nullable Date date) {
-				this.logger.info("Call from {} missed", peerIdentity);
-				this.saveStatus(peerIdentity,
-						false,
-						VoipStatusDataModel.createMissed(callId, date),
-						accepted);
-			}
+		WebClientListenerManager.wakeUpListener.add(() -> RuntimeUtil.runOnUiThread(
+			() -> Toast.makeText(getAppContext(), R.string.webclient_protocol_version_to_old, Toast.LENGTH_LONG).show()
+		));
 
-			@Override
-			public void onAborted(long callId, String peerIdentity) {
-				this.logger.info("Call to {} aborted", peerIdentity);
-				this.saveStatus(peerIdentity,
-						true,
-						VoipStatusDataModel.createAborted(callId),
-						true);
-			}
+        VoipListenerManager.callEventListener.add(new VoipCallEventListener() {
+            private final Logger logger = LoggingUtil.getThreemaLogger("VoipCallEventListener");
 
-			private void saveStatus(
-				@NonNull String identity,
-				boolean isOutbox,
-				@NonNull VoipStatusDataModel status,
-				boolean isRead
-			) {
-				try {
-					// Services
-					if (serviceManager == null) {
-						this.logger.error("Could not save voip status, servicemanager is null");
-						return;
-					}
-					final IdentityStore identityStore = serviceManager.getIdentityStore();
-					final ContactService contactService = serviceManager.getContactService();
-					final MessageService messageService = serviceManager.getMessageService();
-
-					// If an incoming status message is not targeted at our own identity, something's wrong
-					final String appIdentity = identityStore.getIdentity();
-					if (TestUtil.compare(identity, appIdentity) && !isOutbox) {
-						this.logger.error("Could not save voip status (identity={}, appIdentity={}, outbox={})", identity, appIdentity, isOutbox);
-						return;
-					}
-
-					// Create status message
-					final ContactModel contactModel = contactService.getByIdentity(identity);
-					final ContactMessageReceiver receiver = contactService.createReceiver(contactModel);
-					messageService.createVoipStatus(status, receiver, isOutbox, isRead);
-				} catch (ThreemaException e) {
-					logger.error("Exception", e);
-				}
-			}
-		}, THREEMA_APPLICATION_LISTENER_TAG);
-
-		if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.M || ContextCompat.checkSelfPermission(serviceManager.getContext(), android.Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) {
-			serviceManager.getContext().getContentResolver()
-					.registerContentObserver(ContactsContract.Contacts.CONTENT_URI,
-							false,
-							contentObserverChangeContactNames);
-		}
-	}
-
-	public static boolean activityResumed(Activity currentActivity) {
-		logger.debug("*** App ActivityResumed");
-		if (serviceManager != null) {
-			serviceManager.getActivityService().resume(currentActivity);
-			return true;
-		}
-		return false;
-	}
+            @Override
+            public void onRinging(String peerIdentity) {
+                this.logger.debug("onRinging {}", peerIdentity);
+            }
 
-	public static void activityPaused(Activity pausedActivity) {
-		logger.debug("*** App ActivityPaused");
-		if (serviceManager != null) {
-			serviceManager.getActivityService().pause(pausedActivity);
-		}
-	}
+            @Override
+            public void onStarted(String peerIdentity, boolean outgoing) {
+                final String direction = outgoing ? "to" : "from";
+                this.logger.info("Call {} {} started", direction, peerIdentity);
+            }
 
-	public static void activityDestroyed(Activity destroyedActivity) {
-		logger.debug("*** App ActivityDestroyed");
-		if (serviceManager != null) {
-			serviceManager.getActivityService().destroy(destroyedActivity);
-		}
-	}
+            @Override
+            public void onFinished(long callId, @NonNull String peerIdentity, boolean outgoing, int duration) {
+                final String direction = outgoing ? "to" : "from";
+                this.logger.info("Call {} {} finished", direction, peerIdentity);
+                this.saveStatus(peerIdentity,
+                    outgoing,
+                    VoipStatusDataModel.createFinished(callId, duration),
+                    true);
+            }
 
-	public static boolean activityUserInteract(Activity interactedActivity) {
-		if (serviceManager != null) {
-			serviceManager.getActivityService().userInteract(interactedActivity);
-		}
-		return true;
-	}
+            @Override
+            public void onRejected(long callId, String peerIdentity, boolean outgoing, byte reason) {
+                final String direction = outgoing ? "to" : "from";
+                this.logger.info("Call {} {} rejected (reason {})", direction, peerIdentity, reason);
+                this.saveStatus(peerIdentity,
+                    // on rejected incoming, the outgoing was rejected!
+                    !outgoing,
+                    VoipStatusDataModel.createRejected(callId, reason),
+                    true);
+            }
 
-	public static Date getLastLoggedIn() {
-		return lastLoggedIn;
-	}
+            @Override
+            public void onMissed(long callId, String peerIdentity, boolean accepted, @Nullable Date date) {
+                this.logger.info("Call from {} missed", peerIdentity);
+                this.saveStatus(peerIdentity,
+                    false,
+                    VoipStatusDataModel.createMissed(callId, date),
+                    accepted);
+            }
 
-	public static boolean isIsDeviceIdle() {
-		return isDeviceIdle;
-	}
+            @Override
+            public void onAborted(long callId, String peerIdentity) {
+                this.logger.info("Call to {} aborted", peerIdentity);
+                this.saveStatus(peerIdentity,
+                    true,
+                    VoipStatusDataModel.createAborted(callId),
+                    true);
+            }
 
-	public static AppVersion getAppVersion() {
-		return appVersion;
-	}
+            private void saveStatus(
+                @NonNull String identity,
+                boolean isOutbox,
+                @NonNull VoipStatusDataModel status,
+                boolean isRead
+            ) {
+                try {
+                    // Services
+                    if (serviceManager == null) {
+                        this.logger.error("Could not save voip status, servicemanager is null");
+                        return;
+                    }
+                    final IdentityStore identityStore = serviceManager.getIdentityStore();
+                    final ContactService contactService = serviceManager.getContactService();
+                    final MessageService messageService = serviceManager.getMessageService();
+
+                    // If an incoming status message is not targeted at our own identity, something's wrong
+                    final String appIdentity = identityStore.getIdentity();
+                    if (TestUtil.compare(identity, appIdentity) && !isOutbox) {
+                        this.logger.error("Could not save voip status (identity={}, appIdentity={}, outbox={})", identity, appIdentity, isOutbox);
+                        return;
+                    }
 
-	public static Context getAppContext() {
-		return ThreemaApplication.context;
-	}
+                    // Create status message
+                    final ContactModel contactModel = contactService.getByIdentity(identity);
+                    final ContactMessageReceiver receiver = contactService.createReceiver(contactModel);
+                    messageService.createVoipStatus(status, receiver, isOutbox, isRead);
+                } catch (ThreemaException e) {
+                    logger.error("Exception", e);
+                }
+            }
+        }, THREEMA_APPLICATION_LISTENER_TAG);
+
+        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.M || ContextCompat.checkSelfPermission(serviceManager.getContext(), android.Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) {
+            serviceManager.getContext().getContentResolver()
+                .registerContentObserver(ContactsContract.Contacts.CONTENT_URI,
+                    false,
+                    contentObserverChangeContactNames);
+        }
+    }
+
+    public static boolean activityResumed(Activity currentActivity) {
+        logger.debug("*** App ActivityResumed");
+        if (serviceManager != null) {
+            serviceManager.getActivityService().resume(currentActivity);
+            return true;
+        }
+        return false;
+    }
+
+    public static void activityPaused(Activity pausedActivity) {
+        logger.debug("*** App ActivityPaused");
+        if (serviceManager != null) {
+            serviceManager.getActivityService().pause(pausedActivity);
+        }
+    }
+
+    public static void activityDestroyed(Activity destroyedActivity) {
+        logger.debug("*** App ActivityDestroyed");
+        if (serviceManager != null) {
+            serviceManager.getActivityService().destroy(destroyedActivity);
+        }
+    }
+
+    public static boolean activityUserInteract(Activity interactedActivity) {
+        if (serviceManager != null) {
+            serviceManager.getActivityService().userInteract(interactedActivity);
+        }
+        return true;
+    }
+
+    public static Date getLastLoggedIn() {
+        return lastLoggedIn;
+    }
+
+    public static boolean isIsDeviceIdle() {
+        return isDeviceIdle;
+    }
+
+    public static AppVersion getAppVersion() {
+        return appVersion;
+    }
+
+    public static Context getAppContext() {
+        return ThreemaApplication.context;
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/activities/AddContactActivity.java b/app/src/main/java/ch/threema/app/activities/AddContactActivity.java
index eeed431c..eba8b54d 100644
--- a/app/src/main/java/ch/threema/app/activities/AddContactActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/AddContactActivity.java
@@ -48,14 +48,14 @@ import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
-import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask;
 import ch.threema.app.asynctasks.AlreadyVerified;
-import ch.threema.app.asynctasks.ContactAddResult;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactCreated;
 import ch.threema.app.asynctasks.ContactExists;
 import ch.threema.app.asynctasks.ContactModified;
 import ch.threema.app.asynctasks.Failed;
 import ch.threema.app.asynctasks.PolicyViolation;
-import ch.threema.app.asynctasks.Success;
 import ch.threema.app.dialogs.GenericAlertDialog;
 import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.NewContactDialog;
@@ -74,6 +74,7 @@ import ch.threema.base.utils.Base64;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.api.APIConnector;
+import ch.threema.storage.models.ContactModel;
 
 import static ch.threema.app.services.QRCodeServiceImpl.QR_TYPE_ID;
 import static ch.threema.domain.protocol.csp.ProtocolDefines.IDENTITY_LEN;
@@ -237,8 +238,9 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 			return;
 		}
 
-		backgroundExecutor.execute(new AddOrUpdateContactBackgroundTask(
+		backgroundExecutor.execute(new BasicAddOrUpdateContactBackgroundTask(
 			identity,
+			ContactModel.AcquaintanceLevel.DIRECT,
 			getMyIdentity(),
 			apiConnector,
 			contactModelRepository,
@@ -252,14 +254,14 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 			}
 
 			@Override
-			public void onFinished(@NonNull ContactAddResult result) {
+			public void onFinished(@NonNull ContactResult result) {
 				if (isDestroyed()) {
 					return;
 				}
 
 				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_ADD_PROGRESS, true);
 
-				if (result instanceof Success) {
+				if (result instanceof ContactCreated) {
 					showContactAndFinish(identity, R.string.creating_contact_successful);
 				} else if (result instanceof ContactModified) {
 					if (((ContactModified) result).getAcquaintanceLevelChanged()) {
@@ -271,6 +273,9 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 					showContactAndFinish(identity, R.string.scan_duplicate);
 				} else if (result instanceof ContactExists) {
 					showContactAndFinish(identity, R.string.identity_already_exists);
+				} else if (result instanceof PolicyViolation) {
+					Toast.makeText(AddContactActivity.this, R.string.disabled_by_policy_short, Toast.LENGTH_SHORT).show();
+					finish();
 				} else if (result instanceof Failed) {
 					GenericAlertDialog.newInstance(
 						ConfigUtils.isOnPremBuild() ?
@@ -280,9 +285,6 @@ public class AddContactActivity extends ThreemaActivity implements GenericAlertD
 						R.string.close,
 						0
 					).show(getSupportFragmentManager(), DIALOG_TAG_ADD_ERROR);
-				} else if (result instanceof PolicyViolation) {
-					Toast.makeText(AddContactActivity.this, R.string.disabled_by_policy_short, Toast.LENGTH_SHORT).show();
-					finish();
 				}
 			}
 		});
diff --git a/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java b/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java
index e001b244..c7cd61d1 100644
--- a/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/AppLinksActivity.java
@@ -28,20 +28,32 @@ import android.widget.Toast;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
-import ch.threema.app.asynctasks.AddContactAsyncTask;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.grouplinks.OutgoingGroupRequestActivity;
 import ch.threema.app.services.LockAppService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.HiddenChatUtil;
+import ch.threema.app.utils.LazyProperty;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
+import ch.threema.storage.models.ContactModel;
 
 public class AppLinksActivity extends ThreemaToolbarActivity {
+	private final static Logger logger = LoggingUtil.getThreemaLogger("AppLinksActivity");
 
-    private static final Logger logger = LoggingUtil.getThreemaLogger("AppLinksActivity");
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -91,40 +103,23 @@ public class AppLinksActivity extends ThreemaToolbarActivity {
         finish();
     }
 
-    private void handleContactUrl(String appLinkAction, Uri appLinkData) {
-        logger.info("Handle contact url");
-        final String threemaId = appLinkData.getLastPathSegment();
-        if (threemaId != null) {
-            if (threemaId.equalsIgnoreCase("compose")) {
-                Intent intent = new Intent(this, RecipientListActivity.class);
-                intent.setAction(appLinkAction);
-                intent.setData(appLinkData);
-                startActivity(intent);
-            } else if (threemaId.length() == ProtocolDefines.IDENTITY_LEN) {
-                new AddContactAsyncTask(null, null, threemaId, false, () -> {
-                    String text = appLinkData.getQueryParameter("text");
-
-                    Intent intent = new Intent(this, text != null ?
-                        ComposeMessageActivity.class :
-                        ContactDetailActivity.class);
-                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-                    intent.putExtra(ThreemaApplication.INTENT_DATA_CONTACT, threemaId);
-                    intent.putExtra(ThreemaApplication.INTENT_DATA_EDITFOCUS, Boolean.TRUE);
-
-                    if (text != null) {
-                        text = text.trim();
-                        intent.putExtra(ThreemaApplication.INTENT_DATA_TEXT, text);
-                    }
-
-                    startActivity(intent);
-                }).execute();
-            } else {
-                Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
-            }
-        } else {
-            Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
-        }
-    }
+	private void handleContactUrl(String appLinkAction, Uri appLinkData) {
+		final String threemaId = appLinkData.getLastPathSegment();
+		if (threemaId != null) {
+			if (threemaId.equalsIgnoreCase("compose")) {
+				Intent intent = new Intent(this, RecipientListActivity.class);
+				intent.setAction(appLinkAction);
+				intent.setData(appLinkData);
+				startActivity(intent);
+			} else if (threemaId.length() == ProtocolDefines.IDENTITY_LEN) {
+				addNewContactAndOpenChat(threemaId, appLinkData);
+			} else {
+				Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
+			}
+		} else {
+			Toast.makeText(this, R.string.invalid_input, Toast.LENGTH_LONG).show();
+		}
+	}
 
     private void handleGroupLinkUrl(Uri appLinkData) {
         logger.info("Handle group link url");
@@ -139,27 +134,70 @@ public class AppLinksActivity extends ThreemaToolbarActivity {
         overridePendingTransition(0, 0);
     }
 
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        switch (requestCode) {
-            case ThreemaActivity.ACTIVITY_ID_CHECK_LOCK:
-                if (resultCode == RESULT_OK) {
-                    lockAppService.unlock(null);
-                    handleIntent();
-                } else {
-                    Toast.makeText(this, getString(R.string.pin_locked_cannot_send), Toast.LENGTH_LONG).show();
-                    finish();
-                }
-                break;
-            case ThreemaActivity.ACTIVITY_ID_UNLOCK_MASTER_KEY:
-                if (ThreemaApplication.getMasterKey().isLocked()) {
-                    finish();
-                } else {
-                    ConfigUtils.recreateActivity(this, AppLinksActivity.class, getIntent().getExtras());
-                }
-                break;
-            default:
-                super.onActivityResult(requestCode, resultCode, data);
-        }
-    }
+	@Override
+	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+		switch (requestCode) {
+			case ThreemaActivity.ACTIVITY_ID_CHECK_LOCK:
+				if (resultCode == RESULT_OK) {
+					lockAppService.unlock(null);
+					handleIntent();
+				} else {
+					Toast.makeText(this, getString(R.string.pin_locked_cannot_send), Toast.LENGTH_LONG).show();
+					finish();
+				}
+				break;
+			case ThreemaActivity.ACTIVITY_ID_UNLOCK_MASTER_KEY:
+				if (ThreemaApplication.getMasterKey().isLocked()) {
+					finish();
+				} else {
+					ConfigUtils.recreateActivity(this, AppLinksActivity.class, getIntent().getExtras());
+				}
+				break;
+			default:
+				super.onActivityResult(requestCode, resultCode, data);
+		}
+	}
+
+	private void addNewContactAndOpenChat(@NonNull String identity, @NonNull Uri appLinkData) {
+		UserService userService = serviceManager.getUserService();
+		APIConnector apiConnector = serviceManager.getAPIConnector();
+		ContactModelRepository contactModelRepository = serviceManager.getModelRepositories().getContacts();
+
+		backgroundExecutor.get().execute(
+			new BasicAddOrUpdateContactBackgroundTask(
+				identity,
+				ContactModel.AcquaintanceLevel.DIRECT,
+				userService.getIdentity(),
+				apiConnector,
+				contactModelRepository,
+				AddContactRestrictionPolicy.CHECK,
+				AppLinksActivity.this,
+				null
+			) {
+				@Override
+				public void onFinished(ContactResult result) {
+					if (!(result instanceof ContactAvailable)) {
+						logger.error("Could not add contact");
+						return;
+					}
+
+					String text = appLinkData.getQueryParameter("text");
+
+					Intent intent = new Intent(AppLinksActivity.this, text != null ?
+						ComposeMessageActivity.class :
+						ContactDetailActivity.class);
+					intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+					intent.putExtra(ThreemaApplication.INTENT_DATA_CONTACT, identity);
+					intent.putExtra(ThreemaApplication.INTENT_DATA_EDITFOCUS, Boolean.TRUE);
+
+					if (text != null) {
+						text = text.trim();
+						intent.putExtra(ThreemaApplication.INTENT_DATA_TEXT, text);
+					}
+
+					startActivity(intent);
+				}
+			}
+		);
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/activities/BlockedContactsActivity.java b/app/src/main/java/ch/threema/app/activities/BlockedContactsActivity.java
deleted file mode 100644
index 1004bd58..00000000
--- a/app/src/main/java/ch/threema/app/activities/BlockedContactsActivity.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities;
-
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.services.IdListService;
-
-public class BlockedContactsActivity extends IdentityListActivity {
-	private IdListService listService;
-
-	@Override
-	protected IdListService getIdentityListService() {
-		if(this.listService == null) {
-			this.listService = ThreemaApplication.getServiceManager().getBlockedContactsService();
-		}
-		return this.listService;
-	}
-
-	@Override
-	protected String getBlankListText() {
-		return this.getString(R.string.prefs_sum_blocked_contacts);
-	}
-
-	@Override
-	protected String getTitleText() {
-		return this.getString(R.string.prefs_title_blocked_contacts);
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java b/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java
index faca71ca..1f424826 100644
--- a/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/ContactDetailActivity.java
@@ -28,7 +28,6 @@ import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.graphics.Color;
 import android.graphics.PorterDuff;
-import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
@@ -46,9 +45,11 @@ import com.google.android.material.floatingactionbutton.FloatingActionButton;
 import org.slf4j.Logger;
 
 import java.io.File;
+import java.lang.ref.WeakReference;
 import java.util.Date;
 import java.util.List;
 import java.util.Objects;
+import java.util.Set;
 
 import androidx.annotation.ColorInt;
 import androidx.annotation.NonNull;
@@ -64,9 +65,19 @@ import androidx.recyclerview.widget.RecyclerView;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.adapters.ContactDetailAdapter;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.AlreadyVerified;
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy;
+import ch.threema.app.asynctasks.ContactModified;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactSyncPolicy;
+import ch.threema.app.asynctasks.DeleteContactServices;
+import ch.threema.app.asynctasks.DialogMarkContactAsDeletedBackgroundTask;
+import ch.threema.app.asynctasks.Failed;
+import ch.threema.app.asynctasks.LocalPublicKeyMismatch;
 import ch.threema.app.dialogs.ContactEditDialog;
 import ch.threema.app.dialogs.GenericAlertDialog;
-import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.SimpleStringAlertDialog;
 import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.listeners.ContactSettingsListener;
@@ -87,7 +98,7 @@ import ch.threema.app.utils.AndroidContactUtil;
 import ch.threema.app.utils.AppRestrictionUtil;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ContactUtil;
-import ch.threema.app.utils.DialogUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.LogUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.QRScannerUtil;
@@ -95,11 +106,13 @@ import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShareUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.ViewUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.services.VoipStateService;
 import ch.threema.app.voip.util.VoipUtil;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.data.repositories.ModelRepositories;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.storage.models.ContactModel;
@@ -116,7 +129,6 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	private static final String DIALOG_TAG_EDIT = "cedit";
 	private static final String DIALOG_TAG_DELETE_CONTACT = "deleteContact";
 	private static final String DIALOG_TAG_EXCLUDE_CONTACT = "excludeContact";
-	private static final String DIALOG_TAG_DELETING_CONTACT = "dliC";
 	private static final String DIALOG_TAG_ADD_CONTACT = "dac";
 	private static final String DIALOG_TAG_CONFIRM_BLOCK = "block";
 
@@ -129,15 +141,20 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 
 	// Services
 	private ContactService contactService;
+	private ContactModelRepository contactModelRepository;
 	private GroupService groupService;
 	private IdListService blockedContactsService, profilePicRecipientsService;
 	private DeadlineListService hiddenChatsListService;
 	private VoipStateService voipStateService;
+	private DeleteContactServices deleteContactServices;
+
+	private final @NonNull LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
 	// Data and state holders
 	private String identity;
 	@Deprecated
 	private ContactModel contact;
+	private ch.threema.data.models.ContactModel contactModel;
 	private @Nullable ContactDetailViewModel viewModel; // Initially null, until initialized
 	private List<GroupModel> groupList;
 	private boolean isReadonly;
@@ -153,7 +170,15 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	private View workIcon;
 
 	private void refreshAdapter() {
-		contactDetailRecyclerView.setAdapter(setupAdapter());
+		if (viewModel == null) {
+			logger.error("View model is null. Cannot refresh adapter.");
+			return;
+		}
+
+		ContactModelData fetchedData = viewModel.getContact().getValue();
+		if (fetchedData != null) {
+			contactDetailRecyclerView.setAdapter(setupAdapter(fetchedData));
+		}
 	}
 
 	private final ResumePauseHandler.RunIfActive runIfActiveUpdate = new ResumePauseHandler.RunIfActive() {
@@ -201,8 +226,8 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			if (!this.shouldHandleChange(contactModel.getIdentity())) {
+		public void onAvatarChanged(final @NonNull String identity) {
+			if (!this.shouldHandleChange(identity)) {
 				return;
 			}
 			RuntimeUtil.runOnUiThread(() -> updateProfilepicMenu());
@@ -237,21 +262,21 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			if (newIdentity.equals(identity)) {
 				resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD_GROUP, runIfActiveGroupUpdate);
 			}
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String leftIdentity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String leftIdentity) {
 			if (leftIdentity.equals(identity)) {
 				resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD_GROUP, runIfActiveGroupUpdate);
 			}
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String kickedIdentity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String kickedIdentity) {
 			if (kickedIdentity.equals(identity)) {
 				resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD_GROUP, runIfActiveGroupUpdate);
 			}
@@ -302,11 +327,27 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		try {
 			this.contactService = serviceManager.getContactService();
 			modelRepositories = serviceManager.getModelRepositories();
+			contactModelRepository = modelRepositories.getContacts();
 			this.blockedContactsService = serviceManager.getBlockedContactsService();
 			this.profilePicRecipientsService = serviceManager.getProfilePicRecipientsService();
 			this.groupService = serviceManager.getGroupService();
 			this.hiddenChatsListService = serviceManager.getHiddenChatsListService();
 			this.voipStateService = serviceManager.getVoipStateService();
+			this.deleteContactServices = new DeleteContactServices(
+				serviceManager.getUserService(),
+				contactService,
+				serviceManager.getConversationService(),
+				serviceManager.getRingtoneService(),
+				serviceManager.getMutedChatsListService(),
+				hiddenChatsListService,
+				profilePicRecipientsService,
+				serviceManager.getWallpaperService(),
+				serviceManager.getFileService(),
+				serviceManager.getExcludedSyncIdentitiesService(),
+				serviceManager.getDHSessionStore(),
+				serviceManager.getNotificationService(),
+				serviceManager.getDatabaseServiceNew()
+			);
 		} catch (Exception e) {
 			LogUtil.exception(e, this);
 			this.finish();
@@ -315,7 +356,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 
 		// Look up contact data
 		this.contact = this.contactService.getByIdentity(this.identity);
-		final ch.threema.data.models.ContactModel contactModel = modelRepositories.getContacts().getByIdentity(this.identity);
+		contactModel = modelRepositories.getContacts().getByIdentity(this.identity);
 		if (this.contact == null || contactModel == null) {
 			Toast.makeText(this, R.string.contact_not_found, Toast.LENGTH_LONG).show();
 			this.finish();
@@ -371,7 +412,6 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 
 		// Set up contact detail recycler view
 		this.contactDetailRecyclerView.setLayoutManager(new LinearLayoutManager(this));
-		this.contactDetailRecyclerView.setAdapter(setupAdapter());
 
 		// Set description for badge
 		this.workIcon.setContentDescription(
@@ -480,16 +520,17 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	}
 
 	@UiThread
-	private ContactDetailAdapter setupAdapter() {
-		// By the time `setupAdapter` is called for the first time, the viewmodel should
-		// already be initialized.
-		final ContactDetailViewModel viewModel = Objects.requireNonNull(this.viewModel);
-		final ContactModelData contactModelData = Objects.requireNonNull(viewModel.getContact().getValue());
+	@Nullable
+	private ContactDetailAdapter setupAdapter(@NonNull ContactModelData contactModelData) {
+		if (viewModel == null) {
+			logger.error("View model is null");
+			return null;
+		}
 
 		final ContactDetailAdapter contactDetailAdapter = new ContactDetailAdapter(
 			this,
 			this.groupList,
-			contact,
+			viewModel.getContactModel(),
 			contactModelData,
 			Glide.with(this)
 		);
@@ -565,37 +606,25 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		dialogFragment.show(getSupportFragmentManager(), DIALOG_TAG_DELETE_CONTACT);
 	}
 
-	private void removeContactConfirmed(final boolean addToExcludeList, final ContactModel contactModel) {
-		new AsyncTask<Void, Void, Boolean>() {
-			@Override
-			protected void onPreExecute() {
-				GenericProgressDialog.newInstance(R.string.deleting_contact, R.string.please_wait).show(getSupportFragmentManager(), DIALOG_TAG_DELETING_CONTACT);
-			}
-
-
-			@Override
-			protected Boolean doInBackground(Void... params) {
-				if (addToExcludeList) {
-					IdListService excludeFromSyncListService = ContactDetailActivity.this
-							.serviceManager.getExcludedSyncIdentitiesService();
-
-					if (excludeFromSyncListService != null) {
-						excludeFromSyncListService.add(contactModel.getIdentity());
-					}
-				}
-				return contactService.remove(contactModel);
-			}
-
-			@Override
-			protected void onPostExecute(Boolean success) {
-				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_DELETING_CONTACT, true);
-				if (!success) {
-					Toast.makeText(ContactDetailActivity.this, "Failed to remove contact", Toast.LENGTH_SHORT).show();
-				} else {
+	private void removeContactConfirmed(final boolean addToExcludeList) {
+		backgroundExecutor.get().execute(
+			new DialogMarkContactAsDeletedBackgroundTask(
+				getSupportFragmentManager(),
+				new WeakReference<>(this),
+				Set.of(identity),
+				contactModelRepository,
+				deleteContactServices,
+				addToExcludeList ? ContactSyncPolicy.EXCLUDE : ContactSyncPolicy.INCLUDE,
+				AndroidContactLinkPolicy.REMOVE_LINK
+			) {
+				@Override
+				protected void onFinished() {
+					// TODO(ANDR-3051): Do not leave contact detail activity if contact could not be
+					//  deleted.
 					finishAndGoHome();
 				}
 			}
-		}.execute();
+		);
 	}
 
 	private void editName() {
@@ -658,7 +687,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		updateVoipCallMenuItem(null);
 
 		MenuItem galleryMenuItem = menu.findItem(R.id.menu_gallery);
-		if (hiddenChatsListService.has(contactService.getUniqueIdString(contact))) {
+		if (hiddenChatsListService.has(ContactUtil.getUniqueIdString(identity))) {
 			galleryMenuItem.setVisible(false);
 		}
 
@@ -709,7 +738,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 		} else if (id == R.id.action_share_contact) {
 			ShareUtil.shareContact(this, contact);
 		} else if (id == R.id.menu_gallery) {
-			if (!hiddenChatsListService.has(contactService.getUniqueIdString(contact))) {
+			if (!hiddenChatsListService.has(ContactUtil.getUniqueIdString(identity))) {
 				Intent mediaGalleryIntent = new Intent(this, MediaGalleryActivity.class);
 				mediaGalleryIntent.putExtra(ThreemaApplication.INTENT_DATA_CONTACT, identity);
 				startActivity(mediaGalleryIntent);
@@ -763,7 +792,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 					this.profilePicItem.setVisible(false);
 					this.profilePicSendItem.setVisible(!ContactUtil.isEchoEchoOrGatewayContact(contact));
 					break;
-				case PreferenceService.PROFILEPIC_RELEASE_SOME:
+				case PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST:
 					if (!ContactUtil.isEchoEchoOrGatewayContact(contact)) {
 						if (profilePicRecipientsService != null && profilePicRecipientsService.has(this.identity)) {
 							profilePicItem.setTitle(R.string.menu_send_profilpic_off);
@@ -819,42 +848,15 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 								this.serviceManager.getQRCodeService());
 
 				if (qrRes != null) {
-					if (qrRes.getExpirationDate() != null && qrRes.getExpirationDate().before(new Date())) {
-						SimpleStringAlertDialog.newInstance(R.string.title_adduser, getString(R.string.expired_barcode)).show(getSupportFragmentManager(), "expiredId");
-						return;
-					}
-
-					if(!TestUtil.compare(identity, qrRes.getIdentity())) {
-						SimpleStringAlertDialog.newInstance(
-								R.string.scan_id_mismatch_title,
-								getString(R.string.scan_id_mismatch_message)).show(getSupportFragmentManager(), "scanId");
-						return;
-					}
-					int contactVerification = this.contactService.updateContactVerification(identity, qrRes.getPublicKey());
-
-					//update the view
-					// this.updateVerificationLevelImage(this.verificationLevelImageView);
-
-					int txt;
-					switch (contactVerification) {
-						case ContactService.ContactVerificationResult_ALREADY_VERIFIED:
-							txt = R.string.scan_duplicate;
-							break;
-						case ContactService.ContactVerificationResult_VERIFIED:
-							txt = R.string.scan_successful;
-							break;
-						default:
-							txt = R.string.id_mismatch;
-					}
-					SimpleStringAlertDialog.newInstance(R.string.id_scanned, getString(txt)).show(getSupportFragmentManager(), "scanId");
+					applyQRCodeResult(qrRes);
 				}
 				break;
 			case REQUEST_CODE_CONTACT_EDITOR:
 				try {
-					AndroidContactUtil.getInstance().updateNameByAndroidContact(contact);
-					AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contact);
+					AndroidContactUtil.getInstance().updateNameByAndroidContact(contactModel);
+					AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contactModel);
 					this.avatarEditView.setContactModel(contact);
-				} catch (ThreemaException e) {
+				} catch (ThreemaException|SecurityException e) {
 					logger.info("Unable to update contact name or avatar after returning from ContactEditor");
 				}
 				break;
@@ -881,15 +883,67 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 			dialogFragment.setData(contact);
 			dialogFragment.show(getSupportFragmentManager(), DIALOG_TAG_EXCLUDE_CONTACT);
 		} else {
-			removeContactConfirmed(false, contactModel);
+			removeContactConfirmed(false);
 		}
 	}
 
 	void unhideContact(ContactModel contactModel) {
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		onCreateLocal();
 	}
 
+	private void applyQRCodeResult(@NonNull QRCodeService.QRCodeContentResult qrRes) {
+		if (qrRes.getExpirationDate() != null && qrRes.getExpirationDate().before(new Date())) {
+			SimpleStringAlertDialog.newInstance(R.string.title_adduser, getString(R.string.expired_barcode)).show(getSupportFragmentManager(), "expiredId");
+			return;
+		}
+
+		if(!TestUtil.compare(identity, qrRes.getIdentity())) {
+			SimpleStringAlertDialog.newInstance(
+				R.string.scan_id_mismatch_title,
+				getString(R.string.scan_id_mismatch_message)).show(getSupportFragmentManager(), "scanId");
+			return;
+		}
+
+		AddOrUpdateContactBackgroundTask<String> task = new AddOrUpdateContactBackgroundTask<>(
+			identity,
+			ContactModel.AcquaintanceLevel.DIRECT,
+			contactService.getMe().getIdentity(),
+			serviceManager.getAPIConnector(),
+			contactModelRepository,
+			AddContactRestrictionPolicy.CHECK,
+			this,
+			qrRes.getPublicKey()
+		) {
+			@Override
+			public String onContactAdded(@NonNull ContactResult result) {
+				if (result instanceof AlreadyVerified) {
+					return getString(R.string.scan_duplicate);
+				} else if (result instanceof ContactModified) {
+					if (((ContactModified) result).getVerificationLevelChanged()) {
+						return getString(R.string.scan_successful);
+					} else if (((ContactModified) result).getAcquaintanceLevelChanged()) {
+						logger.warn("Acquaintance level has changed instead of verification level");
+					}
+				} else if (result instanceof LocalPublicKeyMismatch) {
+					return getString(R.string.id_mismatch);
+				} else if (result instanceof Failed) {
+					return ((Failed) result).getMessage();
+				}
+				return null;
+			}
+
+			@Override
+			public void onFinished(@Nullable String result) {
+				if (result != null) {
+					SimpleStringAlertDialog.newInstance(R.string.id_scanned, result).show(getSupportFragmentManager(), "scanId");
+				}
+			}
+		};
+
+		backgroundExecutor.get().execute(task);
+	}
+
 	@Override
 	public void onYes(String tag, Object data) {
 		switch (tag) {
@@ -898,7 +952,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 				deleteContact(contactModel);
 				break;
 			case DIALOG_TAG_EXCLUDE_CONTACT:
-				removeContactConfirmed(true, (ContactModel) data);
+				removeContactConfirmed(true);
 				break;
 			case DIALOG_TAG_ADD_CONTACT:
 				unhideContact(this.contact);
@@ -915,7 +969,7 @@ public class ContactDetailActivity extends ThreemaToolbarActivity
 	public void onNo(String tag, Object data) {
 		switch (tag) {
 			case DIALOG_TAG_EXCLUDE_CONTACT:
-				removeContactConfirmed(false, (ContactModel) data);
+				removeContactConfirmed(false);
 				break;
 			case DIALOG_TAG_ADD_CONTACT:
 				finish();
diff --git a/app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt b/app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt
deleted file mode 100644
index 406108ce..00000000
--- a/app/src/main/java/ch/threema/app/activities/ContactDetailViewModel.kt
+++ /dev/null
@@ -1,67 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities
-
-import androidx.lifecycle.DEFAULT_ARGS_KEY
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.ViewModelProvider
-import androidx.lifecycle.viewmodel.initializer
-import androidx.lifecycle.viewmodel.viewModelFactory
-import ch.threema.app.ThreemaApplication
-import ch.threema.data.models.ContactModel
-
-class ContactDetailViewModel(private val contactModel: ContactModel) : ViewModel() {
-    val contact = contactModel.liveData()
-
-    /**
-     * Update the contact's first and last name.
-     */
-    fun updateContactName(firstName: String, lastName: String) {
-        contactModel.setNameFromLocal(firstName, lastName)
-    }
-
-    /**
-     * Whether or not to show the floating edit action button.
-     */
-    fun showEditFAB(): Boolean {
-        // Don't show the edit button for contacts linked to an Android contact
-        return contact.value?.isLinkedToAndroidContact() ?: false
-    }
-
-    companion object {
-        /**
-         * View model must be initialized with the identity.
-         */
-        val Factory: ViewModelProvider.Factory = viewModelFactory {
-            initializer {
-                val modelRepositories = ThreemaApplication.getServiceManager()!!.modelRepositories
-                val bundle = this[DEFAULT_ARGS_KEY]
-                    ?: throw IllegalArgumentException("Bundle not passed to ContactDetailViewModel factory")
-                val identity = bundle.getString(ThreemaApplication.INTENT_DATA_CONTACT)
-                    ?: throw IllegalArgumentException("Identity not passed to ContactDetailViewModel factory")
-                val contactModel = modelRepositories.contacts.getByIdentity(identity)
-                    ?: throw IllegalArgumentException("ContactDetailViewModel: Contact with identity $identity not found")
-                ContactDetailViewModel(contactModel)
-            }
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java b/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java
index 5ec03735..86c88d2c 100644
--- a/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/ContactNotificationsActivity.java
@@ -25,25 +25,25 @@ import android.os.Bundle;
 import android.view.View;
 
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.storage.models.ContactModel;
 
 public class ContactNotificationsActivity extends NotificationsActivity {
-	private String identity;
 	private ContactModel contactModel;
 
 	@Override
 	public void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
 
-		this.identity = getIntent().getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
-		if (TestUtil.isEmptyOrNull(this.identity)) {
+		String identity = getIntent().getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
+		if (TestUtil.isEmptyOrNull(identity)) {
 			finish();
 			return;
 		}
 
 		this.contactModel = contactService.getByIdentity(identity);
-		this.uid = contactService.getUniqueIdString(contactModel);
+		this.uid = ContactUtil.getUniqueIdString(identity);
 
 		refreshSettings();
 	}
diff --git a/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java b/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java
index 34afecb6..7743700e 100644
--- a/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/DirectoryActivity.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.activities;
 
-import static ch.threema.app.ui.DirectoryDataSource.MIN_SEARCH_STRING_LENGTH;
-
 import android.animation.LayoutTransition;
 import android.annotation.SuppressLint;
 import android.content.Intent;
@@ -38,18 +36,6 @@ import android.view.View;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import androidx.annotation.ColorInt;
-import androidx.annotation.IntDef;
-import androidx.annotation.MainThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-import androidx.lifecycle.LiveData;
-import androidx.paging.LivePagedListBuilder;
-import androidx.paging.PagedList;
-import androidx.recyclerview.widget.DefaultItemAnimator;
-import androidx.recyclerview.widget.LinearLayoutManager;
-
 import com.google.android.material.chip.Chip;
 import com.google.android.material.chip.ChipGroup;
 import com.google.android.material.progressindicator.LinearProgressIndicator;
@@ -62,24 +48,41 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.List;
 
+import androidx.annotation.ColorInt;
+import androidx.annotation.IntDef;
+import androidx.annotation.MainThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
+import androidx.lifecycle.LiveData;
+import androidx.paging.LivePagedListBuilder;
+import androidx.paging.PagedList;
+import androidx.recyclerview.widget.DefaultItemAnimator;
+import androidx.recyclerview.widget.LinearLayoutManager;
 import ch.threema.app.R;
 import ch.threema.app.adapters.DirectoryAdapter;
-import ch.threema.app.asynctasks.AddContactAsyncTask;
+import ch.threema.app.asynctasks.AddOrUpdateWorkContactBackgroundTask;
 import ch.threema.app.dialogs.MultiChoiceSelectorDialog;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.ui.DirectoryDataSourceFactory;
 import ch.threema.app.ui.DirectoryHeaderItemDecoration;
 import ch.threema.app.ui.EmptyRecyclerView;
 import ch.threema.app.ui.ThreemaSearchView;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.IntentDataUtil;
-import ch.threema.app.utils.LogUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.api.work.WorkDirectoryCategory;
 import ch.threema.domain.protocol.api.work.WorkDirectoryContact;
 import ch.threema.domain.protocol.api.work.WorkOrganization;
 
+import static ch.threema.app.ui.DirectoryDataSource.MIN_SEARCH_STRING_LENGTH;
+
 public class DirectoryActivity extends ThreemaToolbarActivity implements ThreemaSearchView.OnQueryTextListener, MultiChoiceSelectorDialog.SelectorDialogClickListener {
     private static final Logger logger = LoggingUtil.getThreemaLogger("DirectoryActivity");
 
@@ -95,8 +98,13 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
     private static final int EMPTY_STATE_SEARCHING = 1;
     private static final int EMPTY_STATE_RESULTS = 2;
 
-    private ContactService contactService;
-    private boolean sortByFirstName;
+	private ContactService contactService;
+	private UserService userService;
+	private ContactModelRepository contactModelRepository;
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
+
+	private boolean sortByFirstName;
 
     private DirectoryAdapter directoryAdapter;
     private DirectoryDataSourceFactory directoryDataSourceFactory;
@@ -176,12 +184,14 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
             updateToolbarTitle(getString(R.string.directory_title));
         }
 
-        try {
-            this.contactService = serviceManager.getContactService();
-        } catch (Exception e) {
-            LogUtil.exception(e, this);
-            return false;
-        }
+		try {
+			this.contactService = serviceManager.getContactService();
+		} catch (Exception e) {
+			logger.error("Could not get contact service", e);
+			return false;
+		}
+		this.userService = serviceManager.getUserService();
+		this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
 
         if (preferenceService == null) {
             return false;
@@ -229,11 +239,11 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
                 launchContact(workDirectoryContact, position);
             }
 
-            @Override
-            public void onAdd(WorkDirectoryContact workDirectoryContact, final int position) {
-                addContact(workDirectoryContact, () -> directoryAdapter.notifyItemChanged(position));
-            }
-        });
+			@Override
+			public void onAdd(WorkDirectoryContact workDirectoryContact, final int position) {
+				addContact(workDirectoryContact, () -> directoryAdapter.notifyItemChanged(position));
+			}
+		});
 
         // initial page size
         PagedList.Config config = new PagedList.Config.Builder().setPageSize(API_DIRECTORY_PAGE_SIZE).build();
@@ -348,32 +358,38 @@ public class DirectoryActivity extends ThreemaToolbarActivity implements Threema
         startActivity(intent);
     }
 
-    private void launchContact(final WorkDirectoryContact workDirectoryContact, final int position) {
-        if (workDirectoryContact.threemaId != null) {
-            if (contactService.getByIdentity(workDirectoryContact.threemaId) == null) {
-                addContact(workDirectoryContact, () -> {
-                    openContact(workDirectoryContact.threemaId);
-                    directoryAdapter.notifyItemChanged(position);
-                });
-            } else if (workDirectoryContact.threemaId.equalsIgnoreCase(contactService.getMe().getIdentity())) {
-                Toast.makeText(this, R.string.me_myself_and_i, Toast.LENGTH_LONG).show();
-            } else {
-                openContact(workDirectoryContact.threemaId);
-            }
-        } else {
-            Toast.makeText(this, R.string.contact_not_found, Toast.LENGTH_LONG).show();
-        }
-    }
-
-    private void addContact(final WorkDirectoryContact workDirectoryContact, Runnable runAfter) {
+	private void launchContact(final WorkDirectoryContact workDirectoryContact, final int position) {
+		if (workDirectoryContact.threemaId != null) {
+			if (contactService.getByIdentity(workDirectoryContact.threemaId) == null) {
+				addContact(workDirectoryContact, () -> {
+					openContact(workDirectoryContact.threemaId);
+					directoryAdapter.notifyItemChanged(position);
+				});
+			} else if (workDirectoryContact.threemaId.equalsIgnoreCase(contactService.getMe().getIdentity())) {
+				Toast.makeText(this, R.string.me_myself_and_i, Toast.LENGTH_LONG).show();
+			} else {
+				openContact(workDirectoryContact.threemaId);
+			}
+		} else {
+			Toast.makeText(this, R.string.contact_not_found, Toast.LENGTH_LONG).show();
+		}
+	}
+
+	private void addContact(final WorkDirectoryContact workDirectoryContact, Runnable runAfter) {
         logger.info("Add new work contact");
-        new AddContactAsyncTask(
-            workDirectoryContact.firstName,
-            workDirectoryContact.lastName,
-            workDirectoryContact.threemaId,
-            true,
-            runAfter).execute();
-    }
+		backgroundExecutor.get().execute(
+			new AddOrUpdateWorkContactBackgroundTask(
+				workDirectoryContact,
+				userService.getIdentity(),
+				contactModelRepository
+			) {
+				@Override
+				public void runAfter(ContactModel contactModel) {
+					runAfter.run();
+				}
+			}
+		);
+	}
 
     private DirectoryHeaderItemDecoration.HeaderCallback getSectionCallback() {
         return new DirectoryHeaderItemDecoration.HeaderCallback() {
diff --git a/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java b/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java
index 4c80f1da..0e53a24c 100644
--- a/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/GroupDetailActivity.java
@@ -230,9 +230,9 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			if (this.shouldHandleChange(contactModel.getIdentity())) {
-				this.onModified(contactModel.getIdentity());
+		public void onAvatarChanged(final @NonNull String identity) {
+			if (this.shouldHandleChange(identity)) {
+				this.onModified(identity);
 			}
 		}
 
@@ -263,12 +263,12 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			resumePauseHandler.runOnActive(RUN_ON_ACTIVE_RELOAD, runIfActiveUpdate);
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String identity) {
 			if (identity.equals(myIdentity)) {
 				finish();
 			} else {
@@ -277,7 +277,7 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String identity) {
 			if (identity.equals(myIdentity)) {
 				finish();
 			} else {
@@ -482,7 +482,7 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 
 	private void setupAdapter() throws MasterKeyLockedException, FileSystemNotPresentException {
 		Runnable onCloneGroupRunnable = null;
-		if (groupService.isOrphanedGroup(groupModel) && groupService.getOtherMemberCount(groupModel) > 0) {
+		if (groupService.isOrphanedGroup(groupModel) && groupService.countMembersWithoutUser(groupModel) > 0) {
 			onCloneGroupRunnable = this::showCloneDialog;
 		}
 
@@ -597,7 +597,7 @@ public class GroupDetailActivity extends GroupEditActivity implements SelectorDi
 
 			boolean isMember = groupService.isGroupMember(groupModel);
 			boolean isCreator = groupService.isGroupCreator(groupModel);
-			boolean hasOtherMembers = groupService.getOtherMemberCount(groupModel) > 0;
+			boolean hasOtherMembers = groupService.countMembersWithoutUser(groupModel) > 0;
 
 			// The clone menu only makes sense if at least one other member is present
 			cloneMenu.setVisible(hasOtherMembers);
diff --git a/app/src/main/java/ch/threema/app/activities/HomeActivity.java b/app/src/main/java/ch/threema/app/activities/HomeActivity.java
index 4e3d8ae5..ff8ab415 100644
--- a/app/src/main/java/ch/threema/app/activities/HomeActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/HomeActivity.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.activities;
 
-import static ch.threema.app.services.ConversationTagServiceImpl.FIXED_TAG_UNREAD;
-
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.BroadcastReceiver;
@@ -52,21 +50,6 @@ import android.view.Window;
 import android.widget.ImageView;
 import android.widget.Toast;
 
-import androidx.activity.result.ActivityResultLauncher;
-import androidx.activity.result.contract.ActivityResultContracts;
-import androidx.annotation.AnyThread;
-import androidx.annotation.ColorInt;
-import androidx.annotation.IdRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-import androidx.appcompat.widget.AppCompatImageView;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentTransaction;
-import androidx.lifecycle.LifecycleOwner;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-
 import com.google.android.material.appbar.MaterialToolbar;
 import com.google.android.material.badge.BadgeDrawable;
 import com.google.android.material.badge.ExperimentalBadgeUtils;
@@ -87,12 +70,31 @@ import java.util.Set;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.stream.Collectors;
 
+import androidx.activity.result.ActivityResultLauncher;
+import androidx.activity.result.contract.ActivityResultContracts;
+import androidx.annotation.AnyThread;
+import androidx.annotation.ColorInt;
+import androidx.annotation.IdRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
+import androidx.appcompat.widget.AppCompatImageView;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentTransaction;
+import androidx.lifecycle.LifecycleOwner;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
 import ch.threema.app.BuildFlavor;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.wizard.WizardBaseActivity;
 import ch.threema.app.activities.wizard.WizardStartActivity;
 import ch.threema.app.archive.ArchiveActivity;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactCreated;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.backuprestore.csv.BackupService;
 import ch.threema.app.backuprestore.csv.RestoreService;
 import ch.threema.app.dialogs.GenericAlertDialog;
@@ -100,7 +102,6 @@ import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.SMSVerificationDialog;
 import ch.threema.app.dialogs.ShowOnceDialog;
 import ch.threema.app.dialogs.SimpleStringAlertDialog;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.fragments.ContactsSectionFragment;
 import ch.threema.app.fragments.MessageSectionFragment;
@@ -124,19 +125,20 @@ import ch.threema.app.push.PushService;
 import ch.threema.app.qrscanner.activity.BaseQrScannerActivity;
 import ch.threema.app.routines.CheckLicenseRoutine;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.ContactServiceImpl;
 import ch.threema.app.services.ConversationService;
 import ch.threema.app.services.ConversationTagService;
 import ch.threema.app.services.DeviceService;
 import ch.threema.app.services.FileService;
 import ch.threema.app.services.LockAppService;
 import ch.threema.app.services.MessageService;
-import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.services.PassphraseService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.ThreemaPushService;
 import ch.threema.app.services.UpdateSystemService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.services.license.LicenseService;
+import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.tasks.ApplicationUpdateStepsTask;
 import ch.threema.app.threemasafe.ThreemaSafeMDMConfig;
 import ch.threema.app.threemasafe.ThreemaSafeService;
@@ -150,9 +152,11 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ConnectionIndicatorUtil;
 import ch.threema.app.utils.DialogUtil;
 import ch.threema.app.utils.IntentDataUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.PowermanagerUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.groupcall.GroupCallDescription;
 import ch.threema.app.voip.groupcall.GroupCallManager;
 import ch.threema.app.voip.groupcall.GroupCallObserver;
@@ -160,10 +164,12 @@ import ch.threema.app.voip.groupcall.sfu.GroupCallController;
 import ch.threema.app.voip.services.VoipCallService;
 import ch.threema.app.webclient.activities.SessionsActivity;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.api.LinkMobileNoException;
-import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.protocol.connection.ConnectionState;
 import ch.threema.domain.protocol.connection.ConnectionStateListener;
+import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.localcrypto.MasterKey;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.models.AbstractMessageModel;
@@ -172,6 +178,8 @@ import ch.threema.storage.models.ConversationModel;
 import ch.threema.storage.models.MessageState;
 import ch.threema.storage.models.TagModel;
 
+import static ch.threema.app.services.ConversationTagServiceImpl.FIXED_TAG_UNREAD;
+
 public class HomeActivity extends ThreemaAppCompatActivity implements
 	SMSVerificationDialog.SMSVerificationDialogCallback,
 	GenericAlertDialog.DialogClickListener,
@@ -218,6 +226,8 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 	private NotificationService notificationService;
 	private UserService userService;
 	private ContactService contactService;
+	private ContactModelRepository contactModelRepository;
+	private APIConnector apiConnector;
 	private LockAppService lockAppService;
 	private PreferenceService preferenceService;
 	private ConversationService conversationService;
@@ -225,6 +235,9 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 
     private @Nullable IdentityPopup identityPopup = null;
 
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
+
 	private enum UnsentMessageAction {
 		ADD,
 		REMOVE,
@@ -778,7 +791,7 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 	}
 
 	private void showWhatsNew() {
-		final boolean skipWhatsNew = false; // set this to false if you want to show a What's New screen
+		final boolean skipWhatsNew = true; // set this to false if you want to show a What's New screen
 
 		if (preferenceService != null) {
 			if (!preferenceService.isLatestVersion(this)) {
@@ -1058,6 +1071,8 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 			} catch (Exception e) {
 				//
 			}
+			this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+			this.apiConnector = serviceManager.getAPIConnector();
 
 			if (preferenceService == null || notificationService == null || userService == null) {
 				finish();
@@ -1949,56 +1964,66 @@ public class HomeActivity extends ThreemaAppCompatActivity implements
 			return;
 		}
 
-		new AsyncTask<Void, Void, Exception>() {
-			ContactModel newContactModel;
-
-			@Override
-			protected void onPreExecute() {
-				GenericProgressDialog.newInstance(R.string.threema_channel, R.string.please_wait).show(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY);
-			}
-
-			@Override
-			protected Exception doInBackground(Void... params) {
-				try {
-					newContactModel = contactService.createContactByIdentity(THREEMA_CHANNEL_IDENTITY, true);
-				} catch (Exception e) {
-					return e;
+		backgroundExecutor.get().execute(
+			new BasicAddOrUpdateContactBackgroundTask(
+				THREEMA_CHANNEL_IDENTITY,
+				ContactModel.AcquaintanceLevel.DIRECT,
+				userService.getIdentity(),
+				apiConnector,
+				contactModelRepository,
+				AddContactRestrictionPolicy.IGNORE,
+				this,
+				ContactServiceImpl.THREEMA_PUBLIC_KEY
+			) {
+				@Override
+				public void onBefore() {
+					GenericProgressDialog.newInstance(R.string.threema_channel, R.string.please_wait).show(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY);
 				}
-				return null;
-			}
 
-			@Override
-			protected void onPostExecute(Exception exception) {
-				DialogUtil.dismissDialog(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY, true);
-
-				if (exception == null || exception instanceof EntryAlreadyExistsException) {
-					launchThreemaChannelChat();
+				@Override
+				public void onFinished(@NonNull ContactResult result) {
+					DialogUtil.dismissDialog(getSupportFragmentManager(), THREEMA_CHANNEL_IDENTITY, true);
+
+					if (result instanceof ContactAvailable) {
+						// In case the contact has been successfully created or it has been
+						// modified, already verified, or already exists, the threema channel chat
+						// is launched.
+						launchThreemaChannelChat();
+
+						// Send initial messages to threema channel only if the threema channel has
+						// been newly created as a contact and did not exist before.
+						if (result instanceof ContactCreated) {
+							new Thread(() -> {
+								try {
+									ContactModel threemaChannelModel = contactService.getByIdentity(THREEMA_CHANNEL_IDENTITY);
+									if (threemaChannelModel == null) {
+										logger.error("Threema channel model is null after adding it");
+										return;
+									}
 
-					if (exception == null) {
-						new Thread(() -> {
-							try {
-								MessageReceiver receiver = contactService.createReceiver(newContactModel);
-								if (!getResources().getConfiguration().locale.getLanguage().startsWith("de") && !getResources().getConfiguration().locale.getLanguage().startsWith("gsw")) {
+									MessageReceiver<?> receiver = contactService.createReceiver(threemaChannelModel);
+									if (!getResources().getConfiguration().locale.getLanguage().startsWith("de") && !getResources().getConfiguration().locale.getLanguage().startsWith("gsw")) {
+										Thread.sleep(1000);
+										messageService.sendText("en", receiver);
+										Thread.sleep(500);
+									}
 									Thread.sleep(1000);
-									messageService.sendText("en", receiver);
-									Thread.sleep(500);
+									messageService.sendText(THREEMA_CHANNEL_START_NEWS_COMMAND, receiver);
+									Thread.sleep(1500);
+									messageService.sendText(ConfigUtils.isWorkBuild() ? THREEMA_CHANNEL_WORK_COMMAND : THREEMA_CHANNEL_START_ANDROID_COMMAND, receiver);
+									Thread.sleep(1500);
+									messageService.sendText(THREEMA_CHANNEL_INFO_COMMAND, receiver);
+								} catch (Exception e) {
+									//
 								}
-								Thread.sleep(1000);
-								messageService.sendText(THREEMA_CHANNEL_START_NEWS_COMMAND, receiver);
-								Thread.sleep(1500);
-								messageService.sendText(ConfigUtils.isWorkBuild() ? THREEMA_CHANNEL_WORK_COMMAND : THREEMA_CHANNEL_START_ANDROID_COMMAND, receiver);
-								Thread.sleep(1500);
-								messageService.sendText(THREEMA_CHANNEL_INFO_COMMAND, receiver);
-							} catch (Exception e) {
-								//
-							}
-						}).start();
+							}).start();
+						}
+					} else {
+						Toast.makeText(HomeActivity.this, R.string.internet_connection_required, Toast.LENGTH_LONG).show();
 					}
-				} else {
-					Toast.makeText(HomeActivity.this, R.string.internet_connection_required, Toast.LENGTH_LONG).show();
 				}
 			}
-		}.execute();
+		);
 	}
 
 	private void launchThreemaChannelChat() {
diff --git a/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java b/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java
index ccf87e3b..0531ac39 100644
--- a/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/ImagePaintActivity.java
@@ -903,7 +903,7 @@ public class ImagePaintActivity extends ThreemaToolbarActivity implements Generi
 
 			@Override
 			protected void onPostExecute(List<FaceItem> faceItemList) {
-				if (faceItemList != null && faceItemList.size() > 0) {
+				if (faceItemList != null && !faceItemList.isEmpty()) {
 					motionView.post(() -> {
 						for (FaceItem faceItem : faceItemList) {
 							Layer layer = new Layer();
@@ -1703,9 +1703,6 @@ public class ImagePaintActivity extends ThreemaToolbarActivity implements Generi
 		finishWithoutChanges();
 	}
 
-	@Override
-	public void onNo(String tag, Object data) {}
-
 	/**
 	 * Finish activity with changes (result ok)
 	 */
diff --git a/app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt b/app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt
deleted file mode 100644
index faeff5dd..00000000
--- a/app/src/main/java/ch/threema/app/activities/MessageDetailsActivity.kt
+++ /dev/null
@@ -1,268 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities
-
-import android.content.Intent
-import android.net.Uri
-import android.os.Bundle
-import android.view.ActionMode
-import android.view.Menu
-import android.view.MenuItem
-import androidx.activity.viewModels
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxSize
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.runtime.getValue
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.platform.ComposeView
-import androidx.compose.ui.platform.ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed
-import androidx.compose.ui.unit.dp
-import androidx.lifecycle.compose.collectAsStateWithLifecycle
-import androidx.lifecycle.viewmodel.compose.viewModel
-import androidx.preference.PreferenceManager
-import ch.threema.app.BuildConfig
-import ch.threema.app.R
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.compose.edithistory.EditHistoryList
-import ch.threema.app.compose.edithistory.EditHistoryViewModel
-import ch.threema.app.compose.message.CompleteMessageBubble
-import ch.threema.app.compose.message.MessageDetailsListBox
-import ch.threema.app.compose.message.MessageTimestampsListBox
-import ch.threema.app.compose.theme.ThreemaTheme
-import ch.threema.app.dialogs.GenericAlertDialog.DialogClickListener
-import ch.threema.app.listeners.EditMessageListener
-import ch.threema.app.listeners.MessageDeletedForAllListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.ui.CustomTextSelectionCallback
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.IntentDataUtil
-import ch.threema.app.utils.LinkifyUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.storage.models.AbstractMessageModel
-import com.google.android.material.appbar.MaterialToolbar
-import org.slf4j.Logger
-
-class MessageDetailsActivity : ThreemaToolbarActivity(), DialogClickListener {
-
-    private companion object {
-        val logger: Logger = LoggingUtil.getThreemaLogger("MessageDetailsActivity")
-
-        const val CONTEXT_MENU_FORWARD = 600
-        const val CONTEXT_MENU_GROUP = 22200
-    }
-
-    private lateinit var toolbar: MaterialToolbar
-
-    private val viewModel: MessageDetailsViewModel by viewModels<MessageDetailsViewModel> {
-        MessageDetailsViewModel.provideFactory(
-            IntentDataUtil.getAbstractMessageId(intent),
-            IntentDataUtil.getAbstractMessageType(intent),
-            serviceManager.userService.identity,
-        )
-    }
-
-    private val onEditMessageListener = object : EditMessageListener {
-        override fun onEdit(message: AbstractMessageModel) {
-            if (message.uid == viewModel.uiState.value.message.uid) {
-                viewModel.refreshMessage(message)
-            }
-        }
-    }
-
-    private val onDeleteMessageListener = object : MessageDeletedForAllListener {
-        override fun onDeletedForAll(message: AbstractMessageModel) {
-            if (message.uid == viewModel.uiState.value.message.uid) {
-                viewModel.refreshMessage(message)
-            }
-        }
-    }
-
-    private val textSelectionCallback: CustomTextSelectionCallback = object : CustomTextSelectionCallback() {
-        override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
-            return true
-        }
-
-        override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
-            menu.removeGroup(CONTEXT_MENU_GROUP)
-            try {
-                if (textView != null) {
-                    menu.add(CONTEXT_MENU_GROUP, CONTEXT_MENU_FORWARD, 200, R.string.forward_text)
-                }
-            } catch (e: Exception) {
-                // some MIUI devices crash when attempting to add a context menu
-                logger.error("Error adding context menu (Xiaomi?)", e)
-            }
-            return true
-        }
-
-        override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
-            when (item.itemId) {
-                CONTEXT_MENU_FORWARD -> forwardText()
-                else -> return false
-            }
-            return true
-        }
-
-        override fun onDestroyActionMode(mode: ActionMode) {
-            // we ignore this
-        }
-
-        private fun forwardText() {
-            val textView = textView ?: return
-            val text = textView.text
-
-            if (text.isNotEmpty()) {
-                val start = textView.selectionStart
-                val end = textView.selectionEnd
-
-                val body = text.subSequence(start, end).toString()
-                val intent = Intent(
-                    this@MessageDetailsActivity,
-                    RecipientListBaseActivity::class.java
-                )
-                intent.setType("text/plain")
-                intent.setAction(Intent.ACTION_SEND)
-                intent.putExtra(Intent.EXTRA_TEXT, body)
-                intent.putExtra(ThreemaApplication.INTENT_DATA_IS_FORWARD, true)
-                startActivity(intent)
-            }
-        }
-    }
-
-    override fun getLayoutResource(): Int {
-        return R.layout.activity_message_details
-    }
-
-    override fun initActivity(savedInstanceState: Bundle?): Boolean {
-        theme.applyStyle(ThreemaApplication.getServiceManager()!!.preferenceService.fontStyle, true)
-
-        if (!super.initActivity(savedInstanceState)) {
-            return false
-        }
-
-        initToolbar()
-        initScreenContent()
-
-        ListenerManager.editMessageListener.add(onEditMessageListener)
-        ListenerManager.messageDeletedForAllListener.add(onDeleteMessageListener)
-
-        return true
-    }
-
-    private fun initScreenContent() {
-        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext())
-        val shouldUseDynamicColors = sharedPreferences.getBoolean("pref_dynamic_color", false)
-
-        val editHistoryComposeView = findViewById<ComposeView>(R.id.message_details_compose_view)
-        editHistoryComposeView.setViewCompositionStrategy(DisposeOnViewTreeLifecycleDestroyed)
-
-        editHistoryComposeView.setContent {
-            ThreemaTheme(
-                dynamicColor = shouldUseDynamicColors
-            ) {
-                val uiState: ChatMessageDetailsUiState by viewModel.uiState.collectAsStateWithLifecycle()
-                val messageModel: MessageUiModel = uiState.message
-                val editHistoryViewModel: EditHistoryViewModel = viewModel(
-                    key = messageModel.uid,
-                    factory = EditHistoryViewModel.provideFactory(messageModel.uid)
-                )
-                val editHistoryUiState by editHistoryViewModel.editHistoryUiState.collectAsStateWithLifecycle()
-
-                EditHistoryList(
-                    modifier = Modifier
-                        .fillMaxSize()
-                        .padding(horizontal = 16.dp),
-                    editHistoryUiState = editHistoryUiState,
-                    isOutbox = messageModel.isOutbox,
-                    shouldMarkupText = uiState.shouldMarkupText,
-                    headerContent = {
-                        Column {
-                            Spacer(modifier = Modifier.height(16.dp))
-                            CompleteMessageBubble(
-                                message = messageModel,
-                                shouldMarkupText = uiState.shouldMarkupText,
-                                isTextSelectable = true,
-                                textSelectionCallback = textSelectionCallback
-                            )
-                        }
-                    },
-                    footerContent = if (BuildConfig.SHOW_TIMESTAMPS_AND_TECHNICAL_INFO_IN_MESSAGE_DETAILS) {
-                        {
-                            Column {
-                                Spacer(modifier = Modifier.height(8.dp))
-                                MessageTimestampsListBox(
-                                    messageTimestampsUiModel = messageModel.messageTimestampsUiModel,
-                                    isOutbox = messageModel.isOutbox
-                                )
-                                Spacer(modifier = Modifier.height(16.dp))
-                                MessageDetailsListBox(
-                                    messageDetailsUiModel = messageModel.messageDetailsUiModel,
-                                    isOutbox = messageModel.isOutbox
-                                )
-                                Spacer(modifier = Modifier.height(24.dp))
-                            }
-                        }
-                    } else {
-                        {}
-                    }
-                )
-            }
-        }
-    }
-
-    private fun initToolbar() {
-        toolbar = findViewById(R.id.material_toolbar)
-        toolbar.setNavigationOnClickListener { finish() }
-        toolbar.setOnMenuItemClickListener { item: MenuItem ->
-            if (item.itemId == R.id.enable_formatting) {
-                onToggleFormattingClicked(item)
-                return@setOnMenuItemClickListener true
-            }
-            false
-        }
-        toolbar.setTitle(getString(R.string.message_log_title))
-        ConfigUtils.addIconsToOverflowMenu(toolbar.getMenu())
-    }
-
-    private fun onToggleFormattingClicked(item: MenuItem) {
-        item.setChecked(!item.isChecked)
-        viewModel.markupText(item.isChecked)
-    }
-
-    override fun onDestroy() {
-        ListenerManager.editMessageListener.remove(onEditMessageListener)
-        ListenerManager.messageDeletedForAllListener.remove(onDeleteMessageListener)
-        super.onDestroy()
-    }
-
-    override fun onYes(tag: String, data: Any) {
-        if (LinkifyUtil.DIALOG_TAG_CONFIRM_LINK == tag) {
-            LinkifyUtil.getInstance().openLink(data as Uri, null, this)
-        }
-    }
-
-    override fun onNo(tag: String, data: Any) {
-        //
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/activities/MessageDetailsViewModel.kt b/app/src/main/java/ch/threema/app/activities/MessageDetailsViewModel.kt
deleted file mode 100644
index 71213256..00000000
--- a/app/src/main/java/ch/threema/app/activities/MessageDetailsViewModel.kt
+++ /dev/null
@@ -1,267 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities
-
-import androidx.annotation.DrawableRes
-import androidx.annotation.StringRes
-import androidx.lifecycle.SavedStateHandle
-import androidx.lifecycle.createSavedStateHandle
-import androidx.lifecycle.viewmodel.initializer
-import androidx.lifecycle.viewmodel.viewModelFactory
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.services.MessageService
-import ch.threema.app.utils.QuoteUtil
-import ch.threema.app.utils.StateBitmapUtil
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.DistributionListMessageModel
-import ch.threema.storage.models.GroupMessageModel
-import ch.threema.storage.models.MessageState
-import ch.threema.storage.models.MessageType
-import kotlinx.coroutines.flow.MutableStateFlow
-import kotlinx.coroutines.flow.StateFlow
-import kotlinx.coroutines.flow.update
-import java.util.Date
-
-class MessageDetailsViewModel(
-    savedStateHandle: SavedStateHandle,
-    messageService: MessageService,
-    private val myIdentity: String,
-) : StateFlowViewModel() {
-
-    companion object {
-
-        private const val MESSAGE_ID = "messageId"
-        private const val MESSAGE_TYPE = "messageType"
-
-        fun provideFactory(
-            messageId: Int,
-            messageType: String?,
-            myIdentity: String,
-        ) = viewModelFactory {
-            initializer {
-                MessageDetailsViewModel(
-                    this.createSavedStateHandle().apply {
-                        set(MESSAGE_ID, messageId)
-                        set(MESSAGE_TYPE, messageType)
-                    },
-                    ThreemaApplication.requireServiceManager().messageService,
-                    myIdentity,
-                )
-            }
-        }
-    }
-
-    private val _uiState: MutableStateFlow<ChatMessageDetailsUiState> = let {
-        val messageId = checkNotNull(savedStateHandle[MESSAGE_ID]) as Int
-        val messageType = checkNotNull(savedStateHandle[MESSAGE_TYPE]) as String
-        val message = messageService.getMessageModelFromId(messageId, messageType)
-        MutableStateFlow(
-            ChatMessageDetailsUiState(message.toUiModel(myIdentity), true)
-        )
-    }
-    val uiState: StateFlow<ChatMessageDetailsUiState> = _uiState.stateInViewModel(initialValue = _uiState.value)
-
-    fun refreshMessage(updatedMessage: AbstractMessageModel) {
-        _uiState.update { it.copy(message = updatedMessage.toUiModel(myIdentity)) }
-    }
-
-    fun markupText(value: Boolean) {
-        _uiState.update { it.copy(shouldMarkupText = value) }
-    }
-}
-
-data class ChatMessageDetailsUiState(
-    val message: MessageUiModel,
-    val shouldMarkupText: Boolean
-)
-
-// TODO(ANDR-3195): Move MessageModel mappings from ChatMessageDetailsViewModel to data models
-data class MessageUiModel(
-    val uid: String,
-    val text: String,
-    val createdAt: Date,
-    val editedAt: Date?,
-    val isDeleted: Boolean,
-    val isOutbox: Boolean,
-    val ackUiModel: AckUiModel?,
-    @DrawableRes val deliveryIconRes: Int?,
-    @StringRes val deliveryIconContentDescriptionRes: Int?,
-    val messageTimestampsUiModel: MessageTimestampsUiModel,
-    val messageDetailsUiModel: MessageDetailsUiModel
-)
-
-enum class UserReaction {
-    REACTED,
-    NONE,
-}
-
-enum class ContactAckDecState {
-    ACK,
-    DEC,
-    NONE,
-}
-
-class GroupAckDecState(val count: Int, val userReaction: UserReaction)
-
-sealed interface AckUiModel
-
-data class ContactAckUiModel(
-    val ackDecState: ContactAckDecState,
-) : AckUiModel
-
-data class GroupAckUiModel(
-    val ackState: GroupAckDecState,
-    val decState: GroupAckDecState,
-) : AckUiModel
-
-data class MessageTimestampsUiModel(
-    val createdAt: Date? = null,
-    val sentAt: Date? = null,
-    val receivedAt: Date? = null,
-    val deliveredAt: Date? = null,
-    val readAt: Date? = null,
-    val modifiedAt: Date? = null,
-    val editedAt: Date? = null,
-    val deletedAt: Date? = null
-)
-
-data class MessageDetailsUiModel(
-    val messageId: String? = null,
-    val mimeType: String? = null,
-    val fileSizeInBytes: Long? = null,
-    val pfsState: ForwardSecurityMode? = null
-)
-
-fun AbstractMessageModel.toUiModel(myIdentity: String) = MessageUiModel(
-    uid = this.uid,
-    text = QuoteUtil.getMessageBody(this, false) ?: "",
-    createdAt = this.createdAt,
-    editedAt = this.editedAt,
-    isDeleted = this.isDeleted,
-    isOutbox = this.isOutbox,
-    deliveryIconRes = StateBitmapUtil.getInstance()?.getStateDrawable(this.state),
-    deliveryIconContentDescriptionRes = StateBitmapUtil.getInstance()?.getStateDescription(this.state),
-    ackUiModel = this.getAckUiModel(myIdentity),
-    messageTimestampsUiModel = this.toMessageTimestampsUiModel(),
-    messageDetailsUiModel = this.toMessageDetailsUiModel()
-)
-
-/**
- *  @return Only returns an instance of [AckUiModel] if there is at least one ack/dec for this [AbstractMessageModel].
- */
-private fun AbstractMessageModel.getAckUiModel(myIdentity: String): AckUiModel? = let {
-    if (this is GroupMessageModel) {
-        val ackStates = groupMessageStates?.filter { groupMessageState -> groupMessageState.value == MessageState.USERACK.name }
-        val decStates = groupMessageStates?.filter { groupMessageState -> groupMessageState.value == MessageState.USERDEC.name }
-
-        val ackUserReaction = if (ackStates?.containsKey(myIdentity) == true) {
-            UserReaction.REACTED
-        } else {
-            UserReaction.NONE
-        }
-        val decUserReaction = if (decStates?.containsKey(myIdentity) == true) {
-            UserReaction.REACTED
-        } else {
-            UserReaction.NONE
-        }
-        return@let if (ackUserReaction != UserReaction.NONE || decUserReaction != UserReaction.NONE) {
-            GroupAckUiModel(
-                ackState = GroupAckDecState(ackStates?.size ?: 0, ackUserReaction),
-                decState = GroupAckDecState(decStates?.size ?: 0, decUserReaction),
-            )
-        } else {
-            null
-        }
-    } else {
-        val contactAckDecState = when (this.state) {
-            MessageState.USERACK -> ContactAckDecState.ACK
-            MessageState.USERDEC -> ContactAckDecState.DEC
-            else -> return@let null
-        }
-        ContactAckUiModel(contactAckDecState)
-    }
-}
-
-fun AbstractMessageModel?.toMessageTimestampsUiModel(): MessageTimestampsUiModel {
-    if (this == null) {
-        return MessageTimestampsUiModel()
-    }
-    if (this.isStatusMessage) {
-        return MessageTimestampsUiModel(createdAt = this.createdAt)
-    } else if (this.type == MessageType.GROUP_CALL_STATUS) {
-        return MessageTimestampsUiModel(sentAt = this.createdAt, deliveredAt = if (!this.isOutbox) this.deliveredAt else null)
-    }
-
-    return if (this.isOutbox) {
-        val shouldShowAdditionalTimestamps = this.state != MessageState.SENT && !(this.type == MessageType.BALLOT && this is GroupMessageModel)
-
-        val shouldShowPostedAt =
-            (this.state != MessageState.SENDING && this.state != MessageState.SENDFAILED && this.state != MessageState.FS_KEY_MISMATCH && this.state != MessageState.PENDING)
-                || this.type == MessageType.BALLOT
-
-        val shouldShowModifiedAt = !(this.state == MessageState.READ && this.modifiedAt == this.readAt)
-            && !(this.state == MessageState.DELIVERED && this.modifiedAt == this.deliveredAt)
-
-        MessageTimestampsUiModel(
-            createdAt = this.createdAt,
-            sentAt = if (shouldShowPostedAt) this.postedAt else null,
-            deliveredAt = if (shouldShowAdditionalTimestamps) this.deliveredAt else null,
-            readAt = if (shouldShowAdditionalTimestamps) this.readAt else null,
-            modifiedAt = if (shouldShowAdditionalTimestamps && shouldShowModifiedAt) this.modifiedAt else null,
-            editedAt = this.editedAt,
-            deletedAt = this.deletedAt
-        )
-    } else {
-        MessageTimestampsUiModel(
-            createdAt = this.postedAt,
-            receivedAt = this.createdAt,
-            readAt = if (this.state != MessageState.READ) this.modifiedAt else null,
-            editedAt = this.editedAt,
-            deletedAt = this.deletedAt
-        )
-    }
-}
-
-fun AbstractMessageModel?.toMessageDetailsUiModel(): MessageDetailsUiModel {
-    if (this == null) {
-        return MessageDetailsUiModel()
-    }
-    if (this.isStatusMessage || this.type == MessageType.GROUP_CALL_STATUS) {
-        return MessageDetailsUiModel()
-    }
-    val fileSize: Long? = if (this.type == MessageType.FILE) {
-        this.fileData.fileSize.takeIf { fileSize -> fileSize > 0L }
-    } else {
-        null
-    }
-    val mimeType: String? = if (this.type == MessageType.FILE) this.fileData.mimeType.takeIf(String::isNotBlank) else null
-    val messageId: String? = this.apiMessageId?.takeIf(String::isNotBlank)
-    val pfsState: ForwardSecurityMode? = if (this !is DistributionListMessageModel) this.forwardSecurityMode else null
-
-    return MessageDetailsUiModel(
-        mimeType = mimeType,
-        fileSizeInBytes = fileSize,
-        messageId = messageId,
-        pfsState = pfsState
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.java b/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.java
deleted file mode 100644
index f41d1f33..00000000
--- a/app/src/main/java/ch/threema/app/activities/ProfilePicRecipientsActivity.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities;
-
-import android.os.Bundle;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import ch.threema.app.R;
-import ch.threema.app.services.IdListService;
-import ch.threema.app.utils.LogUtil;
-import ch.threema.storage.models.ContactModel;
-
-public class ProfilePicRecipientsActivity extends MemberChooseActivity {
-	private IdListService profilePicRecipientsService;
-
-	@Override
-	public void onCreate(final Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-	}
-
-	@Override
-	protected boolean initActivity(Bundle savedInstanceState) {
-		if (!super.initActivity(savedInstanceState)) {
-			return false;
-		}
-
-		try {
-			this.profilePicRecipientsService = serviceManager.getProfilePicRecipientsService();
-		} catch (Exception e) {
-			LogUtil.exception(e, this);
-			return false;
-		}
-
-		initData(savedInstanceState);
-
-		return true;
-	}
-
-	@Override
-	protected int getNotice() {
-		return R.string.prefs_sum_receive_profilepics_recipients_list;
-	}
-
-	@Override
-	protected int getMode() {
-		return MODE_PROFILE_PIC_RECIPIENTS;
-	}
-
-	@Override
-	protected void initData(Bundle savedInstanceState) {
-		if (savedInstanceState == null) {
-			String[] ids = profilePicRecipientsService.getAll();
-
-			if (ids != null && ids.length > 0) {
-				preselectedIdentities = new ArrayList<>(Arrays.asList(ids));
-			}
-		}
-
-		updateToolbarTitle(R.string.profile_picture, R.string.title_choose_recipient);
-
-		initList();
-	}
-
-	@Override
-	protected void menuNext(List<ContactModel> selectedContacts) {
-		if (selectedContacts.size() > 0) {
-			List<String> ids = new ArrayList<>(selectedContacts.size());
-
-			for (ContactModel contactModel : selectedContacts) {
-				if (contactModel != null) {
-					ids.add(contactModel.getIdentity());
-				}
-			}
-
-			if (ids.size() > 0) {
-				profilePicRecipientsService.addAll(ids.toArray(new String[ids.size()]));
-				finish();
-				return;
-			}
-		}
-		profilePicRecipientsService.removeAll();
-		finish();
-	}
-
-	@Override
-	protected boolean enableOnBackPressedCallback() {
-		return true;
-	}
-
-	@Override
-	protected void handleOnBackPressed() {
-		this.menuNext(getSelectedContacts());
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java b/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java
index 76a431a9..f0bf10d1 100644
--- a/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/RecipientListBaseActivity.java
@@ -21,12 +21,6 @@
 
 package ch.threema.app.activities;
 
-import static ch.threema.app.activities.SendMediaActivity.MAX_EDITABLE_FILES;
-import static ch.threema.app.fragments.ComposeMessageFragment.MAX_FORWARDABLE_ITEMS;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
-import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
-import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
-
 import android.Manifest;
 import android.annotation.SuppressLint;
 import android.content.ClipData;
@@ -55,22 +49,6 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.widget.Toast;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.annotation.WorkerThread;
-import androidx.appcompat.app.ActionBar;
-import androidx.appcompat.widget.SearchView;
-import androidx.core.app.ActivityCompat;
-import androidx.core.app.TaskStackBuilder;
-import androidx.core.content.ContextCompat;
-import androidx.core.content.pm.ShortcutManagerCompat;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentManager;
-import androidx.fragment.app.FragmentPagerAdapter;
-import androidx.viewpager.widget.ViewPager;
-
 import com.google.android.material.progressindicator.CircularProgressIndicator;
 import com.google.android.material.search.SearchBar;
 import com.google.android.material.snackbar.Snackbar;
@@ -87,6 +65,21 @@ import java.util.List;
 import java.util.concurrent.Executors;
 import java.util.stream.Collectors;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.annotation.WorkerThread;
+import androidx.appcompat.app.ActionBar;
+import androidx.appcompat.widget.SearchView;
+import androidx.core.app.ActivityCompat;
+import androidx.core.app.TaskStackBuilder;
+import androidx.core.content.ContextCompat;
+import androidx.core.content.pm.ShortcutManagerCompat;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentPagerAdapter;
+import androidx.viewpager.widget.ViewPager;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
@@ -94,6 +87,9 @@ import ch.threema.app.actions.LocationMessageSendAction;
 import ch.threema.app.actions.SendAction;
 import ch.threema.app.actions.TextMessageSendAction;
 import ch.threema.app.adapters.FilterableListAdapter;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.dialogs.CancelableHorizontalProgressDialog;
 import ch.threema.app.dialogs.ExpandableTextEntryDialog;
 import ch.threema.app.dialogs.GenericProgressDialog;
@@ -106,6 +102,7 @@ import ch.threema.app.fragments.RecipientListFragment;
 import ch.threema.app.fragments.UserListFragment;
 import ch.threema.app.fragments.WorkUserListFragment;
 import ch.threema.app.messagereceiver.MessageReceiver;
+import ch.threema.app.messagereceiver.SendingPermissionValidationResult;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.ConversationService;
 import ch.threema.app.services.DistributionListService;
@@ -124,14 +121,17 @@ import ch.threema.app.utils.DialogUtil;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.GeoLocationUtil;
 import ch.threema.app.utils.IntentDataUtil;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.NavigationUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShortcutUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.app.messagereceiver.SendingPermissionValidationResult;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.file.FileData;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -142,6 +142,12 @@ import ch.threema.storage.models.data.LocationDataModel;
 import ch.threema.storage.models.data.MessageContentsType;
 import java8.util.concurrent.CompletableFuture;
 
+import static ch.threema.app.activities.SendMediaActivity.MAX_EDITABLE_FILES;
+import static ch.threema.app.fragments.ComposeMessageFragment.MAX_FORWARDABLE_ITEMS;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
+import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
+import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
+
 public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
     CancelableHorizontalProgressDialog.ProgressDialogClickListener,
     ExpandableTextEntryDialog.ExpandableTextEntryDialogClickListener,
@@ -181,12 +187,18 @@ public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
     private final List<Integer> tabs = new ArrayList<>(NUM_FRAGMENTS);
     private boolean isInternallyForwardingMediaFiles = false;
 
-    private GroupService groupService;
-    private ContactService contactService;
-    private ConversationService conversationService;
-    private DistributionListService distributionListService;
-    private MessageService messageService;
-    private FileService fileService;
+	private GroupService groupService;
+	private ContactService contactService;
+	private ConversationService conversationService;
+	private DistributionListService distributionListService;
+	private MessageService messageService;
+	private FileService fileService;
+	private UserService userService;
+	private APIConnector apiConnector;
+	private ContactModelRepository contactModelRepository;
+
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
     private final Runnable copyExternalFilesRunnable = new Runnable() {
         @Override
@@ -276,6 +288,8 @@ public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
             this.distributionListService = serviceManager.getDistributionListService();
             this.messageService = serviceManager.getMessageService();
             this.fileService = serviceManager.getFileService();
+            this.apiConnector = serviceManager.getAPIConnector();
+            this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
             userService = serviceManager.getUserService();
         } catch (Exception e) {
             logger.error("Exception", e);
@@ -838,36 +852,35 @@ public class RecipientListBaseActivity extends ThreemaToolbarActivity implements
         if (contactModel == null) {
             GenericProgressDialog.newInstance(R.string.creating_contact, R.string.please_wait).show(getSupportFragmentManager(), "pro");
 
-            new AsyncTask<Void, Void, Void>() {
-                boolean fail = false;
-                ContactModel newContactModel = null;
-
-                @Override
-                protected Void doInBackground(Void... params) {
-                    try {
-                        newContactModel = contactService.createContactByIdentity(identity, false);
-                    } catch (Exception e) {
-                        fail = true;
-                    }
-                    return null;
-                }
-
-                @Override
-                protected void onPostExecute(Void result) {
-                    DialogUtil.dismissDialog(getSupportFragmentManager(), "pro", true);
-
-                    if (fail) {
-                        View rootView = getWindow().getDecorView().findViewById(android.R.id.content);
-                        Snackbar.make(rootView, R.string.contact_not_found, Snackbar.LENGTH_LONG).show();
-                    } else {
-                        prepareComposeIntent(new ArrayList<>(Collections.singletonList(newContactModel)), false);
-                    }
-                }
-            }.execute();
-        } else {
-            prepareComposeIntent(new ArrayList<>(Collections.singletonList(contactModel)), false);
-        }
-    }
+			backgroundExecutor.get().execute(
+				new BasicAddOrUpdateContactBackgroundTask(
+					identity,
+					ContactModel.AcquaintanceLevel.DIRECT,
+					userService.getIdentity(),
+					apiConnector,
+					contactModelRepository,
+					AddContactRestrictionPolicy.CHECK,
+					RecipientListBaseActivity.this,
+					null
+				) {
+					@Override
+					public void onFinished(ContactResult result) {
+						DialogUtil.dismissDialog(getSupportFragmentManager(), "pro", true);
+
+						ContactModel newContactModel = contactService.getByIdentity(identity);
+						if (newContactModel == null) {
+							View rootView = getWindow().getDecorView().findViewById(android.R.id.content);
+							Snackbar.make(rootView, R.string.contact_not_found, Snackbar.LENGTH_LONG).show();
+						} else {
+							prepareComposeIntent(new ArrayList<>(Collections.singletonList(newContactModel)), false);
+						}
+					}
+				}
+			);
+		} else {
+			prepareComposeIntent(new ArrayList<>(Collections.singletonList(contactModel)), false);
+		}
+	}
 
     @Override
     public boolean onCreateOptionsMenu(Menu menu) {
diff --git a/app/src/main/java/ch/threema/app/activities/StateFlowViewModel.kt b/app/src/main/java/ch/threema/app/activities/StateFlowViewModel.kt
deleted file mode 100644
index 8b0b7ed3..00000000
--- a/app/src/main/java/ch/threema/app/activities/StateFlowViewModel.kt
+++ /dev/null
@@ -1,54 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities
-
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.viewModelScope
-import kotlinx.coroutines.flow.Flow
-import kotlinx.coroutines.flow.SharingStarted
-import kotlinx.coroutines.flow.StateFlow
-import kotlinx.coroutines.flow.WhileSubscribed
-import kotlinx.coroutines.flow.stateIn
-import kotlin.time.Duration
-import kotlin.time.Duration.Companion.seconds
-
-abstract class StateFlowViewModel : ViewModel() {
-
-    /**
-     *  Converts a flow into an immutable state flow of type [T].
-     *
-     *  For the sharingStarted strategy [SharingStarted.WhileSubscribed] is used.
-     *  This has the advantage that the sharing will actually stop, if there
-     *  are no active subscribers after a delay of [stopTimeout]. The default
-     *  value of [stopTimeout] is set to survive a configuration change.
-     */
-    fun <T> Flow<T>.stateInViewModel(
-        initialValue: T,
-        stopTimeout: Duration = 5.seconds
-    ): StateFlow<T> = stateIn(
-        scope = viewModelScope,
-        started = SharingStarted.WhileSubscribed(
-            stopTimeout = stopTimeout
-        ),
-        initialValue = initialValue
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/activities/WorkIntroActivity.kt b/app/src/main/java/ch/threema/app/activities/WorkIntroActivity.kt
deleted file mode 100644
index d4ee5c1d..00000000
--- a/app/src/main/java/ch/threema/app/activities/WorkIntroActivity.kt
+++ /dev/null
@@ -1,122 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.activities
-
-import android.content.Intent
-import android.net.Uri
-import android.os.Bundle
-import android.text.method.LinkMovementMethod
-import android.widget.Button
-import android.widget.TextView
-import android.widget.Toast
-import androidx.core.text.HtmlCompat
-import ch.threema.app.BuildFlavor
-import ch.threema.app.R
-import ch.threema.app.utils.LinkifyUtil
-
-class WorkIntroActivity : ThreemaActivity() {
-
-    companion object {
-        private const val HTML_LINK_FORMAT_TEMPLATE_PREFIX = "<a href='%1\$s'> "
-        private const val HTML_LINK_FORMAT_TEMPLATE_POSTFIX = " </a>"
-    }
-
-    private val loginButton: Button by lazy { findViewById(R.id.work_intro_login_button) }
-    private val consumerStoreButton: Button by lazy { findViewById(R.id.consumer_notice_app_store_button) }
-    private val workInfoLinkTextView: TextView by lazy { findViewById(R.id.work_intro_more_link) }
-
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-
-        setContentView(R.layout.activity_work_intro)
-
-        initLoginButton()
-        initWorkInfoLink()
-        initConsumerStoreButton()
-    }
-
-    private fun initLoginButton() {
-        loginButton.text = getString(R.string.work_intro_login).format(getString(R.string.app_name))
-        loginButton.setOnClickListener {
-            val intent = Intent(this, EnterSerialActivity::class.java)
-            startActivity(intent)
-        }
-    }
-
-    private fun initWorkInfoLink() {
-        val workInfoLinkTemplate = HTML_LINK_FORMAT_TEMPLATE_PREFIX
-            .plus(getString(R.string.work_intro_more_link_text))
-            .plus(HTML_LINK_FORMAT_TEMPLATE_POSTFIX)
-
-        val workInfoLink = getString(R.string.threema_work_url)
-
-        val workInfoHtmlLink = String.format(
-            workInfoLinkTemplate,
-            workInfoLink
-        )
-
-        workInfoLinkTextView.text = HtmlCompat.fromHtml(workInfoHtmlLink, HtmlCompat.FROM_HTML_MODE_COMPACT)
-        workInfoLinkTextView.movementMethod = LinkMovementMethod.getInstance()
-        workInfoLinkTextView.setOnClickListener {
-            LinkifyUtil.getInstance().openLink(Uri.parse(workInfoLink), null, this)
-        }
-    }
-
-    private fun initConsumerStoreButton() {
-        val appStoreText: String
-        val onButtonClick: () -> Unit
-
-        if (BuildFlavor.current.licenseType == BuildFlavor.LicenseType.HMS_WORK) {
-            appStoreText = getString(R.string.consumer_notice_appgallery_link_description)
-            onButtonClick = { openConsumerAppInHuaweiAppGallery() }
-        } else {
-            appStoreText = getString(R.string.consumer_notice_playstore_link_description)
-            onButtonClick = { openConsumerAppInPlayStore() }
-        }
-
-        consumerStoreButton.text = appStoreText
-        consumerStoreButton.setOnClickListener {
-            try {
-                onButtonClick()
-            } catch (e: Exception) {
-                Toast
-                    .makeText(this, getString(R.string.no_activity_for_intent), Toast.LENGTH_SHORT)
-                    .show()
-            }
-        }
-    }
-
-    private fun openConsumerAppInPlayStore() {
-        val intent = Intent(Intent.ACTION_VIEW)
-        intent.setData(Uri.parse(getString(R.string.private_download_url)))
-        intent.setPackage("com.android.vending")
-        startActivity(intent)
-    }
-
-    private fun openConsumerAppInHuaweiAppGallery() {
-        val intent = Intent(Intent.ACTION_VIEW)
-        val uri = Uri.parse("market://details?id=" + this.packageName)
-        intent.setData(uri)
-        intent.setPackage("com.huawei.appmarket")
-        startActivity(intent)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java b/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java
index e6684d10..d173bd60 100644
--- a/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/wizard/WizardBaseActivity.java
@@ -21,9 +21,6 @@
 
 package ch.threema.app.activities.wizard;
 
-import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
-import static ch.threema.app.protocol.ApplicationSetupStepsKt.runApplicationSetupSteps;
-
 import android.Manifest;
 import android.accounts.Account;
 import android.annotation.SuppressLint;
@@ -39,13 +36,6 @@ import android.view.View;
 import android.widget.Button;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentManager;
-import androidx.fragment.app.FragmentStatePagerAdapter;
-import androidx.lifecycle.LifecycleOwner;
-import androidx.viewpager.widget.ViewPager;
-
 import com.google.android.material.button.MaterialButton;
 import com.google.i18n.phonenumbers.NumberParseException;
 import com.google.i18n.phonenumbers.PhoneNumberUtil;
@@ -53,17 +43,23 @@ import com.google.i18n.phonenumbers.Phonenumber;
 
 import org.slf4j.Logger;
 
-import java.util.List;
-
+import androidx.annotation.NonNull;
+import androidx.annotation.WorkerThread;
+import androidx.fragment.app.Fragment;
+import androidx.fragment.app.FragmentManager;
+import androidx.fragment.app.FragmentStatePagerAdapter;
+import androidx.lifecycle.LifecycleOwner;
+import androidx.viewpager.widget.ViewPager;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.ThreemaAppCompatActivity;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
 import ch.threema.app.dialogs.GenericProgressDialog;
 import ch.threema.app.dialogs.WizardDialog;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.fragments.wizard.WizardFragment0;
 import ch.threema.app.fragments.wizard.WizardFragment1;
 import ch.threema.app.fragments.wizard.WizardFragment2;
@@ -91,1028 +87,1023 @@ import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.utils.executor.BackgroundTask;
 import ch.threema.app.workers.WorkSyncWorker;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.api.LinkEmailException;
 import ch.threema.domain.protocol.api.LinkMobileNoException;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
+
+import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
+import static ch.threema.app.protocol.ApplicationSetupStepsKt.runApplicationSetupSteps;
 
 public class WizardBaseActivity extends ThreemaAppCompatActivity implements
-		LifecycleOwner,
-		ViewPager.OnPageChangeListener,
-		View.OnClickListener,
-		WizardFragment1.OnSettingsChangedListener,
-		WizardFragment2.OnSettingsChangedListener,
-		WizardFragment3.OnSettingsChangedListener,
-		WizardFragment4.SettingsInterface,
-		WizardDialog.WizardDialogCallback {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("WizardBaseActivity");
-
-	public static final String EXTRA_NEW_IDENTITY_CREATED = "newIdentity";
-	private static final String DIALOG_TAG_USE_ID_AS_NICKNAME = "nd";
-	private static final String DIALOG_TAG_INVALID_ENTRY = "ie";
-	private static final String DIALOG_TAG_USE_ANONYMOUSLY = "ano";
-	private static final String DIALOG_TAG_THREEMA_SAFE = "sd";
-	private static final String DIALOG_TAG_PASSWORD_BAD = "pwb";
-	private static final String DIALOG_TAG_SYNC_CONTACTS_ENABLE = "scen";
-	private static final String DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE = "scmer";
-	private static final String DIALOG_TAG_APPLICATION_SETUP_RETRY = "app-setup-retry";
-
-	private static final int PERMISSION_REQUEST_READ_CONTACTS = 2;
-	private static final int NUM_PAGES = 5;
-	private static final long FINISH_DELAY = 3 * 1000;
-	private static final long DIALOG_DELAY = 200;
-
-	public static final boolean DEFAULT_SYNC_CONTACTS = false;
-	private static final String DIALOG_TAG_WORK_SYNC = "workSync";
-	private static final String DIALOG_TAG_PASSWORD_PRESET_CONFIRM = "pwPreset";
-
-	private static int lastPage = 0;
-	private ParallaxViewPager viewPager;
-	private MaterialButton prevButton, nextButton;
-	private Button finishButton;
-	private StepPagerStrip stepPagerStrip;
-	private String nickname, email, number, prefix, presetMobile, presetEmail, safePassword;
-	private ThreemaSafeServerInfo safeServerInfo = new ThreemaSafeServerInfo();
-	private boolean isSyncContacts = DEFAULT_SYNC_CONTACTS, userCannotChangeContactSync = false, skipWizard = false, readOnlyProfile = false;
-	private ThreemaSafeMDMConfig safeConfig;
-	private ServiceManager serviceManager;
-	private UserService userService;
-	private LocaleService localeService;
-	private PreferenceService preferenceService;
-	private ThreemaSafeService threemaSafeService;
-	private boolean errorRaised = false, isNewIdentity = false;
-	private WizardFragment4 fragment4;
-	private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
-
-	private final Handler finishHandler = new Handler();
-	private final Handler dialogHandler = new Handler();
-
-	private final Runnable finishTask = new Runnable() {
-		@Override
-		public void run() {
-		 	RuntimeUtil.runOnUiThread(new Runnable() {
-				@Override
-				public void run() {
-					fragment4.setContactsSyncInProgress(false, null);
-					prepareThreemaSafe();
-				}
-			});
-		}
-	};
-
-	private Runnable showDialogDelayedTask(final int current, final int previous) {
-		return () -> {
-			RuntimeUtil.runOnUiThread(() -> {
-				if (current == WizardFragment2.PAGE_ID && previous == WizardFragment1.PAGE_ID && TestUtil.isEmptyOrNull(getSafePassword())) {
-					if (safeConfig.isBackupForced()) {
-						setPage(WizardFragment1.PAGE_ID);
-					} else if (!isReadOnlyProfile()) {
-						WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_disable_confirm, R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
-						wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_THREEMA_SAFE);
-					}
-				}
-
-				if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
-					if (!isReadOnlyProfile()) {
-						if ((!TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(presetMobile) && !localeService.validatePhoneNumber(getPhone())) ||
-								((!TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(presetEmail) && !Patterns.EMAIL_ADDRESS.matcher(email).matches()))) {
-							WizardDialog wizardDialog = WizardDialog.newInstance(ConfigUtils.isWorkBuild() ?
-									R.string.new_wizard_phone_email_invalid :
-									R.string.new_wizard_phone_invalid,
-									R.string.ok);
-							wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_INVALID_ENTRY);
-						}
-					}
-				}
-
-				if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
-					if (!isReadOnlyProfile()) {
-						boolean needConfirm;
-						if (ConfigUtils.isWorkBuild()) {
-							needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(getPresetEmail()) && TestUtil.isEmptyOrNull(getPresetPhone());
-						} else {
-							if (ConfigUtils.isOnPremBuild()) {
-								needConfirm = false;
-							} else {
-								needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(getPresetPhone());
-							}
-						}
-						if (needConfirm) {
-							WizardDialog wizardDialog = WizardDialog.newInstance(
-									ConfigUtils.isWorkBuild() ?
-											R.string.new_wizard_anonymous_confirm :
-											R.string.new_wizard_anonymous_confirm_phone_only,
-									R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
-							wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_USE_ANONYMOUSLY);
-						}
-					}
-				}
-			});
-		};
-	}
-
-	@Override
-	protected void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-
-		try {
-			serviceManager = ThreemaApplication.getServiceManager();
-			if (serviceManager != null) {
-				userService = serviceManager.getUserService();
-				localeService = serviceManager.getLocaleService();
-				preferenceService = serviceManager.getPreferenceService();
-				threemaSafeService = serviceManager.getThreemaSafeService();
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-			finish();
-			return;
-		}
-		if (userService == null || localeService == null || preferenceService == null) {
-			logger.error("Required services not available.");
-			finish();
-			return;
-		}
-
-		setContentView(R.layout.activity_wizard);
-
-		nextButton = findViewById(R.id.next_page_button);
-		nextButton.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View v) {
-				nextPage();
-			}
-		});
-
-		prevButton = findViewById(R.id.prev_page_button);
-		prevButton.setVisibility(View.GONE);
-		prevButton.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View v) {
-				prevPage();
-			}
-		});
-
-		stepPagerStrip = findViewById(R.id.strip);
-		stepPagerStrip.setPageCount(NUM_PAGES);
-		stepPagerStrip.setCurrentPage(WizardFragment0.PAGE_ID);
-
-		viewPager = findViewById(R.id.pager);
-		viewPager.addLayer(findViewById(R.id.layer0));
-		viewPager.addLayer(findViewById(R.id.layer1));
-
-		Intent intent = getIntent();
-		if (intent != null) {
-			isNewIdentity = intent.getBooleanExtra(EXTRA_NEW_IDENTITY_CREATED, false);
-		}
-
-		if (ConfigUtils.isWorkBuild()) {
-			performWorkSync();
-		} else {
-			setupConfig();
-		}
-	}
-
-	private void setupConfig() {
-		safeConfig = ThreemaSafeMDMConfig.getInstance();
-
-		viewPager.setAdapter(new ScreenSlidePagerAdapter(getSupportFragmentManager()));
-		viewPager.addOnPageChangeListener(this);
-
-		if (ConfigUtils.isWorkRestricted()) {
-			if (isSafeEnabled()) {
-				if (isSafeForced()) {
-					safePassword = safeConfig.getPassword();
-				}
-				safeServerInfo = safeConfig.getServerInfo();
-			}
-
-			String stringPreset;
-			Boolean booleanPreset;
-
-			stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_email));
-			if (stringPreset != null) {
-				email = stringPreset;
-			}
-			stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_phone));
-			if (stringPreset != null) {
-				splitMobile(stringPreset);
-			}
-			stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__nickname));
-			if (stringPreset != null) {
-				nickname = stringPreset;
-			} else {
-				nickname = userService.getIdentity();
-			}
-			booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__contact_sync));
-			if (booleanPreset != null) {
-				isSyncContacts = booleanPreset;
-				userCannotChangeContactSync = true;
-			}
-			booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__readonly_profile));
-			if (booleanPreset != null) {
-				readOnlyProfile = booleanPreset;
-			}
-			booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__skip_wizard));
-			if (booleanPreset != null) {
-				if (booleanPreset) {
-					skipWizard = true;
-					viewPager.post(() -> viewPager.setCurrentItem(WizardFragment4.PAGE_ID));
-				}
-			}
-		} else {
-			// ignore backup presets in restricted mode
-			if (!TestUtil.isEmptyOrNull(presetMobile)) {
-				splitMobile(presetMobile);
-			}
-			if (!TestUtil.isEmptyOrNull(presetEmail)) {
-				email = presetEmail;
-			}
-
-		}
-
-		// if the app is running in a restricted user profile, it s not possible to add accounts
-		if (SynchronizeContactsUtil.isRestrictedProfile(this)) {
-			userCannotChangeContactSync = true;
-			isSyncContacts = false;
-		}
-
-		presetMobile = this.userService.getLinkedMobile();
-		presetEmail = this.userService.getLinkedEmail();
-
-		if (ConfigUtils.isWorkRestricted()) {
-			// confirm the use of a managed password
-			if (!safeConfig.isBackupDisabled() && safeConfig.isBackupPasswordPreset()) {
-				WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_managed_password_confirm, R.string.accept, R.string.real_not_now, WizardDialog.Highlight.NONE);
-				wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_PRESET_CONFIRM);
-			}
-		}
-	}
-
-	/**
-	 * Perform an early synchronous fetch2. In case of failure due to rate-limiting, do not allow user to continue
-	 */
-	private void performWorkSync() {
-		GenericProgressDialog.newInstance(R.string.work_data_sync_desc,
-			R.string.please_wait).show(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC);
-
-		WorkSyncWorker.Companion.performOneTimeWorkSync(
-			this,
-			() -> {
-				// On success
-				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
-				setupConfig();
-			},
-			() -> {
-				// On fail
-				DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
-				RuntimeUtil.runOnUiThread(() -> Toast.makeText(WizardBaseActivity.this, R.string.unable_to_fetch_configuration, Toast.LENGTH_LONG).show());
-				logger.info("Unable to post work request for fetch2");
-				try {
-					userService.removeIdentity();
-				} catch (Exception e) {
-					logger.error("Unable to remove identity", e);
-				}
-				finishAndRemoveTask();
-			});
-	}
-
-	private void splitMobile(String phoneNumber) {
-		if (PHONE_LINKED_PLACEHOLDER.equals(phoneNumber)) {
-			prefix = "";
-			number = PHONE_LINKED_PLACEHOLDER;
-		} else {
-			try {
-				PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();
-				Phonenumber.PhoneNumber numberProto = null;
-
-				numberProto = phoneNumberUtil.parse(phoneNumber, "");
-				prefix = "+" + numberProto.getCountryCode();
-				number = String.valueOf(numberProto.getNationalNumber());
-			} catch (NumberParseException e) {
-				logger.error("Exception", e);
-			}
-		}
-	}
-
-	@Override
-	protected void onDestroy() {
-		viewPager.removeOnPageChangeListener(this);
-
-		super.onDestroy();
-	}
-
-	/**
-	 * This method will be invoked when the current page is scrolled, either as part
-	 * of a programmatically initiated smooth scroll or a user initiated touch scroll.
-	 *
-	 * @param position             Position index of the first page currently being displayed.
-	 *                             Page position+1 will be visible if positionOffset is nonzero.
-	 * @param positionOffset       Value from [0, 1) indicating the offset from the page at position.
-	 * @param positionOffsetPixels Value in pixels indicating the offset from position.
-	 */
-	@Override
-	public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-
-	}
-
-	/**
-	 * This method will be invoked when a new page becomes selected. Animation is not
-	 * necessarily complete.
-	 *
-	 * @param position Position index of the new selected page.
-	 */
-	@SuppressLint("StaticFieldLeak")
-	@Override
-	public void onPageSelected(int position) {
-		prevButton.setVisibility(position == WizardFragment0.PAGE_ID ? View.GONE : View.VISIBLE);
-		nextButton.setVisibility(position == NUM_PAGES - 1 ? View.GONE : View.VISIBLE);
-
-		stepPagerStrip.setCurrentPage(position);
-
-		if (position == WizardFragment1.PAGE_ID && safeConfig.isSkipBackupPasswordEntry()) {
-			if (lastPage == WizardFragment0.PAGE_ID) {
-				nextPage();
-			} else {
-				prevPage();
-			}
-			return;
-		}
-
-		if (position == WizardFragment2.PAGE_ID && lastPage == WizardFragment1.PAGE_ID) {
-			if (!TextUtils.isEmpty(safePassword)) {
-				new AsyncTask<Void, Void, Boolean>() {
-					@Override
-					protected Boolean doInBackground(Void... voids) {
-						return TextUtil.checkBadPassword(getApplicationContext(), safePassword);
-					}
-
-					@Override
-					protected void onPostExecute(Boolean isBad) {
-						if (isBad) {
-							Context context = WizardBaseActivity.this;
-							if (AppRestrictionUtil.isSafePasswordPatternSet(context)) {
-								WizardDialog wizardDialog = WizardDialog.newInstance(AppRestrictionUtil.getSafePasswordMessage(context), R.string.try_again);
-								wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD);
-							} else {
-								WizardDialog wizardDialog = WizardDialog.newInstance(R.string.password_bad_explain, R.string.continue_anyway, R.string.try_again, WizardDialog.Highlight.NEGATIVE);
-								wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD);
-							}
-						}
-					}
-				}.execute();
-			}
-		}
-
-		if (position > lastPage && position >= WizardFragment2.PAGE_ID && position <= WizardFragment4.PAGE_ID) {
-			// we delay dialogs for a few milliseconds to prevent stuttering of the page change animation
-			dialogHandler.removeCallbacks(showDialogDelayedTask(position, lastPage));
-			dialogHandler.postDelayed(showDialogDelayedTask(position, lastPage), DIALOG_DELAY);
-		}
-
-		lastPage = position;
-	}
-
-	/**
-	 * Called when the scroll state changes. Useful for discovering when the user
-	 * begins dragging, when the pager is automatically settling to the current page,
-	 * or when it is fully stopped/idle.
-	 *
-	 * @param state The new scroll state.
-	 * @see ViewPager#SCROLL_STATE_IDLE
-	 * @see ViewPager#SCROLL_STATE_DRAGGING
-	 * @see ViewPager#SCROLL_STATE_SETTLING
-	 */
-	@Override
-	public void onPageScrollStateChanged(int state) { }
-
-	/**
-	 * Called when a view has been clicked.
-	 *
-	 * @param v The view that was clicked.
-	 */
-	@Override
-	public void onClick(View v) {
-		if (v.equals(nextButton)) {
-			nextPage();
-		} else if (v.equals(prevButton)) {
-			prevPage();
-		}
-	}
-
-	@Override
-	public void onWizardFinished(WizardFragment4 fragment, Button finishButton) {
-		errorRaised = false;
-		fragment4 = fragment;
-
-		viewPager.lock(true);
-		this.finishButton = finishButton;
-
-		prevButton.setVisibility(View.GONE);
-		if (finishButton != null) {
-			finishButton.setEnabled(false);
-		}
-
-		userService.setPublicNickname(this.nickname);
-
-		askUserForContactSync();
-	}
-
-	private void askUserForContactSync() {
-		/* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
-		serviceManager.getLifetimeService().ensureConnection();
-
-		if (this.userCannotChangeContactSync) {
-			if (this.isSyncContacts) {
-				if (ConfigUtils.isPermissionGranted(this, Manifest.permission.READ_CONTACTS)) {
-					// Permission already granted, therefore continue by linking the phone
-					linkPhone();
-				} else {
-					// If permission is not yet granted, show a dialog to inform that contact sync
-					// has been force enabled by the administrator
-					WizardDialog wizardDialog = WizardDialog.newInstance(R.string.contact_sync_mdm_rationale, R.string.ok);
-					wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE);
-				}
-			} else {
-				linkPhone();
-			}
-		} else {
-			if (this.skipWizard) {
-				isSyncContacts = false;
-				this.serviceManager.getPreferenceService().setSyncContacts(false);
-				linkPhone();
-			} else {
-				WizardDialog wizardDialog = WizardDialog.newInstance(R.string.new_wizard_info_sync_contacts_dialog, R.string.yes, R.string.no, null);
-				wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_ENABLE);
-			}
-		}
-	}
-
-	private void requestContactSyncPermission() {
-		if (ConfigUtils.requestContactPermissions(this, null, PERMISSION_REQUEST_READ_CONTACTS)) {
-			// permission is already granted
-			this.isSyncContacts = true;
-			preferenceService.setSyncContacts(this.isSyncContacts);
-			linkPhone();
-		}
-		// continue to onRequestPermissionsResult
-	}
-
-	@Override
-	public void onNicknameSet(String nickname) {
-		this.nickname = nickname;
-	}
-
-	@Override
-	public void onPhoneSet(String phoneNumber) {
-		this.number = phoneNumber;
-	}
-
-	@Override
-	public void onPrefixSet(String prefix) {
-		this.prefix = prefix;
-	}
-
-	@Override
-	public void onEmailSet(String email) {
-		this.email = email;
-	}
-
-	@Override
-	public void onSafePasswordSet(final String password) {
-		safePassword = password;
-	}
-
-	@Override
-	public void onSafeServerInfoSet(ThreemaSafeServerInfo safeServerInfo) {
-		this.safeServerInfo = safeServerInfo;
-	}
-
-	@Override
-	public String getNickname() {
-		return this.nickname;
-	}
-
-	@Override
-	public String getPhone() {
-		if (PHONE_LINKED_PLACEHOLDER.equals(this.number)) {
-			return this.number;
-		}
-
-		String phone = this.prefix + this.number;
-
-		if (localeService.validatePhoneNumber(phone)) {
-			return serviceManager.getLocaleService().getNormalizedPhoneNumber(phone);
-		}
-		return "";
-	}
-
-	@Override
-	public String getNumber() {
-		return this.number;
-	}
-
-	@Override
-	public String getPrefix() {
-		return this.prefix;
-	}
-
-	@Override
-	public String getEmail() {
-		return (this.email != null && this.email.length() > 4) ? this.email : "";
-	}
-
-	@Override
-	public String getPresetPhone() {
-		return this.presetMobile;
-	}
-
-	@Override
-	public String getPresetEmail() {
-		return this.presetEmail;
-	}
-
-	@Override
-	public boolean getSafeForcePasswordEntry() {
-		return safeConfig.isBackupForced();
-	}
-
-	@Override
-	public boolean getSafeSkipBackupPasswordEntry() {
-		return safeConfig.isSkipBackupPasswordEntry();
-	}
-
-	@Override
-	public boolean isSafeEnabled() {
-		return !safeConfig.isBackupDisabled();
-	}
-
-	@Override
-	public boolean isSafeForced() {
-		return safeConfig.isBackupForced();
-	}
-
-	@Override
-	public String getSafePassword() {
-		return this.safePassword;
-	}
-
-	@Override
-	public ThreemaSafeServerInfo getSafeServerInfo() {
-		return this.safeServerInfo;
-	}
-
-	@Override
-	public boolean getSyncContacts() {
-		return this.isSyncContacts;
-	}
-
-	@Override
-	public boolean isReadOnlyProfile() {
-		return this.readOnlyProfile;
-	}
-
-	@Override
-	public boolean isSkipWizard() {
-		return this.skipWizard;
-	}
-
-	/**
-	 * Return whether the identity was just created
-	 * @return true if it's a new identity, false if the identity was restored
-	 */
-	public boolean isNewIdentity() {
-		return isNewIdentity;
-	}
-
-	@Override
-	public void onYes(String tag, Object data) {
-		switch (tag) {
-			case DIALOG_TAG_USE_ID_AS_NICKNAME:
-				this.nickname = this.userService.getIdentity();
-				break;
-			case DIALOG_TAG_INVALID_ENTRY:
-			case DIALOG_TAG_PASSWORD_BAD:
-				prevPage();
-				break;
-			case DIALOG_TAG_THREEMA_SAFE:
-			case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
-				break;
-			case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
-			case DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE:
-				requestContactSyncPermission();
-				break;
-			case DIALOG_TAG_APPLICATION_SETUP_RETRY:
-				runApplicationSetupStepsAndRestart();
-				break;
-		}
-	}
-
-	@Override
-	public void onNo(String tag) {
-		switch (tag) {
-			case DIALOG_TAG_USE_ID_AS_NICKNAME:
-				prevPage();
-				break;
-			case DIALOG_TAG_USE_ANONYMOUSLY:
-				setPage(WizardFragment3.PAGE_ID);
-				break;
-			case DIALOG_TAG_THREEMA_SAFE:
-				prevPage();
-				break;
-			case DIALOG_TAG_PASSWORD_BAD:
-				setPage(WizardFragment1.PAGE_ID);
-				break;
-			case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
-				isSyncContacts = false;
-				this.serviceManager.getPreferenceService().setSyncContacts(false);
-				linkPhone();
-				break;
-			case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
-				finish();
-				System.exit(0);
-				break;
-		}
-	}
-
-	@Override
-	protected boolean enableOnBackPressedCallback() {
-		return true;
-	}
-
-	@Override
-	protected void handleOnBackPressed() {
-		if (prevButton != null && prevButton.getVisibility() == View.VISIBLE) {
-			prevPage();
-		}
-	}
-
-	private class ScreenSlidePagerAdapter extends FragmentStatePagerAdapter {
-		public ScreenSlidePagerAdapter(FragmentManager fm) {
-			super(fm, FragmentStatePagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
-		}
-
-		@Override
-		public Fragment getItem(int position) {
-			switch (position) {
-				case WizardFragment0.PAGE_ID:
-					return new WizardFragment0();
-				case WizardFragment1.PAGE_ID:
-					return new WizardFragment1();
-				case WizardFragment2.PAGE_ID:
-					return new WizardFragment2();
-				case WizardFragment3.PAGE_ID:
-					return new WizardFragment3();
-				case WizardFragment4.PAGE_ID:
-					return new WizardFragment4();
-				default:
-					break;
-			}
-			return null;
-		}
-
-		@Override
-		public int getCount() {
-			return NUM_PAGES;
-		}
-	}
-
-	public void nextPage() {
-		int currentItem = viewPager.getCurrentItem() + 1;
-		if (currentItem < NUM_PAGES) {
-			viewPager.setCurrentItem(currentItem);
-		}
-	}
-
-	public void prevPage() {
-		int currentItem = viewPager.getCurrentItem();
-		if (currentItem != 0) {
-			viewPager.setCurrentItem(currentItem - 1);
-		}
-	}
-
-	public void setPage(int page) {
-		viewPager.setCurrentItem(page);
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void linkEmail(final WizardFragment4 fragment) {
-		final String newEmail = getEmail();
-		if (TestUtil.isEmptyOrNull(newEmail)) {
-			initSyncAndFinish();
-			return;
-		}
-
-		boolean isNewEmail = (!(presetEmail != null && presetEmail.equals(newEmail)));
-
-		if ((userService.getEmailLinkingState() != UserService.LinkingState_LINKED) && isNewEmail) {
-			new AsyncTask<Void, Void, String>() {
-				@Override
-				protected void onPreExecute() {
-					fragment.setEmailLinkingInProgress(true);
-				}
-
-				@Override
-				protected String doInBackground(Void... params) {
-					try {
-						userService.linkWithEmail(email);
-					} catch (LinkEmailException e) {
-						logger.error("Exception", e);
-						return e.getMessage();
-					} catch (Exception e) {
-						logger.error("Exception", e);
-						return getString(R.string.internet_connection_required);
-					}
-					return null;
-				}
-
-				@Override
-				protected void onPostExecute(String result) {
-					if (result != null) {
-						fragment.setEmailLinkingAlert(result);
-						errorRaised = true;
-					} else {
-						fragment.setEmailLinkingInProgress(false);
-					}
-					initSyncAndFinish();
-				}
-			}.execute();
-		} else {
-			initSyncAndFinish();
-		}
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void linkPhone() {
-		final String phone = getPhone();
-		if (TestUtil.isEmptyOrNull(phone)) {
-			linkEmail(fragment4);
-			return;
-		}
-
-		boolean isNewPhoneNumber = (presetMobile == null || !presetMobile.equals(phone));
-
-		// start linking activity only if not already linked
-		if ((userService.getMobileLinkingState() != UserService.LinkingState_LINKED) && isNewPhoneNumber) {
-			new AsyncTask<Void, Void, String>() {
-				@Override
-				protected void onPreExecute() {
-					fragment4.setMobileLinkingInProgress(true);
-				}
-
-				@Override
-				protected String doInBackground(Void... params) {
-					try {
-						userService.linkWithMobileNumber(phone);
-					} catch (LinkMobileNoException e) {
-						logger.error("Exception", e);
-						return e.getMessage();
-					} catch (Exception e) {
-						logger.error("Exception", e);
-						return getString(R.string.internet_connection_required);
-					}
-					return null;
-				}
-
-				@Override
-				protected void onPostExecute(String result) {
-					if (result != null) {
-						fragment4.setMobileLinkingAlert(result);
-						errorRaised = true;
-					} else {
-						fragment4.setMobileLinkingInProgress(false);
-					}
-					linkEmail(fragment4);
-				}
-			}.execute();
-		} else {
-			linkEmail(fragment4);
-		}
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void addUser(final String id, final String first, final String last) {
-		new AsyncTask<Void, Void, Void>() {
-
-			@Override
-			protected Void doInBackground(Void... params) {
-				try {
-					ContactModel newUser = serviceManager.getContactService()
-							.createContactByIdentity(id, true);
-
-					if (newUser != null) {
-						newUser.setFirstName(first);
-						newUser.setLastName(last);
-						serviceManager.getContactService().save(newUser);
-					}
-
-				} catch (InvalidEntryException | MasterKeyLockedException | FileSystemNotPresentException e) {
-					logger.error("Exception", e);
-					//should not happen, ignore
-				} catch (EntryAlreadyExistsException | PolicyViolationException e) {
-					//ok, id already exists or adding IDs is prohibited, do nothing
-				}
-				return null;
-			}
-		}.execute();
-	}
-
-	private void runApplicationSetupStepsAndRestart() {
-		backgroundExecutor.execute(new BackgroundTask<Boolean>() {
-			@Override
-			public void runBefore() {
-				// Nothing to do
-			}
-
-			@Override
-			public Boolean runInBackground() {
-				return runApplicationSetupSteps(serviceManager, WizardBaseActivity.this);
-			}
-
-			@Override
-			public void runAfter(Boolean result) {
-				if (!Boolean.TRUE.equals(result)) {
-					WizardDialog.newInstance(R.string.application_setup_steps_failed, R.string.retry)
-						.show(getSupportFragmentManager(), DIALOG_TAG_APPLICATION_SETUP_RETRY);
-					return;
-				}
-
-				preferenceService.setWizardRunning(false);
-				preferenceService.setLatestVersion(WizardBaseActivity.this);
-
-				addUser(ThreemaApplication.ECHO_USER_IDENTITY, "Echo", "Test");
-
-				// Flush conversation cache (after a restore) to ensure that the conversation list
-				// will be loaded from the database to prevent the list being incomplete.
-				try {
-					serviceManager.getConversationService().reset();
-				} catch (Exception e) {
-					logger.error("Exception", e);
-				}
-
-				ConfigUtils.recreateActivity(WizardBaseActivity.this);
-			}
-		});
-	}
-
-	private void ensureMasterKeyWrite() {
-		// Write master key now if no passphrase has been set - don't leave it up to the MainActivity
-		if (!ThreemaApplication.getMasterKey().isProtected()) {
-			try {
-				ThreemaApplication.getMasterKey().setPassphrase(null);
-			} catch (Exception e) {
-				// better die if something went wrong as the master key may not have been saved
-				throw new RuntimeException(e);
-			}
-		}
-	}
-
-	@SuppressLint({"StaticFieldLeak", "MissingPermission"})
-	private void reallySyncContactsAndFinish() {
-		ensureMasterKeyWrite();
-
-		if (preferenceService.isSyncContacts()) {
-			new AsyncTask<Void, Void, Void>() {
-				@Override
-				protected void onPreExecute() {
-					fragment4.setContactsSyncInProgress(true, getString(R.string.wizard1_sync_contacts));
-				}
-
-				@SuppressLint("MissingPermission")
-				@Override
-				protected Void doInBackground(Void... params) {
-					try {
-						final Account account = userService.getAccount(true);
-						//disable
-						userService.enableAccountAutoSync(false);
-
-						SynchronizeContactsService synchronizeContactsService = serviceManager.getSynchronizeContactsService();
-						SynchronizeContactsRoutine routine = synchronizeContactsService.instantiateSynchronization(account);
-
-						routine.setOnStatusUpdate(new SynchronizeContactsRoutine.OnStatusUpdate() {
-							@Override
-							public void newStatus(final long percent, final String message) {
-							 	RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(true, message));
-							}
-
-							@Override
-							public void error(final Exception x) {
-							 	RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(false, x.getMessage()));
-							}
-						});
-
-						//on finished, close the dialog
-						routine.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
-							@Override
-							public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
-								userService.enableAccountAutoSync(true);
-							}
-						});
-
-						routine.run();
-					} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
-						logger.error("Exception", e);
-					}
-					return null;
-				}
-
-				@Override
-				protected void onPostExecute(Void result) {
-					finishHandler.removeCallbacks(finishTask);
-					finishHandler.postDelayed(finishTask, FINISH_DELAY);
-				}
-			}.execute();
-		} else {
-			userService.removeAccount();
-			prepareThreemaSafe();
-		}
-	}
-
-	@SuppressLint("StaticFieldLeak")
-	private void prepareThreemaSafe() {
-		if (!TestUtil.isEmptyOrNull(getSafePassword())) {
-			new AsyncTask<Void, Void, byte[]>() {
-				@Override
-				protected void onPreExecute() {
-					fragment4.setThreemaSafeInProgress(true, getString(R.string.preparing_threema_safe));
-				}
-
-				@Override
-				protected byte[] doInBackground(Void... voids) {
-					return threemaSafeService.deriveMasterKey(getSafePassword(), userService.getIdentity());
-				}
-
-				@Override
-				protected void onPostExecute(byte[] masterkey) {
-					fragment4.setThreemaSafeInProgress(false, getString(R.string.menu_done));
-
-					if (masterkey != null) {
-						threemaSafeService.storeMasterKey(masterkey);
-						preferenceService.setThreemaSafeServerInfo(safeServerInfo);
-						threemaSafeService.setEnabled(true);
-						threemaSafeService.uploadNow(true);
-					} else {
-						Toast.makeText(WizardBaseActivity.this, R.string.safe_error_preparing, Toast.LENGTH_LONG).show();
-					}
-
-					runApplicationSetupStepsAndRestart();
-				}
-			}.execute();
-		} else {
-			// no password was set
-			// do not save mdm settings if backup is forced and no password was set - this will cause a password prompt later
-			if (!(ConfigUtils.isWorkRestricted() && ThreemaSafeMDMConfig.getInstance().isBackupForced())) {
-				threemaSafeService.storeMasterKey(new byte[0]);
-			}
-			runApplicationSetupStepsAndRestart();
-		}
-	}
-
-	private void initSyncAndFinish() {
-		if (!errorRaised || ConfigUtils.isWorkRestricted()) {
-			syncContactsAndFinish();
-		} else {
-			resetUi();
-		}
-	}
-
-	private void resetUi() {
-		// unlock UI to try again
-		viewPager.lock(false);
-		prevButton.setVisibility(View.VISIBLE);
-		if (finishButton != null) {
-			finishButton.setEnabled(true);
-		}
-	}
-
-	private void syncContactsAndFinish() {
-		/* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
-		serviceManager.getLifetimeService().ensureConnection();
-
-		if (this.isSyncContacts) {
-			preferenceService.setSyncContacts(true);
-			reallySyncContactsAndFinish();
-		} else {
-			preferenceService.setSyncContacts(false);
-			prepareThreemaSafe();
-		}
-	}
-
-	@Override
-	public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-		super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-		if (requestCode == PERMISSION_REQUEST_READ_CONTACTS) {
-			if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-				this.isSyncContacts = true;
-				linkPhone();
-			} else if (userCannotChangeContactSync) {
-				ConfigUtils.showPermissionRationale(this, (View) viewPager.getParent(), R.string.permission_contacts_sync_required);
-				resetUi();
-			} else {
-				this.isSyncContacts = false;
-				linkPhone();
-			}
-		}
-	}
+    LifecycleOwner,
+    ViewPager.OnPageChangeListener,
+    View.OnClickListener,
+    WizardFragment1.OnSettingsChangedListener,
+    WizardFragment2.OnSettingsChangedListener,
+    WizardFragment3.OnSettingsChangedListener,
+    WizardFragment4.SettingsInterface,
+    WizardDialog.WizardDialogCallback {
+
+    private static final Logger logger = LoggingUtil.getThreemaLogger("WizardBaseActivity");
+
+    public static final String EXTRA_NEW_IDENTITY_CREATED = "newIdentity";
+    private static final String DIALOG_TAG_USE_ID_AS_NICKNAME = "nd";
+    private static final String DIALOG_TAG_INVALID_ENTRY = "ie";
+    private static final String DIALOG_TAG_USE_ANONYMOUSLY = "ano";
+    private static final String DIALOG_TAG_THREEMA_SAFE = "sd";
+    private static final String DIALOG_TAG_PASSWORD_BAD = "pwb";
+    private static final String DIALOG_TAG_PASSWORD_BAD_WORK = "pwbw";
+    private static final String DIALOG_TAG_SYNC_CONTACTS_ENABLE = "scen";
+    private static final String DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE = "scmer";
+    private static final String DIALOG_TAG_APPLICATION_SETUP_RETRY = "app-setup-retry";
+
+    private static final int PERMISSION_REQUEST_READ_CONTACTS = 2;
+    private static final int NUM_PAGES = 5;
+    private static final long FINISH_DELAY = 3 * 1000;
+    private static final long DIALOG_DELAY = 200;
+
+    public static final boolean DEFAULT_SYNC_CONTACTS = false;
+    private static final String DIALOG_TAG_WORK_SYNC = "workSync";
+    private static final String DIALOG_TAG_PASSWORD_PRESET_CONFIRM = "pwPreset";
+
+    private static int lastPage = 0;
+    private ParallaxViewPager viewPager;
+    private MaterialButton prevButton, nextButton;
+    private Button finishButton;
+    private StepPagerStrip stepPagerStrip;
+    private String nickname, email, number, prefix, presetMobile, presetEmail, safePassword;
+    private ThreemaSafeServerInfo safeServerInfo = new ThreemaSafeServerInfo();
+    private boolean isSyncContacts = DEFAULT_SYNC_CONTACTS, userCannotChangeContactSync = false, skipWizard = false, readOnlyProfile = false;
+    private ThreemaSafeMDMConfig safeConfig;
+    private ServiceManager serviceManager;
+    private UserService userService;
+    private LocaleService localeService;
+    private PreferenceService preferenceService;
+    private ThreemaSafeService threemaSafeService;
+    private APIConnector apiConnector;
+    private ContactModelRepository contactModelRepository;
+    private boolean errorRaised = false, isNewIdentity = false;
+    private WizardFragment4 fragment4;
+    private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
+
+    private final Handler finishHandler = new Handler();
+    private final Handler dialogHandler = new Handler();
+
+    private final Runnable finishTask = new Runnable() {
+        @Override
+        public void run() {
+            RuntimeUtil.runOnUiThread(() -> {
+                fragment4.setContactsSyncInProgress(false, null);
+                prepareThreemaSafe();
+            });
+        }
+    };
+
+    private Runnable showDialogDelayedTask(final int current, final int previous) {
+        return () -> RuntimeUtil.runOnUiThread(() -> {
+            if (current == WizardFragment2.PAGE_ID && previous == WizardFragment1.PAGE_ID && TestUtil.isEmptyOrNull(getSafePassword())) {
+                if (safeConfig.isBackupForced()) {
+                    setPage(WizardFragment1.PAGE_ID);
+                } else if (!isReadOnlyProfile()) {
+                    WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_disable_confirm, R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
+                    wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_THREEMA_SAFE);
+                }
+            }
+
+            if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
+                if (!isReadOnlyProfile()) {
+                    if ((!TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(presetMobile) && !localeService.validatePhoneNumber(getPhone())) ||
+                        ((!TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(presetEmail) && !Patterns.EMAIL_ADDRESS.matcher(email).matches()))) {
+                        WizardDialog wizardDialog = WizardDialog.newInstance(ConfigUtils.isWorkBuild() ?
+                                R.string.new_wizard_phone_email_invalid :
+                                R.string.new_wizard_phone_invalid,
+                            R.string.ok);
+                        wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_INVALID_ENTRY);
+                    }
+                }
+            }
+
+            if (current == WizardFragment4.PAGE_ID && previous == WizardFragment3.PAGE_ID) {
+                if (!isReadOnlyProfile()) {
+                    boolean needConfirm;
+                    if (ConfigUtils.isWorkBuild()) {
+                        needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(email) && TestUtil.isEmptyOrNull(getPresetEmail()) && TestUtil.isEmptyOrNull(getPresetPhone());
+                    } else {
+                        if (ConfigUtils.isOnPremBuild()) {
+                            needConfirm = false;
+                        } else {
+                            needConfirm = TestUtil.isEmptyOrNull(number) && TestUtil.isEmptyOrNull(getPresetPhone());
+                        }
+                    }
+                    if (needConfirm) {
+                        WizardDialog wizardDialog = WizardDialog.newInstance(
+                            ConfigUtils.isWorkBuild() ?
+                                R.string.new_wizard_anonymous_confirm :
+                                R.string.new_wizard_anonymous_confirm_phone_only,
+                            R.string.yes, R.string.no, WizardDialog.Highlight.NEGATIVE);
+                        wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_USE_ANONYMOUSLY);
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        try {
+            serviceManager = ThreemaApplication.getServiceManager();
+            if (serviceManager != null) {
+                userService = serviceManager.getUserService();
+                localeService = serviceManager.getLocaleService();
+                preferenceService = serviceManager.getPreferenceService();
+                threemaSafeService = serviceManager.getThreemaSafeService();
+                apiConnector = serviceManager.getAPIConnector();
+                contactModelRepository = serviceManager.getModelRepositories().getContacts();
+            }
+        } catch (Exception e) {
+            logger.error("Exception", e);
+            finish();
+            return;
+        }
+        if (userService == null || localeService == null || preferenceService == null) {
+            logger.error("Required services not available.");
+            finish();
+            return;
+        }
+
+        setContentView(R.layout.activity_wizard);
+
+        nextButton = findViewById(R.id.next_page_button);
+        nextButton.setOnClickListener(v -> nextPage());
+
+        prevButton = findViewById(R.id.prev_page_button);
+        prevButton.setVisibility(View.GONE);
+        prevButton.setOnClickListener(v -> prevPage());
+
+        stepPagerStrip = findViewById(R.id.strip);
+        stepPagerStrip.setPageCount(NUM_PAGES);
+        stepPagerStrip.setCurrentPage(WizardFragment0.PAGE_ID);
+
+        viewPager = findViewById(R.id.pager);
+        viewPager.addLayer(findViewById(R.id.layer0));
+        viewPager.addLayer(findViewById(R.id.layer1));
+
+        Intent intent = getIntent();
+        if (intent != null) {
+            isNewIdentity = intent.getBooleanExtra(EXTRA_NEW_IDENTITY_CREATED, false);
+        }
+
+        if (ConfigUtils.isWorkBuild()) {
+            performWorkSync();
+        } else {
+            setupConfig();
+        }
+    }
+
+    private void setupConfig() {
+        safeConfig = ThreemaSafeMDMConfig.getInstance();
+
+        viewPager.setAdapter(new ScreenSlidePagerAdapter(getSupportFragmentManager()));
+        viewPager.addOnPageChangeListener(this);
+
+        if (ConfigUtils.isWorkRestricted()) {
+            if (isSafeEnabled()) {
+                if (isSafeForced()) {
+                    safePassword = safeConfig.getPassword();
+                }
+                safeServerInfo = safeConfig.getServerInfo();
+            }
+
+            String stringPreset;
+            Boolean booleanPreset;
+
+            stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_email));
+            if (stringPreset != null) {
+                email = stringPreset;
+            }
+            stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__linked_phone));
+            if (stringPreset != null) {
+                splitMobile(stringPreset);
+            }
+            stringPreset = AppRestrictionUtil.getStringRestriction(getString(R.string.restriction__nickname));
+            if (stringPreset != null) {
+                nickname = stringPreset;
+            } else {
+                nickname = userService.getIdentity();
+            }
+            booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__contact_sync));
+            if (booleanPreset != null) {
+                isSyncContacts = booleanPreset;
+                userCannotChangeContactSync = true;
+            }
+            booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__readonly_profile));
+            if (booleanPreset != null) {
+                readOnlyProfile = booleanPreset;
+            }
+            booleanPreset = AppRestrictionUtil.getBooleanRestriction(getString(R.string.restriction__skip_wizard));
+            if (booleanPreset != null) {
+                if (booleanPreset) {
+                    skipWizard = true;
+                    viewPager.post(() -> viewPager.setCurrentItem(WizardFragment4.PAGE_ID));
+                }
+            }
+        } else {
+            // ignore backup presets in restricted mode
+            if (!TestUtil.isEmptyOrNull(presetMobile)) {
+                splitMobile(presetMobile);
+            }
+            if (!TestUtil.isEmptyOrNull(presetEmail)) {
+                email = presetEmail;
+            }
+
+        }
+
+        // if the app is running in a restricted user profile, it s not possible to add accounts
+        if (SynchronizeContactsUtil.isRestrictedProfile(this)) {
+            userCannotChangeContactSync = true;
+            isSyncContacts = false;
+        }
+
+        presetMobile = this.userService.getLinkedMobile();
+        presetEmail = this.userService.getLinkedEmail();
+
+        if (ConfigUtils.isWorkRestricted()) {
+            // confirm the use of a managed password
+            if (!safeConfig.isBackupDisabled() && safeConfig.isBackupPasswordPreset()) {
+                WizardDialog wizardDialog = WizardDialog.newInstance(R.string.safe_managed_password_confirm, R.string.accept, R.string.real_not_now, WizardDialog.Highlight.NONE);
+                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_PRESET_CONFIRM);
+            }
+        }
+    }
+
+    /**
+     * Perform an early synchronous fetch2. In case of failure due to rate-limiting, do not allow user to continue
+     */
+    private void performWorkSync() {
+        GenericProgressDialog.newInstance(R.string.work_data_sync_desc,
+            R.string.please_wait).show(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC);
+
+        WorkSyncWorker.Companion.performOneTimeWorkSync(
+            this,
+            () -> {
+                // On success
+                DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
+                setupConfig();
+            },
+            () -> {
+                // On fail
+                DialogUtil.dismissDialog(getSupportFragmentManager(), DIALOG_TAG_WORK_SYNC, true);
+                RuntimeUtil.runOnUiThread(() -> Toast.makeText(WizardBaseActivity.this, R.string.unable_to_fetch_configuration, Toast.LENGTH_LONG).show());
+                logger.info("Unable to post work request for fetch2");
+                try {
+                    userService.removeIdentity();
+                } catch (Exception e) {
+                    logger.error("Unable to remove identity", e);
+                }
+                finishAndRemoveTask();
+            });
+    }
+
+    private void splitMobile(String phoneNumber) {
+        if (PHONE_LINKED_PLACEHOLDER.equals(phoneNumber)) {
+            prefix = "";
+            number = PHONE_LINKED_PLACEHOLDER;
+        } else {
+            try {
+                PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();
+                Phonenumber.PhoneNumber numberProto = phoneNumberUtil.parse(phoneNumber, "");
+                prefix = "+" + numberProto.getCountryCode();
+                number = String.valueOf(numberProto.getNationalNumber());
+            } catch (NumberParseException e) {
+                logger.error("Exception", e);
+            }
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        viewPager.removeOnPageChangeListener(this);
+
+        super.onDestroy();
+    }
+
+    /**
+     * This method will be invoked when the current page is scrolled, either as part
+     * of a programmatically initiated smooth scroll or a user initiated touch scroll.
+     *
+     * @param position             Position index of the first page currently being displayed.
+     *                             Page position+1 will be visible if positionOffset is nonzero.
+     * @param positionOffset       Value from [0, 1) indicating the offset from the page at position.
+     * @param positionOffsetPixels Value in pixels indicating the offset from position.
+     */
+    @Override
+    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
+
+    }
+
+    /**
+     * This method will be invoked when a new page becomes selected. Animation is not
+     * necessarily complete.
+     *
+     * @param position Position index of the new selected page.
+     */
+    @SuppressLint("StaticFieldLeak")
+    @Override
+    public void onPageSelected(int position) {
+        prevButton.setVisibility(position == WizardFragment0.PAGE_ID ? View.GONE : View.VISIBLE);
+        nextButton.setVisibility(position == NUM_PAGES - 1 ? View.GONE : View.VISIBLE);
+
+        stepPagerStrip.setCurrentPage(position);
+
+        if (position == WizardFragment1.PAGE_ID && safeConfig.isSkipBackupPasswordEntry()) {
+            if (lastPage == WizardFragment0.PAGE_ID) {
+                nextPage();
+            } else {
+                prevPage();
+            }
+            return;
+        }
+
+        if (position == WizardFragment2.PAGE_ID && lastPage == WizardFragment1.PAGE_ID) {
+            if (!TextUtils.isEmpty(safePassword)) {
+                new AsyncTask<Void, Void, Boolean>() {
+                    @Override
+                    protected Boolean doInBackground(Void... voids) {
+                        return TextUtil.checkBadPassword(getApplicationContext(), safePassword);
+                    }
+
+                    @Override
+                    protected void onPostExecute(Boolean isBad) {
+                        if (isBad) {
+                            Context context = WizardBaseActivity.this;
+                            if (AppRestrictionUtil.isSafePasswordPatternSet(context)) {
+                                WizardDialog wizardDialog = WizardDialog.newInstance(AppRestrictionUtil.getSafePasswordMessage(context), R.string.try_again);
+                                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD_WORK);
+                            } else {
+                                WizardDialog wizardDialog = WizardDialog.newInstance(R.string.password_bad_explain, R.string.continue_anyway, R.string.try_again, WizardDialog.Highlight.NEGATIVE);
+                                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_PASSWORD_BAD);
+                            }
+                        }
+                    }
+                }.execute();
+            }
+        }
+
+        if (position > lastPage && position >= WizardFragment2.PAGE_ID && position <= WizardFragment4.PAGE_ID) {
+            // we delay dialogs for a few milliseconds to prevent stuttering of the page change animation
+            dialogHandler.removeCallbacks(showDialogDelayedTask(position, lastPage));
+            dialogHandler.postDelayed(showDialogDelayedTask(position, lastPage), DIALOG_DELAY);
+        }
+
+        lastPage = position;
+    }
+
+    /**
+     * Called when the scroll state changes. Useful for discovering when the user
+     * begins dragging, when the pager is automatically settling to the current page,
+     * or when it is fully stopped/idle.
+     *
+     * @param state The new scroll state.
+     * @see ViewPager#SCROLL_STATE_IDLE
+     * @see ViewPager#SCROLL_STATE_DRAGGING
+     * @see ViewPager#SCROLL_STATE_SETTLING
+     */
+    @Override
+    public void onPageScrollStateChanged(int state) {
+    }
+
+    /**
+     * Called when a view has been clicked.
+     *
+     * @param v The view that was clicked.
+     */
+    @Override
+    public void onClick(View v) {
+        if (v.equals(nextButton)) {
+            nextPage();
+        } else if (v.equals(prevButton)) {
+            prevPage();
+        }
+    }
+
+    @Override
+    public void onWizardFinished(WizardFragment4 fragment, Button finishButton) {
+        errorRaised = false;
+        fragment4 = fragment;
+
+        viewPager.lock(true);
+        this.finishButton = finishButton;
+
+        prevButton.setVisibility(View.GONE);
+        if (finishButton != null) {
+            finishButton.setEnabled(false);
+        }
+
+        userService.setPublicNickname(this.nickname, TriggerSource.LOCAL);
+
+        askUserForContactSync();
+    }
+
+    private void askUserForContactSync() {
+        /* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
+        serviceManager.getLifetimeService().ensureConnection();
+
+        if (this.userCannotChangeContactSync) {
+            if (this.isSyncContacts) {
+                if (ConfigUtils.isPermissionGranted(this, Manifest.permission.READ_CONTACTS)) {
+                    // Permission already granted, therefore continue by linking the phone
+                    linkPhone();
+                } else {
+                    // If permission is not yet granted, show a dialog to inform that contact sync
+                    // has been force enabled by the administrator
+                    WizardDialog wizardDialog = WizardDialog.newInstance(R.string.contact_sync_mdm_rationale, R.string.ok);
+                    wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE);
+                }
+            } else {
+                linkPhone();
+            }
+        } else {
+            if (this.skipWizard) {
+                isSyncContacts = false;
+                this.serviceManager.getPreferenceService().setSyncContacts(false);
+                linkPhone();
+            } else {
+                WizardDialog wizardDialog = WizardDialog.newInstance(R.string.new_wizard_info_sync_contacts_dialog, R.string.yes, R.string.no, null);
+                wizardDialog.show(getSupportFragmentManager(), DIALOG_TAG_SYNC_CONTACTS_ENABLE);
+            }
+        }
+    }
+
+    private void requestContactSyncPermission() {
+        if (ConfigUtils.requestContactPermissions(this, null, PERMISSION_REQUEST_READ_CONTACTS)) {
+            // permission is already granted
+            this.isSyncContacts = true;
+            preferenceService.setSyncContacts(this.isSyncContacts);
+            linkPhone();
+        }
+        // continue to onRequestPermissionsResult
+    }
+
+    @Override
+    public void onNicknameSet(String nickname) {
+        this.nickname = nickname;
+    }
+
+    @Override
+    public void onPhoneSet(String phoneNumber) {
+        this.number = phoneNumber;
+    }
+
+    @Override
+    public void onPrefixSet(String prefix) {
+        this.prefix = prefix;
+    }
+
+    @Override
+    public void onEmailSet(String email) {
+        this.email = email;
+    }
+
+    @Override
+    public void onSafePasswordSet(final String password) {
+        safePassword = password;
+    }
+
+    @Override
+    public void onSafeServerInfoSet(ThreemaSafeServerInfo safeServerInfo) {
+        this.safeServerInfo = safeServerInfo;
+    }
+
+    @Override
+    public String getNickname() {
+        return this.nickname;
+    }
+
+    @Override
+    public String getPhone() {
+        if (PHONE_LINKED_PLACEHOLDER.equals(this.number)) {
+            return this.number;
+        }
+
+        String phone = this.prefix + this.number;
+
+        if (localeService.validatePhoneNumber(phone)) {
+            return serviceManager.getLocaleService().getNormalizedPhoneNumber(phone);
+        }
+        return "";
+    }
+
+    @Override
+    public String getNumber() {
+        return this.number;
+    }
+
+    @Override
+    public String getPrefix() {
+        return this.prefix;
+    }
+
+    @Override
+    public String getEmail() {
+        return (this.email != null && this.email.length() > 4) ? this.email : "";
+    }
+
+    @Override
+    public String getPresetPhone() {
+        return this.presetMobile;
+    }
+
+    @Override
+    public String getPresetEmail() {
+        return this.presetEmail;
+    }
+
+    @Override
+    public boolean getSafeForcePasswordEntry() {
+        return safeConfig.isBackupForced();
+    }
+
+    @Override
+    public boolean getSafeSkipBackupPasswordEntry() {
+        return safeConfig.isSkipBackupPasswordEntry();
+    }
+
+    @Override
+    public boolean isSafeEnabled() {
+        return !safeConfig.isBackupDisabled();
+    }
+
+    @Override
+    public boolean isSafeForced() {
+        return safeConfig.isBackupForced();
+    }
+
+    @Override
+    public String getSafePassword() {
+        return this.safePassword;
+    }
+
+    @Override
+    public ThreemaSafeServerInfo getSafeServerInfo() {
+        return this.safeServerInfo;
+    }
+
+    @Override
+    public boolean getSyncContacts() {
+        return this.isSyncContacts;
+    }
+
+    @Override
+    public boolean isReadOnlyProfile() {
+        return this.readOnlyProfile;
+    }
+
+    @Override
+    public boolean isSkipWizard() {
+        return this.skipWizard;
+    }
+
+    /**
+     * Return whether the identity was just created
+     *
+     * @return true if it's a new identity, false if the identity was restored
+     */
+    public boolean isNewIdentity() {
+        return isNewIdentity;
+    }
+
+    @Override
+    public void onYes(String tag, Object data) {
+        switch (tag) {
+            case DIALOG_TAG_USE_ID_AS_NICKNAME:
+                this.nickname = this.userService.getIdentity();
+                break;
+            case DIALOG_TAG_PASSWORD_BAD_WORK:
+            case DIALOG_TAG_INVALID_ENTRY:
+                prevPage();
+                break;
+            case DIALOG_TAG_PASSWORD_BAD:
+            case DIALOG_TAG_THREEMA_SAFE:
+            case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
+                break;
+            case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
+            case DIALOG_TAG_SYNC_CONTACTS_MDM_ENABLE_RATIONALE:
+                requestContactSyncPermission();
+                break;
+            case DIALOG_TAG_APPLICATION_SETUP_RETRY:
+                runApplicationSetupStepsAndRestart();
+                break;
+        }
+    }
+
+    @Override
+    public void onNo(String tag) {
+        switch (tag) {
+            case DIALOG_TAG_USE_ID_AS_NICKNAME:
+                prevPage();
+                break;
+            case DIALOG_TAG_USE_ANONYMOUSLY:
+                setPage(WizardFragment3.PAGE_ID);
+                break;
+            case DIALOG_TAG_THREEMA_SAFE:
+                prevPage();
+                break;
+            case DIALOG_TAG_PASSWORD_BAD:
+                setPage(WizardFragment1.PAGE_ID);
+                break;
+            case DIALOG_TAG_SYNC_CONTACTS_ENABLE:
+                isSyncContacts = false;
+                this.serviceManager.getPreferenceService().setSyncContacts(false);
+                linkPhone();
+                break;
+            case DIALOG_TAG_PASSWORD_PRESET_CONFIRM:
+                finish();
+                System.exit(0);
+                break;
+        }
+    }
+
+    @Override
+    protected boolean enableOnBackPressedCallback() {
+        return true;
+    }
+
+    @Override
+    protected void handleOnBackPressed() {
+        if (prevButton != null && prevButton.getVisibility() == View.VISIBLE) {
+            prevPage();
+        }
+    }
+
+    private static class ScreenSlidePagerAdapter extends FragmentStatePagerAdapter {
+        public ScreenSlidePagerAdapter(FragmentManager fm) {
+            super(fm, FragmentStatePagerAdapter.BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT);
+        }
+
+        @Override
+        public Fragment getItem(int position) {
+            switch (position) {
+                case WizardFragment0.PAGE_ID:
+                    return new WizardFragment0();
+                case WizardFragment1.PAGE_ID:
+                    return new WizardFragment1();
+                case WizardFragment2.PAGE_ID:
+                    return new WizardFragment2();
+                case WizardFragment3.PAGE_ID:
+                    return new WizardFragment3();
+                case WizardFragment4.PAGE_ID:
+                    return new WizardFragment4();
+                default:
+                    break;
+            }
+            return null;
+        }
+
+        @Override
+        public int getCount() {
+            return NUM_PAGES;
+        }
+    }
+
+    public void nextPage() {
+        int currentItem = viewPager.getCurrentItem() + 1;
+        if (currentItem < NUM_PAGES) {
+            viewPager.setCurrentItem(currentItem);
+        }
+    }
+
+    public void prevPage() {
+        int currentItem = viewPager.getCurrentItem();
+        if (currentItem != 0) {
+            viewPager.setCurrentItem(currentItem - 1);
+        }
+    }
+
+    public void setPage(int page) {
+        viewPager.setCurrentItem(page);
+    }
+
+    @SuppressLint("StaticFieldLeak")
+    private void linkEmail(final WizardFragment4 fragment) {
+        final String newEmail = getEmail();
+        if (TestUtil.isEmptyOrNull(newEmail)) {
+            initSyncAndFinish();
+            return;
+        }
+
+        boolean isNewEmail = (!(presetEmail != null && presetEmail.equals(newEmail)));
+
+        if ((userService.getEmailLinkingState() != UserService.LinkingState_LINKED) && isNewEmail) {
+            new AsyncTask<Void, Void, String>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment.setEmailLinkingInProgress(true);
+                }
+
+                @Override
+                protected String doInBackground(Void... params) {
+                    try {
+                        userService.linkWithEmail(email);
+                    } catch (LinkEmailException e) {
+                        logger.error("Exception", e);
+                        return e.getMessage();
+                    } catch (Exception e) {
+                        logger.error("Exception", e);
+                        return getString(R.string.internet_connection_required);
+                    }
+                    return null;
+                }
+
+                @Override
+                protected void onPostExecute(String result) {
+                    if (result != null) {
+                        fragment.setEmailLinkingAlert(result);
+                        errorRaised = true;
+                    } else {
+                        fragment.setEmailLinkingInProgress(false);
+                    }
+                    initSyncAndFinish();
+                }
+            }.execute();
+        } else {
+            initSyncAndFinish();
+        }
+    }
+
+    @SuppressLint("StaticFieldLeak")
+    private void linkPhone() {
+        final String phone = getPhone();
+        if (TestUtil.isEmptyOrNull(phone)) {
+            linkEmail(fragment4);
+            return;
+        }
+
+        boolean isNewPhoneNumber = (presetMobile == null || !presetMobile.equals(phone));
+
+        // start linking activity only if not already linked
+        if ((userService.getMobileLinkingState() != UserService.LinkingState_LINKED) && isNewPhoneNumber) {
+            new AsyncTask<Void, Void, String>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment4.setMobileLinkingInProgress(true);
+                }
+
+                @Override
+                protected String doInBackground(Void... params) {
+                    try {
+                        userService.linkWithMobileNumber(phone);
+                    } catch (LinkMobileNoException e) {
+                        logger.error("Exception", e);
+                        return e.getMessage();
+                    } catch (Exception e) {
+                        logger.error("Exception", e);
+                        return getString(R.string.internet_connection_required);
+                    }
+                    return null;
+                }
+
+                @Override
+                protected void onPostExecute(String result) {
+                    if (result != null) {
+                        fragment4.setMobileLinkingAlert(result);
+                        errorRaised = true;
+                    } else {
+                        fragment4.setMobileLinkingInProgress(false);
+                    }
+                    linkEmail(fragment4);
+                }
+            }.execute();
+        } else {
+            linkEmail(fragment4);
+        }
+    }
+
+    @WorkerThread
+    private void addContact(final String identity, final String first, final String last) {
+        new BasicAddOrUpdateContactBackgroundTask(
+            identity,
+            ch.threema.storage.models.ContactModel.AcquaintanceLevel.DIRECT,
+            userService.getIdentity(),
+            apiConnector,
+            contactModelRepository,
+            AddContactRestrictionPolicy.IGNORE,
+            WizardBaseActivity.this,
+            null
+        ) {
+            @Override
+            public void onFinished(ContactResult result) {
+                ContactModel contactModel;
+                if (result instanceof ContactAvailable) {
+                    contactModel = ((ContactAvailable) result).getContactModel();
+                } else {
+                    contactModel = null;
+                }
+
+                if (contactModel != null) {
+                    contactModel.setNameFromLocal(first, last);
+                }
+            }
+        }.runSynchronously();
+    }
+
+    private void runApplicationSetupStepsAndRestart() {
+        backgroundExecutor.execute(new BackgroundTask<Boolean>() {
+            @Override
+            public void runBefore() {
+                // Nothing to do
+            }
+
+            @Override
+            public Boolean runInBackground() {
+                Boolean applicationSetupResult = runApplicationSetupSteps(serviceManager);
+
+                addContact(ThreemaApplication.ECHO_USER_IDENTITY, "Echo", "Test");
+
+                return applicationSetupResult;
+            }
+
+            @Override
+            public void runAfter(Boolean result) {
+                if (!Boolean.TRUE.equals(result)) {
+                    WizardDialog.newInstance(R.string.application_setup_steps_failed, R.string.retry)
+                        .show(getSupportFragmentManager(), DIALOG_TAG_APPLICATION_SETUP_RETRY);
+                    return;
+                }
+
+                preferenceService.setWizardRunning(false);
+                preferenceService.setLatestVersion(WizardBaseActivity.this);
+
+                // Flush conversation cache (after a restore) to ensure that the conversation list
+                // will be loaded from the database to prevent the list being incomplete.
+                try {
+                    serviceManager.getConversationService().reset();
+                } catch (Exception e) {
+                    logger.error("Exception", e);
+                }
+
+                ConfigUtils.recreateActivity(WizardBaseActivity.this);
+            }
+        });
+    }
+
+    private void ensureMasterKeyWrite() {
+        // Write master key now if no passphrase has been set - don't leave it up to the MainActivity
+        if (!ThreemaApplication.getMasterKey().isProtected()) {
+            try {
+                ThreemaApplication.getMasterKey().setPassphrase(null);
+            } catch (Exception e) {
+                // better die if something went wrong as the master key may not have been saved
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    @SuppressLint({"StaticFieldLeak", "MissingPermission"})
+    private void reallySyncContactsAndFinish() {
+        ensureMasterKeyWrite();
+
+        if (preferenceService.isSyncContacts()) {
+            new AsyncTask<Void, Void, Void>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment4.setContactsSyncInProgress(true, getString(R.string.wizard1_sync_contacts));
+                }
+
+                @SuppressLint("MissingPermission")
+                @Override
+                protected Void doInBackground(Void... params) {
+                    try {
+                        final Account account = userService.getAccount(true);
+                        //disable
+                        userService.enableAccountAutoSync(false);
+
+                        SynchronizeContactsService synchronizeContactsService = serviceManager.getSynchronizeContactsService();
+                        SynchronizeContactsRoutine routine = synchronizeContactsService.instantiateSynchronization(account);
+
+                        routine.setOnStatusUpdate(new SynchronizeContactsRoutine.OnStatusUpdate() {
+                            @Override
+                            public void newStatus(final long percent, final String message) {
+                                RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(true, message));
+                            }
+
+                            @Override
+                            public void error(final Exception x) {
+                                RuntimeUtil.runOnUiThread(() -> fragment4.setContactsSyncInProgress(false, x.getMessage()));
+                            }
+                        });
+
+                        //on finished, close the dialog
+                        routine.addOnFinished((success, modifiedAccounts, createdContacts, deletedAccounts) -> userService.enableAccountAutoSync(true));
+
+                        routine.run();
+                    } catch (MasterKeyLockedException | FileSystemNotPresentException e) {
+                        logger.error("Exception", e);
+                    }
+                    return null;
+                }
+
+                @Override
+                protected void onPostExecute(Void result) {
+                    finishHandler.removeCallbacks(finishTask);
+                    finishHandler.postDelayed(finishTask, FINISH_DELAY);
+                }
+            }.execute();
+        } else {
+            userService.removeAccount();
+            prepareThreemaSafe();
+        }
+    }
+
+    @SuppressLint("StaticFieldLeak")
+    private void prepareThreemaSafe() {
+        if (!TestUtil.isEmptyOrNull(getSafePassword())) {
+            new AsyncTask<Void, Void, byte[]>() {
+                @Override
+                protected void onPreExecute() {
+                    fragment4.setThreemaSafeInProgress(true, getString(R.string.preparing_threema_safe));
+                }
+
+                @Override
+                protected byte[] doInBackground(Void... voids) {
+                    return threemaSafeService.deriveMasterKey(getSafePassword(), userService.getIdentity());
+                }
+
+                @Override
+                protected void onPostExecute(byte[] masterkey) {
+                    fragment4.setThreemaSafeInProgress(false, getString(R.string.menu_done));
+
+                    if (masterkey != null) {
+                        threemaSafeService.storeMasterKey(masterkey);
+                        preferenceService.setThreemaSafeServerInfo(safeServerInfo);
+                        threemaSafeService.setEnabled(true);
+                        threemaSafeService.uploadNow(true);
+                    } else {
+                        Toast.makeText(WizardBaseActivity.this, R.string.safe_error_preparing, Toast.LENGTH_LONG).show();
+                    }
+
+                    runApplicationSetupStepsAndRestart();
+                }
+            }.execute();
+        } else {
+            // no password was set
+            // do not save mdm settings if backup is forced and no password was set - this will cause a password prompt later
+            if (!(ConfigUtils.isWorkRestricted() && ThreemaSafeMDMConfig.getInstance().isBackupForced())) {
+                threemaSafeService.storeMasterKey(new byte[0]);
+            }
+            runApplicationSetupStepsAndRestart();
+        }
+    }
+
+    private void initSyncAndFinish() {
+        if (!errorRaised || ConfigUtils.isWorkRestricted()) {
+            syncContactsAndFinish();
+        } else {
+            resetUi();
+        }
+    }
+
+    private void resetUi() {
+        // unlock UI to try again
+        viewPager.lock(false);
+        prevButton.setVisibility(View.VISIBLE);
+        if (finishButton != null) {
+            finishButton.setEnabled(true);
+        }
+    }
+
+    private void syncContactsAndFinish() {
+        /* trigger a connection now - as application lifecycle was set to resumed state when there was no identity yet */
+        serviceManager.getLifetimeService().ensureConnection();
+
+        if (this.isSyncContacts) {
+            preferenceService.setSyncContacts(true);
+            reallySyncContactsAndFinish();
+        } else {
+            preferenceService.setSyncContacts(false);
+            prepareThreemaSafe();
+        }
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
+        if (requestCode == PERMISSION_REQUEST_READ_CONTACTS) {
+            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+                this.isSyncContacts = true;
+                linkPhone();
+            } else if (userCannotChangeContactSync) {
+                ConfigUtils.showPermissionRationale(this, (View) viewPager.getParent(), R.string.permission_contacts_sync_required);
+                resetUi();
+            } else {
+                this.isSyncContacts = false;
+                linkPhone();
+            }
+        }
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java b/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java
index e1aeaccd..bcc8d654 100644
--- a/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/wizard/WizardSafeRestoreActivity.java
@@ -297,7 +297,7 @@ public class WizardSafeRestoreActivity extends WizardBackgroundActivity implemen
 
 			@Override
 			public Boolean runInBackground() {
-				return runApplicationSetupSteps(serviceManager, WizardSafeRestoreActivity.this);
+				return runApplicationSetupSteps(serviceManager);
 			}
 
 			@Override
diff --git a/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java b/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java
index 759f139c..c6332f68 100644
--- a/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java
+++ b/app/src/main/java/ch/threema/app/activities/wizard/WizardStartActivity.java
@@ -42,7 +42,7 @@ import static ch.threema.app.backuprestore.csv.RestoreService.RESTORE_COMPLETION
 
 public class WizardStartActivity extends WizardBackgroundActivity {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("WizardStartActivity");
-	boolean doFinish = false;
+	boolean nextActivityLaunched = false;
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState) {
@@ -98,7 +98,12 @@ public class WizardStartActivity extends WizardBackgroundActivity {
 		return frameAnimation;
 	}
 
-	private void launchNextActivity(ActivityOptionsCompat options) {
+	private synchronized void launchNextActivity(ActivityOptionsCompat options) {
+        if (nextActivityLaunched) {
+            // If the next activity already has been launched, we can just return here.
+            return;
+        }
+
 		Intent intent;
 
 		if (userService != null && userService.hasIdentity()) {
@@ -122,13 +127,14 @@ public class WizardStartActivity extends WizardBackgroundActivity {
 			startActivity(intent);
 			overridePendingTransition(R.anim.abc_fade_in, R.anim.abc_fade_out);
 		}
-		doFinish = true;
+		nextActivityLaunched = true;
 	}
 
 	@Override
 	public void onStop() {
 		super.onStop();
-		if (doFinish)
-			finish();
+		if (nextActivityLaunched) {
+            finish();
+        }
 	}
 }
diff --git a/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java b/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java
index d898d07b..cef488b1 100644
--- a/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/ContactDetailAdapter.java
@@ -66,6 +66,9 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ViewUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.domain.models.ReadReceiptPolicy;
+import ch.threema.domain.models.TypingIndicatorPolicy;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.protobuf.csp.e2e.fs.Terminate;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
@@ -87,18 +90,17 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
     private static final int TYPE_HEADER = 0;
     private static final int TYPE_ITEM = 1;
 
-    private final Context context;
-    private ContactService contactService;
-    private GroupService groupService;
-    private PreferenceService preferenceService;
-    private IdListService excludeFromSyncListService;
-    private IdListService blockedContactsService;
-    @Deprecated
-    private final ContactModel contactModel;
-    private final @NonNull ContactModelData contactModelData;
-    private final List<GroupModel> values;
-    private OnClickListener onClickListener;
-    private final @NonNull RequestManager requestManager;
+	private final Context context;
+	private ContactService contactService;
+	private GroupService groupService;
+	private PreferenceService preferenceService;
+	private IdListService excludeFromSyncListService;
+	private IdListService blockedContactsService;
+	private final @NonNull ch.threema.data.models.ContactModel contactModel;
+	private final @NonNull ContactModelData contactModelData;
+	private final List<GroupModel> values;
+	private OnClickListener onClickListener;
+	private final @NonNull RequestManager requestManager;
 
     public static class ItemHolder extends RecyclerView.ViewHolder {
         public final @NonNull View view;
@@ -163,28 +165,34 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
                 return true;
             });
 
-            // When clicking ten times on the Threema ID, the clear forward security session button
-            // becomes visible.
-            threemaIdView.setOnClickListener(v -> {
-                onThreemaIDClickCount++;
-                if (onThreemaIDClickCount >= 10) {
-                    onThreemaIDClickCount = 0;
-                    clearForwardSecuritySection.setVisibility(View.VISIBLE);
-                    clearForwardSecurityButton.setOnClickListener(clearButton -> {
-                        try {
-                            ThreemaApplication.requireServiceManager()
-                                .getTaskCreator()
-                                .scheduleDeleteAndTerminateFSSessionsTaskAsync(
-                                    contactModel,
-                                    Terminate.Cause.RESET
-                                );
-                            Toast.makeText(clearButton.getContext(), R.string.forward_security_cleared, Toast.LENGTH_LONG).show();
-                        } catch (Exception e) {
-                            Toast.makeText(clearButton.getContext(), e.getMessage(), Toast.LENGTH_LONG).show();
-                        }
-                    });
-                }
-            });
+			// When clicking ten times on the Threema ID, the clear forward security session button
+			// becomes visible.
+			threemaIdView.setOnClickListener(v -> {
+				onThreemaIDClickCount++;
+				if (onThreemaIDClickCount >= 10) {
+					onThreemaIDClickCount = 0;
+					clearForwardSecuritySection.setVisibility(View.VISIBLE);
+					clearForwardSecurityButton.setOnClickListener(clearButton -> {
+						ContactModel contactModel = contactService.getByIdentity(contactModelData.identity);
+						if (contactModel == null) {
+							logger.error("Contact model is null. Cannot schedule fs session deletion task.");
+							return;
+						}
+
+						try {
+							ThreemaApplication.requireServiceManager()
+								.getTaskCreator()
+								.scheduleDeleteAndTerminateFSSessionsTaskAsync(
+									contactModel,
+									Terminate.Cause.RESET
+								);
+							Toast.makeText(clearButton.getContext(), R.string.forward_security_cleared, Toast.LENGTH_LONG).show();
+						} catch (Exception e) {
+							Toast.makeText(clearButton.getContext(), e.getMessage(), Toast.LENGTH_LONG).show();
+						}
+					});
+				}
+			});
 
             publicNickNameView.setOnLongClickListener(ignored -> {
                 copyTextToClipboard(contactModelData.nickname, R.string.contact_details_nickname_copied);
@@ -209,19 +217,19 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
         }
     }
 
-    @UiThread
-    public ContactDetailAdapter(
-        Context context,
-        List<GroupModel> values,
-        ContactModel contactModel,
-        @NonNull ContactModelData contactModelData,
-        @NonNull RequestManager requestManager
-    ) {
-        this.context = context;
-        this.values = values;
-        this.contactModel = contactModel;
-        this.contactModelData = contactModelData;
-        this.requestManager = requestManager;
+	@UiThread
+	public ContactDetailAdapter(
+		Context context,
+		List<GroupModel>values,
+		@NonNull ch.threema.data.models.ContactModel contactModel,
+		@NonNull ContactModelData contactModelData,
+		@NonNull RequestManager requestManager
+	) {
+		this.context = context;
+		this.values = values;
+		this.contactModel = contactModel;
+		this.contactModelData = contactModelData;
+		this.requestManager = requestManager;
 
         try {
             ServiceManager serviceManager = ThreemaApplication.requireServiceManager();
@@ -280,40 +288,45 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
         } else {
             HeaderHolder headerHolder = (HeaderHolder) holder;
 
-            String identityAdditional = null;
-            switch (this.contactModelData.activityState) {
-                case ACTIVE:
-                    if (blockedContactsService.has(contactModelData.identity)) {
-                        identityAdditional = context.getString(R.string.blocked);
-                    }
-                    break;
-                case INACTIVE:
-                    identityAdditional = context.getString(R.string.contact_state_inactive);
-                    break;
-                case INVALID:
-                    identityAdditional = context.getString(R.string.contact_state_invalid);
-                    break;
-            }
-
-            final boolean shouldShowJobTitle = contactModel.isWork() && contactModelData.jobTitle != null && !contactModelData.jobTitle.isBlank();
+			String identityAdditional = null;
+			switch (this.contactModelData.activityState) {
+				case ACTIVE:
+					if (blockedContactsService.has(contactModelData.identity)) {
+						identityAdditional = context.getString(R.string.blocked);
+					}
+					break;
+				case INACTIVE:
+					identityAdditional = context.getString(R.string.contact_state_inactive);
+					break;
+				case INVALID:
+					identityAdditional = context.getString(R.string.contact_state_invalid);
+					break;
+			}
+
+            final boolean shouldShowJobTitle = contactModelData.workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+                && contactModelData.jobTitle != null && !contactModelData.jobTitle.isBlank();
             ViewUtil.show(headerHolder.jobTitleHeaderView, shouldShowJobTitle);
             ViewUtil.show(headerHolder.jobTitleTextView, shouldShowJobTitle);
             if (shouldShowJobTitle) {
                 headerHolder.jobTitleTextView.setText(contactModelData.jobTitle);
             }
 
-            final boolean shouldShowDepartment = contactModel.isWork() && contactModelData.department != null && !contactModelData.department.isBlank();
+            final boolean shouldShowDepartment = contactModelData.workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
+                && contactModelData.department != null && !contactModelData.department.isBlank();
             ViewUtil.show(headerHolder.departmentHeaderView, shouldShowDepartment);
             ViewUtil.show(headerHolder.departmentTextView, shouldShowDepartment);
             if (shouldShowDepartment) {
                 headerHolder.departmentTextView.setText(contactModelData.department);
             }
 
-            headerHolder.threemaIdView.setText(
-                contactModelData.identity + (identityAdditional != null ? " (" + identityAdditional + ")" : "")
-            );
-            headerHolder.verificationLevelImageView.setContactModel(contactModel);
-            headerHolder.verificationLevelImageView.setVisibility(View.VISIBLE);
+			headerHolder.threemaIdView.setText(
+				contactModelData.identity + (identityAdditional != null ? " (" + identityAdditional + ")" : "")
+			);
+			headerHolder.verificationLevelImageView.setVerificationLevel(
+				contactModelData.verificationLevel,
+				contactModelData.workVerificationLevel
+			);
+			headerHolder.verificationLevelImageView.setVisibility(View.VISIBLE);
 
             boolean isSyncExcluded = excludeFromSyncListService.has(contactModelData.identity);
 
@@ -323,18 +336,18 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
             ) {
                 headerHolder.synchronizeContainer.setVisibility(View.VISIBLE);
 
-                Drawable icon = null;
-                try {
-                    icon = AndroidContactUtil.getInstance().getAccountIcon(contactModel);
-                } catch (SecurityException e) {
-                    logger.error("Could not access android account icon", e);
-                }
-                if (icon != null) {
-                    headerHolder.syncSourceIcon.setImageDrawable(icon);
-                    headerHolder.syncSourceIcon.setVisibility(View.VISIBLE);
-                } else {
-                    headerHolder.syncSourceIcon.setVisibility(View.GONE);
-                }
+				Drawable icon = null;
+				try {
+					icon = AndroidContactUtil.getInstance().getAccountIcon(contactModelData.androidContactLookupKey);
+				} catch (SecurityException e) {
+					logger.error("Could not access android account icon", e);
+				}
+				if (icon != null) {
+					headerHolder.syncSourceIcon.setImageDrawable(icon);
+					headerHolder.syncSourceIcon.setVisibility(View.VISIBLE);
+				} else {
+					headerHolder.syncSourceIcon.setVisibility(View.GONE);
+				}
 
                 headerHolder.synchronize.setChecked(isSyncExcluded);
                 headerHolder.synchronize.setOnCheckedChangeListener((buttonView, isChecked) -> {
@@ -361,31 +374,10 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
                 headerHolder.groupMembershipTitle.setVisibility(View.GONE);
             }
 
-            final String[] choices = context.getResources().getStringArray(R.array.receipts_override_choices);
-            choices[0] = context.getString(R.string.receipts_override_choice_default,
-                choices[preferenceService.isReadReceipts() ? 1 : 2]);
-
-            ArrayAdapter<String> readReceiptsAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, choices);
-            headerHolder.readReceiptsSpinner.setAdapter(readReceiptsAdapter);
-            headerHolder.readReceiptsSpinner.setText(choices[contactModel.getReadReceipts()], false);
-            headerHolder.readReceiptsSpinner.setOnItemClickListener((parent, view, position1, id) -> {
-                contactModel.setReadReceipts(position1);
-                contactService.save(contactModel);
-            });
-
-            final String[] typingChoices = context.getResources().getStringArray(R.array.receipts_override_choices);
-            typingChoices[0] = context.getString(R.string.receipts_override_choice_default,
-                typingChoices[preferenceService.isTypingIndicator() ? 1 : 2]);
-
-            ArrayAdapter<String> typingIndicatorAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, typingChoices);
-            headerHolder.typingIndicatorsSpinner.setAdapter(typingIndicatorAdapter);
-            headerHolder.typingIndicatorsSpinner.setText(typingChoices[contactModel.getTypingIndicators()], false);
-            headerHolder.typingIndicatorsSpinner.setOnItemClickListener((parent, view, position12, id) -> {
-                contactModel.setTypingIndicators(position12);
-                contactService.save(contactModel);
-            });
-        }
-    }
+			initializeReadReceiptsSpinner(headerHolder);
+			initializeTypingIndicatorSpinner(headerHolder);
+		}
+	}
 
     @Override
     public int getItemCount() {
@@ -418,4 +410,83 @@ public class ContactDetailAdapter extends RecyclerView.Adapter<RecyclerView.View
         void onVerificationInfoClick(View v);
     }
 
+	private void initializeReadReceiptsSpinner(@NonNull HeaderHolder headerHolder) {
+		final String[] choices = context.getResources().getStringArray(R.array.receipts_override_choices);
+		choices[0] = context.getString(R.string.receipts_override_choice_default,
+			choices[preferenceService.isReadReceipts() ? 1 : 2]);
+
+		int initialReadReceiptPosition;
+		switch (contactModelData.readReceiptPolicy) {
+			case SEND:
+				initialReadReceiptPosition = 1;
+				break;
+			case DONT_SEND:
+				initialReadReceiptPosition = 2;
+				break;
+			case DEFAULT:
+			default:
+				initialReadReceiptPosition = 0;
+				break;
+		}
+		ArrayAdapter<String> readReceiptsAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, choices);
+		headerHolder.readReceiptsSpinner.setAdapter(readReceiptsAdapter);
+		headerHolder.readReceiptsSpinner.setText(choices[initialReadReceiptPosition], false);
+		headerHolder.readReceiptsSpinner.setOnItemClickListener((parent, view, readReceiptPosition, id) -> {
+			switch (readReceiptPosition) {
+				case 0:
+					contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.DEFAULT);
+					break;
+				case 1:
+					contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.SEND);
+					break;
+				case 2:
+					contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.DONT_SEND);
+					break;
+				default:
+					logger.warn("Invalid position for read receipt policy: {}", readReceiptPosition);
+					break;
+			}
+		});
+	}
+
+	private void initializeTypingIndicatorSpinner(@NonNull HeaderHolder headerHolder) {
+		final String[] typingChoices = context.getResources().getStringArray(R.array.receipts_override_choices);
+		typingChoices[0] = context.getString(R.string.receipts_override_choice_default,
+			typingChoices[preferenceService.isTypingIndicator() ? 1 : 2]);
+
+		int initialTypingIndicatorPosition;
+		switch (contactModelData.typingIndicatorPolicy) {
+			case SEND:
+				initialTypingIndicatorPosition = 1;
+				break;
+			case DONT_SEND:
+				initialTypingIndicatorPosition = 2;
+				break;
+			case DEFAULT:
+			default:
+				initialTypingIndicatorPosition = 0;
+				break;
+		}
+
+		ArrayAdapter<String> typingIndicatorAdapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, typingChoices);
+		headerHolder.typingIndicatorsSpinner.setAdapter(typingIndicatorAdapter);
+		headerHolder.typingIndicatorsSpinner.setText(typingChoices[initialTypingIndicatorPosition], false);
+		headerHolder.typingIndicatorsSpinner.setOnItemClickListener((parent, view, typingIndicatorPosition, id) -> {
+			switch (typingIndicatorPosition) {
+				case 0:
+					contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.DEFAULT);
+					break;
+				case 1:
+					contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.SEND);
+					break;
+				case 2:
+					contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.DONT_SEND);
+					break;
+				default:
+					logger.warn("Invalid position for typing indicator policy: {}", typingIndicatorPosition);
+					break;
+			}
+		});
+	}
+
 }
diff --git a/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java b/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java
index e4f0496f..1c41a0bc 100644
--- a/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/ContactListAdapter.java
@@ -398,9 +398,12 @@ public class ContactListAdapter extends FilterableListAdapter implements Section
         );
         AdapterUtil.styleContact(holder.contactTextBottomRight, contactModel);
 
-        if (holder.verificationLevelView != null) {
-            holder.verificationLevelView.setContactModel(contactModel);
-        }
+		if (holder.verificationLevelView != null) {
+			holder.verificationLevelView.setVerificationLevel(
+				contactModel.verificationLevel,
+				contactModel.getWorkVerificationLevel()
+			);
+		}
 
         ViewUtil.show(
             holder.blockedContactView,
diff --git a/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java b/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java
index 531e7079..057a8c9d 100644
--- a/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/ContactsSyncAdapter.java
@@ -30,12 +30,9 @@ import android.os.Bundle;
 
 import org.slf4j.Logger;
 
-import java.util.List;
-
 import androidx.localbroadcastmanager.content.LocalBroadcastManager;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
-import ch.threema.app.listeners.NewSyncedContactsListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.routines.SynchronizeContactsRoutine;
@@ -43,19 +40,34 @@ import ch.threema.app.services.SynchronizeContactsService;
 import ch.threema.app.utils.IntentDataUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
 
 public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("ContactsSyncAdapter");
 
+	private boolean isSyncEnabled = true;
+
 	public ContactsSyncAdapter(Context context, boolean autoInitialize) {
 		super(context, autoInitialize);
 	}
 
+	public void setSyncEnabled(boolean enabled) {
+		isSyncEnabled = enabled;
+	}
+
 	@Override
 	public void onPerformSync(Account account, Bundle extras, String authority, ContentProviderClient provider, SyncResult syncResult) {
 		logger.info("onPerformSync");
 
+		if (!isSyncEnabled) {
+			logger.info("Contact sync is disabled; retry later.");
+			// Workaround to trigger a soft error to retry the sync at a later moment
+			// See
+			//  - https://developer.android.com/reference/android/content/SyncResult#hasSoftError()
+			//  - https://developer.android.com/reference/android/content/SyncResult#SyncResult()
+			syncResult.stats.numIoExceptions++;
+			return;
+		}
+
 		try {
 			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
 
@@ -66,10 +78,7 @@ public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 			if (serviceManager.getPreferenceService().isSyncContacts()) {
 				logger.info("Start sync adapter run");
 				SynchronizeContactsService synchronizeContactsService = serviceManager.getSynchronizeContactsService();
-				if (synchronizeContactsService == null) {
-					return;
 
-				}
 				if (synchronizeContactsService.isFullSyncInProgress()) {
 					logger.info("A full sync is already running");
 					syncResult.stats.numUpdates = 0;
@@ -82,29 +91,21 @@ public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 				SynchronizeContactsRoutine routine = synchronizeContactsService.instantiateSynchronization(account);
 				//update stats on finished to resolve the "every minute sync" bug
 
-				routine.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
-					@Override
-					public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
-						// let user know that contact was added
-						ListenerManager.newSyncedContactListener.handle(new ListenerManager.HandleListener<NewSyncedContactsListener>() {
-							@Override
-							public void handle(NewSyncedContactsListener listener) {
-								listener.onNew(createdContacts);
-							}
-						});
-
-						//hack to not schedule the next sync!
-						syncResult.stats.numUpdates = 0;//modifiedAccounts;
-						syncResult.stats.numInserts = 0;//createdAccounts;
-						syncResult.stats.numDeletes = 0;//deletedAccounts;
-						syncResult.stats.numEntries = 0;//createdAccounts;
-
-						//send a broadcast to let others know that the list has changed
-						LocalBroadcastManager.getInstance(ThreemaApplication.getAppContext()).sendBroadcast(IntentDataUtil.createActionIntentContactsChanged());
-					}
+				routine.addOnFinished((success, modifiedAccounts, createdContacts, deletedAccounts) -> {
+					// let user know that contact was added
+					ListenerManager.newSyncedContactListener.handle(listener -> listener.onNew(createdContacts));
+
+					//hack to not schedule the next sync!
+					syncResult.stats.numUpdates = 0;//modifiedAccounts;
+					syncResult.stats.numInserts = 0;//createdAccounts;
+					syncResult.stats.numDeletes = 0;//deletedAccounts;
+					syncResult.stats.numEntries = 0;//createdAccounts;
+
+					//send a broadcast to let others know that the list has changed
+					LocalBroadcastManager.getInstance(ThreemaApplication.getAppContext()).sendBroadcast(IntentDataUtil.createActionIntentContactsChanged());
 				});
 
-				//not in a thread!
+				// not in a thread: `onPerformSync` is already called in a background thread
 				routine.run();
 			}
 		}
@@ -115,10 +116,13 @@ public class ContactsSyncAdapter extends AbstractThreadedSyncAdapter {
 			logger.debug("MasterKeyLockedException [" + e.getMessage() + "]");
 
 		}finally{
-			logger.debug("sync finished Sync [numEntries=" + String.valueOf(syncResult.stats.numEntries) +
-				", updates=" + String.valueOf(syncResult.stats.numUpdates) +
-				", inserts=" + String.valueOf(syncResult.stats.numInserts) +
-				", deletes=" + String.valueOf(syncResult.stats.numDeletes) + "]");
+			logger.debug(
+				"sync finished Sync [numEntries={}, updates={}, inserts={}, deletes={}",
+				syncResult.stats.numEntries,
+				syncResult.stats.numUpdates,
+				syncResult.stats.numInserts,
+				syncResult.stats.numDeletes
+			);
 		}
 	}
 
diff --git a/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java b/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java
index 96c86953..7d80e9ee 100644
--- a/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/GroupDetailAdapter.java
@@ -164,7 +164,7 @@ public class GroupDetailAdapter extends RecyclerView.Adapter<RecyclerView.ViewHo
 			boolean isOrphanedGroup = groupService.isOrphanedGroup(groupModel);
 			boolean isCreator = groupService.isGroupCreator(groupModel);
 			boolean isMember = groupService.isGroupMember(groupModel);
-			boolean hasOtherMembers = groupService.getOtherMemberCount(groupModel) > 0;
+			boolean hasOtherMembers = groupService.countMembersWithoutUser(groupModel) > 0;
 
 			if (isOrphanedGroup) {
 				// Show orphaned group notice
diff --git a/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java b/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java
index 17084df1..da79640c 100644
--- a/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java
+++ b/app/src/main/java/ch/threema/app/adapters/UserListAdapter.java
@@ -171,7 +171,10 @@ public class UserListAdapter extends FilterableListAdapter {
 				blockedContactsService != null && blockedContactsService.has(contactModel.getIdentity())
 		);
 
-		holder.verificationLevelView.setContactModel(contactModel);
+		holder.verificationLevelView.setVerificationLevel(
+			contactModel.verificationLevel,
+			contactModel.getWorkVerificationLevel()
+		);
 
 		String lastMessageDateString = null;
 		MessageReceiver messageReceiver = this.contactService.createReceiver(contactModel);
diff --git a/app/src/main/java/ch/threema/app/adapters/decorators/AnimatedImageDrawableDecorator.java b/app/src/main/java/ch/threema/app/adapters/decorators/AnimatedImageDrawableDecorator.java
deleted file mode 100644
index 489dc8e2..00000000
--- a/app/src/main/java/ch/threema/app/adapters/decorators/AnimatedImageDrawableDecorator.java
+++ /dev/null
@@ -1,293 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.adapters.decorators;
-
-import android.app.Activity;
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Toast;
-
-import com.bumptech.glide.Glide;
-
-import org.slf4j.Logger;
-
-import java.io.File;
-
-import ch.threema.app.R;
-import ch.threema.app.services.MessageServiceImpl;
-import ch.threema.app.services.messageplayer.MessagePlayer;
-import ch.threema.app.services.messageplayer.AnimatedImageDrawableMessagePlayer;
-import ch.threema.app.ui.ControllerView;
-import ch.threema.app.ui.listitemholder.ComposeMessageHolder;
-import ch.threema.app.utils.FileUtil;
-import ch.threema.app.utils.RuntimeUtil;
-import ch.threema.app.utils.TestUtil;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.messages.file.FileData;
-import ch.threema.storage.models.AbstractMessageModel;
-import ch.threema.storage.models.MessageState;
-import ch.threema.storage.models.data.media.FileDataModel;
-
-/**
- * A decorator for animated image formats natively supported by AnimatedImageDrawable and/or by Glide
- */
-public class AnimatedImageDrawableDecorator extends ChatAdapterDecorator {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("AnimatedImageDrawableDecorator");
-
-	private static final String LISTENER_TAG = "decorator";
-	private AnimatedImageDrawableMessagePlayer animatedImageDrawableMessagePlayer;
-
-	public AnimatedImageDrawableDecorator(Context context, AbstractMessageModel messageModel, Helper decoratorHelper) {
-		super(context, messageModel, decoratorHelper);
-	}
-
-	@Override
-	protected void configureChatMessage(final ComposeMessageHolder holder, final int position) {
-		final long fileSize;
-
-		super.configureChatMessage(holder, position);
-
-		logger.debug("configureChatMessage - position " + position);
-
-		animatedImageDrawableMessagePlayer = (AnimatedImageDrawableMessagePlayer) getMessagePlayerService().createPlayer(getMessageModel(), (Activity) getContext(), helper.getMessageReceiver(), null);
-		holder.messagePlayer = animatedImageDrawableMessagePlayer;
-
-		/*
-		 * setup click listeners
-		 */
-		if (holder.controller != null) {
-			holder.controller.setOnClickListener(v -> {
-				int status = holder.controller.getStatus();
-
-				switch (status) {
-					case ControllerView.STATUS_READY_TO_RETRY:
-						propagateControllerRetryClickToParent();
-						break;
-					case ControllerView.STATUS_READY_TO_PLAY:
-					case ControllerView.STATUS_READY_TO_DOWNLOAD:
-						animatedImageDrawableMessagePlayer.open();
-						break;
-					case ControllerView.STATUS_PROGRESSING:
-						if (getMessageModel().isOutbox() && (getMessageModel().getState() == MessageState.TRANSCODING ||
-							getMessageModel().getState() == MessageState.PENDING ||
-							getMessageModel().getState() == MessageState.SENDING ||
-							getMessageModel().getState() == MessageState.UPLOADING)) {
-							getMessageService().remove(getMessageModel());
-						} else {
-							animatedImageDrawableMessagePlayer.cancel();
-						}
-						break;
-					default:
-						// no action taken for other statuses
-						break;
-				}
-			});
-		}
-		setOnClickListener(v -> {
-			if (!isInChoiceMode()) {
-				if ((!getPreferenceService().isAnimationAutoplay() ||
-					holder.controller.getStatus() == ControllerView.STATUS_READY_TO_DOWNLOAD)) {
-					animatedImageDrawableMessagePlayer.open();
-				}
-				if (getPreferenceService().isAnimationAutoplay() && holder.controller.getStatus() == ControllerView.STATUS_NONE) {
-					animatedImageDrawableMessagePlayer.openInExternalPlayer();
-				}
-			}
-		}, holder.messageBlockView);
-
-		/*
-		 * get thumbnail
-		 */
-		Bitmap thumbnail;
-		try {
-			thumbnail = getFileService().getMessageThumbnailBitmap(getMessageModel(),
-				getThumbnailCache());
-		} catch (Exception e) {
-			logger.error("Exception", e);
-			thumbnail = null;
-		}
-
-
-		final FileDataModel fileData = getMessageModel().getFileData();
-		fileSize = fileData.getFileSize();
-
-		int width = getThumbnailWidth();
-		int height;
-		if (thumbnail != null) {
-			height = (int) ((float) thumbnail.getHeight() * getThumbnailWidth() / thumbnail.getWidth());
-		} else {
-			height = ViewGroup.LayoutParams.WRAP_CONTENT;
-		}
-
-		ViewGroup.LayoutParams params = holder.contentView.getLayoutParams();
-		params.width = width;
-		params.height = height;
-		holder.contentView.setLayoutParams(params);
-
-		params = holder.attachmentImage.getLayoutParams();
-		params.width = width;
-		params.height = height;
-		holder.attachmentImage.setLayoutParams(params);
-		holder.attachmentImage.setVisibility(View.VISIBLE);
-
-		Glide.with(getContext())
-			.load(thumbnail)
-			.optionalFitCenter()
-			.override(width, height)
-			.error(R.drawable.ic_image_outline)
-			.into(holder.attachmentImage);
-
-		holder.bodyTextView.setWidth(width);
-
-		if (holder.attachmentImage != null) {
-			holder.attachmentImage.invalidate();
-		}
-		if (fileData.getRenderingType() == FileData.RENDERING_STICKER) {
-			setStickerBackground(holder);
-		} else {
-			setDefaultBackground(holder);
-		}
-
-		configureBodyText(holder, fileData.getCaption());
-
-		RuntimeUtil.runOnUiThread(() -> setControllerState(holder, fileData, fileSize));
-
-		setDatePrefix(FileUtil.getFileMessageDatePrefix(getContext(), getMessageModel(), "WebP"));
-
-		animatedImageDrawableMessagePlayer
-				.attachContainer(holder.attachmentImage)
-				// decryption
-				.addListener(LISTENER_TAG, new MessagePlayer.DecryptionListener() {
-					@Override
-					public void onStart(AbstractMessageModel messageModel) {
-						RuntimeUtil.runOnUiThread(() -> {
-							if (!helper.getPreferenceService().isAnimationAutoplay()) {
-								holder.controller.setProgressing();
-							}
-						});
-					}
-
-					@Override
-					public void onEnd(final AbstractMessageModel messageModel, final boolean success, final String message, final File decryptedFile) {
-						RuntimeUtil.runOnUiThread(() -> {
-							holder.controller.setNeutral();
-							if (success) {
-								if (helper.getPreferenceService().isAnimationAutoplay()) {
-									holder.controller.setVisibility(View.INVISIBLE);
-								} else {
-									setControllerState(holder, messageModel.getFileData(), messageModel.getFileData().getFileSize());
-								}
-							} else {
-								holder.controller.setVisibility(View.GONE);
-								if (!TestUtil.isEmptyOrNull(message)) {
-									Toast.makeText(getContext(), message, Toast.LENGTH_LONG).show();
-								}
-							}
-						});
-					}
-				})
-				// download listener
-				.addListener(LISTENER_TAG, new MessagePlayer.DownloadListener() {
-					@Override
-					public void onStart(AbstractMessageModel messageModel) {
-						RuntimeUtil.runOnUiThread(() -> holder.controller.setProgressingDeterminate(100));
-					}
-
-					@Override
-					public void onStatusUpdate(AbstractMessageModel messageModel, final int progress) {
-						RuntimeUtil.runOnUiThread(() -> holder.controller.setProgress(progress));
-					}
-
-					@Override
-					public void onEnd(AbstractMessageModel messageModel, final boolean success, final String message) {
-						//hide progressbar
-						RuntimeUtil.runOnUiThread(() -> {
-							// report error
-							if (success) {
-								holder.controller.setPlay();
-							} else {
-								holder.controller.setReadyToDownload();
-								if (!TestUtil.isEmptyOrNull(message)) {
-									Toast.makeText(getContext(), message, Toast.LENGTH_LONG).show();
-								}
-							}
-						});
-					}
-				});
-
-	}
-
-	private void setControllerState(ComposeMessageHolder holder, FileDataModel fileData, long fileSize) {
-		if (getMessageModel().isOutbox()) {
-			// outgoing message
-			switch (getMessageModel().getState()) {
-				case TRANSCODING:
-					holder.controller.setTranscoding();
-					break;
-				case PENDING:
-				case UPLOADING:
-				case SENDING:
-					holder.controller.setProgressing();
-					break;
-				case SENDFAILED:
-				case FS_KEY_MISMATCH:
-					holder.controller.setRetry();
-					break;
-				default:
-					setAutoplay(fileData, fileSize, holder);
-			}
-		} else {
-			// incoming message
-			if (getMessageModel() != null && getMessageModel().getState() == MessageState.PENDING) {
-				if (fileData.isDownloaded()) {
-					holder.controller.setProgressing();
-				} else {
-					holder.controller.setProgressingDeterminate(100);
-				}
-			} else {
-				setAutoplay(fileData, fileSize, holder);
-			}
-		}
-	}
-
-	private void setAutoplay(FileDataModel fileData, long fileSize, ComposeMessageHolder holder) {
-		logger.debug("setAutoPlay holder position " + holder.position);
-
-		if (fileData.isDownloaded()) {
-			if (helper.getPreferenceService().isAnimationAutoplay() && animatedImageDrawableMessagePlayer != null) {
-				animatedImageDrawableMessagePlayer.autoPlay();
-				holder.controller.setVisibility(View.INVISIBLE);
-			} else {
-				holder.controller.setPlay();
-			}
-		} else {
-			if (helper.getPreferenceService().isAnimationAutoplay() && animatedImageDrawableMessagePlayer != null && fileSize < MessageServiceImpl.FILE_AUTO_DOWNLOAD_MAX_SIZE_ISO) {
-				animatedImageDrawableMessagePlayer.autoPlay();
-				holder.controller.setVisibility(View.INVISIBLE);
-			} else {
-				holder.controller.setReadyToDownload();
-			}
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/adapters/decorators/DeletedChatAdapterDecorator.kt b/app/src/main/java/ch/threema/app/adapters/decorators/DeletedChatAdapterDecorator.kt
deleted file mode 100644
index fd8b24c4..00000000
--- a/app/src/main/java/ch/threema/app/adapters/decorators/DeletedChatAdapterDecorator.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.adapters.decorators
-
-import android.content.Context
-import ch.threema.app.ui.listitemholder.ComposeMessageHolder
-import ch.threema.app.utils.MessageUtil
-import ch.threema.storage.models.AbstractMessageModel
-
-class DeletedChatAdapterDecorator(context: Context, messageModel: AbstractMessageModel, helper: Helper) : ChatAdapterDecorator(context, messageModel, helper) {
-    override fun configureChatMessage(holder: ComposeMessageHolder, position: Int) {
-        holder.dateView.text = MessageUtil.getDisplayDate(context, messageModel, true)
-        setOnClickListener({
-
-        }, holder.messageBlockView)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/AddContactAsyncTask.java b/app/src/main/java/ch/threema/app/asynctasks/AddContactAsyncTask.java
deleted file mode 100644
index 67cc550d..00000000
--- a/app/src/main/java/ch/threema/app/asynctasks/AddContactAsyncTask.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.asynctasks;
-
-import android.os.AsyncTask;
-import android.widget.Toast;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.NonNull;
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.utils.ConfigUtils;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.models.IdentityType;
-import ch.threema.domain.models.VerificationLevel;
-import ch.threema.storage.models.ContactModel;
-
-public class AddContactAsyncTask extends AsyncTask<Void, Void, Boolean> {
-    private static final Logger logger = LoggingUtil.getThreemaLogger("AddContactAsyncTask");
-
-    private final Runnable runOnCompletion;
-    private final String firstName, lastName, threemaId;
-    private final boolean markAsWorkVerified;
-
-    public AddContactAsyncTask(String firstname, String lastname, String identity, boolean markAsWorkVerified, Runnable runOnCompletion) {
-        this.firstName = firstname;
-        this.lastName = lastname;
-        this.threemaId = identity.toUpperCase();
-        this.runOnCompletion = runOnCompletion;
-        this.markAsWorkVerified = markAsWorkVerified;
-    }
-
-    @Override
-    protected Boolean doInBackground(Void... params) {
-        try {
-            return addContact(ThreemaApplication.requireServiceManager().getContactService());
-        } catch (Exception e) {
-            logger.error("Could not add contact", e);
-            return null;
-        }
-    }
-
-    @Override
-    protected void onPostExecute(Boolean added) {
-        if (added != null) {
-            if (added) {
-                Toast.makeText(ThreemaApplication.getAppContext(), R.string.creating_contact_successful, Toast.LENGTH_SHORT).show();
-            }
-
-            if (runOnCompletion != null) {
-                runOnCompletion.run();
-            }
-        } else {
-            Toast.makeText(ThreemaApplication.getAppContext(), R.string.add_contact_failed, Toast.LENGTH_SHORT).show();
-        }
-    }
-
-    private boolean addContact(@NonNull ContactService contactService) throws InvalidEntryException, PolicyViolationException, EntryAlreadyExistsException {
-        if (contactService.getByIdentity(this.threemaId) != null) {
-            logger.info("Contact already exists");
-            return false;
-        }
-
-        boolean force = (ConfigUtils.isOnPremBuild() || ConfigUtils.isWorkBuild()) && markAsWorkVerified;
-
-        ContactModel contactModel = contactService.createContactByIdentity(this.threemaId, force);
-
-        if (this.firstName != null && this.lastName != null) {
-            contactModel.setFirstName(this.firstName);
-            contactModel.setLastName(this.lastName);
-            contactService.save(contactModel);
-        }
-
-        if (contactModel.getIdentityType() == IdentityType.WORK || markAsWorkVerified) {
-            contactModel.setIsWork(true);
-
-            if(contactModel.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-                contactModel.verificationLevel = VerificationLevel.SERVER_VERIFIED;
-            }
-            contactService.save(contactModel);
-        }
-        return true;
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt b/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt
deleted file mode 100644
index e80b4a04..00000000
--- a/app/src/main/java/ch/threema/app/asynctasks/AddOrUpdateContactBackgroundTask.kt
+++ /dev/null
@@ -1,303 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.asynctasks
-
-import android.content.Context
-import ch.threema.app.R
-import ch.threema.app.utils.AppRestrictionUtil
-import ch.threema.app.utils.executor.BackgroundTask
-import ch.threema.base.ThreemaException
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.data.models.ContactModel
-import ch.threema.data.models.ContactModelData
-import ch.threema.data.repositories.ContactCreateException
-import ch.threema.data.repositories.ContactModelRepository
-import ch.threema.domain.models.IdentityState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.protocol.api.APIConnector
-import ch.threema.domain.protocol.api.APIConnector.FetchIdentityResult
-import ch.threema.domain.protocol.api.APIConnector.HttpConnectionException
-import ch.threema.domain.protocol.api.APIConnector.NetworkException
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import kotlinx.coroutines.runBlocking
-import java.net.HttpURLConnection
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("AddContactBackgroundTask")
-
-/**
- * This background task should be used if a new identity should be added to the contacts. The task
- * will fetch the public key, identity type, activity state, and feature mask from the server.
- *
- * If [expectedPublicKey] is set, this background task verifies that the public key matches before
- * adding the new contact. If the contact already exists, it checks that the public key matches and
- * returns [Failed] if it doesn't match.
- *
- * This task also updates the contact if it already exists. This includes changing the acquaintance
- * level from group to direct or changing the verification level to fully verified.
- *
- * Note that this task can be overridden and the behavior can be adjusted by overwriting [onBefore]
- * and [onFinished].
- */
-open class AddOrUpdateContactBackgroundTask(
-    protected val identity: String,
-    private val myIdentity: String,
-    private val apiConnector: APIConnector,
-    private val contactModelRepository: ContactModelRepository,
-    private val addContactRestrictionPolicy: AddContactRestrictionPolicy,
-    private val context: Context,
-    private val expectedPublicKey: ByteArray? = null,
-) : BackgroundTask<ContactAddResult> {
-
-    final override fun runBefore() {
-        onBefore()
-    }
-
-    final override fun runInBackground(): ContactAddResult {
-        if (identity == myIdentity) {
-            return failed(R.string.identity_already_exists)
-        }
-
-        // Update contact if it exists
-        contactModelRepository.getByIdentity(identity)?.let {
-            val data = it.data.value
-
-            if (data != null) {
-                return updateContact(it, data, expectedPublicKey)
-            }
-        }
-
-        // Only proceed if adding contacts is allowed
-        if (addContactRestrictionPolicy == AddContactRestrictionPolicy.CHECK
-            && AppRestrictionUtil.isAddContactDisabled(context)
-        ) {
-            return PolicyViolation
-        }
-
-        // Fetch the identity
-        val result = try {
-            apiConnector.fetchIdentity(identity)
-        } catch (e: Exception) {
-            logger.error("Failed to fetch identity", e)
-
-            when (e) {
-                is HttpConnectionException -> {
-                    if (e.errorCode == HttpURLConnection.HTTP_NOT_FOUND) {
-                        return failed(R.string.invalid_threema_id)
-                    } else {
-                        return failed(R.string.connection_error)
-                    }
-                }
-
-                is NetworkException, is ThreemaException -> {
-                    return failed(R.string.connection_error)
-                }
-
-                else -> {
-                    throw e
-                }
-            }
-        }
-
-        // Add the new contact
-        return addNewContact(result, expectedPublicKey)
-    }
-
-    final override fun runAfter(result: ContactAddResult) {
-        onFinished(result)
-    }
-
-    /**
-     * This will be run before the contact is being fetched from the server.
-     */
-    open fun onBefore() {}
-
-    /**
-     * As soon as the contact has been added or an error occurred, this method is run with the
-     * provided result.
-     */
-    open fun onFinished(result: ContactAddResult) {}
-
-    private fun addNewContact(
-        result: FetchIdentityResult,
-        expectedPublicKey: ByteArray?,
-    ): ContactAddResult {
-        val verificationLevel = if (expectedPublicKey != null) {
-            if (expectedPublicKey.contentEquals(result.publicKey)) {
-                VerificationLevel.FULLY_VERIFIED
-            } else {
-                return failed(R.string.id_mismatch)
-            }
-        } else {
-            VerificationLevel.UNVERIFIED
-        }
-
-        val identityType = when (result.type) {
-            0 -> IdentityType.NORMAL
-            1 -> IdentityType.WORK
-            else -> {
-                logger.warn("Identity fetch returned invalid identity type: {}", result.type)
-                IdentityType.NORMAL
-            }
-        }
-
-        val activityState = when (result.state) {
-            IdentityState.ACTIVE -> ch.threema.storage.models.ContactModel.State.ACTIVE
-            IdentityState.INACTIVE -> ch.threema.storage.models.ContactModel.State.INACTIVE
-            IdentityState.INVALID -> ch.threema.storage.models.ContactModel.State.INVALID
-            else -> {
-                logger.warn("Identity fetch returned invalid identity state: {}", result.state)
-                ch.threema.storage.models.ContactModel.State.ACTIVE
-            }
-        }
-
-        return runBlocking {
-            try {
-                val contactModel = contactModelRepository.createFromLocal(
-                    result.identity,
-                    result.publicKey,
-                    Date(),
-                    identityType,
-                    AcquaintanceLevel.DIRECT,
-                    activityState,
-                    result.featureMask.toULong(),
-                    verificationLevel,
-                )
-                Success(contactModel)
-            } catch (e: ContactCreateException) {
-                logger.error("Could not insert new contact", e)
-                failed(R.string.add_contact_failed)
-            }
-        }
-    }
-
-    private fun updateContact(contactModel: ContactModel, data: ContactModelData, expectedPublicKey: ByteArray?): ContactAddResult {
-        var verificationLevelChanged = false
-        var contactVerifiedAgain = false
-        var acquaintanceLevelChanged = false
-
-        if (expectedPublicKey != null) {
-            if (expectedPublicKey.contentEquals(data.publicKey)) {
-                if (data.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-                    contactModel.setVerificationLevelFromLocal(VerificationLevel.FULLY_VERIFIED)
-                    verificationLevelChanged = true
-                } else {
-                    contactVerifiedAgain = true
-                }
-            } else {
-                return failed(R.string.id_mismatch)
-            }
-        }
-
-        if (data.acquaintanceLevel == AcquaintanceLevel.GROUP) {
-            contactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.DIRECT)
-            acquaintanceLevelChanged = true
-        }
-
-        return when {
-            acquaintanceLevelChanged || verificationLevelChanged -> ContactModified(
-                contactModel, acquaintanceLevelChanged, verificationLevelChanged
-            )
-
-            contactVerifiedAgain -> AlreadyVerified(contactModel)
-            else -> ContactExists(contactModel)
-        }
-    }
-
-    private fun failed(stringId: Int) = Failed(context.getString(stringId))
-}
-
-/**
- * This is used to define whether the contact add restriction should be respected or if a contact
- * should be added anyways.
- */
-enum class AddContactRestrictionPolicy {
-    /**
-     * The add contact restriction must be followed and a contact won't be added if this is
-     * prohibited. In this case the result will be of the type [PolicyViolation].
-     */
-    CHECK,
-
-    /**
-     * The add contact restriction won't be respected and the contact will be added anyways. Note
-     * that this must only be used in cases where adding the contact is not triggered by the user.
-     */
-    IGNORE
-}
-
-/**
- * The result type of adding a contact.
- */
-sealed interface ContactAddResult
-
-/**
- * The contact has been added successfully. The new contact is provided.
- */
-data class Success(val contactModel: ContactModel) : ContactAddResult
-
-/**
- * The contact already existed and has now been updated.
- */
-data class ContactModified(
-    /**
-     * The updated contact model.
-     */
-    val contactModel: ContactModel,
-    /**
-     * If true, the acquaintance level changed from [AcquaintanceLevel.GROUP] to
-     * [AcquaintanceLevel.DIRECT].
-     */
-    val acquaintanceLevelChanged: Boolean,
-    /**
-     * If true, the verification level has changed to [VerificationLevel.FULLY_VERIFIED].
-     */
-    val verificationLevelChanged: Boolean,
-) : ContactAddResult
-
-/**
- * The result type when adding the contact has failed.
- */
-interface Error : ContactAddResult
-
-/**
- * The contact already exists. This is only returned, if no expected public key is given and the
- * contact already exists. This means, that neither the verification level nor the acquaintance
- * level did change.
- */
-data class ContactExists(val contactModel: ContactModel) : Error
-
-/**
- * The contact already exists and has been fully verified before.
- */
-data class AlreadyVerified(val contactModel: ContactModel) : Error
-
-/**
- * Adding the contact failed. The [message] contains a (translated) error message that can be shown
- * to the user.
- */
-data class Failed(val message: String) : Error
-
-/**
- * The contact could not be added since adding contacts is restricted.
- */
-object PolicyViolation : Error
diff --git a/app/src/main/java/ch/threema/app/asynctasks/DeleteContactAsyncTask.java b/app/src/main/java/ch/threema/app/asynctasks/DeleteContactAsyncTask.java
deleted file mode 100644
index 778c5fe8..00000000
--- a/app/src/main/java/ch/threema/app/asynctasks/DeleteContactAsyncTask.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.asynctasks;
-
-import android.os.AsyncTask;
-
-import java.util.Iterator;
-import java.util.Set;
-
-import androidx.fragment.app.FragmentManager;
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.dialogs.CancelableHorizontalProgressDialog;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.utils.DialogUtil;
-import ch.threema.storage.models.ContactModel;
-
-public class DeleteContactAsyncTask extends AsyncTask<Void, Integer, Integer> {
-	private static final String DIALOG_TAG_DELETE_CONTACT = "dc";
-
-	private final Set<ContactModel> contacts;
-	private final ContactService contactService;
-	private final FragmentManager fragmentManager;
-	private final DeleteContactsPostRunnable runOnCompletion;
-	private boolean cancelled = false;
-
-	public static class DeleteContactsPostRunnable implements Runnable {
-		protected Integer failed;
-
-		protected void setFailed(Integer failed) {
-			this.failed = failed;
-		}
-
-		@Override
-		public void run() {}
-	}
-
-	public DeleteContactAsyncTask(FragmentManager fragmentManager,
-	                              Set<ContactModel> contacts,
-	                              ContactService contactService,
-	                              DeleteContactsPostRunnable runOnCompletion) {
-
-		this.contacts = contacts;
-		this.contactService = contactService;
-		this.fragmentManager = fragmentManager;
-		this.runOnCompletion = runOnCompletion;
-	}
-
-	@Override
-	protected void onPreExecute() {
-		CancelableHorizontalProgressDialog dialog = CancelableHorizontalProgressDialog.newInstance(R.string.deleting_contact, R.string.cancel, contacts.size());
-		dialog.setOnCancelListener((dialog1, which) -> cancelled = true);
-		dialog.show(fragmentManager, DIALOG_TAG_DELETE_CONTACT);
-
-		ThreemaApplication.onAndroidContactChangeLock.lock();
-	}
-
-	@Override
-	protected Integer doInBackground(Void... params) {
-		int failed = 0, i = 0;
-		Iterator<ContactModel> checkedItemsIterator = contacts.iterator();
-		while (checkedItemsIterator.hasNext() && !cancelled) {
-			publishProgress(i++);
-
-			ContactModel contact = checkedItemsIterator.next();
-
-			if (contact == null || !contactService.remove(contact)) {
-				failed++;
-			}
-		}
-		return failed;
-	}
-
-	@Override
-	protected void onProgressUpdate(Integer... index) {
-		DialogUtil.updateProgress(fragmentManager, DIALOG_TAG_DELETE_CONTACT, index[0] + 1);
-	}
-
-	@Override
-	protected void onPostExecute(Integer failed) {
-		DialogUtil.dismissDialog(fragmentManager, DIALOG_TAG_DELETE_CONTACT, true);
-
-		// note: ContactListener.onRemoved() will be triggered by ContactStore.removeContact()
-
-		if (runOnCompletion != null) {
-			runOnCompletion.setFailed(failed);
-			runOnCompletion.run();
-		}
-
-		ThreemaApplication.onAndroidContactChangeLock.unlock();
-	}
-
-	@Override
-	protected void onCancelled(Integer integer) {
-		super.onCancelled(integer);
-
-		// Release the lock just in case this async task was cancelled
-		ThreemaApplication.onAndroidContactChangeLock.unlock();
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java b/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java
index 9c26d0c4..cb5ab8a2 100644
--- a/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java
+++ b/app/src/main/java/ch/threema/app/asynctasks/DeleteIdentityAsyncTask.java
@@ -29,6 +29,7 @@ import org.slf4j.Logger;
 import java.io.File;
 import java.io.IOException;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.fragment.app.FragmentManager;
 import ch.threema.app.R;
@@ -40,11 +41,13 @@ import ch.threema.app.services.PassphraseService;
 import ch.threema.app.utils.DialogUtil;
 import ch.threema.app.utils.SecureDeleteUtil;
 import ch.threema.app.utils.ShortcutUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.webclient.services.SessionWakeUpServiceImpl;
 import ch.threema.app.webclient.services.instance.DisconnectContext;
+import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.DatabaseNonceStore;
+import ch.threema.storage.DatabaseServiceNew;
 
 public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("DeleteIdentityAsyncTask");
@@ -54,6 +57,7 @@ public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 	private final ServiceManager serviceManager;
 	private final FragmentManager fragmentManager;
 	private final Runnable runOnCompletion;
+	private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
 
 	public DeleteIdentityAsyncTask(@Nullable FragmentManager fragmentManager,
 	                               @Nullable Runnable runOnCompletion) {
@@ -80,7 +84,7 @@ public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 			serviceManager.getMessageService().removeAll();
 			serviceManager.getConversationService().reset();
 			serviceManager.getGroupService().removeAll();
-			serviceManager.getContactService().removeAll();
+			backgroundExecutor.execute(getDeleteAllContactsTask());
 			try {
 				serviceManager.getUserService().removeIdentity();
 			} catch (Exception ignored) {}
@@ -157,6 +161,28 @@ public class DeleteIdentityAsyncTask extends AsyncTask<Void, Void, Exception> {
 		}
 	}
 
+	@NonNull
+	private DeleteAllContactsBackgroundTask getDeleteAllContactsTask() throws ThreemaException {
+		return new DeleteAllContactsBackgroundTask(
+			serviceManager.getModelRepositories().getContacts(),
+			new DeleteContactServices(
+				serviceManager.getUserService(),
+				serviceManager.getContactService(),
+				serviceManager.getConversationService(),
+				serviceManager.getRingtoneService(),
+				serviceManager.getMutedChatsListService(),
+				serviceManager.getHiddenChatsListService(),
+				serviceManager.getProfilePicRecipientsService(),
+				serviceManager.getWallpaperService(),
+				serviceManager.getFileService(),
+				serviceManager.getExcludedSyncIdentitiesService(),
+				serviceManager.getDHSessionStore(),
+				serviceManager.getNotificationService(),
+				serviceManager.getDatabaseServiceNew()
+			)
+		);
+	}
+
 	private void secureDelete(File file) {
 		try {
 			SecureDeleteUtil.secureDelete(file);
diff --git a/app/src/main/java/ch/threema/app/asynctasks/EmptyOrDeleteConversationsAsyncTask.java b/app/src/main/java/ch/threema/app/asynctasks/EmptyOrDeleteConversationsAsyncTask.java
deleted file mode 100644
index b8928642..00000000
--- a/app/src/main/java/ch/threema/app/asynctasks/EmptyOrDeleteConversationsAsyncTask.java
+++ /dev/null
@@ -1,208 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.asynctasks;
-
-import android.os.AsyncTask;
-import android.view.View;
-
-import com.google.android.material.snackbar.Snackbar;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.StringRes;
-import androidx.fragment.app.FragmentManager;
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.dialogs.GenericProgressDialog;
-import ch.threema.app.messagereceiver.ContactMessageReceiver;
-import ch.threema.app.messagereceiver.DistributionListMessageReceiver;
-import ch.threema.app.messagereceiver.GroupMessageReceiver;
-import ch.threema.app.messagereceiver.MessageReceiver;
-import ch.threema.app.services.ConversationService;
-import ch.threema.app.services.DistributionListService;
-import ch.threema.app.services.GroupService;
-import ch.threema.app.utils.ConfigUtils;
-import ch.threema.app.utils.DialogUtil;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.DistributionListModel;
-import ch.threema.storage.models.GroupModel;
-
-/**
- * Empty or delete one or more conversation/chat.
- * <p>
- * The primary use case is a user pressing the "delete" icon on a conversation
- * in the conversation list. This will show a dialog while the process is ongoing.
- * <p>
- * Note: Behavior with Mode.DELETE depends on the {@link MessageReceiver} passed in:
- * <p>
- *   - Contacts: Delete conversation, but not contact
- *   - Groups:
- *     - Left: Delete conversation and group
- *     - We are creator: Dissolve and delete group
- *     - We are not creator: Leave and delete group
- *   - Distribution lists: Delete distribution list
- */
-public class EmptyOrDeleteConversationsAsyncTask extends AsyncTask<Void, Void, Void> {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("EmptyOrDeleteConversationAsyncTask");
-
-	private static final String DIALOG_TAG_EMPTYING_OR_DELETING_CHAT = "edc";
-
-	// Services
-	private final @NonNull ConversationService conversationService;
-	private final @NonNull GroupService groupService;
-	private final @NonNull DistributionListService distributionListService;
-
-	private final @NonNull Mode mode;
-	private final MessageReceiver[] messageReceivers;
-	private final @Nullable FragmentManager fragmentManager;
-	private final @Nullable View snackbarFeedbackView;
-	private final @Nullable Runnable runOnCompletion;
-
-	public enum Mode {
-		EMPTY,
-		DELETE,
-	}
-
-	/**
-	 * @param mode Either EMPTY or DELETE
-	 * @param messageReceivers The list of receivers for which to empty or delete the conversation
-	 * @param conversationService Conversation service
-	 * @param groupService Group service
-	 * @param distributionListService Distribution list service
-	 * @param fragmentManager Fragment manager, required to show progress dialog
-	 * @param snackbarFeedbackView If view is set, a snackbar message will be shown after completion
-	 * @param runOnCompletion A runnable invoked after completion
-	 */
-	public EmptyOrDeleteConversationsAsyncTask(
-		@NonNull Mode mode,
-		MessageReceiver[] messageReceivers,
-	    @NonNull ConversationService conversationService,
-	    @NonNull GroupService groupService,
-		@NonNull DistributionListService distributionListService,
-	    @Nullable FragmentManager fragmentManager,
-		@Nullable View snackbarFeedbackView,
-	    @Nullable Runnable runOnCompletion
-	) {
-		this.mode = mode;
-		this.messageReceivers = messageReceivers;
-		this.conversationService = conversationService;
-		this.groupService = groupService;
-		this.distributionListService = distributionListService;
-		this.fragmentManager = fragmentManager;
-		this.snackbarFeedbackView = snackbarFeedbackView;
-		this.runOnCompletion = runOnCompletion;
-	}
-
-	@Override
-	protected void onPreExecute() {
-		if (fragmentManager != null) {
-			@StringRes int title;
-			switch (this.mode) {
-				case EMPTY:
-					title = R.string.emptying_chat;
-					break;
-				case DELETE:
-					title = R.string.deleting_chat;
-					break;
-				default:
-					throw new IllegalArgumentException("Invalid mode: " + this.mode);
-			}
-			final GenericProgressDialog dialog = GenericProgressDialog.newInstance(title, R.string.emptying_chat_deleting_messages);
-			dialog.show(fragmentManager, DIALOG_TAG_EMPTYING_OR_DELETING_CHAT);
-		}
-	}
-
-	@Override
-	protected Void doInBackground(Void... params) {
-		// Empty or delete conversations
-		logger.info("{} chat for {} receivers.", this.mode, messageReceivers.length);
-		switch (this.mode) {
-			case EMPTY:
-				for (MessageReceiver receiver : this.messageReceivers) {
-					int countRemoved = this.conversationService.empty(receiver);
-					logger.info("Removed {} messages for receiver {} (type={}).", countRemoved, receiver.getUniqueIdString(), receiver.getType());
-				}
-				break;
-			case DELETE:
-				for (MessageReceiver receiver : this.messageReceivers) {
-					logger.info("Delete chat with receiver {} (type={}).", receiver.getUniqueIdString(), receiver.getType());
-					if (receiver instanceof ContactMessageReceiver) {
-						final ContactModel contactModel = ((ContactMessageReceiver) receiver).getContact();
-						this.deleteContactConversation(contactModel);
-					} else if (receiver instanceof GroupMessageReceiver) {
-						final GroupModel groupModel = ((GroupMessageReceiver) receiver).getGroup();
-						this.deleteGroupConversation(groupModel);
-					} else if (receiver instanceof DistributionListMessageReceiver) {
-						final DistributionListModel distributionListModel = ((DistributionListMessageReceiver) receiver).getDistributionList();
-						this.deleteDistributionList(distributionListModel);
-					} else {
-						throw new IllegalArgumentException("Unknown message receiver type");
-					}
-				}
-				break;
-		}
-
-		// Refresh message receivers
-		for (MessageReceiver receiver : this.messageReceivers) {
-			conversationService.refresh(receiver);
-		}
-
-		return null;
-	}
-
-	private void deleteContactConversation(@NonNull ContactModel contactModel) {
-		this.conversationService.delete(contactModel);
-	}
-
-	private void deleteGroupConversation(@NonNull GroupModel groupModel) {
-		// Note: Group conversations cannot be deleted without removing the group as well
-		this.groupService.leaveOrDissolveAndRemoveFromLocal(groupModel);
-	}
-
-	private void deleteDistributionList(@NonNull DistributionListModel distributionListModel) {
-		// Note: Distribution list conversations are removed along with the distribution list model
-		this.distributionListService.remove(distributionListModel);
-	}
-
-	@Override
-	protected void onPostExecute(Void result) {
-		if (fragmentManager != null) {
-			DialogUtil.dismissDialog(fragmentManager, DIALOG_TAG_EMPTYING_OR_DELETING_CHAT, true);
-		}
-
-		if (mode == Mode.DELETE && snackbarFeedbackView != null && snackbarFeedbackView.isAttachedToWindow()) {
-			final int count = this.messageReceivers.length;
-			Snackbar.make(
-				snackbarFeedbackView,
-				ConfigUtils.getSafeQuantityString(ThreemaApplication.getAppContext(), R.plurals.chat_deleted, count, count),
-				Snackbar.LENGTH_SHORT
-			).show();
-		}
-
-		if (runOnCompletion != null) {
-			runOnCompletion.run();
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java b/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java
index f9b00bee..2d7f3f94 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/BackupService.java
@@ -97,10 +97,12 @@ import ch.threema.app.utils.StringConversionUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.ZipUtil;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.HashedNonce;
+import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.identitybackup.IdentityBackupGenerator;
-import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -133,6 +135,7 @@ public class BackupService extends Service {
 	private static final int MEDIA_STEP_FACTOR_VIDEOS_AND_FILES = 12;
 	private static final int MEDIA_STEP_FACTOR_THUMBNAILS = 3;
 	private static final int NONCES_PER_STEP = 50;
+	private static final int NONCES_CHUNK_SIZE = 2500;
 
 	private static final String EXTRA_ID_CANCEL = "cnc";
 	public static final String EXTRA_BACKUP_RESTORE_DATA_CONFIG = "ebrdc";
@@ -163,7 +166,7 @@ public class BackupService extends Service {
 	private PreferenceService preferenceService;
 	private PowerManager.WakeLock wakeLock;
 	private NotificationManagerCompat notificationManagerCompat;
-	private DatabaseNonceStore databaseNonceStore;
+	private NonceFactory nonceFactory;
 
 	private NotificationCompat.Builder notificationBuilder;
 
@@ -310,6 +313,7 @@ public class BackupService extends Service {
 			userService = serviceManager.getUserService();
 			ballotService = serviceManager.getBallotService();
 			preferenceService = serviceManager.getPreferenceService();
+			nonceFactory = serviceManager.getNonceFactory();
 		} catch (Exception e) {
 			logger.error("Exception", e);
 			safeStopSelf();
@@ -317,7 +321,6 @@ public class BackupService extends Service {
 		}
 
 		notificationManagerCompat = NotificationManagerCompat.from(this);
-		databaseNonceStore = new DatabaseNonceStore(this, serviceManager.getIdentityStore());
 	}
 
 	@Override
@@ -411,7 +414,7 @@ public class BackupService extends Service {
 
 			if (this.config.backupNonces()) {
 				progress += 1;
-				long nonceCount = this.databaseNonceStore.getCount();
+				long nonceCount = nonceFactory.getCount(NonceScope.CSP) + nonceFactory.getCount(NonceScope.D2D);
 				long nonceProgress = (long) Math.ceil((double) nonceCount / NONCES_PER_STEP);
 				progress += nonceProgress;
 			}
@@ -484,8 +487,9 @@ public class BackupService extends Service {
 		return this.next(subject, 1);
 	}
 
-	private boolean next(String subject, int factor) {
-		this.currentProgressStep += (this.currentProgressStep < this.processSteps ? factor : 0);
+	private boolean next(String subject, int increment) {
+		logger.debug("step [{}]", subject);
+		this.currentProgressStep += (this.currentProgressStep < this.processSteps ? increment : 0);
 		this.handleProgress();
 		return !isCanceled;
 	}
@@ -545,7 +549,7 @@ public class BackupService extends Service {
 			try {
 				ZipUtil.addZipStream(
 					zipOutputStream,
-					this.fileService.getContactAvatarStream(contactService.getMe().getIdentity()),
+					this.fileService.getUserDefinedProfilePictureStream(contactService.getMe().getIdentity()),
 					Tags.CONTACT_AVATAR_FILE_PREFIX + Tags.CONTACT_AVATAR_FILE_SUFFIX_ME,
 					false
 				);
@@ -621,7 +625,7 @@ public class BackupService extends Service {
 							if (!userService.getIdentity().equals(contactModel.getIdentity())) {
 								ZipUtil.addZipStream(
 									zipOutputStream,
-									this.fileService.getContactAvatarStream(contactModel.getIdentity()),
+									this.fileService.getUserDefinedProfilePictureStream(contactModel.getIdentity()),
 									Tags.CONTACT_AVATAR_FILE_PREFIX + identityId,
 									false
 								);
@@ -634,7 +638,7 @@ public class BackupService extends Service {
 						try {
 							ZipUtil.addZipStream(
 								zipOutputStream,
-								this.fileService.getContactPhotoStream(contactModel.getIdentity()),
+								this.fileService.getContactDefinedProfilePictureStream(contactModel.getIdentity()),
 								Tags.CONTACT_PROFILE_PIC_FILE_PREFIX + identityId,
 								false
 							);
@@ -732,6 +736,7 @@ public class BackupService extends Service {
 			Tags.TAG_GROUP_DESC,
 			Tags.TAG_GROUP_DESC_TIMESTAMP,
 			Tags.TAG_GROUP_UID,
+			Tags.TAG_GROUP_USER_STATE,
 		};
 		final String[] groupMessageCsvHeader = {
 			Tags.TAG_MESSAGE_API_MESSAGE_ID,
@@ -807,6 +812,7 @@ public class BackupService extends Service {
 						.write(Tags.TAG_GROUP_DESC, groupModel.getGroupDesc())
 						.write(Tags.TAG_GROUP_DESC_TIMESTAMP, groupModel.getGroupDescTimestamp())
 						.write(Tags.TAG_GROUP_UID, groupUid)
+						.write(Tags.TAG_GROUP_USER_STATE, groupModel.getUserState() != null ? groupModel.getUserState().value : 0)
 						.write();
 
 					//check if the group have a photo
@@ -1091,15 +1097,24 @@ public class BackupService extends Service {
 			return false;
 		}
 
-		try (ByteArrayOutputStream outputStreamBuffer = new ByteArrayOutputStream()) {
-			writeNonces(outputStreamBuffer);
-			// Write nonces to zip *after* the CSVWriter has been closed (and therefore flushed)
-			ZipUtil.addZipStream(
-				zipOutputStream,
-				new ByteArrayInputStream(outputStreamBuffer.toByteArray()),
-				Tags.NONCE_FILE_NAME + Tags.CSV_FILE_POSTFIX,
-				true
+		try {
+			int nonceCountCsp = writeNoncesToBackup(
+				NonceScope.CSP,
+				Tags.NONCE_FILE_NAME_CSP + Tags.CSV_FILE_POSTFIX,
+				zipOutputStream
+			);
+
+			int nonceCountD2d = writeNoncesToBackup(
+				NonceScope.D2D,
+				Tags.NONCE_FILE_NAME_D2D + Tags.CSV_FILE_POSTFIX,
+				zipOutputStream
 			);
+
+			writeNonceCounts(nonceCountCsp, nonceCountD2d, zipOutputStream);
+
+			int remainingCsp = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountCsp);
+			int remainingD2d = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountD2d);
+			next("Backup nonce", (int) Math.ceil(((double) remainingCsp + remainingD2d) / NONCES_PER_STEP));
 			logger.info("Nonce backup completed");
 		} catch (IOException | ThreemaException e) {
 			logger.error("Error with byte array output stream", e);
@@ -1109,36 +1124,91 @@ public class BackupService extends Service {
 		return true;
 	}
 
-	private void writeNonces(
+	private void writeNonceCounts(
+		int nonceCountCsp,
+		int nonceCountD2d,
+		@NonNull ZipOutputStream zipOutputStream
+	) throws IOException, ThreemaException {
+		logger.info("Write nonce counts to backup (CSP: {}, D2D: {})", nonceCountCsp, nonceCountD2d);
+		final String[] nonceCountHeader = new String[]{ Tags.TAG_NONCE_COUNT_CSP, Tags.TAG_NONCE_COUNT_D2D };
+		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
+			try (
+				OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
+				CSVWriter csvWriter = new CSVWriter(outputStreamWriter, nonceCountHeader)
+			) {
+				csvWriter.createRow()
+					.write(Tags.TAG_NONCE_COUNT_CSP, nonceCountCsp)
+					.write(Tags.TAG_NONCE_COUNT_D2D, nonceCountD2d)
+					.write();
+			}
+			ZipUtil.addZipStream(
+				zipOutputStream,
+				new ByteArrayInputStream(outputStream.toByteArray()),
+				Tags.NONCE_COUNTS_FILE + Tags.CSV_FILE_POSTFIX,
+				false
+			);
+		}
+	}
+
+	private int writeNoncesToBackup(
+		@NonNull NonceScope scope,
+		@NonNull String fileName,
+		@NonNull ZipOutputStream zipOutputStream
+	) throws ThreemaException, IOException {
+		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
+			int count = writeNonces(scope, outputStream);
+			// Write nonces to zip *after* the CSVWriter has been closed (and therefore flushed)
+			ZipUtil.addZipStream(
+				zipOutputStream,
+				new ByteArrayInputStream(outputStream.toByteArray()),
+				fileName,
+				true
+			);
+			return count;
+		}
+	}
+
+	private int writeNonces(
+		@NonNull NonceScope scope,
 		@NonNull ByteArrayOutputStream outputStream
 	) throws ThreemaException, IOException {
+		logger.info("Backup {} nonces", scope);
 		final String[] nonceHeader = new String[]{Tags.TAG_NONCES};
+		int backedUpNonceCount = 0;
 		try (
 			OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
 			CSVWriter csvWriter = new CSVWriter(outputStreamWriter, nonceHeader)
 		) {
 			long start = System.currentTimeMillis();
-			long nonceCount = databaseNonceStore.getCount();
-			long numChunks = (long) Math.ceil((double) nonceCount / NONCES_PER_STEP);
-			List<byte[]> nonces = new ArrayList<>(NONCES_PER_STEP);
+			long nonceCount = nonceFactory.getCount(scope);
+			long numChunks = (long) Math.ceil((double) nonceCount / NONCES_CHUNK_SIZE);
+			List<HashedNonce> nonces = new ArrayList<>(NONCES_CHUNK_SIZE);
 			for (int i = 0; i < numChunks; i++) {
-				databaseNonceStore.addHashedNonceChunk(NONCES_PER_STEP, NONCES_PER_STEP * i, nonces);
-				for (byte[] nonceBytes : nonces) {
-					String nonce = Utils.byteArrayToHexString(nonceBytes);
+				nonceFactory.addHashedNoncesChunk(
+					scope,
+					NONCES_CHUNK_SIZE,
+					NONCES_CHUNK_SIZE * i,
+					nonces
+				);
+				for (HashedNonce hashedNonce : nonces) {
+					String nonce = Utils.byteArrayToHexString(hashedNonce.getBytes());
 					csvWriter.createRow().write(Tags.TAG_NONCES, nonce).write();
 				}
+				int increment = nonces.size() / NONCES_PER_STEP;
+				backedUpNonceCount += nonces.size();
 				nonces.clear();
-				if (!next("Backup nonce")) {
-					return;
+				if (!next("Backup nonce", increment)) {
+					return backedUpNonceCount;
 				}
 				// Periodically log nonce backup progress for debugging purposes
-				if ((i & 2047) == 0) {
+				if ((i % 10) == 0 || i == numChunks) {
 					logger.info("Nonce backup progress: {} of {} chunks backed up", i, numChunks);
 				}
 			}
 			long end = System.currentTimeMillis();
-			logger.info("Created row for all nonces in {} ms", end - start);
+			logger.info("Created backup for all {} nonces in {} ms", scope, end - start);
 		}
+		return backedUpNonceCount;
 	}
 
 	/**
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java
index 57f389d9..45179655 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreService.java
@@ -87,13 +87,14 @@ import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.StringConversionUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.connection.ServerConnection;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.ContactModelFactory;
 import ch.threema.storage.models.AbstractMessageModel;
@@ -105,6 +106,7 @@ import ch.threema.storage.models.DistributionListModel;
 import ch.threema.storage.models.GroupMemberModel;
 import ch.threema.storage.models.GroupMessageModel;
 import ch.threema.storage.models.GroupModel;
+import ch.threema.storage.models.GroupModel.UserState;
 import ch.threema.storage.models.MessageModel;
 import ch.threema.storage.models.MessageState;
 import ch.threema.storage.models.MessageType;
@@ -120,6 +122,8 @@ import ch.threema.storage.models.data.media.FileDataModel;
 
 import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC;
 import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
+import static ch.threema.storage.models.GroupModel.UserState.LEFT;
+import static ch.threema.storage.models.GroupModel.UserState.MEMBER;
 
 public class RestoreService extends Service {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("RestoreService");
@@ -145,7 +149,7 @@ public class RestoreService extends Service {
 	private PreferenceService preferenceService;
 	private PowerManager.WakeLock wakeLock;
 	private NotificationManagerCompat notificationManagerCompat;
-	private DatabaseNonceStore databaseNonceStore;
+	private NonceFactory nonceFactory;
 
 	private NotificationCompat.Builder notificationBuilder;
 
@@ -174,6 +178,7 @@ public class RestoreService extends Service {
 	private static final int STEP_SIZE_GROUP_AVATARS = 50;
 	private static final int STEP_SIZE_MEDIA = 25; // per media file
 	private static final int NONCES_PER_STEP = 50;
+	private static final int NONCES_CHUNK_SIZE = 10_000;
 
 	private long stepSizeTotal = (long) STEP_SIZE_PREPARE + STEP_SIZE_IDENTITY + STEP_SIZE_MAIN_FILES + STEP_SIZE_GROUP_AVATARS;
 
@@ -295,7 +300,7 @@ public class RestoreService extends Service {
 			conversationService = serviceManager.getConversationService();
 			userService = serviceManager.getUserService();
 			preferenceService = serviceManager.getPreferenceService();
-			databaseNonceStore = new DatabaseNonceStore(this, serviceManager.getIdentityStore());
+			nonceFactory = serviceManager.getNonceFactory();
 		} catch (Exception e) {
 			logger.error("Could not instantiate all required services", e);
 			stopSelf();
@@ -504,10 +509,6 @@ public class RestoreService extends Service {
 				// Restore nonces
 				logger.info("Restoring nonces");
 				int nonceCount = restoreNonces(fileHeaders);
-				if (nonceCount < 0) {
-					logger.error("Restoring nonces failed ({})", nonceCount);
-					//continue anyway!
-				}
 
 				//contacts, groups and distribution lists
 				logger.info("Restoring main files (contacts, groups, distribution lists)");
@@ -602,7 +603,7 @@ public class RestoreService extends Service {
 		try (
 			InputStream is = zipFile.getInputStream(settingsHeader);
 			InputStreamReader inputStreamReader = new InputStreamReader(is);
-			CSVReader csvReader = new CSVReader(inputStreamReader)
+			CSVReader csvReader = new CSVReader(inputStreamReader, false)
 		) {
 			RestoreSettings settings = new RestoreSettings();
 			settings.parse(csvReader.readAll());
@@ -659,28 +660,112 @@ public class RestoreService extends Service {
 		return true;
 	}
 
+	/**
+	 * Attempt to restore the nonces. If restoring of nonces fails for some reason 0 is returned.
+	 * Since we continue anyway, there is no need to distinguish between zero restored nonces and
+	 * a failure.
+	 */
 	private int restoreNonces(List<FileHeader> fileHeaders) throws IOException, RestoreCanceledException {
-		FileHeader nonceFileHeader = null;
+		if (!writeToDb) {
+			// If not writing to the database only the count of nonces is required.
+			// Try to read optional nonces count file if present in backup.
+			logger.info("Get nonce counts");
+			int nonceCount = readNonceCounts(fileHeaders);
+			if (nonceCount >= 0) {
+				// If the nonce count is available return it and skip reading the whole nonces file.
+				logger.info("{} nonces in backup", nonceCount);
+				return nonceCount;
+			} else {
+				logger.info("Count nonces in backup.");
+			}
+		}
+
+		int nonceCountCsp = restoreNonces(
+			NonceScope.CSP,
+			Tags.NONCE_FILE_NAME_CSP + Tags.CSV_FILE_POSTFIX,
+			fileHeaders
+		);
+
+		int nonceCountD2d = restoreNonces(
+			NonceScope.D2D,
+			Tags.NONCE_FILE_NAME_D2D + Tags.CSV_FILE_POSTFIX,
+			fileHeaders
+		);
+
+		int remainingCsp = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountCsp);
+		int remainingD2d = BackupUtils.calcRemainingNoncesProgress(NONCES_CHUNK_SIZE, NONCES_PER_STEP, nonceCountD2d);
+		int remainingNonceProgress = remainingCsp + remainingD2d;
+		logger.debug("Remaining nonce progress: {}", remainingNonceProgress);
+		updateProgress((long) Math.ceil((double) remainingNonceProgress / NONCES_PER_STEP));
+
+		return nonceCountCsp + nonceCountD2d;
+	}
+
+	/**
+	 * Read the counts from the nonce counts file if available.
+	 *
+	 * @return the count, or -1 if the count could not be read from some reason.
+	 */
+	private int readNonceCounts(List<FileHeader> fileHeaders) throws IOException {
+		FileHeader nonceCountFileHeader = getFileHeader(Tags.NONCE_COUNTS_FILE + Tags.CSV_FILE_POSTFIX, fileHeaders);
+		if (nonceCountFileHeader == null) {
+			logger.info("No nonce count file available in backup");
+			return -1;
+		}
+		try (ZipInputStream inputStream = this.zipFile.getInputStream(nonceCountFileHeader);
+		     InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
+		     CSVReader csvReader = new CSVReader(inputStreamReader, true)
+		) {
+			CSVRow row = csvReader.readNextRow();
+			if (row == null) {
+				logger.warn("Could not read nonce count. File is empty.");
+				return -1;
+			}
+			return row.getInteger(Tags.TAG_NONCE_COUNT_CSP) + row.getInteger(Tags.TAG_NONCE_COUNT_D2D);
+		} catch (ThreemaException | NumberFormatException e) {
+			logger.warn("Could not read nonce count", e);
+			return -1;
+		}
+	}
+
+	/**
+	 * Get the file header where the file name matches the provided exactFileName.
+	 *
+	 * @param exactFileName The file name that is matched against
+	 * @param fileHeaders The file headers that are scanned
+	 * @return The first matching file header or null if none matches
+	 */
+	@Nullable
+	private FileHeader getFileHeader(@NonNull String exactFileName, List<FileHeader> fileHeaders) {
 		for (FileHeader fileHeader : fileHeaders) {
-			String fileName = fileHeader.getFileName();
-			if (fileName != null && fileName.startsWith(Tags.NONCE_FILE_NAME)) {
-				nonceFileHeader = fileHeader;
-				break;
+			if (exactFileName.equals(fileHeader.getFileName())) {
+				return fileHeader;
 			}
 		}
+		logger.info("No file header for '{}' found", exactFileName);
+		return null;
+	}
+
+	private int restoreNonces(
+		@NonNull NonceScope scope,
+		@NonNull String nonceBackupFile,
+		@NonNull List<FileHeader> fileHeaders
+	) throws IOException, RestoreCanceledException {
+		logger.info("Restore {} nonces", scope);
+		final FileHeader nonceFileHeader = getFileHeader(nonceBackupFile, fileHeaders);
 		if (nonceFileHeader == null) {
 			logger.info("Nonce file header is null");
-			return -1;
+			return 0;
 		}
 
 		try (ZipInputStream inputStream = this.zipFile.getInputStream(nonceFileHeader);
 		     InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
-		     CSVReader csvReader = new CSVReader(inputStreamReader, false)
+		     CSVReader csvReader = new CSVReader(inputStreamReader, true)
 		) {
-			int nonceProgressCount = 0;
 			int nonceCount = 0;
 			boolean success = true;
 			CSVRow row;
+			List<byte[]> nonceBytes = new ArrayList<>(NONCES_CHUNK_SIZE);
 			while ((row = csvReader.readNextRow()) != null) {
 				try {
 					// Note that currently there is only one nonce per row, and therefore we do
@@ -689,27 +774,42 @@ public class RestoreService extends Service {
 					String[] nonces = row.getStrings(Tags.TAG_NONCES);
 					nonceCount += nonces.length;
 					if (writeToDb) {
-						success &= databaseNonceStore.insertHashedNonces(nonces);
-						nonceProgressCount += nonces.length;
-						if (nonceProgressCount >= NONCES_PER_STEP) {
-							long increment = nonceProgressCount / NONCES_PER_STEP;
-							updateProgress(increment);
-							nonceProgressCount -= increment * NONCES_PER_STEP;
+						for (String nonce : nonces) {
+							nonceBytes.add(Utils.hexStringToByteArray(nonce));
+							if (nonceBytes.size() >= NONCES_CHUNK_SIZE) {
+								success &= insertNonces(scope, nonceBytes);
+								nonceBytes.clear();
+							}
 						}
 					}
 				} catch (ThreemaException e) {
-					logger.error("Could not insert nonces");
-					return -1;
+					logger.error("Could not insert nonces", e);
+					return 0;
 				}
 			}
+			if (!nonceBytes.isEmpty()) {
+				success &= insertNonces(scope, nonceBytes);
+			}
 			if (success) {
+				logger.info("Restored {} {} nonces", nonceCount, scope);
 				return nonceCount;
 			} else {
-				return -1;
+				logger.warn("Restoring {} nonces was not successfull", scope);
+				return 0;
 			}
 		}
 	}
 
+	private boolean insertNonces(
+		@NonNull NonceScope scope,
+		@NonNull List<byte[]> nonces
+	) throws RestoreCanceledException {
+		logger.debug("Write {} nonces to database", nonces.size());
+		boolean success = nonceFactory.insertHashedNoncesJava(scope, nonces);
+		updateProgress(nonces.size() / NONCES_PER_STEP);
+		return success;
+	}
+
 	/**
 	 * restore all avatars and profile pics
 	 */
@@ -972,7 +1072,7 @@ public class RestoreService extends Service {
 
 		// Set contact avatar
 		try (ZipInputStream inputStream = zipFile.getInputStream(fileHeader)) {
-			return fileService.writeContactAvatar(
+			return fileService.writeUserDefinedProfilePicture(
 				contactModel.getIdentity(),
 				IOUtils.toByteArray(inputStream)
 			);
@@ -1001,7 +1101,7 @@ public class RestoreService extends Service {
 
 		// Set contact profile picture
 		try (ZipInputStream inputStream = zipFile.getInputStream(fileHeader)) {
-			return fileService.writeContactPhoto(
+			return fileService.writeContactDefinedProfilePicture(
 				contactModel.getIdentity(),
 				IOUtils.toByteArray(inputStream));
 		} catch (Exception e) {
@@ -1029,10 +1129,24 @@ public class RestoreService extends Service {
 					restoreResult.incContactSuccess();
 				}
 
-				List<GroupMemberModel> groupMemberModels = createGroupMembers(row, groupModel.getId());
 				if (writeToDb) {
+					String myIdentity = userService.getIdentity();
+					boolean isInMemberList = false;
+
+					List<GroupMemberModel> groupMemberModels = createGroupMembers(row, groupModel.getId());
+
 					for (GroupMemberModel groupMemberModel : groupMemberModels) {
-						databaseServiceNew.getGroupMemberModelFactory().create(groupMemberModel);
+						if (!myIdentity.equals(groupMemberModel.getIdentity())) {
+							databaseServiceNew.getGroupMemberModelFactory().create(groupMemberModel);
+						} else {
+							isInMemberList = true;
+						}
+					}
+					if (restoreSettings.getVersion() < 25) {
+						// In this case the group user state is not included in the backup and we
+						// need to determine the state based on the group member list.
+						groupModel.setUserState(isInMemberList ? MEMBER : LEFT);
+						databaseServiceNew.getGroupModelFactory().update(groupModel);
 					}
 				}
 			} catch (Exception x) {
@@ -1179,6 +1293,10 @@ public class RestoreService extends Service {
 			groupModel.setLastUpdate(row.getDate(Tags.TAG_GROUP_LAST_UPDATE));
 		}
 
+		if (restoreSettings.getVersion() >= 25) {
+			groupModel.setUserState(UserState.valueOf(row.getInteger(Tags.TAG_GROUP_USER_STATE)));
+		}
+
 		return groupModel;
 	}
 
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java
index 92efccdf..e13bbfb8 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/RestoreSettings.java
@@ -44,8 +44,9 @@ public class RestoreSettings {
 	 * 22: add lastUpdate and remove isQueued flag
 	 * 23: add editedAt
 	 * 24: add deletedAt
+	 * 25: add group user state
 	 */
-	public static final int CURRENT_VERSION = 24;
+	public static final int CURRENT_VERSION = 25;
 	private int version;
 
 	public RestoreSettings(int version) {
diff --git a/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java b/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java
index 5d923381..53ce6524 100644
--- a/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java
+++ b/app/src/main/java/ch/threema/app/backuprestore/csv/Tags.java
@@ -36,7 +36,10 @@ public abstract class Tags {
 	public static final String CONTACT_AVATAR_FILE_PREFIX = "contact_avatar_";
 	public static final String CONTACT_AVATAR_FILE_SUFFIX_ME = "me";
 	public static final String CONTACT_PROFILE_PIC_FILE_PREFIX = "contact_profile_pic_";
-	public static final String NONCE_FILE_NAME = "nonces";
+	// do not rename csp nonces file to preserve backwards compatibility
+	public static final String NONCE_FILE_NAME_CSP = "nonces";
+	public static final String NONCE_FILE_NAME_D2D = "nonces_d2d";
+	public static final String NONCE_COUNTS_FILE = "nonce_counts";
 
 	public static final String DISTRIBUTION_LIST_MESSAGE_MEDIA_FILE_PREFIX = "distribution_list_message_media_";
 	public static final String DISTRIBUTION_LIST_MESSAGE_MEDIA_THUMBNAIL_FILE_PREFIX = "distribution_list_thumbnail_";
@@ -51,6 +54,8 @@ public abstract class Tags {
 	public static final String TAG_INFO_VERSION = "version";
 
 	public static final String TAG_NONCES = "nonces";
+	public static final String TAG_NONCE_COUNT_CSP = "csp";
+	public static final String TAG_NONCE_COUNT_D2D = "d2d";
 
 	public static final String TAG_CONTACT_IDENTITY = "identity";
 	public static final String TAG_CONTACT_FIRST_NAME = "firstname";
@@ -75,6 +80,7 @@ public abstract class Tags {
 	public static final String TAG_GROUP_DESC = "groupDesc";
 	public static final String TAG_GROUP_DESC_TIMESTAMP = "groupDescTimestamp";
 	public static final String TAG_GROUP_UID = "group_uid";
+	public static final String TAG_GROUP_USER_STATE = "user_state";
 
 	public static final String TAG_MESSAGE_UID = "uid";
 	public static final String TAG_MESSAGE_IDENTITY = "identity";
diff --git a/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt b/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt
index fe1c9178..7a0a6343 100644
--- a/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt
+++ b/app/src/main/java/ch/threema/app/camera/QRCodeAnalyer.kt
@@ -80,7 +80,7 @@ class QRCodeAnalyzer(private val onDecodeQRCode: (decodeQRCodeState: DecodeQRCod
                     try {
                         decode(imageProxy, data)
                     } catch (e: Exception) {
-                        logger.info("Decode error for inverted QR Code")
+                        logger.debug("Decode error for inverted QR Code")
                     }
                 } catch (e: Exception) {
                     logger.error("Scanning error", e)
diff --git a/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt b/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt
index 035dbc08..3939a722 100644
--- a/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt
+++ b/app/src/main/java/ch/threema/app/camera/QRScannerActivity.kt
@@ -33,7 +33,12 @@ import android.view.WindowManager
 import android.widget.ImageView
 import android.widget.TextView
 import android.widget.Toast
-import androidx.camera.core.*
+import androidx.camera.core.Camera
+import androidx.camera.core.CameraSelector
+import androidx.camera.core.FocusMeteringAction
+import androidx.camera.core.ImageAnalysis
+import androidx.camera.core.ImageCapture
+import androidx.camera.core.Preview
 import androidx.camera.lifecycle.ProcessCameraProvider
 import androidx.camera.view.PreviewView
 import androidx.core.content.ContextCompat
@@ -42,7 +47,6 @@ import ch.threema.app.ThreemaApplication
 import ch.threema.app.activities.ThreemaActivity
 import ch.threema.app.services.QRCodeServiceImpl.QRCodeColor
 import ch.threema.app.services.QRCodeServiceImpl.QR_TYPE_ANY
-import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.SoundUtil
 import ch.threema.base.utils.LoggingUtil
 import java.util.concurrent.ExecutorService
@@ -98,11 +102,19 @@ class QRScannerActivity : ThreemaActivity() {
                 getString(R.string.msg_default_status)
             }
         }
-        findViewById<TextView>(R.id.hint_view).text = hint
-        if (qrColor == QR_TYPE_ANY) {
-            findViewById<ImageView>(R.id.camera_viewfinder).visibility = View.GONE
-        } else {
-            findViewById<ImageView>(R.id.camera_viewfinder).setColorFilter(qrColor)
+
+        // set hint text
+        findViewById<TextView>(R.id.hint_view)?.let {
+            it.text = hint
+        }
+
+        // set viewfinder color
+        findViewById<ImageView>(R.id.camera_viewfinder)?.let {
+            if (qrColor == QR_TYPE_ANY) {
+                it.visibility = View.GONE
+            } else {
+                it.setColorFilter(qrColor)
+            }
         }
 
         // Wait for the views to be properly laid out
diff --git a/app/src/main/java/ch/threema/app/compose/common/ThemedText.kt b/app/src/main/java/ch/threema/app/compose/common/ThemedText.kt
deleted file mode 100644
index 3c78aa69..00000000
--- a/app/src/main/java/ch/threema/app/compose/common/ThemedText.kt
+++ /dev/null
@@ -1,82 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.common
-
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.Text
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.text.TextLayoutResult
-import androidx.compose.ui.text.TextStyle
-import androidx.compose.ui.text.font.FontFamily
-import androidx.compose.ui.text.font.FontStyle
-import androidx.compose.ui.text.font.FontWeight
-import androidx.compose.ui.text.style.TextAlign
-import androidx.compose.ui.text.style.TextDecoration
-import androidx.compose.ui.text.style.TextOverflow
-import androidx.compose.ui.unit.TextUnit
-
-/**
- * Wraps androidx.compose.material3.Text to set a better suited default color
- * and make style required so devs don't forget to think about which style suits the context best
- */
-@Composable
-fun ThemedText(
-    modifier: Modifier = Modifier,
-    text: String,
-    style: TextStyle,
-    color: Color = MaterialTheme.colorScheme.onSurface,
-    fontSize: TextUnit = TextUnit.Unspecified,
-    fontStyle: FontStyle? = null,
-    fontWeight: FontWeight? = null,
-    fontFamily: FontFamily? = null,
-    letterSpacing: TextUnit = TextUnit.Unspecified,
-    textDecoration: TextDecoration? = null,
-    textAlign: TextAlign? = null,
-    lineHeight: TextUnit = TextUnit.Unspecified,
-    overflow: TextOverflow = TextOverflow.Clip,
-    softWrap: Boolean = true,
-    maxLines: Int = Int.MAX_VALUE,
-    minLines: Int = 1,
-    onTextLayout: ((TextLayoutResult) -> Unit)? = null,
-) {
-    Text(
-        modifier = modifier,
-        text = text,
-        style = style,
-        color = color,
-        fontSize = fontSize,
-        fontStyle = fontStyle,
-        fontWeight = fontWeight,
-        fontFamily = fontFamily,
-        letterSpacing = letterSpacing,
-        textDecoration = textDecoration,
-        textAlign = textAlign,
-        lineHeight = lineHeight,
-        overflow = overflow,
-        softWrap = softWrap,
-        maxLines = maxLines,
-        minLines = minLines,
-        onTextLayout = onTextLayout
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/compose/common/anim/AnimatedVisibilityNow.kt b/app/src/main/java/ch/threema/app/compose/common/anim/AnimatedVisibilityNow.kt
deleted file mode 100644
index 3a5235d7..00000000
--- a/app/src/main/java/ch/threema/app/compose/common/anim/AnimatedVisibilityNow.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.common.anim
-
-import androidx.compose.animation.AnimatedVisibility
-import androidx.compose.animation.EnterTransition
-import androidx.compose.animation.ExitTransition
-import androidx.compose.animation.core.MutableTransitionState
-import androidx.compose.animation.fadeIn
-import androidx.compose.animation.fadeOut
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.remember
-import androidx.compose.ui.Modifier
-
-@Composable
-fun AnimatedVisibilityNow(
-    modifier: Modifier = Modifier,
-    enter: EnterTransition = fadeIn(),
-    exit: ExitTransition = fadeOut(),
-    content: @Composable () -> Unit
-) {
-    val state = remember {
-        MutableTransitionState(false).apply {
-            // Start the animation immediately.
-            targetState = true
-        }
-    }
-    AnimatedVisibility(
-        modifier = modifier,
-        visibleState = state,
-        enter = enter,
-        exit = exit
-    ) { content() }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/common/anim/ExpandingBox.kt b/app/src/main/java/ch/threema/app/compose/common/anim/ExpandingBox.kt
deleted file mode 100644
index bffb1c4e..00000000
--- a/app/src/main/java/ch/threema/app/compose/common/anim/ExpandingBox.kt
+++ /dev/null
@@ -1,72 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.common.anim
-
-import androidx.compose.animation.animateContentSize
-import androidx.compose.foundation.layout.Box
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.heightIn
-import androidx.compose.foundation.layout.wrapContentHeight
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.saveable.rememberSaveable
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.unit.Dp
-
-/**
- * @param modifier The modifier to be applied to the box.
- * @param collapsedMaxHeight The max height of the box when collapsed.
- * When expanded the box will wrap its content height.
- * @param expanded The initial expanded state.
- * Can be also used to pass a different state and update it from the parent of the box.
- * @param content The content of the box.
- * Receives the current expanded state and a function to toggle the expanded state.
- * The content composable needs to call `toggleExpandedState` itself in order to update the `expandedState`.
- * This can be used to define e.g. a clickable on a child instead of the whole box.
- */
-@Composable
-fun ExpandingBox(
-    modifier: Modifier = Modifier,
-    collapsedMaxHeight: Dp? = null,
-    expanded: Boolean = false,
-    content: @Composable (
-        expandedState: Boolean,
-        toggleExpandedState:() -> Unit
-    ) -> Unit,
-) {
-    var expandedState by rememberSaveable(expanded) { mutableStateOf(expanded) }
-    Box(modifier = modifier
-        .fillMaxWidth()
-        .then(
-            if (expandedState || collapsedMaxHeight == null) {
-                Modifier.wrapContentHeight()
-            } else {
-                Modifier.heightIn(max = collapsedMaxHeight)
-            }
-        )
-        .animateContentSize()
-    ) {
-        content(expandedState) { expandedState = !expandedState }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/common/extensions/DimensionExt.kt b/app/src/main/java/ch/threema/app/compose/common/extensions/DimensionExt.kt
deleted file mode 100644
index 109dc03a..00000000
--- a/app/src/main/java/ch/threema/app/compose/common/extensions/DimensionExt.kt
+++ /dev/null
@@ -1,37 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.common.extensions
-
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.platform.LocalDensity
-import androidx.compose.ui.unit.Density
-import androidx.compose.ui.unit.Dp
-
-@Composable
-fun Dp.dpToPx() = with(LocalDensity.current) { this@dpToPx.toPx() }
-
-@Composable
-fun Float.pxToDp() = with(LocalDensity.current) { this@pxToDp.toDp() }
-
-fun Dp.dpToPx(density: Density): Float { return density.run { this@dpToPx.toPx() } }
-
-fun Float.pxToDp(density: Density): Dp { return density.run { this@pxToDp.toDp() } }
diff --git a/app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt b/app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt
deleted file mode 100644
index 170270d0..00000000
--- a/app/src/main/java/ch/threema/app/compose/common/interop/ComposeJavaBridge.kt
+++ /dev/null
@@ -1,72 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.common.interop
-
-import androidx.compose.ui.platform.ComposeView
-import androidx.preference.PreferenceManager
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.activities.MessageDetailsUiModel
-import ch.threema.app.activities.MessageTimestampsUiModel
-import ch.threema.app.activities.toUiModel
-import ch.threema.app.compose.message.CombinedMessageDetailsList
-import ch.threema.app.compose.message.MessageBubble
-import ch.threema.app.compose.theme.ThreemaTheme
-import ch.threema.storage.models.AbstractMessageModel
-
-object ComposeJavaBridge {
-
-    fun setContentMessageDetails(
-        composeView: ComposeView,
-        messageTimestampsUiModel: MessageTimestampsUiModel,
-        messageDetailsUiModel: MessageDetailsUiModel,
-    ) {
-        composeView.setContent {
-            ThreemaTheme(dynamicColor = shouldUseDynamicColors()) {
-                CombinedMessageDetailsList(
-                    messageTimestampsUiModel,
-                    messageDetailsUiModel
-                )
-            }
-        }
-    }
-
-    fun setEditModeMessageBubble(
-        composeView: ComposeView,
-        model: AbstractMessageModel,
-        myIdentity: String
-    ) {
-        val messageBubbleUiState = model.toUiModel(myIdentity)
-        composeView.setContent {
-            ThreemaTheme(dynamicColor = shouldUseDynamicColors()) {
-                MessageBubble(
-                    text = messageBubbleUiState.text,
-                    isOutbox = messageBubbleUiState.isOutbox,
-                )
-            }
-        }
-    }
-
-    private fun shouldUseDynamicColors(): Boolean {
-        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext())
-        return sharedPreferences.getBoolean("pref_dynamic_color", false)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/common/interop/InteropEmojiConversationTextView.kt b/app/src/main/java/ch/threema/app/compose/common/interop/InteropEmojiConversationTextView.kt
deleted file mode 100644
index 583a7e54..00000000
--- a/app/src/main/java/ch/threema/app/compose/common/interop/InteropEmojiConversationTextView.kt
+++ /dev/null
@@ -1,114 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.common.interop
-
-import android.os.Build
-import android.text.TextUtils
-import android.view.View
-import androidx.annotation.StyleRes
-import androidx.appcompat.view.ContextThemeWrapper
-import androidx.compose.foundation.layout.Box
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.ExperimentalComposeUiApi
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.graphics.isSpecified
-import androidx.compose.ui.graphics.toArgb
-import androidx.compose.ui.input.pointer.pointerInteropFilter
-import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.viewinterop.AndroidView
-import androidx.core.widget.TextViewCompat
-import ch.threema.app.R
-import ch.threema.app.emojis.EmojiConversationTextView
-import ch.threema.app.ui.CustomTextSelectionCallback
-import ch.threema.app.utils.LinkifyUtil
-
-@OptIn(ExperimentalComposeUiApi::class)
-@Composable
-fun InteropEmojiConversationTextView(
-    text: String,
-    @StyleRes textAppearanceRes: Int,
-    contentColor: Color,
-    shouldMarkupText: Boolean = true,
-    isTextSelectable: Boolean = false,
-    maxLines: Int = Integer.MAX_VALUE,
-    textSelectionCallback: CustomTextSelectionCallback? = null,
-) {
-    var textViewRef: EmojiConversationTextView? by remember { mutableStateOf(null) }
-
-    // Box is a workaround to make semantics work when merging descendants
-    Box(modifier = Modifier.semantics { contentDescription = text }) {
-        AndroidView(
-            modifier = Modifier
-                .fillMaxWidth()
-                .pointerInteropFilter {
-                    if (isTextSelectable) { // TODO(ANDR-3193)
-                        return@pointerInteropFilter false
-                    }
-                    textViewRef?.onTouchEvent(it) ?: false
-                },
-            factory = { context ->
-                val textView = EmojiConversationTextView(ContextThemeWrapper(context, R.style.AppBaseTheme))
-                TextViewCompat.setTextAppearance(textView, textAppearanceRes)
-                textView.setTextColor(contentColor.toArgb())
-
-                textView.apply {
-                    setMaxLines(maxLines)
-                    ellipsize = TextUtils.TruncateAt.END
-                    // TODO(ANDR-3193)
-                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-                        // do not add on lollipop or lower due to this bug: https://issuetracker.google.com/issues/36937508
-                        textSelectionCallback?.let { callback ->
-                            customSelectionActionModeCallback = callback
-                            textSelectionCallback.setTextViewRef(textView)
-                        }
-                    }
-                    setTextIsSelectable(isTextSelectable)
-                    // disable accessibility since we set it for the Box parent
-                    importantForAccessibility = View.IMPORTANT_FOR_ACCESSIBILITY_NO
-                }
-
-                textViewRef = textView
-
-                textView
-            },
-            update = { textView ->
-                textView.apply {
-                    setIgnoreMarkup(!shouldMarkupText)
-                    setText(text)
-                    setMaxLines(maxLines)
-                    ellipsize = TextUtils.TruncateAt.END
-                    if (shouldMarkupText) {
-                        LinkifyUtil.getInstance().linkify(context,null, null, textView, null, true, false, null)
-                    }
-                }
-            }
-        )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryItem.kt b/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryItem.kt
deleted file mode 100644
index 606b13eb..00000000
--- a/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryItem.kt
+++ /dev/null
@@ -1,192 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.edithistory
-
-import androidx.compose.animation.AnimatedVisibility
-import androidx.compose.foundation.background
-import androidx.compose.foundation.layout.Box
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Brush
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.unit.dp
-import ch.threema.app.R
-import ch.threema.app.compose.common.ThemedText
-import ch.threema.app.compose.common.anim.AnimatedVisibilityNow
-import ch.threema.app.compose.message.MessageBubble
-import ch.threema.app.compose.theme.AppTypography
-import ch.threema.app.compose.theme.customColorScheme
-import ch.threema.app.ui.CustomTextSelectionCallback
-import ch.threema.app.utils.LocaleUtil
-import ch.threema.data.models.EditHistoryEntryData
-import java.util.Date
-
-@Composable
-fun EditHistoryTimelineItem(
-    modifier: Modifier = Modifier,
-    bubbleModifier: Modifier = Modifier,
-    editHistoryEntry: EditHistoryEntryData,
-    isOutbox: Boolean,
-    shouldMarkupText: Boolean,
-    isExpanded: Boolean = false,
-    shouldFadeOutTimeLineTop: Boolean = false,
-    shouldFadeOutTimeLineBottom: Boolean = false,
-    textSelectionCallback: CustomTextSelectionCallback? = null,
-    onClick: (() -> Unit)? = null,
-) {
-    VerticalTimelineItem(
-        modifier = modifier
-            .semantics(mergeDescendants = true) { },
-        color = if (isOutbox) MaterialTheme.colorScheme.secondaryContainer else MaterialTheme.customColorScheme.messageBubbleContainerReceive,
-        shouldFadeOutLineTop = shouldFadeOutTimeLineTop,
-        shouldFadeOutLineBottom = shouldFadeOutTimeLineBottom,
-        labelContent = {
-            EditedAtLabel(editHistoryEntry.editedAt)
-        }
-    ) {
-        EditHistoryItemBubble(
-            bubbleModifier = bubbleModifier,
-            editHistoryEntry = editHistoryEntry,
-            isOutbox = isOutbox,
-            shouldMarkupText = shouldMarkupText,
-            isExpanded = isExpanded,
-            textSelectionCallback = textSelectionCallback,
-            onClick = onClick
-        )
-    }
-}
-
-@Composable
-fun EditHistoryItem(
-    modifier: Modifier = Modifier,
-    bubbleModifier: Modifier = Modifier,
-    editHistoryEntry: EditHistoryEntryData,
-    isOutbox: Boolean,
-    shouldMarkupText: Boolean,
-    isExpanded: Boolean = false,
-    textSelectionCallback: CustomTextSelectionCallback? = null,
-    onClick: (() -> Unit)? = null,
-) {
-    Column(modifier) {
-        EditedAtLabel(editHistoryEntry.editedAt)
-        Spacer(Modifier.height(4.dp))
-        EditHistoryItemBubble(
-            bubbleModifier = bubbleModifier,
-            editHistoryEntry = editHistoryEntry,
-            isOutbox = isOutbox,
-            shouldMarkupText = shouldMarkupText,
-            isExpanded = isExpanded,
-            textSelectionCallback = textSelectionCallback,
-            onClick = onClick
-        )
-    }
-}
-
-@Composable
-private fun EditHistoryItemBubble(
-    modifier: Modifier = Modifier,
-    bubbleModifier: Modifier = Modifier,
-    editHistoryEntry: EditHistoryEntryData,
-    isOutbox: Boolean,
-    shouldMarkupText: Boolean,
-    isExpanded: Boolean = false,
-    textSelectionCallback: CustomTextSelectionCallback? = null,
-    onClick: (() -> Unit)? = null,
-) {
-
-    /**
-     * If we encounter a blank/null value in [EditHistoryEntryData.text] we can
-     * be sure it is an EditHistoryEntryData of a file message. Because you cant
-     * clear the text of a normal text message through editing it. So in this case
-     * we want to style the message bubble body text slightly different and set a
-     * placeholder text like `No caption`
-     */
-    val isEmptyFileMessageCaption: Boolean = editHistoryEntry.text.isNullOrBlank()
-
-    Box(modifier) {
-        AnimatedVisibilityNow {
-            MessageBubble(
-                modifier = bubbleModifier
-                    .padding(bottom = 16.dp),
-                text = editHistoryEntry.text ?: stringResource(R.string.edit_history_file_no_caption),
-                isOutbox = isOutbox,
-                shouldMarkupText = shouldMarkupText,
-                onClick = onClick,
-                textSelectionCallback = textSelectionCallback,
-                textAppearanceRes = if (isEmptyFileMessageCaption) {
-                    R.style.Threema_Bubble_Text_Body_HistoryNoCaption
-                } else {
-                    R.style.Threema_Bubble_Text_Body
-                },
-            )
-        }
-
-        // overlay to fade out bottom when collapsed
-        AnimatedVisibility(
-            modifier = Modifier
-                .fillMaxWidth()
-                .height(72.dp)
-                .align(Alignment.BottomCenter),
-            visible = !isExpanded,
-        ) {
-            Box(
-                modifier = Modifier
-                    .background(
-                        Brush.verticalGradient(
-                            colorStops = arrayOf(
-                                0f to Color.Transparent,
-                                .7f to MaterialTheme.colorScheme.background
-                            ),
-                        )
-                    )
-            )
-        }
-    }
-}
-
-@Composable
-private fun EditedAtLabel(editedAt: Date) {
-    val formattedEditedAtDate = LocaleUtil.formatTimeStampStringAbsolute(
-        LocalContext.current,
-        editedAt.time
-    )
-    AnimatedVisibilityNow {
-        ThemedText(
-            modifier = Modifier
-                .padding(start = 4.dp)
-                .then(stringResource(R.string.cd_edited_at).let { Modifier.semantics { contentDescription = it.format(formattedEditedAtDate) } }),
-            text = formattedEditedAtDate,
-            style = AppTypography.labelLarge
-        )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryList.kt b/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryList.kt
deleted file mode 100644
index c4c6b5da..00000000
--- a/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryList.kt
+++ /dev/null
@@ -1,161 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.edithistory
-
-import android.annotation.SuppressLint
-import android.content.Context.ACCESSIBILITY_SERVICE
-import android.view.accessibility.AccessibilityManager
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.lazy.LazyColumn
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.LaunchedEffect
-import androidx.compose.runtime.derivedStateOf
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateMapOf
-import androidx.compose.runtime.produceState
-import androidx.compose.runtime.remember
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.layout.onGloballyPositioned
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.platform.LocalDensity
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.isTraversalGroup
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.unit.dp
-import ch.threema.app.R
-import ch.threema.app.compose.common.ThemedText
-import ch.threema.app.compose.common.anim.ExpandingBox
-import ch.threema.app.ui.CustomTextSelectionCallback
-
-private val ITEM_MAX_HEIGHT = 196.dp
-
-@Composable
-@SuppressLint("ComposableLambdaParameterNaming")
-fun EditHistoryList(
-    modifier: Modifier,
-    editHistoryUiState: EditHistoryUiState,
-    isOutbox: Boolean,
-    shouldMarkupText: Boolean,
-    textSelectionCallback: CustomTextSelectionCallback? = null,
-    headerContent: (@Composable () -> Unit)? = null,
-    footerContent: (@Composable () -> Unit)? = null,
-) {
-    val density = LocalDensity.current
-    val context = LocalContext.current
-
-    // check if talkback is enabled
-    val isExploreByTouchEnabled = produceState(false) {
-        val am: AccessibilityManager? = context.getSystemService(ACCESSIBILITY_SERVICE) as AccessibilityManager?
-        value = am?.isTouchExplorationEnabled ?: false
-    }
-
-    val isItemExpandableMap = remember { mutableStateMapOf<Int, Boolean>() }
-    LaunchedEffect(editHistoryUiState.editHistoryEntries) {
-        isItemExpandableMap.keys.retainAll(editHistoryUiState.editHistoryEntries.map { it.uid }.toSet())
-    }
-
-    LazyColumn(modifier = modifier) {
-        item {
-            headerContent?.invoke()
-        }
-        if (editHistoryUiState.editHistoryEntries.isNotEmpty()) {
-
-            item {
-                Spacer(modifier = Modifier.height(24.dp))
-            }
-
-            // edit history label
-            item {
-                ThemedText(
-                    modifier = Modifier
-                        .padding(start = 8.dp)
-                        .semantics { isTraversalGroup = true },
-                    text = stringResource(R.string.edit_history),
-                    style = MaterialTheme.typography.titleMedium,
-                )
-                Spacer(modifier = Modifier.height(8.dp))
-            }
-            // edit history
-            items(
-                count = editHistoryUiState.editHistoryEntries.size,
-                key = { index -> editHistoryUiState.editHistoryEntries[index].uid }
-            ) { index ->
-                val entry = editHistoryUiState.editHistoryEntries[index]
-                val isExpandable by remember { derivedStateOf { isItemExpandableMap[entry.uid] ?: false } }
-
-                ExpandingBox(
-                    collapsedMaxHeight = if (isExpandable) ITEM_MAX_HEIGHT else null
-                ) { isExpanded, toggleExpanded ->
-                    val itemModifier = Modifier
-                        .padding(start = 8.dp)
-                        .then(stringResource(R.string.cd_index_in_edit_history).let {
-                            Modifier.semantics {
-                                contentDescription = it.format(editHistoryUiState.editHistoryEntries.size - index)
-                            }
-                        })
-                    val bubbleModifier = Modifier.onGloballyPositioned { coordinates ->
-                        // measure bubble height to initialize whether it is expandable
-                        if (!isItemExpandableMap.containsKey(entry.uid)) {
-                            val heightInDp = (coordinates.size.height / density.density).dp
-                            isItemExpandableMap[entry.uid] = !isExploreByTouchEnabled.value && heightInDp > ITEM_MAX_HEIGHT
-                        }
-                    }
-                    if (editHistoryUiState.editHistoryEntries.size > 1) {
-                        EditHistoryTimelineItem(
-                            modifier = itemModifier,
-                            bubbleModifier = bubbleModifier,
-                            editHistoryEntry = entry,
-                            isOutbox = isOutbox,
-                            shouldMarkupText = shouldMarkupText,
-                            isExpanded = if (isExpandable) isExpanded else true,
-                            onClick = if (isExpandable) toggleExpanded else null,
-                            shouldFadeOutTimeLineTop = index == 0,
-                            shouldFadeOutTimeLineBottom = index == editHistoryUiState.editHistoryEntries.size - 1,
-                            textSelectionCallback = textSelectionCallback,
-                        )
-                    } else {
-                        EditHistoryItem(
-                            modifier = itemModifier.padding(start = 8.dp),
-                            bubbleModifier = bubbleModifier,
-                            editHistoryEntry = entry,
-                            isOutbox = isOutbox,
-                            shouldMarkupText = shouldMarkupText,
-                            isExpanded = if (isExpandable) isExpanded else true,
-                            onClick = if (isExpandable) toggleExpanded else null,
-                            textSelectionCallback = textSelectionCallback,
-                        )
-                    }
-                }
-            }
-        }
-        item {
-            Spacer(modifier = Modifier.height(24.dp))
-        }
-        item {
-            footerContent?.invoke()
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryViewModel.kt b/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryViewModel.kt
deleted file mode 100644
index fca76338..00000000
--- a/app/src/main/java/ch/threema/app/compose/edithistory/EditHistoryViewModel.kt
+++ /dev/null
@@ -1,71 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.edithistory
-
-import androidx.lifecycle.SavedStateHandle
-import androidx.lifecycle.createSavedStateHandle
-import androidx.lifecycle.viewmodel.initializer
-import androidx.lifecycle.viewmodel.viewModelFactory
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.activities.StateFlowViewModel
-import ch.threema.data.models.EditHistoryEntryData
-import ch.threema.data.repositories.EditHistoryRepository
-import kotlinx.coroutines.flow.MutableStateFlow
-import kotlinx.coroutines.flow.StateFlow
-import kotlinx.coroutines.flow.map
-
-class EditHistoryViewModel(
-    savedStateHandle: SavedStateHandle,
-    editHistoryRepository: EditHistoryRepository,
-) : StateFlowViewModel() {
-
-    companion object {
-
-        private const val MESSAGE_UID = "messageUid"
-
-        fun provideFactory(messageId: String) = viewModelFactory {
-            initializer {
-                EditHistoryViewModel(
-                    this.createSavedStateHandle().apply {
-                        set(MESSAGE_UID, messageId)
-                    },
-                    ThreemaApplication.requireServiceManager().modelRepositories.editHistory
-                )
-            }
-        }
-    }
-
-    private val messageUid = checkNotNull(savedStateHandle[MESSAGE_UID]) as String
-
-    val editHistoryUiState: StateFlow<EditHistoryUiState> =
-        (editHistoryRepository.getByMessageUid(messageUid)?.data ?: MutableStateFlow(emptyList()))
-            .map { editHistoryEntries ->
-                EditHistoryUiState(editHistoryEntries ?: emptyList())
-            }
-            .stateInViewModel(
-                initialValue = EditHistoryUiState(emptyList())
-            )
-}
-
-data class EditHistoryUiState(
-    val editHistoryEntries: List<EditHistoryEntryData>
-)
diff --git a/app/src/main/java/ch/threema/app/compose/edithistory/VerticalTimelineItem.kt b/app/src/main/java/ch/threema/app/compose/edithistory/VerticalTimelineItem.kt
deleted file mode 100644
index 0c3828d3..00000000
--- a/app/src/main/java/ch/threema/app/compose/edithistory/VerticalTimelineItem.kt
+++ /dev/null
@@ -1,145 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.edithistory
-
-import androidx.compose.foundation.background
-import androidx.compose.foundation.layout.Box
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.IntrinsicSize
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxHeight
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.size
-import androidx.compose.foundation.layout.width
-import androidx.compose.foundation.shape.CircleShape
-import androidx.compose.foundation.shape.RoundedCornerShape
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.draw.clip
-import androidx.compose.ui.graphics.Brush
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.tooling.preview.Preview
-import androidx.compose.ui.unit.Dp
-import androidx.compose.ui.unit.dp
-import ch.threema.app.compose.common.ThemedText
-import ch.threema.app.compose.theme.AppTypography
-
-@Composable
-fun VerticalTimelineItem(
-    modifier: Modifier = Modifier,
-    color: Color,
-    dotSize: Dp = 12.dp,
-    lineWidth: Dp = 4.dp,
-    shouldFadeOutLineBottom: Boolean = false,
-    shouldFadeOutLineTop: Boolean = false,
-    labelContent: @Composable (() -> Unit)? = null,
-    content: @Composable () -> Unit,
-) {
-    fun getLineBackgroundWithBottomFade(): Modifier {
-        return Modifier.background(brush = Brush.verticalGradient(
-            colorStops = arrayOf(
-                .5f to color,
-                1f to Color.Transparent
-            ),
-        ))
-    }
-
-    fun getLineBackgroundWithTopFade(): Modifier {
-        return Modifier.background(brush = Brush.verticalGradient(
-            colorStops = arrayOf(
-                0.2f to Color.Transparent,
-                1f to color
-            ),
-        ))
-    }
-
-    Column(modifier) {
-        val timelineMargin = 12.dp
-        Row(modifier = Modifier.height(IntrinsicSize.Min),
-            verticalAlignment = Alignment.CenterVertically
-        ) {
-            Box(contentAlignment = Alignment.Center) {
-                Box(modifier = Modifier
-                    .fillMaxHeight()
-                    .width(lineWidth)
-                    .then(if (shouldFadeOutLineTop) getLineBackgroundWithTopFade() else Modifier.background(color))
-                )
-                Box(modifier = Modifier
-                    .size(dotSize)
-                    .clip(CircleShape)
-                    .background(color)
-                )
-            }
-            Spacer(modifier = Modifier.width(timelineMargin))
-            labelContent?.invoke()
-        }
-        Row(modifier = Modifier.height(IntrinsicSize.Min),
-            verticalAlignment = Alignment.CenterVertically
-        ) {
-            Box(modifier = Modifier.width(dotSize), contentAlignment = Alignment.Center) {
-                Box(modifier = Modifier
-                    .fillMaxHeight()
-                    .width(lineWidth)
-                    .then(if (shouldFadeOutLineBottom) getLineBackgroundWithBottomFade() else Modifier.background(color))
-                )
-            }
-            Spacer(modifier = Modifier.width(timelineMargin))
-            Box(modifier = Modifier.padding(top = 4.dp)) {
-                content()
-            }
-        }
-    }
-}
-
-@Preview
-@Composable
-private fun VerticalTimelineItemPreview() {
-    VerticalTimelineItem(
-        color = MaterialTheme.colorScheme.secondaryContainer,
-        dotSize = 12.dp,
-        lineWidth = 4.dp,
-        shouldFadeOutLineBottom = true,
-        shouldFadeOutLineTop = true,
-        labelContent = {
-            ThemedText(
-                modifier = Modifier.padding(start = 4.dp),
-                text = "Label",
-                style = AppTypography.labelLarge,
-                color = Color.White
-            )
-        }
-    ) {
-        Box(modifier = Modifier
-            .height(100.dp)
-            .fillMaxWidth()
-            .background(
-                color = MaterialTheme.colorScheme.secondaryContainer,
-                shape = RoundedCornerShape(8.dp)
-            )
-        )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/AckDecIndicator.kt b/app/src/main/java/ch/threema/app/compose/message/AckDecIndicator.kt
deleted file mode 100644
index d2502ed0..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/AckDecIndicator.kt
+++ /dev/null
@@ -1,126 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.size
-import androidx.compose.foundation.layout.width
-import androidx.compose.material3.Icon
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.Text
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.res.painterResource
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.tooling.preview.Preview
-import androidx.compose.ui.unit.dp
-import ch.threema.app.R
-import ch.threema.app.activities.ContactAckDecState
-import ch.threema.app.activities.GroupAckDecState
-import ch.threema.app.activities.UserReaction
-import ch.threema.app.compose.theme.AppTypography
-import ch.threema.app.compose.theme.customColorScheme
-
-@Composable
-fun ContactAckDecIndicator(ackDecState: ContactAckDecState) {
-    Row(verticalAlignment = Alignment.CenterVertically) {
-        when (ackDecState) {
-            ContactAckDecState.ACK -> AckIndicator(true)
-            ContactAckDecState.DEC -> DecIndicator(true)
-            ContactAckDecState.NONE -> Unit
-        }
-    }
-}
-
-@Composable
-fun GroupAckDecIndicator(
-    ackState: GroupAckDecState,
-    decState: GroupAckDecState,
-) {
-    Row(verticalAlignment = Alignment.CenterVertically) {
-        if (ackState.count > 0) {
-            AckIndicator(ackState.userReaction == UserReaction.REACTED)
-            Spacer(modifier = Modifier.width(2.dp))
-            AckDecCountLabel(ackState.count, MaterialTheme.customColorScheme.ackTint)
-        }
-        Spacer(modifier = Modifier.width(2.dp))
-        if (decState.count > 0) {
-            DecIndicator(decState.userReaction == UserReaction.REACTED)
-            Spacer(modifier = Modifier.width(2.dp))
-            AckDecCountLabel(decState.count, MaterialTheme.customColorScheme.decTint)
-        }
-    }
-}
-
-@Composable
-private fun AckIndicator(filled: Boolean) {
-    val resource = if (filled) {
-        R.drawable.ic_thumb_up_filled
-    } else {
-        R.drawable.ic_thumb_up_grey600_24dp
-    }
-    Icon(
-        modifier = Modifier
-            .padding(bottom = 1.dp)
-            .size(16.dp),
-        painter = painterResource(resource),
-        tint = MaterialTheme.customColorScheme.ackTint,
-        contentDescription = stringResource(R.string.cd_ack_icon)
-    )
-}
-
-@Composable
-private fun DecIndicator(filled: Boolean) {
-    val resource = if (filled) {
-        R.drawable.ic_thumb_down_filled
-    } else {
-        R.drawable.ic_thumb_down_grey600_24dp
-    }
-    Icon(
-        modifier = Modifier
-            .size(16.dp),
-        painter = painterResource(resource),
-        tint = MaterialTheme.customColorScheme.decTint,
-        contentDescription = stringResource(R.string.cd_dec_icon)
-    )
-}
-
-@Composable
-private fun AckDecCountLabel(count: Int, color: Color) {
-    Text(
-        modifier = stringResource(R.string.cd_ack_dec_group_count).let { Modifier.semantics { it.format(count) } },
-        text = count.toString(),
-        style = AppTypography.bodySmall,
-        color = color,
-    )
-}
-
-@Composable
-@Preview
-private fun GroupAckDecIndicatorPreview() {
-    GroupAckDecIndicator(GroupAckDecState(4, UserReaction.REACTED), GroupAckDecState(3, UserReaction.NONE))
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/CombinedMessageDetailsList.kt b/app/src/main/java/ch/threema/app/compose/message/CombinedMessageDetailsList.kt
deleted file mode 100644
index bd826169..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/CombinedMessageDetailsList.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.size
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.unit.dp
-import ch.threema.app.activities.MessageDetailsUiModel
-import ch.threema.app.activities.MessageTimestampsUiModel
-
-@Composable
-fun CombinedMessageDetailsList(
-    messageTimestampsUiModel: MessageTimestampsUiModel,
-    messageDetailsUiModel: MessageDetailsUiModel
-) {
-
-    Column {
-        MessageTimestampsList(model = messageTimestampsUiModel)
-        Spacer(modifier = Modifier.size(4.dp))
-        MessageDetailsList(model = messageDetailsUiModel)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/DeliveryIcon.kt b/app/src/main/java/ch/threema/app/compose/message/DeliveryIcon.kt
deleted file mode 100644
index 58a1a8c9..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/DeliveryIcon.kt
+++ /dev/null
@@ -1,48 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import androidx.annotation.DrawableRes
-import androidx.annotation.StringRes
-import androidx.compose.foundation.layout.size
-import androidx.compose.material3.Icon
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.res.painterResource
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.unit.dp
-
-@Composable
-fun DeliveryIndicator(
-    @DrawableRes deliveryIconRes: Int,
-    @StringRes deliveryIconContentDescriptionRes: Int,
-    tintColor: Color?
-) {
-    Icon(
-        modifier = Modifier.size(18.dp),
-        painter = painterResource(deliveryIconRes),
-        tint = tintColor ?: MaterialTheme.colorScheme.onSurface,
-        contentDescription = stringResource(deliveryIconContentDescriptionRes)
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/MessageBubble.kt b/app/src/main/java/ch/threema/app/compose/message/MessageBubble.kt
deleted file mode 100644
index 54e6a654..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/MessageBubble.kt
+++ /dev/null
@@ -1,257 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import android.annotation.SuppressLint
-import androidx.annotation.DrawableRes
-import androidx.annotation.StringRes
-import androidx.annotation.StyleRes
-import androidx.compose.foundation.background
-import androidx.compose.foundation.clickable
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.size
-import androidx.compose.foundation.layout.wrapContentHeight
-import androidx.compose.foundation.shape.RoundedCornerShape
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.draw.clip
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.isTraversalGroup
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.tooling.preview.Preview
-import androidx.compose.ui.unit.dp
-import ch.threema.app.R
-import ch.threema.app.activities.AckUiModel
-import ch.threema.app.activities.GroupAckDecState
-import ch.threema.app.activities.GroupAckUiModel
-import ch.threema.app.activities.MessageUiModel
-import ch.threema.app.activities.UserReaction
-import ch.threema.app.compose.common.ThemedText
-import ch.threema.app.compose.common.interop.InteropEmojiConversationTextView
-import ch.threema.app.compose.theme.AppTypography
-import ch.threema.app.compose.theme.customColorScheme
-import ch.threema.app.ui.CustomTextSelectionCallback
-import ch.threema.app.utils.LocaleUtil
-import ch.threema.data.models.EditHistoryEntryData
-import java.util.Date
-
-@Composable
-fun MessageBubble(
-    modifier: Modifier = Modifier,
-    text: String,
-    @StyleRes textAppearanceRes: Int = R.style.Threema_Bubble_Text_Body,
-    isOutbox: Boolean,
-    shouldMarkupText: Boolean = true,
-    textSelectionCallback: CustomTextSelectionCallback? = null,
-    isTextSelectable: Boolean = false,
-    onClick: (() -> Unit)? = null,
-    @SuppressLint("ComposableLambdaParameterNaming")
-    footerContent: @Composable ((contentColor: Color) -> Unit)? = null
-) {
-    val bubbleColor: Color = if (isOutbox) {
-        MaterialTheme.colorScheme.secondaryContainer
-    } else {
-        MaterialTheme.customColorScheme.messageBubbleContainerReceive
-    }
-    val contentColor = if (isOutbox) {
-        MaterialTheme.colorScheme.onSecondaryContainer
-    } else {
-        MaterialTheme.colorScheme.onBackground
-    }
-    Column(
-        modifier = modifier
-            .background(
-                color = bubbleColor,
-                shape = RoundedCornerShape(16.dp)
-            )
-            .clip(RoundedCornerShape(16.dp))
-            .then(onClick?.let { Modifier.clickable { it() } } ?: Modifier)
-            .padding(start = 16.dp, end = 16.dp, top = 6.dp, bottom = 4.dp)
-    ) {
-        InteropEmojiConversationTextView(
-            text = text,
-            textAppearanceRes = textAppearanceRes,
-            contentColor = contentColor,
-            shouldMarkupText = shouldMarkupText,
-            textSelectionCallback = textSelectionCallback,
-            isTextSelectable = isTextSelectable,
-        )
-        Spacer(modifier = Modifier.size(4.dp))
-        footerContent?.invoke(contentColor)
-    }
-}
-
-@Composable
-fun CompleteMessageBubble(
-    modifier: Modifier = Modifier,
-    message: MessageUiModel,
-    shouldMarkupText: Boolean,
-    isTextSelectable: Boolean = false,
-    textSelectionCallback: CustomTextSelectionCallback? = null,
-) {
-    val cdMessage = stringResource(R.string.cd_message)
-    if (message.isDeleted) {
-        DeletedMessageBubble(message.isOutbox, message.createdAt)
-    } else {
-
-        /**
-         * If we encounter a blank/empty value in [MessageUiModel.text] we can
-         * be sure it is an MessageUiModel of a file message. Because you cant
-         * send empty text messages. So in this case we want to style the
-         * message bubble body text slightly different and set a placeholder
-         * text like `No caption`
-         */
-        val isEmptyFileMessageCaption: Boolean = message.text.isBlank()
-
-        MessageBubble(
-            modifier = modifier.semantics(mergeDescendants = true) {
-                contentDescription = cdMessage
-                isTraversalGroup = true
-            },
-            text = message.text.takeIf(String::isNotBlank) ?: stringResource(R.string.edit_history_file_no_caption),
-            isOutbox = message.isOutbox,
-            shouldMarkupText = shouldMarkupText,
-            textSelectionCallback = textSelectionCallback,
-            isTextSelectable = isTextSelectable,
-            textAppearanceRes = if (isEmptyFileMessageCaption) {
-                R.style.Threema_Bubble_Text_Body_HistoryNoCaption
-            } else {
-                R.style.Threema_Bubble_Text_Body
-            },
-            footerContent = { contentColor: Color ->
-                MessageBubbleFooter(
-                    shouldShowEditedLabel = message.editedAt != null,
-                    date = message.createdAt,
-                    isOutbox = message.isOutbox,
-                    deliveryIconRes = message.deliveryIconRes,
-                    deliveryIconContentDescriptionRes = message.deliveryIconContentDescriptionRes,
-                    contentColor = contentColor,
-                    ackUiModel = message.ackUiModel
-                )
-            }
-        )
-    }
-}
-
-@Composable
-fun DeletedMessageBubble(
-    isOutbox: Boolean,
-    date: Date,
-    onClick: (() -> Unit)? = null,
-) {
-    MessageBubble(
-        text = stringResource(R.string.message_was_deleted),
-        textAppearanceRes = R.style.Threema_Bubble_Text_Body_Deleted,
-        isOutbox = isOutbox,
-        onClick = onClick,
-        footerContent = { contentColor ->
-            MessageBubbleFooter(
-                shouldShowEditedLabel = false,
-                isOutbox = isOutbox,
-                date = date,
-                contentColor = contentColor
-            )
-        }
-    )
-}
-
-@Composable
-fun MessageBubbleFooter(
-    shouldShowEditedLabel: Boolean,
-    date: Date? = null,
-    isOutbox: Boolean,
-    @DrawableRes deliveryIconRes: Int? = null,
-    @StringRes deliveryIconContentDescriptionRes: Int? = null,
-    contentColor: Color,
-    ackUiModel: AckUiModel? = null
-) {
-    Row(
-        modifier = Modifier
-            .fillMaxWidth()
-            .wrapContentHeight(),
-        verticalAlignment = Alignment.CenterVertically
-    ) {
-        if (shouldShowEditedLabel) {
-            ThemedText(
-                modifier = stringResource(R.string.cd_edited).let { Modifier.semantics { contentDescription = it } },
-                text = stringResource(R.string.edited),
-                style = AppTypography.bodySmall,
-                color = contentColor
-            )
-        }
-        Spacer(modifier = Modifier.weight(1f))
-        if (ackUiModel != null && !isOutbox) {
-            Spacer(modifier = Modifier.size(8.dp))
-            MessageStateIndicator(
-                ackUiModel = ackUiModel,
-            )
-        }
-        date?.let {
-            Spacer(modifier = Modifier.size(4.dp))
-            val formattedDate = LocaleUtil.formatTimeStampString(LocalContext.current, it.time, true)
-            ThemedText(
-                modifier = stringResource(R.string.cd_created_at).let { Modifier.semantics { contentDescription = it.format(formattedDate) } },
-                text = formattedDate,
-                style = AppTypography.bodySmall,
-                color = contentColor
-            )
-        }
-        if ((ackUiModel != null || deliveryIconRes != null) && isOutbox) {
-            Spacer(modifier = Modifier.size(8.dp))
-            MessageStateIndicator(
-                ackUiModel = ackUiModel,
-                deliveryIconRes = deliveryIconRes,
-                deliveryIconContentDescriptionRes = deliveryIconContentDescriptionRes,
-                deliveryIndicatorTintColor = contentColor
-            )
-        }
-    }
-}
-
-@Preview
-@Composable
-private fun MessageBubblePreview() {
-    MessageBubble(
-        text = "Lorem ipsum *dolor sit amet*, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam",
-        isOutbox = true,
-        shouldMarkupText = true,
-        footerContent = { contentColor: Color ->
-            MessageBubbleFooter(
-                shouldShowEditedLabel = true,
-                date = Date(),
-                isOutbox = true,
-                deliveryIconRes = R.drawable.ic_mark_read,
-                contentColor = contentColor,
-                ackUiModel = GroupAckUiModel(GroupAckDecState(2, UserReaction.REACTED), GroupAckDecState(1, UserReaction.NONE)),
-            )
-        }
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/MessageDetails.kt b/app/src/main/java/ch/threema/app/compose/message/MessageDetails.kt
deleted file mode 100644
index dbbe004d..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/MessageDetails.kt
+++ /dev/null
@@ -1,165 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import android.content.Context
-import androidx.compose.foundation.background
-import androidx.compose.foundation.border
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.shape.RoundedCornerShape
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.isTraversalGroup
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.tooling.preview.Preview
-import androidx.compose.ui.unit.dp
-import ch.threema.app.R
-import ch.threema.app.activities.MessageDetailsUiModel
-import ch.threema.app.compose.theme.customColorScheme
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode
-import android.text.format.Formatter
-
-@Composable
-fun MessageDetailsListBox(
-    modifier: Modifier = Modifier,
-    messageDetailsUiModel: MessageDetailsUiModel,
-    isOutbox: Boolean
-) {
-    val borderColor = if (isOutbox) {
-        MaterialTheme.colorScheme.secondaryContainer
-    } else {
-        MaterialTheme.customColorScheme.messageBubbleContainerReceive
-    }
-    MessageDetailsList(
-        modifier = modifier
-            .border(width = 2.dp, color = borderColor, shape = RoundedCornerShape(8.dp))
-            .padding(16.dp)
-            .then(stringResource(R.string.cd_message_details_container).let { contentDescription ->
-                Modifier.semantics {
-                    this.contentDescription = contentDescription
-                    isTraversalGroup = true
-                }
-            }),
-        model = messageDetailsUiModel
-    )
-}
-
-@Composable
-fun MessageDetailsList(
-    modifier: Modifier = Modifier,
-    model: MessageDetailsUiModel,
-) {
-
-    Column(
-        modifier = modifier,
-        verticalArrangement = Arrangement.spacedBy(4.dp),
-    ) {
-        model.messageId?.let { messageId ->
-            MessageDetailsRow(
-                label = stringResource(R.string.message_id),
-                value = messageId,
-                selectableValueOption = SelectableValueOption.Selectable(
-                    onValueCopiedNoticeStringResId = R.string.message_details_message_id_copied
-                )
-            )
-        }
-        model.mimeType?.let { mimeType ->
-            MessageDetailsRow(
-                label = stringResource(R.string.mime_type),
-                value = mimeType
-            )
-        }
-        model.fileSizeInBytes?.let { fileSizeInBytes ->
-            MessageDetailsRow(
-                label = stringResource(R.string.file_size),
-                value = Formatter.formatShortFileSize(LocalContext.current, fileSizeInBytes)
-            )
-        }
-        model.pfsState?.let { forwardSecurityMode ->
-            MessageDetailsRow(
-                label = stringResource(R.string.forward_security_mode),
-                value = forwardSecurityMode.getName(LocalContext.current)
-            )
-        }
-    }
-}
-
-private fun ForwardSecurityMode.getName(context: Context): String =
-    when (this) {
-        ForwardSecurityMode.NONE -> context.getString(R.string.forward_security_mode_none)
-        ForwardSecurityMode.TWODH -> context.getString(R.string.forward_security_mode_2dh)
-        ForwardSecurityMode.FOURDH -> context.getString(R.string.forward_security_mode_4dh)
-        ForwardSecurityMode.ALL -> context.getString(R.string.forward_security_mode_all)
-        ForwardSecurityMode.PARTIAL -> context.getString(R.string.forward_security_mode_partial)
-    }
-
-@Preview(name = "Outbox", group = "box")
-@Composable
-private fun MessageDetailsListBoxPreview_Outbox() {
-    MessageDetailsListBox(
-        modifier = Modifier.padding(16.dp),
-        messageDetailsUiModel = MessageDetailsUiModel(
-            messageId = "1234567890123456",
-            mimeType = "image/png",
-            fileSizeInBytes = 1024L,
-            pfsState = ForwardSecurityMode.ALL
-        ),
-        isOutbox = true
-    )
-}
-
-@Preview(name = "Inbox", group = "box")
-@Composable
-private fun MessageDetailsListBoxPreview_Inbox() {
-    MessageDetailsListBox(
-        modifier = Modifier.padding(16.dp),
-        messageDetailsUiModel = MessageDetailsUiModel(
-            messageId = "1234567890123456",
-            mimeType = "image/png",
-            fileSizeInBytes = 1024L,
-            pfsState = ForwardSecurityMode.ALL
-        ),
-        isOutbox = false
-    )
-}
-
-@Preview
-@Composable
-private fun MessageDetailsListPreview() {
-    MessageDetailsList(
-        modifier = Modifier
-            .background(MaterialTheme.colorScheme.background)
-            .padding(16.dp),
-        model = MessageDetailsUiModel(
-            messageId = "1234567890123456",
-            mimeType = "image/png",
-            fileSizeInBytes = 1024L,
-            pfsState = ForwardSecurityMode.ALL
-        )
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/MessageDetailsRow.kt b/app/src/main/java/ch/threema/app/compose/message/MessageDetailsRow.kt
deleted file mode 100644
index 5803cda9..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/MessageDetailsRow.kt
+++ /dev/null
@@ -1,184 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import android.content.ClipData
-import android.content.ClipboardManager
-import android.content.Context
-import android.widget.Toast
-import androidx.annotation.DrawableRes
-import androidx.annotation.StringRes
-import androidx.compose.foundation.ExperimentalFoundationApi
-import androidx.compose.foundation.combinedClickable
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.ExperimentalLayoutApi
-import androidx.compose.foundation.layout.FlowRow
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.size
-import androidx.compose.material3.Icon
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.Surface
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.res.painterResource
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.text.style.TextAlign
-import androidx.compose.ui.tooling.preview.Preview
-import androidx.compose.ui.unit.dp
-import ch.threema.app.R
-import ch.threema.app.compose.common.ThemedText
-import ch.threema.app.compose.theme.AppTypography
-
-@OptIn(ExperimentalLayoutApi::class, ExperimentalFoundationApi::class)
-@Composable
-fun MessageDetailsRow(
-    modifier: Modifier = Modifier,
-    label: String,
-    value: String,
-    @DrawableRes iconResId: Int? = null,
-    selectableValueOption: SelectableValueOption = SelectableValueOption.NotSelectable
-) {
-
-    val context = LocalContext.current
-
-    fun copyToClipboardAndShowHintLink() {
-        copyToClipboardAndShowHint(
-            context = context,
-            value = value,
-            selectableValueOption = selectableValueOption as SelectableValueOption.Selectable
-        )
-    }
-
-    Row(
-        modifier = modifier.fillMaxWidth(),
-        verticalAlignment = Alignment.CenterVertically
-    ) {
-
-        if (iconResId != null) {
-            Icon(
-                modifier = Modifier
-                    .padding(vertical = 4.dp)
-                    .padding(end = 12.dp)
-                    .size(20.dp),
-                painter = painterResource(id = iconResId),
-                tint = MaterialTheme.colorScheme.onSurface,
-                contentDescription = null
-            )
-        }
-
-        FlowRow(
-            modifier = Modifier
-                .weight(1f)
-                .padding(vertical = 2.dp)
-                .semantics(mergeDescendants = true) { },
-            horizontalArrangement = Arrangement.SpaceBetween
-        ) {
-            ThemedText(
-                modifier = Modifier.padding(end = 16.dp),
-                text = label,
-                style = AppTypography.labelLarge,
-            )
-
-            Surface(
-                modifier = Modifier.combinedClickable(
-                    enabled = selectableValueOption.isSelectable,
-                    onLongClick = ::copyToClipboardAndShowHintLink,
-                    onDoubleClick = ::copyToClipboardAndShowHintLink,
-                    onClick = {}
-                ),
-                color = Color.Transparent
-            ) {
-                ThemedText(
-                    text = value,
-                    style = AppTypography.bodyMedium,
-                    textAlign = TextAlign.Start,
-                )
-            }
-        }
-    }
-}
-
-sealed class SelectableValueOption(val isSelectable: Boolean) {
-    data object NotSelectable : SelectableValueOption(isSelectable = false)
-
-    data class Selectable(
-        @StringRes val onValueCopiedNoticeStringResId: Int
-    ) : SelectableValueOption(isSelectable = true)
-}
-
-private fun copyToClipboardAndShowHint(
-    context: Context,
-    value: String,
-    selectableValueOption: SelectableValueOption.Selectable,
-) {
-    val stringResId = selectableValueOption.onValueCopiedNoticeStringResId
-    val clip = ClipData.newPlainText(null, value)
-    (context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager).setPrimaryClip(clip)
-    Toast.makeText(context, context.getString(stringResId), Toast.LENGTH_LONG).show()
-}
-
-@Preview
-@Composable
-private fun MessageDetailsRowPreview() {
-    MessageDetailsRow(
-        modifier = Modifier.padding(16.dp),
-        label = "Label",
-        value = "Value"
-    )
-}
-
-@Preview
-@Composable
-private fun MessageDetailsRowPreview_Icon() {
-    MessageDetailsRow(
-        modifier = Modifier.padding(16.dp),
-        label = "Label",
-        value = "Value",
-        iconResId = R.drawable.ic_key_outline
-    )
-}
-
-@Preview
-@Composable
-private fun MessageDetailsRowPreview_Multiline() {
-    MessageDetailsRow(
-        modifier = Modifier.padding(16.dp),
-        label = "Labelllllllllllllllllllllllllllllllllllllllllll",
-        value = "Valueeeeeeeeeeeeeeeeeeeeeeeeeeee"
-    )
-}
-
-@Preview
-@Composable
-private fun MessageDetailsRowPreview_Multiline_Icon() {
-    MessageDetailsRow(
-        modifier = Modifier.padding(16.dp),
-        label = "Labelllllllllllllllllllllllllllllllllllllllllll",
-        value = "Valueeeeeeeeeeeeeeeeeeeeeeeeeeee",
-        iconResId = R.drawable.ic_key_outline
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/MessageStateIndicator.kt b/app/src/main/java/ch/threema/app/compose/message/MessageStateIndicator.kt
deleted file mode 100644
index a405856f..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/MessageStateIndicator.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import androidx.annotation.DrawableRes
-import androidx.annotation.StringRes
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.graphics.Color
-import ch.threema.app.activities.AckUiModel
-import ch.threema.app.activities.ContactAckUiModel
-import ch.threema.app.activities.GroupAckUiModel
-
-@Composable
-fun MessageStateIndicator(
-    ackUiModel: AckUiModel? = null,
-    @DrawableRes deliveryIconRes: Int? = null,
-    @StringRes deliveryIconContentDescriptionRes: Int? = null,
-    deliveryIndicatorTintColor: Color? = null
-) {
-    when (ackUiModel) {
-        is ContactAckUiModel -> {
-            ContactAckDecIndicator(ackUiModel.ackDecState)
-        }
-        is GroupAckUiModel -> {
-            GroupAckDecIndicator(ackUiModel.ackState, ackUiModel.decState)
-        }
-
-        null -> {
-            if (deliveryIconRes != null && deliveryIconContentDescriptionRes != null) {
-                DeliveryIndicator(
-                    deliveryIconRes = deliveryIconRes,
-                    deliveryIconContentDescriptionRes = deliveryIconContentDescriptionRes,
-                    tintColor = deliveryIndicatorTintColor
-                )
-            }
-        }
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/compose/message/MessageTimestamps.kt b/app/src/main/java/ch/threema/app/compose/message/MessageTimestamps.kt
deleted file mode 100644
index a41edda0..00000000
--- a/app/src/main/java/ch/threema/app/compose/message/MessageTimestamps.kt
+++ /dev/null
@@ -1,215 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.message
-
-import androidx.annotation.DrawableRes
-import androidx.compose.foundation.background
-import androidx.compose.foundation.border
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.shape.RoundedCornerShape
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.res.stringResource
-import androidx.compose.ui.semantics.contentDescription
-import androidx.compose.ui.semantics.isTraversalGroup
-import androidx.compose.ui.semantics.semantics
-import androidx.compose.ui.tooling.preview.Preview
-import androidx.compose.ui.unit.dp
-import ch.threema.app.R
-import ch.threema.app.activities.MessageTimestampsUiModel
-import ch.threema.app.compose.theme.customColorScheme
-import ch.threema.app.utils.LocaleUtil
-import ch.threema.app.utils.capitalize
-import java.util.Date
-import kotlin.time.Duration.Companion.minutes
-
-@Composable
-fun MessageTimestampsListBox(
-    modifier: Modifier = Modifier,
-    messageTimestampsUiModel: MessageTimestampsUiModel,
-    isOutbox: Boolean
-) {
-    val borderColor = if (isOutbox) {
-        MaterialTheme.colorScheme.secondaryContainer
-    } else {
-        MaterialTheme.customColorScheme.messageBubbleContainerReceive
-    }
-    MessageTimestampsList(
-        modifier = modifier
-            .border(width = 2.dp, color = borderColor, shape = RoundedCornerShape(8.dp))
-            .padding(16.dp)
-            .then(
-                stringResource(R.string.cd_message_details_container).let { contentDescription ->
-                    Modifier.semantics {
-                        this.contentDescription = contentDescription
-                        isTraversalGroup = true
-                    }
-                }
-            ),
-        model = messageTimestampsUiModel,
-        displayIcons = true
-    )
-}
-
-@Composable
-fun MessageTimestampsList(
-    modifier: Modifier = Modifier,
-    model: MessageTimestampsUiModel,
-    displayIcons: Boolean = false
-) {
-    Column(
-        modifier = modifier,
-        verticalArrangement = Arrangement.spacedBy(4.dp),
-    ) {
-        model.createdAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_dialog_created),
-                timestamp = model.createdAt,
-                iconResId = if (displayIcons) R.drawable.ic_pencil_outline else null
-            )
-        }
-        model.sentAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_dialog_posted),
-                timestamp = model.sentAt,
-                iconResId = if (displayIcons) R.drawable.ic_mail_filled else null
-            )
-        }
-        model.receivedAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_dialog_received),
-                timestamp = model.receivedAt,
-                iconResId = if (displayIcons) R.drawable.ic_inbox_filled else null
-            )
-        }
-        model.deliveredAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_delivered).capitalize(),
-                timestamp = model.deliveredAt,
-                iconResId = if (displayIcons) R.drawable.ic_inbox_filled else null
-            )
-        }
-        model.readAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_read).capitalize(),
-                timestamp = model.readAt,
-                iconResId = if (displayIcons) R.drawable.ic_mark_read else null
-            )
-        }
-        model.modifiedAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_dialog_modified),
-                timestamp = model.modifiedAt,
-                iconResId = if (displayIcons) R.drawable.ic_edit_file_name else null
-            )
-        }
-        model.editedAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_dialog_edited),
-                timestamp = model.editedAt,
-                iconResId = if (displayIcons) R.drawable.ic_edit_file_name else null
-            )
-        }
-        model.deletedAt?.let {
-            MessageTimestampsRow(
-                label = stringResource(R.string.state_dialog_deleted),
-                timestamp = model.deletedAt,
-                iconResId = if (displayIcons) R.drawable.ic_delete_outline else null
-            )
-        }
-    }
-}
-
-@Composable
-private fun MessageTimestampsRow(
-    label: String,
-    timestamp: Date,
-    @DrawableRes iconResId: Int?
-) {
-    MessageDetailsRow(
-        label = label,
-        value = LocaleUtil.formatTimeStampStringAbsolute(LocalContext.current, timestamp.time),
-        iconResId = iconResId
-    )
-}
-
-@Preview(name = "Outbox", group = "box")
-@Composable
-private fun MessageTimestampsListBoxPreview_Outbox() {
-    MessageTimestampsListBox(
-        modifier = Modifier.padding(16.dp),
-        messageTimestampsUiModel = MessageTimestampsUiModel(
-            createdAt = Date(),
-            sentAt = Date(),
-            receivedAt = Date().apply { time += 1.minutes.inWholeMilliseconds },
-            deliveredAt = Date().apply { time += 1.minutes.inWholeMilliseconds },
-            readAt = Date().apply { time += 10.minutes.inWholeMilliseconds },
-            modifiedAt = Date().apply { time += 10.minutes.inWholeMilliseconds },
-            editedAt = Date().apply { time += 5.minutes.inWholeMilliseconds },
-            deletedAt = Date().apply { time += 15.minutes.inWholeMilliseconds }
-        ),
-        isOutbox = true
-    )
-}
-
-
-@Preview(name = "Inbox", group = "box")
-@Composable
-private fun MessageTimestampsListBoxPreview_Inbox() {
-    MessageTimestampsListBox(
-        modifier = Modifier.padding(16.dp),
-        messageTimestampsUiModel = MessageTimestampsUiModel(
-            createdAt = Date(),
-            sentAt = Date(),
-            deliveredAt = Date().apply { time += 1.minutes.inWholeMilliseconds },
-            readAt = Date().apply { time += 10.minutes.inWholeMilliseconds },
-            modifiedAt = Date().apply { time += 10.minutes.inWholeMilliseconds },
-            editedAt = Date().apply { time += 5.minutes.inWholeMilliseconds },
-            deletedAt = Date().apply { time += 15.minutes.inWholeMilliseconds }
-        ),
-        isOutbox = false
-    )
-}
-
-@Preview
-@Composable
-private fun MessageTimestampsListPreview() {
-    MessageTimestampsList(
-        modifier = Modifier
-            .background(MaterialTheme.colorScheme.background)
-            .padding(16.dp),
-        model = MessageTimestampsUiModel(
-            createdAt = Date(),
-            sentAt = Date(),
-            deliveredAt = Date().apply { time += 1.minutes.inWholeMilliseconds },
-            readAt = Date().apply { time += 10.minutes.inWholeMilliseconds },
-            modifiedAt = Date().apply { time += 10.minutes.inWholeMilliseconds },
-            editedAt = Date().apply { time += 5.minutes.inWholeMilliseconds },
-            deletedAt = Date().apply { time += 15.minutes.inWholeMilliseconds }
-        )
-    )
-}
-
diff --git a/app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt b/app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt
deleted file mode 100644
index 14bd0c1c..00000000
--- a/app/src/main/java/ch/threema/app/compose/theme/ThreemaTheme.kt
+++ /dev/null
@@ -1,91 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme
-
-import android.app.Activity
-import android.os.Build
-import androidx.compose.foundation.isSystemInDarkTheme
-import androidx.compose.material3.ColorScheme
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.Typography
-import androidx.compose.material3.dynamicDarkColorScheme
-import androidx.compose.material3.dynamicLightColorScheme
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.CompositionLocalProvider
-import androidx.compose.runtime.ReadOnlyComposable
-import androidx.compose.runtime.SideEffect
-import androidx.compose.ui.graphics.toArgb
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.platform.LocalView
-import androidx.core.view.WindowCompat
-import ch.threema.app.compose.theme.color.ColorsDark
-import ch.threema.app.compose.theme.color.ColorsLight
-import ch.threema.app.compose.theme.color.CustomColor
-import ch.threema.app.compose.theme.color.CustomColorDark
-import ch.threema.app.compose.theme.color.CustomColorLight
-import ch.threema.app.compose.theme.color.LocalCustomColor
-
-val AppTypography = Typography() // system default
-
-/**
- *  @param dynamicColor available on Android 12+
- */
-@Composable
-fun ThreemaTheme(
-    isDarkTheme: Boolean = isSystemInDarkTheme(),
-    dynamicColor: Boolean = true,
-    content: @Composable () -> Unit
-) {
-    val materialColorScheme: ColorScheme = when {
-        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
-            val context = LocalContext.current
-            if (isDarkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
-        }
-        else -> if (isDarkTheme) ColorsDark.toColorScheme() else ColorsLight.toColorScheme()
-    }
-    val view = LocalView.current
-    if (!view.isInEditMode) {
-        SideEffect {
-            val window = (view.context as Activity).window
-            window.statusBarColor = materialColorScheme.background.toArgb()
-            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars =
-                !isDarkTheme
-        }
-    }
-
-    val customColorScheme = if (isDarkTheme) CustomColorDark else CustomColorLight
-    CompositionLocalProvider(
-        LocalCustomColor provides customColorScheme
-    ) {
-        MaterialTheme(
-            colorScheme = materialColorScheme,
-            typography = AppTypography,
-            content = content
-        )
-    }
-}
-
-@Suppress("UnusedReceiverParameter")
-val MaterialTheme.customColorScheme: CustomColor
-    @Composable
-    @ReadOnlyComposable
-    get() = LocalCustomColor.current
diff --git a/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPalette.kt b/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPalette.kt
deleted file mode 100644
index f0c19a57..00000000
--- a/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPalette.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.material3.ColorScheme
-import androidx.compose.ui.graphics.Color
-
-interface ComposeColorPalette {
-    val primary: Color
-    val onPrimary: Color
-    val primaryContainer: Color
-    val onPrimaryContainer: Color
-    val secondary: Color
-    val onSecondary: Color
-    val secondaryContainer: Color
-    val onSecondaryContainer: Color
-    val tertiary: Color
-    val onTertiary: Color
-    val tertiaryContainer: Color
-    val onTertiaryContainer: Color
-    val error: Color
-    val onError: Color
-    val errorContainer: Color
-    val onErrorContainer: Color
-    val background: Color
-    val onBackground: Color
-    val surface: Color
-    val onSurface: Color
-    val surfaceVariant: Color
-    val onSurfaceVariant: Color
-    val outline: Color
-    val outlineVariant: Color
-    val scrim: Color
-    val inverseSurface: Color
-    val inverseOnSurface: Color
-    val inversePrimary: Color
-
-    fun toColorScheme(): ColorScheme
-}
diff --git a/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteDark.kt b/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteDark.kt
deleted file mode 100644
index 40241aab..00000000
--- a/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteDark.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.material3.darkColorScheme
-
-abstract class ComposeColorPaletteDark : ComposeColorPalette {
-
-    override fun toColorScheme() = darkColorScheme(
-        primary = primary,
-        onPrimary = onPrimary,
-        primaryContainer = primaryContainer,
-        onPrimaryContainer = onPrimaryContainer,
-        secondary = secondary,
-        onSecondary = onSecondary,
-        secondaryContainer = secondaryContainer,
-        onSecondaryContainer = onSecondaryContainer,
-        tertiary = tertiary,
-        onTertiary = onTertiary,
-        tertiaryContainer = tertiaryContainer,
-        onTertiaryContainer = onTertiaryContainer,
-        error = error,
-        onError = onError,
-        errorContainer = errorContainer,
-        onErrorContainer = onErrorContainer,
-        background = background,
-        onBackground = onBackground,
-        surface = surface,
-        onSurface = onSurface,
-        surfaceVariant = surfaceVariant,
-        onSurfaceVariant = onSurfaceVariant,
-        outline = outline,
-        outlineVariant = outlineVariant,
-        scrim = scrim,
-        inverseSurface = inverseSurface,
-        inverseOnSurface = inverseOnSurface,
-        inversePrimary = inversePrimary,
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteLight.kt b/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteLight.kt
deleted file mode 100644
index 811bd346..00000000
--- a/app/src/main/java/ch/threema/app/compose/theme/color/ComposeColorPaletteLight.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.material3.lightColorScheme
-
-abstract class ComposeColorPaletteLight : ComposeColorPalette {
-
-    override fun toColorScheme() = lightColorScheme(
-        primary = primary,
-        onPrimary = onPrimary,
-        primaryContainer = primaryContainer,
-        onPrimaryContainer = onPrimaryContainer,
-        secondary = secondary,
-        onSecondary = onSecondary,
-        secondaryContainer = secondaryContainer,
-        onSecondaryContainer = onSecondaryContainer,
-        tertiary = tertiary,
-        onTertiary = onTertiary,
-        tertiaryContainer = tertiaryContainer,
-        onTertiaryContainer = onTertiaryContainer,
-        error = error,
-        onError = onError,
-        errorContainer = errorContainer,
-        onErrorContainer = onErrorContainer,
-        background = background,
-        onBackground = onBackground,
-        surface = surface,
-        onSurface = onSurface,
-        surfaceVariant = surfaceVariant,
-        onSurfaceVariant = onSurfaceVariant,
-        outline = outline,
-        outlineVariant = outlineVariant,
-        scrim = scrim,
-        inverseSurface = inverseSurface,
-        inverseOnSurface = inverseOnSurface,
-        inversePrimary = inversePrimary,
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/compose/theme/color/CustomColor.kt b/app/src/main/java/ch/threema/app/compose/theme/color/CustomColor.kt
deleted file mode 100644
index b88dd2de..00000000
--- a/app/src/main/java/ch/threema/app/compose/theme/color/CustomColor.kt
+++ /dev/null
@@ -1,35 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.runtime.Immutable
-import androidx.compose.runtime.staticCompositionLocalOf
-import androidx.compose.ui.graphics.Color
-
-@Immutable
-data class CustomColor(
-    val ackTint: Color = Color(0xFF4caf50),
-    val decTint: Color = Color(0xFFff9800),
-    val messageBubbleContainerReceive: Color = Color.Red,
-)
-
-val LocalCustomColor = staticCompositionLocalOf { CustomColor() }
diff --git a/app/src/main/java/ch/threema/app/connection/CspD2mDualConnectionSupplier.kt b/app/src/main/java/ch/threema/app/connection/CspD2mDualConnectionSupplier.kt
deleted file mode 100644
index c80befb3..00000000
--- a/app/src/main/java/ch/threema/app/connection/CspD2mDualConnectionSupplier.kt
+++ /dev/null
@@ -1,127 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.connection
-
-import ch.threema.app.multidevice.MultiDeviceManager
-import ch.threema.app.services.ServerAddressProviderService
-import ch.threema.base.utils.AsyncResolver
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.BaseServerConnectionConfiguration
-import ch.threema.domain.protocol.connection.BaseServerConnectionProvider
-import ch.threema.domain.protocol.connection.ServerConnection
-import ch.threema.domain.protocol.connection.ServerConnectionException
-import ch.threema.domain.protocol.connection.csp.CspConnectionConfiguration
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-import ch.threema.domain.protocol.connection.csp.socket.ProxyAwareSocketFactory
-import ch.threema.domain.protocol.connection.d2m.D2mConnectionConfiguration
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.TaskManager
-import java8.util.function.Supplier
-import okhttp3.OkHttpClient
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("CspD2mDualConnectionSupplier")
-
-/**
- * A connection [Supplier] that creates a new connection if the multi device activation state has
- * changed (CspConnection vs. D2mConnection). If the activation state has not changed since the last
- * call to [get], the same connection instance as in the previous call is returned.
- *
- * @param isTestBuild Set to `true` in test builds to run validations and checks during use to help find
- *                    problems. Failed checks will throw runtime exceptions.
- */
-class CspD2mDualConnectionSupplier (
-    private val multiDeviceManager: MultiDeviceManager,
-    private val incomingMessageProcessor: IncomingMessageProcessor,
-    private val taskManager: TaskManager,
-    private val deviceCookieManager: DeviceCookieManager,
-    private val serverAddressProviderService: ServerAddressProviderService,
-    private val identityStore: IdentityStoreInterface,
-    private val version: Version,
-    private val isIpv6Preferred: Boolean,
-    private val okHttpClientSupplier: Supplier<OkHttpClient>,
-    private val isTestBuild: Boolean
-) : Supplier<ServerConnection> {
-    private val cspConnectionConfiguration by lazy { createCspConnectionConfiguration() }
-    private val d2mConnectionConfiguration by lazy { createD2mConnectionConfiguration() }
-
-    private lateinit var latestConfiguration: BaseServerConnectionConfiguration
-    private lateinit var latestConnection: ServerConnection
-
-    override fun get(): ServerConnection {
-        return synchronized(this) {
-            val configuration = if (multiDeviceManager.isMultiDeviceActive) {
-                d2mConnectionConfiguration
-            } else {
-                cspConnectionConfiguration
-            }
-            if (!this::latestConfiguration.isInitialized || configuration != latestConfiguration) {
-                logger.info("Create new connection")
-                val connection = BaseServerConnectionProvider.createConnection(configuration)
-                if (isTestBuild
-                    && this::latestConnection.isInitialized
-                    && connection::class == latestConnection::class) {
-                    throw ServerConnectionException("Unexpected new connection of same type")
-                }
-                connection.also {
-                    latestConnection = it
-                    latestConfiguration = configuration
-                }
-            } else {
-                latestConnection
-            }
-        }
-    }
-
-    private fun createCspConnectionConfiguration(): CspConnectionConfiguration {
-        logger.info("Create csp connection configuration")
-        return CspConnectionConfiguration(
-            identityStore,
-            serverAddressProviderService.serverAddressProvider,
-            version,
-            isTestBuild,
-            deviceCookieManager,
-            incomingMessageProcessor,
-            taskManager,
-            AsyncResolver::getAllByName,
-            isIpv6Preferred,
-            ProxyAwareSocketFactory::makeSocket
-        )
-    }
-
-    private fun createD2mConnectionConfiguration(): D2mConnectionConfiguration {
-        logger.info("Create d2m connection configuration")
-        return D2mConnectionConfiguration(
-            identityStore,
-            serverAddressProviderService.serverAddressProvider,
-            version,
-            isTestBuild,
-            deviceCookieManager,
-            incomingMessageProcessor,
-            taskManager,
-            multiDeviceManager.propertiesProvider,
-            multiDeviceManager.socketCloseListener,
-            okHttpClientSupplier.get()
-        )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java b/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java
index 9a901612..e5c65edb 100644
--- a/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java
+++ b/app/src/main/java/ch/threema/app/dialogs/CancelableHorizontalProgressDialog.java
@@ -57,7 +57,7 @@ public class CancelableHorizontalProgressDialog extends ThreemaDialogFragment {
 	 * @param title title of dialog
 	 * @param button label of cancel button
 	 * @param total maximum allowed progress value.
-	 * @return nothing
+	 * @return the dialog
 	 */
 	public static CancelableHorizontalProgressDialog newInstance(@StringRes int title, @StringRes int button, int total) {
 		CancelableHorizontalProgressDialog dialog = new CancelableHorizontalProgressDialog();
@@ -70,12 +70,31 @@ public class CancelableHorizontalProgressDialog extends ThreemaDialogFragment {
 		return dialog;
 	}
 
+	/**
+	 * Creates a DialogFragment with a horizontal progress bar and a percentage display below.
+	 * Mimics deprecated system ProgressDialog behavior.
+	 * Note that when using this constructor, no cancel button is shown.
+	 *
+	 * @param title title of dialog
+	 * @param total maximum allowed progress value.
+	 * @return the dialog
+	 */
+	public static CancelableHorizontalProgressDialog newInstance(@StringRes int title, int total) {
+		CancelableHorizontalProgressDialog dialog = new CancelableHorizontalProgressDialog();
+		Bundle args = new Bundle();
+		args.putInt("title", title);
+		args.putInt("total", total);
+
+		dialog.setArguments(args);
+		return dialog;
+	}
+
 	/**
 	 * Creates a DialogFragment with a horizontal progress bar and a percentage display below. Mimics deprecated system ProgressDialog behavior
 	 * @param title title of dialog
 	 * @param button label of cancel button
 	 * @param total maximum allowed progress value.
-	 * @return nothing
+	 * @return the dialog
 	 */
 	public static CancelableHorizontalProgressDialog newInstance(@NonNull String title, @NonNull String button, int total) {
 		CancelableHorizontalProgressDialog dialog = new CancelableHorizontalProgressDialog();
diff --git a/app/src/main/java/ch/threema/app/dialogs/ResendGroupMessageDialog.kt b/app/src/main/java/ch/threema/app/dialogs/ResendGroupMessageDialog.kt
deleted file mode 100644
index 4f63b634..00000000
--- a/app/src/main/java/ch/threema/app/dialogs/ResendGroupMessageDialog.kt
+++ /dev/null
@@ -1,68 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.dialogs
-
-import android.app.Dialog
-import android.os.Bundle
-import ch.threema.app.R
-import ch.threema.app.services.ContactService
-import ch.threema.app.utils.ContactUtil
-import com.google.android.material.dialog.MaterialAlertDialogBuilder
-
-class ResendGroupMessageDialog(
-    private val rejectedIdentities: Set<String>,
-    private val contactService: ContactService,
-    private val callback: ResendMessageCallback,
-) : ThreemaDialogFragment() {
-
-    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
-        val concatenatedContactNames = ContactUtil.joinDisplayNames(context, contactService.getByIdentities(rejectedIdentities.toList()))
-        val builder = MaterialAlertDialogBuilder(requireActivity())
-        builder.setTitle(getString(R.string.resend_message_dialog_title))
-        builder.setMessage(getString(R.string.resend_message_dialog_message, concatenatedContactNames))
-        builder.setPositiveButton(getString(R.string.ok)) { _, _ ->
-            callback.onPositiveClicked()
-        }
-        builder.setNegativeButton(getString(R.string.cancel)) { _, _ -> }
-
-        return builder.create()
-    }
-
-    companion object {
-        fun getInstance(
-            rejectedIdentities: Set<String>,
-            contactService: ContactService,
-            resendMessageCallback: ResendMessageCallback,
-        ): ResendGroupMessageDialog {
-            return ResendGroupMessageDialog(
-                rejectedIdentities,
-                contactService,
-                resendMessageCallback
-            )
-        }
-    }
-
-    interface ResendMessageCallback {
-        fun onPositiveClicked()
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java b/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java
index 6aa21290..d0b90c8a 100644
--- a/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/ComposeMessageFragment.java
@@ -762,17 +762,17 @@ public class ComposeMessageFragment extends Fragment implements
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			updateToolBarTitleInUIThread();
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String identity) {
 			updateToolBarTitleInUIThread();
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String identity) {
 			updateToolBarTitleInUIThread();
 
 			if (userService.isMe(identity)) {
@@ -821,7 +821,7 @@ public class ComposeMessageFragment extends Fragment implements
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
 			updateToolBarTitleInUIThread();
 		}
 
@@ -3112,7 +3112,7 @@ public class ComposeMessageFragment extends Fragment implements
 								// If there is no rejected recipient, we can just update the message
 								// state as the rejected recipient is not longer a group member.
 								// Note that this should never happen.
-								messageService.updateMessageState(messageModel, MessageState.SENT, null);
+								messageService.updateOutgoingMessageState(messageModel, MessageState.SENT, new Date());
 								logger.warn("Resend for group members requested, although no member rejected it");
 								return;
 							}
@@ -4086,13 +4086,16 @@ public class ComposeMessageFragment extends Fragment implements
 			setAvatarContentDescription(R.string.distribution_list);
 		} else {
 			if (contactModel != null) {
-				this.actionBarSubtitleImageView.setContactModel(contactModel);
+				this.actionBarSubtitleImageView.setVerificationLevel(
+					contactModel.verificationLevel,
+					contactModel.getWorkVerificationLevel()
+				);
 				this.actionBarSubtitleImageView.setVisibility(View.VISIBLE);
 				if (actionBarAvatarView.getAvatarView().isAttachedToWindow()) {
 					contactService.loadAvatarIntoImage(
 						contactModel,
 						this.actionBarAvatarView.getAvatarView(),
-						AvatarOptions.PRESET_RESPECT_SETTINGS,
+						AvatarOptions.PRESET_DEFAULT_FALLBACK,
 						Glide.with(requireActivity())
 					);
 				}
@@ -5594,7 +5597,7 @@ public class ComposeMessageFragment extends Fragment implements
 	@Override
 	public void onReportSpamClicked(@NonNull final ContactModel spammerContactModel, boolean block) {
 		contactService.reportSpam(
-			spammerContactModel,
+			spammerContactModel.getIdentity(),
 			unused -> {
 				if (isAdded()) {
 					LongToast.makeText(getContext(), R.string.spam_successfully_reported, Toast.LENGTH_LONG).show();
diff --git a/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java b/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java
index 8c9f39c7..fd0cd71d 100644
--- a/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/ContactsSectionFragment.java
@@ -24,7 +24,8 @@ package ch.threema.app.fragments;
 import static android.view.MenuItem.SHOW_AS_ACTION_ALWAYS;
 import static android.view.MenuItem.SHOW_AS_ACTION_COLLAPSE_ACTION_VIEW;
 import static android.view.MenuItem.SHOW_AS_ACTION_NEVER;
-import static ch.threema.app.ThreemaApplication.WORKER_WORK_SYNC;
+import static ch.threema.app.asynctasks.ContactSyncPolicy.EXCLUDE;
+import static ch.threema.app.asynctasks.ContactSyncPolicy.INCLUDE;
 
 import android.Manifest;
 import android.annotation.SuppressLint;
@@ -61,9 +62,6 @@ import androidx.core.util.Pair;
 import androidx.core.view.MenuItemCompat;
 import androidx.localbroadcastmanager.content.LocalBroadcastManager;
 import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;
-import androidx.work.ExistingWorkPolicy;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.WorkManager;
 
 import com.bumptech.glide.Glide;
 import com.google.android.material.button.MaterialButton;
@@ -72,12 +70,13 @@ import com.google.android.material.tabs.TabLayout;
 
 import org.slf4j.Logger;
 
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
@@ -86,7 +85,10 @@ import ch.threema.app.activities.ComposeMessageActivity;
 import ch.threema.app.activities.ContactDetailActivity;
 import ch.threema.app.activities.ThreemaActivity;
 import ch.threema.app.adapters.ContactListAdapter;
-import ch.threema.app.asynctasks.DeleteContactAsyncTask;
+import ch.threema.app.asynctasks.AndroidContactLinkPolicy;
+import ch.threema.app.asynctasks.ContactSyncPolicy;
+import ch.threema.app.asynctasks.DeleteContactServices;
+import ch.threema.app.asynctasks.DialogMarkContactAsDeletedBackgroundTask;
 import ch.threema.app.asynctasks.EmptyOrDeleteConversationsAsyncTask;
 import ch.threema.app.dialogs.BottomSheetAbstractDialog;
 import ch.threema.app.dialogs.BottomSheetGridDialog;
@@ -107,7 +109,6 @@ import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.routines.SynchronizeContactsRoutine;
 import ch.threema.app.services.AvatarCacheService;
 import ch.threema.app.services.ContactService;
-import ch.threema.app.services.IdListService;
 import ch.threema.app.services.LockAppService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SynchronizeContactsService;
@@ -126,10 +127,12 @@ import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShareUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.workers.ContactUpdateWorker;
 import ch.threema.app.workers.WorkSyncWorker;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.models.ContactModel;
@@ -192,6 +195,8 @@ public class ContactsSectionFragment
 	private PreferenceService preferenceService;
 	private LockAppService lockAppService;
 
+	private final BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
+
 	private String filterQuery;
 	@SuppressLint("StaticFieldLeak")
 	private final TabLayout.OnTabSelectedListener onTabSelectedListener = new TabLayout.OnTabSelectedListener() {
@@ -258,11 +263,8 @@ public class ContactsSectionFragment
 		}
 	}
 
-	private final ResumePauseHandler.RunIfActive runIfActiveShowLoading = new ResumePauseHandler.RunIfActive() {
-		@Override
-		public void runOnUiThread() {
-			// do nothing
-		}
+	private final ResumePauseHandler.RunIfActive runIfActiveShowLoading = () -> {
+		// do nothing
 	};
 
 	private final ResumePauseHandler.RunIfActive runIfActiveClearCacheAndRefresh = new ResumePauseHandler.RunIfActive() {
@@ -275,10 +277,8 @@ public class ContactsSectionFragment
 				if (serviceManager != null) {
 					try {
 						AvatarCacheService avatarCacheService = serviceManager.getAvatarCacheService();
-						if (avatarCacheService != null) {
-							//clear the cache
-							avatarCacheService.clear();
-						}
+						//clear the cache
+						avatarCacheService.clear();
 					} catch (FileSystemNotPresentException e) {
 						logger.error("Exception", e);
 					}
@@ -306,12 +306,7 @@ public class ContactsSectionFragment
 		}
 	};
 
-	private final ResumePauseHandler.RunIfActive runIfActiveCreateList = new ResumePauseHandler.RunIfActive() {
-		@Override
-		public void runOnUiThread() {
-			createListAdapter(null);
-		}
-	};
+	private final ResumePauseHandler.RunIfActive runIfActiveCreateList = () -> createListAdapter(null);
 
 	private final SynchronizeContactsListener synchronizeContactsListener = new SynchronizeContactsListener() {
 		@Override
@@ -381,8 +376,8 @@ public class ContactsSectionFragment
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			this.onModified(contactModel.getIdentity());
+		public void onAvatarChanged(final @NonNull String identity) {
+			this.onModified(identity);
 		}
 
 		@Override
@@ -513,9 +508,7 @@ public class ContactsSectionFragment
 
 		this.resumePauseHandler = ResumePauseHandler.getByActivity(this, this.getActivity());
 
-		if (this.resumePauseHandler != null) {
-			this.resumePauseHandler.runOnActive(RUN_ON_ACTIVE_REFRESH_PULL_TO_REFRESH, runIfActiveUpdatePullToRefresh);
-		}
+		this.resumePauseHandler.runOnActive(RUN_ON_ACTIVE_REFRESH_PULL_TO_REFRESH, runIfActiveUpdatePullToRefresh);
 	}
 
 	@Override
@@ -573,7 +566,7 @@ public class ContactsSectionFragment
 	}
 
 	@Override
-	public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+	public void onCreateOptionsMenu(Menu menu, @NonNull MenuInflater inflater) {
 		logger.debug("onCreateOptionsMenu");
 		searchMenuItem = menu.findItem(R.id.menu_search_contacts);
 
@@ -588,12 +581,9 @@ public class ContactsSectionFragment
 					if (!TestUtil.isEmptyOrNull(filterQuery)) {
 						// restore filter
 						MenuItemCompat.expandActionView(searchMenuItem);
-						this.searchView.post(new Runnable() {
-							@Override
-							public void run() {
-								searchView.setQuery(filterQuery, true);
-								searchView.clearFocus();
-							}
+						this.searchView.post(() -> {
+							searchView.setQuery(filterQuery, true);
+							searchView.clearFocus();
 						});
 					}
 					this.searchView.setQueryHint(getString(R.string.hint_filter_list));
@@ -607,7 +597,7 @@ public class ContactsSectionFragment
 	final SearchView.OnQueryTextListener queryTextListener = new SearchView.OnQueryTextListener() {
 		@Override
 		public boolean onQueryTextChange(String query) {
-			if (contactListAdapter != null && contactListAdapter.getFilter() != null) {
+			if (contactListAdapter != null) {
 				filterQuery = query;
 				contactListAdapter.getFilter().filter(query);
 			}
@@ -812,7 +802,7 @@ public class ContactsSectionFragment
 	}
 
 	@Override
-	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+	public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 		View headerView, fragmentView = getView();
 
 		logger.debug("onCreateView");
@@ -893,12 +883,7 @@ public class ContactsSectionFragment
 				this.contactsCounterButton = footerView.findViewById(R.id.contact_counter_text);
 				listView.addFooterView(footerView, null, false);
 
-				headerView.findViewById(R.id.share_container).setOnClickListener(new View.OnClickListener() {
-					@Override
-					public void onClick(View v) {
-						shareInvite();
-					}
-				});
+				headerView.findViewById(R.id.share_container).setOnClickListener(v -> shareInvite());
 			} else {
 				workTabLayout = fragmentView.findViewById(R.id.work_contacts_tab_layout);
 				workTabLayout.addOnTabSelectedListener(onTabSelectedListener);
@@ -912,12 +897,7 @@ public class ContactsSectionFragment
 			this.swipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);
 
 			this.floatingButtonView = fragmentView.findViewById(R.id.floating);
-			this.floatingButtonView.setOnClickListener(new View.OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					onFABClicked(v);
-				}
-			});
+			this.floatingButtonView.setOnClickListener(this::onFABClicked);
 		}
 		return fragmentView;
 	}
@@ -1064,6 +1044,10 @@ public class ContactsSectionFragment
 
 		new Handler(Looper.getMainLooper()).postDelayed(this::stopSwipeRefresh, 2000);
 
+		try {
+			ContactUpdateWorker.performOneTimeSync(requireContext());
+		} catch (IllegalStateException ignored) {}
+
 		if (this.preferenceService.isSyncContacts() && ConfigUtils.requestContactPermissions(getActivity(), this, PERMISSION_REQUEST_REFRESH_CONTACTS)) {
 			if (this.synchronizeContactsService != null) {
 				// we force a contact sync even if the grace time has not yet been reached
@@ -1074,16 +1058,16 @@ public class ContactsSectionFragment
 
 		if (ConfigUtils.isWorkBuild()) {
 			try {
-				OneTimeWorkRequest workRequest = WorkSyncWorker.Companion.buildOneTimeWorkRequest(false, true, "WorkContactSync");
-				WorkManager.getInstance(ThreemaApplication.getAppContext()).enqueueUniqueWork(WORKER_WORK_SYNC, ExistingWorkPolicy.REPLACE, workRequest);
+				WorkSyncWorker.Companion.performOneTimeWorkSync(
+					ThreemaApplication.getAppContext(),
+					false,
+					true,
+					"WorkContactSync"
+				);
 			} catch (IllegalStateException e) {
 				logger.error("Unable to schedule work sync one time work", e);
 			}
 		}
-		try {
-			OneTimeWorkRequest contactUpdateRequest = new OneTimeWorkRequest.Builder(ContactUpdateWorker.class).build();
-			WorkManager.getInstance(requireContext()).enqueue(contactUpdateRequest);
-		} catch (IllegalStateException ignored) {}
 	}
 
 	private void openConversationForIdentity(@Nullable View v, String identity) {
@@ -1189,7 +1173,7 @@ public class ContactsSectionFragment
 					contactModel.verificationLevel == VerificationLevel.UNVERIFIED
 				) {
 					MessageReceiver messageReceiver = contactService.createReceiver(contactModel);
-					if (messageReceiver != null && messageReceiver.getMessagesCount() > 0) {
+					if (messageReceiver.getMessagesCount() > 0) {
 						items.add(new SelectorDialogItem(getString(R.string.spam_report), R.drawable.ic_outline_report_24));
 						tags.add(SELECTOR_TAG_REPORT_SPAM);
 					}
@@ -1285,43 +1269,57 @@ public class ContactsSectionFragment
 		dialog.show(getFragmentManager(), DIALOG_TAG_REALLY_DELETE_CONTACTS);
 	}
 
-	@SuppressLint("StaticFieldLeak")
-	private void reallyDeleteContacts(@NonNull Set<ContactModel> contactModels, boolean excludeFromSync) {
-		new DeleteContactAsyncTask(getParentFragmentManager(), contactModels, contactService, new DeleteContactAsyncTask.DeleteContactsPostRunnable() {
-			@Override
-			public void run() {
-				if (isAdded()) {
-					if (failed > 0) {
-						Toast.makeText(getActivity(), ConfigUtils.getSafeQuantityString(ThreemaApplication.getAppContext(), R.plurals.some_contacts_not_deleted, failed, failed), Toast.LENGTH_LONG).show();
-					} else {
-						if (contactModels.size() > 1) {
-							Toast.makeText(getActivity(), R.string.contacts_deleted, Toast.LENGTH_LONG).show();
-						} else {
-							Toast.makeText(getActivity(), R.string.contact_deleted, Toast.LENGTH_LONG).show();
-						}
+	private void reallyDeleteContacts(@NonNull Set<ContactModel> contactModels, boolean excludeFromSync) throws ThreemaException {
+		Set<String> identities = contactModels.stream()
+			.map(Contact::getIdentity)
+			.collect(Collectors.toSet());
 
-						if (excludeFromSync) {
-							excludeContactsFromSync(contactModels);
-						}
-					}
-				}
+		ContactSyncPolicy syncPolicy = excludeFromSync ? EXCLUDE : INCLUDE;
 
-				if (actionMode != null) {
-					actionMode.finish();
-				}
-			}
-		}).execute();
+		DialogMarkContactAsDeletedBackgroundTask task = getDialogDeleteContactBackgroundTask(
+			identities, syncPolicy
+		);
+
+		backgroundExecutor.execute(task);
 	}
 
-	private void excludeContactsFromSync(@NonNull Collection<ContactModel> contactModels) {
-		IdListService excludedService = serviceManager.getExcludedSyncIdentitiesService();
-		if (excludedService != null) {
-			for (ContactModel contactModel : contactModels) {
-				if (contactModel.isLinkedToAndroidContact()) {
-					excludedService.add(contactModel.getIdentity());
+	@NonNull
+	private DialogMarkContactAsDeletedBackgroundTask getDialogDeleteContactBackgroundTask(
+		@NonNull Set<String> identities,
+		@NonNull ContactSyncPolicy syncPolicy
+	) throws ThreemaException {
+		DeleteContactServices deleteServices = new DeleteContactServices(
+			serviceManager.getUserService(),
+			contactService,
+			serviceManager.getConversationService(),
+			serviceManager.getRingtoneService(),
+			serviceManager.getMutedChatsListService(),
+			serviceManager.getHiddenChatsListService(),
+			serviceManager.getProfilePicRecipientsService(),
+			serviceManager.getWallpaperService(),
+			serviceManager.getFileService(),
+			serviceManager.getExcludedSyncIdentitiesService(),
+			serviceManager.getDHSessionStore(),
+			serviceManager.getNotificationService(),
+			serviceManager.getDatabaseServiceNew()
+		);
+
+		return new DialogMarkContactAsDeletedBackgroundTask(
+			getParentFragmentManager(),
+			new WeakReference<>(getContext()),
+			identities,
+			serviceManager.getModelRepositories().getContacts(),
+			deleteServices,
+			syncPolicy,
+			AndroidContactLinkPolicy.REMOVE_LINK
+		) {
+			@Override
+			protected void onFinished() {
+				if (actionMode != null) {
+					actionMode.finish();
 				}
 			}
-		}
+		};
 	}
 
 	@Override
@@ -1448,12 +1446,16 @@ public class ContactsSectionFragment
 	public void onYes(String tag, Object data, boolean checked) {
 		switch(tag) {
 			case DIALOG_TAG_REALLY_DELETE_CONTACTS:
-				reallyDeleteContacts((Set<ContactModel>) data, checked);
+				try {
+					reallyDeleteContacts((Set<ContactModel>) data, checked);
+				} catch (ThreemaException e) {
+					logger.error("Could not delete contacts", e);
+				}
 				break;
 			case DIALOG_TAG_REPORT_SPAM:
 				ContactModel contactModel = (ContactModel) data;
 
-				contactService.reportSpam(contactModel,
+				contactService.reportSpam(contactModel.getIdentity(),
 					unused -> {
 						if (isAdded()) {
 							Toast.makeText(getContext(), R.string.spam_successfully_reported, Toast.LENGTH_LONG).show();
@@ -1503,7 +1505,11 @@ public class ContactsSectionFragment
 	public void onYes(String tag, Object data) {
 		switch(tag) {
 			case DIALOG_TAG_REALLY_DELETE_CONTACTS:
-				reallyDeleteContacts((Set<ContactModel>) data, false);
+				try {
+					reallyDeleteContacts((Set<ContactModel>) data, false);
+				} catch (ThreemaException e) {
+					logger.error("Could not delete contacts", e);
+				}
 				break;
 			default:
 				break;
diff --git a/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java b/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java
index 00a92329..10fccbd8 100644
--- a/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/MessageSectionFragment.java
@@ -149,7 +149,6 @@ import ch.threema.app.voip.groupcall.GroupCallManager;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.ConversationModel;
 import ch.threema.storage.models.DistributionListModel;
 import ch.threema.storage.models.GroupModel;
@@ -221,6 +220,7 @@ public class MessageSectionFragment extends MainFragment
 
 	private Activity activity;
 	private File tempMessagesFile;
+    @Nullable
 	private MessageListAdapter messageListAdapter;
 	private EmptyRecyclerView recyclerView;
 	private View loadingView;
@@ -333,7 +333,7 @@ public class MessageSectionFragment extends MainFragment
 
 	private final GroupListener groupListener = new GroupListener() {
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			// If this user is added to an existing group
 			if (groupService != null && myIdentity != null && myIdentity.equals(newIdentity)) {
 				fireReceiverUpdate(groupService.createReceiver(group));
@@ -390,7 +390,7 @@ public class MessageSectionFragment extends MainFragment
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
 			this.handleChange();
 		}
 
@@ -599,8 +599,10 @@ public class MessageSectionFragment extends MainFragment
 		@Override
 		public boolean onQueryTextChange(String query) {
 			filterQuery = query;
-			messageListAdapter.setFilterQuery(query);
-			updateList(0, null, null);
+            if (messageListAdapter != null) {
+                messageListAdapter.setFilterQuery(query);
+                updateList(0, null, null);
+            }
 			return true;
 		}
 
@@ -691,14 +693,16 @@ public class MessageSectionFragment extends MainFragment
 	private void doUnhideChat(@NonNull ConversationModel conversationModel) {
 		MessageReceiver<?> receiver = conversationModel.getReceiver();
 		if (receiver != null && hiddenChatsListService.has(receiver.getUniqueIdString())) {
-			hiddenChatsListService.remove(receiver.getUniqueIdString());
+            hiddenChatsListService.remove(receiver.getUniqueIdString());
 
-			if (getView() != null) {
-				Snackbar.make(getView(), R.string.chat_visible, Snackbar.LENGTH_SHORT).show();
-			}
+            if (getView() != null) {
+                Snackbar.make(getView(), R.string.chat_visible, Snackbar.LENGTH_SHORT).show();
+            }
 
-			this.fireReceiverUpdate(receiver);
-			messageListAdapter.clearSelections();
+            this.fireReceiverUpdate(receiver);
+            if (messageListAdapter != null) {
+                messageListAdapter.clearSelections();
+            }
 		}
 	}
 
@@ -759,6 +763,9 @@ public class MessageSectionFragment extends MainFragment
 			@Override
 			protected void onPostExecute(Boolean success) {
 				if (success) {
+                    if (messageListAdapter == null) {
+                        return;
+                    }
 					messageListAdapter.clearSelections();
 					if (getView() != null) {
 						Snackbar.make(getView(), R.string.chat_hidden, Snackbar.LENGTH_SHORT).show();
@@ -894,6 +901,10 @@ public class MessageSectionFragment extends MainFragment
 
 				@Override
 				public void onSwiped(@NonNull RecyclerView.ViewHolder viewHolder, int direction) {
+                    if (messageListAdapter == null) {
+                        return;
+                    }
+
 					// swipe has ended successfully
 
 					// required to clear swipe layout
@@ -1153,7 +1164,7 @@ public class MessageSectionFragment extends MainFragment
 
 	@Override
 	public boolean onItemLongClick(View view, int position, ConversationModel conversationModel) {
-		if (!isMultiPaneEnabled(activity)) {
+		if (!isMultiPaneEnabled(activity) && messageListAdapter != null) {
 			messageListAdapter.toggleItemChecked(conversationModel, position);
 			showSelector();
 			return true;
@@ -1220,7 +1231,9 @@ public class MessageSectionFragment extends MainFragment
 		}
 		updateHiddenMenuVisibility();
 
-		messageListAdapter.updateDateView();
+        if (messageListAdapter != null) {
+            messageListAdapter.updateDateView();
+        }
 
 		super.onResume();
 	}
@@ -1245,7 +1258,7 @@ public class MessageSectionFragment extends MainFragment
 		ArrayList<SelectorDialogItem> labels = new ArrayList<>();
 		ArrayList<Integer> tags = new ArrayList<>();
 
-		if (messageListAdapter.getCheckedItemCount() != 1) {
+		if (messageListAdapter == null || messageListAdapter.getCheckedItemCount() != 1) {
 			return;
 		}
 
@@ -1311,7 +1324,7 @@ public class MessageSectionFragment extends MainFragment
 			}
 			boolean isCreator = groupService.isGroupCreator(group);
 			boolean isMember = groupService.isGroupMember(group);
-			boolean hasOtherMembers = groupService.getOtherMemberCount(group) > 0;
+			boolean hasOtherMembers = groupService.countMembersWithoutUser(group) > 0;
 			// Check also if the user is a group member, because orphaned groups should not be
 			// editable.
 			if (isCreator && isMember) {
@@ -1350,7 +1363,9 @@ public class MessageSectionFragment extends MainFragment
 	public void onClick(String tag, int which, Object data) {
 		GenericAlertDialog dialog;
 
-		messageListAdapter.clearSelections();
+        if (messageListAdapter != null) {
+            messageListAdapter.clearSelections();
+        }
 
 		final ConversationModel conversationModel = (ConversationModel) data;
 
@@ -1468,12 +1483,14 @@ public class MessageSectionFragment extends MainFragment
 
 	@Override
 	public void onCancel(String tag) {
+        if (messageListAdapter != null) {
 		messageListAdapter.clearSelections();
+        }
 	}
 
 	@Override
 	public void onNo(String tag) {
-		if (DIALOG_TAG_SELECT_DELETE_ACTION.equals(tag)) {
+		if (messageListAdapter != null && DIALOG_TAG_SELECT_DELETE_ACTION.equals(tag)) {
 			messageListAdapter.clearSelections();
 		}
 	}
diff --git a/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java b/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java
index 0c47c8de..af20d9e7 100644
--- a/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/MyIDFragment.java
@@ -51,6 +51,7 @@ import com.google.android.material.textfield.MaterialAutoCompleteTextView;
 
 import org.slf4j.Logger;
 
+import java.util.Arrays;
 import java.util.Date;
 
 import ch.threema.app.R;
@@ -73,11 +74,15 @@ import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.routines.CheckIdentityRoutine;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.ContactService.ProfilePictureSharePolicy;
 import ch.threema.app.services.FileService;
+import ch.threema.app.services.IdListService;
 import ch.threema.app.services.LocaleService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.QRCodeServiceImpl;
 import ch.threema.app.services.UserService;
+import ch.threema.app.tasks.ReflectUserProfileShareWithAllowListSyncTask;
+import ch.threema.app.tasks.ReflectUserProfileShareWithPolicySyncTask;
 import ch.threema.app.ui.AvatarEditView;
 import ch.threema.app.ui.QRCodePopup;
 import ch.threema.app.utils.AppRestrictionUtil;
@@ -93,6 +98,8 @@ import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.api.LinkMobileNoException;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
+import ch.threema.domain.taskmanager.TaskManager;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.localcrypto.MasterKeyLockedException;
 
 /**
@@ -117,6 +124,9 @@ public class MyIDFragment extends MainFragment
 	private LocaleService localeService;
 	private ContactService contactService;
 	private FileService fileService;
+    private IdListService profilePicRecipientsService;
+	private TaskManager taskManager;
+
 	private AvatarEditView avatarView;
 	private EmojiTextView nicknameTextView;
 	private boolean hidden = false;
@@ -237,7 +247,7 @@ public class MyIDFragment extends MainFragment
 
 			final MaterialButton picReleaseConfImageView = fragmentView.findViewById(R.id.picrelease_config);
 			picReleaseConfImageView.setOnClickListener(this);
-			picReleaseConfImageView.setVisibility(preferenceService.getProfilePicRelease() == PreferenceService.PROFILEPIC_RELEASE_SOME ? View.VISIBLE : View.GONE);
+			picReleaseConfImageView.setVisibility(preferenceService.getProfilePicRelease() == PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST ? View.VISIBLE : View.GONE);
 
 			configureEditWithButton(fragmentView.findViewById(R.id.linked_email_layout), fragmentView.findViewById(R.id.change_email), isReadonlyProfile);
 			configureEditWithButton(fragmentView.findViewById(R.id.linked_mobile_layout), fragmentView.findViewById(R.id.change_mobile), isReadonlyProfile);
@@ -300,21 +310,57 @@ public class MyIDFragment extends MainFragment
 		if (fragmentView != null && preferenceService != null) {
 			MaterialAutoCompleteTextView spinner = fragmentView.findViewById(R.id.picrelease_spinner);
 			if (spinner != null) {
-				ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(getContext(), R.array.picrelease_choices, android.R.layout.simple_spinner_dropdown_item);
+				ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(
+                    requireContext(),
+                    R.array.picrelease_choices,
+                    android.R.layout.simple_spinner_dropdown_item
+                );
 				spinner.setAdapter(adapter);
 				spinner.setText(adapter.getItem(preferenceService.getProfilePicRelease()), false);
-				spinner.setOnItemClickListener((parent, view, position, id) -> {
-					int oldPosition = preferenceService.getProfilePicRelease();
-					preferenceService.setProfilePicRelease(position);
-					fragmentView.findViewById(R.id.picrelease_config).setVisibility(position == PreferenceService.PROFILEPIC_RELEASE_SOME ? View.VISIBLE : View.GONE);
-					if (position == PreferenceService.PROFILEPIC_RELEASE_SOME && position != oldPosition) {
-						launchProfilePictureRecipientsSelector(view);
-					}
-				});
+				spinner.setOnItemClickListener((parent, view, position, id) -> onPicReleaseSpinnerItemClicked(view, position));
 			}
 		}
 	}
 
+    private void onPicReleaseSpinnerItemClicked(View view, int position){
+
+        final @Nullable ProfilePictureSharePolicy.Policy sharePolicy = ProfilePictureSharePolicy.Policy.fromIntOrNull(position);
+        if (sharePolicy == null) {
+            logger.error("Failed to get concrete enum value of type ProfilePictureSharePolicy.Policy for ordinal value {}", position);
+            return;
+        }
+
+        final int oldPosition = preferenceService.getProfilePicRelease();
+        preferenceService.setProfilePicRelease(position);
+
+        fragmentView.findViewById(R.id.picrelease_config)
+            .setVisibility(position == PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST ? View.VISIBLE : View.GONE);
+
+        // Only continue of the value actually changes from before
+        if (position == oldPosition) {
+            return;
+        }
+
+        if (sharePolicy == ProfilePictureSharePolicy.Policy.ALLOW_LIST) {
+            launchProfilePictureRecipientsSelector(view);
+            // sync new policy setting with currently set allow list values into device group (if md is active)
+            taskManager.schedule(
+                new ReflectUserProfileShareWithAllowListSyncTask(
+                    Arrays.asList(profilePicRecipientsService.getAll()),
+                    this.serviceManager
+                )
+            );
+        } else {
+            // sync new policy setting to device group (if md is active)
+            taskManager.schedule(
+                new ReflectUserProfileShareWithPolicySyncTask(
+                    sharePolicy,
+                    this.serviceManager
+                )
+            );
+        }
+    }
+
 	@Override
 	public void onStart() {
 		super.onStart();
@@ -737,7 +783,7 @@ public class MyIDFragment extends MainFragment
 				// Update public nickname
 				String newNickname = text.trim();
 				if (!newNickname.equals(userService.getPublicNickname())) {
-					userService.setPublicNickname(newNickname);
+					userService.setPublicNickname(newNickname, TriggerSource.LOCAL);
 				}
 				reloadNickname();
 				break;
@@ -805,6 +851,8 @@ public class MyIDFragment extends MainFragment
 				this.fileService = this.serviceManager.getFileService();
 				this.preferenceService = this.serviceManager.getPreferenceService();
 				this.localeService = this.serviceManager.getLocaleService();
+				this.taskManager = this.serviceManager.getTaskManager();
+				this.profilePicRecipientsService = this.serviceManager.getProfilePicRecipientsService();
 			} catch (MasterKeyLockedException e) {
 				logger.debug("Master Key locked!");
 			} catch (ThreemaException e) {
diff --git a/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java b/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java
index 7a2f012c..f71ade1f 100644
--- a/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/UserMemberListFragment.java
@@ -37,6 +37,7 @@ import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.storage.models.ContactModel;
 
@@ -61,21 +62,21 @@ public class UserMemberListFragment extends MemberListFragment {
 				List<ContactModel> contactModels;
 
 				if (groups) {
-					final ContactModel.State[] contactStates;
+					final IdentityState[] contactStates;
 					if (preferenceService.showInactiveContacts()) {
-						contactStates = new ContactModel.State[]{
-							ContactModel.State.ACTIVE,
-							ContactModel.State.INACTIVE
+						contactStates = new IdentityState[]{
+							IdentityState.ACTIVE,
+							IdentityState.INACTIVE
 						};
 					} else {
-						contactStates = new ContactModel.State[]{
-							ContactModel.State.ACTIVE
+						contactStates = new IdentityState[]{
+							IdentityState.ACTIVE
 						};
 					}
 
 					contactModels = contactService.find(new ContactService.Filter() {
 						@Override
-						public ContactModel.State[] states() {
+						public IdentityState[] states() {
 							return contactStates;
 						}
 
diff --git a/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java b/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java
index e134fd6b..05af4b85 100644
--- a/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/WorkUserListFragment.java
@@ -48,6 +48,7 @@ import ch.threema.app.collections.IPredicateNonNull;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.storage.models.ContactModel;
 
 public class WorkUserListFragment extends RecipientListFragment {
@@ -115,21 +116,21 @@ public class WorkUserListFragment extends RecipientListFragment {
 		new AsyncTask<Void, Void, List<ContactModel>>() {
 			@Override
 			protected List<ContactModel> doInBackground(Void... voids) {
-				final ContactModel.State[] contactStates;
+				final IdentityState[] contactStates;
 				if (preferenceService.showInactiveContacts()) {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE,
-						ContactModel.State.INACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE,
+						IdentityState.INACTIVE
 					};
 				} else {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE
 					};
 				}
 
 				return Functional.filter(contactService.find(new ContactService.Filter() {
 					@Override
-					public ContactModel.State[] states() {
+					public IdentityState[] states() {
 						return contactStates;
 					}
 
diff --git a/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java b/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java
index 2a35e0ce..4284f2ab 100644
--- a/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java
+++ b/app/src/main/java/ch/threema/app/fragments/WorkUserMemberListFragment.java
@@ -39,6 +39,7 @@ import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.ContactUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.storage.models.ContactModel;
 
@@ -60,21 +61,21 @@ public class WorkUserMemberListFragment extends MemberListFragment {
 		new AsyncTask<Void, Void, List<ContactModel>>() {
 			@Override
 			protected List<ContactModel> doInBackground(Void... voids) {
-				final ContactModel.State[] contactStates;
+				final IdentityState[] contactStates;
 				if (preferenceService.showInactiveContacts()) {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE,
-						ContactModel.State.INACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE,
+						IdentityState.INACTIVE
 					};
 				} else {
-					contactStates = new ContactModel.State[]{
-						ContactModel.State.ACTIVE
+					contactStates = new IdentityState[]{
+						IdentityState.ACTIVE
 					};
 				}
 
 				List<ContactModel> contactModels = Functional.filter(contactService.find(new ContactService.Filter() {
 					@Override
-					public ContactModel.State[] states() {
+					public IdentityState[] states() {
 						return contactStates;
 					}
 
diff --git a/app/src/main/java/ch/threema/app/glide/AvatarOptions.java b/app/src/main/java/ch/threema/app/glide/AvatarOptions.java
index 1a930459..5b15fc55 100644
--- a/app/src/main/java/ch/threema/app/glide/AvatarOptions.java
+++ b/app/src/main/java/ch/threema/app/glide/AvatarOptions.java
@@ -34,38 +34,29 @@ public class AvatarOptions {
 	 */
 	public enum DefaultAvatarPolicy {
 		/**
-		 * Try to load the custom avatar. If no custom avatar available, then return the default avatar instead of null.
+		 * Try to load the custom avatar. If no custom avatar available, then return the default
+         * avatar instead of null.
 		 */
 		DEFAULT_FALLBACK,
 		/**
-		 * Load the custom avatar. If no custom avatar is set, then return null.
+		 * Load the custom avatar. If no custom avatar is set, then return null. Note that a custom
+         * avatar can either be a contact or user defined profile picture.
 		 */
 		CUSTOM_AVATAR,
 		/**
 		 * Load the default avatar even if a custom avatar would be available.
 		 */
 		DEFAULT_AVATAR,
-		/**
-		 * Load the custom avatar if not prevented by settings. Otherwise returns the default avatar.
-		 */
-		RESPECT_SETTINGS
 	}
 
 	/**
-	 * Load the avatar in low resolution. If no avatar is found, load the default avatar.
+	 * Load the avatar in low resolution. If no avatar is found, load the default avatar. This
+     * respects the setting where the user defined profile picture should not be shown.
 	 */
 	public static final AvatarOptions PRESET_DEFAULT_FALLBACK = new Builder()
 		.setReturnPolicy(DefaultAvatarPolicy.DEFAULT_FALLBACK)
 		.toOptions();
 
-	/**
-	 * Load the avatar in low resolution. If no avatar is found, or custom avatars are disabled in settings,
-	 * load the default avatar.
-	 */
-	public static final AvatarOptions PRESET_RESPECT_SETTINGS = new Builder()
-		.setReturnPolicy(DefaultAvatarPolicy.RESPECT_SETTINGS)
-		.toOptions();
-
 	/**
 	 * Load the avatar with default fallback and do not cache it.
 	 */
@@ -146,7 +137,7 @@ public class AvatarOptions {
 	 */
 	public static class Builder {
 		private boolean highRes = false;
-		private @NonNull DefaultAvatarPolicy defaultAvatarPolicy = DefaultAvatarPolicy.RESPECT_SETTINGS;
+		private @NonNull DefaultAvatarPolicy defaultAvatarPolicy = DefaultAvatarPolicy.DEFAULT_AVATAR;
 		private boolean disableCache = false;
 		private boolean darkerBackground = false;
 
diff --git a/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt b/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt
index 090ac23b..a75cc455 100644
--- a/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt
+++ b/app/src/main/java/ch/threema/app/glide/ContactAvatarFetcher.kt
@@ -60,7 +60,7 @@ class ContactAvatarFetcher(
         val returnDefaultIfNone: Boolean
         when (contactAvatarConfig.options.defaultAvatarPolicy) {
             AvatarOptions.DefaultAvatarPolicy.DEFAULT_FALLBACK -> {
-                profilePicReceive = true
+                profilePicReceive = preferenceService?.profilePicReceive == true
                 defaultAvatar = false
                 returnDefaultIfNone = true
             }
@@ -74,11 +74,6 @@ class ContactAvatarFetcher(
                 defaultAvatar = true
                 returnDefaultIfNone = true
             }
-            AvatarOptions.DefaultAvatarPolicy.RESPECT_SETTINGS -> {
-                profilePicReceive = preferenceService?.profilePicReceive == true
-                defaultAvatar = false
-                returnDefaultIfNone = true
-            }
         }
         val backgroundColor = getBackgroundColor(contactAvatarConfig.options)
 
@@ -96,29 +91,29 @@ class ContactAvatarFetcher(
             return buildDefaultAvatar(null, highRes, backgroundColor)
         }
 
-        // try profile picture
+        // Try the contact defined profile picture
         if (profilePicReceive) {
-            getProfilePicture(contactModel, highRes)?.let {
+            getContactDefinedProfilePicture(contactModel, highRes)?.let {
                 return it
             }
         }
 
-        // try local saved avatar
-        getLocallySavedAvatar(contactModel, highRes)?.let {
+        // Try the user defined profile picture
+        getUserDefinedProfilePicture(contactModel, highRes)?.let {
             return it
         }
 
-        // try android contact picture
-        getAndroidContactAvatar(contactModel, highRes)?.let {
+        // Try the android defined profile picture
+        getAndroidDefinedProfilePicture(contactModel, highRes)?.let {
             return it
         }
 
         return if (returnDefaultIfNone) buildDefaultAvatar(contactModel, highRes, backgroundColor) else null
     }
 
-    private fun getProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
+    private fun getContactDefinedProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
         try {
-            val result = fileService?.getContactPhoto(contactModel.identity)
+            val result = fileService?.getContactDefinedProfilePicture(contactModel.identity)
             if (result != null && !highRes) {
                 return AvatarConverterUtil.convert(this.context.resources, result)
             }
@@ -128,9 +123,9 @@ class ContactAvatarFetcher(
         }
     }
 
-    private fun getLocallySavedAvatar(contactModel: ContactModel, highRes: Boolean): Bitmap? {
+    private fun getUserDefinedProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
         return try {
-            var result = fileService?.getContactAvatar(contactModel.identity)
+            var result = fileService?.getUserDefinedProfilePicture(contactModel.identity)
             if (result != null && !highRes) {
                 result = AvatarConverterUtil.convert(this.context.resources, result)
             }
@@ -140,13 +135,13 @@ class ContactAvatarFetcher(
         }
     }
 
-    private fun getAndroidContactAvatar(contactModel: ContactModel, highRes: Boolean): Bitmap? {
+    private fun getAndroidDefinedProfilePicture(contactModel: ContactModel, highRes: Boolean): Bitmap? {
         if (ContactUtil.isGatewayContact(contactModel) || AndroidContactUtil.getInstance().getAndroidContactUri(contactModel) == null) {
             return null
         }
         // regular contacts
         return try {
-            var result = fileService?.getAndroidContactAvatar(contactModel)
+            var result = fileService?.getAndroidDefinedProfilePicture(contactModel)
             if (result != null && !highRes) {
                 result = AvatarConverterUtil.convert(this.context.resources, result)
             }
diff --git a/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt b/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt
index 5083405e..d1032283 100644
--- a/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt
+++ b/app/src/main/java/ch/threema/app/glide/GroupAvatarFetcher.kt
@@ -64,10 +64,6 @@ class GroupAvatarFetcher(
                 defaultAvatar = true
                 defaultAvatarIfNone = true
             }
-            AvatarOptions.DefaultAvatarPolicy.RESPECT_SETTINGS -> {
-                defaultAvatar = preferenceService?.profilePicReceive == false
-                defaultAvatarIfNone = true
-            }
         }
         val backgroundColor = getBackgroundColor(config.options)
 
diff --git a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt
deleted file mode 100644
index 990692ee..00000000
--- a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchActivity.kt
+++ /dev/null
@@ -1,291 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.globalsearch
-
-import android.content.res.Configuration
-import android.os.Bundle
-import android.os.Handler
-import android.os.Looper
-import android.view.Menu
-import android.view.View
-import android.view.ViewGroup
-import android.widget.CompoundButton
-import androidx.activity.result.ActivityResult
-import androidx.activity.result.contract.ActivityResultContracts
-import androidx.annotation.IdRes
-import androidx.appcompat.widget.SearchView
-import androidx.core.view.WindowCompat
-import androidx.core.view.WindowInsetsCompat
-import androidx.lifecycle.Observer
-import androidx.lifecycle.ViewModelProvider
-import androidx.recyclerview.widget.DefaultItemAnimator
-import androidx.recyclerview.widget.LinearLayoutManager
-import ch.threema.app.R
-import ch.threema.app.activities.ThreemaToolbarActivity
-import ch.threema.app.fragments.ComposeMessageFragment.EXTRA_OVERRIDE_BACK_TO_HOME_BEHAVIOR
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.DeadlineListService
-import ch.threema.app.services.GroupService
-import ch.threema.app.services.MessageService.MessageFilterFlags
-import ch.threema.app.services.MessageServiceImpl.FILTER_CHATS
-import ch.threema.app.services.MessageServiceImpl.FILTER_GROUPS
-import ch.threema.app.services.MessageServiceImpl.FILTER_INCLUDE_ARCHIVED
-import ch.threema.app.ui.EmptyRecyclerView
-import ch.threema.app.ui.EmptyView
-import ch.threema.app.ui.ThreemaSearchView
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.IntentDataUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.GroupMessageModel
-import com.bumptech.glide.Glide
-import com.google.android.material.chip.Chip
-import com.google.android.material.search.SearchBar
-import org.slf4j.Logger
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("GlobalSearchActivity")
-
-class GlobalSearchActivity : ThreemaToolbarActivity(), SearchView.OnQueryTextListener {
-
-    private companion object {
-        const val QUERY_MIN_LENGTH: Int = 2
-        const val GLOBAL_SEARCH_QUERY_TIMEOUT_MS: Long = 500
-    }
-
-    private var chatsAdapter: GlobalSearchAdapter? = null
-    private var globalSearchViewModel: GlobalSearchViewModel? = null
-    private var searchView: ThreemaSearchView? = null
-    private var searchBar: SearchBar? = null
-    private lateinit var hiddenChatsListService: DeadlineListService
-    private lateinit var contactService: ContactService
-    private lateinit var groupService: GroupService
-
-    @MessageFilterFlags
-    private var filterFlags = FILTER_CHATS or FILTER_GROUPS or FILTER_INCLUDE_ARCHIVED
-    private var queryText: String? = null
-    private val queryHandler = Handler(Looper.getMainLooper())
-    private val queryTask = Runnable {
-        globalSearchViewModel?.onQueryChanged(
-            query = queryText,
-            filterFlags = filterFlags,
-            allowEmpty = false,
-            sortAscending = false
-        )
-        chatsAdapter?.onQueryChanged(queryText)
-    }
-    private val showMessageLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { _: ActivityResult ->
-        // search results may have changed when returning from ComposeMessageFragment
-        globalSearchViewModel?.onDataChanged()
-    }
-
-    override fun onQueryTextSubmit(query: String?): Boolean {
-        return true
-    }
-
-    override fun onQueryTextChange(newText: String?): Boolean {
-        queryText = newText
-        if (globalSearchViewModel != null && chatsAdapter != null) {
-            queryHandler.removeCallbacksAndMessages(null)
-            if ((queryText?.length ?: 0) >= QUERY_MIN_LENGTH) {
-                queryHandler.postDelayed(queryTask, GLOBAL_SEARCH_QUERY_TIMEOUT_MS)
-            } else {
-                globalSearchViewModel?.onQueryChanged(
-                    query = null,
-                    filterFlags = filterFlags,
-                    allowEmpty = false,
-                    sortAscending = false
-                )
-                chatsAdapter?.onQueryChanged(null)
-            }
-        }
-        return true
-    }
-
-    override fun getLayoutResource(): Int {
-        return R.layout.activity_global_search
-    }
-
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-        try {
-            contactService = serviceManager.getContactService()
-            groupService = serviceManager.getGroupService()
-            hiddenChatsListService = serviceManager.getHiddenChatsListService()
-        } catch (e: Exception) {
-            logger.error("Exception", e)
-            finish()
-        }
-    }
-
-    override fun initActivity(savedInstanceState: Bundle?): Boolean {
-        if (!super.initActivity(savedInstanceState)) {
-            return false
-        }
-
-        if (supportActionBar != null) {
-            searchBar = toolbar as SearchBar
-            searchBar?.let { bar ->
-                bar.setNavigationOnClickListener {
-                    searchView?.let {
-                        if (it.isIconified) {
-                            finish()
-                        } else {
-                            it.isIconified = true
-                        }
-                    }
-                }
-                bar.setOnClickListener { searchView?.isIconified = false }
-                ConfigUtils.adjustSearchBarTextViewMargin(this, bar)
-            }
-        }
-
-        chatsAdapter = GlobalSearchAdapter(
-            this,
-            Glide.with(this),
-            R.layout.item_global_search,
-            17
-        )
-        chatsAdapter?.setOnClickItemListener { messageModel: AbstractMessageModel?, _: View, _: Int ->
-            showMessage(
-                messageModel
-            )
-        }
-
-        setupChip(R.id.chats, FILTER_CHATS)
-        setupChip(R.id.groups, FILTER_GROUPS)
-        setupChip(R.id.archived, FILTER_INCLUDE_ARCHIVED)
-
-        val recyclerView = this.findViewById<EmptyRecyclerView>(R.id.recycler_chats)
-        recyclerView.layoutManager = LinearLayoutManager(this)
-        recyclerView.itemAnimator = DefaultItemAnimator()
-        val emptyView = EmptyView(this, ConfigUtils.getActionBarSize(this))
-        emptyView.setup(
-            R.string.global_search_empty_view_text,
-            R.drawable.ic_search_outline,
-            ConfigUtils.getColorFromAttribute(this, R.attr.colorOnBackground)
-        )
-        (recyclerView.parent.parent as ViewGroup).addView(emptyView)
-        recyclerView.emptyView = emptyView
-        emptyView.setLoading(true)
-        recyclerView.adapter = chatsAdapter
-
-        globalSearchViewModel = ViewModelProvider(this)[GlobalSearchViewModel::class.java].also { globalSearchViewModel ->
-            globalSearchViewModel.messageModels.observe(this) { messageModels ->
-                emptyView.setLoading(false)
-
-                val messageModelsWithoutHiddenChats = messageModels.filterNot { messageModel ->
-                    val deadlineListIdentifier: String = if (messageModel is GroupMessageModel) {
-                        groupService.getUniqueIdString(messageModel.groupId)
-                    } else {
-                        contactService.getUniqueIdString(messageModel.identity)
-                    }
-                    hiddenChatsListService.has(deadlineListIdentifier)
-                }
-
-                chatsAdapter?.setMessageModels(messageModelsWithoutHiddenChats)
-
-                if (messageModelsWithoutHiddenChats.isEmpty()) {
-                    if ((queryText?.length ?: 0) >= QUERY_MIN_LENGTH) {
-                        emptyView.setup(R.string.search_no_matches)
-                    } else {
-                        emptyView.setup(R.string.global_search_empty_view_text)
-                    }
-                }
-            }
-
-            globalSearchViewModel.isLoading.observe(this) { isLoading: Boolean ->
-                emptyView.setLoading(isLoading)
-            }
-        }
-
-        onQueryTextChange(null)
-        return true
-    }
-
-    override fun onCreateOptionsMenu(menu: Menu): Boolean {
-        super.onCreateOptionsMenu(menu)
-        menuInflater.inflate(R.menu.activity_global_search, menu)
-        val searchMenuItem = menu.findItem(R.id.menu_action_search)
-        searchView = searchMenuItem.actionView as ThreemaSearchView?
-        searchView?.let {
-            if (ConfigUtils.isLandscape(this)) {
-                it.maxWidth = Int.MAX_VALUE
-            }
-
-            ConfigUtils.adjustSearchViewPadding(it)
-            it.queryHint = getString(R.string.global_search_empty_view_text)
-            it.setOnQueryTextListener(this)
-            it.setOnSearchClickListener {
-                searchBar?.hint = ""
-            }
-            // Show the hint of the search bar again when the search view is closed
-            it.setOnCloseListener {
-                searchBar?.setHint(R.string.global_search)
-                false
-            }
-        }
-        if (searchView == null) {
-            searchMenuItem.isVisible = false
-        }
-        return true
-    }
-
-    private fun setupChip(@IdRes id: Int, flag: Int) {
-        // https://github.com/material-components/material-components-android/issues/1419
-        val chip = findViewById<Chip>(id)
-        chip.isChecked = true
-        chip.setOnCheckedChangeListener { _: CompoundButton?, isChecked: Boolean ->
-            filterFlags = if (isChecked) {
-                filterFlags or flag
-            } else {
-                filterFlags and flag.inv()
-            }
-            globalSearchViewModel?.onQueryChanged(
-                query = queryText,
-                filterFlags = filterFlags,
-                allowEmpty = false,
-                sortAscending = false
-            )
-        }
-    }
-
-    private fun showMessage(messageModel: AbstractMessageModel?) {
-        if (messageModel == null) {
-            return
-        }
-        hideKeyboard()
-        val intent = IntentDataUtil.getJumpToMessageIntent(this, messageModel)
-        intent.putExtra(EXTRA_OVERRIDE_BACK_TO_HOME_BEHAVIOR, true)
-        showMessageLauncher.launch(intent)
-    }
-
-    private fun hideKeyboard() {
-        searchView?.let {
-            WindowCompat.getInsetsController(window, it).hide(WindowInsetsCompat.Type.ime())
-        }
-    }
-
-    override fun onConfigurationChanged(newConfig: Configuration) {
-        hideKeyboard()
-        super.onConfigurationChanged(newConfig)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java
index d498e059..d4a067a5 100644
--- a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java
+++ b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchAdapter.java
@@ -69,6 +69,7 @@ import ch.threema.app.ui.CheckableRelativeLayout;
 import ch.threema.app.ui.listitemholder.AvatarListItemHolder;
 import ch.threema.app.utils.ColorUtil;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.IconUtil;
 import ch.threema.app.utils.LocaleUtil;
 import ch.threema.app.utils.MimeUtil;
@@ -197,7 +198,7 @@ public class GlobalSearchAdapter extends RecyclerView.Adapter<RecyclerView.ViewH
 
             final @NonNull String uid = messageModel instanceof GroupMessageModel
                 ? groupService.getUniqueIdString(((GroupMessageModel) messageModel).getGroupId())
-                : contactService.getUniqueIdString(messageModel.getIdentity());
+                : ContactUtil.getUniqueIdString(messageModel.getIdentity());
             if (hiddenChatsListService.has(uid)) {
                 viewHolder.dateView.setText("");
                 viewHolder.thumbnailView.setVisibility(View.GONE);
diff --git a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchViewModel.kt b/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchViewModel.kt
deleted file mode 100644
index f57ac63d..00000000
--- a/app/src/main/java/ch/threema/app/globalsearch/GlobalSearchViewModel.kt
+++ /dev/null
@@ -1,57 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.globalsearch
-
-import androidx.lifecycle.LiveData
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.map
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.GroupMessageModel
-
-class GlobalSearchViewModel : ViewModel() {
-    val messageModels: LiveData<List<AbstractMessageModel>>
-
-    private val repository = GlobalSearchRepository()
-
-    init {
-        messageModels = repository.messageModels.map { messageModels ->
-            messageModels.filter { message ->
-                if (message is GroupMessageModel) {
-                    message.groupId > 0
-                } else {
-                    message.identity != null
-                }
-            }
-        }
-    }
-
-    fun onQueryChanged(query: String?, filterFlags: Int, allowEmpty: Boolean, sortAscending: Boolean) {
-        repository.onQueryChanged(query, filterFlags, allowEmpty, sortAscending)
-    }
-
-    val isLoading: LiveData<Boolean>
-        get() = repository.isLoading
-
-    fun onDataChanged() {
-        repository.onDataChanged()
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java b/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java
index d7dfb661..0c7ad23f 100644
--- a/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java
+++ b/app/src/main/java/ch/threema/app/grouplinks/OutgoingGroupRequestActivity.java
@@ -23,13 +23,18 @@ package ch.threema.app.grouplinks;
 
 import android.content.Intent;
 import android.net.Uri;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 
+import org.slf4j.Logger;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
 import androidx.annotation.NonNull;
 import androidx.appcompat.app.ActionBar;
 import androidx.appcompat.view.ActionMode;
@@ -38,17 +43,14 @@ import androidx.lifecycle.Observer;
 import androidx.lifecycle.ViewModelProvider;
 import androidx.recyclerview.widget.DefaultItemAnimator;
 import androidx.recyclerview.widget.LinearLayoutManager;
-
-import org.slf4j.Logger;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.ComposeMessageActivity;
 import ch.threema.app.activities.ThreemaToolbarActivity;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
 import ch.threema.app.dialogs.GenericAlertDialog;
 import ch.threema.app.dialogs.SelectorDialog;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
@@ -62,16 +64,21 @@ import ch.threema.app.ui.EmptyRecyclerView;
 import ch.threema.app.ui.EmptyView;
 import ch.threema.app.ui.SelectorDialogItem;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.LazyProperty;
 import ch.threema.app.utils.LogUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.RuntimeUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.group.GroupInviteData;
 import ch.threema.domain.protocol.csp.messages.group.GroupInviteToken;
 import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.protobuf.url_payloads.GroupInvite;
 import ch.threema.storage.DatabaseServiceNew;
+import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
 import ch.threema.storage.models.group.GroupInviteModel;
 import ch.threema.storage.models.group.OutgoingGroupJoinRequestModel;
@@ -98,6 +105,11 @@ public class OutgoingGroupRequestActivity extends ThreemaToolbarActivity impleme
 	private GroupService groupService;
 	private ContactService contactService;
 	private DatabaseServiceNew databaseService;
+	private APIConnector apiConnector;
+	private ContactModelRepository contactModelRepository;
+
+	@NonNull
+	private final LazyProperty<BackgroundExecutor> backgroundExecutor = new LazyProperty<>(BackgroundExecutor::new);
 
 	private OutgoingGroupRequestViewModel viewModel;
 	private GroupInviteData groupInvite;
@@ -169,6 +181,8 @@ public class OutgoingGroupRequestActivity extends ThreemaToolbarActivity impleme
 			this.userService = serviceManager.getUserService();
 			this.groupService = serviceManager.getGroupService();
 			this.databaseService = serviceManager.getDatabaseServiceNew();
+			this.apiConnector = serviceManager.getAPIConnector();
+			this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
 		} catch (MasterKeyLockedException | FileSystemNotPresentException e) {
 			logger.error("Exception, services not available... finishing");
 			finish();
@@ -412,36 +426,32 @@ public class OutgoingGroupRequestActivity extends ThreemaToolbarActivity impleme
 			if (this.resendRequestReference == null) {
 				// first add contact and fetch public key to be able to send a request
 				if (contactService.getByIdentity(groupInvite.getAdminIdentity()) == null) {
-					new AsyncTask<Void, Void, Exception>() {
-						@Override
-						protected void onPreExecute() {
-							// no preparation steps needed
-						}
-
-						@Override
-						protected Exception doInBackground(Void... params) {
-							try {
-								contactService.createContactByIdentity(groupInvite.getAdminIdentity(), true);
-								return null;
-							} catch (Exception e) {
-								return e;
-							}
-						}
-
-						@Override
-						protected void onPostExecute(Exception exception) {
-							if (isDestroyed()) {
-								return;
-							}
-							try {
-								outgoingGroupJoinRequestService.send(
-									groupInvite,
-									message);
-							} catch (Exception e) {
-								LogUtil.error("Exception, sending request after adding contact failed" + e, OutgoingGroupRequestActivity.this);
+					backgroundExecutor.get().execute(
+						new BasicAddOrUpdateContactBackgroundTask(
+							groupInvite.getAdminIdentity(),
+							ContactModel.AcquaintanceLevel.DIRECT,
+							userService.getIdentity(),
+							apiConnector,
+							contactModelRepository,
+							AddContactRestrictionPolicy.CHECK,
+							this,
+							null
+						) {
+							@Override
+							public void onFinished(ContactResult result) {
+								if (result instanceof ContactAvailable) {
+									if (isDestroyed()) {
+										return;
+									}
+									try {
+										outgoingGroupJoinRequestService.send(groupInvite, message);
+									} catch (Exception e) {
+										logger.error("Sending request after adding contact failed", e);
+									}
+								}
 							}
 						}
-					}.execute();
+					);
 				} else {
 					outgoingGroupJoinRequestService.send(
 						groupInvite,
diff --git a/app/src/main/java/ch/threema/app/listeners/ContactListener.java b/app/src/main/java/ch/threema/app/listeners/ContactListener.java
index 5da9d2b4..40f30aac 100644
--- a/app/src/main/java/ch/threema/app/listeners/ContactListener.java
+++ b/app/src/main/java/ch/threema/app/listeners/ContactListener.java
@@ -39,7 +39,7 @@ public interface ContactListener {
 	/**
 	 * Called when the contact avatar was changed.
 	 */
-	@AnyThread default void onAvatarChanged(final ContactModel contactModel) { }
+	@AnyThread default void onAvatarChanged(final @NonNull String identity) { }
 
 	/**
 	 * The contact was removed.
diff --git a/app/src/main/java/ch/threema/app/listeners/EditMessageListener.kt b/app/src/main/java/ch/threema/app/listeners/EditMessageListener.kt
deleted file mode 100644
index 96767980..00000000
--- a/app/src/main/java/ch/threema/app/listeners/EditMessageListener.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.listeners
-
-import ch.threema.storage.models.AbstractMessageModel
-
-interface EditMessageListener {
-    fun onEdit(message: AbstractMessageModel)
-}
diff --git a/app/src/main/java/ch/threema/app/listeners/GroupListener.java b/app/src/main/java/ch/threema/app/listeners/GroupListener.java
index f5c3a457..2a7dd764 100644
--- a/app/src/main/java/ch/threema/app/listeners/GroupListener.java
+++ b/app/src/main/java/ch/threema/app/listeners/GroupListener.java
@@ -31,9 +31,9 @@ public interface GroupListener {
 	@AnyThread default void onUpdatePhoto(GroupModel groupModel) { }
 	@AnyThread default void onRemove(GroupModel groupModel) { }
 
-	@AnyThread default void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) { }
-	@AnyThread default void onMemberLeave(GroupModel group, String identity, int previousMemberCount) { }
-	@AnyThread default void onMemberKicked(GroupModel group, String identity, int previousMemberCount) { }
+	@AnyThread default void onNewMember(GroupModel group, String newIdentity) { }
+	@AnyThread default void onMemberLeave(GroupModel group, String identity) { }
+	@AnyThread default void onMemberKicked(GroupModel group, String identity) { }
 
 	/**
 	 * Group was updated.
diff --git a/app/src/main/java/ch/threema/app/listeners/MessageDeletedForAllListener.kt b/app/src/main/java/ch/threema/app/listeners/MessageDeletedForAllListener.kt
deleted file mode 100644
index 75eb917d..00000000
--- a/app/src/main/java/ch/threema/app/listeners/MessageDeletedForAllListener.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.listeners
-
-import ch.threema.storage.models.AbstractMessageModel
-
-interface MessageDeletedForAllListener {
-    fun onDeletedForAll(message: AbstractMessageModel)
-}
diff --git a/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java b/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java
index a07e3e1c..6e1f8df0 100644
--- a/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java
+++ b/app/src/main/java/ch/threema/app/listeners/NewSyncedContactsListener.java
@@ -24,7 +24,7 @@ package ch.threema.app.listeners;
 import java.util.List;
 
 import androidx.annotation.AnyThread;
-import ch.threema.storage.models.ContactModel;
+import ch.threema.data.models.ContactModel;
 
 /**
  * Listen for new contacts added via sync.
diff --git a/app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt b/app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt
deleted file mode 100644
index 1a9fe5b0..00000000
--- a/app/src/main/java/ch/threema/app/managers/CoreServiceManager.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.managers
-
-import ch.threema.app.multidevice.MultiDeviceManagerImpl
-import ch.threema.app.stores.PreferenceStoreInterface
-import ch.threema.app.tasks.TaskArchiverImpl
-import ch.threema.app.utils.DeviceCookieManagerImpl
-import ch.threema.domain.models.AppVersion
-import ch.threema.domain.taskmanager.TaskManager
-import ch.threema.storage.DatabaseServiceNew
-
-/**
- * The core service manager contains some core services that are used before the other services are
- * instantiated. Note that some of the provided services must be further initialized before they can
- * be used.
- */
-interface CoreServiceManager {
-
-    /**
-     * The app version.
-     */
-    val version: AppVersion
-
-    /**
-     * The database service.
-     */
-    val databaseService: DatabaseServiceNew
-
-    /**
-     * The preference store
-     */
-    val preferenceStore: PreferenceStoreInterface
-
-    /**
-     * The task archiver. Note that this must only be used to load the persisted tasks when the
-     * service manager has been set.
-     */
-    val taskArchiver: TaskArchiverImpl
-
-    /**
-     * The device cookie manager. Note that this must only be used when the notification service is
-     * passed to it.
-     */
-    val deviceCookieManager: DeviceCookieManagerImpl
-
-    /**
-     * The task manager. Note that this must only be used to schedule tasks when the task archiver
-     * has access to the service manager.
-     */
-    val taskManager: TaskManager
-
-    /**
-     * The multi device manager.
-     */
-    val multiDeviceManager: MultiDeviceManagerImpl
-
-}
diff --git a/app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt b/app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt
deleted file mode 100644
index 3a354a08..00000000
--- a/app/src/main/java/ch/threema/app/managers/CoreServiceManagerImpl.kt
+++ /dev/null
@@ -1,97 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.managers
-
-import ch.threema.app.multidevice.MultiDeviceManagerImpl
-import ch.threema.app.services.ServerMessageService
-import ch.threema.app.services.ServerMessageServiceImpl
-import ch.threema.app.stores.PreferenceStoreInterface
-import ch.threema.app.tasks.TaskArchiverImpl
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.DeviceCookieManagerImpl
-import ch.threema.domain.models.AppVersion
-import ch.threema.domain.taskmanager.TaskManager
-import ch.threema.domain.taskmanager.TaskManagerConfiguration
-import ch.threema.domain.taskmanager.TaskManagerProvider
-import ch.threema.storage.DatabaseServiceNew
-
-/**
- * The core service manager contains some core services that are used before the other services are
- * instantiated. Note that some of the provided services must be further initialized before they can
- * be used.
- */
-class CoreServiceManagerImpl(
-    override val version: AppVersion,
-    override val databaseService: DatabaseServiceNew,
-    override val preferenceStore: PreferenceStoreInterface,
-) : CoreServiceManager {
-
-    /**
-     * The task archiver. Note that this must only be used to load the persisted tasks when the
-     * service manager has been set.
-     */
-    override val taskArchiver: TaskArchiverImpl by lazy {
-        TaskArchiverImpl(databaseService.taskArchiveFactory)
-    }
-
-    /**
-     * The device cookie manager. Note that this must only be used when the notification service is
-     * passed to it.
-     */
-    override val deviceCookieManager: DeviceCookieManagerImpl by lazy {
-        DeviceCookieManagerImpl(preferenceStore, databaseService)
-    }
-
-    /**
-     * The task manager. Note that this must only be used to schedule tasks when the task archiver
-     * has access to the service manager.
-     */
-    override val taskManager: TaskManager by lazy {
-        TaskManagerProvider.getTaskManager(
-            TaskManagerConfiguration(
-                { taskArchiver },
-                deviceCookieManager,
-                ConfigUtils.isDevBuild()
-            )
-        )
-    }
-
-    /**
-     * The server message service.
-     * TODO(ANDR-2604): Use this wherever server messages are used
-     */
-    private val serverMessageService: ServerMessageService by lazy {
-        ServerMessageServiceImpl(databaseService)
-    }
-
-    /**
-     * The multi device manager.
-     */
-    override val multiDeviceManager: MultiDeviceManagerImpl by lazy {
-        MultiDeviceManagerImpl(
-            preferenceStore,
-            serverMessageService,
-            version,
-        )
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/managers/ServiceManager.java b/app/src/main/java/ch/threema/app/managers/ServiceManager.java
index 539565d3..37450c93 100644
--- a/app/src/main/java/ch/threema/app/managers/ServiceManager.java
+++ b/app/src/main/java/ch/threema/app/managers/ServiceManager.java
@@ -22,6 +22,9 @@
 package ch.threema.app.managers;
 
 import android.content.Context;
+import android.os.Build;
+
+import com.datatheorem.android.trustkit.pinning.OkHttp3Helper;
 
 import org.slf4j.Logger;
 
@@ -45,7 +48,6 @@ import ch.threema.app.emojis.search.EmojiSearchIndex;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.exceptions.NoIdentityException;
 import ch.threema.app.multidevice.MultiDeviceManager;
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector;
 import ch.threema.app.processors.IncomingMessageProcessorImpl;
 import ch.threema.app.services.ActivityService;
 import ch.threema.app.services.ApiService;
@@ -150,1101 +152,1078 @@ import ch.threema.domain.protocol.connection.csp.DeviceCookieManager;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor;
 import ch.threema.domain.stores.DHSessionStoreInterface;
-import ch.threema.domain.taskmanager.ActiveTaskCodec;
 import ch.threema.domain.taskmanager.IncomingMessageProcessor;
 import ch.threema.domain.taskmanager.TaskManager;
 import ch.threema.localcrypto.MasterKey;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.DatabaseNonceStore;
 import ch.threema.storage.DatabaseServiceNew;
 import java8.util.function.Supplier;
 import okhttp3.OkHttpClient;
 
 public class ServiceManager {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("ServiceManager");
-
-	@NonNull
-	private final CoreServiceManager coreServiceManager;
-	@NonNull
-	private final Supplier<Boolean> isIpv6Preferred;
-	@NonNull
-	private final IdentityStore identityStore;
-	@NonNull
-	private final MasterKey masterKey;
-	@NonNull
-	private final UpdateSystemService updateSystemService;
-	@NonNull
-	private final CacheService cacheService;
-	@Nullable
-	private DatabaseContactStore contactStore;
-	@Nullable
-	private APIConnector apiConnector;
-	@Nullable
-	private ContactService contactService;
-	@Nullable
-	private UserService userService;
-	@Nullable
-	private MessageService messageService;
-	@Nullable
-	private QRCodeService qrCodeService;
-	@Nullable
-	private FileService fileService;
-	@Nullable
-	private PreferenceService preferencesService;
-	@Nullable
-	private LocaleService localeService;
-	@Nullable
-	private DeviceService deviceService;
-	@Nullable
-	private LifetimeService lifetimeService;
-	@Nullable
-	private AvatarCacheService avatarCacheService;
-	@Nullable
-	private LicenseService licenseService;
-	@Nullable
-	private BackupRestoreDataService backupRestoreDataService;
-	@Nullable
-	private GroupService groupService;
-	@Nullable
-	private GroupInviteService groupInviteService;
-	@Nullable
-	private GroupJoinResponseService groupJoinResponseService;
-	@Nullable
-	private IncomingGroupJoinRequestService incomingGroupJoinRequestService;
-	@Nullable
-	private OutgoingGroupJoinRequestService outgoingGroupJoinRequestService;
-	@Nullable
-	private LockAppService lockAppService;
-	@Nullable
-	private ActivityService activityService;
-	@Nullable
-	private ApiService apiService;
-	@Nullable
-	private ConversationService conversationService;
-	@Nullable
-	private NotificationService notificationService;
-	@Nullable
-	private SynchronizeContactsService synchronizeContactsService;
-	@Nullable
-	private SystemScreenLockService systemScreenLockService;
-
-	@Nullable
-	private IdListService blockedContactsService, excludedSyncIdentitiesService, profilePicRecipientsService;
-	@Nullable
-	private DeadlineListService mutedChatsListService, hiddenChatListService, mentionOnlyChatsListService;
-	@Nullable
-	private DistributionListService distributionListService;
-	@Nullable
-	private IncomingMessageProcessor incomingMessageProcessor;
-	@Nullable
-	private MessagePlayerService messagePlayerService = null;
-	@Nullable
-	private DownloadServiceImpl downloadService;
-	@Nullable
-	private BallotService ballotService;
-	@Nullable
-	private WallpaperService wallpaperService;
-	@Nullable
-	private ThreemaSafeService threemaSafeService;
-	@Nullable
-	private RingtoneService ringtoneService;
-	@Nullable
-	private BackupChatService backupChatService;
-	@NonNull
-	private final DatabaseServiceNew databaseServiceNew;
-	@NonNull
-	private final ModelRepositories modelRepositories;
-	@Nullable
-	private SensorService sensorService;
-	@Nullable
-	private VoipStateService voipStateService;
-	@Nullable
-	private GroupCallManager groupCallManager;
-	@Nullable
-	private SfuConnection sfuConnection;
-	@Nullable
-	private BrowserDetectionService browserDetectionService;
-	@Nullable
-	private ConversationTagServiceImpl conversationTagService;
-	@Nullable
-	private ServerAddressProviderService serverAddressProviderService;
-	@Nullable
-	private WebClientServiceManager webClientServiceManager;
-
-	@NonNull
-	private final DHSessionStoreInterface dhSessionStore;
-
-	@Nullable
-	private ForwardSecurityMessageProcessor forwardSecurityMessageProcessor;
-
-	@Nullable
-	private SymmetricEncryptionService symmetricEncryptionService;
-
-	@Nullable
-	private EmojiService emojiService;
-
-	@Nullable
-	private NonceFactory nonceFactory;
-
-	@Nullable
-	private TaskCreator taskCreator;
-
-	@Nullable
-	private DeviceJoinDataCollector deviceJoinDataCollector;
-
-	@NonNull
-	private final ConvertibleServerConnection connection;
-	@NonNull
-	private final LazyProperty<OkHttpClient> okHttpClient = new LazyProperty<>(this::createOkHttpClient);
-
-	public ServiceManager(
-		@NonNull ModelRepositories modelRepositories,
-		@NonNull DHSessionStoreInterface dhSessionStore,
-		@NonNull IdentityStore identityStore,
-		@NonNull MasterKey masterKey,
-		@NonNull CoreServiceManager coreServiceManager,
-		@NonNull UpdateSystemService updateSystemService
-	) throws ThreemaException {
-		this.cacheService = new CacheService();
-		this.coreServiceManager = coreServiceManager;
-		this.isIpv6Preferred = new LazyProperty<>(() -> getPreferenceService().isIpv6Preferred());
-		this.identityStore = identityStore;
-		this.masterKey = masterKey;
-		this.databaseServiceNew = coreServiceManager.getDatabaseService();
-		this.modelRepositories = modelRepositories;
-		this.dhSessionStore = dhSessionStore;
-		this.updateSystemService = updateSystemService;
-		// Finalize initialization of task archiver and device cookie manager before the connection
-		// is created.
-		coreServiceManager.getTaskArchiver().setServiceManager(this);
-		coreServiceManager.getDeviceCookieManager().setNotificationService(getNotificationService());
-		this.connection = createServerConnection();
-		coreServiceManager.getMultiDeviceManager().setReconnectHandle(connection);
-	}
-
-	@NonNull
-	public DatabaseContactStore getContactStore() {
-		if (this.contactStore == null) {
-			this.contactStore = new DatabaseContactStore(
-					this.getIdentityStore(),
-					this.getDHSessionStore(),
-					this.databaseServiceNew,
-					this.getServerAddressProviderService().getServerAddressProvider()
-			);
-		}
-
-		return this.contactStore;
-	}
-
-	@NonNull
-	public APIConnector getAPIConnector() {
-		if (this.apiConnector == null) {
-			try {
-				this.apiConnector = new APIConnector(
-					isIpv6Preferred.get(),
-					this.getServerAddressProviderService().getServerAddressProvider(),
-					ConfigUtils.isWorkBuild(),
-					ConfigUtils::getSSLSocketFactory
-				);
-				this.apiConnector.setVersion(ThreemaApplication.getAppVersion());
-				this.apiConnector.setLanguage(Locale.getDefault().getLanguage());
-
-				if (BuildFlavor.getCurrent().getLicenseType() == BuildFlavor.LicenseType.ONPREM) {
-					// On Premise always requires Basic authentication
-					PreferenceService preferenceService = this.getPreferenceService();
-					this.apiConnector.setAuthenticator(urlConnection -> {
-						if (preferenceService.getLicenseUsername() != null) {
-							String auth = preferenceService.getLicenseUsername() + ":" + preferenceService.getLicensePassword();
-							urlConnection.setRequestProperty("Authorization", "Basic " + Base64.encodeBytes(auth.getBytes(StandardCharsets.UTF_8)));
-						}
-					});
-				}
-			} catch (Exception e) {
-				logger.error("Exception", e);
-			}
-		}
-
-		return this.apiConnector;
-	}
-
-	/**
-	 * Start the server connection. Do not call this directly; use the LifetimeService!
-	 */
-	public void startConnection() throws ThreemaException {
-		logger.trace("startConnection");
-
-		String currentIdentity = this.identityStore.getIdentity();
-		if (currentIdentity == null || currentIdentity.isEmpty()) {
-			throw new NoIdentityException();
-		}
-
-		if(this.masterKey.isLocked()) {
-			throw new MasterKeyLockedException("master key is locked");
-		}
-
-		logger.info("Starting connection");
-		this.connection.start();
-	}
-
-	@NonNull
-	public PreferenceStoreInterface getPreferenceStore() {
-		return coreServiceManager.getPreferenceStore();
-	}
-
-	/**
-	 * Stop the connection. Do not call this directly; use the LifetimeService!
-	 */
-	public void stopConnection() throws InterruptedException {
-		logger.info("Stopping connection");
-		InterruptedException interrupted = null;
-		try {
-			this.connection.stop();
-		} catch (InterruptedException e) {
-			logger.error("Interrupted while stopping connection");
-			interrupted = e;
-		}
-
-		// Re-set interrupted flag
-		if (interrupted != null) {
-			Thread.currentThread().interrupt();
-			throw interrupted;
-		}
-	}
-
-	@WorkerThread
-	private void reconnectConnection() throws InterruptedException {
-		connection.reconnect();
-	}
-
-	@NonNull
-	public UserService getUserService() {
-		if (this.userService == null) {
-			try {
-				this.userService = new UserServiceImpl(
-						this.getContext(),
-						this.coreServiceManager.getPreferenceStore(),
-						this.getLocaleService(),
-						this.getAPIConnector(),
-						this.getIdentityStore(),
-						this.getPreferenceService());
-				// TODO(ANDR-2519): Remove when md allows fs
-				this.userService.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
-			} catch (Exception e) {
-				logger.error("Exception", e);
-			}
-		}
-
-		return this.userService;
-	}
-
-	public @NonNull ContactService getContactService() throws MasterKeyLockedException, FileSystemNotPresentException {
-		if (this.contactService == null) {
-			if(this.masterKey.isLocked()) {
-				throw new MasterKeyLockedException("master key is locked");
-			}
-			this.contactService = new ContactServiceImpl(
-				this.getContext(),
-				this.getContactStore(),
-				this.getAvatarCacheService(),
-				this.databaseServiceNew,
-				this.getDeviceService(),
-				this.getUserService(),
-				this.getIdentityStore(),
-				this.getPreferenceService(),
-				this.getBlockedContactsService(),
-				this.getProfilePicRecipientsService(),
-				this.getRingtoneService(),
-				this.getMutedChatsListService(),
-				this.getHiddenChatsListService(),
-				this.getFileService(),
-				this.cacheService,
-				this.getApiService(),
-				this.getWallpaperService(),
-				this.getLicenseService(),
-				this.getAPIConnector(),
-				this.getModelRepositories().getContacts()
-			);
-		}
-
-		return this.contactService;
-	}
-
-	@NonNull
-	public MessageService getMessageService() throws ThreemaException {
-		if (this.messageService == null) {
-			this.messageService = new MessageServiceImpl(
-					this.getContext(),
-					this.cacheService,
-					this.databaseServiceNew,
-					this.getContactService(),
-					this.getFileService(),
-					this.getIdentityStore(),
-					this.getSymmetricEncryptionService(),
-					this.getPreferenceService(),
-					this.getLockAppService(),
-					this.getBallotService(),
-					this.getGroupService(),
-					this.getApiService(),
-					this.getDownloadService(),
-					this.getHiddenChatsListService(),
-					this.getBlockedContactsService(),
-                    this.getModelRepositories().getEditHistory()
-			);
-		}
-
-		return this.messageService;
-	}
-
-	@NonNull
-	public PreferenceService getPreferenceService() {
-		if (this.preferencesService == null) {
-			this.preferencesService = new PreferenceServiceImpl(
-					this.getContext(),
-					this.coreServiceManager.getPreferenceStore()
-			);
-		}
-		return this.preferencesService;
-	}
-
-	@NonNull
-	public QRCodeService getQRCodeService() {
-		if (this.qrCodeService == null) {
-			this.qrCodeService = new QRCodeServiceImpl(this.getUserService());
-		}
-
-		return this.qrCodeService;
-	}
-
-	@NonNull
-	public FileService getFileService() throws FileSystemNotPresentException {
-		if (this.fileService == null) {
-			this.fileService = new FileServiceImpl(
-					this.getContext(),
-					this.masterKey,
-					this.getPreferenceService()
-			);
-		}
-
-		return this.fileService;
-	}
-
-	@NonNull
-	public LocaleService getLocaleService() {
-		if (this.localeService == null) {
-			this.localeService = new LocaleServiceImpl(this.getContext());
-		}
-
-		return this.localeService;
-	}
-
-	@NonNull
-	public ServerConnection getConnection() {
-		return this.connection;
-	}
-
-	@NonNull
-	public DeviceService getDeviceService() {
-		if(this.deviceService == null) {
-			this.deviceService = new DeviceServiceImpl(this.getContext());
-		}
-
-		return this.deviceService;
-	}
-
-	@NonNull
-	public LifetimeService getLifetimeService() {
-		if(this.lifetimeService == null) {
-			this.lifetimeService = new LifetimeServiceImpl(this.getContext());
-		}
-
-		return this.lifetimeService;
-	}
-
-	@NonNull
-	public AvatarCacheService getAvatarCacheService() throws FileSystemNotPresentException {
-		if(this.avatarCacheService == null) {
-			this.avatarCacheService = new AvatarCacheServiceImpl(this.getContext());
-		}
-
-		return this.avatarCacheService;
-	}
-
-	/**
-	 * @return service to backup or restore data (conversations and contacts)
-	 */
-	public @NonNull BackupRestoreDataService getBackupRestoreDataService() throws FileSystemNotPresentException {
-		if(this.backupRestoreDataService == null) {
-			this.backupRestoreDataService = new BackupRestoreDataServiceImpl(this.getFileService());
-		}
-
-		return this.backupRestoreDataService;
-	}
-
-	@NonNull
-	public LicenseService getLicenseService() throws FileSystemNotPresentException {
-		if(this.licenseService == null) {
-			switch(BuildFlavor.getCurrent().getLicenseType()) {
-				case SERIAL:
-					this.licenseService = new LicenseServiceSerial(
-							this.getAPIConnector(),
-							this.getPreferenceService(),
-							DeviceIdUtil.getDeviceId(getContext()));
-					break;
-				case GOOGLE_WORK:
-				case HMS_WORK:
-				case ONPREM:
-					this.licenseService = new LicenseServiceUser(
-						this.getAPIConnector(),
-						this.getPreferenceService(),
-						DeviceIdUtil.getDeviceId(getContext()));
-					break;
-				default:
-					this.licenseService = new LicenseService() {
-						@Override
-						public String validate(Credentials credentials) {
-							return null;
-						}
-
-						@Override
-						public String validate(boolean allowException) {
-							return null;
-						}
-						@Override
-						public boolean hasCredentials() {
-							return false;
-						}
-
-						@Override
-						public boolean isLicensed() {
-							return true;
-						}
-
-						@Override
-						public Credentials loadCredentials() {
-							return null;
-						}
-					};
-			}
-
-		}
-
-		return this.licenseService;
-	}
-
-	@NonNull
-	public LockAppService getLockAppService() {
-		if(null == this.lockAppService) {
-			this.lockAppService = new PinLockService(
-					this.getContext(),
-					this.getPreferenceService(),
-					this.getUserService()
-			);
-		}
-
-		return this.lockAppService;
-	}
-
-	@NonNull
-	public ActivityService getActivityService() {
-		if(null == this.activityService) {
-			this.activityService = new ActivityService(
-					this.getContext(),
-					this.getLockAppService(),
-					this.getPreferenceService());
-		}
-		return this.activityService;
-	}
-
-	@NonNull
-	public GroupService getGroupService() throws MasterKeyLockedException, FileSystemNotPresentException {
-		if (null == this.groupService) {
-			this.groupService = new GroupServiceImpl(
-				this.getContext(),
-				this.cacheService,
-				this.getUserService(),
-				this.getContactService(),
-				this.databaseServiceNew,
-				this.getAvatarCacheService(),
-				this.getFileService(),
-				this.getWallpaperService(),
-				this.getMutedChatsListService(),
-				this.getHiddenChatsListService(),
-				this.getRingtoneService(),
-				this.getConversationTagService(),
-				this
-			);
-		}
-		return this.groupService;
-	}
-
-	@NonNull
-	public GroupInviteService getGroupInviteService() throws FileSystemNotPresentException, MasterKeyLockedException {
-		if (this.groupInviteService == null) {
-			this.groupInviteService = new GroupInviteServiceImpl(
-				this.getUserService(),
-				this.getGroupService(),
-				this.getDatabaseServiceNew()
-			);
-		}
-		return this.groupInviteService;
-	}
-
-	@NonNull
-	public GroupJoinResponseService getGroupJoinResponseService() {
-		if (this.groupJoinResponseService == null) {
-			this.groupJoinResponseService = new GroupJoinResponseServiceImpl(
-				this.getDatabaseServiceNew()
-			);
-		}
-		return this.groupJoinResponseService;
-	}
-
-	@NonNull
-	public IncomingGroupJoinRequestService getIncomingGroupJoinRequestService() throws FileSystemNotPresentException, MasterKeyLockedException {
-		if (this.incomingGroupJoinRequestService == null) {
-			this.incomingGroupJoinRequestService = new IncomingGroupJoinRequestServiceImpl(
-				this.getGroupJoinResponseService(),
-				this.getGroupService(),
-				this.getUserService(),
-				this.databaseServiceNew
-			);
-		}
-		return this.incomingGroupJoinRequestService;
-	}
-
-	@NonNull
-	public OutgoingGroupJoinRequestService getOutgoingGroupJoinRequestService() {
-		if (this.outgoingGroupJoinRequestService == null) {
-			this.outgoingGroupJoinRequestService = new OutgoingGroupJoinRequestServiceImpl(
-				this.getDatabaseServiceNew()
-			);
-		}
-		return this.outgoingGroupJoinRequestService;
-	}
-
-	@NonNull
-	public ApiService getApiService() {
-		if(null == this.apiService) {
-			this.apiService = new ApiServiceImpl(
-				ThreemaApplication.getAppVersion(),
-				isIpv6Preferred.get(),
-				this.getAPIConnector(),
-				new AuthTokenStore(),
-				this.getServerAddressProviderService().getServerAddressProvider()
-			);
-		}
-		return this.apiService;
-	}
-
-	@NonNull
-	public DistributionListService getDistributionListService() throws MasterKeyLockedException, NoIdentityException, FileSystemNotPresentException {
-		if(null == this.distributionListService) {
-			this.distributionListService = new DistributionListServiceImpl(
-				this.getContext(),
-				this.getAvatarCacheService(),
-				this.databaseServiceNew,
-				this.getContactService(),
-				this.getConversationTagService()
-			);
-		}
-
-		return this.distributionListService;
-	}
-
-	@NonNull
-	public ConversationTagService getConversationTagService() {
-		if (this.conversationTagService == null) {
-			this.conversationTagService = new ConversationTagServiceImpl(this.databaseServiceNew);
-		}
-
-		return this.conversationTagService;
-	}
-
-	@NonNull
-	public ConversationService getConversationService() throws ThreemaException {
-		if(null == this.conversationService) {
-			this.conversationService = new ConversationServiceImpl(
-				this.getContext(),
-				this.cacheService,
-				this.databaseServiceNew,
-				this.getContactService(),
-				this.getGroupService(),
-				this.getDistributionListService(),
-				this.getMessageService(),
-				this.getHiddenChatsListService(),
-				this.getBlockedContactsService(),
-				this.getConversationTagService()
-			);
-		}
-
-		return this.conversationService;
-	}
-
-	@NonNull
-	public ServerAddressProviderService getServerAddressProviderService() {
-		if(null == this.serverAddressProviderService) {
-			this.serverAddressProviderService = new ServerAddressProviderServiceImpl(this.getPreferenceService());
-		}
-
-		return this.serverAddressProviderService;
-	}
-
-	@NonNull
-	public NotificationService getNotificationService() {
-		if(this.notificationService == null) {
-			this.notificationService = new NotificationServiceImpl(
-					this.getContext(),
-					this.getLockAppService(),
-					this.getHiddenChatsListService(),
-					this.getPreferenceService(),
-					this.getRingtoneService()
-			);
-		}
-		return this.notificationService;
-	}
-
-	@NonNull
-	public SynchronizeContactsService getSynchronizeContactsService() throws MasterKeyLockedException, FileSystemNotPresentException {
-		if(this.synchronizeContactsService == null) {
-			this.synchronizeContactsService = new SynchronizeContactsServiceImpl(
-				this.getContext(),
-				this.getAPIConnector(),
-				this.getContactService(),
-				this.getModelRepositories().getContacts(),
-				this.getUserService(),
-				this.getLocaleService(),
-				this.getExcludedSyncIdentitiesService(),
-				this.getPreferenceService(),
-				this.getDeviceService(),
-				this.getFileService(),
-				this.getIdentityStore(),
-				this.getBlockedContactsService(),
-				this.getApiService()
-			);
-		}
-
-		return this.synchronizeContactsService;
-	}
-
-	@NonNull
-	public IdListService getBlockedContactsService() {
-		if(this.blockedContactsService == null) {
+    private static final Logger logger = LoggingUtil.getThreemaLogger("ServiceManager");
+
+    @NonNull
+    private final CoreServiceManager coreServiceManager;
+    @NonNull
+    private final Supplier<Boolean> isIpv6Preferred;
+    @NonNull
+    private final MasterKey masterKey;
+    @NonNull
+    private final UpdateSystemService updateSystemService;
+    @NonNull
+    private final CacheService cacheService;
+    @Nullable
+    private DatabaseContactStore contactStore;
+    @Nullable
+    private APIConnector apiConnector;
+    @Nullable
+    private ContactService contactService;
+    @Nullable
+    private UserService userService;
+    @Nullable
+    private MessageService messageService;
+    @Nullable
+    private QRCodeService qrCodeService;
+    @Nullable
+    private FileService fileService;
+    @Nullable
+    private PreferenceService preferencesService;
+    @Nullable
+    private LocaleService localeService;
+    @Nullable
+    private DeviceService deviceService;
+    @Nullable
+    private LifetimeService lifetimeService;
+    @Nullable
+    private AvatarCacheService avatarCacheService;
+    @Nullable
+    private LicenseService licenseService;
+    @Nullable
+    private BackupRestoreDataService backupRestoreDataService;
+    @Nullable
+    private GroupService groupService;
+    @Nullable
+    private GroupInviteService groupInviteService;
+    @Nullable
+    private GroupJoinResponseService groupJoinResponseService;
+    @Nullable
+    private IncomingGroupJoinRequestService incomingGroupJoinRequestService;
+    @Nullable
+    private OutgoingGroupJoinRequestService outgoingGroupJoinRequestService;
+    @Nullable
+    private LockAppService lockAppService;
+    @Nullable
+    private ActivityService activityService;
+    @Nullable
+    private ApiService apiService;
+    @Nullable
+    private ConversationService conversationService;
+    @Nullable
+    private NotificationService notificationService;
+    @Nullable
+    private SynchronizeContactsService synchronizeContactsService;
+    @Nullable
+    private SystemScreenLockService systemScreenLockService;
+
+    @Nullable
+    private IdListService blockedContactsService, excludedSyncIdentitiesService, profilePicRecipientsService;
+    @Nullable
+    private DeadlineListService mutedChatsListService, hiddenChatListService, mentionOnlyChatsListService;
+    @Nullable
+    private DistributionListService distributionListService;
+    @Nullable
+    private IncomingMessageProcessor incomingMessageProcessor;
+    @Nullable
+    private MessagePlayerService messagePlayerService = null;
+    @Nullable
+    private DownloadServiceImpl downloadService;
+    @Nullable
+    private BallotService ballotService;
+    @Nullable
+    private WallpaperService wallpaperService;
+    @Nullable
+    private ThreemaSafeService threemaSafeService;
+    @Nullable
+    private RingtoneService ringtoneService;
+    @Nullable
+    private BackupChatService backupChatService;
+    @NonNull
+    private final DatabaseServiceNew databaseServiceNew;
+    @NonNull
+    private final ModelRepositories modelRepositories;
+    @Nullable
+    private SensorService sensorService;
+    @Nullable
+    private VoipStateService voipStateService;
+    @Nullable
+    private GroupCallManager groupCallManager;
+    @Nullable
+    private SfuConnection sfuConnection;
+    @Nullable
+    private BrowserDetectionService browserDetectionService;
+    @Nullable
+    private ConversationTagServiceImpl conversationTagService;
+    @Nullable
+    private ServerAddressProviderService serverAddressProviderService;
+    @Nullable
+    private WebClientServiceManager webClientServiceManager;
+
+    @NonNull
+    private final DHSessionStoreInterface dhSessionStore;
+
+    @Nullable
+    private ForwardSecurityMessageProcessor forwardSecurityMessageProcessor;
+
+    @Nullable
+    private SymmetricEncryptionService symmetricEncryptionService;
+
+    @Nullable
+    private EmojiService emojiService;
+
+    @Nullable
+    private TaskCreator taskCreator;
+
+    @NonNull
+    private final ConvertibleServerConnection connection;
+
+    @NonNull
+    private final LazyProperty<OkHttpClient> okHttpClient = new LazyProperty<>(this::createOkHttpClient);
+
+    public ServiceManager(
+        @NonNull ModelRepositories modelRepositories,
+        @NonNull DHSessionStoreInterface dhSessionStore,
+        @NonNull MasterKey masterKey,
+        @NonNull CoreServiceManagerImpl coreServiceManager,
+        @NonNull UpdateSystemService updateSystemService
+    ) throws ThreemaException {
+        this.cacheService = new CacheService();
+        this.coreServiceManager = coreServiceManager;
+        this.isIpv6Preferred = new LazyProperty<>(() -> getPreferenceService().isIpv6Preferred());
+        this.masterKey = masterKey;
+        this.databaseServiceNew = coreServiceManager.getDatabaseService();
+        this.modelRepositories = modelRepositories;
+        this.dhSessionStore = dhSessionStore;
+        this.updateSystemService = updateSystemService;
+        // Finalize initialization of task archiver and device cookie manager before the connection
+        // is created.
+        coreServiceManager.getTaskArchiver().setServiceManager(this);
+        coreServiceManager.getDeviceCookieManager().setNotificationService(getNotificationService());
+        this.connection = createServerConnection();
+        coreServiceManager.getMultiDeviceManager().setReconnectHandle(connection);
+    }
+
+    @NonNull
+    public DatabaseContactStore getContactStore() {
+        if (this.contactStore == null) {
+            this.contactStore = new DatabaseContactStore(
+                this.databaseServiceNew,
+                this.getServerAddressProviderService().getServerAddressProvider()
+            );
+        }
+
+        return this.contactStore;
+    }
+
+    @NonNull
+    public APIConnector getAPIConnector() {
+        if (this.apiConnector == null) {
+            try {
+                this.apiConnector = new APIConnector(
+                    isIpv6Preferred.get(),
+                    this.getServerAddressProviderService().getServerAddressProvider(),
+                    ConfigUtils.isWorkBuild(),
+                    ConfigUtils::getSSLSocketFactory
+                );
+                this.apiConnector.setVersion(ThreemaApplication.getAppVersion());
+                this.apiConnector.setLanguage(Locale.getDefault().getLanguage());
+
+                if (BuildFlavor.getCurrent().getLicenseType() == BuildFlavor.LicenseType.ONPREM) {
+                    // On Premise always requires Basic authentication
+                    PreferenceService preferenceService = this.getPreferenceService();
+                    this.apiConnector.setAuthenticator(urlConnection -> {
+                        if (preferenceService.getLicenseUsername() != null) {
+                            String auth = preferenceService.getLicenseUsername() + ":" + preferenceService.getLicensePassword();
+                            urlConnection.setRequestProperty("Authorization", "Basic " + Base64.encodeBytes(auth.getBytes(StandardCharsets.UTF_8)));
+                        }
+                    });
+                }
+            } catch (Exception e) {
+                logger.error("Exception", e);
+            }
+        }
+
+        return this.apiConnector;
+    }
+
+    /**
+     * Start the server connection. Do not call this directly; use the LifetimeService!
+     */
+    public void startConnection() throws ThreemaException {
+        logger.trace("startConnection");
+
+        String currentIdentity = this.coreServiceManager.getIdentityStore().getIdentity();
+        if (currentIdentity == null || currentIdentity.isEmpty()) {
+            throw new NoIdentityException();
+        }
+
+        if (this.masterKey.isLocked()) {
+            throw new MasterKeyLockedException("master key is locked");
+        }
+
+        logger.info("Starting connection");
+        this.connection.start();
+    }
+
+    @NonNull
+    public PreferenceStoreInterface getPreferenceStore() {
+        return coreServiceManager.getPreferenceStore();
+    }
+
+    /**
+     * Stop the connection. Do not call this directly; use the LifetimeService!
+     */
+    public void stopConnection() throws InterruptedException {
+        logger.info("Stopping connection");
+        InterruptedException interrupted = null;
+        try {
+            this.connection.stop();
+        } catch (InterruptedException e) {
+            logger.error("Interrupted while stopping connection");
+            interrupted = e;
+        }
+
+        // Re-set interrupted flag
+        if (interrupted != null) {
+            Thread.currentThread().interrupt();
+            throw interrupted;
+        }
+    }
+
+    @WorkerThread
+    private void reconnectConnection() throws InterruptedException {
+        connection.reconnect();
+    }
+
+    @NonNull
+    public UserService getUserService() {
+        if (this.userService == null) {
+            try {
+                this.userService = new UserServiceImpl(
+                    this.getContext(),
+                    this.coreServiceManager.getPreferenceStore(),
+                    this.getLocaleService(),
+                    this.getAPIConnector(),
+                    this.getApiService(),
+                    this.getFileService(),
+                    this.getIdentityStore(),
+                    this.getPreferenceService(),
+                    this.getTaskManager(),
+                    this.getTaskCreator(),
+                    this.getMultiDeviceManager()
+                );
+                // TODO(ANDR-2519): Remove when md allows fs
+                this.userService.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
+            } catch (Exception e) {
+                logger.error("Exception", e);
+            }
+        }
+
+        return this.userService;
+    }
+
+    public @NonNull ContactService getContactService() throws MasterKeyLockedException, FileSystemNotPresentException {
+        if (this.contactService == null) {
+            if (this.masterKey.isLocked()) {
+                throw new MasterKeyLockedException("master key is locked");
+            }
+            this.contactService = new ContactServiceImpl(
+                this.getContext(),
+                this.getContactStore(),
+                this.getAvatarCacheService(),
+                this.databaseServiceNew,
+                this.getUserService(),
+                this.getIdentityStore(),
+                this.getPreferenceService(),
+                this.getBlockedContactsService(),
+                this.getProfilePicRecipientsService(),
+                this.getFileService(),
+                this.cacheService,
+                this.getApiService(),
+                this.getLicenseService(),
+                this.getAPIConnector(),
+                this.getModelRepositories().getContacts(),
+                this.getTaskCreator(),
+                this.getMultiDeviceManager()
+            );
+        }
+
+        return this.contactService;
+    }
+
+    @NonNull
+    public MessageService getMessageService() throws ThreemaException {
+        if (this.messageService == null) {
+            this.messageService = new MessageServiceImpl(
+                this.getContext(),
+                this.cacheService,
+                this.databaseServiceNew,
+                this.getContactService(),
+                this.getFileService(),
+                this.getIdentityStore(),
+                this.getSymmetricEncryptionService(),
+                this.getPreferenceService(),
+                this.getLockAppService(),
+                this.getBallotService(),
+                this.getGroupService(),
+                this.getApiService(),
+                this.getDownloadService(),
+                this.getHiddenChatsListService(),
+                this.getBlockedContactsService(),
+                this.getModelRepositories().getEditHistory(),
+                this.getMultiDeviceManager()
+            );
+        }
+
+        return this.messageService;
+    }
+
+    @NonNull
+    public PreferenceService getPreferenceService() {
+        if (this.preferencesService == null) {
+            this.preferencesService = new PreferenceServiceImpl(
+                this.getContext(),
+                this.coreServiceManager.getPreferenceStore()
+            );
+        }
+        return this.preferencesService;
+    }
+
+    @NonNull
+    public QRCodeService getQRCodeService() {
+        if (this.qrCodeService == null) {
+            this.qrCodeService = new QRCodeServiceImpl(this.getUserService());
+        }
+
+        return this.qrCodeService;
+    }
+
+    @NonNull
+    public FileService getFileService() throws FileSystemNotPresentException {
+        if (this.fileService == null) {
+            this.fileService = new FileServiceImpl(
+                this.getContext(),
+                this.masterKey,
+                this.getPreferenceService(),
+                this.getAvatarCacheService()
+            );
+        }
+
+        return this.fileService;
+    }
+
+    @NonNull
+    public LocaleService getLocaleService() {
+        if (this.localeService == null) {
+            this.localeService = new LocaleServiceImpl(this.getContext());
+        }
+
+        return this.localeService;
+    }
+
+    @NonNull
+    public ServerConnection getConnection() {
+        return this.connection;
+    }
+
+    @NonNull
+    public DeviceService getDeviceService() {
+        if (this.deviceService == null) {
+            this.deviceService = new DeviceServiceImpl(this.getContext());
+        }
+
+        return this.deviceService;
+    }
+
+    @NonNull
+    public LifetimeService getLifetimeService() {
+        if (this.lifetimeService == null) {
+            this.lifetimeService = new LifetimeServiceImpl(this.getContext());
+        }
+
+        return this.lifetimeService;
+    }
+
+    @NonNull
+    public AvatarCacheService getAvatarCacheService() throws FileSystemNotPresentException {
+        if (this.avatarCacheService == null) {
+            this.avatarCacheService = new AvatarCacheServiceImpl(this.getContext());
+        }
+
+        return this.avatarCacheService;
+    }
+
+    /**
+     * @return service to backup or restore data (conversations and contacts)
+     */
+    public @NonNull BackupRestoreDataService getBackupRestoreDataService() throws FileSystemNotPresentException {
+        if (this.backupRestoreDataService == null) {
+            this.backupRestoreDataService = new BackupRestoreDataServiceImpl(this.getFileService());
+        }
+
+        return this.backupRestoreDataService;
+    }
+
+    @NonNull
+    public LicenseService getLicenseService() throws FileSystemNotPresentException {
+        if (this.licenseService == null) {
+            switch (BuildFlavor.getCurrent().getLicenseType()) {
+                case SERIAL:
+                    this.licenseService = new LicenseServiceSerial(
+                        this.getAPIConnector(),
+                        this.getPreferenceService(),
+                        DeviceIdUtil.getDeviceId(getContext()));
+                    break;
+                case GOOGLE_WORK:
+                case HMS_WORK:
+                case ONPREM:
+                    this.licenseService = new LicenseServiceUser(
+                        this.getAPIConnector(),
+                        this.getPreferenceService(),
+                        DeviceIdUtil.getDeviceId(getContext()));
+                    break;
+                default:
+                    this.licenseService = new LicenseService() {
+                        @Override
+                        public String validate(Credentials credentials) {
+                            return null;
+                        }
+
+                        @Override
+                        public String validate(boolean allowException) {
+                            return null;
+                        }
+
+                        @Override
+                        public boolean hasCredentials() {
+                            return false;
+                        }
+
+                        @Override
+                        public boolean isLicensed() {
+                            return true;
+                        }
+
+                        @Override
+                        public Credentials loadCredentials() {
+                            return null;
+                        }
+                    };
+            }
+
+        }
+
+        return this.licenseService;
+    }
+
+    @NonNull
+    public LockAppService getLockAppService() {
+        if (null == this.lockAppService) {
+            this.lockAppService = new PinLockService(
+                this.getContext(),
+                this.getPreferenceService(),
+                this.getUserService()
+            );
+        }
+
+        return this.lockAppService;
+    }
+
+    @NonNull
+    public ActivityService getActivityService() {
+        if (null == this.activityService) {
+            this.activityService = new ActivityService(
+                this.getContext(),
+                this.getLockAppService(),
+                this.getPreferenceService());
+        }
+        return this.activityService;
+    }
+
+    @NonNull
+    public GroupService getGroupService() throws MasterKeyLockedException, FileSystemNotPresentException {
+        if (null == this.groupService) {
+            this.groupService = new GroupServiceImpl(
+                this.getContext(),
+                this.cacheService,
+                this.getUserService(),
+                this.getContactService(),
+                this.databaseServiceNew,
+                this.getAvatarCacheService(),
+                this.getFileService(),
+                this.getWallpaperService(),
+                this.getMutedChatsListService(),
+                this.getHiddenChatsListService(),
+                this.getRingtoneService(),
+                this.getConversationTagService(),
+                this
+            );
+        }
+        return this.groupService;
+    }
+
+    @NonNull
+    public GroupInviteService getGroupInviteService() throws FileSystemNotPresentException, MasterKeyLockedException {
+        if (this.groupInviteService == null) {
+            this.groupInviteService = new GroupInviteServiceImpl(
+                this.getUserService(),
+                this.getGroupService(),
+                this.getDatabaseServiceNew()
+            );
+        }
+        return this.groupInviteService;
+    }
+
+    @NonNull
+    public GroupJoinResponseService getGroupJoinResponseService() {
+        if (this.groupJoinResponseService == null) {
+            this.groupJoinResponseService = new GroupJoinResponseServiceImpl(
+                this.getDatabaseServiceNew()
+            );
+        }
+        return this.groupJoinResponseService;
+    }
+
+    @NonNull
+    public IncomingGroupJoinRequestService getIncomingGroupJoinRequestService() throws FileSystemNotPresentException, MasterKeyLockedException {
+        if (this.incomingGroupJoinRequestService == null) {
+            this.incomingGroupJoinRequestService = new IncomingGroupJoinRequestServiceImpl(
+                this.getGroupJoinResponseService(),
+                this.getGroupService(),
+                this.getUserService(),
+                this.databaseServiceNew
+            );
+        }
+        return this.incomingGroupJoinRequestService;
+    }
+
+    @NonNull
+    public OutgoingGroupJoinRequestService getOutgoingGroupJoinRequestService() {
+        if (this.outgoingGroupJoinRequestService == null) {
+            this.outgoingGroupJoinRequestService = new OutgoingGroupJoinRequestServiceImpl(
+                this.getDatabaseServiceNew()
+            );
+        }
+        return this.outgoingGroupJoinRequestService;
+    }
+
+    @NonNull
+    public ApiService getApiService() {
+        if (null == this.apiService) {
+            this.apiService = new ApiServiceImpl(
+                ThreemaApplication.getAppVersion(),
+                isIpv6Preferred.get(),
+                this.getAPIConnector(),
+                new AuthTokenStore(),
+                this.getServerAddressProviderService().getServerAddressProvider(),
+                this.getMultiDeviceManager(),
+                this.getOkHttpClient()
+            );
+        }
+        return this.apiService;
+    }
+
+    @NonNull
+    public DistributionListService getDistributionListService() throws MasterKeyLockedException, NoIdentityException, FileSystemNotPresentException {
+        if (null == this.distributionListService) {
+            this.distributionListService = new DistributionListServiceImpl(
+                this.getContext(),
+                this.getAvatarCacheService(),
+                this.databaseServiceNew,
+                this.getContactService(),
+                this.getConversationTagService()
+            );
+        }
+
+        return this.distributionListService;
+    }
+
+    @NonNull
+    public ConversationTagService getConversationTagService() {
+        if (this.conversationTagService == null) {
+            this.conversationTagService = new ConversationTagServiceImpl(this.databaseServiceNew);
+        }
+
+        return this.conversationTagService;
+    }
+
+    @NonNull
+    public ConversationService getConversationService() throws ThreemaException {
+        if (null == this.conversationService) {
+            this.conversationService = new ConversationServiceImpl(
+                this.getContext(),
+                this.cacheService,
+                this.databaseServiceNew,
+                this.getContactService(),
+                this.getGroupService(),
+                this.getDistributionListService(),
+                this.getMessageService(),
+                this.getHiddenChatsListService(),
+                this.getBlockedContactsService(),
+                this.getConversationTagService()
+            );
+        }
+
+        return this.conversationService;
+    }
+
+    @NonNull
+    public ServerAddressProviderService getServerAddressProviderService() {
+        if (null == this.serverAddressProviderService) {
+            this.serverAddressProviderService = new ServerAddressProviderServiceImpl(this.getPreferenceService());
+        }
+
+        return this.serverAddressProviderService;
+    }
+
+    @NonNull
+    public NotificationService getNotificationService() {
+        if (this.notificationService == null) {
+            this.notificationService = new NotificationServiceImpl(
+                this.getContext(),
+                this.getLockAppService(),
+                this.getHiddenChatsListService(),
+                this.getPreferenceService(),
+                this.getRingtoneService()
+            );
+        }
+        return this.notificationService;
+    }
+
+    @NonNull
+    public SynchronizeContactsService getSynchronizeContactsService() throws MasterKeyLockedException, FileSystemNotPresentException {
+        if (this.synchronizeContactsService == null) {
+            this.synchronizeContactsService = new SynchronizeContactsServiceImpl(
+                this.getContext(),
+                this.getAPIConnector(),
+                this.getContactService(),
+                this.getModelRepositories().getContacts(),
+                this.getUserService(),
+                this.getLocaleService(),
+                this.getExcludedSyncIdentitiesService(),
+                this.getPreferenceService(),
+                this.getDeviceService(),
+                this.getFileService(),
+                this.getIdentityStore(),
+                this.getBlockedContactsService(),
+                this.getApiService()
+            );
+        }
+
+        return this.synchronizeContactsService;
+    }
+
+    @NonNull
+    public IdListService getBlockedContactsService() {
+        if (this.blockedContactsService == null) {
             // Keep the uniqueListName `identity_list_blacklist` to avoid a migration of the key in the preferences
-			this.blockedContactsService = new IdListServiceImpl("identity_list_blacklist", this.getPreferenceService());
-		}
-		return this.blockedContactsService;
-	}
-
-	@NonNull
-	public DeadlineListService getMutedChatsListService() {
-		if(this.mutedChatsListService == null) {
-			this.mutedChatsListService = new DeadlineListServiceImpl("list_muted_chats", this.getPreferenceService());
-		}
-		return this.mutedChatsListService;
-	}
-
-	@NonNull
-	public DeadlineListService getHiddenChatsListService() {
-		if(this.hiddenChatListService == null) {
-			this.hiddenChatListService = new DeadlineListServiceImpl("list_hidden_chats", this.getPreferenceService());
-		}
-		return this.hiddenChatListService;
-	}
-
-	@NonNull
-	public DeadlineListService getMentionOnlyChatsListService() {
-		if(this.mentionOnlyChatsListService == null) {
-			this.mentionOnlyChatsListService = new DeadlineListServiceImpl("list_mention_only", this.getPreferenceService());
-		}
-		return this.mentionOnlyChatsListService;
-	}
-
-	@NonNull
-	public IdListService getExcludedSyncIdentitiesService() {
-		if(this.excludedSyncIdentitiesService == null) {
-			this.excludedSyncIdentitiesService = new IdListServiceImpl("identity_list_sync_excluded", this.getPreferenceService());
-		}
-		return this.excludedSyncIdentitiesService;
-	}
-
-	@NonNull
-	public UpdateSystemService getUpdateSystemService() {
-		return this.updateSystemService;
-	}
-
-	@NonNull
-	public MessagePlayerService getMessagePlayerService() throws ThreemaException {
-		if(this.messagePlayerService == null) {
-			this.messagePlayerService = new MessagePlayerServiceImpl(
-					getContext(),
-					this.getMessageService(),
-					this.getFileService(),
-					this.getPreferenceService(),
-					this.getHiddenChatsListService()
-			);
-		}
-		return this.messagePlayerService;
-	}
-
-	@NonNull
-	public DownloadService getDownloadService() throws FileSystemNotPresentException {
-		if (this.downloadService == null) {
-			this.downloadService = new DownloadServiceImpl(
-					this.getContext(),
-					this.getFileService(),
-					this.getApiService()
-			);
-		}
-		return this.downloadService;
-	}
-
-	@NonNull
-	public BallotService getBallotService() throws NoIdentityException, MasterKeyLockedException, FileSystemNotPresentException {
-		if(this.ballotService == null) {
-			this.ballotService = new BallotServiceImpl(
-					this.cacheService.getBallotModelCache(),
-					this.cacheService.getLinkBallotModelCache(),
-					this.databaseServiceNew,
-					this.getUserService(),
-					this.getGroupService(),
-					this.getContactService(),
-					this);
-		}
-		return this.ballotService;
-	}
-
-	@NonNull
-	public WallpaperService getWallpaperService() throws FileSystemNotPresentException {
-		if(this.wallpaperService == null) {
-			this.wallpaperService = new WallpaperServiceImpl(this.getContext(),
-					this.getFileService(),
-					this.getPreferenceService(),
-					this.masterKey
-			);
-		}
-
-		return this.wallpaperService;
-	}
-
-	public @NonNull ThreemaSafeService getThreemaSafeService() throws FileSystemNotPresentException, MasterKeyLockedException, NoIdentityException {
-		if (this.threemaSafeService == null) {
-			this.threemaSafeService = new ThreemaSafeServiceImpl(
-				this.getContext(),
-				this.getPreferenceService(),
-				this.getUserService(),
-				this.getContactService(),
-				this.getGroupService(),
-				this.getDistributionListService(),
-				this.getLocaleService(),
-				this.getFileService(),
-				this.getBlockedContactsService(),
-				this.getExcludedSyncIdentitiesService(),
-				this.getProfilePicRecipientsService(),
-				this.getDatabaseServiceNew(),
-				this.getIdentityStore(),
-				this.getApiService(),
-				this.getAPIConnector(),
-				this.getHiddenChatsListService(),
-				this.getServerAddressProviderService().getServerAddressProvider(),
-				this.getPreferenceStore()
-			);
-		}
-		return this.threemaSafeService;
-	}
-
-	@NonNull
-	public Context getContext() {
-		return ThreemaApplication.getAppContext();
-	}
-
-	@NonNull
-	public IdentityStore getIdentityStore() {
-		return this.identityStore;
-	}
-
-	@NonNull
-	public RingtoneService getRingtoneService() {
-		if(this.ringtoneService == null) {
-			this.ringtoneService = new RingtoneServiceImpl(this.getPreferenceService());
-		}
-
-		return this.ringtoneService;
-	}
-
-	@NonNull
-	public BackupChatService getBackupChatService() throws ThreemaException {
-		if (this.backupChatService == null) {
-			this.backupChatService = new BackupChatServiceImpl(
-					this.getContext(),
-					this.getFileService(),
-					this.getMessageService(),
-					this.getContactService()
-			);
-		}
-
-		return this.backupChatService;
-	}
-
-	@NonNull
-	public SystemScreenLockService getScreenLockService() {
-		if(this.systemScreenLockService == null) {
-			this.systemScreenLockService = new SystemScreenLockServiceImpl(
-					this.getContext(),
-					this.getLockAppService(),
-					this.getPreferenceService()
-			);
-		}
-		return this.systemScreenLockService;
-	}
-
-	@NonNull
-	public SensorService getSensorService() {
-		if (this.sensorService == null) {
-			this.sensorService = new SensorServiceImpl(this.getContext());
-		}
-		return this.sensorService;
-	}
-
-	@NonNull
-	public WebClientServiceManager getWebClientServiceManager() throws ThreemaException {
-		if (this.webClientServiceManager == null) {
-			this.webClientServiceManager = new WebClientServiceManager(new ServicesContainer(
-				this.getContext().getApplicationContext(),
-				this.getLifetimeService(),
-				this.getContactService(),
-				this.getGroupService(),
-				this.getDistributionListService(),
-				this.getConversationService(),
-				this.getConversationTagService(),
-				this.getMessageService(),
-				this.getNotificationService(),
-				this.databaseServiceNew,
-				this.getBlockedContactsService(),
-				this.getPreferenceService(),
-				this.getUserService(),
-				this.getHiddenChatsListService(),
-				this.getFileService(),
-				this.getSynchronizeContactsService(),
-				this.getLicenseService()
-			));
-		}
-		return this.webClientServiceManager;
-	}
-
-	@NonNull
-	public BrowserDetectionService getBrowserDetectionService() {
-		if (this.browserDetectionService == null) {
-			this.browserDetectionService = new BrowserDetectionServiceImpl();
-		}
-		return this.browserDetectionService;
-	}
-
-	@NonNull
-	public IdListService getProfilePicRecipientsService() {
-		if(this.profilePicRecipientsService == null) {
-			this.profilePicRecipientsService = new IdListServiceImpl("identity_list_profilepics", this.getPreferenceService());
-		}
-		return this.profilePicRecipientsService;
-	}
-
-	@NonNull
-	public VoipStateService getVoipStateService() throws ThreemaException {
-		if (this.voipStateService == null) {
-			this.voipStateService = new VoipStateService(
-					this.getContactService(),
-					this.getRingtoneService(),
-					this.getPreferenceService(),
-					this.getLifetimeService(),
-					this.getContext()
-			);
-		}
-		return this.voipStateService;
-	}
-
-	@NonNull
-	public DatabaseServiceNew getDatabaseServiceNew() {
-		return this.databaseServiceNew;
-	}
-
-	@NonNull
-	public ModelRepositories getModelRepositories() {
-		return this.modelRepositories;
-	}
-
-	@NonNull
-	public DHSessionStoreInterface getDHSessionStore() {
-		return this.dhSessionStore;
-	}
-
-	@NonNull
-	public ForwardSecurityMessageProcessor getForwardSecurityMessageProcessor() throws ThreemaException {
-		if (this.forwardSecurityMessageProcessor == null) {
-			this.forwardSecurityMessageProcessor = new ForwardSecurityMessageProcessor(
-				this.getDHSessionStore(),
-				this.getContactStore(),
-				this.getIdentityStore(),
-				this.getNonceFactory(),
-				new ForwardSecurityStatusSender(
-					this.getContactService(),
-					this.getMessageService(),
-					this.getAPIConnector()
-				)
-			);
-			// TODO(ANDR-2519): Remove when md allows fs
-			forwardSecurityMessageProcessor.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
-		}
-		return this.forwardSecurityMessageProcessor;
-	}
-
-	@NonNull
-	public SymmetricEncryptionService getSymmetricEncryptionService() {
-		if (symmetricEncryptionService == null) {
-			symmetricEncryptionService = new SymmetricEncryptionService();
-		}
-		return symmetricEncryptionService;
-	}
-
-	@NonNull
-	public EmojiService getEmojiService() {
-		if (emojiService == null) {
-			EmojiSearchIndex searchIndex = new EmojiSearchIndex(
-				getContext().getApplicationContext(),
-				getPreferenceService()
-			);
-			emojiService = new EmojiService(
-				getPreferenceService(),
-				searchIndex,
-				new EmojiRecent(getPreferenceService())
-			);
-		}
-		return emojiService;
-	}
-
-	@NonNull
-	public GroupCallManager getGroupCallManager() throws ThreemaException {
-		if (groupCallManager == null) {
-			groupCallManager = new GroupCallManagerImpl(
-				getContext().getApplicationContext(),
-				this,
-				getDatabaseServiceNew(),
-				getGroupService(),
-				getContactService(),
-				getPreferenceService(),
-				getMessageService(),
-				getNotificationService(),
-				getSfuConnection()
-			);
-		}
-		return groupCallManager;
-	}
-
-	@NonNull
-	public SfuConnection getSfuConnection() {
-		if (sfuConnection == null) {
-			sfuConnection = new SfuConnectionImpl(
-				getAPIConnector(),
-				getIdentityStore(),
-				ThreemaApplication.getAppVersion()
-			);
-		}
-		return sfuConnection;
-	}
-
-	public @NonNull NonceFactory getNonceFactory() {
-		if (nonceFactory == null) {
-			DatabaseNonceStore databaseNonceStore = new DatabaseNonceStore(getContext(), identityStore);
-			databaseNonceStore.executeNull();
-			logger.info("Nonce count: " + databaseNonceStore.getCount());
-			nonceFactory = new NonceFactory(databaseNonceStore);
-		}
-		return nonceFactory;
-	}
-
-	private @NonNull IncomingMessageProcessor getIncomingMessageProcessor() throws ThreemaException {
-		if (this.incomingMessageProcessor == null) {
-			this.incomingMessageProcessor = new IncomingMessageProcessorImpl(
-				getMessageService(),
-				getNonceFactory(),
-				getForwardSecurityMessageProcessor(),
-				getContactService(),
-				getContactStore(),
-				getIdentityStore(),
-				getBlockedContactsService(),
-				getPreferenceService(),
-				this
-			);
-		}
-		return this.incomingMessageProcessor;
-	}
-
-	public @NonNull TaskManager getTaskManager() {
-		return this.coreServiceManager.getTaskManager();
-	}
-
-	public @NonNull TaskCreator getTaskCreator() {
-		if (this.taskCreator == null) {
-			this.taskCreator = new TaskCreator(this);
-		}
-		return this.taskCreator;
-	}
-
-	@NonNull
-	public MultiDeviceManager getMultiDeviceManager() {
-		return this.coreServiceManager.getMultiDeviceManager();
-	}
-
-	@NonNull
-	public DeviceJoinDataCollector getDeviceJoinDataCollector() {
-		if (deviceJoinDataCollector == null) {
-			deviceJoinDataCollector = new DeviceJoinDataCollector(this);
-			return deviceJoinDataCollector;
-		}
-		return deviceJoinDataCollector;
-	}
-
-	/**
-	 * Get a task handle. This task handle can be used to send messages.
-	 *
-	 * @deprecated Note that we should only be able to send messages inside a task (where we have
-	 * the task handle anyway). This task handle is only available in the migration phase until we
-	 * have switched completely to tasks.
-	 *
-	 * @return the task handle during the migration phase
-	 */
-	@Deprecated
-	public @NonNull ActiveTaskCodec getMigrationTaskHandle() {
-		return getTaskManager().getMigrationTaskHandle();
-	}
-
-	@NonNull
-	private ConvertibleServerConnection createServerConnection() throws ThreemaException {
-		Supplier<ServerConnection> connectionSupplier = new CspD2mDualConnectionSupplier(
-			getMultiDeviceManager(),
-			getIncomingMessageProcessor(),
-			getTaskManager(),
-			getDeviceCookieManager(),
-			getServerAddressProviderService(),
-			getIdentityStore(),
-			coreServiceManager.getVersion(),
-			isIpv6Preferred.get(),
-			okHttpClient,
-			ConfigUtils.isDevBuild()
-		);
-		return new ConvertibleServerConnection(connectionSupplier);
-	}
-
-	@NonNull
-	public DeviceCookieManager getDeviceCookieManager() {
-		return coreServiceManager.getDeviceCookieManager();
-	}
-
-	@NonNull
-	private OkHttpClient createOkHttpClient() {
-		logger.debug("Create OkHttpClient");
-		return new OkHttpClient.Builder()
-			.connectTimeout(ProtocolDefines.CONNECT_TIMEOUT, TimeUnit.SECONDS)
-			.writeTimeout(ProtocolDefines.WRITE_TIMEOUT, TimeUnit.SECONDS)
-			.readTimeout(ProtocolDefines.READ_TIMEOUT, TimeUnit.SECONDS)
-			.build();
-	}
+            this.blockedContactsService = new IdListServiceImpl("identity_list_blacklist", this.getPreferenceService());
+        }
+        return this.blockedContactsService;
+    }
+
+    @NonNull
+    public DeadlineListService getMutedChatsListService() {
+        if (this.mutedChatsListService == null) {
+            this.mutedChatsListService = new DeadlineListServiceImpl("list_muted_chats", this.getPreferenceService());
+        }
+        return this.mutedChatsListService;
+    }
+
+    @NonNull
+    public DeadlineListService getHiddenChatsListService() {
+        if (this.hiddenChatListService == null) {
+            this.hiddenChatListService = new DeadlineListServiceImpl("list_hidden_chats", this.getPreferenceService());
+        }
+        return this.hiddenChatListService;
+    }
+
+    @NonNull
+    public DeadlineListService getMentionOnlyChatsListService() {
+        if (this.mentionOnlyChatsListService == null) {
+            this.mentionOnlyChatsListService = new DeadlineListServiceImpl("list_mention_only", this.getPreferenceService());
+        }
+        return this.mentionOnlyChatsListService;
+    }
+
+    @NonNull
+    public IdListService getExcludedSyncIdentitiesService() {
+        if (this.excludedSyncIdentitiesService == null) {
+            this.excludedSyncIdentitiesService = new IdListServiceImpl("identity_list_sync_excluded", this.getPreferenceService());
+        }
+        return this.excludedSyncIdentitiesService;
+    }
+
+    @NonNull
+    public UpdateSystemService getUpdateSystemService() {
+        return this.updateSystemService;
+    }
+
+    @NonNull
+    public MessagePlayerService getMessagePlayerService() throws ThreemaException {
+        if (this.messagePlayerService == null) {
+            this.messagePlayerService = new MessagePlayerServiceImpl(
+                getContext(),
+                this.getMessageService(),
+                this.getFileService(),
+                this.getPreferenceService(),
+                this.getHiddenChatsListService()
+            );
+        }
+        return this.messagePlayerService;
+    }
+
+    @NonNull
+    public DownloadService getDownloadService() throws FileSystemNotPresentException {
+        if (this.downloadService == null) {
+            this.downloadService = new DownloadServiceImpl(
+                this.getContext(),
+                this.getFileService(),
+                this.getApiService()
+            );
+        }
+        return this.downloadService;
+    }
+
+    @NonNull
+    public BallotService getBallotService() throws NoIdentityException, MasterKeyLockedException, FileSystemNotPresentException {
+        if (this.ballotService == null) {
+            this.ballotService = new BallotServiceImpl(
+                this.cacheService.getBallotModelCache(),
+                this.cacheService.getLinkBallotModelCache(),
+                this.databaseServiceNew,
+                this.getUserService(),
+                this.getGroupService(),
+                this.getContactService(),
+                this);
+        }
+        return this.ballotService;
+    }
+
+    @NonNull
+    public WallpaperService getWallpaperService() throws FileSystemNotPresentException {
+        if (this.wallpaperService == null) {
+            this.wallpaperService = new WallpaperServiceImpl(this.getContext(),
+                this.getFileService(),
+                this.getPreferenceService(),
+                this.masterKey
+            );
+        }
+
+        return this.wallpaperService;
+    }
+
+    public @NonNull ThreemaSafeService getThreemaSafeService() throws FileSystemNotPresentException, MasterKeyLockedException, NoIdentityException {
+        if (this.threemaSafeService == null) {
+            this.threemaSafeService = new ThreemaSafeServiceImpl(
+                this.getContext(),
+                this.getPreferenceService(),
+                this.getUserService(),
+                this.getContactService(),
+                this.getGroupService(),
+                this.getDistributionListService(),
+                this.getLocaleService(),
+                this.getFileService(),
+                this.getBlockedContactsService(),
+                this.getExcludedSyncIdentitiesService(),
+                this.getProfilePicRecipientsService(),
+                this.getDatabaseServiceNew(),
+                this.getIdentityStore(),
+                this.getApiService(),
+                this.getAPIConnector(),
+                this.getHiddenChatsListService(),
+                this.getServerAddressProviderService().getServerAddressProvider(),
+                this.getPreferenceStore(),
+                this.getModelRepositories().getContacts()
+            );
+        }
+        return this.threemaSafeService;
+    }
+
+    @NonNull
+    public Context getContext() {
+        return ThreemaApplication.getAppContext();
+    }
+
+    @NonNull
+    public IdentityStore getIdentityStore() {
+        return this.coreServiceManager.getIdentityStore();
+    }
+
+    @NonNull
+    public RingtoneService getRingtoneService() {
+        if (this.ringtoneService == null) {
+            this.ringtoneService = new RingtoneServiceImpl(this.getPreferenceService());
+        }
+
+        return this.ringtoneService;
+    }
+
+    @NonNull
+    public BackupChatService getBackupChatService() throws ThreemaException {
+        if (this.backupChatService == null) {
+            this.backupChatService = new BackupChatServiceImpl(
+                this.getContext(),
+                this.getFileService(),
+                this.getMessageService(),
+                this.getContactService()
+            );
+        }
+
+        return this.backupChatService;
+    }
+
+    @NonNull
+    public SystemScreenLockService getScreenLockService() {
+        if (this.systemScreenLockService == null) {
+            this.systemScreenLockService = new SystemScreenLockServiceImpl(
+                this.getContext(),
+                this.getLockAppService(),
+                this.getPreferenceService()
+            );
+        }
+        return this.systemScreenLockService;
+    }
+
+    @NonNull
+    public SensorService getSensorService() {
+        if (this.sensorService == null) {
+            this.sensorService = new SensorServiceImpl(this.getContext());
+        }
+        return this.sensorService;
+    }
+
+    @NonNull
+    public WebClientServiceManager getWebClientServiceManager() throws ThreemaException {
+        if (this.webClientServiceManager == null) {
+            this.webClientServiceManager = new WebClientServiceManager(new ServicesContainer(
+                this.getContext().getApplicationContext(),
+                this.getLifetimeService(),
+                this.getContactService(),
+                this.getGroupService(),
+                this.getDistributionListService(),
+                this.getConversationService(),
+                this.getConversationTagService(),
+                this.getMessageService(),
+                this.getNotificationService(),
+                this.databaseServiceNew,
+                this.getBlockedContactsService(),
+                this.getPreferenceService(),
+                this.getUserService(),
+                this.getHiddenChatsListService(),
+                this.getFileService(),
+                this.getSynchronizeContactsService(),
+                this.getLicenseService(),
+                this.getAPIConnector(),
+                this.getModelRepositories().getContacts()
+            ));
+        }
+        return this.webClientServiceManager;
+    }
+
+    @NonNull
+    public BrowserDetectionService getBrowserDetectionService() {
+        if (this.browserDetectionService == null) {
+            this.browserDetectionService = new BrowserDetectionServiceImpl();
+        }
+        return this.browserDetectionService;
+    }
+
+    @NonNull
+    public IdListService getProfilePicRecipientsService() {
+        if (this.profilePicRecipientsService == null) {
+            this.profilePicRecipientsService = new IdListServiceImpl("identity_list_profilepics", this.getPreferenceService());
+        }
+        return this.profilePicRecipientsService;
+    }
+
+    @NonNull
+    public VoipStateService getVoipStateService() throws ThreemaException {
+        if (this.voipStateService == null) {
+            this.voipStateService = new VoipStateService(
+                this.getContactService(),
+                this.getRingtoneService(),
+                this.getPreferenceService(),
+                this.getLifetimeService(),
+                this.getContext()
+            );
+        }
+        return this.voipStateService;
+    }
+
+    @NonNull
+    public DatabaseServiceNew getDatabaseServiceNew() {
+        return this.databaseServiceNew;
+    }
+
+    @NonNull
+    public ModelRepositories getModelRepositories() {
+        return this.modelRepositories;
+    }
+
+    @NonNull
+    public DHSessionStoreInterface getDHSessionStore() {
+        return this.dhSessionStore;
+    }
+
+    @NonNull
+    public ForwardSecurityMessageProcessor getForwardSecurityMessageProcessor() throws ThreemaException {
+        if (this.forwardSecurityMessageProcessor == null) {
+            this.forwardSecurityMessageProcessor = new ForwardSecurityMessageProcessor(
+                this.getDHSessionStore(),
+                this.getContactStore(),
+                this.getIdentityStore(),
+                this.getNonceFactory(),
+                new ForwardSecurityStatusSender(
+                    this.getContactService(),
+                    this.getMessageService(),
+                    this.getAPIConnector(),
+                    this.getUserService(),
+                    this.getModelRepositories().getContacts()
+                )
+            );
+            // TODO(ANDR-2519): Remove when md allows fs
+            forwardSecurityMessageProcessor.setForwardSecurityEnabled(getMultiDeviceManager().isMdDisabledOrSupportsFs());
+        }
+        return this.forwardSecurityMessageProcessor;
+    }
+
+    @NonNull
+    public SymmetricEncryptionService getSymmetricEncryptionService() {
+        if (symmetricEncryptionService == null) {
+            symmetricEncryptionService = new SymmetricEncryptionService();
+        }
+        return symmetricEncryptionService;
+    }
+
+    @NonNull
+    public EmojiService getEmojiService() {
+        if (emojiService == null) {
+            EmojiSearchIndex searchIndex = new EmojiSearchIndex(
+                getContext().getApplicationContext(),
+                getPreferenceService()
+            );
+            emojiService = new EmojiService(
+                getPreferenceService(),
+                searchIndex,
+                new EmojiRecent(getPreferenceService())
+            );
+        }
+        return emojiService;
+    }
+
+    @NonNull
+    public GroupCallManager getGroupCallManager() throws ThreemaException {
+        if (groupCallManager == null) {
+            groupCallManager = new GroupCallManagerImpl(
+                getContext().getApplicationContext(),
+                this,
+                getDatabaseServiceNew(),
+                getGroupService(),
+                getContactService(),
+                getPreferenceService(),
+                getMessageService(),
+                getNotificationService(),
+                getSfuConnection()
+            );
+        }
+        return groupCallManager;
+    }
+
+    @NonNull
+    public SfuConnection getSfuConnection() {
+        if (sfuConnection == null) {
+            sfuConnection = new SfuConnectionImpl(
+                getAPIConnector(),
+                getIdentityStore(),
+                ThreemaApplication.getAppVersion()
+            );
+        }
+        return sfuConnection;
+    }
+
+    public @NonNull NonceFactory getNonceFactory() {
+        return coreServiceManager.getNonceFactory();
+    }
+
+    private @NonNull IncomingMessageProcessor getIncomingMessageProcessor() {
+        if (this.incomingMessageProcessor == null) {
+            this.incomingMessageProcessor = new IncomingMessageProcessorImpl(this);
+        }
+        return this.incomingMessageProcessor;
+    }
+
+    public @NonNull TaskManager getTaskManager() {
+        return this.coreServiceManager.getTaskManager();
+    }
+
+    public @NonNull TaskCreator getTaskCreator() {
+        if (this.taskCreator == null) {
+            this.taskCreator = new TaskCreator(this);
+        }
+        return this.taskCreator;
+    }
+
+    @NonNull
+    public MultiDeviceManager getMultiDeviceManager() {
+        return this.coreServiceManager.getMultiDeviceManager();
+    }
+
+    @NonNull
+    public OkHttpClient getOkHttpClient() {
+        return okHttpClient.get();
+    }
+
+    @NonNull
+    private ConvertibleServerConnection createServerConnection() throws ThreemaException {
+        Supplier<ServerConnection> connectionSupplier = new CspD2mDualConnectionSupplier(
+            getMultiDeviceManager(),
+            getIncomingMessageProcessor(),
+            getTaskManager(),
+            getDeviceCookieManager(),
+            getServerAddressProviderService(),
+            getIdentityStore(),
+            coreServiceManager.getVersion(),
+            isIpv6Preferred.get(),
+            okHttpClient,
+            ConfigUtils.isDevBuild()
+        );
+        return new ConvertibleServerConnection(connectionSupplier);
+    }
+
+    @NonNull
+    public DeviceCookieManager getDeviceCookieManager() {
+        return coreServiceManager.getDeviceCookieManager();
+    }
+
+    @NonNull
+    private OkHttpClient createOkHttpClient() {
+        logger.debug("Create OkHttpClient");
+        OkHttpClient.Builder builder = new OkHttpClient.Builder()
+            .connectTimeout(ProtocolDefines.CONNECT_TIMEOUT, TimeUnit.SECONDS)
+            .writeTimeout(ProtocolDefines.WRITE_TIMEOUT, TimeUnit.SECONDS)
+            .readTimeout(ProtocolDefines.READ_TIMEOUT, TimeUnit.SECONDS);
+
+        /*
+         * For android versions < 7.0 we have to explicitly configure the okhttp client
+         * to use certificate pinning via TrustKit.
+         * In on-prem builds we never pin.
+         */
+        if (!ConfigUtils.isOnPremBuild() && Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
+            builder.sslSocketFactory(OkHttp3Helper.getSSLSocketFactory(), OkHttp3Helper.getTrustManager());
+            builder.addInterceptor(OkHttp3Helper.getPinningInterceptor());
+        }
+
+        return builder.build();
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java b/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java
index 1c19716e..0f1d3d7d 100644
--- a/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java
+++ b/app/src/main/java/ch/threema/app/messagereceiver/ContactMessageReceiver.java
@@ -36,17 +36,19 @@ import androidx.annotation.Nullable;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ServiceManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.IdListService;
 import ch.threema.app.services.MessageService;
 import ch.threema.app.stores.IdentityStore;
+import ch.threema.app.tasks.OutboundIncomingContactMessageUpdateReadTask;
+import ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask;
 import ch.threema.app.tasks.OutgoingContactDeleteMessageTask;
 import ch.threema.app.tasks.OutgoingContactEditMessageTask;
-import ch.threema.app.tasks.OutgoingPollSetupMessageTask;
-import ch.threema.app.tasks.OutgoingPollVoteContactMessageTask;
-import ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask;
 import ch.threema.app.tasks.OutgoingFileMessageTask;
 import ch.threema.app.tasks.OutgoingLocationMessageTask;
+import ch.threema.app.tasks.OutgoingPollSetupMessageTask;
+import ch.threema.app.tasks.OutgoingPollVoteContactMessageTask;
 import ch.threema.app.tasks.OutgoingTextMessageTask;
 import ch.threema.app.tasks.OutgoingTypingIndicatorMessageTask;
 import ch.threema.app.tasks.OutgoingVoipCallAnswerMessageTask;
@@ -54,6 +56,7 @@ import ch.threema.app.tasks.OutgoingVoipCallHangupMessageTask;
 import ch.threema.app.tasks.OutgoingVoipCallOfferMessageTask;
 import ch.threema.app.tasks.OutgoingVoipCallRingingMessageTask;
 import ch.threema.app.tasks.OutgoingVoipICECandidateMessageTask;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
@@ -83,20 +86,21 @@ import ch.threema.storage.models.data.media.FileDataModel;
 public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	private final ContactModel contactModel;
 	private final ContactService contactService;
-	private Bitmap avatar = null;
 	@NonNull
 	private final ServiceManager serviceManager;
 	private final DatabaseServiceNew databaseServiceNew;
 	private final IdentityStore identityStore;
 	private final IdListService blockedContactsService;
 	private final @NonNull TaskManager taskManager;
+	private final @NonNull MultiDeviceManager multiDeviceManager;
 
 	public ContactMessageReceiver(ContactModel contactModel,
 	                              ContactService contactService,
 	                              @NonNull ServiceManager serviceManager,
 	                              DatabaseServiceNew databaseServiceNew,
 	                              IdentityStore identityStore,
-	                              IdListService blockedContactsService) {
+	                              IdListService blockedContactsService
+	) {
 		this.contactModel = contactModel;
 		this.contactService = contactService;
 		this.serviceManager = serviceManager;
@@ -104,6 +108,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		this.identityStore = identityStore;
 		this.blockedContactsService = blockedContactsService;
 		this.taskManager = serviceManager.getTaskManager();
+		this.multiDeviceManager = serviceManager.getMultiDeviceManager();
 	}
 
 	protected ContactMessageReceiver(ContactMessageReceiver contactMessageReceiver) {
@@ -115,7 +120,6 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 			contactMessageReceiver.identityStore,
 			contactMessageReceiver.blockedContactsService
 		);
-		avatar = contactMessageReceiver.avatar;
 	}
 
 	@Override
@@ -163,7 +167,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		saveLocalModel(messageModel);
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		bumpLastUpdate();
@@ -178,7 +182,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	}
 
 	public void resendTextMessage(@NonNull MessageModel messageModel) {
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		scheduleTask(new OutgoingTextMessageTask(
@@ -196,7 +200,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		saveLocalModel(messageModel);
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		bumpLastUpdate();
@@ -212,7 +216,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 
 	public void resendLocationMessage(@NonNull MessageModel messageModel) {
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		// Schedule outgoing text message task
@@ -242,14 +246,14 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 
 		// Set file data model again explicitly to enforce that the body of the message is rewritten
 		// and therefore updated.
-		messageModel.setFileData(modelFileData);
+		messageModel.setFileDataModel(modelFileData);
 
 		// Create a new message id if the given message id is null
 		messageModel.setApiMessageId(messageId != null ? messageId.toString() : new MessageId().toString());
 		saveLocalModel(messageModel);
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		// Note that lastUpdate lastUpdate was bumped when the file message was created
@@ -279,7 +283,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		final BallotId ballotId = new BallotId(Utils.hexStringToByteArray(ballotModel.getApiBallotId()));
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		bumpLastUpdate();
@@ -310,7 +314,7 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 		}
 
 		// Mark the contact as non-hidden and unarchived
-		contactService.setIsHidden(contactModel.getIdentity(), false);
+		contactService.setAcquaintanceLevel(contactModel.getIdentity(), ContactModel.AcquaintanceLevel.DIRECT);
 		contactService.setIsArchived(contactModel.getIdentity(), false);
 
 		// Schedule outgoing text message task
@@ -340,14 +344,33 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	 * @param receiptType the type of the delivery receipt
 	 * @param messageIds  the message ids
 	 */
-	public void sendDeliveryReceipt(int receiptType, @NonNull MessageId[] messageIds) {
+	public void sendDeliveryReceipt(int receiptType, @NonNull MessageId[] messageIds, long time) {
 		scheduleTask(
 			new OutgoingContactDeliveryReceiptMessageTask(
-				receiptType, messageIds, new Date().getTime(), contactModel.getIdentity(), serviceManager
+				receiptType, messageIds, time, contactModel.getIdentity(), serviceManager
 			)
 		);
 	}
 
+	/**
+	 * Send an incoming message update to mark the message as read. Note that this is the
+	 * alternative of {@link ContactMessageReceiver#sendDeliveryReceipt(int, MessageId[], long)}
+	 * when no delivery receipt should be sent. This method only schedules the outgoing message
+	 * update if multi device is activated.
+	 */
+	public void sendIncomingMessageUpdateRead(@NonNull Set<MessageId> messageIds, long timestamp) {
+		if (multiDeviceManager.isMultiDeviceActive()) {
+			scheduleTask(
+				new OutboundIncomingContactMessageUpdateReadTask(
+					messageIds,
+					timestamp,
+					contactModel.getIdentity(),
+					serviceManager
+				)
+			);
+		}
+	}
+
 	/**
 	 * Send a voip call offer message to the receiver.
 	 *
@@ -506,30 +529,28 @@ public class ContactMessageReceiver implements MessageReceiver<MessageModel> {
 	@Override
 	@Nullable
 	public Bitmap getNotificationAvatar() {
-		if (avatar == null && contactService != null) {
-			avatar = contactService.getAvatar(contactModel, false);
-		}
-		return avatar;
+		return contactService.getAvatar(contactModel, false);
 	}
 
 	@Override
 	@Nullable
 	public Bitmap getAvatar() {
-		if (avatar == null && contactService != null) {
-			avatar = contactService.getAvatar(contactModel, true, true);
-		}
-		return avatar;
+		return contactService.getAvatar(contactModel, true, true);
 	}
 
 	@Deprecated
 	@Override
 	public int getUniqueId() {
-		return contactService.getUniqueId(contactModel);
+		return contactModel != null
+			? ContactUtil.getUniqueId(contactModel.getIdentity())
+			: 0;
 	}
 
 	@Override
 	public String getUniqueIdString() {
-		return contactService.getUniqueIdString(contactModel);
+		return contactModel != null
+			? ContactUtil.getUniqueIdString(contactModel.getIdentity())
+		    : "";
 	}
 
 	@Override
diff --git a/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java b/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java
index ca7bed75..125726d0 100644
--- a/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java
+++ b/app/src/main/java/ch/threema/app/messagereceiver/GroupMessageReceiver.java
@@ -36,8 +36,10 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ServiceManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.tasks.OutboundIncomingGroupMessageUpdateReadTask;
 import ch.threema.app.tasks.OutgoingFileMessageTask;
 import ch.threema.app.tasks.OutgoingGroupDeleteMessageTask;
 import ch.threema.app.tasks.OutgoingGroupEditMessageTask;
@@ -71,10 +73,10 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	private final GroupModel group;
 	private final GroupService groupService;
-	private Bitmap avatar = null;
 	private final DatabaseServiceNew databaseServiceNew;
 	private final @NonNull ServiceManager serviceManager;
 	private final TaskManager taskManager;
+	private final MultiDeviceManager multiDeviceManager;
 
 	public GroupMessageReceiver(
 		GroupModel group,
@@ -87,6 +89,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 		this.databaseServiceNew = databaseServiceNew;
 		this.serviceManager = serviceManager;
 		this.taskManager = serviceManager.getTaskManager();
+		this.multiDeviceManager = serviceManager.getMultiDeviceManager();
 	}
 
 	@Override
@@ -126,7 +129,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public void createAndSendTextMessage(@NonNull GroupMessageModel messageModel) {
-		Set<String> otherMembers = groupService.getOtherMembers(group);
+		Set<String> otherMembers = groupService.getMembersWithoutUser(group);
 
 		if (otherMembers.isEmpty()) {
 			// In case the recipients set is empty, we are sending the message in a notes group. In
@@ -161,7 +164,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public void createAndSendLocationMessage(@NonNull GroupMessageModel messageModel) {
-		Set<String> otherMembers = groupService.getOtherMembers(group);
+		Set<String> otherMembers = groupService.getMembersWithoutUser(group);
 
 		if (otherMembers.isEmpty()) {
 			// In case the recipients set is empty, we are sending the message in a notes group. In
@@ -216,7 +219,7 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 		// Set file data model again explicitly to enforce that the body of the message is rewritten
 		// and therefore updated.
-		messageModel.setFileData(modelFileData);
+		messageModel.setFileDataModel(modelFileData);
 
 		// Create a new message id if the given message id is null
 		messageModel.setApiMessageId(messageId != null ? messageId.toString() : new MessageId().toString());
@@ -282,6 +285,24 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 		));
 	}
 
+	/**
+	 * Send an incoming message update to mark the message as read. This method only schedules the
+	 * outgoing group message update if multi device is activated.
+	 */
+	public void sendIncomingMessageUpdateRead(@NonNull Set<MessageId> messageIds, long timestamp) {
+		if (multiDeviceManager.isMultiDeviceActive()) {
+			taskManager.schedule(
+				new OutboundIncomingGroupMessageUpdateReadTask(
+					messageIds,
+					timestamp,
+					group.getApiGroupId(),
+					group.getCreatorIdentity(),
+					serviceManager
+				)
+			);
+		}
+	}
+
 	public void sendEditMessage(int messageModelId, @NonNull String body, @NonNull Date editedAt) {
 		taskManager.schedule(
 			new OutgoingGroupEditMessageTask(
@@ -362,18 +383,12 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public Bitmap getNotificationAvatar() {
-		if (avatar == null && groupService != null) {
-			avatar = groupService.getAvatar(group, false);
-		}
-		return avatar;
+		return groupService.getAvatar(group, false);
 	}
 
 	@Override
 	public Bitmap getAvatar() {
-		if (avatar == null && groupService != null) {
-			avatar = groupService.getAvatar(group, true, true);
-		}
-		return avatar;
+		return groupService.getAvatar(group, true, true);
 	}
 
 	@Override
@@ -401,6 +416,12 @@ public class GroupMessageReceiver implements MessageReceiver<GroupMessageModel>
 
 	@Override
 	public boolean sendMediaData() {
+        if (multiDeviceManager.isMultiDeviceActive()) {
+            // We need to upload the media in any case (also for notes groups) if multi device is
+            // active. In this case the upload is needed as the message is reflected.
+            return true;
+        }
+
 		// don't really send off group media if user is the only group member left - keep it local
 		String[] groupIdentities = groupService.getGroupIdentities(group);
 		return groupIdentities.length != 1 || !groupService.isGroupMember(group);
diff --git a/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java b/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java
index b778f8ad..f440e26c 100644
--- a/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java
+++ b/app/src/main/java/ch/threema/app/messagereceiver/MessageReceiver.java
@@ -24,10 +24,6 @@ package ch.threema.app.messagereceiver;
 import android.content.Intent;
 import android.graphics.Bitmap;
 
-import androidx.annotation.IntDef;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.sql.SQLException;
@@ -35,6 +31,9 @@ import java.util.Collection;
 import java.util.Date;
 import java.util.List;
 
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.services.MessageService;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.SymmetricEncryptionResult;
diff --git a/app/src/main/java/ch/threema/app/messagereceiver/SendingPermissionValidationResult.kt b/app/src/main/java/ch/threema/app/messagereceiver/SendingPermissionValidationResult.kt
deleted file mode 100644
index b59db1a9..00000000
--- a/app/src/main/java/ch/threema/app/messagereceiver/SendingPermissionValidationResult.kt
+++ /dev/null
@@ -1,33 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.messagereceiver
-
-import androidx.annotation.StringRes
-
-sealed class SendingPermissionValidationResult(val isValid: Boolean) {
-
-    val isDenied: Boolean = !isValid
-
-    data object Valid : SendingPermissionValidationResult(isValid = true)
-
-    data class Denied(@StringRes val errorResId: Int? = null) : SendingPermissionValidationResult(isValid = false)
-}
diff --git a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt b/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt
deleted file mode 100644
index e37ff078..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesActivity.kt
+++ /dev/null
@@ -1,183 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice
-
-import android.Manifest
-import android.annotation.TargetApi
-import android.content.pm.PackageManager
-import android.os.Build
-import android.os.Bundle
-import android.view.View
-import android.widget.TextView
-import androidx.activity.viewModels
-import androidx.lifecycle.Lifecycle
-import androidx.lifecycle.lifecycleScope
-import androidx.lifecycle.repeatOnLifecycle
-import androidx.recyclerview.widget.DefaultItemAnimator
-import androidx.recyclerview.widget.LinearLayoutManager
-import androidx.recyclerview.widget.RecyclerView
-import ch.threema.app.R
-import ch.threema.app.activities.ThreemaToolbarActivity
-import ch.threema.app.services.QRCodeServiceImpl
-import ch.threema.app.ui.EmptyRecyclerView
-import ch.threema.app.ui.SilentSwitchCompat
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.QRScannerUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
-import com.google.android.material.floatingactionbutton.ExtendedFloatingActionButton
-import kotlinx.coroutines.launch
-
-private val logger = LoggingUtil.getThreemaLogger("LinkedDevicesActivity")
-
-class LinkedDevicesActivity : ThreemaToolbarActivity() {
-    private companion object {
-        const val PERMISSION_REQUEST_CAMERA = 1
-    }
-
-    private val viewModel: LinkedDevicesViewModel by viewModels()
-
-    private val qrScanner = QRScannerUtil.prepareScanner(this) {
-        if (it?.isNotEmpty() == true) {
-            logger.debug("Got device link data: {}", it)
-            viewModel.linkDevice(it, serviceManager.deviceJoinDataCollector)
-        }
-    }
-
-    private lateinit var devicesList: EmptyRecyclerView
-    private lateinit var devicesAdapter: LinkedDevicesAdapter
-
-    private lateinit var onOffButton: SilentSwitchCompat
-    private lateinit var linkDeviceButton: ExtendedFloatingActionButton
-
-    override fun getLayoutResource(): Int = R.layout.activity_linked_devices
-
-    override fun onCreate(savedInstanceState: Bundle?) {
-        super.onCreate(savedInstanceState)
-
-        if (!ConfigUtils.isMultiDeviceEnabled() && !serviceManager.multiDeviceManager.isMultiDeviceActive) {
-            logger.warn("Leave activity: MD is not enabled")
-            finish()
-            return
-        }
-
-        supportActionBar?.apply {
-            setDisplayHomeAsUpEnabled(true)
-            setTitle(R.string.md_linked_devices)
-        }
-
-        onOffButton = findViewById(R.id.on_off_button)
-        onOffButton.setOnOffLabel(findViewById(R.id.on_off_button_text))
-        onOffButton.setOnCheckedChangeListener { _, isChecked ->
-            viewModel.setMultiDeviceState(isChecked)
-        }
-
-        linkDeviceButton = findViewById(R.id.link_device_button)
-        linkDeviceButton.setOnClickListener { initiateLinking() }
-
-        initDevicesList()
-
-        startObservers()
-    }
-
-    @TargetApi(Build.VERSION_CODES.M)
-    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
-        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
-        if (requestCode == PERMISSION_REQUEST_CAMERA) {
-            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
-                scanQr()
-            } else if (!this.shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {
-                ConfigUtils.showPermissionRationale(this, findViewById(R.id.parent_layout), R.string.permission_camera_qr_required)
-            }
-        }
-    }
-
-    private fun initDevicesList() {
-        val layoutManager = LinearLayoutManager(this)
-        devicesList = findViewById(R.id.devices_list)
-        devicesList.setHasFixedSize(true)
-        devicesList.layoutManager = layoutManager
-        devicesList.itemAnimator = DefaultItemAnimator()
-        devicesList.addOnScrollListener(object : RecyclerView.OnScrollListener() {
-            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
-                super.onScrolled(recyclerView, dx, dy)
-
-                if (layoutManager.findFirstVisibleItemPosition() == 0) {
-                    linkDeviceButton.extend()
-                } else {
-                    linkDeviceButton.shrink()
-                }
-            }
-        })
-
-        val emptyTextView = findViewById<TextView>(R.id.empty_text)
-        devicesList.emptyView = emptyTextView
-        devicesAdapter = LinkedDevicesAdapter()
-        devicesList.adapter = devicesAdapter
-
-    }
-
-    private fun initiateLinking() {
-        logger.debug("Initiate linking")
-        if (ConfigUtils.requestCameraPermissions(this, null, PERMISSION_REQUEST_CAMERA)) {
-            scanQr()
-        }
-    }
-
-    private fun scanQr() {
-        logger.info("Scan Qr Code")
-        qrScanner.scan(
-            getString(R.string.md_link_device_qr_scan_message),
-            QRCodeServiceImpl.QR_TYPE_ANY
-        )
-    }
-
-    private fun startObservers() {
-        lifecycleScope.launch {
-            repeatOnLifecycle(Lifecycle.State.STARTED) {
-                launch { viewModel.isMdActive.collect(::setMdEnabled) }
-                launch { viewModel.linkedDevices.collect(::updateLinkedDevices) }
-                launch { viewModel.latestCloseReason.collect(::updateLatestCloseReason) }
-            }
-        }
-    }
-
-    private fun setMdEnabled(enabled: Boolean) {
-        onOffButton.isEnabled = enabled || ConfigUtils.isMultiDeviceEnabled()
-        onOffButton.setCheckedSilent(enabled)
-        linkDeviceButton.isEnabled = enabled
-    }
-    private fun updateLinkedDevices(linkedDevices: List<String>) {
-        devicesAdapter.setDevices(linkedDevices)
-    }
-
-    // TODO(ANDR-2604): Remove
-    private fun updateLatestCloseReason(reason: D2mSocketCloseReason?) {
-        val latestCloseCode: TextView = findViewById(R.id.latest_close_code)
-        if (reason != null) {
-            latestCloseCode.text = reason.closeCode.toString()
-            latestCloseCode.visibility = View.VISIBLE
-        } else {
-            latestCloseCode.visibility = View.GONE
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesAdapter.kt b/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesAdapter.kt
deleted file mode 100644
index fdf1ef25..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesAdapter.kt
+++ /dev/null
@@ -1,76 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice
-
-import android.view.LayoutInflater
-import android.view.View
-import android.view.ViewGroup
-import android.widget.TextView
-import androidx.recyclerview.widget.RecyclerView
-import ch.threema.app.R
-
-class LinkedDevicesAdapter : RecyclerView.Adapter<LinkedDevicesAdapter.LinkedDevicesViewHolder>() {
-    private val devices = mutableListOf<String>()
-
-    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): LinkedDevicesViewHolder {
-        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_linked_devices_list, parent, false)
-        return LinkedDevicesViewHolder(view)
-    }
-
-    override fun onBindViewHolder(viewHolder: LinkedDevicesViewHolder, position: Int) {
-        viewHolder.text.text = devices[position]
-    }
-
-    override fun getItemCount(): Int = devices.size
-
-    fun setDevices(newDevices: List<String>) {
-        val commonElementCount = minOf(newDevices.size, devices.size)
-
-        if (commonElementCount > 0) {
-            (0 until commonElementCount).forEach {
-                if (devices[it] != newDevices[it]) {
-                    devices[it] = newDevices[it]
-                    notifyItemChanged(it)
-                }
-            }
-        }
-
-        if (newDevices.size < devices.size) {
-            val count = devices.size - newDevices.size
-            repeat(count) {
-                devices.removeLast()
-            }
-            notifyItemRangeRemoved(newDevices.size, count)
-        } else if (newDevices.size > devices.size) {
-            val from = devices.size
-            val to = newDevices.size
-            (from until to).forEach {
-                devices.add(newDevices[it])
-            }
-            notifyItemRangeInserted(from, to - from)
-        }
-    }
-
-    class LinkedDevicesViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
-        val text: TextView = itemView.findViewById(R.id.text)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt b/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt
deleted file mode 100644
index 3b3e052a..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/LinkedDevicesViewModel.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice
-
-import androidx.annotation.AnyThread
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.viewModelScope
-import ch.threema.app.ThreemaApplication.requireServiceManager
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.flow.Flow
-import kotlinx.coroutines.flow.MutableSharedFlow
-import kotlinx.coroutines.flow.MutableStateFlow
-import kotlinx.coroutines.flow.asSharedFlow
-import kotlinx.coroutines.flow.asStateFlow
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.withContext
-
-class LinkedDevicesViewModel : ViewModel() {
-
-    private val _isMdActive = MutableStateFlow(false)
-    val isMdActive: Flow<Boolean> = _isMdActive.asStateFlow()
-
-    private val _linkedDevices = MutableStateFlow<List<String>>(listOf())
-    val linkedDevices: Flow<List<String>> = _linkedDevices.asStateFlow()
-
-    // TODO(ANDR-2604): Remove
-    private val _latestCloseReason = MutableSharedFlow<D2mSocketCloseReason?>()
-    val latestCloseReason: Flow<D2mSocketCloseReason?> = _latestCloseReason.asSharedFlow()
-
-    private val mdManager: MultiDeviceManager by lazy { requireServiceManager().multiDeviceManager }
-
-    init {
-        emitStates()
-        collectLatestCloseReason()
-    }
-
-    @AnyThread
-    fun linkDevice(deviceJoinOfferUri: String, deviceJoinDataCollector: DeviceJoinDataCollector) {
-        CoroutineScope(Dispatchers.Default).launch {
-            mdManager.linkDevice(deviceJoinOfferUri, deviceJoinDataCollector)
-            emitStates()
-        }
-    }
-
-    @AnyThread
-    fun setMultiDeviceState(active: Boolean) {
-        if (active) {
-            activateMultiDevice()
-        } else {
-            deactivateMultiDevice()
-        }
-    }
-
-    @AnyThread
-    private fun activateMultiDevice() {
-        CoroutineScope(Dispatchers.Default).launch {
-            val serviceManager = requireServiceManager()
-            mdManager.activate(
-                "Android Client", // TODO(ANDR-2487): Should be userselectable (and updateable)
-                serviceManager.taskManager,
-                serviceManager.contactService,
-                serviceManager.userService,
-                serviceManager.forwardSecurityMessageProcessor
-            )
-            emitStates()
-        }
-    }
-
-    @AnyThread
-    private fun deactivateMultiDevice() {
-        CoroutineScope(Dispatchers.Default).launch {
-            val serviceManager = requireServiceManager()
-            // TODO(ANDR-2603): Maybe show a spinner while we are waiting for deactivation to complete
-            mdManager.deactivate(
-                serviceManager.taskManager,
-                serviceManager.userService,
-                serviceManager.forwardSecurityMessageProcessor
-            )
-            emitStates()
-        }
-    }
-
-    @AnyThread
-    private fun emitStates() {
-        emitIsMdActive()
-        emitLinkedDevices()
-    }
-
-    @AnyThread
-    private fun emitIsMdActive() {
-        viewModelScope.launch {
-            _isMdActive.emit(withContext(Dispatchers.Default) { mdManager.isMultiDeviceActive })
-        }
-    }
-
-    @AnyThread
-    private fun emitLinkedDevices() {
-        viewModelScope.launch {
-            _linkedDevices.emit(withContext(Dispatchers.Default) { mdManager.linkedDevices })
-        }
-    }
-
-    @AnyThread
-    private fun collectLatestCloseReason() {
-        viewModelScope.launch {
-            mdManager.latestSocketCloseReason.collect(_latestCloseReason)
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceException.kt b/app/src/main/java/ch/threema/app/multidevice/MultiDeviceException.kt
deleted file mode 100644
index 2b092a39..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceException.kt
+++ /dev/null
@@ -1,26 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice
-
-import ch.threema.base.ThreemaException
-
-class MultiDeviceException(msg: String) : ThreemaException(msg)
diff --git a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt b/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt
deleted file mode 100644
index f046539b..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManager.kt
+++ /dev/null
@@ -1,76 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice
-
-
-import androidx.annotation.AnyThread
-import androidx.annotation.WorkerThread
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.UserService
-import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseListener
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.taskmanager.TaskManager
-import kotlinx.coroutines.flow.Flow
-
-interface MultiDeviceManager {
-    // TODO(ANDR-2519): Remove when md allows fs
-    val isMdDisabledOrSupportsFs: Boolean
-
-    val isMultiDeviceActive: Boolean
-
-    val linkedDevices: List<String>
-
-    val propertiesProvider: MultiDevicePropertyProvider
-
-    val socketCloseListener: D2mSocketCloseListener
-
-    // TODO(ANDR-2604): Remove when a dialog is shown in ui and this is not needed anymore
-    val latestSocketCloseReason: Flow<D2mSocketCloseReason?>
-
-    @WorkerThread
-    suspend fun activate(
-        deviceLabel: String,
-        taskManager: TaskManager, // TODO(ANDR-2519): Remove
-        contactService: ContactService, // TODO(ANDR-2519): remove
-        userService: UserService, // TODO(ANDR-2519): remove
-        fsMessageProcessor: ForwardSecurityMessageProcessor, // TODO(ANDR-2519): remove
-    )
-
-    @WorkerThread
-    suspend fun deactivate(
-        taskManager: TaskManager,
-        userService: UserService, // TODO(ANDR-2519): remove
-        fsMessageProcessor: ForwardSecurityMessageProcessor // TODO(ANDR-2519): remove
-    )
-
-    @WorkerThread
-    suspend fun setDeviceLabel(deviceLabel: String)
-
-    @AnyThread
-    suspend fun linkDevice(
-        deviceJoinOfferUri: String,
-        deviceJoinDataCollector: DeviceJoinDataCollector,
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt b/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt
deleted file mode 100644
index 2781b268..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/MultiDeviceManagerImpl.kt
+++ /dev/null
@@ -1,504 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice
-
-import android.os.Build
-import androidx.annotation.AnyThread
-import androidx.annotation.WorkerThread
-import ch.threema.app.BuildConfig
-import ch.threema.app.multidevice.linking.DeviceJoinData
-import ch.threema.app.multidevice.linking.DeviceJoinDataCollector
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.ServerMessageService
-import ch.threema.app.services.UserService
-import ch.threema.app.stores.PreferenceStore
-import ch.threema.app.stores.PreferenceStoreInterface
-import ch.threema.app.tasks.DeleteAndTerminateFSSessionsTask
-import ch.threema.app.tasks.OutgoingDropDeviceTask
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.SecureRandomUtil.generateRandomBytes
-import ch.threema.base.utils.SecureRandomUtil.generateRandomU64
-import ch.threema.base.utils.toHexString
-import ch.threema.domain.protocol.D2mProtocolDefines
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.ReconnectableServerConnection
-import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
-import ch.threema.domain.protocol.connection.d2m.socket.D2mCloseCode
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseListener
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseReason
-import ch.threema.domain.protocol.connection.data.D2dMessage
-import ch.threema.domain.protocol.connection.data.D2mProtocolVersion
-import ch.threema.domain.protocol.connection.data.DeviceId
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.multidevice.MultiDeviceKeys
-import ch.threema.domain.protocol.multidevice.MultiDeviceProperties
-import ch.threema.domain.taskmanager.TaskManager
-import ch.threema.protobuf.csp.e2e.fs.Terminate
-import ch.threema.storage.models.ServerMessageModel
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.awaitAll
-import kotlinx.coroutines.channels.BufferOverflow
-import kotlinx.coroutines.flow.MutableSharedFlow
-import kotlinx.coroutines.flow.first
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
-import kotlinx.coroutines.withContext
-import org.saltyrtc.client.exceptions.InvalidStateException
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("MultiDeviceManagerImpl")
-
-/** ONLY SET THIS TO `false` WHEN D2D IS IMPLEMENTED AND DOES NOT SUPPORT PFS!!
- * NOTE: If set to `false` the backup version should be incremented, as
- * `ForwardSecurityStatusType.FORWARD_SECURITY_DISABLED` cannot be restored on older versions.
- */
-private const val IS_FS_SUPPORTED_WITH_MD = true // TODO(ANDR-2519): Remove when md supports fs
-
-class MultiDeviceManagerImpl(
-    private val preferenceStore: PreferenceStoreInterface,
-    private val serverMessageService: ServerMessageService,
-    private val version: Version,
-) : MultiDeviceManager {
-
-    private var reconnectHandle: ReconnectableServerConnection? = null
-
-    private var _persistedProperties: PersistedMultiDeviceProperties? = null
-    private var _properties = MutableSharedFlow<MultiDeviceProperties?>(1, onBufferOverflow = BufferOverflow.DROP_OLDEST)
-
-    init {
-        CoroutineScope(Dispatchers.Default).launch {
-            _persistedProperties = loadProperties()
-                .also {
-                    _properties.emit(it?.let(::mapPersistedProperties)) }
-        }
-    }
-
-    fun setReconnectHandle(reconnectHandle: ReconnectableServerConnection) {
-        this.reconnectHandle = reconnectHandle
-    }
-
-    /**
-     * Setting [persistedProperties] with a new value will also
-     *  - persist the properties
-     *  - update the value of [properties]
-     */
-    private var persistedProperties: PersistedMultiDeviceProperties?
-        set(value) {
-            _persistedProperties = value
-            storeProperties(value)
-            _properties.tryEmit(value?.let(::mapPersistedProperties))
-        }
-        get() = _persistedProperties
-
-    private val properties: MultiDeviceProperties?
-        get() = runBlocking { _properties.first() }
-
-    override val propertiesProvider: MultiDevicePropertyProvider = MultiDevicePropertyProvider {
-        properties ?: throw NullPointerException("MultiDeviceProperties must not be null")
-    }
-
-    override val socketCloseListener = D2mSocketCloseListener {
-        onSocketClosed(it)
-    }
-
-    // TODO(ANDR-2519): Remove when md allows fs
-    override val isMdDisabledOrSupportsFs = !isMultiDeviceActive || IS_FS_SUPPORTED_WITH_MD
-
-    override val isMultiDeviceActive: Boolean
-        get() = properties != null
-
-    private val _linkedDevices = mutableListOf<String>()
-    override val linkedDevices: List<String>
-        get() = _linkedDevices // TODO(ANDR-2484): persist linked devices
-
-    override val latestSocketCloseReason = MutableSharedFlow<D2mSocketCloseReason?>(1, 0, BufferOverflow.DROP_OLDEST)
-
-    private var serverInfo: InboundD2mMessage.ServerInfo? = null
-
-    private var deactivationOngoing = false
-
-    @AnyThread
-    override suspend fun activate(
-        deviceLabel: String,
-        taskManager: TaskManager,
-        contactService: ContactService,
-        userService: UserService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor,
-    ) {
-        logger.info("Activate multi device")
-        if (!BuildConfig.MD_ENABLED) {
-            logger.warn("Md is disabled in build configuration")
-            return
-        }
-
-        if (isMultiDeviceActive) {
-            logger.info("MD is already activated")
-            return
-        }
-
-        persistedProperties = generateProperties(deviceLabel)
-
-        // TODO(ANDR-2519): Remove when md allows fs by default `activate` could then be non-suspending
-        if (!IS_FS_SUPPORTED_WITH_MD) {
-            disableForwardSecurity(taskManager, contactService, userService, fsMessageProcessor)
-        }
-        latestSocketCloseReason.tryEmit(null)
-        reconnect()
-    }
-
-    @AnyThread
-    override suspend fun deactivate(
-        taskManager: TaskManager,
-        userService: UserService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor
-    ) {
-        logger.debug("Deactivate multi device")
-
-        val mdProperties = properties ?: throw MultiDeviceException("Multi device properties are missing")
-
-        // TODO(ANDR-2519): Remove when md allows fs by default
-        if (!IS_FS_SUPPORTED_WITH_MD) {
-            enableForwardSecurity(userService, fsMessageProcessor)
-        }
-
-        serverInfo = null
-        _linkedDevices.clear()
-
-        deactivationOngoing = true
-
-        taskManager.schedule(OutgoingDropDeviceTask(mdProperties.mediatorDeviceId)).await()
-
-        // TODO(ANDR-2603): Unlink all linked devices (including own device id):
-        //  Ensure all linked devices are removed, then kick own device. When the connection is closed by the mediator with
-        //  a close code "kicked from group" the dgk can be deleted an md deactivated. It
-        //  would be even nicer if we can wait for the drop device ack of the own device
-        //  and then complete the task without being cancelled. This should be possible if the code
-        //  executed after the drop device ack is not cancellable.
-        //  Will it be possible to trigger a reconnect from the task?
-        //  There should probably be a dedicated task, that ensures that _all_ other devices are dropped and only then
-        //  drops the own device. If we are sure every other device is dropped and no device could be linked in the meantime
-        //  the task could still trigger deletion of the properties if connection to the mediator is not possible anymore because
-        //  the own device has already been dropped.
-        //   oh no -> if no connection is possible, no tasks will be executed...
-    }
-
-    override suspend fun setDeviceLabel(deviceLabel: String) {
-        persistedProperties = persistedProperties!!.withDeviceLabel(deviceLabel)
-    }
-
-    @AnyThread
-    override suspend fun linkDevice(
-        deviceJoinOfferUri: String,
-        deviceJoinDataCollector: DeviceJoinDataCollector,
-    ) {
-        logger.debug("Link device: {}", deviceJoinOfferUri)
-
-        _linkedDevices.add(deviceJoinOfferUri)
-        // TODO(ANDR-2484): Actual device linking
-
-        return try {
-            val deviceJoinData = withContext(Dispatchers.Default) {
-                collectDeviceJoinData(deviceJoinDataCollector)
-            }
-            deviceJoinData.essentialData.toString().lines().forEach {
-                logger.debug("Essential data: {}", it)
-            }
-        } catch (e: Exception) {
-            // This could for example be a MasterKeyLockedException since the data collector
-            // initialises some dependencies when data is collected (e.g. ContactService)
-            logger.error("Linking failed due to an exception", e)
-            // TODO(ANDR-2484): rethrow (dedicated type?) and abort linking
-            // TODO(ANDR-2487): show a message to users that linking failed
-        }
-    }
-
-    @WorkerThread
-    private fun collectDeviceJoinData(deviceJoinDataCollector: DeviceJoinDataCollector): DeviceJoinData {
-        // TODO(ANDR-2484): Make sure the state of the data cannot change during collection:
-        //  - disconnect from server
-        //  - do not perform any api calls?
-        //  - disconnect web clients
-        //  - stop workers..?
-        //  --> how is this done during a backup?
-
-        val dgk = properties?.keys?.dgk ?: throw InvalidStateException("Multi device is not active")
-
-        return deviceJoinDataCollector.collectData(dgk)
-    }
-
-    private fun onSocketClosed(reason: ServerSocketCloseReason) {
-        logger.info("Socket was closed with {}", reason)
-        if (reason is D2mSocketCloseReason) {
-            handleD2mSocketClose(reason)
-        }
-    }
-
-    private fun handleD2mSocketClose(reason: D2mSocketCloseReason) {
-        latestSocketCloseReason.tryEmit(reason)
-
-        // Handle close codes which do not allow a reconnect
-        when (reason.closeCode.code) {
-            D2mCloseCode.D2M_UNSUPPORTED_PROTOCOL_VERSION -> handleUnsupportedProtocolVersion()
-            D2mCloseCode.D2M_DEVICE_LIMIT_REACHED -> handleDeviceLimitReached()
-            D2mCloseCode.D2M_DUPLICATE_CONNECTION -> handleDuplicateConnection()
-            D2mCloseCode.D2M_DEVICE_DROPPED -> handleDeviceDropped()
-            D2mCloseCode.D2M_REFLECTION_QUEUE_LIMIT_REACHED -> handleDeviceDropped()
-            D2mCloseCode.D2M_EXPECTED_DEVICE_SLOT_MISMATCH -> handleDeviceSlotMismatch()
-        }
-    }
-
-    private fun handleUnsupportedProtocolVersion() {
-        displayConnectionError("Unsupported protocol version")
-    }
-    private fun handleDeviceLimitReached() {
-        displayConnectionError("Device limit reached")
-    }
-
-    private fun handleDuplicateConnection() {
-        displayConnectionError("Duplicate connection")
-    }
-
-    private fun handleDeviceDropped() {
-        if (deactivationOngoing) {
-            logger.debug("Device dropped during ongoing md deactivation. Delete properties.")
-            // complete deactivation: delete dgk etc.
-            persistedProperties = null
-            deactivationOngoing = false
-            reconnect()
-        } else {
-            displayConnectionError("Device was dropped")
-        }
-    }
-
-    private fun handleDeviceSlotMismatch() {
-        displayConnectionError("Device slot mismatch")
-
-        // TODO(ANDR-2603): Remove
-        deleteMdPropertiesAfterSlotMismatch()
-    }
-
-    private fun deleteMdPropertiesAfterSlotMismatch() {
-        // TODO(ANDR-2603): Remove this, as it is just a temporary workaround for an unsuccessful
-        //  md deactivation.
-        //  If deactivation of md has not been properly completed the client might already be dropped,
-        //  but the properties are not yet deleted.
-        //  In that state it is not possible to login on the server (expected slot mismatch) and therefore
-        //  a drop device cannot be sent (and actually does not have to, since the device has already
-        //  been dropped).
-        //  How to handle that case? How does iOS handle this situation?
-        //  Only if we are sure there are no other remaining devices in the device group md should be deactivated.
-        //  --> could lead to many "Another connection ..." server errors
-        logger.warn("Delete md properties after device slot mismatch")
-        deactivationOngoing = false
-        persistedProperties = null
-
-        // We do not reconnect automatically. After a restart of the app the csp connection will be used
-        // which should work. This way we could display an error to the user which will allow to react somehow
-        // before the connection is changed. Or there might even be a button "reconnect without md" in the
-        // shown dialog
-    }
-
-    /**
-     * Display a connection error to the user if a reconnect is not allowed.
-     */
-    private fun displayConnectionError(msg: String) {
-        // TODO(ANDR-2604): Show actual dialog to user
-        // TODO(ANDR-2604): Use string resources instead of string
-        // TODO(ANDR-2604): Only show error if a reconnect ist not allowed (see `D2mCloseCode#isReconnectAllowed()`)
-        logger.warn("Reconnect is not allowed: {}", msg)
-
-        val message = ServerMessageModel(msg, ServerMessageModel.TYPE_ERROR)
-        serverMessageService.saveIncomingServerMessage(message)
-    }
-
-    private fun reconnect() {
-        CoroutineScope(Dispatchers.Default).launch {
-            reconnectHandle?.reconnect() ?: logger.error("Reconnect handle is null")
-        }
-    }
-
-    // TODO(ANDR-2519): Remove when md allows fs
-    @AnyThread
-    private suspend fun disableForwardSecurity(
-        taskManager: TaskManager,
-        contactService: ContactService,
-        userService: UserService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor
-    ) {
-        withContext(Dispatchers.IO) {
-            updateFeatureMask(userService, false)
-            terminateAllForwardSecuritySessions(
-                taskManager,
-                contactService,
-                fsMessageProcessor
-            )
-            fsMessageProcessor.setForwardSecurityEnabled(false)
-        }
-    }
-
-    // TODO(ANDR-2519): Remove when md allows fs
-    @AnyThread
-    private suspend fun enableForwardSecurity(
-        userService: UserService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor
-    ) {
-        withContext(Dispatchers.IO) {
-            updateFeatureMask(userService, true)
-            fsMessageProcessor.setForwardSecurityEnabled(true)
-            // TODO(ANDR-2872): Run FS Refresh Steps
-        }
-    }
-
-    /**
-     * This terminates and deletes all forward security sessions that exist with other contacts.
-     */
-    // TODO(ANDR-2519): Remove when md allows fs
-    @WorkerThread
-    private suspend fun terminateAllForwardSecuritySessions(
-        taskManager: TaskManager,
-        contactService: ContactService,
-        fsMessageProcessor: ForwardSecurityMessageProcessor
-    ) {
-        contactService.all.map {
-            taskManager.schedule(
-                DeleteAndTerminateFSSessionsTask(
-                    fsMessageProcessor, it, Terminate.Cause.DISABLED_BY_LOCAL
-                )
-            )
-        }.awaitAll()
-    }
-
-    // TODO(ANDR-2519): Do not update feature mask when md supports fs
-    @WorkerThread
-    private fun updateFeatureMask(userService: UserService, isFsAllowed: Boolean) {
-        userService.setForwardSecurityEnabled(isFsAllowed)
-        userService.sendFeatureMask()
-    }
-
-    /**
-     * Generate the properties required to activate multi device.
-     * This includes device ids and md key material.
-     */
-    private fun generateProperties(deviceLabel: String): PersistedMultiDeviceProperties {
-        return PersistedMultiDeviceProperties(
-            null,
-            deviceLabel,
-            DeviceId(generateRandomU64()),
-            DeviceId(generateRandomU64()),
-            generateRandomBytes(D2mProtocolDefines.DGK_LENGTH_BYTES)
-        )
-    }
-
-    private fun mapPersistedProperties(persistedProperties: PersistedMultiDeviceProperties): MultiDeviceProperties {
-        return MultiDeviceProperties(
-            persistedProperties.registrationTime,
-            persistedProperties.mediatorDeviceId,
-            persistedProperties.cspDeviceId,
-            MultiDeviceKeys(persistedProperties.dgk),
-            createDeviceInfo(persistedProperties.deviceLabel),
-            D2mProtocolVersion(
-                D2mProtocolDefines.D2M_PROTOCOL_VERSION_MIN,
-                D2mProtocolDefines.D2M_PROTOCOL_VERSION_MAX
-            ),
-            ::updateServerInfo
-        )
-    }
-
-    private fun createDeviceInfo(deviceLabel: String): D2dMessage.DeviceInfo {
-        val platformDetails = listOfNotNull(Build.MANUFACTURER, Build.MODEL)
-            .joinToString(" ")
-
-        return D2dMessage.DeviceInfo(
-            D2dMessage.DeviceInfo.Platform.ANDROID,
-            platformDetails,
-            version.version,
-            deviceLabel
-        ).also { logger.trace("Device info created: {}", it) }
-    }
-
-    private suspend fun loadProperties(): PersistedMultiDeviceProperties? {
-        return withContext(Dispatchers.IO) {
-            if (preferenceStore.containsKey(PreferenceStore.PREFS_MD_PROPERTIES, true)) {
-                val bytes = preferenceStore.getBytes(PreferenceStore.PREFS_MD_PROPERTIES, true)
-                logger.trace("Properties size={}", bytes.size)
-                try {
-                    // return:
-                    PersistedMultiDeviceProperties.deserialize(bytes).also {
-                        logger.trace("Deserialized persisted md properties: {} -> {}", bytes.toHexString(5), it)
-                    }
-                } catch (e: PersistedMultiDeviceProperties.DeserializeException) {
-                    logger.error("Persisted properties are invalid. Remove properties.", e)
-                    preferenceStore.remove(PreferenceStore.PREFS_MD_PROPERTIES, true)
-                    // return:
-                    null
-                }
-
-            } else {
-                // return:
-                null
-            }
-        }
-    }
-
-    /**
-     * Store the properties in the preference store. If [properties] is null
-     * any persisted property will be removed.
-     */
-    @AnyThread
-    private fun storeProperties(properties: PersistedMultiDeviceProperties?) {
-        CoroutineScope(Dispatchers.IO).launch {
-            if (properties == null) {
-                logger.info("Delete md properties")
-                preferenceStore.remove(PreferenceStore.PREFS_MD_PROPERTIES, true)
-            } else {
-                val bytes = properties.serialize()
-                logger.trace("Serialize md properties: {} -> {}", properties, bytes.toHexString(5))
-                preferenceStore.save(PreferenceStore.PREFS_MD_PROPERTIES, properties.serialize(), true)
-            }
-        }
-    }
-
-    @AnyThread
-    private fun updateServerInfo(serverInfo: InboundD2mMessage.ServerInfo) {
-        this.serverInfo = serverInfo
-        // TODO(ANDR-2580): Trigger whatever is required based on the server info
-        CoroutineScope(Dispatchers.Default).launch {
-            updateRegistrationTime()
-        }
-    }
-
-
-    @AnyThread
-    private fun updateRegistrationTime() {
-        persistedProperties!!.let { properties ->
-            if (properties.registrationTime == null) {
-                logger.debug("Set time of first registration")
-                persistedProperties = properties.withRegistrationTime(Date().time.toULong())
-            } else {
-                logger.debug("Registration time already set. Ignore ServerInfo")
-            }
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/multidevice/PersistedMultiDeviceProperties.kt b/app/src/main/java/ch/threema/app/multidevice/PersistedMultiDeviceProperties.kt
deleted file mode 100644
index 0977d9aa..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/PersistedMultiDeviceProperties.kt
+++ /dev/null
@@ -1,153 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice
-
-import ch.threema.domain.protocol.D2mProtocolDefines
-import ch.threema.domain.protocol.connection.data.DeviceId
-import java.io.ByteArrayInputStream
-import java.io.ByteArrayOutputStream
-import java.io.DataInputStream
-import java.io.DataOutputStream
-import java.nio.charset.StandardCharsets
-
-internal data class PersistedMultiDeviceProperties (
-    val registrationTime: ULong?,
-    val deviceLabel: String,
-    val mediatorDeviceId: DeviceId,
-    val cspDeviceId: DeviceId,
-    val dgk: ByteArray
-
-) {
-
-    class DeserializeException(msg: String) : Error(msg)
-    companion object {
-
-        fun deserialize(byteArray: ByteArray): PersistedMultiDeviceProperties {
-            val minimalPropertiesSize = (
-                Long.SIZE_BYTES // registration time
-                + Int.SIZE_BYTES  // device label size
-                + Long.SIZE_BYTES // mediator device id
-                + Long.SIZE_BYTES // csp device id
-                + D2mProtocolDefines.DGK_LENGTH_BYTES // dgk
-            )
-
-            if (byteArray.size < minimalPropertiesSize) {
-                throw DeserializeException("Invalid data size. expected >= $minimalPropertiesSize, actual=${byteArray.size}")
-            }
-
-            return DataInputStream(ByteArrayInputStream(byteArray)).use {
-                // 1. registration time (8 bytes)
-                val time = it.readLong().toULong()
-                val registrationTime = if (time > 0UL) {
-                    time
-                } else {
-                    null
-                }
-                // 2. device label (variable bytes)
-                val deviceLabelSize = it.readInt()
-                val expectedLabelSize = byteArray.size - minimalPropertiesSize
-                if (deviceLabelSize != expectedLabelSize) {
-                    throw DeserializeException("Invalid data: expectedLabelSize=$expectedLabelSize, provided=$deviceLabelSize")
-                }
-                val deviceLabelBytes = ByteArray(deviceLabelSize)
-                it.read(deviceLabelBytes)
-                val deviceLabel = String(deviceLabelBytes, StandardCharsets.UTF_8)
-                // 3. mediator device id (8bytes)
-                val mediatorDeviceId = DeviceId(it.readLong().toULong())
-                // 4. csp device id (8 bytes)
-                val cspDeviceId = DeviceId(it.readLong().toULong())
-                // 5. dgk
-                val dgk = ByteArray(D2mProtocolDefines.DGK_LENGTH_BYTES)
-                it.read(dgk)
-                PersistedMultiDeviceProperties(
-                    registrationTime,
-                    deviceLabel,
-                    mediatorDeviceId,
-                    cspDeviceId,
-                    dgk
-                )
-            }
-        }
-    }
-
-    fun serialize(): ByteArray {
-        val bos = ByteArrayOutputStream()
-        DataOutputStream(bos).use {
-            // 1. registration time
-            it.writeLong(registrationTime?.toLong() ?: 0L)
-            // 2. device label
-            val deviceLabelBytes = deviceLabel.encodeToByteArray()
-            it.writeInt(deviceLabelBytes.size)
-            it.write(deviceLabelBytes)
-            // 3. mediator device id
-            it.writeLong(mediatorDeviceId.id.toLong())
-            // 4. csp device id
-            it.writeLong(cspDeviceId.id.toLong())
-            // 5. dgk
-            it.write(dgk)
-        }
-        return bos.toByteArray()
-
-    }
-
-    fun withRegistrationTime(registrationTime: ULong?): PersistedMultiDeviceProperties {
-        return PersistedMultiDeviceProperties(
-            registrationTime,
-            deviceLabel,
-            mediatorDeviceId,
-            cspDeviceId,
-            dgk
-        )
-    }
-
-    fun withDeviceLabel(deviceLabel: String): PersistedMultiDeviceProperties {
-        return PersistedMultiDeviceProperties(
-            registrationTime,
-            deviceLabel,
-            mediatorDeviceId,
-            cspDeviceId,
-            dgk
-        )
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is PersistedMultiDeviceProperties) return false
-
-        if (!dgk.contentEquals(other.dgk)) return false
-        if (mediatorDeviceId != other.mediatorDeviceId) return false
-        if (cspDeviceId != other.cspDeviceId) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        var result = dgk.contentHashCode()
-        result = 31 * result + mediatorDeviceId.hashCode()
-        result = 31 * result + cspDeviceId.hashCode()
-        return result
-    }
-
-    override fun toString(): String {
-        return "PersistedMultiDeviceProperties(registrationTime=$registrationTime, deviceLabel='$deviceLabel', mediatorDeviceId=$mediatorDeviceId, cspDeviceId=$cspDeviceId, dgk=********)"
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/multidevice/linking/DeviceJoinDataCollector.kt b/app/src/main/java/ch/threema/app/multidevice/linking/DeviceJoinDataCollector.kt
deleted file mode 100644
index 19cb441c..00000000
--- a/app/src/main/java/ch/threema/app/multidevice/linking/DeviceJoinDataCollector.kt
+++ /dev/null
@@ -1,766 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.multidevice.linking
-
-import android.graphics.Bitmap
-import androidx.annotation.WorkerThread
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.DeadlineListService
-import ch.threema.app.services.license.LicenseServiceUser
-import ch.threema.app.utils.BitmapUtil
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.ConversationUtil.getConversationUid
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.protobuf.Common.BlobData
-import ch.threema.protobuf.Common.DeltaImage
-import ch.threema.protobuf.Common.Identities
-import ch.threema.protobuf.Common.Image
-import ch.threema.protobuf.blob
-import ch.threema.protobuf.blobData
-import ch.threema.protobuf.d2d.join.EssentialDataKt.augmentedContact
-import ch.threema.protobuf.d2d.join.EssentialDataKt.augmentedDistributionList
-import ch.threema.protobuf.d2d.join.EssentialDataKt.augmentedGroup
-import ch.threema.protobuf.d2d.join.EssentialDataKt.deviceGroupData
-import ch.threema.protobuf.d2d.join.EssentialDataKt.identityData
-import ch.threema.protobuf.d2d.join.MdD2DJoin.EssentialData
-import ch.threema.protobuf.d2d.join.MdD2DJoin.EssentialData.AugmentedContact
-import ch.threema.protobuf.d2d.join.MdD2DJoin.EssentialData.AugmentedDistributionList
-import ch.threema.protobuf.d2d.join.MdD2DJoin.EssentialData.AugmentedGroup
-import ch.threema.protobuf.d2d.join.MdD2DJoin.EssentialData.IdentityData
-import ch.threema.protobuf.d2d.join.essentialData
-import ch.threema.protobuf.d2d.sync.ContactKt
-import ch.threema.protobuf.d2d.sync.ContactKt.readReceiptPolicyOverride
-import ch.threema.protobuf.d2d.sync.ContactKt.typingIndicatorPolicyOverride
-import ch.threema.protobuf.d2d.sync.GroupKt
-import ch.threema.protobuf.d2d.sync.MdD2DSync
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.NotificationSoundPolicyOverride
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.NotificationTriggerPolicyOverride
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.SyncState
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Contact.VerificationLevel
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Group.UserState
-import ch.threema.protobuf.d2d.sync.MdD2DSync.Settings
-import ch.threema.protobuf.d2d.sync.MdD2DSync.UserProfile.IdentityLinks
-import ch.threema.protobuf.d2d.sync.MdD2DSync.UserProfile.ProfilePictureShareWith
-import ch.threema.protobuf.d2d.sync.UserProfileKt.IdentityLinksKt.identityLink
-import ch.threema.protobuf.d2d.sync.UserProfileKt.identityLinks
-import ch.threema.protobuf.d2d.sync.UserProfileKt.profilePictureShareWith
-import ch.threema.protobuf.d2d.sync.contact
-import ch.threema.protobuf.d2d.sync.distributionList
-import ch.threema.protobuf.d2d.sync.group
-import ch.threema.protobuf.d2d.sync.settings
-import ch.threema.protobuf.d2d.sync.threemaWorkCredentials
-import ch.threema.protobuf.d2d.sync.userProfile
-import ch.threema.protobuf.deltaImage
-import ch.threema.protobuf.groupIdentity
-import ch.threema.protobuf.identities
-import ch.threema.protobuf.image
-import ch.threema.protobuf.unit
-import ch.threema.storage.models.ContactModel
-import ch.threema.storage.models.DistributionListModel
-import ch.threema.storage.models.GroupModel
-import com.google.protobuf.ByteString
-import java.nio.ByteBuffer
-
-private val logger = LoggingUtil.getThreemaLogger("DeviceJoinDataCollector")
-
-data class DeviceJoinData(val blobs: Sequence<BlobData>, val essentialData: EssentialData)
-
-class BlobDataProvider (private val blobId: ByteArray?, private val dataProvider: () -> ByteArray?) {
-    /**
-     * Get this providers [BlobData].
-     *
-     * @return [BlobData] or null if no blobId or actual data is available
-     */
-    fun get(): BlobData? {
-        if (blobId == null) {
-            return null
-        }
-
-        logger.debug("Invoke blob data provider")
-        return dataProvider.invoke()?.toByteString()?.let {
-            blobData {
-                id = blobId.toByteString()
-                data = it
-            }
-        }
-    }
-}
-
-class DeviceJoinDataCollector(
-    serviceManager: ServiceManager
-) {
-    private val identityStore by lazy { serviceManager.identityStore }
-    private val userService by lazy { serviceManager.userService }
-    private val contactService by lazy { serviceManager.contactService }
-    private val groupService by lazy { serviceManager.groupService }
-    private val distributionListService by lazy { serviceManager.distributionListService }
-    private val deviceCookieManager by lazy { serviceManager.deviceCookieManager }
-    private val preferenceService by lazy { serviceManager.preferenceService }
-    private val blockedIdentitiesService by lazy { serviceManager.blockedContactsService }
-    private val excludeFromSyncService by lazy { serviceManager.excludedSyncIdentitiesService }
-    private val fileService by lazy { serviceManager.fileService }
-    private val hiddenChatsService by lazy { serviceManager.hiddenChatsListService }
-    private val conversationService by lazy { serviceManager.conversationService }
-    private val mutedChatsService by lazy { serviceManager.mutedChatsListService }
-    private val mentionOnlyChatsService by lazy { serviceManager.mentionOnlyChatsListService }
-    private val ringtoneService by lazy { serviceManager.ringtoneService }
-    private val nonceFactory by lazy { serviceManager.nonceFactory }
-    private val licenseService by lazy { serviceManager.licenseService }
-
-    @WorkerThread
-    fun collectData(dgk: ByteArray): DeviceJoinData {
-        val blobDataProviders = mutableListOf<BlobDataProvider>()
-
-        val data = essentialData {
-            logger.trace("Collect identity data")
-            this.identityData = collectIdentityData()
-
-            logger.trace("Collect device group data")
-            this.deviceGroupData = deviceGroupData {
-                this.dgk = dgk.toByteString()
-            }
-
-            logger.trace("Collect user profile")
-            val (userProfileBlobProvider, userProfileData) = collectUserProfile()
-            blobDataProviders.add(userProfileBlobProvider)
-            this.userProfile = userProfileData
-
-            logger.trace("Collect settings")
-            this.settings = collectSettings()
-
-            val conversationsStats = collectConversationsStats()
-
-            logger.trace("Collect contacts")
-            collectContacts(conversationsStats).forEach { (contactBlobDataProviders, contact) ->
-                blobDataProviders.addAll(contactBlobDataProviders)
-                this.contacts += contact
-            }
-
-            logger.trace("Collect groups")
-            collectGroups(conversationsStats).forEach { (groupBlobDataProviders, group) ->
-                blobDataProviders.addAll(groupBlobDataProviders)
-                this.groups += group
-            }
-
-            logger.trace("Collect distribution lists")
-            this.distributionLists += collectDistributionLists(conversationsStats)
-
-            logger.trace("Collect csp nonce hashes")
-            this.cspHashedNonces += collectCspNonceHashes()
-
-
-            // TODO(ANDR-2632): At the moment we do not store any d2d nonces
-            this.d2DHashedNonces.clear()
-
-            // work
-            if (ConfigUtils.isWorkBuild()) {
-                logger.trace("Collect work credentials")
-                this.workCredentials = collectWorkCredentials()
-                    ?: throw IllegalStateException("No work credentials available in work build")
-
-                // mdm parameters TODO(ANDR-2670)
-            //            this.mdmParameters = collectMdmParameters()
-            }
-        }
-
-        logger.debug("Number of blobDataProviders: {}", blobDataProviders.size)
-        val blobsSequence = blobDataProviders
-            .asSequence()
-            .mapNotNull { it.get() }
-
-        return DeviceJoinData(blobsSequence, data)
-    }
-
-    private fun collectIdentityData(): IdentityData {
-        return identityData {
-            identity = identityStore.identity
-            ck = identityStore.privateKey.toByteString()
-            cspDeviceCookie = deviceCookieManager.obtainDeviceCookie().toByteString()
-            cspServerGroup = identityStore.serverGroup
-        }
-    }
-
-    private fun collectUserProfile(): Pair<BlobDataProvider, MdD2DSync.UserProfile> {
-        return collectUserProfilePicture().let { (blobDataProvider, avatar) ->
-            blobDataProvider to userProfile {
-                nickname = identityStore.publicNickname
-                profilePicture = avatar
-                profilePictureShareWith = collectProfilePictureShareWith()
-                identityLinks = collectIdentityLinks()
-            }
-        }
-    }
-
-    private fun collectUserProfilePicture(): Pair<BlobDataProvider, DeltaImage> {
-        val profilePictureData = contactService.updatedProfilePictureUploadData
-
-        val hasProfilePicture = profilePictureData.blobId != null
-            && !profilePictureData.blobId.contentEquals(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)
-
-        val profilePicture = if (hasProfilePicture) {
-            val blobMeta = blob {
-                id = profilePictureData.blobId.toByteString()
-                nonce = ProtocolDefines.CONTACT_PHOTO_NONCE.toByteString()
-                key = profilePictureData.encryptionKey.toByteString()
-                uploadedAt = profilePictureData.uploadedAt
-            }
-
-            deltaImage { updated = image {
-                type = Image.Type.JPEG
-                blob = blobMeta
-            } }
-        } else {
-            deltaImage { removed = unit {} }
-        }
-
-        val blobDataProvider = BlobDataProvider(profilePictureData.blobId) {
-            profilePictureData.bitmapArray
-        }
-
-        return blobDataProvider to profilePicture
-    }
-
-    private fun collectProfilePictureShareWith(): ProfilePictureShareWith {
-        val policy = contactService.profilePictureSharePolicy
-
-        return profilePictureShareWith {
-            when (policy.policy) {
-                ContactService.ProfilePictureSharePolicy.Policy.NOBODY -> nobody = unit {}
-                ContactService.ProfilePictureSharePolicy.Policy.EVERYONE -> everyone = unit {}
-                ContactService.ProfilePictureSharePolicy.Policy.SOME -> {
-                    allowList = identities { identities += policy.allowedIdentities }
-                }
-            }
-        }
-    }
-
-    private fun collectIdentityLinks(): IdentityLinks {
-        return identityLinks {
-            userService.linkedMobileE164?.let {
-                links += identityLink { phoneNumber = it }
-            }
-            userService.linkedEmail?.let {
-                links += identityLink { email = it }
-            }
-        }
-    }
-
-    private fun collectSettings(): Settings {
-        return settings {
-            contactSyncPolicy = if (preferenceService.isSyncContacts) {
-                Settings.ContactSyncPolicy.SYNC
-            } else {
-                Settings.ContactSyncPolicy.NOT_SYNCED
-            }
-            unknownContactPolicy = if (preferenceService.isBlockUnknown) {
-                Settings.UnknownContactPolicy.BLOCK_UNKNOWN
-            } else {
-                Settings.UnknownContactPolicy.ALLOW_UNKNOWN
-            }
-            readReceiptPolicy = if (preferenceService.isReadReceipts) {
-                MdD2DSync.ReadReceiptPolicy.SEND_READ_RECEIPT
-            } else {
-                MdD2DSync.ReadReceiptPolicy.DONT_SEND_READ_RECEIPT
-            }
-            typingIndicatorPolicy = if (preferenceService.isTypingIndicator) {
-                MdD2DSync.TypingIndicatorPolicy.SEND_TYPING_INDICATOR
-            } else {
-                MdD2DSync.TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR
-            }
-            o2OCallPolicy = if (preferenceService.isVoipEnabled) {
-                Settings.O2oCallPolicy.ALLOW_O2O_CALL
-            } else {
-                Settings.O2oCallPolicy.DENY_O2O_CALL
-            }
-            o2OCallConnectionPolicy = if (preferenceService.forceTURN) {
-                Settings.O2oCallConnectionPolicy.REQUIRE_RELAYED_CONNECTION
-            } else {
-                Settings.O2oCallConnectionPolicy.ALLOW_DIRECT_CONNECTION
-            }
-            o2OCallVideoPolicy = if (preferenceService.isVideoCallsEnabled) {
-                Settings.O2oCallVideoPolicy.ALLOW_VIDEO
-            } else {
-                Settings.O2oCallVideoPolicy.DENY_VIDEO
-            }
-            groupCallPolicy = if (preferenceService.isGroupCallsEnabled) {
-                Settings.GroupCallPolicy.ALLOW_GROUP_CALL
-            } else {
-                Settings.GroupCallPolicy.DENY_GROUP_CALL
-            }
-            screenshotPolicy = if (preferenceService.isDisableScreenshots) {
-                Settings.ScreenshotPolicy.DENY_SCREENSHOT
-            } else {
-                Settings.ScreenshotPolicy.ALLOW_SCREENSHOT
-            }
-            keyboardDataCollectionPolicy = if (preferenceService.incognitoKeyboard) {
-                Settings.KeyboardDataCollectionPolicy.DENY_DATA_COLLECTION
-            } else {
-                Settings.KeyboardDataCollectionPolicy.ALLOW_DATA_COLLECTION
-            }
-            blockedIdentities = collectBlockedIdentities()
-            excludeFromSyncIdentities = collectExcludeFromSyncIdentities()
-        }
-    }
-
-    private fun collectBlockedIdentities(): Identities {
-        return identities {
-            identities += blockedIdentitiesService.all.toSet()
-        }
-    }
-
-    private fun collectExcludeFromSyncIdentities(): Identities {
-        return identities {
-            identities += excludeFromSyncService.all.toSet()
-        }
-    }
-
-    private data class ConversationStats(
-        val isArchived: Boolean,
-        val isPinned: Boolean,
-        val lastMessageCreatedAt: Long?
-    )
-
-    private fun collectConversationsStats(): Map<String, ConversationStats> {
-        val notArchived = conversationService.getAll(true).associate {
-            it.uid to ConversationStats(false, it.isPinTagged, it.latestMessage?.createdAt?.time)
-        }
-        val archived = conversationService.getArchived(null).associate {
-            it.uid to ConversationStats(
-                isArchived = true,
-                isPinned = false,
-                lastMessageCreatedAt = it.latestMessage?.createdAt?.time)
-        }
-        return notArchived + archived
-    }
-
-    private fun collectContacts(conversationsStats: Map<String, ConversationStats>): List<Pair<List<BlobDataProvider>, AugmentedContact>> {
-        return contactService.all
-            .map { mapToAugmentedContact(it, conversationsStats) }
-            .also { logger.trace("{} contacts", it.size)}
-    }
-
-    private fun mapToAugmentedContact(contactModel: ContactModel, conversationsStats: Map<String, ConversationStats>): Pair<List<BlobDataProvider>, AugmentedContact> {
-        val blobDataProviders = mutableListOf<BlobDataProvider>()
-
-        val conversationStats = conversationsStats[contactModel.getConversationUid()]
-
-        val contact = contact {
-            identity = contactModel.identity
-            publicKey = contactModel.publicKey.toByteString()
-            createdAt = contactModel.dateCreated?.time ?: System.currentTimeMillis()
-            firstName = contactModel.firstName ?: ""
-            lastName = contactModel.lastName ?: ""
-            nickname = contactModel.publicNickName ?: ""
-            verificationLevel = mapVerificationLevel(contactModel)
-            workVerificationLevel = when {
-                contactModel.isWork -> Contact.WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
-                else -> Contact.WorkVerificationLevel.NONE
-            }
-            identityType = when (contactModel.identityType) {
-                IdentityType.NORMAL -> Contact.IdentityType.REGULAR
-                IdentityType.WORK -> Contact.IdentityType.WORK
-                else -> Contact.IdentityType.UNRECOGNIZED
-            }
-            acquaintanceLevel = when (contactModel.acquaintanceLevel) {
-                ContactModel.AcquaintanceLevel.GROUP -> Contact.AcquaintanceLevel.GROUP
-                ContactModel.AcquaintanceLevel.DIRECT -> Contact.AcquaintanceLevel.DIRECT
-            }
-            activityState = when (contactModel.state) {
-                ContactModel.State.ACTIVE -> Contact.ActivityState.ACTIVE
-                ContactModel.State.INACTIVE -> Contact.ActivityState.INACTIVE
-                ContactModel.State.INVALID -> Contact.ActivityState.INVALID
-                else -> throw IllegalStateException("Contact ${contactModel.identity} has missing state")
-            }
-            featureMask = contactModel.featureMask
-            syncState = collectSyncState(contactModel)
-            readReceiptPolicyOverride = readReceiptPolicyOverride {
-                val readReceipts = contactModel.readReceipts
-                if (readReceipts == ContactModel.DEFAULT) {
-                    default = unit {}
-                } else {
-                    policy = when (readReceipts) {
-                        ContactModel.DONT_SEND -> MdD2DSync.ReadReceiptPolicy.DONT_SEND_READ_RECEIPT
-                        ContactModel.SEND -> MdD2DSync.ReadReceiptPolicy.SEND_READ_RECEIPT
-                        else -> throw IllegalStateException("Invalid read receipt policy override $readReceipts for contact ${contactModel.identity}")
-                    }
-                }
-            }
-            typingIndicatorPolicyOverride = typingIndicatorPolicyOverride {
-                if (contactModel.typingIndicators == ContactModel.DEFAULT) {
-                    default = unit {}
-                } else {
-                    policy = when (contactModel.typingIndicators) {
-                        ContactModel.DONT_SEND -> MdD2DSync.TypingIndicatorPolicy.DONT_SEND_TYPING_INDICATOR
-                        ContactModel.SEND -> MdD2DSync.TypingIndicatorPolicy.SEND_TYPING_INDICATOR
-                        else -> throw IllegalStateException("Invalid typing indicator policy override ${contactModel.typingIndicators} for contact ${contactModel.identity}")
-                    }
-                }
-            }
-            notificationTriggerPolicyOverride = collectContactNotificationTriggerPolicyOverride(contactModel)
-            notificationSoundPolicyOverride = collectNotificationSoundPolicyOverride(contactModel)
-
-            collectContactDefinedProfilePicture(contactModel)?.let { (blobDataProvider, image) ->
-                blobDataProviders.add(blobDataProvider)
-                contactDefinedProfilePicture = image
-            }
-            collectUserDefinedProfilePicture(contactModel)?.let { (blobDataProvider, image) ->
-                blobDataProviders.add(blobDataProvider)
-                userDefinedProfilePicture = image
-            }
-
-            conversationCategory = if (hiddenChatsService.has(contactModel.getUniqueId())) {
-                MdD2DSync.ConversationCategory.PROTECTED
-            } else {
-                MdD2DSync.ConversationCategory.DEFAULT
-            }
-
-            conversationVisibility = if (conversationStats?.isPinned == true) {
-                MdD2DSync.ConversationVisibility.PINNED
-            } else if (conversationStats?.isArchived == true) {
-                MdD2DSync.ConversationVisibility.ARCHIVED
-            } else {
-                MdD2DSync.ConversationVisibility.NORMAL
-            }
-        }
-
-        val augmentedContact = augmentedContact {
-            this.contact = contact
-            conversationStats?.lastMessageCreatedAt?.let {
-                this.lastUpdateAt = it
-            }
-        }
-
-        return blobDataProviders to augmentedContact
-    }
-
-    private fun collectSyncState(contactModel: ContactModel): SyncState {
-        // TODO(ANDR-2327): Consolidate this mechanism
-        return if (contactModel.isLinkedToAndroidContact) {
-            SyncState.IMPORTED
-        } else  if (contactModel.lastName.isNullOrBlank() && contactModel.firstName.isNullOrBlank()) {
-            SyncState.INITIAL
-        } else {
-            SyncState.CUSTOM
-        }
-    }
-
-    private fun collectContactNotificationTriggerPolicyOverride(contactModel: ContactModel): NotificationTriggerPolicyOverride {
-        val mutedUntil = mutedChatsService.getDeadline(contactModel.getUniqueId())
-        return if (mutedUntil == DeadlineListService.DEADLINE_INDEFINITE || mutedUntil > 0) {
-            ContactKt.notificationTriggerPolicyOverride {
-                policy = ContactKt.NotificationTriggerPolicyOverrideKt.policy {
-                    policy = NotificationTriggerPolicy.NEVER
-                    if (mutedUntil > 0) {
-                        expiresAt = mutedUntil
-                    }
-                }
-            }
-        } else {
-            ContactKt.notificationTriggerPolicyOverride {
-                default = unit {}
-            }
-        }
-    }
-
-    private fun collectNotificationSoundPolicyOverride(contactModel: ContactModel): NotificationSoundPolicyOverride {
-        return ContactKt.notificationSoundPolicyOverride {
-            if (ringtoneService.isSilent(contactModel.getUniqueId(), false)) {
-                policy = MdD2DSync.NotificationSoundPolicy.MUTED
-            } else {
-                default = unit {}
-            }
-        }
-    }
-
-    private fun ContactModel.getUniqueId(): String {
-        return contactService.getUniqueIdString(this)
-    }
-
-    private fun collectContactDefinedProfilePicture(contactModel: ContactModel): Pair<BlobDataProvider, DeltaImage>? {
-        return if (fileService.hasContactPhotoFile(contactModel.identity)) {
-            createJpegBlobAssets { fileService.getContactPhoto(contactModel.identity) }
-        } else {
-            null
-        }
-    }
-
-    private fun collectUserDefinedProfilePicture(contactModel: ContactModel): Pair<BlobDataProvider, DeltaImage>? {
-        return if (fileService.hasContactAvatarFile(contactModel.identity)) {
-            createJpegBlobAssets { fileService.getContactAvatar(contactModel.identity) }
-        } else {
-            null
-        }
-    }
-
-    private fun createJpegBlobAssets(bitmapProvider: () -> Bitmap?): Pair<BlobDataProvider, DeltaImage> {
-        val blobId = getNextBlobId()
-
-        val blobDataProvider = BlobDataProvider(blobId) {
-            bitmapProvider.invoke()?.let { BitmapUtil.bitmapToJpegByteArray(it) }
-        }
-
-        val blobMeta = blob { id = blobId.toByteString() }
-
-        val picture = deltaImage { updated = image {
-            type = Image.Type.JPEG
-            blob = blobMeta
-        } }
-        return blobDataProvider to picture
-    }
-
-    private fun mapVerificationLevel(contactModel: ContactModel): VerificationLevel {
-        return when (contactModel.verificationLevel) {
-            ch.threema.domain.models.VerificationLevel.UNVERIFIED -> VerificationLevel.UNVERIFIED
-            ch.threema.domain.models.VerificationLevel.SERVER_VERIFIED -> VerificationLevel.SERVER_VERIFIED
-            ch.threema.domain.models.VerificationLevel.FULLY_VERIFIED -> VerificationLevel.FULLY_VERIFIED
-        }
-    }
-
-    private fun collectGroups(conversationsStats: Map<String, ConversationStats>): List<Pair<List<BlobDataProvider>, AugmentedGroup>> {
-        return groupService.all.map {
-            mapToAugmentedGroup(it, conversationsStats)
-        }.also { logger.trace("{} groups", it.size) }
-    }
-
-    private fun mapToAugmentedGroup(groupModel: GroupModel, conversationsStats: Map<String, ConversationStats>): Pair<List<BlobDataProvider>, AugmentedGroup> {
-        val blobDataProviders = mutableListOf<BlobDataProvider>()
-
-        val conversationStats = conversationsStats[groupModel.getConversationUid()]
-
-        val group = group {
-            groupIdentity = groupIdentity {
-                groupId = groupModel.apiGroupId.toLong()
-                creatorIdentity = groupModel.creatorIdentity
-            }
-            name = groupModel.name ?: ""
-            createdAt = groupModel.createdAt.time
-            userState = if (groupService.isGroupMember(groupModel)) {
-                UserState.MEMBER
-            } else {
-                // TODO(ANDR-2676)
-                //  at the moment we cannot distinguish between KICKED and LEFT
-                UserState.KICKED
-            }
-            notificationTriggerPolicyOverride = collectGroupNotificationTriggerPolicyOverride(groupModel)
-            notificationSoundPolicyOverride = collectGroupNotificationSoundPolicyOverride(groupModel)
-            collectGroupAvatar(groupModel)?.let { (groupAvatarBlobDataProvider, image) ->
-                blobDataProviders.add(groupAvatarBlobDataProvider)
-                profilePicture = image
-            }
-            memberIdentities = collectGroupIdentities(groupModel)
-            conversationCategory = if (hiddenChatsService.has(groupModel.getUniqueId())) {
-                MdD2DSync.ConversationCategory.PROTECTED
-            } else {
-                MdD2DSync.ConversationCategory.DEFAULT
-            }
-            conversationVisibility = if (conversationStats?.isPinned == true) {
-                MdD2DSync.ConversationVisibility.PINNED
-            } else if (conversationStats?.isArchived == true) {
-                MdD2DSync.ConversationVisibility.ARCHIVED
-            } else {
-                MdD2DSync.ConversationVisibility.NORMAL
-            }
-        }
-
-        val augmentedGroup = augmentedGroup {
-            this.group = group
-            this.lastUpdateAt = conversationStats?.lastMessageCreatedAt
-                ?: groupModel.createdAt.time
-        }
-        return blobDataProviders to augmentedGroup
-    }
-
-    private fun collectGroupAvatar(groupModel: GroupModel): Pair<BlobDataProvider, DeltaImage>? {
-        return if (fileService.hasGroupAvatarFile(groupModel)) {
-            createJpegBlobAssets { fileService.getGroupAvatar(groupModel) }
-        } else {
-            null
-        }
-    }
-
-    /**
-     * @return The provided group's member identities NOT including the user itself
-     */
-    private fun collectGroupIdentities(groupModel: GroupModel): Identities {
-        return identities {
-            identities += groupService
-                .getGroupIdentities(groupModel)
-                .filter { it != identityStore.identity }
-        }
-    }
-
-    private fun collectGroupNotificationTriggerPolicyOverride(groupModel: GroupModel): MdD2DSync.Group.NotificationTriggerPolicyOverride {
-        val uid = groupModel.getUniqueId()
-
-        return if (mentionOnlyChatsService.has(uid)) {
-            GroupKt.notificationTriggerPolicyOverride {
-                policy = GroupKt.NotificationTriggerPolicyOverrideKt.policy {
-                    policy = MdD2DSync.Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy.MENTIONED
-                }
-            }
-        } else {
-            val mutedUntil = mutedChatsService.getDeadline(uid)
-            if (mutedUntil == DeadlineListService.DEADLINE_INDEFINITE || mutedUntil > 0) {
-                GroupKt.notificationTriggerPolicyOverride {
-                    policy = GroupKt.NotificationTriggerPolicyOverrideKt.policy {
-                        policy = MdD2DSync.Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy.NEVER
-                        if (mutedUntil > 0) {
-                            expiresAt = mutedUntil
-                        }
-                    }
-                }
-            } else {
-                GroupKt.notificationTriggerPolicyOverride {
-                    default = unit {}
-                }
-            }
-        }
-    }
-
-    private fun collectGroupNotificationSoundPolicyOverride(groupModel: GroupModel): MdD2DSync.Group.NotificationSoundPolicyOverride {
-        return GroupKt.notificationSoundPolicyOverride {
-            if (ringtoneService.isSilent(groupModel.getUniqueId(), true)) {
-                policy = MdD2DSync.NotificationSoundPolicy.MUTED
-            } else {
-                default = unit {}
-            }
-        }
-    }
-
-    private fun GroupModel.getUniqueId(): String {
-        return groupService.getUniqueIdString(this)
-    }
-
-    /**
-     * Collect the distribution lists and ignore lists without members.
-     */
-    private fun collectDistributionLists(conversationsStats: Map<String, ConversationStats>): List<AugmentedDistributionList> {
-        return distributionListService.all.mapNotNull {
-            mapToAugmentedDistributionList(it, conversationsStats)
-        }.also { logger.trace("{} distribution lists", it.size) }
-    }
-
-    /**
-     * Returns null if the [distributionListModel] does not have any members
-     */
-    private fun mapToAugmentedDistributionList(
-        distributionListModel: DistributionListModel,
-        conversationsStats: Map<String, ConversationStats>
-    ): AugmentedDistributionList? {
-        val conversationStats = conversationsStats[distributionListModel.getConversationUid()]
-
-        return collectDistributionListIdentities(distributionListModel)?.let { identities ->
-            distributionList {
-                distributionListId = distributionListModel.id
-                name = distributionListModel.name ?: ""
-                createdAt = distributionListModel.createdAt.time
-                memberIdentities = identities
-                conversationCategory = if (hiddenChatsService.has(distributionListModel.getUniqueId())) {
-                    MdD2DSync.ConversationCategory.PROTECTED
-                } else {
-                    MdD2DSync.ConversationCategory.DEFAULT
-                }
-                conversationVisibility = if (conversationStats?.isPinned == true) {
-                    MdD2DSync.ConversationVisibility.PINNED
-                } else if (conversationStats?.isArchived == true) {
-                    MdD2DSync.ConversationVisibility.ARCHIVED
-                } else {
-                    MdD2DSync.ConversationVisibility.NORMAL
-                }
-            }
-        }?.let {
-            augmentedDistributionList {
-                this.distributionList = it
-                this.lastUpdateAt = conversationStats?.lastMessageCreatedAt
-                    ?: distributionListModel.createdAt.time
-            }
-        }
-    }
-
-    private fun DistributionListModel.getUniqueId(): String {
-        return distributionListService.getUniqueIdString(this)
-    }
-
-    private fun collectDistributionListIdentities(distributionListModel: DistributionListModel): Identities? {
-        return distributionListService
-            .getDistributionListIdentities(distributionListModel)
-            .toList()
-            .ifEmpty { null }
-            ?.let {
-                identities {
-                    identities += it
-                }
-            }
-    }
-
-    private fun collectCspNonceHashes(): Set<ByteString> {
-        return nonceFactory.allHashedNonces.map { it.toByteString() }
-            .toSet()
-            .also { logger.trace("{} csp nonce hashes", it.size) }
-    }
-
-    private fun collectWorkCredentials(): MdD2DSync.ThreemaWorkCredentials? {
-        val credentials = licenseService.let {
-            if (it is LicenseServiceUser) {
-                it.loadCredentials()
-            } else {
-                null
-            }
-        }
-        return credentials?.let {
-            threemaWorkCredentials {
-                username = it.username
-                password = it.password
-            }
-        }
-    }
-
-    //    TODO(ANDR-2670)
-//    private fun collectMdmParameters(): MdmParameters {
-//        return mdmParameters {
-//            externalParameters = ...
-//            threemaParameters = ...
-//            parameterPrecedence = ...
-//        }
-//    }
-
-    private companion object {
-        private var nextBlobId = 1L
-        fun getNextBlobId(): ByteArray {
-            return ByteBuffer.wrap(ByteArray(ProtocolDefines.BLOB_ID_LEN))
-                .putLong(nextBlobId++)
-                .array()
-                .also { if (it.size != ProtocolDefines.BLOB_ID_LEN) {
-                    throw IllegalStateException("Invalid blob id generated")
-                } }
-        }
-    }
-}
-
-private fun ByteArray.toByteString(): ByteString {
-    return ByteString.copyFrom(this)
-}
diff --git a/app/src/main/java/ch/threema/app/notifications/ForwardSecurityNotificationManager.kt b/app/src/main/java/ch/threema/app/notifications/ForwardSecurityNotificationManager.kt
deleted file mode 100644
index 33373223..00000000
--- a/app/src/main/java/ch/threema/app/notifications/ForwardSecurityNotificationManager.kt
+++ /dev/null
@@ -1,132 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.notifications
-
-import android.Manifest
-import android.annotation.SuppressLint
-import android.app.PendingIntent
-import android.content.Context
-import android.content.Intent
-import android.content.pm.PackageManager
-import android.os.Build
-import androidx.core.app.ActivityCompat
-import androidx.core.app.NotificationCompat
-import androidx.core.app.NotificationManagerCompat
-import ch.threema.app.R
-import ch.threema.app.activities.ComposeMessageActivity
-import ch.threema.app.messagereceiver.ContactMessageReceiver
-import ch.threema.app.messagereceiver.GroupMessageReceiver
-import ch.threema.app.messagereceiver.MessageReceiver
-import ch.threema.app.services.DeadlineListService
-import ch.threema.app.utils.IntentDataUtil
-import ch.threema.base.utils.LoggingUtil
-import kotlin.random.Random
-
-private val logger = LoggingUtil.getThreemaLogger("ForwardSecurityNotificationManager")
-
-class ForwardSecurityNotificationManager(
-    private val context: Context,
-    private val hiddenChatListService: DeadlineListService,
-) {
-    private val notificationIdMap = HashMap<String, Int>()
-
-    @SuppressLint("MissingPermission")
-    fun showForwardSecurityNotification(messageReceiver: MessageReceiver<*>) {
-        val contentText = getNotificationContextText(messageReceiver)
-
-        val builder: NotificationCompat.Builder = NotificationCompat.Builder(context, NotificationChannels.NOTIFICATION_CHANNEL_FORWARD_SECURITY)
-            .setContentTitle(context.getString(R.string.forward_security_notification_rejected_title))
-            .setContentText(contentText)
-            .setSmallIcon(R.drawable.ic_baseline_key_off_24)
-            .setLocalOnly(true)
-            .setContentIntent(getIntent(messageReceiver))
-            .setAutoCancel(true)
-            .setOnlyAlertOnce(true)
-            .setOngoing(false)
-
-        val notificationId = getNotificationId(messageReceiver)
-
-        NotificationManagerCompat.from(context).apply {
-            if (hasNotificationPermission()) {
-                logger.info("Displaying fs reject notification with id {}", notificationId)
-                notify(notificationId, builder.build())
-            } else {
-                logger.warn("Cannot show forward security notification due to missing permission")
-            }
-        }
-    }
-
-    private fun hasNotificationPermission() =
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-            ActivityCompat.checkSelfPermission(
-                context,
-                Manifest.permission.POST_NOTIFICATIONS
-            ) == PackageManager.PERMISSION_GRANTED
-        } else {
-            true
-        }
-
-    private fun getNotificationId(messageReceiver: MessageReceiver<*>): Int {
-        return notificationIdMap[messageReceiver.uniqueIdString] ?: run {
-            val newId = Random.nextInt()
-            notificationIdMap[messageReceiver.uniqueIdString] = newId
-            newId
-        }
-    }
-
-    private fun getIntent(messageReceiver: MessageReceiver<*>): PendingIntent {
-        val intent = Intent(context, ComposeMessageActivity::class.java)
-        messageReceiver.prepareIntent(intent)
-        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
-        return PendingIntent.getActivity(
-            context,
-            // Use unique request code to prevent that pending intent extras are overridden
-            messageReceiver.uniqueIdString.hashCode(),
-            intent,
-            PendingIntent.FLAG_UPDATE_CURRENT or IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE
-        )
-    }
-
-    private fun getNotificationContextText(messageReceiver: MessageReceiver<*>): String {
-        // Do not include name in case of a hidden contact. The intent remains the same, so clicking
-        // the notification will still result in opening the correct chat.
-        return if (hiddenChatListService.has(messageReceiver.uniqueIdString)) {
-            context.getString(R.string.forward_security_notification_rejected_text_generic)
-        } else {
-            when (messageReceiver) {
-                is ContactMessageReceiver -> context.getString(
-                    R.string.forward_security_notification_rejected_text_contact,
-                    messageReceiver.displayName
-                )
-
-                is GroupMessageReceiver -> context.getString(
-                    R.string.forward_security_notification_rejected_text_group,
-                    messageReceiver.displayName
-                )
-
-                // Note that messages in distribution lists are rejected in the corresponding 1:1
-                // chat and therefore handled via contact message receiver.
-                else -> throw IllegalArgumentException("Cannot show notification for unexpected receiver type: " + messageReceiver.type)
-            }
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/notifications/NotificationChannels.kt b/app/src/main/java/ch/threema/app/notifications/NotificationChannels.kt
deleted file mode 100644
index 372627e9..00000000
--- a/app/src/main/java/ch/threema/app/notifications/NotificationChannels.kt
+++ /dev/null
@@ -1,679 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.notifications
-
-import android.app.Activity
-import android.content.ActivityNotFoundException
-import android.content.Context
-import android.content.Intent
-import android.content.SharedPreferences
-import android.media.AudioAttributes
-import android.media.RingtoneManager
-import android.net.Uri
-import android.os.Build
-import android.os.DeadObjectException
-import android.provider.Settings
-import androidx.activity.result.ActivityResultLauncher
-import androidx.core.app.NotificationChannelCompat
-import androidx.core.app.NotificationChannelGroupCompat
-import androidx.core.app.NotificationCompat
-import androidx.core.app.NotificationManagerCompat
-import androidx.preference.PreferenceManager
-import ch.threema.app.R
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.SoundUtil
-import ch.threema.base.utils.LoggingUtil
-import org.slf4j.Logger
-
-object NotificationChannels {
-
-    val logger: Logger = LoggingUtil.getThreemaLogger("NotificationChannels")
-
-    /**
-     * Notification channel version
-     */
-
-    private const val CHANNEL_SETUP_VERSION = 1
-
-    /*
-     * static notification channels
-     */
-    const val NOTIFICATION_CHANNEL_CHATS_DEFAULT: String = "chats_default" // channel for default chat notifications
-    const val NOTIFICATION_CHANNEL_GROUP_CHATS_DEFAULT: String = "group_chats_default" // channel for default chat notifications
-    const val NOTIFICATION_CHANNEL_INCOMING_CALLS: String = "incoming_call"
-    const val NOTIFICATION_CHANNEL_IN_CALL: String = "ongoing_call"
-    const val NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS: String = "incoming_group_call" // channel for group calls
-    const val NOTIFICATION_CHANNEL_PASSPHRASE: String = "passphrase"
-    const val NOTIFICATION_CHANNEL_WEBCLIENT: String = "webclient"
-    const val NOTIFICATION_CHANNEL_ALERT: String = "alert"
-    const val NOTIFICATION_CHANNEL_NOTICE: String = "notice"
-    const val NOTIFICATION_CHANNEL_BACKUP_RESTORE_IN_PROGRESS: String = "data_backup"
-    const val NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS: String = "new_contact_found"
-    const val NOTIFICATION_CHANNEL_FORWARD_SECURITY: String = "forward_security_alert"
-    const val NOTIFICATION_CHANNEL_CHAT_UPDATE: String = "silent_chat_update" // channel for quiet chat notification updates (e.g. when changing from regular to PIN locked)
-    const val NOTIFICATION_CHANNEL_WORK_SYNC: String = "work_sync"
-
-    // these channels are created on demand only
-    const val NOTIFICATION_CHANNEL_THREEMA_PUSH: String = "threema_push" // channel will be created on-the-fly by ThreemaPushService
-    const val NOTIFICATION_CHANNEL_VOICE_MSG_PLAYER: String = "voicemessage_player" // channel will be created on-the-fly by VoiceMessagePlayerService
-
-    /*
-     * notification channel groups
-     */
-    private const val NOTIFICATION_CHANNELGROUP_CHAT: String = "chats"
-    private const val NOTIFICATION_CHANNELGROUP_GROUP_CHAT: String = "group_chats"
-
-    /**
-     * deprecated notification channels (pre versioning)
-     */
-    private const val NOTIFICATION_CHANNEL_PASSPHRASE_PRE: String = "ps"
-    private const val NOTIFICATION_CHANNEL_WEBCLIENT_PRE: String = "wc"
-    private const val NOTIFICATION_CHANNEL_CHATS_DEFAULT_PRE: String = "cc" // channel for default chat notifications
-    private const val NOTIFICATION_CHANNEL_CALL_PRE: String = "ca" // channel used for calls
-    private const val NOTIFICATION_CHANNEL_IN_CALL_PRE: String = "ic"
-    private const val NOTIFICATION_CHANNEL_ALERT_PRE: String = "al"
-    private const val NOTIFICATION_CHANNEL_NOTICE_PRE: String = "no"
-    private const val NOTIFICATION_CHANNEL_WORK_SYNC_PRE: String = "ws"
-    private const val NOTIFICATION_CHANNEL_IDENTITY_SYNC_PRE: String = "is"
-    private const val NOTIFICATION_CHANNEL_BACKUP_RESTORE_IN_PROGRESS_PRE: String = "bk"
-    private const val NOTIFICATION_CHANNEL_CHAT_UPDATE_PRE: String = "cu" // channel for quiet chat notification updates (e.g. when changing from regular to PIN locked)
-    private const val NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS_PRE: String = "nc"
-    private const val NOTIFICATION_CHANNEL_GROUP_JOIN_RESPONSE_PRE: String = "jres" // currently not used
-    private const val NOTIFICATION_CHANNEL_GROUP_JOIN_REQUEST_PRE: String = "jreq" // currently not use
-    private const val NOTIFICATION_CHANNEL_THREEMA_PUSH_PRE: String = "tpush"
-    private const val NOTIFICATION_CHANNEL_GROUP_CALL_PRE: String = "gcall" // channel for group calls
-    private const val NOTIFICATION_CHANNEL_VOICE_MSG_PLAYER_PRE: String = "vmp"
-    private const val NOTIFICATION_CHANNEL_FORWARD_SECURITY_PRE: String = "fs"
-
-    /*
-     * deprecated notification channel groups (pre versioning)
-     */
-    private const val NOTIFICATION_CHANNELGROUP_CHAT_PRE: String = "group"
-    private const val NOTIFICATION_CHANNELGROUP_VOIP_PRE: String = "vgroup"
-    private const val NOTIFICATION_CHANNELGROUP_CHAT_UPDATE_PRE: String = "ugroup" // silent updates
-    private const val NOTIFICATION_CHANNELGROUP_GROUP_CALLS_PRE: String = "group_calls"
-
-    /**
-     * Default vibration patterns
-     */
-    @JvmField val VIBRATE_PATTERN_REGULAR: LongArray = longArrayOf(0, 250, 250, 250)
-    @JvmField val VIBRATE_PATTERN_INCOMING_CALL: LongArray = longArrayOf(0, 1000, 1000, 0)
-    @JvmField val VIBRATE_PATTERN_GROUP_CALL: LongArray = longArrayOf(0, 2000)
-
-    /**
-     * Ensure notification channels and groups are created. Upgrade if necessary
-     */
-    fun ensureNotificationChannelsAndGroups() {
-        val appContext = ThreemaApplication.getAppContext()
-        val notificationManagerCompat = NotificationManagerCompat.from(appContext)
-
-        // PreferenceService may not yet be available at that time
-        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext())
-
-        val previousVersion = sharedPreferences.getInt(appContext.getString(R.string.preferences__notification_channels_version), 0)
-        if (previousVersion < CHANNEL_SETUP_VERSION) {
-            if (previousVersion == 0) {
-                logger.info("Upgrading notification channels and groups from version {} to {}", previousVersion, CHANNEL_SETUP_VERSION)
-                upgradeGroupsAndChannelsToVersion1(appContext, notificationManagerCompat)
-            }
-            sharedPreferences.edit().putInt(appContext.getString(R.string.preferences__notification_channels_version), CHANNEL_SETUP_VERSION).apply()
-        }
-
-        createOrRefreshChannelsAndGroups(appContext, notificationManagerCompat)
-    }
-
-    /**
-     * create all channels for a new installation
-     */
-    private fun createOrRefreshChannelsAndGroups(context: Context, notificationManagerCompat: NotificationManagerCompat) {
-        createGroup(context, notificationManagerCompat, NOTIFICATION_CHANNELGROUP_CHAT, R.string.chats)
-        createGroup(context, notificationManagerCompat, NOTIFICATION_CHANNELGROUP_GROUP_CHAT, R.string.group_chats)
-
-        getChannelBuilder(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_CHATS_DEFAULT,
-            context.getString(R.string.new_messages),
-            NotificationManagerCompat.IMPORTANCE_MAX,
-            null,
-            NOTIFICATION_CHANNELGROUP_CHAT
-        )?.let {
-            it.setLightsEnabled(true)
-            it.setVibrationEnabled(true)
-            it.setVibrationPattern(VIBRATE_PATTERN_REGULAR)
-            it.setShowBadge(true)
-            it.setSound(
-                Settings.System.DEFAULT_NOTIFICATION_URI,
-                SoundUtil.getAudioAttributesForUsage(AudioAttributes.USAGE_NOTIFICATION)
-            )
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_GROUP_CHATS_DEFAULT,
-            context.getString(R.string.new_group_messages),
-            NotificationManagerCompat.IMPORTANCE_MAX,
-            null,
-            NOTIFICATION_CHANNELGROUP_GROUP_CHAT
-        )?.let {
-            it.setLightsEnabled(true)
-            it.setVibrationEnabled(true)
-            it.setVibrationPattern(VIBRATE_PATTERN_REGULAR)
-            it.setShowBadge(true)
-            it.setSound(
-                Settings.System.DEFAULT_NOTIFICATION_URI,
-                SoundUtil.getAudioAttributesForUsage(AudioAttributes.USAGE_NOTIFICATION)
-            )
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_INCOMING_CALLS,
-            context.getString(R.string.incoming_calls),
-            NotificationManagerCompat.IMPORTANCE_HIGH
-        )?.let {
-            it.setLightsEnabled(true)
-            it.setVibrationEnabled(true)
-            it.setVibrationPattern(VIBRATE_PATTERN_INCOMING_CALL)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_IN_CALL,
-            context.getString(R.string.call_ongoing),
-            NotificationManagerCompat.IMPORTANCE_LOW
-        )?.let {
-            it.setLightsEnabled(false)
-            it.setVibrationEnabled(false)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS,
-            context.getString(R.string.group_calls),
-            NotificationManagerCompat.IMPORTANCE_HIGH
-        )?.let {
-            it.setLightsEnabled(true)
-            it.setVibrationEnabled(true)
-            it.setVibrationPattern(VIBRATE_PATTERN_GROUP_CALL)
-            it.setShowBadge(false)
-            it.setSound(
-                Settings.System.DEFAULT_RINGTONE_URI,
-                SoundUtil.getAudioAttributesForUsage(AudioAttributes.USAGE_NOTIFICATION_RINGTONE)
-            )
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_PASSPHRASE,
-            context.getString(R.string.passphrase_service_name),
-            NotificationManagerCompat.IMPORTANCE_LOW
-        )?.let {
-            it.setDescription(context.getString(R.string.passphrase_service_description))
-            it.setLightsEnabled(false)
-            it.setVibrationEnabled(false)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_WEBCLIENT,
-            context.getString(R.string.webclient),
-            NotificationManagerCompat.IMPORTANCE_LOW
-        )?.let {
-            it.setDescription(context.getString(R.string.webclient_service_description))
-            it.setLightsEnabled(false)
-            it.setVibrationEnabled(false)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_ALERT,
-            context.getString(R.string.notification_channel_alerts),
-            NotificationManagerCompat.IMPORTANCE_HIGH
-        )?.let {
-            it.setLightsEnabled(true)
-            it.setVibrationEnabled(true)
-            it.setShowBadge(false)
-            it.setSound(
-                RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION),
-                SoundUtil.getAudioAttributesForUsage(AudioAttributes.USAGE_NOTIFICATION_EVENT)
-            )
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_NOTICE,
-            context.getString(R.string.notification_channel_notices),
-            NotificationManagerCompat.IMPORTANCE_LOW
-        )?.let {
-            it.setLightsEnabled(false)
-            it.setVibrationEnabled(false)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_BACKUP_RESTORE_IN_PROGRESS,
-            context.getString(R.string.backup_or_restore_progress),
-            NotificationManagerCompat.IMPORTANCE_LOW
-        )?.let {
-            it.setLightsEnabled(false)
-            it.setVibrationEnabled(false)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS,
-            context.getString(R.string.notification_channel_new_contact),
-            NotificationManagerCompat.IMPORTANCE_HIGH
-        )?.let {
-            it.setDescription(context.getString(R.string.notification_channel_new_contact_desc))
-            it.setLightsEnabled(true)
-            it.setVibrationEnabled(true)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_FORWARD_SECURITY,
-            context.getString(R.string.forward_security_notification_channel_name),
-            NotificationManagerCompat.IMPORTANCE_HIGH
-        )?.let {
-            it.setDescription(context.getString(R.string.notification_channel_new_contact_desc))
-            it.setLightsEnabled(true)
-            it.setVibrationEnabled(true)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(notificationManagerCompat,
-            NOTIFICATION_CHANNEL_CHAT_UPDATE,
-            context.getString(R.string.chat_updates),
-            NotificationManagerCompat.IMPORTANCE_LOW
-        )?.let {
-            it.setLightsEnabled(false)
-            it.setVibrationEnabled(false)
-            it.setShowBadge(false)
-            it.setSound(null, null)
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        // work sync notification
-        if (ConfigUtils.isWorkBuild()) {
-            getChannelBuilder(notificationManagerCompat,
-                NOTIFICATION_CHANNEL_WORK_SYNC,
-                context.getString(R.string.work_data_sync),
-                NotificationManagerCompat.IMPORTANCE_LOW
-            )?.let {
-                it.setDescription(context.getString(R.string.work_data_sync_desc))
-                it.setLightsEnabled(false)
-                it.setVibrationEnabled(false)
-                it.setShowBadge(false)
-                it.setSound(null, null)
-                notificationManagerCompat.createNotificationChannel(it.build())
-            }
-        }
-    }
-
-    private fun upgradeGroupsAndChannelsToVersion1(context: Context, notificationManagerCompat: NotificationManagerCompat) {
-        // destination groups must be created *before* we can migrate
-        createGroup(context, notificationManagerCompat, NOTIFICATION_CHANNELGROUP_CHAT, R.string.chats)
-        createGroup(context, notificationManagerCompat, NOTIFICATION_CHANNELGROUP_GROUP_CHAT, R.string.group_chats)
-
-        // migrate all channels that are part of a group
-        migrateChannel(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_CHAT_UPDATE_PRE,
-            NOTIFICATION_CHANNEL_CHAT_UPDATE,
-            NOTIFICATION_CHANNELGROUP_CHAT
-        )
-
-        // migrate all channels that are not part of a group (they will just get a new ID)
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_PASSPHRASE_PRE, NOTIFICATION_CHANNEL_PASSPHRASE)
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_WEBCLIENT_PRE, NOTIFICATION_CHANNEL_WEBCLIENT)
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_ALERT_PRE, NOTIFICATION_CHANNEL_ALERT)
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_NOTICE_PRE, NOTIFICATION_CHANNEL_NOTICE)
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_WORK_SYNC_PRE, NOTIFICATION_CHANNEL_WORK_SYNC)
-        migrateChannel(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_BACKUP_RESTORE_IN_PROGRESS_PRE,
-            NOTIFICATION_CHANNEL_BACKUP_RESTORE_IN_PROGRESS
-        )
-        migrateChannel(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS_PRE,
-            NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS
-        )
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_THREEMA_PUSH_PRE, NOTIFICATION_CHANNEL_THREEMA_PUSH)
-        migrateChannel(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_VOICE_MSG_PLAYER_PRE,
-            NOTIFICATION_CHANNEL_VOICE_MSG_PLAYER
-        )
-        migrateChannel(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_FORWARD_SECURITY_PRE,
-            NOTIFICATION_CHANNEL_FORWARD_SECURITY
-        )
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_CALL_PRE, NOTIFICATION_CHANNEL_INCOMING_CALLS)
-        migrateChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_IN_CALL_PRE, NOTIFICATION_CHANNEL_IN_CALL)
-        migrateChannel(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_GROUP_CALL_PRE,
-            NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS
-        )
-
-        // delete obsolete channels
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_IDENTITY_SYNC_PRE)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_GROUP_JOIN_RESPONSE_PRE)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_GROUP_JOIN_REQUEST_PRE)
-
-        // delete obsolete channel groups. this also deletes all remaining channels in these groups
-        deleteChannelGroup(notificationManagerCompat, NOTIFICATION_CHANNELGROUP_CHAT_PRE)
-        deleteChannelGroup(notificationManagerCompat, NOTIFICATION_CHANNELGROUP_CHAT_UPDATE_PRE)
-        deleteChannelGroup(notificationManagerCompat, NOTIFICATION_CHANNELGROUP_VOIP_PRE)
-        deleteChannelGroup(notificationManagerCompat, NOTIFICATION_CHANNELGROUP_GROUP_CALLS_PRE)
-
-        // create default chat channels based on current settings
-        val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(ThreemaApplication.getAppContext())
-        val channelImportance = if (NotificationUtil.getNotificationPriority(context) >= NotificationCompat.PRIORITY_HIGH)  NotificationManagerCompat.IMPORTANCE_MAX else NotificationManagerCompat.IMPORTANCE_HIGH
-
-        getChannelBuilder(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_CHATS_DEFAULT,
-            context.getString(R.string.new_messages),
-            channelImportance,
-            null,
-            NOTIFICATION_CHANNELGROUP_CHAT
-        )?.let {
-            it.setVibrationEnabled(sharedPreferences.getBoolean(context.getString(R.string.preferences__vibrate), true))
-            it.setVibrationPattern(VIBRATE_PATTERN_REGULAR)
-            it.setShowBadge(true)
-            it.setSound(
-                getRingtoneUriFromPrefsKey(context, sharedPreferences, R.string.preferences__notification_sound),
-                SoundUtil.getAudioAttributesForUsage(AudioAttributes.USAGE_NOTIFICATION)
-            )
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-
-        getChannelBuilder(
-            notificationManagerCompat,
-            NOTIFICATION_CHANNEL_GROUP_CHATS_DEFAULT,
-            context.getString(R.string.new_group_messages),
-            channelImportance,
-            null,
-            NOTIFICATION_CHANNELGROUP_GROUP_CHAT
-        )?.let {
-            it.setVibrationEnabled(sharedPreferences.getBoolean(context.getString(R.string.preferences__group_vibrate), true))
-            it.setVibrationPattern(VIBRATE_PATTERN_REGULAR)
-            it.setShowBadge(true)
-            it.setSound(
-                getRingtoneUriFromPrefsKey(context, sharedPreferences, R.string.preferences__group_notification_sound),
-                SoundUtil.getAudioAttributesForUsage(AudioAttributes.USAGE_NOTIFICATION)
-            )
-            notificationManagerCompat.createNotificationChannel(it.build())
-        }
-    }
-
-    private fun getRingtoneUriFromPrefsKey(context: Context, sharedPreferences: SharedPreferences, key: Int) : Uri {
-        val ringtone = sharedPreferences.getString(context.getString(key), null)
-        return if (!ringtone.isNullOrEmpty() && "null" != ringtone) Uri.parse(ringtone) else Settings.System.DEFAULT_NOTIFICATION_URI
-    }
-
-    /**
-     * Migrate existing channel to a new channel while dropping the group if a groupId is not specified
-     * It is safe to call this method if a channel with oldId does not exist - no new channel will be created.
-     * The old channel will be deleted after migration
-     */
-    private fun migrateChannel(
-        notificationManagerCompat: NotificationManagerCompat,
-        oldId: String,
-        newId: String,
-        groupId: String? = null
-    ) {
-        val oldNotificationChannel = notificationManagerCompat.getNotificationChannelCompat(oldId)
-
-        if (oldNotificationChannel != null) {
-            val newNotificationChannelBuilder =
-                NotificationChannelCompat.Builder(newId, oldNotificationChannel.importance)
-                    .setName(oldNotificationChannel.name)
-                    .setDescription(oldNotificationChannel.description)
-                    .setLightColor(oldNotificationChannel.lightColor)
-                    .setLightsEnabled(oldNotificationChannel.shouldShowLights())
-                    .setShowBadge(oldNotificationChannel.canShowBadge())
-                    .setVibrationEnabled(oldNotificationChannel.shouldVibrate())
-                    .setVibrationPattern(oldNotificationChannel.vibrationPattern)
-                    .setSound(oldNotificationChannel.sound, oldNotificationChannel.audioAttributes)
-
-            if (groupId != null) {
-                newNotificationChannelBuilder.setGroup(groupId)
-            }
-
-            notificationManagerCompat.createNotificationChannel(newNotificationChannelBuilder.build())
-            deleteChannel(notificationManagerCompat, oldId)
-        }
-    }
-
-    /**
-     * Attempt to delete a channel. Continue if deleting the channel fails.
-     */
-    fun deleteChannel(notificationManagerCompat: NotificationManagerCompat, channelId: String) {
-        try {
-            notificationManagerCompat.deleteNotificationChannel(channelId)
-        } catch (e: SecurityException) {
-            logger.error("Unable to delete notification channel {}", channelId, e)
-        }
-    }
-
-    /**
-     * Attempt to delete a channel group. Continue if deleting the channel group fails.
-     */
-    private fun deleteChannelGroup(notificationManagerCompat: NotificationManagerCompat, groupId: String) {
-        try {
-            notificationManagerCompat.deleteNotificationChannelGroup(groupId)
-        } catch (e: SecurityException) {
-            logger.error("Unable to delete notification channel group {}", groupId, e)
-        }
-    }
-
-    /**
-     * Create a notification channel group with the provided ID and name
-     * If a group already exists and the name has changed, rename it to the provided group name
-     */
-    private fun createGroup(context: Context, notificationManagerCompat: NotificationManagerCompat, groupId: String, groupNameRes: Int) {
-        val newName = context.getString(groupNameRes)
-        val existingGroup = getNotificationChannelGroup(notificationManagerCompat, groupId)
-
-        if (existingGroup != null && newName == existingGroup.name) {
-            return
-        }
-
-        val builder = NotificationChannelGroupCompat.Builder(
-            groupId
-        ).setName(newName)
-
-        notificationManagerCompat.createNotificationChannelGroup(builder.build())
-    }
-
-    /**
-     * Get builder for a notification channel if a channel with the same ID doesn't already exist
-     * If the channel exists and has a different name, the channel will be renamed
-     * If a conversationId is specified, this is assumed to be a conversation-centric channel that will be linked to the specified channel in absence of a specific conversation id.
-     * Otherwise, null is returned
-     */
-    private fun getChannelBuilder(
-        notificationManagerCompat: NotificationManagerCompat,
-        channelId: String,
-        channelName: String?,
-        channelImportance: Int,
-        parentChannelId: String? = null,
-        groupId: String? = null
-    ): NotificationChannelCompat.Builder? {
-        val newName = channelName ?: channelId
-        val existingChannel = notificationManagerCompat.getNotificationChannelCompat(channelId)
-
-        if (existingChannel != null && newName == existingChannel.name) {
-            return null
-        }
-
-        val builder = NotificationChannelCompat.Builder(
-            channelId,
-            channelImportance
-        ).setName(newName)
-
-        if (parentChannelId != null) {
-            builder.setConversationId(parentChannelId, channelId)
-        }
-
-        if (groupId != null) {
-            builder.setGroup(groupId)
-        }
-
-        return builder
-    }
-
-    /**
-     * Check if a notification group with the given groupId exists
-     * @param notificationManagerCompat The notification manager
-     * @param groupId The id of the group
-     * @return NotificationChannelGroup object of matching group if exists, null otherwise
-     */
-    private fun getNotificationChannelGroup(
-        notificationManagerCompat: NotificationManagerCompat,
-        groupId: String
-    ): NotificationChannelGroupCompat? {
-        try {
-            notificationManagerCompat.getNotificationChannelGroupCompat(groupId)
-        } catch (e: DeadObjectException) {
-            val groups = notificationManagerCompat.notificationChannelGroupsCompat
-            for (group in groups) {
-                if (groupId == group.id) {
-                    return group
-                }
-            }
-        }
-        return null
-    }
-
-    public fun exists(context: Context, channelId: String) : Boolean {
-        val notificationManagerCompat = NotificationManagerCompat.from(context)
-        return notificationManagerCompat.getNotificationChannelCompat(channelId) != null;
-    }
-
-    /**
-     * launch notification channel settings screen for the channel specified by the channelId
-     */
-    fun launchChannelSettings(
-        activityContext: Activity,
-        channelName: String?,
-        channelId: String,
-        isGroupChat: Boolean,
-        launcher: ActivityResultLauncher<Intent>? = null
-    ) {
-        if (!ConfigUtils.supportsNotificationChannels()) {
-            return
-        }
-
-        val notificationManagerCompat = NotificationManagerCompat.from(activityContext)
-
-        // check if a channel for specified ID exists - if not, create it before opening the intent
-        if (!exists(activityContext, channelId)) {
-            getChannelBuilder(
-                notificationManagerCompat,
-                channelId,
-                channelName,
-                NotificationManagerCompat.IMPORTANCE_MAX,
-                if (isGroupChat) NOTIFICATION_CHANNEL_GROUP_CHATS_DEFAULT else NOTIFICATION_CHANNEL_CHATS_DEFAULT,
-                if (isGroupChat) NOTIFICATION_CHANNELGROUP_GROUP_CHAT else NOTIFICATION_CHANNELGROUP_CHAT
-            )?.let {
-                it.setLightsEnabled(true)
-                it.setVibrationEnabled(true)
-                it.setVibrationPattern(VIBRATE_PATTERN_REGULAR)
-                it.setShowBadge(true)
-                it.setSound(
-                    Settings.System.DEFAULT_NOTIFICATION_URI,
-                    SoundUtil.getAudioAttributesForUsage(AudioAttributes.USAGE_NOTIFICATION)
-                )
-                notificationManagerCompat.createNotificationChannel(it.build())
-            }
-        }
-
-        val intent = Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS)
-        intent.putExtra(Settings.EXTRA_CHANNEL_ID, channelId)
-        intent.putExtra(Settings.EXTRA_APP_PACKAGE, ThreemaApplication.getAppContext().packageName)
-        if (Build.VERSION.SDK_INT >= 30) {
-            intent.putExtra(Settings.EXTRA_CONVERSATION_ID, channelId)
-        }
-        try {
-            if (launcher != null) {
-                launcher.launch(intent)
-            } else {
-                activityContext.startActivity(intent)
-            }
-        } catch (e: ActivityNotFoundException) {
-            logger.debug("No settings activity found")
-        }
-    }
-
-    fun deleteAll() {
-        val notificationManagerCompat = NotificationManagerCompat.from(ThreemaApplication.getAppContext())
-
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_INCOMING_CALLS)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_IN_CALL)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_ALERT)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_NOTICE)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_FORWARD_SECURITY)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_CHAT_UPDATE)
-
-        // get rid of foreground service channels
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_BACKUP_RESTORE_IN_PROGRESS)
-        if (ConfigUtils.isWorkBuild()) {
-            deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_WORK_SYNC)
-        }
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_VOICE_MSG_PLAYER)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_PASSPHRASE)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_WEBCLIENT)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_THREEMA_PUSH)
-
-        deleteChannelGroup(notificationManagerCompat, NOTIFICATION_CHANNELGROUP_CHAT) // this deletes all channels contained in this group
-        deleteChannelGroup(notificationManagerCompat, NOTIFICATION_CHANNELGROUP_GROUP_CHAT) // this deletes all channels contained in this group
-
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_CHATS_DEFAULT)
-        deleteChannel(notificationManagerCompat, NOTIFICATION_CHANNEL_GROUP_CHATS_DEFAULT)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/notifications/NotificationGroups.kt b/app/src/main/java/ch/threema/app/notifications/NotificationGroups.kt
deleted file mode 100644
index 0f7bef89..00000000
--- a/app/src/main/java/ch/threema/app/notifications/NotificationGroups.kt
+++ /dev/null
@@ -1,27 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.notifications
-
-object NotificationGroups {
-    const val CALLS = "calls"
-    const val WEB_DESKTOP_SESSIONS = "web_desktop_sessions"
-}
diff --git a/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java b/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java
index 29089f41..1c73a0de 100644
--- a/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java
+++ b/app/src/main/java/ch/threema/app/preference/SettingsAdvancedOptionsFragment.java
@@ -21,9 +21,6 @@
 
 package ch.threema.app.preference;
 
-import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_AUTOSTART;
-import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_POWERMANAGER;
-
 import android.Manifest;
 import android.annotation.SuppressLint;
 import android.app.Activity;
@@ -34,7 +31,6 @@ import android.content.IntentFilter;
 import android.content.SharedPreferences;
 import android.content.pm.PackageManager;
 import android.net.Uri;
-import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
@@ -42,9 +38,21 @@ import android.text.TextUtils;
 import android.view.View;
 import android.widget.Toast;
 
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+
+import org.slf4j.Logger;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
 import androidx.activity.result.ActivityResultLauncher;
 import androidx.activity.result.contract.ActivityResultContracts;
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.core.content.ContextCompat;
 import androidx.core.content.IntentCompat;
 import androidx.core.content.PackageManagerCompat;
@@ -56,23 +64,13 @@ import androidx.preference.Preference.SummaryProvider;
 import androidx.preference.PreferenceCategory;
 import androidx.preference.PreferenceScreen;
 import androidx.preference.TwoStatePreference;
-
-import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-
-import org.slf4j.Logger;
-
-import java.io.File;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 import ch.threema.app.BuildConfig;
 import ch.threema.app.BuildFlavor;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.DisableBatteryOptimizationsActivity;
+import ch.threema.app.asynctasks.SendToSupportBackgroundTask;
+import ch.threema.app.asynctasks.SendToSupportResult;
 import ch.threema.app.dialogs.CancelableHorizontalProgressDialog;
 import ch.threema.app.dialogs.GenericAlertDialog;
 import ch.threema.app.dialogs.GenericProgressDialog;
@@ -81,7 +79,7 @@ import ch.threema.app.dialogs.TextEntryDialog;
 import ch.threema.app.listeners.ConversationListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
-import ch.threema.app.messagereceiver.MessageReceiver;
+import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.push.PushService;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeadlineListService;
@@ -105,11 +103,17 @@ import ch.threema.app.utils.PushUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShareUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.activities.WebRTCDebugActivity;
 import ch.threema.app.webclient.activities.WebDiagnosticsActivity;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.logging.backend.DebugLogFileBackend;
-import ch.threema.storage.models.ContactModel;
+
+import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_AUTOSTART;
+import static ch.threema.app.utils.PowermanagerUtil.RESULT_DISABLE_POWERMANAGER;
 
 public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment implements GenericAlertDialog.DialogClickListener, SharedPreferences.OnSharedPreferenceChangeListener, TextEntryDialog.TextEntryDialogClickListener, CancelableHorizontalProgressDialog.ProgressDialogClickListener {
     private static final Logger logger = LoggingUtil.getThreemaLogger("SettingsAdvancedOptionsFragment");
@@ -135,22 +139,26 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
     private TwoStatePreference threemaPushTwoStatePreference;
     private TwoStatePreference messageLogPreference, ipv6Preferences;
 
-    private WallpaperService wallpaperService;
-    private SharedPreferences sharedPreferences;
-    private PreferenceService preferenceService;
-    private RingtoneService ringtoneService;
-    private NotificationService notificationService;
-    private FileService fileService;
-    private UserService userService;
-    private LifetimeService lifetimeService;
-    private DeadlineListService mutedChatsListService, mentionOnlyChatsListService;
-    private MessageService messageService;
-    private ContactService contactService;
-    private View fragmentView;
+	private WallpaperService wallpaperService;
+	private SharedPreferences sharedPreferences;
+	private PreferenceService preferenceService;
+	private RingtoneService ringtoneService;
+	private NotificationService notificationService;
+	private FileService fileService;
+	private UserService userService;
+	private LifetimeService lifetimeService;
+	private DeadlineListService mutedChatsListService, mentionOnlyChatsListService;
+	private MessageService messageService;
+	private ContactService contactService;
+	private APIConnector apiConnector;
+	private ContactModelRepository contactModelRepository;
+	private View fragmentView;
 
     private BroadcastReceiver pushTokenResetBroadcastReceiver;
 
-    private boolean pushServicesInstalled;
+	private @Nullable BackgroundExecutor backgroundExecutor;
+
+	private boolean pushServicesInstalled;
 
     /**
      * This activity result launcher is needed to open the settings to disable hibernation.
@@ -566,40 +574,44 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
         return this.checkInstances();
     }
 
-    protected boolean checkInstances() {
-        return TestUtil.required(
-            this.wallpaperService,
-            this.lifetimeService,
-            this.preferenceService,
-            this.fileService,
-            this.userService,
-            this.ringtoneService,
-            this.mutedChatsListService,
-            this.messageService,
-            this.contactService
-        );
-    }
-
-    protected void instantiate() {
-        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-        if (serviceManager != null) {
-            try {
-                this.wallpaperService = serviceManager.getWallpaperService();
-                this.lifetimeService = serviceManager.getLifetimeService();
-                this.preferenceService = serviceManager.getPreferenceService();
-                this.fileService = serviceManager.getFileService();
-                this.userService = serviceManager.getUserService();
-                this.ringtoneService = serviceManager.getRingtoneService();
-                this.mutedChatsListService = serviceManager.getMutedChatsListService();
-                this.mentionOnlyChatsListService = serviceManager.getMentionOnlyChatsListService();
-                this.messageService = serviceManager.getMessageService();
-                this.contactService = serviceManager.getContactService();
-                this.notificationService = serviceManager.getNotificationService();
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        }
-    }
+	protected boolean checkInstances() {
+		return TestUtil.required(
+			this.wallpaperService,
+			this.lifetimeService,
+			this.preferenceService,
+			this.fileService,
+			this.userService,
+			this.ringtoneService,
+			this.mutedChatsListService,
+			this.messageService,
+			this.contactService,
+			this.apiConnector,
+			this.contactModelRepository
+		);
+	}
+
+	protected void instantiate() {
+		ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+		if (serviceManager != null) {
+			try {
+				this.wallpaperService = serviceManager.getWallpaperService();
+				this.lifetimeService = serviceManager.getLifetimeService();
+				this.preferenceService = serviceManager.getPreferenceService();
+				this.fileService = serviceManager.getFileService();
+				this.userService = serviceManager.getUserService();
+				this.ringtoneService = serviceManager.getRingtoneService();
+				this.mutedChatsListService = serviceManager.getMutedChatsListService();
+				this.mentionOnlyChatsListService = serviceManager.getMentionOnlyChatsListService();
+				this.messageService = serviceManager.getMessageService();
+				this.contactService = serviceManager.getContactService();
+				this.notificationService = serviceManager.getNotificationService();
+				this.apiConnector = serviceManager.getAPIConnector();
+				this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+			} catch (Exception e) {
+				logger.error("Exception", e);
+			}
+		}
+	}
 
     @Override
     public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
@@ -723,24 +735,32 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
     }
 
 
-    @SuppressLint("StaticFieldLeak")
-    public void sendLogFileToSupport(final String caption) {
-        new AsyncTask<Void, Void, Exception>() {
-
-            @Override
-            protected void onPreExecute() {
-                GenericProgressDialog.newInstance(R.string.preparing_messages, R.string.please_wait).show(getParentFragmentManager(), DIALOG_TAG_SENDLOG);
-            }
-
-            @Override
-            protected Exception doInBackground(Void... params) {
-                File zipFile = DebugLogFileBackend.getZipFile(fileService);
-
-                try {
-                    final ContactModel contactModel = contactService.getOrCreateByIdentity(
-                        THREEMA_SUPPORT_IDENTITY, true);
-
-                    MessageReceiver receiver = contactService.createReceiver(contactModel);
+	@SuppressLint("StaticFieldLeak")
+	public void sendLogFileToSupport(final String caption) {
+		final Context context = getContext();
+		if (context == null) {
+			logger.warn("Cannot send logfile as the context is null");
+			return;
+		}
+
+		SendToSupportBackgroundTask sendLogFileTask = new SendToSupportBackgroundTask(
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			context
+		) {
+			@Override
+			public void onBefore() {
+				GenericProgressDialog.newInstance(R.string.preparing_messages, R.string.please_wait).show(getParentFragmentManager(), DIALOG_TAG_SENDLOG);
+			}
+
+			@NonNull
+			@Override
+			public SendToSupportResult onSupportAvailable(@NonNull ContactModel contactModel) {
+				File zipFile = DebugLogFileBackend.getZipFile(fileService);
+
+				try {
+					ContactMessageReceiver receiver = contactService.createReceiver(contactModel);
 
                     messageService.sendText(caption +
                         "\n-- \n" +
@@ -759,31 +779,39 @@ public class SettingsAdvancedOptionsFragment extends ThreemaPreferenceFragment i
                                 RuntimeUtil.runOnUiThread(() -> Toast.makeText(getContext(), R.string.an_error_occurred_during_send, Toast.LENGTH_LONG).show());
                             }
 
-                            @Override
-                            public void onCompleted() {
-                                RuntimeUtil.runOnUiThread(() -> Toast.makeText(getContext(), R.string.message_sent, Toast.LENGTH_LONG).show());
-                            }
-                        });
-                } catch (Exception e) {
-                    return e;
-                }
-                return null;
-            }
-
-            @Override
-            protected void onPostExecute(Exception exception) {
-                if (isAdded()) {
-                    DialogUtil.dismissDialog(getParentFragmentManager(), DIALOG_TAG_SENDLOG, true);
-
-                    if (exception != null) {
-                        Toast.makeText(requireActivity().getApplicationContext(), R.string.an_error_occurred, Toast.LENGTH_LONG).show();
-                    } else {
-                        Toast.makeText(requireActivity().getApplicationContext(), R.string.message_sent, Toast.LENGTH_LONG).show();
-                    }
-                }
-            }
-        }.execute();
-    }
+							@Override
+							public void onCompleted() {
+								RuntimeUtil.runOnUiThread(() -> Toast.makeText(getContext(), R.string.message_sent, Toast.LENGTH_LONG).show());
+							}
+						});
+				} catch (Exception e) {
+					logger.error("Could not send log file");
+					return SendToSupportResult.FAILED;
+				}
+
+				return SendToSupportResult.SUCCESS;
+			}
+
+			@Override
+			public void onFinished(@NonNull SendToSupportResult result) {
+				if (isAdded()) {
+					DialogUtil.dismissDialog(getParentFragmentManager(), DIALOG_TAG_SENDLOG, true);
+
+					if (result == SendToSupportResult.SUCCESS) {
+						Toast.makeText(requireActivity().getApplicationContext(), R.string.message_sent, Toast.LENGTH_LONG).show();
+					} else {
+						Toast.makeText(requireActivity().getApplicationContext(), R.string.an_error_occurred, Toast.LENGTH_LONG).show();
+					}
+				}
+			}
+		};
+
+		if (backgroundExecutor == null) {
+			backgroundExecutor = new BackgroundExecutor();
+		}
+
+		backgroundExecutor.execute(sendLogFileTask);
+	}
 
     @Override
     public void onActivityResult(int requestCode, int resultCode, Intent data) {
diff --git a/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java b/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java
index b41b12a0..aeb1f2d9 100644
--- a/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java
+++ b/app/src/main/java/ch/threema/app/preference/SettingsDeveloperFragment.java
@@ -23,6 +23,7 @@ package ch.threema.app.preference;
 
 import android.annotation.SuppressLint;
 import android.app.Activity;
+import android.content.Intent;
 import android.os.AsyncTask;
 import android.widget.Toast;
 
@@ -38,7 +39,12 @@ import androidx.preference.Preference;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.PolicyViolation;
+import ch.threema.app.debug.PatternLibraryActivity;
 import ch.threema.app.exceptions.InvalidEntryException;
 import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.managers.ServiceManager;
@@ -50,7 +56,9 @@ import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.models.MessageId;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.TextMessage;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData;
 import ch.threema.storage.DatabaseServiceNew;
@@ -61,265 +69,296 @@ import static ch.threema.storage.models.data.status.VoipStatusDataModel.NO_CALL_
 
 @SuppressWarnings("unused")
 public class SettingsDeveloperFragment extends ThreemaPreferenceFragment {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("SettingsDeveloperFragment");
-
-	// Test identities.
-	private static final String TEST_IDENTITY_1 = "ADDRTCNX";
-	private static final String TEST_IDENTITY_2 = "H6AXSHKC";
-
-	private PreferenceService preferenceService;
-	private DatabaseServiceNew databaseService;
-	private ContactService contactService;
-	private MessageService messageService;
-	private UserService userService;
-	private MultiDeviceManager multiDeviceManager;
-
-	@Override
-	public void initializePreferences() {
-		if (!requiredInstances()) {
-			return;
-		}
-
-		initMdSetting();
-		initConversationSetting();
-
-		// Generate VoIP messages
-		final Preference generateVoipPreference = getPref(getResources().getString(R.string.preferences__generate_voip_messages));
-		generateVoipPreference.setSummary("Create the test identity " + TEST_IDENTITY_1
-			+ " and add all possible VoIP messages to that conversation.");
-		generateVoipPreference.setOnPreferenceClickListener(this::generateVoipMessages);
-
-		// Generate test quotes
-		final Preference generateRecursiveQuote = getPref(getResources().getString(R.string.preferences__generate_test_quotes));
-		generateRecursiveQuote.setSummary("Create the test identities " + TEST_IDENTITY_1 + " and "
-			+ TEST_IDENTITY_2 + " and add some test quotes.");
-		generateRecursiveQuote.setOnPreferenceClickListener(this::generateTestQuotes);
-
-		// Remove developer menu
-		final Preference removeMenuPreference = getPref(getResources().getString(R.string.preferences__remove_menu));
-		removeMenuPreference.setSummary("Hide the developer menu from the settings.");
-		removeMenuPreference.setOnPreferenceClickListener(this::hideDeveloperMenu);
-	}
-
-	@UiThread
-	private void showOk(CharSequence msg) {
-		Toast.makeText(this.getContext(), msg, Toast.LENGTH_LONG).show();
-	}
-
-	@UiThread
-	private void showError(Exception e) {
-		logger.error("Exception", e);
-		Toast.makeText(this.getContext(), e.toString(), Toast.LENGTH_LONG).show();
-	}
-
-	@WorkerThread
-	private ContactModel createTestContact(
-		String identity,
-		String firstName,
-		String lastName
-	) throws EntryAlreadyExistsException, InvalidEntryException, PolicyViolationException {
-		ContactModel contact = contactService.getByIdentity(identity);
-		if (contact == null) {
-			contact = contactService.createContactByIdentity(identity, true);
-		}
-		contact.setName(firstName, lastName);
-		databaseService.getContactModelFactory().createOrUpdate(contact);
-		return contact;
-	}
-
-	@UiThread
-	@SuppressLint("StaticFieldLeak")
-	private boolean generateVoipMessages(Preference preference) {
-
-		// Pojo for holding test data.
-		class VoipMessage {
-			final VoipStatusDataModel dataModel;
-			final String description;
-			VoipMessage(VoipStatusDataModel dataModel, String description) {
-				this.dataModel = dataModel;
-				this.description = description;
-			}
-		}
-
-		// Test messages
-		final VoipMessage[] testMessages = new VoipMessage[]{
-			new VoipMessage(VoipStatusDataModel.createMissed(NO_CALL_ID, null), "missed"),
-			new VoipMessage(VoipStatusDataModel.createFinished(NO_CALL_ID,42), "finished"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.UNKNOWN), "rejected (unknown)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.BUSY), "rejected (busy)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.TIMEOUT), "rejected (timeout)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.REJECTED), "rejected (rejected)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.DISABLED), "rejected (disabled)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, (byte) 99), "rejected (invalid reason code)"),
-			new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID,null), "rejected (null reason code)"),
-			new VoipMessage(VoipStatusDataModel.createAborted(NO_CALL_ID), "aborted"),
-		};
-
-		new AsyncTask<Void, Void, Exception>() {
-			@Override
-			@Nullable protected Exception doInBackground(Void... voids) {
-				try {
-					// Create test identity
-					final ContactModel contact = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
-
-					// Create test messages
-					final ContactMessageReceiver receiver = contactService.createReceiver(contact);
-					messageService.createStatusMessage("Creating test messages...", receiver);
-					for (boolean isOutbox : new boolean[]{true, false}) {
-						for (VoipMessage msg : testMessages) {
-							final String text = (isOutbox ? "Outgoing " : "Incoming ") + msg.description;
-							messageService.createStatusMessage(text, receiver);
-							messageService.createVoipStatus(msg.dataModel, receiver, isOutbox, true);
-						}
-					}
-
-					return null;
-				} catch (Exception e) {
-					return e;
-				}
-			}
-
-			@Override
-			protected void onPostExecute(@Nullable Exception e) {
-				if (e == null) {
-					showOk("Test messages created!");
-				} else {
-					showError(e);
-				}
-			}
-		}.execute();
-		return true;
-	}
-
-	@UiThread
-	@SuppressLint("StaticFieldLeak")
-	private boolean generateTestQuotes(Preference preference) {
-		new AsyncTask<Void, Void, Exception>() {
-			@Override
-			@Nullable protected Exception doInBackground(Void... voids) {
-				try {
-					// Create test identity
-					final ContactModel contact1 = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
-					final ContactMessageReceiver receiver1 = contactService.createReceiver(contact1);
-					final ContactModel contact2 = createTestContact(TEST_IDENTITY_2, "Another Developer", "Testcontact");
-					final ContactMessageReceiver receiver2 = contactService.createReceiver(contact2);
-
-					messageService.createStatusMessage("Creating test quotes...", receiver1);
-
-					// Create recursive quote
-					final MessageId messageIdRecursive = new MessageId();
-					TextMessage messageRecursive = new TextMessage();
-					messageRecursive.setFromIdentity(contact1.getIdentity());
-					messageRecursive.setToIdentity(userService.getIdentity());
-					messageRecursive.setDate(new Date());
-					messageRecursive.setMessageId(messageIdRecursive);
-					messageRecursive.setText("> quote #" + messageIdRecursive.toString() + "\n\na quote that references itself");
-					messageService.processIncomingContactMessage(messageRecursive);
-
-					// Create cross-chat quote
-					final MessageId messageIdCrossChat1 = new MessageId();
-					final MessageId messageIdCrossChat2 = new MessageId();
-					TextMessage messageChat2 = new TextMessage();
-					messageChat2.setFromIdentity(contact2.getIdentity());
-					messageChat2.setToIdentity(userService.getIdentity());
-					messageChat2.setDate(new Date());
-					messageChat2.setMessageId(messageIdCrossChat2);
-					messageChat2.setText("hello, this is a secret message");
-					messageService.processIncomingContactMessage(messageChat2);
-					TextMessage messageChat1 = new TextMessage();
-					messageChat1.setFromIdentity(contact1.getIdentity());
-					messageChat1.setToIdentity(userService.getIdentity());
-					messageChat1.setDate(new Date());
-					messageChat1.setMessageId(messageIdCrossChat1);
-					messageChat1.setText("> quote #" + messageIdCrossChat2.toString() + "\n\nOMG!");
-					messageService.processIncomingContactMessage(messageChat1);
-
-					messageService.createStatusMessage("Done creating test quotes", receiver1);
-
-					return null;
-				} catch (Exception e) {
-					return e;
-				}
-			}
-
-			@Override
-			protected void onPostExecute(@Nullable Exception e) {
-				if (e == null) {
-					showOk("Test quotes created!");
-				} else {
-					showError(e);
-				}
-			}
-		}.execute();
-		return true;
-	}
-
-	@UiThread
-	@SuppressLint("StaticFieldLeak")
-	private boolean hideDeveloperMenu(Preference preference) {
-		this.preferenceService.setShowDeveloperMenu(false);
-		this.showOk("Not everybody can be a craaazy developer!");
-		final Activity activity = this.getActivity();
-		if (activity != null) {
-			activity.finish();
-		}
-		return true;
-	}
-
-	private void initMdSetting() {
-		CheckBoxPreference preference = getPref(R.string.preferences__md_unlocked);
-		preference.setEnabled(multiDeviceManager.isMultiDeviceActive() || preferenceService.isMdUnlocked() || BuildConfig.MD_ENABLED);
-		preference.setOnPreferenceChangeListener((p, v) -> {
-			p.setEnabled((boolean)v || BuildConfig.MD_ENABLED);
-			return true;
-		});
-	}
-
-	private void initConversationSetting() {
-		CheckBoxPreference preference = getPref(R.string.preferences__show_last_update_prefix);
-	}
-
-	final protected boolean requiredInstances() {
-		if (!this.checkInstances()) {
-			this.instantiate();
-		}
-		return this.checkInstances();
-	}
-
-	protected boolean checkInstances() {
-		return TestUtil.required(
-			this.preferenceService,
-			this.databaseService,
-			this.contactService,
-			this.messageService,
-			this.userService,
-			this.multiDeviceManager
-		);
-	}
-
-	protected void instantiate() {
-		ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-		if (serviceManager != null) {
-			try {
-				this.preferenceService = serviceManager.getPreferenceService();
-				this.databaseService = serviceManager.getDatabaseServiceNew();
-				this.contactService = serviceManager.getContactService();
-				this.messageService = serviceManager.getMessageService();
-				this.userService = serviceManager.getUserService();
-				this.multiDeviceManager = serviceManager.getMultiDeviceManager();
-			} catch (Exception e) {
-				logger.error("Exception", e);
-			}
-		}
-	}
-
-	@Override
-	public int getPreferenceTitleResource() {
-		return R.string.prefs_developers;
-	}
-
-	@Override
-	public int getPreferenceResource() {
-		return R.xml.preference_developers;
-	}
+    private static final Logger logger = LoggingUtil.getThreemaLogger("SettingsDeveloperFragment");
+
+    // Test identities.
+    private static final String TEST_IDENTITY_1 = "ADDRTCNX";
+    private static final String TEST_IDENTITY_2 = "H6AXSHKC";
+
+    private PreferenceService preferenceService;
+    private DatabaseServiceNew databaseService;
+    private ContactService contactService;
+    private MessageService messageService;
+    private UserService userService;
+    private MultiDeviceManager multiDeviceManager;
+    private APIConnector apiConnector;
+    private ContactModelRepository contactModelRepository;
+
+    @Override
+    public void initializePreferences() {
+        if (!requiredInstances()) {
+            return;
+        }
+
+        initMdSetting();
+        initConversationSetting();
+
+        // Generate VoIP messages
+        final Preference generateVoipPreference = getPref(getResources().getString(R.string.preferences__generate_voip_messages));
+        generateVoipPreference.setSummary("Create the test identity " + TEST_IDENTITY_1
+            + " and add all possible VoIP messages to that conversation.");
+        generateVoipPreference.setOnPreferenceClickListener(this::generateVoipMessages);
+
+        // Generate test quotes
+        final Preference generateRecursiveQuote = getPref(getResources().getString(R.string.preferences__generate_test_quotes));
+        generateRecursiveQuote.setSummary("Create the test identities " + TEST_IDENTITY_1 + " and "
+            + TEST_IDENTITY_2 + " and add some test quotes.");
+        generateRecursiveQuote.setOnPreferenceClickListener(this::generateTestQuotes);
+
+        // Theming
+        final Preference openPatternLibraryPreference = getPref(getResources().getString(R.string.preferences__open_pattern_library));
+        openPatternLibraryPreference.setOnPreferenceClickListener((preference) -> {
+            startActivity(new Intent(getContext(), PatternLibraryActivity.class));
+            return true;
+        });
+
+        // Remove developer menu
+        final Preference removeMenuPreference = getPref(getResources().getString(R.string.preferences__remove_menu));
+        removeMenuPreference.setSummary("Hide the developer menu from the settings.");
+        removeMenuPreference.setOnPreferenceClickListener(this::hideDeveloperMenu);
+    }
+
+    @UiThread
+    private void showOk(CharSequence msg) {
+        Toast.makeText(this.getContext(), msg, Toast.LENGTH_LONG).show();
+    }
+
+    @UiThread
+    private void showError(Exception e) {
+        logger.error("Exception", e);
+        Toast.makeText(this.getContext(), e.toString(), Toast.LENGTH_LONG).show();
+    }
+
+    @WorkerThread
+    private ContactModel createTestContact(
+        String identity,
+        String firstName,
+        String lastName
+    ) throws InvalidEntryException, PolicyViolationException {
+        ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+            identity,
+            ContactModel.AcquaintanceLevel.DIRECT,
+            userService.getIdentity(),
+            apiConnector,
+            contactModelRepository,
+            AddContactRestrictionPolicy.CHECK,
+            ThreemaApplication.getAppContext(),
+            null
+        ).runSynchronously();
+
+        if (result instanceof ContactAvailable) {
+            ((ContactAvailable) result).getContactModel().setNameFromLocal(firstName, lastName);
+
+            ContactModel contactModel = contactService.getByIdentity(identity);
+            if (contactModel == null) {
+                throw new IllegalStateException("Contact model is null after adding it");
+            }
+            return contactModel;
+        } else if (result instanceof PolicyViolation) {
+            throw new PolicyViolationException();
+        } else {
+            throw new InvalidEntryException(R.string.invalid_threema_id);
+        }
+    }
+
+    @UiThread
+    @SuppressLint("StaticFieldLeak")
+    private boolean generateVoipMessages(Preference preference) {
+
+        // Pojo for holding test data.
+        class VoipMessage {
+            final VoipStatusDataModel dataModel;
+            final String description;
+
+            VoipMessage(VoipStatusDataModel dataModel, String description) {
+                this.dataModel = dataModel;
+                this.description = description;
+            }
+        }
+
+        // Test messages
+        final VoipMessage[] testMessages = new VoipMessage[]{
+            new VoipMessage(VoipStatusDataModel.createMissed(NO_CALL_ID, null), "missed"),
+            new VoipMessage(VoipStatusDataModel.createFinished(NO_CALL_ID, 42), "finished"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.UNKNOWN), "rejected (unknown)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.BUSY), "rejected (busy)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.TIMEOUT), "rejected (timeout)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.REJECTED), "rejected (rejected)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, VoipCallAnswerData.RejectReason.DISABLED), "rejected (disabled)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, (byte) 99), "rejected (invalid reason code)"),
+            new VoipMessage(VoipStatusDataModel.createRejected(NO_CALL_ID, null), "rejected (null reason code)"),
+            new VoipMessage(VoipStatusDataModel.createAborted(NO_CALL_ID), "aborted"),
+        };
+
+        new AsyncTask<Void, Void, Exception>() {
+            @Override
+            @Nullable
+            protected Exception doInBackground(Void... voids) {
+                try {
+                    // Create test identity
+                    final ContactModel contact = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
+
+                    // Create test messages
+                    final ContactMessageReceiver receiver = contactService.createReceiver(contact);
+                    messageService.createStatusMessage("Creating test messages...", receiver);
+                    for (boolean isOutbox : new boolean[]{true, false}) {
+                        for (VoipMessage msg : testMessages) {
+                            final String text = (isOutbox ? "Outgoing " : "Incoming ") + msg.description;
+                            messageService.createStatusMessage(text, receiver);
+                            messageService.createVoipStatus(msg.dataModel, receiver, isOutbox, true);
+                        }
+                    }
+
+                    return null;
+                } catch (Exception e) {
+                    return e;
+                }
+            }
+
+            @Override
+            protected void onPostExecute(@Nullable Exception e) {
+                if (e == null) {
+                    showOk("Test messages created!");
+                } else {
+                    showError(e);
+                }
+            }
+        }.execute();
+        return true;
+    }
+
+    @UiThread
+    @SuppressLint("StaticFieldLeak")
+    private boolean generateTestQuotes(Preference preference) {
+        new AsyncTask<Void, Void, Exception>() {
+            @Override
+            @Nullable
+            protected Exception doInBackground(Void... voids) {
+                try {
+                    // Create test identity
+                    final ContactModel contact1 = createTestContact(TEST_IDENTITY_1, "Developer", "Testcontact");
+                    final ContactMessageReceiver receiver1 = contactService.createReceiver(contact1);
+                    final ContactModel contact2 = createTestContact(TEST_IDENTITY_2, "Another Developer", "Testcontact");
+                    final ContactMessageReceiver receiver2 = contactService.createReceiver(contact2);
+
+                    messageService.createStatusMessage("Creating test quotes...", receiver1);
+
+                    // Create recursive quote
+                    final MessageId messageIdRecursive = new MessageId();
+                    TextMessage messageRecursive = new TextMessage();
+                    messageRecursive.setFromIdentity(contact1.getIdentity());
+                    messageRecursive.setToIdentity(userService.getIdentity());
+                    messageRecursive.setDate(new Date());
+                    messageRecursive.setMessageId(messageIdRecursive);
+                    messageRecursive.setText("> quote #" + messageIdRecursive.toString() + "\n\na quote that references itself");
+                    messageService.processIncomingContactMessage(messageRecursive);
+
+                    // Create cross-chat quote
+                    final MessageId messageIdCrossChat1 = new MessageId();
+                    final MessageId messageIdCrossChat2 = new MessageId();
+                    TextMessage messageChat2 = new TextMessage();
+                    messageChat2.setFromIdentity(contact2.getIdentity());
+                    messageChat2.setToIdentity(userService.getIdentity());
+                    messageChat2.setDate(new Date());
+                    messageChat2.setMessageId(messageIdCrossChat2);
+                    messageChat2.setText("hello, this is a secret message");
+                    messageService.processIncomingContactMessage(messageChat2);
+                    TextMessage messageChat1 = new TextMessage();
+                    messageChat1.setFromIdentity(contact1.getIdentity());
+                    messageChat1.setToIdentity(userService.getIdentity());
+                    messageChat1.setDate(new Date());
+                    messageChat1.setMessageId(messageIdCrossChat1);
+                    messageChat1.setText("> quote #" + messageIdCrossChat2.toString() + "\n\nOMG!");
+                    messageService.processIncomingContactMessage(messageChat1);
+
+                    messageService.createStatusMessage("Done creating test quotes", receiver1);
+
+                    return null;
+                } catch (Exception e) {
+                    return e;
+                }
+            }
+
+            @Override
+            protected void onPostExecute(@Nullable Exception e) {
+                if (e == null) {
+                    showOk("Test quotes created!");
+                } else {
+                    showError(e);
+                }
+            }
+        }.execute();
+        return true;
+    }
+
+    @UiThread
+    @SuppressLint("StaticFieldLeak")
+    private boolean hideDeveloperMenu(Preference preference) {
+        this.preferenceService.setShowDeveloperMenu(false);
+        this.showOk("Not everybody can be a craaazy developer!");
+        final Activity activity = this.getActivity();
+        if (activity != null) {
+            activity.finish();
+        }
+        return true;
+    }
+
+    private void initMdSetting() {
+        CheckBoxPreference preference = getPref(R.string.preferences__md_unlocked);
+        preference.setEnabled(multiDeviceManager.isMultiDeviceActive() || preferenceService.isMdUnlocked() || BuildConfig.MD_ENABLED);
+        preference.setOnPreferenceChangeListener((p, v) -> {
+            p.setEnabled((boolean) v || BuildConfig.MD_ENABLED);
+            return true;
+        });
+    }
+
+    private void initConversationSetting() {
+        CheckBoxPreference preference = getPref(R.string.preferences__show_last_update_prefix);
+    }
+
+    final protected boolean requiredInstances() {
+        if (!this.checkInstances()) {
+            this.instantiate();
+        }
+        return this.checkInstances();
+    }
+
+    protected boolean checkInstances() {
+        return TestUtil.required(
+            this.preferenceService,
+            this.databaseService,
+            this.contactService,
+            this.messageService,
+            this.userService,
+            this.multiDeviceManager
+        );
+    }
+
+    protected void instantiate() {
+        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+        if (serviceManager != null) {
+            try {
+                this.preferenceService = serviceManager.getPreferenceService();
+                this.databaseService = serviceManager.getDatabaseServiceNew();
+                this.contactService = serviceManager.getContactService();
+                this.messageService = serviceManager.getMessageService();
+                this.userService = serviceManager.getUserService();
+                this.multiDeviceManager = serviceManager.getMultiDeviceManager();
+                this.apiConnector = serviceManager.getAPIConnector();
+                this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+            } catch (Exception e) {
+                logger.error("Exception", e);
+            }
+        }
+    }
+
+    @Override
+    public int getPreferenceTitleResource() {
+        return R.string.prefs_developers;
+    }
+
+    @Override
+    public int getPreferenceResource() {
+        return R.xml.preference_developers;
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingCspMessageSubTask.kt b/app/src/main/java/ch/threema/app/processors/IncomingCspMessageSubTask.kt
deleted file mode 100644
index 4af08ba6..00000000
--- a/app/src/main/java/ch/threema/app/processors/IncomingCspMessageSubTask.kt
+++ /dev/null
@@ -1,34 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.tasks.ActiveComposableTask
-
-abstract class IncomingCspMessageSubTask(protected val serviceManager: ServiceManager) :
-    ActiveComposableTask<ReceiveStepsResult> {
-}
-
-enum class ReceiveStepsResult {
-    SUCCESS,
-    DISCARD,
-}
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt b/app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt
deleted file mode 100644
index 723ccd5f..00000000
--- a/app/src/main/java/ch/threema/app/processors/IncomingForwardSecurityProcessor.kt
+++ /dev/null
@@ -1,73 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.fs.IncomingForwardSecurityAcceptTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityInitTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityMessageTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityRejectTask
-import ch.threema.app.processors.fs.IncomingForwardSecurityTerminateTask
-import ch.threema.base.ThreemaException
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-import ch.threema.domain.protocol.csp.fs.UnknownMessageTypeException
-import ch.threema.domain.protocol.csp.messages.BadMessageException
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataAccept
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataInit
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataReject
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataTerminate
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingForwardSecurityProcessor(
-    private val serviceManager: ServiceManager,
-) {
-    private val fsmp = serviceManager.forwardSecurityMessageProcessor
-
-    /**
-     * Process a forward security envelope message by attempting to decapsulate/decrypt it.
-     *
-     * @param sender Sender contact
-     * @param envelopeMessage The envelope with the encapsulated message
-     *
-     * @return Decapsulated message or null in case of an invalid inner message or a control message
-     * that has been consumed and does not need further processing
-     */
-    @Throws(ThreemaException::class, BadMessageException::class)
-    suspend fun processEnvelopeMessage(
-        sender: Contact,
-        envelopeMessage: ForwardSecurityEnvelopeMessage,
-        handle: ActiveTaskCodec,
-    ): ForwardSecurityDecryptionResult {
-        return when (val data = envelopeMessage.data) {
-            is ForwardSecurityDataInit -> IncomingForwardSecurityInitTask(fsmp, sender, data)
-            is ForwardSecurityDataAccept -> IncomingForwardSecurityAcceptTask(fsmp, sender, data)
-            is ForwardSecurityDataReject -> IncomingForwardSecurityRejectTask(sender, data, serviceManager)
-            is ForwardSecurityDataTerminate -> IncomingForwardSecurityTerminateTask(fsmp, sender, data)
-            is ForwardSecurityDataMessage -> IncomingForwardSecurityMessageTask(fsmp, sender, envelopeMessage)
-            else -> throw UnknownMessageTypeException("Unsupported message type")
-        }.run(handle)
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt b/app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt
deleted file mode 100644
index 1651d6db..00000000
--- a/app/src/main/java/ch/threema/app/processors/IncomingMessageProcessorImpl.kt
+++ /dev/null
@@ -1,473 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.calls.IncomingCallAnswerTask
-import ch.threema.app.processors.calls.IncomingCallHangupTask
-import ch.threema.app.processors.calls.IncomingCallIceCandidateTask
-import ch.threema.app.processors.calls.IncomingCallOfferTask
-import ch.threema.app.processors.calls.IncomingCallRingingTask
-import ch.threema.app.processors.contactcontrol.IncomingContactRequestProfilePictureTask
-import ch.threema.app.processors.contactcontrol.IncomingDeleteProfilePictureTask
-import ch.threema.app.processors.contactcontrol.IncomingSetProfilePictureTask
-import ch.threema.app.processors.conversation.IncomingBallotVoteTask
-import ch.threema.app.processors.conversation.IncomingContactConversationMessageTask
-import ch.threema.app.processors.conversation.IncomingContactDeleteMessageTask
-import ch.threema.app.processors.conversation.IncomingContactEditMessageTask
-import ch.threema.app.processors.conversation.IncomingGroupConversationMessageTask
-import ch.threema.app.processors.conversation.IncomingGroupDeleteMessageTask
-import ch.threema.app.processors.conversation.IncomingGroupEditMessageTask
-import ch.threema.app.processors.fs.IncomingEmptyTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupCallControlTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupDeleteProfilePictureTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupJoinRequestTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupJoinResponseMessage
-import ch.threema.app.processors.groupcontrol.IncomingGroupLeaveTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupNameTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupSetProfilePictureTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupSetupTask
-import ch.threema.app.processors.groupcontrol.IncomingGroupSyncRequestTask
-import ch.threema.app.processors.push.IncomingWebSessionResumeMessageTask
-import ch.threema.app.processors.statusupdates.IncomingDeliveryReceiptTask
-import ch.threema.app.processors.statusupdates.IncomingGroupDeliveryReceiptTask
-import ch.threema.app.processors.statusupdates.IncomingTypingIndicatorTask
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.IdListService
-import ch.threema.app.services.MessageService
-import ch.threema.app.services.PreferenceService
-import ch.threema.app.tasks.OutgoingContactDeliveryReceiptMessageTask
-import ch.threema.base.crypto.NonceFactory
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.Utils
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.api.APIConnector
-import ch.threema.domain.protocol.api.APIConnector.HttpConnectionException
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.protocol.csp.coders.MessageCoder
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.fs.PeerRatchetIdentifier
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.BadMessageException
-import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.DeleteMessage
-import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
-import ch.threema.domain.protocol.csp.messages.EditMessage
-import ch.threema.domain.protocol.csp.messages.EmptyMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeleteProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
-import ch.threema.domain.protocol.csp.messages.GroupEditMessage
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupNameMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
-import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException
-import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
-import ch.threema.domain.protocol.csp.messages.WebSessionResumeMessage
-import ch.threema.domain.protocol.csp.messages.ballot.BallotVoteInterface
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestMessage
-import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseMessage
-import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallControlMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
-import ch.threema.domain.stores.ContactStore
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.NetworkException
-import ch.threema.domain.taskmanager.ProtocolException
-import ch.threema.domain.taskmanager.catchAllExceptNetworkException
-import ch.threema.domain.taskmanager.catchExceptNetworkException
-import ch.threema.storage.models.ServerMessageModel
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingMessageProcessorImpl")
-
-class IncomingMessageProcessorImpl(
-    private val messageService: MessageService,
-    private val nonceFactory: NonceFactory,
-    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    private val contactService: ContactService,
-    private val contactStore: ContactStore,
-    private val identityStore: IdentityStoreInterface,
-    private val blockedContactsService: IdListService,
-    private val preferenceService: PreferenceService,
-    private val serviceManager: ServiceManager,
-) : IncomingMessageProcessor {
-    private val incomingForwardSecurityProcessor = IncomingForwardSecurityProcessor(serviceManager)
-
-    override suspend fun processIncomingMessage(messageBox: MessageBox, handle: ActiveTaskCodec) {
-        suspend {
-            processMessage(messageBox, handle)
-        }.catchAllExceptNetworkException { e ->
-            val messageId = messageBox.messageId
-            val fromIdentity = messageBox.fromIdentity
-
-            logger.error("Processing message {} from {} failed", messageId, fromIdentity, e)
-
-            // If we catch a network related exception, we throw a protocol exception to trigger a
-            // reconnect by the task manager.
-            if (e is HttpConnectionException || e is APIConnector.NetworkException) {
-                val errorMsg = "Could not process message $messageId from $fromIdentity"
-                logger.error(errorMsg, e)
-                throw ProtocolException(e.message ?: errorMsg)
-            }
-
-            // For every other exception, we acknowledge the failed message. Due to forward
-            // security, it would not make sense to process a message later on. Note that when a
-            // NetworkException is thrown, we do not need to acknowledge the message as the task
-            // manager will be stopped before the next message can be processed. On the next
-            // reconnect, we will receive the non-acked messages.
-            // Note that we do not protect messages that could not be decoded against replay
-            acknowledgeMessage(messageBox, false, null, handle)
-        }
-    }
-
-    override fun processIncomingServerAlert(alertData: CspMessage.ServerAlertData) {
-        val msg = ServerMessageModel(alertData.message, ServerMessageModel.TYPE_ALERT)
-        messageService.saveIncomingServerMessage(msg)
-    }
-
-    override fun processIncomingServerError(errorData: CspMessage.ServerErrorData) {
-        val errorMessage = errorData.message
-        if (errorMessage.contains("Another connection")) {
-            // See `MonitoringLayer#handleCloseError(CspContainer)` for more info
-            logger.info("Do not display `Another connection` close-error")
-        } else {
-            val msg = ServerMessageModel(errorMessage, ServerMessageModel.TYPE_ERROR)
-            messageService.saveIncomingServerMessage(msg)
-        }
-    }
-
-    private suspend fun processMessage(messageBox: MessageBox, handle: ActiveTaskCodec) {
-        logger.info(
-            "Incoming message from {} with ID {}",
-            messageBox.fromIdentity,
-            messageBox.messageId
-        )
-
-        val (message, peerRatchetIdentifier) = suspend {
-            decryptMessage(messageBox, handle)
-        }.catchExceptNetworkException { e: DiscardMessageException ->
-            logger.warn("Discard message {}", messageBox.messageId)
-            // If the message could be decrypted, then check if it should be protected against
-            // replay. Otherwise we do not protect it against replay.
-            val protectAgainstReplay = e.discardedMessage?.protectAgainstReplay() ?: false
-            acknowledgeMessage(messageBox, protectAgainstReplay, e.peerRatchetIdentifier, handle)
-            return
-        }
-
-        if (message == null) {
-            // Note that if the message is null, it is an fs control message or an invalid message
-            // that does not need any further processing. Therefore we just acknowledge the message.
-            // Note that we need to protect fs control message against replay.
-            acknowledgeMessage(messageBox, true, peerRatchetIdentifier, handle)
-            return
-        }
-
-        suspend {
-            processMessage(message, handle)
-        }.catchExceptNetworkException { _: DiscardMessageException ->
-            logger.warn("Discard message {}", messageBox.messageId)
-            acknowledgeMessage(
-                messageBox,
-                message.protectAgainstReplay(),
-                peerRatchetIdentifier,
-                handle
-            )
-            return
-        }
-
-        // Acknowledge the message
-        acknowledgeMessage(messageBox, message.protectAgainstReplay(), peerRatchetIdentifier, handle)
-
-        // If the message type requires automatic delivery receipts and the message does not contain
-        // the no delivery receipt flag, send a delivery receipt
-        if (message.sendAutomaticDeliveryReceipt()
-            && !message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_DELIVERY_RECEIPTS)
-        ) {
-            OutgoingContactDeliveryReceiptMessageTask(
-                ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED,
-                arrayOf(message.messageId),
-                Date().time,
-                message.fromIdentity,
-                serviceManager
-            ).invoke(handle)
-            logger.info(
-                "Sent delivery receipt (delivered) message for message ID {} from {}",
-                message.messageId, message.fromIdentity
-            )
-        }
-    }
-
-    private suspend fun decryptMessage(
-        messageBox: MessageBox,
-        handle: ActiveTaskCodec,
-    ): Pair<AbstractMessage?, PeerRatchetIdentifier?> {
-        // If the nonce has already been used, acknowledge and discard the message
-        if (nonceFactory.exists(messageBox.nonce)) {
-            logger.warn(
-                "Skipped processing message {} as its nonce has already been used",
-                messageBox.messageId
-            )
-            throw DiscardMessageException()
-        }
-
-        // First, we need to ensure we have the public key of the sender
-        contactService.fetchAndCacheContact(messageBox.fromIdentity)
-
-        // Try to decode the message. At this point we have the public key of the sender either
-        // stored or cached in the contact store.
-        val messageCoder = MessageCoder(this.contactStore, this.identityStore)
-        val encapsulatedMessage = try {
-            messageCoder.decode(messageBox)
-        } catch (e: BadMessageException) {
-            logger.warn("Could not decode message: {}", e.message)
-            throw DiscardMessageException()
-        }
-
-        logger.info(
-            "Incoming message {} from {} to {} (type {})",
-            messageBox.messageId,
-            messageBox.fromIdentity,
-            messageBox.toIdentity,
-            Utils.byteToHex(encapsulatedMessage.type.toByte(), true, true)
-        )
-
-        // Decapsulate fs message if it is an fs envelope message
-        val (message, peerRatchetIdentifier) = decapsulateMessage(encapsulatedMessage, handle)
-
-        // In case there is no decapsulated message, it was an fs control message or an invalid
-        // message that does not need any further processing
-        if (message == null) {
-            return null to peerRatchetIdentifier
-        }
-
-        logger.info(
-            "Processing decrypted message {} from {} to {} (type {})",
-            message.messageId,
-            message.fromIdentity,
-            message.toIdentity,
-            Utils.byteToHex(message.type.toByte(), true, true)
-        )
-
-        if (isBlocked(message.fromIdentity) && !message.exemptFromBlocking()) {
-            logger.info(
-                "Message {} from {} will be discarded: Contact is implicitly or explicitly blocked.",
-                message.messageId,
-                message.fromIdentity
-            )
-            throw DiscardMessageException(message, peerRatchetIdentifier)
-        }
-
-        return Pair(message, peerRatchetIdentifier)
-    }
-
-    private suspend fun decapsulateMessage(
-        encapsulated: AbstractMessage,
-        handle: ActiveTaskCodec,
-    ): Pair<AbstractMessage?, PeerRatchetIdentifier?> {
-        // If the message is not a fs encapsulated message, warn the user depending on the fs
-        // session and return the already decapsulated message.
-        if (encapsulated !is ForwardSecurityEnvelopeMessage) {
-            forwardSecurityMessageProcessor.warnIfMessageWithoutForwardSecurityReceived(
-                encapsulated,
-                handle
-            )
-            return Pair(encapsulated, null)
-        }
-
-        val contact = contactStore.getContactForIdentityIncludingCache(encapsulated.fromIdentity)
-            ?: throw MissingPublicKeyException("Missing public key for ID ${encapsulated.fromIdentity}")
-
-        val fsDecryptionResult = incomingForwardSecurityProcessor
-            .processEnvelopeMessage(contact, encapsulated, handle)
-
-        return Pair(fsDecryptionResult.message, fsDecryptionResult.peerRatchetIdentifier)
-    }
-
-    private suspend fun processMessage(message: AbstractMessage, handle: ActiveTaskCodec) {
-        if (message.fromIdentity == ProtocolDefines.SPECIAL_CONTACT_PUSH) {
-            when (message) {
-                is WebSessionResumeMessage -> IncomingWebSessionResumeMessageTask(
-                    message,
-                    serviceManager,
-                )
-
-                else -> throw DiscardMessageException(message)
-            }.run(handle)
-
-            return
-        }
-
-        // Create implicit direct contact depending on the message type and if not already exists
-        if (message.createImplicitlyDirectContact() && contactService.getByIdentity(message.fromIdentity) == null) {
-            contactService.createContactByIdentity(message.fromIdentity, true)
-        }
-
-        // Update the nickname and set contact as active (if contact exists)
-        contactService.updatePublicNickName(message)
-        contactService.setActive(message.fromIdentity)
-
-        // Determine the message type and get its corresponding receive steps. Note that the order
-        // of checking the types is important. For instance, an abstract group message must first be
-        // checked for a group control message before processing it as a group conversation message.
-        val subtask = when (message) {
-            // Check if message is a status update
-            is TypingIndicatorMessage -> IncomingTypingIndicatorTask(message, serviceManager)
-            is DeliveryReceiptMessage -> IncomingDeliveryReceiptTask(message, serviceManager)
-            is GroupDeliveryReceiptMessage -> IncomingGroupDeliveryReceiptTask(
-                message,
-                serviceManager
-            )
-
-            // Check if message is a group control message
-            is GroupSetupMessage -> IncomingGroupSetupTask(message, serviceManager)
-            is GroupNameMessage -> IncomingGroupNameTask(message, serviceManager)
-            is GroupSetProfilePictureMessage -> IncomingGroupSetProfilePictureTask(
-                message,
-                serviceManager
-            )
-            is GroupDeleteProfilePictureMessage -> IncomingGroupDeleteProfilePictureTask(
-                message,
-                serviceManager
-            )
-            is GroupLeaveMessage -> IncomingGroupLeaveTask(message, serviceManager)
-            is GroupSyncRequestMessage -> IncomingGroupSyncRequestTask(message, serviceManager)
-            is GroupCallControlMessage -> IncomingGroupCallControlTask(message, serviceManager)
-
-            // Check if message is a contact control message
-            is SetProfilePictureMessage -> IncomingSetProfilePictureTask(message, serviceManager)
-            is DeleteProfilePictureMessage -> IncomingDeleteProfilePictureTask(
-                message,
-                serviceManager
-            )
-            is ContactRequestProfilePictureMessage -> IncomingContactRequestProfilePictureTask(
-                message,
-                serviceManager
-            )
-
-            // Check if message is a ballot or group join message
-            is BallotVoteInterface -> IncomingBallotVoteTask(message, serviceManager)
-            is GroupJoinRequestMessage -> IncomingGroupJoinRequestTask(message, serviceManager)
-            is GroupJoinResponseMessage -> IncomingGroupJoinResponseMessage(message, serviceManager)
-
-            // Check if message is a call message
-            is VoipCallOfferMessage -> IncomingCallOfferTask(message, serviceManager)
-            is VoipCallAnswerMessage -> IncomingCallAnswerTask(message, serviceManager)
-            is VoipICECandidatesMessage -> IncomingCallIceCandidateTask(message, serviceManager)
-            is VoipCallRingingMessage -> IncomingCallRingingTask(message, serviceManager)
-            is VoipCallHangupMessage -> IncomingCallHangupTask(message, serviceManager)
-
-            // Check if message is an edit message
-            is EditMessage -> IncomingContactEditMessageTask(message, serviceManager)
-            is GroupEditMessage -> IncomingGroupEditMessageTask(message, serviceManager)
-
-            // Check if message is a delete message
-            is DeleteMessage -> IncomingContactDeleteMessageTask(message, serviceManager)
-            is GroupDeleteMessage -> IncomingGroupDeleteMessageTask(message, serviceManager)
-
-            // If it is a group message, process it as a group conversation message
-            is AbstractGroupMessage -> IncomingGroupConversationMessageTask(message, serviceManager)
-
-            // Process the empty message in its corresponding task
-            is EmptyMessage -> IncomingEmptyTask(message, serviceManager)
-
-            // Otherwise it must be a contact conversation message
-            else -> IncomingContactConversationMessageTask(message, serviceManager)
-        }
-
-        val result = try {
-            subtask.run(handle)
-        } catch (e: Exception) {
-            when (e) {
-                // If a network exception is thrown, we cancel processing the message to start over
-                // when the connection has been restarted.
-                is NetworkException -> throw e
-                // Any other exception should never be thrown. If there is one, we discard the
-                // message. Note that we also acknowledge discarded messages towards the server.
-                else -> {
-                    logger.error("Error while processing incoming message", e)
-                    throw DiscardMessageException(message)
-                }
-            }
-        }
-
-        if (result == ReceiveStepsResult.DISCARD) {
-            throw DiscardMessageException(message)
-        }
-    }
-
-    private suspend fun acknowledgeMessage(
-        messageBox: MessageBox,
-        protectAgainstReplay: Boolean,
-        peerRatchetIdentifier: PeerRatchetIdentifier?,
-        handle: ActiveTaskCodec,
-    ) {
-        // If the no-server-ack message flag is not set, send a message-ack to the server
-        if ((messageBox.flags and ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK) == 0) {
-            sendAck(messageBox.messageId, messageBox.fromIdentity, handle)
-        }
-
-        // If the message should be protected against replay, store the nonce
-        if (protectAgainstReplay) {
-            nonceFactory.store(messageBox.nonce)
-        }
-
-        // If there is a peer ratchet identifier known, then turn the peer ratchet
-        peerRatchetIdentifier?.let {
-            forwardSecurityMessageProcessor.commitPeerRatchet(it, handle)
-        }
-    }
-
-    private suspend fun sendAck(messageId: MessageId, identity: String, handle: ActiveTaskCodec) {
-        logger.debug("Sending ack for message ID {} from {}", messageId, identity)
-
-        val data = identity.encodeToByteArray() + messageId.messageId
-
-        handle.write(CspMessage(ProtocolDefines.PLTYPE_INCOMING_MESSAGE_ACK.toUByte(), data))
-    }
-
-    private fun isBlocked(identity: String): Boolean =
-        blockedContactsService.has(identity) || contactService.getByIdentity(identity) == null && preferenceService.isBlockUnknown
-
-    private class DiscardMessageException(
-        val discardedMessage: AbstractMessage?,
-        val peerRatchetIdentifier: PeerRatchetIdentifier?,
-    ) : Exception() {
-        constructor() : this(null, null)
-
-        constructor(discardedMessage: AbstractMessage?) : this(discardedMessage, null)
-
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallAnswerTask.kt b/app/src/main/java/ch/threema/app/processors/calls/IncomingCallAnswerTask.kt
deleted file mode 100644
index 8fc1e4f2..00000000
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallAnswerTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.calls
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingCallAnswerTask(
-    private val message: VoipCallAnswerMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val voipStateService = serviceManager.voipStateService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleCallAnswer(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallHangupTask.kt b/app/src/main/java/ch/threema/app/processors/calls/IncomingCallHangupTask.kt
deleted file mode 100644
index 7a00d0a0..00000000
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallHangupTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.calls
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingCallHangupTask(
-    private val message: VoipCallHangupMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val voipStateService = serviceManager.voipStateService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleRemoteCallHangup(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallIceCandidateTask.kt b/app/src/main/java/ch/threema/app/processors/calls/IncomingCallIceCandidateTask.kt
deleted file mode 100644
index 384ff8f2..00000000
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallIceCandidateTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.calls
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingCallIceCandidateTask(
-    private val message: VoipICECandidatesMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val voipStateService = serviceManager.voipStateService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleICECandidates(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallOfferTask.kt b/app/src/main/java/ch/threema/app/processors/calls/IncomingCallOfferTask.kt
deleted file mode 100644
index 0be3b12c..00000000
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallOfferTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.calls
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingCallOfferTask(
-    private val message: VoipCallOfferMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val voipStateService = serviceManager.voipStateService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleCallOffer(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallRingingTask.kt b/app/src/main/java/ch/threema/app/processors/calls/IncomingCallRingingTask.kt
deleted file mode 100644
index 3a57354c..00000000
--- a/app/src/main/java/ch/threema/app/processors/calls/IncomingCallRingingTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.calls
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingCallRingingTask(
-    private val message: VoipCallRingingMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val voipStateService = serviceManager.voipStateService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (voipStateService.handleCallRinging(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingContactRequestProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingContactRequestProfilePictureTask.kt
deleted file mode 100644
index 7a59a06b..00000000
--- a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingContactRequestProfilePictureTask.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.contactcontrol
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingContactRequestProfilePictureTask")
-
-class IncomingContactRequestProfilePictureTask(
-    private val message: ContactRequestProfilePictureMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val contactService = serviceManager.contactService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val contactModel = contactService.getByIdentity(message.fromIdentity)
-        if (contactModel == null) {
-            logger.warn("Received incoming contact request profile picture message from unknown contact")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        contactService.resetContactPhotoSentState(contactModel)
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingDeleteProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingDeleteProfilePictureTask.kt
deleted file mode 100644
index 80e4e76e..00000000
--- a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingDeleteProfilePictureTask.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.contactcontrol
-
-import ch.threema.app.listeners.ContactListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.ContactModel
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingDeleteProfilePictureTask")
-
-class IncomingDeleteProfilePictureTask(
-    private val message: DeleteProfilePictureMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val contactService by lazy { serviceManager.contactService }
-    private val fileService by lazy { serviceManager.fileService }
-    private val avatarCacheService by lazy { serviceManager.avatarCacheService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val contactModel: ContactModel = contactService.getByIdentity(message.fromIdentity) ?: run {
-            logger.warn("Delete profile picture message received from unknown contact")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        fileService.removeContactPhoto(contactModel.identity)
-        this.avatarCacheService.reset(contactModel)
-        ListenerManager.contactListeners.handle { listener: ContactListener ->
-            listener.onAvatarChanged(contactModel)
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingSetProfilePictureTask.kt
deleted file mode 100644
index b2bd8006..00000000
--- a/app/src/main/java/ch/threema/app/processors/contactcontrol/IncomingSetProfilePictureTask.kt
+++ /dev/null
@@ -1,78 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.contactcontrol
-
-import ch.threema.app.listeners.ContactListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.blob.BlobLoader
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.catchAllExceptNetworkException
-import com.neilalexander.jnacl.NaCl
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingSetProfilePictureTask")
-
-class IncomingSetProfilePictureTask(
-    private val message: SetProfilePictureMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val contactService by lazy { serviceManager.contactService }
-    private val apiService by lazy { serviceManager.apiService }
-    private val fileService by lazy { serviceManager.fileService }
-    private val avatarCacheService by lazy { serviceManager.avatarCacheService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val contactModel = contactService.getByIdentity(message.fromIdentity) ?: run {
-            logger.warn("Received profile picture from unknown contact")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val blobLoader: BlobLoader = this.apiService.createLoader(message.blobId)
-
-        // Download blob and throw exception if there is no blob
-        val encryptedBlob = {
-            blobLoader.load(false)
-        }.catchAllExceptNetworkException {
-            logger.error("Could not download profile picture", it)
-            // TODO(ANDR-2869): We should act differently depending on the cause of the failure
-            throw it
-        } ?: throw IllegalStateException("Profile picture blob is null")
-
-        NaCl.symmetricDecryptDataInplace(
-            encryptedBlob,
-            message.encryptionKey,
-            ProtocolDefines.CONTACT_PHOTO_NONCE
-        )
-        this.fileService.writeContactPhoto(contactModel.identity, encryptedBlob)
-        this.avatarCacheService.reset(contactModel)
-        ListenerManager.contactListeners.handle { listener: ContactListener ->
-            listener.onAvatarChanged(contactModel)
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingBallotVoteTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingBallotVoteTask.kt
deleted file mode 100644
index 0b3e1a9a..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingBallotVoteTask.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.ballot.BallotVoteInterface
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingBallotVoteTask(
-    private val message: BallotVoteInterface,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val ballotService = serviceManager.ballotService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        if (message is AbstractGroupMessage && runCommonGroupReceiveSteps(message, handle, serviceManager) == null) {
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val result = this.ballotService.vote(message)
-        return if (result != null && result.isSuccess) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactConversationMessageTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactConversationMessageTask.kt
deleted file mode 100644
index 020f0d2b..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactConversationMessageTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingContactConversationMessageTask(
-    private val message: AbstractMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val messageService = serviceManager.messageService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (messageService.processIncomingContactMessage(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactDeleteMessageTask.kt
deleted file mode 100644
index 84515f0f..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactDeleteMessageTask.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.tasks.runCommonDeleteMessageReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.DeleteMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import org.slf4j.Logger
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingContactDeleteMessageTask")
-
-class IncomingContactDeleteMessageTask(
-    private val deleteMessage: DeleteMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-
-    private val messageService by lazy { serviceManager.messageService }
-    private val contactService by lazy { serviceManager.contactService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingContactDeleteMessageTask id: {}", deleteMessage.data.messageId)
-
-        val contactModel = contactService.getByIdentity(deleteMessage.fromIdentity)
-        if (contactModel == null) {
-            logger.warn("Incoming Delete Message: No contact found for {}", deleteMessage.fromIdentity)
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val receiver = contactService.createReceiver(contactModel)
-        val message = runCommonDeleteMessageReceiveSteps(deleteMessage, receiver, messageService)
-            ?: return ReceiveStepsResult.DISCARD
-
-        messageService.deleteMessageContentsAndEditHistory(message, deleteMessage.date)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactEditMessageTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactEditMessageTask.kt
deleted file mode 100644
index ba6aa02e..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingContactEditMessageTask.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.tasks.runCommonEditMessageReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.EditMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import org.slf4j.Logger
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingContactEditMessageTask")
-
-class IncomingContactEditMessageTask(
-        private val editMessage: EditMessage,
-        serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-
-    private val messageService by lazy { serviceManager.messageService }
-    private val contactService by lazy { serviceManager.contactService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingContactEditMessageTask id: ${editMessage.data.messageId}")
-
-        val contactModel = contactService.getByIdentity(editMessage.fromIdentity)
-        if (contactModel == null) {
-            logger.warn("Incoming Edit Message: No contact found for ${editMessage.fromIdentity}")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val receiver = contactService.createReceiver(contactModel)
-        val message = runCommonEditMessageReceiveSteps(editMessage, receiver, messageService)
-            ?: return ReceiveStepsResult.DISCARD
-
-        messageService.saveEditedMessageText(message, editMessage.data.text, editMessage.date)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupConversationMessageTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupConversationMessageTask.kt
deleted file mode 100644
index d0a1ef4b..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupConversationMessageTask.kt
+++ /dev/null
@@ -1,48 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingGroupConversationMessageTask(
-    private val message: AbstractGroupMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val messageService = serviceManager.messageService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        if (runCommonGroupReceiveSteps(message, handle, serviceManager) == null) {
-            return ReceiveStepsResult.DISCARD
-        }
-
-        return if (messageService.processIncomingGroupMessage(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupDeleteMessageTask.kt
deleted file mode 100644
index bd52c739..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupDeleteMessageTask.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.app.tasks.runCommonDeleteMessageReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import org.slf4j.Logger
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingGroupDeleteMessageTask")
-
-class IncomingGroupDeleteMessageTask(
-    private val deleteMessage: GroupDeleteMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-
-    private val messageService = serviceManager.messageService
-    private val groupService = serviceManager.groupService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingGroupDeleteMessageTask id: {}", deleteMessage.data.messageId)
-
-        val groupModel = runCommonGroupReceiveSteps(deleteMessage, handle, serviceManager)
-            ?: return ReceiveStepsResult.DISCARD
-
-        val receiver = groupService.createReceiver(groupModel)
-        val message = runCommonDeleteMessageReceiveSteps(deleteMessage, receiver, messageService)
-            ?: return ReceiveStepsResult.DISCARD
-
-        messageService.deleteMessageContentsAndEditHistory(message, deleteMessage.date)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupEditMessageTask.kt b/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupEditMessageTask.kt
deleted file mode 100644
index 816f06b4..00000000
--- a/app/src/main/java/ch/threema/app/processors/conversation/IncomingGroupEditMessageTask.kt
+++ /dev/null
@@ -1,58 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.conversation
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.app.tasks.runCommonEditMessageReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.GroupEditMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import org.slf4j.Logger
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("IncomingGroupEditMessageTask")
-
-class IncomingGroupEditMessageTask(
-        private val editMessage: GroupEditMessage,
-        serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-
-    private val messageService by lazy { serviceManager.messageService }
-    private val groupService by lazy { serviceManager.groupService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.debug("IncomingGroupEditMessageTask id: ${editMessage.data.messageId}")
-
-        val groupModel = runCommonGroupReceiveSteps(editMessage, handle, serviceManager)
-                ?: return ReceiveStepsResult.DISCARD
-
-        val receiver = groupService.createReceiver(groupModel)
-        val message = runCommonEditMessageReceiveSteps(editMessage, receiver, messageService)
-            ?: return ReceiveStepsResult.DISCARD
-
-        messageService.saveEditedMessageText(message, editMessage.data.text, editMessage.date)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingEmptyTask.kt b/app/src/main/java/ch/threema/app/processors/fs/IncomingEmptyTask.kt
deleted file mode 100644
index c48c15d6..00000000
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingEmptyTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.fs
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.EmptyMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingEmptyTask")
-
-class IncomingEmptyTask(
-    private val emptyMessage: EmptyMessage,
-    serviceManager: ServiceManager
-) : IncomingCspMessageSubTask(serviceManager) {
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        logger.info("Processed incoming empty message {}", emptyMessage.messageId)
-        return ReceiveStepsResult.SUCCESS
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityAcceptTask.kt b/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityAcceptTask.kt
deleted file mode 100644
index 6b006f98..00000000
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityAcceptTask.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.fs
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataAccept
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingForwardSecurityAcceptTask")
-
-class IncomingForwardSecurityAcceptTask(
-    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    private val contact: Contact,
-    private val data: ForwardSecurityDataAccept,
-) : IncomingForwardSecurityEnvelopeTask {
-    override suspend fun run(handle: ActiveTaskCodec): ForwardSecurityDecryptionResult {
-        logger.info("Received forward security accept message")
-        // TODO(ANDR-2519): Remove when md allows fs
-        // Note that we should only send a terminate message when we receive an encapsulated message.
-        if (!forwardSecurityMessageProcessor.canForwardSecurityMessageBeProcessed(
-                contact, data.sessionId, false, handle
-            )
-        ) {
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        forwardSecurityMessageProcessor.processAccept(contact, data, handle)
-        return ForwardSecurityDecryptionResult.NONE
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityEnvelopeTask.kt b/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityEnvelopeTask.kt
deleted file mode 100644
index 92b026a6..00000000
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityEnvelopeTask.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.fs
-
-import ch.threema.app.tasks.ActiveComposableTask
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-
-interface IncomingForwardSecurityEnvelopeTask :
-    ActiveComposableTask<ForwardSecurityDecryptionResult>
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityInitTask.kt b/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityInitTask.kt
deleted file mode 100644
index 5e3a021d..00000000
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityInitTask.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.fs
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataInit
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingForwardSecurityInitTask")
-
-class IncomingForwardSecurityInitTask(
-    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    private val contact: Contact,
-    private val data: ForwardSecurityDataInit,
-) : IncomingForwardSecurityEnvelopeTask {
-    override suspend fun run(handle: ActiveTaskCodec): ForwardSecurityDecryptionResult {
-        logger.info("Received forward security init message")
-        // TODO(ANDR-2519): Remove when md allows fs
-        // Note that we should only send a terminate message when we receive an encapsulated message.
-        if (!forwardSecurityMessageProcessor.canForwardSecurityMessageBeProcessed(
-                contact, data.sessionId, false, handle
-            )
-        ) {
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        forwardSecurityMessageProcessor.processInit(contact, data, handle)
-        return ForwardSecurityDecryptionResult.NONE
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityMessageTask.kt b/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityMessageTask.kt
deleted file mode 100644
index 76a02d03..00000000
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityMessageTask.kt
+++ /dev/null
@@ -1,46 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.fs
-
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingForwardSecurityMessageTask(
-    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    private val contact: Contact,
-    private val envelopeMessage: ForwardSecurityEnvelopeMessage,
-) : IncomingForwardSecurityEnvelopeTask {
-    override suspend fun run(handle: ActiveTaskCodec): ForwardSecurityDecryptionResult {
-        // TODO(ANDR-2519): Remove when md allows fs
-        if (!forwardSecurityMessageProcessor.canForwardSecurityMessageBeProcessed(
-                contact, envelopeMessage.data.sessionId, true, handle
-            )
-        ) {
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        return forwardSecurityMessageProcessor.processMessage(contact, envelopeMessage, handle)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityRejectTask.kt b/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityRejectTask.kt
deleted file mode 100644
index b7848552..00000000
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityRejectTask.kt
+++ /dev/null
@@ -1,259 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.fs
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.groupcontrol.handleIncomingGroupSyncRequest
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.Contact
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataReject
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.protobuf.Common
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.GroupMessageModel
-import ch.threema.storage.models.GroupModel
-import ch.threema.storage.models.MessageModel
-import ch.threema.storage.models.MessageState
-import ch.threema.storage.models.MessageType
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingForwardSecurityRejectTask")
-
-class IncomingForwardSecurityRejectTask(
-    private val sender: Contact,
-    private val data: ForwardSecurityDataReject,
-    private val serviceManager: ServiceManager,
-) : IncomingForwardSecurityEnvelopeTask {
-    private val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
-    private val messageService by lazy { serviceManager.messageService }
-    private val voipStateService by lazy { serviceManager.voipStateService }
-    private val contactService by lazy { serviceManager.contactService }
-    private val groupService by lazy { serviceManager.groupService }
-    private val databaseService by lazy { serviceManager.databaseServiceNew }
-    private val notificationService by lazy { serviceManager.notificationService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ForwardSecurityDecryptionResult {
-        logger.info("Received a reject message for message {}", data.rejectedApiMessageId)
-        // TODO(ANDR-2519): Remove when md allows fs
-        // Note that in this case we should not send a terminate if we do not support fs. Sending a
-        // terminate could trigger the sender to respond with a terminate again.
-        if (!forwardSecurityMessageProcessor.canForwardSecurityMessageBeProcessed(
-                sender, data.sessionId, false, handle
-            )
-        ) {
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        forwardSecurityMessageProcessor.processReject(sender, data, handle)
-
-        val groupIdentity = data.groupIdentity
-        if (groupIdentity == null || groupIdentity.isEmpty()) {
-            handleContactMessageReject()
-        } else {
-            handleGroupMessageReject(groupIdentity.groupId, groupIdentity.creatorIdentity, handle)
-        }
-
-        return ForwardSecurityDecryptionResult.NONE
-    }
-
-    private fun handleContactMessageReject() {
-        when (val messageModel = getContactMessageModel()) {
-            is MessageModel -> {
-                handleReject(messageModel)
-            }
-
-            null -> {
-                voipStateService.handlePotentialCallMessageReject(data.rejectedApiMessageId)
-            }
-
-            else -> {
-                logger.warn(
-                    "Invalid message model found for rejected message id {}",
-                    data.rejectedApiMessageId
-                )
-            }
-        }
-    }
-
-    private suspend fun handleGroupMessageReject(
-        groupId: Long,
-        creatorIdentity: String,
-        handle: ActiveTaskCodec,
-    ) {
-        // 1. Run the common group receive steps and abort if the group is not found
-        val group = runCommonGroupReceiveSteps(
-            GroupId(groupId),
-            creatorIdentity,
-            sender.identity,
-            handle,
-            serviceManager
-        )
-
-        // 2. Lookup the group and 3. abort if not defined
-        if (group == null) {
-            logger.warn("Received reject of a group message of unknown group")
-            return
-        }
-
-        // 4. Look up the message for the message id
-        val messageModel = getGroupMessageModel(group)
-
-        // 5. If the message is not defined
-        if (messageModel == null) {
-            // 5.1 If the user is the creator of the group, assume that a group sync request has
-            // been received
-            if (groupService.isGroupCreator(group)) {
-                handleIncomingGroupSyncRequest(group, sender.identity, handle, serviceManager)
-            }
-            // 5.2 Abort these steps
-            return
-        }
-
-        // 6. If the user is not the sender of the message, abort these steps
-        if (!messageModel.isOutbox) {
-            logger.warn("Received reject of a message where the user is not the sender")
-            return
-        }
-
-        // 7. If the reject logic of the message type allows re-send, mark the message with
-        // 're-send requested' and add the sender to the list of receivers requesting a re-send
-        handleReject(messageModel, group)
-    }
-
-    private fun getContactMessageModel(): AbstractMessageModel? =
-        databaseService.messageModelFactory.getByApiMessageIdAndIdentityAndIsOutbox(
-            data.rejectedApiMessageId,
-            sender.identity,
-            true
-        )
-
-    private fun getGroupMessageModel(group: GroupModel): GroupMessageModel? {
-        val messageModel = messageService.getMessageModelByApiMessageIdAndReceiver(
-            data.rejectedApiMessageId.toString(),
-            groupService.createReceiver(group)
-        )
-        return when (messageModel) {
-            is GroupMessageModel -> {
-                messageModel
-            }
-
-            null -> {
-                logger.info("Rejected message model is not found. Handling reject as incoming group sync request.")
-                null
-            }
-
-            else -> {
-                logger.warn("Rejected message model is not a group message model even though the group identity is set")
-                null
-            }
-        }
-    }
-
-    private fun handleReject(messageModel: MessageModel) {
-        val type = messageModel.type ?: return
-        when (type) {
-            MessageType.TEXT,
-            MessageType.LOCATION,
-            MessageType.FILE,
-            MessageType.BALLOT,
-            -> {
-                // Mark the message with 're-send requested'. Note that we use the fs key mismatch
-                // state to represent the 're-send requested'-mark.
-                messageService.updateContactMessageState(
-                    data.rejectedApiMessageId,
-                    sender.identity,
-                    MessageState.FS_KEY_MISMATCH,
-                    Date()
-                )
-
-                // Show a notification that a reject was received (if the contact is known)
-                contactService.getByIdentity(messageModel.identity)
-                    ?.let { contactService.createReceiver(it) }?.let { receiver ->
-                        notificationService.showForwardSecurityMessageRejectedNotification(receiver)
-                    }
-            }
-
-            MessageType.IMAGE,
-            MessageType.VIDEO,
-            MessageType.VOICEMESSAGE,
-            MessageType.CONTACT,
-            -> logger.warn("Received a reject for a deprecated message")
-
-            MessageType.STATUS,
-            MessageType.VOIP_STATUS,
-            MessageType.DATE_SEPARATOR,
-            MessageType.GROUP_CALL_STATUS,
-            MessageType.FORWARD_SECURITY_STATUS,
-            MessageType.GROUP_STATUS,
-            -> logger.warn("Received a reject for a status message")
-        }
-    }
-
-    private fun handleReject(messageModel: GroupMessageModel, group: GroupModel) {
-        val type = messageModel.type ?: return
-        when (type) {
-            MessageType.TEXT,
-            MessageType.LOCATION,
-            MessageType.FILE,
-            MessageType.BALLOT,
-            -> {
-                // Mark the message with 're-send requested'. Note that we use the fs key mismatch
-                // state to represent the 're-send requested'-mark.
-                messageService.updateMessageState(
-                    messageModel,
-                    MessageState.FS_KEY_MISMATCH,
-                    Date()
-                )
-
-                // Add the sender to the list of recipients requesting a re-send
-                databaseService.rejectedGroupMessageFactory.insertMessageReject(
-                    MessageId.fromString(messageModel.apiMessageId), sender.identity, group
-                )
-
-                // Show a notification that a reject was received
-                notificationService.showForwardSecurityMessageRejectedNotification(
-                    groupService.createReceiver(group)
-                )
-            }
-
-            MessageType.IMAGE,
-            MessageType.VIDEO,
-            MessageType.VOICEMESSAGE,
-            MessageType.CONTACT,
-            -> logger.warn("Received a reject for a deprecated message")
-
-            MessageType.STATUS,
-            MessageType.VOIP_STATUS,
-            MessageType.DATE_SEPARATOR,
-            MessageType.GROUP_CALL_STATUS,
-            MessageType.FORWARD_SECURITY_STATUS,
-            MessageType.GROUP_STATUS,
-            -> logger.warn("Received a reject for a status message")
-        }
-    }
-
-    private fun Common.GroupIdentity.isEmpty() = groupId == 0L && creatorIdentity == ""
-}
diff --git a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityTerminateTask.kt b/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityTerminateTask.kt
deleted file mode 100644
index 26d98f3a..00000000
--- a/app/src/main/java/ch/threema/app/processors/fs/IncomingForwardSecurityTerminateTask.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.fs
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataTerminate
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingForwardSecurityTerminateTask")
-
-class IncomingForwardSecurityTerminateTask(
-    private val forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    private val contact: Contact,
-    private val data: ForwardSecurityDataTerminate,
-) : IncomingForwardSecurityEnvelopeTask {
-    override suspend fun run(handle: ActiveTaskCodec): ForwardSecurityDecryptionResult {
-        logger.info("Received forward security terminate message")
-        // TODO(ANDR-2519): Remove when md allows fs
-        // Note that in this case we should not send a terminate if we do not support fs. Sending a
-        // terminate could trigger the sender to respond with a terminate again.
-        if (!forwardSecurityMessageProcessor.canForwardSecurityMessageBeProcessed(
-                contact, data.sessionId, false, handle
-            )
-        ) {
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        forwardSecurityMessageProcessor.processTerminate(contact, data)
-        return ForwardSecurityDecryptionResult.NONE
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupCallControlTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupCallControlTask.kt
deleted file mode 100644
index bf1890e0..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupCallControlTask.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallControlMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingGroupCallControlTask(
-    private val message: GroupCallControlMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val groupCallManager = serviceManager.groupCallManager
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (runCommonGroupReceiveSteps(
-                message as AbstractGroupMessage,
-                handle,
-                serviceManager
-            ) != null
-        ) {
-            groupCallManager.handleControlMessage(message)
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
deleted file mode 100644
index de29c359..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupDeleteProfilePictureTask.kt
+++ /dev/null
@@ -1,61 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.GroupDeleteProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupDeleteProfilePictureTask")
-
-class IncomingGroupDeleteProfilePictureTask(
-    private val deleteProfilePictureMessage: GroupDeleteProfilePictureMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val fileService = serviceManager.fileService
-    private val avatarCacheService = serviceManager.avatarCacheService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        // 1. Run the common group receive steps
-        val groupModel =
-            runCommonGroupReceiveSteps(deleteProfilePictureMessage, handle, serviceManager)
-        if (groupModel == null) {
-            logger.warn("Discarding group delete profile picture message because group could not be found")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        // 2. Remove the profile picture of the group
-        if (fileService.hasGroupAvatarFile(groupModel)) {
-            fileService.removeGroupAvatar(groupModel)
-
-            avatarCacheService.reset(groupModel)
-
-            ListenerManager.groupListeners.handle { it.onUpdatePhoto(groupModel) }
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinRequestTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinRequestTask.kt
deleted file mode 100644
index b7398ed9..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinRequestTask.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingGroupJoinRequestTask(
-    private val message: GroupJoinRequestMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val incomingGroupJoinRequestService = serviceManager.incomingGroupJoinRequestService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        return if (incomingGroupJoinRequestService.process(message)) {
-            ReceiveStepsResult.SUCCESS
-        } else {
-            ReceiveStepsResult.DISCARD
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinResponseMessage.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinResponseMessage.kt
deleted file mode 100644
index b572a234..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupJoinResponseMessage.kt
+++ /dev/null
@@ -1,103 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.grouplinks.GroupJoinResponseListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseData
-import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.group.OutgoingGroupJoinRequestModel
-import java8.util.Optional
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupJoinResponseMessage")
-
-class IncomingGroupJoinResponseMessage(
-    private val message: GroupJoinResponseMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val outgoingGroupJoinRequestModelFactory = serviceManager.databaseServiceNew.outgoingGroupJoinRequestModelFactory
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val responseData: GroupJoinResponseData = message.data
-        val token = responseData.token
-
-        val joinRequest: Optional<OutgoingGroupJoinRequestModel> =
-            outgoingGroupJoinRequestModelFactory
-                .getByInviteToken(token.toString())
-
-        if (joinRequest.isEmpty) {
-            logger.info("Group Join Response: Ignore with unknown request")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val outgoingGroupJoinRequestModel = joinRequest.get()
-
-        val sender: String = message.fromIdentity
-        if (outgoingGroupJoinRequestModel.adminIdentity != sender) {
-            logger.info(
-                "Group Join Response: Ignore with invalid sender {}",
-                sender
-            )
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val response = responseData.response
-        val status: OutgoingGroupJoinRequestModel.Status
-
-        val updatedRequestBuilder =
-            OutgoingGroupJoinRequestModel.Builder(outgoingGroupJoinRequestModel)
-
-        status = when (response) {
-            is GroupJoinResponseData.Accept -> {
-                val groupId = response.groupId
-                updatedRequestBuilder.withGroupApiId(GroupId(groupId)).build()
-                OutgoingGroupJoinRequestModel.Status.ACCEPTED
-            }
-            is GroupJoinResponseData.Reject -> OutgoingGroupJoinRequestModel.Status.REJECTED
-            is GroupJoinResponseData.GroupFull -> OutgoingGroupJoinRequestModel.Status.GROUP_FULL
-            is GroupJoinResponseData.Expired -> OutgoingGroupJoinRequestModel.Status.EXPIRED
-            else -> throw IllegalStateException("Invalid response: " + responseData.response)
-        }
-
-        updatedRequestBuilder.withResponseStatus(status)
-
-        val updateModel = updatedRequestBuilder.build()
-        outgoingGroupJoinRequestModelFactory.update(
-            updateModel
-        )
-
-        ListenerManager.groupJoinResponseListener.handle { listener: GroupJoinResponseListener ->
-            listener.onReceived(
-                updateModel,
-                status
-            )
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupLeaveTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupLeaveTask.kt
deleted file mode 100644
index 25df4c53..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupLeaveTask.kt
+++ /dev/null
@@ -1,101 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.services.GroupService
-import ch.threema.app.tasks.OutgoingGroupSyncRequestTask
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupLeaveTask")
-
-class IncomingGroupLeaveTask(
-    private val groupLeaveMessage: GroupLeaveMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val groupService = serviceManager.groupService
-    private val userService = serviceManager.userService
-    private val groupCallManager = serviceManager.groupCallManager
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val creator = groupLeaveMessage.groupCreator
-        val sender = groupLeaveMessage.fromIdentity
-
-        // 1. If the sender is the creator of the group, abort these steps
-        if (sender == creator) {
-            logger.warn("Discarding group leave message from group creator")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        // 2. Look up the group
-        val group = groupService.getByGroupMessage(groupLeaveMessage)
-
-        // 3. If the group could not be found or is marked as left
-        if (group == null || !groupService.isGroupMember(group)) {
-            // 3.1 If the user is the creator of the group, abort these steps
-            if (userService.identity == creator) {
-                return ReceiveStepsResult.DISCARD
-            }
-            // 3.2 Send a group-sync-request to the group creator and abort these steps
-            OutgoingGroupSyncRequestTask(
-                groupLeaveMessage.apiGroupId,
-                creator,
-                null,
-                serviceManager
-            ).invoke(handle)
-            return ReceiveStepsResult.DISCARD
-        }
-
-        @GroupService.GroupState val oldGroupState = groupService.getGroupState(group)
-
-        // 4. Remove the member from the local group
-        val previousCount = groupService.countMembers(group)
-        if (groupService.removeMemberFromGroup(group, sender)) {
-            ListenerManager.groupListeners.handle { it.onMemberLeave(group, sender, previousCount) }
-        }
-        // Reset the cache
-        groupService.resetCache(group.id)
-
-        @GroupService.GroupState val newGroupState = groupService.getGroupState(group)
-
-        // Trigger a state change if the group transitions from a people group to a notes group
-        if (oldGroupState != newGroupState) {
-            ListenerManager.groupListeners.handle {
-                it.onGroupStateChanged(group, oldGroupState, newGroupState)
-            }
-        }
-
-        // 5. Run the rejected messages refresh steps for the group
-        groupService.runRejectedMessagesRefreshSteps(group)
-
-        // 6. If the user and the sender are participating in a group call of this group, remove the
-        // sender from the group call (handle it as if the sender left the call)
-        groupCallManager.updateAllowedCallParticipants(group)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupMessageUtils.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupMessageUtils.kt
deleted file mode 100644
index 9a964f6d..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupMessageUtils.kt
+++ /dev/null
@@ -1,148 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.tasks.OutgoingGroupLeaveTask
-import ch.threema.app.tasks.OutgoingGroupSetupTask
-import ch.threema.app.tasks.OutgoingGroupSyncRequestTask
-import ch.threema.app.utils.TestUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.GroupModel
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupUtils")
-
-suspend fun runCommonGroupReceiveSteps(
-    message: AbstractGroupMessage,
-    handle: ActiveTaskCodec,
-    serviceManager: ServiceManager,
-): GroupModel? = runCommonGroupReceiveSteps(
-    message.apiGroupId,
-    message.groupCreator,
-    message.fromIdentity,
-    handle,
-    serviceManager
-)
-
-/**
- * Run the common group receive steps.
- *
- * @return the group model if the steps completed successfully, null otherwise
- */
-suspend fun runCommonGroupReceiveSteps(
-    groupId: GroupId,
-    creatorIdentity: String,
-    fromIdentity: String,
-    handle: ActiveTaskCodec,
-    serviceManager: ServiceManager,
-): GroupModel? {
-    val userService = serviceManager.userService
-    val groupService = serviceManager.groupService
-
-    // 1. Look up the group
-    val groupModel = groupService.getByApiGroupIdAndCreator(groupId, creatorIdentity)
-
-    // 2. Check if the group could be found
-    if (groupModel == null) {
-        if (TestUtil.compare(creatorIdentity, userService.identity)) {
-            // 2.1 If the user is the creator of the group (as alleged by received message),
-            // discard the received message and abort these steps
-            logger.info("Could not find group with me as creator")
-            return null
-        }
-        // 2.2 Send a group-sync-request to the group creator
-        sendGroupSyncRequest(groupId, creatorIdentity, serviceManager, handle)
-        return null
-    }
-
-    // 3. Check if the group is left
-    if (!groupService.isGroupMember(groupModel)) {
-        if (groupService.isGroupCreator(groupModel)) {
-            // 3.1 If the user is the creator, send a group-setup with an empty
-            // members list back to the sender and discard the received message.
-            logger.info("Got a message in a left group where I am the creator")
-            sendEmptyGroupSetup(groupModel, fromIdentity, handle, serviceManager)
-        } else {
-            // 3.2 Send a group leave to the sender and discard the received message
-            logger.info("Got a message in a left group")
-            OutgoingGroupLeaveTask(
-                groupId,
-                creatorIdentity,
-                setOf(fromIdentity),
-                null,
-                serviceManager
-            ).invoke(handle)
-        }
-        return null
-    }
-
-    // 4. If the sender is not a member of the group and the user is the creator of the group,
-    // send a group-setup with an empty members list back to the sender and discard the received
-    // message.
-    if (!groupService.getGroupIdentities(groupModel).contains(fromIdentity)) {
-        logger.info("Got a message in a group from a sender that is not a member")
-        if (groupService.isGroupCreator(groupModel)) {
-            // 4.1 If the user is the creator of the group, send a group-setup with an empty member
-            // list back
-            sendEmptyGroupSetup(groupModel, fromIdentity, handle, serviceManager)
-        } else {
-            // 4.2 Send a group-sync-request to the group creator
-            sendGroupSyncRequest(groupId, creatorIdentity, serviceManager, handle)
-        }
-        // Abort these steps
-        return null
-    }
-    return groupModel
-}
-
-suspend fun sendEmptyGroupSetup(
-    groupModel: GroupModel,
-    receiverIdentity: String,
-    handle: ActiveTaskCodec,
-    serviceManager: ServiceManager,
-) {
-    OutgoingGroupSetupTask(
-        groupModel.apiGroupId,
-        groupModel.creatorIdentity,
-        emptySet(),
-        setOf(receiverIdentity),
-        null,
-        serviceManager
-    ).invoke(handle)
-}
-
-private suspend fun sendGroupSyncRequest(
-    groupId: GroupId,
-    creatorIdentity: String,
-    serviceManager: ServiceManager,
-    handle: ActiveTaskCodec,
-) {
-    OutgoingGroupSyncRequestTask(
-        groupId,
-        creatorIdentity,
-        null,
-        serviceManager
-    ).invoke(handle)
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupNameTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupNameTask.kt
deleted file mode 100644
index 05776be4..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupNameTask.kt
+++ /dev/null
@@ -1,71 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.listeners.GroupListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.GroupNameMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupNameTask")
-
-/**
- * The task to run the required steps when a group rename message has been received.
- */
-class IncomingGroupNameTask(
-    private val groupNameMessage: GroupNameMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val databaseService = serviceManager.databaseServiceNew
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        // 1. Run the common group receive steps
-        val groupModel = runCommonGroupReceiveSteps(groupNameMessage, handle, serviceManager)
-        if (groupModel == null) {
-            logger.warn("Discarding group name message because group could not be found")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        val newGroupName = groupNameMessage.groupName ?: ""
-        val oldGroupName = groupModel.name ?: ""
-
-        // 2. Update the group with the given name (only if the new name is different)
-        if (oldGroupName != newGroupName) {
-            groupModel.name = newGroupName
-            val success = databaseService.groupModelFactory.createOrUpdate(groupModel)
-            if (!success) {
-                logger.error("Failed to update the group model")
-                return ReceiveStepsResult.DISCARD
-            }
-
-            ListenerManager.groupListeners.handle { listener: GroupListener ->
-                listener.onRename(groupModel)
-            }
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetProfilePictureTask.kt
deleted file mode 100644
index b66b5474..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetProfilePictureTask.kt
+++ /dev/null
@@ -1,94 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.GroupSetProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.GroupModel
-import com.neilalexander.jnacl.NaCl
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupSetProfilePictureTask")
-
-class IncomingGroupSetProfilePictureTask(
-    private val setProfilePictureMessage: GroupSetProfilePictureMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val fileService = serviceManager.fileService
-    private val apiService = serviceManager.apiService
-    private val avatarCacheService = serviceManager.avatarCacheService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        // 1. Run the common group receive steps
-        val group = runCommonGroupReceiveSteps(setProfilePictureMessage, handle, serviceManager)
-        if (group == null) {
-            logger.warn("Discarding group set profile picture message because group could not be found")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        // 2. Download the picture from the blob server but do not request the blob to be removed
-        val blobLoader = apiService.createLoader(setProfilePictureMessage.blobId)
-        // TODO(ANDR-2869): Correctly handle blob server faults
-        val blob = blobLoader.load(false)
-            ?: throw IllegalStateException("Profile picture blob is null")
-        NaCl.symmetricDecryptDataInplace(
-            blob,
-            setProfilePictureMessage.encryptionKey,
-            ProtocolDefines.GROUP_PHOTO_NONCE
-        )
-
-        // 3. Store and apply the profile picture to the group (if it is different than the old one)
-        if (hasDifferentGroupPhoto(group, blob)) {
-            this.fileService.writeGroupAvatar(group, blob)
-
-            this.avatarCacheService.reset(group)
-
-            ListenerManager.groupListeners.handle { it.onUpdatePhoto(group) }
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-
-    private fun hasDifferentGroupPhoto(group: GroupModel, newGroupPhoto: ByteArray?): Boolean {
-        var differentGroupPhoto = true
-        fileService.getGroupAvatarStream(group).use { existingAvatar ->
-            if (newGroupPhoto != null && existingAvatar != null) {
-                var index = 0
-                var next: Int
-                while (existingAvatar.read().also { next = it } != -1) {
-                    if (next.toByte() != newGroupPhoto[index]) {
-                        break
-                    }
-                    index++
-                }
-                differentGroupPhoto = index != newGroupPhoto.size
-            }
-        }
-        return differentGroupPhoto
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetupTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetupTask.kt
deleted file mode 100644
index 1ad23c20..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSetupTask.kt
+++ /dev/null
@@ -1,231 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.filterValid
-import ch.threema.app.utils.sendMessageToReceivers
-import ch.threema.app.utils.toContactModels
-import ch.threema.app.voip.groupcall.localGroupId
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.GroupModel
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupSetupTask")
-
-class IncomingGroupSetupTask(
-    private val groupSetupMessage: GroupSetupMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val userService = serviceManager.userService
-    private val contactService = serviceManager.contactService
-    private val groupService = serviceManager.groupService
-    private val blockedContactsService = serviceManager.blockedContactsService
-    private val groupCallManager = serviceManager.groupCallManager
-    private val databaseService = serviceManager.databaseServiceNew
-    private val contactStore = serviceManager.contactStore
-    private val identityStore = serviceManager.identityStore
-    private val nonceFactory = serviceManager.nonceFactory
-    private val apiConnector by lazy { serviceManager.apiConnector }
-    private val taskCreator by lazy { serviceManager.taskCreator }
-    private val preferenceService = serviceManager.preferenceService
-    private val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        // 1. Let members be the given member list. Remove all duplicate entries from members.
-        // Remove the sender from members if present.
-        val sender = groupSetupMessage.fromIdentity
-        val members = groupSetupMessage.members.filter { it != sender }.toSet()
-        val myIdentity = userService.identity
-
-        // 2. Look up the group
-        var group = groupService.getByGroupMessage(groupSetupMessage)
-        val previousMemberCount = if (group != null) {
-            groupService.countMembers(group)
-        } else {
-            0
-        }
-
-        val newGroup = group == null
-
-        // 3. If the group could not be found:
-        if (group == null) {
-            // 3.1 If the user is not present in members, abort these steps
-            if (!members.contains(myIdentity)) {
-                logger.info("Dismissing group setup message for unknown group without the user as member")
-                return ReceiveStepsResult.DISCARD
-            }
-            // 3.2 If the sender is blocked, send a group-leave message to the sender and all
-            // provided members (including those who are blocked) and abort these steps.
-            if (isBlocked(sender)) {
-                logger.info("Sending a leave message to the creator of a new group that is blocked")
-                sendLeave(handle, groupSetupMessage.apiGroupId, sender, members)
-                return ReceiveStepsResult.SUCCESS
-            }
-        }
-
-        // 4. If the group could be found and members is empty or does not include the user:
-        if (group != null && !members.contains(myIdentity)) {
-            // 4.1 If the user is currently participating in a group call of this group, trigger
-            // leaving the call.
-            if (groupCallManager.hasJoinedCall(group.localGroupId)) {
-                logger.info("Group call is running in a group where the user just has been kicked")
-                groupCallManager.abortCurrentCall()
-            }
-
-            // If we are not a member anyway, we do not have to do anything. Especially, we should
-            // not call the listener as this would trigger a status message each time.
-            if (!groupService.isGroupMember(group)) {
-                return ReceiveStepsResult.SUCCESS
-            }
-
-            // 4.2 Mark the group as left and abort these steps.
-            groupService.removeMemberFromGroup(group, myIdentity)
-
-            ListenerManager.groupListeners.handle {
-                it.onMemberKicked(
-                    group,
-                    myIdentity,
-                    previousMemberCount,
-                )
-            }
-
-            return ReceiveStepsResult.SUCCESS
-        }
-
-        // 5. For each member of members, create a contact with acquaintance level group
-        // if not already present in the contact list.
-        val unknownContacts = members.filter { contactService.getByIdentity(it) == null }
-        contactService.createGroupContactsByIdentities(unknownContacts)
-
-        // 6. Create or update the group with the given members plus the sender (creator).
-        val now = Date()
-        if (group == null) {
-            group = GroupModel().apply {
-                apiGroupId = groupSetupMessage.apiGroupId
-                creatorIdentity = groupSetupMessage.groupCreator
-                createdAt = now
-                lastUpdate = now
-            }
-            databaseService.groupModelFactory.create(group)
-        } else if (group.isDeleted || !groupService.isGroupMember(group)) {
-            group.isDeleted = false
-            group.lastUpdate = now
-            databaseService.groupModelFactory.update(group)
-        }
-        updateMembers(group, members, previousMemberCount)
-
-        // If the group is new, then fire the listener.
-        if (newGroup) {
-            ListenerManager.groupListeners.handle { it.onCreate(group) }
-        }
-
-        // 7. If the group was previously marked as left, remove the left mark.
-        // Note that this step is already handled in step 6, because a group is defined to be left,
-        // if the user is not part of the members.
-
-        // 8. Run the rejected messages refresh steps for the group
-        groupService.runRejectedMessagesRefreshSteps(group)
-
-        // 9. If the user is currently participating in a group call of this group and there are
-        // group call participants that are no longer members of the group, remove these
-        // participants from the group call (handle them as if they left the call).
-        groupCallManager.updateAllowedCallParticipants(group)
-
-        return ReceiveStepsResult.SUCCESS
-    }
-
-    private suspend fun sendLeave(
-        handle: ActiveTaskCodec,
-        apiGroupId: GroupId,
-        creatorIdentity: String,
-        members: Set<String>,
-    ) {
-        val messageId = MessageId()
-        val myIdentity = userService.identity
-
-        val recipients = (members + creatorIdentity - myIdentity)
-            .toContactModels(contactService, apiConnector)
-            .filterValid()
-            .toSet()
-
-        handle.sendMessageToReceivers(
-            OutgoingCspGroupMessageCreator(messageId, apiGroupId, creatorIdentity) { GroupLeaveMessage() },
-            recipients,
-            forwardSecurityMessageProcessor,
-            identityStore,
-            contactStore,
-            nonceFactory,
-            blockedContactsService,
-            taskCreator
-        )
-    }
-
-    private fun updateMembers(group: GroupModel, members: Set<String>, previousMemberCount: Int) {
-        // Delete all local group members that are not a member of the updated group. Don't delete
-        // the group creator.
-        val localMembersToDelete = groupService.getGroupMemberModels(group)
-            .filter { group.creatorIdentity != it.identity && !members.contains(it.identity) }
-
-        localMembersToDelete.forEach { memberModel ->
-            // Remove member from group
-            groupService.removeMemberFromGroup(group, memberModel.identity)
-
-            // Notify listeners that the member has been removed
-            ListenerManager.groupListeners.handle {
-                it.onMemberKicked(
-                    group,
-                    memberModel.identity,
-                    previousMemberCount
-                )
-            }
-        }
-
-        // All members that are already added (including the group creator)
-        val addedMembers = groupService.getGroupMemberModels(group).map { it.identity }
-
-        // All members including the creator that should be part of the group
-        val allMembers = (listOf(group.creatorIdentity) + members).toSet()
-
-        // Add all members to the group that are not already in the group
-        allMembers.filter { !addedMembers.contains(it) }.forEach { memberIdentity ->
-            if (groupService.addMemberToGroup(group, memberIdentity)) {
-                ListenerManager.groupListeners.handle {
-                    it.onNewMember(group, memberIdentity, previousMemberCount)
-                }
-            }
-        }
-    }
-
-    private fun isBlocked(identity: String): Boolean =
-        blockedContactsService.has(identity) ||
-                (contactService.getByIdentity(identity) == null && preferenceService.isBlockUnknown)
-}
diff --git a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSyncRequestTask.kt b/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSyncRequestTask.kt
deleted file mode 100644
index 9b541ad6..00000000
--- a/app/src/main/java/ch/threema/app/processors/groupcontrol/IncomingGroupSyncRequestTask.kt
+++ /dev/null
@@ -1,116 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.groupcontrol
-
-import android.text.format.DateUtils
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.services.GroupService
-import ch.threema.app.tasks.OutgoingGroupSyncTask
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.GroupModel
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupSyncRequestTask")
-
-class IncomingGroupSyncRequestTask(
-    private val groupSyncRequestMessage: GroupSyncRequestMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val groupService by lazy { serviceManager.groupService }
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        // 1. Look up the group. If the group could not be found, abort these steps
-        val group = groupService.getByGroupMessage(groupSyncRequestMessage)
-        if (group == null) {
-            logger.warn("Discarding group sync request message because group could not be found")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        if (!groupService.isGroupCreator(group)) {
-            logger.warn("Discarding group sync request message to non-creator")
-            return ReceiveStepsResult.DISCARD
-        }
-
-        return handleIncomingGroupSyncRequest(
-            group,
-            groupSyncRequestMessage.fromIdentity,
-            handle,
-            serviceManager
-        )
-    }
-}
-
-suspend fun handleIncomingGroupSyncRequest(
-    group: GroupModel,
-    sender: String,
-    handle: ActiveTaskCodec,
-    serviceManager: ServiceManager,
-): ReceiveStepsResult {
-    val groupService = serviceManager.groupService
-    val incomingGroupSyncRequestLogModelFactory =
-        serviceManager.databaseServiceNew.incomingGroupSyncRequestLogModelFactory
-
-    // 2. If a group-sync-request from this sender and group has already been handled within the
-    //    last hour, log a notice and abort these steps
-    val groupSyncLog = incomingGroupSyncRequestLogModelFactory.getByGroupIdAndSenderIdentity(
-        group.id, sender
-    )
-    val now = System.currentTimeMillis()
-    val oneHourAgo = now - DateUtils.HOUR_IN_MILLIS
-    if (groupSyncLog.lastHandledRequest > oneHourAgo) {
-        logger.info("Group sync request already handled {}ms ago", now - groupSyncLog.lastHandledRequest)
-        return ReceiveStepsResult.DISCARD
-    }
-    incomingGroupSyncRequestLogModelFactory.createOrUpdate(
-        groupSyncLog.apply { lastHandledRequest = now }
-    )
-
-    // 3. If the group is marked as left or the sender is not a member of the group, send a
-    //    group-setup with an empty members list back to the sender and abort these steps.
-    if (groupService.isLeftGroup(group) || !groupService.isSenderGroupMember(group, sender)) {
-        sendEmptyGroupSetup(group, sender, handle, serviceManager)
-        return ReceiveStepsResult.DISCARD
-    }
-
-    // 4. Send a group-setup message followed by a group-name message, 5. send a
-    //    set-profile-picture (if set), and 6. send a delete-profile-picture (if not set)
-    OutgoingGroupSyncTask(
-        group.apiGroupId,
-        group.creatorIdentity,
-        setOf(sender),
-        serviceManager
-    ).invoke(handle)
-
-    // 7. If a group call is currently considered running within this group, send a group call
-    //    start message
-    serviceManager.groupCallManager.sendGroupCallStartToNewMembers(group, setOf(sender), handle)
-
-    return ReceiveStepsResult.SUCCESS
-}
-
-private fun GroupService.isLeftGroup(group: GroupModel): Boolean = !isGroupMember(group)
-
-private fun GroupService.isSenderGroupMember(group: GroupModel, sender: String) =
-    getMembers(group).map { it.identity }.contains(sender)
diff --git a/app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt b/app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt
deleted file mode 100644
index 89a80f44..00000000
--- a/app/src/main/java/ch/threema/app/processors/push/IncomingWebSessionResumeMessageTask.kt
+++ /dev/null
@@ -1,42 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.push
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.utils.PushUtil
-import ch.threema.domain.protocol.csp.messages.WebSessionResumeMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingWebSessionResumeMessageTask(
-    private val message: WebSessionResumeMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        PushUtil.processRemoteMessage(message.getData())
-
-        return ReceiveStepsResult.SUCCESS
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingDeliveryReceiptTask.kt
deleted file mode 100644
index 7a79a0b4..00000000
--- a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingDeliveryReceiptTask.kt
+++ /dev/null
@@ -1,63 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.statusupdates
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.MessageState
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingDeliveryReceiptTask")
-
-class IncomingDeliveryReceiptTask(
-    private val message: DeliveryReceiptMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val messageService = serviceManager.messageService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val state: MessageState = when (message.receiptType) {
-            ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED -> MessageState.DELIVERED
-            ProtocolDefines.DELIVERYRECEIPT_MSGREAD -> MessageState.READ
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERACK -> MessageState.USERACK
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERDEC -> MessageState.USERDEC
-            else -> {
-                logger.warn("Message {} error: unknown delivery receipt type", message.messageId)
-                return ReceiveStepsResult.DISCARD
-            }
-        }
-        for (msgId in message.receiptMessageIds) {
-            logger.info(
-                "Message {}: delivery receipt for {} (state = {})",
-                message.messageId,
-                msgId,
-                state
-            )
-            this.messageService.updateMessageState(msgId, state, message)
-        }
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingGroupDeliveryReceiptTask.kt b/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingGroupDeliveryReceiptTask.kt
deleted file mode 100644
index 190f280c..00000000
--- a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingGroupDeliveryReceiptTask.kt
+++ /dev/null
@@ -1,70 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.statusupdates
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.app.processors.groupcontrol.runCommonGroupReceiveSteps
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.MessageState
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingGroupDeliveryReceiptTask")
-
-class IncomingGroupDeliveryReceiptTask(
-    private val message: GroupDeliveryReceiptMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val messageService = serviceManager.messageService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        val state: MessageState = when (message.receiptType) {
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERACK -> MessageState.USERACK
-            ProtocolDefines.DELIVERYRECEIPT_MSGUSERDEC -> MessageState.USERDEC
-            else -> {
-                logger.warn(
-                    "Message {} error: unknown or unsupported delivery receipt type",
-                    message.messageId
-                )
-                return ReceiveStepsResult.DISCARD
-            }
-        }
-        if (runCommonGroupReceiveSteps(message, handle, serviceManager) == null) {
-            // If the common group receive steps did not succeed, ignore this delivery receipt
-            return ReceiveStepsResult.DISCARD
-        }
-        for (messageId in message.receiptMessageIds) {
-            logger.info(
-                "Message {}: group delivery receipt for {} (state = {})",
-                messageId.messageId,
-                messageId,
-                state
-            )
-            messageService.updateGroupMessageState(messageId, state, message)
-        }
-
-        return ReceiveStepsResult.SUCCESS
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingTypingIndicatorTask.kt b/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingTypingIndicatorTask.kt
deleted file mode 100644
index 3742b12d..00000000
--- a/app/src/main/java/ch/threema/app/processors/statusupdates/IncomingTypingIndicatorTask.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.processors.statusupdates
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.processors.IncomingCspMessageSubTask
-import ch.threema.app.processors.ReceiveStepsResult
-import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class IncomingTypingIndicatorTask(
-    private val message: TypingIndicatorMessage,
-    serviceManager: ServiceManager,
-) : IncomingCspMessageSubTask(serviceManager) {
-    private val contactService = serviceManager.contactService
-
-    override suspend fun run(handle: ActiveTaskCodec): ReceiveStepsResult {
-        if (contactService.getByIdentity(message.fromIdentity) != null) {
-            contactService.setIsTyping(message.fromIdentity, message.isTyping)
-            return ReceiveStepsResult.SUCCESS
-        }
-        return ReceiveStepsResult.DISCARD
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt b/app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt
deleted file mode 100644
index d8115d76..00000000
--- a/app/src/main/java/ch/threema/app/protocol/ApplicationSetupSteps.kt
+++ /dev/null
@@ -1,100 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.protocol
-
-import android.content.Context
-import androidx.annotation.WorkerThread
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.tasks.FSRefreshStepsTask
-import ch.threema.app.tasks.OutgoingContactRequestProfilePictureTask
-import ch.threema.app.workers.ContactUpdateWorker
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.storage.models.ContactModel
-
-private val logger = LoggingUtil.getThreemaLogger("ApplicationSetupSteps")
-
-/**
- * Run the _Application Setup Steps_ as defined in the protocol.
- */
-@WorkerThread
-fun runApplicationSetupSteps(serviceManager: ServiceManager, context: Context): Boolean {
-    logger.info("Running application setup steps")
-
-    val groupService = serviceManager.groupService
-
-    // Send the feature mask to the server and update the contacts. It is important that the feature
-    // masks of the contacts are updated to check whether the contacts support FS or not.
-    if (!ContactUpdateWorker.sendFeatureMaskAndUpdateContacts(serviceManager, context)) {
-        logger.warn("Aborting application setup steps as identity state update did not work")
-        return false
-    }
-
-    // Get all groups where the user is a member (or creator). Only include groups that are not
-    // deleted.
-    val groups = groupService.all.filter { !it.isDeleted && groupService.isGroupMember(it) }
-
-    // Find group contacts of groups that are not left
-    val groupContacts = groups.flatMap { groupService.getMembers(it) }.toSet()
-
-    // Find valid contacts with defined last-update flag
-    val contactsWithConversation = serviceManager.contactService.all
-        .filter { it.lastUpdate != null }
-        .toSet()
-
-    val myIdentity = serviceManager.contactService.me.identity
-
-    // Determine the solicited contacts defined by group contacts and conversation contacts and
-    // remove invalid contacts
-    val solicitedContacts = (groupContacts + contactsWithConversation)
-        .filter { it.state != ContactModel.State.INVALID }
-        .filter { it.identity != myIdentity }
-        .toSet()
-
-    // If forward security is supported, run the FS Refresh Steps
-    // TODO(ANDR-2519): Remove the check when md allows fs (but keep running the FS Refresh Steps)
-    if (serviceManager.multiDeviceManager.isMdDisabledOrSupportsFs) {
-        serviceManager.taskManager.schedule(FSRefreshStepsTask(solicitedContacts, serviceManager))
-    }
-
-    // Send a contact-request-profile-picture message to each solicited contact
-    solicitedContacts.forEach {
-        serviceManager.taskManager.schedule(
-            OutgoingContactRequestProfilePictureTask(
-                it.identity,
-                serviceManager
-            )
-        )
-    }
-
-    // Send a group sync or group sync request for groups where the user is the creator or a member
-    groups.forEach { group ->
-        if (groupService.isGroupCreator(group)) {
-            groupService.scheduleSync(group)
-        } else if (groupService.isGroupMember(group)) {
-            groupService.scheduleSyncRequest(group.creatorIdentity, group.apiGroupId)
-        }
-    }
-
-    logger.info("Application setup steps completed successfully")
-
-    return true
-}
diff --git a/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java b/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java
index ea22bc7b..572cf55b 100644
--- a/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java
+++ b/app/src/main/java/ch/threema/app/receivers/ActionBroadcastReceiver.java
@@ -25,6 +25,7 @@ import android.content.BroadcastReceiver;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.services.ContactService;
@@ -34,7 +35,10 @@ import ch.threema.app.services.LifetimeService;
 import ch.threema.app.services.MessageService;
 import ch.threema.app.services.notification.NotificationService;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 
 public abstract class ActionBroadcastReceiver extends BroadcastReceiver {
 	protected static final String TAG = "ActionBroadcastReceiver";
@@ -48,6 +52,11 @@ public abstract class ActionBroadcastReceiver extends BroadcastReceiver {
 	protected ContactService contactService;
 	protected DistributionListService distributionListService;
 	protected GroupService groupService;
+	protected ContactModelRepository contactModelRepository;
+	protected APIConnector apiConnector;
+
+	@NonNull
+	protected BackgroundExecutor backgroundExecutor = new BackgroundExecutor();
 
 	public ActionBroadcastReceiver() {
 		this.instantiate();
@@ -81,6 +90,8 @@ public abstract class ActionBroadcastReceiver extends BroadcastReceiver {
 				this.contactService = serviceManager.getContactService();
 				this.distributionListService = serviceManager.getDistributionListService();
 				this.groupService = serviceManager.getGroupService();
+				this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+				this.apiConnector = serviceManager.getAPIConnector();
 			} catch (Exception e) {
 				logger.error("Exception", e);
 			}
diff --git a/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java b/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java
index 599345a8..08edf45e 100644
--- a/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java
+++ b/app/src/main/java/ch/threema/app/receivers/SendTextToContactBroadcastReceiver.java
@@ -24,14 +24,19 @@ package ch.threema.app.receivers;
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.Intent;
-import android.os.AsyncTask;
 import android.widget.Toast;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import androidx.core.app.NotificationManagerCompat;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.AddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.Failed;
+import ch.threema.app.asynctasks.PolicyViolation;
 import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.notifications.BackgroundErrorNotification;
 import ch.threema.base.utils.LoggingUtil;
@@ -58,40 +63,65 @@ public class SendTextToContactBroadcastReceiver extends ActionBroadcastReceiver
 
 			final PendingResult pendingResult = goAsync();
 
-			new AsyncTask<Void, Void, Boolean>() {
+			String identity = intent.getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
+			if (identity == null) {
+				logger.error("Identity is null");
+				return;
+			}
+
+			AddOrUpdateContactBackgroundTask<Boolean> sendMessageTask = new AddOrUpdateContactBackgroundTask<>(
+				identity,
+				ContactModel.AcquaintanceLevel.DIRECT,
+				contactService.getMe().getIdentity(),
+				apiConnector,
+				contactModelRepository,
+				AddContactRestrictionPolicy.CHECK,
+				context,
+				null
+			) {
 				@Override
-				protected Boolean doInBackground(Void... params) {
-					try {
-						// we need to make sure there's a connection during delivery
-						lifetimeService.acquireConnection(TAG);
+				public void onBefore() {
+					// We need to make sure there's a connection during delivery
+					lifetimeService.acquireConnection(TAG);
+				}
 
-						String identity = intent.getStringExtra(ThreemaApplication.INTENT_DATA_CONTACT);
-						if (identity != null) {
-							final ContactModel contactModel = contactService.getOrCreateByIdentity(identity, true);
-							MessageReceiver messageReceiver = contactService.createReceiver(contactModel);
-							if (messageReceiver != null) {
-								messageService.sendText(text, messageReceiver);
-								messageService.markConversationAsRead(messageReceiver, notificationService);
-								logger.debug("Message sent to: " + messageReceiver.getShortName());
-								return true;
-							}
+				@Override
+				@NonNull
+				public Boolean onContactAdded(@NonNull ContactResult result) {
+					if (result instanceof Failed) {
+						logger.error("Could not add contact: {}", ((Failed) result).getMessage());
+						return false;
+					} else if (result instanceof PolicyViolation) {
+						logger.error("Could not add contact because of a policy violation");
+						return false;
+					}
+
+					try {
+						final ContactModel contactModel = contactService.getByIdentity(identity);
+						if (contactModel == null) {
+							return false;
 						}
+						MessageReceiver<?> messageReceiver = contactService.createReceiver(contactModel);
+						messageService.sendText(text, messageReceiver);
+						messageService.markConversationAsRead(messageReceiver, notificationService);
+						logger.debug("Message sent to: " + messageReceiver.getShortName());
+						return true;
 					} catch (Exception e) {
 						logger.error("Exception", e);
+						return false;
 					} finally {
 						lifetimeService.releaseConnectionLinger(TAG, WEARABLE_CONNECTION_LINGER);
 					}
-					return false;
 				}
 
 				@Override
-				protected void onPostExecute(Boolean success) {
-					if (success != null) {
-						Toast.makeText(context, success ? R.string.message_sent : R.string.verify_failed, Toast.LENGTH_LONG).show();
-					}
+				public void onFinished(@NonNull Boolean success) {
+					Toast.makeText(context, success ? R.string.message_sent : R.string.verify_failed, Toast.LENGTH_LONG).show();
 					pendingResult.finish();
 				}
-			}.execute();
+			};
+
+			backgroundExecutor.execute(sendMessageTask);
 		}
 	}
 }
diff --git a/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java b/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java
index d1b99981..363e90de 100644
--- a/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java
+++ b/app/src/main/java/ch/threema/app/routines/SynchronizeContactsRoutine.java
@@ -29,18 +29,21 @@ import android.database.Cursor;
 import android.provider.ContactsContract;
 import android.text.format.DateUtils;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.RequiresPermission;
 
 import com.google.common.collect.ListMultimap;
 
 import org.slf4j.Logger;
 
+import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import ch.threema.app.asynctasks.AddContactBackgroundTask;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeviceService;
 import ch.threema.app.services.IdListService;
@@ -54,10 +57,18 @@ import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.models.ContactModelData;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.models.ContactSyncState;
+import ch.threema.domain.models.IdentityState;
+import ch.threema.domain.models.IdentityType;
+import ch.threema.domain.models.ReadReceiptPolicy;
+import ch.threema.domain.models.TypingIndicatorPolicy;
 import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.stores.IdentityStoreInterface;
-import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
 
 public class SynchronizeContactsRoutine implements Runnable {
@@ -67,6 +78,7 @@ public class SynchronizeContactsRoutine implements Runnable {
 	private final Context context;
 	private final APIConnector apiConnector;
 	private final ContactService contactService;
+	private final ContactModelRepository contactModelRepository;
 	private final LocaleService localeService;
 	private final ContentResolver contentResolver;
 	private final IdListService excludedSyncList;
@@ -97,23 +109,23 @@ public class SynchronizeContactsRoutine implements Runnable {
 		void started(boolean fullSync);
 	}
 
-    public SynchronizeContactsRoutine(
-        Context context,
-        APIConnector apiConnector,
-        ContactService contactService,
-        UserService userService,
-        LocaleService localeService,
-        ContentResolver contentResolver,
-        IdListService excludedSyncList,
-        DeviceService deviceService,
-        PreferenceService preferenceService,
-        IdentityStoreInterface identityStore,
-        IdListService blockedContactsService
-    ) {
+	public SynchronizeContactsRoutine(Context context,
+	                                  APIConnector apiConnector,
+	                                  ContactService contactService,
+									  @NonNull ContactModelRepository contactModelRepository,
+	                                  UserService userService,
+	                                  LocaleService localeService,
+	                                  ContentResolver contentResolver,
+	                                  IdListService excludedSyncList,
+	                                  DeviceService deviceService,
+	                                  PreferenceService preferenceService,
+	                                  IdentityStoreInterface identityStore,
+	                                  IdListService blockedContactsService) {
 		this.context = context;
 		this.apiConnector = apiConnector;
 		this.userService = userService;
 		this.contactService = contactService;
+		this.contactModelRepository = contactModelRepository;
 		this.localeService = localeService;
 		this.contentResolver = contentResolver;
 		this.excludedSyncList = excludedSyncList;
@@ -241,7 +253,7 @@ public class SynchronizeContactsRoutine implements Runnable {
 					continue;
 				}
 
-				if(!this.processingIdentities.isEmpty() && !this.processingIdentities.contains(id.getKey())) {
+				if (!this.processingIdentities.isEmpty() && !this.processingIdentities.contains(id.getKey())) {
 					continue;
 				}
 
@@ -265,19 +277,57 @@ public class SynchronizeContactsRoutine implements Runnable {
 				}
 
 				//try to get the contact
-				ContactModel contact = this.contactService.getByIdentity(id.getKey());
+				ContactModel contact = contactModelRepository.getByIdentity(
+					id.getKey()
+				);
+				ContactModelData data = contact != null ? contact.getData().getValue() : null;
 				//contact does not exist, create a new one
-				if (contact == null) {
-					contact = new ContactModel(id.getKey(), id.getValue().publicKey);
-					contact.verificationLevel = VerificationLevel.SERVER_VERIFIED;
-					contact.setDateCreated(new Date());
+				if (contact == null || data == null) {
+					APIConnector.MatchIdentityResult result = id.getValue();
+					ContactModelData contactModelData = ContactModelData.javaCreate(
+						id.getKey(),
+						result.publicKey,
+						new Date(),
+						"",
+						"",
+						null,
+						ContactModelData.getIdColorIndexInt(id.getKey()),
+						VerificationLevel.SERVER_VERIFIED,
+						WorkVerificationLevel.NONE,
+						IdentityType.NORMAL,   // TODO(ANDR-3044): Fetch identity type
+						AcquaintanceLevel.DIRECT,
+						IdentityState.ACTIVE,  // TODO(ANDR-3044): Fetch identity state
+						BigInteger.valueOf(0), // TODO(ANDR-3044): Fetch feature mask
+						ContactSyncState.IMPORTED,
+						ReadReceiptPolicy.DEFAULT,
+						TypingIndicatorPolicy.DEFAULT,
+						null,
+						null,
+						false,
+						null,
+                        null,
+                        null
+					);
+					contact = new AddContactBackgroundTask(contactModelData, contactModelRepository)
+						.runSynchronously();
+
+					if (contact == null) {
+						logger.error("Could not create contact with identity {}", id.getKey());
+						continue;
+					}
+
+					data = contact.getData().getValue();
+					if (data == null) {
+						logger.error("Contact data is null");
+						continue;
+					}
+
 					insertedContacts.add(contact);
 
 					isNewContact = true;
 					logger.info("Inserting new Threema contact {}", id.getKey());
 				}
-
-				contact.setAndroidContactLookupKey(lookupKey + "/" + contactId); // It can optionally also have a "/" and last known contact ID appended after that. This "complete" format is an important optimization and is highly recommended.
+				contact.setAndroidLookupKey(lookupKey + "/" + contactId);
 
 				try {
 					boolean createNewRawContact;
@@ -285,9 +335,9 @@ public class SynchronizeContactsRoutine implements Runnable {
 					AndroidContactUtil.getInstance().updateNameByAndroidContact(contact); // throws an exception if no name can be determined
 					AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contact);
 
-					contact.setAcquaintanceLevel(AcquaintanceLevel.DIRECT);
-					if (contact.verificationLevel == VerificationLevel.UNVERIFIED) {
-						contact.verificationLevel = VerificationLevel.SERVER_VERIFIED;
+					contact.setAcquaintanceLevelFromLocal(AcquaintanceLevel.DIRECT);
+					if (data.verificationLevel == VerificationLevel.UNVERIFIED) {
+						contact.setVerificationLevelFromLocal(VerificationLevel.SERVER_VERIFIED);
 					}
 
 					List<AndroidContactUtil.RawContactInfo> rawContactInfos = existingRawContacts.get(contact.getIdentity());
@@ -313,7 +363,7 @@ public class SynchronizeContactsRoutine implements Runnable {
 					}
 
 					if (createNewRawContact) {
-						boolean supportsVoiceCalls = ContactUtil.canReceiveVoipMessages(contact, this.blockedContactsService)
+						boolean supportsVoiceCalls = ContactUtil.canReceiveVoipMessages(contact.getIdentity(), this.blockedContactsService)
 							&& ConfigUtils.isCallsEnabled();
 
 						// create a raw contact for our stuff and aggregate it
@@ -322,19 +372,14 @@ public class SynchronizeContactsRoutine implements Runnable {
 							matchKeyEmail != null ?
 								matchKeyEmail.rawContactId :
 								matchKeyPhone.rawContactId,
-							contact,
+							contact.getIdentity(),
 							supportsVoiceCalls);
 					}
-
-					this.contactService.save(contact);
 				} catch (ThreemaException e) {
 					if (isNewContact) {
 						// probably not a valid contact
 						insertedContacts.remove(contact);
 						logger.info("Ignore Threema contact {} due to missing name", id.getKey());
-					} else {
-						// save the contact only if it was updated
-						this.contactService.save(contact);
 					}
 					logger.error("Contact lookup Exception", e);
 				}
@@ -361,14 +406,12 @@ public class SynchronizeContactsRoutine implements Runnable {
 				if (!preSynchronizedIdentities.isEmpty()) {
 					logger.info("Found {} synchronized contacts that are no longer synchronized", preSynchronizedIdentities.size());
 
-					List<ContactModel> contactModels = this.contactService.getByIdentities(preSynchronizedIdentities);
-					this.contactService.save(
-						contactModels,
-						contactModel -> {
-							contactModel.setAndroidContactLookupKey(null);
-							return true;
+					for (String identity : preSynchronizedIdentities) {
+						ContactModel contactModel = contactModelRepository.getByIdentity(identity);
+						if (contactModel != null) {
+							contactModel.removeAndroidContactLink();
 						}
-					);
+					}
 				}
 			}
 			success = true;
diff --git a/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java b/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java
index 1521b289..74d58564 100644
--- a/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java
+++ b/app/src/main/java/ch/threema/app/routines/UpdateBusinessAvatarRoutine.java
@@ -45,6 +45,7 @@ import ch.threema.app.utils.FileUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModel;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.domain.taskmanager.TriggerSource;
 
 import static android.provider.MediaStore.MEDIA_IGNORE_FILENAME;
 
@@ -120,14 +121,16 @@ public class UpdateBusinessAvatarRoutine implements Runnable {
 				if (responseCode != HttpsURLConnection.HTTP_OK) {
 					if (responseCode == HttpsURLConnection.HTTP_NOT_FOUND) {
 						logger.debug("Avatar not found");
-						//remove existing avatar
-						this.fileService.removeContactAvatar(contactModel.getIdentity());
+						// Remove existing avatar
+                        // Note that the profile picture of a gateway id is stored as user defined
+                        // profile picture on purpose. This prevents that it is overwritten if the
+                        // gateway would suddenly start distributing its own profile picture via csp
+                        // messages.
+						this.fileService.removeUserDefinedProfilePicture(contactModel.getIdentity());
 
 						//ok, no avatar set
 						//add expires date = now + 1day
 						this.contactModel.setLocalAvatarExpires(tomorrow);
-
-						this.contactService.clearAvatarCache(contactModel.getIdentity());
 					} else if (responseCode == HttpsURLConnection.HTTP_UNAUTHORIZED) {
 						 logger.warn("Unauthorized access to avatar server");
 						 if (ConfigUtils.isOnPremBuild()) {
@@ -163,12 +166,15 @@ public class UpdateBusinessAvatarRoutine implements Runnable {
 
 						logger.debug("Avatar downloaded");
 
-						//define avatar
-						this.contactService.setAvatar(contactModel.getIdentity(), temporaryFile);
+						// Store profile picture
+                        // Note that the profile picture of a gateway id is stored as user defined
+                        // profile picture on purpose. This prevents that it is overwritten if the
+                        // gateway would suddenly start distributing its own profile picture via csp
+                        // messages.
+						this.contactService.setUserDefinedProfilePicture(contactModel.getIdentity(), temporaryFile, TriggerSource.LOCAL);
 
 						//set expires header
 						this.contactModel.setLocalAvatarExpires(expires);
-						this.contactService.clearAvatarCache(contactModel.getIdentity());
 
 						//remove temporary file
 						FileUtil.deleteFileOrWarn(temporaryFile, "temporaryFile", logger);
diff --git a/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java b/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java
index cf63500d..20338175 100644
--- a/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java
+++ b/app/src/main/java/ch/threema/app/routines/UpdateFeatureLevelRoutine.java
@@ -23,85 +23,60 @@ package ch.threema.app.routines;
 
 import org.slf4j.Logger;
 
-import java.util.ArrayList;
 import java.util.Calendar;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Collectors;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
-import ch.threema.app.collections.Functional;
-import ch.threema.app.collections.IPredicateNonNull;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.utils.TestUtil;
+import ch.threema.app.services.UserService;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ModelDeletedException;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.api.APIConnector;
-import ch.threema.storage.models.ContactModel;
+import ch.threema.data.models.ContactModel;
 
 public class UpdateFeatureLevelRoutine implements Runnable {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("UpdateFeatureLevelRoutine");
 
 	private static final Map<String, Long> checkedIdentities = new HashMap<>();
 
-	public static void removeTimeCache(String identity) {
+	public static void removeTimeCache(@Nullable String identity) {
 		synchronized (checkedIdentities) {
 			checkedIdentities.remove(identity);
 		}
 	}
 
-	public static void removeTimeCache(ContactModel contactModel) {
-		if (contactModel != null) {
-			removeTimeCache(contactModel.getIdentity());
-		}
-	}
-	public interface StatusResult {
-		void onFinished(List<ContactModel> handledContacts);
-		void onAbort();
-		void onError(Exception x);
-	}
-
-	public interface Request {
-		boolean requestToServer(long featureLevel);
-	}
-
-	private final ContactService contactService;
+	@NonNull
+	private final UserService userService;
+	@NonNull
 	private final APIConnector apiConnector;
-	private String[] identities = null;
-	private List<ContactModel> contactModels = null;
-	private Request request = null;
-	private final List<StatusResult> statusResults = new ArrayList<StatusResult>();
-	private boolean abortOnCheckIdentitiesFailed = true;
-
-	public UpdateFeatureLevelRoutine(@NonNull ContactService contactService,
-									 @NonNull APIConnector apiConnector,
-									 String[] identities,
-									 Request request) {
-		this.contactService = contactService;
+	@NonNull
+	private List<ContactModel> contactModels;
+
+	public UpdateFeatureLevelRoutine(
+		@NonNull ContactModelRepository contactModelRepository,
+		@NonNull UserService userService,
+		@NonNull APIConnector apiConnector,
+		@Nullable List<String> identities
+	) {
+		this.userService = userService;
 		this.apiConnector = apiConnector;
-		this.identities = identities;
-		this.request = request;
-	}
-
-
-	public UpdateFeatureLevelRoutine(@NonNull ContactService contactService,
-									 @NonNull APIConnector apiConnector,
-									 @Nullable List<ContactModel> contactModels) {
-		this.contactService = contactService;
-		this.apiConnector = apiConnector;
-		this.contactModels = contactModels;
-	}
-
-	public UpdateFeatureLevelRoutine abortOnCheckIdentitiesFailed(boolean abort) {
-		this.abortOnCheckIdentitiesFailed = abort;
-		return this;
-	}
-
-	public UpdateFeatureLevelRoutine addStatusResult(StatusResult result) {
-		this.statusResults.add(result);
-		return this;
+		if (identities != null) {
+			this.contactModels = identities
+				.stream()
+				.map(contactModelRepository::getByIdentity)
+				.filter(Objects::nonNull)
+				.collect(Collectors.toList());
+		} else {
+			contactModels = Collections.emptyList();
+		}
 	}
 
 	@Override
@@ -110,28 +85,10 @@ public class UpdateFeatureLevelRoutine implements Runnable {
 		logger.info("Running...");
 
 		try {
-			//get all identities
-			if(this.contactModels == null) {
-				if(this.request != null ) {
-					this.contactModels = Functional.filter(this.contactService.getByIdentities(this.identities), new IPredicateNonNull<ContactModel>() {
-						@Override
-						public boolean apply(@NonNull ContactModel type) {
-							return request.requestToServer(type.getFeatureMask());
-						}
-					});
-				}
-				else {
-					this.contactModels = this.contactService.getByIdentities(identities);
-				}
-			}
-
 			//remove "me" from list
-			this.contactModels = Functional.filter(this.contactModels, new IPredicateNonNull<ContactModel>() {
-				@Override
-				public boolean apply(@NonNull ContactModel c) {
-					return !TestUtil.compare(c, contactService.getMe());
-				}
-			});
+			this.contactModels = this.contactModels.stream()
+				.filter(c -> !userService.getIdentity().equals(c.getIdentity()))
+				.collect(Collectors.toList());
 
 			//remove already checked identities
 			final Calendar calendar = Calendar.getInstance();
@@ -142,22 +99,17 @@ public class UpdateFeatureLevelRoutine implements Runnable {
 			final long validTimestamp = calendar.getTimeInMillis();
 
 			synchronized (checkedIdentities) {
-				//leave only identities that have not been checked in the last hour
-
-				List<ContactModel> filteredList = Functional.filter(this.contactModels, new IPredicateNonNull<ContactModel>() {
-					@Override
-					public boolean apply(@NonNull ContactModel contactModel) {
-						if(checkedIdentities.containsKey(contactModel.getIdentity())
-								&& checkedIdentities.get(contactModel.getIdentity()) >= validTimestamp) {
-							return false;
+				// Leave only identities that have not been checked in the last hour
+				List<ContactModel> filteredList = this.contactModels.stream()
+					.filter(contactModel -> {
+							Long checkedAt = checkedIdentities.get(contactModel.getIdentity());
+							return checkedAt == null || checkedAt < validTimestamp;
 						}
-						return true;
-					}
-				});
+					).collect(Collectors.toList());
 
 				logger.info("Running for {} entries", filteredList.size());
 
-				if(filteredList.size() > 0) {
+				if (!filteredList.isEmpty()) {
 					String[] identities = new String[filteredList.size()];
 
 					for (int n = 0; n < filteredList.size(); n++) {
@@ -175,43 +127,21 @@ public class UpdateFeatureLevelRoutine implements Runnable {
 							}
 
 							ContactModel model = filteredList.get(n);
-							if (model != null && model.getFeatureMask() != featureMask) {
-								final String identity = model.getIdentity();
-
-								model.setFeatureMask(featureMask);
-								this.contactService.save(model);
-
-								//update checked identities cache
-								checkedIdentities.put(identity, nowTimestamp);
-							}
+							model.setFeatureMaskFromLocal(featureMask);
+							// Update checked identities cache
+							checkedIdentities.put(model.getIdentity(), nowTimestamp);
 						}
+					} catch (ModelDeletedException e) {
+						logger.warn("Model has been deleted", e);
 					} catch (Exception x) {
-						//connection error
-						if(this.abortOnCheckIdentitiesFailed) {
-							for (StatusResult result : statusResults) {
-								result.onAbort();
-							}
-						}
+						// Connection error
 						logger.error("Error while setting feature mask", x);
 					}
-
-					for (StatusResult result : statusResults) {
-						result.onFinished(this.contactModels);
-					}
-				}
-				else {
-					for (StatusResult result : statusResults) {
-						result.onFinished(this.contactModels);
-					}
 				}
 			}
 
 		} catch (Exception e) {
 			logger.error("Error in run()", e);
-
-			for(StatusResult result: statusResults) {
-				result.onError(e);
-			}
 		}
 
 		logger.info("Done");
diff --git a/app/src/main/java/ch/threema/app/services/ApiService.java b/app/src/main/java/ch/threema/app/services/ApiService.java
deleted file mode 100644
index 1f8f3533..00000000
--- a/app/src/main/java/ch/threema/app/services/ApiService.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services;
-
-import java.io.IOException;
-
-import javax.net.ssl.HttpsURLConnection;
-
-import ch.threema.base.ThreemaException;
-import ch.threema.domain.protocol.blob.BlobLoader;
-import ch.threema.domain.protocol.blob.BlobUploader;
-
-public interface ApiService {
-	BlobUploader createUploader(byte[] data) throws ThreemaException;
-	BlobLoader createLoader(byte[] blobId);
-	String getAuthToken() throws ThreemaException;
-
-	/**
-	 * Invalidate the auth token (only used for onprem). This forces a new fetch of the auth token
-	 * the next time the token is obtained with {@link #getAuthToken()}.
-	 */
-	void invalidateAuthToken();
-	HttpsURLConnection createAvatarURLConnection(String identity) throws ThreemaException, IOException;
-}
diff --git a/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java b/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java
index 58e62690..40916cde 100644
--- a/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ApiServiceImpl.java
@@ -28,70 +28,132 @@ import java.net.URL;
 
 import javax.net.ssl.HttpsURLConnection;
 
+import androidx.annotation.NonNull;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.models.AppVersion;
 import ch.threema.domain.protocol.ServerAddressProvider;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.blob.BlobLoader;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.blob.BlobUploader;
-import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.domain.stores.TokenStoreInterface;
+import okhttp3.OkHttpClient;
 
 public class ApiServiceImpl implements ApiService {
-	private final AppVersion appVersion;
-	private final boolean ipv6;
-	private final APIConnector apiConnector;
-	private final TokenStoreInterface authTokenStore;
-	private final ServerAddressProvider serverAddressProvider;
+    private final AppVersion appVersion;
+    private final boolean useIpv6;
+    private final APIConnector apiConnector;
+    private final TokenStoreInterface authTokenStore;
+    private final ServerAddressProvider serverAddressProvider;
+    private final MultiDeviceManager multiDeviceManager;
+    private final OkHttpClient baseOkHttpClient;
 
-	public ApiServiceImpl(AppVersion appVersion, boolean ipv6, APIConnector apiConnector, TokenStoreInterface authTokenStore, ServerAddressProvider serverAddressProvider) {
-		this.appVersion = appVersion;
-		this.ipv6 = ipv6;
-		this.apiConnector = apiConnector;
-		this.authTokenStore = authTokenStore;
-		this.serverAddressProvider = serverAddressProvider;
-	}
+    public ApiServiceImpl(
+        AppVersion appVersion,
+        boolean useIpv6,
+        APIConnector apiConnector,
+        TokenStoreInterface authTokenStore,
+        ServerAddressProvider serverAddressProvider,
+        MultiDeviceManager multiDeviceManager,
+        OkHttpClient baseOkHttpClient
+    ) {
+        this.appVersion = appVersion;
+        this.useIpv6 = useIpv6;
+        this.apiConnector = apiConnector;
+        this.authTokenStore = authTokenStore;
+        this.serverAddressProvider = serverAddressProvider;
+        this.multiDeviceManager = multiDeviceManager;
+        this.baseOkHttpClient = baseOkHttpClient;
+    }
 
-	@Override
-	public BlobUploader createUploader(byte[] data) throws ThreemaException {
-		BlobUploader uploader = new BlobUploader(ConfigUtils::getSSLSocketFactory, data, ipv6, serverAddressProvider, null);
-		uploader.setVersion(this.appVersion);
-		if (ConfigUtils.isOnPremBuild()) {
-			uploader.setAuthToken(getAuthToken());
-		}
-		return uploader;
-	}
+    @NonNull
+    @Override
+    public BlobUploader createUploader(
+        @NonNull byte[] blobData,
+        boolean shouldPersist,
+        @NonNull BlobScope blobScope
+    ) throws ThreemaException {
+        final BlobUploader blobUploader;
+        if (multiDeviceManager.isMultiDeviceActive()) {
+            blobUploader = BlobUploader.mirror(
+                baseOkHttpClient,
+                ConfigUtils.isOnPremBuild() ? getAuthToken() : null,
+                blobData,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                multiDeviceManager.getPropertiesProvider(),
+                blobScope
+            );
+        } else {
+            blobUploader = BlobUploader.usual(
+                baseOkHttpClient,
+                ConfigUtils.isOnPremBuild() ? getAuthToken() : null,
+                blobData,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                useIpv6,
+                shouldPersist
+            );
+        }
+        return blobUploader;
+    }
 
-	@Override
-	public BlobLoader createLoader(byte[] blobId) {
-		BlobLoader loader = new BlobLoader(ConfigUtils::getSSLSocketFactory, blobId, ipv6, serverAddressProvider, null);
-		loader.setVersion(this.appVersion);
-		return loader;
-	}
+    @NonNull
+    @Override
+    public BlobLoader createLoader(@NonNull byte[] blobId) {
+        BlobLoader loader;
+        if (multiDeviceManager.isMultiDeviceActive()) {
+            loader = BlobLoader.mirror(
+                baseOkHttpClient,
+                blobId,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                multiDeviceManager.getPropertiesProvider()
+            );
+        } else {
+            loader = BlobLoader.usual(
+                baseOkHttpClient,
+                blobId,
+                appVersion,
+                ConfigUtils.isDevBuild(),
+                serverAddressProvider,
+                null,
+                useIpv6
+            );
+        }
+        return loader;
+    }
 
-	@Override
-	public String getAuthToken() throws ThreemaException {
-		try {
-			return apiConnector.obtainAuthToken(authTokenStore, false);
-		} catch (IOException | JSONException e) {
-			throw new ThreemaException("Cannot obtain authentication token", e);
-		}
-	}
+    @Override
+    public String getAuthToken() throws ThreemaException {
+        try {
+            return apiConnector.obtainAuthToken(authTokenStore, false);
+        } catch (IOException | JSONException e) {
+            throw new ThreemaException("Cannot obtain authentication token", e);
+        }
+    }
 
-	@Override
-	public void invalidateAuthToken() {
-		this.authTokenStore.storeToken(null);
-	}
+    @Override
+    public void invalidateAuthToken() {
+        this.authTokenStore.storeToken(null);
+    }
 
-	@Override
-	public HttpsURLConnection createAvatarURLConnection(String identity) throws ThreemaException, IOException {
-		URL url = new URL(serverAddressProvider.getAvatarServerUrl(false) + identity);
-		HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
-		connection.setSSLSocketFactory(ConfigUtils.getSSLSocketFactory(url.getHost()));
-		if (ConfigUtils.isOnPremBuild()) {
-			connection.setRequestProperty("Authorization", "Token " + getAuthToken());
-		}
-		return connection;
-	}
+    @Override
+    public HttpsURLConnection createAvatarURLConnection(String identity) throws ThreemaException, IOException {
+        URL url = new URL(serverAddressProvider.getAvatarServerUrl(false) + identity);
+        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
+        connection.setSSLSocketFactory(ConfigUtils.getSSLSocketFactory(url.getHost()));
+        if (ConfigUtils.isOnPremBuild()) {
+            connection.setRequestProperty("Authorization", "Token " + getAuthToken());
+        }
+        return connection;
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/AvatarCacheService.java b/app/src/main/java/ch/threema/app/services/AvatarCacheService.java
index a19feba2..5b08c6a5 100644
--- a/app/src/main/java/ch/threema/app/services/AvatarCacheService.java
+++ b/app/src/main/java/ch/threema/app/services/AvatarCacheService.java
@@ -137,7 +137,13 @@ public interface AvatarCacheService {
 	@AnyThread
 	void reset(@NonNull ContactModel contactModel);
 
-	/**
+    /**
+     * Clears the cache of the contact with the given identity.
+     */
+    @AnyThread
+    void reset(@NonNull String identity);
+
+    /**
 	 * Clears the cache of the given group model.
 	 */
 	@AnyThread
diff --git a/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java b/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java
index 11d3b48b..a9bd4bbd 100644
--- a/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/AvatarCacheServiceImpl.java
@@ -169,12 +169,17 @@ final public class AvatarCacheServiceImpl implements AvatarCacheService {
 	@AnyThread
 	@Override
 	public void reset(@NonNull ContactModel contactModel) {
-		synchronized (this.contactAvatarStates) {
-			this.contactAvatarStates.put(contactModel.getIdentity(), System.currentTimeMillis());
-		}
+        reset(contactModel.getIdentity());
 	}
 
-	@AnyThread
+    @Override
+    public void reset(@NonNull String identity) {
+        synchronized (this.contactAvatarStates) {
+            this.contactAvatarStates.put(identity, System.currentTimeMillis());
+        }
+    }
+
+    @AnyThread
 	@Override
 	public void reset(@NonNull GroupModel groupModel) {
 		synchronized (this.groupAvatarStates) {
diff --git a/app/src/main/java/ch/threema/app/services/AvatarService.java b/app/src/main/java/ch/threema/app/services/AvatarService.java
index 0bd2ba90..bcae54c9 100644
--- a/app/src/main/java/ch/threema/app/services/AvatarService.java
+++ b/app/src/main/java/ch/threema/app/services/AvatarService.java
@@ -145,11 +145,6 @@ public interface AvatarService<M extends ReceiverModel> {
 		return getAvatar(null, options != null ? options : AvatarOptions.PRESET_DEFAULT_AVATAR_NO_CACHE);
 	}
 
-	/**
-	 * Delete the cache of the given model
-	 */
-	void clearAvatarCache(@NonNull M model);
-
 	/**
 	 * Get the color of the avatar. This method considers the "isDefaultContactPictureColored" setting.
 	 *
diff --git a/app/src/main/java/ch/threema/app/services/ContactService.java b/app/src/main/java/ch/threema/app/services/ContactService.java
index 8d194f07..e9db6517 100644
--- a/app/src/main/java/ch/threema/app/services/ContactService.java
+++ b/app/src/main/java/ch/threema/app/services/ContactService.java
@@ -21,35 +21,29 @@
 
 package ch.threema.app.services;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.WorkerThread;
-
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
 
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.data.models.ContactModelData;
 import ch.threema.domain.fs.DHSession;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.api.APIConnector;
-import ch.threema.domain.protocol.api.work.WorkContact;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 import ch.threema.domain.taskmanager.ActiveTaskCodec;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.access.AccessModel;
 import java8.util.function.Consumer;
 
 public interface ContactService extends AvatarService<ContactModel> {
 
-	int ContactVerificationResult_NO_MATCH = 0;
-	int ContactVerificationResult_ALREADY_VERIFIED = 1;
-	int ContactVerificationResult_VERIFIED = 2;
-
 	String ALL_USERS_PLACEHOLDER_ID = "@@@@@@@@";
 
     interface ContactProcessor {
@@ -65,10 +59,31 @@ public interface ContactService extends AvatarService<ContactModel> {
 	}
 
 	class ProfilePictureSharePolicy {
-		public enum Policy { NOBODY, EVERYONE, SOME }
+
+        // Do NOT change the order of these values, as features rely on the `ordinal` value to stay the same
+		public enum Policy {
+            NOBODY,
+            EVERYONE,
+            ALLOW_LIST;
+
+            @Nullable
+            public static Policy fromIntOrNull(final int value) {
+                switch (value) {
+                    case PreferenceService.PROFILEPIC_RELEASE_NOBODY:
+                        return Policy.NOBODY;
+                    case PreferenceService.PROFILEPIC_RELEASE_EVERYONE:
+                        return Policy.EVERYONE;
+                    case PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST:
+                        return Policy.ALLOW_LIST;
+                    default:
+                        return null;
+                }
+            }
+        }
 
 		@NonNull
 		private final Policy policy;
+
 		@NonNull
 		private final List<String> allowedIdentities;
 
@@ -166,7 +181,7 @@ public interface ContactService extends AvatarService<ContactModel> {
 		/**
 		 * States filter
 		 */
-		ContactModel.State[] states();
+		IdentityState[] states();
 
 		/**
 		 * @return feature int
@@ -197,6 +212,7 @@ public interface ContactService extends AvatarService<ContactModel> {
 		Boolean onlyWithReceiptSettings();
 	}
 
+	@NonNull
 	ContactModel getMe();
 
 	/**
@@ -260,14 +276,6 @@ public interface ContactService extends AvatarService<ContactModel> {
 	@Nullable
 	ContactModel getByIdentity(@Nullable String identity);
 
-	/**
-	 * Return the contact model for the specified identity. If the contact does not exist yet, create it.
-	 *
-	 * @param identity The identity string
-	 * @param force Force the creation of the contact, even if adding new contacts has been disabled
-	 */
-	@NonNull
-	ContactModel getOrCreateByIdentity(String identity, boolean force) throws EntryAlreadyExistsException, InvalidEntryException, PolicyViolationException;
 	List<ContactModel> getByIdentities(String[] identities);
 	List<ContactModel> getByIdentities(List<String> identities);
 
@@ -308,8 +316,16 @@ public interface ContactService extends AvatarService<ContactModel> {
 	@Nullable
 	ContactModel getByPublicKey(byte[] publicKey);
 
-	void setIsHidden(String identity, boolean hidden);
-	boolean getIsHidden(String identity);
+	/**
+	 * Update the acquaintance level of the given identity if it exists as a contact.
+	 *
+	 * @param identity the identity of the contact
+	 * @param acquaintanceLevel the new acquaintance level
+	 */
+	void setAcquaintanceLevel(
+		@NonNull String identity,
+		@NonNull ContactModel.AcquaintanceLevel acquaintanceLevel
+	);
 
 	void setIsArchived(String identity, boolean archived);
 
@@ -329,16 +345,17 @@ public interface ContactService extends AvatarService<ContactModel> {
 	 */
 	void clearLastUpdate(@NonNull String identity);
 
+    /**
+     * Save the given contact model.
+     *
+     * @deprecated This method should not be used anymore as it may override the database with old
+     * data from the model. To perform changes on a contact, the contact model repository should be
+     * used.
+     */
+    @Deprecated
 	void save(@NonNull ContactModel model);
 
-	/**
-	 * save contacts after processing and returning true
-	 */
-	int save(List<ContactModel> contactModels, ContactProcessor contactProcessor);
-
-	boolean remove(ContactModel model);
-	boolean remove(ContactModel model, boolean removeLink);
-	AccessModel getAccess(ContactModel model);
+	AccessModel getAccess(@Nullable String identity);
 
 	void setIsTyping(String identity, boolean isTyping) ;
 	boolean isTyping(String identity);
@@ -351,106 +368,91 @@ public interface ContactService extends AvatarService<ContactModel> {
 	 */
 	void sendTypingIndicator(String toIdentity, boolean isTyping);
 
-	void setActive(@Nullable String identity);
-
-	int updateContactVerification(String identity, byte[] publicKey);
-
-	/**
-	 * Create a contact with the specified identity.
-	 *
-	 * @param identity The identity string
-	 * @param force Force the creation of the contact, even if adding new contacts has been disabled
-	 */
-	@NonNull
-	ContactModel createContactByIdentity(@NonNull String identity, boolean force) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException;
-
-	/**
-	 * Create a contact with the specified identity.
-	 *
-	 * @param identity The identity string
-	 * @param force Force the creation of the contact, even if adding new contacts has been disabled
-	 * @param acquaintanceLevel The acquaintance level of the new contact
-	 */
-	@NonNull ContactModel createContactByIdentity(@NonNull String identity, boolean force, @NonNull ContactModel.AcquaintanceLevel acquaintanceLevel) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException;
-
-	/**
-	 * Create (optionally hidden) contacts for all provided identities. Note that contacts are also created when block
-	 * unknown is active or th_disable_add_contact is set to true.
-	 * Contacts are added with acquaintance level 'group'.
-	 * There is no contact created for an identity if
-	 *  - it is the user's identity
-	 *  - there is already a contact for that identity
-	 *  - the identity public key cannot be fetched (404)
-	 */
-	void createGroupContactsByIdentities(@NonNull List<String> identities);
-
-	VerificationLevel getInitialVerificationLevel(ContactModel contactModel);
-
-	void removeAll();
-
 	/**
 	 * Create a new message receiver for the specified contact model.
 	 */
 	@NonNull ContactMessageReceiver createReceiver(ContactModel contact);
 
 	/**
-	 * @param msg latest message with the "newest" public nickname
+	 * Create a new message receiver for the specified contact model. Note that the return value is
+	 * null, if the old contact model does not exist with the identity of the given model.
 	 */
-	void updatePublicNickName(@NonNull AbstractMessage msg);
+	@Nullable ContactMessageReceiver createReceiver(@NonNull ch.threema.data.models.ContactModel contact);
+
+    /**
+     * Create a new message receiver for the given identity. Note that the return value is null if
+     * there is no contact with the provided identity.
+     */
+    @Nullable ContactMessageReceiver createReceiver(@NonNull String identity);
 
 	boolean updateAllContactNamesFromAndroidContacts();
 
 	void removeAllSystemContactLinks();
 
-	@Deprecated
-	int getUniqueId(@Nullable ContactModel contactModel);
-	@Deprecated
-	int getUniqueId(@NonNull String identity);
-	String getUniqueIdString(ContactModel contactModel);
-
-	String getUniqueIdString(String identity);
-
-	boolean setAvatar(@Nullable ContactModel contactModel, @Nullable File temporaryAvatarFile) throws Exception;
-	boolean setAvatar(@NonNull String identity, @Nullable File temporaryAvatarFile) throws Exception;
-	boolean setAvatar(ContactModel contactModel, byte[] avatar) throws Exception;
-	boolean removeAvatar(ContactModel contactModel);
-	void clearAvatarCache(@NonNull String identity);
+    /**
+     * Set the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if storing the profile picture succeeded
+     */
+    boolean setUserDefinedProfilePicture(
+        @Nullable ContactModel contactModel,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    );
+
+    /**
+     * Set the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if storing the profile picture succeeded
+     */
+    boolean setUserDefinedProfilePicture(
+        @NonNull String identity,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    );
+
+    /**
+     * Set the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if storing the profile picture succeeded
+     * @throws IOException when the byte array cannot be written to the file
+     * @throws MasterKeyLockedException when the master key is locked
+     */
+    boolean setUserDefinedProfilePicture(
+        @Nullable ContactModel contactModel,
+        @Nullable byte[] avatar,
+        @NonNull TriggerSource triggerSource
+    ) throws IOException, MasterKeyLockedException;
+
+    /**
+     * Remove the user defined profile picture. Depending on the trigger source, the change is also
+     * reflected.
+     *
+     * @return true if the removal succeeded
+     */
+    boolean removeUserDefinedProfilePicture(
+        @Nullable ContactModel contactModel,
+        @NonNull TriggerSource triggerSource
+    );
 
 	@NonNull
 	ProfilePictureSharePolicy getProfilePictureSharePolicy();
 
 	/**
-	 * Check whether the app settings allow the profile picture to be sent to the contact. Note that
+	 * Check whether the app settings allow the profile picture to be sent to the identity. Note that
 	 * this method does <b>not</b> check whether the contact is a gateway ID or ECHOECHO.
 	 *
 	 * @return {@code true} if the profile picture could be sent, {@code false} otherwise
 	 */
-	boolean isContactAllowedToReceiveProfilePicture(@NonNull ContactModel contactModel);
-
-	/**
-	 * Upload the current profile picture if it hasn't been uploaded recently and get the most
-	 * recent contact profile picture upload data.
-	 *
-	 * @return the most recent profile picture upload data. If the upload failed or the last stored
-	 * data could not be read, the returned data contains null as blob ID. If there is no profile
-	 * picture set, the blob ID is {@link ContactModel#NO_PROFILE_PICTURE_BLOB_ID}.
-	 */
-	@NonNull
-	@WorkerThread
-	ProfilePictureUploadData getUpdatedProfilePictureUploadData();
-
-	/**
-	 * Reset the date of the last profile picture distribution date of the given contact.
-	 */
-	void resetContactPhotoSentState(@NonNull ContactModel contactModel);
-
-	ContactModel createContactModelByIdentity(String identity) throws InvalidEntryException;
+	boolean isContactAllowedToReceiveProfilePicture(@NonNull String identity);
 
 	boolean showBadge(@Nullable ContactModel contactModel);
 	boolean showBadge(@NonNull ContactModelData contactModelData);
 
 	String getAndroidContactLookupUriString(ContactModel contactModel);
-	@Nullable ContactModel addWorkContact(@NonNull WorkContact workContact, @Nullable List<ContactModel> existingWorkContacts);
 
 	/**
 	 * Remove the specified contact from the contact cache.
@@ -484,8 +486,8 @@ public interface ContactService extends AvatarService<ContactModel> {
 	void fetchAndCacheContact(@NonNull String identity) throws APIConnector.HttpConnectionException, APIConnector.NetworkException, MissingPublicKeyException;
 
 	@WorkerThread
-	boolean resetReceiptsSettings();
-	void reportSpam(@NonNull ContactModel spammerContactModel, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure);
+	void resetReceiptsSettings();
+	void reportSpam(@NonNull String identity, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure);
 
 	/**
 	 * Get the forward security state of a given contact.
diff --git a/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java b/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java
index 510e06e4..15b39bb2 100644
--- a/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ContactServiceImpl.java
@@ -41,8 +41,6 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.net.HttpURLConnection;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -51,8 +49,10 @@ import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Timer;
 import java.util.TimerTask;
+import java.util.stream.Collectors;
 
 import androidx.annotation.AnyThread;
 import androidx.annotation.ColorInt;
@@ -63,25 +63,23 @@ import androidx.annotation.WorkerThread;
 import androidx.core.content.ContextCompat;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.asynctasks.AddOrUpdateWorkIdentityBackgroundTask;
 import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.glide.AvatarOptions;
 import ch.threema.app.listeners.ContactTypingListener;
 import ch.threema.app.listeners.ProfileListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.routines.UpdateBusinessAvatarRoutine;
 import ch.threema.app.routines.UpdateFeatureLevelRoutine;
 import ch.threema.app.services.license.LicenseService;
-import ch.threema.app.services.license.UserCredentials;
 import ch.threema.app.stores.DatabaseContactStore;
 import ch.threema.app.stores.IdentityStore;
+import ch.threema.app.tasks.TaskCreator;
 import ch.threema.app.utils.AndroidContactUtil;
-import ch.threema.app.utils.AppRestrictionUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ColorUtil;
 import ch.threema.app.utils.ConfigUtils;
@@ -89,27 +87,28 @@ import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.ShortcutUtil;
 import ch.threema.app.utils.SynchronizeContactsUtil;
-import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.Base32;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.data.models.ContactModelData;
+import ch.threema.data.models.ModelDeletedException;
 import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.fs.DHSession;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
+import ch.threema.domain.models.ReadReceiptPolicy;
+import ch.threema.domain.models.TypingIndicatorPolicy;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.api.APIConnector;
-import ch.threema.domain.protocol.api.work.WorkContact;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.blob.BlobUploader;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
-import ch.threema.domain.stores.DHSessionStoreException;
-import ch.threema.domain.stores.DHSessionStoreInterface;
 import ch.threema.domain.taskmanager.ActiveTaskCodec;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.DatabaseUtil;
 import ch.threema.storage.QueryBuilder;
@@ -119,8 +118,6 @@ import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
 import ch.threema.storage.models.ValidationMessage;
 import ch.threema.storage.models.access.AccessModel;
 import java8.util.function.Consumer;
-import java8.util.stream.Collectors;
-import java8.util.stream.StreamSupport;
 
 import static ch.threema.app.glide.AvatarOptions.DefaultAvatarPolicy.CUSTOM_AVATAR;
 
@@ -128,13 +125,11 @@ public class ContactServiceImpl implements ContactService {
     private static final Logger logger = LoggingUtil.getThreemaLogger("ContactServiceImpl");
 
     private static final int TYPING_RECEIVE_TIMEOUT = (int) DateUtils.MINUTE_IN_MILLIS;
-    private static final String CONTACT_UID_PREFIX = "c-";
 
     private final Context context;
     private final AvatarCacheService avatarCacheService;
     private final DatabaseContactStore contactStore;
     private final DatabaseServiceNew databaseServiceNew;
-    private final DeviceService deviceService;
     private final UserService userService;
     private final IdentityStore identityStore;
     private final PreferenceService preferenceService;
@@ -142,14 +137,14 @@ public class ContactServiceImpl implements ContactService {
     // layer, since that data layer has caching built-in.
     private final Map<String, ContactModel> contactModelCache;
     private final IdListService blockedContactsService, profilePicRecipientsService;
-    private final DeadlineListService mutedChatsListService;
-    private final DeadlineListService hiddenChatsListService;
-    private final RingtoneService ringtoneService;
     private final FileService fileService;
     private final ApiService apiService;
-    private final WallpaperService wallpaperService;
     private final LicenseService licenseService;
     private final APIConnector apiConnector;
+    @NonNull
+    private final TaskCreator taskCreator;
+    @NonNull
+    private final MultiDeviceManager multiDeviceManager;
     private final Timer typingTimer;
     private final Map<String, TimerTask> typingTimerTasks;
 
@@ -160,20 +155,26 @@ public class ContactServiceImpl implements ContactService {
 
     private ContactModel me;
 
+    public final static byte[] THREEMA_PUBLIC_KEY = new byte[]{ // *THREEMA
+        58, 56, 101, 12, 104, 20, 53, -67, 31, -72, 73, -114, 33, 58, 41, 25,
+        -80, -109, -120, -11, -128, 58, -92, 70, 64, -32, -9, 6, 50, 106, -122, 92,
+    };
+
+    public final static byte[] SUPPORT_PUBLIC_KEY = new byte[]{ // *SUPPORT
+        15, -108, 77, 24, 50, 75, 33, 50, -58, 29, -114, 64, -81, -50, 96, -96,
+        -21, -41, 1, -69, 17, -24, -101, -23, 73, 114, -44, 34, -98, -108, 114, 42,
+    };
+
+    public final static byte[] MY_DATA_PUBLIC_KEY = new byte[]{ // *MY3DATA
+        59, 1, -123, 79, 36, 115, 110, 45, 13, 45, -61, -121, -22, -14, -64, 39,
+        60, 80, 73, 5, 33, 71, 19, 35, 105, -65, 57, 96, -48, -96, -65, 2
+    };
+
     // These are public keys of identities that will be immediately trusted (three green dots)
-    private final static byte[][] TRUSTED_PUBLIC_KEYS = {
-        new byte[]{ // *THREEMA
-            58, 56, 101, 12, 104, 20, 53, -67, 31, -72, 73, -114, 33, 58, 41, 25,
-            -80, -109, -120, -11, -128, 58, -92, 70, 64, -32, -9, 6, 50, 106, -122, 92,
-        },
-        new byte[]{ // *SUPPORT
-            15, -108, 77, 24, 50, 75, 33, 50, -58, 29, -114, 64, -81, -50, 96, -96,
-            -21, -41, 1, -69, 17, -24, -101, -23, 73, 114, -44, 34, -98, -108, 114, 42,
-        },
-        new byte[]{ // *MY3DATA
-            59, 1, -123, 79, 36, 115, 110, 45, 13, 45, -61, -121, -22, -14, -64, 39,
-            60, 80, 73, 5, 33, 71, 19, 35, 105, -65, 57, 96, -48, -96, -65, 2
-        }
+    public final static byte[][] TRUSTED_PUBLIC_KEYS = {
+        THREEMA_PUBLIC_KEY,
+        SUPPORT_PUBLIC_KEY,
+        MY_DATA_PUBLIC_KEY,
     };
 
     public ContactServiceImpl(
@@ -181,49 +182,44 @@ public class ContactServiceImpl implements ContactService {
         DatabaseContactStore contactStore,
         AvatarCacheService avatarCacheService,
         DatabaseServiceNew databaseServiceNew,
-        DeviceService deviceService,
         UserService userService,
         IdentityStore identityStore,
         PreferenceService preferenceService,
         IdListService blockedContactsService,
         IdListService profilePicRecipientsService,
-        RingtoneService ringtoneService,
-        DeadlineListService mutedChatsListService,
-        DeadlineListService hiddenChatsListService,
         FileService fileService,
         CacheService cacheService,
         ApiService apiService,
-        WallpaperService wallpaperService,
         LicenseService licenseService,
         APIConnector apiConnector,
-        @NonNull ContactModelRepository contactModelRepository
+        @NonNull ContactModelRepository contactModelRepository,
+        @NonNull TaskCreator taskCreator,
+        @NonNull MultiDeviceManager multiDeviceManager
     ) {
 
         this.context = context;
         this.avatarCacheService = avatarCacheService;
         this.contactStore = contactStore;
         this.databaseServiceNew = databaseServiceNew;
-        this.deviceService = deviceService;
         this.userService = userService;
         this.identityStore = identityStore;
         this.preferenceService = preferenceService;
         this.blockedContactsService = blockedContactsService;
         this.profilePicRecipientsService = profilePicRecipientsService;
-        this.ringtoneService = ringtoneService;
-        this.mutedChatsListService = mutedChatsListService;
-        this.hiddenChatsListService = hiddenChatsListService;
         this.fileService = fileService;
         this.apiService = apiService;
-        this.wallpaperService = wallpaperService;
         this.licenseService = licenseService;
         this.apiConnector = apiConnector;
         this.contactModelRepository = contactModelRepository;
+        this.taskCreator = taskCreator;
+        this.multiDeviceManager = multiDeviceManager;
         this.typingTimer = new Timer();
         this.typingTimerTasks = new HashMap<>();
         this.contactModelCache = cacheService.getContactModelCache();
     }
 
     @Override
+    @NonNull
     public ContactModel getMe() {
         if (this.me == null && this.userService.getIdentity() != null) {
             this.me = new ContactModel(
@@ -231,7 +227,7 @@ public class ContactServiceImpl implements ContactService {
                 this.userService.getPublicKey()
             );
             this.me.setPublicNickName(this.userService.getPublicNickname());
-            this.me.setState(ContactModel.State.ACTIVE);
+            this.me.setState(IdentityState.ACTIVE);
             this.me.setFirstName(context.getString(R.string.me_myself_and_i));
             this.me.verificationLevel = VerificationLevel.FULLY_VERIFIED;
             this.me.setFeatureMask(-1);
@@ -245,20 +241,20 @@ public class ContactServiceImpl implements ContactService {
     public List<ContactModel> getAllDisplayed(@NonNull ContactSelection contactSelection) {
         return this.find(new Filter() {
             @Override
-            public ContactModel.State[] states() {
+            public IdentityState[] states() {
                 if (preferenceService.showInactiveContacts()) {
                     switch (contactSelection) {
                         case EXCLUDE_INVALID:
-                            return new ContactModel.State[]{
-                                ContactModel.State.ACTIVE,
-                                ContactModel.State.INACTIVE,
+                            return new IdentityState[]{
+                                IdentityState.ACTIVE,
+                                IdentityState.INACTIVE,
                             };
                         case INCLUDE_INVALID:
                         default:
                             return null;
                     }
                 } else {
-                    return new ContactModel.State[]{ContactModel.State.ACTIVE};
+                    return new IdentityState[]{IdentityState.ACTIVE};
                 }
             }
 
@@ -305,12 +301,12 @@ public class ContactServiceImpl implements ContactService {
 
         List<ContactModel> result;
         if (filter != null) {
-            ContactModel.State[] filterStates = filter.states();
+            IdentityState[] filterStates = filter.states();
             if (filterStates != null && filterStates.length > 0) {
 
                 //dirty, add placeholder should be added to makePlaceholders
                 queryBuilder.appendWhere(ContactModel.COLUMN_STATE + " IN (" + DatabaseUtil.makePlaceholders(filterStates.length) + ")");
-                for (ContactModel.State s : filterStates) {
+                for (IdentityState s : filterStates) {
                     placeholders.add(s.toString());
                 }
             }
@@ -319,7 +315,7 @@ public class ContactServiceImpl implements ContactService {
                 queryBuilder.appendWhere(ContactModel.COLUMN_ACQUAINTANCE_LEVEL + "=0");
             }
 
-            if (!filter.includeMyself() && getMe() != null) {
+            if (!filter.includeMyself()) {
                 queryBuilder.appendWhere(ContactModel.COLUMN_IDENTITY + "!=?");
                 placeholders.add(getMe().getIdentity());
             }
@@ -331,14 +327,14 @@ public class ContactServiceImpl implements ContactService {
             result = contactModelFactory.convert
                 (
                     queryBuilder,
-                    placeholders.toArray(new String[placeholders.size()]),
+                    placeholders.toArray(new String[0]),
                     null
                 );
         } else {
             result = contactModelFactory.convert
                 (
                     queryBuilder,
-                    placeholders.toArray(new String[placeholders.size()]),
+                    placeholders.toArray(new String[0]),
                     null
                 );
         }
@@ -356,24 +352,26 @@ public class ContactServiceImpl implements ContactService {
             if (feature != null) {
                 if (filter.fetchMissingFeatureLevel()) {
                     //do not filtering with sql
-                    UpdateFeatureLevelRoutine routine = new UpdateFeatureLevelRoutine(this,
+                    UpdateFeatureLevelRoutine routine = new UpdateFeatureLevelRoutine(
+                        contactModelRepository,
+                        userService,
                         this.apiConnector,
-                        Functional.filter(result, new IPredicateNonNull<ContactModel>() {
-                            @Override
-                            public boolean apply(@NonNull ContactModel contactModel) {
-                                return !ThreemaFeature.hasFeature(contactModel.getFeatureMask(), feature);
-                            }
-                        }));
+                        result
+                            .stream()
+                            .filter(Objects::nonNull)
+                            .filter(model -> !ThreemaFeature.hasFeature(model.getFeatureMask(), feature))
+                            .map(Contact::getIdentity)
+                            .collect(Collectors.toList())
+                    );
                     routine.run();
                 }
 
-                // Now filter
-                result = Functional.filter(result, new IPredicateNonNull<ContactModel>() {
-                    @Override
-                    public boolean apply(@NonNull ContactModel contactModel) {
-                        return ThreemaFeature.hasFeature(contactModel.getFeatureMask(), feature);
-                    }
-                });
+                // Filter the result by the required feature
+                result = result
+                    .stream()
+                    .map(outdatedModel -> getByIdentity(outdatedModel.getIdentity()))
+                    .filter(model -> model != null && ThreemaFeature.hasFeature(model.getFeatureMask(), feature))
+                    .collect(Collectors.toList());
             }
 
         }
@@ -421,21 +419,6 @@ public class ContactServiceImpl implements ContactService {
         return this.cache(this.contactStore.getContactForIdentity(identity));
     }
 
-    /**
-     * If a contact for the specified identity exists, return the contactmodel.
-     * Otherwise, create a new contact and return the contactmodel.
-     */
-    @Override
-    @NonNull
-    public ContactModel getOrCreateByIdentity(@NonNull String identity, boolean force)
-        throws EntryAlreadyExistsException, InvalidEntryException, PolicyViolationException {
-        ContactModel contactModel = this.getByIdentity(identity);
-        if (contactModel == null) {
-            contactModel = this.createContactByIdentity(identity, force);
-        }
-        return contactModel;
-    }
-
     private ContactModel cache(ContactModel contactModel) {
         if (contactModel != null) {
             this.contactModelCache.put(contactModel.getIdentity(), contactModel);
@@ -502,11 +485,11 @@ public class ContactServiceImpl implements ContactService {
     public List<ContactModel> getCanReceiveProfilePics() {
         return Functional.filter(this.find(new Filter() {
             @Override
-            public ContactModel.State[] states() {
+            public IdentityState[] states() {
                 if (preferenceService.showInactiveContacts()) {
                     return null;
                 }
-                return new ContactModel.State[]{ContactModel.State.ACTIVE};
+                return new IdentityState[]{IdentityState.ACTIVE};
             }
 
             @Override
@@ -690,43 +673,22 @@ public class ContactServiceImpl implements ContactService {
     }
 
     @Override
-    public void setActive(@Nullable String identity) {
-        final ContactModel contact = this.getByIdentity(identity);
-
-        if (contact != null && contact.getState() == ContactModel.State.INACTIVE) {
-            contact.setState(ContactModel.State.ACTIVE);
-            this.save(contact);
-        }
-    }
-
-    /**
-     * Change hidden status of contact
-     *
-     * @param identity
-     * @param hide     true if we want to hide the contact, false to unhide
-     */
-    @Override
-    public void setIsHidden(String identity, boolean hide) {
-        final ContactModel contact = this.getByIdentity(identity);
+    public void setAcquaintanceLevel(
+        @NonNull String identity,
+        @NonNull AcquaintanceLevel acquaintanceLevel
+    ) {
+        final ch.threema.data.models.ContactModel contactModel =
+            contactModelRepository.getByIdentity(identity);
 
-        if (contact != null && contact.isHidden() != hide) {
-            this.removeFromCache(identity);
-            this.contactStore.hideContact(contact, hide);
+        if (contactModel != null) {
+            try {
+                contactModel.setAcquaintanceLevelFromLocal(acquaintanceLevel);
+            } catch (ModelDeletedException e) {
+                logger.warn("Could not set acquaintance level because model has been deleted", e);
+            }
         }
     }
 
-    /**
-     * Get hidden status of contact
-     *
-     * @param identity
-     * @return true if contact is hidden from contact list, false otherwise
-     */
-    @Override
-    public boolean getIsHidden(String identity) {
-        final ContactModel contact = this.getByIdentity(identity);
-        return (contact != null && contact.isHidden());
-    }
-
     @Override
     public void setIsArchived(String identity, boolean archived) {
         final ContactModel contact = this.getByIdentity(identity);
@@ -741,8 +703,10 @@ public class ContactServiceImpl implements ContactService {
         logger.info("Bump last update for contact with identity {}", identity);
         final ContactModel contact = this.getByIdentity(identity);
         if (contact != null) {
-            contact.setLastUpdate(new Date());
-            save(contact); // listeners will be fired by save()
+            Date lastUpdate = new Date();
+            contact.setLastUpdate(lastUpdate);
+            databaseServiceNew.getContactModelFactory().setLastUpdate(identity, lastUpdate);
+            ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
         } else {
             logger.warn(
                 "Could not bump last update because the contact with identity {} is null",
@@ -756,104 +720,27 @@ public class ContactServiceImpl implements ContactService {
         final ContactModel contact = this.getByIdentity(identity);
         if (contact != null) {
             contact.setLastUpdate(null);
-            save(contact); // listeners will be fired by save()
+            databaseServiceNew.getContactModelFactory().setLastUpdate(identity, null);
+            ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
         }
     }
 
     @Override
+    @Deprecated
     public void save(@NonNull ContactModel contactModel) {
-        this.contactStore.addContact(contactModel);
-    }
+        logger.info("Saving old contact model of contact {}", contactModel.getIdentity());
 
-    @Override
-    public int save(List<ContactModel> contactModels, ContactProcessor contactProcessor) {
-        int savedModels = 0;
-        if (TestUtil.required(contactModels, contactProcessor)) {
-            for (ContactModel contactModel : contactModels) {
-                if (contactProcessor.process(contactModel)) {
-                    this.save(contactModel);
-                    savedModels++;
-                }
-            }
+        for (StackTraceElement stackTraceElement : Thread.currentThread().getStackTrace()) {
+            logger.info("{}", stackTraceElement);
         }
-        return savedModels;
-    }
 
-    @Override
-    public boolean remove(ContactModel model) {
-        return this.remove(model, true);
-    }
-
-    @Override
-    public boolean remove(@NonNull ContactModel model, boolean removeLink) {
-        String uniqueIdString = getUniqueIdString(model);
-
-        clearAvatarCache(model);
-
-        // Remove draft of this contact
-        ContactMessageReceiver receiver = createReceiver(model);
-        ThreemaApplication.putMessageDraft(receiver.getUniqueIdString(), null, null);
-
-        AccessModel access = this.getAccess(model);
-        if (access.canDelete()) {
-            // remove
-            this.contactStore.removeContact(model);
-
-            this.removeFromCache(model.getIdentity());
-
-            this.ringtoneService.removeCustomRingtone(uniqueIdString);
-            this.mutedChatsListService.remove(uniqueIdString);
-            this.hiddenChatsListService.remove(uniqueIdString);
-            this.profilePicRecipientsService.remove(model.getIdentity());
-            this.wallpaperService.removeWallpaper(uniqueIdString);
-            this.fileService.removeAndroidContactAvatar(model.getIdentity());
-            ShortcutUtil.deleteShareTargetShortcut(uniqueIdString);
-            ShortcutUtil.deletePinnedShortcut(uniqueIdString);
-
-            removeDHSessions(model.getIdentity());
-        } else {
-            // Hide contact
-            setIsHidden(model.getIdentity(), true);
-        }
-
-        deleteConversation(model);
-
-        if (removeLink) {
-            AndroidContactUtil.getInstance().deleteThreemaRawContact(model);
-        }
-
-        return true;
-    }
-
-    private void deleteConversation(@NonNull ContactModel contactModel) {
-        // Delete the conversation with the contact
-        try {
-            ConversationService conversationService = ThreemaApplication.getServiceManager().getConversationService();
-            conversationService.delete(contactModel);
-        } catch (Exception e) {
-            logger.error("Exception", e);
-        }
-    }
-
-    private void removeDHSessions(@Nullable String peerIdentity) {
-        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-        String identity = userService.getIdentity();
-        if (serviceManager != null && identity != null && peerIdentity != null) {
-            try {
-                DHSessionStoreInterface dhSessionStore = serviceManager.getDHSessionStore();
-                dhSessionStore.deleteAllDHSessions(identity, peerIdentity);
-            } catch (DHSessionStoreException e) {
-                logger.error("Could not delete all DH sessions");
-            }
-        } else {
-            logger.warn("Could not delete DH sessions because the service manager or identity is null");
-        }
+        this.contactStore.addContact(contactModel);
     }
 
     @NonNull
     @Override
-    public AccessModel getAccess(ContactModel model) {
-        if (model == null) {
+    public AccessModel getAccess(@Nullable String identity) {
+        if (identity == null) {
             return new AccessModel() {
                 @Override
                 public boolean canDelete() {
@@ -872,17 +759,14 @@ public class ContactServiceImpl implements ContactService {
             };
         } else {
             boolean isInGroup = false;
-            Cursor c = this.databaseServiceNew.getReadableDatabase().rawQuery("" +
-                "SELECT COUNT(*) FROM m_group g " +
-                "INNER JOIN group_member m " +
-                "	ON m.groupId = g.id " +
-                "WHERE m.identity = ? AND deleted = 0", new String[]{
-                model.getIdentity()
-            });
+            Cursor c = this.databaseServiceNew.getReadableDatabase().rawQuery(
+                DatabaseUtil.IS_GROUP_MEMBER_QUERY,
+                identity
+            );
 
             if (c != null) {
                 if (c.moveToFirst()) {
-                    isInGroup = c.getInt(0) > 0;
+                    isInGroup = c.getInt(0) == 1;
                 }
                 c.close();
             }
@@ -920,25 +804,6 @@ public class ContactServiceImpl implements ContactService {
         };
     }
 
-    @Override
-    public int updateContactVerification(String identity, byte[] publicKey) {
-        ContactModel c = this.getByIdentity(identity);
-
-        if (c != null) {
-            if (Arrays.equals(c.getPublicKey(), publicKey)) {
-                if (c.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-                    c.verificationLevel = VerificationLevel.FULLY_VERIFIED;
-                    this.save(c);
-                    return ContactVerificationResult_VERIFIED;
-                } else {
-                    return ContactVerificationResult_ALREADY_VERIFIED;
-                }
-            }
-        }
-
-        return ContactVerificationResult_NO_MATCH;
-    }
-
     @AnyThread
     @Override
     public Bitmap getAvatar(@Nullable ContactModel contact, @NonNull AvatarOptions options) {
@@ -980,7 +845,7 @@ public class ContactServiceImpl implements ContactService {
             return false;
         }
 
-        return fileService.hasContactAvatarFile(contact.getIdentity()) || fileService.hasContactPhotoFile(contact.getIdentity());
+        return fileService.hasUserDefinedProfilePicture(contact.getIdentity()) || fileService.hasContactDefinedProfilePicture(contact.getIdentity());
     }
 
     @Override
@@ -1002,110 +867,6 @@ public class ContactServiceImpl implements ContactService {
         avatarCacheService.loadContactAvatarIntoImage(model, imageView, options, requestManager);
     }
 
-    @AnyThread
-    @Override
-    public void clearAvatarCache(@NonNull ContactModel contactModel) {
-        if (this.avatarCacheService != null) {
-            this.avatarCacheService.reset(contactModel);
-        }
-    }
-
-    @Override
-    public @NonNull ContactModel createContactByIdentity(
-        @NonNull String identity,
-        boolean force
-    ) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException {
-        return createContactByIdentity(identity, force, AcquaintanceLevel.DIRECT);
-    }
-
-    @Override
-    public @NonNull ContactModel createContactByIdentity(
-        @NonNull String identity,
-        boolean force,
-        @NonNull AcquaintanceLevel acquaintanceLevel
-    ) throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException {
-        logger.info("Create contact by identity; identity={}, force={}, acquaintanceLevel={}", identity, force, acquaintanceLevel);
-        if (!force && AppRestrictionUtil.isAddContactDisabled(ThreemaApplication.getAppContext())) {
-            throw new PolicyViolationException();
-        }
-
-        if (identity.equals(getMe().getIdentity())) {
-            throw new InvalidEntryException(R.string.identity_already_exists);
-        }
-
-        ContactModel newContact = this.getByIdentity(identity);
-        if (newContact == null) {
-            // create a new contact
-            newContact = this.createContactModelByIdentity(identity);
-        } else if (newContact.getAcquaintanceLevel() == AcquaintanceLevel.DIRECT || acquaintanceLevel == AcquaintanceLevel.GROUP) {
-            throw new EntryAlreadyExistsException(R.string.identity_already_exists);
-        }
-
-        newContact.setAcquaintanceLevel(acquaintanceLevel);
-        newContact.verificationLevel = getInitialVerificationLevel(newContact);
-
-        this.save(newContact);
-
-        return newContact;
-    }
-
-    @Override
-    public void createGroupContactsByIdentities(@NonNull List<String> identities) {
-        List<String> newIdentities = StreamSupport.stream(identities)
-            .filter(identity -> {
-                if (identity == null) {
-                    return false;
-                }
-                if (identity.equals(getMe().getIdentity())) {
-                    logger.warn("Ignore own identity");
-                    return false;
-                }
-                if (getByIdentity(identity) != null) {
-                    logger.warn("Ignore ID that is already in contact list");
-                    return false;
-                }
-                return true;
-            }).collect(Collectors.toList());
-
-        if (newIdentities.isEmpty()) {
-            return;
-        }
-
-        try {
-            for (APIConnector.FetchIdentityResult result : apiConnector.fetchIdentities(newIdentities)) {
-                ContactModel contactModel = createContactByFetchIdentityResult(result);
-                if (contactModel != null) {
-                    contactModel.setAcquaintanceLevel(AcquaintanceLevel.GROUP);
-                    contactStore.addContact(contactModel);
-                }
-            }
-        } catch (Exception e) {
-            logger.error("Error while bulk creating contacts", e);
-        }
-    }
-
-    @Override
-    @NonNull
-    public VerificationLevel getInitialVerificationLevel(ContactModel contactModel) {
-        // Determine whether this is a trusted public key (e.g. for *SUPPORT)
-        final byte[] pubKey = contactModel.getPublicKey();
-        boolean isTrusted = false;
-        for (byte[] trustedKey : TRUSTED_PUBLIC_KEYS) {
-            if (Arrays.equals(trustedKey, pubKey)) {
-                isTrusted = true;
-                break;
-            }
-        }
-        return isTrusted ? VerificationLevel.FULLY_VERIFIED : VerificationLevel.UNVERIFIED;
-    }
-
-    @Override
-    public void removeAll() {
-        for (ContactModel model : this.find(null)) {
-            this.remove(model, false);
-        }
-    }
-
     @Override
     @NonNull
     public ContactMessageReceiver createReceiver(ContactModel contact) {
@@ -1123,27 +884,20 @@ public class ContactServiceImpl implements ContactService {
         );
     }
 
-    private ContactModel getContact(AbstractMessage msg) {
-        return this.getByIdentity(msg.getFromIdentity());
+    @Override
+    @Nullable
+    public ContactMessageReceiver createReceiver(@NonNull ch.threema.data.models.ContactModel contact) {
+        return createReceiver(contact.getIdentity());
     }
 
     @Override
-    public void updatePublicNickName(@NonNull AbstractMessage msg) {
-        ContactModel contact = getContact(msg);
-        if (contact == null) {
-            return;
-        }
-
-        String nickname = msg.getNickname();
-        // If nickname is present (not null), trim whitespaces
-        if (nickname != null) {
-            nickname = nickname.trim();
-        }
-
-        // Update nickname if it is not null (and different from the current nickname)
-        if (nickname != null && !nickname.equals(contact.getPublicNickName())) {
-            contact.setPublicNickName(nickname);
-            save(contact);
+    @Nullable
+    public ContactMessageReceiver createReceiver(@NonNull String identity) {
+        ContactModel contactModel = getByIdentity(identity);
+        if (contactModel != null) {
+            return createReceiver(contactModel);
+        } else {
+            return null;
         }
     }
 
@@ -1155,233 +909,119 @@ public class ContactServiceImpl implements ContactService {
             return false;
         }
 
-        List<ContactModel> contactModels = this.getAll();
-        for (ContactModel contactModel : contactModels) {
-            if (contactModel.isLinkedToAndroidContact()) {
+        // TODO(ANDR-3172): Get all contacts via contact model repository
+        this.getAll().stream()
+            .map(m -> contactModelRepository.getByIdentity(m.getIdentity()))
+            .filter(Objects::nonNull)
+            .filter(contactModel -> {
+                ContactModelData data = contactModel.getData().getValue();
+                return data != null && data.isLinkedToAndroidContact();
+            })
+            .forEach(contactModel -> {
                 try {
                     AndroidContactUtil.getInstance().updateNameByAndroidContact(contactModel);
                 } catch (ThreemaException e) {
-                    contactModel.setAndroidContactLookupKey(null);
                     logger.error("Unable to update contact name", e);
                 }
-                this.save(contactModel);
-            }
-        }
+            });
         return true;
     }
 
     @Override
     public void removeAllSystemContactLinks() {
-        for (ContactModel c : this.find(null)) {
-            if (c.isLinkedToAndroidContact()) {
-                c.setAndroidContactLookupKey(null);
-                this.save(c);
-            }
-        }
-    }
-
-    @Override
-    @Deprecated
-    public int getUniqueId(@Nullable ContactModel contactModel) {
-        if (contactModel != null) {
-            return getUniqueId(contactModel.getIdentity());
-        } else {
-            return 0;
-        }
-    }
-
-    @Override
-    @Deprecated
-    public int getUniqueId(@NonNull String identity) {
-        return (CONTACT_UID_PREFIX + identity).hashCode();
-    }
-
-    @Override
-    public String getUniqueIdString(ContactModel contactModel) {
-        if (contactModel != null) {
-            return getUniqueIdString(contactModel.getIdentity());
-        }
-        return "";
-    }
-
-    @Override
-    public String getUniqueIdString(String identity) {
-        if (identity != null) {
-            try {
-                MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
-                messageDigest.update((CONTACT_UID_PREFIX + identity).getBytes());
-                return Base32.encode(messageDigest.digest());
-            } catch (NoSuchAlgorithmException e) {
-                //
-            }
-        }
-        return "";
+        // TODO(ANDR-3172): Get all contacts via contact model repository
+        this.getAll()
+            .stream()
+            .filter(ContactModel::isLinkedToAndroidContact)
+            .map(m -> contactModelRepository.getByIdentity(m.getIdentity()))
+            .filter(Objects::nonNull)
+            .forEach(contactModel -> {
+                try {
+                    contactModel.removeAndroidContactLink();
+                } catch (ModelDeletedException e) {
+                    logger.info("Could not set android lookup key as model has been deleted");
+                }
+            });
     }
 
     @Override
-    public boolean setAvatar(final ContactModel contactModel, File temporaryAvatarFile) throws Exception {
+    public boolean setUserDefinedProfilePicture(
+        @Nullable final ContactModel contactModel,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    ) {
         if (contactModel != null && temporaryAvatarFile != null) {
-            if (this.fileService.writeContactAvatar(contactModel.getIdentity(), temporaryAvatarFile)) {
-                return this.onAvatarSet(contactModel);
+            if (this.fileService.writeUserDefinedProfilePicture(contactModel.getIdentity(), temporaryAvatarFile)) {
+                if (triggerSource != TriggerSource.SYNC && multiDeviceManager.isMultiDeviceActive()) {
+                    taskCreator.scheduleUserDefinedProfilePictureUpdate(contactModel.getIdentity());
+                }
+                return this.onUserDefinedProfilePictureSet(contactModel);
             }
         }
         return false;
     }
 
     @Override
-    public boolean setAvatar(@NonNull String identity, @Nullable File temporaryAvatarFile) throws Exception {
+    public boolean setUserDefinedProfilePicture(
+        @NonNull String identity,
+        @Nullable File temporaryAvatarFile,
+        @NonNull TriggerSource triggerSource
+    ) {
         ContactModel contactModel = getByIdentity(identity);
-        return setAvatar(contactModel, temporaryAvatarFile);
+        return setUserDefinedProfilePicture(contactModel, temporaryAvatarFile, triggerSource);
     }
 
     @Override
-    public boolean setAvatar(final ContactModel contactModel, byte[] avatar) throws Exception {
+    public boolean setUserDefinedProfilePicture(
+        @Nullable final ContactModel contactModel,
+        @Nullable byte[] avatar,
+        @NonNull TriggerSource triggerSource
+    ) throws IOException, MasterKeyLockedException {
         if (contactModel != null && avatar != null) {
-            if (this.fileService.writeContactAvatar(contactModel.getIdentity(), avatar)) {
-                return this.onAvatarSet(contactModel);
+            if (this.fileService.writeUserDefinedProfilePicture(contactModel.getIdentity(), avatar)) {
+                if (triggerSource != TriggerSource.SYNC && multiDeviceManager.isMultiDeviceActive()) {
+                    taskCreator.scheduleUserDefinedProfilePictureUpdate(contactModel.getIdentity());
+                }
+                return this.onUserDefinedProfilePictureSet(contactModel);
             }
         }
         return false;
     }
 
-    private boolean onAvatarSet(final ContactModel contactModel) {
-        this.clearAvatarCache(contactModel);
-
+    private boolean onUserDefinedProfilePictureSet(final ContactModel contactModel) {
         if (this.userService.isMe(contactModel.getIdentity())) {
-            // Update last profile picture upload date
-            this.preferenceService.setProfilePicUploadDate(new Date(0));
-            this.preferenceService.setProfilePicUploadData(null);
-
-            // Notify listeners
-            ListenerManager.profileListeners.handle(ProfileListener::onAvatarChanged);
+            logger.error("The users profile picture must not be set via contact service");
         } else {
-            ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel));
+            ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel.getIdentity()));
+            ShortcutUtil.updateShareTargetShortcut(createReceiver(contactModel));
         }
 
         return true;
     }
 
     @Override
-    public boolean removeAvatar(final ContactModel contactModel) {
-        if (contactModel != null) {
-            if (this.fileService.removeContactAvatar(contactModel.getIdentity())) {
-                this.clearAvatarCache(contactModel);
-
-                // Notify listeners
-                if (this.userService.isMe(contactModel.getIdentity())) {
-                    ListenerManager.profileListeners.handle(ProfileListener::onAvatarRemoved);
-                }
-                ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel));
-
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public void clearAvatarCache(@NonNull String identity) {
-        ContactModel contactModel = getByIdentity(identity);
-        if (contactModel != null) {
-            clearAvatarCache(contactModel);
-        }
-    }
-
-    @Override
-    @WorkerThread
-    @NonNull
-    public ProfilePictureUploadData getUpdatedProfilePictureUploadData() {
-        Bitmap contactPhoto;
-        try {
-            contactPhoto = getMyProfilePicture();
-        } catch (ThreemaException e) {
-            logger.error("Could not get my profile picture", e);
-            // Returning empty profile picture upload data means no set or delete profile picture
-            // message will be sent.
-            return new ProfilePictureUploadData();
-        }
-        if (contactPhoto == null) {
-            // If there is no profile picture set, then return empty upload data with an empty byte
-            // array as blob ID. This means, that a delete-profile-picture message will be sent.
-            ProfilePictureUploadData data = new ProfilePictureUploadData();
-            data.blobId = ContactModel.NO_PROFILE_PICTURE_BLOB_ID;
-            return data;
-        }
-
-        /* only upload blob every 7 days */
-        long uploadedAt = preferenceService.getProfilePicUploadDate();
-        Date uploadDeadline = new Date(uploadedAt + ContactUtil.PROFILE_PICTURE_BLOB_CACHE_DURATION);
-        Date now = new Date();
-
-        if (now.after(uploadDeadline)) {
-            logger.info("Uploading profile picture blob");
-
-            ProfilePictureUploadData data = uploadContactPhoto(contactPhoto);
-
-            if (data == null) {
-                return new ProfilePictureUploadData();
-            }
-
-            preferenceService.setProfilePicUploadDate(now);
-            preferenceService.setProfilePicUploadData(data);
-
-            data.uploadedAt = now.getTime();
-            return data;
-        } else {
-            ProfilePictureUploadData data = preferenceService.getProfilePicUploadData();
-            if (data != null) {
-                data.uploadedAt = uploadedAt;
-                return data;
-            } else {
-                return new ProfilePictureUploadData();
-            }
+    public boolean removeUserDefinedProfilePicture(
+        @Nullable final ContactModel contactModel,
+        @NonNull TriggerSource triggerSource
+    ) {
+        if (contactModel == null) {
+            logger.warn("Could not remove user defined profile picture as contact model is null");
+            return false;
         }
-    }
-
-    @WorkerThread
-    @Nullable
-    private Bitmap getMyProfilePicture() throws ThreemaException {
-        ContactModel myContactModel = getMe();
-        Bitmap myProfilePicture = getAvatar(myContactModel, true, false);
-        if (myProfilePicture == null && fileService.hasContactAvatarFile(myContactModel.getIdentity())) {
-            throw new ThreemaException("Could not load profile picture despite having set one");
+        if (userService.isMe(contactModel.getIdentity())) {
+            logger.error("The user's profile picture cannot be removed using the contact service");
+            return false;
         }
-        return myProfilePicture;
-    }
-
-    @Nullable
-    private ProfilePictureUploadData uploadContactPhoto(@NonNull Bitmap contactPhoto) {
-        ProfilePictureUploadData data = new ProfilePictureUploadData();
-
-        SecureRandom rnd = new SecureRandom();
-        data.encryptionKey = new byte[NaCl.SYMMKEYBYTES];
-        rnd.nextBytes(data.encryptionKey);
 
-        data.bitmapArray = BitmapUtil.bitmapToJpegByteArray(contactPhoto);
-        byte[] imageData = NaCl.symmetricEncryptData(data.bitmapArray, data.encryptionKey, ProtocolDefines.CONTACT_PHOTO_NONCE);
-        try {
-            BlobUploader blobUploader = this.apiService.createUploader(imageData);
-            data.blobId = blobUploader.upload();
-        } catch (ThreemaException | IOException e) {
-            logger.error("Could not upload contact photo", e);
-
-            if (e instanceof FileNotFoundException && ConfigUtils.isOnPremBuild()) {
-                logger.info("Invalidating auth token");
-                apiService.invalidateAuthToken();
+        if (this.fileService.removeUserDefinedProfilePicture(contactModel.getIdentity())) {
+            if (triggerSource != TriggerSource.SYNC && multiDeviceManager.isMultiDeviceActive()) {
+                taskCreator.scheduleUserDefinedProfilePictureUpdate(contactModel.getIdentity());
             }
-
-            return null;
+            ListenerManager.contactListeners.handle(listener -> listener.onAvatarChanged(contactModel.getIdentity()));
+            return true;
         }
-        data.size = imageData.length;
-        return data;
-    }
 
-    @Override
-    public void resetContactPhotoSentState(@NonNull ContactModel contactModel) {
-        // Note that setting the blob id to null also triggers a delete-profile-picture message to
-        // be sent again in case there is no profile picture set.
-        contactModel.setProfilePicBlobID(null);
-        save(contactModel);
+        return false;
     }
 
     @Override
@@ -1393,15 +1033,15 @@ public class ContactServiceImpl implements ContactService {
             case PreferenceService.PROFILEPIC_RELEASE_EVERYONE:
                 policy = ProfilePictureSharePolicy.Policy.EVERYONE;
                 break;
-            case PreferenceService.PROFILEPIC_RELEASE_SOME:
-                policy = ProfilePictureSharePolicy.Policy.SOME;
+            case PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST:
+                policy = ProfilePictureSharePolicy.Policy.ALLOW_LIST;
                 break;
             default:
                 policy = ProfilePictureSharePolicy.Policy.NOBODY;
                 break;
         }
 
-        List<String> allowedIdentities = policy == ProfilePictureSharePolicy.Policy.SOME
+        List<String> allowedIdentities = policy == ProfilePictureSharePolicy.Policy.ALLOW_LIST
             ? Arrays.asList(profilePicRecipientsService.getAll())
             : Collections.emptyList();
 
@@ -1409,55 +1049,10 @@ public class ContactServiceImpl implements ContactService {
     }
 
     @Override
-    public boolean isContactAllowedToReceiveProfilePicture(@NonNull ContactModel contactModel) {
+    public boolean isContactAllowedToReceiveProfilePicture(@NonNull String identity) {
         int profilePicRelease = preferenceService.getProfilePicRelease();
         return profilePicRelease == PreferenceService.PROFILEPIC_RELEASE_EVERYONE ||
-            (profilePicRelease == PreferenceService.PROFILEPIC_RELEASE_SOME && profilePicRecipientsService.has(contactModel.getIdentity()));
-    }
-
-    @Override
-    public ContactModel createContactModelByIdentity(String identity) throws InvalidEntryException {
-        if (identity == null || identity.length() != ProtocolDefines.IDENTITY_LEN) {
-            throw new InvalidEntryException(R.string.invalid_threema_id);
-        }
-
-        //auto UPPERCASE identity
-        identity = identity.toUpperCase();
-
-        //check for existing
-        if (this.getByIdentity(identity) != null) {
-            throw new InvalidEntryException(R.string.contact_already_exists);
-        }
-
-        if (identity.equals(userService.getIdentity())) {
-            throw new InvalidEntryException(R.string.contact_already_exists);
-        }
-
-        if (!this.deviceService.isOnline()) {
-            throw new InvalidEntryException(R.string.connection_error);
-        }
-
-        ContactModel contact;
-        try {
-            contact = this.fetchPublicKeyForIdentity(identity);
-        } catch (APIConnector.HttpConnectionException e) {
-            logger.error("Could not fetch public key", e);
-            if (e.getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
-                throw new InvalidEntryException(R.string.invalid_threema_id);
-            } else {
-                throw new InvalidEntryException(R.string.connection_error);
-            }
-        } catch (APIConnector.NetworkException e) {
-            throw new InvalidEntryException(R.string.connection_error);
-        }
-
-        if (contact == null) {
-            throw new InvalidEntryException(R.string.invalid_threema_id);
-        }
-
-        save(contact);
-
-        return contact;
+            (profilePicRelease == PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST && profilePicRecipientsService.has(identity));
     }
 
     @Override
@@ -1513,64 +1108,6 @@ public class ContactServiceImpl implements ContactService {
         return contactLookupUri;
     }
 
-    /**
-     * Create a ContactModel for the provided Work contact. If a ContactModel already exists, it will be updated with the data from the Work API,
-     * namely. name, verification level, work status. If the contact was hidden (i.e. added by a group), it will be visible after this operation
-     *
-     * @param workContact          WorkContact object for the contact to add
-     * @param existingWorkContacts An optional list of ContactModels. If a ContactModel already exists for workContact, the ContactModel will be removed from this list
-     * @return ContactModel of created or updated contact or null if public key of provided WorkContact was invalid
-     */
-    @Override
-    @Nullable
-    public ContactModel addWorkContact(@NonNull WorkContact workContact, @Nullable List<ContactModel> existingWorkContacts) {
-        if (!ConfigUtils.isWorkBuild()) {
-            return null;
-        }
-
-        if (workContact.publicKey == null || workContact.publicKey.length != NaCl.PUBLICKEYBYTES) {
-            // ignore work contact with invalid public key
-            return null;
-        }
-
-        if (workContact.threemaId != null && workContact.threemaId.equals(getMe().getIdentity())) {
-            // do not add our own ID as a contact
-            return null;
-        }
-
-        ContactModel contactModel = getByIdentity(workContact.threemaId);
-
-        if (contactModel == null) {
-            contactModel = new ContactModel(workContact.threemaId, workContact.publicKey);
-        } else if (existingWorkContacts != null) {
-            // try to remove from list of existing work contacts
-            for (int x = 0; x < existingWorkContacts.size(); x++) {
-                if (existingWorkContacts.get(x).getIdentity().equals(workContact.threemaId)) {
-                    existingWorkContacts.remove(x);
-                    break;
-                }
-            }
-        }
-
-        if (
-            !contactModel.isLinkedToAndroidContact()
-                && (workContact.firstName != null || workContact.lastName != null)
-        ) {
-            contactModel.setFirstName(workContact.firstName);
-            contactModel.setLastName(workContact.lastName);
-        }
-        contactModel.setJobTitle(workContact.jobTitle);
-        contactModel.setDepartment(workContact.department);
-        contactModel.setIsWork(true);
-        contactModel.setAcquaintanceLevel(AcquaintanceLevel.DIRECT);
-        if (contactModel.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-            contactModel.verificationLevel = VerificationLevel.SERVER_VERIFIED;
-        }
-        this.save(contactModel);
-
-        return contactModel;
-    }
-
     @Override
     public void removeFromCache(@NonNull String identity) {
         synchronized (this.contactModelCache) {
@@ -1607,9 +1144,9 @@ public class ContactServiceImpl implements ContactService {
 
         try {
             // Otherwise try to fetch the identity
-            Contact contact = fetchPublicKeyForIdentity(identity);
-            if (contact != null) {
-                contactStore.addCachedContact(contact);
+            BasicContact contactModel = fetchPublicKeyForIdentity(identity);
+            if (contactModel != null) {
+                contactStore.addCachedContact(contactModel);
             }
         } catch (APIConnector.HttpConnectionException e) {
             if (e.getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
@@ -1628,72 +1165,24 @@ public class ContactServiceImpl implements ContactService {
      *
      * @param identity the identity of the contact that might be a work contact
      */
+    @WorkerThread
     private void fetchAndCreateWorkContact(@NonNull String identity) {
-        LicenseService.Credentials credentials = this.licenseService.loadCredentials();
-        if ((credentials instanceof UserCredentials)) {
-            try {
-                List<WorkContact> workContacts = apiConnector.fetchWorkContacts(((UserCredentials) credentials).username, ((UserCredentials) credentials).password, new String[]{identity});
-                if (workContacts.size() > 0) {
-                    WorkContact workContact = workContacts.get(0);
-                    addWorkContact(workContact, null);
-                }
-            } catch (Exception e) {
-                logger.error("Error fetching work contact", e);
-            }
-        }
-    }
-
-    /**
-     * Create a visible (i.e. non-hidden) contact by an identity fetch result but do NOT save it yet.
-     *
-     * @param result the result of the identity fetch
-     * @return the contact model if the fetch was successful, null otherwise
-     */
-    private @Nullable ContactModel createContactByFetchIdentityResult(
-        @Nullable APIConnector.FetchIdentityResult result
-    ) {
-        if (result == null || result.publicKey == null) {
-            return null;
-        }
-
-        byte[] b = result.publicKey;
-
-        ContactModel contact = new ContactModel(result.identity, b);
-        contact.setFeatureMask(result.featureMask);
-        contact.verificationLevel = VerificationLevel.UNVERIFIED;
-        contact.setDateCreated(new Date());
-        switch (result.type) {
-            case 0:
-                contact.setIdentityType(IdentityType.NORMAL);
-                break;
-            case 1:
-                contact.setIdentityType(IdentityType.WORK);
-                break;
-            default:
-                logger.warn("Identity fetch returned invalid identity type: {}", result.type);
-        }
-        switch (result.state) {
-            case IdentityState.ACTIVE:
-                contact.setState(ContactModel.State.ACTIVE);
-                break;
-            case IdentityState.INACTIVE:
-                contact.setState(ContactModel.State.INACTIVE);
-                break;
-            case IdentityState.INVALID:
-                contact.setState(ContactModel.State.INVALID);
-                break;
-        }
-
-        return contact;
+        new AddOrUpdateWorkIdentityBackgroundTask(
+            identity,
+            userService.getIdentity(),
+            licenseService,
+            apiConnector,
+            contactModelRepository
+        ).runSynchronously();
     }
 
     @Override
     @WorkerThread
-    public boolean resetReceiptsSettings() {
+    public void resetReceiptsSettings() {
         List<ContactModel> contactModels = find(new Filter() {
             @Override
-            public ContactModel.State[] states() {
-                return new ContactModel.State[]{ContactModel.State.ACTIVE, ContactModel.State.INACTIVE};
+            public IdentityState[] states() {
+                return new IdentityState[]{IdentityState.ACTIVE, IdentityState.INACTIVE};
             }
 
             @Override
@@ -1722,28 +1211,38 @@ public class ContactServiceImpl implements ContactService {
             }
         });
 
-        if (contactModels.size() > 0) {
-            for (ContactModel contactModel : contactModels) {
-                contactModel.setTypingIndicators(ContactModel.DEFAULT);
-                contactModel.setReadReceipts(ContactModel.DEFAULT);
-                save(contactModel);
-            }
-            return true;
-        }
-        return false;
+        contactModels
+            .stream()
+            .map(contactModel -> contactModelRepository.getByIdentity(contactModel.getIdentity()))
+            .forEach(contactModel -> {
+                if (contactModel != null) {
+                    contactModel.setReadReceiptPolicyFromLocal(ReadReceiptPolicy.DEFAULT);
+                    contactModel.setTypingIndicatorPolicyFromLocal(TypingIndicatorPolicy.DEFAULT);
+                }
+            });
     }
 
     @Override
     @UiThread
-    public void reportSpam(@NonNull final ContactModel spammerContactModel, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure) {
+    public void reportSpam(@NonNull final String identity, @Nullable Consumer<Void> onSuccess, @Nullable Consumer<String> onFailure) {
         new Thread(() -> {
             try {
-                apiConnector.reportJunk(identityStore, spammerContactModel.getIdentity(), spammerContactModel.getPublicNickName());
+                ch.threema.data.models.ContactModel spammerContactModel = contactModelRepository.getByIdentity(identity);
+                if (spammerContactModel == null) {
+                    logger.warn("No contact with identity {} found", identity);
+                    return;
+                }
+                ContactModelData contactModelData = spammerContactModel.getData().getValue();
+                if (contactModelData == null) {
+                    logger.warn("Contact model data for identity {} is null", identity);
+                    return;
+                }
+
+                apiConnector.reportJunk(identityStore, identity, contactModelData.nickname);
 
                 // Note: This is semantically wrong. Once we support multi-device, we probably
                 //       need to adapt the logic. Protocol discussions are ongoing.
-                spammerContactModel.setAcquaintanceLevel(AcquaintanceLevel.GROUP);
-                save(spammerContactModel);
+                spammerContactModel.setAcquaintanceLevelFromLocal(AcquaintanceLevel.GROUP);
 
                 if (onSuccess != null) {
                     RuntimeUtil.runOnUiThread(() -> onSuccess.accept(null));
@@ -1794,10 +1293,10 @@ public class ContactServiceImpl implements ContactService {
      * @throws ch.threema.domain.protocol.api.APIConnector.NetworkException        when the identity cannot be fetched
      */
     @WorkerThread
-    private @Nullable ContactModel fetchPublicKeyForIdentity(@NonNull String identity) throws APIConnector.HttpConnectionException, APIConnector.NetworkException {
+    private @Nullable BasicContact fetchPublicKeyForIdentity(@NonNull String identity) throws APIConnector.HttpConnectionException, APIConnector.NetworkException {
         ContactModel contactModel = contactStore.getContactForIdentity(identity);
         if (contactModel != null) {
-            return contactModel;
+            return contactModel.toBasicContact();
         }
 
         APIConnector.FetchIdentityResult result;
@@ -1812,32 +1311,36 @@ public class ContactServiceImpl implements ContactService {
             throw new APIConnector.NetworkException(e);
         }
 
-        ContactModel contact = new ContactModel(identity, result.publicKey);
-        contact.setFeatureMask(result.featureMask);
-        contact.verificationLevel = VerificationLevel.UNVERIFIED;
-        contact.setDateCreated(new Date());
+        IdentityType identityType;
         switch (result.type) {
             case 0:
-                contact.setIdentityType(IdentityType.NORMAL);
+                identityType = IdentityType.NORMAL;
                 break;
             case 1:
-                contact.setIdentityType(IdentityType.WORK);
+                identityType = IdentityType.WORK;
                 break;
             default:
                 logger.warn("Identity fetch returned invalid identity type: {}", result.type);
-        }
-        switch (result.state) {
-            case IdentityState.ACTIVE:
-                contact.setState(ContactModel.State.ACTIVE);
-                break;
-            case IdentityState.INACTIVE:
-                contact.setState(ContactModel.State.INACTIVE);
-                break;
-            case IdentityState.INVALID:
-                contact.setState(ContactModel.State.INVALID);
-                break;
+                identityType = IdentityType.NORMAL;
+        }
+        IdentityState identityState;
+        if (result.state == IdentityState.ACTIVE.getValue()) {
+            identityState = IdentityState.ACTIVE;
+        } else if (result.state == IdentityState.INACTIVE.getValue()) {
+            identityState = IdentityState.INACTIVE;
+        } else if (result.state == IdentityState.INVALID.getValue()) {
+            identityState = IdentityState.INVALID;
+        } else {
+            logger.warn("Identity fetch returned invalid identity state: {}", result.state);
+            identityState = IdentityState.ACTIVE;
         }
 
-        return contact;
+        return BasicContact.javaCreate(
+            result.identity,
+            result.publicKey,
+            result.featureMask,
+            identityState,
+            identityType
+        );
     }
 }
diff --git a/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java b/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java
index 655b2f30..cf7b257f 100644
--- a/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java
+++ b/app/src/main/java/ch/threema/app/services/ContactsSyncAdapterService.java
@@ -29,9 +29,33 @@ import ch.threema.app.adapters.ContactsSyncAdapter;
 
 public class ContactsSyncAdapterService extends Service {
 
-	private ContactsSyncAdapter contactsSyncAdapter = null;
+	private static ContactsSyncAdapter contactsSyncAdapter = null;
 	private static final Object syncAdapterLock = new Object();
 
+	private static boolean isSyncEnabled = true;
+
+	public static void enableSync() {
+		synchronized (syncAdapterLock) {
+			isSyncEnabled = true;
+			setAdapterSyncEnabled();
+		}
+	}
+
+	public static void disableSync() {
+		synchronized (syncAdapterLock) {
+			isSyncEnabled = false;
+			setAdapterSyncEnabled();
+		}
+	}
+
+	private static void setAdapterSyncEnabled() {
+		synchronized (syncAdapterLock) {
+			if (contactsSyncAdapter != null) {
+				contactsSyncAdapter.setSyncEnabled(isSyncEnabled);
+			}
+		}
+	}
+
 	@Override
 	public void onCreate() {
 		super.onCreate();
@@ -39,6 +63,7 @@ public class ContactsSyncAdapterService extends Service {
 		synchronized (syncAdapterLock) {
 			if (contactsSyncAdapter == null) {
 				contactsSyncAdapter = new ContactsSyncAdapter(getApplicationContext(), true);
+				contactsSyncAdapter.setSyncEnabled(isSyncEnabled);
 			}
 		}
 	}
diff --git a/app/src/main/java/ch/threema/app/services/ConversationService.java b/app/src/main/java/ch/threema/app/services/ConversationService.java
index f1f474ff..28631a6f 100644
--- a/app/src/main/java/ch/threema/app/services/ConversationService.java
+++ b/app/src/main/java/ch/threema/app/services/ConversationService.java
@@ -161,15 +161,6 @@ public interface ConversationService {
 	 */
 	int empty(@NonNull MessageReceiver messageReceiver);
 
-	/**
-	 * Empty associated conversation (remove all messages).
-	 *
-	 * The message listener onRemoved method will *not* be called for removed messages.
-	 *
-	 * @return the number of removed messages.
-	 */
-	int empty(@NonNull ContactModel contactModel);
-
 	/**
 	 * Empty associated conversation (remove all messages).
 	 *
diff --git a/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java b/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java
index 6679364c..f3da3f3f 100644
--- a/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ConversationServiceImpl.java
@@ -51,6 +51,7 @@ import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.MessageUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -245,20 +246,20 @@ public class ConversationServiceImpl implements ConversationService {
                     });
                 }
 
-                if (filter.noInvalid()) {
-                    logger.debug("filter chats with revoked contacts / left group that cannot receive messages");
-                    filtered = Functional.filter(filtered, new IPredicateNonNull<ConversationModel>() {
-                        @Override
-                        public boolean apply(@NonNull ConversationModel conversationModel) {
-                            if (conversationModel.isContactConversation()) {
-                                return conversationModel.getContact() != null && !(conversationModel.getContact().getState() == ContactModel.State.INVALID);
-                            } else if (conversationModel.isGroupConversation()) {
-                                return conversationModel.getGroup() != null && groupService.isGroupMember(conversationModel.getGroup());
-                            }
-                            return true;
-                        }
-                    });
-                }
+				if (filter.noInvalid()) {
+					logger.debug("filter chats with revoked contacts / left group that cannot receive messages");
+					filtered = Functional.filter(filtered, new IPredicateNonNull<ConversationModel>() {
+						@Override
+						public boolean apply(@NonNull ConversationModel conversationModel) {
+							if (conversationModel.isContactConversation()) {
+								return conversationModel.getContact() != null && conversationModel.getContact().getState() != IdentityState.INVALID;
+							} else if (conversationModel.isGroupConversation()) {
+								return conversationModel.getGroup() != null && groupService.isGroupMember(conversationModel.getGroup());
+							}
+							return true;
+						}
+					});
+				}
 
                 if (filter.onlyPersonal()) {
                     logger.debug("filter non-personal chats such as channels/broadcasts or blocked chats");
@@ -538,15 +539,14 @@ public class ConversationServiceImpl implements ConversationService {
 
     @Override
     public synchronized int empty(@NonNull MessageReceiver receiver) {
-        switch (receiver.getType()) {
-            case MessageReceiver.Type_CONTACT:
-                return this.empty(((ContactMessageReceiver) receiver).getContact());
-            case MessageReceiver.Type_GROUP:
-                return this.empty(((GroupMessageReceiver) receiver).getGroup());
-            case MessageReceiver.Type_DISTRIBUTION_LIST:
-                return this.empty(((DistributionListMessageReceiver) receiver).getDistributionList());
-            default:
-                throw new IllegalStateException("Got ReceiverModel with invalid receiver type!");
+        // First refresh the receiver. Otherwise it is possible that the conversation is null as it
+        // does not yet exist (or is just not yet loaded) and then the chat won't be emptied.
+        ConversationModel model = refresh(receiver);
+        if (model != null) {
+            return this.empty(model, true);
+        } else {
+            logger.error("Could not empty conversation as conversation model is null");
+            return 0;
         }
     }
 
@@ -576,11 +576,6 @@ public class ConversationServiceImpl implements ConversationService {
         return messages.size();
     }
 
-    @Override
-    public synchronized int empty(@NonNull ContactModel contactModel) {
-        return empty(contactModel.getIdentity());
-    }
-
     @Override
     public int empty(@NonNull String identity) {
         final ConversationModel conversationModel = new ContactConversationModelParser().getCached(identity);
diff --git a/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java b/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java
index ad16a1d8..e957cbf8 100644
--- a/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/DistributionListServiceImpl.java
@@ -163,11 +163,6 @@ public class DistributionListServiceImpl implements DistributionListService {
 		avatarCacheService.loadDistributionListAvatarIntoImage(model, imageView, options, requestManager);
 	}
 
-	@Override
-	public void clearAvatarCache(@NonNull DistributionListModel model) {
-		// Nothing to do, as distribution list avatars currently aren't being cached
-	}
-
 	@Override
 	public @ColorInt int getAvatarColor(@Nullable DistributionListModel distributionList) {
 		if (distributionList != null) {
diff --git a/app/src/main/java/ch/threema/app/services/DownloadService.java b/app/src/main/java/ch/threema/app/services/DownloadService.java
index 2c4d7281..d8872d1f 100644
--- a/app/src/main/java/ch/threema/app/services/DownloadService.java
+++ b/app/src/main/java/ch/threema/app/services/DownloadService.java
@@ -21,18 +21,36 @@
 
 package ch.threema.app.services;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
 import ch.threema.base.ProgressListener;
+import ch.threema.domain.protocol.blob.BlobScope;
 
-public interface DownloadService{
-	@WorkerThread @Nullable byte[] download(int id, byte[] blobId, boolean markAsDown, @Nullable ProgressListener progressListener);
-	void complete(int id, byte[] blobId);
-	boolean cancel(int id);
+public interface DownloadService {
 
-	boolean isDownloading(int blobId);
+    /**
+     * @param blobScopeMarkAsDone If this field is <strong>not</strong> {@code null}, the blob will
+     *                            automatically be marked as "done" on the server. Of course only if
+     *                            the preceding download succeeded.
+     */
+    @WorkerThread
+    @Nullable
+    byte[] download(
+        int id,
+        @Nullable byte[] blobId,
+        @NonNull BlobScope blobScopeDownload,
+        @Nullable BlobScope blobScopeMarkAsDone,
+        @Nullable ProgressListener progressListener
+    );
 
-	boolean isDownloading();
+    void complete(int id, byte[] blobId);
 
-	void error(int id);
+    boolean cancel(int id);
+
+    boolean isDownloading(int blobId);
+
+    boolean isDownloading();
+
+    void error(int id);
 }
diff --git a/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java b/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java
index 45037752..e1368723 100644
--- a/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/DownloadServiceImpl.java
@@ -46,6 +46,7 @@ import ch.threema.base.ProgressListener;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.protocol.blob.BlobLoader;
+import ch.threema.domain.protocol.blob.BlobScope;
 
 public class DownloadServiceImpl implements DownloadService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("DownloadServiceImpl");
@@ -109,7 +110,7 @@ public class DownloadServiceImpl implements DownloadService {
 						messageModelId,
 						cancel);
 					if (cancel) {
-						download.blobLoader.cancel();
+						download.blobLoader.cancelDownload();
 					}
 					this.downloads.remove(download);
 				}
@@ -127,7 +128,13 @@ public class DownloadServiceImpl implements DownloadService {
 
 	@Override
 	@WorkerThread
-	public @Nullable byte[] download(int messageModelId, final byte[] blobId, boolean markAsDown, @Nullable ProgressListener progressListener) {
+	public @Nullable byte[] download(
+        int messageModelId,
+        final @Nullable byte[] blobId,
+        @NonNull BlobScope blobScopeDownload,
+        @Nullable BlobScope blobScopeMarkAsDone,
+        @Nullable ProgressListener progressListener
+    ) {
 		PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKELOCK_TAG);
 		try {
 			if (wakeLock != null) {
@@ -174,12 +181,12 @@ public class DownloadServiceImpl implements DownloadService {
 				}
 
 				if (progressListener != null) {
-					blobLoader.setProgressListener(progressListener);
+					blobLoader.progressListener = progressListener;
 				}
 
 				// Load blob from server
 				logger.info("Blob {} now fetching", blobIdHex);
-				blobBytes = blobLoader.load(false);
+				blobBytes = blobLoader.load(blobScopeDownload);
 
 				if (blobBytes != null) {
 					synchronized (this.downloads) {
@@ -197,8 +204,8 @@ public class DownloadServiceImpl implements DownloadService {
 								if (downloadFile.length() == blobBytes.length) {
 									downloadSuccess = true;
 
-									//ok download saved, set as down if set
-									if (markAsDown) {
+									//ok download saved, set as done if set
+									if (blobScopeMarkAsDone != null) {
 										logger.info("Blob {} scheduled for marking as downloaded", blobIdHex);
 										try {
 											new Thread(() -> {
@@ -208,7 +215,7 @@ public class DownloadServiceImpl implements DownloadService {
 												}
 												if (download != null) {
 													if (download.blobLoader != null) {
-														download.blobLoader.markAsDone(download.blobId);
+														download.blobLoader.markAsDone(download.blobId, blobScopeMarkAsDone);
 													}
 													logger.info("Blob {} marked as downloaded", blobIdHex);
 												}
diff --git a/app/src/main/java/ch/threema/app/services/FileService.java b/app/src/main/java/ch/threema/app/services/FileService.java
index cb0ada78..7041af75 100644
--- a/app/src/main/java/ch/threema/app/services/FileService.java
+++ b/app/src/main/java/ch/threema/app/services/FileService.java
@@ -128,9 +128,9 @@ public interface FileService {
 	 */
 	File createWallpaperFile(MessageReceiver messageReceiver) throws IOException;
 
-	boolean hasContactAvatarFile(@NonNull String identity);
+	boolean hasUserDefinedProfilePicture(@NonNull String identity);
 
-	boolean hasContactPhotoFile(@NonNull String identity);
+	boolean hasContactDefinedProfilePicture(@NonNull String identity);
 
 	/**
 	 * decrypt a file and save into a new one
@@ -194,93 +194,107 @@ public interface FileService {
 	 */
 	boolean writeConversationMedia(AbstractMessageModel messageModel, byte[] data, int pos, int length, boolean overwrite) throws Exception;
 
-	/**
-	 * Save a group avatar (resize if needed) and return true on success.
-	 */
-	boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws Exception;
+    /**
+     * Save a group avatar (resize if needed) and return true on success. Additionally, this resets
+     * the avatar cache for this group.
+     */
+	boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * get the group avatar as InputStream
 	 */
-	InputStream getGroupAvatarStream(GroupModel groupModel) throws Exception;
+	InputStream getGroupAvatarStream(GroupModel groupModel) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * get the group avatar if the file exists
 	 */
-	Bitmap getGroupAvatar(GroupModel groupModel) throws Exception;
+	Bitmap getGroupAvatar(GroupModel groupModel) throws IOException, MasterKeyLockedException;
 
 	/**
-	 * remove the group avatar
+	 * Remove the group avatar. Additionally, this resets the avatar cache for this group.
 	 */
-	void removeGroupAvatar(GroupModel groupModel);
+	void removeGroupAvatar(@NonNull GroupModel groupModel);
 
 	boolean hasGroupAvatarFile(GroupModel groupModel);
 
-	/**
-	 * write the contact avatar
-	 */
-	boolean writeContactAvatar(@NonNull String identity, File file) throws Exception;
+    /**
+     * Write the contact profile picture set by the user. Additionally, this resets the avatar cache
+     * for this contact.
+     */
+	boolean writeUserDefinedProfilePicture(@NonNull String identity, File file);
 
 	/**
-	 * write the contact avatar
+	 * Write the contact profile picture set by the user. Additionally, this resets the avatar cache
+     * for this contact.
 	 */
-	boolean writeContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception;
+	boolean writeUserDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws IOException, MasterKeyLockedException;
 
 	/**
-	 * write the contact photo received by the contact
+	 * Write the contact profile picture received by the contact. Additionally, this resets the
+     * avatar cache for this contact.
 	 */
-	boolean writeContactPhoto(@NonNull String identity, byte[] encryptedBlob) throws Exception;
+	boolean writeContactDefinedProfilePicture(@NonNull String identity, byte[] encryptedBlob) throws IOException, MasterKeyLockedException;
 
 	/**
-	 * write the contact avatar from Android's address book
+	 * Write the contact profile picture from Android's address book. Additionally, this resets the
+     * avatar cache for this contact.
 	 */
-	boolean writeAndroidContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception;
+	boolean writeAndroidDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws Exception;
 
 	/**
 	 * return the decrypted bitmap of a contact avatar
 	 * if no file exists, null will be returned
 	 */
-	Bitmap getContactAvatar(@NonNull String identity) throws Exception;
+	Bitmap getUserDefinedProfilePicture(@NonNull String identity) throws Exception;
 
-	Bitmap getAndroidContactAvatar(@NonNull ContactModel contactModel) throws Exception;
+	Bitmap getAndroidDefinedProfilePicture(@NonNull ContactModel contactModel) throws Exception;
 
 	/**
 	 * Return a input stream of a local saved contact avatar
 	 */
-	InputStream getContactAvatarStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
+	InputStream getUserDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * Return a input stream of a contact photo
 	 */
-	InputStream getContactPhotoStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
+	InputStream getContactDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException;
 
 	/**
 	 * return the decrypted bitmap of a contact-provided profile picture
 	 * returns null if no file exists
 	 */
-	Bitmap getContactPhoto(@NonNull String identity) throws Exception;
+	Bitmap getContactDefinedProfilePicture(@NonNull String identity) throws Exception;
 
 	/**
-	 * remove the saved avatar
-	 * return true if the avatar was deleted, false if the remove failed or no avatar file exists
-	 */
-	boolean removeContactAvatar(@NonNull String identity);
+     * Remove the user defined profile picture for the contact with the given identity.
+     * Additionally, this resets the avatar cache for this contact.
+     *
+     * @param identity the identity of the contact
+     * @return true if the avatar was deleted, false if the remove failed or no avatar file exists
+     */
+	boolean removeUserDefinedProfilePicture(@NonNull String identity);
 
-	/**
-	 * remove the saved profile pic for this contact
-	 * @param identity the identity of the contact
-	 * @return true if avatar was deleted, false if the remove failed or no avatar file exists
-	 */
-	boolean removeContactPhoto(@NonNull String identity);
+    /**
+     * Remove the contact defined profile picture for the contact with the given identity.
+     * Additionally, this resets the avatar cache for this contact.
+     *
+     * @param identity the identity of the contact
+     * @return true if avatar was deleted, false if the remove failed or no avatar file exists
+     */
+	boolean removeContactDefinedProfilePicture(@NonNull String identity);
 
 	/**
-	 * remove the saved avatar from Android's address book
-	 * return true if the avatar was deleted, false if the remove failed or no avatar file exists
+	 * Remove the profile picture from Android's address book. Additionally, this resets the avatar
+     * cache for this contact.
+     *
+     * @param identity the identity of the contact
+	 * @return true if the avatar was deleted, false if the remove failed or no avatar file exists
 	 */
-	boolean removeAndroidContactAvatar(@NonNull String identity);
+	boolean removeAndroidDefinedProfilePicture(@NonNull String identity);
 
 	/**
-	 * remove all avatars in the respective directory
+	 * Remove all avatars in the respective directory. Note that this does *not* reset the avatar
+     * caches.
 	 */
 	void removeAllAvatars();
 
diff --git a/app/src/main/java/ch/threema/app/services/FileServiceImpl.java b/app/src/main/java/ch/threema/app/services/FileServiceImpl.java
index 7fb48ce8..512471cc 100644
--- a/app/src/main/java/ch/threema/app/services/FileServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/FileServiceImpl.java
@@ -139,10 +139,19 @@ public class FileServiceImpl implements FileService {
 	private final File appDataPath;
 	private final File backupPath;
 
-	public FileServiceImpl(Context c, MasterKey masterKey, PreferenceService preferenceService) {
+    @NonNull
+    private final AvatarCacheService avatarCacheService;
+
+	public FileServiceImpl(
+        @NonNull Context c,
+        @NonNull MasterKey masterKey,
+        @NonNull PreferenceService preferenceService,
+        @NonNull AvatarCacheService avatarCacheService
+    ) {
 		this.context = c;
 		this.preferenceService = preferenceService;
 		this.masterKey = masterKey;
+        this.avatarCacheService = avatarCacheService;
 
 		String mediaPathPrefix = Environment.getExternalStorageDirectory() + "/" + BuildConfig.MEDIA_PATH + "/";
 
@@ -491,14 +500,14 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean hasContactAvatarFile(@NonNull String identity) {
+	public boolean hasUserDefinedProfilePicture(@NonNull String identity) {
 		File avatar = getContactAvatarFile(identity);
 
 		return avatar != null && avatar.exists();
 	}
 
 	@Override
-	public boolean hasContactPhotoFile(@NonNull String identity) {
+	public boolean hasContactDefinedProfilePicture(@NonNull String identity) {
 		File avatar = getContactPhotoFile(identity);
 
 		return avatar != null && avatar.exists();
@@ -524,6 +533,7 @@ public class FileServiceImpl implements FileService {
 		return getPictureFile(getAvatarDirPath(), ".p-", identity);
 	}
 
+	@Nullable
 	private File getAndroidContactAvatarFile(@NonNull String identity) {
 		return getPictureFile(getAvatarDirPath(), ".a-", identity);
 	}
@@ -928,12 +938,16 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws Exception {
-		return this.writeFile(photoData, new File(getGroupAvatarDirPath(), getGroupAvatarFileName(groupModel)));
+	public boolean writeGroupAvatar(GroupModel groupModel, byte[] photoData) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(photoData, new File(getGroupAvatarDirPath(), getGroupAvatarFileName(groupModel)));
+        if (success) {
+            avatarCacheService.reset(groupModel);
+        }
+        return success;
 	}
 
 	@Override
-	public InputStream getGroupAvatarStream(GroupModel groupModel) throws Exception {
+	public InputStream getGroupAvatarStream(GroupModel groupModel) throws IOException, MasterKeyLockedException {
 		File f = this.getGroupAvatarFile(groupModel);
 		if (f.exists()) {
 			return masterKey.getCipherInputStream(new FileInputStream(f));
@@ -943,19 +957,20 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public Bitmap getGroupAvatar(GroupModel groupModel) throws Exception {
+	public Bitmap getGroupAvatar(GroupModel groupModel) throws IOException, MasterKeyLockedException {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
 		return decryptBitmapFromFile(this.getGroupAvatarFile(groupModel));
 	}
 
 	@Override
-	public void removeGroupAvatar(GroupModel groupModel) {
+	public void removeGroupAvatar(@NonNull GroupModel groupModel) {
 		File f = this.getGroupAvatarFile(groupModel);
 		if (f.exists()) {
 			FileUtil.deleteFileOrWarn(f, "removeGroupAvatar", logger);
+            avatarCacheService.reset(groupModel);
 		}
 	}
 
@@ -967,38 +982,54 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean writeContactAvatar(@NonNull String identity, File file) throws Exception {
-		return this.decryptFileToFile(file, this.getContactAvatarFile(identity));
+	public boolean writeUserDefinedProfilePicture(@NonNull String identity, File file) {
+		boolean success = this.decryptFileToFile(file, this.getContactAvatarFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean writeContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception {
-		return this.writeFile(avatarFile, this.getContactAvatarFile(identity));
+	public boolean writeUserDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(avatarFile, this.getContactAvatarFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean writeContactPhoto(@NonNull String identity, byte[] encryptedBlob) throws Exception {
-		return this.writeFile(encryptedBlob, this.getContactPhotoFile(identity));
+	public boolean writeContactDefinedProfilePicture(@NonNull String identity, byte[] encryptedBlob) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(encryptedBlob, this.getContactPhotoFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean writeAndroidContactAvatar(@NonNull String identity, byte[] avatarFile) throws Exception {
-		return this.writeFile(avatarFile, this.getAndroidContactAvatarFile(identity));
+	public boolean writeAndroidDefinedProfilePicture(@NonNull String identity, byte[] avatarFile) throws IOException, MasterKeyLockedException {
+		boolean success = this.writeFile(avatarFile, this.getAndroidContactAvatarFile(identity));
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public Bitmap getContactAvatar(@NonNull String identity) throws Exception {
+	public Bitmap getUserDefinedProfilePicture(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
 		return decryptBitmapFromFile(this.getContactAvatarFile(identity));
 	}
 
 	@Override
-	public Bitmap getAndroidContactAvatar(@NonNull ContactModel contactModel) throws Exception {
+	public Bitmap getAndroidDefinedProfilePicture(@NonNull ContactModel contactModel) throws Exception {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
 		long now = System.currentTimeMillis();
@@ -1006,9 +1037,13 @@ public class FileServiceImpl implements FileService {
 		if (expiration < now) {
 			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
 			if (serviceManager != null) {
-				if (AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contactModel)) {
-					ContactService contactService = serviceManager.getContactService();
-					contactService.save(contactModel);
+				try {
+					if (AndroidContactUtil.getInstance().updateAvatarByAndroidContact(contactModel)) {
+						ContactService contactService = serviceManager.getContactService();
+						contactService.save(contactModel);
+					}
+				} catch (SecurityException e) {
+					logger.error("Could not update avatar by android contact", e);
 				}
 			}
 		}
@@ -1017,7 +1052,7 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public InputStream getContactAvatarStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
+	public InputStream getUserDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		File f = this.getContactAvatarFile(identity);
 		if (f != null && f.exists() && f.length() > 0) {
 			return masterKey.getCipherInputStream(new FileInputStream(f));
@@ -1027,7 +1062,7 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public InputStream getContactPhotoStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
+	public InputStream getContactDefinedProfilePictureStream(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		File f = this.getContactPhotoFile(identity);
 		if (f != null && f.exists() && f.length() > 0) {
 			return masterKey.getCipherInputStream(new FileInputStream(f));
@@ -1036,18 +1071,15 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public Bitmap getContactPhoto(@NonNull String identity) throws Exception {
+	public Bitmap getContactDefinedProfilePicture(@NonNull String identity) throws IOException, MasterKeyLockedException {
 		if (this.masterKey.isLocked()) {
-			throw new Exception("no masterkey or locked");
+			throw new MasterKeyLockedException("no masterkey or locked");
 		}
 
-		if (this.preferenceService.getProfilePicReceive()) {
-			return decryptBitmapFromFile(this.getContactPhotoFile(identity));
-		}
-		return null;
+		return decryptBitmapFromFile(this.getContactPhotoFile(identity));
 	}
 
-	private Bitmap decryptBitmapFromFile(@Nullable File file) throws Exception {
+	private Bitmap decryptBitmapFromFile(@Nullable File file) throws IOException, MasterKeyLockedException {
 		if (file != null && file.exists()) {
 			InputStream inputStream = masterKey.getCipherInputStream(new FileInputStream(file));
 			if (inputStream != null) {
@@ -1062,21 +1094,33 @@ public class FileServiceImpl implements FileService {
 	}
 
 	@Override
-	public boolean removeContactAvatar(@NonNull String identity) {
+	public boolean removeUserDefinedProfilePicture(@NonNull String identity) {
 		File f = this.getContactAvatarFile(identity);
-		return f != null && f.exists() && f.delete();
+		boolean success = f != null && f.exists() && f.delete();
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean removeContactPhoto(@NonNull String identity) {
+	public boolean removeContactDefinedProfilePicture(@NonNull String identity) {
 		File f = this.getContactPhotoFile(identity);
-		return f != null && f.exists() && f.delete();
+		boolean success = f != null && f.exists() && f.delete();
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
-	public boolean removeAndroidContactAvatar(@NonNull String identity) {
+	public boolean removeAndroidDefinedProfilePicture(@NonNull String identity) {
 		File f = this.getAndroidContactAvatarFile(identity);
-		return f != null && f.exists() && f.delete();
+		boolean success = f != null && f.exists() && f.delete();
+        if (success) {
+            avatarCacheService.reset(identity);
+        }
+        return success;
 	}
 
 	@Override
@@ -1088,8 +1132,8 @@ public class FileServiceImpl implements FileService {
 		}
 	}
 
-	private boolean writeFile(byte[] data, File file) throws Exception {
-		if (data != null && data.length > 0) {
+	private boolean writeFile(@Nullable byte[] data, @Nullable File file) throws IOException, MasterKeyLockedException {
+		if (data != null && data.length > 0 && file != null) {
 			try (FileOutputStream fileOutputStream = new FileOutputStream(file); CipherOutputStream cipherOutputStream = this.masterKey.getCipherOutputStream(fileOutputStream)) {
 				cipherOutputStream.write(data);
 				return true;
@@ -1101,7 +1145,7 @@ public class FileServiceImpl implements FileService {
 		return false;
 	}
 
-	private boolean writeFile(byte[] data, int pos, int length, File file) throws Exception {
+	private boolean writeFile(byte[] data, int pos, int length, File file) throws IOException, MasterKeyLockedException {
 		if (data != null && data.length > 0) {
 			try (FileOutputStream fileOutputStream = new FileOutputStream(file); CipherOutputStream cipherOutputStream = this.masterKey.getCipherOutputStream(fileOutputStream)) {
 				cipherOutputStream.write(data, pos, length);
diff --git a/app/src/main/java/ch/threema/app/services/GroupService.java b/app/src/main/java/ch/threema/app/services/GroupService.java
index 95cbf3f3..8db28b7a 100644
--- a/app/src/main/java/ch/threema/app/services/GroupService.java
+++ b/app/src/main/java/ch/threema/app/services/GroupService.java
@@ -25,10 +25,6 @@ import android.app.Activity;
 import android.content.Intent;
 import android.graphics.Bitmap;
 
-import androidx.annotation.IntDef;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collection;
@@ -36,15 +32,17 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.messagereceiver.GroupMessageReceiver;
-import ch.threema.app.processors.groupcontrol.IncomingGroupSetupTask;
+import ch.threema.app.processors.incomingcspmessage.groupcontrol.IncomingGroupSetupTask;
 import ch.threema.app.utils.GroupFeatureSupport;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
 import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.GroupMemberModel;
 import ch.threema.storage.models.GroupMessageModel;
 import ch.threema.storage.models.GroupModel;
 import ch.threema.storage.models.MessageState;
@@ -200,12 +198,13 @@ public interface GroupService extends AvatarService<GroupModel> {
 	) throws Exception;
 
 	/**
-	 * Add a member to a group. Will fetch the identity from the server if not known. If "block
-	 * unknown" is enabled, the contact (and group member) will not be created if not already in
-	 * contacts. Note that this does not fire any listeners nor sending any messages.
+	 * Add a member to a group. Note that the user's identity must not be added to the member list
+	 * and is therefore ignored by this method. If the contact does not exist, the identity won't be
+	 * added to the members list. Note that this does not fire any listeners nor sending any
+	 * messages.
 	 *
 	 * @return true if the identity is added or already in the group, false if no contact with this
-	 * identity exists
+	 * identity exists or it is the user's identity
 	 */
 	boolean addMemberToGroup(@NonNull GroupModel groupModel, @NonNull String identity);
 
@@ -278,35 +277,31 @@ public interface GroupService extends AvatarService<GroupModel> {
 	void leaveGroupFromLocal(@NonNull GroupModel groupModel);
 
 	/**
-	 * Return the member identities of the group except the user.
+	 * Get the group members including the group creator and the user (if the creator or user are
+	 * members).
+	 *
+	 * @param groupModel the group model
+	 * @return a list of the contact models
 	 */
 	@NonNull
-	Set<String> getOtherMembers(@NonNull GroupModel groupModel);
+	Collection<ContactModel> getMembers(@NonNull GroupModel groupModel);
 
 	/**
-	 * Return the identities of all members of this group including the creator and including the current user
+	 * Return the identities of all members of this group including the creator (if the creator has
+	 * not left the group) and the user (if the user is part of the group). To check whether the
+	 * user is a member of the group, use {@link #isGroupMember(GroupModel)}.
+	 *
 	 * @param groupModel Group model of the group
 	 * @return String array of identities (i.e. Threema IDs)
 	 */
 	@NonNull String[] getGroupIdentities(@NonNull GroupModel groupModel);
 
 	/**
-	 * Return the group member models of the group. This includes the group creator - except in
-	 * orphaned groups.
-	 *
-	 * @param groupModel the group model
-	 * @return a list of the group members
-	 */
-	List<GroupMemberModel> getGroupMemberModels(@NonNull GroupModel groupModel);
-
-	/**
-	 * Get the group members including the group creator.
-	 *
-	 * @param groupModel the group model
-	 * @return a list of the contact models
+	 * Return the member identities (including the creator if part of the group) of the group except
+	 * the user.
 	 */
 	@NonNull
-	Collection<ContactModel> getMembers(@NonNull GroupModel groupModel);
+	Set<String> getMembersWithoutUser(@NonNull GroupModel groupModel);
 
 	/**
 	 * Get a string where the group members' display names are concatenated and separated by a
@@ -344,6 +339,16 @@ public interface GroupService extends AvatarService<GroupModel> {
 	 */
 	boolean isGroupMember(@NonNull GroupModel groupModel);
 
+	/**
+	 * Check whether the given identity is part of the group. Note that the group creator is also a
+	 * member.
+	 *
+	 * @param groupModel the group model
+	 * @param identity   the identity that is checked
+	 * @return {@code true} if the identity belongs to a group member, {@code false} otherwise
+	 */
+	boolean isGroupMember(@NonNull GroupModel groupModel, @NonNull String identity);
+
 	/**
 	 * Check whether the group is orphaned or not. In an orphaned group, the group creator is not a
 	 * member. Additionally, the user must not be the creator, otherwise it is a dissolved group.
@@ -358,7 +363,7 @@ public interface GroupService extends AvatarService<GroupModel> {
 	boolean isOrphanedGroup(@NonNull GroupModel groupModel);
 
 	/**
-	 * Count members in a group. This includes the group creator.
+	 * Count members in a group. This includes the group creator and the user.
 	 *
 	 * @param groupModel the group model
 	 * @return Number of members in this group including group creator and the current user
@@ -391,7 +396,7 @@ public interface GroupService extends AvatarService<GroupModel> {
 	 * @param model the group model
 	 * @return the number of other members
 	 */
-	int getOtherMemberCount(@NonNull GroupModel model);
+	int countMembersWithoutUser(@NonNull GroupModel model);
 
 	/**
 	 * Get a map from the group member identity to its id color index.
diff --git a/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java b/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java
index 66837f22..6a44e5cb 100644
--- a/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/GroupServiceImpl.java
@@ -227,14 +227,15 @@ public class GroupServiceImpl implements GroupService {
 		String[] identities = getGroupIdentities(groupModel);
 		scheduleEmptyGroupSetup(groupModel, Set.of(identities));
 
-		// Remove me from the group members
-		removeMemberFromGroup(groupModel, userService.getIdentity());
+		// Do not remove user from members: just set the user state of the group
+		groupModel.setUserState(GroupModel.UserState.LEFT);
+		save(groupModel);
 
 		// Update the rejected message states
 		runRejectedMessagesRefreshSteps(groupModel);
 
 		// Trigger listener
-		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, myIdentity, identities.length));
+		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, myIdentity));
 		ListenerManager.groupListeners.handle(listener -> listener.onLeave(groupModel));
 	}
 
@@ -245,14 +246,14 @@ public class GroupServiceImpl implements GroupService {
 			return;
 		}
 
-		String[] identities = this.getGroupIdentities(groupModel);
+		Set<String> identities = this.getMembersWithoutUser(groupModel);
 
 		// Send group leave to all members
-		scheduleGroupLeave(groupModel, Set.of(identities));
+		scheduleGroupLeave(groupModel, identities);
 
-		// Remove only me from the members
-		String myIdentity = userService.getIdentity();
-		removeMemberFromGroup(groupModel, myIdentity);
+		// Do not remove user from members: just set the user state of the group
+		groupModel.setUserState(GroupModel.UserState.LEFT);
+		save(groupModel);
 
 		// Update the rejected message states
 		runRejectedMessagesRefreshSteps(groupModel);
@@ -264,7 +265,7 @@ public class GroupServiceImpl implements GroupService {
 		this.resetIdentityCache(groupModel.getId());
 
 		// Fire group left listener
-		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, myIdentity, identities.length));
+		ListenerManager.groupListeners.handle(listener -> listener.onMemberLeave(groupModel, userService.getIdentity()));
 		ListenerManager.groupListeners.handle(listener -> listener.onLeave(groupModel));
 		updateAllowedCallParticipants(groupModel);
 	}
@@ -486,12 +487,12 @@ public class GroupServiceImpl implements GroupService {
 			.setCreatorIdentity(creatorIdentity)
 			.setCreatedAt(now)
 			.setLastUpdate(now)
-			.setSynchronizedAt(now);
+			.setSynchronizedAt(now)
+			.setUserState(GroupModel.UserState.MEMBER);
 		this.databaseServiceNew.getGroupModelFactory().create(groupModel);
 		this.cache(groupModel);
 
-		// Add members to group (including own identity)
-		this.addMemberToGroup(groupModel, creatorIdentity);
+		// Add members to group (do not include the user's identity)
 		for (String identity : groupMemberIdentities) {
 			this.addMemberToGroup(groupModel, identity);
 		}
@@ -499,7 +500,7 @@ public class GroupServiceImpl implements GroupService {
 		// Notify listeners
 		for (String memberIdentity : groupMemberIdentities) {
 			ListenerManager.groupListeners.handle(listener ->
-				listener.onNewMember(groupModel, memberIdentity, 0)
+				listener.onNewMember(groupModel, memberIdentity)
 			);
 		}
 		ListenerManager.groupListeners.handle(listener -> listener.onCreate(groupModel));
@@ -518,6 +519,11 @@ public class GroupServiceImpl implements GroupService {
 	public boolean addMemberToGroup(@NonNull final GroupModel groupModel, @NonNull final String identity) {
 		final GroupMemberModel memberModel = this.getGroupMember(groupModel, identity);
 
+		if (userService.getIdentity().equals(identity)) {
+			logger.warn("User should not be added to member list");
+			return false;
+		}
+
 		if (memberModel == null) {
 			// Do not add the member to the group if it is already in the group or there is no contact
 			// with that ID. Note that the contacts for the valid identities have been created at this
@@ -660,15 +666,13 @@ public class GroupServiceImpl implements GroupService {
 		Set<String> kickedGroupMembers = new HashSet<>(existingMembers);
 		kickedGroupMembers.removeAll(updatedGroupMembers);
 
-		int previousMemberCount = countMembers(groupModel);
-
 		// Remove the kicked members from the database
 		for (final String kickedIdentity : kickedGroupMembers) {
 			logger.debug("Remove member {} from group", kickedIdentity);
 			removeMemberFromGroup(groupModel, kickedIdentity);
 
 			ListenerManager.groupListeners.handle(listener ->
-				listener.onMemberKicked(groupModel, kickedIdentity, previousMemberCount)
+				listener.onMemberKicked(groupModel, kickedIdentity)
 			);
 		}
 
@@ -725,6 +729,7 @@ public class GroupServiceImpl implements GroupService {
 				// If there was a change, then the method above already dealt with sending sync
 				// messages to all members (including new members).
 				sendPictureToNewMembers = false;
+                ShortcutUtil.updateShareTargetShortcut(createReceiver(groupModel));
 			}
 		}
 		if (sendPictureToNewMembers && hasNewMembers) {
@@ -742,7 +747,7 @@ public class GroupServiceImpl implements GroupService {
 		// members and must therefore be called *after* the group setup has been sent.
 		for (String newMember : newMembers) {
 			ListenerManager.groupListeners.handle(listener ->
-				listener.onNewMember(groupModel, newMember, previousMemberCount)
+				listener.onNewMember(groupModel, newMember)
 			);
 		}
 
@@ -960,7 +965,7 @@ public class GroupServiceImpl implements GroupService {
 
 	@NonNull
 	@Override
-	public Set<String> getOtherMembers(@NonNull GroupModel groupModel) {
+	public Set<String> getMembersWithoutUser(@NonNull GroupModel groupModel) {
 		Set<String> otherMembers = new HashSet<>(Arrays.asList(getGroupIdentities(groupModel)));
 		otherMembers.remove(userService.getIdentity());
 		return otherMembers;
@@ -976,9 +981,23 @@ public class GroupServiceImpl implements GroupService {
 			}
 
 			List<GroupMemberModel> memberModels = this.getGroupMemberModels(groupModel);
-			String[] res = new String[memberModels.size()];
+			boolean isGroupMember = isGroupMember(groupModel);
+
+			String[] res;
+			int arrayIndexOffset;
+			if (isGroupMember) {
+				res = new String[memberModels.size() + 1];
+				arrayIndexOffset = 1;
+				// Include the user in the array if it is a member. Note that this is required as the
+				// user is never stored as a group member.
+				res[0] = userService.getIdentity();
+			} else {
+				res = new String[memberModels.size()];
+				arrayIndexOffset = 0;
+			}
+
 			for (int i = 0; i < memberModels.size(); i++) {
-				res[i] = memberModels.get(i).getIdentity();
+				res[i + arrayIndexOffset] = memberModels.get(i).getIdentity();
 			}
 
 			this.groupIdentityCache.put(groupModel.getId(), res);
@@ -986,8 +1005,18 @@ public class GroupServiceImpl implements GroupService {
 		}
 	}
 
-	private boolean isGroupMember(@NonNull GroupModel groupModel, @Nullable String identity) {
+	@Override
+	public boolean isGroupMember(@NonNull GroupModel groupModel) {
+		return groupModel.getUserState() == GroupModel.UserState.MEMBER;
+	}
+
+	@Override
+	public boolean isGroupMember(@NonNull GroupModel groupModel, @Nullable String identity) {
 		if (!TestUtil.isEmptyOrNull(identity)) {
+			if (userService.getIdentity().equals(identity)) {
+				return isGroupMember(groupModel);
+			}
+
 			for (String existingIdentity : this.getGroupIdentities(groupModel)) {
 				if (TestUtil.compare(existingIdentity, identity)) {
 					return true;
@@ -997,21 +1026,29 @@ public class GroupServiceImpl implements GroupService {
 		return false;
 	}
 
-	@Override
-	public boolean isGroupMember(@NonNull GroupModel groupModel) {
-		return isGroupMember(groupModel, userService.getIdentity());
-	}
-
 	@Override
 	public boolean isOrphanedGroup(@NonNull GroupModel groupModel) {
 		return !isGroupMember(groupModel, groupModel.getCreatorIdentity()) && !isGroupCreator(groupModel);
 	}
 
-	@Override
-	public List<GroupMemberModel> getGroupMemberModels(@NonNull GroupModel groupModel) {
-		return this.databaseServiceNew.getGroupMemberModelFactory().getByGroupId(
-			groupModel.getId()
-		);
+	/**
+	 * Get the group member models of the given group. Note that the user is not part of this list.
+	 */
+	private List<GroupMemberModel> getGroupMemberModels(@NonNull GroupModel groupModel) {
+		List<GroupMemberModel> groupMemberModels = databaseServiceNew
+			.getGroupMemberModelFactory()
+			.getByGroupId(groupModel.getId());
+
+		// Remove own identity. Note that the user's identity should never be stored as member.
+		// This is just a check to ensure correct behavior even if the member list is wrong.
+		String myIdentity = userService.getIdentity();
+		if (groupMemberModels.removeIf(
+			groupMemberModel -> myIdentity.equals(groupMemberModel.getIdentity())
+		)) {
+			logger.warn("User is contained as member in group");
+		}
+
+		return groupMemberModels;
 	}
 
 	/**
@@ -1094,11 +1131,6 @@ public class GroupServiceImpl implements GroupService {
 		return ColorUtil.getInstance().getCurrentThemeGray(this.context);
 	}
 
-	@Override
-	public void clearAvatarCache(@NonNull GroupModel model) {
-		avatarCacheService.reset(model);
-	}
-
 	@Override
 	public boolean isGroupCreator(GroupModel groupModel) {
 		return groupModel != null
@@ -1114,7 +1146,8 @@ public class GroupServiceImpl implements GroupService {
 				return existingIdentities.length;
 			}
 		}
-		return (int) this.databaseServiceNew.getGroupMemberModelFactory().countMembers(groupModel.getId());
+		int userMemberCount = groupModel.getUserState() == GroupModel.UserState.MEMBER ? 1 : 0;
+		return (int) this.databaseServiceNew.getGroupMemberModelFactory().countMembersWithoutUser(groupModel.getId()) + userMemberCount;
 	}
 
 	@Override
@@ -1125,15 +1158,10 @@ public class GroupServiceImpl implements GroupService {
 	}
 
 	@Override
-	public int getOtherMemberCount(@NonNull GroupModel groupModel) {
-		int count = 0;
-		String[] identities = this.getGroupIdentities(groupModel);
-		for (String identity : identities) {
-			if (!this.userService.isMe(identity)) {
-				count++;
-			}
-		}
-		return count;
+	public int countMembersWithoutUser(@NonNull GroupModel groupModel) {
+		return (int) this.databaseServiceNew
+			.getGroupMemberModelFactory()
+			.countMembersWithoutUser(groupModel.getId());
 	}
 
 	@Override
@@ -1333,7 +1361,7 @@ public class GroupServiceImpl implements GroupService {
 					false,
 					R.string.you_are_not_a_member_of_this_group
 				));
-			} else if (getOtherMemberCount(groupModel) <= 0 && !allowEmpty) {
+			} else if (countMembersWithoutUser(groupModel) <= 0 && !allowEmpty) {
 				// Don't allow sending in empty groups (except allowEmpty is true)
 				groupAccessModel.setCanReceiveMessageAccess(new Access(
 					false,
@@ -1440,7 +1468,7 @@ public class GroupServiceImpl implements GroupService {
 		return new GroupFeatureSupport(
 			feature,
 			new ArrayList<>(
-				OutgoingCspMessageUtilsKt.filterBroadcastIdentity(getMembers(groupModel), groupModel)
+				OutgoingCspMessageUtilsKt.removeCreatorIfRequired(getMembers(groupModel), groupModel)
 					.stream().filter((member) -> !userService.isMe(member.getIdentity())).collect(Collectors.toList())
 			)
 		);
diff --git a/app/src/main/java/ch/threema/app/services/IdListService.java b/app/src/main/java/ch/threema/app/services/IdListService.java
index 6478bd04..01d60861 100644
--- a/app/src/main/java/ch/threema/app/services/IdListService.java
+++ b/app/src/main/java/ch/threema/app/services/IdListService.java
@@ -32,6 +32,6 @@ public interface IdListService {
 	void toggle(Context context, ContactModel contactModel);
 
 	String[] getAll();
-	void addAll(String[] ids);
 	void removeAll();
+    void replaceAll(String[] ids);
 }
diff --git a/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java b/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java
index c10dd09b..ce011b07 100644
--- a/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/IdListServiceImpl.java
@@ -28,94 +28,93 @@ import java.util.Arrays;
 import java.util.List;
 
 import ch.threema.app.R;
-import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.storage.models.ContactModel;
 
 public class IdListServiceImpl implements IdListService {
-	private final Object lock = new Object();
-	private String[] ids;
-	private final String uniqueListName;
-	private final PreferenceService preferenceService;
+    private final Object lock = new Object();
+    private String[] ids;
+    private final String uniqueListName;
+    private final PreferenceService preferenceService;
 
-	public IdListServiceImpl(String uniqueListName, PreferenceService preferenceService) {
-		this.uniqueListName = uniqueListName;
-		this.preferenceService = preferenceService;
-		this.ids = preferenceService.getList(this.uniqueListName);
-	}
+    public IdListServiceImpl(String uniqueListName, PreferenceService preferenceService) {
+        this.uniqueListName = uniqueListName;
+        this.preferenceService = preferenceService;
+        this.ids = preferenceService.getList(this.uniqueListName);
+    }
 
-	@Override
-	public boolean has(String id) {
-		if(this.ids != null) {
-			synchronized (this.lock) {
-				return Arrays.asList(this.ids).contains(id);
-			}
-		}
-		return false;
-	}
+    @Override
+    public boolean has(String id) {
+        if (this.ids != null) {
+            synchronized (this.lock) {
+                return Arrays.asList(this.ids).contains(id);
+            }
+        }
+        return false;
+    }
 
-	@Override
-	public void remove(String id) {
-		if(this.ids != null) {
-			synchronized (this.lock) {
-				List<String> idList = Arrays.asList(this.ids);
-				if(idList.contains(id)) {
-					String[] newIdentities = new String[idList.size()-1];
-					int pos = 0;
-					for(String other: idList) {
-						if(other != null && !other.equals(id)) {
-							newIdentities[pos++] = other;
-						}
-					}
-					this.preferenceService.setList(this.uniqueListName, newIdentities);
-					this.ids = newIdentities;
-				}
-			}
-		}
-	}
+    @Override
+    public void remove(String id) {
+        if (this.ids != null) {
+            synchronized (this.lock) {
+                List<String> idList = Arrays.asList(this.ids);
+                if (idList.contains(id)) {
+                    String[] newIdentities = new String[idList.size() - 1];
+                    int pos = 0;
+                    for (String other : idList) {
+                        if (other != null && !other.equals(id)) {
+                            newIdentities[pos++] = other;
+                        }
+                    }
+                    this.preferenceService.setList(this.uniqueListName, newIdentities);
+                    this.ids = newIdentities;
+                }
+            }
+        }
+    }
 
-	@Override
-	public void add(String id) {
-		if(this.ids != null && (id != null && id.length() > 0)) {
-			synchronized (this.lock) {
-				List<String> idList = Arrays.asList(this.ids);
-				if(!idList.contains(id)) {
-					this.ids = Arrays.copyOf(this.ids, this.ids.length + 1);
-					this.ids[ids.length-1] = id;
-					this.preferenceService.setList(this.uniqueListName, ids);
-				}
-			}
-		}
-	}
+    @Override
+    public void add(String id) {
+        if (this.ids != null && (id != null && !id.isEmpty())) {
+            synchronized (this.lock) {
+                List<String> idList = Arrays.asList(this.ids);
+                if (!idList.contains(id)) {
+                    this.ids = Arrays.copyOf(this.ids, this.ids.length + 1);
+                    this.ids[ids.length - 1] = id;
+                    this.preferenceService.setList(this.uniqueListName, ids);
+                }
+            }
+        }
+    }
 
-	@Override
-	public void toggle(Context context, final ContactModel contactModel) {
-		String identity = contactModel.getIdentity();
+    @Override
+    public void toggle(Context context, final ContactModel contactModel) {
+        String identity = contactModel.getIdentity();
 
-		if (this.has(identity)) {
-			this.remove(identity);
-			Toast.makeText(context, context.getString(R.string.contact_now_unblocked), Toast.LENGTH_SHORT).show();
-		} else {
-			IdListServiceImpl.this.add(contactModel.getIdentity());
-			Toast.makeText(context, context.getString(R.string.contact_now_blocked), Toast.LENGTH_SHORT).show();
-		}
-		ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
-	}
+        if (this.has(identity)) {
+            this.remove(identity);
+            Toast.makeText(context, context.getString(R.string.contact_now_unblocked), Toast.LENGTH_SHORT).show();
+        } else {
+            IdListServiceImpl.this.add(contactModel.getIdentity());
+            Toast.makeText(context, context.getString(R.string.contact_now_blocked), Toast.LENGTH_SHORT).show();
+        }
+        ListenerManager.contactListeners.handle(listener -> listener.onModified(identity));
+    }
 
-	@Override
-	public synchronized String[] getAll() {
-		return this.ids;
-	}
+    @Override
+    public synchronized String[] getAll() {
+        return this.ids;
+    }
 
-	@Override
-	public void addAll(String[] ids) {
-		this.ids = ids;
-		this.preferenceService.setList(this.uniqueListName, this.ids);
-	}
+    @Override
+    public void removeAll() {
+        this.ids = new String[0];
+        this.preferenceService.setList(this.uniqueListName, this.ids);
+    }
 
-	@Override
-	public void removeAll() {
-		this.ids = new String[0];
-		this.preferenceService.setList(this.uniqueListName, this.ids);
-	}
+    @Override
+    public void replaceAll(String[] ids) {
+        this.ids = ids;
+        this.preferenceService.setList(this.uniqueListName, this.ids);
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/MessageSendingService.java b/app/src/main/java/ch/threema/app/services/MessageSendingService.java
index a589fbbe..584aad1a 100644
--- a/app/src/main/java/ch/threema/app/services/MessageSendingService.java
+++ b/app/src/main/java/ch/threema/app/services/MessageSendingService.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.services;
 
-import androidx.annotation.NonNull;
-
 import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.storage.models.AbstractMessageModel;
 
diff --git a/app/src/main/java/ch/threema/app/services/MessageService.java b/app/src/main/java/ch/threema/app/services/MessageService.java
index 574e63af..3957ca62 100644
--- a/app/src/main/java/ch/threema/app/services/MessageService.java
+++ b/app/src/main/java/ch/threema/app/services/MessageService.java
@@ -47,12 +47,12 @@ import ch.threema.app.ui.MediaItem;
 import ch.threema.app.voip.groupcall.GroupCallDescription;
 import ch.threema.base.ProgressListener;
 import ch.threema.base.ThreemaException;
+import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
 import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage;
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage;
+import ch.threema.domain.protocol.csp.messages.file.FileData;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.DistributionListMessageModel;
@@ -267,35 +267,44 @@ public interface MessageService {
     @WorkerThread
     boolean sendUserDecline(@NonNull AbstractMessageModel messageModel, boolean markAsRead);
 
-    void updateMessageState(@NonNull final MessageId apiMessageId, MessageState state, @NonNull DeliveryReceiptMessage stateMessage);
-
-    void updateGroupMessageState(@NonNull final MessageId apiMessageId, @NonNull MessageState state, @NonNull GroupDeliveryReceiptMessage stateMessage);
-
-    /**
-     * Update the message state of a contact message. Currently only used for server acks.
-     *
-     * @param messageId         the message id of the message
-     * @param recipientIdentity the recipient of the message
-     * @param state             the new state
-     * @param stateDate         the date of state change
-     */
-    boolean updateContactMessageState(
-        @NonNull final MessageId messageId,
-        @NonNull String recipientIdentity,
-        @NonNull MessageState state,
-        @Nullable Date stateDate
-    );
-
-    /**
-     * Update message state of outgoing message. Currently only used for server acks.
-     *
-     * @param messageModel the message model that should be updated
-     * @param state        the mew state
-     * @param stateDate    the date of state change
-     */
-    boolean updateMessageState(@NonNull final AbstractMessageModel messageModel, @NonNull MessageState state, @Nullable Date stateDate);
-
-    boolean markAsRead(AbstractMessageModel message, boolean silent) throws ThreemaException;
+	/**
+	 * Update message state of an outgoing message. Note that the state is only changed if it is a
+	 * legal transition. E.g. a message's state won't be changed from read to delivered. See
+	 * {@link ch.threema.app.utils.MessageUtil#canChangeToState(MessageState, MessageState, boolean)}
+	 * for possible state transitions.
+	 *
+	 * The corresponding timestamps are changed in any case. E.g. the delivered at timestamp will be
+	 * saved even if the message has already been marked as read.
+	 *
+	 * Do not use this method for reactions: Use
+	 * {@link #addMessageReaction(AbstractMessageModel, MessageState, String, Date)} instead.
+	 *
+	 * @param messageModel the message model that should be updated
+	 * @param state        the mew state
+	 * @param date         the date of the state change
+	 */
+	void updateOutgoingMessageState(
+		@NonNull final AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull Date date
+	);
+
+	/**
+	 * Add a reaction to a contact or group message.
+	 *
+	 * @param messageModel the message model that should be updated
+	 * @param state        the reaction (as state, but only ACK and DEC allowed)
+	 * @param fromIdentity the identity that reacted to the message
+	 * @param date         the date of the state change
+	 */
+	void addMessageReaction(
+		@NonNull AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull String fromIdentity,
+		@NonNull Date date
+	);
+
+	boolean markAsRead(AbstractMessageModel message, boolean silent) throws ThreemaException;
 
     @WorkerThread
     boolean markAsConsumed(AbstractMessageModel message) throws ThreemaException;
@@ -354,12 +363,34 @@ public interface MessageService {
     @Nullable
     DistributionListMessageModel getDistributionListMessageModel(long id);
 
-    MessageString getMessageString(AbstractMessageModel messageModel, int maxLength);
-
-    MessageString getMessageString(AbstractMessageModel messageModel, int maxLength, boolean withPrefix);
+	/**
+	 * Get the contact message model by message id and identity.
+	 */
+	@Nullable
+	MessageModel getContactMessageModel(
+		@NonNull final MessageId messageId,
+		@NonNull final String identity
+	);
+
+	/**
+	 * Get the group message model by message id, creator identity, and group id.
+	 */
+	@Nullable
+	GroupMessageModel getGroupMessageModel(
+		@NonNull MessageId messageId,
+		@NonNull String creatorIdentity,
+		@NonNull GroupId groupId
+	);
+
+	MessageString getMessageString(AbstractMessageModel messageModel, int maxLength);
+	MessageString getMessageString(AbstractMessageModel messageModel, int maxLength, boolean withPrefix);
 
     void saveIncomingServerMessage(ServerMessageModel msg);
 
+    boolean downloadThumbnailIfPresent(@NonNull FileData fileData, @NonNull AbstractMessageModel messageModel) throws Exception;
+
+    boolean shouldAutoDownload(@NonNull AbstractMessageModel messageModel);
+
     boolean downloadMediaMessage(AbstractMessageModel mediaMessageModel, ProgressListener progressListener) throws Exception;
 
     boolean cancelMessageDownload(AbstractMessageModel messageModel);
diff --git a/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java b/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java
index 62f2317f..60672150 100644
--- a/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/MessageServiceImpl.java
@@ -21,21 +21,6 @@
 
 package ch.threema.app.services;
 
-import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE;
-import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE_MB;
-import static ch.threema.app.services.PreferenceService.ImageScale_DEFAULT;
-import static ch.threema.app.ui.MediaItem.TIME_UNDEFINED;
-import static ch.threema.app.ui.MediaItem.TYPE_FILE;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_ANIMATED;
-import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_CAM;
-import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
-import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
-import static ch.threema.app.ui.MediaItem.TYPE_VIDEO;
-import static ch.threema.app.ui.MediaItem.TYPE_VIDEO_CAM;
-import static ch.threema.app.ui.MediaItem.TYPE_VOICEMESSAGE;
-import static ch.threema.domain.protocol.csp.messages.file.FileData.RENDERING_STICKER;
-
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.ActivityNotFoundException;
@@ -104,6 +89,7 @@ import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.messagereceiver.DistributionListMessageReceiver;
 import ch.threema.app.messagereceiver.GroupMessageReceiver;
 import ch.threema.app.messagereceiver.MessageReceiver;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.routines.ReadMessagesRoutine;
 import ch.threema.app.services.ballot.BallotService;
 import ch.threema.app.services.ballot.BallotUpdateResult;
@@ -115,6 +101,7 @@ import ch.threema.app.ui.MediaItem;
 import ch.threema.app.utils.BallotUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.ExifInterface;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.GeoLocationUtil;
@@ -124,7 +111,6 @@ import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.utils.QuoteUtil;
 import ch.threema.app.utils.RuntimeUtil;
-import ch.threema.app.utils.StreamUtil;
 import ch.threema.app.utils.StringConversionUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.ThumbnailUtil;
@@ -141,6 +127,7 @@ import ch.threema.base.utils.Utils;
 import ch.threema.data.repositories.EditHistoryRepository;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.MessageId;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.blob.BlobUploader;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
@@ -149,10 +136,8 @@ import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.AudioMessage;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
 import ch.threema.domain.protocol.csp.messages.DeleteMessage;
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage;
 import ch.threema.domain.protocol.csp.messages.EditMessage;
 import ch.threema.domain.protocol.csp.messages.GroupAudioMessage;
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage;
 import ch.threema.domain.protocol.csp.messages.GroupImageMessage;
 import ch.threema.domain.protocol.csp.messages.GroupLocationMessage;
 import ch.threema.domain.protocol.csp.messages.GroupTextMessage;
@@ -161,13 +146,10 @@ import ch.threema.domain.protocol.csp.messages.ImageMessage;
 import ch.threema.domain.protocol.csp.messages.LocationMessage;
 import ch.threema.domain.protocol.csp.messages.TextMessage;
 import ch.threema.domain.protocol.csp.messages.VideoMessage;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotCreateInterface;
+import ch.threema.domain.protocol.csp.messages.ballot.BallotSetupInterface;
 import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.file.FileData;
-import ch.threema.domain.protocol.csp.messages.file.FileMessage;
-import ch.threema.domain.protocol.csp.messages.file.FileMessageInterface;
-import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.GroupMessageModelFactory;
@@ -197,6 +179,22 @@ import ch.threema.storage.models.data.status.GroupCallStatusDataModel;
 import ch.threema.storage.models.data.status.GroupStatusDataModel;
 import ch.threema.storage.models.data.status.VoipStatusDataModel;
 
+import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE;
+import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE_MB;
+import static ch.threema.app.services.PreferenceService.ImageScale_DEFAULT;
+import static ch.threema.app.ui.MediaItem.TIME_UNDEFINED;
+import static ch.threema.app.ui.MediaItem.TYPE_FILE;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_ANIMATED;
+import static ch.threema.app.ui.MediaItem.TYPE_IMAGE_CAM;
+import static ch.threema.app.ui.MediaItem.TYPE_LOCATION;
+import static ch.threema.app.ui.MediaItem.TYPE_TEXT;
+import static ch.threema.app.ui.MediaItem.TYPE_VIDEO;
+import static ch.threema.app.ui.MediaItem.TYPE_VIDEO_CAM;
+import static ch.threema.app.ui.MediaItem.TYPE_VOICEMESSAGE;
+import static ch.threema.app.utils.StreamUtilKt.getFromUri;
+import static ch.threema.domain.protocol.csp.messages.file.FileData.RENDERING_STICKER;
+
 public class MessageServiceImpl implements MessageService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("MessageServiceImpl");
 
@@ -226,6 +224,9 @@ public class MessageServiceImpl implements MessageService {
     // Repositories
     private final EditHistoryRepository editHistoryRepository;
 
+    // Managers
+    private final MultiDeviceManager multiDeviceManager;
+
 	// Caches
 	private final Collection<MessageModel> contactMessageCache;
 	private final Collection<GroupMessageModel> groupMessageCache;
@@ -234,23 +235,24 @@ public class MessageServiceImpl implements MessageService {
 	private final SparseIntArray loadingProgress = new SparseIntArray();
 
 	public MessageServiceImpl(
-		Context context,
-	    CacheService cacheService,
-	    DatabaseServiceNew databaseServiceNew,
-	    ContactService contactService,
-	    FileService fileService,
-	    IdentityStore identityStore,
-	    SymmetricEncryptionService symmetricEncryptionService,
-	    PreferenceService preferenceService,
-	    LockAppService appLockService,
-	    BallotService ballotService,
-	    GroupService groupService,
-	    ApiService apiService,
-	    DownloadService downloadService,
-	    DeadlineListService hiddenChatsListService,
-	    IdListService blockedContactsService,
-        EditHistoryRepository editHistoryRepository
-	) {
+        Context context,
+        CacheService cacheService,
+        DatabaseServiceNew databaseServiceNew,
+        ContactService contactService,
+        FileService fileService,
+        IdentityStore identityStore,
+        SymmetricEncryptionService symmetricEncryptionService,
+        PreferenceService preferenceService,
+        LockAppService appLockService,
+        BallotService ballotService,
+        GroupService groupService,
+        ApiService apiService,
+        DownloadService downloadService,
+        DeadlineListService hiddenChatsListService,
+        IdListService blockedContactsService,
+        EditHistoryRepository editHistoryRepository,
+        MultiDeviceManager multiDeviceManager
+    ) {
 		this.context = context;
 		this.databaseServiceNew = databaseServiceNew;
 		this.contactService = contactService;
@@ -271,14 +273,15 @@ public class MessageServiceImpl implements MessageService {
 		distributionListMessageCache = cacheService.getDistributionListMessageCache();
 
         this.editHistoryRepository = editHistoryRepository;
+        this.multiDeviceManager = multiDeviceManager;
 
-		// init queue
+        // init queue
 		messageSendingService = new MessageSendingServiceExponentialBackOff(new MessageSendingService.MessageSendingServiceState() {
 			@Override
 			public void processingFailed(AbstractMessageModel messageModel, MessageReceiver<AbstractMessageModel> receiver) {
 				//remove send machine
 				removeSendMachine(messageModel);
-				updateMessageState(messageModel, MessageState.SENDFAILED, null);
+				updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 			}
 
 			@Override
@@ -511,7 +514,7 @@ public class MessageServiceImpl implements MessageService {
 		// If the referred message has been sent (`sent-at`) more than 6 hours ago,
 		//  prevent creation and abort these steps.
 		if (deltaTime > EditMessage.EDIT_MESSAGES_MAX_AGE) {
-			logger.error("Cannot edit message older than {}}ms", EditMessage.EDIT_MESSAGES_MAX_AGE);
+			logger.error("Cannot edit message older than {}ms", EditMessage.EDIT_MESSAGES_MAX_AGE);
 			return;
 		}
 
@@ -726,7 +729,7 @@ public class MessageServiceImpl implements MessageService {
 			return;
 		}
 
-		updateMessageState(messageModel, MessageState.SENDING, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDING, new Date());
 		fireOnModifiedMessage(messageModel);
 	}
 
@@ -752,7 +755,7 @@ public class MessageServiceImpl implements MessageService {
 			return;
 		}
 
-		updateMessageState(messageModel, MessageState.SENDING, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDING, new Date());
 		fireOnModifiedMessage(messageModel);
 		if (completionHandler != null) {
 			completionHandler.sendQueued(messageModel);
@@ -773,7 +776,7 @@ public class MessageServiceImpl implements MessageService {
 			throw new ThreemaException("Message file not present");
 		}
 
-		updateMessageState(messageModel, MessageState.PENDING, new Date());
+		updateOutgoingMessageState(messageModel, MessageState.PENDING, new Date());
 
 		//enqueue processing and uploading stuff...
 		messageSendingService.addToQueue(new MessageSendingService.MessageSendingProcess() {
@@ -841,8 +844,12 @@ public class MessageServiceImpl implements MessageService {
 					})
 					.next(() -> {
 						// upload (encrypted) file data
-						BlobUploader blobUploader = initUploader(getMessageModel(), contentEncryptResult.getData());
-						blobUploader.setProgressListener(new ProgressListener() {
+						BlobUploader blobUploader = initUploader(
+                            getMessageModel(),
+                            contentEncryptResult.getData(),
+                            getReceiver()
+                        );
+						blobUploader.progressListener = new ProgressListener() {
 							@Override
 							public void updateProgress(int progress) {
 								updateMessageLoadingProgress(messageModel, progress);
@@ -852,7 +859,7 @@ public class MessageServiceImpl implements MessageService {
 							public void onFinished(boolean success) {
 								setMessageLoadingFinished(messageModel);
 							}
-						});
+						};
 						blobId = blobUploader.upload();
 					})
 					.next(() -> {
@@ -863,8 +870,12 @@ public class MessageServiceImpl implements MessageService {
 							if (thumbnailEncryptResult.isEmpty()) {
 								throw new ThreemaException("Thumbnail encryption failed");
 							} else {
-								BlobUploader blobUploader = initUploader(getMessageModel(), thumbnailEncryptResult.getData());
-								blobUploader.setProgressListener(new ProgressListener() {
+								BlobUploader blobUploader = initUploader(
+                                    getMessageModel(),
+                                    thumbnailEncryptResult.getData(),
+                                    getReceiver()
+                                );
+								blobUploader.progressListener = new ProgressListener() {
 									@Override
 									public void updateProgress(int progress) {
 										updateMessageLoadingProgress(messageModel, progress);
@@ -874,7 +885,7 @@ public class MessageServiceImpl implements MessageService {
 									public void onFinished(boolean success) {
 										setMessageLoadingFinished(messageModel);
 									}
-								});
+								};
 								blobIdThumbnail = blobUploader.upload();
 							}
 						}
@@ -892,7 +903,7 @@ public class MessageServiceImpl implements MessageService {
 						save(messageModel);
 					})
 					.next(() -> {
-						updateMessageState(messageModel, MessageState.SENDING, null);
+						updateOutgoingMessageState(messageModel, MessageState.SENDING, new Date());
 
 						if (completionHandler != null)
 							completionHandler.sendComplete(messageModel);
@@ -946,7 +957,7 @@ public class MessageServiceImpl implements MessageService {
 		if(!TestUtil.required(messageModel, ballotModel, receiver)) {
 			return;
 		}
-		updateMessageState(messageModel, MessageState.PENDING, new Date());
+		updateOutgoingMessageState(messageModel, MessageState.PENDING, new Date());
 		try {
 			ballotService.publish(receiver, ballotModel, messageModel);
 		}
@@ -957,7 +968,7 @@ public class MessageServiceImpl implements MessageService {
 				fireOnRemovedMessage(messageModel);
 				throw new MessageTooLongException();
 			} else {
-				updateMessageState(messageModel, MessageState.SENDFAILED, new Date());
+				updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 			}
 		}
 	}
@@ -995,7 +1006,8 @@ public class MessageServiceImpl implements MessageService {
 
 		contactService.createReceiver(contactModel).sendDeliveryReceipt(
 			type,
-			new MessageId[]{MessageId.fromString(messageModel.getApiMessageId())}
+			new MessageId[]{MessageId.fromString(messageModel.getApiMessageId())},
+			new Date().getTime()
 		);
 		return true;
 	}
@@ -1056,42 +1068,53 @@ public class MessageServiceImpl implements MessageService {
 		return false;
 	}
 
-	private AbstractMessageModel getAbstractMessageModelByApiIdAndIdentity(final MessageId apiMessageId, final String identity) {
-		//contact message cache
+	@Nullable
+	@Override
+	public MessageModel getContactMessageModel(
+		@NonNull final MessageId apiMessageId,
+		@NonNull final String identity
+	) {
+		// Check contact message cache first
 		synchronized (contactMessageCache) {
-			AbstractMessageModel messageModel = Functional.select(contactMessageCache, m -> m.getApiMessageId() != null
+			MessageModel messageModel = Functional.select(contactMessageCache, m -> m.getApiMessageId() != null
 				&& m.getApiMessageId().equals(apiMessageId.toString())
 				&& TestUtil.compare(m.getIdentity(), identity));
-			if(messageModel != null) {
+			if (messageModel != null) {
 				return messageModel;
 			}
 		}
 
+		// If not cached, load from database (and cache it)
 		MessageModel contactMessageModel = databaseServiceNew.getMessageModelFactory().getByApiMessageIdAndIdentity(
 				apiMessageId,
 				identity);
-		if(contactMessageModel != null) {
+		if (contactMessageModel != null) {
 			cache(contactMessageModel);
-			return contactMessageModel;
 		}
-		return null;
+
+		return contactMessageModel;
 	}
 
 	/**
-	 * Get the AbstractMessageModel of a group message referenced by apiMessageId, apiGroupId and creatorId
-	 * @param apiMessageId the message
-	 * @param apiGroupId the group id
+	 * Get the AbstractMessageModel of a group message referenced by messageId, creatorId, and groupId
+	 * @param messageId the message
 	 * @param creatorIdentity the creator of the group
+	 * @param groupId the group id
 	 * @return a GroupMessageModel of the matching message or null in case a message could not be found
 	 */
+	@Override
 	@Nullable
-	private GroupMessageModel getGroupMessageModel(@NonNull final MessageId apiMessageId, @NonNull final GroupId apiGroupId, @NonNull String creatorIdentity) {
-		String apiMessageIdString = apiMessageId.toString();
+	public GroupMessageModel getGroupMessageModel(
+		@NonNull final MessageId messageId,
+		@NonNull final String creatorIdentity,
+		@NonNull final GroupId groupId
+	) {
+		String apiMessageIdString = messageId.toString();
 		if (apiMessageIdString == null) {
 			return null;
 		}
 
-		GroupModel groupModel = groupService.getByApiGroupIdAndCreator(apiGroupId, creatorIdentity);
+		GroupModel groupModel = groupService.getByApiGroupIdAndCreator(groupId, creatorIdentity);
 		if (groupModel == null) {
 			return null;
 		}
@@ -1106,7 +1129,7 @@ public class MessageServiceImpl implements MessageService {
 
 		// retrieve from database
 		GroupMessageModel groupMessageModel = databaseServiceNew.getGroupMessageModelFactory().getByApiMessageIdAndGroupId(
-				apiMessageId,
+				messageId,
 				groupModel.getId());
 
 		if (groupMessageModel != null) {
@@ -1118,96 +1141,115 @@ public class MessageServiceImpl implements MessageService {
 	}
 
 	@Override
-	public void updateMessageState(@NonNull final MessageId apiMessageId,
-	                               MessageState state,
-	                               @NonNull DeliveryReceiptMessage stateMessage) {
+	public void updateOutgoingMessageState(
+		@NonNull AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull Date date
+	) {
+		if (!messageModel.isOutbox()) {
+			throw new IllegalArgumentException("Updating outgoing message state on incoming message " + messageModel.getApiMessageId());
+		}
 
-		AbstractMessageModel messageModel = getAbstractMessageModelByApiIdAndIdentity(apiMessageId, stateMessage.getFromIdentity());
-		if (messageModel != null && !messageModel.isDeleted()) {
-			updateMessageState(messageModel, state, stateMessage.getDate());
+		if (MessageUtil.isReaction(state)) {
+			throw new IllegalArgumentException("The given message state is a reaction: " + state);
 		}
-	}
 
-	/**
-	 * Update the message state for the message referenced by the supplied apiMessageId
-	 * @param apiMessageId apiMessageID of the message whose state needs to be changed
-	 * @param state new state
-	 * @param stateMessage incoming message that contains the state information
-	 */
-	@Override
-	public void updateGroupMessageState(@NonNull MessageId apiMessageId,
-										@NonNull MessageState state,
-										@NonNull GroupDeliveryReceiptMessage stateMessage) {
-		if (!MessageUtil.isAllowedGroupMessageState(state)) {
+		if (messageModel.isDeleted()) {
 			return;
 		}
 
-		GroupMessageModel messageModel = getGroupMessageModel(apiMessageId, stateMessage.getApiGroupId(), stateMessage.getGroupCreator());
-		if (messageModel != null && !messageModel.isDeleted()) {
-			updateGroupMessageState(messageModel, stateMessage, state);
-		}
-	}
+		synchronized (this) {
+			logger.debug(
+				"Updating message state from {} to {} at {}",
+				messageModel.getState(), state, date.getTime()
+			);
 
-	@Override
-	public boolean updateContactMessageState(
-		@NonNull MessageId messageId,
-		@NonNull String recipientIdentity,
-		@NonNull MessageState state,
-		@Nullable Date date
-	) {
-		AbstractMessageModel messageModel = getAbstractMessageModelByApiIdAndIdentity(messageId, recipientIdentity);
-		if (messageModel != null) {
-			return updateMessageState(messageModel, state, date);
-		}
-		return false;
-	}
+			boolean hasChanges = true;
+
+			// Save date of state change
+			switch (state) {
+				case SENT:
+					// Note that we do not check whether the posted at time already exists as this
+					// value is already set when the message model has been created. We just update
+					// it when the message actually has been sent.
+					messageModel.setPostedAt(date);
+					messageModel.setModifiedAt(date);
+					break;
+				case DELIVERED:
+					if (messageModel.getDeliveredAt() != null) {
+						logger.warn("'Delivered at' already set for message {}", messageModel.getApiMessageId());
+					}
+					messageModel.setDeliveredAt(date);
+					messageModel.setModifiedAt(date);
+					break;
+				case READ:
+					if (messageModel.getReadAt() != null) {
+						logger.warn("'Read at' already set for message {}", messageModel.getApiMessageId());
+					}
+					messageModel.setReadAt(date);
+					messageModel.setModifiedAt(date);
+					break;
+				case SENDFAILED:
+				case FS_KEY_MISMATCH:
+				case CONSUMED:
+					messageModel.setModifiedAt(date);
+					break;
+				default:
+					hasChanges = false;
+			}
 
-	@Override
-	public boolean updateMessageState(
-		@NonNull AbstractMessageModel messageModel,
-		@NonNull MessageState state,
-		@Nullable Date stateDate
-	) {
-		synchronized (this) {
-			logger.debug("Updating message state from {} to {} (outbox={})", messageModel.getState(), state, messageModel.isOutbox());
-			if (MessageUtil.canChangeToState(messageModel.getState(), state, messageModel.isOutbox())) {
+			// Change the state only if it is possible
+			if (MessageUtil.canChangeToState(messageModel.getState(), state, messageModel instanceof GroupMessageModel)) {
 				messageModel.setState(state);
-				if (stateDate != null) {
-					messageModel.setModifiedAt(stateDate);
-				}
+				hasChanges = true;
+			} else {
+				logger.warn(
+					"State transition from {} to {}, ignoring",
+					messageModel.getState(), state
+				);
+			}
+
+			if (hasChanges) {
 				save(messageModel);
 				fireOnModifiedMessage(messageModel);
-				return true;
-			} else {
-				logger.warn("State transition from {} to {} (outbox={}), ignoring",
-					messageModel.getState(), state, messageModel.isOutbox());
-				return false;
 			}
 		}
 	}
 
-	/**
-	 * Update message states for group messages. Currently, only ACK and DEC are supported
-	 * @param messageModel Group Message to update
-	 * @param stateMessage Message of delivery receipt
-	 * @param newState Desired new state
-	 */
-	private void updateGroupMessageState(
-		@NonNull GroupMessageModel messageModel,
-		@NonNull AbstractMessage stateMessage,
-		@NonNull MessageState newState
+	@Override
+	public void addMessageReaction(
+		@NonNull AbstractMessageModel messageModel,
+		@NonNull MessageState state,
+		@NonNull String fromIdentity,
+		@NonNull Date date
 	) {
-		if (!MessageUtil.isAllowedGroupMessageState(newState)) {
-			return;
+		if (!MessageUtil.isReaction(state)) {
+			throw new IllegalArgumentException("The given message state is not a reaction: " + state);
 		}
 
-		synchronized (this) {
-			logger.debug("Updating message state for group {} from identity {} to state {} ", messageModel.getGroupId(), stateMessage.getFromIdentity(), newState);
+		messageModel.setModifiedAt(date);
 
-			groupService.addGroupMessageState(messageModel, stateMessage.getFromIdentity(), newState);
-			messageModel.setModifiedAt(stateMessage.getDate());
+		if (messageModel instanceof GroupMessageModel) {
+			// Add group reaction
+			groupService.addGroupMessageState((GroupMessageModel) messageModel, fromIdentity, state);
 			save(messageModel);
 			fireOnModifiedMessage(messageModel);
+		} else {
+			// Add contact reaction (only if state transition is possible)
+			boolean canChangeState;
+			if (messageModel.isOutbox()) {
+				// For outbound messages, we need to check whether the message state transition is
+				// possible. For example, we can't add a reaction to failed messages.
+				canChangeState = MessageUtil.canChangeToState(messageModel.getState(), state, false);
+			} else {
+				// For inbound messages it is always possible to add a reaction
+				canChangeState = true;
+			}
+			if (canChangeState) {
+				messageModel.setState(state);
+				save(messageModel);
+				fireOnModifiedMessage(messageModel);
+			}
 		}
 	}
 
@@ -1219,41 +1261,68 @@ public class MessageServiceImpl implements MessageService {
 		if (MessageUtil.canMarkAsRead(message)) {
 			ContactModel contactModel = contactService.getByIdentity(message.getIdentity());
 
-			boolean sendDeliveryReceipt = MessageUtil.canSendDeliveryReceipt(message, ProtocolDefines.DELIVERYRECEIPT_MSGREAD);
-			if (sendDeliveryReceipt && contactModel != null) {
-				if (preferenceService.isReadReceipts()) {
-					if (contactModel.getReadReceipts() == ContactModel.DONT_SEND) {
-						sendDeliveryReceipt = false;
-					}
-				} else {
-					if (contactModel.getReadReceipts() != ContactModel.SEND) {
-						sendDeliveryReceipt = false;
-					}
-				}
-			}
+			// Check whether the message allows read receipt before setting the message to read
+			// because a message only allows a read receipt if has not been marked as read yet.
+			boolean messageAllowsDeliveryReceipt = MessageUtil.canSendDeliveryReceipt(message, ProtocolDefines.DELIVERYRECEIPT_MSGREAD);
+
+			Date readAt = new Date();
 
 			//save is read
 			message.setRead(true);
-			message.setReadAt(new Date());
-			message.setModifiedAt(new Date());
+			message.setReadAt(readAt);
+			message.setModifiedAt(readAt);
 
 			save(message);
 
-			if(!silent) {
+			if (!silent) {
 				//fire on modified if not silent
 				fireOnModifiedMessage(message);
 			}
 
 			saved = true;
 
-			if (sendDeliveryReceipt && contactModel != null) {
+			if (contactModel == null) {
+				return saved;
+			}
+
+            boolean receiverAllowsDeliveryReceipt;
+            switch (contactModel.getReadReceipts()) {
+                case ContactModel.SEND:
+                    receiverAllowsDeliveryReceipt = true;
+                    break;
+                case ContactModel.DONT_SEND:
+                    receiverAllowsDeliveryReceipt = false;
+                    break;
+                default:
+                    receiverAllowsDeliveryReceipt = preferenceService.isReadReceipts();
+                    break;
+            }
+
+			if (messageAllowsDeliveryReceipt && receiverAllowsDeliveryReceipt) {
 				contactService.createReceiver(contactModel).sendDeliveryReceipt(
 					ProtocolDefines.DELIVERYRECEIPT_MSGREAD,
-					new MessageId[]{MessageId.fromString(message.getApiMessageId())}
+					new MessageId[]{MessageId.fromString(message.getApiMessageId())},
+					readAt.getTime()
 				);
-
-				logger.info("Enqueue delivery receipt (read) message for message ID {} from {}",
+				logger.info("Enqueued delivery receipt (read) message for message ID {} from {}",
 					message.getApiMessageId(), contactModel.getIdentity());
+			} else {
+				if (message instanceof MessageModel) {
+					contactService.createReceiver(contactModel).sendIncomingMessageUpdateRead(
+						Set.of(MessageId.fromString(message.getApiMessageId())), readAt.getTime()
+					);
+				} else if (message instanceof GroupMessageModel) {
+					int localGroupId = ((GroupMessageModel) message).getGroupId();
+					GroupModel groupModel = groupService.getById(localGroupId);
+					if (groupModel != null) {
+						groupService.createReceiver(groupModel).sendIncomingMessageUpdateRead(
+							Set.of(MessageId.fromString(message.getApiMessageId())),
+							readAt.getTime()
+						);
+					} else {
+						logger.warn("Could not find group with local group id {}", localGroupId);
+					}
+				}
 			}
 		}
 
@@ -1289,7 +1358,7 @@ public class MessageServiceImpl implements MessageService {
 	@Override
 	public void remove(final AbstractMessageModel messageModel, boolean silent) {
 
-		SendMachine machine = getSendMachine(messageModel);
+		SendMachine machine = getSendMachine(messageModel, false);
 		if(machine != null) {
 			//abort pending send machine
 			//do not remove SendMachine (fix ANDR-522)
@@ -1405,7 +1474,7 @@ public class MessageServiceImpl implements MessageService {
 		}
 
         // As soon as we get a direct message, unhide and unarchive the contact
-        contactService.setIsHidden(senderIdentity, false);
+        contactService.setAcquaintanceLevel(senderIdentity, ContactModel.AcquaintanceLevel.DIRECT);
         contactService.setIsArchived(senderIdentity, false);
 
         // Bump "lastUpdate" if necessary, depending on the message type. Note that due to the
@@ -1428,7 +1497,7 @@ public class MessageServiceImpl implements MessageService {
 				preferenceService != null
 				&& preferenceService.isSaveMedia()
 				&& messageModel.getImageData().isDownloaded()
-				&& !hiddenChatsListService.has(contactService.getUniqueIdString(messageModel.getIdentity()))
+				&& !hiddenChatsListService.has(ContactUtil.getUniqueIdString(messageModel.getIdentity()))
 			) {
 				fileService.saveMedia(null, null, new CopyOnWriteArrayList<>(Collections.singletonList(messageModel)), true);
 			}
@@ -1445,9 +1514,6 @@ public class MessageServiceImpl implements MessageService {
 		else if (messageClass.equals(PollSetupMessage.class)) {
 			messageModel = saveBoxMessage((PollSetupMessage) message, messageModel, contactModel);
 		}
-		else if (messageClass.equals(FileMessage.class)) {
-			messageModel = saveBoxMessage((FileMessage) message, messageModel, contactModel);
-		}
 
 		if (messageModel == null) {
 			logger.info("processIncomingContactMessage: {} FAILED", message.getMessageId());
@@ -1544,12 +1610,9 @@ public class MessageServiceImpl implements MessageService {
 			messageModel = saveGroupMessage((GroupPollSetupMessage) message, messageModel);
 			// This is only used for debugging
 			if (ConfigUtils.isDevBuild()) {
-				logger.info("Processed GroupBallotCreateMessage {}", ((GroupPollSetupMessage) message).getRawBallotData());
+				logger.info("Processed GroupBallotCreateMessage {}", ((GroupPollSetupMessage) message).rawBallotData);
 			}
 		}
-		else if(message.getClass().equals(GroupFileMessage.class)) {
-			messageModel = saveGroupMessage((GroupFileMessage) message, messageModel);
-		}
 
 		if (messageModel != null) {
 			logger.info("processIncomingGroupMessage: {} SUCCESS - Message ID = {}", message.getMessageId(), messageModel.getId());
@@ -1630,7 +1693,7 @@ public class MessageServiceImpl implements MessageService {
 
 	private AbstractMessageModel saveBallotCreateMessage(MessageReceiver receiver,
 	                                                     MessageId messageId,
-	                                                     BallotCreateInterface message,
+	                                                     BallotSetupInterface message,
 	                                                     AbstractMessageModel messageModel,
 														 int messageFlags,
 	                                                     ForwardSecurityMode forwardSecurityMode)
@@ -1659,36 +1722,6 @@ public class MessageServiceImpl implements MessageService {
 		return messageModel;
 	}
 
-	/**
-	 * Process a 1:1 file message (0x17).
-	 */
-	private MessageModel saveBoxMessage(
-		@NonNull FileMessage message,
-		MessageModel messageModel,
-		@NonNull ContactModel contactModel
-	) throws Exception {
-		MessageReceiver messageReceiver = contactService.createReceiver(contactModel);
-		return (MessageModel) saveFileMessage(
-				messageReceiver,
-				message,
-				messageModel);
-	}
-
-	private GroupMessageModel saveGroupMessage(GroupFileMessage message, GroupMessageModel messageModel) throws Exception {
-		GroupModel groupModel = groupService.getByGroupMessage(message);
-
-		if(groupModel == null) {
-			return null;
-		}
-
-		MessageReceiver messageReceiver = groupService.createReceiver(groupModel);
-
-		return (GroupMessageModel) saveFileMessage(
-				messageReceiver,
-				message,
-				messageModel);
-	}
-
 	@Deprecated
 	private AbstractMessageModel saveAudioMessage(@NonNull MessageReceiver receiver,
 	                                              AbstractMessage message,
@@ -1731,7 +1764,7 @@ public class MessageServiceImpl implements MessageService {
 		if (newModel) {
 			fireOnCreatedMessage(messageModel);
 
-			if (canDownload(MessageType.VOICEMESSAGE)) {
+			if (shouldAutoDownload(MessageType.VOICEMESSAGE)) {
 				try {
 					downloadMediaMessage(messageModel, null);
 				} catch (Exception e) {
@@ -1747,9 +1780,11 @@ public class MessageServiceImpl implements MessageService {
 	}
 
 	@Deprecated
-	private AbstractMessageModel saveVideoMessage(@NonNull MessageReceiver receiver,
-	                                             AbstractMessage message,
-	                                             AbstractMessageModel messageModel) throws Exception {
+	private AbstractMessageModel saveVideoMessage(
+        @NonNull MessageReceiver receiver,
+	    AbstractMessage message,
+	    AbstractMessageModel messageModel
+    ) throws Exception {
 		boolean newModel = false;
 		int duration, videoSize;
 		byte[] encryptionKey, videoBlobId, thumbnailBlobId;
@@ -1791,21 +1826,31 @@ public class MessageServiceImpl implements MessageService {
 
 		//use download service!
 		logger.info("Downloading blob for message {} id = {}", messageModel.getApiMessageId(), messageModel.getId());
-		byte[] thumbnailBlob = downloadService.download(
-				messageModel.getId(),
-				thumbnailBlobId,
-				!(message instanceof AbstractGroupMessage),
-				new ProgressListener() {
-					@Override
-					public void updateProgress(int progress) {
-						updateMessageLoadingProgress(messageModel1, progress);
-					}
 
-					@Override
-					public void onFinished(boolean success) {
-						setMessageLoadingFinished(messageModel1);
-					}
-				});
+        // If multi-device is active, we always mark as done. Otherwise we do not mark as done if its a group message
+        boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive() || !(message instanceof AbstractGroupMessage);
+        @Nullable BlobScope blobScopeMarkAsDone = null;
+        if (shouldMarkAsDone) {
+            blobScopeMarkAsDone = messageModel.getBlobScopeForMarkAsDone();
+        }
+
+        byte[] thumbnailBlob = downloadService.download(
+            messageModel.getId(),
+            thumbnailBlobId,
+            messageModel.getBlobScopeForDownload(),
+            blobScopeMarkAsDone,
+            new ProgressListener() {
+                @Override
+                public void updateProgress(int progress) {
+                    updateMessageLoadingProgress(messageModel1, progress);
+                }
+
+                @Override
+                public void onFinished(boolean success) {
+                    setMessageLoadingFinished(messageModel1);
+                }
+            }
+        );
 
 		if (thumbnailBlob != null && thumbnailBlob.length > NaCl.BOXOVERHEAD) {
 			byte[] thumbnail = symmetricEncryptionService.decrypt(thumbnailBlob, encryptionKey, ProtocolDefines.THUMBNAIL_NONCE);
@@ -1827,7 +1872,7 @@ public class MessageServiceImpl implements MessageService {
 			if (newModel) {
 				fireOnCreatedMessage(messageModel);
 
-				if (canDownload(MessageType.VIDEO)) {
+				if (shouldAutoDownload(MessageType.VIDEO)) {
 					if (videoSize <= FILE_AUTO_DOWNLOAD_MAX_SIZE_ISO) {
 						try {
 							downloadMediaMessage(messageModel, null);
@@ -1848,128 +1893,63 @@ public class MessageServiceImpl implements MessageService {
 		return null;
 	}
 
-	private AbstractMessageModel saveFileMessage(MessageReceiver receiver,
-	                                             AbstractMessage message,
-	                                             AbstractMessageModel messageModel) throws Exception {
-		boolean newModel = false;
+    /**
+     * @return {@code true} if the thumbnail was downloaded and saved
+     */
+    @Override
+	public boolean downloadThumbnailIfPresent(@NonNull FileData fileData, @NonNull AbstractMessageModel messageModel) throws Exception {
 
-		if(!(message instanceof FileMessageInterface)) {
-			throw new ThreemaException("not a file message interface");
-		}
-		FileData fileData = ((FileMessageInterface)message).getData();
-
-		if(null == fileData) {
-			return null;
-		}
-
-		if (TestUtil.isEmptyOrNull(fileData.getMimeType())) {
-			fileData.setMimeType(MimeUtil.MIME_TYPE_DEFAULT);
-		}
-
-		logger.debug("process incoming file");
-		if (messageModel == null) {
-			newModel = true;
-
-			FileDataModel fileDataModel = new FileDataModel(
-				fileData.getFileBlobId(),
-				fileData.getEncryptionKey(),
-				fileData.getMimeType(),
-				fileData.getThumbnailMimeType(),
-				fileData.getFileSize(),
-				FileUtil.sanitizeFileName(fileData.getFileName()),
-				fileData.getRenderingType(),
-				fileData.getCaption(),
-				false,
-				fileData.getMetaData());
-
-			messageModel = receiver.createLocalModel(MessageType.FILE, MimeUtil.getContentTypeFromFileData(fileDataModel), message.getDate());
-			cache(messageModel);
-
-			messageModel.setApiMessageId(message.getMessageId().toString());
-			messageModel.setMessageFlags(message.getMessageFlags());
-			messageModel.setOutbox(false);
-			messageModel.setIdentity(message.getFromIdentity());
-			// Save correlation id into db field instead json
-			messageModel.setCorrelationId(fileData.getCorrelationId());
-			messageModel.setFileData(fileDataModel);
-			messageModel.setForwardSecurityMode(message.getForwardSecurityMode());
-
-			// Set the message model as saved in case the app gets killed while downloading the
-			// thumbnail. Due to forward security the message can not be processed twice anyway.
-			messageModel.setSaved(true);
-
-			//create the record
-			receiver.saveLocalModel(messageModel);
-		}
-
-		try {
-			downloadThumbnail(fileData, messageModel);
-		} catch (Exception e) {
-			logger.error("Download of thumbnail failed", e);
-		}
-
-		messageModel.setSaved(true);
-		receiver.saveLocalModel(messageModel);
-
-		if(newModel) {
-			fireOnCreatedMessage(messageModel);
-			// Auto download
-			if (canDownload(messageModel)) {
-				try {
-					downloadMediaMessage(messageModel, null);
-				} catch (Exception e) {
-					// a failed blob auto-download should not be considered a failure as the user can try again manually
-					logger.error("Unable to auto-download blob", e);
-				}
-			}
-		}
-		else {
-			fireOnModifiedMessage(messageModel);
-		}
+        if (fileData.getThumbnailBlobId() == null) {
+            return false;
+        }
 
-		return messageModel;
-	}
+        logger.info("Downloading thumbnail of message {}", messageModel.getApiMessageId());
+        final AbstractMessageModel messageModel1 = messageModel;
 
-	private void downloadThumbnail(FileData fileData, AbstractMessageModel messageModel) throws Exception {
-		if (fileData.getThumbnailBlobId() != null) {
-			logger.info("Downloading thumbnail of message {}", messageModel.getApiMessageId());
-			final AbstractMessageModel messageModel1 = messageModel;
-			byte[] thumbnailBlob = downloadService.download(
-				messageModel.getId(),
-				fileData.getThumbnailBlobId(),
-				!(messageModel instanceof GroupMessageModel),
-				new ProgressListener() {
-					@Override
-					public void updateProgress(int progress) {
-						updateMessageLoadingProgress(messageModel1, progress);
-					}
-
-					@Override
-					public void onFinished(boolean success) {
-						setMessageLoadingFinished(messageModel1);
-					}
-				});
+        // If multi-device is active, we always mark as done. Otherwise we do not mark as done if its a group message
+        boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive() || !(messageModel instanceof GroupMessageModel);
+        @Nullable BlobScope blobScopeMarkAsDone = null;
+        if (shouldMarkAsDone) {
+            blobScopeMarkAsDone = messageModel.getBlobScopeForMarkAsDone();
+        }
 
-			if (thumbnailBlob == null) {
-				downloadService.error(messageModel.getId());
-				logger.info("Error downloading thumbnail for message {}", messageModel.getApiMessageId());
-				throw new ThreemaException("Error downloading thumbnail");
-			}
+        byte[] thumbnailBlob = downloadService.download(
+            messageModel.getId(),
+            fileData.getThumbnailBlobId(),
+            messageModel.getBlobScopeForDownload(),
+            blobScopeMarkAsDone,
+            new ProgressListener() {
+                @Override
+                public void updateProgress(int progress) {
+                    updateMessageLoadingProgress(messageModel1, progress);
+                }
+
+                @Override
+                public void onFinished(boolean success) {
+                    setMessageLoadingFinished(messageModel1);
+                }
+            });
+
+        if (thumbnailBlob == null) {
+            downloadService.error(messageModel.getId());
+            logger.info("Error downloading thumbnail for message {}", messageModel.getApiMessageId());
+            throw new ThreemaException("Error downloading thumbnail");
+        }
 
-			byte[] thumbnail = symmetricEncryptionService.decrypt(thumbnailBlob, fileData.getEncryptionKey(), ProtocolDefines.FILE_THUMBNAIL_NONCE);
+        byte[] thumbnail = symmetricEncryptionService.decrypt(thumbnailBlob, fileData.getEncryptionKey(), ProtocolDefines.FILE_THUMBNAIL_NONCE);
 
-			if (thumbnail != null) {
-				try {
-					fileService.writeConversationMediaThumbnail(messageModel, thumbnail);
-				} catch (Exception e) {
-					downloadService.error(messageModel.getId());
-					logger.info("Error writing thumbnail for message {}", messageModel.getApiMessageId());
-					throw e;
-				}
-			}
+        if (thumbnail != null) {
+            try {
+                fileService.writeConversationMediaThumbnail(messageModel, thumbnail);
+            } catch (Exception exception) {
+                downloadService.error(messageModel.getId());
+                logger.info("Error writing thumbnail for message {}", messageModel.getApiMessageId());
+                throw exception;
+            }
+        }
 
-			downloadService.complete(messageModel.getId(), fileData.getThumbnailBlobId());
-		}
+        downloadService.complete(messageModel.getId(), fileData.getThumbnailBlobId());
+        return true;
 	}
 
 	private GroupMessageModel saveGroupMessage(GroupTextMessage message, GroupMessageModel messageModel) {
@@ -2003,7 +1983,7 @@ public class MessageServiceImpl implements MessageService {
 		return messageModel;
 	}
 
-	private boolean canDownload(MessageType type) {
+	private boolean shouldAutoDownload(MessageType type) {
 		if (preferenceService != null) {
 			ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
 			NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
@@ -2029,7 +2009,8 @@ public class MessageServiceImpl implements MessageService {
 	 * @param messageModel AbstractMessageModel to check
 	 * @return true if file should be downloaded immediately, false otherwise
 	 */
-	private boolean canDownload(@NonNull AbstractMessageModel messageModel) {
+    @Override
+	public boolean shouldAutoDownload(@NonNull AbstractMessageModel messageModel) {
 		MessageType type = MessageType.FILE;
 		FileDataModel fileDataModel = messageModel.getFileData();
 
@@ -2111,20 +2092,34 @@ public class MessageServiceImpl implements MessageService {
 
 		final GroupMessageModel messageModel1 = messageModel;
 
-		if (canDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
-			byte[] blob = downloadService.download(messageModel.getId(), message.getBlobId(), false, new ProgressListener() {
-
-				// do we really need a progress listener for images?
-				@Override
-				public void updateProgress(int progress) {
-					updateMessageLoadingProgress(messageModel1, progress);
-				}
-
-				@Override
-				public void onFinished(boolean success) {
-					setMessageLoadingFinished(messageModel1);
-				}
-			});
+		if (shouldAutoDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
+
+            // If multi-device is active, we always mark as done (even for a group message)
+            boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive();
+            @Nullable BlobScope blobScopeMarkAsDone = null;
+            if (shouldMarkAsDone) {
+                blobScopeMarkAsDone = messageModel.getBlobScopeForMarkAsDone();
+            }
+
+            byte[] blob = downloadService.download(
+                messageModel.getId(),
+                message.getBlobId(),
+                messageModel.getBlobScopeForDownload(),
+                blobScopeMarkAsDone,
+                new ProgressListener() {
+
+                    // do we really need a progress listener for images?
+                    @Override
+                    public void updateProgress(int progress) {
+                        updateMessageLoadingProgress(messageModel1, progress);
+                    }
+
+                    @Override
+                    public void onFinished(boolean success) {
+                        setMessageLoadingFinished(messageModel1);
+                    }
+                }
+            );
 
 			if (blob != null && messageModel.getImageData().getEncryptionKey().length > 0) {
 				try {
@@ -2310,9 +2305,16 @@ public class MessageServiceImpl implements MessageService {
 
 		logger.info("saveBoxMessage: {} - F", message.getMessageId());
 
-		if (canDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
-			// Use download class to handle failures after downloads
-			byte[] imageBlob = downloadService.download(messageModel.getId(), message.getBlobId(), true, null);
+		if (shouldAutoDownload(MessageType.IMAGE) && !messageModel.getImageData().isDownloaded()) {
+
+            // Use download class to handle failures after downloads
+			byte[] imageBlob = downloadService.download(
+                messageModel.getId(),
+                message.getBlobId(),
+                messageModel.getBlobScopeForDownload(),
+                messageModel.getBlobScopeForMarkAsDone(),
+                null
+            );
 			if (imageBlob != null) {
 				byte[] image = identityStore.decryptData(imageBlob, message.getNonce(), contactModel.getPublicKey());
 				if (image != null) {
@@ -2798,7 +2800,7 @@ public class MessageServiceImpl implements MessageService {
 			isHidden = hiddenChatsListService.has(groupService.getUniqueIdString(groupModel));
 		} else {
 			final ContactModel contactModel = contactService.getByIdentity(messageModel.getIdentity());
-			isHidden = hiddenChatsListService.has(contactService.getUniqueIdString(contactModel));
+			isHidden = hiddenChatsListService.has(ContactUtil.getUniqueIdString(messageModel.getIdentity()));
 		}
 
 		if (isHidden) {
@@ -2960,10 +2962,18 @@ public class MessageServiceImpl implements MessageService {
 			}
 		}
 
+        // If multi-device is active, we always mark as done. Otherwise we do not mark as done if its a group message
+        boolean shouldMarkAsDone = multiDeviceManager.isMultiDeviceActive() || !(mediaMessageModel instanceof GroupMessageModel);
+        @Nullable BlobScope blobScopeMarkAsDone = null;
+        if (shouldMarkAsDone) {
+            blobScopeMarkAsDone = mediaMessageModel.getBlobScopeForMarkAsDone();
+        }
+
 		byte[] blob = downloadService.download(
 			mediaMessageModel.getId(),
 			data.getBlobId(),
-			!(mediaMessageModel instanceof GroupMessageModel),
+            mediaMessageModel.getBlobScopeForDownload(),
+            blobScopeMarkAsDone,
 			progressListener
 		);
 		if (blob == null || blob.length < NaCl.BOXOVERHEAD) {
@@ -3009,7 +3019,7 @@ public class MessageServiceImpl implements MessageService {
 			&& isImageOrVideoFile(mediaMessageModel, data)) {
 			boolean isHidden = mediaMessageModel instanceof GroupMessageModel
 				? hiddenChatsListService.has(groupService.getUniqueIdString(((GroupMessageModel) mediaMessageModel).getGroupId()))
-				: hiddenChatsListService.has(contactService.getUniqueIdString(mediaMessageModel.getIdentity()));
+				: hiddenChatsListService.has(ContactUtil.getUniqueIdString(mediaMessageModel.getIdentity()));
 
 			if (!isHidden) {
 				fileService.saveMedia(null, null, new CopyOnWriteArrayList<>(Collections.singletonList(mediaMessageModel)), true);
@@ -3167,11 +3177,14 @@ public class MessageServiceImpl implements MessageService {
 							(MessageModel) messageModel
 					);
 
-					//remove "old" message models from cache
-					for(MessageModel m: Functional.filter(contactMessageCache, (IPredicateNonNull<MessageModel>) type -> type.getId() == messageModel.getId() && messageModel != type)){
-						//remove cached unsaved object
-						logger.debug("copy from message model fix");
-						m.copyFrom(messageModel);
+					// Update the cache
+					Iterator<MessageModel> iterator = contactMessageCache.iterator();
+					while (iterator.hasNext()) {
+						MessageModel cached = iterator.next();
+						if (cached.getId() == messageModel.getId() && cached != messageModel) {
+							// Remove old message model from cache if not the same object
+							iterator.remove();
+						}
 					}
 
 				}
@@ -3464,14 +3477,34 @@ public class MessageServiceImpl implements MessageService {
 	 * create a new AbstractMessageModel uploader
 	 * a existing uploader will be canceled
 	 */
-	private BlobUploader initUploader(AbstractMessageModel messageModel, byte[] data) throws ThreemaException {
+	@NonNull
+    private BlobUploader initUploader(
+        AbstractMessageModel messageModel,
+        byte[] data,
+        @NonNull MessageReceiver<?> messageReceiver
+    ) throws ThreemaException {
 		synchronized (uploaders) {
 			String key = cancelUploader(messageModel);
-			BlobUploader up = apiService.createUploader(data);
+
+            boolean shouldPersist = shouldPersistUploadForMessage(messageModel);
+
+            @NonNull BlobScope blobScope = BlobScope.Public.INSTANCE;
+
+            // If the message is send to a notes group, the blob scope must not be "public"
+            if (messageReceiver instanceof GroupMessageReceiver) {
+                if (groupService.isNotesGroup(((GroupMessageReceiver) messageReceiver).getGroup())) {
+                    blobScope = BlobScope.Local.INSTANCE;
+                }
+            }
+
+            BlobUploader up = apiService.createUploader(
+                data,
+                shouldPersist,
+                blobScope
+            );
 			uploaders.put(key, up);
-			boolean persist = shouldPersistUploadForMessage(messageModel);
-			up.setPersist(persist);
-			logger.debug("create new uploader for message {}, persist={}", key, persist);
+
+			logger.debug("create new uploader for message {}, persist={}", key, shouldPersist);
 			return up;
 		}
 	}
@@ -3485,7 +3518,7 @@ public class MessageServiceImpl implements MessageService {
 	}
 
 	/**
-	 * cancel a existing AbstractMessageModel uploader
+	 * cancel an existing AbstractMessageModel uploader
 	 */
 	private String cancelUploader(AbstractMessageModel messageModel) {
 		synchronized (uploaders) {
@@ -3525,7 +3558,7 @@ public class MessageServiceImpl implements MessageService {
 
 	@Override
 	public void cancelMessageUpload(AbstractMessageModel messageModel) {
-		updateMessageState(messageModel, MessageState.SENDFAILED, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 
 		if (messageSendingService != null) {
 			messageSendingService.abort(messageModel.getUid());
@@ -3536,7 +3569,7 @@ public class MessageServiceImpl implements MessageService {
 
 	@Override
 	public void cancelVideoTranscoding(AbstractMessageModel messageModel) {
-		updateMessageState(messageModel, MessageState.SENDFAILED, null);
+		updateOutgoingMessageState(messageModel, MessageState.SENDFAILED, new Date());
 
 		removeSendMachine(messageModel);
 		cancelTranscoding(messageModel);
@@ -3943,7 +3976,7 @@ public class MessageServiceImpl implements MessageService {
 				break;
 			case TYPE_IMAGE_CAM:
 				// cam images will always be sent in their original size. no scaling needed but possibly rotate and flip
-				try (InputStream inputStream = StreamUtil.getFromUri(context, mediaItem.getUri())) {
+				try (InputStream inputStream = getFromUri(context, mediaItem.getUri())) {
 					if (inputStream != null && inputStream.available() > 0) {
 						bitmap = BitmapFactory.decodeStream(new BufferedInputStream(inputStream), null, null);
 						if (bitmap != null) {
@@ -4201,14 +4234,18 @@ public class MessageServiceImpl implements MessageService {
 								save(messageModel);
 							}
 							fileDataModel.setFileSize(contentData.length - NaCl.BOXOVERHEAD);
-							messageModel.setFileData(fileDataModel);
+							messageModel.setFileDataModel(fileDataModel);
 							fireOnModifiedMessage(messageModel);
 						})
 						.next(() -> {
 							if (getReceiver().sendMediaData()) {
 								// upload file data
-								BlobUploader blobUploader = initUploader(getMessageModel(), contentEncryptResult[0].getData());
-								blobUploader.setProgressListener(new ProgressListener() {
+								BlobUploader blobUploader = initUploader(
+                                    getMessageModel(),
+                                    contentEncryptResult[0].getData(),
+                                    getReceiver()
+                                );
+								blobUploader.progressListener = new ProgressListener() {
 									@Override
 									public void updateProgress(int progress) {
 										updateMessageLoadingProgress(messageModel, progress);
@@ -4218,9 +4255,8 @@ public class MessageServiceImpl implements MessageService {
 									public void onFinished(boolean success) {
 										setMessageLoadingFinished(messageModel);
 									}
-								});
+								};
 								contentBlobId = blobUploader.upload();
-								logger.debug("blobId = {}", Utils.byteArrayToHexString(contentBlobId));
 							}
 						})
 						.next(() -> {
@@ -4233,8 +4269,12 @@ public class MessageServiceImpl implements MessageService {
 									if (thumbnailEncryptResult[0].isEmpty()) {
 										throw new ThreemaException("Thumbnail encrypt failed");
 									} else {
-										BlobUploader blobUploader = initUploader(getMessageModel(), thumbnailEncryptResult[0].getData());
-										blobUploader.setProgressListener(new ProgressListener() {
+										BlobUploader blobUploader = initUploader(
+                                            getMessageModel(),
+                                            thumbnailEncryptResult[0].getData(),
+                                            getReceiver()
+                                        );
+										blobUploader.progressListener = new ProgressListener() {
 											@Override
 											public void updateProgress(int progress) {
 												updateMessageLoadingProgress(messageModel, progress);
@@ -4244,10 +4284,8 @@ public class MessageServiceImpl implements MessageService {
 											public void onFinished(boolean success) {
 												setMessageLoadingFinished(messageModel);
 											}
-										});
+										};
 										thumbnailBlobId = blobUploader.upload();
-										logger.debug("blobIdThumbnail = {}", Utils.byteArrayToHexString(thumbnailBlobId));
-
 										fireOnModifiedMessage(messageModel);
 									}
 								}
@@ -4262,22 +4300,22 @@ public class MessageServiceImpl implements MessageService {
 								null,
 								null
 							);
-							updateMessageState(messageModel,
+							updateOutgoingMessageState(messageModel,
 								getReceiver().sendMediaData() && getReceiver().offerRetry() ?
 									MessageState.SENDING :
-									MessageState.SENT, null);
+									MessageState.SENT, new Date());
 
-							messageModel.setFileData(fileDataModel);
+							messageModel.setFileDataModel(fileDataModel);
 							// save updated model
 							save(messageModel);
 						})
 						.next(() -> {
 							messageModel.setSaved(true);
 							// Verify current saved state
-							updateMessageState(messageModel,
+							updateOutgoingMessageState(messageModel,
 								getReceiver().sendMediaData() && getReceiver().offerRetry() ?
 									MessageState.SENDING :
-									MessageState.SENT, null);
+									MessageState.SENT, new Date());
 
 							if (!getReceiver().sendMediaData()) {
 								// update status for message that stay local
@@ -4315,7 +4353,7 @@ public class MessageServiceImpl implements MessageService {
 
 			messageModel.setOutbox(true);
 			messageModel.setState(MessageState.PENDING); // shows a progress bar
-			messageModel.setFileData(fileDataModel);
+			messageModel.setFileDataModel(fileDataModel);
 			messageModel.setCorrelationId(correlationId);
 			String trimmedCaption = mediaItem.getTrimmedCaption();
 			if (trimmedCaption != null && !trimmedCaption.isBlank()) {
@@ -4665,7 +4703,7 @@ public class MessageServiceImpl implements MessageService {
 	 */
 	@WorkerThread
 	private byte[] getContentData(MediaItem mediaItem) {
-		try (InputStream inputStream = StreamUtil.getFromUri(context, mediaItem.getUri())) {
+		try (InputStream inputStream = getFromUri(context, mediaItem.getUri())) {
 			if (inputStream != null) {
  				int fileLength = inputStream.available();
 
diff --git a/app/src/main/java/ch/threema/app/services/PreferenceService.java b/app/src/main/java/ch/threema/app/services/PreferenceService.java
index 48475add..1ec16162 100644
--- a/app/src/main/java/ch/threema/app/services/PreferenceService.java
+++ b/app/src/main/java/ch/threema/app/services/PreferenceService.java
@@ -28,8 +28,6 @@ import androidx.annotation.IntDef;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
-import org.jetbrains.annotations.NotNull;
-
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Date;
@@ -78,7 +76,7 @@ public interface PreferenceService {
 
 	int PROFILEPIC_RELEASE_NOBODY = 0;
 	int PROFILEPIC_RELEASE_EVERYONE = 1;
-	int PROFILEPIC_RELEASE_SOME = 2;
+	int PROFILEPIC_RELEASE_ALLOW_LIST = 2;
 
 	int PRIVACY_POLICY_ACCEPT_NONE = 0;
 	int PRIVACY_POLICY_ACCEPT_EXCPLICIT = 1;
@@ -221,8 +219,6 @@ public interface PreferenceService {
 
 	/**
 	 * value in seconds!
-	 *
-	 * @return
 	 */
 	int getPinLockGraceTime();
 
@@ -252,14 +248,10 @@ public interface PreferenceService {
 
 	void clear();
 
-	public List<String[]> write();
+	List<String[]> write();
 
 	boolean read(List<String[]> values);
 
-	Integer getRoutineInterval(String key);
-
-	void setRoutineInterval(String key, Integer intervalSeconds);
-
 	boolean showInactiveContacts();
 
 	boolean getLastOnlineStatus();
@@ -503,6 +495,17 @@ public interface PreferenceService {
 	void setWorkSyncCheckInterval(int checkInterval);
 	int getWorkSyncCheckInterval();
 
+	/**
+	 * Store the interval for the identity state sync in seconds.
+	 * @param syncIntervalS The sync interval in seconds
+	 */
+	void setIdentityStateSyncInterval(int syncIntervalS);
+
+	/**
+	 * @return The identity state sync interval in seconds
+	 */
+	int getIdentityStateSyncIntervalS();
+
 	boolean getIsExportIdTooltipShown();
 
 	void setThreemaSafeMDMConfig(String mdmConfigHash);
diff --git a/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java b/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java
index 88fc9eff..e8f5e31f 100644
--- a/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/PreferenceServiceImpl.java
@@ -228,7 +228,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 			return ImageScale_MEDIUM;
 		}
 
-		switch (Integer.valueOf(imageScale)) {
+		switch (Integer.parseInt(imageScale)) {
 			case 0:
 				return ImageScale_SMALL;
 			case 2:
@@ -250,7 +250,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 			return VideoSize_MEDIUM;
 		}
 
-		switch (Integer.valueOf(videoSize)) {
+		switch (Integer.parseInt(videoSize)) {
 			case 0:
 				return VideoSize_SMALL;
 			case 2:
@@ -335,7 +335,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 
 	@Override
 	public void setRecentEmojis2(LinkedList<String> list) {
-		this.preferenceStore.save(this.getKeyName(R.string.preferences__recent_emojis2), list.toArray(new String[list.size()]), false);
+		this.preferenceStore.save(this.getKeyName(R.string.preferences__recent_emojis2), list.toArray(new String[0]), false);
 	}
 
 	@Override
@@ -506,7 +506,7 @@ public class PreferenceServiceImpl implements PreferenceService {
 			return R.style.FontStyle_Normal;
 		}
 
-		switch (Integer.valueOf(fontStyle)) {
+		switch (Integer.parseInt(fontStyle)) {
 			case 1:
 				return R.style.FontStyle_Large;
 			case 2:
@@ -669,11 +669,9 @@ public class PreferenceServiceImpl implements PreferenceService {
 			String valueClass = v[2];
 
 			if (valueClass.equals(Boolean.class.toString())) {
-				this.preferenceStore.save(key, Boolean.valueOf(value));
-			} else if (valueClass.equals(Float.class.toString())) {
-//					this.preferenceStore.save(key, ((Float) v).floatValue());
+				this.preferenceStore.save(key, Boolean.parseBoolean(value));
 			} else if (valueClass.equals(Integer.class.toString())) {
-				this.preferenceStore.save(key, Integer.valueOf(value));
+				this.preferenceStore.save(key, Integer.parseInt(value));
 			} else if (valueClass.equals(Long.class.toString())) {
 				this.preferenceStore.save(key, Long.valueOf(value));
 			} else if (valueClass.equals(String.class.toString())) {
@@ -688,16 +686,6 @@ public class PreferenceServiceImpl implements PreferenceService {
 		return this.context.getString(resourceId);
 	}
 
-	@Override
-	public Integer getRoutineInterval(String key) {
-		return this.preferenceStore.getInt(key);
-	}
-
-	@Override
-	public void setRoutineInterval(String key, Integer intervalSeconds) {
-		this.preferenceStore.save(key, intervalSeconds);
-	}
-
 	@Override
 	public boolean showInactiveContacts() {
 		return this.preferenceStore.getBoolean(this.getKeyName(R.string.preferences__show_inactive_contacts));
@@ -1373,6 +1361,16 @@ public class PreferenceServiceImpl implements PreferenceService {
 		return this.preferenceStore.getInt(this.getKeyName(R.string.preferences__work_sync_check_interval));
 	}
 
+	@Override
+	public void setIdentityStateSyncInterval(int syncIntervalS) {
+		this.preferenceStore.save(this.getKeyName(R.string.preferences__identity_states_check_interval), syncIntervalS);
+	}
+
+	@Override
+	public int getIdentityStateSyncIntervalS() {
+		return this.preferenceStore.getInt(this.getKeyName(R.string.preferences__identity_states_check_interval));
+	}
+
 	@Override
 	public boolean getIsExportIdTooltipShown() {
 		return this.preferenceStore.getBoolean(this.getKeyName(R.string.preferences__tooltip_export_id_shown));
diff --git a/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java b/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java
index 9bb84dd5..83e41541 100644
--- a/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ServerAddressProviderServiceImpl.java
@@ -27,170 +27,267 @@ import java.net.URL;
 import java.net.URLEncoder;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.utils.Utils;
 import ch.threema.domain.onprem.OnPremConfigFetcher;
 import ch.threema.domain.onprem.ServerAddressProviderOnPrem;
 import ch.threema.domain.protocol.ServerAddressProvider;
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider;
 
 public class ServerAddressProviderServiceImpl implements ServerAddressProviderService {
-	private final PreferenceService preferenceService;
-	private OnPremConfigFetcher onPremConfigFetcher;
-	private URL lastOnPremServer;
-
-	public ServerAddressProviderServiceImpl(PreferenceService preferenceService) {
-		this.preferenceService = preferenceService;
-	}
-
-	@Override
-	@NonNull
-	public ServerAddressProvider getServerAddressProvider() {
-		if (ConfigUtils.isOnPremBuild()) {
-			return getServerAddressProviderOnPrem();
-		} else {
-			return getServerAddressProviderBuildConfig();
-		}
-	}
-
-	private ServerAddressProvider getServerAddressProviderOnPrem() {
-		return new ServerAddressProviderOnPrem(this::getOnPremConfigFetcher);
-	}
-
-	private ServerAddressProvider getServerAddressProviderBuildConfig() {
-		return new ServerAddressProvider() {
-			@Override
-			public String getChatServerNamePrefix(boolean ipv6) {
-				return ipv6 ? BuildConfig.CHAT_SERVER_IPV6_PREFIX : BuildConfig.CHAT_SERVER_PREFIX;
-			}
-
-			@Override
-			public String getChatServerNameSuffix(boolean ipv6) {
-				return BuildConfig.CHAT_SERVER_SUFFIX;
-			}
-
-			@Override
-			public int[] getChatServerPorts() {
-				return BuildConfig.CHAT_SERVER_PORTS;
-			}
-
-			@Override
-			public boolean getChatServerUseServerGroups() {
-				return BuildConfig.CHAT_SERVER_GROUPS;
-			}
-
-			@Override
-			public byte[] getChatServerPublicKey() {
-				return BuildConfig.SERVER_PUBKEY;
-			}
-
-			@Override
-			public byte[] getChatServerPublicKeyAlt() {
-				return BuildConfig.SERVER_PUBKEY_ALT;
-			}
-
-			@Override
-			public String getDirectoryServerUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.DIRECTORY_SERVER_IPV6_URL : BuildConfig.DIRECTORY_SERVER_URL;
-			}
-
-			@Override
-			public String getWorkServerUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.WORK_SERVER_IPV6_URL : BuildConfig.WORK_SERVER_URL;
-			}
-
-			@Override
-			public String getBlobServerDownloadUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.BLOB_SERVER_DOWNLOAD_IPV6_URL : BuildConfig.BLOB_SERVER_DOWNLOAD_URL;
-			}
-
-			@Override
-			public String getBlobServerDoneUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.BLOB_SERVER_DONE_IPV6_URL : BuildConfig.BLOB_SERVER_DONE_URL;
-			}
-
-			@Override
-			public String getBlobServerUploadUrl(boolean ipv6) {
-				return ipv6 ? BuildConfig.BLOB_SERVER_UPLOAD_IPV6_URL : BuildConfig.BLOB_SERVER_UPLOAD_URL;
-			}
-
-			@Override
-			public String getAvatarServerUrl(boolean ipv6) {
-				return BuildConfig.AVATAR_FETCH_URL;
-			}
-
-			@Override
-			public String getSafeServerUrl(boolean ipv6) {
-				return BuildConfig.SAFE_SERVER_URL;
-			}
-
-			@Override
-			public String getWebServerUrl() {
-				return BuildConfig.WEB_SERVER_URL;
-			}
-
-			@Override
-			public String getWebOverrideSaltyRtcHost() {
-				return null;
-			}
-
-			@Override
-			public int getWebOverrideSaltyRtcPort() {
-				return 0;
-			}
-
-			@Override
-			public byte[] getThreemaPushPublicKey() {
-				return BuildConfig.THREEMA_PUSH_PUBLIC_KEY;
-			}
-
-			@NonNull
-			@Override
-			public String getMediatorUrl() {
-				return BuildConfig.MEDIATOR_SERVER_URL;
-			}
-
-			@NonNull
-			@Override
-			public String getAppRatingUrl() {
-				return BuildConfig.APP_RATING_URL;
-			}
-		};
-	}
-
-	private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
-		try {
-			URL curOnPremServer = makeUrlWithUsernamePassword(new URL(preferenceService.getOnPremServer()),
-				preferenceService.getLicenseUsername(), preferenceService.getLicensePassword());
-
-			// Note: must use toString when comparing URLs, as Java ignores userInfo in URL.equals()
-			if (onPremConfigFetcher == null || !curOnPremServer.toString().equals(lastOnPremServer.toString())) {
-				onPremConfigFetcher = new OnPremConfigFetcher(curOnPremServer, BuildConfig.ONPREM_CONFIG_TRUSTED_PUBLIC_KEYS);
-				lastOnPremServer = curOnPremServer;
-			}
-		} catch (MalformedURLException e) {
-			throw new ThreemaException("Bad OnPrem server URL", e);
-		}
-
-		return onPremConfigFetcher;
-	}
-
-	private URL makeUrlWithUsernamePassword(URL url, String username, String password) throws MalformedURLException {
-		String urlAuth = null;
-		try {
-			urlAuth = url.getProtocol() + "://" +
-				URLEncoder.encode(username, "UTF-8") + ":" +
-				URLEncoder.encode(password, "UTF-8") + "@" +
-				url.getHost();
-		} catch (UnsupportedEncodingException e) {
-			// UTF-8 is always supported
-			throw new RuntimeException(e);
-		}
-		if (url.getPort() > 0) {
-			urlAuth += ":" + url.getPort();
-		}
-		urlAuth += url.getFile();
-
-		return new URL(urlAuth);
-	}
+    private final PreferenceService preferenceService;
+    private OnPremConfigFetcher onPremConfigFetcher;
+    private URL lastOnPremServer;
+
+    public ServerAddressProviderServiceImpl(PreferenceService preferenceService) {
+        this.preferenceService = preferenceService;
+    }
+
+    @Override
+    @NonNull
+    public ServerAddressProvider getServerAddressProvider() {
+        if (ConfigUtils.isOnPremBuild()) {
+            return getServerAddressProviderOnPrem();
+        } else {
+            return getServerAddressProviderBuildConfig();
+        }
+    }
+
+    private ServerAddressProvider getServerAddressProviderOnPrem() {
+        return new ServerAddressProviderOnPrem(this::getOnPremConfigFetcher);
+    }
+
+    private ServerAddressProvider getServerAddressProviderBuildConfig() {
+        return new ServerAddressProvider() {
+            @Override
+            public String getChatServerNamePrefix(boolean ipv6) {
+                return ipv6 ? BuildConfig.CHAT_SERVER_IPV6_PREFIX : BuildConfig.CHAT_SERVER_PREFIX;
+            }
+
+            @Override
+            public String getChatServerNameSuffix(boolean ipv6) {
+                return BuildConfig.CHAT_SERVER_SUFFIX;
+            }
+
+            @Override
+            public int[] getChatServerPorts() {
+                return BuildConfig.CHAT_SERVER_PORTS;
+            }
+
+            @Override
+            public boolean getChatServerUseServerGroups() {
+                return BuildConfig.CHAT_SERVER_GROUPS;
+            }
+
+            @Override
+            public byte[] getChatServerPublicKey() {
+                return BuildConfig.SERVER_PUBKEY;
+            }
+
+            @Override
+            public byte[] getChatServerPublicKeyAlt() {
+                return BuildConfig.SERVER_PUBKEY_ALT;
+            }
+
+            @Override
+            public String getDirectoryServerUrl(boolean ipv6) {
+                return ipv6 ? BuildConfig.DIRECTORY_SERVER_IPV6_URL : BuildConfig.DIRECTORY_SERVER_URL;
+            }
+
+            @Override
+            public String getWorkServerUrl(boolean ipv6) {
+                return ipv6 ? BuildConfig.WORK_SERVER_IPV6_URL : BuildConfig.WORK_SERVER_URL;
+            }
+
+            /**
+             * @throws ThreemaException if the build config field for the correct base url is missing in current build flavor. This
+             * is the case if this implementation is incorrectly used in an on-prem build.
+             */
+            @NonNull
+            private String getBlobBaseUrlDefaultServer(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                final @NonNull String blobIdPrefix8 = blobIdHexString.substring(0, 2);
+                final @Nullable String baseUrlRawValue = useIpV6 ? BuildConfig.BLOB_SERVER_IPV6_URL : BuildConfig.BLOB_SERVER_URL;
+                // Could actually be null, if the build-config field was explicitly set to value "null" in build.gradle
+                //noinspection ConstantValue
+                if (baseUrlRawValue == null) {
+                    throw new ThreemaException("Missing value for blob server url in current build flavor");
+                }
+                return baseUrlRawValue.replace("{blobIdPrefix8}", blobIdPrefix8);
+            }
+
+            /**
+             * @throws ThreemaException if the build config field for the correct base url is missing in current build flavor. This
+             * is the case if this implementation is incorrectly used in an on-prem build.
+             */
+            @NonNull
+            @Override
+            public String getBlobBaseUrlMirrorServer(@NonNull MultiDevicePropertyProvider multiDevicePropertyProvider) throws ThreemaException {
+                final @NonNull byte[] deviceGroupId = multiDevicePropertyProvider.get().getKeys().getDgid$domain();
+                final @Nullable String deviceGroupIdHexString = Utils.byteArrayToHexString(deviceGroupId);
+                if (deviceGroupIdHexString == null || deviceGroupIdHexString.length() < 2) {
+                    throw new ThreemaException("Key deviceGroupId is not in correct form");
+                }
+                final @NonNull String deviceGroupIdPrefix4 = deviceGroupIdHexString.substring(0, 1);
+                final @NonNull String deviceGroupIdPrefix8 = deviceGroupIdHexString.substring(0, 2);
+                // Could actually be null, if the build-config field was explicitly set to value "null" in build.gradle
+                //noinspection ConstantValue
+                if (BuildConfig.BLOB_MIRROR_SERVER_URL == null) {
+                    throw new ThreemaException("Missing value for blob server url in current build flavor");
+                }
+                return BuildConfig.BLOB_MIRROR_SERVER_URL
+                    .replace("{deviceGroupIdPrefix4}", deviceGroupIdPrefix4)
+                    .replace("{deviceGroupIdPrefix8}", deviceGroupIdPrefix8);
+            }
+
+            @NonNull
+            @Override
+            public String getBlobServerDownloadUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+                final @NonNull String blobBaseUrlDefaultServer = getBlobBaseUrlDefaultServer(useIpV6, blobId);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlDefaultServer + "/" + blobIdHexString;
+            }
+
+            @NonNull
+            @Override
+            public String getBlobServerUploadUrl(boolean useIpV6) {
+                return useIpV6 ? BuildConfig.BLOB_SERVER_IPV6_URL_UPLOAD : BuildConfig.BLOB_SERVER_URL_UPLOAD;
+            }
+
+            @NonNull
+            @Override
+            public String getBlobServerDoneUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+                final @NonNull String blobBaseUrlDefaultServer = getBlobBaseUrlDefaultServer(useIpV6, blobId);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlDefaultServer + "/" + blobIdHexString + "/done";
+            }
+
+            @NonNull
+            @Override
+            public String getBlobMirrorServerDownloadUrl(
+                @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+                @NonNull byte[] blobId
+            ) throws ThreemaException {
+                final @NonNull String blobBaseUrlMirrorServer = getBlobBaseUrlMirrorServer(multiDevicePropertyProvider);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlMirrorServer + "/" + blobIdHexString;
+            }
+
+            @NonNull
+            @Override
+            public String getBlobMirrorServerUploadUrl(
+                @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+            ) throws ThreemaException {
+                final @NonNull String blobBaseUrlMirrorServer = getBlobBaseUrlMirrorServer(multiDevicePropertyProvider);
+                return blobBaseUrlMirrorServer + "/upload";
+            }
+
+            @NonNull
+            @Override
+            public String getBlobMirrorServerDoneUrl(
+                @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+                @NonNull byte[] blobId
+            ) throws ThreemaException {
+                final @NonNull String blobBaseUrlMirrorServer = getBlobBaseUrlMirrorServer(multiDevicePropertyProvider);
+                final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+                if (blobIdHexString == null || blobIdHexString.isBlank()) {
+                    throw new ThreemaException("Argument blobId is not in correct form");
+                }
+                return blobBaseUrlMirrorServer + "/" + blobIdHexString + "/done";
+            }
+
+            @Override
+            public String getAvatarServerUrl(boolean ipv6) {
+                return BuildConfig.AVATAR_FETCH_URL;
+            }
+
+            @Override
+            public String getSafeServerUrl(boolean ipv6) {
+                return BuildConfig.SAFE_SERVER_URL;
+            }
+
+            @Override
+            public String getWebServerUrl() {
+                return BuildConfig.WEB_SERVER_URL;
+            }
+
+            @Override
+            public String getWebOverrideSaltyRtcHost() {
+                return null;
+            }
+
+            @Override
+            public int getWebOverrideSaltyRtcPort() {
+                return 0;
+            }
+
+            @Override
+            public byte[] getThreemaPushPublicKey() {
+                return BuildConfig.THREEMA_PUSH_PUBLIC_KEY;
+            }
+
+            @NonNull
+            @Override
+            public String getMediatorUrl() {
+                return BuildConfig.MEDIATOR_SERVER_URL;
+            }
+
+            @NonNull
+            @Override
+            public String getAppRatingUrl() {
+                return BuildConfig.APP_RATING_URL;
+            }
+        };
+    }
+
+    private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
+        try {
+            URL curOnPremServer = makeUrlWithUsernamePassword(new URL(preferenceService.getOnPremServer()),
+                preferenceService.getLicenseUsername(), preferenceService.getLicensePassword());
+
+            // Note: must use toString when comparing URLs, as Java ignores userInfo in URL.equals()
+            if (onPremConfigFetcher == null || !curOnPremServer.toString().equals(lastOnPremServer.toString())) {
+                onPremConfigFetcher = new OnPremConfigFetcher(curOnPremServer, BuildConfig.ONPREM_CONFIG_TRUSTED_PUBLIC_KEYS);
+                lastOnPremServer = curOnPremServer;
+            }
+        } catch (MalformedURLException e) {
+            throw new ThreemaException("Bad OnPrem server URL", e);
+        }
+
+        return onPremConfigFetcher;
+    }
+
+    private URL makeUrlWithUsernamePassword(@NonNull URL url, String username, String password) throws MalformedURLException {
+        String urlAuth = null;
+        try {
+            urlAuth = url.getProtocol() + "://" +
+                URLEncoder.encode(username, "UTF-8") + ":" +
+                URLEncoder.encode(password, "UTF-8") + "@" +
+                url.getHost();
+        } catch (UnsupportedEncodingException e) {
+            // UTF-8 is always supported
+            throw new RuntimeException(e);
+        }
+        if (url.getPort() > 0) {
+            urlAuth += ":" + url.getPort();
+        }
+        urlAuth += url.getFile();
+
+        return new URL(urlAuth);
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/ServerMessageService.kt b/app/src/main/java/ch/threema/app/services/ServerMessageService.kt
deleted file mode 100644
index 9b562126..00000000
--- a/app/src/main/java/ch/threema/app/services/ServerMessageService.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services
-
-import ch.threema.app.managers.ListenerManager
-import ch.threema.storage.DatabaseServiceNew
-import ch.threema.storage.models.ServerMessageModel
-
-interface ServerMessageService {
-    fun saveIncomingServerMessage(msg: ServerMessageModel)
-}
-
-class ServerMessageServiceImpl(
-    private val databaseService: DatabaseServiceNew,
-) : ServerMessageService {
-
-    override fun saveIncomingServerMessage(msg: ServerMessageModel) {
-        // store message
-        databaseService.serverMessageModelFactory.storeServerMessageModel(msg)
-
-        // notify listeners
-        ListenerManager.serverMessageListeners.handle {
-            if (msg.type == ServerMessageModel.TYPE_ALERT) {
-                it.onAlert(msg)
-            } else {
-                it.onError(msg)
-            }
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java b/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java
index 7f7baf44..740bfe8e 100644
--- a/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/SynchronizeContactsServiceImpl.java
@@ -36,7 +36,6 @@ import java.util.List;
 import androidx.annotation.NonNull;
 import ch.threema.app.collections.Functional;
 import ch.threema.app.collections.IPredicateNonNull;
-import ch.threema.app.listeners.NewSyncedContactsListener;
 import ch.threema.app.listeners.SynchronizeContactsListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.routines.SynchronizeContactsRoutine;
@@ -44,6 +43,7 @@ import ch.threema.app.routines.UpdateBusinessAvatarRoutine;
 import ch.threema.app.utils.AndroidContactUtil;
 import ch.threema.app.utils.ContactUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ModelDeletedException;
 import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.api.APIConnector;
@@ -61,7 +61,7 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 	private final LocaleService localeService;
 	private final IdentityStoreInterface identityStore;
 
-	private final List<SynchronizeContactsRoutine> pendingRoutines = new ArrayList<SynchronizeContactsRoutine>();
+	private final List<SynchronizeContactsRoutine> pendingRoutines = new ArrayList<>();
 	private final IdListService excludedIdentityListService;
 	private final PreferenceService preferenceService;
 	private final DeviceService deviceService;
@@ -106,18 +106,10 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 
 		if (sync != null) {
 			if(this.deviceService != null && this.deviceService.isOnline()) {
-				sync.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
-					@Override
-					public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
-						// let user know that contact was added
-						ListenerManager.newSyncedContactListener.handle(new ListenerManager.HandleListener<NewSyncedContactsListener>() {
-							@Override
-							public void handle(NewSyncedContactsListener listener) {
-								listener.onNew(createdContacts);
-							}
-						});
-					}
-				});
+				sync.addOnFinished((success, modifiedAccounts, createdContacts, deletedAccounts) ->
+					// let user know that contact was added
+					ListenerManager.newSyncedContactListener.handle(listener -> listener.onNew(createdContacts))
+				);
 
 				new Thread(new Runnable() {
 					@Override
@@ -180,19 +172,20 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 		logger.info("Running contact sync");
 		logger.debug("instantiateSynchronization with account {}", account);
 
-        final SynchronizeContactsRoutine routine = new SynchronizeContactsRoutine(
-            this.context,
-            this.apiConnector,
-            this.contactService,
-            this.userService,
-            this.localeService,
-            this.contentResolver,
-            this.excludedIdentityListService,
-            this.deviceService,
-            this.preferenceService,
-            this.identityStore,
-            this.blockedContactsService
-        );
+		final SynchronizeContactsRoutine routine =
+				new SynchronizeContactsRoutine(
+						this.context,
+						this.apiConnector,
+						this.contactService,
+						this.contactModelRepository,
+						this.userService,
+						this.localeService,
+						this.contentResolver,
+						this.excludedIdentityListService,
+						this.deviceService,
+						this.preferenceService,
+						this.identityStore,
+						this.blockedContactsService);
 
 		synchronized (this.pendingRoutines) {
 			this.pendingRoutines.add(routine);
@@ -200,7 +193,7 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 
 		routine.addOnFinished(new SynchronizeContactsRoutine.OnFinished() {
 			@Override
-			public void finished(boolean success, long modifiedAccounts, List<ContactModel> createdContacts, long deletedAccounts) {
+			public void finished(boolean success, long modifiedAccounts, List<ch.threema.data.models.ContactModel> createdContacts, long deletedAccounts) {
 				finishedRoutine(routine);
 			}
 		});
@@ -292,9 +285,15 @@ public class SynchronizeContactsServiceImpl implements SynchronizeContactsServic
 			// cleanup / degrade remaining identities that are still server verified
 			List<String> identities = contactService.getIdentitiesByVerificationLevel(VerificationLevel.SERVER_VERIFIED);
 			if (identities != null && !identities.isEmpty()) {
-				for (ContactModel contactModel : contactService.getByIdentities(identities)) {
-					contactModel.verificationLevel = VerificationLevel.UNVERIFIED;
-					contactService.save(contactModel);
+				for (String identity : identities) {
+					ch.threema.data.models.ContactModel model = contactModelRepository.getByIdentity(identity);
+					if (model != null) {
+						try {
+							model.setVerificationLevelFromLocal(VerificationLevel.UNVERIFIED);
+						} catch (ModelDeletedException e) {
+							logger.info("Could not set verification level because contact {} has been deleted", identity, e);
+						}
+					}
 				}
 			}
 		}
diff --git a/app/src/main/java/ch/threema/app/services/UserService.java b/app/src/main/java/ch/threema/app/services/UserService.java
index b5d87724..9476de98 100644
--- a/app/src/main/java/ch/threema/app/services/UserService.java
+++ b/app/src/main/java/ch/threema/app/services/UserService.java
@@ -24,10 +24,15 @@ package ch.threema.app.services;
 import android.accounts.Account;
 import android.accounts.AccountManagerCallback;
 
+import java.io.File;
 import java.util.Date;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.services.license.LicenseService;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.storage.models.ContactModel;
 
 /**
  * Method and actions for the current Threema-User!
@@ -103,7 +108,44 @@ public interface UserService {
 	 *
 	 * @return converted and truncated string or null if an error happens.
 	 */
-	@Nullable String setPublicNickname(String publicNickname);
+	@Nullable String setPublicNickname(String publicNickname, @NonNull TriggerSource triggerSource);
+
+    /**
+     * Get the user profile picture. If no profile picture is set, then null is returned.
+     */
+    @Nullable
+    byte[] getUserProfilePicture();
+
+    /**
+     * Set the user profile picture. Note that this will trigger a user profile sync if multi device
+     * is active.
+     */
+    boolean setUserProfilePicture(@NonNull File userProfilePicture, @NonNull TriggerSource triggerSource);
+
+    /**
+     * Set the user profile picture. Note that this will trigger a user profile sync if multi device
+     * is active.
+     */
+    boolean setUserProfilePicture(@NonNull byte[] userProfilePicture, @NonNull TriggerSource triggerSource);
+
+    /**
+     * Remove the user profile picture. Note that this will trigger a user profile sync if multi
+     * device is active.
+     */
+    void removeUserProfilePicture(@NonNull TriggerSource triggerSource);
+
+    /**
+     * Upload the current profile picture if it hasn't been uploaded recently and get the most
+     * recent contact profile picture upload data.
+     *
+     * @return the most recent profile picture upload data. If the upload failed or the last stored
+     * data could not be read, the returned data contains null as blob ID. If there is no profile
+     * picture set, the blob ID is {@link ContactModel#NO_PROFILE_PICTURE_BLOB_ID}.
+     */
+    @NonNull
+    @WorkerThread
+    ContactService.ProfilePictureUploadData uploadUserProfilePictureOrGetPreviousUploadData();
+
 
 	boolean restoreIdentity(String backupString, String password) throws Exception;
 
diff --git a/app/src/main/java/ch/threema/app/services/UserServiceImpl.java b/app/src/main/java/ch/threema/app/services/UserServiceImpl.java
index 510ddbb7..a058e0b1 100644
--- a/app/src/main/java/ch/threema/app/services/UserServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/UserServiceImpl.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.services;
 
-import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
-
 import android.accounts.Account;
 import android.accounts.AccountManager;
 import android.accounts.AccountManagerCallback;
@@ -31,22 +29,31 @@ import android.content.Context;
 import android.provider.ContactsContract;
 import android.text.format.DateUtils;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
+import com.neilalexander.jnacl.NaCl;
 
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.security.SecureRandom;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.HashSet;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.BuildFlavor;
 import ch.threema.app.R;
+import ch.threema.app.ThreemaApplication;
 import ch.threema.app.collections.Functional;
+import ch.threema.app.listeners.ProfileListener;
 import ch.threema.app.listeners.SMSVerificationListener;
 import ch.threema.app.managers.ListenerManager;
+import ch.threema.app.multidevice.MultiDeviceManager;
 import ch.threema.app.routines.UpdateWorkInfoRoutine;
 import ch.threema.app.services.license.LicenseService;
 import ch.threema.app.services.license.SerialCredentials;
@@ -55,7 +62,10 @@ import ch.threema.app.stores.IdentityStore;
 import ch.threema.app.stores.PreferenceStore;
 import ch.threema.app.stores.PreferenceStoreInterface;
 import ch.threema.app.stores.PreferenceStoreInterfaceDevNullImpl;
+import ch.threema.app.tasks.ReflectUserProfileNicknameSyncTask;
+import ch.threema.app.tasks.TaskCreator;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.DeviceIdUtil;
 import ch.threema.app.utils.LocaleUtil;
 import ch.threema.app.utils.PushUtil;
@@ -67,8 +77,16 @@ import ch.threema.domain.identitybackup.IdentityBackupDecoder;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.api.CreateIdentityRequestDataInterface;
+import ch.threema.domain.protocol.blob.BlobScope;
+import ch.threema.domain.protocol.blob.BlobUploader;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.stores.IdentityStoreInterface;
+import ch.threema.domain.taskmanager.TaskManager;
+import ch.threema.domain.taskmanager.TriggerSource;
+import ch.threema.storage.models.ContactModel;
+
+import static ch.threema.app.ThreemaApplication.PHONE_LINKED_PLACEHOLDER;
+import static ch.threema.app.utils.StreamUtilKt.toByteArray;
 
 /**
  * This service class handle all user actions (db/identity....)
@@ -76,12 +94,28 @@ import ch.threema.domain.stores.IdentityStoreInterface;
 public class UserServiceImpl implements UserService, CreateIdentityRequestDataInterface  {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("UserServiceImpl");
 
+    @NonNull
 	private final Context context;
+    @NonNull
 	private final PreferenceStoreInterface preferenceStore;
+    @NonNull
 	private final IdentityStore identityStore;
+    @NonNull
 	private final APIConnector apiConnector;
+    @NonNull
+    private final ApiService apiService;
+    @NonNull
+    private final FileService fileService;
+    @NonNull
 	private final LocaleService localeService;
+    @NonNull
 	private final PreferenceService preferenceService;
+    @NonNull
+	private final TaskManager taskManager;
+    @NonNull
+    private final TaskCreator taskCreator;
+    @NonNull
+    private final MultiDeviceManager multiDeviceManager;
 	private String policyResponseData;
 	private String policySignature;
 	private int policyErrorCode;
@@ -92,19 +126,29 @@ public class UserServiceImpl implements UserService, CreateIdentityRequestDataIn
 	private boolean isFsEnabled = true;
 
 	public UserServiceImpl(
-		Context context,
-		PreferenceStoreInterface preferenceStore,
-		LocaleService localeService,
-		APIConnector apiConnector,
-		IdentityStore identityStore,
-		PreferenceService preferenceService
+		@NonNull Context context,
+		@NonNull PreferenceStoreInterface preferenceStore,
+		@NonNull LocaleService localeService,
+		@NonNull APIConnector apiConnector,
+        @NonNull ApiService apiService,
+        @NonNull FileService fileService,
+		@NonNull IdentityStore identityStore,
+		@NonNull PreferenceService preferenceService,
+        @NonNull TaskManager taskManager,
+        @NonNull TaskCreator taskCreator,
+        @NonNull MultiDeviceManager multiDeviceManager
 	) {
 		this.context = context;
 		this.preferenceStore = preferenceStore;
 		this.localeService = localeService;
 		this.identityStore = identityStore;
 		this.apiConnector = apiConnector;
+        this.apiService = apiService;
+        this.fileService = fileService;
 		this.preferenceService = preferenceService;
+        this.taskCreator = taskCreator;
+        this.taskManager = taskManager;
+        this.multiDeviceManager = multiDeviceManager;
 	}
 
 	@Override
@@ -437,19 +481,167 @@ public class UserServiceImpl implements UserService, CreateIdentityRequestDataIn
 	}
 
 	@Override
-	public String setPublicNickname(String publicNickname) {
-		//truncate string into a 32 byte length string
-		//fix #ANDR-530
-		String truncated = Utils.truncateUTF8String(publicNickname, ProtocolDefines.PUSH_FROM_LEN);
-		this.identityStore.setPublicNickname(truncated);
-		//run update work info (only if the app is the work version)
-		if(ConfigUtils.isWorkBuild()) {
+	public String setPublicNickname(String publicNickname, @NonNull TriggerSource triggerSource) {
+        final @NonNull String oldNickname = this.identityStore.getPublicNickname();
+		// truncate string into a 32 byte length string
+		// fix #ANDR-530
+		final @Nullable String publicNicknameTruncated = Utils.truncateUTF8String(
+            publicNickname,
+            ProtocolDefines.PUSH_FROM_LEN
+        );
+		this.identityStore.persistPublicNickname(publicNicknameTruncated);
+		// run update work info (only if the app is the work version)
+		if (ConfigUtils.isWorkBuild()) {
 			UpdateWorkInfoRoutine.start();
 		}
-		return truncated;
-	}
+        if (publicNicknameTruncated != null && !publicNicknameTruncated.equals(oldNickname)
+            && multiDeviceManager.isMultiDeviceActive()
+            && triggerSource != TriggerSource.SYNC) {
+            taskManager.schedule(
+                new ReflectUserProfileNicknameSyncTask(
+                    publicNicknameTruncated,
+                    ThreemaApplication.requireServiceManager()
+                )
+            );
+        }
+		return publicNicknameTruncated;
+	}
+
+    @Override
+    @Nullable
+    public byte[] getUserProfilePicture() {
+        try {
+            return toByteArray(fileService.getUserDefinedProfilePictureStream(getIdentity()));
+        } catch (Exception e) {
+            logger.error("Could not get user profile picture");
+            return null;
+        }
+    }
+
+    @Override
+    public boolean setUserProfilePicture(@NonNull File userProfilePicture, @NonNull TriggerSource triggerSource) {
+        try {
+            fileService.writeUserDefinedProfilePicture(getIdentity(), userProfilePicture);
+            onUserProfilePictureChanged();
+            if (multiDeviceManager.isMultiDeviceActive() && triggerSource != TriggerSource.SYNC) {
+               taskCreator.scheduleReflectUserProfilePictureTask();
+            }
+            return true;
+        } catch (Exception e) {
+            logger.error("Could not set user profile picture", e);
+            return false;
+        }
+    }
+
+    @Override
+    public boolean setUserProfilePicture(@NonNull byte[] userProfilePicture, @NonNull TriggerSource triggerSource) {
+        try {
+            fileService.writeUserDefinedProfilePicture(getIdentity(), userProfilePicture);
+            onUserProfilePictureChanged();
+            if (multiDeviceManager.isMultiDeviceActive() && triggerSource != TriggerSource.SYNC) {
+                taskCreator.scheduleReflectUserProfilePictureTask();
+            }
+            return true;
+        } catch (Exception e) {
+            logger.error("Could not set user profile picture", e);
+            return false;
+        }
+    }
+
+    @Override
+    public void removeUserProfilePicture(@NonNull TriggerSource triggerSource) {
+        fileService.removeUserDefinedProfilePicture(getIdentity());
+        onUserProfilePictureChanged();
+        if (multiDeviceManager.isMultiDeviceActive() && triggerSource != TriggerSource.SYNC) {
+            taskCreator.scheduleReflectUserProfilePictureTask();
+        }
+    }
+
+    @Override
+    @WorkerThread
+    @NonNull
+    public ContactService.ProfilePictureUploadData uploadUserProfilePictureOrGetPreviousUploadData() {
+        byte[] profilePicture = getUserProfilePicture();
+        if (profilePicture == null) {
+            // If there is no profile picture set, then return empty upload data with an empty byte
+            // array as blob ID.
+            ContactService.ProfilePictureUploadData data = new ContactService.ProfilePictureUploadData();
+            data.blobId = ContactModel.NO_PROFILE_PICTURE_BLOB_ID;
+            return data;
+        }
+
+        // Only upload blob every 7 days
+        long uploadedAt = preferenceService.getProfilePicUploadDate();
+        Date uploadDeadline = new Date(uploadedAt + ContactUtil.PROFILE_PICTURE_BLOB_CACHE_DURATION);
+        Date now = new Date();
+
+        if (now.after(uploadDeadline)) {
+            logger.info("Uploading profile picture blob");
+
+            ContactService.ProfilePictureUploadData data = uploadContactPhoto(profilePicture);
+
+            if (data == null) {
+                return new ContactService.ProfilePictureUploadData();
+            }
+
+            data.uploadedAt = now.getTime();
+
+            preferenceService.setProfilePicUploadDate(now);
+            preferenceService.setProfilePicUploadData(data);
+            return data;
+        } else {
+            ContactService.ProfilePictureUploadData data = preferenceService.getProfilePicUploadData();
+            if (data != null) {
+                data.uploadedAt = uploadedAt;
+                data.bitmapArray = profilePicture;
+                return data;
+            } else {
+                return new ContactService.ProfilePictureUploadData();
+            }
+        }
+    }
+
+    @Nullable
+    private ContactService.ProfilePictureUploadData uploadContactPhoto(@NonNull byte[] contactPhoto) {
+        ContactService.ProfilePictureUploadData data = new ContactService.ProfilePictureUploadData();
+
+        SecureRandom rnd = new SecureRandom();
+        data.encryptionKey = new byte[NaCl.SYMMKEYBYTES];
+        rnd.nextBytes(data.encryptionKey);
+
+        data.bitmapArray = contactPhoto;
+        byte[] imageData = NaCl.symmetricEncryptData(data.bitmapArray, data.encryptionKey, ProtocolDefines.CONTACT_PHOTO_NONCE);
+        try {
+            BlobUploader blobUploader = this.apiService.createUploader(
+                imageData,
+                false,
+                BlobScope.Public.INSTANCE
+            );
+            data.blobId = blobUploader.upload();
+        } catch (ThreemaException | IOException e) {
+            logger.error("Could not upload contact photo", e);
+
+            if (e instanceof FileNotFoundException && ConfigUtils.isOnPremBuild()) {
+                logger.info("Invalidating auth token");
+                apiService.invalidateAuthToken();
+            }
+
+            return null;
+        }
+        data.size = imageData.length;
+        return data;
+    }
+
+    private void onUserProfilePictureChanged() {
+        // Reset the last profile picture upload date
+        this.preferenceService.setProfilePicUploadDate(new Date(0));
+        this.preferenceService.setProfilePicUploadData(null);
+
+        // Notify listeners
+        ListenerManager.profileListeners.handle(ProfileListener::onAvatarChanged);
+    }
 
-	private String getLanguage() {
+    private String getLanguage() {
 		return LocaleUtil.getLanguage();
 	}
 
diff --git a/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt b/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt
index 45751c37..022f0a8b 100644
--- a/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt
+++ b/app/src/main/java/ch/threema/app/services/VoiceMessagePlayerService.kt
@@ -23,8 +23,6 @@ package ch.threema.app.services
 
 import android.Manifest
 import android.annotation.SuppressLint
-import android.app.NotificationChannel
-import android.app.NotificationManager
 import android.app.PendingIntent
 import android.app.PendingIntent.FLAG_IMMUTABLE
 import android.app.PendingIntent.FLAG_UPDATE_CURRENT
@@ -71,7 +69,6 @@ import com.google.common.util.concurrent.ListenableFuture
 
 @androidx.annotation.OptIn(androidx.media3.common.util.UnstableApi::class)
 class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudioFocusChangeListener {
-    private val logger = LoggingUtil.getThreemaLogger(TAG)
     private val audioBecomingNoisyFilter = IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY)
     private val audioBecomingNoisyReceiver: BroadcastReceiver = object : BroadcastReceiver() {
         override fun onReceive(context: Context, intent: Intent) {
@@ -82,7 +79,7 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
     }
 
     private lateinit var player: ExoPlayer
-    private lateinit var mediaSession: MediaSession
+    private var mediaSession: MediaSession? = null
     private lateinit var audioManager: AudioManager
     private lateinit var audioFocusRequestCompat: AudioFocusRequestCompat
 
@@ -92,6 +89,8 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
 
     companion object {
         private const val TAG = "VoiceMessagePlayerService"
+        private val logger = LoggingUtil.getThreemaLogger(TAG)
+
         private const val NOTIFICATION_ID = 59843
     }
 
@@ -122,8 +121,10 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         mediaNotificationProvider.setSmallIcon(R.drawable.ic_notification_small)
         setMediaNotificationProvider(mediaNotificationProvider)
 
-        initializeSessionAndPlayer()
-        setListener(MediaSessionServiceListener())
+        val sessionWasCreated = initializeSessionAndPlayer()
+        if (sessionWasCreated) {
+            setListener(MediaSessionServiceListener())
+        }
     }
 
     override fun onUpdateNotification(session: MediaSession, startInForegroundRequired: Boolean) {
@@ -133,9 +134,7 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         super.onUpdateNotification(session, true)
     }
 
-    override fun onGetSession(controllerInfo: MediaSession.ControllerInfo): MediaSession {
-        return mediaSession
-    }
+    override fun onGetSession(controllerInfo: MediaSession.ControllerInfo): MediaSession? = mediaSession
 
     override fun onTaskRemoved(rootIntent: Intent?) {
         logger.info("onTaskRemoved")
@@ -146,6 +145,11 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
 
     override fun onDestroy() {
         logger.info("onDestroy")
+        destroySelf()
+        super.onDestroy()
+    }
+
+    private fun destroySelf() {
         preferenceService?.let {
             if (it.isUseProximitySensor) {
                 sensorService?.unregisterSensors(TAG)
@@ -153,22 +157,21 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         }
         releaseAudioFocus()
         player.release()
-        mediaSession.release()
+        mediaSession?.release()
         clearListener()
-        super.onDestroy()
     }
 
-    private fun initializeSessionAndPlayer() {
+    private fun initializeSessionAndPlayer(): Boolean {
         player = ExoPlayer.Builder(this)
-                .setRenderersFactory(SamsungQuirkRenderersFactory(this))
-                .setAudioAttributes(getRegularAudioAttributes(), false)
-                .setWakeMode(C.WAKE_MODE_LOCAL)
-                .setLoadControl(
-                        DefaultLoadControl.Builder()
-                                .setBufferDurationsMs(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE)
-                                .build()
-                )
-                .build()
+            .setRenderersFactory(SamsungQuirkRenderersFactory(this))
+            .setAudioAttributes(getRegularAudioAttributes(), false)
+            .setWakeMode(C.WAKE_MODE_LOCAL)
+            .setLoadControl(
+                DefaultLoadControl.Builder()
+                    .setBufferDurationsMs(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE)
+                    .build()
+            )
+            .build()
 
         preferenceService?.let {
             player.addListener(object : Player.Listener {
@@ -192,32 +195,56 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
         }
 
         val mediaSessionCallback = (object : Callback {
-            override fun onAddMediaItems(mediaSession: MediaSession, controller: MediaSession.ControllerInfo, mediaItems: MutableList<MediaItem>): ListenableFuture<MutableList<MediaItem>> {
+            override fun onAddMediaItems(
+                mediaSession: MediaSession,
+                controller: MediaSession.ControllerInfo,
+                mediaItems: MutableList<MediaItem>
+            ): ListenableFuture<MutableList<MediaItem>> {
                 val resolvedMediaItems = mutableListOf<MediaItem>()
                 for (mediaItem in mediaItems) {
                     val resolvedMediaItem = MediaItem.Builder()
-                            .setUri(Uri.parse(mediaItem.mediaId))
-                            .setMediaId(mediaItem.mediaId)
-                            .setMediaMetadata(mediaItem.mediaMetadata)
-                            .build()
+                        .setUri(Uri.parse(mediaItem.mediaId))
+                        .setMediaId(mediaItem.mediaId)
+                        .setMediaMetadata(mediaItem.mediaMetadata)
+                        .build()
                     resolvedMediaItems.add(resolvedMediaItem)
                 }
                 return Futures.immediateFuture(resolvedMediaItems)
             }
         })
 
-        mediaSession =
-                MediaSession.Builder(this, player)
-                        .setCallback(mediaSessionCallback)
-                        .setSessionActivity(getSessionActivityPendingIntent())
-                        .build()
+        val mediaSessionBuilder = MediaSession
+            .Builder(this, player)
+            .setCallback(mediaSessionCallback)
+            .setSessionActivity(getSessionActivityPendingIntent())
+
+        // TODO(ANDR-3531): Remove this workaround after media3 dependency update to version >= 1.5
+        try {
+            mediaSession = mediaSessionBuilder.build()
+        } catch (exception: IllegalArgumentException) {
+            if (ConfigUtils.isMotorolaDevice()) {
+                // Some motorola devices throw an unexpected IllegalArgumentException.
+                // This workaround can be removed when we update media3-session to >= 1.5
+                // https://github.com/androidx/media/issues/1730
+                logger.error(
+                    "Caught IllegalArgumentException on a motorola device when attempting to set the media button broadcast receiver.",
+                    exception
+                )
+            } else {
+                logger.error("Failed to create a media session.", exception)
+            }
+            destroySelf()
+            stopSelf()
+            return false
+        }
+        return true
     }
 
     private fun getSessionActivityPendingIntent(): PendingIntent {
         val intent = packageManager
-                .getLaunchIntentForPackage(packageName)
-                ?.setPackage(null)
-                ?.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)
+            .getLaunchIntentForPackage(packageName)
+            ?.setPackage(null)
+            ?.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)
 
         val immutableFlag = if (Build.VERSION.SDK_INT >= 23) FLAG_IMMUTABLE else 0
         return getActivity(this, 0, intent, immutableFlag or FLAG_UPDATE_CURRENT)
@@ -235,16 +262,16 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
             if (ConfigUtils.isPermissionGranted(this@VoiceMessagePlayerService, Manifest.permission.POST_NOTIFICATIONS)) {
                 val notificationManagerCompat = NotificationManagerCompat.from(this@VoiceMessagePlayerService)
                 val builder =
-                        NotificationCompat.Builder(this@VoiceMessagePlayerService, NotificationChannels.NOTIFICATION_CHANNEL_ALERT)
-                                .setContentIntent(getSessionActivityPendingIntent())
-                                .setSmallIcon(R.drawable.ic_notification_small)
-                                .setColor(ResourcesCompat.getColor(resources, R.color.md_theme_light_primary, theme))
-                                .setContentTitle(getString(R.string.vm_fg_service_not_allowed))
-                                .setStyle(
-                                        NotificationCompat.BigTextStyle().bigText(getString(R.string.vm_fg_service_not_allowed_explain))
-                                )
-                                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
-                                .setAutoCancel(true)
+                    NotificationCompat.Builder(this@VoiceMessagePlayerService, NotificationChannels.NOTIFICATION_CHANNEL_ALERT)
+                        .setContentIntent(getSessionActivityPendingIntent())
+                        .setSmallIcon(R.drawable.ic_notification_small)
+                        .setColor(ResourcesCompat.getColor(resources, R.color.md_theme_light_primary, theme))
+                        .setContentTitle(getString(R.string.vm_fg_service_not_allowed))
+                        .setStyle(
+                            NotificationCompat.BigTextStyle().bigText(getString(R.string.vm_fg_service_not_allowed_explain))
+                        )
+                        .setPriority(NotificationCompat.PRIORITY_DEFAULT)
+                        .setAutoCancel(true)
 
                 notificationManagerCompat.notify(NOTIFICATION_ID, builder.build())
             } else {
@@ -295,19 +322,22 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
             AudioManager.AUDIOFOCUS_GAIN -> {
                 player.volume = 1.0f
             }
+
             AudioManager.AUDIOFOCUS_LOSS -> {
                 player.pause()
             }
+
             AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {
                 player.pause()
             }
+
             AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {
                 player.volume = 0.2f
             }
         }
     }
 
-    private fun getRegularAudioAttributes() : AudioAttributes {
+    private fun getRegularAudioAttributes(): AudioAttributes {
         return AudioAttributes.Builder()
             .setUsage(C.USAGE_MEDIA)
             .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)
@@ -315,7 +345,7 @@ class VoiceMessagePlayerService : MediaSessionService(), SensorListener, OnAudio
             .build()
     }
 
-    private fun getEarpieceAudioAttributes() : AudioAttributes {
+    private fun getEarpieceAudioAttributes(): AudioAttributes {
         return AudioAttributes.Builder()
             .setUsage(C.USAGE_VOICE_COMMUNICATION)
             .setContentType(C.AUDIO_CONTENT_TYPE_SPEECH)
diff --git a/app/src/main/java/ch/threema/app/services/ballot/BallotService.java b/app/src/main/java/ch/threema/app/services/ballot/BallotService.java
index 79cfc936..8bf08b4a 100644
--- a/app/src/main/java/ch/threema/app/services/ballot/BallotService.java
+++ b/app/src/main/java/ch/threema/app/services/ballot/BallotService.java
@@ -35,7 +35,7 @@ import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotCreateInterface;
+import ch.threema.domain.protocol.csp.messages.ballot.BallotSetupInterface;
 import ch.threema.domain.protocol.csp.messages.ballot.BallotVoteInterface;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
@@ -95,7 +95,7 @@ public interface BallotService {
 	 * @return BallotUpdateResult
 	 * @throws ThreemaException if an error occurred during processing
 	 */
-	@NonNull BallotUpdateResult update(BallotCreateInterface createMessage) throws ThreemaException, BadMessageException;
+	@NonNull BallotUpdateResult update(BallotSetupInterface createMessage) throws ThreemaException, BadMessageException;
 	boolean update(BallotModel ballotModel);
 
 	BallotPublishResult publish(MessageReceiver<?> messageReceiver, BallotModel ballotModel,
diff --git a/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java b/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java
index 90a513d4..a683c7ba 100644
--- a/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/services/ballot/BallotServiceImpl.java
@@ -61,7 +61,7 @@ import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.MessageTooLongException;
 import ch.threema.domain.protocol.csp.messages.AbstractMessage;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotCreateInterface;
+import ch.threema.domain.protocol.csp.messages.ballot.BallotSetupInterface;
 import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.BallotData;
 import ch.threema.domain.protocol.csp.messages.ballot.BallotDataChoice;
@@ -83,1433 +83,1416 @@ import ch.threema.storage.models.ballot.IdentityBallotModel;
 import ch.threema.storage.models.ballot.LinkBallotModel;
 
 public class BallotServiceImpl implements BallotService {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BallotServiceImpl");
-
-	private static final int REQUIRED_CHOICE_COUNT = 2;
-
-	private final SparseArray<BallotModel> ballotModelCache;
-	private final SparseArray<LinkBallotModel> linkBallotModelCache;
-
-	private final DatabaseServiceNew databaseServiceNew;
-	private final UserService userService;
-	private final GroupService groupService;
-	private final ContactService contactService;
-	private final ServiceManager serviceManager;
-
-	private int openBallotId = 0;
-
-	public BallotServiceImpl(SparseArray<BallotModel> ballotModelCache,
-	                         SparseArray<LinkBallotModel> linkBallotModelCache,
-	                         DatabaseServiceNew databaseServiceNew,
-	                         UserService userService,
-	                         GroupService groupService,
-	                         ContactService contactService,
-	                         ServiceManager serviceManager) {
-		this.ballotModelCache = ballotModelCache;
-		this.linkBallotModelCache = linkBallotModelCache;
-		this.databaseServiceNew = databaseServiceNew;
-		this.userService = userService;
-		this.groupService = groupService;
-		this.contactService = contactService;
-		this.serviceManager = serviceManager;
-	}
-
-	@Override
-	public BallotModel create(GroupModel groupModel,
-							  String description,
-							  BallotModel.State state,
-							  BallotModel.Assessment assessment,
-							  BallotModel.Type type,
-							  BallotModel.ChoiceType choiceType) throws NotAllowedException {
-
-		final BallotModel model = this.create(description, state, assessment, type, choiceType);
-		if (model != null) {
-			this.link(groupModel, model);
-			//handle
-		}
-
-
-		return model;
-	}
-
-	@Override
-	public boolean modifyFinished(final BallotModel ballotModel) throws MessageTooLongException {
-		if(ballotModel != null) {
-			switch (ballotModel.getState()) {
-				case TEMPORARY:
-					ballotModel.setState(BallotModel.State.OPEN);
-					try {
-						this.checkAccess();
-						this.databaseServiceNew.getBallotModelFactory().update(
-								ballotModel
-						);
-					} catch (NotAllowedException e) {
-						logger.error("Exception", e);
-						return false;
-					}
-
-					try {
-						return this.send(ballotModel, listener -> {
-							if (listener.handle(ballotModel)) {
-								listener.onCreated(ballotModel);
-							}
-						});
-					} catch (MessageTooLongException e) {
-						ballotModel.setState(BallotModel.State.TEMPORARY);
-						this.databaseServiceNew.getBallotModelFactory().update(
-							ballotModel
-						);
-						throw new MessageTooLongException();
-					}
-				default:
-					this.handleModified(ballotModel);
-					break;
-			}
-			return true;
-		}
-		return false;
-	}
-
-	@Override
-	public boolean viewingBallot(BallotModel ballotModel,  boolean view) {
-		if(ballotModel != null) {
-			if(view) {
-				ballotModel.setLastViewedAt(new Date());
-				this.databaseServiceNew.getBallotModelFactory().update(
-						ballotModel);
-				this.openBallotId = ballotModel.getId();
-				//disabled for the moment!
+    private static final Logger logger = LoggingUtil.getThreemaLogger("BallotServiceImpl");
+
+    private static final int REQUIRED_CHOICE_COUNT = 2;
+
+    private final SparseArray<BallotModel> ballotModelCache;
+    private final SparseArray<LinkBallotModel> linkBallotModelCache;
+
+    private final DatabaseServiceNew databaseServiceNew;
+    private final UserService userService;
+    private final GroupService groupService;
+    private final ContactService contactService;
+    private final ServiceManager serviceManager;
+
+    private int openBallotId = 0;
+
+    public BallotServiceImpl(SparseArray<BallotModel> ballotModelCache,
+                             SparseArray<LinkBallotModel> linkBallotModelCache,
+                             DatabaseServiceNew databaseServiceNew,
+                             UserService userService,
+                             GroupService groupService,
+                             ContactService contactService,
+                             ServiceManager serviceManager) {
+        this.ballotModelCache = ballotModelCache;
+        this.linkBallotModelCache = linkBallotModelCache;
+        this.databaseServiceNew = databaseServiceNew;
+        this.userService = userService;
+        this.groupService = groupService;
+        this.contactService = contactService;
+        this.serviceManager = serviceManager;
+    }
+
+    @Override
+    public BallotModel create(GroupModel groupModel,
+                              String description,
+                              BallotModel.State state,
+                              BallotModel.Assessment assessment,
+                              BallotModel.Type type,
+                              BallotModel.ChoiceType choiceType) throws NotAllowedException {
+
+        final BallotModel model = this.create(description, state, assessment, type, choiceType);
+        if (model != null) {
+            this.link(groupModel, model);
+            //handle
+        }
+
+
+        return model;
+    }
+
+    @Override
+    public boolean modifyFinished(final BallotModel ballotModel) throws MessageTooLongException {
+        if (ballotModel != null) {
+            switch (ballotModel.getState()) {
+                case TEMPORARY:
+                    ballotModel.setState(BallotModel.State.OPEN);
+                    try {
+                        this.checkAccess();
+                        this.databaseServiceNew.getBallotModelFactory().update(
+                            ballotModel
+                        );
+                    } catch (NotAllowedException e) {
+                        logger.error("Exception", e);
+                        return false;
+                    }
+
+                    try {
+                        return this.send(ballotModel, listener -> {
+                            if (listener.handle(ballotModel)) {
+                                listener.onCreated(ballotModel);
+                            }
+                        });
+                    } catch (MessageTooLongException e) {
+                        ballotModel.setState(BallotModel.State.TEMPORARY);
+                        this.databaseServiceNew.getBallotModelFactory().update(
+                            ballotModel
+                        );
+                        throw new MessageTooLongException();
+                    }
+                default:
+                    this.handleModified(ballotModel);
+                    break;
+            }
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean viewingBallot(BallotModel ballotModel, boolean view) {
+        if (ballotModel != null) {
+            if (view) {
+                ballotModel.setLastViewedAt(new Date());
+                this.databaseServiceNew.getBallotModelFactory().update(
+                    ballotModel);
+                this.openBallotId = ballotModel.getId();
+                //disabled for the moment!
 //						this.handleModified(ballotModel);
-				return true;
-			}
-			else if(this.openBallotId == ballotModel.getId()) {
-				this.openBallotId = 0;
-			}
-
-		}
-		return false;
-	}
-
-	@Override
-	public BallotModel create(ContactModel contactModel,
-							  String description,
-							  BallotModel.State state,
-							  BallotModel.Assessment assessment,
-							  BallotModel.Type type,
-							  BallotModel.ChoiceType choiceType) throws NotAllowedException {
-		final BallotModel model = this.create(description,state,assessment,type, choiceType);
-		if(model != null) {
-			this.link(contactModel, model);
-		}
-
-		return model;
-	}
-
-	private BallotModel create(String description,
-							  BallotModel.State state,
-							  BallotModel.Assessment assessment,
-							  BallotModel.Type type,
-							  BallotModel.ChoiceType choiceType) throws NotAllowedException {
-		//create a new blank model
-		try {
-			this.checkAccess();
-
-
-
-			final BallotModel ballotModel = new BallotModel();
-			//unique id
-			String randomId = UUID.randomUUID().toString();
-			BallotId newBallotId = new BallotId(
-					Utils.hexStringToByteArray(
-							randomId.substring(randomId.length() - (ProtocolDefines.BALLOT_ID_LEN * 2))
-					));
-
-			ballotModel.setApiBallotId(Utils.byteArrayToHexString(newBallotId.getBallotId()));
-			ballotModel.setCreatorIdentity(this.userService.getIdentity());
-			ballotModel.setCreatedAt(new Date());
-			ballotModel.setModifiedAt(new Date());
-			ballotModel.setName(description);
-			ballotModel.setState(state);
-			ballotModel.setAssessment(assessment);
-			ballotModel.setType(type);
-			ballotModel.setChoiceType(choiceType);
-			ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE); // default display type for ballots created on mobile client.
-			ballotModel.setLastViewedAt(new Date());
-
-			this.databaseServiceNew.getBallotModelFactory().create(
-					ballotModel
-			);
-
-			this.cache(ballotModel);
-
-			return ballotModel;
-
-		}
-		catch (NotAllowedException notAllowedException) {
-			logger.error("Not allowed", notAllowedException);
-			throw notAllowedException;
-		}
-		catch (ThreemaException e) {
-			logger.error("Exception", e);
-			return null;
-		}
-	}
-
-	@Override
-	public boolean update(BallotModel ballotModel, BallotChoiceModel choice) throws NotAllowedException {
-		if(choice.getId() > 0 && choice.getBallotId() > 0 && choice.getBallotId() != ballotModel.getId()) {
-			throw new NotAllowedException("choice already set on another ballot");
-		}
-
-		if(choice.getApiBallotChoiceId() <= 0) {
-			throw new NotAllowedException("no api ballot choice id set");
-		}
-		choice.setBallotId(ballotModel.getId());
-
-		if(choice.getCreatedAt() == null) {
-			choice.setCreatedAt(new Date());
-		}
-
-		choice.setModifiedAt(new Date());
-
-		return this.databaseServiceNew.getBallotChoiceModelFactory().create(
-				choice
-		);
-	}
-
-	@Override
-	public boolean close(Integer ballotModelId) throws NotAllowedException, MessageTooLongException {
-		//be sure to use the cached ballot model!
-		final BallotModel ballotModel = this.get(ballotModelId);
-
-		//if i am not the creator
-		if(!BallotUtil.canClose(ballotModel, this.userService.getIdentity())) {
-			throw new NotAllowedException();
-		}
-
-		MessageReceiver messageReceiver = this.getReceiver(ballotModel);
-		if(messageReceiver == null) {
-			return false;
-		}
-
-		//save model
-		ballotModel.setState(BallotModel.State.CLOSED);
-		if (this.update(ballotModel)) {
-			return this.send(ballotModel, listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onClosed(ballotModel);
-				}
-			});
-		}
-		return false;
-	}
-
-	@Override
-	public boolean send(BallotModel ballotModel, ListenerManager.HandleListener<BallotListener> handleListener) throws MessageTooLongException {
-		//add message
-		if (TestUtil.compare(userService.getIdentity(), ballotModel.getCreatorIdentity())) {
-			//ok, i am the creator.... send a message to every participant
-			try {
-				if (serviceManager.getMessageService() != null) {
-					if (serviceManager.getMessageService().sendBallotMessage(ballotModel) != null) {
-						ListenerManager.ballotListeners.handle(handleListener);
-						return true;
-					}
-				}
-			} catch (ThreemaException e) {
-				logger.error("Exception", e);
-				if (e instanceof MessageTooLongException) {
-					throw new MessageTooLongException();
-				}
-			}
-		}
-		return false;
-	}
-
-	@Override
-	@Nullable
-	public BallotModel get(int ballotId) {
-		BallotModel model = this.getFromCache(ballotId);
-		if(model == null) {
-			model = this.databaseServiceNew.getBallotModelFactory().getById(
-					ballotId
-			);
-
-			this.cache(model);
-		}
-		return model;
-	}
-
-	@Override
-	@NonNull
-	public BallotUpdateResult update(BallotCreateInterface createMessage) throws ThreemaException, BadMessageException {
-		//check if allowed
-		BallotData data = createMessage.getData();
-		if (data == null) {
-			throw new ThreemaException("invalid format");
-		}
-
-		final BallotModel.State toState;
-		final BallotModel ballotModel;
-
-		Date date = ((AbstractMessage)createMessage).getDate();
-		BallotModel existingModel = this.get(createMessage.getBallotId().toString(), createMessage.getBallotCreator());
-
-		if (existingModel != null) {
-			if (data.getDisplayType() != null && existingModel.getDisplayType() != null && data.getDisplayType().ordinal() != existingModel.getDisplayType().ordinal()) {
-				throw new BadMessageException("Ballot display mode not allowed to change. Discarding message");
-			}
-			if (data.getState() == BallotData.State.CLOSED) {
-				ballotModel = existingModel;
-				toState = BallotModel.State.CLOSED;
-			}
-			else {
-				throw new BadMessageException("Ballot with same ID already exists. Discarding message.");
-			}
-		} else {
-			if (data.getState() != BallotData.State.CLOSED) {
-				ballotModel = new BallotModel();
-				ballotModel.setCreatorIdentity(createMessage.getBallotCreator());
-				ballotModel.setApiBallotId(createMessage.getBallotId().toString());
-				ballotModel.setCreatedAt(date);
-				ballotModel.setLastViewedAt(null);
-				toState = BallotModel.State.OPEN;
-			} else {
-				throw new BadMessageException("New ballot with closed state requested. Discarding message.");
-			}
-		}
-
-		ballotModel.setName(data.getDescription());
-		ballotModel.setModifiedAt(new Date());
-
-		switch (data.getAssessmentType()) {
-			case MULTIPLE:
-				ballotModel.setAssessment(BallotModel.Assessment.MULTIPLE_CHOICE);
-				break;
-			case SINGLE:
-				ballotModel.setAssessment(BallotModel.Assessment.SINGLE_CHOICE);
-				break;
-		}
-
-		switch (data.getType()) {
-			case RESULT_ON_CLOSE:
-				ballotModel.setType(BallotModel.Type.RESULT_ON_CLOSE);
-				break;
-			case INTERMEDIATE:
-				ballotModel.setType(BallotModel.Type.INTERMEDIATE);
-				break;
-		}
-
-		switch (data.getChoiceType()) {
-			case TEXT:
-				ballotModel.setChoiceType(BallotModel.ChoiceType.TEXT);
-				break;
-		}
-
-		switch (data.getDisplayType()) {
-			case SUMMARY_MODE:
-				ballotModel.setDisplayType(BallotModel.DisplayType.SUMMARY_MODE);
-				break;
-			case LIST_MODE:
-			default:
-				ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE);
-				break;
-
-		}
-
-		ballotModel.setState(toState);
-
-		if (toState == BallotModel.State.OPEN) {
-			this.databaseServiceNew.getBallotModelFactory().create(
-					ballotModel
-			);
-		}
-		else {
-			this.databaseServiceNew.getBallotModelFactory().update(
-					ballotModel
-			);
-		}
-
-		if(createMessage instanceof GroupPollSetupMessage) {
-			GroupModel groupModel;
-			groupModel = this.groupService.getByGroupMessage((GroupPollSetupMessage) createMessage);
-			if (groupModel == null) {
-				throw new ThreemaException("invalid group");
-			}
-			//link with group
-			this.link(groupModel, ballotModel);
-		}
-		else if(createMessage instanceof PollSetupMessage) {
-			ContactModel contactModel = this.contactService.getByIdentity(createMessage.getBallotCreator());
-			if (contactModel == null) {
-				throw new ThreemaException("invalid identity");
-			}
-			//link with group
-			this.link(contactModel, ballotModel);
-		}
-		else {
-			throw new ThreemaException("invalid");
-		}
-
-		if (toState == BallotModel.State.CLOSED && ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE) {
-			//first remove all previously known votes if result should be shown in list mode to ensure a common result for all participants
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
-					ballotModel.getId()
-			);
-		}
-
-		//create choices of ballot
-		for (BallotDataChoice apiChoice: data.getChoiceList()) {
-			//check if choice already exist
-			BallotChoiceModel ballotChoiceModel = this.getChoiceByApiId(ballotModel, apiChoice.getId());
-			if(ballotChoiceModel == null) {
-				ballotChoiceModel = new BallotChoiceModel();
-				ballotChoiceModel.setBallotId(ballotModel.getId());
-				ballotChoiceModel.setApiBallotChoiceId(apiChoice.getId());
-			}
-
-			// save returned total vote count if ballot is in summary mode (case broadcast poll)
-			if (ballotModel.getDisplayType() == BallotModel.DisplayType.SUMMARY_MODE) {
-				ballotChoiceModel.setVoteCount(apiChoice.getTotalVotes());
-			}
-
-			ballotChoiceModel.setName(apiChoice.getName());
-			ballotChoiceModel.setOrder(apiChoice.getOrder());
-			switch (data.getChoiceType()) {
-				case TEXT:
-					ballotChoiceModel.setType(BallotChoiceModel.Type.Text);
-					break;
-			}
-			ballotChoiceModel.setCreatedAt(date);
-
-			this.databaseServiceNew.getBallotChoiceModelFactory().createOrUpdate(
-					ballotChoiceModel
-			);
-
-			//save individual votes received in case result should be shown in list mode for each participant (case mobile client user poll)
-			if (ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE && !data.getParticipants().isEmpty()) {
-				int participantPos = 0;
-				for(String p: data.getParticipants()) {
-					BallotVoteModel voteModel = new BallotVoteModel();
-					voteModel.setBallotId(ballotModel.getId());
-					voteModel.setBallotChoiceId(ballotChoiceModel.getId());
-					voteModel.setVotingIdentity(p);
-					voteModel.setChoice(apiChoice.getResult(participantPos));
-					voteModel.setModifiedAt(new Date());
-					voteModel.setCreatedAt(new Date());
-
-					this.databaseServiceNew.getBallotVoteModelFactory().create(
-						voteModel
-					);
-
-					participantPos++;
-				}
-			}
-		}
-
-		if (toState == BallotModel.State.OPEN) {
-			this.cache(ballotModel);
-			this.send(ballotModel, listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onCreated(ballotModel);
-				}
-			});
-
-			return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CREATE);
-		}
-		else {
-			// toState == BallotModel.State.CLOSED
-			this.send(ballotModel, listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onClosed(ballotModel);
-				}
-			});
-			return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CLOSE);
-		}
-	}
-
-	@Override
-	public BallotModel get(String id, String creator) {
-		if(TestUtil.isEmptyOrNull(id, creator)) {
-			return null;
-		}
-
-		BallotModel model = this.getFromCache(id, creator);
-		if(model == null) {
-			model = this.databaseServiceNew.getBallotModelFactory().getByApiBallotIdAndIdentity(
-					id,
-					creator
-			);
-
-			this.cache(model);
-		}
-
-		return model;
-	}
-
-	@Override
-	public List<BallotModel> getBallots(final BallotFilter filter) {
-		List<BallotModel> ballots = this.databaseServiceNew.getBallotModelFactory().filter(
-				filter
-		);
-		this.cache(ballots);
-
-		if(filter != null) {
-			return Functional.filter(ballots, new IPredicateNonNull<BallotModel>() {
-				@Override
-				public boolean apply(@NonNull BallotModel type) {
-					return filter.filter(type);
-				}
-			});
-		}
-		else {
-			return ballots;
-		}
-	}
-
-	@Override
-	public long countBallots(final BallotFilter filter) {
-		return this.databaseServiceNew.getBallotModelFactory().count(filter);
-	}
-
-	@Override
-	public List<BallotChoiceModel> getChoices(Integer ballotModelId) throws NotAllowedException {
-		if(ballotModelId == null) {
-			throw new NotAllowedException();
-		}
-
-		return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotId(
-				ballotModelId
-		);
-	}
-
-	@Override
-	public int getVotingCount(BallotChoiceModel choiceModel) {
-		BallotModel b = this.get(choiceModel.getBallotId());
-		if(b == null) {
-			return 0;
-		}
-
-		return this.getCalculatedVotingCount(choiceModel);
-	}
-
-
-	@Override
-	public boolean update(final BallotModel ballotModel) {
-		ballotModel.setModifiedAt(new Date());
-		this.databaseServiceNew.getBallotModelFactory().update(
-				ballotModel);
-
-		this.handleModified(ballotModel);
-		return true;
-	}
-
-	@Override
-	public boolean removeVotes(final MessageReceiver receiver, final String identity) {
-		List<BallotModel> ballots = this.getBallots(new BallotFilter() {
-			@Override
-			public MessageReceiver getReceiver() {
-				return receiver;
-			}
-
-			@Override
-			public BallotModel.State[] getStates() {
-				return new BallotModel.State[0];
-			}
-
-			@Override
-			public boolean filter(BallotModel ballotModel) {
-				return true;
-			}
-		});
-
-		for(final BallotModel ballotModel: ballots) {
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
-					ballotModel.getId(),
-					identity
-			);
-
-			ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
-				@Override
-				public void handle(BallotVoteListener listener) {
-					if(listener.handle(ballotModel)) {
-						listener.onVoteRemoved(ballotModel, identity);
-					}
-				}
-			});
-		}
-
-		return true;
-	}
-
-	@Override
-	@NonNull
-	public List<String> getVotedParticipants(Integer ballotModelId) {
-		List<String> identities = new ArrayList<>();
-
-		if(ballotModelId !=null) {
-			List<BallotVoteModel> ballotVotes = this.getBallotVotes(ballotModelId);
-			for (BallotVoteModel v : ballotVotes) {
-				if (!identities.contains(v.getVotingIdentity())) {
-					identities.add(v.getVotingIdentity());
-				}
-			}
-		}
-		return identities;
-	}
-
-	@Override
-	@NonNull
-	public List<String> getPendingParticipants(Integer ballotModelId) {
-		String[] allParticipants = this.getParticipants(ballotModelId);
-		List<String> pendingParticipants = new ArrayList<>();
-		if(allParticipants.length > 0) {
-			for(String i: allParticipants) {
-				List<BallotVoteModel> voteModels = this.getVotes(ballotModelId, i);
-				if(voteModels == null || voteModels.size() == 0) {
-					pendingParticipants.add(i);
-				}
-			}
-		}
-
-		return pendingParticipants;
-	}
-
-
-	@Override
-	@NonNull
-	public String[] getParticipants(MessageReceiver messageReceiver) {
-		if(messageReceiver != null) {
-			switch (messageReceiver.getType()) {
-				case MessageReceiver.Type_GROUP:
-					return this.groupService.getGroupIdentities(((GroupMessageReceiver)messageReceiver).getGroup());
-
-				case MessageReceiver.Type_CONTACT:
-					return new String[] {
-							this.userService.getIdentity(),
-							((ContactMessageReceiver)messageReceiver).getContact().getIdentity()
-					};
-				case MessageReceiver.Type_DISTRIBUTION_LIST:
-					break;
-			}
-		}
-		return new String[0];
-	}
-
-	@Override
-	@NonNull
-	public String[] getParticipants(Integer ballotModelId) {
-		BallotModel b = this.get(ballotModelId);
-		if (b != null) {
-			try {
-				LinkBallotModel link = this.getLinkedBallotModel(b);
-				if (link != null) {
-					switch (link.getType()) {
-						case GROUP:
-							GroupModel groupModel = this.getGroupModel(link);
-							if (groupModel != null) {
-								return this.groupService.getGroupIdentities(this.getGroupModel(link));
-							}
-							break;
-						case CONTACT:
-							ContactModel contactModel = this.getContactModel(link);
-							if (contactModel != null) {
-								return new String[]{
-										this.userService.getIdentity(),
-										contactModel.getIdentity()};
-							}
-							break;
-
-						default:
-							throw new NotAllowedException("invalid type");
-					}
-				}
-			} catch (NotAllowedException e) {
-				logger.error("Exception", e);
-			}
-		}
-
-		return new String[0];
-	}
-
-	private List<BallotVoteModel> getVotes(Integer ballotModelId, String fromIdentity) {
-		if(ballotModelId == null) {
-			return null;
-		}
-
-		return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotIdAndVotingIdentity(
-				ballotModelId,
-				fromIdentity
-		);
-	}
-
-	@Override
-	public boolean hasVoted(Integer ballotModelId, String fromIdentity) {
-		if(ballotModelId == null) {
-			return false;
-		}
-
-		return this.databaseServiceNew.getBallotVoteModelFactory().countByBallotIdAndVotingIdentity(
-			ballotModelId,
-			fromIdentity
-		) > 0L;
-	}
-
-	@Override
-	public List<BallotVoteModel> getMyVotes(Integer ballotModelId) {
-		return this.getVotes(ballotModelId, this.userService.getIdentity());
-	}
-
-	@Override
-	public List<BallotVoteModel> getBallotVotes(Integer ballotModelId) {
-		if(ballotModelId == null) {
-			return null;
-		}
-		return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotId(
-				ballotModelId);
-	}
-
-
-	@Override
-	public boolean removeAll() {
-		this.databaseServiceNew.getBallotModelFactory().deleteAll();
-		this.databaseServiceNew.getBallotVoteModelFactory().deleteAll();
-		this.databaseServiceNew.getBallotChoiceModelFactory().deleteAll();
-		this.databaseServiceNew.getGroupBallotModelFactory().deleteAll();
-		return true;
-	}
-
-	@Override
-	public BallotPublishResult publish(MessageReceiver messageReceiver, final BallotModel ballotModel, AbstractMessageModel abstractMessageModel) throws NotAllowedException, MessageTooLongException {
-		return this.publish(messageReceiver, ballotModel, abstractMessageModel, null);
-	}
-
-	@Override
-	public BallotPublishResult publish(MessageReceiver messageReceiver,
-	                                   final BallotModel ballotModel,
-	                                   AbstractMessageModel abstractMessageModel,
-	                                   @Nullable Collection<String> receivingIdentities
-	) throws NotAllowedException, MessageTooLongException {
-		BallotPublishResult result = new BallotPublishResult();
-
-		this.checkAccess();
-
-		if(!TestUtil.required(messageReceiver, ballotModel)) {
-			return result;
-		}
-
-		// validate choices
-		List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
-		if(choices == null || choices.size() < REQUIRED_CHOICE_COUNT) {
-			return result.error(R.string.ballot_error_more_than_x_choices);
-		}
-
-		switch (messageReceiver.getType()) {
-			case MessageReceiver.Type_GROUP:
-				this.link(((GroupMessageReceiver)messageReceiver).getGroup(), ballotModel);
-				break;
-
-			case MessageReceiver.Type_CONTACT:
-				this.link(((ContactMessageReceiver)messageReceiver).getContact(), ballotModel);
-				break;
-		}
-
-		final boolean isClosing = ballotModel.getState() == BallotModel.State.CLOSED;
-
-		BallotData ballotData = new BallotData();
-		ballotData.setDescription(ballotModel.getName());
-
-		switch (ballotModel.getChoiceType()) {
-			case TEXT:
-				ballotData.setChoiceType(BallotData.ChoiceType.TEXT);
-				break;
-		}
-
-		switch (ballotModel.getType()) {
-			case RESULT_ON_CLOSE:
-				ballotData.setType(BallotData.Type.RESULT_ON_CLOSE);
-				break;
-			case INTERMEDIATE:
-			default:
-				ballotData.setType(BallotData.Type.INTERMEDIATE);
-		}
-
-		switch (ballotModel.getAssessment()) {
-			case MULTIPLE_CHOICE:
-				ballotData.setAssessmentType(BallotData.AssessmentType.MULTIPLE);
-				break;
-			case SINGLE_CHOICE:
-			default:
-				ballotData.setAssessmentType(BallotData.AssessmentType.SINGLE);
-		}
-
-		switch (ballotModel.getState()) {
-			case CLOSED:
-				ballotData.setState(BallotData.State.CLOSED);
-				break;
-			case OPEN:
-			default:
-				ballotData.setState(BallotData.State.OPEN);
-		}
-
-		switch (ballotModel.getDisplayType()) {
-			case SUMMARY_MODE:
-				ballotData.setDisplayType(BallotData.DisplayType.SUMMARY_MODE);
-				break;
-			case LIST_MODE:
-			default:
-				ballotData.setDisplayType(BallotData.DisplayType.LIST_MODE);
-				break;
-		}
-
-		HashMap<String, Integer> votersPositions = new HashMap<>();
-		List<BallotVoteModel> voteModels = null;
-		int votersCount = 0;
-		if (isClosing || receivingIdentities != null) {
-			// load a list of voters
-			String[] voters = this.getVotedParticipants(ballotModel.getId()).toArray(new String[0]);
-
-			for (String s : voters) {
-				ballotData.addParticipant(s);
-				votersPositions.put(s, votersCount);
-				votersCount++;
-			}
-
-			voteModels = this.getBallotVotes(ballotModel.getId());
-		}
-		// if closing, add result!
-		for(final BallotChoiceModel c: choices) {
-			BallotDataChoice choice = new BallotDataChoice(votersCount);
-			choice.setId(c.getApiBallotChoiceId());
-			choice.setName(c.getName());
-			choice.setOrder(c.getOrder());
-
-			if ((isClosing || receivingIdentities != null) && TestUtil.required(voteModels, votersPositions)) {
-
-				for(BallotVoteModel v: Functional.filter(voteModels, new IPredicateNonNull<BallotVoteModel>() {
-					@Override
-					public boolean apply(@NonNull BallotVoteModel type) {
-						return type.getBallotChoiceId() == c.getId();
-					}
-				})){
-					int pos = votersPositions.get(v.getVotingIdentity());
-					if(pos >= 0) {
-						choice.addResult(pos, v.getChoice());
-					}
-				}
-
-			}
-			ballotData.getChoiceList().add(choice);
-		}
-
-		try {
-			messageReceiver.createAndSendBallotSetupMessage(
-				ballotData,
-				ballotModel,
-				abstractMessageModel,
-				null,
-				receivingIdentities
-			);
-
-			//set as open
-			if(ballotModel.getState() == BallotModel.State.TEMPORARY) {
-				ballotModel.setState(BallotModel.State.OPEN);
-				ballotModel.setModifiedAt(new Date());
-
-				this.databaseServiceNew.getBallotModelFactory().update(
-						ballotModel
-				);
-
-			}
-
-			result.success();
-		} catch (ThreemaException e) {
-			logger.error("create boxed ballot failed", e);
-			if (e instanceof MessageTooLongException) {
-				throw new MessageTooLongException();
-			}
-		}
-
-		return result;
-	}
-
-	@Override
-	public LinkBallotModel getLinkedBallotModel(BallotModel ballotModel) throws NotAllowedException {
-		if(ballotModel == null) {
-			return null;
-		}
-
-		LinkBallotModel linkBallotModel = this.getLinkModelFromCache(ballotModel.getId());
-		if(linkBallotModel != null) {
-			return linkBallotModel;
-		}
-
-		GroupBallotModel group = this.databaseServiceNew.getGroupBallotModelFactory().getByBallotId(
-				ballotModel.getId());
-
-		if(group != null) {
-			this.cache(group);
-			return group;
-		}
-
-		IdentityBallotModel identityBallotModel = this.databaseServiceNew.getIdentityBallotModelFactory().getByBallotId(
-				ballotModel.getId()
-		);
-		if(identityBallotModel != null) {
-			this.cache(identityBallotModel);
-			return identityBallotModel;
-		}
-
-		return null;
-	}
-
-	@Override
-	public boolean remove(final BallotModel ballotModel) throws NotAllowedException {
-		if (serviceManager == null) {
-			logger.debug("Unable to delete ballot, ServiceManager is not available");
-			return false;
-		}
-
-		MessageService messageService;
-		try {
-			messageService = serviceManager.getMessageService();
-		} catch (ThreemaException e) {
-			logger.error("Unable to delete ballot, MessageService not available", e);
-			return false;
-		}
-
-		if (ballotModel != null) {
-			List<AbstractMessageModel> messageModels = messageService.getMessageForBallot(ballotModel);
-
-			//remove all votes
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			//remove choices
-			this.databaseServiceNew.getBallotChoiceModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			//remove link
-			this.databaseServiceNew.getGroupBallotModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			this.databaseServiceNew.getIdentityBallotModelFactory().deleteByBallotId(
-				ballotModel.getId());
-
-			//remove ballot
-			this.databaseServiceNew.getBallotModelFactory().delete(
-				ballotModel
-			);
-
-			// delete associated messages
-			if (messageModels != null) {
-				for (AbstractMessageModel m : messageModels) {
-					if (m != null) {
-						try {
-							logger.debug("Removing ballot message {} of type {}", m.getApiMessageId() != null ? m.getApiMessageId() : m.getId(), m.getBallotData().getType());
-							messageService.remove(m);
-						} catch (Exception e) {
-							logger.error("Unable to remove message", e);
-						}
-					}
-				}
-			}
-
-			// remove ballot from cache
-			this.resetCache(ballotModel);
-
-			ListenerManager.ballotListeners.handle(listener -> {
-				if (listener.handle(ballotModel)) {
-					listener.onRemoved(ballotModel);
-				}
-			});
-		}
-		return true;
-	}
-
-	@Override
-	public boolean remove(final MessageReceiver receiver) {
-		try {
-			for(BallotModel ballotModel: this.getBallots(new BallotFilter() {
-				@Override
-				public MessageReceiver getReceiver() {
-					return receiver;
-				}
-
-				@Override
-				public BallotModel.State[] getStates() {
-					return null;
-				}
-
-				@Override
-				public boolean filter(BallotModel ballotModel) {
-					return true;
-				}
-			})) {
-				if(!this.remove(ballotModel)) {
-					return false;
-				}
-			}
-		}
-		catch (NotAllowedException x) {
-			//do nothing more
-			logger.error("Exception", x);
-			return false;
-		}
-
-		return true;
-	}
-
-	@Override
-	public boolean belongsToMe(Integer ballotModelId, MessageReceiver messageReceiver) throws NotAllowedException {
-		BallotModel ballotModel = this.get(ballotModelId);
-
-		if(!TestUtil.required(ballotModel, messageReceiver)) {
-			return false;
-		}
-
-		switch (messageReceiver.getType()) {
-			case MessageReceiver.Type_CONTACT:
-			case MessageReceiver.Type_GROUP:
-				LinkBallotModel l = this.getLinkedBallotModel(ballotModel);
-				if(l != null) {
-					if(messageReceiver.getType() == MessageReceiver.Type_GROUP && l.getType() == LinkBallotModel.Type.GROUP) {
-						return ((GroupBallotModel)l).getGroupId() == ((GroupMessageReceiver)messageReceiver).getGroup().getId();
-					}
-					else if(messageReceiver.getType() == MessageReceiver.Type_CONTACT && l.getType() == LinkBallotModel.Type.CONTACT) {
-						return TestUtil.compare(((IdentityBallotModel)l).getIdentity(), ((ContactMessageReceiver)messageReceiver).getContact().getIdentity());
-					}
-				}
-		}
-
-		return false;
-	}
-
-	@Override
-	public BallotVoteResult vote(Integer ballotModelId, Map<Integer, Integer> voting) throws NotAllowedException {
-		BallotModel ballotModel = this.get(ballotModelId);
-
-		if(!TestUtil.required(ballotModel, voting)) {
-			return new BallotVoteResult(false);
-		}
-
-		List<BallotChoiceModel> allChoices = this.getChoices(ballotModel.getId());
-		if(allChoices == null) {
-			return new BallotVoteResult(false);
-		}
-
-		LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
-		MessageReceiver messageReceiver = this.getReceiver(link);
-
-		if(messageReceiver == null) {
-			return new BallotVoteResult(false);
-		}
-
-		//prepare all messages and save local
-		BallotVote[] votes = new BallotVote[allChoices.size()];
-		int n = 0;
-		for(final BallotChoiceModel choiceModel: allChoices) {
-			BallotVote vote = new BallotVote();
-			vote.setId(choiceModel.getApiBallotChoiceId());
-
-			//change if other values implement
-			if(voting.containsKey(choiceModel.getId())){
-				vote.setValue(voting.get(choiceModel.getId()));
-			}
-			else {
-				vote.setValue(0);
-			}
-
-			votes[n] = vote;
-			n++;
-		}
-
-		try {
-			//send
-			messageReceiver.createAndSendBallotVoteMessage(votes, ballotModel);
-
-			//and save
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
-					ballotModel.getId(),
-					this.userService.getIdentity()
-			);
-
-			for(BallotChoiceModel choiceModel: allChoices) {
-				BallotVoteModel ballotVoteModel = new BallotVoteModel();
-				ballotVoteModel.setVotingIdentity(this.userService.getIdentity());
-				ballotVoteModel.setBallotId(ballotModel.getId());
-				ballotVoteModel.setBallotChoiceId(choiceModel.getId());
-
-				if(voting.containsKey(choiceModel.getId())){
-					ballotVoteModel.setChoice(voting.get(choiceModel.getId()));
-				}
-				else {
-					ballotVoteModel.setChoice(0);
-				}
-
-				ballotVoteModel.setModifiedAt(new Date());
-				ballotVoteModel.setCreatedAt(new Date());
-				this.databaseServiceNew.getBallotVoteModelFactory().create(
-						ballotVoteModel
-				);
-			}
-		} catch (ThreemaException e) {
-			logger.error("create boxed ballot failed", e);
-			return new BallotVoteResult(false);
-		}
-
-		ListenerManager.ballotVoteListeners.handle(listener -> {
-			if(listener.handle(ballotModel)) {
-				listener.onSelfVote(
-					ballotModel);
-			}
-		});
-
-		return new BallotVoteResult(true);
-	}
-
-	@Override
-	public BallotVoteResult vote(final BallotVoteInterface voteMessage) throws NotAllowedException {
-		final BallotModel ballotModel = this.get(voteMessage.getBallotId().toString(), voteMessage.getBallotCreator());
-
-		//invalid ballot model
-		if(ballotModel == null) {
-			return new BallotVoteResult(false);
-		}
-
-		if(ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE && !TestUtil.compare(
-				ballotModel.getCreatorIdentity(),
-				this.userService.getIdentity())) {
-			logger.error("this is not a intermediate ballot and not mine, ingore the message");
-			//return true to ack the message
-			return new BallotVoteResult(true);
-		}
-
-		//if the ballot is closed, ignore any votes
-		if(ballotModel.getState() == BallotModel.State.CLOSED) {
-			logger.error("this is a closed ballot, ignore this message");
-			return new BallotVoteResult(true);
-		}
-
-		final String fromIdentity = ((AbstractMessage)voteMessage).getFromIdentity();
-
-		//load existing votes of user
-		List<BallotVoteModel> existingVotes = this.getVotes(ballotModel.getId(), fromIdentity);
-		final boolean firstVote = existingVotes == null || existingVotes.size() == 0;
-
-		List<BallotVoteModel> savingVotes = new ArrayList<>();
-		List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
-
-		for(final BallotVote apiVoteModel: voteMessage.getBallotVotes()) {
-			apiVoteModel.getId();
-
-			//check if the choice correct
-			final BallotChoiceModel c = Functional.select(choices, new IPredicateNonNull<BallotChoiceModel>() {
-				@Override
-				public boolean apply(@NonNull BallotChoiceModel type) {
-					return type.getApiBallotChoiceId() == apiVoteModel.getId();
-				}
-			});
-
-			if(c != null) {
-				//cool, correct choice
-				BallotVoteModel ballotVoteModel = Functional.select(existingVotes, new IPredicateNonNull<BallotVoteModel>() {
-					@Override
-					public boolean apply(@NonNull BallotVoteModel type) {
-						return type.getBallotChoiceId() == c.getId();
-					}
-				});
-
-				if(ballotVoteModel == null) {
-					//ok, a new vote
-					ballotVoteModel = new BallotVoteModel();
-					ballotVoteModel.setBallotId(ballotModel.getId());
-					ballotVoteModel.setBallotChoiceId(c.getId());
-					ballotVoteModel.setVotingIdentity(fromIdentity);
-					ballotVoteModel.setCreatedAt(new Date());
-				}
-				else {
-					//remove from existing votes
-					if(existingVotes != null) {
-						existingVotes.remove(ballotVoteModel);
-					}
-				}
-
-				if(
-						//is a new vote...
-						ballotVoteModel.getId() <= 0
-						//... or a modified
-					|| ballotVoteModel.getChoice() != apiVoteModel.getValue()) {
-
-					ballotVoteModel.setChoice(apiVoteModel.getValue());
-					ballotVoteModel.setModifiedAt(new Date());
-					savingVotes.add(ballotVoteModel);
-				}
-			}
-		}
-
-		//remove votes
-		boolean hasModifications = false;
-
-		if(existingVotes != null && existingVotes.size() > 0) {
-			int[] ids = new int[existingVotes.size()];
-			for(int n = 0; n < ids.length; n++) {
-				ids[n] = existingVotes.get(n).getId();
-			}
-
-			this.databaseServiceNew.getBallotVoteModelFactory().deleteByIds(
-					ids);
-
-			hasModifications = true;
-		}
-
-		for(BallotVoteModel ballotVoteModel: savingVotes) {
-			this.databaseServiceNew.getBallotVoteModelFactory().createOrUpdate(
-					ballotVoteModel
-			);
-			hasModifications = true;
-		}
-
-		if(hasModifications) {
-
-			ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
-				@Override
-				public void handle(BallotVoteListener listener) {
-					if(listener.handle(ballotModel)) {
-						listener.onVoteChanged(
-								ballotModel,
-								fromIdentity,
-								firstVote);
-					}
-				}
-			});
-		}
-		return new BallotVoteResult(true);
-	}
-
-
-
-	private GroupModel getGroupModel(LinkBallotModel link) {
-		if(link.getType() != LinkBallotModel.Type.GROUP) {
-			return null;
-		}
-
-		int groupId = ((GroupBallotModel)link).getGroupId();
-		return this.groupService.getById(groupId);
-	}
-
-
-	private ContactModel getContactModel(LinkBallotModel link) {
-		if(link.getType() != LinkBallotModel.Type.CONTACT) {
-			return null;
-		}
-
-		String identity = ((IdentityBallotModel)link).getIdentity();
-		return this.contactService.getByIdentity(identity);
-
-	}
-
-	@Override
-	public MessageReceiver getReceiver(BallotModel ballotModel) {
-		try {
-			LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
-			return this.getReceiver(link);
-		} catch (NotAllowedException e) {
-			logger.error("Exception", e);
-			return null;
-		}
-	}
-
-	@Override
-	public BallotMatrixData getMatrixData(int ballotModelId) {
-		try {
-			BallotModel ballotModel = this.get(ballotModelId);
-
-			//ok, ballot not found
-			if(ballotModel == null) {
-				throw new ThreemaException("invalid ballot");
-			}
-
-			BallotMatrixService matrixService = new BallotMatrixServiceImpl(ballotModel);
-
-			String[] participants = this.getParticipants(ballotModelId);
-
-			if (participants.length > 0) {
-				for (String identity : participants) {
-					matrixService.createParticipant(identity);
-				}
-
-				for (BallotChoiceModel choice : this.getChoices(ballotModelId)) {
-					matrixService.createChoice(choice);
-				}
-
-				for (BallotVoteModel ballotVoteModel : this.getBallotVotes(ballotModelId)) {
-					matrixService.addVote(ballotVoteModel);
-				}
-
-				return matrixService.finish();
-			}
-		}
-		catch (ThreemaException x) {
-			logger.error("Exception", x);
-		}
-		return null;
-	}
-
-	private MessageReceiver getReceiver(LinkBallotModel link) {
-		if(link != null) {
-			switch (link.getType()) {
-				case GROUP:
-					GroupModel groupModel = this.getGroupModel(link);
-					return this.groupService.createReceiver(groupModel);
-				case CONTACT:
-					ContactModel contactModel = this.getContactModel(link);
-					return this.contactService.createReceiver(contactModel);
-			}
-		}
-		return null;
-	}
-
-	private int getCalculatedVotingCount(BallotChoiceModel choiceModel) {
-		return (int) this.databaseServiceNew.getBallotVoteModelFactory().countByBallotChoiceIdAndChoice(
-				choiceModel.getId(),
-				1);
-	}
-
-	private BallotChoiceModel getChoiceByApiId(BallotModel ballotModel, int choiceId) {
-		return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotIdAndApiChoiceId(
-				ballotModel.getId(),
-				choiceId
-		);
-	}
-
-	/**
-	 * Link a ballot with a contact
-	 *
-	 * @return success
-	 */
-	private boolean link(ContactModel contactModel, BallotModel ballotModel) {
-		IdentityBallotModelFactory identityBallotModelFactory = this.databaseServiceNew.getIdentityBallotModelFactory();
-		if(identityBallotModelFactory.getByIdentityAndBallotId(
-				contactModel.getIdentity(),
-				ballotModel.getId()
-		) != null) {
-			//already linked
-			return true;
-		}
-
-		IdentityBallotModel m = new IdentityBallotModel();
-		m.setBallotId(ballotModel.getId());
-		m.setIdentity(contactModel.getIdentity());
-		identityBallotModelFactory.create(
-				m);
-
-		this.cache(m);
-
-		return true;
-	}
-
-	/**
-	 * Link a a ballot with a group
-	 *
-	 * @return success
-	 */
-	private boolean link(GroupModel groupModel, BallotModel ballotModel) {
-		GroupBallotModelFactory groupBallotModelFactory = this.databaseServiceNew.getGroupBallotModelFactory();
-		if(groupBallotModelFactory.getByGroupIdAndBallotId(
-				groupModel.getId(),
-				ballotModel.getId()
-		) != null) {
-			//already linked
-			return true;
-		}
-
-		GroupBallotModel m = new GroupBallotModel();
-		m.setBallotId(ballotModel.getId());
-		m.setGroupId(groupModel.getId());
-		groupBallotModelFactory.create(
-				m);
-
-		this.cache(m);
-		return true;
-	}
-
-	private void handleModified(final BallotModel ballotModel) {
-		ListenerManager.ballotListeners.handle(new ListenerManager.HandleListener<BallotListener>() {
-			@Override
-			public void handle(BallotListener listener) {
-				if(listener.handle(ballotModel)) {
-					listener.onModified(ballotModel);
-				}
-			}
-		});
-	}
-
-	private void checkAccess() throws NotAllowedException {
-		if(!this.userService.hasIdentity()) {
-			throw new NotAllowedException();
-		}
-	}
-
-	private void cache(List<BallotModel> ballotModels) {
-		for(BallotModel m: ballotModels) {
-			this.cache(m);
-		}
-	}
-
-	private void cache(BallotModel ballotModel) {
-		if(ballotModel != null) {
-			synchronized (this.ballotModelCache) {
-				this.ballotModelCache.put(ballotModel.getId(), ballotModel);
-			}
-		}
-	}
-
-	private void cache(LinkBallotModel linkBallotModel) {
-		if(linkBallotModel != null) {
-			synchronized (this.linkBallotModelCache) {
-				this.linkBallotModelCache.put(linkBallotModel.getBallotId(), linkBallotModel);
-			}
-		}
-	}
-
-	private void resetCache(BallotModel ballotModel) {
-		if(ballotModel != null) {
-			synchronized (this.ballotModelCache) {
-				this.ballotModelCache.remove(ballotModel.getId());
-			}
-		}
-	}
-
-	@Nullable
-	private BallotModel getFromCache(int id) {
-		synchronized (this.ballotModelCache) {
-			if(this.ballotModelCache.indexOfKey(id) >= 0) {
-				return this.ballotModelCache.get(id);
-			}
-		}
-
-		return null;
-	}
-
-	private LinkBallotModel getLinkModelFromCache(int ballotId) {
-		synchronized (this.linkBallotModelCache) {
-			if(this.linkBallotModelCache.indexOfKey(ballotId) >= 0) {
-				return this.linkBallotModelCache.get(ballotId);
-			}
-		}
-		return null;
-	}
-
-	private BallotModel getFromCache(final String apiId, final String creator) {
-		synchronized (this.ballotModelCache) {
-			return Functional.select(this.ballotModelCache, new IPredicateNonNull<BallotModel>() {
-				@Override
-				public boolean apply(@NonNull BallotModel type) {
-					return TestUtil.compare(type.getApiBallotId(), apiId)
-							&& TestUtil.compare(type.getCreatorIdentity(), creator);
-				}
-			});
-		}
-	}
+                return true;
+            } else if (this.openBallotId == ballotModel.getId()) {
+                this.openBallotId = 0;
+            }
+
+        }
+        return false;
+    }
+
+    @Override
+    public BallotModel create(ContactModel contactModel,
+                              String description,
+                              BallotModel.State state,
+                              BallotModel.Assessment assessment,
+                              BallotModel.Type type,
+                              BallotModel.ChoiceType choiceType) throws NotAllowedException {
+        final BallotModel model = this.create(description, state, assessment, type, choiceType);
+        if (model != null) {
+            this.link(contactModel, model);
+        }
+
+        return model;
+    }
+
+    private BallotModel create(String description,
+                               BallotModel.State state,
+                               BallotModel.Assessment assessment,
+                               BallotModel.Type type,
+                               BallotModel.ChoiceType choiceType) throws NotAllowedException {
+        //create a new blank model
+        try {
+            this.checkAccess();
+
+
+            final BallotModel ballotModel = new BallotModel();
+            //unique id
+            String randomId = UUID.randomUUID().toString();
+            BallotId newBallotId = new BallotId(
+                Utils.hexStringToByteArray(
+                    randomId.substring(randomId.length() - (ProtocolDefines.BALLOT_ID_LEN * 2))
+                ));
+
+            ballotModel.setApiBallotId(Utils.byteArrayToHexString(newBallotId.getBallotId()));
+            ballotModel.setCreatorIdentity(this.userService.getIdentity());
+            ballotModel.setCreatedAt(new Date());
+            ballotModel.setModifiedAt(new Date());
+            ballotModel.setName(description);
+            ballotModel.setState(state);
+            ballotModel.setAssessment(assessment);
+            ballotModel.setType(type);
+            ballotModel.setChoiceType(choiceType);
+            ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE); // default display type for ballots created on mobile client.
+            ballotModel.setLastViewedAt(new Date());
+
+            this.databaseServiceNew.getBallotModelFactory().create(
+                ballotModel
+            );
+
+            this.cache(ballotModel);
+
+            return ballotModel;
+
+        } catch (NotAllowedException notAllowedException) {
+            logger.error("Not allowed", notAllowedException);
+            throw notAllowedException;
+        } catch (ThreemaException e) {
+            logger.error("Exception", e);
+            return null;
+        }
+    }
+
+    @Override
+    public boolean update(BallotModel ballotModel, BallotChoiceModel choice) throws NotAllowedException {
+        if (choice.getId() > 0 && choice.getBallotId() > 0 && choice.getBallotId() != ballotModel.getId()) {
+            throw new NotAllowedException("choice already set on another ballot");
+        }
+
+        if (choice.getApiBallotChoiceId() <= 0) {
+            throw new NotAllowedException("no api ballot choice id set");
+        }
+        choice.setBallotId(ballotModel.getId());
+
+        if (choice.getCreatedAt() == null) {
+            choice.setCreatedAt(new Date());
+        }
+
+        choice.setModifiedAt(new Date());
+
+        return this.databaseServiceNew.getBallotChoiceModelFactory().create(
+            choice
+        );
+    }
+
+    @Override
+    public boolean close(Integer ballotModelId) throws NotAllowedException, MessageTooLongException {
+        //be sure to use the cached ballot model!
+        final BallotModel ballotModel = this.get(ballotModelId);
+
+        //if i am not the creator
+        if (!BallotUtil.canClose(ballotModel, this.userService.getIdentity())) {
+            throw new NotAllowedException();
+        }
+
+        MessageReceiver messageReceiver = this.getReceiver(ballotModel);
+        if (messageReceiver == null) {
+            return false;
+        }
+
+        //save model
+        ballotModel.setState(BallotModel.State.CLOSED);
+        if (this.update(ballotModel)) {
+            return this.send(ballotModel, listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onClosed(ballotModel);
+                }
+            });
+        }
+        return false;
+    }
+
+    @Override
+    public boolean send(BallotModel ballotModel, ListenerManager.HandleListener<BallotListener> handleListener) throws MessageTooLongException {
+        //add message
+        if (TestUtil.compare(userService.getIdentity(), ballotModel.getCreatorIdentity())) {
+            //ok, i am the creator.... send a message to every participant
+            try {
+                if (serviceManager.getMessageService() != null) {
+                    if (serviceManager.getMessageService().sendBallotMessage(ballotModel) != null) {
+                        ListenerManager.ballotListeners.handle(handleListener);
+                        return true;
+                    }
+                }
+            } catch (ThreemaException e) {
+                logger.error("Exception", e);
+                if (e instanceof MessageTooLongException) {
+                    throw new MessageTooLongException();
+                }
+            }
+        }
+        return false;
+    }
+
+    @Override
+    @Nullable
+    public BallotModel get(int ballotId) {
+        BallotModel model = this.getFromCache(ballotId);
+        if (model == null) {
+            model = this.databaseServiceNew.getBallotModelFactory().getById(
+                ballotId
+            );
+
+            this.cache(model);
+        }
+        return model;
+    }
+
+    @Override
+    @NonNull
+    public BallotUpdateResult update(BallotSetupInterface createMessage) throws ThreemaException, BadMessageException {
+        //check if allowed
+        BallotData ballotData = createMessage.getBallotData();
+        if (ballotData == null) {
+            throw new ThreemaException("invalid format");
+        }
+
+        final BallotModel.State toState;
+        final BallotModel ballotModel;
+
+        Date date = ((AbstractMessage) createMessage).getDate();
+        BallotModel existingModel = this.get(createMessage.getBallotId().toString(), createMessage.getBallotCreatorIdentity());
+
+        if (existingModel != null) {
+            if (ballotData.getDisplayType() != null && existingModel.getDisplayType() != null && ballotData.getDisplayType().ordinal() != existingModel.getDisplayType().ordinal()) {
+                throw new BadMessageException("Ballot display mode not allowed to change. Discarding message");
+            }
+            if (ballotData.getState() == BallotData.State.CLOSED) {
+                ballotModel = existingModel;
+                toState = BallotModel.State.CLOSED;
+            } else {
+                throw new BadMessageException("Ballot with same ID already exists. Discarding message.");
+            }
+        } else {
+            if (ballotData.getState() != BallotData.State.CLOSED) {
+                ballotModel = new BallotModel();
+                ballotModel.setCreatorIdentity(createMessage.getBallotCreatorIdentity());
+                ballotModel.setApiBallotId(createMessage.getBallotId().toString());
+                ballotModel.setCreatedAt(date);
+                ballotModel.setLastViewedAt(null);
+                toState = BallotModel.State.OPEN;
+            } else {
+                throw new BadMessageException("New ballot with closed state requested. Discarding message.");
+            }
+        }
+
+        ballotModel.setName(ballotData.getDescription());
+        ballotModel.setModifiedAt(new Date());
+
+        switch (ballotData.getAssessmentType()) {
+            case MULTIPLE:
+                ballotModel.setAssessment(BallotModel.Assessment.MULTIPLE_CHOICE);
+                break;
+            case SINGLE:
+                ballotModel.setAssessment(BallotModel.Assessment.SINGLE_CHOICE);
+                break;
+        }
+
+        switch (ballotData.getType()) {
+            case RESULT_ON_CLOSE:
+                ballotModel.setType(BallotModel.Type.RESULT_ON_CLOSE);
+                break;
+            case INTERMEDIATE:
+                ballotModel.setType(BallotModel.Type.INTERMEDIATE);
+                break;
+        }
+
+        switch (ballotData.getChoiceType()) {
+            case TEXT:
+                ballotModel.setChoiceType(BallotModel.ChoiceType.TEXT);
+                break;
+        }
+
+        switch (ballotData.getDisplayType()) {
+            case SUMMARY_MODE:
+                ballotModel.setDisplayType(BallotModel.DisplayType.SUMMARY_MODE);
+                break;
+            case LIST_MODE:
+            default:
+                ballotModel.setDisplayType(BallotModel.DisplayType.LIST_MODE);
+                break;
+
+        }
+
+        ballotModel.setState(toState);
+
+        if (toState == BallotModel.State.OPEN) {
+            this.databaseServiceNew.getBallotModelFactory().create(
+                ballotModel
+            );
+        } else {
+            this.databaseServiceNew.getBallotModelFactory().update(
+                ballotModel
+            );
+        }
+
+        if (createMessage instanceof GroupPollSetupMessage) {
+            GroupModel groupModel;
+            groupModel = this.groupService.getByGroupMessage((GroupPollSetupMessage) createMessage);
+            if (groupModel == null) {
+                throw new ThreemaException("invalid group");
+            }
+            //link with group
+            this.link(groupModel, ballotModel);
+        } else if (createMessage instanceof PollSetupMessage) {
+            ContactModel contactModel = this.contactService.getByIdentity(createMessage.getBallotCreatorIdentity());
+            if (contactModel == null) {
+                throw new ThreemaException("invalid identity");
+            }
+            //link with group
+            this.link(contactModel, ballotModel);
+        } else {
+            throw new ThreemaException("invalid");
+        }
+
+        if (toState == BallotModel.State.CLOSED && ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE) {
+            //first remove all previously known votes if result should be shown in list mode to ensure a common result for all participants
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
+                ballotModel.getId()
+            );
+        }
+
+        //create choices of ballot
+        for (BallotDataChoice apiChoice : ballotData.getChoiceList()) {
+            //check if choice already exist
+            BallotChoiceModel ballotChoiceModel = this.getChoiceByApiId(ballotModel, apiChoice.getId());
+            if (ballotChoiceModel == null) {
+                ballotChoiceModel = new BallotChoiceModel();
+                ballotChoiceModel.setBallotId(ballotModel.getId());
+                ballotChoiceModel.setApiBallotChoiceId(apiChoice.getId());
+            }
+
+            // save returned total vote count if ballot is in summary mode (case broadcast poll)
+            if (ballotModel.getDisplayType() == BallotModel.DisplayType.SUMMARY_MODE) {
+                ballotChoiceModel.setVoteCount(apiChoice.getTotalVotes());
+            }
+
+            ballotChoiceModel.setName(apiChoice.getName());
+            ballotChoiceModel.setOrder(apiChoice.getOrder());
+            switch (ballotData.getChoiceType()) {
+                case TEXT:
+                    ballotChoiceModel.setType(BallotChoiceModel.Type.Text);
+                    break;
+            }
+            ballotChoiceModel.setCreatedAt(date);
+
+            this.databaseServiceNew.getBallotChoiceModelFactory().createOrUpdate(
+                ballotChoiceModel
+            );
+
+            //save individual votes received in case result should be shown in list mode for each participant (case mobile client user poll)
+            if (ballotModel.getDisplayType() == BallotModel.DisplayType.LIST_MODE && !ballotData.getParticipants().isEmpty()) {
+                int participantPos = 0;
+                for (String p : ballotData.getParticipants()) {
+                    BallotVoteModel voteModel = new BallotVoteModel();
+                    voteModel.setBallotId(ballotModel.getId());
+                    voteModel.setBallotChoiceId(ballotChoiceModel.getId());
+                    voteModel.setVotingIdentity(p);
+                    voteModel.setChoice(apiChoice.getResult(participantPos));
+                    voteModel.setModifiedAt(new Date());
+                    voteModel.setCreatedAt(new Date());
+
+                    this.databaseServiceNew.getBallotVoteModelFactory().create(
+                        voteModel
+                    );
+
+                    participantPos++;
+                }
+            }
+        }
+
+        if (toState == BallotModel.State.OPEN) {
+            this.cache(ballotModel);
+            this.send(ballotModel, listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onCreated(ballotModel);
+                }
+            });
+
+            return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CREATE);
+        } else {
+            // toState == BallotModel.State.CLOSED
+            this.send(ballotModel, listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onClosed(ballotModel);
+                }
+            });
+            return new BallotUpdateResult(ballotModel, BallotUpdateResult.Operation.CLOSE);
+        }
+    }
+
+    @Override
+    public BallotModel get(String id, String creator) {
+        if (TestUtil.isEmptyOrNull(id, creator)) {
+            return null;
+        }
+
+        BallotModel model = this.getFromCache(id, creator);
+        if (model == null) {
+            model = this.databaseServiceNew.getBallotModelFactory().getByApiBallotIdAndIdentity(
+                id,
+                creator
+            );
+
+            this.cache(model);
+        }
+
+        return model;
+    }
+
+    @Override
+    public List<BallotModel> getBallots(final BallotFilter filter) {
+        List<BallotModel> ballots = this.databaseServiceNew.getBallotModelFactory().filter(
+            filter
+        );
+        this.cache(ballots);
+
+        if (filter != null) {
+            return Functional.filter(ballots, new IPredicateNonNull<BallotModel>() {
+                @Override
+                public boolean apply(@NonNull BallotModel type) {
+                    return filter.filter(type);
+                }
+            });
+        } else {
+            return ballots;
+        }
+    }
+
+    @Override
+    public long countBallots(final BallotFilter filter) {
+        return this.databaseServiceNew.getBallotModelFactory().count(filter);
+    }
+
+    @Override
+    public List<BallotChoiceModel> getChoices(Integer ballotModelId) throws NotAllowedException {
+        if (ballotModelId == null) {
+            throw new NotAllowedException();
+        }
+
+        return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotId(
+            ballotModelId
+        );
+    }
+
+    @Override
+    public int getVotingCount(BallotChoiceModel choiceModel) {
+        BallotModel b = this.get(choiceModel.getBallotId());
+        if (b == null) {
+            return 0;
+        }
+
+        return this.getCalculatedVotingCount(choiceModel);
+    }
+
+
+    @Override
+    public boolean update(final BallotModel ballotModel) {
+        ballotModel.setModifiedAt(new Date());
+        this.databaseServiceNew.getBallotModelFactory().update(
+            ballotModel);
+
+        this.handleModified(ballotModel);
+        return true;
+    }
+
+    @Override
+    public boolean removeVotes(final MessageReceiver receiver, final String identity) {
+        List<BallotModel> ballots = this.getBallots(new BallotFilter() {
+            @Override
+            public MessageReceiver getReceiver() {
+                return receiver;
+            }
+
+            @Override
+            public BallotModel.State[] getStates() {
+                return new BallotModel.State[0];
+            }
+
+            @Override
+            public boolean filter(BallotModel ballotModel) {
+                return true;
+            }
+        });
+
+        for (final BallotModel ballotModel : ballots) {
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
+                ballotModel.getId(),
+                identity
+            );
+
+            ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
+                @Override
+                public void handle(BallotVoteListener listener) {
+                    if (listener.handle(ballotModel)) {
+                        listener.onVoteRemoved(ballotModel, identity);
+                    }
+                }
+            });
+        }
+
+        return true;
+    }
+
+    @Override
+    @NonNull
+    public List<String> getVotedParticipants(Integer ballotModelId) {
+        List<String> identities = new ArrayList<>();
+
+        if (ballotModelId != null) {
+            List<BallotVoteModel> ballotVotes = this.getBallotVotes(ballotModelId);
+            for (BallotVoteModel v : ballotVotes) {
+                if (!identities.contains(v.getVotingIdentity())) {
+                    identities.add(v.getVotingIdentity());
+                }
+            }
+        }
+        return identities;
+    }
+
+    @Override
+    @NonNull
+    public List<String> getPendingParticipants(Integer ballotModelId) {
+        String[] allParticipants = this.getParticipants(ballotModelId);
+        List<String> pendingParticipants = new ArrayList<>();
+        if (allParticipants.length > 0) {
+            for (String i : allParticipants) {
+                List<BallotVoteModel> voteModels = this.getVotes(ballotModelId, i);
+                if (voteModels == null || voteModels.size() == 0) {
+                    pendingParticipants.add(i);
+                }
+            }
+        }
+
+        return pendingParticipants;
+    }
+
+
+    @Override
+    @NonNull
+    public String[] getParticipants(MessageReceiver messageReceiver) {
+        if (messageReceiver != null) {
+            switch (messageReceiver.getType()) {
+                case MessageReceiver.Type_GROUP:
+                    return this.groupService.getGroupIdentities(((GroupMessageReceiver) messageReceiver).getGroup());
+
+                case MessageReceiver.Type_CONTACT:
+                    return new String[]{
+                        this.userService.getIdentity(),
+                        ((ContactMessageReceiver) messageReceiver).getContact().getIdentity()
+                    };
+                case MessageReceiver.Type_DISTRIBUTION_LIST:
+                    break;
+            }
+        }
+        return new String[0];
+    }
+
+    @Override
+    @NonNull
+    public String[] getParticipants(Integer ballotModelId) {
+        BallotModel b = this.get(ballotModelId);
+        if (b != null) {
+            try {
+                LinkBallotModel link = this.getLinkedBallotModel(b);
+                if (link != null) {
+                    switch (link.getType()) {
+                        case GROUP:
+                            GroupModel groupModel = this.getGroupModel(link);
+                            if (groupModel != null) {
+                                return this.groupService.getGroupIdentities(this.getGroupModel(link));
+                            }
+                            break;
+                        case CONTACT:
+                            ContactModel contactModel = this.getContactModel(link);
+                            if (contactModel != null) {
+                                return new String[]{
+                                    this.userService.getIdentity(),
+                                    contactModel.getIdentity()};
+                            }
+                            break;
+
+                        default:
+                            throw new NotAllowedException("invalid type");
+                    }
+                }
+            } catch (NotAllowedException e) {
+                logger.error("Exception", e);
+            }
+        }
+
+        return new String[0];
+    }
+
+    private List<BallotVoteModel> getVotes(Integer ballotModelId, String fromIdentity) {
+        if (ballotModelId == null) {
+            return null;
+        }
+
+        return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotIdAndVotingIdentity(
+            ballotModelId,
+            fromIdentity
+        );
+    }
+
+    @Override
+    public boolean hasVoted(Integer ballotModelId, String fromIdentity) {
+        if (ballotModelId == null) {
+            return false;
+        }
+
+        return this.databaseServiceNew.getBallotVoteModelFactory().countByBallotIdAndVotingIdentity(
+            ballotModelId,
+            fromIdentity
+        ) > 0L;
+    }
+
+    @Override
+    public List<BallotVoteModel> getMyVotes(Integer ballotModelId) {
+        return this.getVotes(ballotModelId, this.userService.getIdentity());
+    }
+
+    @Override
+    public List<BallotVoteModel> getBallotVotes(Integer ballotModelId) {
+        if (ballotModelId == null) {
+            return null;
+        }
+        return this.databaseServiceNew.getBallotVoteModelFactory().getByBallotId(
+            ballotModelId);
+    }
+
+
+    @Override
+    public boolean removeAll() {
+        this.databaseServiceNew.getBallotModelFactory().deleteAll();
+        this.databaseServiceNew.getBallotVoteModelFactory().deleteAll();
+        this.databaseServiceNew.getBallotChoiceModelFactory().deleteAll();
+        this.databaseServiceNew.getGroupBallotModelFactory().deleteAll();
+        return true;
+    }
+
+    @Override
+    public BallotPublishResult publish(MessageReceiver messageReceiver, final BallotModel ballotModel, AbstractMessageModel abstractMessageModel) throws NotAllowedException, MessageTooLongException {
+        return this.publish(messageReceiver, ballotModel, abstractMessageModel, null);
+    }
+
+    @Override
+    public BallotPublishResult publish(MessageReceiver messageReceiver,
+                                       final BallotModel ballotModel,
+                                       AbstractMessageModel abstractMessageModel,
+                                       @Nullable Collection<String> receivingIdentities
+    ) throws NotAllowedException, MessageTooLongException {
+        BallotPublishResult result = new BallotPublishResult();
+
+        this.checkAccess();
+
+        if (!TestUtil.required(messageReceiver, ballotModel)) {
+            return result;
+        }
+
+        // validate choices
+        List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
+        if (choices == null || choices.size() < REQUIRED_CHOICE_COUNT) {
+            return result.error(R.string.ballot_error_more_than_x_choices);
+        }
+
+        switch (messageReceiver.getType()) {
+            case MessageReceiver.Type_GROUP:
+                this.link(((GroupMessageReceiver) messageReceiver).getGroup(), ballotModel);
+                break;
+
+            case MessageReceiver.Type_CONTACT:
+                this.link(((ContactMessageReceiver) messageReceiver).getContact(), ballotModel);
+                break;
+        }
+
+        final boolean isClosing = ballotModel.getState() == BallotModel.State.CLOSED;
+
+        BallotData ballotData = new BallotData();
+        ballotData.setDescription(ballotModel.getName());
+
+        switch (ballotModel.getChoiceType()) {
+            case TEXT:
+                ballotData.setChoiceType(BallotData.ChoiceType.TEXT);
+                break;
+        }
+
+        switch (ballotModel.getType()) {
+            case RESULT_ON_CLOSE:
+                ballotData.setType(BallotData.Type.RESULT_ON_CLOSE);
+                break;
+            case INTERMEDIATE:
+            default:
+                ballotData.setType(BallotData.Type.INTERMEDIATE);
+        }
+
+        switch (ballotModel.getAssessment()) {
+            case MULTIPLE_CHOICE:
+                ballotData.setAssessmentType(BallotData.AssessmentType.MULTIPLE);
+                break;
+            case SINGLE_CHOICE:
+            default:
+                ballotData.setAssessmentType(BallotData.AssessmentType.SINGLE);
+        }
+
+        switch (ballotModel.getState()) {
+            case CLOSED:
+                ballotData.setState(BallotData.State.CLOSED);
+                break;
+            case OPEN:
+            default:
+                ballotData.setState(BallotData.State.OPEN);
+        }
+
+        switch (ballotModel.getDisplayType()) {
+            case SUMMARY_MODE:
+                ballotData.setDisplayType(BallotData.DisplayType.SUMMARY_MODE);
+                break;
+            case LIST_MODE:
+            default:
+                ballotData.setDisplayType(BallotData.DisplayType.LIST_MODE);
+                break;
+        }
+
+        HashMap<String, Integer> votersPositions = new HashMap<>();
+        List<BallotVoteModel> voteModels = null;
+        int votersCount = 0;
+        if (isClosing || receivingIdentities != null) {
+            // load a list of voters
+            String[] voters = this.getVotedParticipants(ballotModel.getId()).toArray(new String[0]);
+
+            for (String s : voters) {
+                ballotData.addParticipant(s);
+                votersPositions.put(s, votersCount);
+                votersCount++;
+            }
+
+            voteModels = this.getBallotVotes(ballotModel.getId());
+        }
+        // if closing, add result!
+        for (final BallotChoiceModel c : choices) {
+            BallotDataChoice choice = new BallotDataChoice(votersCount);
+            choice.setId(c.getApiBallotChoiceId());
+            choice.setName(c.getName());
+            choice.setOrder(c.getOrder());
+
+            if ((isClosing || receivingIdentities != null) && TestUtil.required(voteModels, votersPositions)) {
+
+                for (BallotVoteModel v : Functional.filter(voteModels, new IPredicateNonNull<BallotVoteModel>() {
+                    @Override
+                    public boolean apply(@NonNull BallotVoteModel type) {
+                        return type.getBallotChoiceId() == c.getId();
+                    }
+                })) {
+                    int pos = votersPositions.get(v.getVotingIdentity());
+                    if (pos >= 0) {
+                        choice.addResult(pos, v.getChoice());
+                    }
+                }
+
+            }
+            ballotData.getChoiceList().add(choice);
+        }
+
+        try {
+            messageReceiver.createAndSendBallotSetupMessage(
+                ballotData,
+                ballotModel,
+                abstractMessageModel,
+                null,
+                receivingIdentities
+            );
+
+            //set as open
+            if (ballotModel.getState() == BallotModel.State.TEMPORARY) {
+                ballotModel.setState(BallotModel.State.OPEN);
+                ballotModel.setModifiedAt(new Date());
+
+                this.databaseServiceNew.getBallotModelFactory().update(
+                    ballotModel
+                );
+
+            }
+
+            result.success();
+        } catch (ThreemaException e) {
+            logger.error("create boxed ballot failed", e);
+            if (e instanceof MessageTooLongException) {
+                throw new MessageTooLongException();
+            }
+        }
+
+        return result;
+    }
+
+    @Override
+    public LinkBallotModel getLinkedBallotModel(BallotModel ballotModel) throws NotAllowedException {
+        if (ballotModel == null) {
+            return null;
+        }
+
+        LinkBallotModel linkBallotModel = this.getLinkModelFromCache(ballotModel.getId());
+        if (linkBallotModel != null) {
+            return linkBallotModel;
+        }
+
+        GroupBallotModel group = this.databaseServiceNew.getGroupBallotModelFactory().getByBallotId(
+            ballotModel.getId());
+
+        if (group != null) {
+            this.cache(group);
+            return group;
+        }
+
+        IdentityBallotModel identityBallotModel = this.databaseServiceNew.getIdentityBallotModelFactory().getByBallotId(
+            ballotModel.getId()
+        );
+        if (identityBallotModel != null) {
+            this.cache(identityBallotModel);
+            return identityBallotModel;
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean remove(final BallotModel ballotModel) throws NotAllowedException {
+        if (serviceManager == null) {
+            logger.debug("Unable to delete ballot, ServiceManager is not available");
+            return false;
+        }
+
+        MessageService messageService;
+        try {
+            messageService = serviceManager.getMessageService();
+        } catch (ThreemaException e) {
+            logger.error("Unable to delete ballot, MessageService not available", e);
+            return false;
+        }
+
+        if (ballotModel != null) {
+            List<AbstractMessageModel> messageModels = messageService.getMessageForBallot(ballotModel);
+
+            //remove all votes
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            //remove choices
+            this.databaseServiceNew.getBallotChoiceModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            //remove link
+            this.databaseServiceNew.getGroupBallotModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            this.databaseServiceNew.getIdentityBallotModelFactory().deleteByBallotId(
+                ballotModel.getId());
+
+            //remove ballot
+            this.databaseServiceNew.getBallotModelFactory().delete(
+                ballotModel
+            );
+
+            // delete associated messages
+            if (messageModels != null) {
+                for (AbstractMessageModel m : messageModels) {
+                    if (m != null) {
+                        try {
+                            logger.debug("Removing ballot message {} of type {}", m.getApiMessageId() != null ? m.getApiMessageId() : m.getId(), m.getBallotData().getType());
+                            messageService.remove(m);
+                        } catch (Exception e) {
+                            logger.error("Unable to remove message", e);
+                        }
+                    }
+                }
+            }
+
+            // remove ballot from cache
+            this.resetCache(ballotModel);
+
+            ListenerManager.ballotListeners.handle(listener -> {
+                if (listener.handle(ballotModel)) {
+                    listener.onRemoved(ballotModel);
+                }
+            });
+        }
+        return true;
+    }
+
+    @Override
+    public boolean remove(final MessageReceiver receiver) {
+        try {
+            for (BallotModel ballotModel : this.getBallots(new BallotFilter() {
+                @Override
+                public MessageReceiver getReceiver() {
+                    return receiver;
+                }
+
+                @Override
+                public BallotModel.State[] getStates() {
+                    return null;
+                }
+
+                @Override
+                public boolean filter(BallotModel ballotModel) {
+                    return true;
+                }
+            })) {
+                if (!this.remove(ballotModel)) {
+                    return false;
+                }
+            }
+        } catch (NotAllowedException x) {
+            //do nothing more
+            logger.error("Exception", x);
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean belongsToMe(Integer ballotModelId, MessageReceiver messageReceiver) throws NotAllowedException {
+        BallotModel ballotModel = this.get(ballotModelId);
+
+        if (!TestUtil.required(ballotModel, messageReceiver)) {
+            return false;
+        }
+
+        switch (messageReceiver.getType()) {
+            case MessageReceiver.Type_CONTACT:
+            case MessageReceiver.Type_GROUP:
+                LinkBallotModel l = this.getLinkedBallotModel(ballotModel);
+                if (l != null) {
+                    if (messageReceiver.getType() == MessageReceiver.Type_GROUP && l.getType() == LinkBallotModel.Type.GROUP) {
+                        return ((GroupBallotModel) l).getGroupId() == ((GroupMessageReceiver) messageReceiver).getGroup().getId();
+                    } else if (messageReceiver.getType() == MessageReceiver.Type_CONTACT && l.getType() == LinkBallotModel.Type.CONTACT) {
+                        return TestUtil.compare(((IdentityBallotModel) l).getIdentity(), ((ContactMessageReceiver) messageReceiver).getContact().getIdentity());
+                    }
+                }
+        }
+
+        return false;
+    }
+
+    @Override
+    public BallotVoteResult vote(Integer ballotModelId, Map<Integer, Integer> voting) throws NotAllowedException {
+        BallotModel ballotModel = this.get(ballotModelId);
+
+        if (!TestUtil.required(ballotModel, voting)) {
+            return new BallotVoteResult(false);
+        }
+
+        List<BallotChoiceModel> allChoices = this.getChoices(ballotModel.getId());
+        if (allChoices == null) {
+            return new BallotVoteResult(false);
+        }
+
+        LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
+        MessageReceiver messageReceiver = this.getReceiver(link);
+
+        if (messageReceiver == null) {
+            return new BallotVoteResult(false);
+        }
+
+        //prepare all messages and save local
+        BallotVote[] votes = new BallotVote[allChoices.size()];
+        int n = 0;
+        for (final BallotChoiceModel choiceModel : allChoices) {
+            //change if other values implement
+            final int voteValue;
+            if (voting.containsKey(choiceModel.getId())) {
+                voteValue = voting.get(choiceModel.getId());
+            } else {
+                voteValue = 0;
+            }
+            votes[n] = new BallotVote(
+                choiceModel.getApiBallotChoiceId(),
+                voteValue
+            );
+            n++;
+        }
+
+        try {
+            //send
+            messageReceiver.createAndSendBallotVoteMessage(votes, ballotModel);
+
+            //and save
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByBallotIdAndVotingIdentity(
+                ballotModel.getId(),
+                this.userService.getIdentity()
+            );
+
+            for (BallotChoiceModel choiceModel : allChoices) {
+                BallotVoteModel ballotVoteModel = new BallotVoteModel();
+                ballotVoteModel.setVotingIdentity(this.userService.getIdentity());
+                ballotVoteModel.setBallotId(ballotModel.getId());
+                ballotVoteModel.setBallotChoiceId(choiceModel.getId());
+
+                if (voting.containsKey(choiceModel.getId())) {
+                    ballotVoteModel.setChoice(voting.get(choiceModel.getId()));
+                } else {
+                    ballotVoteModel.setChoice(0);
+                }
+
+                ballotVoteModel.setModifiedAt(new Date());
+                ballotVoteModel.setCreatedAt(new Date());
+                this.databaseServiceNew.getBallotVoteModelFactory().create(
+                    ballotVoteModel
+                );
+            }
+        } catch (ThreemaException e) {
+            logger.error("create boxed ballot failed", e);
+            return new BallotVoteResult(false);
+        }
+
+        ListenerManager.ballotVoteListeners.handle(listener -> {
+            if (listener.handle(ballotModel)) {
+                listener.onSelfVote(
+                    ballotModel);
+            }
+        });
+
+        return new BallotVoteResult(true);
+    }
+
+    @Override
+    public BallotVoteResult vote(final BallotVoteInterface voteMessage) throws NotAllowedException {
+        final BallotModel ballotModel = this.get(voteMessage.getBallotId().toString(), voteMessage.getBallotCreatorIdentity());
+
+        //invalid ballot model
+        if (ballotModel == null) {
+            return new BallotVoteResult(false);
+        }
+
+        if (ballotModel.getType() == BallotModel.Type.RESULT_ON_CLOSE && !TestUtil.compare(
+            ballotModel.getCreatorIdentity(),
+            this.userService.getIdentity())) {
+            logger.error("this is not a intermediate ballot and not mine, ingore the message");
+            //return true to ack the message
+            return new BallotVoteResult(true);
+        }
+
+        //if the ballot is closed, ignore any votes
+        if (ballotModel.getState() == BallotModel.State.CLOSED) {
+            logger.error("this is a closed ballot, ignore this message");
+            return new BallotVoteResult(true);
+        }
+
+        final String fromIdentity = ((AbstractMessage) voteMessage).getFromIdentity();
+
+        //load existing votes of user
+        List<BallotVoteModel> existingVotes = this.getVotes(ballotModel.getId(), fromIdentity);
+        final boolean firstVote = existingVotes == null || existingVotes.size() == 0;
+
+        List<BallotVoteModel> savingVotes = new ArrayList<>();
+        List<BallotChoiceModel> choices = this.getChoices(ballotModel.getId());
+
+        for (final BallotVote apiVoteModel : voteMessage.getVotes()) {
+            apiVoteModel.getId();
+
+            //check if the choice correct
+            final BallotChoiceModel c = Functional.select(choices, new IPredicateNonNull<BallotChoiceModel>() {
+                @Override
+                public boolean apply(@NonNull BallotChoiceModel type) {
+                    return type.getApiBallotChoiceId() == apiVoteModel.getId();
+                }
+            });
+
+            if (c != null) {
+                //cool, correct choice
+                BallotVoteModel ballotVoteModel = Functional.select(existingVotes, new IPredicateNonNull<BallotVoteModel>() {
+                    @Override
+                    public boolean apply(@NonNull BallotVoteModel type) {
+                        return type.getBallotChoiceId() == c.getId();
+                    }
+                });
+
+                if (ballotVoteModel == null) {
+                    //ok, a new vote
+                    ballotVoteModel = new BallotVoteModel();
+                    ballotVoteModel.setBallotId(ballotModel.getId());
+                    ballotVoteModel.setBallotChoiceId(c.getId());
+                    ballotVoteModel.setVotingIdentity(fromIdentity);
+                    ballotVoteModel.setCreatedAt(new Date());
+                } else {
+                    //remove from existing votes
+                    if (existingVotes != null) {
+                        existingVotes.remove(ballotVoteModel);
+                    }
+                }
+
+                if (
+                    //is a new vote...
+                    ballotVoteModel.getId() <= 0
+                        //... or a modified
+                        || ballotVoteModel.getChoice() != apiVoteModel.getValue()) {
+
+                    ballotVoteModel.setChoice(apiVoteModel.getValue());
+                    ballotVoteModel.setModifiedAt(new Date());
+                    savingVotes.add(ballotVoteModel);
+                }
+            }
+        }
+
+        //remove votes
+        boolean hasModifications = false;
+
+        if (existingVotes != null && existingVotes.size() > 0) {
+            int[] ids = new int[existingVotes.size()];
+            for (int n = 0; n < ids.length; n++) {
+                ids[n] = existingVotes.get(n).getId();
+            }
+
+            this.databaseServiceNew.getBallotVoteModelFactory().deleteByIds(
+                ids);
+
+            hasModifications = true;
+        }
+
+        for (BallotVoteModel ballotVoteModel : savingVotes) {
+            this.databaseServiceNew.getBallotVoteModelFactory().createOrUpdate(
+                ballotVoteModel
+            );
+            hasModifications = true;
+        }
+
+        if (hasModifications) {
+
+            ListenerManager.ballotVoteListeners.handle(new ListenerManager.HandleListener<BallotVoteListener>() {
+                @Override
+                public void handle(BallotVoteListener listener) {
+                    if (listener.handle(ballotModel)) {
+                        listener.onVoteChanged(
+                            ballotModel,
+                            fromIdentity,
+                            firstVote);
+                    }
+                }
+            });
+        }
+        return new BallotVoteResult(true);
+    }
+
+
+    private GroupModel getGroupModel(LinkBallotModel link) {
+        if (link.getType() != LinkBallotModel.Type.GROUP) {
+            return null;
+        }
+
+        int groupId = ((GroupBallotModel) link).getGroupId();
+        return this.groupService.getById(groupId);
+    }
+
+
+    private ContactModel getContactModel(LinkBallotModel link) {
+        if (link.getType() != LinkBallotModel.Type.CONTACT) {
+            return null;
+        }
+
+        String identity = ((IdentityBallotModel) link).getIdentity();
+        return this.contactService.getByIdentity(identity);
+
+    }
+
+    @Override
+    public MessageReceiver getReceiver(BallotModel ballotModel) {
+        try {
+            LinkBallotModel link = this.getLinkedBallotModel(ballotModel);
+            return this.getReceiver(link);
+        } catch (NotAllowedException e) {
+            logger.error("Exception", e);
+            return null;
+        }
+    }
+
+    @Override
+    public BallotMatrixData getMatrixData(int ballotModelId) {
+        try {
+            BallotModel ballotModel = this.get(ballotModelId);
+
+            //ok, ballot not found
+            if (ballotModel == null) {
+                throw new ThreemaException("invalid ballot");
+            }
+
+            BallotMatrixService matrixService = new BallotMatrixServiceImpl(ballotModel);
+
+            String[] participants = this.getParticipants(ballotModelId);
+
+            if (participants.length > 0) {
+                for (String identity : participants) {
+                    matrixService.createParticipant(identity);
+                }
+
+                for (BallotChoiceModel choice : this.getChoices(ballotModelId)) {
+                    matrixService.createChoice(choice);
+                }
+
+                for (BallotVoteModel ballotVoteModel : this.getBallotVotes(ballotModelId)) {
+                    matrixService.addVote(ballotVoteModel);
+                }
+
+                return matrixService.finish();
+            }
+        } catch (ThreemaException x) {
+            logger.error("Exception", x);
+        }
+        return null;
+    }
+
+    private MessageReceiver getReceiver(LinkBallotModel link) {
+        if (link != null) {
+            switch (link.getType()) {
+                case GROUP:
+                    GroupModel groupModel = this.getGroupModel(link);
+                    return this.groupService.createReceiver(groupModel);
+                case CONTACT:
+                    ContactModel contactModel = this.getContactModel(link);
+                    return this.contactService.createReceiver(contactModel);
+            }
+        }
+        return null;
+    }
+
+    private int getCalculatedVotingCount(BallotChoiceModel choiceModel) {
+        return (int) this.databaseServiceNew.getBallotVoteModelFactory().countByBallotChoiceIdAndChoice(
+            choiceModel.getId(),
+            1);
+    }
+
+    private BallotChoiceModel getChoiceByApiId(BallotModel ballotModel, int choiceId) {
+        return this.databaseServiceNew.getBallotChoiceModelFactory().getByBallotIdAndApiChoiceId(
+            ballotModel.getId(),
+            choiceId
+        );
+    }
+
+    /**
+     * Link a ballot with a contact
+     *
+     * @return success
+     */
+    private boolean link(ContactModel contactModel, BallotModel ballotModel) {
+        IdentityBallotModelFactory identityBallotModelFactory = this.databaseServiceNew.getIdentityBallotModelFactory();
+        if (identityBallotModelFactory.getByIdentityAndBallotId(
+            contactModel.getIdentity(),
+            ballotModel.getId()
+        ) != null) {
+            //already linked
+            return true;
+        }
+
+        IdentityBallotModel m = new IdentityBallotModel();
+        m.setBallotId(ballotModel.getId());
+        m.setIdentity(contactModel.getIdentity());
+        identityBallotModelFactory.create(
+            m);
+
+        this.cache(m);
+
+        return true;
+    }
+
+    /**
+     * Link a a ballot with a group
+     *
+     * @return success
+     */
+    private boolean link(GroupModel groupModel, BallotModel ballotModel) {
+        GroupBallotModelFactory groupBallotModelFactory = this.databaseServiceNew.getGroupBallotModelFactory();
+        if (groupBallotModelFactory.getByGroupIdAndBallotId(
+            groupModel.getId(),
+            ballotModel.getId()
+        ) != null) {
+            //already linked
+            return true;
+        }
+
+        GroupBallotModel m = new GroupBallotModel();
+        m.setBallotId(ballotModel.getId());
+        m.setGroupId(groupModel.getId());
+        groupBallotModelFactory.create(
+            m);
+
+        this.cache(m);
+        return true;
+    }
+
+    private void handleModified(final BallotModel ballotModel) {
+        ListenerManager.ballotListeners.handle(new ListenerManager.HandleListener<BallotListener>() {
+            @Override
+            public void handle(BallotListener listener) {
+                if (listener.handle(ballotModel)) {
+                    listener.onModified(ballotModel);
+                }
+            }
+        });
+    }
+
+    private void checkAccess() throws NotAllowedException {
+        if (!this.userService.hasIdentity()) {
+            throw new NotAllowedException();
+        }
+    }
+
+    private void cache(List<BallotModel> ballotModels) {
+        for (BallotModel m : ballotModels) {
+            this.cache(m);
+        }
+    }
+
+    private void cache(BallotModel ballotModel) {
+        if (ballotModel != null) {
+            synchronized (this.ballotModelCache) {
+                this.ballotModelCache.put(ballotModel.getId(), ballotModel);
+            }
+        }
+    }
+
+    private void cache(LinkBallotModel linkBallotModel) {
+        if (linkBallotModel != null) {
+            synchronized (this.linkBallotModelCache) {
+                this.linkBallotModelCache.put(linkBallotModel.getBallotId(), linkBallotModel);
+            }
+        }
+    }
+
+    private void resetCache(BallotModel ballotModel) {
+        if (ballotModel != null) {
+            synchronized (this.ballotModelCache) {
+                this.ballotModelCache.remove(ballotModel.getId());
+            }
+        }
+    }
+
+    @Nullable
+    private BallotModel getFromCache(int id) {
+        synchronized (this.ballotModelCache) {
+            if (this.ballotModelCache.indexOfKey(id) >= 0) {
+                return this.ballotModelCache.get(id);
+            }
+        }
+
+        return null;
+    }
+
+    private LinkBallotModel getLinkModelFromCache(int ballotId) {
+        synchronized (this.linkBallotModelCache) {
+            if (this.linkBallotModelCache.indexOfKey(ballotId) >= 0) {
+                return this.linkBallotModelCache.get(ballotId);
+            }
+        }
+        return null;
+    }
+
+    private BallotModel getFromCache(final String apiId, final String creator) {
+        synchronized (this.ballotModelCache) {
+            return Functional.select(this.ballotModelCache, new IPredicateNonNull<BallotModel>() {
+                @Override
+                public boolean apply(@NonNull BallotModel type) {
+                    return TestUtil.compare(type.getApiBallotId(), apiId)
+                        && TestUtil.compare(type.getCreatorIdentity(), creator);
+                }
+            });
+        }
+    }
 }
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java
deleted file mode 100644
index 22166638..00000000
--- a/app/src/main/java/ch/threema/app/services/messageplayer/AnimatedImageDrawableMessagePlayer.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2016-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.messageplayer;
-
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.drawable.Animatable;
-import android.graphics.drawable.Drawable;
-import android.widget.ImageView;
-
-import com.bumptech.glide.Glide;
-import com.bumptech.glide.load.DataSource;
-import com.bumptech.glide.load.engine.GlideException;
-import com.bumptech.glide.request.RequestListener;
-import com.bumptech.glide.request.target.Target;
-
-import org.slf4j.Logger;
-
-import java.io.File;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.app.R;
-import ch.threema.app.activities.MediaViewerActivity;
-import ch.threema.app.activities.ThreemaActivity;
-import ch.threema.app.messagereceiver.MessageReceiver;
-import ch.threema.app.services.FileService;
-import ch.threema.app.services.MessageService;
-import ch.threema.app.services.PreferenceService;
-import ch.threema.app.utils.ConfigUtils;
-import ch.threema.app.utils.IntentDataUtil;
-import ch.threema.app.utils.RuntimeUtil;
-import ch.threema.app.utils.TestUtil;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.models.AbstractMessageModel;
-import ch.threema.storage.models.data.media.FileDataModel;
-import ch.threema.storage.models.data.media.MediaMessageDataInterface;
-
-/**
- * A message player for animated image formats supported by AnimatedImageDrawable
- * Currently, this is limited to WebP
- */
-public class AnimatedImageDrawableMessagePlayer extends MessagePlayer {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("AnimatedImageDrawableMessagePlayer");
-
-	private final PreferenceService preferenceService;
-	private Drawable imageDrawable;
-	private ImageView imageContainer;
-
-	protected AnimatedImageDrawableMessagePlayer(Context context,
-												 MessageService messageService,
-												 FileService fileService,
-												 PreferenceService preferenceService,
-												 MessageReceiver messageReceiver,
-												 AbstractMessageModel messageModel) {
-		super(context, messageService, fileService, messageReceiver, messageModel);
-		this.preferenceService = preferenceService;
-	}
-
-	public AnimatedImageDrawableMessagePlayer attachContainer(ImageView container) {
-		this.imageContainer = container;
-		return this;
-	}
-
-	@Override
-	public MediaMessageDataInterface getData() {
-		return this.getMessageModel().getFileData();
-	}
-
-	@Override
-	protected AbstractMessageModel setData(MediaMessageDataInterface data) {
-		AbstractMessageModel messageModel = this.getMessageModel();
-		messageModel.setFileData((FileDataModel) data);
-		return messageModel;
-	}
-
-	@Override
-	protected void open(final File decryptedFile) {
-		logger.debug("open(decryptedFile)");
-		if (this.currentActivityRef != null && this.currentActivityRef.get() != null && this.isReceiverMatch(this.currentMessageReceiver)) {
-			final String mimeType = getMessageModel().getFileData().getMimeType();
-
-			if (!TestUtil.isEmptyOrNull(mimeType) && decryptedFile.exists()) {
-				if (preferenceService.isAnimationAutoplay()) {
-					autoPlay(decryptedFile);
-				} else {
-					openInExternalPlayer();
-				}
-			}
-		}
-	}
-
-	public void autoPlay(final File decryptedFile) {
-		logger.debug("autoPlay(decryptedFile)");
-
-		if (this.imageContainer != null && this.currentActivityRef != null && this.currentActivityRef.get() != null && getMessageModel() != null) {
-			this.makePause(SOURCE_UNDEFINED);
-
-			final String mimeType = getMessageModel().getFileData().getMimeType();
-
-			if (ConfigUtils.isDisplayableAnimatedImageFormat(mimeType)) {
-				Glide.with(getContext())
-					.load(new File(decryptedFile.getPath()))
-					.optionalFitCenter()
-					.error(R.drawable.ic_image_outline)
-					.addListener(new RequestListener<>() {
-						@Override
-						public boolean onLoadFailed(@Nullable GlideException e, @Nullable Object model, @NonNull Target<Drawable> target, boolean isFirstResource) {
-							return false;
-						}
-
-						@Override
-						public boolean onResourceReady(@NonNull Drawable resource, @NonNull Object model, Target<Drawable> target, @NonNull DataSource dataSource, boolean isFirstResource) {
-							imageDrawable = resource;
-							return false;
-						}
-					})
-					.into(imageContainer);
-			}
-		}
-	}
-
-	@Override
-	public boolean open() {
-		logger.debug("open");
-
-		return super.open();
-	}
-
-	public boolean autoPlay() {
-		logger.debug("autoPlay");
-
-		return super.open(true);
-	}
-
-	public void openInExternalPlayer() {
-		RuntimeUtil.runOnUiThread(() -> {
-			if (currentActivityRef != null && currentActivityRef.get() != null && this.isReceiverMatch(currentMessageReceiver)) {
-				Intent intent = new Intent(getContext(), MediaViewerActivity.class);
-				IntentDataUtil.append(getMessageModel(), intent);
-				intent.putExtra(MediaViewerActivity.EXTRA_ID_REVERSE_ORDER, true);
-				currentActivityRef.get().startActivityForResult(intent, ThreemaActivity.ACTIVITY_ID_MEDIA_VIEWER);
-			}
-		});
-	}
-
-	@Override
-	protected void makePause(int source) {
-		logger.debug("makePause");
-		if (this.imageContainer != null && this.imageDrawable != null) {
-			if (imageDrawable instanceof Animatable) {
-				if (((Animatable) imageDrawable).isRunning()) {
-					((Animatable) this.imageDrawable).stop();
-				}
-			}
-		}
-	}
-
-	@Override
-	protected void makeResume(int source) {
-		logger.debug("makeResume: " + getMessageModel().getId());
-		if (this.imageContainer != null && this.imageDrawable != null) {
-			if (imageDrawable instanceof Animatable) {
-				if (!((Animatable) imageDrawable).isRunning()) {
-					((Animatable) this.imageDrawable).start();
-				}
-			}
-		}
-	}
-
-	@Override
-	public void seekTo(int pos) {
-	}
-
-	@Override
-	public int getDuration() {
-		return 0;
-	}
-
-	@Override
-	public int getPosition() {
-		return 0;
-	}
-
-	@Override
-	public void removeListeners() {
-		super.removeListeners();
-		logger.debug("removeListeners");
-
-		// release animated image players if item comes out of view
-		if (this.imageDrawable != null) {
-			if (imageDrawable instanceof Animatable) {
-				if (((Animatable) imageDrawable).isRunning()) {
-					((Animatable) this.imageDrawable).stop();
-				}
-			}
-			this.imageDrawable = null;
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java
index eb2e8cb2..7a9fa21a 100644
--- a/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java
+++ b/app/src/main/java/ch/threema/app/services/messageplayer/AudioMessagePlayer.java
@@ -161,7 +161,7 @@ public class AudioMessagePlayer extends MessagePlayer {
         if (messageModel.getType() == MessageType.VOICEMESSAGE) {
             messageModel.setAudioData((AudioDataModel) data);
         } else {
-            messageModel.setFileData((FileDataModel) data);
+            messageModel.setFileDataModel((FileDataModel) data);
         }
         return messageModel;
     }
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java
index af76eb02..535d10e7 100644
--- a/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java
+++ b/app/src/main/java/ch/threema/app/services/messageplayer/FileMessagePlayer.java
@@ -57,7 +57,7 @@ public class FileMessagePlayer extends MessagePlayer {
 	@Override
 	protected AbstractMessageModel setData(MediaMessageDataInterface data) {
 		AbstractMessageModel messageModel =  this.getMessageModel();
-		messageModel.setFileData((FileDataModel) data);
+		messageModel.setFileDataModel((FileDataModel) data);
 		return messageModel;
 	}
 
diff --git a/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java b/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java
index df30fd0c..4683633d 100644
--- a/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java
+++ b/app/src/main/java/ch/threema/app/services/messageplayer/MessagePlayer.java
@@ -29,6 +29,7 @@ import android.os.AsyncTask;
 
 import androidx.annotation.AnyThread;
 import androidx.annotation.MainThread;
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
 
@@ -51,6 +52,7 @@ import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ProgressListener;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.data.media.MediaMessageDataInterface;
 
diff --git a/app/src/main/java/ch/threema/app/services/notification/ConversationNotificationGroup.kt b/app/src/main/java/ch/threema/app/services/notification/ConversationNotificationGroup.kt
deleted file mode 100644
index b0d155d1..00000000
--- a/app/src/main/java/ch/threema/app/services/notification/ConversationNotificationGroup.kt
+++ /dev/null
@@ -1,54 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2021-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.notification
-
-import android.graphics.Bitmap
-import ch.threema.app.messagereceiver.MessageReceiver
-
-data class ConversationNotificationGroup(
-
-    @JvmField
-    val uid: String,
-
-    @JvmField
-    var name: String,
-
-    @JvmField
-    var shortName: String?,
-
-    @JvmField
-    val messageReceiver: MessageReceiver<*>,
-
-    private val onFetchAvatar: () -> Bitmap?
-) {
-
-    @JvmField
-    var lastNotificationDate: Long = 0L
-
-    @JvmField
-    val conversations: MutableList<NotificationService.ConversationNotification> = mutableListOf()
-
-    @JvmField
-    val notificationId: Int = messageReceiver.uniqueId
-
-    fun loadAvatar(): Bitmap? = onFetchAvatar()
-}
diff --git a/app/src/main/java/ch/threema/app/services/notification/NotificationActionService.java b/app/src/main/java/ch/threema/app/services/notification/NotificationActionService.java
deleted file mode 100644
index 4539d639..00000000
--- a/app/src/main/java/ch/threema/app/services/notification/NotificationActionService.java
+++ /dev/null
@@ -1,235 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2021-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.notification;
-
-import android.app.IntentService;
-import android.app.UiModeManager;
-import android.content.Context;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.os.Bundle;
-import android.widget.Toast;
-
-import org.slf4j.Logger;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.StringRes;
-import androidx.core.app.RemoteInput;
-import ch.threema.app.BuildConfig;
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.managers.ServiceManager;
-import ch.threema.app.messagereceiver.MessageReceiver;
-import ch.threema.app.services.LifetimeService;
-import ch.threema.app.services.MessageService;
-import ch.threema.app.services.group.IncomingGroupJoinRequestService;
-import ch.threema.app.utils.ConversationNotificationUtil;
-import ch.threema.app.utils.IntentDataUtil;
-import ch.threema.app.utils.RuntimeUtil;
-import ch.threema.app.utils.TestUtil;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.models.AbstractMessageModel;
-import ch.threema.storage.models.group.IncomingGroupJoinRequestModel;
-
-public class NotificationActionService extends IntentService {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("NotificationActionService");
-
-	private static final String TAG = "notificationAction";
-	public static final String ACTION_REPLY = BuildConfig.APPLICATION_ID + ".REPLY";
-	public static final String ACTION_MARK_AS_READ = BuildConfig.APPLICATION_ID + ".MARK_AS_READ";
-	public static final String ACTION_ACK = BuildConfig.APPLICATION_ID + ".ACK";
-	public static final String ACTION_DEC = BuildConfig.APPLICATION_ID + ".DEC";
-	public static final String ACTION_GROUP_REQUEST_ACCEPT = BuildConfig.APPLICATION_ID + ".ACCEPT";
-	public static final String ACTION_GROUP_REQUEST_REJECT = BuildConfig.APPLICATION_ID + ".REJECT";
-
-	private static final int NOTIFICATION_ACTION_CONNECTION_LINGER = 1000 * 5;
-
-	private MessageService messageService;
-	private LifetimeService lifetimeService;
-	private NotificationService notificationService;
-	private IncomingGroupJoinRequestService incomingGroupJoinRequestService;
-
-	public NotificationActionService() {
-		super(TAG);
-
-		ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-		if (serviceManager != null) {
-			try {
-				this.messageService = serviceManager.getMessageService();
-				this.lifetimeService = serviceManager.getLifetimeService();
-				this.notificationService = serviceManager.getNotificationService();
-				this.incomingGroupJoinRequestService = serviceManager.getIncomingGroupJoinRequestService();
-			} catch (Exception e) {
-				logger.error("Exception", e);
-			}
-		}
-	}
-
-
-	@Override
-	protected void onHandleIntent(@Nullable Intent intent) {
-		if (intent != null) {
-			String action = intent.getAction();
-			if (action != null) {
-				MessageReceiver messageReceiver = IntentDataUtil.getMessageReceiverFromIntent(this, intent);
-				if (messageReceiver != null) {
-					AbstractMessageModel messageModel = IntentDataUtil.getMessageModelFromReceiver(intent, messageReceiver);
-
-					switch (action) {
-						case ACTION_REPLY:
-							if (reply(messageReceiver, intent)) {
-								return;
-							}
-							break;
-						case ACTION_MARK_AS_READ:
-							markAsRead(messageReceiver);
-							return;
-						case ACTION_ACK:
-							if (messageModel != null) {
-								ack(messageModel);
-								return;
-							}
-							break;
-						case ACTION_DEC:
-							if (messageModel != null) {
-								dec(messageModel);
-								return;
-							}
-							break;
-						default:
-							logger.info("Unknown action {}", action);
-					}
-				}
-				IncomingGroupJoinRequestModel incomingGroupJoinRequestModel = (IncomingGroupJoinRequestModel) intent.getSerializableExtra(ThreemaApplication.INTENT_DATA_INCOMING_GROUP_REQUEST);
-				if (incomingGroupJoinRequestModel != null) {
-					int notificationId = intent.getIntExtra(ThreemaApplication.INTENT_DATA_GROUP_REQUEST_NOTIFICATION_ID, 0);
-					logger.info("action {}", action);
-					switch (action) {
-						case ACTION_GROUP_REQUEST_ACCEPT:
-							acceptGroupRequest(incomingGroupJoinRequestModel);
-							notificationService.cancel(notificationId);
-							return;
-						case ACTION_GROUP_REQUEST_REJECT:
-							rejectGroupRequest(incomingGroupJoinRequestModel);
-							notificationService.cancel(notificationId);
-							return;
-						default:
-							logger.info("Unknown action {}", action);
-							break;
-					}
-				}
-			}
-		}
-		showToast(R.string.verify_failed);
-		logger.info("Failed to handle notification action");
-	}
-
-	private void ack(@NonNull AbstractMessageModel messageModel) {
-		lifetimeService.acquireConnection(TAG);
-
-		messageService.sendUserAcknowledgement(messageModel, true);
-		notificationService.cancelConversationNotification(ConversationNotificationUtil.getUid(messageModel));
-
-		showToast(R.string.message_acknowledged);
-
-		lifetimeService.releaseConnectionLinger(TAG, NOTIFICATION_ACTION_CONNECTION_LINGER);
-	}
-
-	private void dec(@NonNull AbstractMessageModel messageModel) {
-		lifetimeService.acquireConnection(TAG);
-
-		messageService.sendUserDecline(messageModel, true);
-		notificationService.cancelConversationNotification(ConversationNotificationUtil.getUid(messageModel));
-
-		showToast(R.string.message_declined);
-
-		lifetimeService.releaseConnectionLinger(TAG, NOTIFICATION_ACTION_CONNECTION_LINGER);
-	}
-
-	private boolean reply(@NonNull MessageReceiver messageReceiver, @NonNull Intent intent) {
-		Bundle results = RemoteInput.getResultsFromIntent(intent);
-		if (results != null) {
-			String message = null;
-			CharSequence messageCs = results.getCharSequence(ThreemaApplication.EXTRA_VOICE_REPLY);
-			if (messageCs != null) {
-				message = messageCs.toString();
-			}
-
-			if (!TestUtil.isEmptyOrNull(message)) {
-				lifetimeService.acquireConnection(TAG);
-
-				try {
-					messageService.sendText(message, messageReceiver);
-					messageService.markConversationAsRead(messageReceiver, notificationService);
-					notificationService.cancel(messageReceiver);
-
-					showToast(R.string.message_sent);
-					return true;
-				} catch (Exception e) {
-					logger.error("Failed to send message", e);
-				}
-				lifetimeService.releaseConnectionLinger(TAG, NOTIFICATION_ACTION_CONNECTION_LINGER);
-			}
-		}
-		logger.info("Reply message is empty");
-		return false;
-	}
-
-	private void markAsRead(@NonNull MessageReceiver messageReceiver) {
-		lifetimeService.acquireConnection(TAG);
-		messageService.markConversationAsRead(messageReceiver, notificationService);
-		lifetimeService.releaseConnectionLinger(TAG, NOTIFICATION_ACTION_CONNECTION_LINGER);
-		notificationService.cancel(messageReceiver);
-	}
-
-	private void acceptGroupRequest(IncomingGroupJoinRequestModel incomingGroupJoinRequestModel) {
-		lifetimeService.acquireConnection(TAG);
-		try {
-			incomingGroupJoinRequestService.accept(incomingGroupJoinRequestModel);
-		} catch (Exception e) {
-			logger.error("Exception, failed to accept group request ", e);
-		}
-		lifetimeService.releaseConnectionLinger(TAG, NOTIFICATION_ACTION_CONNECTION_LINGER);
-	}
-
-	private void rejectGroupRequest(IncomingGroupJoinRequestModel incomingGroupJoinRequestModel) {
-		lifetimeService.acquireConnection(TAG);
-		try {
-			incomingGroupJoinRequestService.reject(incomingGroupJoinRequestModel);
-		} catch (ThreemaException e) {
-			logger.error("Exception, failed to reject group request ", e);
-		}
-		lifetimeService.releaseConnectionLinger(TAG, NOTIFICATION_ACTION_CONNECTION_LINGER);
-	}
-
-	private void showToast(final @StringRes int stringRes) {
-		UiModeManager uiModeManager = (UiModeManager) getSystemService(Context.UI_MODE_SERVICE);
-		if (uiModeManager != null && uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_CAR) {
-			logger.info("Toast suppressed due to car connection: {}", getString(stringRes));
-		} else {
-			RuntimeUtil.runOnUiThread(() -> Toast.makeText(NotificationActionService.this, stringRes, Toast.LENGTH_LONG).show());
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/services/notification/NotificationSchema.kt b/app/src/main/java/ch/threema/app/services/notification/NotificationSchema.kt
deleted file mode 100644
index 706b42c6..00000000
--- a/app/src/main/java/ch/threema/app/services/notification/NotificationSchema.kt
+++ /dev/null
@@ -1,33 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2021-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.notification
-
-import android.net.Uri
-
-data class NotificationSchema(
-
-    @JvmField
-    val shouldVibrate: Boolean = false,
-
-    @JvmField
-    val soundUri: Uri? = null
-)
diff --git a/app/src/main/java/ch/threema/app/services/notification/NotificationService.java b/app/src/main/java/ch/threema/app/services/notification/NotificationService.java
deleted file mode 100644
index 1c717c21..00000000
--- a/app/src/main/java/ch/threema/app/services/notification/NotificationService.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.notification;
-
-import android.annotation.TargetApi;
-import android.net.Uri;
-import android.os.Build;
-
-import java.io.File;
-import java.util.Date;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.core.app.Person;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.emojis.EmojiMarkupUtil;
-import ch.threema.app.messagereceiver.MessageReceiver;
-import ch.threema.app.services.MessageService;
-import ch.threema.app.utils.TestUtil;
-import ch.threema.storage.DatabaseServiceNew;
-import ch.threema.storage.models.AbstractMessageModel;
-import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.ConversationModel;
-import ch.threema.storage.models.GroupModel;
-import ch.threema.storage.models.MessageType;
-import ch.threema.storage.models.ServerMessageModel;
-import ch.threema.storage.models.group.IncomingGroupJoinRequestModel;
-import ch.threema.storage.models.group.OutgoingGroupJoinRequestModel;
-
-public interface NotificationService {
-
-	interface FetchCacheUri {
-		@Nullable Uri fetch();
-	}
-
-	class ConversationNotification {
-		private CharSequence message;
-		private CharSequence rawMessage;
-		private Person senderPerson;
-		private final Date when;
-		private final String uid;
-		private final ConversationNotificationGroup group;
-		private final FetchCacheUri fetchThumbnailUri;
-		private final int id;
-		private Uri thumbnailUri = null;
-		private final String thumbnailMimeType;
-		private final MessageType messageType;
-		private final EmojiMarkupUtil emojiMarkupUtil;
-		private final boolean isMessageDeleted;
-
-		public ConversationNotification(MessageService.MessageString messageString, Date when, int id, String uid,
-                                        ConversationNotificationGroup group, FetchCacheUri fetchThumbnailUri, String thumbnailMimeType,
-                                        Person senderPerson, MessageType messageType, boolean isMessageDeleted) {
-			this.when = when;
-			this.uid = uid;
-			this.id = id;
-			this.group = group;
-			this.fetchThumbnailUri = fetchThumbnailUri;
-			this.thumbnailMimeType = thumbnailMimeType;
-			this.emojiMarkupUtil = EmojiMarkupUtil.getInstance();
-			this.messageType = messageType;
-			this.isMessageDeleted = isMessageDeleted;
-			setMessage(messageString.getMessage());
-			setRawMessage(messageString.getRawMessage());
-			setSenderPerson(senderPerson);
-
-			this.group.conversations.add(this);
-		}
-
-		public CharSequence getMessage() {
-			return this.message;
-		}
-
-		public CharSequence getRawMessage() {
-			return this.rawMessage;
-		}
-
-		private void setMessage(String message) {
-			if (!TestUtil.isEmptyOrNull(message)) {
-				this.message = emojiMarkupUtil.addTextSpans(message);
-			} else {
-				this.message = "";
-			}
-		}
-
-		private void setRawMessage(String rawMessage) {
-			if (!TestUtil.isEmptyOrNull(rawMessage)) {
-				this.rawMessage = rawMessage;
-			} else {
-				this.rawMessage = "";
-			}
-		}
-
-		public Person getSenderPerson() {
-			return this.senderPerson;
-		}
-
-		public void setSenderPerson(Person person) {
-			if (!TestUtil.isBlankOrNull(message)) {
-				this.senderPerson = person;
-			} else {
-				this.senderPerson = null;
-			}
-		}
-
-		public Date getWhen() {
-			return this.when;
-		}
-
-		public int getId() {
-			return this.id;
-		}
-		public String getUid() {
-			return this.uid;
-		}
-
-		public ConversationNotificationGroup getGroup() {
-			return this.group;
-		}
-
-		@Nullable
-		public Uri getThumbnailUri() {
-			if(this.thumbnailUri == null && this.fetchThumbnailUri != null) {
-				this.thumbnailUri = this.fetchThumbnailUri.fetch();
-			}
-			return this.thumbnailUri;
-		}
-
-		public MessageType getMessageType() {
-			return this.messageType;
-		}
-
-
-		public boolean isMessageDeleted() {
-			return this.isMessageDeleted;
-		}
-
-		public void destroy() {
-			if (this.thumbnailUri != null) {
-				File thumbnailFile = new File(ThreemaApplication.getAppContext().getCacheDir(), thumbnailUri.getLastPathSegment());
-				if (thumbnailFile.exists()) {
-					//noinspection ResultOfMethodCallIgnored
-					thumbnailFile.delete();
-				}
-
-				this.group.conversations.remove(this);
-			}
-		}
-
-		@Nullable
-		public String getThumbnailMimeType() {
-			return thumbnailMimeType;
-		}
-	}
-
-	@TargetApi(Build.VERSION_CODES.O)
-	void deleteNotificationChannels();
-
-	@TargetApi(Build.VERSION_CODES.O)
-	void createNotificationChannels();
-
-	/**
-	 * Set the identity for which a conversation is currently visible (there can only be
-	 * one at any given time). No notifications will created for messages from this identity.
-	 *
-	 * @param receiver visible conversation identity or group (or null)
-	 */
-	void setVisibleReceiver(MessageReceiver receiver);
-
-	void addGroupCallNotification(@NonNull GroupModel group, @NonNull ContactModel contactModel);
-	void cancelGroupCallNotification(int groupId);
-
-	/**
-	 * add a new conversation notification
-	 */
-	void showConversationNotification(ConversationNotification conversationNotification, boolean updateExisting);
-
-	/**
-	 * cancel a conversation notification
-	 */
-	void cancelConversationNotification(String... uids);
-
-	/**
-	 * cancel all conversation notifications saved in notificationsService.conversationNotifications synchronously
-	 * called when pin lock is called
-	 */
-	void cancelCachedConversationNotifications();
-
-	/**
-	 * cancel all conversation notifications saved in notificationsService.conversationNotifications
-	 */
-	void cancelAllCachedConversationNotifications();
-
-	/**
-	 * cancel all conversation notifications of category Notification.CATEGORY_MESSAGE
-	 * returns true if any have been cancelled
-	 */
-	boolean cancelAllMessageCategoryNotifications();
-
-	/**
-	 * handle conversation cancellation upon pin lock depending on sdk version and saved notifications
-	 */
-	void cancelConversationNotificationsOnLockApp();
-
-	/**
-	 * helper that returns true if there are currently held conversations notifications.
-	 * called when pin lock is called on SDK < 23 to check if we should show a pinLockedNotification
-	 */
-	boolean isConversationNotificationVisible();
-
-	void cancel(ConversationModel conversationModel);
-	void cancel(MessageReceiver receiver);
-	void cancel(int notificationId);
-	void cancel(@NonNull String identity);
-
-	void showMasterKeyLockedNewMessageNotification();
-	void showPinLockedNewMessageNotification(NotificationSchema notificationSchema, String uid, String channelId);
-
-	void showServerMessage(ServerMessageModel m);
-
-	/**
-	 * Show a notification that a message could not be sent. Note that this is should not be used
-	 * for messages that were rejected because of forward security.
-	 *
-	 * @param failedMessages the failed message models
-	 */
-	void showUnsentMessageNotification(@NonNull List<AbstractMessageModel> failedMessages);
-
-	/**
-	 * Show a forward security message rejected notification for the given receiver. Note that for
-	 * every receiver only one notification is shown. If a notification is already shown, this call
-	 * has no effect. The notification remains visible until the user cancels (or clicks) it.
-	 */
-	void showForwardSecurityMessageRejectedNotification(
-		@NonNull MessageReceiver<?> messageReceiver
-	);
-
-	void showSafeBackupFailed(int numDays);
-
-	void cancelWorkSyncProgress();
-
-	void showNewSyncedContactsNotification(List<ContactModel> contactModels);
-
-	void showWebclientResumeFailed(String msg);
-	void cancelRestartNotification();
-	void cancelRestoreNotification();
-
-	void showGroupJoinResponseNotification(@NonNull OutgoingGroupJoinRequestModel outgoingGroupJoinRequestModel,
-	                                       @NonNull OutgoingGroupJoinRequestModel.Status status,
-	                                       @NonNull DatabaseServiceNew databaseService);
-
-	void showGroupJoinRequestNotification(@NonNull IncomingGroupJoinRequestModel incomingGroupJoinRequestModel, GroupModel groupModel);
-}
diff --git a/app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java b/app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java
deleted file mode 100644
index 49e44a65..00000000
--- a/app/src/main/java/ch/threema/app/services/notification/NotificationServiceImpl.java
+++ /dev/null
@@ -1,1457 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.notification;
-
-import static android.provider.Settings.System.DEFAULT_NOTIFICATION_URI;
-import static android.provider.Settings.System.DEFAULT_RINGTONE_URI;
-import static androidx.core.app.NotificationCompat.MessagingStyle.MAXIMUM_RETAINED_MESSAGES;
-import static ch.threema.app.ThreemaApplication.WORK_SYNC_NOTIFICATION_ID;
-import static ch.threema.app.backuprestore.csv.RestoreService.RESTORE_COMPLETION_NOTIFICATION_ID;
-import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_ACTIVITY_MODE;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CALL_ID;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CONTACT_IDENTITY;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_IS_INITIATOR;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.Notification;
-import android.app.PendingIntent;
-import android.content.AsyncQueryHandler;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.media.AudioManager;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.SystemClock;
-import android.service.notification.StatusBarNotification;
-import android.text.format.DateUtils;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.RequiresApi;
-import androidx.core.app.NotificationCompat;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.app.Person;
-import androidx.core.app.RemoteInput;
-import androidx.core.app.TaskStackBuilder;
-import androidx.core.content.LocusIdCompat;
-import androidx.core.graphics.drawable.IconCompat;
-
-import org.jetbrains.annotations.Contract;
-import org.slf4j.Logger;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Map;
-import java.util.Objects;
-import java.util.concurrent.TimeUnit;
-
-import ch.threema.app.BuildConfig;
-import ch.threema.app.R;
-import ch.threema.app.ThreemaApplication;
-import ch.threema.app.activities.BackupAdminActivity;
-import ch.threema.app.activities.ComposeMessageActivity;
-import ch.threema.app.activities.HomeActivity;
-import ch.threema.app.activities.ServerMessageActivity;
-import ch.threema.app.collections.Functional;
-import ch.threema.app.managers.ServiceManager;
-import ch.threema.app.messagereceiver.ContactMessageReceiver;
-import ch.threema.app.messagereceiver.GroupMessageReceiver;
-import ch.threema.app.messagereceiver.MessageReceiver;
-import ch.threema.app.notifications.ForwardSecurityNotificationManager;
-import ch.threema.app.notifications.NotificationChannels;
-import ch.threema.app.notifications.NotificationGroups;
-import ch.threema.app.receivers.CancelResendMessagesBroadcastReceiver;
-import ch.threema.app.receivers.ReSendMessagesBroadcastReceiver;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.services.DeadlineListService;
-import ch.threema.app.services.GroupService;
-import ch.threema.app.services.LockAppService;
-import ch.threema.app.services.PreferenceService;
-import ch.threema.app.services.RingtoneService;
-import ch.threema.app.utils.ConfigUtils;
-import ch.threema.app.utils.DNDUtil;
-import ch.threema.app.utils.IntentDataUtil;
-import ch.threema.app.utils.NameUtil;
-import ch.threema.app.utils.RuntimeUtil;
-import ch.threema.app.utils.TestUtil;
-import ch.threema.app.utils.TextUtil;
-import ch.threema.app.utils.WidgetUtil;
-import ch.threema.app.voip.activities.CallActivity;
-import ch.threema.app.voip.activities.GroupCallActivity;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.DatabaseServiceNew;
-import ch.threema.storage.models.AbstractMessageModel;
-import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.ConversationModel;
-import ch.threema.storage.models.GroupModel;
-import ch.threema.storage.models.MessageType;
-import ch.threema.storage.models.ServerMessageModel;
-import ch.threema.storage.models.group.IncomingGroupJoinRequestModel;
-import ch.threema.storage.models.group.OutgoingGroupJoinRequestModel;
-
-public class NotificationServiceImpl implements NotificationService {
-    private static final Logger logger = LoggingUtil.getThreemaLogger("NotificationServiceImpl");
-    private static final long NOTIFY_AGAIN_TIMEOUT = 30 * DateUtils.SECOND_IN_MILLIS;
-    private static final String NAME_PREPEND_SEPARATOR = ": ";
-
-    private final @NonNull Context context;
-    private final @NonNull LockAppService lockAppService;
-    private final @NonNull DeadlineListService hiddenChatsListService;
-    private final @NonNull PreferenceService preferenceService;
-    private final @NonNull RingtoneService ringtoneService;
-    private @Nullable ContactService contactService = null;
-    private @Nullable GroupService groupService = null;
-    private static final int MAX_TICKER_TEXT_LENGTH = 256;
-    public static final int APP_RESTART_NOTIFICATION_ID = 481773;
-    private static final int GC_PENDING_INTENT_BASE = 30000;
-
-    private static final String PIN_LOCKED_NOTIFICATION_ID = "(transition to locked state)";
-    private AsyncQueryHandler queryHandler;
-
-    private final NotificationManagerCompat notificationManagerCompat;
-    private final int pendingIntentFlags;
-
-    private final LinkedList<ConversationNotification> conversationNotifications = new LinkedList<>();
-    private MessageReceiver visibleConversationReceiver;
-
-    @NonNull
-    private final ForwardSecurityNotificationManager fsNotificationManager;
-
-    public NotificationServiceImpl(
-        @NonNull Context context,
-        @NonNull LockAppService lockAppService,
-        @NonNull DeadlineListService hiddenChatsListService,
-        @NonNull PreferenceService preferenceService,
-        @NonNull RingtoneService ringtoneService
-    ) {
-        this.context = context;
-        this.lockAppService = lockAppService;
-        this.hiddenChatsListService = hiddenChatsListService;
-        this.preferenceService = preferenceService;
-        this.ringtoneService = ringtoneService;
-        this.notificationManagerCompat = NotificationManagerCompat.from(context);
-        this.fsNotificationManager = new ForwardSecurityNotificationManager(context, hiddenChatsListService);
-
-        // poor design by Google, as usual...
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            this.pendingIntentFlags = PendingIntent.FLAG_UPDATE_CURRENT | 0x02000000; // FLAG_MUTABLE
-        } else {
-            this.pendingIntentFlags = PendingIntent.FLAG_UPDATE_CURRENT;
-        }
-
-        initContactService();
-        initGroupService();
-
-        // create or update notification channels */
-        NotificationChannels.INSTANCE.ensureNotificationChannelsAndGroups();
-    }
-
-    private void initContactService() {
-        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-        if (serviceManager != null) {
-            try {
-                this.contactService = serviceManager.getContactService();
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        }
-    }
-
-    private void initGroupService() {
-        ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-        if (serviceManager != null) {
-            try {
-                this.groupService = serviceManager.getGroupService();
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        }
-    }
-
-    @Nullable
-    private ContactService getContactService() {
-        if (contactService == null) {
-            initContactService();
-        }
-        return contactService;
-    }
-
-    @Nullable
-    private GroupService getGroupService() {
-        if (groupService == null) {
-            initGroupService();
-        }
-        return groupService;
-    }
-
-    @Deprecated
-    public void deleteNotificationChannels() {
-        if (ConfigUtils.supportsNotificationChannels()) {
-            NotificationChannels.INSTANCE.deleteAll();
-        }
-    }
-
-    @TargetApi(Build.VERSION_CODES.O)
-    @Override
-    public void createNotificationChannels() {
-        if (ConfigUtils.supportsNotificationChannels()) {
-            NotificationChannels.INSTANCE.ensureNotificationChannelsAndGroups();
-        }
-    }
-
-    @Override
-    public void setVisibleReceiver(MessageReceiver receiver) {
-        if (receiver != null) {
-            //cancel
-            this.cancel(receiver);
-        }
-        this.visibleConversationReceiver = receiver;
-    }
-
-    @SuppressLint("MissingPermission")
-    @Override
-    public void addGroupCallNotification(@NonNull GroupModel group, @NonNull ContactModel contactModel) {
-        if (getGroupService() == null) {
-            logger.error("Group service is null; cannot show notification");
-            return;
-        }
-
-        // Treat the visibility of a group call notification the same as a group message that contains a mention.
-        MessageReceiver<?> messageReceiver = getGroupService().createReceiver(group);
-        DNDUtil dndUtil = DNDUtil.getInstance();
-        if (dndUtil.isMutedChat(messageReceiver) || dndUtil.isMutedWork()) {
-            return;
-        }
-
-        NotificationCompat.Action joinAction = new NotificationCompat.Action(
-            R.drawable.ic_phone_locked_outline,
-            context.getString(R.string.voip_gc_join_call),
-            getGroupCallJoinPendingIntent(group.getId(), pendingIntentFlags)
-        );
-
-        Intent notificationIntent = new Intent(context, ComposeMessageActivity.class);
-        notificationIntent.putExtra(ThreemaApplication.INTENT_DATA_GROUP, group.getId());
-        notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NO_USER_ACTION);
-        PendingIntent openPendingIntent = createPendingIntentWithTaskStack(notificationIntent);
-
-        String contentText = context.getString(R.string.voip_gc_notification_call_started, NameUtil.getShortName(contactModel), group.getName());
-
-        // public version of the notification
-        NotificationCompat.Builder publicBuilder = new NotificationCompat.Builder(context, NotificationChannels.NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS)
-            .setContentTitle(context.getString(R.string.group_call))
-            .setContentText(context.getString(R.string.voip_gc_notification_new_call_public))
-            .setSmallIcon(R.drawable.ic_phone_locked_outline)
-            .setGroup(NotificationGroups.CALLS)
-            .setGroupSummary(false)
-            .setChannelId(NotificationChannels.NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS);
-
-        // private version of the notification
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationChannels.NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS)
-            .setStyle(new NotificationCompat.BigTextStyle().bigText(contentText))
-            .setContentTitle(context.getString(R.string.group_call))
-            .setContentText(contentText)
-            .setContentIntent(openPendingIntent)
-            .setSmallIcon(R.drawable.ic_phone_locked_outline)
-            .setLargeIcon(getGroupService().getAvatar(group, false))
-            .setLocalOnly(true)
-            .setGroup(NotificationGroups.CALLS)
-            .setGroupSummary(false)
-            .setCategory(NotificationCompat.CATEGORY_SOCIAL)
-            .setPriority(NotificationCompat.PRIORITY_HIGH)
-            .setVisibility(NotificationCompat.VISIBILITY_PRIVATE)
-            .setPublicVersion(publicBuilder.build())
-            .setSound(preferenceService.getGroupCallRingtone(), AudioManager.STREAM_RING)
-            .setTimeoutAfter(TimeUnit.SECONDS.toMillis(30))
-            .addAction(joinAction);
-
-        if (preferenceService.isGroupCallVibrate()) {
-            builder.setVibrate(NotificationChannels.VIBRATE_PATTERN_GROUP_CALL);
-        }
-
-        String tag = "" + group.getId();
-        try {
-            notificationManagerCompat.notify(tag, ThreemaApplication.INCOMING_GROUP_CALL_NOTIFICATION_ID, builder.build());
-        } catch (Exception e) {
-            logger.error("Exception when notifying", e);
-        }
-    }
-
-    @Override
-    public void cancelGroupCallNotification(int groupId) {
-        PendingIntent joinIntent = getGroupCallJoinPendingIntent(groupId, PendingIntent.FLAG_NO_CREATE | PENDING_INTENT_FLAG_IMMUTABLE);
-        if (joinIntent != null) {
-            joinIntent.cancel();
-        }
-        notificationManagerCompat.cancel("" + groupId, ThreemaApplication.INCOMING_GROUP_CALL_NOTIFICATION_ID);
-    }
-
-    private PendingIntent getGroupCallJoinPendingIntent(int groupId, int flags) {
-        // To make sure a new PendingIntent only for this group is created, use the group id as request code.
-        return PendingIntent.getActivity(
-            context,
-            GC_PENDING_INTENT_BASE + groupId,
-            GroupCallActivity.getJoinCallIntent(context, groupId),
-            flags
-        );
-    }
-
-    @Override
-    public void showConversationNotification(final ConversationNotification conversationNotification, boolean updateExisting) {
-        logger.debug("showConversationNotifications");
-
-        if (ConfigUtils.hasInvalidCredentials()) {
-            logger.debug("Credentials are not (or no longer) valid. Suppressing notification.");
-            return;
-        }
-
-        if (preferenceService.getWizardRunning()) {
-            logger.debug("Wizard in progress. Notification suppressed.");
-            return;
-        }
-
-        synchronized (this.conversationNotifications) {
-            //check if current receiver is the receiver of the group
-            if (this.visibleConversationReceiver != null &&
-                conversationNotification.getGroup().messageReceiver.isEqual(this.visibleConversationReceiver)) {
-                //ignore notification
-                logger.info("No notification - chat visible");
-                return;
-            }
-
-            String uniqueId = null;
-            //check if notification not exist
-            if (
-                Functional.select(
-                    this.conversationNotifications,
-                    conversationNotification1 -> TestUtil.compare(conversationNotification1.getUid(), conversationNotification.getUid())
-                ) == null
-            ) {
-                uniqueId = conversationNotification.getGroup().messageReceiver.getUniqueIdString();
-                if (!DNDUtil.getInstance().isMuted(conversationNotification.getGroup().messageReceiver, conversationNotification.getRawMessage())) {
-                    this.conversationNotifications.addFirst(conversationNotification);
-                }
-            } else if (updateExisting) {
-                uniqueId = conversationNotification.getGroup().messageReceiver.getUniqueIdString();
-            }
-
-            Map<String, ConversationNotificationGroup> uniqueNotificationGroups = new HashMap<>();
-
-            //to refactor on merge update and add
-            final ConversationNotificationGroup newestGroup = conversationNotification.getGroup();
-
-            int numberOfNotificationsForCurrentChat = 0;
-
-            ListIterator<ConversationNotification> iterator = this.conversationNotifications.listIterator();
-            while (iterator.hasNext()) {
-                ConversationNotification notification = iterator.next();
-                ConversationNotificationGroup group = notification.getGroup();
-                uniqueNotificationGroups.put(group.uid, group);
-                boolean isMessageDeleted = conversationNotification.isMessageDeleted();
-
-                if (group.equals(newestGroup) && !isMessageDeleted) {
-                    numberOfNotificationsForCurrentChat++;
-                }
-
-                if (conversationNotification.getUid().equals(notification.getUid()) && updateExisting) {
-                    if (isMessageDeleted) {
-                        iterator.remove();
-                    } else {
-                        iterator.set(conversationNotification);
-                    }
-                }
-            }
-
-            if (this.conversationNotifications
-                .stream()
-                .noneMatch(notification ->
-                    Objects.equals(notification.getGroup().uid, conversationNotification.getGroup().uid)
-                )
-            ) {
-                this.conversationNotifications.add(conversationNotification);
-                cancelConversationNotification(conversationNotification.getUid());
-                return;
-            }
-
-            if (!TestUtil.required(conversationNotification, newestGroup)) {
-                logger.info("No notification - missing data");
-                return;
-            }
-
-            if (updateExisting) {
-                if (!this.preferenceService.isShowMessagePreview() || hiddenChatsListService.has(uniqueId)) {
-                    return;
-                }
-
-                if (this.lockAppService.isLocked()) {
-                    return;
-                }
-            }
-
-            final String latestFullName = newestGroup.name;
-            boolean isGroupChat = newestGroup.messageReceiver instanceof GroupMessageReceiver;
-            String parentChannelId = isGroupChat
-                ? NotificationChannels.NOTIFICATION_CHANNEL_GROUP_CHATS_DEFAULT
-                : NotificationChannels.NOTIFICATION_CHANNEL_CHATS_DEFAULT;
-            String channelId = uniqueId != null && NotificationChannels.INSTANCE.exists(context, uniqueId) ? uniqueId : parentChannelId;
-            int unreadMessagesCount = this.conversationNotifications.size();
-            int unreadConversationsCount = uniqueNotificationGroups.size();
-            NotificationSchema notificationSchema = this.createNotificationSchema(newestGroup, conversationNotification.getRawMessage());
-
-            if (notificationSchema == null) {
-                logger.warn("No notification - no notification schema");
-                return;
-            }
-
-            if (this.lockAppService.isLocked()) {
-                this.showPinLockedNewMessageNotification(notificationSchema, conversationNotification.getUid(), parentChannelId);
-                return;
-            }
-
-            // make sure pin locked notification is canceled
-            cancelPinLockedNewMessagesNotification();
-
-            CharSequence tickerText;
-            CharSequence singleMessageText;
-            String summaryText = unreadConversationsCount > 1 ?
-                ConfigUtils.getSafeQuantityString(context, R.plurals.new_messages_in_chats, unreadMessagesCount, unreadMessagesCount, unreadConversationsCount) :
-                ConfigUtils.getSafeQuantityString(context, R.plurals.new_messages, unreadMessagesCount, unreadMessagesCount);
-            String contentTitle;
-            Intent notificationIntent;
-
-            /* set avatar, intent and contentTitle */
-            notificationIntent = new Intent(context, ComposeMessageActivity.class);
-            newestGroup.messageReceiver.prepareIntent(notificationIntent);
-            contentTitle = latestFullName;
-
-            if (hiddenChatsListService.has(uniqueId)) {
-                tickerText = summaryText;
-                singleMessageText = summaryText;
-            } else {
-                if (this.preferenceService.isShowMessagePreview()) {
-                    tickerText = latestFullName + NAME_PREPEND_SEPARATOR + TextUtil.trim(conversationNotification.getMessage(), MAX_TICKER_TEXT_LENGTH, "...");
-                    singleMessageText = conversationNotification.getMessage();
-                } else {
-                    tickerText = latestFullName + NAME_PREPEND_SEPARATOR + summaryText;
-                    singleMessageText = summaryText;
-                }
-            }
-
-            // Create PendingIntent for notification tab
-            notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NO_USER_ACTION);
-            PendingIntent openPendingIntent = createPendingIntentWithTaskStack(notificationIntent);
-
-            /* ************ ANDROID AUTO ************* */
-
-            int conversationId = newestGroup.notificationId * 10;
-
-            Intent replyIntent = new Intent(context, NotificationActionService.class);
-            replyIntent.setAction(NotificationActionService.ACTION_REPLY);
-            IntentDataUtil.addMessageReceiverToIntent(replyIntent, newestGroup.messageReceiver);
-            PendingIntent replyPendingIntent = PendingIntent.getService(context, conversationId, replyIntent, pendingIntentFlags);
-
-            Intent markReadIntent = new Intent(context, NotificationActionService.class);
-            markReadIntent.setAction(NotificationActionService.ACTION_MARK_AS_READ);
-            IntentDataUtil.addMessageReceiverToIntent(markReadIntent, newestGroup.messageReceiver);
-            PendingIntent markReadPendingIntent = PendingIntent.getService(context, conversationId + 1, markReadIntent, pendingIntentFlags);
-
-            Intent ackIntent = new Intent(context, NotificationActionService.class);
-            ackIntent.setAction(NotificationActionService.ACTION_ACK);
-            IntentDataUtil.addMessageReceiverToIntent(ackIntent, newestGroup.messageReceiver);
-            ackIntent.putExtra(ThreemaApplication.INTENT_DATA_MESSAGE_ID, conversationNotification.getId());
-            PendingIntent ackPendingIntent = PendingIntent.getService(context, conversationId + 2, ackIntent, pendingIntentFlags);
-
-            Intent decIntent = new Intent(context, NotificationActionService.class);
-            decIntent.setAction(NotificationActionService.ACTION_DEC);
-            IntentDataUtil.addMessageReceiverToIntent(decIntent, newestGroup.messageReceiver);
-            decIntent.putExtra(ThreemaApplication.INTENT_DATA_MESSAGE_ID, conversationNotification.getId());
-            PendingIntent decPendingIntent = PendingIntent.getService(context, conversationId + 3, decIntent, pendingIntentFlags);
-
-            long timestamp = System.currentTimeMillis();
-            boolean onlyAlertOnce = (timestamp - newestGroup.lastNotificationDate) < NOTIFY_AGAIN_TIMEOUT;
-            newestGroup.lastNotificationDate = timestamp;
-
-            final NotificationCompat.Builder builder;
-
-            summaryText = ConfigUtils.getSafeQuantityString(
-                context,
-                R.plurals.new_messages,
-                numberOfNotificationsForCurrentChat,
-                numberOfNotificationsForCurrentChat
-            );
-
-            if (!this.preferenceService.isShowMessagePreview() || hiddenChatsListService.has(uniqueId)) {
-                singleMessageText = summaryText;
-                tickerText = summaryText;
-            }
-
-            // public version of the notification
-            NotificationCompat.Builder publicBuilder = new NotificationCompat.Builder(context, channelId)
-                .setContentTitle(summaryText)
-                .setContentText(context.getString(R.string.notification_hidden_text))
-                .setSmallIcon(R.drawable.ic_notification_small)
-                .setOnlyAlertOnce(onlyAlertOnce);
-
-            // private version
-            builder = new NotificationCompat.Builder(context, channelId)
-                .setContentTitle(contentTitle)
-                .setContentText(singleMessageText)
-                .setTicker(tickerText)
-                .setSmallIcon(R.drawable.ic_notification_small)
-                .setLargeIcon(newestGroup.loadAvatar())
-                .setGroup(newestGroup.uid)
-                .setGroupSummary(false)
-                .setOnlyAlertOnce(onlyAlertOnce)
-                .setPriority(this.preferenceService.getNotificationPriority())
-                .setCategory(NotificationCompat.CATEGORY_MESSAGE)
-                .setVisibility(NotificationCompat.VISIBILITY_PRIVATE)
-                .setPublicVersion(publicBuilder.build());
-
-            if (notificationSchema.soundUri != null) {
-                builder.setSound(notificationSchema.soundUri, AudioManager.STREAM_NOTIFICATION);
-            }
-            if (notificationSchema.shouldVibrate) {
-                builder.setVibrate(NotificationChannels.VIBRATE_PATTERN_REGULAR);
-            }
-
-            // Add identity to notification for system DND priority override
-            builder.addPerson(conversationNotification.getSenderPerson());
-
-            if (this.preferenceService.isShowMessagePreview() && !hiddenChatsListService.has(uniqueId)) {
-                builder.setStyle(getMessagingStyle(newestGroup, getConversationNotificationsForGroup(newestGroup)));
-                if (uniqueId != null) {
-                    builder.setShortcutId(uniqueId);
-                    builder.setLocusId(new LocusIdCompat(uniqueId));
-                }
-                addConversationNotificationActions(builder, replyPendingIntent, ackPendingIntent, markReadPendingIntent, conversationNotification, numberOfNotificationsForCurrentChat, unreadConversationsCount, uniqueId, newestGroup);
-                addWearableExtender(builder, newestGroup, ackPendingIntent, decPendingIntent, replyPendingIntent, markReadPendingIntent, numberOfNotificationsForCurrentChat, uniqueId);
-            }
-
-            builder.setContentIntent(openPendingIntent);
-
-            if (updateExisting) {
-                List<StatusBarNotification> notifications = notificationManagerCompat.getActiveNotifications();
-                for (StatusBarNotification notification : notifications) {
-                    if (notification.getId() == newestGroup.notificationId) {
-                        this.notify(newestGroup.notificationId, builder, notificationSchema, parentChannelId);
-                        break;
-                    }
-                }
-            } else {
-                this.notify(newestGroup.notificationId, builder, notificationSchema, parentChannelId);
-            }
-
-            logger.info(
-                "Showing notification {} sound: {}",
-                conversationNotification.getUid(),
-                notificationSchema.soundUri != null ? notificationSchema.soundUri.toString() : "null"
-            );
-
-            showIconBadge(unreadMessagesCount);
-        }
-    }
-
-    private int getRandomRequestCode() {
-        return (int) System.nanoTime();
-    }
-
-    @Nullable
-    private NotificationCompat.MessagingStyle getMessagingStyle(ConversationNotificationGroup group, ArrayList<ConversationNotification> notifications) {
-        if (getContactService() == null) {
-            return null;
-        }
-
-        String chatName = group.name;
-        boolean isGroupChat = group.messageReceiver instanceof GroupMessageReceiver;
-        Person.Builder builder = new Person.Builder()
-            .setName(context.getString(R.string.me_myself_and_i))
-            .setKey(getContactService().getUniqueIdString(getContactService().getMe()));
-
-        Bitmap avatar = getContactService().getAvatar(getContactService().getMe(), false);
-        if (avatar != null) {
-            IconCompat iconCompat = IconCompat.createWithBitmap(avatar);
-            builder.setIcon(iconCompat);
-        }
-        Person me = builder.build();
-
-        NotificationCompat.MessagingStyle messagingStyle = new NotificationCompat.MessagingStyle(me);
-        messagingStyle.setConversationTitle(isGroupChat ? chatName : null);
-        messagingStyle.setGroupConversation(isGroupChat);
-
-        List<NotificationCompat.MessagingStyle.Message> messages = new ArrayList<>();
-
-        for (int i = 0; i < Math.min(notifications.size(), MAXIMUM_RETAINED_MESSAGES); i++) {
-            ConversationNotification notification = notifications.get(i);
-
-            CharSequence messageText = notification.getMessage();
-            Date date = notification.getWhen();
-
-            Person person = notification.getSenderPerson();
-
-            // hack to show full name in non-group chats
-            if (!isGroupChat) {
-                if (person == null) {
-                    person = new Person.Builder()
-                        .setName(chatName).build();
-                } else {
-                    person = person.toBuilder()
-                        .setName(chatName).build();
-                }
-            }
-
-            long created = date == null ? 0 : date.getTime();
-
-            NotificationCompat.MessagingStyle.Message message = new NotificationCompat.MessagingStyle.Message(messageText, created, person);
-
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && notification.getThumbnailUri() != null && notification.getThumbnailMimeType() != null) {
-                message.setData(notification.getThumbnailMimeType(), notification.getThumbnailUri());
-            }
-            messages.add(message);
-        }
-
-        Collections.reverse(messages);
-
-        for (NotificationCompat.MessagingStyle.Message message : messages) {
-            messagingStyle.addMessage(message);
-        }
-
-        return messagingStyle;
-    }
-
-    @NonNull
-    private ArrayList<ConversationNotification> getConversationNotificationsForGroup(ConversationNotificationGroup group) {
-        ArrayList<ConversationNotification> notifications = new ArrayList<>();
-        for (ConversationNotification notification : conversationNotifications) {
-            if (notification.getGroup().uid.equals(group.uid)) {
-                notifications.add(notification);
-            }
-        }
-        return notifications;
-    }
-
-    private void addConversationNotificationActions(
-        NotificationCompat.Builder builder,
-        PendingIntent replyPendingIntent,
-        PendingIntent ackPendingIntent,
-        PendingIntent markReadPendingIntent,
-        ConversationNotification conversationNotification,
-        int unreadMessagesCount,
-        int unreadGroupsCount,
-        String uniqueId,
-        ConversationNotificationGroup newestGroup
-    ) {
-        // add action buttons
-        boolean showMarkAsReadAction = false;
-
-        if (preferenceService.isShowMessagePreview() && !hiddenChatsListService.has(uniqueId)) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-                RemoteInput remoteInput = new RemoteInput.Builder(ThreemaApplication.EXTRA_VOICE_REPLY)
-                    .setLabel(context.getString(R.string.compose_message_and_enter))
-                    .build();
-
-                NotificationCompat.Action.Builder replyActionBuilder = new NotificationCompat.Action.Builder(
-                    R.drawable.ic_reply_black_18dp, context.getString(R.string.wearable_reply), replyPendingIntent)
-                    .addRemoteInput(remoteInput)
-                    .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_REPLY)
-                    .setShowsUserInterface(false);
-
-                if (Build.VERSION.SDK_INT >= 29) {
-                    replyActionBuilder.setAllowGeneratedReplies(!preferenceService.getDisableSmartReplies());
-                }
-
-                builder.addAction(replyActionBuilder.build());
-            }
-            if (newestGroup.messageReceiver instanceof GroupMessageReceiver) {
-                if (unreadMessagesCount == 1) {
-                    builder.addAction(getThumbsUpAction(ackPendingIntent));
-                }
-                showMarkAsReadAction = true;
-            } else if (newestGroup.messageReceiver instanceof ContactMessageReceiver) {
-                if (conversationNotification.getMessageType().equals(MessageType.VOIP_STATUS)) {
-                    // Create an intent for the call action
-                    Intent callActivityIntent = new Intent(context, CallActivity.class);
-                    callActivityIntent.putExtra(EXTRA_ACTIVITY_MODE, CallActivity.MODE_OUTGOING_CALL);
-                    callActivityIntent.putExtra(EXTRA_CONTACT_IDENTITY, ((ContactMessageReceiver) newestGroup.messageReceiver).getContact().getIdentity());
-                    callActivityIntent.putExtra(EXTRA_IS_INITIATOR, true);
-                    callActivityIntent.putExtra(EXTRA_CALL_ID, -1L);
-
-                    PendingIntent callPendingIntent = PendingIntent.getActivity(
-                        context,
-                        getRandomRequestCode(), // http://stackoverflow.com/questions/19031861/pendingintent-not-opening-activity-in-android-4-3
-                        callActivityIntent,
-                        this.pendingIntentFlags);
-
-                    builder.addAction(
-                        new NotificationCompat.Action.Builder(R.drawable.ic_call_white_24dp, context.getString(R.string.voip_return_call), callPendingIntent)
-                            .setShowsUserInterface(true)
-                            .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_CALL)
-                            .build());
-                } else {
-                    if (unreadMessagesCount == 1) {
-                        builder.addAction(getThumbsUpAction(ackPendingIntent));
-                    }
-                    showMarkAsReadAction = true;
-                }
-            }
-        }
-
-        if (showMarkAsReadAction) {
-            builder.addAction(getMarkAsReadAction(markReadPendingIntent));
-        } else {
-            builder.addInvisibleAction(getMarkAsReadAction(markReadPendingIntent));
-        }
-    }
-
-    @NonNull
-    @Contract("_ -> new")
-    private NotificationCompat.Action getMarkAsReadAction(PendingIntent markReadPendingIntent) {
-        return new NotificationCompat.Action.Builder(R.drawable.ic_mark_read_bitmap, context.getString(R.string.mark_read_short), markReadPendingIntent)
-            .setShowsUserInterface(false)
-            .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_MARK_AS_READ)
-            .build();
-    }
-
-    @NonNull
-    @Contract("_ -> new")
-    private NotificationCompat.Action getThumbsUpAction(PendingIntent ackPendingIntent) {
-        return new NotificationCompat.Action.Builder(R.drawable.ic_thumb_up_white_24dp, context.getString(R.string.acknowledge), ackPendingIntent)
-            .setShowsUserInterface(false)
-            .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_THUMBS_UP)
-            .build();
-    }
-
-    private void addWearableExtender(
-        NotificationCompat.Builder builder,
-        ConversationNotificationGroup newestGroup,
-        PendingIntent ackPendingIntent,
-        PendingIntent decPendingIntent,
-        PendingIntent replyPendingIntent,
-        PendingIntent markReadPendingIntent,
-        int numberOfUnreadMessagesForThisChat,
-        String uniqueId
-    ) {
-
-        String replyLabel = String.format(context.getString(R.string.wearable_reply_label), newestGroup.name);
-        RemoteInput remoteInput = new RemoteInput.Builder(ThreemaApplication.EXTRA_VOICE_REPLY)
-            .setLabel(replyLabel)
-            .setChoices(context.getResources().getStringArray(R.array.wearable_reply_choices))
-            .build();
-
-        NotificationCompat.Action.Builder replyActionBuilder =
-            new NotificationCompat.Action.Builder(R.drawable.ic_wear_full_reply,
-                context.getString(R.string.wearable_reply), replyPendingIntent)
-                .addRemoteInput(remoteInput)
-                .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_REPLY)
-                .setShowsUserInterface(false);
-
-        NotificationCompat.Action.WearableExtender replyActionExtender =
-            new NotificationCompat.Action.WearableExtender()
-                .setHintDisplayActionInline(true);
-
-        NotificationCompat.WearableExtender wearableExtender = new NotificationCompat.WearableExtender()
-            .addAction(replyActionBuilder.extend(replyActionExtender).build());
-
-        if (this.preferenceService.isShowMessagePreview() && !hiddenChatsListService.has(uniqueId)) {
-            if (numberOfUnreadMessagesForThisChat == 1 && newestGroup.messageReceiver instanceof ContactMessageReceiver && !hiddenChatsListService.has(uniqueId)) {
-                NotificationCompat.Action ackAction = new NotificationCompat.Action.Builder(R.drawable.ic_wear_full_ack,
-                    context.getString(R.string.acknowledge), ackPendingIntent)
-                    .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_THUMBS_UP)
-                    .build();
-                wearableExtender.addAction(ackAction);
-
-                NotificationCompat.Action decAction = new NotificationCompat.Action.Builder(R.drawable.ic_wear_full_decline,
-                    context.getString(R.string.decline), decPendingIntent)
-                    .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_THUMBS_DOWN)
-                    .build();
-                wearableExtender.addAction(decAction);
-            }
-
-            NotificationCompat.Action markReadAction = new NotificationCompat.Action.Builder(R.drawable.ic_mark_read,
-                context.getString(R.string.mark_read), markReadPendingIntent)
-                .setShowsUserInterface(false)
-                .setSemanticAction(NotificationCompat.Action.SEMANTIC_ACTION_MARK_AS_READ)
-                .build();
-            wearableExtender.addAction(markReadAction);
-        }
-        builder.extend(wearableExtender);
-        builder.extend(
-            new NotificationCompat.CarExtender().setLargeIcon(newestGroup.loadAvatar())
-        );
-    }
-
-    @Override
-    public void cancelConversationNotificationsOnLockApp() {
-        // cancel cached notification ids if still available
-        if (!conversationNotifications.isEmpty()) {
-            boolean containedAnyNotificationToAnUnMutedReceiver = conversationNotifications
-                .stream()
-                .anyMatch(conversationNotification ->
-                    !DNDUtil.getInstance().isMuted(
-                        conversationNotification.getGroup().messageReceiver,
-                        conversationNotification.getRawMessage()
-                    )
-                );
-            cancelCachedConversationNotifications();
-            /*
-             * We do not want to show the pin-locked-new-message notification if all the cached notifications
-             * originated from NOW muted receivers
-             */
-            if (containedAnyNotificationToAnUnMutedReceiver) {
-                showDefaultPinLockedNewMessageNotification();
-            }
-        }
-        // get and cancel active conversations notifications trough notificationManager
-        else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && cancelAllMessageCategoryNotifications()) {
-            /*
-             * In this case we cant really tell if all the cancelled system notifications are from blocked
-             * receivers or not. That all the system notifications that were cancelled here belonging to NOW
-             * muted receivers is an extreme edge case. So we display the pin-locked-new-message notification.
-             *
-             * Note: One could determine the actual receiver of the cancelled system notifications by its tag.
-             * But still than we would be missing the raw-message required for `DNDUtils.isMuted` method.
-             */
-            showDefaultPinLockedNewMessageNotification();
-        }
-        // hack to detect active conversation Notifications by checking for active pending Intent
-        else if (isConversationNotificationVisible()) {
-            cancel(ThreemaApplication.NEW_MESSAGE_NOTIFICATION_ID);
-            showDefaultPinLockedNewMessageNotification();
-        }
-    }
-
-    @Override
-    public void cancelConversationNotification(@Nullable final String... uids) {
-        if (uids == null) {
-            logger.warn("Unique id array must not be null! Ignoring.");
-            return;
-        }
-        synchronized (this.conversationNotifications) {
-            logger.info("Cancel {} conversation notifications", uids.length);
-            for (final String uid : uids) {
-                ConversationNotification conversationNotification = Functional.select(
-                    this.conversationNotifications,
-                    conversationNotification1 -> TestUtil.compare(conversationNotification1.getUid(), uid)
-                );
-
-                if (conversationNotification != null) {
-                    logger.info("Cancel notification {}", uid);
-                    cancelAndDestroyConversationNotification(conversationNotification);
-                } else {
-                    logger.info("Notification {} not found", uid);
-                }
-            }
-
-            showIconBadge(this.conversationNotifications.size());
-
-            // no unread conversations left. make sure PIN locked notification is canceled as well
-            if (this.conversationNotifications.isEmpty()) {
-                cancelPinLockedNewMessagesNotification();
-            }
-        }
-
-        WidgetUtil.updateWidgets(context);
-    }
-
-    private void cancelAndDestroyConversationNotification(@Nullable ConversationNotification conversationNotification) {
-        if (conversationNotification == null) {
-            return;
-        }
-        synchronized (this.conversationNotifications) {
-            logger.info("Destroy notification {}", conversationNotification.getUid());
-            cancel(conversationNotification.getGroup().notificationId);
-            conversationNotification.destroy();
-        }
-    }
-
-    @Override
-    public void cancelAllCachedConversationNotifications() {
-        this.cancel(ThreemaApplication.NEW_MESSAGE_NOTIFICATION_ID);
-
-        synchronized (this.conversationNotifications) {
-            if (!conversationNotifications.isEmpty()) {
-                for (ConversationNotification conversationNotification : conversationNotifications) {
-                    this.cancelAndDestroyConversationNotification(conversationNotification);
-                }
-                conversationNotifications.clear();
-            }
-        }
-    }
-
-    @Nullable
-    private NotificationSchema createNotificationSchema(@NonNull ConversationNotificationGroup notificationGroup, CharSequence rawMessage) {
-        final MessageReceiver messageReceiver = notificationGroup.messageReceiver;
-        if (messageReceiver instanceof GroupMessageReceiver) {
-            if (DNDUtil.getInstance().isMuted(messageReceiver, rawMessage)) {
-                return null;
-            }
-            return new NotificationSchema(
-                this.preferenceService.isGroupVibrate(),
-                this.ringtoneService.getGroupRingtone(messageReceiver.getUniqueIdString())
-            );
-        } else if (messageReceiver instanceof ContactMessageReceiver) {
-            if (DNDUtil.getInstance().isMuted(messageReceiver, null)) {
-                return null;
-            }
-            return new NotificationSchema(
-                this.preferenceService.isVibrate(),
-                this.ringtoneService.getContactRingtone(messageReceiver.getUniqueIdString())
-            );
-        }
-        return new NotificationSchema();
-    }
-
-    @Override
-    public void cancel(ConversationModel conversationModel) {
-        if (conversationModel != null) {
-            this.cancel(conversationModel.getReceiver());
-        }
-    }
-
-    @Override
-    public void cancel(final MessageReceiver receiver) {
-        if (receiver != null) {
-            int id = receiver.getUniqueId();
-            String uniqueIdString = receiver.getUniqueIdString();
-
-            this.cancel(id, uniqueIdString);
-        }
-        this.cancel(ThreemaApplication.NEW_MESSAGE_NOTIFICATION_ID);
-    }
-
-    @Override
-    public void cancelCachedConversationNotifications() {
-        /* called when pin lock becomes active */
-        synchronized (this.conversationNotifications) {
-            cancelAllCachedConversationNotifications();
-            showIconBadge(this.conversationNotifications.size());
-        }
-    }
-
-    @RequiresApi(api = Build.VERSION_CODES.M)
-    @Override
-    public boolean cancelAllMessageCategoryNotifications() {
-        boolean cancelledIDs = false;
-        try {
-            List<StatusBarNotification> notifications = notificationManagerCompat.getActiveNotifications();
-            if (!notifications.isEmpty()) {
-                for (StatusBarNotification notification : notifications) {
-                    if (notification.getNotification() != null && Notification.CATEGORY_MESSAGE.equals(notification.getNotification().category)) {
-                        notificationManagerCompat.cancel(notification.getId());
-                        cancelledIDs = true;
-                    }
-                }
-            }
-        } catch (Exception e) {
-            logger.error("Could not cancel notifications of CATEGORY_MESSAGE ", e);
-        }
-        return cancelledIDs;
-    }
-
-    @NonNull
-    private NotificationSchema getDefaultNotificationSchema() {
-        return new NotificationSchema(
-            this.preferenceService.isVibrate(),
-            this.preferenceService.getNotificationSound()
-        );
-    }
-
-    @Override
-    public boolean isConversationNotificationVisible() {
-        Intent notificationIntent = new Intent(context, ComposeMessageActivity.class);
-        PendingIntent test = PendingIntent.getActivity(
-            context,
-            ThreemaApplication.NEW_MESSAGE_NOTIFICATION_ID,
-            notificationIntent,
-            PendingIntent.FLAG_NO_CREATE | PENDING_INTENT_FLAG_IMMUTABLE
-        );
-        return test != null;
-    }
-
-    private void showDefaultPinLockedNewMessageNotification() {
-        logger.debug("showDefaultPinLockedNewMessageNotification");
-        this.showPinLockedNewMessageNotification(
-            new NotificationSchema(false, null),
-            PIN_LOCKED_NOTIFICATION_ID,
-            NotificationChannels.NOTIFICATION_CHANNEL_CHAT_UPDATE
-        );
-    }
-
-    @Override
-    public void showPinLockedNewMessageNotification(@NonNull NotificationSchema notificationSchema, String uid, String channelId) {
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(this.context, channelId)
-            .setSmallIcon(R.drawable.ic_notification_small)
-            .setContentTitle(this.context.getString(R.string.new_messages_locked))
-            .setContentText(this.context.getString(R.string.new_messages_locked_description))
-            .setTicker(this.context.getString(R.string.new_messages_locked))
-            .setCategory(NotificationCompat.CATEGORY_MESSAGE)
-            .setPriority(this.preferenceService.getNotificationPriority())
-            .setOnlyAlertOnce(false)
-            .setContentIntent(getPendingIntentForActivity(HomeActivity.class))
-            .setSound(notificationSchema.soundUri, AudioManager.STREAM_NOTIFICATION);
-
-        if (notificationSchema.shouldVibrate) {
-            builder.setVibrate(NotificationChannels.VIBRATE_PATTERN_REGULAR);
-        }
-
-        this.notify(ThreemaApplication.NEW_MESSAGE_PIN_LOCKED_NOTIFICATION_ID, builder, null, channelId);
-
-        showIconBadge(0);
-
-        // cancel this message as soon as the app is unlocked
-        this.lockAppService.addOnLockAppStateChanged(isLocked -> {
-            logger.debug("LockAppState changed. locked = " + isLocked);
-            if (!isLocked) {
-                cancelPinLockedNewMessagesNotification();
-                return true;
-            }
-            return false;
-        });
-
-        logger.info("Showing generic notification (pin locked) = {} channelId = {} ", uid, channelId);
-    }
-
-    @Override
-    public void showMasterKeyLockedNewMessageNotification() {
-        this.showMasterKeyLockedNewMessageNotification(this.getDefaultNotificationSchema());
-    }
-
-    private void showMasterKeyLockedNewMessageNotification(@NonNull NotificationSchema notificationSchema) {
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(this.context, NotificationChannels.NOTIFICATION_CHANNEL_CHATS_DEFAULT)
-            .setSmallIcon(R.drawable.ic_notification_small)
-            .setContentTitle(this.context.getString(R.string.new_messages_locked))
-            .setContentText(this.context.getString(R.string.new_messages_locked_description))
-            .setTicker(this.context.getString(R.string.new_messages_locked))
-            .setCategory(NotificationCompat.CATEGORY_MESSAGE)
-            .setOnlyAlertOnce(false)
-            .setContentIntent(getPendingIntentForActivity(HomeActivity.class))
-            .setSound(notificationSchema.soundUri, AudioManager.STREAM_NOTIFICATION);
-
-        if (notificationSchema.shouldVibrate) {
-            builder.setVibrate(NotificationChannels.VIBRATE_PATTERN_REGULAR);
-        }
-
-        this.notify(
-            ThreemaApplication.NEW_MESSAGE_LOCKED_NOTIFICATION_ID,
-            builder,
-            null,
-            NotificationChannels.NOTIFICATION_CHANNEL_CHATS_DEFAULT
-        );
-
-        logger.info("Showing generic notification (master key locked)");
-    }
-
-    private void cancelPinLockedNewMessagesNotification() {
-        logger.debug("cancel Pin Locked New Messages");
-        this.cancel(ThreemaApplication.NEW_MESSAGE_PIN_LOCKED_NOTIFICATION_ID);
-    }
-
-    @Override
-    public void showServerMessage(ServerMessageModel m) {
-        Intent intent = new Intent(context, ServerMessageActivity.class);
-        PendingIntent pendingIntent = PendingIntent.getActivity(
-            context,
-            0,
-            intent,
-            PENDING_INTENT_FLAG_IMMUTABLE | PendingIntent.FLAG_UPDATE_CURRENT
-        );
-
-        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationChannels.NOTIFICATION_CHANNEL_NOTICE)
-            .setSmallIcon(R.drawable.ic_error_red_24dp)
-            .setTicker(this.context.getString(R.string.server_message_title))
-            .setContentTitle(this.context.getString(R.string.server_message_title))
-            .setContentText(this.context.getString(R.string.tap_here_for_more))
-            .setContentIntent(pendingIntent)
-            .setLocalOnly(true)
-            .setPriority(NotificationCompat.PRIORITY_MAX)
-            .setAutoCancel(true);
-
-        this.notify(ThreemaApplication.SERVER_MESSAGE_NOTIFICATION_ID, builder, null, NotificationChannels.NOTIFICATION_CHANNEL_NOTICE);
-    }
-
-    private PendingIntent createPendingIntentWithTaskStack(@NonNull Intent intent) {
-        intent.setData((Uri.parse("foobar://" + SystemClock.elapsedRealtime())));
-
-        TaskStackBuilder stackBuilder = TaskStackBuilder.create(context);
-        stackBuilder.addNextIntentWithParentStack(intent);
-        return stackBuilder.getPendingIntent(0, this.pendingIntentFlags);
-    }
-
-    private PendingIntent getPendingIntentForActivity(Class<? extends Activity> activityClass) {
-        Intent notificationIntent = new Intent(this.context, activityClass);
-        notificationIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
-        return createPendingIntentWithTaskStack(notificationIntent);
-    }
-
-    @Override
-    public void showUnsentMessageNotification(@NonNull List<AbstractMessageModel> failedMessages) {
-        int num = failedMessages.size();
-
-        if (num > 0) {
-            Intent sendIntent = new Intent(context, ReSendMessagesBroadcastReceiver.class);
-            IntentDataUtil.appendMultipleMessageTypes(failedMessages, sendIntent);
-
-            PendingIntent sendPendingIntent = PendingIntent.getBroadcast(
-                context,
-                ThreemaApplication.UNSENT_MESSAGE_NOTIFICATION_ID,
-                sendIntent,
-                this.pendingIntentFlags
-            );
-
-            NotificationCompat.Action tryAgainAction = new NotificationCompat.Action.Builder(
-                R.drawable.ic_wear_full_retry,
-                context.getString(R.string.try_again),
-                sendPendingIntent
-            ).build();
-            NotificationCompat.WearableExtender wearableExtender = new NotificationCompat.WearableExtender();
-            wearableExtender.addAction(tryAgainAction);
-
-            Intent cancelIntent = new Intent(context, CancelResendMessagesBroadcastReceiver.class);
-            IntentDataUtil.appendMultipleMessageTypes(failedMessages, cancelIntent);
-
-            PendingIntent cancelSendingMessages = PendingIntent.getBroadcast(
-                context,
-                ThreemaApplication.UNSENT_MESSAGE_NOTIFICATION_ID,
-                cancelIntent,
-                this.pendingIntentFlags
-            );
-
-            String content = ConfigUtils.getSafeQuantityString(context, R.plurals.sending_message_failed, num, num);
-
-            NotificationCompat.Builder builder =
-                new NotificationCompat.Builder(context, NotificationChannels.NOTIFICATION_CHANNEL_ALERT)
-                    .setSmallIcon(R.drawable.ic_error_red_24dp)
-                    .setTicker(content)
-                    .setPriority(NotificationCompat.PRIORITY_HIGH)
-                    .setCategory(NotificationCompat.CATEGORY_ERROR)
-                    .setContentIntent(getPendingIntentForActivity(HomeActivity.class))
-                    .extend(wearableExtender)
-                    .setContentTitle(this.context.getString(R.string.app_name))
-                    .setContentText(content)
-                    .setStyle(new NotificationCompat.BigTextStyle().bigText(content))
-                    .setDeleteIntent(cancelSendingMessages)
-                    .addAction(R.drawable.ic_refresh_white_24dp, context.getString(R.string.try_again), sendPendingIntent);
-
-            this.notify(ThreemaApplication.UNSENT_MESSAGE_NOTIFICATION_ID, builder, null, NotificationChannels.NOTIFICATION_CHANNEL_ALERT);
-        } else {
-            this.cancel(ThreemaApplication.UNSENT_MESSAGE_NOTIFICATION_ID);
-        }
-    }
-
-    @Override
-    public void showForwardSecurityMessageRejectedNotification(@NonNull MessageReceiver<?> messageReceiver) {
-        fsNotificationManager.showForwardSecurityNotification(messageReceiver);
-    }
-
-    @Override
-    public void showSafeBackupFailed(int numDays) {
-        if (numDays > 0 && preferenceService.getThreemaSafeEnabled()) {
-            Intent intent = new Intent(context, BackupAdminActivity.class);
-            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, PENDING_INTENT_FLAG_IMMUTABLE);
-
-            String content = String.format(this.context.getString(R.string.safe_failed_notification), numDays);
-
-            NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationChannels.NOTIFICATION_CHANNEL_ALERT)
-                .setSmallIcon(R.drawable.ic_error_red_24dp)
-                .setTicker(content)
-                .setLocalOnly(true)
-                .setPriority(NotificationCompat.PRIORITY_HIGH)
-                .setCategory(NotificationCompat.CATEGORY_ERROR)
-                .setContentIntent(pendingIntent)
-                .setContentTitle(this.context.getString(R.string.app_name))
-                .setContentText(content)
-                .setStyle(new NotificationCompat.BigTextStyle().bigText(content));
-
-            this.notify(ThreemaApplication.SAFE_FAILED_NOTIFICATION_ID, builder, null, NotificationChannels.NOTIFICATION_CHANNEL_ALERT);
-        } else {
-            this.cancel(ThreemaApplication.SAFE_FAILED_NOTIFICATION_ID);
-        }
-    }
-
-    @Override
-    public void cancelWorkSyncProgress() {
-        this.cancel(WORK_SYNC_NOTIFICATION_ID);
-    }
-
-    @Override
-    public void showNewSyncedContactsNotification(@Nullable List<ContactModel> contactModels) {
-        if (contactModels != null && !contactModels.isEmpty()) {
-            String message;
-            Intent notificationIntent;
-
-            if (contactModels.size() > 1) {
-                StringBuilder contactListBuilder = new StringBuilder();
-                for (ContactModel contactModel : contactModels) {
-                    if (contactListBuilder.length() > 0) {
-                        contactListBuilder.append(", ");
-                    }
-                    contactListBuilder.append(NameUtil.getDisplayName(contactModel));
-                }
-                message = this.context.getString(R.string.notification_contact_has_joined_multiple, contactModels.size(), this.context.getString(R.string.app_name), contactListBuilder.toString());
-                notificationIntent = new Intent(context, HomeActivity.class);
-                notificationIntent.putExtra(HomeActivity.EXTRA_SHOW_CONTACTS, true);
-            } else {
-                String name = NameUtil.getDisplayName(contactModels.get(0));
-                message = String.format(this.context.getString(R.string.notification_contact_has_joined), name, this.context.getString(R.string.app_name));
-                notificationIntent = new Intent(context, ComposeMessageActivity.class);
-                if (getContactService() != null) {
-                    getContactService().createReceiver(contactModels.get(0)).prepareIntent(notificationIntent);
-                }
-            }
-            notificationIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NO_USER_ACTION);
-            PendingIntent openPendingIntent = createPendingIntentWithTaskStack(notificationIntent);
-
-            NotificationSchema notificationSchema = new NotificationSchema(
-                this.preferenceService.isVibrate(),
-                null
-            );
-
-            NotificationCompat.Builder builder = new NotificationCompat.Builder(context, NotificationChannels.NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS)
-                .setSmallIcon(R.drawable.ic_notification_small)
-                .setContentTitle(this.context.getString(R.string.notification_channel_new_contact))
-                .setContentText(message)
-                .setContentIntent(openPendingIntent)
-                .setStyle(new NotificationCompat.BigTextStyle().bigText(message))
-                .setPriority(NotificationCompat.PRIORITY_HIGH)
-                .setAutoCancel(true);
-
-            if (notificationSchema.shouldVibrate) {
-                builder.setVibrate(NotificationChannels.VIBRATE_PATTERN_REGULAR);
-            }
-
-            this.notify(
-                ThreemaApplication.NEW_SYNCED_CONTACTS_NOTIFICATION_ID,
-                builder,
-                null,
-                NotificationChannels.NOTIFICATION_CHANNEL_NEW_SYNCED_CONTACTS
-            );
-        }
-    }
-
-    /**
-     * Create and show notification
-     */
-    private void notify(int id, NotificationCompat.Builder builder, @Nullable NotificationSchema schema, @NonNull String channelId) {
-        try {
-            notificationManagerCompat.notify(id, builder.build());
-        } catch (SecurityException e) {
-            // some phones revoke access to selected sound files for notifications after an OS upgrade
-            logger.error("Can't show notification. Falling back to default ringtone", e);
-
-            if (NotificationChannels.NOTIFICATION_CHANNEL_CHATS_DEFAULT.equals(channelId) ||
-                NotificationChannels.NOTIFICATION_CHANNEL_GROUP_CHATS_DEFAULT.equals(channelId) ||
-                NotificationChannels.NOTIFICATION_CHANNEL_INCOMING_CALLS.equals(channelId) ||
-                NotificationChannels.NOTIFICATION_CHANNEL_INCOMING_GROUP_CALLS.equals(channelId)
-            ) {
-                if (schema != null &&
-                    schema.soundUri != null &&
-                    !DEFAULT_NOTIFICATION_URI.equals(schema.soundUri) &&
-                    !DEFAULT_RINGTONE_URI.equals(schema.soundUri)
-                ) {
-                    // post notification to a silent channel
-                    builder.setChannelId(NotificationChannels.NOTIFICATION_CHANNEL_CHAT_UPDATE);
-                    try {
-                        notificationManagerCompat.notify(id, builder.build());
-                    } catch (Exception ex) {
-                        logger.error("Failed to show fallback notification", ex);
-                    }
-                }
-            }
-        } catch (Exception e) {
-            // catch FileUriExposedException - see https://commonsware.com/blog/2016/09/07/notifications-sounds-android-7p0-aggravation.html
-            logger.error("Exception", e);
-        }
-    }
-
-    @Override
-    public void cancel(int id) {
-        //make sure that pending intent is also cancelled to allow to check for active conversation notifications pre SDK 23
-        Intent intent = new Intent(context, ComposeMessageActivity.class);
-        if (id == ThreemaApplication.NEW_MESSAGE_NOTIFICATION_ID) {
-            PendingIntent pendingConversationIntent = PendingIntent.getActivity(
-                context,
-                ThreemaApplication.NEW_MESSAGE_NOTIFICATION_ID,
-                intent,
-                this.pendingIntentFlags
-            );
-            if (pendingConversationIntent != null) {
-                pendingConversationIntent.cancel();
-            }
-        }
-        notificationManagerCompat.cancel(id);
-    }
-
-    @Override
-    public void cancel(@NonNull String identity) {
-        if (contactService == null) {
-            logger.warn("Cannot cancel notification because contact service is null");
-            return;
-        }
-
-        int uniqueId = contactService.getUniqueId(identity);
-        String uniqueIdString = contactService.getUniqueIdString(identity);
-
-        this.cancel(uniqueId, uniqueIdString);
-    }
-
-    private void cancel(int uniqueId, @Nullable String uniqueIdString) {
-        if (uniqueId != 0) {
-            this.cancel(uniqueId);
-        }
-
-        //remove all cached notifications from the receiver
-        synchronized (this.conversationNotifications) {
-            for (Iterator<ConversationNotification> iterator = this.conversationNotifications.iterator(); iterator.hasNext(); ) {
-                ConversationNotification conversationNotification = iterator.next();
-                if (conversationNotification != null
-                    && conversationNotification.getGroup() != null
-                    && conversationNotification.getGroup().messageReceiver.getUniqueIdString().equals(uniqueIdString)) {
-                    iterator.remove();
-                    //call destroy
-                    this.cancelAndDestroyConversationNotification(conversationNotification);
-                }
-            }
-            showIconBadge(conversationNotifications.size());
-        }
-        this.cancel(ThreemaApplication.NEW_MESSAGE_NOTIFICATION_ID);
-    }
-
-    private void showIconBadge(int unreadMessages) {
-        logger.info("Badge: showing " + unreadMessages + " unread");
-
-        if (context.getPackageManager().resolveContentProvider("com.teslacoilsw.notifier", 0) != null) {
-            // nova launcher / teslaunread
-            try {
-                String launcherClassName = context.getPackageManager().getLaunchIntentForPackage(BuildConfig.APPLICATION_ID).getComponent().getClassName();
-                final ContentValues contentValues = new ContentValues();
-                contentValues.put("tag", BuildConfig.APPLICATION_ID + "/" + launcherClassName);
-                contentValues.put("count", unreadMessages);
-
-                context.getApplicationContext().getContentResolver().insert(Uri.parse("content://com.teslacoilsw.notifier/unread_count"), contentValues);
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        } else if (ConfigUtils.isHuaweiDevice()) {
-            try {
-                String launcherClassName = context.getPackageManager().getLaunchIntentForPackage(BuildConfig.APPLICATION_ID).getComponent().getClassName();
-                Bundle localBundle = new Bundle();
-                localBundle.putString("package", BuildConfig.APPLICATION_ID);
-                localBundle.putString("class", launcherClassName);
-                localBundle.putInt("badgenumber", unreadMessages);
-                context.getContentResolver().call(Uri.parse("content://com.huawei.android.launcher.settings/badge/"), "change_badge", null, localBundle);
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        } else if (ConfigUtils.isSonyDevice()) {
-            try {
-                String launcherClassName = context.getPackageManager().getLaunchIntentForPackage(BuildConfig.APPLICATION_ID).getComponent().getClassName();
-                if (context.getPackageManager().resolveContentProvider("com.sonymobile.home.resourceprovider", 0) != null) {
-                    // use content provider
-                    final ContentValues contentValues = new ContentValues();
-                    contentValues.put("badge_count", unreadMessages);
-                    contentValues.put("package_name", BuildConfig.APPLICATION_ID);
-                    contentValues.put("activity_name", launcherClassName);
-
-                    if (RuntimeUtil.isOnUiThread()) {
-                        if (queryHandler == null) {
-                            queryHandler = new AsyncQueryHandler(
-                                context.getApplicationContext().getContentResolver()) {
-                            };
-                        }
-                        queryHandler.startInsert(0, null, Uri.parse("content://com.sonymobile.home.resourceprovider/badge"), contentValues);
-                    } else {
-                        context.getApplicationContext().getContentResolver().insert(Uri.parse("content://com.sonymobile.home.resourceprovider/badge"), contentValues);
-                    }
-                } else {
-                    // use broadcast
-                    Intent intent = new Intent("com.sonyericsson.home.action.UPDATE_BADGE");
-                    intent.putExtra("com.sonyericsson.home.intent.extra.badge.PACKAGE_NAME", BuildConfig.APPLICATION_ID);
-                    intent.putExtra("com.sonyericsson.home.intent.extra.badge.ACTIVITY_NAME", launcherClassName);
-                    intent.putExtra("com.sonyericsson.home.intent.extra.badge.MESSAGE", String.valueOf(unreadMessages));
-                    intent.putExtra("com.sonyericsson.home.intent.extra.badge.SHOW_MESSAGE", unreadMessages > 0);
-                    context.sendBroadcast(intent);
-                }
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        } else {
-            // also works on LG and later HTC devices
-            try {
-                String launcherClassName = context.getPackageManager().getLaunchIntentForPackage(BuildConfig.APPLICATION_ID).getComponent().getClassName();
-                Intent intent = new Intent("android.intent.action.BADGE_COUNT_UPDATE");
-                intent.putExtra("badge_count", unreadMessages);
-                intent.putExtra("badge_count_package_name", BuildConfig.APPLICATION_ID);
-                intent.putExtra("badge_count_class_name", launcherClassName);
-                context.sendBroadcast(intent);
-            } catch (Exception e) {
-                logger.error("Exception", e);
-            }
-        }
-    }
-
-    @Override
-    public void showWebclientResumeFailed(String msg) {
-        NotificationCompat.Builder builder =
-            new NotificationCompat.Builder(this.context, NotificationChannels.NOTIFICATION_CHANNEL_NOTICE)
-                .setSmallIcon(R.drawable.ic_web_notification)
-                .setTicker(msg)
-                .setLocalOnly(true)
-                .setPriority(NotificationCompat.PRIORITY_HIGH)
-                .setCategory(NotificationCompat.CATEGORY_ERROR)
-                .setContentTitle(this.context.getString(R.string.app_name))
-                .setContentText(msg)
-                .setStyle(new NotificationCompat.BigTextStyle().bigText(msg));
-        this.notify(ThreemaApplication.WEB_RESUME_FAILED_NOTIFICATION_ID, builder, null, NotificationChannels.NOTIFICATION_CHANNEL_NOTICE);
-    }
-
-    @Override
-    public void cancelRestartNotification() {
-        cancel(APP_RESTART_NOTIFICATION_ID);
-    }
-
-    @Override
-    public void cancelRestoreNotification() {
-        cancel(RESTORE_COMPLETION_NOTIFICATION_ID);
-    }
-
-    @Override
-    public void showGroupJoinResponseNotification(@NonNull OutgoingGroupJoinRequestModel outgoingGroupJoinRequestModel,
-                                                  @NonNull OutgoingGroupJoinRequestModel.Status status,
-                                                  @NonNull DatabaseServiceNew databaseService) {
-        /* stub */
-    }
-
-    @Override
-    public void showGroupJoinRequestNotification(@NonNull IncomingGroupJoinRequestModel incomingGroupJoinRequestModel, GroupModel groupModel) {
-        /* stub */
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/FSDatabaseUpgradeToVersion4.kt b/app/src/main/java/ch/threema/app/services/systemupdate/FSDatabaseUpgradeToVersion4.kt
deleted file mode 100644
index 9666e685..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/FSDatabaseUpgradeToVersion4.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class FSDatabaseUpgradeToVersion4(
-    private val sqLiteDatabase: SQLiteDatabase
-): UpdateSystemService.SystemUpdate {
-
-    companion object {
-        const val VERSION = 4
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        if (!fieldExists(sqLiteDatabase, "session", "lastOutgoingMessageTimestamp")) {
-            sqLiteDatabase.rawExecSQL("ALTER TABLE session ADD COLUMN lastOutgoingMessageTimestamp INTEGER DEFAULT 0")
-        }
-        return true
-    }
-
-    override fun getText() = "Version $VERSION (add timestamp of last sent fs message)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateHelpers.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateHelpers.kt
deleted file mode 100644
index f6307ee9..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateHelpers.kt
+++ /dev/null
@@ -1,42 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-/**
- * Return whether or not the specified fieldName exists in the specified table.
- */
-fun fieldExists(
-    sqliteDatabase: SQLiteDatabase,
-    table: String,
-    fieldName: String
-): Boolean {
-    // The SQLite table_info pragma returns one row for each normal column in the named table.
-    sqliteDatabase.query(
-        "pragma_table_info('$table')", arrayOf("name"),
-        "name = ?", arrayOf(fieldName),
-        null,
-        null,
-        null
-    ).use { cursor -> return cursor.count > 0 }
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion100.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion100.kt
deleted file mode 100644
index 7f5b0f68..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion100.kt
+++ /dev/null
@@ -1,65 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion100(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 100
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        sqLiteDatabase.execSQL(
-            "CREATE TABLE IF NOT EXISTS `contact_edit_history_entries` (" +
-                "`uid` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
-                "`messageUid` VARCHAR NOT NULL, " +
-                "`messageId` INTEGER NOT NULL, " +
-                "`text` VARCHAR NOT NULL, " +
-                "`editedAt` DATETIME NOT NULL, " +
-                "CONSTRAINT fk_contact_message_id FOREIGN KEY(messageId) " +
-                "REFERENCES message (id) ON UPDATE CASCADE ON DELETE CASCADE " +
-                ")"
-        )
-
-        sqLiteDatabase.execSQL(
-            "CREATE TABLE IF NOT EXISTS `group_edit_history_entries` (" +
-                "`uid` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
-                "`messageUid` VARCHAR NOT NULL, " +
-                "`messageId` INTEGER NOT NULL, " +
-                "`text` VARCHAR NOT NULL, " +
-                "`editedAt` DATETIME NOT NULL, " +
-                "CONSTRAINT fk_group_message_id FOREIGN KEY(messageId) " +
-                "REFERENCES m_group_message (id) ON UPDATE CASCADE ON DELETE CASCADE " +
-                ")"
-        )
-
-        return true
-    }
-
-    override fun getText() = "version $VERSION (create edit message history entries tables)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion101.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion101.kt
deleted file mode 100644
index 367779f2..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion101.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion101(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 101
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        if (!fieldExists(sqLiteDatabase, "contacts", "jobTitle")) {
-            sqLiteDatabase.rawExecSQL("ALTER TABLE `contacts` ADD COLUMN `jobTitle` VARCHAR DEFAULT NULL")
-        }
-        if (!fieldExists(sqLiteDatabase, "contacts", "department")) {
-            sqLiteDatabase.rawExecSQL("ALTER TABLE `contacts` ADD COLUMN `department` VARCHAR DEFAULT NULL")
-        }
-        return true
-    }
-
-    override fun getText() = "version $VERSION (add contacts job title & department field)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion102.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion102.kt
deleted file mode 100644
index c31acdab..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion102.kt
+++ /dev/null
@@ -1,109 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion102(private val sqLiteDatabase: SQLiteDatabase) : UpdateSystemService.SystemUpdate {
-
-    companion object {
-        const val VERSION = 102
-    }
-
-    override fun getText() =
-        "version $VERSION (made column `text` nullable in tables `contact_edit_history_entries` and `group_edit_history_entries`)"
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-
-        /**
-         *  We want to change the data type of column `text` from `VARCHAR NOT NULL` to `VARCHAR DEFAULT NULL`.
-         *  Because SqLite does not support this with the `ALTER TABLE` command we have to do these steps:
-         *  1. Create a new table with the new schema (updated column data type)
-         *  2. Copy over all data from the existing to the new table
-         *  3. Delete the old table
-         *  4. Rename the new table to the old tables name
-         */
-
-        makeColumnTextFromContactEditHistoryEntriesNullable()
-        makeColumnTextFromGroupEditHistoryEntriesNullable()
-        return true
-    }
-
-    /**
-     *  Note that there is no way in SqLite to rename a constraint.
-     *  So the constraint `fk_contact_message_id_new` has to stay like this.
-     */
-    private fun makeColumnTextFromContactEditHistoryEntriesNullable() {
-        sqLiteDatabase.execSQL(
-            """
-                CREATE TABLE `contact_edit_history_entries_new` (
-                    `uid` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
-                    `messageUid` VARCHAR NOT NULL,
-                    `messageId` INTEGER NOT NULL,
-                    `text` VARCHAR DEFAULT NULL,
-                    `editedAt` DATETIME NOT NULL,
-                    CONSTRAINT `fk_contact_message_id_new` FOREIGN KEY(messageId) REFERENCES message (id) ON UPDATE CASCADE ON DELETE CASCADE
-                )
-                """
-        )
-        sqLiteDatabase.execSQL(
-            """
-                INSERT INTO `contact_edit_history_entries_new` (`uid`, `messageUid`, `messageId`, `text`, `editedAt`)
-                    SELECT `uid`, `messageUid`, `messageId`, `text`, `editedAt`
-                    FROM `contact_edit_history_entries`
-                """
-        )
-        sqLiteDatabase.execSQL("DROP TABLE `contact_edit_history_entries`")
-        sqLiteDatabase.execSQL("ALTER TABLE `contact_edit_history_entries_new` RENAME TO `contact_edit_history_entries`")
-    }
-
-    /**
-     *  Note that there is no way in SqLite to rename a constraint.
-     *  So the constraint `fk_group_message_id_new` has to stay like this.
-     */
-    private fun makeColumnTextFromGroupEditHistoryEntriesNullable() {
-        sqLiteDatabase.execSQL(
-            """
-                CREATE TABLE `group_edit_history_entries_new` (
-                    `uid` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
-                    `messageUid` VARCHAR NOT NULL,
-                    `messageId` INTEGER NOT NULL,
-                    `text` VARCHAR DEFAULT NULL,
-                    `editedAt` DATETIME NOT NULL,
-                    CONSTRAINT fk_group_message_id_new FOREIGN KEY(messageId) REFERENCES m_group_message (id) ON UPDATE CASCADE ON DELETE CASCADE
-                )
-                """
-        )
-        sqLiteDatabase.execSQL(
-            """
-                INSERT INTO `group_edit_history_entries_new` (`uid`, `messageUid`, `messageId`, `text`, `editedAt`)
-                    SELECT `uid`, `messageUid`, `messageId`, `text`, `editedAt`
-                    FROM `group_edit_history_entries`
-                """
-        )
-        sqLiteDatabase.execSQL("DROP TABLE `group_edit_history_entries`")
-        sqLiteDatabase.execSQL("ALTER TABLE `group_edit_history_entries_new` RENAME TO `group_edit_history_entries`")
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion103.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion103.kt
deleted file mode 100644
index 0158660f..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion103.kt
+++ /dev/null
@@ -1,62 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion103(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 103
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        unStarStarredStatusMessages(messageTableName = "message")
-        unStarStarredStatusMessages(messageTableName = "m_group_message")
-        unStarStarredStatusMessages(messageTableName = "distribution_list_message")
-        return true
-    }
-
-    /**
-     *  This will un-star every status message that could be starred in previous app-versions.
-     *
-     *  The flag `DisplayTag.DISPLAY_TAG_STARRED` gets removed from cell value `displayTags` if set.
-     *
-     *  `1` here stands for the flag `DisplayTag.DISPLAY_TAG_STARRED`
-     */
-    private fun unStarStarredStatusMessages(messageTableName: String) {
-        sqLiteDatabase.execSQL(
-            """
-                UPDATE $messageTableName
-                SET displayTags = (displayTags & ~1)
-                WHERE isStatusMessage = 1
-                  AND (displayTags & 1) = 1;
-            """
-        )
-    }
-
-    override fun getText() = "version $VERSION (correct starred status message to not-starred)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java
index f3dfe22b..859fb476 100644
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java
+++ b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion39.java
@@ -28,6 +28,7 @@ import ch.threema.app.exceptions.FileSystemNotPresentException;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.UpdateSystemService;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.localcrypto.MasterKeyLockedException;
 import ch.threema.storage.models.ContactModel;
@@ -60,7 +61,7 @@ public class SystemUpdateToVersion39 implements UpdateSystemService.SystemUpdate
 			// call find with fetchMissingFeatureLevel = true to fetch all contacts without current feature level
 			contactService.find(new ContactService.Filter() {
 				@Override
-				public ContactModel.State[] states() {
+				public IdentityState[] states() {
 					return null;
 				}
 
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion86.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion86.kt
deleted file mode 100644
index e1df0a70..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion86.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion86(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 86
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        sqLiteDatabase.execSQL(
-            "CREATE TABLE `tasks` (" +
-                    "`id` INTEGER PRIMARY KEY AUTOINCREMENT, " +
-                    "`task` STRING NOT NULL)"
-        )
-
-        return true
-    }
-
-    override fun getText() = "version $VERSION (create task archive table)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion87.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion87.kt
deleted file mode 100644
index 1ebdf090..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion87.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion87(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 87
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        sqLiteDatabase.execSQL(
-            "CREATE TABLE `rejected_group_messages` (" +
-                    "`messageId` INTEGER NOT NULL, " +
-                    "`rejectedIdentity` VARCHAR NOT NULL," +
-                    "`groupId` INTEGER NOT NULL," +
-                    "PRIMARY KEY (`messageId`, `rejectedIdentity`, `groupId`) ON CONFLICT IGNORE " +
-                    ")"
-        )
-
-        return true
-    }
-
-    override fun getText() = "version $VERSION (create rejected group message table)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion88.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion88.kt
deleted file mode 100644
index ae6423b2..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion88.kt
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion88(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 88
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        sqLiteDatabase.execSQL("DROP TABLE IF EXISTS `m_group_message_pending_msg_id`")
-
-        return true
-    }
-
-    override fun getText() = "version $VERSION (remove pending group message table)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion89.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion89.kt
deleted file mode 100644
index 524b35a1..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion89.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import ch.threema.base.utils.LoggingUtil
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion89(
-    private val db: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 89
-        private val logger = LoggingUtil.getThreemaLogger("SystemUpdateToVersion89")
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        val tables = arrayOf("contacts", "m_group", "distribution_list")
-        val field = "lastUpdate"
-
-        // Add field
-        for (table in tables) {
-            if (!fieldExists(db, table, field)) {
-                logger.info("Adding $field field to table $table")
-                db.execSQL("ALTER TABLE `$table` ADD COLUMN `$field` INTEGER")
-            }
-        }
-
-        // Calculate lastUpdate based on existing data
-        calculateLastUpdateContacts()
-        calculateLastUpdateGroups()
-        calculateLastUpdateDistributionLists()
-
-        return true
-    }
-
-    override fun getText() = "version $VERSION (add lastUpdate field)"
-
-    private fun calculateLastUpdateContacts() {
-        logger.info("Calculate lastUpdate for contacts")
-
-        // Consider all message types except date separators and forward security status messages.
-        // Note that in a previous version of the update script (that has been applied for most
-        // users), all message types have been used to determine the last update flag leading to
-        // some chat reordering.
-        db.execSQL("""
-            UPDATE contacts
-            SET lastUpdate = tmp.lastUpdate FROM (
-                SELECT m.identity, max(m.createdAtUtc) as lastUpdate
-                FROM message m
-                WHERE m.isSaved = 1 AND type != 10 AND type != 12
-                GROUP BY m.identity
-            ) tmp
-            WHERE contacts.identity = tmp.identity;
-        """)
-    }
-
-    private fun calculateLastUpdateGroups() {
-        logger.info("Calculate lastUpdate for groups")
-
-        // Set lastUpdate to the create date of the latest message if present
-        // Consider all message types except date separators and group status messages. Note that in
-        // a previous version of the update script (that has been applied for most users), all
-        // message types have been used to determine the last update flag leading to some chat
-        // reordering.
-        db.execSQL("""
-            UPDATE m_group
-            SET lastUpdate = tmp.lastUpdate FROM (
-                SELECT m.groupId, max(m.createdAtUtc) as lastUpdate
-                FROM m_group_message m
-                WHERE m.isSaved = 1 AND type != 10 AND type != 13
-                GROUP BY m.groupId
-            ) tmp
-            WHERE m_group.id = tmp.groupId;
-        """)
-
-        // Set lastUpdate for groups without messages.
-        // `createdAt` is stored in localtime and therefore needs to be converted to UTC.
-        db.execSQL("""
-            UPDATE m_group
-            SET lastUpdate = strftime('%s', createdAt, 'utc') * 1000
-            WHERE lastUpdate IS NULL;
-        """)
-    }
-
-    private fun calculateLastUpdateDistributionLists() {
-        logger.info("Calculate lastUpdate for distribution lists")
-
-        // Set lastUpdate to the create date of the latest message if present
-        db.execSQL("""
-            UPDATE distribution_list
-            SET lastUpdate = tmp.lastUpdate FROM (
-                SELECT m.distributionListId, max(m.createdAtUtc) as lastUpdate
-                FROM distribution_list_message m
-                WHERE m.isSaved = 1
-                GROUP BY m.distributionListId
-            ) tmp
-            WHERE distribution_list.id = tmp.distributionListId;
-        """)
-
-        // Set lastUpdate for distribution lists without messages.
-        // `createdAt` is stored in localtime and therefore needs to be converted to UTC.
-        db.execSQL("""
-            UPDATE distribution_list
-            SET lastUpdate = strftime('%s', createdAt, 'utc') * 1000
-            WHERE lastUpdate IS NULL;
-        """)
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion90.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion90.kt
deleted file mode 100644
index 333c8128..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion90.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-class SystemUpdateToVersion90(
-    private val db: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 90
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        db.execSQL("DROP INDEX IF EXISTS `message_queue_idx`")
-
-        db.execSQL("CREATE INDEX IF NOT EXISTS `message_state_idx` ON `message` ( " +
-            "`type`, " +
-            "`state`, " +
-            "`outbox` " +
-            ")")
-
-        db.execSQL("CREATE INDEX IF NOT EXISTS `group_message_state_idx` ON `m_group_message` ( " +
-            "`type`, " +
-            "`state`, " +
-            "`outbox` " +
-            ")")
-
-        db.execSQL("CREATE INDEX IF NOT EXISTS `distribution_list_message_state_idx` ON `distribution_list_message` ( " +
-            "`type`, " +
-            "`state`, " +
-            "`outbox` " +
-            ")")
-        return true
-    }
-
-    override fun getText() = "version $VERSION (update message index)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion91.java b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion91.java
deleted file mode 100644
index 9dc74b91..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion91.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate;
-
-import android.Manifest;
-import android.accounts.Account;
-import android.accounts.AccountManager;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.provider.ContactsContract;
-
-import androidx.preference.PreferenceManager;
-
-import org.slf4j.Logger;
-
-import java.sql.SQLException;
-
-import ch.threema.app.BuildFlavor;
-import ch.threema.app.R;
-import ch.threema.app.services.UpdateSystemService;
-import ch.threema.app.utils.ConfigUtils;
-import ch.threema.app.utils.SynchronizeContactsUtil;
-import ch.threema.base.utils.LoggingUtil;
-
-/**
- *  Fix Contact sync account type for Threema Libre
- */
-public class SystemUpdateToVersion91 implements UpdateSystemService.SystemUpdate {
-	public static final int VERSION = 91;
-	private static final Logger logger = LoggingUtil.getThreemaLogger("SystemUpdateToVersion91");
-
-	private final Context context;
-
-	public SystemUpdateToVersion91(Context context) {
-		this.context = context;
-	}
-
-	@Override
-	public boolean runDirectly() throws SQLException {
-		if (BuildFlavor.getCurrent().isLibre()) {
-			final boolean isSyncContacts = PreferenceManager.getDefaultSharedPreferences(this.context).getBoolean(context.getString(R.string.preferences__sync_contacts), false);
-
-			if (!SynchronizeContactsUtil.isRestrictedProfile(context) && isSyncContacts) {
-				if (ConfigUtils.isPermissionGranted(context, Manifest.permission.WRITE_CONTACTS)) {
-					final AccountManager accountManager = AccountManager.get(this.context);
-
-					if (accountManager != null) {
-						try {
-							for (Account account : accountManager.getAccountsByTypeForPackage("ch.threema.app", context.getPackageName())) {
-								if (account.name.equals(context.getString(R.string.app_name))) {
-									accountManager.removeAccount(account, null, null);
-								}
-							}
-
-							// we don't need to wait until removal is complete to create a new account that differs from the existing one(s)
-							Account newAccount = new Account(context.getString(R.string.app_name), context.getString(R.string.package_name));
-							accountManager.addAccountExplicitly(newAccount, "", null);
-							ContentResolver.setIsSyncable(newAccount, ContactsContract.AUTHORITY, 1);
-							if (!ContentResolver.getSyncAutomatically(newAccount, ContactsContract.AUTHORITY)) {
-								ContentResolver.setSyncAutomatically(newAccount, ContactsContract.AUTHORITY, true);
-							}
-						} catch (Exception e) {
-							logger.error("Exception", e);
-						}
-					}
-				}
-			}
-		}
-		return true;
-	}
-
-	@Override
-	public boolean runAsync() {
-		return true;
-	}
-
-	@Override
-	public String getText() {
-		return "version " + VERSION + " (fix libre account type)";
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion92.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion92.kt
deleted file mode 100644
index 8d546a1d..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion92.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-class SystemUpdateToVersion92(
-    private val db: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 92
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        for (table in arrayOf(
-            "message",
-            "m_group_message",
-            "distribution_list_message"
-        )) {
-            if (fieldExists(db, table, "displayTags")) {
-                db.execSQL("UPDATE $table SET `displayTags` = 0 WHERE `type` = 12 AND `displayTags` = 1")
-            }
-        }
-        return true
-    }
-
-    override fun getText() = "version $VERSION (remove star from fs status messages)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion93.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion93.kt
deleted file mode 100644
index f30c0655..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion93.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion93(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 93
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        for (table in arrayOf(
-            "message",
-            "m_group_message"
-        )) {
-            if (!fieldExists(sqLiteDatabase, table, "editedAtUtc")) {
-                sqLiteDatabase.rawExecSQL("ALTER TABLE `$table` ADD COLUMN `editedAtUtc` DATETIME")
-            }
-        }
-        return true
-    }
-
-    override fun getText() = "version $VERSION (add editedAt field for messages)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion94.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion94.kt
deleted file mode 100644
index 479d0508..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion94.kt
+++ /dev/null
@@ -1,69 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import ch.threema.base.utils.LoggingUtil
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion94(
-    private val db: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 94
-        private val logger = LoggingUtil.getThreemaLogger("SystemUpdateToVersion94")
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        val table = "contacts"
-
-        // Remove unused fields
-        dropField(table, "threemaAndroidContactId")
-        dropField(table, "isSynchronized")
-
-        // Migrate "isHidden" to "acquaintanceLevel"
-        if (!fieldExists(db, table, "acquaintanceLevel")) {
-            // Values: 0: Direct, 1: Group
-            logger.info("Renaming $table.isHidden to acquaintanceLevel")
-            db.execSQL("ALTER TABLE `$table` RENAME COLUMN `isHidden` TO `acquaintanceLevel`")
-        }
-
-        // Add "syncState" field
-        // Values: 0: Initial, 1: Imported, 2: Custom
-        if (!fieldExists(db, table, "syncState")) {
-            logger.info("Adding $table.syncState")
-            db.execSQL("ALTER TABLE `$table` ADD COLUMN `syncState` INTEGER NOT NULL DEFAULT 0")
-        }
-        return true
-    }
-
-    override fun getText() = "version $VERSION (contact table cleanup and changes)"
-
-    private fun dropField(table: String, field: String) {
-        if (fieldExists(db, table, field)) {
-            logger.info("Removing $field field from table $table")
-            db.execSQL("ALTER TABLE `$table` DROP COLUMN `$field`")
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion95.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion95.kt
deleted file mode 100644
index b164cf25..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion95.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion95(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 95
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        val table = "distribution_list_message"
-        if (!fieldExists(sqLiteDatabase, table, "editedAtUtc")) {
-            sqLiteDatabase.rawExecSQL("ALTER TABLE `$table` ADD COLUMN `editedAtUtc` DATETIME")
-        }
-        return true
-    }
-
-    override fun getText() = "version $VERSION (add editedAt field for distribution messages)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion96.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion96.kt
deleted file mode 100644
index f15ba517..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion96.kt
+++ /dev/null
@@ -1,113 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import android.content.ContentValues
-import ch.threema.app.services.UpdateSystemService
-import ch.threema.app.utils.ColorUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.Utils
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-import java.nio.charset.StandardCharsets
-import java.security.MessageDigest
-import java.security.NoSuchAlgorithmException
-
-private val logger = LoggingUtil.getThreemaLogger("SystemUpdateToVersion96")
-
-class SystemUpdateToVersion96(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 96
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        removeIsActiveColumn()
-        removeGroupKindColumn()
-        addColorIndexColumn()
-        return true
-    }
-
-    override fun getText() = "version $VERSION (remove isActive from group member table)"
-
-    private fun removeIsActiveColumn() {
-        if (fieldExists(sqLiteDatabase, "group_member", "isActive")) {
-            // Remove 'isActive' column in group member table
-            sqLiteDatabase.execSQL("ALTER TABLE `group_member` DROP COLUMN `isActive`")
-        }
-    }
-
-    private fun removeGroupKindColumn() {
-        if (fieldExists(sqLiteDatabase, "m_group", "groupKind")) {
-            // Remove 'groupKind' column in group member table
-            sqLiteDatabase.execSQL("ALTER TABLE `m_group` DROP COLUMN `groupKind`")
-        }
-    }
-
-    private fun addColorIndexColumn() {
-        // Add color index column
-        if (!fieldExists(sqLiteDatabase, "m_group", "colorIndex")) {
-            sqLiteDatabase.execSQL("ALTER TABLE `m_group` ADD COLUMN `colorIndex` INTEGER DEFAULT 0 NOT NULL")
-        }
-
-        // Get the required fields and calculate the color index for each entry
-        val cursor = sqLiteDatabase.query("SELECT `apiGroupId`, `creatorIdentity` FROM `m_group`")
-        val colorIndices = mutableListOf<Triple<String, String, Int>>()
-        while (cursor.moveToNext()) {
-            val creatorIdentity = cursor.getString(cursor.getColumnIndexOrThrow("creatorIdentity"))
-            val groupIdString = cursor.getString(cursor.getColumnIndexOrThrow("apiGroupId"))
-            val colorIndex = computeColorIndex(creatorIdentity, groupIdString)
-            colorIndices.add(Triple(creatorIdentity, groupIdString, colorIndex))
-        }
-
-        // Write the calculated color indices to the database
-        colorIndices.forEach {
-            val (creatorIdentity, groupIdString, colorIndex) = it
-            val contentValues = ContentValues()
-            contentValues.put("colorIndex", colorIndex)
-            sqLiteDatabase.update(
-                "m_group",
-                contentValues,
-                "`creatorIdentity` = ? AND `apiGroupId` = ?",
-                arrayOf(creatorIdentity, groupIdString)
-            )
-        }
-    }
-
-    private fun computeColorIndex(creatorIdentity: String, groupIdString: String): Int {
-        val groupCreatorIdentity: ByteArray = creatorIdentity.toByteArray(StandardCharsets.UTF_8)
-        val groupId: ByteArray = Utils.hexStringToByteArray(groupIdString)
-
-        try {
-            val md = MessageDigest.getInstance("SHA-256")
-            md.update(groupCreatorIdentity)
-            md.update(groupId)
-            val firstByte = md.digest()[0]
-            return ColorUtil.getInstance().getIDColorIndex(firstByte)
-        } catch (e: NoSuchAlgorithmException) {
-            logger.error("Could not hash the identity to determine color", e)
-            return 0
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion97.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion97.kt
deleted file mode 100644
index 4c07b1db..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion97.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-internal class SystemUpdateToVersion97(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 97
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        for (table in arrayOf(
-            "message",
-            "m_group_message",
-            "distribution_list_message"
-        )) {
-            if (!fieldExists(sqLiteDatabase, table, "deletedAtUtc")) {
-                sqLiteDatabase.rawExecSQL("ALTER TABLE `$table` ADD COLUMN `deletedAtUtc` DATETIME")
-            }
-        }
-        return true
-    }
-
-    override fun getText() = "version $VERSION (add deletedAtUtc field for messages)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion98.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion98.kt
deleted file mode 100644
index c9cda0aa..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion98.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-class SystemUpdateToVersion98(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 98
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        sqLiteDatabase.execSQL(
-            """
-                CREATE TABLE `m_group_incoming_sync_request_log`(
-                    `groupId` INTEGER,
-                    `senderIdentity` VARCHAR,
-                    `lastHandledRequest` VARCHAR,
-                    PRIMARY KEY(`groupId`, `senderIdentity`),
-                    FOREIGN KEY(`groupId`) REFERENCES `m_group`(`id`)
-                )
-            """
-        )
-
-        return true
-    }
-
-    override fun getText() = "version $VERSION (add incoming group sync request log table)"
-}
diff --git a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion99.kt b/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion99.kt
deleted file mode 100644
index cdb096c7..00000000
--- a/app/src/main/java/ch/threema/app/services/systemupdate/SystemUpdateToVersion99.kt
+++ /dev/null
@@ -1,63 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.services.systemupdate
-
-import ch.threema.app.services.UpdateSystemService
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-class SystemUpdateToVersion99(
-    private val sqLiteDatabase: SQLiteDatabase,
-) : UpdateSystemService.SystemUpdate {
-    companion object {
-        const val VERSION = 99
-    }
-
-    override fun runAsync() = true
-
-    override fun runDirectly(): Boolean {
-        // Create new table with on delete/update actions
-        sqLiteDatabase.execSQL(
-            """
-            CREATE TABLE IF NOT EXISTS `incoming_group_sync_request_log`(
-                `groupId` INTEGER,
-                `senderIdentity` VARCHAR,
-                `lastHandledRequest` DATETIME,
-                PRIMARY KEY(`groupId`, `senderIdentity`),
-                FOREIGN KEY(`groupId`) REFERENCES `m_group`(`id`) ON UPDATE CASCADE ON DELETE CASCADE
-            )
-            """
-        )
-
-        // Drop the old table
-        sqLiteDatabase.execSQL("DROP TABLE `m_group_incoming_sync_request_log`")
-
-        // Note that we omit the migration of the content of this table as it is not a problem if
-        // the request log is emptied from time to time. The effect is only that a sync request
-        // might be answered too early. The purpose of preventing infinite loops is still fulfilled.
-        // The migration of the content would be somehow risky because the old table could contain
-        // data that violates the foreign key constraint.
-
-        return true
-    }
-
-    override fun getText() = "version $VERSION (fix incoming group sync request constraint)"
-}
diff --git a/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java b/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java
index 1f9a6b88..07e12bbd 100644
--- a/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java
+++ b/app/src/main/java/ch/threema/app/stores/DatabaseContactStore.java
@@ -31,31 +31,20 @@ import java.util.stream.Collectors;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
-import ch.threema.app.ThreemaApplication;
 import ch.threema.app.managers.ListenerManager;
-import ch.threema.app.managers.ServiceManager;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.services.MessageService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.fs.DHSession;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.ServerAddressProvider;
-import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.stores.ContactStore;
-import ch.threema.domain.stores.DHSessionStoreException;
-import ch.threema.domain.stores.DHSessionStoreInterface;
-import ch.threema.domain.stores.IdentityStoreInterface;
-import ch.threema.protobuf.csp.e2e.fs.Terminate;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.ContactModelFactory;
 import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
-import ch.threema.storage.models.data.status.ForwardSecurityStatusDataModel;
 
 /**
  * The {@link DatabaseContactStore} is an implementation of the {@link ContactStore} interface
@@ -64,8 +53,6 @@ import ch.threema.storage.models.data.status.ForwardSecurityStatusDataModel;
 public class DatabaseContactStore implements ContactStore {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("DatabaseContactStore");
 
-	private final @NonNull IdentityStoreInterface identityStore;
-	private final @NonNull DHSessionStoreInterface fsSessions;
 	private final @NonNull DatabaseServiceNew databaseServiceNew;
 
 	/**
@@ -74,19 +61,15 @@ public class DatabaseContactStore implements ContactStore {
 	private final @NonNull Map<String, Contact> specialContacts = new HashMap<>();
 
 	/**
-	 * The cache of fetched contacts. Note that this cache only contains the cached contacts from a
-	 * server fetch. Contacts from the database are not cached here.
+	 * The cache of contacts. Note that this cache only contains the cached contacts from a server
+	 * fetch. Contacts from the database are not cached here.
 	 */
-	private final @NonNull Map<String, Contact> contactCache = new HashMap<>();
+	private final @NonNull Map<String, BasicContact> contactCache = new HashMap<>();
 
 	public DatabaseContactStore(
-		@NonNull IdentityStoreInterface identityStore,
-		@NonNull DHSessionStoreInterface fsSessions,
 		@NonNull DatabaseServiceNew databaseServiceNew,
 		@NonNull ServerAddressProvider serverAddressProvider
 	) {
-		this.identityStore = identityStore;
-		this.fsSessions = fsSessions;
 		this.databaseServiceNew = databaseServiceNew;
 
 		try {
@@ -119,10 +102,16 @@ public class DatabaseContactStore implements ContactStore {
 	}
 
 	@Override
-	public void addCachedContact(@NonNull Contact contact) {
+	public void addCachedContact(@NonNull BasicContact contact) {
 		contactCache.put(contact.getIdentity(), contact);
 	}
 
+	@Nullable
+	@Override
+	public BasicContact getCachedContact(@NonNull String identity) {
+		return contactCache.get(identity);
+	}
+
 	@Nullable
 	@Override
 	public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
@@ -173,28 +162,6 @@ public class DatabaseContactStore implements ContactStore {
 					);
 				}
 			}
-
-			// Only warn about an FS feature mask downgrade if an FS session existed.
-			DHSession fsSession = null;
-			try {
-				fsSession = fsSessions.getBestDHSession(identityStore.getIdentity(), contact.getIdentity(), ThreemaApplication.requireServiceManager().getMigrationTaskHandle());
-			} catch (DHSessionStoreException | NullPointerException exception) {
-				logger.error("Unable to determine best DH session", exception);
-			}
-			if (fsSession != null && !ThreemaFeature.canForwardSecurity(contactModel.getFeatureMask())) {
-				logger.info("Forward security feature has been downgraded for contact {}", contactModel.getIdentity());
-				// Create a status message that forward security has been disabled for this contact
-				// due to a downgrade.
-				createForwardSecurityDowngradedStatus(contactModel);
-
-				// Clear and terminate all sessions with that contact
-				ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-				if (serviceManager != null) {
-					serviceManager.getTaskCreator().scheduleDeleteAndTerminateFSSessionsTaskAsync(
-						contact, Terminate.Cause.DISABLED_BY_REMOTE
-					);
-				}
-			}
 		}
 
 		contactModelFactory.createOrUpdate(contactModel);
@@ -207,49 +174,9 @@ public class DatabaseContactStore implements ContactStore {
 		}
 	}
 
-	private void createForwardSecurityDowngradedStatus(@NonNull ContactModel contactModel) {
-		try {
-			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
-			if (serviceManager != null) {
-				MessageService messageService = serviceManager.getMessageService();
-				ContactService contactService = serviceManager.getContactService();
-				messageService.createForwardSecurityStatus(
-					contactService.createReceiver(contactModel),
-					ForwardSecurityStatusDataModel.ForwardSecurityStatusType.FORWARD_SECURITY_UNAVAILABLE_DOWNGRADE,
-					0,
-					null
-				);
-			} else {
-				logger.error("ServiceManager is null");
-			}
-		} catch (ThreemaException e) {
-			logger.error("Error while creating forward security downgrade status message", e);
-		}
-	}
-
-	/**
-	 * Mark the contact as hidden / unhidden. Then store or update the contact in the database.
-	 */
-	public void hideContact(@NonNull ContactModel contactModel, boolean hide) {
-		// Mark as hidden / unhidden
-		contactModel.setAcquaintanceLevel(hide ? AcquaintanceLevel.GROUP : AcquaintanceLevel.DIRECT);
-
-		// Update database
-		ContactModelFactory contactModelFactory = this.databaseServiceNew.getContactModelFactory();
-		contactModelFactory.createOrUpdate(contactModel);
-
-		// Fire listeners
-		this.fireOnModifiedContact(contactModel.getIdentity());
-	}
-
 	@Override
-	public void removeContact(@NonNull Contact contact) {
-		this.removeContact((ContactModel)contact);
-	}
-
-	public void removeContact(final ContactModel contactModel) {
-		this.databaseServiceNew.getContactModelFactory().delete(contactModel);
-		fireOnRemovedContact(contactModel);
+	public boolean isSpecialContact(@NonNull String identity) {
+		return specialContacts.containsKey(identity);
 	}
 
 	private void fireOnNewContact(final ContactModel createdContactModel) {
@@ -263,10 +190,4 @@ public class DatabaseContactStore implements ContactStore {
 			listener.onModified(identity);
 		});
 	}
-
-	private void fireOnRemovedContact(final ContactModel removedContactModel) {
-		ListenerManager.contactListeners.handle(listener -> {
-			listener.onRemoved(removedContactModel.getIdentity());
-		});
-	}
 }
diff --git a/app/src/main/java/ch/threema/app/stores/IdentityStore.java b/app/src/main/java/ch/threema/app/stores/IdentityStore.java
index d6c5d286..9a9e017b 100644
--- a/app/src/main/java/ch/threema/app/stores/IdentityStore.java
+++ b/app/src/main/java/ch/threema/app/stores/IdentityStore.java
@@ -132,7 +132,11 @@ public class IdentityStore implements IdentityStoreInterface {
 		return this.publicNickname;
 	}
 
-	public void setPublicNickname(String publicNickname) {
+    /**
+     * This method persists the public nickname. It does *not* reflect the changes and must
+     * therefore only be used to persist the nickname.
+     */
+	public void persistPublicNickname(String publicNickname) {
 		this.publicNickname = publicNickname;
 		this.preferenceStore.save(PreferenceStore.PREFS_PUBLIC_NICKNAME, publicNickname);
 		ListenerManager.profileListeners.handle(listener -> listener.onNicknameChanged(publicNickname));
@@ -156,7 +160,7 @@ public class IdentityStore implements IdentityStoreInterface {
 		this.preferenceStore.save(PreferenceStore.PREFS_PRIVATE_KEY, privateKey, true);
 
 		//default identity
-		this.setPublicNickname(identity);
+		this.persistPublicNickname(identity);
 	}
 
 	public void clear() {
diff --git a/app/src/main/java/ch/threema/app/stores/PreferenceStore.java b/app/src/main/java/ch/threema/app/stores/PreferenceStore.java
index 315054a4..147d2c7f 100644
--- a/app/src/main/java/ch/threema/app/stores/PreferenceStore.java
+++ b/app/src/main/java/ch/threema/app/stores/PreferenceStore.java
@@ -35,15 +35,11 @@ import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 
-import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
-import java.io.FilenameFilter;
 import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectInputStream;
 import java.io.ObjectOutput;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -59,7 +55,6 @@ import java.util.Set;
 import javax.crypto.CipherInputStream;
 import javax.crypto.CipherOutputStream;
 
-import ch.threema.app.listeners.PreferenceListener;
 import ch.threema.app.managers.ListenerManager;
 import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.StringConversionUtil;
@@ -91,7 +86,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 
 	private final Context context;
 	private final MasterKey masterKey;
-	private SharedPreferences sharedPreferences;
+	private final SharedPreferences sharedPreferences;
 
 	public PreferenceStore(Context context, MasterKey masterKey) {
 		this.context = context;
@@ -309,7 +304,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		if (crypt) {
 			//save into a file
 			try {
-				//TODO
+				// TODO(ANDR-2798): Implement or remove method if unused
 				//this.saveDataToCryptedFile(thing, key);
 			} catch (Exception e) {
 				logger.error("Exception", e);
@@ -340,6 +335,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		// ignore close exception
 	}
 
+	@Override
 	public void save(String key, JSONArray array, boolean crypt) {
 		if (crypt) {
 			if (array != null) {
@@ -423,7 +419,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 	@Override
 	@Nullable
 	public String[] getStringArray(String key, boolean crypted) {
-		String value = null;
+		String value;
 		if (crypted) {
 			byte[] r = this.getDataFromCryptedFile(key);
 			if (r != null) {
@@ -606,10 +602,12 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		return this.sharedPreferences.getFloat(key, defValue);
 	}
 
+	@Override
 	public boolean getBoolean(String key) {
 		return this.sharedPreferences.getBoolean(key, false);
 	}
 
+	@Override
 	public boolean getBoolean(String key, boolean defValue) {
 		return this.sharedPreferences.getBoolean(key, defValue);
 	}
@@ -668,37 +666,6 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		return null;
 	}
 
-	@Override
-	public <T> T getRealObject(String key, boolean crypt) {
-		try {
-			if (crypt) {
-				byte[] data = this.getDataFromCryptedFile(key);
-
-				ByteArrayInputStream bis = new ByteArrayInputStream(data);
-				ObjectInput in = null;
-				T o = null;
-				try {
-					in = new ObjectInputStream(bis);
-					o = (T)in.readObject();
-				} finally {
-					try {
-						if (in != null) {
-							in.close();
-						}
-					} catch (IOException ex) {
-						// ignore close exception
-					}
-				}
-				return o;
-			} else {
-				// not implemented
-			}
-		} catch (Exception e) {
-			logger.error("Exception", e);
-		}
-		return null;
-	}
-
 	@Override
 	public void clear() {
 		SharedPreferences.Editor editor = this.sharedPreferences.edit();
@@ -706,12 +673,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 		editor.apply();
 
 		try {
-			for (File f : this.context.getFilesDir().listFiles(new FilenameFilter() {
-				@Override
-				public boolean accept(File dir, String filename) {
-					return filename.startsWith(CRYPTED_FILE_PREFIX);
-				}
-			})) {
+			for (File f : this.context.getFilesDir().listFiles((dir, filename) -> filename.startsWith(CRYPTED_FILE_PREFIX))) {
 				FileUtil.deleteFileOrWarn(f, "clear", logger);
 			}
 		} catch (Exception e) {
@@ -749,12 +711,7 @@ public class PreferenceStore implements PreferenceStoreInterface {
 	}
 
 	private void fireOnChanged(final String key, final  Object value) {
-		ListenerManager.preferenceListeners.handle(new ListenerManager.HandleListener<PreferenceListener>() {
-			@Override
-			public void handle(PreferenceListener listener) {
-				listener.onChanged(key, value);
-			}
-		});
+		ListenerManager.preferenceListeners.handle(listener -> listener.onChanged(key, value));
 	}
 
 	@WorkerThread
diff --git a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java
index b677b64c..96a5839e 100644
--- a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java
+++ b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterface.java
@@ -155,8 +155,6 @@ public interface PreferenceStoreInterface {
 
 	JSONObject getJSONObject(String key, boolean crypt);
 
-	<T> T getRealObject(String key, boolean crypt);
-
 	void clear();
 
 	Map<String, ?> getAllNonCrypted();
diff --git a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java
index 668f99df..9e0dc8ac 100644
--- a/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java
+++ b/app/src/main/java/ch/threema/app/stores/PreferenceStoreInterfaceDevNullImpl.java
@@ -284,11 +284,6 @@ public class PreferenceStoreInterfaceDevNullImpl implements PreferenceStoreInter
 		return null;
 	}
 
-	@Override
-	public <T> T getRealObject(String key, boolean crypt) {
-		return null;
-	}
-
 	@Override
 	public void clear() {
 
@@ -301,7 +296,7 @@ public class PreferenceStoreInterfaceDevNullImpl implements PreferenceStoreInter
 
 	@Override
 	public Set<String> getStringSet(String key, int defaultRes) {
-		return new HashSet<String>();
+		return new HashSet<>();
 	}
 
 	@Override
diff --git a/app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt b/app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt
deleted file mode 100644
index e4862a7e..00000000
--- a/app/src/main/java/ch/threema/app/tasks/ApplicationUpdateStepsTask.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import androidx.work.OneTimeWorkRequest
-import androidx.work.WorkManager
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.workers.ContactUpdateWorker
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import kotlinx.serialization.Serializable
-
-/**
- * This task runs the _Application Update Steps_ as defined in the protocol.
- */
-class ApplicationUpdateStepsTask(serviceManager: ServiceManager) : ActiveTask<Unit>,
-    PersistableTask {
-    private val contactService by lazy { serviceManager.contactService }
-    private val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
-
-    override val type = "ApplicationUpdateStepsTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        val workRequest = OneTimeWorkRequest.Builder(ContactUpdateWorker::class.java).build()
-        WorkManager.getInstance(ThreemaApplication.getAppContext()).enqueue(workRequest)
-
-        // Remove all sessions with contacts where the version is not known
-        contactService.all.forEach {
-            forwardSecurityMessageProcessor.terminateAllInvalidSessions(it, handle)
-        }
-    }
-
-    override fun serialize() = ApplicationUpdateStepsData
-
-    @Serializable
-    object ApplicationUpdateStepsData : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager) =
-            ApplicationUpdateStepsTask(serviceManager)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/ComposableTask.kt b/app/src/main/java/ch/threema/app/tasks/ComposableTask.kt
deleted file mode 100644
index e9ef5c79..00000000
--- a/app/src/main/java/ch/threema/app/tasks/ComposableTask.kt
+++ /dev/null
@@ -1,33 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.PassiveTaskCodec
-
-interface ComposableTask<out R, in T> {
-    suspend fun run(handle: T): R
-}
-
-interface ActiveComposableTask<out R> : ComposableTask<R, ActiveTaskCodec>
-
-interface PassiveComposableTask<out R> : ComposableTask<R, PassiveTaskCodec>
diff --git a/app/src/main/java/ch/threema/app/tasks/DeleteAndTerminateFSSessionsTask.kt b/app/src/main/java/ch/threema/app/tasks/DeleteAndTerminateFSSessionsTask.kt
deleted file mode 100644
index c97d99fe..00000000
--- a/app/src/main/java/ch/threema/app/tasks/DeleteAndTerminateFSSessionsTask.kt
+++ /dev/null
@@ -1,65 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.protobuf.csp.e2e.fs.Terminate.Cause
-import kotlinx.serialization.Serializable
-
-class DeleteAndTerminateFSSessionsTask(
-    private val fsmp: ForwardSecurityMessageProcessor,
-    private val contact: Contact,
-    private val cause: Cause,
-) : ActiveTask<Unit>, PersistableTask {
-    override val type: String = "DeleteAndTerminateFSSessionsTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        fsmp.clearAndTerminateAllSessions(contact, cause, handle)
-    }
-
-    override fun serialize(): SerializableTaskData = DeleteAndTerminateFSSessionsTaskData(
-        contact.identity, cause
-    )
-
-    @Serializable
-    class DeleteAndTerminateFSSessionsTaskData(
-        private val identity: String,
-        private val cause: Cause,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> {
-            val contact = serviceManager.contactStore.getContactForIdentityIncludingCache(identity)
-                ?: throw IllegalStateException("Cannot re-create fs termination task for identity where no contact is known")
-
-            return DeleteAndTerminateFSSessionsTask(
-                serviceManager.forwardSecurityMessageProcessor,
-                contact,
-                cause
-            )
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/DeleteMessageUtils.kt b/app/src/main/java/ch/threema/app/tasks/DeleteMessageUtils.kt
deleted file mode 100644
index 6f449a0a..00000000
--- a/app/src/main/java/ch/threema/app/tasks/DeleteMessageUtils.kt
+++ /dev/null
@@ -1,88 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.messagereceiver.MessageReceiver
-import ch.threema.app.services.MessageService
-import ch.threema.app.utils.MessageUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.DeleteMessage
-import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
-import ch.threema.storage.models.AbstractMessageModel
-import org.slf4j.Logger
-
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("DeleteMessageUtils")
-
-fun runCommonDeleteMessageReceiveSteps(
-    deleteMessage: DeleteMessage,
-    receiver: MessageReceiver<*>,
-    messageService: MessageService
-) : AbstractMessageModel? {
-    return runCommonDeleteMessageReceiveSteps(deleteMessage, deleteMessage.data.messageId, receiver, messageService)
-}
-
-fun runCommonDeleteMessageReceiveSteps(
-    deleteMessage: GroupDeleteMessage,
-    receiver: MessageReceiver<*>,
-    messageService: MessageService
-) : AbstractMessageModel? {
-    return runCommonDeleteMessageReceiveSteps(deleteMessage, deleteMessage.data.messageId, receiver, messageService)
-}
-
-private fun runCommonDeleteMessageReceiveSteps(
-    deleteMessage: AbstractMessage,
-    messageId: Long,
-    receiver: MessageReceiver<*>,
-    messageService: MessageService
-) : AbstractMessageModel? {
-    // Lookup the message with `message_id` originally sent by the sender within
-    //  the associated conversation and let `message` be the result.
-    val apiMessageId = MessageId(messageId).toString()
-    val message = messageService.getMessageModelByApiMessageIdAndReceiver(apiMessageId, receiver)
-
-    // If `message` is not defined or the sender is not the original sender of
-    //  `message`, discard the message and abort these steps.
-    if (message == null) {
-        logger.warn("Incoming Delete Message: No message found for id: {}", apiMessageId)
-        return null
-    }
-    if (deleteMessage.fromIdentity != message.identity) {
-        logger.warn("Incoming Delete Message: original message's sender {} does not equal deleted message's sender {}", message.identity, deleteMessage.fromIdentity)
-        return null
-    }
-
-    // 3. If the `message` is not deletable because of its type, discard the message and abort these
-    //    steps.
-    if (!MessageUtil.canDeleteRemotely(message.type)) {
-        logger.warn("Incoming Delete Message: Message of type {} cannot be deleted", message.type)
-        return null
-    }
-
-    // Replace `message` with a message informing the user that the message of
-    //  the sender has been removed at `created-at`.
-    message.deletedAt = deleteMessage.date
-
-    return message
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/EditMessageUtils.kt b/app/src/main/java/ch/threema/app/tasks/EditMessageUtils.kt
deleted file mode 100644
index 56420607..00000000
--- a/app/src/main/java/ch/threema/app/tasks/EditMessageUtils.kt
+++ /dev/null
@@ -1,79 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.messagereceiver.MessageReceiver
-import ch.threema.app.services.MessageService
-import ch.threema.app.utils.MessageUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.EditMessage
-import ch.threema.domain.protocol.csp.messages.GroupEditMessage
-import ch.threema.storage.models.AbstractMessageModel
-import org.slf4j.Logger
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("EditMessageUtils")
-
-fun runCommonEditMessageReceiveSteps(
-    editMessage: EditMessage,
-    receiver: MessageReceiver<*>,
-    messageService: MessageService
-) : AbstractMessageModel? {
-    return runCommonEditMessageReceiveSteps(editMessage, editMessage.data.messageId, receiver, messageService)
-}
-
-fun runCommonEditMessageReceiveSteps(
-    editMessage: GroupEditMessage,
-    receiver: MessageReceiver<*>,
-    messageService: MessageService
-) : AbstractMessageModel? {
-    return runCommonEditMessageReceiveSteps(editMessage, editMessage.data.messageId, receiver, messageService)
-}
-
-private fun runCommonEditMessageReceiveSteps(
-    editMessage: AbstractMessage,
-    messageId: Long,
-    receiver: MessageReceiver<*>,
-    messageService: MessageService
-) : AbstractMessageModel? {
-    val apiMessageId = MessageId(messageId).toString()
-    val message = messageService.getMessageModelByApiMessageIdAndReceiver(apiMessageId, receiver)
-
-    if (message == null) {
-        logger.warn("Incoming Edit Message: No message found for id: $apiMessageId")
-        return null
-    }
-    if (editMessage.fromIdentity != message.identity) {
-        logger.warn("Incoming Edit Message: original message's sender ${message.identity} does not equal edited message's sender ${editMessage.fromIdentity}")
-        return null
-    }
-
-    if (!MessageUtil.canEdit(message.type)) {
-        logger.warn("Incoming Edit Message: Message of type {} cannot be edited", message.type)
-        return null
-    }
-
-    message.editedAt = editMessage.date
-
-    return message
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/FSRefreshStepsTask.kt b/app/src/main/java/ch/threema/app/tasks/FSRefreshStepsTask.kt
deleted file mode 100644
index 38ba3e6b..00000000
--- a/app/src/main/java/ch/threema/app/tasks/FSRefreshStepsTask.kt
+++ /dev/null
@@ -1,71 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.ThreemaFeature
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.storage.models.ContactModel
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("FSRefreshStepsTask")
-
-class FSRefreshStepsTask(
-    private val contacts: Set<ContactModel>,
-    serviceManager: ServiceManager,
-) : ActiveTask<Unit>, PersistableTask {
-    private val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
-
-    override val type = "FSRefreshStepsTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        logger.info("Running fs refresh steps")
-
-        contacts.filter { contact ->
-            ThreemaFeature.canForwardSecurity(contact.featureMask).also { hasFsSupport ->
-                if (!hasFsSupport) {
-                    logger.info("Skipping contact {} due to missing fs support", contact.identity)
-                }
-            }
-        }.forEach {
-            logger.info("Refreshing fs session with contact {}", it.identity)
-            forwardSecurityMessageProcessor.runFsRefreshSteps(it, handle)
-        }
-    }
-
-    override fun serialize() = FSRefreshStepsTaskData(contacts.map { it.identity })
-
-    @Serializable
-    class FSRefreshStepsTaskData(
-        private val contactIdentities: Collection<String>,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> {
-            val contactService = serviceManager.contactService
-            val contacts = contactIdentities.mapNotNull { contactService.getByIdentity(it) }.toSet()
-            return FSRefreshStepsTask(contacts, serviceManager)
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/ForwardSecurityStateLogTask.kt b/app/src/main/java/ch/threema/app/tasks/ForwardSecurityStateLogTask.kt
deleted file mode 100644
index a930a20c..00000000
--- a/app/src/main/java/ch/threema/app/tasks/ForwardSecurityStateLogTask.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.services.ContactService
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.storage.models.ContactModel
-
-private val logger = LoggingUtil.getThreemaLogger("ForwardSecurityStateLogTask")
-
-/**
- * This task just logs the forward security state. This needs to be a task, because accessing the
- * forward security state may require to send a terminate.
- */
-class ForwardSecurityStateLogTask(
-    private val contactService: ContactService,
-    private val contactModel: ContactModel,
-) : ActiveTask<Unit> {
-    override val type: String = "ForwardSecurityStateLogTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        val state = contactService.getForwardSecurityState(contactModel, handle)
-
-        logger.info("DH session state with contact {}: {}", contactModel.identity, state)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt b/app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt
deleted file mode 100644
index a7a420b4..00000000
--- a/app/src/main/java/ch/threema/app/tasks/MessageQueueMigrationTask.kt
+++ /dev/null
@@ -1,199 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import android.content.Context
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.services.GroupService
-import ch.threema.app.services.MessageService
-import ch.threema.app.utils.FileUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.NetworkException
-import ch.threema.domain.taskmanager.waitForServerAck
-import ch.threema.localcrypto.MasterKey
-import ch.threema.storage.factories.GroupMessageModelFactory
-import ch.threema.storage.factories.MessageModelFactory
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.MessageState
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.isActive
-import kotlinx.coroutines.withContext
-import kotlinx.coroutines.withTimeout
-import java.io.EOFException
-import java.io.File
-import java.io.FileInputStream
-import java.io.InputStream
-import java.io.ObjectInputStream
-import java.io.ObjectStreamClass
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("MessageQueueMigrationTask")
-
-// TODO(ANDR-2626): Remove this task as soon as the file has been deleted for most users
-/**
- * This task reads the legacy message queue and sends the messages if there are some. Afterwards,
- * the message queue file is deleted.
- */
-class MessageQueueMigrationTask(
-    private val context: Context,
-    private val myIdentity: String?,
-    private val messageService: MessageService,
-    private val groupService: GroupService,
-    private val messageModelFactory: MessageModelFactory,
-    private val groupMessageModelFactory: GroupMessageModelFactory,
-) : ActiveTask<Unit> {
-    private val messageQueueSaveFile = "msgqueue.ser"
-
-    override val type: String = "MessageQueueMigrationTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        val messageQueueFile = File(context.filesDir, messageQueueSaveFile)
-        if (!messageQueueFile.exists()) {
-            logger.debug("No message queue file found")
-            return
-        }
-
-        val masterKey = ThreemaApplication.getMasterKey()
-        if (masterKey == null) {
-            logger.warn("No master key. Deleting the message queue file")
-            FileUtil.deleteFileOrWarn(messageQueueFile, "message queue file", logger)
-            return
-        }
-
-        if (masterKey.isLocked) {
-            logger.warn("Could not restore messages from message queue, as the master key was locked")
-            FileUtil.deleteFileOrWarn(messageQueueFile, "message queue file", logger)
-            return
-        }
-
-        try {
-            // After 30 seconds, we give up (to prevent waiting forever)
-            withTimeout(30000) {
-                sendMessages(masterKey, messageQueueFile, handle)
-            }
-        } catch (e: Exception) {
-            when (e) {
-                is NetworkException -> throw e
-                else -> logger.error("Could not send queued messages", e)
-            }
-        }
-
-        logger.info("Deleting message queue file")
-        FileUtil.deleteFileOrWarn(messageQueueFile, "Remove message queue", logger)
-    }
-
-    private suspend fun sendMessages(masterKey: MasterKey, file: File, handle: ActiveTaskCodec) {
-        withContext(Dispatchers.IO) {
-            return@withContext MessageBoxInputStream(masterKey.getCipherInputStream(FileInputStream(file))).use {
-                val messages = mutableListOf<MessageBox>()
-                while (true) {
-                    if (!coroutineContext.isActive) {
-                        break
-                    }
-
-                    try {
-                        val messageBox = it.readObject() as MessageBox
-
-                        if (myIdentity != messageBox.fromIdentity) {
-                            logger.warn(
-                                "Skipping outgoing message from wrong identity ({}) in queue",
-                                messageBox.fromIdentity
-                            )
-                            continue
-                        }
-
-                        logger.info(
-                            "Sending message {} from message queue file",
-                            messageBox.messageId
-                        )
-
-                        messages.add(messageBox)
-                    } catch (e: Exception) {
-                        when (e) {
-                            is EOFException -> {
-                                logger.info("Finished reading message queue file")
-                                break
-                            }
-                            else -> {
-                                logger.error("Error while reading message from queue file", e)
-                                // Abort as the stream may be corrupt and therefore never succeeds
-                                break
-                            }
-                        }
-                    }
-                }
-                return@use messages
-            }
-        }.forEach { sendMessage(it, handle) }
-    }
-
-    private suspend fun sendMessage(messageBox: MessageBox, handle: ActiveTaskCodec) {
-        // Send message
-        handle.write(messageBox.creatCspMessage())
-
-        val messageId = messageBox.messageId
-        val recipientIdentity = messageBox.toIdentity
-
-        // Wait until message has been sent
-        handle.waitForServerAck(messageId, recipientIdentity)
-
-        // Update state if message model found for message
-        updateMessageModel(messageId, recipientIdentity)
-    }
-
-    private fun updateMessageModel(messageId: MessageId, identity: String) {
-        val date = Date()
-        val messageModels = getMatchingMessageModels(messageId, identity).filterNotNull()
-        // We update the state for each message model that fits the message id and identity. Note
-        // that for group messages, the message state is set to sent too early. Since this is only
-        // needed for the migration to the task manager queue, this is acceptable.
-        messageModels.forEach { messageService.updateMessageState(it, MessageState.SENT, date) }
-    }
-
-    private fun getMatchingMessageModels(
-        messageId: MessageId,
-        identity: String,
-    ): List<AbstractMessageModel?> {
-        return groupService.getGroupsByIdentity(identity).mapNotNull {
-            groupMessageModelFactory.getByApiMessageIdAndGroupId(messageId, it.id)
-        } + messageModelFactory.getByApiMessageIdAndIdentity(messageId, identity)
-    }
-
-}
-
-private class MessageBoxInputStream(input: InputStream) : ObjectInputStream(input) {
-    override fun readClassDescriptor(): ObjectStreamClass {
-        val readClassDescriptor = super.readClassDescriptor()
-        val localClass = Class.forName(readClassDescriptor.name)
-        val localClassDescriptor = ObjectStreamClass.lookup(localClass)
-        if (localClassDescriptor != null && localClassDescriptor.serialVersionUID != readClassDescriptor.serialVersionUID) {
-            // Note that this is dangerous if the MessageBox class changes. However, this is only
-            // migration code and new message boxes won't be deserialized here.
-            return localClassDescriptor
-        }
-        return readClassDescriptor
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt
deleted file mode 100644
index 99725453..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeleteMessageTask.kt
+++ /dev/null
@@ -1,83 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.ThreemaException
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.DeleteMessage
-import ch.threema.domain.protocol.csp.messages.DeleteMessageData
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-import java.util.Date
-
-class OutgoingContactDeleteMessageTask(
-    private val toIdentity: String,
-    private val messageModelId: Int,
-    private val messageId: MessageId,
-    private val deletedAt: Date,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingContactDeleteMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = getContactMessageModel(messageModelId)
-            ?: throw ThreemaException("No contact message model found for messageModelId=$messageModelId")
-
-        val deleteMessage = DeleteMessage(
-            DeleteMessageData(messageId = MessageId.fromString(message.apiMessageId).messageIdLong)
-        )
-        deleteMessage.toIdentity = toIdentity
-        deleteMessage.date = deletedAt
-        deleteMessage.messageId = messageId
-
-        sendContactMessage(deleteMessage, null, handle)
-    }
-
-    override fun serialize(): SerializableTaskData =
-        OutgoingContactDeleteMessageData(
-            toIdentity,
-            messageModelId,
-            messageId.messageId,
-            deletedAt.time
-        )
-
-    @Serializable
-    class OutgoingContactDeleteMessageData(
-        private val toIdentity: String,
-        private val messageModelId: Int,
-        private val messageId: ByteArray,
-        private val deletedAt: Long,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingContactDeleteMessageTask(
-                toIdentity,
-                messageModelId,
-                MessageId(messageId),
-                Date(deletedAt),
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt
deleted file mode 100644
index bb292de2..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactDeliveryReceiptMessageTask.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-import java.util.Date
-
-class OutgoingContactDeliveryReceiptMessageTask(
-    private val receiptType: Int,
-    private val messageIds: Array<MessageId>,
-    private val date: Long,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    override val type: String = "OutgoingContactDeliveryReceiptMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = DeliveryReceiptMessage().also {
-            it.receiptType = receiptType
-            it.receiptMessageIds = messageIds
-            it.toIdentity = toIdentity
-            it.messageId = MessageId()
-            it.date = Date(date)
-        }
-
-        sendContactMessage(message, null, handle)
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingDeliveryReceiptMessageData(
-        receiptType,
-        messageIds.map { it.toString() },
-        date,
-        toIdentity
-    )
-
-    @Serializable
-    data class OutgoingDeliveryReceiptMessageData(
-        private val receiptType: Int,
-        private val messageIds: List<String>,
-        private val date: Long,
-        private val toIdentity: String,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingContactDeliveryReceiptMessageTask(
-                receiptType,
-                messageIds.map { MessageId.fromString(it) }.toTypedArray(),
-                date,
-                toIdentity,
-                serviceManager,
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt
deleted file mode 100644
index 22be17c3..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactEditMessageTask.kt
+++ /dev/null
@@ -1,89 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.ThreemaException
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.EditMessage
-import ch.threema.domain.protocol.csp.messages.EditMessageData
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-import java.util.Date
-
-class OutgoingContactEditMessageTask(
-    private val toIdentity: String,
-    private val messageModelId: Int,
-    private val messageId: MessageId,
-    private val editedText: String,
-    private val editedAt: Date,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingContactEditMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val messageModel = getContactMessageModel(messageModelId)
-                ?: throw ThreemaException("No contact message model found for messageModelId=$messageModelId")
-
-        val editMessage = EditMessage(
-            EditMessageData(
-                messageId = MessageId.fromString(messageModel.apiMessageId).messageIdLong,
-                text = editedText
-            )
-        )
-        editMessage.toIdentity = toIdentity
-        editMessage.date = editedAt
-        editMessage.messageId = messageId
-
-        sendContactMessage(editMessage, null, handle)
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingContactEditMessageData(
-        toIdentity,
-        messageModelId,
-        messageId.messageId,
-        editedText,
-        editedAt.time
-    )
-
-    @Serializable
-    class OutgoingContactEditMessageData(
-        private val toIdentity: String,
-        private val messageModelId: Int,
-        private val messageId: ByteArray,
-        private val editedText: String,
-        private val editedAt: Long
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingContactEditMessageTask(
-                toIdentity,
-                messageModelId,
-                MessageId(messageId),
-                editedText,
-                Date(editedAt),
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt
deleted file mode 100644
index ab7b0ba8..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingContactRequestProfilePictureTask.kt
+++ /dev/null
@@ -1,80 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingContactRequestProfilePictureTask")
-
-/**
- * Sends a request-profile-picture message to the given contact. Note that it is only sent, if the
- * contact has been restored. After sending the profile picture request, the restored flag is
- * cleared from the contact.
- */
-class OutgoingContactRequestProfilePictureTask(
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingProfilePictureTask(serviceManager) {
-
-    override val type = "OutgoingContactRequestProfilePictureTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        // Get contact and check that sending a profile picture request is necessary
-        val contact = contactService.getByIdentity(toIdentity)
-        if (contact == null) {
-            logger.warn(
-                "Contact {} is unknown, even though a profile picture request should be sent",
-                toIdentity
-            )
-            return
-        }
-
-        if (!contact.isRestored) {
-            logger.warn(
-                "Contact {} is not restored; sending profile picture request is skipped",
-                toIdentity
-            )
-            return
-        }
-
-        // Send the profile picture request message
-        sendRequestProfilePictureMessage(toIdentity, handle)
-
-        contact.setIsRestored(false)
-        contactService.save(contact)
-    }
-
-    override fun serialize() = OutgoingContactRequestProfilePictureData(toIdentity)
-
-    @Serializable
-    data class OutgoingContactRequestProfilePictureData(
-        private val toIdentity: String,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingContactRequestProfilePictureTask(toIdentity, serviceManager)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt
deleted file mode 100644
index 707fb7a1..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingCspGroupControlMessageTask.kt
+++ /dev/null
@@ -1,81 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.filterValid
-import ch.threema.app.utils.sendMessageToReceivers
-import ch.threema.app.utils.toKnownContactModels
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import java.util.Date
-
-abstract class OutgoingCspGroupControlMessageTask(serviceManager: ServiceManager) :
-    OutgoingCspMessageTask(serviceManager) {
-    private val taskCreator by lazy { serviceManager.taskCreator }
-    private val blockedContactsService by lazy { serviceManager.blockedContactsService }
-
-    protected abstract val messageId: MessageId
-    protected abstract val creatorIdentity: String
-    protected abstract val groupId: GroupId
-    protected abstract val recipientIdentities: Set<String>
-    protected open val date: Date = Date()
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val recipients = recipientIdentities
-            .toSet()
-            .toKnownContactModels(contactService)
-            .filterValid()
-            .toSet()
-
-        val messageCreator = OutgoingCspGroupMessageCreator(
-            messageId,
-            groupId,
-            creatorIdentity
-        ) { createGroupMessage() }
-
-        // Note that the given recipients may no longer be part of the group. Therefore we must use
-        // sendMessageToReceivers instead of sendGroupMessage.
-        handle.sendMessageToReceivers(
-            messageCreator,
-            recipients,
-            forwardSecurityMessageProcessor,
-            identityStore,
-            contactStore,
-            nonceFactory,
-            blockedContactsService,
-            taskCreator
-        )
-    }
-
-    /**
-     * Get the group message that will be sent. Note that this message must contain all the message
-     * specific information. The message id, group id, creator identity, to identity, and the date
-     * will be added before sending the message.
-     *
-     * Every invocation of this method must create a new instance of the message.
-     */
-    abstract fun createGroupMessage(): AbstractGroupMessage
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt
deleted file mode 100644
index 4167f6d5..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingCspMessageTask.kt
+++ /dev/null
@@ -1,364 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.listeners.MessageListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.messagereceiver.MessageReceiver.MessageReceiverType
-import ch.threema.app.messagereceiver.MessageReceiver
-import ch.threema.app.utils.OutgoingCspContactMessageCreator
-import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.filterBroadcastIdentity
-import ch.threema.app.utils.filterValid
-import ch.threema.app.utils.sendContactMessage
-import ch.threema.app.utils.sendGroupMessage
-import ch.threema.app.utils.toKnownContactModels
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.Utils
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.fs.BadDHStateException
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.NetworkException
-import ch.threema.domain.taskmanager.catchAllExceptNetworkException
-import ch.threema.domain.taskmanager.catchExceptNetworkException
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.GroupMessageModel
-import ch.threema.storage.models.GroupModel
-import ch.threema.storage.models.MessageModel
-import ch.threema.storage.models.MessageState
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingCspMessageTask")
-
-sealed class OutgoingCspMessageTask(serviceManager: ServiceManager) :
-    ActiveTask<Unit>, PersistableTask {
-    private val myIdentity by lazy { serviceManager.userService.identity }
-    protected val contactService by lazy { serviceManager.contactService }
-    protected val groupService by lazy { serviceManager.groupService }
-    protected val contactStore by lazy { serviceManager.contactStore }
-    protected val identityStore by lazy { serviceManager.identityStore }
-    protected val nonceFactory by lazy { serviceManager.nonceFactory }
-    protected val forwardSecurityMessageProcessor by lazy { serviceManager.forwardSecurityMessageProcessor }
-    protected val messageService by lazy { serviceManager.messageService }
-    private val rejectedGroupMessageFactory by lazy { serviceManager.databaseServiceNew.rejectedGroupMessageFactory }
-
-    // It is important that the task creator is loaded lazily, as the task archiver may instantiate
-    // this class before the connection is initialized (which is used for the task creator).
-    private val taskCreator by lazy { serviceManager.taskCreator }
-    private val blockedContactsService by lazy { serviceManager.blockedContactsService }
-
-    final override suspend fun invoke(handle: ActiveTaskCodec) {
-        suspend {
-            runSendingSteps(handle)
-        }.catchAllExceptNetworkException { exception ->
-            onSendingStepsFailed(exception)
-            throw exception
-        }
-    }
-
-    /**
-     * Run the steps that need to be performed to send the message(s). If this throws an exception
-     * that is not an [NetworkException], [onSendingStepsFailed] is called.
-     */
-    abstract suspend fun runSendingSteps(handle: ActiveTaskCodec)
-
-    /**
-     * This method is called if the sending steps have thrown an exception.
-     *
-     * Note that this method won't be called if the thrown exception is a [NetworkException].
-     *
-     * Note that the task will be finished and [runSendingSteps] must not be executed again to
-     * prevent infinite retries. The task will exit by throwing [e]. This exception will then be
-     * handled by the task manager that may re-run this task.
-     */
-    open fun onSendingStepsFailed(e: Exception) {
-        // Nothing to do here
-    }
-
-    /**
-     * Encapsulate and send the given message. Note that the message must be ready to be sent. This
-     * includes having the correct flags, from and to identities as well as a message id. If there
-     * is a message model to this message, it should also be passed to this method, so that it gets
-     * updated.
-     *
-     * Note that there must exists a contact model of the receiver. Otherwise, the message cannot be
-     * sent. In this case the message model state is set to [MessageState.SENDFAILED] (if provided)
-     * and an [IllegalStateException] is thrown.
-     */
-    suspend fun sendContactMessage(
-        message: AbstractMessage,
-        messageModel: MessageModel?,
-        handle: ActiveTaskCodec,
-    ) {
-        val recipient = contactService.getByIdentity(message.toIdentity)
-        if (recipient == null) {
-            logger.error(
-                "Could not send message to {} as the contact model is null",
-                message.toIdentity
-            )
-            messageModel?.let {
-                messageService.updateMessageState(
-                    it,
-                    MessageState.SENDFAILED,
-                    Date()
-                )
-            }
-            throw IllegalStateException("Could not send message as the receiver model is unknown")
-        }
-
-        message.date = messageModel?.createdAt ?: message.date
-
-        val sentMessageContainer = suspend {
-            handle.sendContactMessage(
-                OutgoingCspContactMessageCreator(message.messageId) { message },
-                recipient,
-                forwardSecurityMessageProcessor,
-                identityStore,
-                contactStore,
-                nonceFactory,
-                blockedContactsService,
-                taskCreator
-            )
-        }.catchExceptNetworkException { e: BadDHStateException ->
-            if (messageModel != null) {
-                messageService.updateMessageState(messageModel, MessageState.SENDFAILED, Date())
-            }
-            throw e
-        }
-
-        if (messageModel != null) {
-            if (sentMessageContainer != null) {
-                // Update the message state for the outgoing message
-                val sentDate = Date(sentMessageContainer.sentTimestamp.toLong())
-                messageService.updateMessageState(messageModel, MessageState.SENT, sentDate)
-
-                // Set forward security mode
-                messageModel.forwardSecurityMode = sentMessageContainer.forwardSecurityMode
-            } else {
-                // In this case the message was not sent because the recipient is blocked. This
-                // should never happen as sending a message that corresponds to a message model
-                // should be prevented by the UI. If the user sends a message and then blocks the
-                // recipient, the message may end in this state if the message could not be sent in
-                // the meanwhile.
-                messageService.updateMessageState(messageModel, MessageState.SENDFAILED, Date())
-            }
-
-            // Save the updated message model
-            messageService.save(messageModel)
-        }
-    }
-
-    /**
-     * Send the group message to the recipients following the _Common Send Steps_. The message is
-     * only sent to those recipients that are still part of the group.
-     *
-     * Note that the message is only sent to valid members and if the member is not blocked (except
-     * the message should be exempted from blocking). If there is no contact model for a member, the
-     * message will not be sent to this member.
-     */
-    suspend fun sendGroupMessage(
-        group: GroupModel,
-        recipients: Collection<String>,
-        messageModel: GroupMessageModel?,
-        messageId: MessageId,
-        createAbstractMessage: () -> AbstractGroupMessage,
-        handle: ActiveTaskCodec,
-    ) {
-        if (!groupService.isGroupMember(group)) {
-            logger.warn("The user is no member of the group and the message is therefore not sent")
-            return
-        }
-
-        // Get the known contacts
-        val finalRecipients = recipients
-            .toKnownContactModels(contactService)
-            .filterValid()
-            .filterBroadcastIdentity(group)
-            .toSet()
-
-        // Create and send the messages for all recipients
-        val sentMessageContainers = suspend {
-            handle.sendGroupMessage(
-                OutgoingCspGroupMessageCreator(messageId, group) { createAbstractMessage() },
-                finalRecipients,
-                group,
-                forwardSecurityMessageProcessor,
-                identityStore,
-                contactStore,
-                nonceFactory,
-                groupService,
-                blockedContactsService,
-                taskCreator
-            )
-        }.catchExceptNetworkException { e: BadDHStateException ->
-            if (messageModel != null) {
-                messageService.updateMessageState(messageModel, MessageState.SENDFAILED, Date())
-            }
-            throw e
-        }
-
-        if (sentMessageContainers == null) {
-            // If the message has not been sent (sentMessageContainers is null), then update the
-            // message state (if available) and return. Note that this only happens, if the user is
-            // not a member of the group.
-            if (messageModel != null) {
-                // Note that this should be prevented by the UI, but may happen with some bad timing
-                messageModel.state = MessageState.SENDFAILED
-                messageService.save(messageModel)
-            }
-
-            return
-        }
-
-        sentMessageContainers.map { it.recipient.identity }.forEach {
-            rejectedGroupMessageFactory.removeMessageReject(messageId, it, group)
-        }
-
-        // Update the message state as all messages have been sent now
-        if (messageModel != null) {
-            // If there is no recipient (notes group), then we set the message state directly to
-            // read, otherwise sent. If there are (still) some rejected identities, we set the state
-            // to fs key mismatch, so that the message can be sent again to those. Note that we use
-            // the fs key mismatch state to represent the 're-send requested'-mark.
-            val state = when {
-                recipients.isEmpty() -> MessageState.READ
-
-                rejectedGroupMessageFactory.getMessageRejects(messageId, group)
-                    .isNotEmpty() -> MessageState.FS_KEY_MISMATCH
-
-                else -> MessageState.SENT
-            }
-            messageModel.state = state
-
-            // Update sent timestamp
-            val sentDate = if (sentMessageContainers.isNotEmpty()) {
-                // The message has been sent to at least someone
-                Date(sentMessageContainers.first().sentTimestamp.toLong())
-            } else {
-                // The message wasn't sent to anybody. This can happen in notes groups.
-                // TODO(ANDR-2705): When reflecting a message in a notes group, we should still be
-                // able to get the timestamp (when it has been reflected)
-                Date()
-            }
-            messageModel.postedAt = sentDate
-            messageModel.modifiedAt = sentDate
-
-            // Update forward security mode
-            val forwardSecurityMode =
-                when (sentMessageContainers.count { it.forwardSecurityMode != ForwardSecurityMode.NONE }) {
-                    0 -> ForwardSecurityMode.NONE
-                    sentMessageContainers.size -> ForwardSecurityMode.ALL
-                    else -> ForwardSecurityMode.PARTIAL
-                }
-            if (messageModel.forwardSecurityMode == null) {
-                // If the forward security mode is null, it is the first time we send this message.
-                // Therefore we can set the mode directly to the current mode.
-                messageModel.forwardSecurityMode = forwardSecurityMode
-            } else {
-                // If the previous forward security mode is already set, this means this has been a
-                // resend of the message that only reached a subset of the group members. Therefore
-                // we follow a best effort downgrade procedure:
-                if (forwardSecurityMode == ForwardSecurityMode.PARTIAL || forwardSecurityMode == ForwardSecurityMode.NONE) {
-                    // If there is a re-sent message without forward security, we set the mode to
-                    // partial, as some may have received the message with forward security in an
-                    // earlier attempt.
-                    messageModel.forwardSecurityMode = ForwardSecurityMode.PARTIAL
-                }
-            }
-
-            messageService.save(messageModel)
-
-            // Trigger listener TODO(ANDR-2705): Check updated version of MessageService#updateMessageState
-            ListenerManager.messageListeners.handle { listener: MessageListener ->
-                listener.onModified(listOf(messageModel))
-            }
-        }
-
-        groupService.setIsArchived(group, false)
-    }
-
-    /**
-     * Returns the message id of the message model.
-     *
-     * @throws IllegalArgumentException if the message id of the message model is null
-     */
-    protected fun ensureMessageId(messageModel: AbstractMessageModel): MessageId {
-        messageModel.apiMessageId?.let {
-            return MessageId(Utils.hexStringToByteArray(it))
-        }
-
-        throw IllegalArgumentException("Message id of message model is null")
-    }
-
-    /**
-     * Get the message model with the given local database message model id.
-     *
-     * @throws IllegalArgumentException if receiver type is not [MessageReceiver.Type_CONTACT] or
-     * [MessageReceiver.Type_GROUP]
-     */
-    protected fun getMessageModel(
-        @MessageReceiverType receiverType: Int,
-        messageModelId: Int
-    ): AbstractMessageModel? {
-        return when (receiverType) {
-            MessageReceiver.Type_CONTACT -> getContactMessageModel(messageModelId)
-            MessageReceiver.Type_GROUP -> getGroupMessageModel(messageModelId)
-            else -> throw IllegalArgumentException("Invalid receiver type: $receiverType")
-        }
-    }
-
-    /**
-     * Get the contact message model with the given local database message model id.
-     */
-    protected fun getContactMessageModel(messageModelId: Int): MessageModel? {
-        val messageModel = messageService.getContactMessageModel(messageModelId)
-        if (messageModel == null) {
-            logger.warn("Could not find contact message model with id {}", messageModelId)
-        }
-        return messageModel
-    }
-
-    /**
-     * Get the group message model with the given local database message model id.
-     */
-    protected fun getGroupMessageModel(messageModelId: Int): GroupMessageModel? {
-        val messageModel = messageService.getGroupMessageModel(messageModelId)
-        if (messageModel == null) {
-            logger.warn("Could not find group message model with id {}", messageModelId)
-        }
-        return messageModel
-    }
-
-    /**
-     * Set the message model state to [MessageState.SENDFAILED] and save the model to the database.
-     */
-    protected fun AbstractMessageModel.saveWithStateFailed() {
-        logger.info("Setting message state of model with message id {} to failed", apiMessageId)
-        state = MessageState.SENDFAILED
-        messageService.save(this)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingD2mMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingD2mMessageTask.kt
deleted file mode 100644
index 9049ccff..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingD2mMessageTask.kt
+++ /dev/null
@@ -1,54 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.protocol.connection.data.DeviceId
-import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-sealed class OutgoingD2mMessageTask : ActiveTask<Unit>, PersistableTask {
-    protected suspend fun sendD2mMessage(message: OutboundD2mMessage, handle: ActiveTaskCodec) {
-        handle.write(message)
-    }
-}
-
-class OutgoingDropDeviceTask(private val deviceId: DeviceId) : OutgoingD2mMessageTask() {
-    override val type: String = "OutgoingDropDeviceTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        sendD2mMessage(OutboundD2mMessage.DropDevice(deviceId), handle)
-    }
-
-    override fun serialize(): SerializableTaskData =
-        OutgoingDropDeviceData(deviceId.id)
-
-    @Serializable
-    data class OutgoingDropDeviceData(private val deviceId: ULong) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingDropDeviceTask(DeviceId(deviceId))
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt
deleted file mode 100644
index 9bd86a61..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingFileMessageTask.kt
+++ /dev/null
@@ -1,157 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.messagereceiver.MessageReceiver
-import ch.threema.app.messagereceiver.MessageReceiver.MessageReceiverType
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.file.FileData
-import ch.threema.domain.protocol.csp.messages.file.FileMessage
-import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.data.media.FileDataModel
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingFileMessageTask")
-
-class OutgoingFileMessageTask(
-    private val messageModelId: Int,
-    @MessageReceiverType
-    private val receiverType: Int,
-    private val recipientIdentities: Set<String>,
-    private val thumbnailBlobId: ByteArray?,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingFileMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        when (receiverType) {
-            MessageReceiver.Type_CONTACT -> sendContactMessage(handle)
-            MessageReceiver.Type_GROUP -> sendGroupMessage(handle)
-            else -> throw IllegalStateException("Invalid message receiver type $receiverType")
-        }
-    }
-
-    override fun onSendingStepsFailed(e: Exception) {
-        getMessageModel(receiverType, messageModelId)?.saveWithStateFailed()
-    }
-
-    private suspend fun sendContactMessage(handle: ActiveTaskCodec) {
-        val messageModel = getContactMessageModel(messageModelId) ?: return
-
-        val fileDataModel = messageModel.fileData
-
-        // Create the message
-        val message = FileMessage().apply {
-            data = fileDataModel.toFileData(thumbnailBlobId, messageModel)
-            toIdentity = messageModel.identity
-            messageId = ensureMessageId(messageModel)
-        }
-
-        sendContactMessage(message, messageModel, handle)
-    }
-
-    private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
-        val messageModel = getGroupMessageModel(messageModelId) ?: return
-
-        val group = groupService.getById(messageModel.groupId)
-            ?: throw IllegalStateException("Could not get group for message model ${messageModel.apiMessageId}")
-
-        val fileDataModel = messageModel.fileData
-
-        sendGroupMessage(
-            group,
-            recipientIdentities,
-            messageModel,
-            ensureMessageId(messageModel),
-            {
-                GroupFileMessage().apply {
-                    data = fileDataModel.toFileData(thumbnailBlobId, messageModel)
-                }
-            },
-            handle
-        )
-    }
-
-    private fun FileDataModel.toFileData(
-        thumbnailBlobId: ByteArray?,
-        messageModel: AbstractMessageModel,
-    ): FileData {
-
-        // Validate that the blob id has the correct length
-        if (blobId == null || blobId.size != ProtocolDefines.BLOB_ID_LEN) {
-            logger.error("Invalid blob id of length {}", blobId?.size)
-            throw IllegalStateException("Invalid blob id")
-        }
-
-        // Validate that the encryption key has the correct length
-        if (encryptionKey == null || encryptionKey.size != ProtocolDefines.BLOB_KEY_LEN) {
-            logger.error("Invalid encryption key of length {}", encryptionKey?.size)
-            throw IllegalStateException("Invalid blob encryption key")
-        }
-
-        return FileData().also {
-            it.fileBlobId = blobId
-            it.thumbnailBlobId = thumbnailBlobId
-            it.encryptionKey = encryptionKey
-            it.mimeType = mimeType
-            it.thumbnailMimeType = thumbnailMimeType
-            it.fileSize = fileSize
-            it.fileName = fileName
-            it.renderingType = renderingType
-            it.caption = caption
-            it.correlationId = messageModel.correlationId
-            it.metaData = metaData
-        }
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingFileMessageData(
-        messageModelId,
-        receiverType,
-        recipientIdentities,
-        thumbnailBlobId,
-    )
-
-    @Serializable
-    class OutgoingFileMessageData(
-        private val messageModelId: Int,
-        @MessageReceiverType
-        private val receiverType: Int,
-        private val recipientIdentities: Set<String>,
-        private val thumbnailBlobId: ByteArray?,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingFileMessageTask(
-                messageModelId,
-                receiverType,
-                recipientIdentities,
-                thumbnailBlobId,
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupCallStartTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupCallStartTask.kt
deleted file mode 100644
index 80d5a50f..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupCallStartTask.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartData
-import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import java.util.Date
-
-class OutgoingGroupCallStartTask(
-    override val groupId: GroupId,
-    override val creatorIdentity: String,
-    override val recipientIdentities: Set<String>,
-    private val protocolVersion: UInt,
-    private val gck: ByteArray,
-    private val sfuBaseUrl: String,
-    createdAt: Date,
-    serviceManager: ServiceManager,
-) : OutgoingCspGroupControlMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingGroupCallStartTask"
-
-    override val messageId = MessageId()
-
-    override val date = createdAt
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        super.runSendingSteps(handle)
-
-        groupService.getByApiGroupIdAndCreator(groupId, creatorIdentity)?.let {
-            groupService.bumpLastUpdate(it)
-        }
-    }
-
-    override fun createGroupMessage() = GroupCallStartMessage(GroupCallStartData(protocolVersion, gck, sfuBaseUrl))
-
-    override fun serialize(): SerializableTaskData? = null
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt
deleted file mode 100644
index ed7adea4..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteMessageTask.kt
+++ /dev/null
@@ -1,98 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.ThreemaException
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.DeleteMessageData
-import ch.threema.domain.protocol.csp.messages.GroupDeleteMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-import java.util.Date
-
-class OutgoingGroupDeleteMessageTask(
-    private val messageModelId: Int,
-    private val messageId: MessageId,
-    private val deletedAt: Date,
-    private val recipientIdentities: Set<String>,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingGroupDeleteMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = getGroupMessageModel(messageModelId)
-            ?: throw ThreemaException("No group message model found for messageModelId=$messageModelId")
-
-        val editedMessageIdLong = MessageId.fromString(message.apiMessageId).messageIdLong
-
-        val group = groupService.getById(message.groupId)
-            ?: throw ThreemaException("No group model found for groupId=${message.groupId}")
-
-        sendGroupMessage(
-            group,
-            recipientIdentities,
-            null,
-            messageId,
-            createAbstractMessage =  { createDeleteMessage(
-                editedMessageIdLong,
-                deletedAt
-            ) },
-            handle
-        )
-    }
-
-    private fun createDeleteMessage(messageId: Long, date: Date) : GroupDeleteMessage {
-        val deleteMessage = GroupDeleteMessage(
-            DeleteMessageData(messageId = messageId)
-        )
-        deleteMessage.date = date
-        return deleteMessage
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupDeleteMessageData(
-        messageModelId,
-        messageId.messageId,
-        deletedAt.time,
-        recipientIdentities
-    )
-
-    @Serializable
-    class OutgoingGroupDeleteMessageData(
-        private val messageModelId: Int,
-        private val messageId: ByteArray,
-        private val deletedAt: Long,
-        private val recipientIdentities: Set<String>
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupDeleteMessageTask(
-                messageModelId,
-                MessageId(messageId),
-                Date(deletedAt),
-                recipientIdentities,
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteProfilePictureTask.kt
deleted file mode 100644
index 32cbf75e..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeleteProfilePictureTask.kt
+++ /dev/null
@@ -1,66 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupDeleteProfilePictureMessage
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-class OutgoingGroupDeleteProfilePictureTask(
-    override val groupId: GroupId,
-    override val creatorIdentity: String,
-    override val recipientIdentities: Set<String>,
-    messageId: MessageId?,
-    serviceManager: ServiceManager,
-) : OutgoingCspGroupControlMessageTask(serviceManager) {
-    override val type: String = "OutgoingGroupDeleteProfilePictureTask"
-
-    override val messageId = messageId ?: MessageId()
-
-    override fun createGroupMessage() = GroupDeleteProfilePictureMessage()
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupDeleteProfilePictureData(
-        groupId.groupId, creatorIdentity, recipientIdentities, messageId.messageId
-    )
-
-    @Serializable
-    class OutgoingGroupDeleteProfilePictureData(
-        private val groupId: ByteArray,
-        private val creatorIdentity: String,
-        private val receiverIdentities: Set<String>,
-        private val messageId: ByteArray,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupDeleteProfilePictureTask(
-                GroupId(groupId),
-                creatorIdentity,
-                receiverIdentities,
-                MessageId(messageId),
-                serviceManager,
-            )
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt
deleted file mode 100644
index 6ca6f83a..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupDeliveryReceiptMessageTask.kt
+++ /dev/null
@@ -1,90 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupDeliveryReceiptMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingGroupDeliverReceiptMessageTask")
-
-class OutgoingGroupDeliveryReceiptMessageTask(
-    private val messageModelId: Int,
-    private val receiptType: Int,
-    private val recipientIdentities: Set<String>,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingGroupDeliveryReceiptMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val messageModel = getGroupMessageModel(messageModelId)
-        if (messageModel == null) {
-            logger.warn("Message model ($messageModelId) is null while trying to send group delivery receipt")
-            return
-        }
-        val group = groupService.getById(messageModel.groupId)
-        if (group == null) {
-            logger.warn("Group (${messageModel.groupId}) is null while trying to send group delivery receipt")
-            return
-        }
-
-        val messageId = MessageId()
-
-        sendGroupMessage(
-            group,
-            recipientIdentities,
-            null,
-            messageId,
-            {
-                GroupDeliveryReceiptMessage().also {
-                    it.receiptType = receiptType
-                    it.receiptMessageIds = arrayOf(MessageId.fromString(messageModel.apiMessageId))
-                }
-            },
-            handle
-        )
-    }
-
-    override fun serialize(): SerializableTaskData =
-        OutgoingGroupDeliveryReceiptMessageData(messageModelId, receiptType, recipientIdentities)
-
-    @Serializable
-    class OutgoingGroupDeliveryReceiptMessageData(
-        private val messageModelId: Int,
-        private val receiptType: Int,
-        private val recipientIdentities: Set<String>,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupDeliveryReceiptMessageTask(
-                messageModelId,
-                receiptType,
-                recipientIdentities,
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt
deleted file mode 100644
index 5f07a1bf..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupEditMessageTask.kt
+++ /dev/null
@@ -1,102 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.ThreemaException
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.EditMessageData
-import ch.threema.domain.protocol.csp.messages.GroupEditMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-import java.util.Date
-
-class OutgoingGroupEditMessageTask(
-    private val messageModelId: Int,
-    private val messageId: MessageId,
-    private val editedText: String,
-    private val editedAt: Date,
-    private val recipientIdentities: Set<String>,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingGroupEditMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = getGroupMessageModel(messageModelId)
-                ?: throw ThreemaException("No group message model found for messageModelId=$messageModelId")
-
-        val group = groupService.getById(message.groupId)
-            ?: throw ThreemaException("No group model found for groupId=${message.groupId}")
-
-        val editedMessageId = MessageId.fromString(message.apiMessageId).messageIdLong
-
-        sendGroupMessage(
-                group,
-                groupService.getGroupIdentities(group).toSet(),
-                null,
-                messageId,
-                createAbstractMessage =  { createEditMessage(editedMessageId, editedAt) },
-                handle
-        )
-    }
-
-    private fun createEditMessage(messageId: Long, date: Date): GroupEditMessage {
-        val editMessage = GroupEditMessage(
-            EditMessageData(
-                messageId = messageId,
-                text = editedText
-            )
-        )
-        editMessage.date = date
-        return editMessage
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupEditMessageData(
-        messageModelId,
-        messageId.messageId,
-        editedText,
-        editedAt.time,
-        recipientIdentities
-    )
-
-    @Serializable
-    class OutgoingGroupEditMessageData(
-        private val messageModelId: Int,
-        private val messageId: ByteArray,
-        private val editedText: String,
-        private val editedAt: Long,
-        private val recipientIdentities: Set<String>
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupEditMessageTask(
-                messageModelId,
-                MessageId(messageId),
-                editedText,
-                Date(editedAt),
-                recipientIdentities,
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupLeaveTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupLeaveTask.kt
deleted file mode 100644
index 27324b8c..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupLeaveTask.kt
+++ /dev/null
@@ -1,66 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-class OutgoingGroupLeaveTask(
-    override val groupId: GroupId,
-    override val creatorIdentity: String,
-    override val recipientIdentities: Set<String>,
-    messageId: MessageId?,
-    serviceManager: ServiceManager,
-) : OutgoingCspGroupControlMessageTask(serviceManager) {
-    override val type: String = "OutgoingGroupLeaveTask"
-
-    override val messageId = messageId ?: MessageId()
-
-    override fun createGroupMessage() = GroupLeaveMessage()
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupLeaveData(
-        groupId.groupId, creatorIdentity, recipientIdentities, messageId.messageId
-    )
-
-    @Serializable
-    class OutgoingGroupLeaveData(
-        private val groupId: ByteArray,
-        private val creatorIdentity: String,
-        private val receiverIdentities: Set<String>,
-        private val messageId: ByteArray,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupLeaveTask(
-                GroupId(groupId),
-                creatorIdentity,
-                receiverIdentities,
-                MessageId(messageId),
-                serviceManager,
-            )
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupNameTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupNameTask.kt
deleted file mode 100644
index ed976f77..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupNameTask.kt
+++ /dev/null
@@ -1,72 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupNameMessage
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-class OutgoingGroupNameTask(
-    override val groupId: GroupId,
-    override val creatorIdentity: String,
-    private val groupName: String,
-    override val recipientIdentities: Set<String>,
-    messageId: MessageId?,
-    serviceManager: ServiceManager,
-) : OutgoingCspGroupControlMessageTask(serviceManager) {
-    override val type: String = "OutgoingGroupNameTask"
-
-    override val messageId = messageId ?: MessageId()
-
-    override fun createGroupMessage() = GroupNameMessage().also { it.groupName = groupName }
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupNameData(
-        groupId.groupId,
-        creatorIdentity,
-        groupName,
-        recipientIdentities,
-        messageId.messageId
-    )
-
-    @Serializable
-    class OutgoingGroupNameData(
-        private val groupId: ByteArray,
-        private val creatorIdentity: String,
-        private val groupName: String,
-        private val receiverIdentities: Set<String>,
-        private val messageId: ByteArray,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupNameTask(
-                GroupId(groupId),
-                creatorIdentity,
-                groupName,
-                receiverIdentities,
-                MessageId(messageId),
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt
deleted file mode 100644
index eeed8530..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupProfilePictureTask.kt
+++ /dev/null
@@ -1,122 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import android.graphics.Bitmap
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingGroupProfilePictureTask")
-
-/**
- * This task sends a set-profile-picture message to the group if there is a group picture. If no
- * group picture is set for the given group, an [OutgoingGroupDeleteProfilePictureTask] is started
- * directly. Note that the messages are only sent to the given [receiverIdentities].
- */
-class OutgoingGroupProfilePictureTask(
-    private val groupId: GroupId,
-    private val creatorIdentity: String,
-    receiverIdentities: Set<String>,
-    messageId: MessageId?,
-    private val serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    private val messageId by lazy { messageId ?: MessageId() }
-    private val userService by lazy { serviceManager.userService }
-    private val receiverIdentities by lazy { receiverIdentities - userService.identity }
-    private val fileService by lazy { serviceManager.fileService }
-
-    override val type: String = "OutgoingGroupProfilePictureTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        if (creatorIdentity != userService.identity) {
-            logger.warn("Only the group creator should send the group picture to the members")
-            return
-        }
-
-        val group = groupService.getByApiGroupIdAndCreator(groupId, creatorIdentity)
-        if (group == null) {
-            logger.error(
-                "Could not find group {} with creator {} to send the profile picture",
-                groupId,
-                creatorIdentity
-            )
-            return
-        }
-
-        if (fileService.hasGroupAvatarFile(group)) {
-            sendGroupPhoto(fileService.getGroupAvatar(group), handle)
-        } else {
-            sendGroupDeletePhoto(handle)
-        }
-    }
-
-    private suspend fun sendGroupPhoto(groupPhoto: Bitmap, handle: ActiveTaskCodec) {
-        OutgoingGroupSetProfilePictureTask(
-            groupId,
-            creatorIdentity,
-            receiverIdentities,
-            groupPhoto,
-            null,
-            serviceManager
-        ).invoke(handle)
-    }
-
-    private suspend fun sendGroupDeletePhoto(handle: ActiveTaskCodec) {
-        OutgoingGroupDeleteProfilePictureTask(
-            groupId,
-            creatorIdentity,
-            receiverIdentities,
-            null,
-            serviceManager
-        ).invoke(handle)
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupProfilePictureData(
-        groupId.groupId,
-        creatorIdentity,
-        receiverIdentities,
-        messageId.messageId
-    )
-
-    @Serializable
-    class OutgoingGroupProfilePictureData(
-        private val groupId: ByteArray,
-        private val creatorIdentity: String,
-        private val receiverIdentities: Set<String>,
-        private val messageId: ByteArray,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupProfilePictureTask(
-                GroupId(groupId),
-                creatorIdentity,
-                receiverIdentities,
-                MessageId(messageId),
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt
deleted file mode 100644
index a4b51f13..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetProfilePictureTask.kt
+++ /dev/null
@@ -1,128 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import android.graphics.Bitmap
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.utils.BitmapUtil
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetProfilePictureMessage
-import com.neilalexander.jnacl.NaCl
-import java.io.FileNotFoundException
-import java.security.SecureRandom
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingGroupSetProfilePictureTask")
-
-class OutgoingGroupSetProfilePictureTask(
-    override val groupId: GroupId,
-    override val creatorIdentity: String,
-    override val recipientIdentities: Set<String>,
-    private val groupPhoto: Bitmap,
-    messageId: MessageId?,
-    serviceManager: ServiceManager,
-): OutgoingCspGroupControlMessageTask(serviceManager) {
-    private val apiService by lazy { serviceManager.apiService }
-    private val groupPhotoUploadResult by lazy { tryUploadingGroupPhoto(groupPhoto) }
-
-    override val type = "OutgoingGroupSetProfilePictureTask"
-
-    override val messageId = messageId ?: MessageId()
-
-    override fun createGroupMessage(): AbstractGroupMessage {
-        val (blobId, encryptionKey, size) = groupPhotoUploadResult
-
-        return GroupSetProfilePictureMessage()
-            .also {
-                it.blobId = blobId
-                it.encryptionKey = encryptionKey
-                it.size = size
-            }
-    }
-
-    override fun serialize() = null
-
-    private fun tryUploadingGroupPhoto(picture: Bitmap): GroupPhotoUploadResult = try {
-        // Upload group photo
-        uploadGroupPhoto(picture)
-    } catch (e: FileNotFoundException) {
-        // On onprem builds this exception may occur if the auth token is not valid anymore.
-        // Therefore, we invalidate the auth token and retry it once more.
-        if (ConfigUtils.isOnPremBuild()) {
-            logger.info("Invalidating auth token")
-            apiService.invalidateAuthToken()
-            logger.info("Retrying upload")
-            uploadGroupPhoto(picture)
-        } else {
-            throw e
-        }
-    }
-
-    private fun uploadGroupPhoto(picture: Bitmap): GroupPhotoUploadResult {
-        val rnd = SecureRandom()
-        val encryptionKey = ByteArray(NaCl.SYMMKEYBYTES)
-        rnd.nextBytes(encryptionKey)
-
-        val bitmapArray = BitmapUtil.bitmapToJpegByteArray(picture)
-        val encryptedData = NaCl.symmetricEncryptData(
-            bitmapArray,
-            encryptionKey,
-            ProtocolDefines.GROUP_PHOTO_NONCE
-        )
-        val blobUploader = apiService.createUploader(encryptedData)
-        val blobId = blobUploader.upload()
-        val size = encryptedData.size
-
-        return GroupPhotoUploadResult(blobId, encryptionKey, size)
-    }
-
-    private data class GroupPhotoUploadResult(
-        val blobId: ByteArray,
-        val encryptionKey: ByteArray,
-        val size: Int,
-    ) {
-        override fun equals(other: Any?): Boolean {
-            if (this === other) return true
-            if (javaClass != other?.javaClass) return false
-
-            other as GroupPhotoUploadResult
-
-            if (!blobId.contentEquals(other.blobId)) return false
-            if (!encryptionKey.contentEquals(other.encryptionKey)) return false
-            if (size != other.size) return false
-
-            return true
-        }
-
-        override fun hashCode(): Int {
-            var result = blobId.contentHashCode()
-            result = 31 * result + encryptionKey.contentHashCode()
-            result = 31 * result + size
-            return result
-        }
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetupTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetupTask.kt
deleted file mode 100644
index e4247b3d..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSetupTask.kt
+++ /dev/null
@@ -1,75 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-class OutgoingGroupSetupTask(
-    override val groupId: GroupId,
-    override val creatorIdentity: String,
-    private val memberIdentities: Set<String>,
-    override val recipientIdentities: Set<String>,
-    messageId: MessageId?,
-    serviceManager: ServiceManager,
-) : OutgoingCspGroupControlMessageTask(serviceManager) {
-    override val type: String = "OutgoingGroupSetupTask"
-
-    override val messageId = messageId ?: MessageId()
-
-    override fun createGroupMessage() = GroupSetupMessage().also {
-        it.members = memberIdentities.toTypedArray()
-    }
-
-    override fun serialize(): SerializableTaskData =
-        OutgoingGroupSetupData(
-            groupId.groupId,
-            creatorIdentity,
-            memberIdentities,
-            recipientIdentities,
-            messageId.messageId,
-        )
-
-    @Serializable
-    class OutgoingGroupSetupData(
-        private val groupId: ByteArray,
-        private val creatorIdentity: String,
-        private val memberIdentities: Set<String>,
-        private val receiverIdentities: Set<String>,
-        private val messageId: ByteArray,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupSetupTask(
-                GroupId(groupId),
-                creatorIdentity,
-                memberIdentities,
-                receiverIdentities,
-                MessageId(messageId),
-                serviceManager,
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt
deleted file mode 100644
index 85c82510..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncRequestTask.kt
+++ /dev/null
@@ -1,133 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import android.text.format.DateUtils
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.utils.OutgoingCspGroupMessageCreator
-import ch.threema.app.utils.fetchContactModel
-import ch.threema.app.utils.sendMessageToReceivers
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.GroupSyncRequestMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.storage.models.OutgoingGroupSyncRequestLogModel
-import kotlinx.serialization.Serializable
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingGroupSyncRequestTask")
-
-/**
- * Send a group sync request to the specified group creator. Note that maximum one sync request is
- * sent per group and hour. If a sync request has been sent within the last hour, this task does not
- * send a sync request.
- *
- * The sync request is also sent to unknown or blocked contacts.
- */
-class OutgoingGroupSyncRequestTask(
-    private val groupId: GroupId,
-    private val creatorIdentity: String,
-    messageId: MessageId?,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    private val messageId = messageId ?: MessageId()
-    private val apiConnector by lazy { serviceManager.apiConnector }
-    private val taskCreator by lazy { serviceManager.taskCreator }
-    private val outgoingGroupSyncRequestLogModelFactory by lazy { serviceManager.databaseServiceNew.outgoingGroupSyncRequestLogModelFactory }
-    private val blockedContactsService by lazy { serviceManager.blockedContactsService }
-
-    override val type: String = "OutgoingGroupSyncRequestTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        // Don't send group sync request to myself
-        if (creatorIdentity.equals(identityStore.identity, true)) {
-            return
-        }
-
-        // Only send a group sync request once in an hour for a specific group
-        val model = outgoingGroupSyncRequestLogModelFactory.get(groupId.toString(), creatorIdentity)
-        val oneHourAgo = Date(System.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS)
-        val lastSyncRequest = model?.lastRequest ?: Date(0)
-        if (lastSyncRequest.after(oneHourAgo)) {
-            logger.info(
-                "Do not send request sync to group creator {}: last sync request was at {}",
-                creatorIdentity,
-                model.lastRequest
-            )
-            return
-        }
-
-        val recipient = contactService.getByIdentity(creatorIdentity)
-            ?: creatorIdentity.fetchContactModel(apiConnector)
-
-        val messageCreator = OutgoingCspGroupMessageCreator(
-            messageId,
-            groupId,
-            creatorIdentity
-        ) { GroupSyncRequestMessage() }
-
-        // Send message
-        handle.sendMessageToReceivers(
-            messageCreator,
-            setOf(recipient),
-            forwardSecurityMessageProcessor,
-            identityStore,
-            contactStore,
-            nonceFactory,
-            blockedContactsService,
-            taskCreator
-        )
-
-        // Update sync request sent date
-        if (model == null) {
-            val newModel = OutgoingGroupSyncRequestLogModel()
-            newModel.setAPIGroupId(groupId.toString(), creatorIdentity)
-            newModel.lastRequest = Date()
-            outgoingGroupSyncRequestLogModelFactory.create(newModel)
-        } else {
-            model.lastRequest = Date()
-            outgoingGroupSyncRequestLogModelFactory.update(model)
-        }
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupSyncRequestData(
-        groupId.groupId, creatorIdentity, messageId.messageId
-    )
-
-    @Serializable
-    class OutgoingGroupSyncRequestData(
-        private val groupId: ByteArray,
-        private val creatorIdentity: String,
-        private val messageId: ByteArray,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupSyncRequestTask(
-                GroupId(groupId),
-                creatorIdentity,
-                MessageId(messageId),
-                serviceManager,
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt
deleted file mode 100644
index 323841a9..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingGroupSyncTask.kt
+++ /dev/null
@@ -1,116 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingGroupSyncTask")
-
-/**
- * Send a group sync to the given receiver identities. This includes sending a setup message, a
- * name message, and a set-profile-picture or delete-profile-picture message. Note that this task
- * does not update the synchronized-at-timestamp of the group as this task may also be used to send
- * a sync to individual members.
- */
-class OutgoingGroupSyncTask(
-    private val groupId: GroupId,
-    private val creatorIdentity: String,
-    private val receiverIdentities: Set<String>,
-    private val serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    private val userService by lazy { serviceManager.userService }
-
-    override val type: String = "OutgoingGroupSyncTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val myIdentity = userService.identity
-        if (creatorIdentity != myIdentity) {
-            logger.warn("Only the group creator should send a group sync")
-            return
-        }
-
-        val group = groupService.getByApiGroupIdAndCreator(groupId, creatorIdentity)
-        if (group == null) {
-            logger.error(
-                "Could not find group {} with creator {} to send a group sync",
-                groupId,
-                creatorIdentity
-            )
-            return
-        }
-
-        // Send a group setup message (run task immediately)
-        OutgoingGroupSetupTask(
-            groupId,
-            creatorIdentity,
-            groupService.getMembers(group).map { it.identity }.toSet(),
-            receiverIdentities,
-            null,
-            serviceManager
-        ).invoke(handle)
-
-        // Send a group name message (run task immediately)
-        OutgoingGroupNameTask(
-            groupId,
-            creatorIdentity,
-            group.name ?: "",
-            receiverIdentities,
-            null,
-            serviceManager
-        ).invoke(handle)
-
-        // Send a profile picture (delete) message (run task immediately)
-        OutgoingGroupProfilePictureTask(
-            groupId,
-            creatorIdentity,
-            receiverIdentities,
-            null,
-            serviceManager
-        ).invoke(handle)
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingGroupSyncData(
-        groupId.groupId, creatorIdentity, receiverIdentities
-    )
-
-    @Serializable
-    private class OutgoingGroupSyncData(
-        private val groupId: ByteArray,
-        private val creatorIdentity: String,
-        private val receiverIdentities: Set<String>,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingGroupSyncTask(
-                GroupId(groupId),
-                creatorIdentity,
-                receiverIdentities,
-                serviceManager
-            )
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt
deleted file mode 100644
index ee1f1b60..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingLocationMessageTask.kt
+++ /dev/null
@@ -1,123 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.messagereceiver.MessageReceiver
-import ch.threema.app.messagereceiver.MessageReceiver.MessageReceiverType
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.csp.messages.LocationMessage
-import ch.threema.domain.protocol.csp.messages.GroupLocationMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingLocationMessageTask")
-
-class OutgoingLocationMessageTask(
-    private val messageModelId: Int,
-    @MessageReceiverType
-    private val receiverType: Int,
-    private val recipientIdentities: Set<String>,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingLocationMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        when (receiverType) {
-            MessageReceiver.Type_CONTACT -> sendContactMessage(handle)
-            MessageReceiver.Type_GROUP -> sendGroupMessage(handle)
-            else -> throw IllegalStateException("Invalid message receiver type $receiverType")
-        }
-    }
-
-    override fun onSendingStepsFailed(e: Exception) {
-        getMessageModel(receiverType, messageModelId)?.saveWithStateFailed()
-    }
-
-    private suspend fun sendContactMessage(handle: ActiveTaskCodec) {
-        val messageModel = getContactMessageModel(messageModelId) ?: return
-
-        val locationDataModel = messageModel.locationData
-
-        // Create the message
-        val message = LocationMessage().apply {
-            latitude = locationDataModel.latitude
-            longitude = locationDataModel.longitude
-            accuracy = locationDataModel.accuracy.toDouble()
-            poiName = locationDataModel.poi
-            poiAddress = locationDataModel.address
-
-            toIdentity = messageModel.identity
-            messageId = ensureMessageId(messageModel)
-        }
-
-        sendContactMessage(message, messageModel, handle)
-    }
-
-    private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
-        val messageModel = getGroupMessageModel(messageModelId) ?: return
-
-        val group = groupService.getById(messageModel.groupId)
-            ?: throw IllegalStateException("Could not get group for message model ${messageModel.apiMessageId}")
-
-        val locationDataModel = messageModel.locationData
-
-        sendGroupMessage(
-            group,
-            recipientIdentities,
-            messageModel,
-            ensureMessageId(messageModel),
-            {
-                GroupLocationMessage().apply {
-                    latitude = locationDataModel.latitude
-                    longitude = locationDataModel.longitude
-                    accuracy = locationDataModel.accuracy.toDouble()
-                    poiName = locationDataModel.poi
-                    poiAddress = locationDataModel.address
-                }
-            },
-            handle
-        )
-    }
-
-    override fun serialize(): SerializableTaskData =
-        OutgoingLocationMessageTaskData(messageModelId, receiverType, recipientIdentities)
-
-    @Serializable
-    class OutgoingLocationMessageTaskData(
-        private val messageModelId: Int,
-        @MessageReceiverType
-        private val receiverType: Int,
-        private val recipientIdentities: Set<String>,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingLocationMessageTask(
-                messageModelId,
-                receiverType,
-                recipientIdentities,
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt
deleted file mode 100644
index b8244986..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingPollSetupMessageTask.kt
+++ /dev/null
@@ -1,125 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.messagereceiver.MessageReceiver
-import ch.threema.app.messagereceiver.MessageReceiver.MessageReceiverType
-import ch.threema.domain.protocol.csp.messages.ballot.BallotData
-import ch.threema.domain.protocol.csp.messages.ballot.BallotId
-import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage
-import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-class OutgoingPollSetupMessageTask(
-    private val messageModelId: Int,
-    @MessageReceiverType
-    private val receiverType: Int,
-    private val recipientIdentities: Set<String>,
-    private val ballotId: BallotId,
-    private val ballotData: BallotData,
-    private val serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    override val type: String = "OutgoingPollSetupMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        when (receiverType) {
-            MessageReceiver.Type_CONTACT -> sendContactMessage(handle)
-            MessageReceiver.Type_GROUP -> sendGroupMessage(handle)
-            else -> throw IllegalStateException("Invalid message receiver type $receiverType")
-        }
-    }
-
-    override fun onSendingStepsFailed(e: Exception) {
-        getMessageModel(receiverType, messageModelId)?.saveWithStateFailed()
-    }
-
-    private suspend fun sendContactMessage(handle: ActiveTaskCodec) {
-        val messageModel = getContactMessageModel(messageModelId) ?: return
-
-        // Create the message
-        val message = PollSetupMessage()
-            .also {
-                it.ballotCreator = serviceManager.identityStore.identity
-                it.ballotId = ballotId
-                it.data = ballotData
-                it.toIdentity = messageModel.identity
-                it.messageId = ensureMessageId(messageModel)
-            }
-
-        sendContactMessage(message, messageModel, handle)
-    }
-
-    private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
-        val messageModel = getGroupMessageModel(messageModelId) ?: return
-
-        val group = serviceManager.groupService.getById(messageModel.groupId)
-            ?: throw IllegalStateException("Could not get group for message model ${messageModel.apiMessageId}")
-
-        sendGroupMessage(
-            group,
-            recipientIdentities,
-            messageModel,
-            ensureMessageId(messageModel),
-            {
-                GroupPollSetupMessage()
-                    .also {
-                        it.ballotCreator = serviceManager.identityStore.identity
-                        it.ballotId = ballotId
-                        it.data = ballotData
-                    }
-            },
-            handle
-        )
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingPollSetupMessageData(
-        messageModelId,
-        receiverType,
-        recipientIdentities,
-        ballotId.ballotId,
-        ballotData.generateString()
-    )
-
-    @Serializable
-    class OutgoingPollSetupMessageData(
-        private val messageModelId: Int,
-        @MessageReceiverType
-        private val receiverType: Int,
-        private val recipientIdentities: Set<String>,
-        private val ballotId: ByteArray,
-        private val ballotData: String,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingPollSetupMessageTask(
-                messageModelId,
-                receiverType,
-                recipientIdentities,
-                BallotId(ballotId),
-                BallotData.parse(ballotData),
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt
deleted file mode 100644
index 68c79aa1..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteContactMessageTask.kt
+++ /dev/null
@@ -1,92 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.ballot.BallotId
-import ch.threema.domain.protocol.csp.messages.ballot.BallotVote
-import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-class OutgoingPollVoteContactMessageTask(
-    private val messageId: MessageId,
-    private val ballotId: BallotId,
-    private val ballotCreator: String,
-    private val ballotVotes: Array<BallotVote>,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    override val type: String = "OutgoingPollVoteContactMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        // Create the message
-        val message = PollVoteMessage()
-            .also {
-                it.ballotCreator = ballotCreator
-                it.ballotId = ballotId
-                it.toIdentity = toIdentity
-                it.messageId = messageId
-            }
-
-        // Add all ballot votes
-        message.addVotes(ballotVotes.toList())
-
-        // Send the message
-        sendContactMessage(message, null, handle)
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingPollVoteContactMessageData(
-        messageId.toString(),
-        ballotId.ballotId,
-        ballotCreator,
-        ballotVotes.map { Pair(it.id, it.value) },
-        toIdentity
-    )
-
-    @Serializable
-    class OutgoingPollVoteContactMessageData(
-        private val messageId: String,
-        private val ballotId: ByteArray,
-        private val ballotCreator: String,
-        private val ballotVotes: List<Pair<Int, Int>>,
-        private val toIdentity: String,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingPollVoteContactMessageTask(
-                MessageId.fromString(messageId),
-                BallotId(ballotId),
-                ballotCreator,
-                ballotVotes.map {
-                    BallotVote().apply {
-                        id = it.first
-                        value = it.second
-                    }
-                }.toTypedArray(),
-                toIdentity,
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt
deleted file mode 100644
index 35a6d35d..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingPollVoteGroupMessageTask.kt
+++ /dev/null
@@ -1,129 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.ballot.BallotId
-import ch.threema.domain.protocol.csp.messages.ballot.BallotVote
-import ch.threema.domain.protocol.csp.messages.ballot.GroupPollVoteMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.storage.models.ballot.BallotModel
-import kotlinx.serialization.Serializable
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingPollVoteGroupMessageTask")
-
-class OutgoingPollVoteGroupMessageTask(
-    private val messageId: MessageId,
-    private val recipientIdentities: Set<String>,
-    private val ballotId: BallotId,
-    private val ballotCreator: String,
-    private val ballotVotes: Array<BallotVote>,
-    private val ballotType: BallotModel.Type,
-    private val apiGroupId: GroupId,
-    private val groupCreator: String,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingPollVoteGroupMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        if (ballotType == BallotModel.Type.RESULT_ON_CLOSE) {
-            sendBallotVote(handle, setOf(ballotCreator))
-        } else {
-            sendBallotVote(handle, recipientIdentities)
-        }
-    }
-
-    private suspend fun sendBallotVote(handle: ActiveTaskCodec, recipients: Set<String>) {
-        val group = groupService.getByApiGroupIdAndCreator(apiGroupId, groupCreator)
-
-        if (group == null) {
-            logger.error(
-                "Cannot find group model for id {} with creator {}",
-                apiGroupId,
-                groupCreator
-            )
-            return
-        }
-
-        sendGroupMessage(
-            group,
-            recipients,
-            null,
-            messageId,
-            { createMessage() },
-            handle
-        )
-    }
-
-    private fun createMessage() = GroupPollVoteMessage().also {
-        it.ballotCreator = ballotCreator
-        it.ballotId = ballotId
-        it.addVotes(ballotVotes.toList())
-    }
-
-    override fun serialize(): SerializableTaskData = OutgoingPollVoteGroupMessageData(
-        messageId.toString(),
-        recipientIdentities,
-        ballotId.ballotId,
-        ballotCreator,
-        ballotVotes.map { Pair(it.id, it.value) },
-        ballotType,
-        apiGroupId.toString(),
-        groupCreator
-    )
-
-    @Serializable
-    class OutgoingPollVoteGroupMessageData(
-        private val messageId: String,
-        private val recipientIdentities: Set<String>,
-        private val ballotId: ByteArray,
-        private val ballotCreator: String,
-        private val ballotVotes: List<Pair<Int, Int>>,
-        private val ballotType: BallotModel.Type,
-        private val apiGroupId: String,
-        private val groupCreator: String,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingPollVoteGroupMessageTask(
-                MessageId.fromString(messageId),
-                recipientIdentities,
-                BallotId(ballotId),
-                ballotCreator,
-                ballotVotes.map {
-                    BallotVote().apply {
-                        id = it.first
-                        value = it.second
-                    }
-                }.toTypedArray(),
-                ballotType,
-                GroupId(apiGroupId),
-                groupCreator,
-                serviceManager
-            )
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt
deleted file mode 100644
index e133efd4..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingProfilePictureTask.kt
+++ /dev/null
@@ -1,87 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.services.ContactService
-import ch.threema.domain.protocol.csp.messages.DeleteProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.ContactRequestProfilePictureMessage
-import ch.threema.domain.protocol.csp.messages.SetProfilePictureMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-/**
- * This class provides methods to send set-profile-picture, request-profile-picture, and
- * delete-profile-picture messages.
- */
-sealed class OutgoingProfilePictureTask(serviceManager: ServiceManager) :
-    OutgoingCspMessageTask(serviceManager), PersistableTask {
-    /**
-     * Send request profile picture message to the receiver.
-     */
-    protected suspend fun sendRequestProfilePictureMessage(
-        toIdentity: String,
-        handle: ActiveTaskCodec,
-    ) {
-        // Create the message
-        val innerMsg = ContactRequestProfilePictureMessage()
-        innerMsg.toIdentity = toIdentity
-
-        // Encapsulate and send the message
-        sendContactMessage(innerMsg, null, handle)
-    }
-
-    /**
-     * Send a set profile picture message to the receiver.
-     *
-     * @param data the profile picture upload data
-     */
-    protected suspend fun sendSetProfilePictureMessage(
-        data: ContactService.ProfilePictureUploadData,
-        toIdentity: String,
-        handle: ActiveTaskCodec,
-    ) {
-        // Create the message
-        val innerMsg =
-            SetProfilePictureMessage()
-        innerMsg.blobId = data.blobId
-        innerMsg.encryptionKey = data.encryptionKey
-        innerMsg.size = data.size
-        innerMsg.toIdentity = toIdentity
-
-        sendContactMessage(innerMsg, null, handle)
-    }
-
-    /**
-     * Send a delete profile picture message to the receiver.
-     */
-    protected suspend fun sendDeleteProfilePictureMessage(
-        toIdentity: String,
-        handle: ActiveTaskCodec,
-    ) {
-        // Create the message
-        val innerMsg =
-            DeleteProfilePictureMessage()
-        innerMsg.toIdentity = toIdentity
-
-        sendContactMessage(innerMsg, null, handle)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt
deleted file mode 100644
index 14e8de67..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingTextMessageTask.kt
+++ /dev/null
@@ -1,114 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.messagereceiver.MessageReceiver.MessageReceiverType
-import ch.threema.app.messagereceiver.MessageReceiver.Type_CONTACT
-import ch.threema.app.messagereceiver.MessageReceiver.Type_GROUP
-import ch.threema.domain.protocol.csp.messages.GroupTextMessage
-import ch.threema.domain.protocol.csp.messages.TextMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-
-class OutgoingTextMessageTask(
-    private val messageModelId: Int,
-    @MessageReceiverType
-    private val receiverType: Int,
-    private val recipientIdentities: Set<String>,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-
-    override val type: String = "OutgoingTextMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        when (receiverType) {
-            Type_CONTACT -> sendContactMessage(handle)
-            Type_GROUP -> sendGroupMessage(handle)
-            else -> throw IllegalStateException("Invalid message receiver type $receiverType")
-        }
-    }
-
-    override fun onSendingStepsFailed(e: Exception) {
-        getMessageModel(receiverType, messageModelId)?.saveWithStateFailed()
-    }
-
-    private suspend fun sendContactMessage(handle: ActiveTaskCodec) {
-        val messageModel = getContactMessageModel(messageModelId) ?: return
-
-        // Create the message
-        val message = TextMessage()
-        message.messageId = ensureMessageId(messageModel)
-        message.text = messageModel.bodyAndQuotedMessageId
-        message.toIdentity = messageModel.identity
-
-        sendContactMessage(message, messageModel, handle)
-    }
-
-    private suspend fun sendGroupMessage(handle: ActiveTaskCodec) {
-        val messageModel = getGroupMessageModel(messageModelId) ?: return
-
-        val group = groupService.getById(messageModel.groupId)
-            ?: throw IllegalStateException("Could not get group for message model ${messageModel.apiMessageId}")
-
-        val textIncludingQuote = messageModel.bodyAndQuotedMessageId
-
-        sendGroupMessage(
-            group,
-            recipientIdentities,
-            messageModel,
-            ensureMessageId(messageModel),
-            {
-                GroupTextMessage().apply {
-                    text = textIncludingQuote
-                }
-            },
-            handle
-        )
-    }
-
-    override fun serialize(): SerializableTaskData =
-        OutgoingTextMessageData(
-            messageModelId,
-            receiverType,
-            recipientIdentities,
-        )
-
-    @Serializable
-    class OutgoingTextMessageData(
-        private val messageModelId: Int,
-        @MessageReceiverType
-        private val receiverType: Int,
-        private val recipientIdentities: Set<String>,
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            OutgoingTextMessageTask(
-                messageModelId,
-                receiverType,
-                recipientIdentities,
-                serviceManager
-            )
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt
deleted file mode 100644
index ca2b119f..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingTypingIndicatorMessageTask.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class OutgoingTypingIndicatorMessageTask(
-    private val isTyping: Boolean,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-): OutgoingCspMessageTask(serviceManager) {
-    override val type: String = "OutgoingTypingIndicatorMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = TypingIndicatorMessage().also {
-            it.messageId = MessageId()
-            it.toIdentity = toIdentity
-            it.isTyping = isTyping
-        }
-
-        sendContactMessage(message, null, handle)
-    }
-
-    override fun serialize(): SerializableTaskData? = null
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt
deleted file mode 100644
index ff19c287..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallAnswerMessageTask.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class OutgoingVoipCallAnswerMessageTask(
-    private val voipCallAnswerData: VoipCallAnswerData,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    private val voipStateService by lazy { serviceManager.voipStateService }
-
-    override val type: String = "OutgoingVoipCallAnswerMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = VoipCallAnswerMessage()
-        message.data = voipCallAnswerData
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
-
-        voipStateService.addRequiredMessageId(voipCallAnswerData.callId ?: 0, message.messageId)
-
-        sendContactMessage(message, null, handle)
-    }
-
-    // We do not need to persist this message
-    override fun serialize(): SerializableTaskData? = null
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt
deleted file mode 100644
index 666bf6d7..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallHangupMessageTask.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupData
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class OutgoingVoipCallHangupMessageTask(
-    private val voipCallHangupData: VoipCallHangupData,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-): OutgoingCspMessageTask(serviceManager) {
-    override val type: String = "OutgoingVoipCallHangupMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = VoipCallHangupMessage()
-        message.setData(voipCallHangupData)
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
-
-        sendContactMessage(message, null, handle)
-    }
-
-    // We do not need to persist this message
-    override fun serialize(): SerializableTaskData? = null
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt
deleted file mode 100644
index 4ae9ab5e..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallOfferMessageTask.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferData
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class OutgoingVoipCallOfferMessageTask(
-    private val voipCallOfferData: VoipCallOfferData,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    private val voipStateService by lazy { serviceManager.voipStateService }
-
-    override val type: String = "OutgoingVoipCallOfferMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = VoipCallOfferMessage()
-        message.data = voipCallOfferData
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
-
-        voipStateService.addRequiredMessageId(voipCallOfferData.callId ?: 0, message.messageId)
-
-        sendContactMessage(message, null, handle)
-
-        contactService.bumpLastUpdate(toIdentity)
-    }
-
-    // We do not need to persist this message
-    override fun serialize(): SerializableTaskData? = null
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt
deleted file mode 100644
index aaf8e517..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipCallRingingMessageTask.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingData
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class OutgoingVoipCallRingingMessageTask(
-    private val voipCallRingingData: VoipCallRingingData,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingCspMessageTask(serviceManager) {
-    private val voipStateService by lazy { serviceManager.voipStateService }
-
-    override val type: String = "OutgoingVoipCallRingingMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = VoipCallRingingMessage()
-        message.setData(voipCallRingingData)
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
-
-        voipStateService.addRequiredMessageId(voipCallRingingData.callId ?: 0, message.messageId)
-
-        sendContactMessage(message, null, handle)
-    }
-
-    // We do not need to persist this message
-    override fun serialize(): SerializableTaskData? = null
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt b/app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt
deleted file mode 100644
index 5c70a368..00000000
--- a/app/src/main/java/ch/threema/app/tasks/OutgoingVoipICECandidateMessageTask.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage
-import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesData
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-
-class OutgoingVoipICECandidateMessageTask(
-    private val voipICECandidatesData: VoipICECandidatesData,
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-): OutgoingCspMessageTask(serviceManager) {
-    override val type: String = "OutgoingVoipICECandidateMessageTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val message = VoipICECandidatesMessage()
-        message.data = voipICECandidatesData
-        message.toIdentity = toIdentity
-        message.messageId = MessageId()
-
-        sendContactMessage(message, null, handle)
-    }
-
-    // We do not need to persist this message
-    override fun serialize(): SerializableTaskData? = null
-
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/PersistableTask.kt b/app/src/main/java/ch/threema/app/tasks/PersistableTask.kt
deleted file mode 100644
index f54f7045..00000000
--- a/app/src/main/java/ch/threema/app/tasks/PersistableTask.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-import kotlinx.serialization.encodeToString
-import kotlinx.serialization.json.Json
-
-internal sealed interface PersistableTask {
-    fun serialize(): SerializableTaskData?
-}
-
-@Serializable
-sealed interface SerializableTaskData {
-    fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec>
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/ProfilePictureDistributionTask.kt b/app/src/main/java/ch/threema/app/tasks/ProfilePictureDistributionTask.kt
deleted file mode 100644
index 3750ab3d..00000000
--- a/app/src/main/java/ch/threema/app/tasks/ProfilePictureDistributionTask.kt
+++ /dev/null
@@ -1,128 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.services.ContactService.ProfilePictureUploadData
-import ch.threema.app.utils.ContactUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.storage.models.ContactModel
-import kotlinx.serialization.Serializable
-import java.util.Arrays
-
-private val logger = LoggingUtil.getThreemaLogger("ProfilePictureDistributionTask")
-
-/**
- * This task runs the profile distribution
- */
-class ProfilePictureDistributionTask(
-    private val toIdentity: String,
-    serviceManager: ServiceManager,
-) : OutgoingProfilePictureTask(serviceManager) {
-
-    override val type: String = "ProfilePictureDistributionTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        // Step 1 is already done as this task is only scheduled for messages that allow user
-        // profile distribution.
-
-        val prefix = "Profile picture distribution"
-
-        val contactModel = contactService.getByIdentity(toIdentity)
-        if (contactModel == null) {
-            logger.warn("{}: Contact model not found", prefix)
-            return
-        }
-
-        // Step 2: Abort if the contact's id is ECHOECHO or a Gateway ID
-        if (ContactUtil.isEchoEchoOrGatewayContact(contactModel)) {
-            logger.info(
-                "{}: Contact {} should not receive the profile picture",
-                prefix,
-                toIdentity
-            )
-            return
-        }
-
-        // If the contact has been restored, send a photo request message and mark contact as not
-        // restored if successful. Don't do this for ECHOECHO or channel IDs.
-        if (contactModel.isRestored) {
-            sendRequestProfilePictureMessage(toIdentity, handle)
-            contactModel.setIsRestored(false)
-            contactService.save(contactModel)
-        }
-
-        // Step 3: Abort if the contact should not receive the profile picture according to settings
-        if (!contactService.isContactAllowedToReceiveProfilePicture(contactModel)) {
-            logger.info(
-                "{}: Contact {} is not allowed to receive the profile picture",
-                prefix,
-                toIdentity
-            )
-            return
-        }
-
-        // Step 4: Upload profile picture to blob server if no valid cached blob id exists
-        val data: ProfilePictureUploadData = contactService.updatedProfilePictureUploadData
-        if (data.blobId == null) {
-            logger.warn("{}: Blob ID is null; abort", prefix)
-            return
-        }
-
-        // Step 5: If the currently cached blob ID equals the blob ID that was most recently
-        // distributed to the contact, abort these steps
-        if (Arrays.equals(data.blobId, contactModel.profilePicBlobID)) {
-            logger.debug(
-                "{}: Contact {} already has the latest profile picture",
-                prefix,
-                toIdentity
-            )
-            return
-        }
-
-        // Step 6: Send a set-profile-picture message to the contact using the cached blob ID
-        if (!data.blobId.contentEquals(ContactModel.NO_PROFILE_PICTURE_BLOB_ID)) {
-            sendSetProfilePictureMessage(data, toIdentity, handle)
-            logger.info("{}: Profile picture successfully sent to {}", prefix, toIdentity)
-        } else {
-            sendDeleteProfilePictureMessage(toIdentity, handle)
-            logger.info("{}: Profile picture deletion successfully sent to {}", prefix, toIdentity)
-        }
-
-        // Step 7: Store the cached blob ID as the most recently used blob ID for this contact
-        contactModel.profilePicBlobID = data.blobId
-        contactService.save(contactModel)
-    }
-
-    override fun serialize(): SerializableTaskData = ProfilePictureDistributionTaskData(toIdentity)
-
-    @Serializable
-    data class ProfilePictureDistributionTaskData(
-        private val toIdentity: String
-    ) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            ProfilePictureDistributionTask(toIdentity, serviceManager)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt b/app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt
deleted file mode 100644
index 14eed5f4..00000000
--- a/app/src/main/java/ch/threema/app/tasks/SendProfilePictureTask.kt
+++ /dev/null
@@ -1,66 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.storage.models.ContactModel
-import kotlinx.serialization.Serializable
-import java.util.Arrays
-
-private val logger = LoggingUtil.getThreemaLogger("SendProfilePictureTask")
-
-/**
- * This task sends out either a set-profile-picture message or a delete-profile-picture message to
- * the given contact. Note that this task does not check when the profile picture has been sent the
- * last time.
- */
-class SendProfilePictureTask(private val toIdentity: String, serviceManager: ServiceManager) :
-    OutgoingProfilePictureTask(serviceManager) {
-
-    override val type: String = "SendProfilePictureTask"
-
-    override suspend fun runSendingSteps(handle: ActiveTaskCodec) {
-        val data = contactService.updatedProfilePictureUploadData
-        if (data.blobId == null) {
-            logger.warn("Blob ID is null; cannot send profile picture")
-            return
-        }
-
-        return if (Arrays.equals(data.blobId, ContactModel.NO_PROFILE_PICTURE_BLOB_ID)) {
-            sendDeleteProfilePictureMessage(toIdentity, handle)
-        } else {
-            sendSetProfilePictureMessage(data, toIdentity, handle)
-        }
-    }
-
-    override fun serialize(): SerializableTaskData = SendProfilePictureData(toIdentity)
-
-    @Serializable
-    data class SendProfilePictureData(private val toIdentity: String) : SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            SendProfilePictureTask(toIdentity, serviceManager)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/SendPushTokenTask.kt b/app/src/main/java/ch/threema/app/tasks/SendPushTokenTask.kt
deleted file mode 100644
index ef294de3..00000000
--- a/app/src/main/java/ch/threema/app/tasks/SendPushTokenTask.kt
+++ /dev/null
@@ -1,102 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import androidx.preference.PreferenceManager
-import ch.threema.app.R
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.utils.PushUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.taskmanager.ActiveTask
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.serialization.Serializable
-import java.nio.charset.StandardCharsets
-
-private val logger = LoggingUtil.getThreemaLogger("SendPushTokenTask")
-
-class SendPushTokenTask(
-    private val token: String,
-    private val tokenType: Int,
-    private val serviceManager: ServiceManager,
-) : ActiveTask<Unit>,
-    PersistableTask {
-    override val type: String = "SendPushTokenTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        val resetPushToken = token.isEmpty()
-
-        // In case the push token should be reset, we must not check whether it needs to be refreshed
-        if (!resetPushToken && !PushUtil.pushTokenNeedsRefresh(serviceManager.context)) {
-            logger.warn("Push token does not need to be sent; aborting this task")
-            return
-        }
-
-        sendPushToken(handle)
-
-        // Reset token update timestamp if it was reset; set current update time otherwise
-        val sentTime = if (resetPushToken) {
-            // If the token has been reset, then set the timestamp to 0 so that the new token will
-            // be sent again as soon as possible
-            0L
-        } else {
-            // If the token has been set, then use the current timestamp
-            System.currentTimeMillis()
-        }
-
-        PreferenceManager.getDefaultSharedPreferences(serviceManager.context)
-            .edit()
-            .putLong(
-                serviceManager.context.getString(R.string.preferences__token_sent_date),
-                sentTime
-            )
-            .apply()
-
-        // Used in the Webclient Sessions
-        serviceManager.getPreferenceService().setPushToken(token)
-    }
-
-    private suspend fun sendPushToken(handle: ActiveTaskCodec) {
-        val tokenBytes = token.toByteArray(StandardCharsets.US_ASCII)
-        val type = byteArrayOf(tokenType.toByte())
-        val tokenData = type + tokenBytes
-
-        // Send regular push token
-        handle.write(CspMessage(ProtocolDefines.PLTYPE_PUSH_NOTIFICATION_TOKEN.toUByte(), tokenData))
-        // Send voip push token. This is identical to the regular push token.
-        handle.write(CspMessage(ProtocolDefines.PLTYPE_VOIP_PUSH_NOTIFICATION_TOKEN.toUByte(), tokenData))
-
-        logger.info("Push token successfully sent to server")
-    }
-
-    override fun serialize(): SerializableTaskData = SendPushTokenData(token, tokenType)
-
-    @Serializable
-    data class SendPushTokenData(private val token: String, private val tokenType: Int) :
-        SerializableTaskData {
-        override fun createTask(serviceManager: ServiceManager): Task<*, TaskCodec> =
-            SendPushTokenTask(token, tokenType, serviceManager)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/TaskArchiverImpl.kt b/app/src/main/java/ch/threema/app/tasks/TaskArchiverImpl.kt
deleted file mode 100644
index 4e54004d..00000000
--- a/app/src/main/java/ch/threema/app/tasks/TaskArchiverImpl.kt
+++ /dev/null
@@ -1,97 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskArchiver
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.domain.taskmanager.getDebugString
-import ch.threema.storage.factories.TaskArchiveFactory
-import kotlinx.serialization.encodeToString
-import kotlinx.serialization.json.Json
-
-private val logger = LoggingUtil.getThreemaLogger("TaskArchiverImpl")
-
-class TaskArchiverImpl(private val taskArchiveFactory: TaskArchiveFactory) : TaskArchiver {
-    private var serviceManager: ServiceManager? = null
-
-    fun setServiceManager(serviceManager: ServiceManager) {
-        this.serviceManager = serviceManager
-    }
-
-    override fun addTask(task: Task<*, TaskCodec>) {
-        task.toEncodedTaskData()?.let {
-            logger.info("Persisting task {}", task.getDebugString())
-            taskArchiveFactory.insert(it)
-        }
-    }
-
-    override fun removeTask(task: Task<*, TaskCodec>) {
-        val encodedTaskData = task.toEncodedTaskData() ?: return
-        logger.info("Removing task {} from archive", task.getDebugString())
-        taskArchiveFactory.remove(encodedTaskData)
-    }
-
-    override fun loadAllTasks(): List<Task<*, TaskCodec>> {
-        // Map all encodings to pairs containing the encoding and the decoded task (or null if
-        // decoding failed)
-        val tasks = taskArchiveFactory.getAll().map {
-            it to it.decodeToTask()
-        }
-
-        // Remove all tasks from database that could not be decoded
-        tasks.forEach {
-            val (encoding, task) = it
-            if (task == null) {
-                taskArchiveFactory.removeOne(encoding)
-                logger.warn("Dropping persisted task as it could not be decoded: '{}'", encoding)
-            }
-        }
-
-        // Return all successfully decoded tasks
-        return tasks.mapNotNull { it.second }.onEach {
-            logger.info("Loading task {} from archive", it.getDebugString())
-        }
-    }
-
-    private fun Task<*, TaskCodec>.toEncodedTaskData(): String? {
-        return if (this is PersistableTask) {
-            serialize()?.let { Json.encodeToString(it) }
-        } else {
-            null
-        }
-    }
-
-    private fun String.decodeToTask(): Task<*, TaskCodec>? {
-        val serviceManager = this@TaskArchiverImpl.serviceManager
-            ?: throw IllegalStateException("Service manager is not set while loading persisted tasks")
-
-        return try {
-            Json.decodeFromString<SerializableTaskData>(this).createTask(serviceManager)
-        } catch (e: Exception) {
-            logger.error("Task data decoding error. Dropping task '$this'", e)
-            null
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/tasks/TaskCreator.kt b/app/src/main/java/ch/threema/app/tasks/TaskCreator.kt
deleted file mode 100644
index af7c4ac1..00000000
--- a/app/src/main/java/ch/threema/app/tasks/TaskCreator.kt
+++ /dev/null
@@ -1,59 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.tasks
-
-import ch.threema.app.managers.ServiceManager
-import ch.threema.domain.models.Contact
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.protobuf.csp.e2e.fs.Terminate.Cause
-import kotlinx.coroutines.Deferred
-
-class TaskCreator(private val serviceManager: ServiceManager) {
-    fun scheduleProfilePictureSendTaskAsync(toIdentity: String): Deferred<Unit> =
-        scheduleTaskAsync {
-            SendProfilePictureTask(toIdentity, serviceManager)
-        }
-
-    fun scheduleProfilePictureExecution(toIdentity: String): Deferred<Unit> = scheduleTaskAsync {
-        ProfilePictureDistributionTask(toIdentity, serviceManager)
-    }
-
-    fun scheduleDeleteAndTerminateFSSessionsTaskAsync(
-        contact: Contact,
-        cause: Cause,
-    ): Deferred<Unit> =
-        scheduleTaskAsync {
-            DeleteAndTerminateFSSessionsTask(
-                serviceManager.forwardSecurityMessageProcessor,
-                contact,
-                cause
-            )
-        }
-
-    fun scheduleSendPushTokenTask(token: String, type: Int): Deferred<Unit> =
-        scheduleTaskAsync { SendPushTokenTask(token, type, serviceManager) }
-
-    private fun <R> scheduleTaskAsync(createTask: () -> Task<R, TaskCodec>): Deferred<R> {
-        return serviceManager.taskManager.schedule(createTask())
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java b/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java
index 28a3255e..32ce4849 100644
--- a/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/threemasafe/ThreemaSafeServiceImpl.java
@@ -32,14 +32,6 @@ import android.view.Display;
 import android.view.WindowManager;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.work.ExistingPeriodicWorkPolicy;
-import androidx.work.ExistingWorkPolicy;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.PeriodicWorkRequest;
-import androidx.work.WorkManager;
-
 import com.neilalexander.jnacl.NaCl;
 
 import org.bouncycastle.crypto.generators.SCrypt;
@@ -65,6 +57,7 @@ import java.util.Arrays;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.zip.Deflater;
@@ -72,12 +65,20 @@ import java.util.zip.GZIPInputStream;
 
 import javax.net.ssl.HttpsURLConnection;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.work.ExistingPeriodicWorkPolicy;
+import androidx.work.ExistingWorkPolicy;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.PeriodicWorkRequest;
+import androidx.work.WorkManager;
 import ch.threema.app.BuildConfig;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
-import ch.threema.app.exceptions.EntryAlreadyExistsException;
-import ch.threema.app.exceptions.InvalidEntryException;
-import ch.threema.app.exceptions.PolicyViolationException;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactResult;
 import ch.threema.app.services.ApiService;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeadlineListService;
@@ -93,6 +94,7 @@ import ch.threema.app.stores.PreferenceStoreInterface;
 import ch.threema.app.utils.AppRestrictionUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.GzipOutputStream;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.StringConversionUtil;
@@ -103,6 +105,7 @@ import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.Base64;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
@@ -111,6 +114,7 @@ import ch.threema.domain.protocol.ProtocolStrings;
 import ch.threema.domain.protocol.ServerAddressProvider;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.ContactModelFactory;
 import ch.threema.storage.factories.DistributionListMemberModelFactory;
@@ -128,11 +132,13 @@ import static ch.threema.app.ThreemaApplication.WORKER_PERIODIC_THREEMA_SAFE_UPL
 import static ch.threema.app.ThreemaApplication.WORKER_THREEMA_SAFE_UPLOAD;
 import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_EVERYONE;
 import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_NOBODY;
-import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_SOME;
+import static ch.threema.app.services.PreferenceService.PROFILEPIC_RELEASE_ALLOW_LIST;
 import static ch.threema.app.threemasafe.ThreemaSafeConfigureActivity.EXTRA_OPEN_HOME_ACTIVITY;
 import static ch.threema.app.threemasafe.ThreemaSafeConfigureActivity.EXTRA_WORK_FORCE_PASSWORD;
 import static ch.threema.app.threemasafe.ThreemaSafeServerTestResponse.CONFIG_MAX_BACKUP_BYTES;
 import static ch.threema.app.threemasafe.ThreemaSafeServerTestResponse.CONFIG_RETENTION_DAYS;
+import static ch.threema.storage.models.GroupModel.UserState.LEFT;
+import static ch.threema.storage.models.GroupModel.UserState.MEMBER;
 
 public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("ThreemaSafeServiceImpl");
@@ -247,6 +253,8 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 	private final ServerAddressProvider serverAddressProvider;
 	@NonNull
 	private final PreferenceStoreInterface preferenceStore;
+	@NonNull
+	private final ContactModelRepository contactModelRepository;
 
 	public ThreemaSafeServiceImpl(
 		Context context,
@@ -266,7 +274,8 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		@NonNull APIConnector apiConnector,
 		DeadlineListService hiddenChatsListService,
 		@NonNull ServerAddressProvider serverAddressProvider,
-		@NonNull PreferenceStoreInterface preferenceStore
+		@NonNull PreferenceStoreInterface preferenceStore,
+		@NonNull ContactModelRepository contactModelRepository
 		) {
 		this.context = context;
 		this.preferenceService = preferenceService;
@@ -286,6 +295,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		this.hiddenChatsListService = hiddenChatsListService;
 		this.serverAddressProvider = serverAddressProvider;
 		this.preferenceStore = preferenceStore;
+		this.contactModelRepository = contactModelRepository;
 	}
 
 	@Override
@@ -816,7 +826,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 
 		ContactModel contactModel = contactService.getByIdentity(userService.getIdentity());
 		if (contactModel != null) {
-			userService.setPublicNickname(nickname);
+			userService.setPublicNickname(nickname, TriggerSource.LOCAL);
 
 
 			boolean isLinksRestricted = false;
@@ -847,7 +857,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 			String profilePic = user.optString(TAG_SAFE_USER_PROFILE_PIC, null);
 			if (profilePic != null) {
 				try {
-					contactService.setAvatar(contactModel, Base64.decode(profilePic));
+					contactService.setUserDefinedProfilePicture(contactModel, Base64.decode(profilePic), TriggerSource.LOCAL);
 				} catch (Exception e) {
 					// base 64 decoding or avatar setting failed - forget about the pic
 				}
@@ -855,7 +865,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 
 			JSONArray profilePicRelease = user.optJSONArray(TAG_SAFE_USER_PROFILE_PIC_RELEASE);
 			if (profilePicRelease != null) {
-				preferenceService.setProfilePicRelease(PROFILEPIC_RELEASE_SOME);
+				preferenceService.setProfilePicRelease(PROFILEPIC_RELEASE_ALLOW_LIST);
 
 				for (int i = 0; i < profilePicRelease.length(); i++) {
 					String id = profilePicRelease.getString(i);
@@ -937,7 +947,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 			return;
 		}
 
-		ArrayList<APIConnector.FetchIdentityResult> results;
+		List<APIConnector.FetchIdentityResult> results;
 		try {
 			results = this.apiConnector.fetchIdentities(identities);
 		}
@@ -978,16 +988,12 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 							default:
 								logger.warn("Identity fetch returned invalid identity type: {}", result.type);
 						}
-						switch (result.state) {
-							case IdentityState.ACTIVE:
-								contactModel.setState(ContactModel.State.ACTIVE);
-								break;
-							case IdentityState.INACTIVE:
-								contactModel.setState(ContactModel.State.INACTIVE);
-								break;
-							case IdentityState.INVALID:
-								contactModel.setState(ContactModel.State.INVALID);
-								break;
+						if (result.state == IdentityState.ACTIVE.getValue()) {
+							contactModel.setState(IdentityState.ACTIVE);
+						} else if (result.state == IdentityState.INACTIVE.getValue()) {
+							contactModel.setState(IdentityState.INACTIVE);
+						} else if (result.state == IdentityState.INVALID.getValue()) {
+							contactModel.setState(IdentityState.INVALID);
 						}
 						contactModel.setIsWork(contact.optBoolean(TAG_SAFE_CONTACT_WORK_VERIFIED));
 						contactModel.setFirstName(contact.optString(TAG_SAFE_CONTACT_FIRST_NAME));
@@ -1011,7 +1017,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 						contactModelFactory.createOrUpdate(contactModel);
 
 						if (contact.optBoolean(TAG_SAFE_CONTACT_PRIVATE, false)) {
-							hiddenChatsListService.add(contactService.getUniqueIdString(contactModel), DeadlineListService.DEADLINE_INDEFINITE);
+							hiddenChatsListService.add(ContactUtil.getUniqueIdString(contactModel.getIdentity()), DeadlineListService.DEADLINE_INDEFINITE);
 						}
 					}
 				}
@@ -1046,7 +1052,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 					groupModel.setDeleted(group.getBoolean(TAG_SAFE_GROUP_DELETED));
 					groupModel.setSynchronizedAt(new Date(0));
 					if (!group.isNull(TAG_SAFE_GROUP_LAST_UPDATE)) {
-						final long lastUpdate = group.getLong("lastUpdate");
+						final long lastUpdate = group.getLong(TAG_SAFE_GROUP_LAST_UPDATE);
 						groupModel.setLastUpdate(new Date(lastUpdate));
 					}
 
@@ -1055,27 +1061,48 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 							hiddenChatsListService.add(this.groupService.getUniqueIdString(groupModel), DeadlineListService.DEADLINE_INDEFINITE);
 						}
 
+						String myIdentity = userService.getIdentity();
+						boolean isMember = false;
+
 						JSONArray members = group.getJSONArray(TAG_SAFE_GROUP_MEMBERS);
 						for (int j = 0; j < members.length(); j++) {
 							String identity = members.getString(j);
 							if (!TestUtil.isEmptyOrNull(identity)) {
 								if (contactService.getByIdentity(identity) == null) {
-									// fetch group contact if not in contact list
-									try {
-										contactService.createContactByIdentity(identity, true, AcquaintanceLevel.GROUP);
-									} catch (InvalidEntryException | EntryAlreadyExistsException | PolicyViolationException e) {
-										// do not add as group member if contact cannot be created
+									// Fetch group contact if not in contact list. Note that we do
+									// not add the contact to the group if it couldn't be created.
+									ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+										identity,
+										AcquaintanceLevel.GROUP,
+										myIdentity,
+										apiConnector,
+										contactModelRepository,
+										AddContactRestrictionPolicy.IGNORE,
+										context,
+										null
+									).runSynchronously();
+
+									if (!(result instanceof ContactAvailable)) {
+										logger.error("Contact {} could not be created", identity);
 										continue;
 									}
 								}
 
-								GroupMemberModel groupMemberModel = new GroupMemberModel();
-								groupMemberModel.setGroupId(groupModel.getId());
-								groupMemberModel.setIdentity(identity);
+								if (identity.equals(myIdentity)) {
+									isMember = true;
+								} else {
+									// Only create a group member model if it is not the user itself
+									GroupMemberModel groupMemberModel = new GroupMemberModel();
+									groupMemberModel.setGroupId(groupModel.getId());
+									groupMemberModel.setIdentity(identity);
 
-								groupMemberModelFactory.create(groupMemberModel);
+									groupMemberModelFactory.create(groupMemberModel);
+								}
 							}
 						}
+
+						groupModel.setUserState(isMember ? MEMBER : LEFT);
+						groupModelFactory.update(groupModel);
 					}
 				}
 			} catch (JSONException | NullPointerException e){
@@ -1123,11 +1150,21 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 					String identity = members.getString(j);
 					if (!TestUtil.isEmptyOrNull(identity)) {
 						if (contactService.getByIdentity(identity) == null) {
-							// fetch contact if not in contact list
-							try {
-								contactService.createContactByIdentity(identity, true, AcquaintanceLevel.GROUP);
-							} catch (InvalidEntryException | EntryAlreadyExistsException | PolicyViolationException e) {
-								// do not add as distribution list member if contact cannot be created
+							// Fetch contact if not in contact list. Note that we do not add the
+							// contact to the distribution list if it couldn't be created.
+							ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+								identity,
+								AcquaintanceLevel.DIRECT,
+								userService.getIdentity(),
+								apiConnector,
+								contactModelRepository,
+								AddContactRestrictionPolicy.IGNORE,
+								context,
+								null
+							).runSynchronously();
+
+							if (!(result instanceof ContactAvailable)) {
+								logger.error("Contact {} could not be created", identity);
 								continue;
 							}
 						}
@@ -1331,7 +1368,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 
 		contact.put(TAG_SAFE_CONTACT_IDENTITY, contactModel.getIdentity());
 		boolean contactIsVerified = contactModel.verificationLevel == VerificationLevel.FULLY_VERIFIED;
-		boolean contactIsRevoked = contactModel.getState() == ContactModel.State.INVALID;
+		boolean contactIsRevoked = contactModel.getState() == IdentityState.INVALID;
 		if (contactIsVerified || contactIsRevoked) {
 			// Back up the public key if the contact is verified, or if it's revoked.
 			//
@@ -1358,7 +1395,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		contact.put(TAG_SAFE_CONTACT_HIDDEN, contactModel.getAcquaintanceLevel() == AcquaintanceLevel.GROUP);
 		contact.put(TAG_SAFE_CONTACT_TYPING_INDICATORS, contactModel.getTypingIndicators());
 		contact.put(TAG_SAFE_CONTACT_READ_RECEIPTS, contactModel.getReadReceipts());
-		contact.put(TAG_SAFE_CONTACT_PRIVATE, hiddenChatsListService.has(contactService.getUniqueIdString(contactModel)));
+		contact.put(TAG_SAFE_CONTACT_PRIVATE, hiddenChatsListService.has(ContactUtil.getUniqueIdString(contactModel.getIdentity())));
 
 		return contact;
 	}
@@ -1375,11 +1412,13 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		return contactsArray;
 	}
 
-	private JSONArray getGroupMembers(String[] groupMembers) {
+	private JSONArray getGroupMembers(String[] groupMembers, @Nullable String ignoreIdentity) {
 		JSONArray membersArray = new JSONArray();
 
 		for (final String groupMember : groupMembers) {
-			membersArray.put(groupMember);
+			if (!groupMember.equals(ignoreIdentity)) {
+				membersArray.put(groupMember);
+			}
 		}
 
 		return membersArray;
@@ -1398,7 +1437,15 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		} else {
 			group.put(TAG_SAFE_GROUP_CREATED_AT, 0);
 		}
-		group.put(TAG_SAFE_GROUP_MEMBERS, getGroupMembers(this.groupService.getGroupIdentities(groupModel)));
+		JSONArray groupMembers;
+		if (groupModel.getUserState() == MEMBER) {
+			// In case the user is a member, we should include the user in the list
+			groupMembers = getGroupMembers(this.groupService.getGroupIdentities(groupModel), null);
+		} else {
+			// If the user is no member, we do not include the user's identity
+			groupMembers = getGroupMembers(this.groupService.getGroupIdentities(groupModel), userService.getIdentity());
+		}
+		group.put(TAG_SAFE_GROUP_MEMBERS, groupMembers);
 		group.put(TAG_SAFE_GROUP_DELETED, groupModel.isDeleted());
 		if (groupModel.getLastUpdate() != null) {
 			group.put(TAG_SAFE_GROUP_LAST_UPDATE, groupModel.getLastUpdate().getTime());
@@ -1519,7 +1566,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 		user.put(TAG_SAFE_USER_NICKNAME, userService.getPublicNickname());
 
 		try {
-			Bitmap image = fileService.getContactAvatar(contactService.getMe().getIdentity());
+			Bitmap image = fileService.getUserDefinedProfilePicture(contactService.getMe().getIdentity());
 			if (image != null) {
 				// scale image - assume profile pics are always square
 				if (Math.max(image.getWidth(), image.getHeight()) > PROFILEPIC_MAX_WIDTH) {
@@ -1531,7 +1578,7 @@ public class ThreemaSafeServiceImpl implements ThreemaSafeService {
 					case PROFILEPIC_RELEASE_EVERYONE:
 						profilePicRelease.put(PROFILE_PIC_RELEASE_ALL_PLACEHOLDER);
 						break;
-					case PROFILEPIC_RELEASE_SOME:
+					case PROFILEPIC_RELEASE_ALLOW_LIST:
 						for (String id: profilePicRecipientsService.getAll()) {
 							profilePicRelease.put(id);
 						}
diff --git a/app/src/main/java/ch/threema/app/ui/AckjiPopup.java b/app/src/main/java/ch/threema/app/ui/AckjiPopup.java
index 1ff706ba..6caebd5d 100644
--- a/app/src/main/java/ch/threema/app/ui/AckjiPopup.java
+++ b/app/src/main/java/ch/threema/app/ui/AckjiPopup.java
@@ -133,7 +133,7 @@ AckjiPopup extends PopupWindow implements View.OnClickListener {
                     if (!isMember) {
                         this.editButton.setVisibility(View.GONE);
                     }
-                    if (!isMember || groupService.getOtherMemberCount(groupModel) < 1) {
+                    if (!isMember || groupService.countMembersWithoutUser(groupModel) < 1) {
                         this.decButton.setVisibility(View.GONE);
                         this.ackButton.setVisibility(View.GONE);
                     }
diff --git a/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt b/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt
index bd469ee0..eea6410b 100644
--- a/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt
+++ b/app/src/main/java/ch/threema/app/ui/AudioProgressBarView.kt
@@ -51,8 +51,9 @@ import ch.threema.storage.models.AbstractMessageModel
 import kotlin.math.min
 import kotlin.math.roundToInt
 
+private val logger = LoggingUtil.getThreemaLogger("AudioProgressBarView")
+
 class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWaveformGeneratorTask.AudioWaveformGeneratorListener {
-    private val logger = LoggingUtil.getThreemaLogger("AudioProgressBarView")
 
     private var barHeight = 20
     private var barWidth = 5
@@ -62,7 +63,7 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
     private var state = 0
 
     private lateinit var barColor: ColorStateList
-    var barColorActivated = Color.TRANSPARENT
+    private var barColorActivated = Color.TRANSPARENT
     private lateinit var barPaint: Paint
     private lateinit var barPaintChecked: Paint
     private lateinit var barPaintActivated: Paint
@@ -76,8 +77,7 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
     private var messageModel: AbstractMessageModel? = null
     private var changeBounds: Transition = ChangeClipBounds()
 
-    // we calculate a sufficiently large number of samples upfront so we don't need to wait for onLayout
-    private val numPreCalculatedSamples = 30
+    private var numPreCalculatedSamples: Int = 0
 
     // radius of bar edges in px
     private val radius = 2F
@@ -107,6 +107,8 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
             recycle()
         }
 
+        numPreCalculatedSamples = guessSuitableAmountOfSamples(context)
+
         barPaint = Paint().apply {
             isAntiAlias = true
             color = if (Build.VERSION.SDK_INT >= 23) {
@@ -194,7 +196,16 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
         super.onDraw(canvas)
     }
 
-    private fun createEmptyBitmap() : Bitmap {
+    /**
+     *  We calculate a sufficiently large number of samples upfront so we don't need to wait for onLayout
+     *  to tell us the width of our view.
+     *  The number will adapt based on the devices screen width. Because on tablets we want to present more samples.
+     */
+    private fun guessSuitableAmountOfSamples(context: Context): Int {
+        return (30f + (context.resources.displayMetrics.widthPixels / 40f)).roundToInt()
+    }
+
+    private fun createEmptyBitmap(): Bitmap {
         val tmpBitmap = Bitmap.createBitmap(viewWidth, barHeight, Bitmap.Config.ARGB_8888)
         val unusedHeight: Float = (barHeight / 2F) - halfBarMinHeight
         val halfSpace = spaceWidth.toFloat() / 2F
@@ -202,23 +213,27 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
         for (i: Int in 0 until numSamples) {
             tmpBitmap.applyCanvas {
                 drawRoundRect(
-                        RectF(
-                                halfSpace + (i * (barWidth + spaceWidth)),
-                                unusedHeight,
-                                halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
-                                barHeight - unusedHeight
-                        ),
-                        radius,
-                        radius,
-                        barPaint
+                    RectF(
+                        halfSpace + (i * (barWidth + spaceWidth)),
+                        unusedHeight,
+                        halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
+                        barHeight - unusedHeight
+                    ),
+                    radius,
+                    radius,
+                    barPaint
                 )
             }
         }
         return tmpBitmap
     }
 
-    private fun createWaveformBitmap(samplesData: List<Float>) : Bitmap {
+    private fun createWaveformBitmap(samplesData: List<Float>): Bitmap {
         val tmpBitmap = Bitmap.createBitmap(viewWidth, barHeight, Bitmap.Config.ARGB_8888)
+        if (samplesData.size < numSamples) {
+            logger.warn("Insufficient amount of calculated samples: {} < {}", samplesData.size, numSamples)
+            return tmpBitmap
+        }
         val factor: Float = samplesData.size.toFloat() / numSamples.toFloat()
         val halfSpace = spaceWidth.toFloat() / 2F
         val halfBarHeight = barHeight / 2F
@@ -229,15 +244,15 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
 
             tmpBitmap.applyCanvas {
                 drawRoundRect(
-                        RectF(
-                                halfSpace + (i * (barWidth + spaceWidth)),
-                                unusedHeight,
-                                halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
-                                barHeight - unusedHeight
-                        ),
-                        radius,
-                        radius,
-                        barPaint
+                    RectF(
+                        halfSpace + (i * (barWidth + spaceWidth)),
+                        unusedHeight,
+                        halfSpace + (i * (barWidth + spaceWidth)) + barWidth,
+                        barHeight - unusedHeight
+                    ),
+                    radius,
+                    radius,
+                    barPaint
                 )
             }
         }
@@ -302,11 +317,11 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
 
         if (messageModel?.id != newMessageModel.id) {
             // recycled view
-            waveFormTask?.let {
-                if (it.getMessageId() == newMessageModel.id) {
+            waveFormTask?.let { task ->
+                if (task.getMessageId() == newMessageModel.id) {
                     return
                 } else {
-                    it.cancel()
+                    task.cancel()
                 }
             }
         }
@@ -319,17 +334,19 @@ class AudioProgressBarView : androidx.appcompat.widget.AppCompatSeekBar, AudioWa
             postInvalidate()
             visibility = VISIBLE
         } else {
-            waveFormTask?.let {
-                if (it.getMessageId() == newMessageModel.id) {
+            waveFormTask?.let { task ->
+                if (task.getMessageId() == newMessageModel.id) {
                     return
                 }
             }
 
             waveBitmap = null
             messageModel = newMessageModel
-            waveFormTask = AudioWaveformGeneratorTask(newMessageModel,
-                    numPreCalculatedSamples,
-                    this@AudioProgressBarView)
+            waveFormTask = AudioWaveformGeneratorTask(
+                newMessageModel,
+                numPreCalculatedSamples,
+                this@AudioProgressBarView
+            )
 
             ThreemaApplication.voiceMessageThumbnailExecutorService.execute(Thread(waveFormTask, "WaveformGenerator"))
         }
diff --git a/app/src/main/java/ch/threema/app/ui/AvatarEditView.java b/app/src/main/java/ch/threema/app/ui/AvatarEditView.java
index 22e48fac..ba2c0e50 100644
--- a/app/src/main/java/ch/threema/app/ui/AvatarEditView.java
+++ b/app/src/main/java/ch/threema/app/ui/AvatarEditView.java
@@ -85,10 +85,12 @@ import ch.threema.app.glide.AvatarOptions;
 import ch.threema.app.listeners.ContactListener;
 import ch.threema.app.listeners.ProfileListener;
 import ch.threema.app.managers.ListenerManager;
+import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.FileService;
 import ch.threema.app.services.GroupService;
 import ch.threema.app.services.PreferenceService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.AvatarConverterUtil;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.utils.ColorUtil;
@@ -99,6 +101,7 @@ import ch.threema.app.utils.MimeUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.GroupModel;
 
@@ -109,6 +112,7 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 	private static final int REQUEST_CODE_CAMERA = 43322;
 	private static final int REQUEST_CODE_CROP = 43323;
 	private static final String DIALOG_TAG_SAMSUNG_FIX = "samsung_fix";
+    private UserService userService;
 	private ContactService contactService;
 	private GroupService groupService;
 	private FileService fileService;
@@ -153,10 +157,12 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 		avatarData = new ViewModelProvider(getActivity()).get(AvatarEditViewModel.class);
 
 		try {
-			contactService = ThreemaApplication.getServiceManager().getContactService();
-			groupService = ThreemaApplication.getServiceManager().getGroupService();
-			fileService = ThreemaApplication.getServiceManager().getFileService();
-			preferenceService = ThreemaApplication.getServiceManager().getPreferenceService();
+            ServiceManager serviceManager = ThreemaApplication.requireServiceManager();
+            userService = serviceManager.getUserService();
+			contactService = serviceManager.getContactService();
+			groupService = serviceManager.getGroupService();
+			fileService = serviceManager.getFileService();
+			preferenceService = serviceManager.getPreferenceService();
 		} catch (Exception e) {
 			logger.error("Exception", e);
 			return;
@@ -179,7 +185,8 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 
 	private final ContactListener contactListener = new ContactListener() {
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
+            ContactModel contactModel = contactService.getByIdentity(identity);
 			if (contactModel != null && this.shouldHandleChange(contactModel.getIdentity())) {
 				RuntimeUtil.runOnUiThread(() -> loadAvatarForModel(contactModel, null));
 			}
@@ -229,19 +236,20 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 
 		try {
 			if (contactModel != null) {
-				// Get the custom avatar (or null if no custom avatar available)
-				Bitmap bitmap = getCustomContactAvatar(contactModel);
-				boolean isCustomAvatar = true;
-				if (bitmap == null) {
-					// Get default avatar as no custom avatar is available
-					bitmap = contactService.getAvatar(contactModel, new AvatarOptions.Builder()
-						.setHighRes(true)
-						.setReturnPolicy(AvatarOptions.DefaultAvatarPolicy.DEFAULT_FALLBACK)
-						.setDarkerBackground(isAvatarEditable())
-						.toOptions()
-					);
-					isCustomAvatar = false;
-				}
+				// Respect the settings for getting the profile picture.
+				Bitmap bitmap = contactService.getAvatar(contactModel, new AvatarOptions.Builder()
+					.setHighRes(true)
+					.setReturnPolicy(AvatarOptions.DefaultAvatarPolicy.DEFAULT_FALLBACK)
+					.setDarkerBackground(isAvatarEditable())
+					.toOptions()
+				);
+
+				// If the preferences allow showing the profile pictures, then check if there is a
+				// profile picture available for the contact. Otherwise, check whether there is a
+				// locally saved avatar.
+				boolean isCustomAvatar =
+					(preferenceService.getProfilePicReceive() && fileService.hasContactDefinedProfilePicture(contactModel.getIdentity()))
+						|| fileService.hasUserDefinedProfilePicture(contactModel.getIdentity());
 
 				// If it is my profile picture then make it round
 				if (isMyProfilePicture) {
@@ -282,49 +290,6 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 		avatarEditOverlay.setVisibility(editable ? View.VISIBLE : View.GONE);
 	}
 
-	/**
-	 * Get the custom contact avatar. The size is automatically scaled down to the maximum possible
-	 * size if it was too large. Due to a bug in compression some avatars may be too large and then
-	 * the application crashes when displaying them in full size.
-	 *
-	 * Updates the avatar if it needs to be resized (only if it is my profile picture).
-	 *
-	 * If there is no custom avatar set for the contact, null is returned.
-	 */
-	@Nullable
-	private Bitmap getCustomContactAvatar(@NonNull ContactModel contactModel) {
-		Bitmap customAvatar = contactService.getAvatar(contactModel, new AvatarOptions.Builder()
-			.setHighRes(true)
-			.setReturnPolicy(AvatarOptions.DefaultAvatarPolicy.CUSTOM_AVATAR)
-			.toOptions()
-		);
-
-		Bitmap scaledAvatar = scaleToSize(customAvatar);
-		if (scaledAvatar != null && scaledAvatar != customAvatar && isLocallySavedAvatar(contactModel)) {
-			try {
-				logger.info("Updating resized contact avatar");
-				contactService.setAvatar(contactModel, BitmapUtil.bitmapToByteArray(scaledAvatar, Bitmap.CompressFormat.PNG, 100));
-			} catch (Exception e) {
-				logger.error("Could not update avatar", e);
-			}
-		}
-
-		return scaledAvatar;
-	}
-
-	/**
-	 * Returns true if the locally saved avatar is displayed. The locally saved avatar is displayed
-	 * if it is my profile picture or there is a locally saved avatar available and the profile
-	 * pictures are hidden ('getProfilePicReceive-preference') or there is no profile picture.
-	 */
-	private boolean isLocallySavedAvatar(@NonNull ContactModel contactModel) {
-		boolean showProfilePictures = preferenceService.getProfilePicReceive();
-		boolean hasProfilePicture = fileService.hasContactPhotoFile(contactModel.getIdentity());
-		boolean hasLocallySavedAvatar = fileService.hasContactAvatarFile(contactModel.getIdentity());
-
-		return isMyProfilePicture || (hasLocallySavedAvatar && (!showProfilePictures || !hasProfilePicture));
-	}
-
 	/**
 	 * Get the custom contact avatar. The size is automatically scaled down to the maximum possible
 	 * size if it was too large. Due to a bug in compression some avatars may be too large and then
@@ -471,10 +436,16 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 			new AsyncTask<Void, Void, Void>() {
 				@Override
 				protected Void doInBackground(Void... voids) {
-					if (avatarData.getContactModel() != null) {
-						contactService.removeAvatar(avatarData.getContactModel());
-						fileService.removeContactPhoto(avatarData.getContactModel().getIdentity());
-					} else if (avatarData.getGroupModel() != null) {
+                    ContactModel contactModel = avatarData.getContactModel();
+                    if (contactModel != null) {
+                        if (userService.isMe(contactModel.getIdentity())) {
+                            userService.removeUserProfilePicture(TriggerSource.LOCAL);
+                        } else {
+                            contactService.removeUserDefinedProfilePicture(
+                                avatarData.getContactModel(), TriggerSource.LOCAL
+                            );
+                        }
+                    } else if (avatarData.getGroupModel() != null) {
 						saveGroupAvatar(null, true);
 					}
 					return null;
@@ -605,9 +576,20 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 							if (listenerRef.get() != null) {
 								listenerRef.get().onAvatarSet(avatarData.getCroppedFile());
 							} else {
-								if (this.avatarData.getContactModel() != null) {
+                                ContactModel contactModel = avatarData.getContactModel();
+								if (contactModel != null) {
 									try {
-										contactService.setAvatar(this.avatarData.getContactModel(), avatarData.getCroppedFile());
+                                        File profilePicture = avatarData.getCroppedFile();
+                                        if (profilePicture == null) {
+                                            logger.error("Cropped file for profile picture is null");
+                                            return;
+                                        }
+
+                                        if (userService.isMe(contactModel.getIdentity())) {
+                                            userService.setUserProfilePicture(profilePicture, TriggerSource.LOCAL);
+                                        } else {
+                                            contactService.setUserDefinedProfilePicture(contactModel, profilePicture, TriggerSource.LOCAL);
+                                        }
 										loadAvatarForModel(this.avatarData.getContactModel(), null);
 									} catch (Exception e) {
 										logger.error("Exception", e);
@@ -738,8 +720,8 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 	 */
 	private boolean hasAvatar() {
 		if (this.avatarData.getContactModel() != null) {
-			return fileService.hasContactAvatarFile(this.avatarData.getContactModel().getIdentity())
-				|| fileService.hasContactPhotoFile(this.avatarData.getContactModel().getIdentity());
+			return fileService.hasUserDefinedProfilePicture(this.avatarData.getContactModel().getIdentity())
+				|| fileService.hasContactDefinedProfilePicture(this.avatarData.getContactModel().getIdentity());
 		} else if (this.avatarData.getGroupModel() != null) {
 			return fileService.hasGroupAvatarFile(this.avatarData.getGroupModel());
 		}
@@ -754,7 +736,7 @@ public class AvatarEditView extends FrameLayout implements DefaultLifecycleObser
 		if (this.avatarData.getContactModel() != null) {
 			return isEditable && ContactUtil.canHaveCustomAvatar(this.avatarData.getContactModel())
 				&& !(preferenceService.getProfilePicReceive()
-				&& fileService.hasContactPhotoFile(this.avatarData.getContactModel().getIdentity()));
+				&& fileService.hasContactDefinedProfilePicture(this.avatarData.getContactModel().getIdentity()));
 		} else if (this.avatarData.getGroupModel() != null) {
 			GroupModel group = avatarData.getGroupModel();
 			return isEditable && groupService.isGroupCreator(group) && groupService.isGroupMember(group);
diff --git a/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java b/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java
index f49d99a5..9a703972 100644
--- a/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java
+++ b/app/src/main/java/ch/threema/app/ui/AvatarListItemUtil.java
@@ -63,7 +63,7 @@ public class AvatarListItemUtil {
 			contactService.loadAvatarIntoImage(
 				conversationModel.getContact(),
 				avatarView,
-				AvatarOptions.PRESET_RESPECT_SETTINGS,
+				AvatarOptions.PRESET_DEFAULT_FALLBACK,
 				requestManager
 			);
 		} else if (conversationModel.isGroupConversation()) {
@@ -115,7 +115,7 @@ public class AvatarListItemUtil {
 
 		AvatarOptions options;
 		if (model instanceof ContactModel) {
-			options = AvatarOptions.PRESET_RESPECT_SETTINGS;
+			options = AvatarOptions.PRESET_DEFAULT_FALLBACK;
 		} else if (model instanceof GroupModel) {
 			options = AvatarOptions.PRESET_DEFAULT_FALLBACK;
 		} else {
diff --git a/app/src/main/java/ch/threema/app/ui/ControllerView.java b/app/src/main/java/ch/threema/app/ui/ControllerView.java
index 7ea4bced..4e042226 100644
--- a/app/src/main/java/ch/threema/app/ui/ControllerView.java
+++ b/app/src/main/java/ch/threema/app/ui/ControllerView.java
@@ -104,7 +104,6 @@ public class ControllerView extends MaterialCardView {
 
     private void initProgressBars() {
         progressBarIndeterminate.setIndicatorColor(getProgressTrackIndicatorColor());
-        progressBarDeterminate.setTrackColor(getProgressTrackColor());
         progressBarDeterminate.setIndicatorColor(getProgressTrackIndicatorColor());
     }
 
@@ -260,68 +259,28 @@ public class ControllerView extends MaterialCardView {
         }
     }
 
-    /**
-     * We only want to apply dynamic colors if the current view is used to
-     * render an outbox message and they are enabled by the threema setting.
-     * This workaround is necessary because we actually use different color
-     * references when this returns true.
-     */
-    private boolean shouldUseDynamicColors() {
-        return isUsedForOutboxMessage && ColorUtil.areDynamicColorsCurrentlyApplied(getContext());
-    }
-
-    /**
-     *  We do this color workaround to render this view on the left side of the chat in its fixed colors (old way)
-     *  and on the right side with the <strong>possibility</strong> to show itself in dynamic colors.
-     */
     private @ColorInt int getBackgroundDefaultColor() {
-        if (shouldUseDynamicColors()) {
-            return ConfigUtils.getColorFromAttribute(getContext(), R.attr.colorPrimary);
-        } else {
-            return getResources().getColor(
-                ColorUtil.shouldUseDarkVariant(getContext())
-                    ? R.color.md_theme_dark_tertiaryContainer
-                    : R.color.md_theme_light_tertiaryContainer
-            );
-        }
-    }
-
-    /**
-     *  We do this color workaround to render this view on the left side of the chat in its fixed colors (old way)
-     *  and on the right side with the <strong>possibility</strong> to show itself in dynamic colors.
-     */
-    private @ColorInt int getProgressTrackColor() {
-        if (shouldUseDynamicColors()) {
-            return ConfigUtils.getColorFromAttribute(getContext(), R.attr.colorSurfaceBright);
-        } else {
-            return getResources().getColor(
-                ColorUtil.shouldUseDarkVariant(getContext())
-                    ? R.color.md_theme_dark_primaryContainer
-                    : R.color.md_theme_light_primaryContainer
-            );
-        }
+        return ConfigUtils.getColorFromAttribute(
+            getContext(),
+            ColorUtil.areDynamicColorsCurrentlyApplied(getContext())
+                ? R.attr.colorPrimary
+                : R.attr.colorTertiaryContainer
+        );
     }
 
-    /**
-     *  We do this color workaround to render this view on the left side of the chat in its fixed colors (old way)
-     *  and on the right side with the <strong>possibility</strong> to show itself in dynamic colors.
-     */
     private @ColorInt int getProgressTrackIndicatorColor() {
-        if (shouldUseDynamicColors()) {
-            return ConfigUtils.getColorFromAttribute(getContext(), R.attr.colorOnPrimary);
-        } else {
-            return getResources().getColor(
-                ColorUtil.shouldUseDarkVariant(getContext())
-                    ? R.color.md_theme_dark_primary
-                    : R.color.md_theme_light_primary
-            );
-        }
+        return ConfigUtils.getColorFromAttribute(
+            getContext(),
+            ColorUtil.areDynamicColorsCurrentlyApplied(getContext())
+                ? R.attr.colorOnPrimary
+                : R.attr.colorPrimary
+        );
     }
 
     private @ColorInt int getIconTintColor() {
         return ConfigUtils.getColorFromAttribute(
             getContext(),
-            shouldUseDynamicColors()
+            ColorUtil.areDynamicColorsCurrentlyApplied(getContext())
                 ? R.attr.colorOnPrimary
                 : R.attr.colorOnBackground
         );
diff --git a/app/src/main/java/ch/threema/app/ui/CustomTextSelectionCallback.kt b/app/src/main/java/ch/threema/app/ui/CustomTextSelectionCallback.kt
deleted file mode 100644
index 7b3937ac..00000000
--- a/app/src/main/java/ch/threema/app/ui/CustomTextSelectionCallback.kt
+++ /dev/null
@@ -1,32 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.ui
-
-import android.view.ActionMode
-import android.widget.TextView
-
-abstract class CustomTextSelectionCallback : ActionMode.Callback {
-    protected var textView: TextView? = null
-    fun setTextViewRef(textView: TextView) {
-        this.textView = textView
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt b/app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt
deleted file mode 100644
index 9991a8ed..00000000
--- a/app/src/main/java/ch/threema/app/ui/MentionSelectorPopup.kt
+++ /dev/null
@@ -1,312 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.ui
-
-import android.annotation.SuppressLint
-import android.app.Activity
-import android.content.Context
-import android.graphics.Color
-import android.graphics.drawable.ColorDrawable
-import android.text.Editable
-import android.text.TextUtils
-import android.text.TextWatcher
-import android.view.Gravity
-import android.view.LayoutInflater
-import android.view.View
-import android.view.ViewGroup
-import android.view.ViewTreeObserver.OnGlobalLayoutListener
-import android.view.WindowManager.BadTokenException
-import androidx.core.view.ViewCompat
-import androidx.recyclerview.widget.LinearLayoutManager
-import androidx.recyclerview.widget.RecyclerView
-import androidx.window.layout.WindowMetricsCalculator
-import ch.threema.app.R
-import ch.threema.app.adapters.MentionSelectorAdapter
-import ch.threema.app.collections.Functional
-import ch.threema.app.collections.IPredicateNonNull
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.GroupService
-import ch.threema.app.services.PreferenceService
-import ch.threema.app.services.UserService
-import ch.threema.app.utils.AnimationUtil
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.ContactUtil
-import ch.threema.app.utils.NameUtil
-import ch.threema.app.utils.TestUtil
-import ch.threema.storage.models.ContactModel
-import ch.threema.storage.models.GroupModel
-import com.google.android.material.card.MaterialCardView
-import com.google.android.material.textfield.TextInputLayout
-import java.util.Locale
-
-@SuppressLint("InflateParams")
-class MentionSelectorPopup(
-    private val context: Context,
-    private val mentionSelectorListener: MentionSelectorListener?,
-    private val groupService: GroupService,
-    private val contactService: ContactService,
-    private val userService: UserService,
-    private val preferenceService: PreferenceService,
-    private val groupModel: GroupModel
-) : MovingPopupWindow(context), MentionSelectorAdapter.OnClickListener {
-    private var mentionAdapter: MentionSelectorAdapter? = null
-    private var filterText: String = ""
-    private var filterStart: Int = 0
-    private val recyclerView: RecyclerView
-    private val allContactModel: ContactModel =
-        ContactModel(ContactService.ALL_USERS_PLACEHOLDER_ID, byteArrayOf())
-    private var editText: ComposeEditText? = null
-    private val popupLayout: MaterialCardView
-    private var viewableSpaceHeight = 0
-    private var overlayMode = false // whether this popup is shown on top of another popupwindow
-    private val textWatcher: TextWatcher = object : TextWatcher {
-        private fun run() {
-            dismiss()
-        }
-
-        override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
-
-        override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
-            try {
-                if (count == 0 && start == 0) { // @ at first position is deleted
-                    editText?.post { this.run() }
-                    return
-                }
-                val last = s[start - 1]
-                if (count == 0 && (' ' == last || '\n' == last) || count == 1 && (' ' == s[start] || '\n' == s[start])) { // if spacebar or newline is added, escape the mention popup.
-                    editText?.post { this.run() }
-                }
-            } catch (e: IndexOutOfBoundsException) {
-                // don't care, happens when deleting a char after the @ the first time around
-                // hacky because there is no other logic with the listener callback that would not mess with the rest of the logic.
-            }
-        }
-
-        override fun afterTextChanged(s: Editable) {
-            if (TextUtils.isEmpty(s)) { // if text field is completely empty
-                editText?.post { this.run() }
-            } else if (s.toString() != filterText) {
-                val filterTextAfterAtChar: String?
-                var spacePosition = -1
-                try {
-                    filterTextAfterAtChar = s.toString().substring(filterStart)
-                    if (!TestUtil.isEmptyOrNull(filterTextAfterAtChar)) {
-                        spacePosition = filterTextAfterAtChar.indexOf(" ")
-                        if (spacePosition == -1) {
-                            spacePosition = filterTextAfterAtChar.indexOf("\n")
-                        }
-                    }
-                } catch (e: IndexOutOfBoundsException) {
-                    //
-                }
-                filterText = if (spacePosition != -1) {
-                    s.toString().substring(0, filterStart + spacePosition)
-                } else {
-                    s.toString()
-                }
-                updateList(false)
-                updateRecyclerViewDimensions()
-            }
-        }
-    }
-
-    init {
-        popupLayout = LayoutInflater.from(context).inflate(R.layout.popup_mention_selector, null, false) as MaterialCardView
-        contentView = popupLayout
-        inputMethodMode = INPUT_METHOD_NOT_NEEDED
-        animationStyle = 0
-        isFocusable = false
-        isTouchable = true
-        isOutsideTouchable = false
-        setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
-        @Suppress("DEPRECATION")
-        setWindowLayoutMode(0, ViewGroup.LayoutParams.WRAP_CONTENT)
-        height = 1
-
-        allContactModel.setName(context.getString(R.string.all), "")
-        allContactModel.state = ContactModel.State.ACTIVE
-        filterText = ""
-        filterStart = 0
-
-        recyclerView = popupLayout.findViewById(R.id.group_members_list)
-        val linearLayoutManager = LinearLayoutManager(context)
-        linearLayoutManager.stackFromEnd = true
-        recyclerView.layoutManager = linearLayoutManager
-        recyclerView.itemAnimator = null
-
-        val adapter = updateList(true)
-        if (adapter != null) {
-            recyclerView.adapter = adapter
-        }
-    }
-
-    fun show(activity: Activity, editText: ComposeEditText, anchorView: TextInputLayout?) {
-        super.show(activity, anchorView)
-
-        if (mentionAdapter == null) {
-            dismiss()
-            return
-        }
-
-        if (anchorView != null) {
-            popupLayout.setCardBackgroundColor(anchorView.boxBackgroundColor)
-            overlayMode =
-                if (anchorView.boxCornerRadiusTopStart == anchorView.resources.getDimensionPixelSize(R.dimen.compose_textinputlayout_radius_expanded)
-                        .toFloat()
-                ) {
-                    true
-                } else {
-                    anchorView.setBoxCornerRadiiResources(
-                        R.dimen.compose_textinputlayout_radius_expanded,
-                        R.dimen.compose_textinputlayout_radius_expanded,
-                        R.dimen.compose_textinputlayout_radius,
-                        R.dimen.compose_textinputlayout_radius
-                    )
-                    false
-                }
-        }
-
-        val coordinates = ConfigUtils.getPopupWindowPositionAboveAnchor(activity, anchorView ?: editText)
-        val popupX = if (anchorView == null) 0 else coordinates[0]
-        var popupY = coordinates[1]
-
-        if (anchorView == null) {
-            popupY += context.resources.getDimensionPixelSize(R.dimen.compose_bottom_panel_padding_bottom)
-        }
-
-        this.editText = editText
-        editText.setLocked(true)
-        editText.addTextChangedListener(textWatcher)
-        filterStart = editText.selectionStart
-        viewableSpaceHeight = coordinates[2] - context.resources.getDimensionPixelSize(R.dimen.compose_bottom_panel_padding_bottom)
-        this.width =
-            if (anchorView == null) WindowMetricsCalculator.getOrCreate().computeCurrentWindowMetrics(activity).bounds.width()
-            else editText.width
-        this.height = viewableSpaceHeight
-
-        try {
-            showAtLocation(editText, Gravity.LEFT or Gravity.BOTTOM, popupX, popupY)
-            contentView.viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener {
-                override fun onGlobalLayout() {
-                    contentView.viewTreeObserver.removeOnGlobalLayoutListener(this)
-                    AnimationUtil.slideInAnimation(contentView, true, 150)
-                }
-            })
-            this.anchorView?.let {
-                ViewCompat.setWindowInsetsAnimationCallback(
-                    it,
-                    windowInsetsAnimationCallback
-                )
-                it.addOnLayoutChangeListener(onLayoutChangeListener)
-            }
-        } catch (e: BadTokenException) {
-            //
-        }
-    }
-
-    private fun updateRecyclerViewDimensions() {
-        val maxHeight = context.resources.getDimensionPixelSize(R.dimen.group_detail_list_item_size) * (mentionAdapter?.itemCount ?: 1)
-        recyclerView.layoutParams.height = maxHeight.coerceAtMost(viewableSpaceHeight)
-        recyclerView.requestLayout()
-    }
-
-    private fun updateList(init: Boolean): MentionSelectorAdapter? {
-        var groupContacts = contactService.getByIdentities(
-            groupService.getGroupIdentities(groupModel)
-        )
-        val isSortingFirstName = preferenceService.isContactListSortingFirstName
-
-        groupContacts.sortWith { model1: ContactModel?, model2: ContactModel? ->
-            ContactUtil.getSafeNameString(model1, isSortingFirstName).compareTo(
-                ContactUtil.getSafeNameString(model2, isSortingFirstName)
-            )
-        }
-        groupContacts.add(allContactModel)
-
-        if (!init && filterText.length - filterStart > 0) {
-            groupContacts = Functional.filter(groupContacts,
-                IPredicateNonNull { contactModel: ContactModel ->
-                    val lowercaseName =
-                        filterText.substring(filterStart).lowercase(Locale.getDefault())
-                    if (userService.isMe(contactModel.identity) && NameUtil.getQuoteName(
-                            contactModel,
-                            userService
-                        ).lowercase(Locale.getDefault()).contains(lowercaseName)
-                    ) {
-                        return@IPredicateNonNull true
-                    }
-                    ContactUtil.getSafeNameString(contactModel, isSortingFirstName)
-                        .lowercase(Locale.getDefault()).contains(lowercaseName)
-                })
-        }
-
-        if (groupContacts.isEmpty()) { // just show all selector as default placeholder if there are no more specific results
-            groupContacts.add(allContactModel)
-        }
-
-        if (mentionAdapter == null) {
-            mentionAdapter = MentionSelectorAdapter(context, userService, contactService, groupService, groupModel)
-            mentionAdapter?.setOnClickListener(this)
-        }
-
-        mentionAdapter?.setData(groupContacts)
-
-        return mentionAdapter
-    }
-
-    override fun onItemClick(v: View, contactModel: ContactModel) {
-        val identity = contactModel.identity
-        if (mentionSelectorListener != null) {
-            dismiss()
-            mentionSelectorListener.onContactSelected(
-                identity,
-                filterText.length - filterStart + 1,
-                if (filterStart > 0) filterStart - 1 else 0
-            )
-        }
-    }
-
-    override fun dismiss() {
-        anchorView?.let {
-            if (!overlayMode) {
-                it.setBoxCornerRadiiResources(
-                    R.dimen.compose_textinputlayout_radius,
-                    R.dimen.compose_textinputlayout_radius,
-                    R.dimen.compose_textinputlayout_radius,
-                    R.dimen.compose_textinputlayout_radius
-                )
-                it.removeOnLayoutChangeListener(onLayoutChangeListener)
-                ViewCompat.setWindowInsetsAnimationCallback(it, null)
-            }
-        }
-
-        editText?.let {
-            it.removeTextChangedListener(textWatcher)
-            it.setLocked(false)
-        }
-        super.dismiss()
-    }
-
-    interface MentionSelectorListener {
-        fun onContactSelected(identity: String?, length: Int, insertPosition: Int)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/ui/MovingPopupWindow.kt b/app/src/main/java/ch/threema/app/ui/MovingPopupWindow.kt
deleted file mode 100644
index 04b3552f..00000000
--- a/app/src/main/java/ch/threema/app/ui/MovingPopupWindow.kt
+++ /dev/null
@@ -1,96 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.ui
-
-import android.app.Activity
-import android.content.Context
-import android.view.View.OnLayoutChangeListener
-import android.widget.PopupWindow
-import androidx.core.view.WindowInsetsAnimationCompat
-import androidx.core.view.WindowInsetsCompat
-import ch.threema.app.utils.ConfigUtils
-import com.google.android.material.textfield.TextInputLayout
-
-/**
- * A PopupWindow that moves with its anchor view
- */
-abstract class MovingPopupWindow(context: Context?) : PopupWindow(context) {
-    protected lateinit var activity: Activity
-    protected var lastY = 0
-    protected var anchorView: TextInputLayout? = null
-
-    protected var onLayoutChangeListener =
-        OnLayoutChangeListener { _, _, _, _, _, _, _, _, _ ->
-            anchorView?.let {
-                val coordinates = ConfigUtils.getPopupWindowPositionAboveAnchor(
-                    activity,
-                    it
-                )
-                if (coordinates[1] != lastY) {
-                    update(coordinates[0], coordinates[1], -1, -1)
-                }
-                lastY = coordinates[1]
-            }
-        }
-
-    protected var windowInsetsAnimationCallback: WindowInsetsAnimationCompat.Callback =
-        object : WindowInsetsAnimationCompat.Callback(
-            DISPATCH_MODE_STOP
-        ) {
-            var startY = 0
-            override fun onPrepare(animation: WindowInsetsAnimationCompat) {
-                super.onPrepare(animation)
-                anchorView?.let {
-                    val coordinates = ConfigUtils.getPopupWindowPositionAboveAnchor(
-                        activity,
-                        it
-                    )
-                    startY = coordinates[1]
-                    lastY = 0
-                }
-            }
-
-            override fun onProgress(
-                insets: WindowInsetsCompat,
-                runningAnimations: List<WindowInsetsAnimationCompat>
-            ): WindowInsetsCompat {
-                anchorView?.let {
-                    val coordinates = ConfigUtils.getPopupWindowPositionAboveAnchor(
-                        activity,
-                        it
-                    )
-                    if (coordinates[1] != lastY &&
-                        coordinates[1] != startY
-                    ) {
-                        update(coordinates[0], coordinates[1], -1, -1)
-                    }
-                    lastY = coordinates[1]
-                }
-                return insets
-            }
-        }
-
-    protected fun show(activity: Activity, anchorView: TextInputLayout?) {
-        this.activity = activity
-        this.anchorView = anchorView
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/ui/QuotePopup.kt b/app/src/main/java/ch/threema/app/ui/QuotePopup.kt
deleted file mode 100644
index 32dc5a53..00000000
--- a/app/src/main/java/ch/threema/app/ui/QuotePopup.kt
+++ /dev/null
@@ -1,203 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.ui
-
-import android.annotation.SuppressLint
-import android.app.Activity
-import android.content.Context
-import android.graphics.Color
-import android.graphics.drawable.ColorDrawable
-import android.view.Gravity
-import android.view.LayoutInflater
-import android.view.View
-import android.view.ViewGroup
-import android.view.ViewTreeObserver.OnGlobalLayoutListener
-import android.view.WindowManager.BadTokenException
-import android.widget.ImageView
-import android.widget.TextView
-import androidx.annotation.ColorInt
-import androidx.core.view.ViewCompat
-import ch.threema.app.R
-import ch.threema.app.cache.ThumbnailCache
-import ch.threema.app.emojis.EmojiMarkupUtil
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.FileService
-import ch.threema.app.services.UserService
-import ch.threema.app.utils.ConfigUtils
-import ch.threema.app.utils.MessageUtil
-import ch.threema.app.utils.NameUtil
-import ch.threema.app.utils.QuoteUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.storage.models.AbstractMessageModel
-import com.google.android.material.card.MaterialCardView
-import com.google.android.material.textfield.TextInputLayout
-
-private val logger = LoggingUtil.getThreemaLogger("QuotePopup")
-
-@SuppressLint("InflateParams")
-class QuotePopup(
-    private val context: Context,
-    private val contactService: ContactService,
-    private val userService: UserService,
-    private val fileService: FileService,
-    private val thumbnailCache: ThumbnailCache<*>
-) : MovingPopupWindow(context) {
-    private val quoteTextView: TextView
-    private val quoteIdentityView: TextView
-    private val quoteThumbnail: ImageView
-    private val quoteTypeImage: ImageView
-    private val quoteBar: View
-    private val popupLayout: MaterialCardView
-    private var quotePopupListener: QuotePopupListener? = null
-
-    class QuoteInfo {
-        var quoteText: String? = null
-        var quoteIdentity: String? = null
-        var messageModel: AbstractMessageModel? = null
-    }
-
-    val quoteInfo = QuoteInfo()
-
-    init {
-        popupLayout = LayoutInflater.from(context).inflate(R.layout.popup_quote, null, false) as MaterialCardView
-        quoteTextView = popupLayout.findViewById(R.id.quote_text_view)
-        quoteIdentityView = popupLayout.findViewById(R.id.quote_id_view)
-        quoteBar = popupLayout.findViewById(R.id.quote_bar)
-        quoteThumbnail = popupLayout.findViewById(R.id.quote_thumbnail)
-        quoteTypeImage = popupLayout.findViewById(R.id.quote_type_image)
-        val quoteCloseButton = popupLayout.findViewById<ImageView>(R.id.quote_panel_close_button)
-        quoteCloseButton.setOnClickListener { dismiss() }
-
-        contentView = popupLayout
-        inputMethodMode = INPUT_METHOD_NEEDED
-        animationStyle = R.style.Threema_Animation_QuotePopup
-        isFocusable = false
-        isTouchable = true
-        isOutsideTouchable = false
-        setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))
-        @Suppress("DEPRECATION")
-        setWindowLayoutMode(0, ViewGroup.LayoutParams.WRAP_CONTENT)
-        height = 1
-    }
-
-    fun show(
-        activity: Activity,
-        editText: ComposeEditText,
-        textInputLayout: TextInputLayout,
-        messageModel: AbstractMessageModel?,
-        identity: String?,
-        @ColorInt color: Int,
-        listener: QuotePopupListener?
-    ) {
-        this.quotePopupListener = listener
-
-        super.show(activity, textInputLayout)
-
-        popupLayout.setCardBackgroundColor(textInputLayout.boxBackgroundColor)
-        val coordinates = ConfigUtils.getPopupWindowPositionAboveAnchor(activity, textInputLayout)
-        val popupX = coordinates[0]
-        val popupY = coordinates[1]
-        val viewableSpaceHeight = coordinates[2] - context.resources.getDimensionPixelSize(R.dimen.compose_bottom_panel_padding_bottom)
-        this.width = editText.width
-        this.height = viewableSpaceHeight
-
-        try {
-            showAtLocation(editText, Gravity.LEFT or Gravity.BOTTOM, popupX, popupY)
-            adjustCornersToOpenState(textInputLayout, 20)
-            contentView.viewTreeObserver.addOnGlobalLayoutListener(object : OnGlobalLayoutListener {
-                override fun onGlobalLayout() {
-                    contentView?.viewTreeObserver?.removeOnGlobalLayoutListener(this)
-                    listener?.onHeightSet(popupLayout.measuredHeight)
-                }
-            })
-            anchorView?.let {
-                ViewCompat.setWindowInsetsAnimationCallback(it, windowInsetsAnimationCallback)
-                it.addOnLayoutChangeListener(onLayoutChangeListener)
-            }
-            adjustCornersToOpenState(textInputLayout, 200)
-        } catch (e: BadTokenException) {
-            //
-        }
-        quoteInfo.messageModel = messageModel
-        quoteInfo.quoteText = QuoteUtil.getMessageBody(quoteInfo.messageModel, true)
-        quoteInfo.quoteIdentity = identity
-        quoteIdentityView.text = NameUtil.getQuoteName(quoteInfo.quoteIdentity, contactService, userService)
-        quoteBar.setBackgroundColor(color)
-        quoteTextView.text = EmojiMarkupUtil.getInstance().addTextSpans(activity, quoteInfo.quoteText, quoteTextView, false, false)
-        quoteThumbnail.visibility = View.GONE
-        quoteTypeImage.visibility = View.GONE
-
-        try {
-            val thumbnail = fileService.getMessageThumbnailBitmap(
-                messageModel,
-                thumbnailCache
-            )
-            if (thumbnail != null) {
-                quoteThumbnail.setImageBitmap(thumbnail)
-                quoteThumbnail.visibility = View.VISIBLE
-            }
-        } catch (ignore: Exception) {
-        }
-
-        val messageViewElement = MessageUtil.getViewElement(context, messageModel)
-        if (messageViewElement.icon != null) {
-            quoteTypeImage.setImageResource(messageViewElement.icon)
-            quoteTypeImage.visibility = View.VISIBLE
-        }
-
-        quotePopupListener?.onPostVisibilityChange()
-    }
-
-    fun adjustCornersToOpenState(layout: TextInputLayout, delayMs: Long) {
-        layout.postDelayed({
-            layout.setBoxCornerRadiiResources(
-                R.dimen.compose_textinputlayout_radius_expanded,
-                R.dimen.compose_textinputlayout_radius_expanded,
-                R.dimen.compose_textinputlayout_radius,
-                R.dimen.compose_textinputlayout_radius)
-        }, delayMs)
-    }
-
-    override fun dismiss() {
-        anchorView?.let {
-            it.postDelayed({
-                it.setBoxCornerRadiiResources(
-                    R.dimen.compose_textinputlayout_radius,
-                    R.dimen.compose_textinputlayout_radius,
-                    R.dimen.compose_textinputlayout_radius,
-                    R.dimen.compose_textinputlayout_radius
-                )
-            }, 200)
-            it.removeOnLayoutChangeListener(onLayoutChangeListener)
-            ViewCompat.setWindowInsetsAnimationCallback(it, null)
-        }
-        quotePopupListener?.onDismiss()
-        super.dismiss()
-        quotePopupListener?.onPostVisibilityChange()
-    }
-
-    interface QuotePopupListener {
-        fun onHeightSet(height : Int)
-        fun onDismiss()
-        fun onPostVisibilityChange()
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java b/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java
index adc5156e..c66cf866 100644
--- a/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java
+++ b/app/src/main/java/ch/threema/app/ui/VerificationLevelImageView.java
@@ -28,6 +28,8 @@ import androidx.annotation.NonNull;
 import ch.threema.app.R;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ContactUtil;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.storage.models.ContactModel;
 
 public class VerificationLevelImageView extends androidx.appcompat.widget.AppCompatImageView {
@@ -50,32 +52,47 @@ public class VerificationLevelImageView extends androidx.appcompat.widget.AppCom
 	}
 
 	/**
-	 * takes a ContactModel and sets the according verification
-	 * level image source and content description on the VerificationLevelImageView.
-	 * The ContactModel input contains a contacts' attributes name, publicKey etc.
-	 * @param ContactModel contact
+	 * Sets the view to the provided verification levels.
 	 */
-	public void setContactModel(@NonNull ContactModel contact){
-		setContentDescription(getVerificationLevelDescription(contact));
-		setImageDrawable(ContactUtil.getVerificationDrawable(context, contact));
+	public void setVerificationLevel(
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		setContentDescription(
+			getVerificationLevelDescription(
+				verificationLevel, workVerificationLevel
+			)
+		);
+		setImageDrawable(
+			ContactUtil.getVerificationDrawable(
+				context,
+				verificationLevel,
+				workVerificationLevel
+			)
+		);
 	}
 
 	/**
-	 * takes a ContactModel and gets the according verificationlevel description.
-	 * The ContactModel input contains a contacts' attributes name, publicKey etc.
-	 * @param ContactModel contactModel
+	 * Get the verification level description from the given verification level. This also depends
+	 * on the build and whether the contact is a work contact or not.
+	 *
 	 * @return String defined text in strings.xml for the according verification level
 	 */
-	private @NonNull String getVerificationLevelDescription(@NonNull ContactModel contactModel) {
-		switch (contactModel.verificationLevel) {
+	private @NonNull String getVerificationLevelDescription(
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		boolean isWorkVerifiedOnWorkBuild = ConfigUtils.isWorkBuild()
+			&& workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED;
+		switch (verificationLevel) {
 			case FULLY_VERIFIED:
-				if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
+				if (isWorkVerifiedOnWorkBuild) {
 					return context.getString(R.string.verification_level3_work_explain);
 				} else {
 					return context.getString(R.string.verification_level3_explain);
 				}
 			case SERVER_VERIFIED:
-				if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
+				if (isWorkVerifiedOnWorkBuild) {
 					return context.getString(R.string.verification_level2_work_explain);
 				}
 				return context.getString(R.string.verification_level2_explain);
diff --git a/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java b/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java
index ca18dc0d..6fc4c3b8 100644
--- a/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/AndroidContactUtil.java
@@ -27,7 +27,6 @@ import android.Manifest;
 import android.accounts.Account;
 import android.accounts.AccountManager;
 import android.accounts.AuthenticatorDescription;
-import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.ContentProviderOperation;
 import android.content.ContentResolver;
@@ -70,6 +69,7 @@ import ch.threema.app.services.FileService;
 import ch.threema.app.services.UserService;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModelData;
 import ch.threema.storage.models.ContactModel;
 
 public class AndroidContactUtil {
@@ -170,7 +170,7 @@ public class AndroidContactUtil {
 					try {
 						contactLookupUri = ContactsContract.Contacts.lookupContact(contentResolver, contactLookupUri);
 					} catch (Exception e) {
-						logger.error("Exception", e);
+						logger.error("Could not lookup the contact with identity {}", contactModel.getIdentity(), e);
 						return null;
 					}
 				}
@@ -181,14 +181,49 @@ public class AndroidContactUtil {
 	}
 
 	/**
-	 * Update the avatar for the specified contact from Android's contact database, if any
-	 * If there's no avatar for this Android contact, any current avatar on file will be deleted
+	 * Return a valid uri to the given contact that can be used to build an intent for the contact app
+	 * It is safe to call this method if permission to access contacts is not granted - null will be returned in that case
+	 *
+	 * @param contactModel ContactModel for which to get the Android contact URI
+	 * @return a valid uri pointing to the android contact or null if permission was not granted, no android contact is linked or android contact could not be looked up
+	 */
+	@Nullable
+	public Uri getAndroidContactUri(@NonNull ch.threema.data.models.ContactModel contactModel) {
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
+			ContextCompat.checkSelfPermission(ThreemaApplication.getAppContext(), Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+			return null;
+		}
+
+		ContactModelData data = contactModel.getData().getValue();
+
+		if (data != null) {
+			final String androidContactLookupKey = data.androidContactLookupKey;
+			if (androidContactLookupKey != null) {
+				Uri contactLookupUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_LOOKUP_URI, androidContactLookupKey);
+				if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.LOLLIPOP_MR1) {
+					try {
+						contactLookupUri = ContactsContract.Contacts.lookupContact(contentResolver, contactLookupUri);
+					} catch (Exception e) {
+						logger.error("Could not lookup the contact with identity {}", contactModel.getIdentity(), e);
+						return null;
+					}
+				}
+				return contactLookupUri;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Update the avatar for the specified contact from Android's contact database, if any.
+	 * If there's no avatar for this Android contact, any current avatar file will be deleted.
 	 *
 	 * It is safe to call this method even if permission to read contacts is not given
 	 *
 	 * @param contactModel ContactModel
 	 * @return true if setting or deleting the avatar was successful, false otherwise
 	 */
+	@RequiresPermission(Manifest.permission.READ_CONTACTS)
 	public boolean updateAvatarByAndroidContact(@NonNull ContactModel contactModel) {
 		if (fileService == null) {
 			logger.info("FileService not available");
@@ -203,19 +238,19 @@ public class AndroidContactUtil {
 		// contactUri will be null if permission is not granted
 		Uri contactUri = getAndroidContactUri(contactModel);
 		if (contactUri != null) {
-			@SuppressLint("MissingPermission") Bitmap bitmap = AvatarConverterUtil.convert(ThreemaApplication.getAppContext(), contactUri);
+			Bitmap bitmap = AvatarConverterUtil.convert(ThreemaApplication.getAppContext(), contactUri);
 
 			if (bitmap != null) {
 				try {
-					fileService.writeAndroidContactAvatar(contactModel.getIdentity(), BitmapUtil.bitmapToByteArray(bitmap, Bitmap.CompressFormat.PNG, 100));
+					fileService.writeAndroidDefinedProfilePicture(contactModel.getIdentity(), BitmapUtil.bitmapToByteArray(bitmap, Bitmap.CompressFormat.PNG, 100));
 					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
 					return true;
 				} catch (Exception e) {
-					logger.error("Exception", e);
+					logger.error("Could not write android contact avatar of contact {}", contactModel.getIdentity(), e);
 				}
 			} else {
 				// delete old avatar
-				boolean success = fileService.removeAndroidContactAvatar(contactModel.getIdentity());
+				boolean success = fileService.removeAndroidDefinedProfilePicture(contactModel.getIdentity());
 				if (success) {
 					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
 					return true;
@@ -227,38 +262,86 @@ public class AndroidContactUtil {
 		return false;
 	}
 
+	/**
+	 * Update the avatar for the specified contact from Android's contact database, if any.
+	 * If there's no avatar for this Android contact, any current avatar file will be deleted.
+	 *
+	 * It is safe to call this method even if permission to read contacts is not given
+	 *
+	 * @param contactModel ContactModel
+	 * @return true if setting or deleting the avatar was successful, false otherwise
+	 */
+	@RequiresPermission(Manifest.permission.READ_CONTACTS)
+	public void updateAvatarByAndroidContact(@NonNull ch.threema.data.models.ContactModel contactModel) {
+		if (fileService == null) {
+			logger.info("FileService not available");
+			return;
+		}
+
+		ContactModelData data = contactModel.getData().getValue();
+		if (data == null) {
+			logger.warn("Contact model data is null");
+			return;
+		}
+
+		final String androidContactLookupKey = data.androidContactLookupKey;
+		if (androidContactLookupKey == null) {
+			return;
+		}
+
+		// contactUri will be null if permission is not granted
+		Uri contactUri = getAndroidContactUri(contactModel);
+		if (contactUri != null) {
+			Bitmap bitmap = AvatarConverterUtil.convert(ThreemaApplication.getAppContext(), contactUri);
+
+			if (bitmap != null) {
+				try {
+					fileService.writeAndroidDefinedProfilePicture(contactModel.getIdentity(), BitmapUtil.bitmapToByteArray(bitmap, Bitmap.CompressFormat.PNG, 100));
+					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
+					return;
+				} catch (Exception e) {
+					logger.error("Exception", e);
+				}
+			} else {
+				// delete old avatar
+				boolean success = fileService.removeAndroidDefinedProfilePicture(contactModel.getIdentity());
+				if (success) {
+					contactModel.setLocalAvatarExpires(new Date(System.currentTimeMillis() + DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY));
+					return;
+				}
+			}
+		}
+
+		logger.debug("Unable to get avatar for {} lookupKey = {} contactUri = {}", contactModel.getIdentity(), androidContactLookupKey, contactUri);
+	}
+
 	/**
 	 * Update the name of this contact according to the name of the Android contact
-	 * Note that the ContactModel needs to be saved to the ContactStore to apply the changes!
 	 *
 	 * @param contactModel ContactModel
-	 * @return true if the name has changed, false otherwise
 	 */
 	@RequiresPermission(Manifest.permission.READ_CONTACTS)
-	public boolean updateNameByAndroidContact(@NonNull ContactModel contactModel) throws ThreemaException {
+	public void updateNameByAndroidContact(@NonNull ch.threema.data.models.ContactModel contactModel) throws ThreemaException {
+		ContactModelData data = contactModel.getData().getValue();
+		if (data == null) {
+			logger.warn("Contact model data is null");
+			return;
+		}
 		Uri namedContactUri = getAndroidContactUri(contactModel);
-		if(TestUtil.required(contactModel, namedContactUri)) {
-			ContactName contactName = this.getContactName(namedContactUri);
+		if (namedContactUri != null) {
+			ContactName contactName = getContactName(namedContactUri);
 
 			if (contactName == null) {
-				logger.info("Unable to get contact name for {} lookupKey = {} namedUri = {}", contactModel.getIdentity(), contactModel.getAndroidContactLookupKey(), namedContactUri);
+				logger.info("Unable to get contact name for {} lookupKey = {} namedUri = {}", contactModel.getIdentity(), data.androidContactLookupKey, namedContactUri);
 				// remove contact link to unresolvable contact
-				contactModel.setAndroidContactLookupKey(null);
+				contactModel.removeAndroidContactLink();
 				throw new ThreemaException("Unable to get contact name");
 			}
 
-			if(!TestUtil.compare(contactModel.getFirstName(), contactName.firstName)
-					|| !TestUtil.compare(contactModel.getLastName(), contactName.lastName)) {
-				contactModel.setFirstName(contactName.firstName);
-				contactModel.setLastName(contactName.lastName);
-				return true;
-			}
+			contactModel.setNameFromLocal(contactName.firstName, contactName.lastName);
 		} else {
-			if (contactModel != null) {
-				logger.info("Unable to get android contact uri for {} lookupkey = {}", contactModel.getIdentity(), contactModel.getAndroidContactLookupKey());
-			}
+			logger.info("Unable to get android contact uri for {} lookupKey = {}", contactModel.getIdentity(), data.androidContactLookupKey);
 		}
-		return false;
 	}
 
 	/**
@@ -415,12 +498,11 @@ public class AndroidContactUtil {
 	 *
 	 * @param contentProviderOperations List of ContentProviderOperations to add this operation to
 	 * @param systemRawContactId The raw contact that matched the criteria for aggregation (i.e. email or phone number)
-	 * @param contactModel ContactModel to create a raw contact for
+	 * @param identity the identity of the contact to create a raw contact for
 	 * @param supportsVoiceCalls Whether the user has voice calls enabled
 	 */
 	@RequiresPermission(allOf = {Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS})
-	public void createThreemaRawContact(@NonNull List<ContentProviderOperation> contentProviderOperations, long systemRawContactId, @NonNull ContactModel contactModel, boolean supportsVoiceCalls) {
-		String identity = contactModel.getIdentity();
+	public void createThreemaRawContact(@NonNull List<ContentProviderOperation> contentProviderOperations, long systemRawContactId, @NonNull String identity, boolean supportsVoiceCalls) {
 		Context context = ThreemaApplication.getAppContext();
 		Account account = this.getAccount();
 		if (!TestUtil.required(account, identity)) {
@@ -487,10 +569,10 @@ public class AndroidContactUtil {
 	 * Delete all raw contacts where the given identity matches the entry in the contact's SYNC1 column
 	 * It's safe to call this method without contacts permission
 	 *
-	 * @param contactModel ContactModel whose raw contact we want to be deleted
+	 * @param identity the identity of the contact whose raw contact we want to be deleted
 	 * @return number of raw contacts deleted
 	 */
-	public int deleteThreemaRawContact(@NonNull ContactModel contactModel) {
+	public int deleteThreemaRawContact(@NonNull String identity) {
 		if (!ConfigUtils.isPermissionGranted(ThreemaApplication.getAppContext(), Manifest.permission.WRITE_CONTACTS)) {
 			return 0;
 		}
@@ -503,7 +585,7 @@ public class AndroidContactUtil {
 		Uri rawContactUri = ContactsContract.RawContacts.CONTENT_URI
 			.buildUpon()
 			.appendQueryParameter(ContactsContract.CALLER_IS_SYNCADAPTER, "true")
-			.appendQueryParameter(ContactsContract.RawContacts.SYNC1, contactModel.getIdentity())
+			.appendQueryParameter(ContactsContract.RawContacts.SYNC1, identity)
 			.appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_NAME, account.name)
 			.appendQueryParameter(ContactsContract.RawContacts.ACCOUNT_TYPE, account.type).build();
 
@@ -684,7 +766,7 @@ public class AndroidContactUtil {
 	@RequiresPermission(allOf = {Manifest.permission.READ_CONTACTS, Manifest.permission.GET_ACCOUNTS})
 	@Nullable
 	@WorkerThread
-	public Drawable getAccountIcon(@NonNull ContactModel contactModel) {
+	public Drawable getAccountIcon(@Nullable String androidContactLookupKey) {
 		final PackageManager pm = ThreemaApplication.getAppContext().getPackageManager();
 
 		Account myAccount = this.getAccount();
@@ -692,7 +774,6 @@ public class AndroidContactUtil {
 			return null;
 		}
 
-		final String androidContactLookupKey = contactModel.getAndroidContactLookupKey();
 		if (androidContactLookupKey == null) {
 			return null;
 		}
diff --git a/app/src/main/java/ch/threema/app/utils/ApplicationExitInfoUtil.kt b/app/src/main/java/ch/threema/app/utils/ApplicationExitInfoUtil.kt
deleted file mode 100644
index 9e968391..00000000
--- a/app/src/main/java/ch/threema/app/utils/ApplicationExitInfoUtil.kt
+++ /dev/null
@@ -1,97 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-import android.app.ApplicationExitInfo
-import android.os.Build
-import android.system.OsConstants
-import androidx.annotation.RequiresApi
-
-object ApplicationExitInfoUtil {
-    @RequiresApi(Build.VERSION_CODES.R)
-    @JvmStatic
-    fun getStatusText(exitInfo: ApplicationExitInfo): String {
-        val status = exitInfo.status
-        return when (status) {
-            OsConstants.SIGABRT -> "SIGABRT"
-            OsConstants.SIGALRM -> "SIGALRM"
-            OsConstants.SIGBUS -> "SIGBUS"
-            OsConstants.SIGCHLD -> "SIGCHLD"
-            OsConstants.SIGCONT -> "SIGCONT"
-            OsConstants.SIGFPE -> "SIGFPE"
-            OsConstants.SIGHUP -> "SIGHUP"
-            OsConstants.SIGILL -> "SIGILL"
-            OsConstants.SIGINT -> "SIGINT"
-            OsConstants.SIGIO -> "SIGIO"
-            OsConstants.SIGKILL -> "SIGKILL"
-            OsConstants.SIGPIPE -> "SIGPIPE"
-            OsConstants.SIGPROF -> "SIGPROF"
-            OsConstants.SIGPWR -> "SIGPWR"
-            OsConstants.SIGQUIT -> "SIGQUIT"
-            OsConstants.SIGRTMAX -> "SIGRTMAX"
-            OsConstants.SIGRTMIN -> "SIGRTMIN"
-            OsConstants.SIGSEGV -> "SIGSEGV"
-            OsConstants.SIGSTKFLT -> "SIGSTKFLT"
-            OsConstants.SIGSTOP -> "SIGSTOP"
-            OsConstants.SIGSYS -> "SIGSYS"
-            OsConstants.SIGTERM -> "SIGTERM"
-            OsConstants.SIGTRAP -> "SIGTRAP"
-            OsConstants.SIGTSTP -> "SIGTSTP"
-            OsConstants.SIGTTIN -> "SIGTTIN"
-            OsConstants.SIGTTOU -> "SIGTTOU"
-            OsConstants.SIGURG -> "SIGURG"
-            OsConstants.SIGUSR1 -> "SIGUSR1"
-            OsConstants.SIGUSR2 -> "SIGUSR2"
-            OsConstants.SIGVTALRM -> "SIGVTALRM"
-            OsConstants.SIGWINCH -> "SIGWINCH"
-            OsConstants.SIGXCPU -> "SIGXCPU"
-            OsConstants.SIGXFSZ -> "SIGXFSZ"
-            0 -> null
-            else -> "UNKNOWN"
-        }?.let { "$status ($it)" } ?: "$status"
-    }
-
-    @RequiresApi(Build.VERSION_CODES.R)
-    @JvmStatic
-    fun getReasonText(exitInfo: ApplicationExitInfo): String {
-        val reasonName = when (exitInfo.reason) {
-            ApplicationExitInfo.REASON_EXIT_SELF -> "EXIT_SELF"
-            ApplicationExitInfo.REASON_SIGNALED -> "SIGNALED"
-            ApplicationExitInfo.REASON_LOW_MEMORY -> "LOW_MEMORY"
-            ApplicationExitInfo.REASON_CRASH -> "APP CRASH(EXCEPTION)"
-            ApplicationExitInfo.REASON_CRASH_NATIVE -> "APP CRASH(NATIVE)"
-            ApplicationExitInfo.REASON_ANR -> "ANR"
-            ApplicationExitInfo.REASON_INITIALIZATION_FAILURE -> "INITIALIZATION FAILURE"
-            ApplicationExitInfo.REASON_PERMISSION_CHANGE -> "PERMISSION CHANGE"
-            ApplicationExitInfo.REASON_EXCESSIVE_RESOURCE_USAGE -> "EXCESSIVE RESOURCE USAGE"
-            ApplicationExitInfo.REASON_USER_REQUESTED -> "USER REQUESTED"
-            ApplicationExitInfo.REASON_USER_STOPPED -> "USER STOPPED"
-            ApplicationExitInfo.REASON_DEPENDENCY_DIED -> "DEPENDENCY DIED"
-            ApplicationExitInfo.REASON_OTHER -> "OTHER KILLS BY SYSTEM"
-            ApplicationExitInfo.REASON_FREEZER -> "FREEZER"
-            ApplicationExitInfo.REASON_PACKAGE_STATE_CHANGE -> "STATE CHANGE"
-            ApplicationExitInfo.REASON_PACKAGE_UPDATED -> "PACKAGE UPDATED"
-            else -> "UNKNOWN"
-        }
-        return "${exitInfo.reason} ($reasonName)"
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/utils/BackupUtils.java b/app/src/main/java/ch/threema/app/utils/BackupUtils.java
index f4644e96..91b02d9c 100644
--- a/app/src/main/java/ch/threema/app/utils/BackupUtils.java
+++ b/app/src/main/java/ch/threema/app/utils/BackupUtils.java
@@ -28,9 +28,6 @@ import ch.threema.storage.models.ballot.BallotModel;
 
 public class BackupUtils {
 
-	public static final String BACKUP_DIR = "backup/";
-	public static final String KEY_BACKUP_PATH = BACKUP_DIR + "keybackup.bin";
-
 	private static String buildBallotChoiceUid(int apiChoiceId) {
 		return String.valueOf(apiChoiceId);
 	}
@@ -60,4 +57,27 @@ public class BackupUtils {
 	public static String buildDistributionListUid(DistributionListModel distributionListModel) {
 		return String.valueOf(distributionListModel.getId());
 	}
+
+	/**
+	 * Calculate the count of nonces that are not yet respected in the progress calculation.
+	 *
+	 * This calculation is based on the assumption that per noncesPerChunk of processed nonces
+	 * the steps are calculated like `steps = noncesInChunk / noncesPerStep`. It is assumed that every
+	 * chunk except the last contains noncesPerChunk.
+	 * Therefore for every processed chunk there may remain some nonces that are not yet respected.
+	 *
+	 * @return The number of nonces not yet respected for step calculation
+	 */
+	public static int calcRemainingNoncesProgress(
+		final int noncesPerChunk,
+		final int noncesPerStep,
+		final int nonceCount
+	) {
+		int fullChunks = nonceCount / noncesPerChunk;
+		int lastChunkCount = nonceCount - (noncesPerChunk * fullChunks);
+
+		int remainingPerFullChunk = noncesPerChunk % noncesPerStep;
+		int remainingInLastChunk = lastChunkCount % noncesPerStep;
+		return remainingPerFullChunk * fullChunks + remainingInLastChunk;
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/utils/CSVReader.java b/app/src/main/java/ch/threema/app/utils/CSVReader.java
index c670eddc..13bb4595 100644
--- a/app/src/main/java/ch/threema/app/utils/CSVReader.java
+++ b/app/src/main/java/ch/threema/app/utils/CSVReader.java
@@ -27,45 +27,11 @@ import java.io.Reader;
 public class CSVReader extends au.com.bytecode.opencsv.CSVReader {
 	private String[] headerRow;
 
-	public CSVReader(Reader reader) {
-		super(reader);
-	}
-
 	public CSVReader(Reader reader, boolean firstRowIsHeader) throws IOException{
 		super(reader);
-		this.headerRow = this.readNext();
-	}
-
-	public CSVReader(Reader reader, char c) {
-		super(reader, c);
-	}
-
-	public CSVReader(Reader reader, char c, char c2) {
-		super(reader, c, c2);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, boolean b) {
-		super(reader, c, c2, b);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3) {
-		super(reader, c, c2, c3);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, int i) {
-		super(reader, c, c2, i);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3, int i) {
-		super(reader, c, c2, c3, i);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3, int i, boolean b) {
-		super(reader, c, c2, c3, i, b);
-	}
-
-	public CSVReader(Reader reader, char c, char c2, char c3, int i, boolean b, boolean b2) {
-		super(reader, c, c2, c3, i, b, b2);
+		if (firstRowIsHeader) {
+			this.headerRow = this.readNext();
+		}
 	}
 
 	public CSVRow readNextRow() throws IOException {
diff --git a/app/src/main/java/ch/threema/app/utils/ConfigUtils.java b/app/src/main/java/ch/threema/app/utils/ConfigUtils.java
index b4a07439..fc407f6a 100644
--- a/app/src/main/java/ch/threema/app/utils/ConfigUtils.java
+++ b/app/src/main/java/ch/threema/app/utils/ConfigUtils.java
@@ -217,6 +217,9 @@ public class ConfigUtils {
     public static boolean isSamsungDevice() {
         return (Build.MANUFACTURER.equalsIgnoreCase("Samsung"));
     }
+    public static boolean isMotorolaDevice() {
+        return (Build.MANUFACTURER.equalsIgnoreCase("motorola"));
+    }
 
     public static boolean isSonyDevice() {
         return (Build.MANUFACTURER.equalsIgnoreCase("Sony"));
@@ -337,9 +340,10 @@ public class ConfigUtils {
      */
     public static @NonNull SSLSocketFactory getSSLSocketFactory(String host) {
         return new TLSUpgradeSocketFactoryWrapper(
-            ConfigUtils.isOnPremBuild() ?
-                HttpsURLConnection.getDefaultSSLSocketFactory() :
-                TrustKit.getInstance().getSSLSocketFactory(host));
+            ConfigUtils.isOnPremBuild()
+                ? HttpsURLConnection.getDefaultSSLSocketFactory()
+                : TrustKit.getInstance().getSSLSocketFactory(host)
+        );
     }
 
     public static boolean isXiaomiDevice() {
diff --git a/app/src/main/java/ch/threema/app/utils/ContactUtil.java b/app/src/main/java/ch/threema/app/utils/ContactUtil.java
index ed6ee257..77bc2eb5 100644
--- a/app/src/main/java/ch/threema/app/utils/ContactUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/ContactUtil.java
@@ -33,6 +33,8 @@ import android.text.format.DateUtils;
 
 import org.slf4j.Logger;
 
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.text.Collator;
 import java.util.Comparator;
 import java.util.Date;
@@ -46,10 +48,17 @@ import androidx.appcompat.content.res.AppCompatResources;
 import androidx.core.util.Pair;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
+import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.services.FileService;
 import ch.threema.app.services.IdListService;
 import ch.threema.app.services.PreferenceService;
+import ch.threema.app.tasks.OnFSFeatureMaskDowngradedTask;
+import ch.threema.base.ThreemaException;
+import ch.threema.base.utils.Base32;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.IdentityState;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 import ch.threema.storage.models.ContactModel;
 
 /**
@@ -60,10 +69,34 @@ import ch.threema.storage.models.ContactModel;
 public class ContactUtil {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("ContactUtil");
 
+	private static final String CONTACT_UID_PREFIX = "c-";
+
 	public static final int CHANNEL_NAME_MAX_LENGTH_BYTES = 256;
 
 	public static final long PROFILE_PICTURE_BLOB_CACHE_DURATION = DateUtils.WEEK_IN_MILLIS;
 
+	@Deprecated
+	public static int getUniqueId(@Nullable String identity) {
+		if (identity == null) {
+			return 0;
+		}
+		return (CONTACT_UID_PREFIX + identity).hashCode();
+	}
+
+	@NonNull
+	public static String getUniqueIdString(@Nullable String identity) {
+		if (identity != null) {
+			try {
+				MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
+				messageDigest.update((CONTACT_UID_PREFIX + identity).getBytes());
+				return Base32.encode(messageDigest.digest());
+			} catch (NoSuchAlgorithmException e) {
+				logger.warn("Could not calculate unique id string");
+			}
+		}
+		return "";
+	}
+
 	public static boolean canChangeFirstName(@Nullable ContactModel contact) {
 		return contact != null && !contact.isLinkedToAndroidContact();
 	}
@@ -80,7 +113,7 @@ public class ContactUtil {
 		@NonNull FileService fileService
 	) {
 		return canHaveCustomAvatar(contactModel)
-				&& !(preferenceService.getProfilePicReceive() && fileService.hasContactPhotoFile(contactModel.getIdentity()));
+				&& !(preferenceService.getProfilePicReceive() && fileService.hasContactDefinedProfilePicture(contactModel.getIdentity()));
 	}
 
 	/**
@@ -127,22 +160,28 @@ public class ContactUtil {
 				&& !isEchoEchoOrGatewayContact(contactModel);
 	}
 
+	public static boolean canReceiveVoipMessages(@Nullable String identity, @Nullable IdListService blockedContactsService) {
+		return identity != null
+			&& blockedContactsService != null
+			&& !blockedContactsService.has(identity)
+			&& !isEchoEchoOrGatewayContact(identity);
+	}
+
 	public static boolean allowedChangeToState(
-		@Nullable ContactModel contactModel,
-		@Nullable ContactModel.State newState
+		@Nullable IdentityState oldState,
+		@Nullable IdentityState newState
 	) {
-		if(contactModel != null && newState != null && contactModel.getState() != newState) {
-			ContactModel.State oldState = contactModel.getState();
-
-			switch (newState) {
-				//change to active is always allowed
-				case ACTIVE:
-					return true;
-				case INACTIVE:
-					return oldState == ContactModel.State.ACTIVE;
-				case INVALID:
-					return true;
-			}
+		if (oldState == newState || newState == null) {
+			return false;
+		}
+		switch (newState) {
+			//change to active is always allowed
+			case ACTIVE:
+				return true;
+			case INACTIVE:
+				return oldState == IdentityState.ACTIVE;
+			case INVALID:
+				return true;
 		}
 		return false;
 	}
@@ -214,34 +253,46 @@ public class ContactUtil {
 		return key;
 	}
 
-	public static @DrawableRes int getVerificationResource(ContactModel contactModel) {
-		int iconResource = R.drawable.ic_verification_none;
-		if(contactModel != null) {
-			switch (contactModel.verificationLevel) {
-				case SERVER_VERIFIED:
-					if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
-						iconResource = R.drawable.ic_verification_server_work;
-					} else {
-						iconResource = R.drawable.ic_verification_server;
-					}
-					break;
-				case FULLY_VERIFIED:
-					if (ConfigUtils.isWorkBuild() && contactModel.isWork()) {
-						iconResource = R.drawable.ic_verification_full_work;
-					} else {
-						iconResource = R.drawable.ic_verification_full;
-					}
-					break;
-			}
+	public static @DrawableRes int getVerificationResource(
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		int iconResource;
+		boolean isWorkVerifiedOnWorkBuild = ConfigUtils.isWorkBuild()
+			&& workVerificationLevel == WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED;
+		switch (verificationLevel) {
+			case SERVER_VERIFIED:
+				if (isWorkVerifiedOnWorkBuild) {
+					iconResource = R.drawable.ic_verification_server_work;
+				} else {
+					iconResource = R.drawable.ic_verification_server;
+				}
+				break;
+			case FULLY_VERIFIED:
+				if (isWorkVerifiedOnWorkBuild) {
+					iconResource = R.drawable.ic_verification_full_work;
+				} else {
+					iconResource = R.drawable.ic_verification_full;
+				}
+				break;
+			case UNVERIFIED:
+			default:
+				iconResource = R.drawable.ic_verification_none;
+				break;
 		}
 		return iconResource;
 	}
 
-	public static Drawable getVerificationDrawable(Context context, ContactModel contactModel) {
-		if (context != null) {
-			return AppCompatResources.getDrawable(context, getVerificationResource(contactModel));
-		}
-		return null;
+	@Nullable
+	public static Drawable getVerificationDrawable(
+		@NonNull Context context,
+		@NonNull VerificationLevel verificationLevel,
+		@NonNull WorkVerificationLevel workVerificationLevel
+	) {
+		return AppCompatResources.getDrawable(context, getVerificationResource(
+			verificationLevel,
+			workVerificationLevel
+		));
 	}
 
 	public static String getIdentityFromViewIntent(Context context, Intent intent) {
@@ -280,4 +331,41 @@ public class ContactUtil {
 			return String.join(", ", contactNames);
 		}
 	}
+
+	/**
+	 * Perform the required steps if a contact does not support forward security anymore due to a
+	 * change of its feature mask. This includes creating a status message in the conversation with
+	 * that contact to warn the user that forward security has been disabled for this contact. This
+	 * method also terminates all existing sessions with the contact.
+	 * <p>
+	 * Note that the status message is only created if a forward security session currently exists.
+	 * <p>
+	 * Note that this method must only be called if the feature mask of a contact is changed from a
+	 * feature mask that indicates forward security support to a feature mask without forward
+	 * security support.
+	 *
+	 * @param contactModel the affected contact
+	 */
+	public static void onForwardSecurityNotSupportedAnymore(@NonNull ch.threema.data.models.ContactModel contactModel) {
+		ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+		if (serviceManager == null) {
+			logger.error("Service manager is null");
+			return;
+		}
+
+		try {
+			serviceManager.getTaskManager().schedule(
+				new OnFSFeatureMaskDowngradedTask(
+					contactModel,
+					serviceManager.getContactService(),
+					serviceManager.getMessageService(),
+					serviceManager.getDHSessionStore(),
+					serviceManager.getIdentityStore(),
+					serviceManager.getForwardSecurityMessageProcessor()
+				)
+			);
+		} catch (ThreemaException e) {
+			logger.error("Could not schedule fs feature mask downgraded task");
+		}
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java b/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java
index d321e994..2c609231 100644
--- a/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/ConversationNotificationUtil.java
@@ -25,18 +25,15 @@ import android.content.Context;
 import android.graphics.Bitmap;
 import android.net.Uri;
 
-import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 import java.util.Date;
 import java.util.HashMap;
 
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.WorkerThread;
 import androidx.core.app.Person;
 import androidx.core.graphics.drawable.IconCompat;
-
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
@@ -106,19 +103,21 @@ public class ConversationNotificationUtil {
             return null;
         }
 
-        Person.Builder builder = new Person.Builder()
-            .setKey(contactService.getUniqueIdString(contactModel))
-            .setName(name);
-        Bitmap avatar = contactService.getAvatar(contactModel, false);
-        if (avatar != null) {
-            IconCompat iconCompat = IconCompat.createWithBitmap(avatar);
-            builder.setIcon(iconCompat);
-        }
-        if (contactModel != null && contactModel.isLinkedToAndroidContact()) {
-            builder.setUri(contactService.getAndroidContactLookupUriString(contactModel));
-        }
-        return builder.build();
-    }
+		String identity = contactModel != null ? contactModel.getIdentity() : null;
+
+		Person.Builder builder = new Person.Builder()
+			.setKey(ContactUtil.getUniqueIdString(identity))
+			.setName(name);
+		Bitmap avatar = contactService.getAvatar(contactModel, false);
+		if (avatar != null) {
+			IconCompat iconCompat = IconCompat.createWithBitmap(avatar);
+			builder.setIcon(iconCompat);
+		}
+		if (contactModel != null && contactModel.isLinkedToAndroidContact()) {
+			builder.setUri(contactService.getAndroidContactLookupUriString(contactModel));
+		}
+		return builder.build();
+	}
 
     private static MessageType getMessageType(AbstractMessageModel messageModel) {
         return messageModel.getType();
@@ -128,40 +127,44 @@ public class ConversationNotificationUtil {
         return messageModel.getCreatedAt();
     }
 
-    private static NotificationService.ConversationNotification create(
-        final Context context,
-        final MessageModel messageModel,
-        final @NonNull ContactService contactService,
-        final DeadlineListService hiddenChatsListService
-    ) {
-        final ContactModel contactModel = contactService.getByIdentity(messageModel.getIdentity());
-        String groupUid = "i" + messageModel.getIdentity();
-        synchronized (notificationGroupHashMap) {
-            @Nullable ConversationNotificationGroup group = notificationGroupHashMap.get(groupUid);
-            final @NotNull String longName = hiddenChatsListService.has(contactService.getUniqueIdString(contactModel))
-                ? context.getString(R.string.private_chat_subject)
-                : NameUtil.getDisplayNameOrNickname(contactModel, true);
-            final @Nullable String shortName = hiddenChatsListService.has(contactService.getUniqueIdString(contactModel))
-                ? context.getString(R.string.private_chat_subject)
-                : NameUtil.getShortName(contactModel);
-
-            if (group == null) {
-                group = new ConversationNotificationGroup(
-                    groupUid,
-                    longName,
-                    shortName,
-                    contactService.createReceiver(contactModel),
-                    () -> contactService.getAvatar(
-                        hiddenChatsListService.has(contactService.getUniqueIdString(contactModel)) ? null : contactModel,
-                        false
-                    )
-                );
-                notificationGroupHashMap.put(groupUid, group);
-            } else {
-                // contact name may change between notifications - set it again
-                group.name = longName;
-                group.shortName = shortName;
-            }
+	private static NotificationService.ConversationNotification create(final Context context, final MessageModel messageModel,
+	                                                                   final ContactService contactService, final DeadlineListService hiddenChatsListService) {
+		final ContactModel contactModel = contactService.getByIdentity(messageModel.getIdentity());
+		String groupUid = "i" + messageModel.getIdentity();
+		synchronized (notificationGroupHashMap) {
+			ConversationNotificationGroup group = notificationGroupHashMap.get(groupUid);
+			boolean isPrivateChat = hiddenChatsListService.has(
+				ContactUtil.getUniqueIdString(messageModel.getIdentity())
+			);
+			String longName, shortName;
+			if (isPrivateChat) {
+				longName = shortName = context.getString(R.string.private_chat_subject);
+			} else {
+				longName = NameUtil.getDisplayNameOrNickname(contactModel, true);
+				shortName = NameUtil.getShortName(contactModel);
+			}
+
+			if (group == null) {
+				group = new ConversationNotificationGroup(
+						groupUid,
+						longName,
+						shortName,
+						contactService.createReceiver(contactModel),
+                        () -> {
+                            if (contactModel != null) {
+                                return contactService.getAvatar(
+                                        isPrivateChat ? null : contactModel,
+                                        false
+                                );
+                            }
+                            return null;
+                        });
+				notificationGroupHashMap.put(groupUid, group);
+			} else {
+				// contact name may change between notifications - set it again
+				group.name = longName;
+				group.shortName = shortName;
+			}
 
             return new NotificationService.ConversationNotification(
                 getMessage(messageModel),
diff --git a/app/src/main/java/ch/threema/app/utils/ConversationUtil.kt b/app/src/main/java/ch/threema/app/utils/ConversationUtil.kt
deleted file mode 100644
index 5d7dbb4e..00000000
--- a/app/src/main/java/ch/threema/app/utils/ConversationUtil.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-import ch.threema.storage.models.ContactModel
-import ch.threema.storage.models.DistributionListModel
-import ch.threema.storage.models.GroupModel
-
-object ConversationUtil {
-    @JvmStatic
-    fun getIdentityConversationUid(identity: String): String {
-        return "i-$identity"
-    }
-
-    @JvmStatic
-    fun getGroupConversationUid(groupId: Int): String {
-        return "g-$groupId"
-    }
-
-    @JvmStatic
-    fun getDistributionListConversationUid(distributionListId: Long): String {
-        return "d-$distributionListId"
-    }
-
-    fun ContactModel.getConversationUid(): String {
-        return getIdentityConversationUid(identity)
-    }
-
-    fun GroupModel.getConversationUid(): String {
-        return getGroupConversationUid(id)
-    }
-
-    fun DistributionListModel.getConversationUid(): String {
-        return getDistributionListConversationUid(id)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/utils/ExifInterfaceUtils.java b/app/src/main/java/ch/threema/app/utils/ExifInterfaceUtils.java
deleted file mode 100644
index 0fdc1605..00000000
--- a/app/src/main/java/ch/threema/app/utils/ExifInterfaceUtils.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2019-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * Based on AOSP code with modifications by Threema
- *
- * (C) Google Inc. All Rights Reserved
- * Licensed under the Apache License, version 2.0
- */
-
-package ch.threema.app.utils;
-
-import android.media.MediaDataSource;
-import android.media.MediaMetadataRetriever;
-import android.os.Build;
-import android.system.ErrnoException;
-import android.system.Os;
-import android.util.Log;
-
-import androidx.annotation.DoNotInline;
-import androidx.annotation.RequiresApi;
-
-import java.io.Closeable;
-import java.io.FileDescriptor;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-
-class ExifInterfaceUtils {
-    private static final String TAG = "ExifInterfaceUtils";
-
-    private ExifInterfaceUtils() {
-        // Prevent instantiation
-    }
-    /**
-     * Copies all of the bytes from {@code in} to {@code out}. Neither stream is closed.
-     * Returns the total number of bytes transferred.
-     */
-    static int copy(InputStream in, OutputStream out) throws IOException {
-        int total = 0;
-        byte[] buffer = new byte[8192];
-        int c;
-        while ((c = in.read(buffer)) != -1) {
-            total += c;
-            out.write(buffer, 0, c);
-        }
-        return total;
-    }
-
-    /**
-     * Copies the given number of the bytes from {@code in} to {@code out}. Neither stream is
-     * closed.
-     */
-    static void copy(InputStream in, OutputStream out, int numBytes) throws IOException {
-        int remainder = numBytes;
-        byte[] buffer = new byte[8192];
-        while (remainder > 0) {
-            int bytesToRead = Math.min(remainder, 8192);
-            int bytesRead = in.read(buffer, 0, bytesToRead);
-            if (bytesRead != bytesToRead) {
-                throw new IOException("Failed to copy the given amount of bytes from the input"
-                        + "stream to the output stream.");
-            }
-            remainder -= bytesRead;
-            out.write(buffer, 0, bytesRead);
-        }
-    }
-
-    /**
-     * Convert given int[] to long[]. If long[] is given, just return it.
-     * Return null for other types of input.
-     */
-    static long[] convertToLongArray(Object inputObj) {
-        if (inputObj instanceof int[]) {
-            int[] input = (int[]) inputObj;
-            long[] result = new long[input.length];
-            for (int i = 0; i < input.length; i++) {
-                result[i] = input[i];
-            }
-            return result;
-        } else if (inputObj instanceof long[]) {
-            return (long[]) inputObj;
-        }
-        return null;
-    }
-
-    static boolean startsWith(byte[] cur, byte[] val) {
-        if (cur == null || val == null) {
-            return false;
-        }
-        if (cur.length < val.length) {
-            return false;
-        }
-        for (int i = 0; i < val.length; i++) {
-            if (cur[i] != val[i]) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    static String byteArrayToHexString(byte[] bytes) {
-        StringBuilder sb = new StringBuilder(bytes.length * 2);
-        for (int i = 0; i < bytes.length; i++) {
-            sb.append(String.format("%02x", bytes[i]));
-        }
-        return sb.toString();
-    }
-
-    static long parseSubSeconds(String subSec) {
-        try {
-            final int len = Math.min(subSec.length(), 3);
-            long sub = Long.parseLong(subSec.substring(0, len));
-            for (int i = len; i < 3; i++) {
-                sub *= 10;
-            }
-            return sub;
-        } catch (NumberFormatException e) {
-            // Ignored
-        }
-        return 0L;
-    }
-
-
-    /**
-     * Closes 'closeable', ignoring any checked exceptions. Does nothing if 'closeable' is null.
-     */
-    static void closeQuietly(Closeable closeable) {
-        if (closeable != null) {
-            try {
-                closeable.close();
-            } catch (RuntimeException rethrown) {
-                throw rethrown;
-            } catch (Exception ignored) {
-            }
-        }
-    }
-
-    /**
-     * Closes a file descriptor that has been duplicated.
-     */
-    static void closeFileDescriptor(FileDescriptor fd) {
-        // Os.dup and Os.close was introduced in API 21 so this method shouldn't be called
-        // in API < 21.
-        if (Build.VERSION.SDK_INT >= 21) {
-            try {
-                Api21Impl.close(fd);
-                // Catching ErrnoException will raise error in API < 21
-            } catch (Exception ex) {
-                Log.e(TAG, "Error closing fd.");
-            }
-        } else {
-            Log.e(TAG, "closeFileDescriptor is called in API < 21, which must be wrong.");
-        }
-    }
-
-    @RequiresApi(21)
-    static class Api21Impl {
-        private Api21Impl() {}
-
-        @DoNotInline
-        static FileDescriptor dup(FileDescriptor fileDescriptor) throws ErrnoException {
-            return Os.dup(fileDescriptor);
-        }
-
-        @DoNotInline
-        static long lseek(FileDescriptor fd, long offset, int whence) throws ErrnoException {
-            return Os.lseek(fd, offset, whence);
-        }
-
-        @DoNotInline
-        static void close(FileDescriptor fd) throws ErrnoException {
-            Os.close(fd);
-        }
-    }
-
-    @RequiresApi(23)
-    static class Api23Impl {
-        private Api23Impl() {}
-
-        @DoNotInline
-        static void setDataSource(MediaMetadataRetriever retriever, MediaDataSource dataSource) {
-            retriever.setDataSource(dataSource);
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/utils/FileUtil.java b/app/src/main/java/ch/threema/app/utils/FileUtil.java
index 69c2fcf4..4e77c6c1 100644
--- a/app/src/main/java/ch/threema/app/utils/FileUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/FileUtil.java
@@ -75,6 +75,7 @@ import ch.threema.storage.models.data.media.FileDataModel;
 
 import static ch.threema.app.ThreemaApplication.MAX_BLOB_SIZE;
 import static ch.threema.app.filepicker.FilePickerActivity.INTENT_DATA_DEFAULT_PATH;
+import static ch.threema.app.utils.StreamUtilKt.getFromUri;
 
 public class FileUtil {
 	private static final Logger logger = LoggingUtil.getThreemaLogger("FileUtil");
@@ -832,7 +833,7 @@ public class FileUtil {
 	 * @return true if the file is an animated WebP file, false if it is not animated, in another format, corrupt or not readable
 	 */
 	private static boolean isAnimatedWebPFile(@NonNull Uri uri) {
-		try (InputStream inputStream = StreamUtil.getFromUri(ThreemaApplication.getAppContext(), uri)) {
+		try (InputStream inputStream = getFromUri(ThreemaApplication.getAppContext(), uri)) {
 			byte[] buffer = new byte[34];
 			return inputStream != null
 				&& inputStream.read(buffer) == 34
diff --git a/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java b/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java
index 931631fe..657f0ade 100644
--- a/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java
+++ b/app/src/main/java/ch/threema/app/utils/ForwardSecurityStatusSender.java
@@ -32,7 +32,9 @@ import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.routines.UpdateFeatureLevelRoutine;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.services.UserService;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.fs.DHSession;
 import ch.threema.domain.fs.DHSessionId;
 import ch.threema.domain.models.Contact;
@@ -50,15 +52,30 @@ import ch.threema.storage.models.data.status.ForwardSecurityStatusDataModel.Forw
 public class ForwardSecurityStatusSender implements ForwardSecurityStatusListener {
 	private final static Logger logger = LoggingUtil.getThreemaLogger("ForwardSecurityStatusSender");
 	private final boolean debug;
+	@NonNull
 	private final ContactService contactService;
+	@NonNull
 	private final MessageService messageService;
+	@NonNull
 	private final APIConnector apiConnector;
-
-	public ForwardSecurityStatusSender(ContactService contactService, MessageService messageService, APIConnector apiConnector) {
+	@NonNull
+	private final UserService userService;
+	@NonNull
+	private final ContactModelRepository contactModelRepository;
+
+	public ForwardSecurityStatusSender(
+		@NonNull ContactService contactService,
+		@NonNull MessageService messageService,
+		@NonNull APIConnector apiConnector,
+		@NonNull UserService userService,
+		@NonNull ContactModelRepository contactModelRepository
+	) {
 		this.debug = ConfigUtils.isDevBuild();
 		this.contactService = contactService;
 		this.messageService = messageService;
 		this.apiConnector = apiConnector;
+		this.userService = userService;
+		this.contactModelRepository = contactModelRepository;
 	}
 
 	@Override
@@ -247,11 +264,12 @@ public class ForwardSecurityStatusSender implements ForwardSecurityStatusListene
 		}
 
 		// Force a feature mask re-fetch
-		UpdateFeatureLevelRoutine.removeTimeCache(contactModel);
+		UpdateFeatureLevelRoutine.removeTimeCache(contactModel.getIdentity());
 		new UpdateFeatureLevelRoutine(
-			contactService,
+			contactModelRepository,
+			userService,
 			apiConnector,
-			Collections.singletonList(contactModel)
+			Collections.singletonList(contactModel.getIdentity())
 		).run();
 	}
 
diff --git a/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt b/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt
index 780ae743..351e946c 100644
--- a/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt
+++ b/app/src/main/java/ch/threema/app/utils/GroupCallUtil.kt
@@ -86,6 +86,7 @@ fun initiateCall(
         groupModel: GroupModel
 ) {
     val serviceManager = ThreemaApplication.getServiceManager() ?: return
+    val contactModelRepository = serviceManager.modelRepositories.contacts
     val userService: UserService
     val groupService: GroupService
     val contactService: ContactService
@@ -112,7 +113,7 @@ fun initiateCall(
         return
     }
 
-    val otherMemberIdentities = groupService.getGroupIdentities(groupModel).filter { !userService.isMe(it) }
+    val otherMemberIdentities = groupService.getMembersWithoutUser(groupModel).toList()
     val otherMembers = contactService.getByIdentities(otherMemberIdentities)
 
     // Disallow group calls in empty groups
@@ -131,8 +132,13 @@ fun initiateCall(
                 .show(activity.supportFragmentManager, dialogTagFetchingFeatureMask)
 
             withContext(Dispatchers.Default) {
-                otherMembers.forEach { UpdateFeatureLevelRoutine.removeTimeCache(it) }
-                UpdateFeatureLevelRoutine(contactService, apiConnector, otherMembers).run()
+                otherMembers.forEach { UpdateFeatureLevelRoutine.removeTimeCache(it.identity) }
+                UpdateFeatureLevelRoutine(
+                    contactModelRepository,
+                    userService,
+                    apiConnector,
+                    otherMembers.map { it.identity }
+                ).run()
             }
 
             DialogUtil.dismissDialog(activity.supportFragmentManager, dialogTagFetchingFeatureMask, true)
diff --git a/app/src/main/java/ch/threema/app/utils/GroupFeatureSupport.kt b/app/src/main/java/ch/threema/app/utils/GroupFeatureSupport.kt
deleted file mode 100644
index 44dd67d2..00000000
--- a/app/src/main/java/ch/threema/app/utils/GroupFeatureSupport.kt
+++ /dev/null
@@ -1,67 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-import ch.threema.domain.protocol.ThreemaFeature
-import ch.threema.storage.models.ContactModel
-
-class GroupFeatureSupport(
-    @ThreemaFeature.Feature feature: Long,
-    groupMembers: List<ContactModel>
-) {
-    @SuppressWarnings("WeakerAccess") val contactsWithFeatureSupport: List<ContactModel>
-    val contactsWithoutFeatureSupport: List<ContactModel>
-
-    init {
-        groupMembers.groupBy { ThreemaFeature.hasFeature(it.featureMask, feature) }.also {
-            contactsWithFeatureSupport = it[true] ?: emptyList()
-            contactsWithoutFeatureSupport = it[false] ?: emptyList()
-        }
-    }
-
-    val adoptionRate : GroupFeatureAdoptionRate =
-        // deduct adoption rate
-        if (contactsWithFeatureSupport.isNotEmpty() && contactsWithoutFeatureSupport.isNotEmpty()) {
-            GroupFeatureAdoptionRate.PARTIAL
-        } else if (contactsWithFeatureSupport.isNotEmpty() /*implies that contactsWithoutFeatureSupport is empty*/) {
-            GroupFeatureAdoptionRate.ALL
-        } else /*implies that there are no contacts with feature support*/ {
-            GroupFeatureAdoptionRate.NONE
-        }
-}
-
-enum class GroupFeatureAdoptionRate {
-    /**
-     * no group member supports a feature
-     */
-    NONE,
-
-    /**
-     * not all group members support a feature
-     */
-    PARTIAL,
-
-    /**
-     * all group members support a feature
-     */
-    ALL
-}
diff --git a/app/src/main/java/ch/threema/app/utils/LazyProperty.kt b/app/src/main/java/ch/threema/app/utils/LazyProperty.kt
deleted file mode 100644
index 4efc84c3..00000000
--- a/app/src/main/java/ch/threema/app/utils/LazyProperty.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-import java8.util.function.Supplier
-
-/**
- * Intended to be used in java code to fill the missing gap of lazy initialized properties.
- *
- * This uses the kotlin [lazy] initializer internally when the value is accessed. Subsequent access
- * to the value will always return the same instance of the same value.
- *
- * @param supplier The supplier that will be utilized to initialise the value.
- */
-class LazyProperty<T>(private val supplier: Supplier<T>) : Supplier<T> {
-    private val value: T by lazy { supplier.get() }
-
-    /**
-     * Get the value provided by this [Supplier]. If the value is not yet initialized it will
-     * be created using the provided [supplier].
-     *
-     * Subsequent calls will always return the value created on initialisation.
-     */
-    override fun get() = value
-}
diff --git a/app/src/main/java/ch/threema/app/utils/MessageUtil.java b/app/src/main/java/ch/threema/app/utils/MessageUtil.java
index 87a536ca..dd6a9797 100644
--- a/app/src/main/java/ch/threema/app/utils/MessageUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/MessageUtil.java
@@ -23,10 +23,6 @@ package ch.threema.app.utils;
 
 import android.content.Context;
 
-import androidx.annotation.DrawableRes;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
@@ -36,6 +32,9 @@ import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.adapters.decorators.GroupStatusAdapterDecorator;
@@ -353,6 +352,7 @@ public class MessageUtil {
 
 	/**
 	 * Check if a MessageState change from fromState to toState is allowed
+	 *
 	 * @param fromState State from which a state change is requested
 	 * @param toState State to which a state change is requested
 	 * @param isGroupMessage true, if it's a group message
@@ -465,11 +465,12 @@ public class MessageUtil {
 	}
 
 	/**
-	 * Check if the provided MessageState is acceptable as a group message state and should be saved to the database
-	 * @param state MessageState
-	 * @return true if MessageState is acceptable, false otherwise
+	 * Check if the provided MessageState is a user reaction.
+	 *
+	 * @param state the message state
+	 * @return true if it is a user reaction, false otherwise
 	 */
-	public static boolean isAllowedGroupMessageState(MessageState state) {
+	public static boolean isReaction(MessageState state) {
 		return state == MessageState.USERACK || state == MessageState.USERDEC;
 	}
 
@@ -930,4 +931,20 @@ public class MessageUtil {
 			&& (message.getPostedAt() != null && message.getState() != MessageState.SENDFAILED)
 			&& !message.isDeleted();
 	}
+
+	@Nullable
+	public static MessageState receiptTypeToMessageState(int receiptType) {
+		switch (receiptType) {
+			case ProtocolDefines.DELIVERYRECEIPT_MSGRECEIVED:
+				return MessageState.DELIVERED;
+			case ProtocolDefines.DELIVERYRECEIPT_MSGREAD:
+				return MessageState.READ;
+			case ProtocolDefines.DELIVERYRECEIPT_MSGUSERACK:
+				return MessageState.USERACK;
+			case ProtocolDefines.DELIVERYRECEIPT_MSGUSERDEC:
+				return MessageState.USERDEC;
+			default:
+				return null;
+		}
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/utils/MimeUtil.java b/app/src/main/java/ch/threema/app/utils/MimeUtil.java
index af3cb638..5e764a10 100644
--- a/app/src/main/java/ch/threema/app/utils/MimeUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/MimeUtil.java
@@ -452,7 +452,7 @@ public class MimeUtil {
 		String mimeType = fileDataModel.getMimeType();
 
 		int messageContentsType = MessageContentsType.FILE;
-		if (mimeType.length() > 0) {
+		if (!mimeType.isEmpty()) {
 			if (MimeUtil.isGifFile(mimeType)) {
 				messageContentsType = MessageContentsType.GIF;
 			} else if (MimeUtil.isImageFile(mimeType)) {
diff --git a/app/src/main/java/ch/threema/app/utils/NameUtil.java b/app/src/main/java/ch/threema/app/utils/NameUtil.java
index 7eadb535..64516939 100644
--- a/app/src/main/java/ch/threema/app/utils/NameUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/NameUtil.java
@@ -36,6 +36,7 @@ import ch.threema.app.services.GroupService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.stores.PreferenceStore;
+import ch.threema.data.models.ContactModelData;
 import ch.threema.storage.models.AbstractMessageModel;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.DistributionListModel;
@@ -65,7 +66,7 @@ public class NameUtil {
 	 * Return the display name for a group.
 	 */
 	public static String getDisplayName(GroupModel groupModel, GroupService groupService) {
-		if (groupModel.getName() != null && groupModel.getName().length() > 0) {
+		if (groupModel.getName() != null && !groupModel.getName().isEmpty()) {
 			return groupModel.getName();
 		}
 
@@ -175,9 +176,23 @@ public class NameUtil {
 	 * Return the display name for a contact.
 	 */
 	@NonNull
-	public static String getDisplayName(ContactModel contactModel) {
-		String c = "";
+	public static String getDisplayName(@Nullable ContactModel contactModel) {
+		if (contactModel == null) {
+			return "undefined";
+		}
+
+		if (contactModel.getIdentity().isEmpty()) {
+			return "invalid contact";
+		}
+
+		String firstName = contactModel.getFirstName();
+		String lastName = contactModel.getLastName();
+
+		return getDisplayName(contactModel.getIdentity(), firstName, lastName);
+	}
 
+	@NonNull
+	public static String getDisplayName(@Nullable ch.threema.data.models.ContactModel contactModel) {
 		if (contactModel == null) {
 			return "undefined";
 		}
@@ -186,37 +201,47 @@ public class NameUtil {
 			return "invalid contact";
 		}
 
-		String f = contactModel.getFirstName();
-		String l = contactModel.getLastName();
+		ContactModelData data = contactModel.getData().getValue();
+		if (data == null) {
+			return "undefined";
+		}
+
+		return getDisplayName(data.identity, data.firstName, data.lastName);
+	}
 
-		if (TestUtil.isEmptyOrNull(f, l)) {
-			return contactModel.getIdentity();
+	public static String getDisplayName(@NonNull String identity, @Nullable String firstName, @Nullable String lastName) {
+		if (TestUtil.isEmptyOrNull(firstName, lastName)) {
+			return identity;
 		}
 
+		String c = "";
+
 		PreferenceService preferenceService = NameUtil.getPreferenceService();
 		if (preferenceService == null || preferenceService.isContactFormatFirstNameLastName()) {
-			if (f != null) {
-				c += f + " ";
+			if (firstName != null) {
+				c += firstName + " ";
 			}
 
-			if (l != null) {
-				c += l;
+			if (lastName != null) {
+				c += lastName;
 			}
 		} else {
-			if (l != null) {
-				c += l + " ";
+			if (lastName != null) {
+				c += lastName + " ";
 			}
 
-			if (f != null) {
-				c += f;
+			if (firstName != null) {
+				c += firstName;
 			}
 		}
 
+		c = c.trim();
+
 		if (TestUtil.isEmptyOrNull(c)) {
-			c = contactModel.getIdentity();
+			c = identity.trim();
 		}
 
-		return c.trim();
+		return c;
 	}
 
 	/**
diff --git a/app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt b/app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt
deleted file mode 100644
index 48f5b2e6..00000000
--- a/app/src/main/java/ch/threema/app/utils/OutgoingCspMessageUtils.kt
+++ /dev/null
@@ -1,492 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-import androidx.annotation.WorkerThread
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.GroupService
-import ch.threema.app.services.IdListService
-import ch.threema.app.tasks.TaskCreator
-import ch.threema.base.crypto.NonceFactory
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.Utils
-import ch.threema.domain.models.GroupId
-import ch.threema.domain.models.IdentityState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.ThreemaFeature
-import ch.threema.domain.protocol.api.APIConnector
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityEncryptionResult
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.GroupLeaveMessage
-import ch.threema.domain.protocol.csp.messages.GroupSetupMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode
-import ch.threema.domain.stores.ContactStore
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.toCspMessage
-import ch.threema.domain.taskmanager.waitForServerAck
-import ch.threema.storage.models.ContactModel
-import ch.threema.storage.models.GroupModel
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("OutgoingCspMessageUtils")
-
-/**
- * Get all contact models of the given identities. If there are unknown contact models, they are
- * fetched from the server. Note that this may throw an exception when no connection is available or
- * there are invalid identities.
- */
-fun Collection<String>.toContactModels(contactService: ContactService, apiConnector: APIConnector) =
-    map { contactService.getByIdentity(it) ?: it.fetchContactModel(apiConnector) }
-
-/**
- * Fetch a contact model. Note that this may throw an exception when no connection is available or
- * the identity is invalid.
- */
-@WorkerThread
-fun String.fetchContactModel(apiConnector: APIConnector): ContactModel =
-    apiConnector.fetchIdentity(this)
-        .let {
-            ContactModel(it.identity, it.publicKey)
-                .setFeatureMask(it.featureMask)
-                .setIdentityType(when (it.type) {
-                    0 -> IdentityType.NORMAL
-                    1 -> IdentityType.WORK
-                    else -> IdentityType.NORMAL /* Out of range! */
-                })
-                .setState(
-                    when (it.state) {
-                        IdentityState.ACTIVE -> ContactModel.State.ACTIVE
-                        IdentityState.INACTIVE -> ContactModel.State.INACTIVE
-                        else -> ContactModel.State.INVALID
-                    }
-                )
-        }
-
-/**
- * Only known contact models are returned. Hidden contacts (acquaintance level 'group') are also
- * included. Note that no cached contacts (added with [ContactStore.addCachedContact]) are returned.
- */
-fun Collection<String>.toKnownContactModels(contactService: ContactService): Collection<ContactModel> =
-    mapNotNull { contactService.getByIdentity(it) }
-
-/**
- * All contacts that are not invalid are included. Only invalid contacts are discarded.
- */
-fun Collection<ContactModel>.filterValid() = filter { it.state != ContactModel.State.INVALID }
-
-/**
- * Only include non-blocked contacts. Note that only explicitly blocked identities are excluded.
- */
-fun Collection<ContactModel>.filterNotBlocked(blockedContactsService: IdListService) =
-    filterNotBlockedIf(true, blockedContactsService)
-
-/**
- * Only include non-blocked contacts if [applyFilter] is true. Note that only explicitly blocked
- * identities are excluded.
- */
-fun Collection<ContactModel>.filterNotBlockedIf(
-    applyFilter: Boolean,
-    blockedContactsService: IdListService,
-) = filterIf(applyFilter) { !blockedContactsService.has(it.identity) }
-
-/**
- * Filter the broadcast identity if no messages should be sent to it according to
- * [GroupUtil.sendMessageToCreator].
- */
-fun Collection<ContactModel>.filterBroadcastIdentity(group: GroupModel): Collection<ContactModel> =
-    filterIf(!GroupUtil.sendMessageToCreator(group)) { it.identity != group.creatorIdentity }
-
-fun <T> Collection<T>.filterIf(condition: Boolean, predicate: (T) -> Boolean): Collection<T> =
-    if (condition) {
-        this.filter(predicate)
-    } else {
-        this
-    }
-
-data class OutgoingMessageResult(
-    /**
-     * The recipient that received the message.
-     */
-    val recipient: ContactModel,
-
-    /**
-     * The forward security mode that has been used to encapsulate the message.
-     */
-    val forwardSecurityMode: ForwardSecurityMode,
-
-    /**
-     * The timestamp when the message has been sent.
-     */
-    val sentTimestamp: ULong,
-)
-
-/**
- * This class is internally used to bundle different information used for sending the messages out.
- */
-private data class MessageSendContainer(
-    val recipient: ContactModel,
-    val forwardSecurityEncryptionResult: ForwardSecurityEncryptionResult?,
-    val nonces: List<ByteArray>,
-    val outgoingMessages: List<AbstractMessage>,
-    val forwardSecurityMode: ForwardSecurityMode,
-) {
-    companion object {
-        internal fun create(
-            recipient: ContactModel,
-            innerMessage: AbstractMessage,
-            forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-            nonceFactory: NonceFactory,
-            handle: ActiveTaskCodec,
-        ): MessageSendContainer {
-            //TODO(ANDR-2519): Remove when md allows fs
-            val senderCanForwardSecurity = forwardSecurityMessageProcessor.isForwardSecurityEnabled()
-            val recipientCanForwardSecurity =
-                ThreemaFeature.canForwardSecurity(recipient.featureMask)
-            val innerMessageEncapsulated = innerMessage is ForwardSecurityEnvelopeMessage
-
-            // Create forward security encryption result
-            val encryptionResult =
-                if (senderCanForwardSecurity && recipientCanForwardSecurity && !innerMessageEncapsulated) {
-                    forwardSecurityMessageProcessor.makeMessage(recipient, innerMessage, handle)
-                } else {
-                    null
-                }
-
-            // Get the message from the result. If there is no result, then forward security is not
-            // supported (or the provided message is already encapsulated) and we add the list of
-            // the message without encapsulating it (again)
-            val outgoingMessages = encryptionResult?.outgoingMessages ?: listOf(innerMessage)
-
-            // Get the forward security mode from the encryption result if available, otherwise take
-            // the forward security mode of the inner message.
-            val forwardSecurityMode =
-                encryptionResult?.forwardSecurityMode ?: innerMessage.forwardSecurityMode
-
-            // Create a nonce for every outgoing message. Note that the nonce will be saved when the
-            // message is encoded (depending on the message type)
-            val nonces = outgoingMessages.map { nonceFactory.next(false) }
-
-            return MessageSendContainer(
-                recipient,
-                encryptionResult,
-                nonces,
-                outgoingMessages,
-                forwardSecurityMode,
-            )
-        }
-    }
-}
-
-/**
- * Used to create messages that are sent with [ActiveTaskCodec.sendMessageToReceivers].
- */
-sealed interface OutgoingCspMessageCreator {
-    /**
-     * Create an abstract message containing all the message type specific information. The
-     * following fields must not be set, as they will be set by the send utils or the message
-     * creator:
-     *
-     * - [AbstractMessage.toIdentity]
-     * - [AbstractMessage.fromIdentity]
-     * - [AbstractMessage.date]
-     * - [AbstractMessage.messageId]
-     * - [AbstractGroupMessage.apiGroupId]
-     * - [AbstractGroupMessage.groupCreator]
-     *
-     *  Note that each call of this method must return a new instance of the message.
-     */
-    fun createAbstractMessage(): AbstractMessage
-}
-
-/**
- * Used to create messages that are sent with [ActiveTaskCodec.sendContactMessage].
- */
-class OutgoingCspContactMessageCreator(
-    private val messageId: MessageId,
-    private val createContactMessage: () -> AbstractMessage,
-) : OutgoingCspMessageCreator {
-    override fun createAbstractMessage(): AbstractMessage {
-        return createContactMessage().also {
-            // Check that this message creator is only used for contact messages
-            if (it is AbstractGroupMessage) {
-                throw IllegalArgumentException(
-                    "The contact message creator cannot be used for group messages"
-                )
-            }
-
-            it.messageId = messageId
-        }
-    }
-}
-
-/**
- * Used to create message that are sent with [ActiveTaskCodec.sendGroupMessage].
- */
-class OutgoingCspGroupMessageCreator(
-    private val messageId: MessageId,
-    private val groupId: GroupId,
-    private val groupCreator: String,
-    private val createGroupMessage: () -> AbstractGroupMessage,
-) : OutgoingCspMessageCreator {
-
-    constructor(
-        messageId: MessageId,
-        group: GroupModel,
-        createAbstractGroupMessage: () -> AbstractGroupMessage,
-    ) : this(
-        messageId,
-        group.apiGroupId,
-        group.creatorIdentity,
-        createAbstractGroupMessage
-    )
-
-    /**
-     * Create an abstract message containing all the message type specific information. The
-     * following fields must not be set, as they will be set by the send utils:
-     *
-     * - [AbstractMessage.toIdentity]
-     * - [AbstractMessage.fromIdentity]
-     * - [AbstractMessage.date]
-     * - [AbstractMessage.messageId]
-     *
-     *  Note that each call of this method must return a new instance of the message.
-     */
-    override fun createAbstractMessage(): AbstractGroupMessage {
-        return createGroupMessage().also {
-            it.messageId = messageId
-            it.apiGroupId = groupId
-            it.groupCreator = groupCreator
-        }
-    }
-}
-
-/**
- * Run the _Common Send Steps_ to send the provided message to the given recipient. Note that if the
- * recipient is blocked and [AbstractMessage.exemptFromBlocking] is not set, the message is not sent
- * and null is returned.
- *
- * @return the [OutgoingMessageResult] with the send information of the message or null if it was
- * not sent because the recipient is blocked
- */
-suspend fun ActiveTaskCodec.sendContactMessage(
-    messageCreator: OutgoingCspContactMessageCreator,
-    recipient: ContactModel,
-    forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    identityStore: IdentityStoreInterface,
-    contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    blockedContactsService: IdListService,
-    taskCreator: TaskCreator,
-): OutgoingMessageResult? = sendMessageToReceivers(
-    messageCreator,
-    setOf(recipient),
-    forwardSecurityMessageProcessor,
-    identityStore,
-    contactStore,
-    nonceFactory,
-    blockedContactsService,
-    taskCreator
-).firstOrNull()
-
-/**
- * Run the _Common Send Steps_ and the _Common Group Send Steps_. If the user is not a member of the
- * given group, null is returned. The messages are created for every recipient of the group.
- * Depending on the message type, they are only sent to not-blocked contacts.
- *
- * Note that the messages are only sent to recipients that are part of the group.
- *
- * @return the [OutgoingMessageResult]s with the send information of the messages that were sent, or
- * null if the user is not a member of the group
- */
-suspend fun ActiveTaskCodec.sendGroupMessage(
-    messageCreator: OutgoingCspGroupMessageCreator,
-    recipients: Set<ContactModel>,
-    group: GroupModel,
-    forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    identityStore: IdentityStoreInterface,
-    contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    groupService: GroupService,
-    blockedContactsService: IdListService,
-    taskCreator: TaskCreator,
-): Set<OutgoingMessageResult>? {
-    if (!groupService.isGroupMember(group)) {
-        logger.warn("Tried to send a message in a group where the user is not a member anymore")
-        return null
-    }
-
-    val groupMembers = groupService.getMembers(group).toSet()
-
-    return sendMessageToReceivers(
-        messageCreator,
-        recipients.intersect(groupMembers),
-        forwardSecurityMessageProcessor,
-        identityStore,
-        contactStore,
-        nonceFactory,
-        blockedContactsService,
-        taskCreator
-    )
-}
-
-/**
- * Run the _Common Send Steps_ for the given recipients. Note that this method does not run the
- * _Common Group Send Steps_. Therefore, this method can also be used to send a group message to
- * members that are not part of the group anymore (e.g. [GroupLeaveMessage]s) or in a group where
- * the user is not a member (e.g. when receiving a [GroupSetupMessage] from a blocked identity).
- */
-suspend fun ActiveTaskCodec.sendMessageToReceivers(
-    messageCreator: OutgoingCspMessageCreator,
-    recipients: Set<ContactModel>,
-    forwardSecurityMessageProcessor: ForwardSecurityMessageProcessor,
-    identityStore: IdentityStoreInterface,
-    contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    blockedContactsService: IdListService,
-    taskCreator: TaskCreator,
-): Set<OutgoingMessageResult> {
-    val myIdentity = identityStore.identity
-
-    val recipientList = recipients.filter { it.identity != myIdentity }
-    val messageList = recipientList.map { messageCreator.createAbstractMessage() }
-
-    // Perform some sanity checks
-    messageList.let {
-        val expectedSize = it.size
-        val messageSet = it.toSet()
-
-        if (messageSet.size < expectedSize) {
-            throw IllegalArgumentException("The message creator created at least two identical messages")
-        }
-
-        messageSet.map { message -> message.type }.toSet().size.let { numTypes ->
-            if (numTypes > 1) {
-                throw IllegalArgumentException("The message create created messages of $numTypes different types")
-            }
-        }
-    }
-
-    // Create list of recipients that are not blocked (or exempted from blocking) with the messages
-    val recipientMessageList = recipientList.zip(messageList).filter { (recipient, message) ->
-        //Filter blocked recipients except message type is exempted from blocking
-        (message.exemptFromBlocking() || !blockedContactsService.has(recipient.identity)).also {
-            if (!it) {
-                message.logMessage("Skipping message because recipient $recipient is blocked:")
-            }
-        }
-    }
-
-    // TODO(ANDR-2705): Reflect the message here
-
-    val createdAt = Date()
-
-    // Prepare messages to be sent
-    recipientMessageList.forEach { (recipient, message) ->
-        message.also {
-            it.fromIdentity = myIdentity
-            it.toIdentity = recipient.identity
-            it.date = createdAt
-        }
-        message.logMessage("Preparing to send")
-    }
-
-    // Create the send containers of the remaining recipients and messages
-    val sendContainers = recipientMessageList.map { (recipient, message) ->
-        MessageSendContainer.create(
-            recipient,
-            message,
-            forwardSecurityMessageProcessor,
-            nonceFactory,
-            this
-        )
-    }
-
-    // Cache the public keys of the contacts (if not available)
-    sendContainers.forEach { (recipient, _) ->
-        if (contactStore.getContactForIdentityIncludingCache(recipient.identity) == null) {
-            contactStore.addCachedContact(recipient)
-        }
-    }
-
-    // Send messages
-    sendContainers.forEach { messageContainer ->
-        val outgoingMessages = messageContainer.outgoingMessages
-
-        for ((message, nonce) in outgoingMessages.zip(messageContainer.nonces)) {
-            write(message.toCspMessage(identityStore, contactStore, nonceFactory, nonce))
-            message.logMessage("Sent")
-        }
-    }
-
-    // Await server acknowledgments
-    sendContainers.forEach { messageContainer ->
-        for (message in messageContainer.outgoingMessages) {
-            if (!message.hasFlags(ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK)) {
-                waitForServerAck(message.messageId, message.toIdentity)
-                message.logMessage("Received server ack for")
-            }
-        }
-    }
-
-    // Schedule user profile distribution tasks
-    sendContainers.forEach { messageContainer ->
-        // Schedule a user profile distribution task if at least one of the sent messages allows it
-        if (messageContainer.outgoingMessages.any { it.allowUserProfileDistribution() }) {
-            taskCreator.scheduleProfilePictureExecution(messageContainer.recipient.identity)
-        }
-    }
-
-    // Commit the session state of each recipient
-    sendContainers.forEach { messageContainer ->
-        messageContainer.forwardSecurityEncryptionResult?.let {
-            forwardSecurityMessageProcessor.commitSessionState(it)
-        }
-    }
-
-    // TODO(ANDR-2705): Reflect an outgoing message update
-
-    // Set the timestamp of each message container
-    val sentTimestamp = Date().time.toULong()
-    return sendContainers.map {
-        OutgoingMessageResult(
-            it.recipient,
-            it.forwardSecurityMode,
-            sentTimestamp,
-        )
-    }.toSet()
-}
-
-private fun AbstractMessage.logMessage(logMessage: String) {
-    logger.info(
-        "{} message {} of type {} to {}",
-        logMessage,
-        messageId,
-        Utils.byteToHex(type.toByte(), true, true),
-        toIdentity
-    )
-}
diff --git a/app/src/main/java/ch/threema/app/utils/QuoteUtil.java b/app/src/main/java/ch/threema/app/utils/QuoteUtil.java
index e766a33e..eec66640 100644
--- a/app/src/main/java/ch/threema/app/utils/QuoteUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/QuoteUtil.java
@@ -24,6 +24,7 @@ package ch.threema.app.utils;
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.util.Pair;
 
 import org.slf4j.Logger;
 
@@ -201,31 +202,53 @@ public class QuoteUtil {
 	}
 
 	/**
-	 * Extract body text and quoted message reference from text string containing a quote v2 signature and add to MessageModel
-	 * If no valid quote v2 signature is found, add full input text to body
-	 * @param messageModel where to add extracted information
-	 * @param text source text containing a quote v2 signature
+	 * Get the body and quoted message id based on the text of a text message. Note that the message
+	 * id is null, if the text does not contain a quote. If parsing the text fails, the passed text
+	 * is returned as body and the message id is null.
+	 *
+	 * @param text the text of a text message
+	 * @return a pair of the body and the quoted message id
 	 */
-	public static void addBodyAndQuotedMessageId(@NonNull AbstractMessageModel messageModel, @Nullable String text) {
+	@NonNull
+	public static Pair<String, String> getBodyAndQuotedMessageId(@Nullable String text) {
+		String body = text;
+		String quotedMessageId = null;
+
 		if (!TestUtil.isEmptyOrNull(text)) {
 			Matcher match = quoteV2MatchPattern.matcher(text);
 			try {
 				if (match.find()) {
 					if (match.groupCount() == 2) {
-						messageModel.setQuotedMessageId(match.group(1));
-						if (!TestUtil.isEmptyOrNull(match.group(2))) {
-							messageModel.setBody(match.group(2).trim());
-						} else {
-							messageModel.setBody("");
+						quotedMessageId = match.group(1);
+						body = match.group(2);
+						if (body == null) {
+							body = "";
 						}
-						return;
 					}
 				}
 			} catch (Exception e) {
-				//
+				logger.error("Could not extract quote from text");
 			}
 		}
-		messageModel.setBody(text);
+
+		return new Pair<>(body, quotedMessageId);
+	}
+
+
+	/**
+	 * Extract body text and quoted message reference from text string containing a quote v2 signature and add to MessageModel
+	 * If no valid quote v2 signature is found, add full input text to body
+	 * @param messageModel where to add extracted information
+	 * @param text source text containing a quote v2 signature
+	 */
+	public static void addBodyAndQuotedMessageId(@NonNull AbstractMessageModel messageModel, @Nullable String text) {
+		Pair<String, String> quoteContent = getBodyAndQuotedMessageId(text);
+
+		// The first string contains the body
+		messageModel.setBody(quoteContent.first);
+
+		// The second string contains the message id (as string)
+		messageModel.setQuotedMessageId(quoteContent.second);
 	}
 
 	/**
diff --git a/app/src/main/java/ch/threema/app/utils/RuntimeAssertions.kt b/app/src/main/java/ch/threema/app/utils/RuntimeAssertions.kt
deleted file mode 100644
index c075a819..00000000
--- a/app/src/main/java/ch/threema/app/utils/RuntimeAssertions.kt
+++ /dev/null
@@ -1,32 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-/**
- * An assertion that work at runtime, even if runtime assertions haven't been enabled
- * on the JVM using the -ea JVM option.
- */
-fun runtimeAssert(value: Boolean, message: String) {
-    if (!value) {
-        throw AssertionError("Assertion failed: $message")
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java b/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java
index 56738a69..8ea9089a 100644
--- a/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java
+++ b/app/src/main/java/ch/threema/app/utils/ShortcutUtil.java
@@ -461,7 +461,10 @@ public final class ShortcutUtil {
 	 * @param messageReceiver MessageReceiver represented by shortcut
 	 */
 	@WorkerThread
-	public static void updateShareTargetShortcut(MessageReceiver messageReceiver) {
+	public static void updateShareTargetShortcut(@Nullable MessageReceiver<?> messageReceiver) {
+        if (messageReceiver == null) {
+            return;
+        }
 		synchronized (dynamicShortcutLock) {
 			List<ShortcutInfoCompat> shortcutInfos = ShortcutManagerCompat.getDynamicShortcuts(getContext());
 			for (ShortcutInfoCompat shortcutInfo: shortcutInfos) {
diff --git a/app/src/main/java/ch/threema/app/utils/StreamUtil.java b/app/src/main/java/ch/threema/app/utils/StreamUtil.java
deleted file mode 100644
index 0b6687a1..00000000
--- a/app/src/main/java/ch/threema/app/utils/StreamUtil.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.net.Uri;
-
-import org.slf4j.Logger;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-
-import ch.threema.app.ThreemaApplication;
-import ch.threema.base.utils.LoggingUtil;
-
-public class StreamUtil {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("StreamUtil");
-
-	public static InputStream getFromUri(Context context, Uri uri) throws FileNotFoundException {
-		InputStream inputStream = null;
-
-		if (uri != null && uri.getScheme() != null) {
-			if (ContentResolver.SCHEME_CONTENT.equalsIgnoreCase(uri.getScheme())) {
-				try {
-					inputStream = context.getContentResolver().openInputStream(uri);
-				} catch (FileNotFoundException e) {
-					logger.info("Unable to get an InputStream for this file using ContentResolver: " + uri.toString());
-				}
-			}
-
-			if (inputStream == null) {
-				// try to open as local file if openInputStream fails for a content Uri
-				String filePath = FileUtil.getRealPathFromURI(context, uri);
-				String appPath;
-				String tmpPath;
-				String intTmpPath;
-
-				try {
-					tmpPath = ThreemaApplication.getServiceManager().getFileService().getTempPath().getAbsolutePath();
-					intTmpPath = ThreemaApplication.getServiceManager().getFileService().getIntTmpPath().getAbsolutePath();
-					appPath = context.getApplicationInfo().dataDir;
-				} catch (Exception e) {
-					return null;
-				}
-
-				if (TestUtil.required(filePath, appPath, tmpPath)) {
-					// do not allow sending of files from local directories - but allow tmp dir
-					if (!filePath.startsWith(appPath) || filePath.startsWith(tmpPath) || filePath.startsWith(intTmpPath)) {
-						inputStream = new FileInputStream(filePath);
-					} else {
-						throw new FileNotFoundException("File on private directory");
-					}
-				} else {
-					inputStream = context.getContentResolver().openInputStream(uri);
-				}
-			}
-			return inputStream;
-		} else {
-			throw new FileNotFoundException();
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/app/utils/StringExtensions.kt b/app/src/main/java/ch/threema/app/utils/StringExtensions.kt
deleted file mode 100644
index f2f12c16..00000000
--- a/app/src/main/java/ch/threema/app/utils/StringExtensions.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils
-
-fun String.capitalize() = TextUtil.capitalize(this)
diff --git a/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.java b/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.java
deleted file mode 100644
index f1f2fcd4..00000000
--- a/app/src/main/java/ch/threema/app/utils/WorkManagerUtil.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils;
-
-import com.google.common.util.concurrent.ListenableFuture;
-
-import org.slf4j.Logger;
-
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ExecutionException;
-
-import androidx.work.WorkInfo;
-import androidx.work.WorkManager;
-import ch.threema.base.utils.LoggingUtil;
-
-public class WorkManagerUtil {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("WorkManagerUtil");
-
-	/**
-	 * Check if periodic work with provided tag is already scheduled or running and has the same schedule period.
-	 * Cancel existing work in case of error
-	 * @param workManager An instance of the WorkManager
-	 * @param tag Unique work name
-	 * @param schedulePeriod scheduled period of this work
-	 * @return true if no periodic work with the same tag exists or the existing work has a different schedule period;
-	 *      false if the work already exists and has the same schedule period
-	 */
-	public static boolean shouldScheduleNewWorkManagerInstance(WorkManager workManager, String tag, long schedulePeriod) {
-		// check if work is already scheduled or running, if yes, do not attempt launch a new request
-		ListenableFuture<List<WorkInfo>> workInfos = workManager.getWorkInfosForUniqueWork(tag);
-		try {
-			List<WorkInfo> workInfoList = workInfos.get();
-			for (WorkInfo workInfo : workInfoList) {
-				WorkInfo.State state = workInfo.getState();
-				if (state == WorkInfo.State.RUNNING || state == WorkInfo.State.ENQUEUED) {
-					logger.debug("a job of the same name is already running or queued");
-					Set<String> tags = workInfo.getTags();
-					if (tags.size() > 0 && tags.contains(String.valueOf(schedulePeriod))) {
-						logger.debug("job has same schedule period");
-						return false;
-					} else {
-						logger.debug("job has a different schedule period");
-						break;
-					}
-				}
-			}
-		} catch (Exception e) {
-			logger.info("WorkManager Exception");
-			workManager.cancelUniqueWork(tag);
-		}
-		return true;
-	}
-
-	public static boolean isWorkManagerInstanceScheduled(WorkManager workManager, String tag) {
-		ListenableFuture<List<WorkInfo>> workInfos = workManager.getWorkInfosForUniqueWork(tag);
-		try {
-			List<WorkInfo> workInfoList = workInfos.get();
-			for (WorkInfo workInfo : workInfoList) {
-				WorkInfo.State state = workInfo.getState();
-				if (state == WorkInfo.State.ENQUEUED || state == WorkInfo.State.BLOCKED) {
-					return true;
-				}
-			}
-		} catch (ExecutionException | InterruptedException e) {
-			logger.error("Could not get work info", e);
-			return false;
-		}
-		return false;
-	}
-
-}
diff --git a/app/src/main/java/ch/threema/app/utils/compose/ComposeExtensions.kt b/app/src/main/java/ch/threema/app/utils/compose/ComposeExtensions.kt
deleted file mode 100644
index b3f22419..00000000
--- a/app/src/main/java/ch/threema/app/utils/compose/ComposeExtensions.kt
+++ /dev/null
@@ -1,40 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils.compose
-
-import android.content.Context
-import android.util.TypedValue
-import androidx.compose.runtime.Composable
-import androidx.compose.ui.graphics.Color
-import androidx.compose.ui.platform.LocalContext
-import androidx.compose.ui.res.colorResource
-
-@Composable
-fun getColor(color: Int): Color {
-    return colorResource(LocalContext.current.getColorFromAttrs(color).resourceId)
-}
-
-fun Context.getColorFromAttrs(attr: Int): TypedValue {
-    return TypedValue().apply {
-        theme.resolveAttribute(attr, this, true)
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/utils/executor/BackgroundExecutor.kt b/app/src/main/java/ch/threema/app/utils/executor/BackgroundExecutor.kt
deleted file mode 100644
index 13838350..00000000
--- a/app/src/main/java/ch/threema/app/utils/executor/BackgroundExecutor.kt
+++ /dev/null
@@ -1,119 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.utils.executor
-
-import android.os.Handler
-import android.os.Looper
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.Deferred
-import java.util.concurrent.Executors
-
-/**
- * A background executor that can be used to perform background work and afterwards update the UI.
- * Regarding usage, it similar to AsyncTasks.
- *
- * Note that if any exceptions are thrown in the [BackgroundTask], the completable deferred will be
- * completed exceptionally.
- */
-class BackgroundExecutor {
-    private val executor = Executors.newSingleThreadExecutor()
-    private val handler = Handler(Looper.getMainLooper())
-
-    /**
-     * Execute a task in this executor. The result of [BackgroundTask.runInBackground] is passed to
-     * [BackgroundTask.runAfter]. Use [executeDeferred] if a deferred is needed to get the result of
-     * the background task.
-     */
-    fun <R> execute(backgroundTask: BackgroundTask<R>) {
-        executeDeferred(backgroundTask)
-    }
-
-    /**
-     * Execute a task in this executor. The result of [BackgroundTask.runInBackground] is passed to
-     * [BackgroundTask.runAfter] and it is also returned as a deferred.
-     * If the deferred result is not used, use [execute] instead.
-     *
-     * @return a deferred that is completed normally after [BackgroundTask.runAfter] has been
-     * executed and exceptionally if an exception has been thrown during execution
-     */
-    fun <R> executeDeferred(backgroundTask: BackgroundTask<R>): Deferred<R> {
-        val completableDeferred = CompletableDeferred<R>()
-
-        // Run background task initialization on the same thread as the caller
-        try {
-            backgroundTask.runBefore()
-        } catch (e: Exception) {
-            completableDeferred.completeExceptionally(e)
-            return completableDeferred
-        }
-
-        executor.execute Executor@ {
-            // Execute background task in executor
-            val result = try {
-                backgroundTask.runInBackground()
-            } catch (e: Exception) {
-                completableDeferred.completeExceptionally(e)
-                return@Executor
-            }
-
-            // Run final method on main thread and complete the deferred afterwards
-            handler.post {
-                try {
-                    backgroundTask.runAfter(result)
-                    completableDeferred.complete(result)
-                } catch (e: Exception) {
-                    completableDeferred.completeExceptionally(e)
-                }
-            }
-        }
-
-        return completableDeferred
-    }
-}
-
-/**
- * A task that can be run with a [BackgroundExecutor] on a background thread.
- */
-interface BackgroundTask<R> {
-
-    /**
-     * This method is run before [runInBackground] on the same thread as the callee of
-     * [BackgroundExecutor.execute] is running.
-     */
-    fun runBefore() {
-        // The default implementation does not need to do anything
-    }
-
-    /**
-     * This method is run on the background thread. The result of it will be passed to [runAfter].
-     */
-    fun runInBackground(): R
-
-    /**
-     * This method is run on the UI thread after [runInBackground] has completed.
-     * @param result the result from [runInBackground]
-     */
-    fun runAfter(result: R) {
-        // The default implementation does not need to do anything
-    }
-
-}
diff --git a/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java b/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java
index 8f36b529..6f50c1b8 100644
--- a/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java
+++ b/app/src/main/java/ch/threema/app/voip/activities/CallActivity.java
@@ -125,6 +125,7 @@ import ch.threema.app.services.LifetimeService;
 import ch.threema.app.services.LockAppService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SensorService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.ui.AnimatedEllipsisTextView;
 import ch.threema.app.ui.BottomSheetItem;
 import ch.threema.app.ui.DebouncedOnClickListener;
@@ -151,6 +152,7 @@ import ch.threema.app.voip.services.VoipStateService;
 import ch.threema.app.voip.util.VoipUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
+import ch.threema.data.repositories.ContactModelRepository;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData;
@@ -284,6 +286,10 @@ public class CallActivity extends ThreemaActivity implements
 	private NotificationManagerCompat notificationManagerCompat;
 	private AudioManager audioManager;
 
+	@Nullable
+	private ContactModelRepository contactModelRepository;
+	@Nullable
+	private UserService userService;
 	private ContactService contactService;
 	private SensorService sensorService;
 	private PreferenceService preferenceService;
@@ -639,8 +645,8 @@ public class CallActivity extends ThreemaActivity implements
 		}
 
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
-			this.handleUpdate(contactModel.getIdentity());
+		public void onAvatarChanged(@NonNull String identity) {
+			this.handleUpdate(identity);
 		}
 
 		private void handleUpdate(String identity) {
@@ -733,7 +739,14 @@ public class CallActivity extends ThreemaActivity implements
 		// Threema services
 		try {
 			ServiceManager serviceManager = ThreemaApplication.getServiceManager();
+			if (serviceManager == null) {
+				logger.error("Service manager is null");
+				finish();
+				return;
+			}
+			this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
 			this.contactService = serviceManager.getContactService();
+			this.userService = serviceManager.getUserService();
 			this.sensorService = serviceManager.getSensorService();
 			this.preferenceService = serviceManager.getPreferenceService();
 			this.voipStateService = serviceManager.getVoipStateService();
@@ -1203,7 +1216,11 @@ public class CallActivity extends ThreemaActivity implements
 			}.execute();
 
 			this.commonViews.contactName.setText(NameUtil.getDisplayNameOrNickname(contact, true));
-			this.commonViews.contactDots.setImageDrawable(ContactUtil.getVerificationDrawable(this, contact));
+			this.commonViews.contactDots.setImageDrawable(ContactUtil.getVerificationDrawable(
+				this,
+				contact.verificationLevel,
+				contact.getWorkVerificationLevel()
+			));
 		}
 	}
 
@@ -1267,11 +1284,17 @@ public class CallActivity extends ThreemaActivity implements
 					setEnabled(this.commonViews.toggleOutgoingVideoButton, true);
 				} else {
 					try {
+						if (contactModelRepository == null || userService == null) {
+							logger.warn("Could not refresh feature mask due to unavailable services");
+							return;
+						}
+
 						CompletableFuture
 							.runAsync(new UpdateFeatureLevelRoutine(
-								contactService,
+								contactModelRepository,
+								userService,
 								apiConnector,
-								Collections.singletonList(contact)
+								Collections.singletonList(contact.getIdentity())
 							))
 							.thenRun(() -> RuntimeUtil.runOnUiThread(() -> {
 								if (!isDestroyed()) {
diff --git a/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java b/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java
index 15abcaaa..a9ae1f2b 100644
--- a/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java
+++ b/app/src/main/java/ch/threema/app/voip/activities/WebRTCDebugActivity.java
@@ -21,12 +21,9 @@
 
 package ch.threema.app.voip.activities;
 
-import static ch.threema.app.preference.SettingsAdvancedOptionsFragment.THREEMA_SUPPORT_IDENTITY;
-
 import android.annotation.SuppressLint;
 import android.content.ClipData;
 import android.content.ClipboardManager;
-import android.os.AsyncTask;
 import android.os.Bundle;
 import android.os.Handler;
 import android.view.MenuItem;
@@ -37,12 +34,6 @@ import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-
 import com.google.android.material.progressindicator.CircularProgressIndicator;
 
 import org.slf4j.Logger;
@@ -56,24 +47,35 @@ import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.activities.ThreemaToolbarActivity;
+import ch.threema.app.asynctasks.SendToSupportBackgroundTask;
+import ch.threema.app.asynctasks.SendToSupportResult;
 import ch.threema.app.dialogs.TextEntryDialog;
 import ch.threema.app.managers.ServiceManager;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.LocaleUtil;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.WebRTCUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.voip.PeerConnectionClient;
 import ch.threema.app.voip.util.SdpPatcher;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.protobuf.callsignaling.O2OCall;
-import ch.threema.storage.models.ContactModel;
 
 /**
  * An activity to debug problems with WebRTC (in the context of Threema Calls).
@@ -83,8 +85,13 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 	private static final String DIALOG_TAG_SEND_WEBRTC_DEBUG = "swd";
 
 	// Threema services
-	@NonNull private MessageService messageService;
-	@NonNull private ContactService contactService;
+	@Nullable private MessageService messageService;
+	@Nullable private ContactService contactService;
+	@Nullable private APIConnector apiConnector;
+	@Nullable private ContactModelRepository contactModelRepository;
+	@Nullable private UserService userService;
+
+	@Nullable private BackgroundExecutor backgroundExecutor;
 
 	// Views
 	@NonNull private CircularProgressIndicator progressBar;
@@ -126,6 +133,9 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 			finish();
 			return;
 		}
+		this.apiConnector = serviceManager.getAPIConnector();
+		this.contactModelRepository = serviceManager.getModelRepositories().getContacts();
+		this.userService = serviceManager.getUserService();
 
 		final ActionBar actionBar = getSupportActionBar();
 		if (actionBar != null) {
@@ -428,17 +438,30 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 
 	@SuppressLint("StaticFieldLeak")
 	private void sendToSupport(@NonNull String caption) {
-		if (this.contactService == null || messageService == null) {
+		if (
+			contactService == null
+				|| messageService == null
+				|| userService == null
+				|| apiConnector == null
+				|| contactModelRepository == null
+		) {
 			logger.error("Cannot send to support, some services are null");
 			return;
 		}
 
-		new AsyncTask<Void, Void, Boolean>() {
+		SendToSupportBackgroundTask sendToSupportTask = new SendToSupportBackgroundTask(
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			this
+		) {
+			@NonNull
 			@Override
-			protected Boolean doInBackground(Void... voids) {
+			public SendToSupportResult onSupportAvailable(@NonNull ContactModel contactModel) {
 				try {
-					final ContactModel contactModel = contactService.getOrCreateByIdentity(THREEMA_SUPPORT_IDENTITY, true);
-					final ContactMessageReceiver messageReceiver = contactService.createReceiver(contactModel);
+					final ContactMessageReceiver messageReceiver = contactService.createReceiver(
+						contactModel
+					);
 
 					messageService.sendText(clipboardString +
 						"\n---\n" +
@@ -448,23 +471,28 @@ public class WebRTCDebugActivity extends ThreemaToolbarActivity implements PeerC
 						"Threema " + ConfigUtils.getAppVersion() + "\n" +
 						getMyIdentity(), messageReceiver);
 
-					return true;
+					return SendToSupportResult.SUCCESS;
 				} catch (Exception e) {
 					logger.error("Exception while sending information to support", e);
-					return false;
+					return SendToSupportResult.FAILED;
 				}
 			}
 
 			@Override
-			protected void onPostExecute(Boolean success) {
+			public void onFinished(SendToSupportResult result) {
 				Toast.makeText(
 					getApplicationContext(),
-					Boolean.TRUE.equals(success) ? R.string.message_sent : R.string.an_error_occurred,
+					result == SendToSupportResult.SUCCESS ? R.string.message_sent : R.string.an_error_occurred,
 					Toast.LENGTH_LONG
 				).show();
 				finish();
 			}
-		}.execute();
+		};
+
+		if (backgroundExecutor == null) {
+			backgroundExecutor = new BackgroundExecutor();
+		}
+		backgroundExecutor.execute(sendToSupportTask);
 	}
 
 	@AnyThread
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt b/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt
index 35a1c693..1107044e 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/GroupCallManagerImpl.kt
@@ -615,8 +615,10 @@ class GroupCallManagerImpl(
 			return
 		}
 
-		logger.debug("Show group call notification")
-		notificationService.addGroupCallNotification(group, callerContactModel)
+        if (callerContactModel.identity != contactService.me.identity) {
+		    logger.debug("Show group call notification")
+            notificationService.addGroupCallNotification(group, callerContactModel)
+        }
 	}
 
 	/**
@@ -812,8 +814,7 @@ class GroupCallManagerImpl(
 			groupJson.put("id", Base64.encodeBytes(group.apiGroupId.groupId))
 
 			val membersJson = JSONArray()
-			groupService.getGroupIdentities(group)
-				.mapNotNull { contactService.getByIdentity(it) }
+			groupService.getMembers(group)
 				.forEach {
 					val member = JSONObject()
 					member.put("identity", it.identity)
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt b/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt
index cf73dd5f..5098666f 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallService.kt
@@ -65,6 +65,8 @@ import ch.threema.app.voip.services.VoipStateService
 import ch.threema.app.voip.util.VoipUtil
 import ch.threema.base.ThreemaException
 import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.storage.models.GroupModel
 import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.CoroutineScope
@@ -143,6 +145,8 @@ class GroupCallService : Service() {
     private lateinit var identityStore: IdentityStore
     private lateinit var contactService: ContactService
     private lateinit var groupService: GroupService
+    private lateinit var apiConnector: APIConnector
+    private lateinit var contactModelRepository: ContactModelRepository
     private lateinit var sfuConnection: SfuConnection
     private lateinit var preferenceService: PreferenceService
     private lateinit var voipStateService: VoipStateService
@@ -201,6 +205,8 @@ class GroupCallService : Service() {
         contactService = serviceManager.contactService
         sfuConnection = serviceManager.sfuConnection
         groupService = serviceManager.groupService
+        apiConnector = serviceManager.apiConnector
+        contactModelRepository = serviceManager.modelRepositories.contacts
         preferenceService = serviceManager.preferenceService
         voipStateService = serviceManager.voipStateService
     }
@@ -329,7 +335,9 @@ class GroupCallService : Service() {
                 controller.dependencies = GroupCallDependencies(
                     identityStore,
                     contactService,
-                    groupService
+                    groupService,
+                    apiConnector,
+                    contactModelRepository
                 )
                 CoroutineScope(GroupCallThreadUtil.DISPATCHER).launch {
                     launch { controller.join(applicationContext, sfuBaseUrl, sfuConnection) { stopService() } }
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallServiceBinder.kt b/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallServiceBinder.kt
deleted file mode 100644
index 38baf4cd..00000000
--- a/app/src/main/java/ch/threema/app/voip/groupcall/service/GroupCallServiceBinder.kt
+++ /dev/null
@@ -1,39 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2022-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.voip.groupcall.service
-
-import android.os.Binder
-import ch.threema.app.voip.CallAudioManager
-import ch.threema.app.voip.groupcall.sfu.GroupCallController
-import kotlinx.coroutines.CompletableDeferred
-
-class GroupCallServiceBinder(private val controllerDeferred : CompletableDeferred<GroupCallController>, private val audioManagerDeferred : CompletableDeferred<CallAudioManager>) :
-    Binder() {
-
-    suspend fun getGroupCallController(): GroupCallController {
-        return controllerDeferred.await()
-    }
-
-    suspend fun getCallAudioManager(): CallAudioManager {
-        return audioManagerDeferred.await()
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt
index 909fe667..4e912898 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/GroupCallDependencies.kt
@@ -24,9 +24,13 @@ package ch.threema.app.voip.groupcall.sfu
 import ch.threema.app.services.ContactService
 import ch.threema.app.services.GroupService
 import ch.threema.app.stores.IdentityStore
+import ch.threema.data.repositories.ContactModelRepository
+import ch.threema.domain.protocol.api.APIConnector
 
 data class GroupCallDependencies(
     val identityStore: IdentityStore,
     val contactService: ContactService,
-    val groupService: GroupService
+    val groupService: GroupService,
+    val apiConnector: APIConnector,
+    val contactModelRepository: ContactModelRepository,
 )
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt
index 3d8fc41f..c42e6662 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/P2PHandshake.kt
@@ -24,6 +24,11 @@ package ch.threema.app.voip.groupcall.sfu
 import androidx.annotation.AnyThread
 import androidx.annotation.UiThread
 import androidx.annotation.WorkerThread
+import ch.threema.app.ThreemaApplication
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask
+import ch.threema.app.asynctasks.ContactAvailable
+import ch.threema.app.asynctasks.Failed
 import ch.threema.app.voip.groupcall.GroupCallException
 import ch.threema.app.voip.groupcall.GroupCallThreadUtil
 import ch.threema.app.voip.groupcall.gcBlake2b
@@ -36,6 +41,7 @@ import ch.threema.app.voip.groupcall.sfu.webrtc.ConnectionCtx
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.ProtocolDefines
 import ch.threema.storage.models.ContactModel
+import ch.threema.storage.models.ContactModel.AcquaintanceLevel
 import com.neilalexander.jnacl.NaCl
 import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.Deferred
@@ -49,7 +55,7 @@ class P2PHandshake private constructor(
     val sender: LocalParticipant,
     val receiverId: ParticipantId,
     private val call: GroupCall,
-    initialState: HandshakeState
+    initialState: HandshakeState,
 ) {
     private var handshakeState: HandshakeState = initialState
         set(value) {
@@ -77,7 +83,8 @@ class P2PHandshake private constructor(
     lateinit var p2pContexts: P2PContexts
 
     private val queuedMessages = mutableListOf<P2PMessageContent>()
-    private val completedSignal: CompletableDeferred<Pair<P2PContexts, List<P2PMessageContent.MediaKey>>> = CompletableDeferred()
+    private val completedSignal: CompletableDeferred<Pair<P2PContexts, List<P2PMessageContent.MediaKey>>> =
+        CompletableDeferred()
 
     val isDone: Boolean
         get() = handshakeState == HandshakeState.DONE
@@ -113,10 +120,12 @@ class P2PHandshake private constructor(
                 logger.debug("Queuing Rekey to be sent once authenticated")
                 queuedMessages.add(message)
             }
+
             HandshakeState.DONE -> {
                 // Note: This is considered unreachable
                 throw Error("Cannot queue Rekey, handshake already done!")
             }
+
             HandshakeState.CANCELLED -> logger.debug("Ignoring Rekey because handshake is cancelled")
             else -> logger.debug("Ignoring Rekey because we have not sent a Handshake.*Auth yet")
         }
@@ -131,8 +140,14 @@ class P2PHandshake private constructor(
             try {
                 when (handshakeState) {
                     HandshakeState.INIT -> handleUnexpectedMessage(message)
-                    HandshakeState.AWAIT_EXISTING_PARTICIPANT_HELLO -> handleMessageInAwaitEpHelloState(message)
-                    HandshakeState.AWAIT_NEW_PARTICIPANT_HELLO -> handleMessageInAwaitNpHelloState(message)
+                    HandshakeState.AWAIT_EXISTING_PARTICIPANT_HELLO -> handleMessageInAwaitEpHelloState(
+                        message
+                    )
+
+                    HandshakeState.AWAIT_NEW_PARTICIPANT_HELLO -> handleMessageInAwaitNpHelloState(
+                        message
+                    )
+
                     HandshakeState.AWAIT_AUTH -> handleMessageInAwaitAuthState(message)
                     HandshakeState.DONE, HandshakeState.CANCELLED -> handleUnexpectedMessage(message)
                 }
@@ -161,7 +176,8 @@ class P2PHandshake private constructor(
         logger.info("Create Hello from {} to {}", sender.id, receiverId)
         val hello = Handshake.Hello(
             call.dependencies.identityStore.identity,
-            call.dependencies.identityStore.publicNickname ?: call.dependencies.identityStore.identity,
+            call.dependencies.identityStore.publicNickname
+                ?: call.dependencies.identityStore.identity,
             senderP2PContext.pckPublic,
             senderP2PContext.pcck
         )
@@ -180,7 +196,8 @@ class P2PHandshake private constructor(
             receiverP2PContext.pcck,
             call.context.connectionCtx.pcmk.all().map { P2PMessageContent.MediaKey.fromState(it) },
         )
-        val encryptedInnerData = NaCl.symmetricEncryptData(auth.getEnvelopeBytes(), gcnhak, innerNonce)
+        val encryptedInnerData =
+            NaCl.symmetricEncryptData(auth.getEnvelopeBytes(), gcnhak, innerNonce)
         val encryptedAuthData = pck.encrypt(
             innerNonce + encryptedInnerData,
             senderP2PContext.nextPcckNonce()
@@ -200,9 +217,16 @@ class P2PHandshake private constructor(
                 renderer: SurfaceViewRenderer,
                 width: Int,
                 height: Int,
-                fps: Int
+                fps: Int,
             ): DetachSinkFn {
-                call.context.sendMessageToSfu { P2SMessage.SubscribeParticipantCamera(participantId, width, height, fps) }
+                call.context.sendMessageToSfu {
+                    P2SMessage.SubscribeParticipantCamera(
+                        participantId,
+                        width,
+                        height,
+                        fps
+                    )
+                }
 
                 participantLogger.trace("Starting to render remote camera video")
                 val videoContext = remoteCtx?.cameraVideoContext
@@ -215,14 +239,22 @@ class P2PHandshake private constructor(
             @UiThread
             override fun unsubscribeCamera() {
                 participantLogger.trace("Unsubscribe camera participant={}", participantId.id)
-                call.context.sendMessageToSfu { P2SMessage.UnsubscribeParticipantCamera(participantId) }
+                call.context.sendMessageToSfu {
+                    P2SMessage.UnsubscribeParticipantCamera(
+                        participantId
+                    )
+                }
             }
         }
     }
 
     @WorkerThread
     private fun handleUnexpectedMessage(message: P2POuterEnvelope) {
-        logger.warn("Received unexpected message from {} while in handshake state '{}'", message.senderId, handshakeState)
+        logger.warn(
+            "Received unexpected message from {} while in handshake state '{}'",
+            message.senderId,
+            handshakeState
+        )
     }
 
     @WorkerThread
@@ -273,7 +305,7 @@ class P2PHandshake private constructor(
     private fun isGroupMember(identity: String): Boolean {
         val groupService = call.dependencies.groupService
         return groupService.getById(call.description.groupId.id)?.let {
-            identity in groupService.getGroupIdentities(it)
+            groupService.isGroupMember(it, identity)
         } ?: false
     }
 
@@ -307,7 +339,7 @@ class P2PHandshake private constructor(
         GroupCallThreadUtil.assertDispatcherThread()
 
         try {
-            receiverContact = call.dependencies.contactService.getOrCreateByIdentity(hello.identity, false)
+            receiverContact = getOrCreateContact(hello.identity)
             val receiverParticipant = createRemoteParticipant(receiverId)
             receiverP2PContext = RemoteP2PContext(receiverParticipant, hello.pck, hello.pcck)
         } catch (e: Exception) {
@@ -315,6 +347,36 @@ class P2PHandshake private constructor(
         }
     }
 
+    @WorkerThread
+    private fun getOrCreateContact(identity: String): ContactModel {
+        // Check if the contact already exists
+        call.dependencies.contactService.getByIdentity(identity)?.let {
+            return it
+        }
+
+        val result = BasicAddOrUpdateContactBackgroundTask(
+            identity = identity,
+            AcquaintanceLevel.GROUP,
+            myIdentity = sender.identity,
+            call.dependencies.apiConnector,
+            call.dependencies.contactModelRepository,
+            AddContactRestrictionPolicy.CHECK,
+            context = ThreemaApplication.getAppContext(),
+            null
+        ).runSynchronously()
+
+        when (result) {
+            is ContactAvailable -> Unit
+            is Failed -> {
+                logger.error("Could not create contact: {}", result.message)
+                throw IllegalStateException("Could not create contact")
+            }
+        }
+
+        return call.dependencies.contactService.getByIdentity(identity)
+            ?: throw IllegalStateException("Contact must exist after creating it")
+    }
+
     @WorkerThread
     private fun handleMessageInAwaitAuthState(message: P2POuterEnvelope) {
         GroupCallThreadUtil.assertDispatcherThread()
@@ -332,7 +394,9 @@ class P2PHandshake private constructor(
 
     @WorkerThread
     private fun hasValidRepeatedAuthFeatures(auth: Handshake.Auth): Boolean {
-        return auth.pck.contentEquals(senderP2PContext.pckPublic) && auth.pcck.contentEquals(senderP2PContext.pcck)
+        return auth.pck.contentEquals(senderP2PContext.pckPublic) && auth.pcck.contentEquals(
+            senderP2PContext.pcck
+        )
     }
 
     @WorkerThread
@@ -367,7 +431,8 @@ class P2PHandshake private constructor(
         GroupCallThreadUtil.assertDispatcherThread()
 
         val nonce = decryptedOuterData.copyOfRange(0, NaCl.NONCEBYTES)
-        val encryptedInnerData = decryptedOuterData.copyOfRange(NaCl.NONCEBYTES, decryptedOuterData.size)
+        val encryptedInnerData =
+            decryptedOuterData.copyOfRange(NaCl.NONCEBYTES, decryptedOuterData.size)
         return NaCl.symmetricDecryptData(encryptedInnerData, gcnhak, nonce)
     }
 
@@ -407,7 +472,7 @@ class P2PHandshake private constructor(
     @WorkerThread
     internal class P2PHandshakeFactory(
         private val sender: LocalParticipant,
-        private val call: GroupCall
+        private val call: GroupCall,
     ) {
         /**
          * This will initiate a Handshake with an existing call participant.
diff --git a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt
index 2fd54c12..89d246f6 100644
--- a/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt
+++ b/app/src/main/java/ch/threema/app/voip/groupcall/sfu/SfuConnectionImpl.kt
@@ -178,7 +178,7 @@ internal class SfuConnectionImpl (
     }
 
     private fun getUserAgent(): String {
-        return "${ProtocolStrings.USER_AGENT}/${version.version}"
+        return "${ProtocolStrings.USER_AGENT}/${version.versionString}"
     }
 
     @WorkerThread
diff --git a/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java b/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java
index 0f1fe32a..54f58a5a 100644
--- a/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java
+++ b/app/src/main/java/ch/threema/app/voip/services/VoipStateService.java
@@ -21,22 +21,6 @@
 
 package ch.threema.app.voip.services;
 
-import static ch.threema.app.ThreemaApplication.INCOMING_CALL_NOTIFICATION_ID;
-import static ch.threema.app.ThreemaApplication.getAppContext;
-import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
-import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_MUTABLE;
-import static ch.threema.app.voip.activities.CallActivity.EXTRA_ACCEPT_INCOMING_CALL;
-import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CALL_ID;
-import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CONTACT_IDENTITY;
-import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_REJECT_REASON;
-import static ch.threema.app.voip.services.VoipCallService.ACTION_ICE_CANDIDATES;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_ACTIVITY_MODE;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CALL_ID;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANCEL_WEAR;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANDIDATES;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_CONTACT_IDENTITY;
-import static ch.threema.app.voip.services.VoipCallService.EXTRA_IS_INITIATOR;
-
 import android.app.ActivityOptions;
 import android.app.Notification;
 import android.app.PendingIntent;
@@ -61,18 +45,6 @@ import android.text.Spannable;
 import android.text.SpannableString;
 import android.text.style.ForegroundColorSpan;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.WorkerThread;
-import androidx.core.app.NotificationCompat;
-import androidx.core.app.NotificationManagerCompat;
-import androidx.core.content.LocusIdCompat;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import androidx.work.Data;
-import androidx.work.OneTimeWorkRequest;
-import androidx.work.WorkManager;
-
 import org.slf4j.Logger;
 import org.webrtc.IceCandidate;
 import org.webrtc.SessionDescription;
@@ -88,17 +60,30 @@ import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.WorkerThread;
+import androidx.core.app.NotificationCompat;
+import androidx.core.app.NotificationManagerCompat;
+import androidx.core.content.LocusIdCompat;
+import androidx.localbroadcastmanager.content.LocalBroadcastManager;
+import androidx.work.Data;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkManager;
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.messagereceiver.ContactMessageReceiver;
 import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.notifications.NotificationChannels;
 import ch.threema.app.notifications.NotificationGroups;
+import ch.threema.app.routines.UpdateFeatureLevelRoutine;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.LifetimeService;
 import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.RingtoneService;
 import ch.threema.app.utils.ConfigUtils;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.DNDUtil;
 import ch.threema.app.utils.IdUtil;
 import ch.threema.app.utils.MediaPlayerStateWrapper;
@@ -129,6 +114,22 @@ import ch.threema.domain.protocol.csp.messages.voip.features.VideoFeature;
 import ch.threema.storage.models.ContactModel;
 import java8.util.concurrent.CompletableFuture;
 
+import static ch.threema.app.ThreemaApplication.INCOMING_CALL_NOTIFICATION_ID;
+import static ch.threema.app.ThreemaApplication.getAppContext;
+import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_IMMUTABLE;
+import static ch.threema.app.utils.IntentDataUtil.PENDING_INTENT_FLAG_MUTABLE;
+import static ch.threema.app.voip.activities.CallActivity.EXTRA_ACCEPT_INCOMING_CALL;
+import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CALL_ID;
+import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_CONTACT_IDENTITY;
+import static ch.threema.app.voip.services.CallRejectWorkerKt.KEY_REJECT_REASON;
+import static ch.threema.app.voip.services.VoipCallService.ACTION_ICE_CANDIDATES;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_ACTIVITY_MODE;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CALL_ID;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANCEL_WEAR;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CANDIDATES;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_CONTACT_IDENTITY;
+import static ch.threema.app.voip.services.VoipCallService.EXTRA_IS_INITIATOR;
+
 /**
  * The service keeping track of VoIP call state.
  * <p>
@@ -576,7 +577,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
             return false;
         }
         final String sdpType = offer.getSdpType();
-        if (!sdpType.equals("offer")) {
+        if (sdpType == null || !sdpType.equals("offer")) {
             logger.error("Offer data is invalid: Sdp type is {}, not offer", sdpType);
             return false;
         }
@@ -632,13 +633,13 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
      * @return true if messages was successfully processed
      */
     @WorkerThread
-    public synchronized boolean handleCallOffer(final VoipCallOfferMessage msg) {
+    public synchronized boolean handleCallOffer(@NonNull final VoipCallOfferMessage voipCallOfferMessage) {
         // Unwrap data
-        final String callerIdentity = msg.getFromIdentity();
-        final VoipCallOfferData callOfferData = msg.getData();
+        final String callerIdentity = voipCallOfferMessage.getFromIdentity();
+        final VoipCallOfferData callOfferData = voipCallOfferMessage.getData();
         if (callOfferData == null) {
             logger.warn("Call offer received from {}. Data is null, ignoring.", callerIdentity);
-            return true;
+            return false;
         }
         final long callId = callOfferData.getCallIdOrDefault(0L);
         logCallInfo(
@@ -652,7 +653,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         final ContactModel contact = this.contactService.getByIdentity(callerIdentity);
         if (contact == null) {
             logCallError(callId, "Could not fetch contact for identity {}", callerIdentity);
-            return true;
+            return false;
         }
 
         // Handle some reasons for rejecting calls...
@@ -698,7 +699,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         Config.getTurnServerCache().prefetchTurnServers();
 
         // Reset fetch cache
-        ch.threema.app.routines.UpdateFeatureLevelRoutine.removeTimeCache(contact);
+        UpdateFeatureLevelRoutine.removeTimeCache(contact.getIdentity());
 
         // Store offer in offer map
         logger.debug("Adding information for call {} to offerMap", callId);
@@ -736,7 +737,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         this.setStateRinging(callId);
 
         // Show call notification
-        final Notification notification = this.showNotification(contact, accept, reject, msg);
+        final Notification notification = this.showNotification(contact, accept, reject, voipCallOfferMessage);
 
         DNDUtil dndUtil = DNDUtil.getInstance();
         boolean isReceiverMuted = dndUtil.isMutedPrivate(messageReceiver, null);
@@ -752,7 +753,9 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         this.startVibration(notification, isMuted);
 
         // Update conversation timestamp
-        contactService.bumpLastUpdate(callerIdentity);
+        if (voipCallOfferMessage.bumpLastUpdate()) {
+            contactService.bumpLastUpdate(callerIdentity);
+        }
 
         // Send "ringing" message to caller
         try {
@@ -770,7 +773,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         // Notify listeners
         VoipListenerManager.messageListener.handle(listener -> {
             if (listener.handle(callerIdentity)) {
-                listener.onOffer(callerIdentity, msg.getData());
+                listener.onOffer(callerIdentity, voipCallOfferMessage.getData());
             }
         });
         VoipListenerManager.callEventListener.handle(listener -> listener.onRinging(callerIdentity));
@@ -854,16 +857,16 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
      * @return true if messages was successfully processed
      */
     @WorkerThread
-    public synchronized boolean handleICECandidates(final VoipICECandidatesMessage msg) {
+    public synchronized boolean handleICECandidates(@NonNull final VoipICECandidatesMessage voipICECandidatesMessage) {
         // Unwrap data
-        final VoipICECandidatesData candidatesData = msg.getData();
+        final VoipICECandidatesData candidatesData = voipICECandidatesMessage.getData();
         if (candidatesData == null) {
-            logger.warn("Call ICE candidate message received from {}. Data is null, ignoring", msg.getFromIdentity());
-            return true;
+            logger.warn("Call ICE candidate message received from {}. Data is null, ignoring", voipICECandidatesMessage.getFromIdentity());
+            return false;
         }
         if (candidatesData.getCandidates() == null) {
-            logger.warn("Call ICE candidate message received from {}. Candidates are null, ignoring", msg.getFromIdentity());
-            return true;
+            logger.warn("Call ICE candidate message received from {}. Candidates are null, ignoring", voipICECandidatesMessage.getFromIdentity());
+            return false;
         }
 
         // Validate Call ID
@@ -871,21 +874,21 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         if (!this.isCallIdValid(callId)) {
             logger.info(
                 "Call ICE candidate message received from {} for an invalid Call ID ({}, local={}), ignoring",
-                msg.getFromIdentity(), callId, this.callState.getCallId()
+                voipICECandidatesMessage.getFromIdentity(), callId, this.callState.getCallId()
             );
-            return true;
+            return false;
         }
 
         // The "removed" flag is deprecated, see ANDR-1145 / SE-66
         if (candidatesData.isRemoved()) {
             logCallInfo(callId, "Call ICE candidate message received from {} with removed=true, ignoring");
-            return true;
+            return false;
         }
 
         logCallInfo(
             callId,
             "Call ICE candidate message received from {} ({} candidates)",
-            msg.getFromIdentity(), candidatesData.getCandidates().length
+            voipICECandidatesMessage.getFromIdentity(), candidatesData.getCandidates().length
         );
         for (VoipICECandidatesData.Candidate candidate : candidatesData.getCandidates()) {
             logCallInfo(callId, "  Incoming ICE candidate: {}", candidate.getCandidate());
@@ -894,21 +897,19 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         // Handle candidates depending on state
         if (this.callState.isIdle() || this.callState.isRinging()) {
             // If the call hasn't been started yet, cache the candidate(s)
-            this.cacheCandidate(msg.getFromIdentity(), candidatesData);
+            this.cacheCandidate(voipICECandidatesMessage.getFromIdentity(), candidatesData);
         } else if (this.callState.isInitializing() || this.callState.isCalling()) {
             // Otherwise, send candidate(s) directly to call service via broadcast
             Intent intent = new Intent();
             intent.setAction(ACTION_ICE_CANDIDATES);
-            intent.putExtra(EXTRA_CALL_ID, msg.getData().getCallIdOrDefault(0L));
-            intent.putExtra(EXTRA_CONTACT_IDENTITY, msg.getFromIdentity());
+            intent.putExtra(EXTRA_CALL_ID, voipICECandidatesMessage.getData().getCallIdOrDefault(0L));
+            intent.putExtra(EXTRA_CONTACT_IDENTITY, voipICECandidatesMessage.getFromIdentity());
             intent.putExtra(EXTRA_CANDIDATES, candidatesData);
             LocalBroadcastManager.getInstance(appContext).sendBroadcast(intent);
         } else {
             logCallWarning(callId, "Received ICE candidates in invalid call state ({})", this.callState);
+            return false;
         }
-
-        // Otherwise, ignore message.
-
         return true;
     }
 
@@ -965,30 +966,30 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
      * @return true if message was successfully processed
      */
     @WorkerThread
-    public synchronized boolean handleRemoteCallHangup(final VoipCallHangupMessage msg) {
+    public synchronized boolean handleRemoteCallHangup(@NonNull final VoipCallHangupMessage voipCallHangupMessage) {
         // Validate Call ID
         //
         // NOTE: Hangup messages from older Threema versions may not have any associated data!
         // NOTE: If a remote hangup message arrives with an invalid call id that does not appear
         // in the call history, it is a missed call
-        final long callId = msg.getData() == null
+        final long callId = voipCallHangupMessage.getData() == null
             ? 0L
-            : msg.getData().getCallIdOrDefault(0L);
+            : voipCallHangupMessage.getData().getCallIdOrDefault(0L);
         if (!this.isCallIdValid(callId)) {
-            if (isMissedCall(msg, callId)) {
-                handleMissedCall(msg, callId, false);
+            if (isMissedCall(voipCallHangupMessage, callId)) {
+                handleMissedCall(voipCallHangupMessage, callId, false);
                 return true;
             }
             logger.info(
                 "Call hangup message received from {} for an invalid Call ID ({}, local={}), ignoring",
-                msg.getFromIdentity(), callId, this.callState.getCallId()
+                voipCallHangupMessage.getFromIdentity(), callId, this.callState.getCallId()
             );
-            return true;
+            return false;
         }
 
-        logCallInfo(callId, "Call hangup message received from {}", msg.getFromIdentity());
+        logCallInfo(callId, "Call hangup message received from {}", voipCallHangupMessage.getFromIdentity());
 
-        final String identity = msg.getFromIdentity();
+        final String identity = voipCallHangupMessage.getFromIdentity();
 
         final CallStateSnapshot prevState = this.callState.getStateSnapshot();
         final Integer duration = getCallDuration();
@@ -1003,20 +1004,20 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         this.setStateIdle();
 
         // Cancel call notification for that person
-        this.cancelCallNotification(msg.getFromIdentity(), CallActivity.ACTION_DISCONNECTED);
+        this.cancelCallNotification(voipCallHangupMessage.getFromIdentity(), CallActivity.ACTION_DISCONNECTED);
 
         // Notify listeners
         VoipListenerManager.messageListener.handle(listener -> {
             if (listener.handle(identity)) {
-                listener.onHangup(identity, msg.getData());
+                listener.onHangup(identity, voipCallHangupMessage.getData());
             }
         });
         if (incoming && (prevState.isIdle() || prevState.isRinging() || prevState.isInitializing())) {
             final boolean accepted = prevState.isInitializing();
-            handleMissedCall(msg, callId, accepted);
+            handleMissedCall(voipCallHangupMessage, callId, accepted);
         } else if (prevState.isCalling() && duration != null) {
             VoipListenerManager.callEventListener.handle(listener -> {
-                listener.onFinished(callId, msg.getFromIdentity(), !incoming, duration);
+                listener.onFinished(callId, voipCallHangupMessage.getFromIdentity(), !incoming, duration);
             });
         }
 
@@ -1063,13 +1064,8 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
         // ANDR-1140: If we are the initiator, then we will have initialized the call ID to a
         // random value. If however the remote device does not yet support call IDs, then returned
         // messages will not contain a Call ID. Accept the messages anyways.
-        final boolean isInitiatior = this.isInitiator() == Boolean.TRUE;
-        if (isInitiatior && callId == 0L) {
-            return true;
-        }
-
-        // Otherwise, there's a call ID mismatch.
-        return false;
+        final boolean isInitiator = this.isInitiator() == Boolean.TRUE;
+        return isInitiator && callId == 0L;
     }
 
     /**
@@ -1591,7 +1587,7 @@ public class VoipStateService implements AudioManager.OnAudioFocusChangeListener
                 nbuilder.addPerson(contactLookupUri);
             }
 
-            nbuilder.setLocusId(new LocusIdCompat(contactService.getUniqueIdString(contact)));
+            nbuilder.setLocusId(new LocusIdCompat(ContactUtil.getUniqueIdString(contact.getIdentity())));
 
             // Actions
             final SpannableString rejectString = new SpannableString(appContext.getString(R.string.voip_reject));
diff --git a/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java b/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java
index 2ad3b582..6fbb8785 100644
--- a/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java
+++ b/app/src/main/java/ch/threema/app/voip/util/VoipUtil.java
@@ -31,6 +31,10 @@ import android.telecom.TelecomManager;
 import android.telephony.TelephonyManager;
 import android.widget.Toast;
 
+import org.slf4j.Logger;
+
+import java.util.Collections;
+
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.RequiresApi;
@@ -38,11 +42,6 @@ import androidx.appcompat.app.AppCompatActivity;
 import androidx.core.content.ContextCompat;
 import androidx.fragment.app.FragmentManager;
 import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-
-import org.slf4j.Logger;
-
-import java.util.Collections;
-
 import ch.threema.app.R;
 import ch.threema.app.ThreemaApplication;
 import ch.threema.app.dialogs.GenericProgressDialog;
@@ -176,15 +175,14 @@ public class VoipUtil {
 				protected Exception doInBackground(Void... params) {
 					try {
 						// Reset the cache (only for Beta?)
-						UpdateFeatureLevelRoutine.removeTimeCache(contactModel);
+						UpdateFeatureLevelRoutine.removeTimeCache(contactModel.getIdentity());
 
-						(new UpdateFeatureLevelRoutine
-								(
-										serviceManager.getContactService(),
-										// Bad code
-										serviceManager.getAPIConnector(),
-										Collections.singletonList(contactModel)
-								)).run();
+						new UpdateFeatureLevelRoutine(
+							serviceManager.getModelRepositories().getContacts(),
+							serviceManager.getUserService(),
+							serviceManager.getAPIConnector(),
+							Collections.singletonList(contactModel.getIdentity())
+						).run();
 					} catch (Exception e) {
 						return e;
 					}
diff --git a/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java b/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java
index cea67bef..4697f281 100644
--- a/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java
+++ b/app/src/main/java/ch/threema/app/webclient/activities/WebDiagnosticsActivity.java
@@ -21,8 +21,6 @@
 
 package ch.threema.app.webclient.activities;
 
-import static ch.threema.app.preference.SettingsAdvancedOptionsFragment.THREEMA_SUPPORT_IDENTITY;
-
 import android.annotation.SuppressLint;
 import android.content.ClipData;
 import android.content.ClipboardManager;
@@ -30,7 +28,6 @@ import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.Network;
 import android.net.NetworkInfo;
-import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
@@ -42,12 +39,6 @@ import android.widget.ListView;
 import android.widget.TextView;
 import android.widget.Toast;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.UiThread;
-import androidx.appcompat.app.ActionBar;
-
 import com.google.android.material.progressindicator.CircularProgressIndicator;
 import com.neovisionaries.ws.client.DualStackMode;
 import com.neovisionaries.ws.client.WebSocket;
@@ -86,24 +77,35 @@ import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.UiThread;
+import androidx.appcompat.app.ActionBar;
 import ch.threema.app.R;
 import ch.threema.app.activities.ThreemaToolbarActivity;
+import ch.threema.app.asynctasks.SendToSupportBackgroundTask;
+import ch.threema.app.asynctasks.SendToSupportResult;
 import ch.threema.app.dialogs.TextEntryDialog;
 import ch.threema.app.exceptions.FileSystemNotPresentException;
-import ch.threema.app.messagereceiver.ContactMessageReceiver;
+import ch.threema.app.messagereceiver.MessageReceiver;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.MessageService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.utils.WebRTCUtil;
+import ch.threema.app.utils.executor.BackgroundExecutor;
 import ch.threema.app.webclient.utils.DefaultNoopPeerConnectionObserver;
 import ch.threema.app.webclient.utils.DefaultNoopWebSocketListener;
 import ch.threema.app.webclient.webrtc.PeerConnectionWrapper;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.models.ContactModel;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.localcrypto.MasterKeyLockedException;
-import ch.threema.storage.models.ContactModel;
 
 @SuppressWarnings("FieldCanBeLocal")
 @UiThread
@@ -152,6 +154,7 @@ public class WebDiagnosticsActivity extends ThreemaToolbarActivity implements Te
 	// Executor service that should be used for running creation / destruction
 	// of the peer connection and related objects.
 	@Nullable private ScheduledExecutorService webrtcExecutor;
+	@Nullable private BackgroundExecutor backgroundExecutor;
 
 	@Override
 	protected void onCreate(@Nullable Bundle savedInstanceState) {
@@ -303,23 +306,27 @@ public class WebDiagnosticsActivity extends ThreemaToolbarActivity implements Te
 			return;
 		}
 
-		if (this.contactService == null || messageService == null) {
+		if (this.contactService == null) {
 			return;
 		}
 
-		new AsyncTask<Void, Void, ContactMessageReceiver>() {
-			@Override
-			protected ContactMessageReceiver doInBackground(Void... voids) {
-				try {
-					final ContactModel contactModel = contactService.getOrCreateByIdentity(THREEMA_SUPPORT_IDENTITY, true);
-					return contactService.createReceiver(contactModel);
-				} catch (Exception e) {
-					return null;
-				}
-			}
+		final UserService userService = serviceManager.getUserService();
+		final APIConnector apiConnector = serviceManager.getAPIConnector();
+		final ContactModelRepository contactModelRepository = serviceManager.getModelRepositories().getContacts();
+		if (backgroundExecutor == null) {
+			this.backgroundExecutor = new BackgroundExecutor();
+		}
 
+		backgroundExecutor.execute(new SendToSupportBackgroundTask(
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			this
+		) {
 			@Override
-			protected void onPostExecute(ContactMessageReceiver messageReceiver) {
+			@NonNull
+			public SendToSupportResult onSupportAvailable(@NonNull ContactModel contactModel) {
+				MessageReceiver<?> messageReceiver = contactService.createReceiver(contactModel);
 				try {
 					messageService.sendText(clipboardString +
 						"\n---\n" +
@@ -328,15 +335,23 @@ public class WebDiagnosticsActivity extends ThreemaToolbarActivity implements Te
 						ConfigUtils.getSupportDeviceInfo() + "\n" +
 						"Threema " + ConfigUtils.getAppVersion() + "\n" +
 						getMyIdentity(), messageReceiver);
-					Toast.makeText(getApplicationContext(), R.string.message_sent, Toast.LENGTH_LONG).show();
 					finish();
-					return;
-				} catch (Exception e1) {
-					logger.error("Exception", e1);
+					return SendToSupportResult.SUCCESS;
+				} catch (Exception e) {
+					logger.error("Exception", e);
 				}
-				Toast.makeText(getApplicationContext(), R.string.an_error_occurred, Toast.LENGTH_LONG).show();
+				return SendToSupportResult.FAILED;
 			}
-		}.execute();
+
+			@Override
+			public void onFinished(SendToSupportResult result) {
+				if (result == SendToSupportResult.SUCCESS) {
+					Toast.makeText(WebDiagnosticsActivity.this, R.string.message_sent, Toast.LENGTH_LONG).show();
+				} else {
+					Toast.makeText(WebDiagnosticsActivity.this, R.string.an_error_occurred, Toast.LENGTH_LONG).show();
+				}
+			}
+		});
 	}
 
 	@UiThread
diff --git a/app/src/main/java/ch/threema/app/webclient/converter/Contact.java b/app/src/main/java/ch/threema/app/webclient/converter/Contact.java
index 83cfa079..92e949b3 100644
--- a/app/src/main/java/ch/threema/app/webclient/converter/Contact.java
+++ b/app/src/main/java/ch/threema/app/webclient/converter/Contact.java
@@ -38,6 +38,7 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.NameUtil;
 import ch.threema.app.webclient.exceptions.ConversionException;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.protocol.ThreemaFeature;
 import ch.threema.storage.models.ContactModel;
@@ -103,13 +104,13 @@ public class Contact extends Converter {
 			// TODO(ANDR-2708): Remove
 			builder.put(FEATURE_LEVEL, ThreemaFeature.featureMaskToLevel(featureMask));
 
-			boolean isSecretChat = getHiddenChatListService().has(getContactService().getUniqueIdString(contact));
+			boolean isSecretChat = getHiddenChatListService().has(ContactUtil.getUniqueIdString(contact.getIdentity()));
 			builder.put(Receiver.LOCKED, isSecretChat);
 			builder.put(Receiver.VISIBLE, !isSecretChat || !getPreferenceService().isPrivateChatsHidden());
 
 			//define access
 			builder.put(Receiver.ACCESS, (new MsgpackObjectBuilder())
-					.put(Receiver.CAN_DELETE, getContactService().getAccess(contact).canDelete())
+					.put(Receiver.CAN_DELETE, getContactService().getAccess(contact.getIdentity()).canDelete())
 					.put(CAN_CHANGE_AVATAR, ContactUtil.canChangeAvatar(contact, getPreferenceService(), getFileService()))
 					.put(CAN_CHANGE_FIRST_NAME, ContactUtil.canChangeFirstName(contact))
 					.put(CAN_CHANGE_LAST_NAME, ContactUtil.canChangeLastName(contact)));
@@ -246,11 +247,11 @@ public class Contact extends Converter {
 	public static ContactService.Filter getContactFilter() {
 		return new ContactService.Filter() {
 			@Override
-			public ContactModel.State[] states() {
-				return new ContactModel.State[] {
-					ContactModel.State.ACTIVE,
-					ContactModel.State.INACTIVE,
-					ContactModel.State.INVALID,
+			public IdentityState[] states() {
+				return new IdentityState[] {
+					IdentityState.ACTIVE,
+					IdentityState.INACTIVE,
+					IdentityState.INVALID,
 				};
 			}
 
diff --git a/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java b/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java
index 5423c386..c58d6401 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/BatteryStatusServiceImpl.java
@@ -95,7 +95,8 @@ public class BatteryStatusServiceImpl implements BatteryStatusService {
 	/**
 	 * Subscribe to the battery status broadcast.
 	 */
-	public void acquire(WebClientSessionModel session) {
+	@Override
+    public void acquire(WebClientSessionModel session) {
 		logger.debug("Acquire webclient battery status subscription for session {}", session.getId());
 		if (!this.acquiredSessionIds.contains(session.getId())) {
 			this.acquiredSessionIds.add(session.getId());
@@ -106,7 +107,8 @@ public class BatteryStatusServiceImpl implements BatteryStatusService {
 	/**
 	 * Unsubscribe from the battery status broadcast.
 	 */
-	public void release(WebClientSessionModel session) {
+	@Override
+    public void release(WebClientSessionModel session) {
 		logger.debug("Release webclient battery status subscription for session {}", session.getId());
 		if (this.acquiredSessionIds.contains(session.getId())) {
 			this.acquiredSessionIds.remove((Integer)session.getId());
diff --git a/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java b/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java
index 46a0757e..b5e914b3 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/ServicesContainer.java
@@ -41,6 +41,8 @@ import ch.threema.app.services.PreferenceService;
 import ch.threema.app.services.SynchronizeContactsService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.services.license.LicenseService;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.storage.DatabaseServiceNew;
 
 /**
@@ -71,6 +73,8 @@ public class ServicesContainer {
 	@NonNull public final SessionWakeUpService sessionWakeUp;
 	@NonNull public final WakeLockService wakeLock;
 	@NonNull public final BatteryStatusService batteryStatus;
+	@NonNull public final APIConnector apiConnector;
+	@NonNull public final ContactModelRepository contactModelRepository;
 
 	public ServicesContainer(
 		@NonNull final Context appContext,
@@ -89,7 +93,9 @@ public class ServicesContainer {
 		@NonNull final DeadlineListService hiddenChat,
 		@NonNull final FileService file,
 		@NonNull final SynchronizeContactsService synchronizeContacts,
-		@NonNull final LicenseService license
+		@NonNull final LicenseService license,
+		@NonNull final APIConnector apiConnector,
+		@NonNull final ContactModelRepository contactModelRepository
 	) {
 		this.appContext = appContext;
 		this.lifetime = lifetime;
@@ -109,6 +115,8 @@ public class ServicesContainer {
 		this.synchronizeContacts = synchronizeContacts;
 		this.license = license;
 		this.sessionWakeUp = SessionWakeUpServiceImpl.getInstance();
+		this.apiConnector = apiConnector;
+		this.contactModelRepository = contactModelRepository;
 
 		// Initialize wakelock service
 		this.wakeLock = new WakeLockServiceImpl(appContext, lifetime);
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java b/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java
index 31394a86..48c97614 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/SessionInstanceServiceImpl.java
@@ -189,7 +189,8 @@ public class SessionInstanceServiceImpl implements SessionInstanceService {
 		);
 		final AvatarUpdateHandler avatarUpdateHandler = new AvatarUpdateHandler(
 			handler,
-			updateDispatcher
+			updateDispatcher,
+            services.contact
 		);
 		final ConversationUpdateHandler conversationUpdateHandler = new ConversationUpdateHandler(
 			handler,
@@ -438,7 +439,10 @@ public class SessionInstanceServiceImpl implements SessionInstanceService {
 
 		createDispatcher.addReceiver(new CreateContactHandler(
 			createDispatcher,
-			services.contact
+			services.contact,
+			services.user,
+			services.apiConnector,
+			services.contactModelRepository
 		));
 
 		createDispatcher.addReceiver(new CreateGroupHandler(
@@ -465,7 +469,6 @@ public class SessionInstanceServiceImpl implements SessionInstanceService {
 		));
 		updateDispatcher.addReceiver(new ModifyProfileHandler(
 			responseDispatcher,
-			services.contact,
 			services.user
 		));
 		updateDispatcher.addReceiver(new ModifyConversationHandler(
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java
index 4dd46f08..7e40de86 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/CreateContactHandler.java
@@ -21,10 +21,6 @@
 
 package ch.threema.app.webclient.services.instance.message.receiver;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.StringDef;
-import androidx.annotation.WorkerThread;
-
 import org.msgpack.core.MessagePackException;
 import org.msgpack.value.Value;
 import org.slf4j.Logger;
@@ -33,17 +29,32 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.StringDef;
+import androidx.annotation.WorkerThread;
+import ch.threema.app.R;
+import ch.threema.app.ThreemaApplication;
+import ch.threema.app.asynctasks.AddContactRestrictionPolicy;
+import ch.threema.app.asynctasks.BasicAddOrUpdateContactBackgroundTask;
+import ch.threema.app.asynctasks.ContactResult;
+import ch.threema.app.asynctasks.ContactAvailable;
+import ch.threema.app.asynctasks.ContactCreated;
+import ch.threema.app.asynctasks.PolicyViolation;
 import ch.threema.app.exceptions.EntryAlreadyExistsException;
 import ch.threema.app.exceptions.InvalidEntryException;
+import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.app.services.ContactService;
+import ch.threema.app.services.UserService;
 import ch.threema.app.webclient.Protocol;
 import ch.threema.app.webclient.converter.Contact;
 import ch.threema.app.webclient.converter.MsgpackObjectBuilder;
 import ch.threema.app.webclient.exceptions.ConversionException;
 import ch.threema.app.webclient.services.instance.MessageDispatcher;
 import ch.threema.app.webclient.services.instance.MessageReceiver;
-import ch.threema.app.exceptions.PolicyViolationException;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.data.repositories.ContactModelRepository;
+import ch.threema.domain.protocol.api.APIConnector;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.storage.models.ContactModel;
 
@@ -53,6 +64,9 @@ public class CreateContactHandler extends MessageReceiver {
 
 	private final MessageDispatcher dispatcher;
 	private final ContactService contactService;
+	private final UserService userService;
+	private final APIConnector apiConnector;
+	private final ContactModelRepository contactModelRepository;
 
 	@Retention(RetentionPolicy.SOURCE)
 	@StringDef({
@@ -63,11 +77,19 @@ public class CreateContactHandler extends MessageReceiver {
 	private @interface ErrorCode {}
 
 	@AnyThread
-	public CreateContactHandler(MessageDispatcher dispatcher,
-	                            ContactService contactService) {
+	public CreateContactHandler(
+		MessageDispatcher dispatcher,
+		ContactService contactService,
+		@NonNull UserService userService,
+		@NonNull APIConnector apiConnector,
+		@NonNull ContactModelRepository contactModelRepository
+	) {
 		super(Protocol.SUB_TYPE_CONTACT);
 		this.dispatcher = dispatcher;
 		this.contactService = contactService;
+		this.userService = userService;
+		this.apiConnector = apiConnector;
+		this.contactModelRepository = contactModelRepository;
 	}
 
 	@Override
@@ -102,7 +124,7 @@ public class CreateContactHandler extends MessageReceiver {
 
 		// Otherwise try to create the contact
 		try {
-			contactModel = this.contactService.createContactByIdentity(threemaId, false);
+			contactModel = createContact(threemaId);
 			this.success(threemaId, temporaryId, contactModel);
 		} catch (InvalidEntryException e) {
 			this.failed(threemaId, temporaryId, Protocol.ERROR_INVALID_IDENTITY);
@@ -145,4 +167,34 @@ public class CreateContactHandler extends MessageReceiver {
 	protected boolean maybeNeedsConnection() {
 		return false;
 	}
+
+	@NonNull
+	@WorkerThread
+	private ContactModel createContact(@NonNull String identity)
+		throws InvalidEntryException, EntryAlreadyExistsException, PolicyViolationException {
+		ContactResult result = new BasicAddOrUpdateContactBackgroundTask(
+			identity,
+			ContactModel.AcquaintanceLevel.DIRECT,
+			userService.getIdentity(),
+			apiConnector,
+			contactModelRepository,
+			AddContactRestrictionPolicy.CHECK,
+			ThreemaApplication.getAppContext(),
+			null
+		).runSynchronously();
+
+		if (result instanceof ContactCreated) {
+			ContactModel contactModel = contactService.getByIdentity(identity);
+			if (contactModel == null) {
+				throw new IllegalStateException("Contact model is null after adding it");
+			}
+			return contactModel;
+		} else if (result instanceof ContactAvailable) {
+			throw new EntryAlreadyExistsException(R.string.identity_already_exists);
+		} else if (result instanceof PolicyViolation) {
+			throw new PolicyViolationException();
+		} else {
+			throw new InvalidEntryException(R.string.invalid_threema_id);
+		}
+	}
 }
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java
index 6fb65872..ddca428c 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/MessageReadRequestHandler.java
@@ -21,15 +21,14 @@
 
 package ch.threema.app.webclient.services.instance.message.receiver;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.WorkerThread;
-
 import org.msgpack.core.MessagePackException;
 import org.msgpack.value.Value;
 import org.slf4j.Logger;
 
 import java.util.Map;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.routines.ReadMessagesRoutine;
 import ch.threema.app.services.ContactService;
 import ch.threema.app.services.GroupService;
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java
index bac3196c..ee44efa5 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyContactHandler.java
@@ -46,6 +46,7 @@ import ch.threema.app.webclient.exceptions.ConversionException;
 import ch.threema.app.webclient.services.instance.MessageDispatcher;
 import ch.threema.app.webclient.services.instance.MessageReceiver;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.taskmanager.TriggerSource;
 import ch.threema.storage.models.ContactModel;
 import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
 
@@ -96,6 +97,7 @@ public class ModifyContactHandler extends MessageReceiver {
 		final String identity = args.get(Protocol.ARGUMENT_IDENTITY).asStringValue().toString();
 		final String temporaryId = args.get(Protocol.ARGUMENT_TEMPORARY_ID).asStringValue().toString();
 
+		// TODO(ANDR-3139): Use new contact model
 		// Validate identity
 		final ContactModel contactModel = this.contactService.getByIdentity(identity);
 		if (contactModel == null) {
@@ -139,7 +141,7 @@ public class ModifyContactHandler extends MessageReceiver {
 					final Value avatarValue = data.get(Protocol.ARGUMENT_AVATAR);
 					if (avatarValue == null || avatarValue.isNilValue()) {
 						// Clear avatar
-						this.contactService.removeAvatar(contactModel);
+						this.contactService.removeUserDefinedProfilePicture(contactModel, TriggerSource.LOCAL);
 					} else {
 						// Set avatar
 						final byte[] bmp = avatarValue.asBinaryValue().asByteArray();
@@ -149,11 +151,13 @@ public class ModifyContactHandler extends MessageReceiver {
 							avatar = BitmapUtil.resizeBitmap(avatar,
 									ContactEditDialog.CONTACT_AVATAR_WIDTH_PX,
 									ContactEditDialog.CONTACT_AVATAR_HEIGHT_PX);
-							this.contactService.setAvatar(
-									contactModel,
-									// Without quality loss
-									BitmapUtil.bitmapToByteArray(avatar, Bitmap.CompressFormat.PNG, 100)
-							);
+                            this.contactService.setUserDefinedProfilePicture(
+                                contactModel,
+                                // Without quality loss
+                                BitmapUtil.bitmapToByteArray(avatar, Bitmap.CompressFormat.PNG,
+                                    100),
+                                TriggerSource.LOCAL
+                            );
 						}
 					}
 				} catch (Exception e) {
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java
index dde9365a..ca1747f1 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/receiver/ModifyProfileHandler.java
@@ -33,18 +33,18 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.Map;
 
 import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.StringDef;
 import androidx.annotation.WorkerThread;
 import ch.threema.app.dialogs.ContactEditDialog;
-import ch.threema.app.services.ContactService;
 import ch.threema.app.services.UserService;
 import ch.threema.app.utils.BitmapUtil;
 import ch.threema.app.webclient.Protocol;
 import ch.threema.app.webclient.services.instance.MessageDispatcher;
 import ch.threema.app.webclient.services.instance.MessageReceiver;
 import ch.threema.base.utils.LoggingUtil;
-import ch.threema.storage.models.ContactModel;
+import ch.threema.domain.taskmanager.TriggerSource;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
@@ -59,10 +59,11 @@ public class ModifyProfileHandler extends MessageReceiver {
 	private static final String FIELD_AVATAR = "avatar";
 
 	// Dispatchers
+    @NonNull
 	private final MessageDispatcher responseDispatcher;
 
 	// Services
-	private final ContactService contactService;
+    @NonNull
 	private final UserService userService;
 
 	// Error codes
@@ -83,12 +84,12 @@ public class ModifyProfileHandler extends MessageReceiver {
 	}
 
 	@AnyThread
-	public ModifyProfileHandler(MessageDispatcher responseDispatcher,
-	                            ContactService contactService,
-	                            UserService userService) {
+	public ModifyProfileHandler(
+        @NonNull MessageDispatcher responseDispatcher,
+        @NonNull UserService userService
+    ) {
 		super(Protocol.SUB_TYPE_PROFILE);
 		this.responseDispatcher = responseDispatcher;
-		this.contactService = contactService;
 		this.userService = userService;
 	}
 
@@ -138,18 +139,16 @@ public class ModifyProfileHandler extends MessageReceiver {
 		if (nickname.getBytes(UTF_8).length > Protocol.LIMIT_BYTES_PUBLIC_NICKNAME) {
 			throw new ModifyProfileException(Protocol.ERROR_VALUE_TOO_LONG);
 		}
-		this.userService.setPublicNickname(nickname);
+		this.userService.setPublicNickname(nickname, TriggerSource.LOCAL);
 	}
 
 	/**
 	 * Update the avatar.
 	 */
 	private void processAvatar(@Nullable byte[] avatarBytes) throws ModifyProfileException {
-		final ContactModel me = this.contactService.getMe();
-
 		// If avatar bytes are null, delete own avatar.
 		if (avatarBytes == null) {
-			this.contactService.removeAvatar(me);
+            userService.removeUserProfilePicture(TriggerSource.LOCAL);
 			return;
 		}
 
@@ -170,15 +169,15 @@ public class ModifyProfileHandler extends MessageReceiver {
 			ContactEditDialog.CONTACT_AVATAR_HEIGHT_PX
 		);
 
-		// Set the avatar
-		try {
-			final byte[] converted = BitmapUtil
-				.bitmapToByteArray(resized, Bitmap.CompressFormat.PNG, 100);
-			this.contactService.setAvatar(this.contactService.getMe(), converted);
-		} catch (Exception e) {
-			logger.error("Could not update own avatar", e);
-			throw new ModifyProfileException(Protocol.ERROR_INTERNAL);
-		}
+        // Set the avatar
+        try {
+            final byte[] converted = BitmapUtil
+                .bitmapToByteArray(resized, Bitmap.CompressFormat.PNG, 100);
+            userService.setUserProfilePicture(converted, TriggerSource.LOCAL);
+        } catch (Exception e) {
+            logger.error("Could not update own avatar", e);
+            throw new ModifyProfileException(Protocol.ERROR_INTERNAL);
+        }
 	}
 
 	@Override
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java
index 4d49ffd2..c601a0cb 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/AvatarUpdateHandler.java
@@ -21,14 +21,14 @@
 
 package ch.threema.app.webclient.services.instance.message.updater;
 
-import androidx.annotation.AnyThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.WorkerThread;
-
 import org.msgpack.core.MessagePackException;
 import org.slf4j.Logger;
 
+import androidx.annotation.AnyThread;
+import androidx.annotation.NonNull;
+import androidx.annotation.WorkerThread;
 import ch.threema.app.managers.ListenerManager;
+import ch.threema.app.services.ContactService;
 import ch.threema.app.utils.executor.HandlerExecutor;
 import ch.threema.app.webclient.Protocol;
 import ch.threema.app.webclient.converter.MsgpackObjectBuilder;
@@ -57,14 +57,24 @@ public class AvatarUpdateHandler extends MessageUpdater {
 	// Dispatchers
 	private final @NonNull MessageDispatcher updateDispatcher;
 
+    // Services
+    private final @NonNull ContactService contactService;
+
 	@AnyThread
-	public AvatarUpdateHandler(@NonNull HandlerExecutor handler, @NonNull MessageDispatcher updateDispatcher) {
+	public AvatarUpdateHandler(
+        @NonNull HandlerExecutor handler,
+        @NonNull MessageDispatcher updateDispatcher,
+        @NonNull ContactService contactService
+    ) {
 		super(Protocol.SUB_TYPE_AVATAR);
 		this.handler = handler;
 
 		// Dispatchers
 		this.updateDispatcher = updateDispatcher;
 
+        // Services
+        this.contactService = contactService;
+
 		// Create receiver listeners
 		this.contactListener = new ContactListener();
 		this.groupListener = new GroupListener();
@@ -90,7 +100,7 @@ public class AvatarUpdateHandler extends MessageUpdater {
 	/**
 	 * Update a contact avatar.
 	 */
-	private void update(final ContactModel contact) {
+	private void update(@NonNull final ContactModel contact) {
 		this.update(new Utils.ModelWrapper(contact));
 	}
 
@@ -125,9 +135,14 @@ public class AvatarUpdateHandler extends MessageUpdater {
 	@AnyThread
 	private class ContactListener implements ch.threema.app.listeners.ContactListener {
 		@Override
-		public void onAvatarChanged(ContactModel contactModel) {
+		public void onAvatarChanged(final @NonNull String identity) {
 			logger.debug("Contact Listener: onAvatarChanged");
-			handler.post(() -> AvatarUpdateHandler.this.update(contactModel));
+            ContactModel contactModel = contactService.getByIdentity(identity);
+            if (contactModel == null) {
+                logger.error("Got an avatar update for an unknown contact");
+            } else {
+                handler.post(() -> AvatarUpdateHandler.this.update(contactModel));
+            }
 		}
 	}
 
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java
index c52add15..54bd3587 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ConversationUpdateHandler.java
@@ -34,6 +34,7 @@ import ch.threema.app.services.ContactService;
 import ch.threema.app.services.DeadlineListService;
 import ch.threema.app.services.DistributionListService;
 import ch.threema.app.services.GroupService;
+import ch.threema.app.utils.ContactUtil;
 import ch.threema.app.utils.executor.HandlerExecutor;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.app.webclient.Protocol;
@@ -114,7 +115,11 @@ public class ConversationUpdateHandler extends MessageUpdater {
 		if (model.isGroupConversation()) {
 			uniqueId = this.groupService.getUniqueIdString(model.getGroup());
 		} else if (model.isContactConversation()) {
-			uniqueId = this.contactService.getUniqueIdString(model.getContact());
+			String identity = null;
+			if (model.getContact() != null) {
+				identity = model.getContact().getIdentity();
+			}
+			uniqueId = ContactUtil.getUniqueIdString(identity);
 		} else if (model.isDistributionListConversation()) {
 			uniqueId = this.distributionListService.getUniqueIdString(model.getDistributionList());
 		}
diff --git a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java
index 4122f88c..df3851ec 100644
--- a/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java
+++ b/app/src/main/java/ch/threema/app/webclient/services/instance/message/updater/ReceiverUpdateHandler.java
@@ -261,19 +261,19 @@ public class ReceiverUpdateHandler extends MessageUpdater {
 		}
 
 		@Override
-		public void onNewMember(GroupModel group, String newIdentity, int previousMemberCount) {
+		public void onNewMember(GroupModel group, String newIdentity) {
 			logger.debug("Group Listener: onNewMember");
 			updateGroup(group, Protocol.ARGUMENT_MODE_MODIFIED);
 		}
 
 		@Override
-		public void onMemberLeave(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberLeave(GroupModel group, String identity) {
 			logger.debug("Group Listener: onMemberLeave");
 			updateGroup(group, Protocol.ARGUMENT_MODE_MODIFIED);
 		}
 
 		@Override
-		public void onMemberKicked(GroupModel group, String identity, int previousMemberCount) {
+		public void onMemberKicked(GroupModel group, String identity) {
 			logger.debug("Group Listener: onMemberKicked");
 			updateGroup(group, Protocol.ARGUMENT_MODE_MODIFIED);
 		}
diff --git a/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt b/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt
index 019baf13..d1ee4b3f 100644
--- a/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt
+++ b/app/src/main/java/ch/threema/app/workers/AutoDeleteWorker.kt
@@ -42,6 +42,7 @@ import ch.threema.app.services.ballot.BallotService
 import ch.threema.app.utils.AppRestrictionUtil
 import ch.threema.app.utils.AutoDeleteUtil
 import ch.threema.app.utils.ConfigUtils
+import ch.threema.app.utils.WorkManagerUtil
 import ch.threema.base.ThreemaException
 import ch.threema.base.utils.LoggingUtil
 import ch.threema.domain.protocol.csp.ProtocolDefines
@@ -71,7 +72,11 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
         const val EXTRA_GRACE_DAYS = "grace_days"
         private const val schedulePeriodMs = DateUtils.DAY_IN_MILLIS / 2
 
-        fun scheduleAutoDelete(context: Context) : Boolean {
+        /**
+         * Schedule the auto delete worker to run periodically. If auto delete is not configured
+         * and a worker is already scheduled, it will be cancelled.
+         */
+        fun scheduleAutoDelete(context: Context) {
             val graceDays = getGraceDays(context)
             if (graceDays != null && graceDays > ProtocolDefines.AUTO_DELETE_KEEP_MESSAGES_DAYS_OFF_VALUE) {
                 logger.info("Scheduling auto delete")
@@ -90,11 +95,10 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
                         logger.error("Exception scheduling auto delete", e)
                     }
                 }
-                return true
             } else {
                 logger.info("No auto delete configured")
+                cancelAutoDelete(context)
             }
-            return false
         }
 
         private fun buildPeriodicWorkRequest(graceDays: Int): PeriodicWorkRequest {
@@ -124,16 +128,14 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
         }
 
         fun cancelAutoDelete(context: Context) {
-            logger.info("Canceling auto delete")
             CoroutineScope(Dispatchers.IO).launch {
-                val operation = WorkManager.getInstance(context)
-                    .cancelUniqueWork(ThreemaApplication.WORKER_AUTO_DELETE)
-                logger.info("Cancel result = {}",
-                    withContext(Dispatchers.IO) {
-                        operation.result.get()
-                    })
+                cancelAutoDeleteAwait(context)
             }
         }
+
+        suspend fun cancelAutoDeleteAwait(context: Context) {
+            WorkManagerUtil.cancelUniqueWorkAwait(context, ThreemaApplication.WORKER_AUTO_DELETE)
+        }
     }
 
     override fun doWork(): Result {
@@ -230,7 +232,7 @@ class AutoDeleteWorker(context: Context, workerParameters: WorkerParameters) : W
                     }
                 } else {
                     logger.info("Removing message {}", messageModel.apiMessageId ?: messageModel.id)
-                    fileService.removeMessageFiles(messageModel, true);
+                    fileService.removeMessageFiles(messageModel, true)
                     messageService.remove(messageModel, false)
                     numDeletedMessages++
                 }
diff --git a/app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt b/app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt
deleted file mode 100644
index 1184dece..00000000
--- a/app/src/main/java/ch/threema/app/workers/ContactUpdateWorker.kt
+++ /dev/null
@@ -1,246 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.workers
-
-import android.content.Context
-import androidx.work.Worker
-import androidx.work.WorkerParameters
-import ch.threema.app.R
-import ch.threema.app.ThreemaApplication
-import ch.threema.app.managers.ServiceManager
-import ch.threema.app.services.ContactService
-import ch.threema.app.services.PollingHelper
-import ch.threema.app.services.PreferenceService
-import ch.threema.app.services.UserService
-import ch.threema.app.utils.ContactUtil
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.IdentityState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.protocol.api.APIConnector
-import ch.threema.storage.models.ContactModel
-
-private val logger = LoggingUtil.getThreemaLogger("ContactUpdateWorker")
-
-/**
- * The contact update worker sends the feature mask (if necessary) and updates all contacts. This
- * includes fetching the states, types, and features masks.
- */
-class ContactUpdateWorker(
-    private val context: Context,
-    workerParameters: WorkerParameters,
-) : Worker(context, workerParameters) {
-
-    override fun doWork(): Result {
-        val serviceManager = ThreemaApplication.getServiceManager()
-
-        val success = sendFeatureMaskAndUpdateContacts(
-            serviceManager?.contactService,
-            serviceManager?.apiConnector,
-            serviceManager?.userService,
-            serviceManager?.preferenceService,
-            PollingHelper(context, "contactUpdateWorker"),
-            applicationContext
-        )
-
-        return if (success) {
-            Result.success()
-        } else {
-            Result.failure()
-        }
-    }
-
-    companion object {
-        fun sendFeatureMaskAndUpdateContacts(serviceManager: ServiceManager, context: Context) =
-            sendFeatureMaskAndUpdateContacts(
-                serviceManager.contactService,
-                serviceManager.apiConnector,
-                serviceManager.userService,
-                serviceManager.preferenceService,
-                null,
-                context,
-            )
-
-        private fun sendFeatureMaskAndUpdateContacts(
-            contactService: ContactService?,
-            apiConnector: APIConnector?,
-            userService: UserService?,
-            preferenceService: PreferenceService?,
-            pollingHelper: PollingHelper?,
-            context: Context,
-        ): Boolean {
-            logger.info("Starting contact update")
-
-            if (contactService == null || apiConnector == null || userService == null || preferenceService == null) {
-                logger.warn("Services not available while updating contact states")
-                return false
-            }
-
-            if (!userService.hasIdentity()) {
-                logger.warn("No identity found. Contact update not needed.")
-                // Treat a contact update as successful if no identity is available to prevent
-                // unnecessary retries
-                return true
-            }
-
-            if (!userService.sendFeatureMask()) {
-                logger.warn("Feature mask could not be sent. Aborting contact update")
-                return false
-            }
-
-            val contactModels = contactService.find(object : ContactService.Filter {
-                override fun states(): Array<ContactModel.State> =
-                    arrayOf(ContactModel.State.ACTIVE, ContactModel.State.INACTIVE)
-
-                override fun requiredFeature() = null
-
-                override fun fetchMissingFeatureLevel() = null
-
-                override fun includeMyself() = true
-
-                override fun includeHidden() = true
-
-                override fun onlyWithReceiptSettings() = false
-            })
-
-            val success = if (contactModels.isNotEmpty()) {
-                fetchAndUpdateContactModels(
-                    contactModels,
-                    apiConnector,
-                    contactService,
-                    preferenceService,
-                    context,
-                )
-            } else {
-                true
-            }
-
-            // Force a quick poll
-            pollingHelper?.poll(false)
-
-            logger.debug("Finished contact update; success={}", success)
-
-            return success
-        }
-
-        fun fetchAndUpdateContactModels(
-            contactModels: List<ContactModel>,
-            apiConnector: APIConnector,
-            contactService: ContactService,
-            preferenceService: PreferenceService,
-            context: Context,
-        ): Boolean {
-            val identities = contactModels.map { it.identity }.toTypedArray()
-            val contactModelMap = contactModels.associateBy { it.identity }
-
-            try {
-                val result = apiConnector.checkIdentityStates(identities)
-
-                for ((i, identity) in result.identities.withIndex()) {
-                    val contactModel = contactModelMap[identity] ?: continue
-
-                    val newState = when (result.states[i]) {
-                        IdentityState.ACTIVE -> ContactModel.State.ACTIVE
-                        IdentityState.INACTIVE -> ContactModel.State.INACTIVE
-                        IdentityState.INVALID -> ContactModel.State.INVALID
-
-                        // In case we receive an unexpected value from the server, we set the new
-                        // state to null. We should not abort these steps as this contact update
-                        // routine is required to be run when setting up the app. We do not consider
-                        // an invalid state to be a failure that should prevent using the app.
-                        else -> null
-                    }
-
-                    if (newState == null) {
-                        logger.warn(
-                            "Received invalid state {} for identity {}", result.states[i], identity
-                        )
-                    }
-
-                    val newIdentityType = when (result.types[i]) {
-                        0 -> IdentityType.NORMAL
-                        1 -> IdentityType.WORK
-                        else -> {
-                            logger.warn("Received invalid type {} for identity {}", result.types[i], identity);
-                            IdentityType.NORMAL
-                        }
-                    }
-
-                    val newFeatureMask: Long? = result.featureMasks[i]
-
-                    updateContactModel(
-                        contactModel,
-                        newState,
-                        newIdentityType,
-                        newFeatureMask,
-                        contactService
-                    )
-
-                    if (result.checkInterval > 0) {
-                        // Save new interval duration
-                        preferenceService.setRoutineInterval(
-                            context.getString(R.string.preferences__identity_states_check_interval),
-                            result.checkInterval
-                        )
-                    }
-                }
-
-                return true
-            } catch (e: Exception) {
-                logger.error("Could not fetch contact updates", e)
-                return false
-            }
-        }
-
-        private fun updateContactModel(
-            contactModel: ContactModel,
-            newState: ContactModel.State?,
-            newIdentityType: IdentityType,
-            newFeatureMask: Long?,
-            contactService: ContactService,
-        ) {
-            var updated = false
-
-            // Only update the state if it is a valid state change. Note that changing to null is
-            // not allowed and will not result in any change.
-            if (ContactUtil.allowedChangeToState(contactModel, newState)) {
-                contactModel.state = newState
-                updated = true
-            }
-
-            if (contactModel.identityType != newIdentityType) {
-                contactModel.identityType = newIdentityType
-                updated = true
-            }
-
-            if (newFeatureMask == null) {
-                logger.warn("Feature mask for contact {} is null", contactModel.identity)
-            } else if (newFeatureMask != contactModel.featureMask) {
-                contactModel.featureMask = newFeatureMask
-                updated = true
-            }
-
-            if (updated) {
-                contactService.save(contactModel)
-            }
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt b/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt
index cc1df71c..a61a6bb5 100644
--- a/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt
+++ b/app/src/main/java/ch/threema/app/workers/WorkSyncWorker.kt
@@ -30,6 +30,7 @@ import androidx.core.app.NotificationCompat
 import androidx.preference.PreferenceManager
 import androidx.work.Constraints
 import androidx.work.Data
+import androidx.work.ExistingPeriodicWorkPolicy
 import androidx.work.ExistingWorkPolicy
 import androidx.work.ForegroundInfo
 import androidx.work.NetworkType
@@ -44,8 +45,9 @@ import androidx.work.Worker
 import androidx.work.WorkerParameters
 import ch.threema.app.R
 import ch.threema.app.ThreemaApplication
-import ch.threema.app.notifications.NotificationChannels
+import ch.threema.app.asynctasks.AddOrUpdateWorkContactBackgroundTask
 import ch.threema.app.managers.ServiceManager
+import ch.threema.app.notifications.NotificationChannels
 import ch.threema.app.routines.UpdateAppLogoRoutine
 import ch.threema.app.routines.UpdateWorkInfoRoutine
 import ch.threema.app.services.AppRestrictionService
@@ -61,11 +63,15 @@ import ch.threema.app.utils.AppRestrictionUtil
 import ch.threema.app.utils.ConfigUtils
 import ch.threema.app.utils.RuntimeUtil
 import ch.threema.app.utils.TestUtil
+import ch.threema.app.utils.WorkManagerUtil
 import ch.threema.base.utils.LoggingUtil
+import ch.threema.data.models.ContactModel
+import ch.threema.data.repositories.ContactModelRepository
 import ch.threema.domain.models.VerificationLevel
+import ch.threema.domain.models.WorkVerificationLevel
 import ch.threema.domain.protocol.api.APIConnector
 import ch.threema.domain.protocol.api.work.WorkData
-import ch.threema.storage.models.ContactModel
+import ch.threema.domain.taskmanager.TriggerSource
 import com.google.common.util.concurrent.Futures
 import com.google.common.util.concurrent.ListenableFuture
 import java.net.HttpURLConnection
@@ -83,12 +89,41 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
     private val notificationService: NotificationService? = serviceManager?.notificationService
     private val userService: UserService? = serviceManager?.userService
     private val identityStore: IdentityStore? = serviceManager?.identityStore
+    private val contactModelRepository: ContactModelRepository? = serviceManager?.modelRepositories?.contacts
 
     companion object {
         private const val EXTRA_REFRESH_RESTRICTIONS_ONLY = "RESTRICTIONS_ONLY"
         private const val EXTRA_FORCE_UPDATE = "FORCE_UPDATE"
 
-        fun buildOneTimeWorkRequest(refreshRestrictionsOnly: Boolean, forceUpdate: Boolean, tag: String?): OneTimeWorkRequest {
+        fun schedulePeriodicWorkSync(context: Context, preferenceService: PreferenceService) {
+            if (!ConfigUtils.isWorkBuild()) {
+                logger.debug("Do not start work sync worker in non-work build")
+                return
+            }
+
+            val schedulePeriodMs = WorkManagerUtil.normalizeSchedulePeriod(preferenceService.workSyncCheckInterval)
+            logger.info("Scheduling periodic work sync. Schedule period: {} ms", schedulePeriodMs)
+
+            try {
+                val workManager = WorkManager.getInstance(context)
+                val policy = if (WorkManagerUtil.shouldScheduleNewWorkManagerInstance(workManager, ThreemaApplication.WORKER_PERIODIC_WORK_SYNC, schedulePeriodMs)) {
+                    ExistingPeriodicWorkPolicy.CANCEL_AND_REENQUEUE
+                } else {
+                    ExistingPeriodicWorkPolicy.KEEP
+                }
+                logger.info("{}: {} existing periodic work", ThreemaApplication.WORKER_PERIODIC_WORK_SYNC, policy)
+                val workRequest = buildPeriodicWorkRequest(schedulePeriodMs)
+                workManager.enqueueUniquePeriodicWork(ThreemaApplication.WORKER_PERIODIC_WORK_SYNC, policy, workRequest)
+            } catch (e: IllegalStateException) {
+                logger.error("Unable to schedule periodic work sync work", e)
+            }
+        }
+
+        suspend fun cancelPeriodicWorkSyncAwait(context: Context) {
+            WorkManagerUtil.cancelUniqueWorkAwait(context, ThreemaApplication.WORKER_PERIODIC_WORK_SYNC)
+        }
+
+        private fun buildOneTimeWorkRequest(refreshRestrictionsOnly: Boolean, forceUpdate: Boolean, tag: String?): OneTimeWorkRequest {
             val data = Data.Builder()
                     .putBoolean(EXTRA_REFRESH_RESTRICTIONS_ONLY, refreshRestrictionsOnly)
                     .putBoolean(EXTRA_FORCE_UPDATE, forceUpdate)
@@ -105,7 +140,7 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
             return builder.build()
         }
 
-        fun buildPeriodicWorkRequest(schedulePeriodMs: Long): PeriodicWorkRequest {
+        private fun buildPeriodicWorkRequest(schedulePeriodMs: Long): PeriodicWorkRequest {
             val data = Data.Builder()
                 .putBoolean(EXTRA_REFRESH_RESTRICTIONS_ONLY, false)
                 .putBoolean(EXTRA_FORCE_UPDATE, false)
@@ -121,6 +156,22 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
                 .build()
         }
 
+        /**
+         * Start a one time work sync request. Existing work will be [ExistingWorkPolicy.REPLACE]d.
+         *
+         * If it is required to run a callback when the request was successful or failed, use
+         * `performOneTimeWorkSync(Activity, Runnable, Runnable)`.
+         */
+        fun performOneTimeWorkSync(
+            context: Context,
+            refreshRestrictionsOnly: Boolean,
+            forceUpdate: Boolean,
+            tag: String?
+        ) {
+            val workRequest = buildOneTimeWorkRequest(refreshRestrictionsOnly, forceUpdate, tag)
+            WorkManager.getInstance(context).enqueueUniqueWork(ThreemaApplication.WORKER_WORK_SYNC, ExistingWorkPolicy.REPLACE, workRequest)
+        }
+
         /**
          * Start a one time work sync request.
          *
@@ -166,7 +217,14 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
 
         logger.info("Refreshing work data. Restrictions only = {}, force = {}", updateRestrictionsOnly, forceUpdate)
 
-        if (licenseService == null || notificationService == null || contactService == null || apiConnector == null || preferenceService == null) {
+        if (licenseService == null
+            || notificationService == null
+            || contactService == null
+            || apiConnector == null
+            || preferenceService == null
+            || userService == null
+            || contactModelRepository == null
+        ) {
             logger.info("Services not available")
             return Result.failure()
         }
@@ -181,7 +239,8 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
         if (!updateRestrictionsOnly) {
             val workData: WorkData?
             try {
-                val allContacts: List<ContactModel> = contactService.all
+                // TODO(ANDR-3172): Get all contacts via contact model repository
+                val allContacts: List<ch.threema.storage.models.ContactModel> = contactService.all
                 val identities = arrayOfNulls<String>(allContacts.size)
                 for (n in allContacts.indices) {
                     identities[n] = allContacts[n].identity
@@ -208,24 +267,34 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
                 return Result.failure()
             }
 
-            val existingWorkContacts: List<ContactModel> = contactService.allWork
-            val immutableExistingWorkContacts = existingWorkContacts.toList()
-            for (workContact in workData.workContacts) {
-                val newContact = contactService.addWorkContact(workContact, existingWorkContacts)
-                if (immutableExistingWorkContacts.none { it == newContact }) {
-                    newContact?.let { newWorkContacts.add(it) }
-                }
-            }
+            val existingWorkIdentities = contactService.allWork.map { it.identity }.toSet()
+            val fetchedWorkIdentities = workData.workContacts.map { it.threemaId }.toSet()
+
+            // Create or update work contacts
+            val refreshedWorkIdentities = workData.workContacts.mapNotNull { workContact ->
+                AddOrUpdateWorkContactBackgroundTask(
+                    workContact,
+                    userService.identity,
+                    contactModelRepository,
+                ).runSynchronously()
+            }.map { it.identity }
+
+            val newWorkIdentities = refreshedWorkIdentities - existingWorkIdentities
+            newWorkContacts.addAll(
+                newWorkIdentities.mapNotNull { contactModelRepository.getByIdentity(it) }
+            )
+
+            // Downgrade work contacts
+            val downgradedIdentities = existingWorkIdentities - fetchedWorkIdentities
+            downgradedIdentities.mapNotNull { contactModelRepository.getByIdentity(it) }.forEach {
+                // The contact is no longer a work contact, so set work verification level to none
+                it.setWorkVerificationLevelFromLocal(WorkVerificationLevel.NONE)
 
-            //downgrade work contacts
-            for (x in existingWorkContacts.indices) {
-                //remove isWork flag
-                val c = existingWorkContacts[x]
-                c.setIsWork(false)
-                if (c.verificationLevel != VerificationLevel.FULLY_VERIFIED) {
-                    c.verificationLevel = VerificationLevel.UNVERIFIED
+                // Additionally, the contact may not be server verified anymore (except it has been
+                // fully verified before)
+                if (it.data.value?.verificationLevel == VerificationLevel.SERVER_VERIFIED) {
+                    it.setVerificationLevelFromLocal(VerificationLevel.UNVERIFIED)
                 }
-                this.contactService.save(c)
             }
 
             // update applogos
@@ -273,9 +342,7 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
             if (newWorkContacts.isEmpty() || ContactUpdateWorker.fetchAndUpdateContactModels(
                 contactModels = newWorkContacts,
                 apiConnector = apiConnector,
-                contactService = contactService,
                 preferenceService = preferenceService,
-                context = context
             )) {
                 return Result.success()
             } else {
@@ -341,9 +408,9 @@ class WorkSyncWorker(private val context: Context, workerParameters: WorkerParam
     }
 
     private fun applyNicknameRestriction() {
-        AppRestrictionUtil.getStringRestriction(context.getString(R.string.restriction__nickname))?.let {
-            if (userService != null && !TestUtil.compare(userService.publicNickname, it)) {
-                userService.publicNickname = it
+        AppRestrictionUtil.getStringRestriction(context.getString(R.string.restriction__nickname))?.let { nickname ->
+            if (userService != null && !TestUtil.compare(userService.publicNickname, nickname)) {
+                userService.setPublicNickname(nickname, TriggerSource.LOCAL)
             }
         }
     }
diff --git a/app/src/main/java/ch/threema/data/ModelCache.kt b/app/src/main/java/ch/threema/data/ModelCache.kt
deleted file mode 100644
index c1ee8b9d..00000000
--- a/app/src/main/java/ch/threema/data/ModelCache.kt
+++ /dev/null
@@ -1,74 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data
-
-import ch.threema.data.models.BaseModel
-import ch.threema.data.models.ContactModel
-import ch.threema.data.models.EditHistoryListModel
-import ch.threema.data.models.GroupIdentity
-import ch.threema.data.models.GroupModel
-
-/**
- * The model cache holds a [ModelTypeCache] for every model type.
- *
- * Note: This class should be initialized only once in the application
- * (except for use cases like testing).
- */
-class ModelCache {
-    // Contacts are identified by their identity
-    val contacts = ModelTypeCache<String, ContactModel>()
-
-    // Groups are identified by their group identity (creator identity and group id)
-    val groups = ModelTypeCache<GroupIdentity, GroupModel>()
-
-    // Edit history entries are identified by their reference to a message's uid
-    val editHistory = ModelTypeCache<String, EditHistoryListModel>()
-}
-
-/**
- * The model type cache holds models of a certain type. It ensures that every model
- * is instantiated only once.
- *
- * Internally, it uses a [WeakValueMap], so the values are not prevented from being
- * garbage collected by the cache.
- */
-class ModelTypeCache<TIdentifier, TModel : BaseModel<*>> {
-    private val map = WeakValueMap<TIdentifier, TModel>()
-
-    /**
-     * Return the cached model with the specified [identifier].
-     */
-    fun get(identifier: TIdentifier): TModel? = this.map.get(identifier)
-
-    /**
-     * Return the cached model with the specified [identifier].
-     *
-     * If it cannot be found, create the model using the [miss] function, cache it
-     * and return it.
-     */
-    fun getOrCreate(identifier: TIdentifier, miss: () -> TModel?): TModel? = this.map.getOrCreate(identifier, miss)
-
-    /**
-     * Remove the model with the specified [identifier] from the cache and return it.
-     */
-    fun remove(identifier: TIdentifier): TModel? = this.map.remove(identifier)
-}
diff --git a/app/src/main/java/ch/threema/data/WeakValueMap.kt b/app/src/main/java/ch/threema/data/WeakValueMap.kt
deleted file mode 100644
index ef35e4ec..00000000
--- a/app/src/main/java/ch/threema/data/WeakValueMap.kt
+++ /dev/null
@@ -1,62 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data
-
-import java.lang.ref.WeakReference
-
-/**
- * A map where all values are weakly referenced.
- */
-class WeakValueMap<K, V> {
-    private val map: MutableMap<K, WeakReference<V>> = HashMap()
-
-    /**
-     * Return the value associated with the specified key, or `null` if the key is not present
-     * in the map or if the value has already been garbage collected.
-     */
-    @Synchronized
-    fun get(key: K): V? = this.map[key]?.get()
-
-    /**
-     * Look up the value associated with the specified key. If the key is not present in the map
-     * or if the value has already been garbage collected, run the [miss] function, store the value
-     * in the map, and return it. Otherwise, return the looked up value directly.
-     */
-    @Synchronized
-    fun getOrCreate(key: K, miss: () -> V?): V? {
-        var value = this.get(key)
-        if (value != null) {
-            return value;
-        }
-        value = miss()
-        if (value != null) {
-            this.map[key] = WeakReference(value)
-        }
-        return value
-    }
-
-    /**
-     * Remove the value associated with the specified key and return it.
-     */
-    @Synchronized
-    fun remove(key: K): V? = this.map.remove(key)?.get()
-}
diff --git a/app/src/main/java/ch/threema/data/models/BaseModel.kt b/app/src/main/java/ch/threema/data/models/BaseModel.kt
deleted file mode 100644
index 61ad3b18..00000000
--- a/app/src/main/java/ch/threema/data/models/BaseModel.kt
+++ /dev/null
@@ -1,116 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.models
-
-import kotlinx.coroutines.flow.MutableStateFlow
-import kotlinx.coroutines.flow.StateFlow
-
-interface ModelDataFactory<TDataType, TDbType> {
-    /**
-     * Create the corresponding database type for this model data.
-     */
-    fun toDbType(value: TDataType): TDbType
-
-    /**
-     * Create the corresponding model for this database type.
-     */
-    fun toDataType(value: TDbType): TDataType
-}
-
-/**
- * This exception is thrown when a model, which was deleted, is being mutated.
- */
-class ModelDeletedException(modelName: String, methodName: String)
-    : RuntimeException("Cannot call method $methodName: $modelName was deleted")
-
-/**
- * The base model is extended by every model.
- *
- * It handles reactivity and provides common APIs shared by all models.
- */
-abstract class BaseModel<TData>(
-    /**
-     * Mutable state flow that holds the model data.
-     *
-     * The field is protected, and is only exposed through the [data] property.
-     *
-     * Initially, the data is present. If the model is deleted, the data is set to `null`.
-     * From that point on, the model must not be modified anymore, and all methods that mutate
-     * model state must throw [ModelDeletedException].
-     *
-     * NOTE: Access to [mutableData] should always be protected by a synchronized(this) block!
-     */
-    protected val mutableData: MutableStateFlow<TData?>,
-
-    /**
-     * The name of this model. Used for debugging purposes.
-     */
-    protected val modelName: String,
-) {
-    /**
-     * State flow that holds
-     */
-    val data: StateFlow<TData?> = mutableData
-
-    /**
-     * Ensure that [data] is not null. Throw [ModelDeletedException] otherwise.
-     */
-    protected fun ensureNotDeleted(data: TData?, methodName: String): TData {
-        if (data == null) {
-            throw ModelDeletedException(modelName, methodName)
-        }
-        return data
-    }
-
-    /**
-     * Helper function to update data in the model.
-     *
-     * @param methodName The name of the method using this helper.
-     * @param detectChanges A function that determines whether or not data was modified.
-     * @param updateData A function that receives the original data and returns the updated data.
-     * @param updateDatabase A function that updates the database with the updated data.
-     * @param onUpdated An optional function that is invoked at the end if data was updated.
-     */
-    protected fun updateFields(
-        methodName: String,
-        detectChanges: (originalData: TData) -> Boolean,
-        updateData: (originalData: TData) -> TData,
-        updateDatabase: (updatedData: TData) -> Unit,
-        onUpdated: ((updatedData: TData) -> Unit)?,
-    ) {
-        val updatedData = synchronized(this) {
-            val originalData = ensureNotDeleted(mutableData.value, methodName)
-            val dataChanged = detectChanges(originalData)
-            if (dataChanged) {
-                val updatedData = updateData(originalData)
-                mutableData.value = updatedData
-                updateDatabase(updatedData)
-                updatedData
-            } else {
-                null
-            }
-        }
-        if (updatedData != null && onUpdated != null) {
-            onUpdated(updatedData)
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/data/models/ContactModel.kt b/app/src/main/java/ch/threema/data/models/ContactModel.kt
deleted file mode 100644
index b7bece45..00000000
--- a/app/src/main/java/ch/threema/data/models/ContactModel.kt
+++ /dev/null
@@ -1,489 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.models
-
-import androidx.lifecycle.LiveData
-import androidx.lifecycle.asLiveData
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.utils.ContactUtil
-import ch.threema.app.utils.runtimeAssert
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.UnsignedHelper
-import ch.threema.data.repositories.ContactModelRepository
-import ch.threema.data.repositories.RepositoryToken
-import ch.threema.data.storage.DatabaseBackend
-import ch.threema.data.storage.DbContact
-import ch.threema.domain.models.ContactSyncState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.ReadReceiptPolicy
-import ch.threema.domain.models.TypingIndicatorPolicy
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.models.WorkVerificationLevel
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
-import kotlinx.coroutines.flow.MutableStateFlow
-import java.math.BigInteger
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("data.ContactModel")
-
-/**
- * Immutable contact model data.
- */
-data class ContactModelData(
-    /** The contact identity string. Must be 8 characters long. */
-    @JvmField val identity: String,
-    /** The 32-byte public key of the contact. */
-    @JvmField val publicKey: ByteArray,
-    /** Timestamp when this contact was added to the contact list. */
-    @JvmField val createdAt: Date,
-    /** First name. */
-    @JvmField val firstName: String,
-    /** Last name. */
-    @JvmField val lastName: String,
-    /** Public nickname. */
-    @JvmField val nickname: String?,
-    /** Color index (0-255). */
-    val colorIndex: UByte,
-    /** Verification level. */
-    @JvmField val verificationLevel: VerificationLevel,
-    /** Threema Work verification level. */
-    @JvmField val workVerificationLevel: WorkVerificationLevel,
-    /** Identity type (regular / work). */
-    @JvmField val identityType: IdentityType,
-    /** Acquaintance level (direct / group). */
-    @JvmField val acquaintanceLevel: AcquaintanceLevel,
-    /** Activity state (active / inactive / invalid). */
-    @JvmField val activityState: State,
-    /** Contact sync state. */
-    @JvmField val syncState: ContactSyncState,
-    /** Feature mask. */
-    val featureMask: ULong,
-    /** Read receipt policy. */
-    @JvmField val readReceiptPolicy: ReadReceiptPolicy,
-    /** Typing indicator policy. */
-    @JvmField val typingIndicatorPolicy: TypingIndicatorPolicy,
-    // TODO(ANDR-2998): Notification trigger policy override
-    // TODO(ANDR-2998): Notification sound policy override
-    /** Android contact lookup key. */
-    @JvmField val androidContactLookupKey: String?,
-    /**
-     * Local avatar expiration date.
-     *
-     * For gateway contacts, this is used to determine when to refresh the avatar from the server.
-     *
-     * For contacts linked to an Android system contact, this is used to determine when to refresh
-     * the avatar from the system address book.
-     *
-     * For other contacts, this is always set to null.
-     */
-    @JvmField val localAvatarExpires: Date?,
-    /**
-     * Whether this contact has been restored from backup.
-     */
-    @JvmField val isRestored: Boolean,
-    /**
-     * BlobId of the latest profile picture that was sent to this contact.
-     */
-    @JvmField val profilePictureBlobId: ByteArray?,
-    @JvmField val jobTitle: String?,
-    @JvmField val department: String?,
-) {
-    companion object {
-        /**
-         * Factory function using only Java-compatible types.
-         */
-        @JvmStatic
-        fun javaCreate(
-            identity: String,
-            publicKey: ByteArray,
-            createdAt: Date,
-            firstName: String,
-            lastName: String,
-            nickname: String?,
-            colorIndex: Int,
-            verificationLevel: VerificationLevel,
-            workVerificationLevel: WorkVerificationLevel,
-            identityType: IdentityType,
-            acquaintanceLevel: AcquaintanceLevel,
-            activityState: State,
-            featureMask: BigInteger,
-            syncState: ContactSyncState,
-            readReceiptPolicy: ReadReceiptPolicy,
-            typingIndicatorPolicy: TypingIndicatorPolicy,
-            androidContactLookupKey: String?,
-            localAvatarExpires: Date?,
-            isRestored: Boolean,
-            profilePictureBlobId: ByteArray?,
-            jobTitle: String?,
-            department: String?
-        ): ContactModelData {
-            if (colorIndex < 0 || colorIndex > 255) {
-                throw IllegalArgumentException("colorIndex must be between 0 and 255")
-            }
-            if (featureMask.signum() < 0 || featureMask.bitLength() > 64) {
-                throw IllegalArgumentException("featureMask must be between 0 and 2^64")
-            }
-            return ContactModelData(
-                identity,
-                publicKey,
-                createdAt,
-                firstName,
-                lastName,
-                nickname,
-                colorIndex.toUByte(),
-                verificationLevel,
-                workVerificationLevel,
-                identityType,
-                acquaintanceLevel,
-                activityState,
-                syncState,
-                featureMask.toLong().toULong(),
-                readReceiptPolicy,
-                typingIndicatorPolicy,
-                androidContactLookupKey,
-                localAvatarExpires,
-                isRestored,
-                profilePictureBlobId,
-                jobTitle,
-                department,
-            )
-        }
-    }
-
-    /**
-     * Return the [colorIndex] as [Int].
-     */
-    fun colorIndexInt(): Int = colorIndex.toInt()
-
-    /**
-     * Return the [featureMask] as [BigInteger].
-     */
-    fun featureMaskBigInteger(): BigInteger =
-        UnsignedHelper.unsignedLongToBigInteger(featureMask.toLong())
-
-    /**
-     * Return the [featureMask] as positive [Long].
-     *
-     * Throws [IllegalArgumentException] if value does not fit in a [Long].
-     */
-    fun featureMaskLong(): Long {
-        val long = featureMask.toLong()
-        if (long < 0) {
-            throw IllegalArgumentException("Feature mask does not fit in a signed long")
-        }
-        return long
-    }
-
-    /**
-     * Return the display name for this contact.
-     *
-     * - Use first and/or last name if set
-     * - Use nickname if set
-     * - Fall back to identity
-     */
-    fun getDisplayName(): String {
-        val hasFirstName = this.firstName.isNotBlank()
-        val hasLastName = this.lastName.isNotBlank()
-        val hasNickname = !this.nickname.isNullOrBlank() && this.nickname != this.identity
-
-        if (hasFirstName && hasLastName) {
-            return "${this.firstName} ${this.lastName}"
-        }
-        if (hasFirstName) {
-            return this.firstName
-        }
-        if (hasLastName) {
-            return this.lastName
-        }
-        if (hasNickname) {
-            return "~${this.nickname}"
-        }
-        return this.identity
-    }
-
-    /**
-     * Return whether or not this contact is linked to an Android contact.
-     */
-    fun isLinkedToAndroidContact(): Boolean = this.androidContactLookupKey != null
-
-    /**
-     * Check if the avatar is expired. If no [localAvatarExpires] is set, the avatar is also
-     * considered as expired.
-     */
-    fun isAvatarExpired(): Boolean = localAvatarExpires?.before(Date()) ?: true
-
-    /**
-     * Check if the contact is a gateway contact.
-     */
-    fun isGatewayContact(): Boolean = ContactUtil.isGatewayContact(identity)
-}
-
-/**
- * A contact.
- */
-class ContactModel(
-    val identity: String,
-    data: ContactModelData,
-    private val databaseBackend: DatabaseBackend,
-) : BaseModel<ContactModelData>(MutableStateFlow(data), "ContactModel") {
-
-    init {
-        runtimeAssert(identity == data.identity, "Contact model identity mismatch")
-    }
-
-    /**
-     * Get a [LiveData] for the internal data state flow.
-     */
-    fun liveData(): LiveData<ContactModelData?> = data.asLiveData()
-
-    /**
-     * Update the contact's first and last name.
-     *
-     * @throws [ModelDeletedException] if model is deleted.
-     */
-    fun setNameFromLocal(firstName: String, lastName: String) {
-        this.updateFields(
-            "setNameFromLocal",
-            { originalData -> originalData.firstName != firstName || originalData.lastName != lastName },
-            { originalData -> originalData.copy(firstName = firstName, lastName = lastName) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
-        )
-    }
-
-    /**
-     * Update the contact's acquaintance level.
-     *
-     * @throws [ModelDeletedException] if model is deleted.
-     */
-    fun setAcquaintanceLevelFromLocal(acquaintanceLevel: AcquaintanceLevel) {
-        this.updateFields(
-            "setAcquaintanceLevelFromLocal",
-            { originalData -> originalData.acquaintanceLevel != acquaintanceLevel },
-            { originalData -> originalData.copy(acquaintanceLevel = acquaintanceLevel) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
-        )
-    }
-
-    /**
-     * Update the contact's verification level.
-     *
-     * @throws [ModelDeletedException] if model is deleted.
-     */
-    fun setVerificationLevelFromLocal(verificationLevel: VerificationLevel) {
-        this.updateFields(
-            "setVerificationLevelFromLocal",
-            { originalData -> originalData.verificationLevel != verificationLevel },
-            { originalData -> originalData.copy(verificationLevel = verificationLevel) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
-        )
-    }
-
-    /**
-     * Update the contact's public nickname.
-     *
-     * @throws [ModelDeletedException] if model is deleted.
-     */
-    fun setNicknameFromSync(nickname: String?) {
-        this.updateFields(
-            "setNicknameFromSync",
-            { originalData -> originalData.nickname != nickname },
-            { originalData -> originalData.copy(nickname = nickname) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
-        )
-    }
-
-    /**
-     * Update or remove the contact's Android contact lookup key.
-     */
-    fun setAndroidLookupKey(lookupKey: String?) {
-        this.updateFields(
-            "setAndroidLookupKey",
-            { originalData -> originalData.androidContactLookupKey != lookupKey },
-            { originalData -> originalData.copy(androidContactLookupKey = lookupKey) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
-        )
-    }
-
-    /**
-     * Update or remove the contact's local avatar expiration date.
-     */
-    fun setLocalAvatarExpires(expiresAt: Date?) {
-        this.updateFields(
-            "setLocalAvatarExpires",
-            { originalData -> originalData.localAvatarExpires != expiresAt },
-            { originalData -> originalData.copy(localAvatarExpires = expiresAt) },
-            ::updateDatabase,
-            null, // No need to notify listeners, this isn't something that will result in a UI change.
-        )
-    }
-
-    /**
-     * Clear the "isRestored" flag on the contact.
-     *
-     * This should be called once the post-restore sync steps (e.g. profile picture request)
-     * have been completed.
-     */
-    fun clearIsRestored() {
-        this.updateFields(
-            "clearIsRestored",
-            { originalData -> originalData.isRestored },
-            { originalData -> originalData.copy(isRestored = false) },
-            ::updateDatabase,
-            null, // No need to notify listeners, this isn't something that will result in a UI change.
-        )
-    }
-
-    /**
-     * Set the BlobId of the latest profile picture that was sent to this contact.
-     *
-     * @param blobId The blobId of the latest profile picture sent to this contact, `null` if no
-     *   profile-picture has been sent, or an empty array if a delete-profile-picture message has
-     *   been sent.
-     */
-    fun setProfilePictureBlobId(blobId: ByteArray?) {
-        this.updateFields(
-            "setProfilePictureBlobId",
-            { originalData -> !originalData.profilePictureBlobId.contentEquals(blobId) },
-            { originalData -> originalData.copy(profilePictureBlobId = blobId) },
-            ::updateDatabase,
-            ::notifyDeprecatedOnModifiedListeners
-        )
-    }
-
-    /**
-     * Update all data from database.
-     *
-     * Note: This method may only be called by the repository, in code that bridges the old models
-     * to the new models. All other code does not need to refresh the data, the model's state flow
-     * should always be up to date.
-     *
-     * Note: If the model is marked as deleted, then this will have no effect.
-     */
-    internal fun refreshFromDb(token: RepositoryToken) {
-        logger.info("Refresh from database")
-        synchronized(this) {
-            if (mutableData.value == null) {
-                logger.warn("Cannot refresh deleted ${this.modelName} from DB")
-                return
-            }
-            val dbContact = databaseBackend.getContactByIdentity(identity) ?: return
-            val newData = ContactModelDataFactory.toDataType(dbContact)
-            runtimeAssert(
-                newData.identity == identity,
-                "Cannot update contact model with data for different identity: ${newData.identity} != $identity"
-            )
-            mutableData.value = newData
-        }
-    }
-
-    /**
-     * Mark this model as deleted. If [fromDatabase] is true, then the entry will be deleted
-     * from the database as well.
-     *
-     * Note: This method may only be called by the repository! To delete a contact model, call the
-     * appropriate method on the [ContactModelRepository].
-     *
-     * @throws [ModelDeletedException] if model was already marked as deleted.
-     */
-    internal fun delete(token: RepositoryToken, fromDatabase: Boolean) {
-        logger.info("Delete")
-        synchronized(this) {
-            ensureNotDeleted(mutableData.value, "delete")
-            if (fromDatabase) {
-                databaseBackend.deleteContactByIdentity(identity)
-            }
-            mutableData.value = null
-        }
-        if (fromDatabase) {
-            ListenerManager.contactListeners.handle { it.onRemoved(identity) }
-        }
-    }
-
-    private fun updateDatabase(updatedData: ContactModelData) {
-        databaseBackend.updateContact(ContactModelDataFactory.toDbType(updatedData))
-    }
-
-    /**
-     * Synchronously notify contact change listeners.
-     */
-    private fun notifyDeprecatedOnModifiedListeners(data: ContactModelData) {
-        ListenerManager.contactListeners.handle { it.onModified(data.identity) }
-    }
-}
-
-internal object ContactModelDataFactory : ModelDataFactory<ContactModelData, DbContact> {
-    override fun toDbType(value: ContactModelData): DbContact = DbContact(
-        value.identity,
-        value.publicKey,
-        value.createdAt,
-        value.firstName,
-        value.lastName,
-        value.nickname,
-        value.colorIndex,
-        value.verificationLevel,
-        value.workVerificationLevel,
-        value.identityType,
-        value.acquaintanceLevel,
-        value.activityState,
-        value.syncState,
-        value.featureMask,
-        value.readReceiptPolicy,
-        value.typingIndicatorPolicy,
-        value.androidContactLookupKey,
-        value.localAvatarExpires,
-        value.isRestored,
-        value.profilePictureBlobId,
-        value.jobTitle,
-        value.department
-    )
-
-    override fun toDataType(value: DbContact): ContactModelData = ContactModelData(
-        value.identity,
-        value.publicKey,
-        value.createdAt,
-        value.firstName,
-        value.lastName,
-        value.nickname,
-        value.colorIndex,
-        value.verificationLevel,
-        value.workVerificationLevel,
-        value.identityType,
-        value.acquaintanceLevel,
-        value.activityState,
-        value.syncState,
-        value.featureMask,
-        value.readReceiptPolicy,
-        value.typingIndicatorPolicy,
-        value.androidContactLookupKey,
-        value.localAvatarExpires,
-        value.isRestored,
-        value.profilePictureBlobId,
-        value.jobTitle,
-        value.department
-    )
-}
diff --git a/app/src/main/java/ch/threema/data/models/EditHistoryEntryData.kt b/app/src/main/java/ch/threema/data/models/EditHistoryEntryData.kt
deleted file mode 100644
index f5c11f52..00000000
--- a/app/src/main/java/ch/threema/data/models/EditHistoryEntryData.kt
+++ /dev/null
@@ -1,51 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.models
-
-import ch.threema.data.storage.DbEditHistoryEntry
-import java.util.Date
-
-data class EditHistoryEntryData(
-    /** unique id. */
-    @JvmField val uid: Int,
-    /** The id of the edited message referencing the db row. */
-    @JvmField val messageUid: String,
-    /** The former text of the edited message. */
-    @JvmField val text: String?,
-    /** Timestamp when the message was edited and hence the entry created. */
-    @JvmField val editedAt: Date
-) {
-    fun uid() = uid
-
-    fun messageUid() = messageUid
-
-    fun text() = text
-
-    fun editedAt() = editedAt
-}
-
-fun DbEditHistoryEntry.toDataType() = EditHistoryEntryData(
-    uid = this.uid,
-    messageUid = this.messageUid,
-    text = this.text,
-    editedAt = this.editedAt
-)
diff --git a/app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt b/app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt
deleted file mode 100644
index 8dba998f..00000000
--- a/app/src/main/java/ch/threema/data/models/EditHistoryListModel.kt
+++ /dev/null
@@ -1,39 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.models
-
-import kotlinx.coroutines.flow.MutableStateFlow
-
-class EditHistoryListModel(data: List<EditHistoryEntryData>) : BaseModel<List<EditHistoryEntryData>>(
-    modelName = "EditHistoryListModel",
-    mutableData = MutableStateFlow(data)
-) {
-    fun addEntry(entry: EditHistoryEntryData) {
-        if (mutableData.value?.none { it == entry } == true) {
-            mutableData.value = mutableData.value?.toMutableList()?.apply { add(0, entry) }
-        }
-    }
-
-    fun clear() {
-        mutableData.value = emptyList()
-    }
-}
diff --git a/app/src/main/java/ch/threema/data/models/GroupModel.kt b/app/src/main/java/ch/threema/data/models/GroupModel.kt
deleted file mode 100644
index 0f653110..00000000
--- a/app/src/main/java/ch/threema/data/models/GroupModel.kt
+++ /dev/null
@@ -1,223 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.models
-
-import androidx.lifecycle.LiveData
-import androidx.lifecycle.asLiveData
-import ch.threema.app.utils.runtimeAssert
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.base.utils.Utils
-import ch.threema.data.repositories.RepositoryToken
-import ch.threema.data.storage.DatabaseBackend
-import ch.threema.data.storage.DbGroup
-import kotlinx.coroutines.flow.MutableStateFlow
-import kotlinx.serialization.Serializable
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-import java.util.Collections
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("data.GroupModel")
-
-/**
- * The group identity uniquely identifies a group. It consists of the creator identity and the group
- * id.
- */
-@Serializable
-data class GroupIdentity(
-    /** The creator identity string. Must be 8 characters long. */
-    val creatorIdentity: String,
-    /** The group id of the group. */
-    val groupId: Long,
-) {
-    /**
-     * The hex representation of the group id.
-     */
-    val groupIdHexString: String by lazy { Utils.byteArrayToHexString(groupIdByteArray) }
-
-    /**
-     * The group id as little endian byte array.
-     */
-    val groupIdByteArray: ByteArray by lazy { Utils.longToByteArrayLittleEndian(groupId) }
-}
-
-data class GroupModelData(
-    /** The identity of the group. */
-    @JvmField val groupIdentity: GroupIdentity,
-    /** The group name. */
-    @JvmField val name: String?,
-    /** The creation date. */
-    @JvmField val createdAt: Date,
-    /** Currently not used. Might be used for periodic group sync in the future. TODO(SE-146) */
-    @JvmField val synchronizedAt: Date?,
-    /** Last update flag. */
-    @JvmField val lastUpdate: Date?,
-    /** Deleted flag. */
-    @JvmField val deleted: Boolean,
-    /** Is archived flag. */
-    @JvmField val isArchived: Boolean,
-    /** The color index. */
-    val colorIndex: UByte,
-    /** The group description. */
-    @JvmField val groupDescription: String?,
-    /** The group description timestamp. */
-    @JvmField val groupDescriptionChangedAt: Date?,
-    /**
-     * The group members' identities. This does not include the user's identity.
-     *
-     * Note that this set must not be modified.
-     *
-     * @throws UnsupportedOperationException if the set is being modified
-     */
-    @JvmField val members: Set<String>,
-) {
-    companion object {
-        /**
-         * Factory function using only Java-compatible types.
-         */
-        @JvmStatic
-        fun javaCreate(
-            creatorIdentity: String,
-            groupId: Long,
-            name: String?,
-            createdAt: Date,
-            synchronizedAt: Date,
-            lastUpdate: Date?,
-            deleted: Boolean,
-            isArchived: Boolean,
-            colorIndex: Int,
-            groupDescription: String?,
-            groupDescriptionChangedAt: Date?,
-            members: Set<String>,
-        ): GroupModelData {
-            if (colorIndex < 0 || colorIndex > 255) {
-                throw IllegalArgumentException("colorIndex must be between 0 and 255")
-            }
-            return GroupModelData(
-                GroupIdentity(creatorIdentity, groupId),
-                name,
-                createdAt,
-                synchronizedAt,
-                lastUpdate,
-                deleted,
-                isArchived,
-                colorIndex.toUByte(),
-                groupDescription,
-                groupDescriptionChangedAt,
-                Collections.unmodifiableSet(members),
-            )
-        }
-    }
-
-    /**
-     * Return the [colorIndex] as [Int].
-     */
-    fun colorIndexInt(): Int = colorIndex.toInt()
-}
-
-/**
- * A group.
- */
-class GroupModel(
-    val groupIdentity: GroupIdentity,
-    data: GroupModelData,
-    private val databaseBackend: DatabaseBackend,
-) : BaseModel<GroupModelData>(MutableStateFlow(data), "GroupModel") {
-
-    init {
-        runtimeAssert(
-            groupIdentity == data.groupIdentity,
-            "Group identity mismatch"
-        )
-    }
-
-    /**
-     * Get a [LiveData] for the internal data state flow.
-     */
-    fun liveData(): LiveData<GroupModelData?> = data.asLiveData()
-
-    /**
-     * Update all data from database.
-     *
-     * Note: This method may only be called by the repository, in code that bridges the old models
-     * to the new models. All other code does not need to refresh the data, the model's state flow
-     * should always be up to date.
-     *
-     * Note: If the model is marked as deleted, then this will have no effect.
-     */
-    internal fun refreshFromDb(token: RepositoryToken) {
-        logger.info("Refresh from database")
-        synchronized(this) {
-            if (mutableData.value == null) {
-                logger.warn("Cannot refresh deleted ${this.modelName} from DB")
-                return
-            }
-            val dbGroup = databaseBackend.getGroupByGroupIdentity(groupIdentity) ?: return
-            val newData = GroupModelDataFactory.toDataType(dbGroup)
-            runtimeAssert(
-                newData.groupIdentity == groupIdentity,
-                "Cannot update group model with data for different group: ${newData.groupIdentity} != $groupIdentity"
-            )
-            mutableData.value = newData
-        }
-    }
-
-}
-
-internal object GroupModelDataFactory : ModelDataFactory<GroupModelData, DbGroup> {
-    override fun toDbType(value: GroupModelData): DbGroup = DbGroup(
-        creatorIdentity = value.groupIdentity.creatorIdentity,
-        groupId = value.groupIdentity.groupIdHexString,
-        name = value.name,
-        createdAt = value.createdAt,
-        synchronizedAt = value.synchronizedAt,
-        lastUpdate = value.lastUpdate,
-        deleted = value.deleted,
-        isArchived = value.isArchived,
-        colorIndex = value.colorIndex,
-        groupDescription = value.groupDescription,
-        groupDescriptionChangedAt = value.groupDescriptionChangedAt,
-        members = value.members,
-    )
-
-    override fun toDataType(value: DbGroup): GroupModelData = GroupModelData(
-        groupIdentity = GroupIdentity(value.creatorIdentity, groupIdDbToData(value.groupId)),
-        name = value.name,
-        createdAt = value.createdAt,
-        synchronizedAt = value.synchronizedAt,
-        lastUpdate = value.lastUpdate,
-        deleted = value.deleted,
-        isArchived = value.isArchived,
-        colorIndex = value.colorIndex,
-        groupDescription = value.groupDescription,
-        groupDescriptionChangedAt = value.groupDescriptionChangedAt,
-        members = value.members,
-    )
-
-    private fun groupIdDbToData(littleEndianHexGroupId: String): Long {
-        val byteArray = Utils.hexStringToByteArray(littleEndianHexGroupId)
-
-        return ByteBuffer.wrap(byteArray)
-            .order(ByteOrder.LITTLE_ENDIAN)
-            .getLong()
-    }
-}
diff --git a/app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt b/app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt
deleted file mode 100644
index 27326bc5..00000000
--- a/app/src/main/java/ch/threema/data/repositories/ContactModelRepository.kt
+++ /dev/null
@@ -1,276 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-import android.database.sqlite.SQLiteException
-import ch.threema.app.listeners.ContactListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.app.utils.ColorUtil
-import ch.threema.base.ThreemaException
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.data.ModelTypeCache
-import ch.threema.data.models.ContactModel
-import ch.threema.data.models.ContactModelData
-import ch.threema.data.models.ContactModelDataFactory
-import ch.threema.data.models.ModelDeletedException
-import ch.threema.data.storage.DatabaseBackend
-import ch.threema.domain.models.ContactSyncState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.ReadReceiptPolicy
-import ch.threema.domain.models.TypingIndicatorPolicy
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.models.WorkVerificationLevel
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
-import java.nio.charset.StandardCharsets
-import java.security.MessageDigest
-import java.security.NoSuchAlgorithmException
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("data.ContactModelRepository")
-
-class ContactModelRepository(
-    private val cache: ModelTypeCache<String, ContactModel>, // Note: Synchronize access
-    private val databaseBackend: DatabaseBackend,
-) {
-    private object ContactModelRepositoryToken : RepositoryToken
-
-    init {
-        // Register an "old" contact listener that updates the "new" models
-        ListenerManager.contactListeners.add(object : ContactListener {
-            override fun onModified(identity: String) {
-                synchronized(this@ContactModelRepository) {
-                    cache.get(identity)?.refreshFromDb(ContactModelRepositoryToken)
-                }
-            }
-
-            override fun onAvatarChanged(contactModel: ch.threema.storage.models.ContactModel?) {
-                // Ignored, avatars are not handled in contact model
-            }
-
-            override fun onRemoved(identity: String) {
-                // Called when the "old model" was deleted. Propagate the deletion.
-                synchronized(this@ContactModelRepository) {
-                    cache.get(identity)?.let {
-                        delete(it, true)
-                    }
-                }
-            }
-        })
-    }
-
-    /**
-     * Create a new contact from local. This also reflects the contact if MD is active.
-     *
-     * @throws ContactCreateException if inserting the contact in the database failed
-     */
-    fun createFromLocal(
-        identity: String,
-        publicKey: ByteArray,
-        date: Date,
-        identityType: IdentityType,
-        acquaintanceLevel: AcquaintanceLevel,
-        activityState: State,
-        featureMask: ULong,
-        verificationLevel: VerificationLevel = VerificationLevel.UNVERIFIED,
-    ): ContactModel = createAndReflect(
-        identity,
-        publicKey,
-        date,
-        identityType,
-        acquaintanceLevel,
-        activityState,
-        featureMask,
-        verificationLevel,
-    )
-
-    /**
-     * Create a new contact from remote. This also reflects the contact if MD is active.
-     *
-     * @throws ContactCreateException if inserting the contact in the database failed
-     */
-    suspend fun createFromRemote(
-        identity: String,
-        publicKey: ByteArray,
-        date: Date,
-        identityType: IdentityType,
-        acquaintanceLevel: AcquaintanceLevel,
-        activityState: State,
-        featureMask: ULong,
-        verificationLevel: VerificationLevel = VerificationLevel.UNVERIFIED,
-    ) = createAndReflect(
-        identity,
-        publicKey,
-        date,
-        identityType,
-        acquaintanceLevel,
-        activityState,
-        featureMask,
-        verificationLevel,
-    )
-
-    @Synchronized
-    fun createFromSync(contactModelData: ContactModelData): ContactModel {
-        databaseBackend.createContact(ContactModelDataFactory.toDbType(contactModelData))
-
-        notifyDeprecatedListenersNew(contactModelData.identity)
-
-        return getByIdentity(contactModelData.identity)
-            ?: throw IllegalStateException("Contact must exist at this point")
-    }
-
-    /**
-     * Create and reflect a new contact.
-     *
-     * @throws ContactCreateException if inserting the contact in the database failed
-     */
-    private fun createAndReflect(
-        identity: String,
-        publicKey: ByteArray,
-        date: Date,
-        identityType: IdentityType,
-        acquaintanceLevel: AcquaintanceLevel,
-        activityState: State,
-        featureMask: ULong,
-        verificationLevel: VerificationLevel
-    ): ContactModel {
-        val contactModelData = ContactModelData(
-            identity = identity,
-            publicKey = publicKey,
-            createdAt = date,
-            firstName = "",
-            lastName = "",
-            nickname = null,
-            colorIndex = getIdColorIndex(identity),
-            verificationLevel = verificationLevel,
-            workVerificationLevel = WorkVerificationLevel.NONE,
-            identityType = identityType,
-            acquaintanceLevel = acquaintanceLevel,
-            activityState = activityState,
-            syncState = ContactSyncState.INITIAL,
-            featureMask = featureMask,
-            readReceiptPolicy = ReadReceiptPolicy.DEFAULT,
-            typingIndicatorPolicy = TypingIndicatorPolicy.DEFAULT,
-            androidContactLookupKey = null,
-            localAvatarExpires = null,
-            isRestored = false,
-            profilePictureBlobId = null,
-            jobTitle = null,
-            department = null
-        )
-
-        // TODO(ANDR-3002) and TODO(ANDR-3003): Reflect contact sync create
-
-        val contactModel = synchronized(this) {
-            try {
-                databaseBackend.createContact(ContactModelDataFactory.toDbType(contactModelData))
-            } catch (exception: SQLiteException) {
-                // Note that in case the insertion fails, this is most likely because the identity
-                // already exists.
-                throw ContactCreateException(exception)
-            }
-
-            getByIdentity(identity)
-                ?: throw IllegalStateException("Contact must exist at this point")
-        }
-
-        notifyDeprecatedListenersNew(identity)
-
-        return contactModel
-    }
-
-    /**
-     * Return the contact model for the specified identity.
-     */
-    @Synchronized
-    fun getByIdentity(identity: String): ContactModel? {
-        return cache.getOrCreate(identity) {
-            val dbContact =
-                databaseBackend.getContactByIdentity(identity) ?: return@getOrCreate null
-            ContactModel(identity, ContactModelDataFactory.toDataType(dbContact), databaseBackend)
-        }
-    }
-
-    /**
-     * Remove the specified contact from the database and cache.
-     */
-    @Synchronized
-    fun deleteByIdentity(identity: String) {
-        // Look up model. If found, delete it.
-        getByIdentity(identity)?.let { this.delete(it, false) }
-
-        // TODO(ANDR-2835): Test that deletion works as intended, by opening the contact details,
-        // and then deleting the contact via multi-device protocol.
-    }
-
-    /**
-     * Remove the specified contact model from the database and cache.
-     */
-    @Synchronized
-    fun delete(contact: ContactModel) {
-        this.delete(contact, false)
-    }
-
-    /**
-     * Remove the specified contact model from the cache and possibly from the database.
-     *
-     * @param indirect This parameter should be set to `false` when called directly by app code,
-     *     and `true` when called as an effect of a `onRemoved` listener.
-     */
-    @Synchronized
-    private fun delete(model: ContactModel, indirect: Boolean) {
-        // Remove from cache
-        cache.remove(model.identity)
-
-        // Delete data from database and deactivate model
-        try {
-            model.delete(ContactModelRepositoryToken, !indirect)
-        } catch (e: ModelDeletedException) {
-            if (!indirect) {
-                throw e
-            } else {
-                logger.warn("Model for ${model.identity} is already marked as deleted")
-            }
-        }
-    }
-
-    private fun notifyDeprecatedListenersNew(identity: String) {
-        ListenerManager.contactListeners.handle { it.onNew(identity) }
-    }
-
-    /**
-     * Compute the sha 256 hash of this identity and set the color index accordingly.
-     */
-    private fun getIdColorIndex(identity: String): UByte = try {
-        val firstByte = MessageDigest.getInstance("SHA-256")
-            .digest(identity.toByteArray(StandardCharsets.UTF_8))[0]
-        ColorUtil.getInstance().getIDColorIndex(firstByte).toUByte()
-    } catch (e: NoSuchAlgorithmException) {
-        throw IllegalStateException("Could not find hashing algorithm for id color", e)
-    }
-}
-
-/**
- * This exception is thrown if the contact could not be added. A corrupt database or
- */
-class ContactCreateException(e: SQLiteException) :
-    ThreemaException("Failed to create the contact", e)
diff --git a/app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt b/app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt
deleted file mode 100644
index 3dd9ad12..00000000
--- a/app/src/main/java/ch/threema/data/repositories/EditHistoryRepository.kt
+++ /dev/null
@@ -1,102 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-import android.database.sqlite.SQLiteException
-import ch.threema.base.ThreemaException
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.data.ModelTypeCache
-import ch.threema.data.models.EditHistoryListModel
-import ch.threema.data.models.toDataType
-import ch.threema.data.storage.DbEditHistoryEntry
-import ch.threema.data.storage.EditHistoryDao
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.MessageType
-import org.slf4j.Logger
-import java.util.Date
-
-private val logger: Logger = LoggingUtil.getThreemaLogger("EditHistoryRepository")
-
-class EditHistoryRepository(
-    private val cache: ModelTypeCache<String, EditHistoryListModel>,
-    private val editHistoryDao: EditHistoryDao,
-) {
-    fun getByMessageUid(messageUid: String): EditHistoryListModel? {
-        return cache.getOrCreate(messageUid) {
-            logger.debug("Load edit history for message {} from database", messageUid)
-            EditHistoryListModel(
-                editHistoryDao
-                    .findAllByMessageUid(messageUid)
-                    .map(DbEditHistoryEntry::toDataType)
-            )
-        }
-    }
-
-    /**
-     * Inserts a [DbEditHistoryEntry] into the db.
-     * Call this before saving the edited message so the old message is saved in the history.
-     *
-     * @param message The message model to create an edit history entry from.
-     *
-     * @throws EditHistoryEntryCreateException if inserting the [DbEditHistoryEntry] in the database failed
-     * @throws IllegalStateException if the [message] is not valid to create a [DbEditHistoryEntry] from
-     *
-     */
-    fun createEntry(message: AbstractMessageModel) {
-        val oldText: String? = when (message.type) {
-            MessageType.TEXT -> message.body
-            MessageType.FILE -> message.caption
-            else -> throw IllegalStateException("Unhandled messageType ${message.type}")
-        }
-
-        synchronized(this) {
-            try {
-                if (message.editedAt == null && message.createdAt == null) {
-                    logger.error("Failed to get valid date to create the edit history entry. Fallback to current date.")
-                }
-                val historyEntry = DbEditHistoryEntry(
-                    uid = 0,
-                    messageUid = message.uid,
-                    messageId = message.id,
-                    text = oldText,
-                    editedAt = message.editedAt ?: message.createdAt ?: Date()
-                )
-
-                val uid = editHistoryDao.create(historyEntry, message)
-
-                val historyEntryWithUid = historyEntry.copy(uid = uid.toInt())
-                cache.get(message.uid)?.addEntry(historyEntryWithUid.toDataType())
-            } catch(exception: SQLiteException) {
-                throw EditHistoryEntryCreateException(exception)
-            }
-        }
-    }
-
-    fun deleteByMessageUid(messageUid: String) {
-        logger.debug("Delete by message uid {}", messageUid)
-        editHistoryDao.deleteAllByMessageUid(messageUid)
-        cache.get(messageUid)?.clear()
-        cache.remove(messageUid)
-    }
-}
-
-class EditHistoryEntryCreateException(e: Exception) : ThreemaException("Failed to create the edit history entry in the db", e)
diff --git a/app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt b/app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt
deleted file mode 100644
index 0c276dc1..00000000
--- a/app/src/main/java/ch/threema/data/repositories/GroupModelRepository.kt
+++ /dev/null
@@ -1,139 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-import ch.threema.app.listeners.GroupListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.data.ModelTypeCache
-import ch.threema.data.models.GroupIdentity
-import ch.threema.data.models.GroupModel
-import ch.threema.data.models.GroupModelDataFactory
-import ch.threema.data.storage.DatabaseBackend
-import ch.threema.domain.models.GroupId
-
-class GroupModelRepository(
-    private val cache: ModelTypeCache<GroupIdentity, GroupModel>, // Note: Synchronize access
-    private val databaseBackend: DatabaseBackend,
-) {
-    private object GroupModelRepositoryToken : RepositoryToken
-
-    init {
-        // Register an "old" group listener that updates the "new" models
-        ListenerManager.groupListeners.add(object : GroupListener {
-            override fun onRename(groupModel: ch.threema.storage.models.GroupModel?) {
-                onModified(groupModel)
-            }
-
-            override fun onNewMember(
-                group: ch.threema.storage.models.GroupModel?,
-                newIdentity: String?,
-                previousMemberCount: Int,
-            ) {
-                onModified(group)
-            }
-
-            override fun onMemberLeave(
-                group: ch.threema.storage.models.GroupModel?,
-                identity: String?,
-                previousMemberCount: Int,
-            ) {
-                onModified(group)
-            }
-
-            override fun onMemberKicked(
-                group: ch.threema.storage.models.GroupModel?,
-                identity: String?,
-                previousMemberCount: Int,
-            ) {
-                onModified(group)
-            }
-
-            override fun onUpdate(groupModel: ch.threema.storage.models.GroupModel?) {
-                onModified(groupModel)
-            }
-
-            override fun onRemove(groupModel: ch.threema.storage.models.GroupModel?) {
-                // Currently, a group is never completely removed except when the identity is
-                // removed or in tests. Therefore, we do not need to handle this here.
-                // TODO(ANDR-3049): Groups are now removed from the database and therefore must be
-                //  handled here.
-            }
-
-            override fun onLeave(groupModel: ch.threema.storage.models.GroupModel?) {
-                onModified(groupModel)
-            }
-
-            private fun onModified(group: ch.threema.storage.models.GroupModel?) {
-                if (group != null) {
-                    onModified(
-                        GroupIdentity(group.creatorIdentity, group.apiGroupId.toLong())
-                    )
-                }
-            }
-
-            @Synchronized
-            private fun onModified(groupIdentity: GroupIdentity) {
-                cache.get(groupIdentity)?.refreshFromDb(GroupModelRepositoryToken)
-            }
-        })
-    }
-
-    /**
-     * Get the group with the [localGroupDbId]. Note that this call always accesses the database.
-     * Use [getByGroupIdentity] or [getByCreatorIdentityAndId] to reduce database accesses.
-     */
-    @Synchronized
-    fun getByLocalGroupDbId(localGroupDbId: Long): GroupModel? {
-        // Note that we need to access the database to get the corresponding group model. The
-        // fetched group is needed to get the group identity. If the group is not cached, the
-        // fetched group data is used to construct the group model. Otherwise the cached group model
-        // is returned.
-        val dbGroup = databaseBackend.getGroupByLocalGroupDbId(localGroupDbId) ?: return null
-        val groupIdentity = GroupIdentity(dbGroup.creatorIdentity, GroupId(dbGroup.groupId).toLong())
-        return cache.getOrCreate(groupIdentity) {
-            GroupModel(
-                groupIdentity,
-                GroupModelDataFactory.toDataType(dbGroup),
-                databaseBackend,
-            )
-        }
-    }
-
-    @Synchronized
-    fun getByCreatorIdentityAndId(creatorIdentity: String, groupId: GroupId): GroupModel? {
-        val groupIdentity = GroupIdentity(creatorIdentity, groupId.toLong())
-        return getByGroupIdentity(groupIdentity)
-    }
-
-    @Synchronized
-    fun getByGroupIdentity(groupIdentity: GroupIdentity): GroupModel? {
-        return cache.getOrCreate(groupIdentity) {
-            val dbGroup = databaseBackend.getGroupByGroupIdentity(groupIdentity)
-                ?: return@getOrCreate null
-            GroupModel(
-                groupIdentity,
-                GroupModelDataFactory.toDataType(dbGroup),
-                databaseBackend
-            )
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt b/app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt
deleted file mode 100644
index abfe95a5..00000000
--- a/app/src/main/java/ch/threema/data/repositories/ModelRepositories.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.data.ModelCache
-import ch.threema.data.storage.EditHistoryDaoImpl
-import ch.threema.data.storage.SqliteDatabaseBackend
-import ch.threema.storage.DatabaseServiceNew
-
-class ModelRepositories(databaseService: DatabaseServiceNew) {
-    private val logger = LoggingUtil.getThreemaLogger("data.ModelRepositories")
-
-    private val cache = ModelCache()
-    private val databaseBackend = SqliteDatabaseBackend(databaseService)
-    private val editHistoryDao = EditHistoryDaoImpl(databaseService)
-
-    val contacts = ContactModelRepository(cache.contacts, databaseBackend)
-    val groups = GroupModelRepository(cache.groups, databaseBackend)
-    val editHistory = EditHistoryRepository(cache.editHistory, editHistoryDao)
-
-    init {
-        logger.debug("Created")
-    }
-}
diff --git a/app/src/main/java/ch/threema/data/repositories/RepositoryToken.kt b/app/src/main/java/ch/threema/data/repositories/RepositoryToken.kt
deleted file mode 100644
index ea6f6fb2..00000000
--- a/app/src/main/java/ch/threema/data/repositories/RepositoryToken.kt
+++ /dev/null
@@ -1,31 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.repositories
-
-/**
- * A token that can only be obtained by a model repository.
- *
- * The goal is to ensure that certain methods cannot be called by code outside the repository.
- *
- * Note: Should only be implemented by classes in model repositories!
- */
-internal interface RepositoryToken
diff --git a/app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt b/app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt
deleted file mode 100644
index ae4a569a..00000000
--- a/app/src/main/java/ch/threema/data/storage/DatabaseBackend.kt
+++ /dev/null
@@ -1,90 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.storage
-
-import android.database.sqlite.SQLiteException
-
-import ch.threema.data.models.GroupIdentity
-
-/**
- * This interface fully abstracts the database access.
- */
-interface DatabaseBackend {
-
-    /**
-     * Insert a new contact.
-     *
-     * @throws SQLiteException if insertion fails due to a conflict
-     */
-    fun createContact(contact: DbContact)
-
-    /**
-     * Return the contact with the specified [identity].
-     */
-    fun getContactByIdentity(identity: String): DbContact?
-
-    /**
-     * Update the specified contact (using the identity as lookup key).
-     *
-     * Note: Some fields will not be overwritten:
-     *
-     * - The identity
-     * - The public key
-     * - The createdAt timestamp
-     */
-    fun updateContact(contact: DbContact)
-
-    /**
-     * Delete the contact with the specified identity.
-     *
-     * Return whether the contact was deleted (true) or wasn't found (false).
-     */
-    fun deleteContactByIdentity(identity: String): Boolean
-
-    /**
-     * Insert a new group.
-     *
-     * @throws SQLiteException if insertion fails due to a conflict
-     */
-    fun createGroup(group: DbGroup)
-
-    /**
-     * Return the group with the specified [localDbId].
-     */
-    fun getGroupByLocalGroupDbId(localDbId: Long): DbGroup?
-
-    /**
-     * Return the group with the specified [groupIdentity].
-     */
-    fun getGroupByGroupIdentity(groupIdentity: GroupIdentity): DbGroup?
-
-    /**
-     * Update the specified group (using the creator identity and group id as lookup key).
-     *
-     * Note: Some fields will not be overwritten:
-     *
-     * - The creator identity
-     * - The group id
-     * - The createdAt timestamp
-     */
-    fun updateGroup(group: DbGroup)
-}
diff --git a/app/src/main/java/ch/threema/data/storage/DbTypes.kt b/app/src/main/java/ch/threema/data/storage/DbTypes.kt
deleted file mode 100644
index 45174dbc..00000000
--- a/app/src/main/java/ch/threema/data/storage/DbTypes.kt
+++ /dev/null
@@ -1,134 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.storage
-
-import ch.threema.domain.models.ContactSyncState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.ReadReceiptPolicy
-import ch.threema.domain.models.TypingIndicatorPolicy
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.models.WorkVerificationLevel
-import ch.threema.storage.models.ContactModel
-import java.util.Date
-
-// This file contains the types used in the database abstraction layer.
-
-data class DbContact(
-    /** The contact identity string. Must be 8 characters long. */
-    val identity: String,
-    /** The 32-byte public key of the contact. */
-    val publicKey: ByteArray,
-    /** Timestamp when this contact was added to the contact list. */
-    val createdAt: Date,
-    /** First name. */
-    val firstName: String,
-    /** Last name. */
-    val lastName: String,
-    /** Public nickname. */
-    val nickname: String?,
-    /** Color index (0-255). */
-    val colorIndex: UByte,
-    /** Verification level. */
-    val verificationLevel: VerificationLevel,
-    /** Threema Work verification level. */
-    val workVerificationLevel: WorkVerificationLevel,
-    /** Identity type (regular / work). */
-    val identityType: IdentityType,
-    /** Acquaintance level (direct / group). */
-    val acquaintanceLevel: ContactModel.AcquaintanceLevel,
-    /** Activity state (active / inactive / invalid). */
-    val activityState: ContactModel.State,
-    /** Contact sync state. */
-    val syncState: ContactSyncState,
-    /** Feature mask. */
-    val featureMask: ULong,
-    /** Read receipt policy. */
-    val readReceiptPolicy: ReadReceiptPolicy,
-    /** Typing indicator policy. */
-    val typingIndicatorPolicy: TypingIndicatorPolicy,
-    // TODO(ANDR-2998): Notification trigger policy override
-    // TODO(ANDR-2998): Notification sound policy override
-    /** Android contact lookup key. */
-    val androidContactLookupKey: String?,
-    /** Local avatar expiration date. */
-    val localAvatarExpires: Date?,
-    /** Whether this contact has been restored from backup. */
-    val isRestored: Boolean,
-    /** BlobId of the latest profile picture that was sent to this contact. */
-    val profilePictureBlobId: ByteArray?,
-    val jobTitle: String?,
-    val department: String?
-)
-
-data class DbGroup(
-    /** The group creator identity string. Must be 8 characters long. */
-    val creatorIdentity: String,
-    /**
-     * The group id of the group. It is the hex string representation of the group id as little
-     * endian byte array.
-     */
-    val groupId: String,
-    /** The group name. */
-    val name: String?,
-    /** The creation date. */
-    val createdAt: Date,
-    /** Currently not used. Might be used for periodic group sync. TODO(SE-146) */
-    val synchronizedAt: Date?,
-    /** Last update flag. */
-    val lastUpdate: Date?,
-    /** Deleted flag. */
-    val deleted: Boolean,
-    /** Is archived flag. */
-    val isArchived: Boolean,
-    /** The color index. */
-    val colorIndex: UByte,
-    /** The group description. */
-    val groupDescription: String?,
-    /** The group description changed timestamp. */
-    val groupDescriptionChangedAt: Date?,
-    /** The group members' identities. */
-    val members: Set<String>,
-)
-
-data class DbEditHistoryEntry(
-    /** The unique id used as primary key. */
-    val uid: Int = 0,
-    /** The uid of the edited message referencing the [ch.threema.storage.models.AbstractMessageModel.COLUMN_UID] */
-    val messageUid: String,
-    /** The id of the edited message referencing the [ch.threema.storage.models.AbstractMessageModel.COLUMN_ID]
-     *  Can be identical for different classes of messages that are stored in different tables
-     *  This is only used as foreign key because uid is not actually constrained as unique
-     */
-    val messageId: Int,
-    /** The former text of the edited message. */
-    val text: String?,
-    /** Timestamp when the message was edited and hence the entry created. */
-    val editedAt: Date
-) {
-    companion object {
-        const val COLUMN_UID = "uid"
-        const val COLUMN_MESSAGE_UID = "messageUid"
-        const val COLUMN_MESSAGE_ID = "messageId"
-        const val COLUMN_TEXT = "text"
-        const val COLUMN_EDITED_AT = "editedAt"
-    }
-}
diff --git a/app/src/main/java/ch/threema/data/storage/EditHistoryDao.kt b/app/src/main/java/ch/threema/data/storage/EditHistoryDao.kt
deleted file mode 100644
index da07d9bc..00000000
--- a/app/src/main/java/ch/threema/data/storage/EditHistoryDao.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.storage
-
-import android.database.sqlite.SQLiteException
-import ch.threema.data.repositories.EditHistoryEntryCreateException
-import ch.threema.storage.models.AbstractMessageModel
-
-interface EditHistoryDao {
-
-    /**
-     * Insert a new edit history entry
-     *
-     * @param entry The entry to add for the edit history
-     * @param messageModel The message referenced by the edit history entry
-     *
-     * @throws SQLiteException if insertion fails due to a conflict
-     * @throws EditHistoryEntryCreateException if inserting the [DbEditHistoryEntry] in the database failed
-     *
-     * @return the row ID of the newly inserted row, or -1 if an error occurred
-     */
-    fun create(entry: DbEditHistoryEntry, messageModel: AbstractMessageModel): Long
-
-    /**
-     * Delete all edit history entries referencing the specified message id
-     */
-    fun deleteAllByMessageUid(messageUid: String)
-
-    /**
-     * Find all edit history entries referencing the specified message uid
-     */
-    fun findAllByMessageUid(messageUid: String): List<DbEditHistoryEntry>
-}
diff --git a/app/src/main/java/ch/threema/data/storage/EditHistoryDaoImpl.kt b/app/src/main/java/ch/threema/data/storage/EditHistoryDaoImpl.kt
deleted file mode 100644
index 053fbb6b..00000000
--- a/app/src/main/java/ch/threema/data/storage/EditHistoryDaoImpl.kt
+++ /dev/null
@@ -1,104 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.storage
-
-import android.content.ContentValues
-import androidx.core.database.getStringOrNull
-import androidx.sqlite.db.SupportSQLiteOpenHelper
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.data.repositories.EditHistoryEntryCreateException
-import ch.threema.storage.factories.ContactEditHistoryEntryModelFactory
-import ch.threema.storage.factories.GroupEditHistoryEntryModelFactory
-import ch.threema.storage.models.AbstractMessageModel
-import ch.threema.storage.models.GroupMessageModel
-import ch.threema.storage.models.MessageModel
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-private val logger = LoggingUtil.getThreemaLogger("EditHistoryDaoImpl")
-
-class EditHistoryDaoImpl(
-    private val sqlite: SupportSQLiteOpenHelper,
-) : EditHistoryDao {
-
-    override fun create(entry: DbEditHistoryEntry, messageModel: AbstractMessageModel): Long {
-        val contentValues = ContentValues()
-
-        contentValues.put(DbEditHistoryEntry.COLUMN_MESSAGE_UID, entry.messageUid)
-        contentValues.put(DbEditHistoryEntry.COLUMN_MESSAGE_ID, entry.messageId)
-        contentValues.put(DbEditHistoryEntry.COLUMN_TEXT, entry.text)
-        contentValues.put(DbEditHistoryEntry.COLUMN_EDITED_AT, entry.editedAt.time)
-
-        val table = when (messageModel) {
-            is MessageModel -> ContactEditHistoryEntryModelFactory.TABLE
-            is GroupMessageModel -> GroupEditHistoryEntryModelFactory.TABLE
-            else -> throw EditHistoryEntryCreateException(
-                IllegalArgumentException("Cannot create edit history entry for message of class ${messageModel.javaClass.name}")
-            )
-        }
-
-        return sqlite.writableDatabase.insert(table, SQLiteDatabase.CONFLICT_ROLLBACK, contentValues)
-    }
-
-    override fun deleteAllByMessageUid(messageUid: String) {
-        var deletedEntries = sqlite.writableDatabase.delete(
-            table = ContactEditHistoryEntryModelFactory.TABLE,
-            whereClause = "${DbEditHistoryEntry.COLUMN_MESSAGE_UID} = ?",
-            whereArgs = arrayOf(messageUid)
-        )
-        deletedEntries += sqlite.writableDatabase.delete(
-            table = GroupEditHistoryEntryModelFactory.TABLE,
-            whereClause = "${DbEditHistoryEntry.COLUMN_MESSAGE_UID} = ?",
-            whereArgs = arrayOf(messageUid)
-        )
-        logger.debug("{} edit history entries deleted for message {}", deletedEntries, messageUid)
-    }
-
-    override fun findAllByMessageUid(messageUid: String): List<DbEditHistoryEntry> {
-        val cursor = (sqlite.readableDatabase as SQLiteDatabase)
-            .rawQuery(
-                "SELECT * FROM ${ContactEditHistoryEntryModelFactory.TABLE} WHERE ${DbEditHistoryEntry.COLUMN_MESSAGE_UID} = ? " +
-                    "UNION " +
-                    "SELECT * FROM ${GroupEditHistoryEntryModelFactory.TABLE} WHERE ${DbEditHistoryEntry.COLUMN_MESSAGE_UID} = ? " +
-                    "ORDER BY ${DbEditHistoryEntry.COLUMN_EDITED_AT} DESC",
-                messageUid,
-                messageUid
-            )
-
-        val result = mutableListOf<DbEditHistoryEntry>()
-        while (cursor.moveToNext()) {
-            val uid = cursor.getInt(getColumnIndexOrThrow(cursor, DbEditHistoryEntry.COLUMN_UID))
-            val messageId = cursor.getInt(getColumnIndexOrThrow(cursor, DbEditHistoryEntry.COLUMN_MESSAGE_ID))
-            val text = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, DbEditHistoryEntry.COLUMN_TEXT))
-            val editedAt = cursor.getDate(getColumnIndexOrThrow(cursor, DbEditHistoryEntry.COLUMN_EDITED_AT))
-            result.add(DbEditHistoryEntry(
-                uid = uid,
-                messageUid = messageUid,
-                messageId = messageId,
-                text = text,
-                editedAt = editedAt
-            ))
-        }
-
-        cursor.close()
-        return result
-    }
-}
diff --git a/app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt b/app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt
deleted file mode 100644
index cde0ccf6..00000000
--- a/app/src/main/java/ch/threema/data/storage/SqliteDatabaseBackend.kt
+++ /dev/null
@@ -1,695 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data.storage
-
-import android.content.ContentValues
-import android.database.Cursor
-import android.database.sqlite.SQLiteException
-import androidx.annotation.IntRange
-import androidx.core.database.getBlobOrNull
-import androidx.core.database.getIntOrNull
-import androidx.core.database.getLongOrNull
-import androidx.core.database.getStringOrNull
-import androidx.sqlite.db.SupportSQLiteOpenHelper
-import androidx.sqlite.db.SupportSQLiteQueryBuilder
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.data.models.GroupIdentity
-import ch.threema.domain.models.ContactSyncState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.ReadReceiptPolicy
-import ch.threema.domain.models.TypingIndicatorPolicy
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.models.WorkVerificationLevel
-import ch.threema.storage.CursorHelper
-import ch.threema.storage.models.ContactModel
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.GroupMemberModel
-import ch.threema.storage.models.GroupModel
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-import java.util.Collections
-import java.util.Date
-
-class DatabaseException internal constructor(message: String, cause: Throwable?) :
-    RuntimeException(message, cause) {
-    internal constructor(message: String) : this(message, null)
-}
-
-/**
- * Returns the value of the requested column as a Date, assuming that it contains
- * the unix timestamp in milliseconds as a numeric value.
- *
- * If that is not the case, an exception is thrown.
- */
-fun Cursor.getDate(@IntRange(from = 0) columnIndex: Int): Date {
-    val timestampMs = this.getLong(columnIndex)
-    return Date(timestampMs)
-}
-
-/**
- * Returns the value of the requested column as a Date, assuming that it contains
- * the unix timestamp in milliseconds as a numeric value.
- *
- * If the column contains a null value, then null is returned.
- */
-private fun Cursor.getDateOrNull(@IntRange(from = 0) columnIndex: Int): Date? {
-    val timestampMs = this.getLongOrNull(columnIndex) ?: return null
-    return Date(timestampMs)
-}
-
-/**
- * Returns the value of the requested column as a Date, assuming that it contains the string
- * representation of the date as defined in [CursorHelper.dateAsStringFormat].
- *
- * @throws NullPointerException if the column contains a null value
- */
-private fun Cursor.getDateByString(@IntRange(from = 0) columnIndex: Int): Date {
-    val dateString = this.getString(columnIndex)
-    return CursorHelper.dateAsStringFormat.get()!!.parse(dateString)!!
-}
-
-/**
- * Returns the value of the requested column as a Date, assuming that it contains the string
- * representation of the date as defined in [CursorHelper.dateAsStringFormat].
- *
- * If the column contains a null value, then null is returned
- */
-private fun Cursor.getDateByStringOrNull(@IntRange(from = 0) columnIndex: Int): Date? {
-    val dateString = this.getStringOrNull(columnIndex) ?: return null
-    return CursorHelper.dateAsStringFormat.get()?.parse(dateString)
-}
-
-/**
- * Returns the value of the requested column as a Boolean, assuming that it contains a numeric value
- * of 0 (false) or not 0 (true).
- */
-private fun Cursor.getBoolean(@IntRange(from = 0) columnIndex: Int): Boolean {
-    val numericBool = this.getInt(columnIndex)
-    return when (numericBool) {
-        0 -> false
-        else -> true
-    }
-}
-
-/**
- * Returns the value of the requested column as an UByte, assuming that it contains a numeric value
- * between 0 and [UByte.MAX_VALUE]. Otherwise, an [IllegalArgumentException] is thrown.
- */
-private fun Cursor.getUByte(@IntRange(from = 0) columnIndex: Int): UByte {
-    val numberAsInt = this.getInt(columnIndex)
-    if (numberAsInt < 0 || numberAsInt > UByte.MAX_VALUE.toInt()) {
-        throw IllegalArgumentException("Value '$numberAsInt' at index $columnIndex is not an ubyte")
-    }
-    return numberAsInt.toUByte()
-}
-
-/**
- * Returns the value of the requested column as a Boolean, assuming that it contains
- * a numeric 1 or 0 value.
- *
- * If the column contains another value than 0 or 1, then null is returned.
- */
-private fun Cursor.getBooleanOrNull(@IntRange(from = 0) columnIndex: Int): Boolean? {
-    val numericBool = this.getIntOrNull(columnIndex) ?: return null
-    return when (numericBool) {
-        0 -> false
-        1 -> true
-        else -> null
-    }
-}
-
-/**
- * Returns the date as string. If conversion does not work, null is returned.
- */
-private fun Date.toDateStringOrNull(): String? = CursorHelper.dateAsStringFormat.get()?.format(this)
-
-private val logger = LoggingUtil.getThreemaLogger("data.SqliteDatabaseBackend")
-
-/**
- * Return the column index for the specified [columName].
- *
- * If the column cannot be found in the [cursor], a [DatabaseException] is thrown.
- */
-@IntRange(from = 0)
-fun getColumnIndexOrThrow(cursor: Cursor, columName: String): Int {
-    val index = cursor.getColumnIndex(columName)
-    if (index < 0) {
-        throw DatabaseException("Cannot find column with name $columName")
-    }
-    return index
-}
-
-class SqliteDatabaseBackend(private val sqlite: SupportSQLiteOpenHelper) : DatabaseBackend {
-
-    override fun createContact(contact: DbContact) {
-        val contentValues = ContentValues()
-        contentValues.put(ContactModel.COLUMN_IDENTITY, contact.identity)
-        contentValues.put(ContactModel.COLUMN_PUBLIC_KEY, contact.publicKey)
-        contentValues.put(ContactModel.COLUMN_CREATED_AT, contact.createdAt.time)
-        contentValues.update(contact)
-
-        sqlite.writableDatabase.insert(
-            ContactModel.TABLE,
-            SQLiteDatabase.CONFLICT_ROLLBACK,
-            contentValues
-        )
-    }
-
-    override fun getContactByIdentity(identity: String): DbContact? {
-        val cursor = sqlite.readableDatabase.query(
-            SupportSQLiteQueryBuilder.builder(ContactModel.TABLE)
-                .columns(
-                    arrayOf(
-                        ContactModel.COLUMN_PUBLIC_KEY,
-                        ContactModel.COLUMN_CREATED_AT,
-                        ContactModel.COLUMN_FIRST_NAME,
-                        ContactModel.COLUMN_LAST_NAME,
-                        ContactModel.COLUMN_PUBLIC_NICK_NAME,
-                        ContactModel.COLUMN_ID_COLOR_INDEX,
-                        ContactModel.COLUMN_VERIFICATION_LEVEL,
-                        ContactModel.COLUMN_IS_WORK,
-                        ContactModel.COLUMN_TYPE,
-                        ContactModel.COLUMN_ACQUAINTANCE_LEVEL,
-                        ContactModel.COLUMN_STATE,
-                        ContactModel.COLUMN_SYNC_STATE,
-                        ContactModel.COLUMN_FEATURE_MASK,
-                        ContactModel.COLUMN_READ_RECEIPTS,
-                        ContactModel.COLUMN_TYPING_INDICATORS,
-                        ContactModel.COLUMN_ANDROID_CONTACT_LOOKUP_KEY,
-                        ContactModel.COLUMN_LOCAL_AVATAR_EXPIRES,
-                        ContactModel.COLUMN_IS_RESTORED,
-                        ContactModel.COLUMN_PROFILE_PIC_BLOB_ID,
-                        ContactModel.COLUMN_JOB_TITLE,
-                        ContactModel.COLUMN_DEPARTMENT,
-                    )
-                )
-                .selection("${ContactModel.COLUMN_IDENTITY} = ?", arrayOf(identity))
-                .create()
-        )
-        if (!cursor.moveToFirst()) {
-            cursor.close()
-            return null
-        }
-
-        val publicKey = cursor.getBlob(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_PUBLIC_KEY))
-        val createdAt = cursor.getDate(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_CREATED_AT))
-        val firstName = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_FIRST_NAME))
-            ?: ""
-        val lastName = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_LAST_NAME))
-            ?: ""
-        val nickname = cursor.getStringOrNull(
-            getColumnIndexOrThrow(
-                cursor,
-                ContactModel.COLUMN_PUBLIC_NICK_NAME
-            )
-        )
-        var colorIndex = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_ID_COLOR_INDEX))
-        val verificationLevelRaw = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_VERIFICATION_LEVEL))
-        val isWorkVerifiedRaw = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_IS_WORK))
-        val identityTypeRaw = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_TYPE))
-        val acquaintanceLevelRaw = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_ACQUAINTANCE_LEVEL))
-        val activityStateRaw = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_STATE))
-        val syncStateRaw = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_SYNC_STATE))
-        var featureMask = cursor.getLong(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_FEATURE_MASK))
-        val readReceipts = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_READ_RECEIPTS))
-        val typingIndicators = cursor.getInt(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_TYPING_INDICATORS))
-        val androidContactLookupKey = cursor.getStringOrNull(
-            getColumnIndexOrThrow(
-                cursor,
-                ContactModel.COLUMN_ANDROID_CONTACT_LOOKUP_KEY
-            )
-        )
-        val localAvatarExpires = cursor.getDateOrNull(
-            getColumnIndexOrThrow(
-                cursor,
-                ContactModel.COLUMN_LOCAL_AVATAR_EXPIRES
-            )
-        )
-        val isRestored = cursor.getBooleanOrNull(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_IS_RESTORED))
-            ?: false
-        val profilePictureBlobId = cursor.getBlobOrNull(
-            getColumnIndexOrThrow(
-                cursor,
-                ContactModel.COLUMN_PROFILE_PIC_BLOB_ID
-            )
-        )
-        val jobTitle = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_JOB_TITLE))
-        val department = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, ContactModel.COLUMN_DEPARTMENT))
-
-        cursor.close()
-
-        // Validation and mapping
-        if (colorIndex < 0 || colorIndex > 255) {
-            logger.warn("colorIndex value out of range: {}. Falling back to 0.", colorIndex)
-            colorIndex = 0
-        }
-        val verificationLevel = when (verificationLevelRaw) {
-            0 -> VerificationLevel.UNVERIFIED
-            1 -> VerificationLevel.SERVER_VERIFIED
-            2 -> VerificationLevel.FULLY_VERIFIED
-            else -> {
-                logger.warn(
-                    "verificationLevel value out of range: {}. Falling back to UNVERIFIED.",
-                    verificationLevelRaw
-                )
-                VerificationLevel.UNVERIFIED
-            }
-        }
-        val workVerificationLevel = when (isWorkVerifiedRaw) {
-            0 -> WorkVerificationLevel.NONE
-            1 -> WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED
-            else -> {
-                logger.warn(
-                    "workVerificationLevel value out of range: {}. Falling back to NONE.",
-                    isWorkVerifiedRaw
-                )
-                WorkVerificationLevel.NONE
-            }
-        }
-        val identityType = when (identityTypeRaw) {
-            0 -> IdentityType.NORMAL
-            1 -> IdentityType.WORK
-            else -> {
-                logger.warn(
-                    "identityType value out of range: {}. Falling back to NORMAL.",
-                    identityTypeRaw
-                )
-                IdentityType.NORMAL
-            }
-        }
-        val acquaintanceLevel = when (acquaintanceLevelRaw) {
-            0 -> AcquaintanceLevel.DIRECT
-            1 -> AcquaintanceLevel.GROUP
-            else -> {
-                logger.warn(
-                    "acquaintanceLevel value out of range: {}. Falling back to DIRECT.",
-                    acquaintanceLevelRaw
-                )
-                AcquaintanceLevel.DIRECT
-            }
-        }
-        val activityState = when (activityStateRaw) {
-            "INACTIVE" -> ContactModel.State.INACTIVE
-            "INVALID" -> ContactModel.State.INVALID
-            "ACTIVE" -> ContactModel.State.ACTIVE
-            "TEMPORARY" -> ContactModel.State.ACTIVE // Legacy state, see !276
-            else -> {
-                logger.warn(
-                    "activityState value out of range: {}. Falling back to ACTIVE.",
-                    activityStateRaw
-                )
-                ContactModel.State.ACTIVE
-            }
-        }
-        val syncState = when (syncStateRaw) {
-            0 -> ContactSyncState.INITIAL
-            1 -> ContactSyncState.IMPORTED
-            2 -> ContactSyncState.CUSTOM
-            else -> {
-                logger.warn(
-                    "syncState value out of range: {}. Falling back to INITIAL.",
-                    syncStateRaw
-                )
-                ContactSyncState.INITIAL
-            }
-        }
-        if (featureMask < 0) {
-            logger.warn("featureMask value out of range: {}. Falling back to 0.", featureMask)
-            featureMask = 0
-        }
-        val readReceiptPolicy = when (readReceipts) {
-            0 -> ReadReceiptPolicy.DEFAULT
-            1 -> ReadReceiptPolicy.SEND
-            2 -> ReadReceiptPolicy.DONT_SEND
-            else -> {
-                logger.warn(
-                    "readReceipts value out of range: {}. Falling back to DEFAULT.",
-                    typingIndicators
-                )
-                ReadReceiptPolicy.DEFAULT
-            }
-        }
-        val typingIndicatorPolicy = when (typingIndicators) {
-            0 -> TypingIndicatorPolicy.DEFAULT
-            1 -> TypingIndicatorPolicy.SEND
-            2 -> TypingIndicatorPolicy.DONT_SEND
-            else -> {
-                logger.warn(
-                    "typingIndicators value out of range: {}. Falling back to DEFAULT.",
-                    typingIndicators
-                )
-                TypingIndicatorPolicy.DEFAULT
-            }
-        }
-
-        return DbContact(
-            identity,
-            publicKey,
-            createdAt,
-            firstName,
-            lastName,
-            nickname,
-            colorIndex.toUByte(),
-            verificationLevel,
-            workVerificationLevel,
-            identityType,
-            acquaintanceLevel,
-            activityState,
-            syncState,
-            featureMask.toULong(),
-            readReceiptPolicy,
-            typingIndicatorPolicy,
-            androidContactLookupKey,
-            localAvatarExpires,
-            isRestored,
-            profilePictureBlobId,
-            jobTitle,
-            department
-        )
-    }
-
-    override fun updateContact(contact: DbContact) {
-        val contentValues = ContentValues()
-        contentValues.update(contact)
-
-        sqlite.writableDatabase.update(
-            table = ContactModel.TABLE,
-            conflictAlgorithm = SQLiteDatabase.CONFLICT_ROLLBACK,
-            values = contentValues,
-            whereClause = "${ContactModel.COLUMN_IDENTITY} = ?",
-            whereArgs = arrayOf(contact.identity),
-        )
-    }
-
-    private fun ContentValues.update(contact: DbContact) {
-        // Note: Identity, public key and created at cannot be updated.
-        put(ContactModel.COLUMN_FIRST_NAME, contact.firstName)
-        put(ContactModel.COLUMN_LAST_NAME, contact.lastName)
-        put(ContactModel.COLUMN_PUBLIC_NICK_NAME, contact.nickname)
-        put(ContactModel.COLUMN_ID_COLOR_INDEX, contact.colorIndex.toInt())
-        put(ContactModel.COLUMN_VERIFICATION_LEVEL, contact.verificationLevel.code)
-        put(
-            ContactModel.COLUMN_IS_WORK, when (contact.workVerificationLevel) {
-                WorkVerificationLevel.NONE -> 0
-                WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED -> 1
-            }
-        )
-        put(
-            ContactModel.COLUMN_TYPE, when (contact.identityType) {
-                IdentityType.NORMAL -> 0
-                IdentityType.WORK -> 1
-            }
-        )
-        put(
-            ContactModel.COLUMN_ACQUAINTANCE_LEVEL, when (contact.acquaintanceLevel) {
-                AcquaintanceLevel.DIRECT -> 0
-                AcquaintanceLevel.GROUP -> 1
-            }
-        )
-        put(
-            ContactModel.COLUMN_STATE, when (contact.activityState) {
-                ContactModel.State.ACTIVE -> "ACTIVE"
-                ContactModel.State.INACTIVE -> "INACTIVE"
-                ContactModel.State.INVALID -> "INVALID"
-            }
-        )
-        put(
-            ContactModel.COLUMN_SYNC_STATE, when (contact.syncState) {
-                ContactSyncState.INITIAL -> 0
-                ContactSyncState.IMPORTED -> 1
-                ContactSyncState.CUSTOM -> 2
-            }
-        )
-        put(ContactModel.COLUMN_FEATURE_MASK, contact.featureMask.toLong())
-        put(
-            ContactModel.COLUMN_READ_RECEIPTS, when (contact.readReceiptPolicy) {
-                ReadReceiptPolicy.DEFAULT -> 0
-                ReadReceiptPolicy.SEND -> 1
-                ReadReceiptPolicy.DONT_SEND -> 2
-            }
-        )
-        put(
-            ContactModel.COLUMN_TYPING_INDICATORS, when (contact.typingIndicatorPolicy) {
-                TypingIndicatorPolicy.DEFAULT -> 0
-                TypingIndicatorPolicy.SEND -> 1
-                TypingIndicatorPolicy.DONT_SEND -> 2
-            }
-        )
-        put(ContactModel.COLUMN_ANDROID_CONTACT_LOOKUP_KEY, contact.androidContactLookupKey)
-        put(ContactModel.COLUMN_LOCAL_AVATAR_EXPIRES, contact.localAvatarExpires?.time)
-        put(ContactModel.COLUMN_IS_RESTORED, contact.isRestored)
-        put(ContactModel.COLUMN_PROFILE_PIC_BLOB_ID, contact.profilePictureBlobId)
-        put(ContactModel.COLUMN_JOB_TITLE, contact.jobTitle)
-        put(ContactModel.COLUMN_DEPARTMENT, contact.department)
-    }
-
-    override fun deleteContactByIdentity(identity: String): Boolean {
-        return sqlite.writableDatabase.delete(
-            table = ContactModel.TABLE,
-            whereClause = "${ContactModel.COLUMN_IDENTITY} = ?",
-            whereArgs = arrayOf(identity),
-        ) > 0
-    }
-
-    /**
-     * Create a group.
-     *
-     * @throws DatabaseException if the constraints fail while inserting the group
-     */
-    override fun createGroup(group: DbGroup) {
-        val contentValues = ContentValues()
-        contentValues.put(GroupModel.COLUMN_CREATOR_IDENTITY, group.creatorIdentity)
-        contentValues.put(GroupModel.COLUMN_API_GROUP_ID, group.groupId)
-        contentValues.put(GroupModel.COLUMN_CREATED_AT, group.createdAt.toDateStringOrNull())
-        contentValues.update(group)
-
-        val rowId = try {
-            sqlite.writableDatabase.insert(
-                GroupModel.TABLE,
-                SQLiteDatabase.CONFLICT_ROLLBACK,
-                contentValues
-            )
-        } catch (e: SQLiteException) {
-            throw DatabaseException("Could not insert group", e)
-        }
-
-        if (rowId < 0) {
-            throw DatabaseException("Could not insert group")
-        }
-
-        updateGroupMembers(rowId, group.members)
-    }
-
-    override fun getGroupByLocalGroupDbId(localDbId: Long): DbGroup? {
-        return getGroup {
-            it.selection("${GroupModel.COLUMN_ID} = ?", arrayOf(localDbId))
-        }
-    }
-
-    override fun getGroupByGroupIdentity(groupIdentity: GroupIdentity): DbGroup? {
-        val creatorIdentitySelection = "${GroupModel.COLUMN_CREATOR_IDENTITY} = ?"
-        val groupIdSelection = "${GroupModel.COLUMN_API_GROUP_ID} = ?"
-        val creatorIdentitySelectionArg = groupIdentity.creatorIdentity
-        val groupIdSelectionArg = groupIdentity.groupIdHexString
-        val selection = "$creatorIdentitySelection AND $groupIdSelection"
-        val selectionArgs = arrayOf(creatorIdentitySelectionArg, groupIdSelectionArg)
-
-        return getGroup {
-            it.selection(selection, selectionArgs)
-        }
-    }
-
-    private fun getGroup(addSelection: (SupportSQLiteQueryBuilder) -> Unit): DbGroup? {
-        sqlite.readableDatabase.query(
-            SupportSQLiteQueryBuilder.builder(GroupModel.TABLE)
-                .columns(
-                    arrayOf(
-                        GroupModel.COLUMN_ID,
-                        GroupModel.COLUMN_API_GROUP_ID,
-                        GroupModel.COLUMN_NAME,
-                        GroupModel.COLUMN_CREATOR_IDENTITY,
-                        GroupModel.COLUMN_CREATED_AT,
-                        GroupModel.COLUMN_SYNCHRONIZED_AT,
-                        GroupModel.COLUMN_LAST_UPDATE,
-                        GroupModel.COLUMN_DELETED,
-                        GroupModel.COLUMN_IS_ARCHIVED,
-                        GroupModel.COLUMN_COLOR_INDEX,
-                        GroupModel.COLUMN_GROUP_DESC,
-                        GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP,
-                    )
-                )
-                .apply(addSelection)
-                .create()
-        ).use { cursor ->
-            if (!cursor.moveToFirst()) {
-                return null
-            }
-
-            val localDbId = cursor.getLong(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_ID))
-            val creatorIdentity = cursor.getString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_CREATOR_IDENTITY))
-            val groupId = cursor.getString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_API_GROUP_ID))
-            val name = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_NAME))
-            val createdAt = cursor.getDateByString(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_CREATED_AT))
-            val synchronizedAt = cursor.getDateOrNull(
-                getColumnIndexOrThrow(
-                    cursor,
-                    GroupModel.COLUMN_SYNCHRONIZED_AT
-                )
-            )
-            val lastUpdate = cursor.getDateOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_LAST_UPDATE))
-            val deleted = cursor.getBoolean(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_DELETED))
-            val isArchived = cursor.getBoolean(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_IS_ARCHIVED))
-            val colorIndex = cursor.getUByte(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_COLOR_INDEX))
-            val groupDesc = cursor.getStringOrNull(getColumnIndexOrThrow(cursor, GroupModel.COLUMN_GROUP_DESC))
-            val groupDescChangedAt = cursor.getDateByStringOrNull(
-                getColumnIndexOrThrow(
-                    cursor,
-                    GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP
-                )
-            )
-            val members = getGroupMembers(localDbId)
-
-            return DbGroup(
-                creatorIdentity = creatorIdentity,
-                groupId = groupId,
-                name = name,
-                createdAt = createdAt,
-                synchronizedAt = synchronizedAt,
-                lastUpdate = lastUpdate,
-                deleted = deleted,
-                isArchived = isArchived,
-                colorIndex = colorIndex,
-                groupDescription = groupDesc,
-                groupDescriptionChangedAt = groupDescChangedAt,
-                members = members,
-            )
-        }
-    }
-
-    override fun updateGroup(group: DbGroup) {
-        val localGroupDbId = getLocalGroupDbId(group)
-
-        // First update general group information
-        val contentValues = ContentValues().apply { update(group) }
-
-        sqlite.writableDatabase.update(
-            table = GroupModel.TABLE,
-            conflictAlgorithm = SQLiteDatabase.CONFLICT_ROLLBACK,
-            values = contentValues,
-            whereClause = "${GroupModel.COLUMN_ID} = ?",
-            whereArgs = arrayOf(localGroupDbId)
-        )
-
-        // Then update group members
-        updateGroupMembers(localGroupDbId, group.members)
-    }
-
-    private fun ContentValues.update(group: DbGroup) {
-        // Note: creator identity, group id, and created at cannot be updated
-        put(GroupModel.COLUMN_NAME, group.name)
-        put(GroupModel.COLUMN_LAST_UPDATE, group.lastUpdate?.time)
-        put(GroupModel.COLUMN_SYNCHRONIZED_AT, group.synchronizedAt?.time)
-        put(GroupModel.COLUMN_DELETED, group.deleted)
-        put(GroupModel.COLUMN_IS_ARCHIVED, group.isArchived)
-        put(GroupModel.COLUMN_COLOR_INDEX, group.colorIndex.toInt())
-        put(GroupModel.COLUMN_GROUP_DESC, group.groupDescription)
-        put(
-            GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP,
-            group.groupDescriptionChangedAt?.toDateStringOrNull()
-        )
-    }
-
-    private fun getLocalGroupDbId(group: DbGroup): Long {
-        val creatorIdentitySelection = "${GroupModel.COLUMN_CREATOR_IDENTITY} = ?"
-        val groupIdSelection = "${GroupModel.COLUMN_API_GROUP_ID} = ?"
-        val creatorIdentitySelectionArg = group.creatorIdentity
-        val groupIdSelectionArg = group.groupId
-        val selection = "$creatorIdentitySelection AND $groupIdSelection"
-        val selectionArgs = arrayOf(creatorIdentitySelectionArg, groupIdSelectionArg)
-
-        sqlite.readableDatabase.query(
-            SupportSQLiteQueryBuilder.builder(GroupModel.TABLE)
-                .columns(arrayOf(GroupModel.COLUMN_ID))
-                .selection(selection, selectionArgs)
-                .create()
-        ).use { cursor ->
-            if (!cursor.moveToFirst()) {
-                throw DatabaseException("Could not find a group with creator ${group.creatorIdentity} and id ${group.groupId}")
-            }
-
-            return cursor.getLong(cursor.getColumnIndexOrThrow(GroupModel.COLUMN_ID))
-        }
-    }
-
-    private fun getGroupMembers(localDbId: Long): Set<String> {
-        sqlite.readableDatabase.query(
-            SupportSQLiteQueryBuilder.builder(GroupMemberModel.TABLE)
-                .columns(arrayOf(GroupMemberModel.COLUMN_IDENTITY))
-                .selection("${GroupMemberModel.COLUMN_GROUP_ID} = ?", arrayOf(localDbId))
-                .create()
-        ).use { cursor ->
-            val members = mutableSetOf<String>()
-
-            while (cursor.moveToNext()) {
-                members.add(
-                    cursor.getString(
-                        getColumnIndexOrThrow(
-                            cursor,
-                            GroupMemberModel.COLUMN_IDENTITY
-                        )
-                    )
-                )
-            }
-
-            return Collections.unmodifiableSet(members)
-        }
-    }
-
-    private fun updateGroupMembers(localDbId: Long, members: Set<String>) {
-        // First remove all members that are not part of the group anymore
-        val whereGroupId = "${GroupMemberModel.COLUMN_GROUP_ID} = ?"
-        val whereNotMember = "${GroupMemberModel.COLUMN_IDENTITY} NOT IN ( ${
-            members.joinToString(separator = " , ") { "?" }
-        } )"
-
-        sqlite.writableDatabase.delete(
-            GroupMemberModel.TABLE,
-            "$whereGroupId AND $whereNotMember",
-            (listOf(localDbId) + members).toTypedArray(),
-        )
-
-        // Add all members (if not already exists)
-        val contentValuesList = members.map { memberIdentity ->
-            ContentValues().apply {
-                put(GroupMemberModel.COLUMN_IDENTITY, memberIdentity)
-                put(GroupMemberModel.COLUMN_GROUP_ID, localDbId)
-            }
-        }
-
-        contentValuesList.forEach { contentValues ->
-            sqlite.writableDatabase.insert(
-                GroupMemberModel.TABLE,
-                SQLiteDatabase.CONFLICT_FAIL,
-                contentValues,
-            )
-        }
-    }
-}
diff --git a/app/src/main/java/ch/threema/storage/DatabaseNonceStore.java b/app/src/main/java/ch/threema/storage/DatabaseNonceStore.java
deleted file mode 100644
index b5649c35..00000000
--- a/app/src/main/java/ch/threema/storage/DatabaseNonceStore.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage;
-
-import android.annotation.SuppressLint;
-import android.content.ContentValues;
-import android.content.Context;
-import android.database.Cursor;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteException;
-
-import androidx.annotation.NonNull;
-
-import net.zetetic.database.sqlcipher.SQLiteConnection;
-import net.zetetic.database.sqlcipher.SQLiteDatabase;
-import net.zetetic.database.sqlcipher.SQLiteDatabaseHook;
-import net.zetetic.database.sqlcipher.SQLiteOpenHelper;
-
-import org.slf4j.Logger;
-
-import java.security.InvalidKeyException;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.crypto.Mac;
-import javax.crypto.spec.SecretKeySpec;
-
-import ch.threema.base.crypto.NonceStore;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.base.utils.Utils;
-import ch.threema.domain.stores.IdentityStoreInterface;
-
-public class DatabaseNonceStore extends SQLiteOpenHelper
-	implements NonceStore {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("NonceDatabaseBlobService");
-
-	public static final String DATABASE_NAME_V4 = "threema-nonce-blob4.db";
-	private static final int DATABASE_VERSION = 1;
-	private final IdentityStoreInterface identityStore;
-
-	public DatabaseNonceStore(final Context context, IdentityStoreInterface identityStore) {
-		super(
-			context,
-			DATABASE_NAME_V4,
-			"",
-			null,
-			DATABASE_VERSION,
-			0,
-			null,
-			new SQLiteDatabaseHook() {
-				@Override
-				public void preKey(SQLiteConnection connection) {
-					// not used
-				}
-
-				@SuppressLint("DefaultLocale")
-				@Override
-				public void postKey(SQLiteConnection connection) {
-					// turn off memory wiping for now due to https://github.com/sqlcipher/android-database-sqlcipher/issues/411
-					connection.execute("PRAGMA cipher_memory_security = OFF;", new Object[]{}, null);
-				}
-			}
-			,
-			false);
-		this.identityStore = identityStore;
-	}
-
-	@Override
-	public void onCreate(SQLiteDatabase sqLiteDatabase) {
-		sqLiteDatabase.execSQL("CREATE TABLE `threema_nonce` (`nonce` BLOB PRIMARY KEY)");
-	}
-
-	@Override
-	public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {
-		// no special upgrade handling
-	}
-
-	public void executeNull() throws SQLiteException {
-		try {
-			getWritableDatabase().rawQuery("SELECT NULL").close();
-		} catch (Exception e) {
-			logger.error("Unable to execute initial query", e);
-		}
-	}
-
-	@Override
-	public boolean exists(@NonNull byte[] nonce) {
-		boolean hasRecord = false;
-		Cursor c = this.getReadableDatabase()
-				.rawQuery("SELECT COUNT(*) FROM `threema_nonce` WHERE `nonce` = x'"
-								+ Utils.byteArrayToHexString(nonce)
-								+ "' OR `nonce` = x'"
-								+ Utils.byteArrayToHexString(this.hashNonce(nonce))
-								+ "'", null);
-		if (c != null) {
-			if (c.moveToFirst()) {
-				hasRecord = c.getInt(0) > 0;
-			}
-			c.close();
-		}
-		return hasRecord;
-	}
-
-	@Override
-	public boolean store(@NonNull byte[] nonce) {
-		ContentValues c = new ContentValues();
-		c.put("nonce", this.hashNonce(nonce));
-
-		try {
-			return this.getWritableDatabase()
-					.insertOrThrow("threema_nonce", null, c) >= 1;
-		} catch (SQLException x) {
-			//ignore exception
-			logger.error("Exception", x);
-		}
-
-		return false;
-	}
-
-	public long getCount() {
-		long size = 0;
-		Cursor c = this.getReadableDatabase().rawQuery("SELECT COUNT(*) FROM `threema_nonce`", null);
-		if (c != null) {
-			if (c.moveToFirst()) {
-				size = c.getLong(0);
-			}
-			c.close();
-		}
-		return size;
-	}
-
-	@NonNull
-	@Override
-	public List<byte[]> getAllHashedNonces() {
-		int nonceCount = (int) getCount();
-		List<byte[]> nonces = new ArrayList<>(nonceCount);
-		addHashedNonceChunk(nonceCount, 0, nonces);
-		return nonces;
-	}
-
-	/**
-	 * Get the hashed nonces of the provided chunk in their byte array representation.
-	 *
-	 * @param chunkSize the number of nonces that is returned
-	 * @param offset    the offset where reading the nonces starts
-	 * @return a list of the hashed nonces in their byte array representation.
-	 */
-	public void addHashedNonceChunk(int chunkSize, int offset, List<byte[]> nonces) {
-		Cursor c = this.getReadableDatabase().rawQuery(
-			"SELECT `nonce` FROM `threema_nonce` LIMIT ? OFFSET ?",
-			new String[]{String.valueOf(chunkSize), String.valueOf(offset)}
-	);
-		if (c != null) {
-			if (c.moveToFirst()) {
-				int columnIndex = c.getColumnIndex("nonce");
-				do {
-					nonces.add(c.getBlob(columnIndex));
-				} while (c.moveToNext());
-			}
-			c.close();
-		}
-	}
-
-	/**
-	 * Insert hashed nonces to the database.
-	 *
-	 * @param hashedNonces the hashed nonces
-	 * @return true if all nonces have been inserted successfully, false otherwise
-	 */
-	public boolean insertHashedNonces(@NonNull String[] hashedNonces) {
-		boolean success = true;
-		SQLiteDatabase database = getWritableDatabase();
-		for (String hashedNonce : hashedNonces) {
-			ContentValues values = new ContentValues();
-			values.put("nonce", Utils.hexStringToByteArray(hashedNonce));
-			try {
-				long row = database.insertOrThrow("threema_nonce", null, values);
-				if (row < 0) {
-					logger.warn("Could not insert a nonce into the nonce database");
-					success = false;
-				}
-			} catch (SQLException e) {
-				logger.error("Could not insert a nonce into the nonce database", e);
-				success = false;
-			}
-		}
-
-		return success;
-	}
-
-	private byte[] hashNonce(byte[] nonce) {
-		// Hash nonce with HMAC-SHA256 using the identity as the key if available.
-		// This serves to make it impossible to correlate the nonce DBs of users to determine whether they have been communicating. */
-		String identity = identityStore.getIdentity();
-		if (identity == null) {
-			return nonce;
-		}
-
-		try {
-			Mac mobileNoMac = Mac.getInstance("HmacSHA256");
-			mobileNoMac.init(new SecretKeySpec(identity.getBytes(), "HmacSHA256"));
-			return mobileNoMac.doFinal(nonce);
-		} catch (NoSuchAlgorithmException | InvalidKeyException e) {
-			throw new RuntimeException(e);
-		}
-	}
-}
diff --git a/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java b/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java
index df257c4e..2f557e0c 100644
--- a/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java
+++ b/app/src/main/java/ch/threema/storage/DatabaseServiceNew.java
@@ -25,8 +25,6 @@ import android.content.Context;
 import android.database.sqlite.SQLiteException;
 import android.widget.Toast;
 
-import androidx.annotation.NonNull;
-
 import net.zetetic.database.sqlcipher.SQLiteConnection;
 import net.zetetic.database.sqlcipher.SQLiteDatabase;
 import net.zetetic.database.sqlcipher.SQLiteDatabaseHook;
@@ -34,10 +32,15 @@ import net.zetetic.database.sqlcipher.SQLiteOpenHelper;
 
 import org.slf4j.Logger;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.app.services.UpdateSystemService;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion10;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion99;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion100;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion101;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion102;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion103;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion104;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion11;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion12;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion13;
@@ -124,10 +127,7 @@ import ch.threema.app.services.systemupdate.SystemUpdateToVersion95;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion96;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion97;
 import ch.threema.app.services.systemupdate.SystemUpdateToVersion98;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion100;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion101;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion102;
-import ch.threema.app.services.systemupdate.SystemUpdateToVersion103;
+import ch.threema.app.services.systemupdate.SystemUpdateToVersion99;
 import ch.threema.app.utils.RuntimeUtil;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
@@ -148,13 +148,13 @@ import ch.threema.storage.factories.GroupInviteModelFactory;
 import ch.threema.storage.factories.GroupMemberModelFactory;
 import ch.threema.storage.factories.GroupMessageModelFactory;
 import ch.threema.storage.factories.GroupModelFactory;
-import ch.threema.storage.factories.IncomingGroupSyncRequestLogModelFactory;
-import ch.threema.storage.factories.OutgoingGroupSyncRequestLogModelFactory;
 import ch.threema.storage.factories.IdentityBallotModelFactory;
 import ch.threema.storage.factories.IncomingGroupJoinRequestModelFactory;
+import ch.threema.storage.factories.IncomingGroupSyncRequestLogModelFactory;
 import ch.threema.storage.factories.MessageModelFactory;
 import ch.threema.storage.factories.ModelFactory;
 import ch.threema.storage.factories.OutgoingGroupJoinRequestModelFactory;
+import ch.threema.storage.factories.OutgoingGroupSyncRequestLogModelFactory;
 import ch.threema.storage.factories.RejectedGroupMessageFactory;
 import ch.threema.storage.factories.ServerMessageModelFactory;
 import ch.threema.storage.factories.TaskArchiveFactory;
@@ -165,7 +165,7 @@ public class DatabaseServiceNew extends SQLiteOpenHelper {
 
     public static final String DEFAULT_DATABASE_NAME_V4 = "threema4.db";
     public static final String DATABASE_BACKUP_EXT = ".backup";
-    private static final int DATABASE_VERSION = SystemUpdateToVersion103.VERSION;
+    private static final int DATABASE_VERSION = SystemUpdateToVersion104.VERSION;
 
     private final Context context;
     private final UpdateSystemService updateSystemService;
@@ -818,6 +818,9 @@ public class DatabaseServiceNew extends SQLiteOpenHelper {
         if (oldVersion < SystemUpdateToVersion103.VERSION) {
             this.updateSystemService.addUpdate(new SystemUpdateToVersion103(sqLiteDatabase));
         }
+        if (oldVersion < SystemUpdateToVersion104.VERSION) {
+            this.updateSystemService.addUpdate(new SystemUpdateToVersion104(sqLiteDatabase, context));
+        }
     }
 
     public void executeNull() throws SQLiteException {
diff --git a/app/src/main/java/ch/threema/storage/DatabaseUtil.java b/app/src/main/java/ch/threema/storage/DatabaseUtil.java
index ad74d931..c745abd5 100644
--- a/app/src/main/java/ch/threema/storage/DatabaseUtil.java
+++ b/app/src/main/java/ch/threema/storage/DatabaseUtil.java
@@ -27,6 +27,10 @@ import android.database.Cursor;
 import java.util.Date;
 import java.util.List;
 
+import androidx.annotation.NonNull;
+import ch.threema.storage.models.GroupMemberModel;
+import ch.threema.storage.models.GroupModel;
+
 public class DatabaseUtil {
 
 	private DatabaseUtil() { }
@@ -89,4 +93,16 @@ public class DatabaseUtil {
 		}
 		return arguments;
 	}
+
+	/**
+	 * An SQL query that can be used to check whether an identity is part of a group. There is one
+	 * placeholder (?) that should be used for the identity that should be checked. Note that only
+	 * groups are considered where 'deleted' is 0.
+	 */
+	@NonNull
+	public final static String IS_GROUP_MEMBER_QUERY = "SELECT EXISTS(" +
+		"SELECT 1 FROM " + GroupModel.TABLE + " g INNER JOIN " + GroupMemberModel.TABLE + " m" +
+		"  ON m." + GroupMemberModel.COLUMN_GROUP_ID + " = g." + GroupModel.COLUMN_ID + " " +
+		"WHERE m." + GroupMemberModel.COLUMN_IDENTITY + " = ? AND " + GroupModel.COLUMN_DELETED + " = 0" +
+		")";
 }
diff --git a/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java b/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java
index 9f891c38..1fe2cfbe 100644
--- a/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java
+++ b/app/src/main/java/ch/threema/storage/factories/ContactModelFactory.java
@@ -25,16 +25,19 @@ import android.content.ContentValues;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteException;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import org.slf4j.Logger;
 
 import java.util.ArrayList;
+import java.util.Date;
 import java.util.List;
 
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.base.utils.Utils;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.storage.CursorHelper;
@@ -127,7 +130,7 @@ public class ContactModelFactory extends ModelFactory {
                     cursorFactory1.getString(ContactModel.COLUMN_FIRST_NAME),
                     cursorFactory1.getString(ContactModel.COLUMN_LAST_NAME))
                 .setPublicNickName(cursorFactory1.getString(ContactModel.COLUMN_PUBLIC_NICK_NAME))
-                .setState(ContactModel.State.valueOf(cursorFactory1.getString(ContactModel.COLUMN_STATE)))
+                .setState(IdentityState.valueOf(cursorFactory1.getString(ContactModel.COLUMN_STATE)))
                 .setAndroidContactLookupKey(cursorFactory1.getString(ContactModel.COLUMN_ANDROID_CONTACT_LOOKUP_KEY))
                 .setIsWork(cursorFactory1.getInt(ContactModel.COLUMN_IS_WORK) == 1)
                 .setIdentityType(
@@ -157,15 +160,15 @@ public class ContactModelFactory extends ModelFactory {
             // Convert state to enum
             switch (cursorFactory1.getString(ContactModel.COLUMN_STATE)) {
                 case "INACTIVE":
-                    c.setState(ContactModel.State.INACTIVE);
+                    c.setState(IdentityState.INACTIVE);
                     break;
                 case "INVALID":
-                    c.setState(ContactModel.State.INVALID);
+                    c.setState(IdentityState.INVALID);
                     break;
                 case "ACTIVE":
                 case "TEMPORARY": // Legacy state, see !276
                 default:
-                    c.setState(ContactModel.State.ACTIVE);
+                    c.setState(IdentityState.ACTIVE);
                     break;
             }
 
@@ -220,7 +223,7 @@ public class ContactModelFactory extends ModelFactory {
         contentValues.put(ContactModel.COLUMN_VERIFICATION_LEVEL, contactModel.verificationLevel.ordinal());
 
         if (contactModel.getState() == null) {
-            contactModel.setState(ContactModel.State.ACTIVE);
+            contactModel.setState(IdentityState.ACTIVE);
         }
         contentValues.put(ContactModel.COLUMN_STATE, contactModel.getState().toString());
         contentValues.put(ContactModel.COLUMN_ANDROID_CONTACT_LOOKUP_KEY, contactModel.getAndroidContactLookupKey());
@@ -265,6 +268,22 @@ public class ContactModelFactory extends ModelFactory {
         return true;
     }
 
+    /**
+     * Updates the last update flag of the given identity.
+     */
+    public void setLastUpdate(@NonNull String identity, @Nullable Date lastUpdate) {
+        Long lastUpdateTime = lastUpdate != null ? lastUpdate.getTime() : null;
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(ContactModel.COLUMN_LAST_UPDATE, lastUpdateTime);
+
+        getWritableDatabase().update(
+            ContactModel.TABLE,
+            contentValues,
+            ContactModel.COLUMN_IDENTITY + " = ?",
+            new String[]{identity}
+        );
+    }
+
     public int delete(ContactModel contactModel) {
         return this.databaseService.getWritableDatabase().delete(this.getTableName(),
             ContactModel.COLUMN_IDENTITY + "=?",
diff --git a/app/src/main/java/ch/threema/storage/factories/EditHistoryEntryModelFactory.kt b/app/src/main/java/ch/threema/storage/factories/EditHistoryEntryModelFactory.kt
deleted file mode 100644
index 2415411e..00000000
--- a/app/src/main/java/ch/threema/storage/factories/EditHistoryEntryModelFactory.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage.factories
-
-import ch.threema.data.storage.DbEditHistoryEntry.Companion.COLUMN_EDITED_AT
-import ch.threema.data.storage.DbEditHistoryEntry.Companion.COLUMN_MESSAGE_ID
-import ch.threema.data.storage.DbEditHistoryEntry.Companion.COLUMN_MESSAGE_UID
-import ch.threema.data.storage.DbEditHistoryEntry.Companion.COLUMN_TEXT
-import ch.threema.data.storage.DbEditHistoryEntry.Companion.COLUMN_UID
-import ch.threema.storage.DatabaseServiceNew
-import ch.threema.storage.models.GroupMessageModel
-import ch.threema.storage.models.MessageModel
-
-abstract class EditHistoryEntryModelFactory(dbService: DatabaseServiceNew, tableName: String) : ModelFactory(dbService, tableName) {
-
-    // This statement represents the first version if this table
-    // It has been changed. See SystemUpdateToVersion102
-    override fun getStatements(): Array<String> = arrayOf(
-        "CREATE TABLE IF NOT EXISTS `$tableName` (" +
-            "`$COLUMN_UID` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
-            "`$COLUMN_MESSAGE_UID` VARCHAR NOT NULL, " +
-            "`$COLUMN_MESSAGE_ID` INTEGER NOT NULL, " +
-            "`$COLUMN_TEXT` VARCHAR DEFAULT NULL, " +
-            "`$COLUMN_EDITED_AT` DATETIME NOT NULL, " +
-            getConstraints() +
-            ")"
-    )
-
-    protected abstract fun getConstraints(): String
-}
-
-class ContactEditHistoryEntryModelFactory(dbService: DatabaseServiceNew) : EditHistoryEntryModelFactory(dbService, TABLE) {
-
-    companion object {
-        const val TABLE = "contact_edit_history_entries"
-    }
-
-    // This statement represents the first version if this constraint
-    // It has been changed. See SystemUpdateToVersion102
-    override fun getConstraints(): String {
-        return "CONSTRAINT fk_contact_message_id_new FOREIGN KEY($COLUMN_MESSAGE_ID) " +
-            "REFERENCES ${MessageModel.TABLE} (${MessageModel.COLUMN_ID}) ON UPDATE CASCADE ON DELETE CASCADE "
-    }
-}
-
-class GroupEditHistoryEntryModelFactory(dbService: DatabaseServiceNew) : EditHistoryEntryModelFactory(dbService, TABLE) {
-
-    companion object {
-        const val TABLE = "group_edit_history_entries"
-    }
-
-    // This statement represents the first version if this constraint
-    // It has been changed. See SystemUpdateToVersion102
-    override fun getConstraints(): String {
-        return "CONSTRAINT fk_group_message_id_new FOREIGN KEY($COLUMN_MESSAGE_ID) " +
-            "REFERENCES ${GroupMessageModel.TABLE} (${GroupMessageModel.COLUMN_ID}) ON UPDATE CASCADE ON DELETE CASCADE "
-    }
-}
diff --git a/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java b/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java
index c3018c99..4c684c7b 100644
--- a/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java
+++ b/app/src/main/java/ch/threema/storage/factories/GroupMemberModelFactory.java
@@ -64,7 +64,11 @@ public class GroupMemberModelFactory extends ModelFactory {
 				null));
 	}
 
-	public long countMembers(int groupId) {
+	/**
+	 * This does not include the user itself. If the user is part of the group, the total number of
+	 * members is the value returned by this method + 1.
+	 */
+	public long countMembersWithoutUser(int groupId) {
 		return DatabaseUtil.count(this.databaseService.getReadableDatabase().rawQuery(
 			"SELECT COUNT(*) FROM " + this.getTableName()
 				+ " WHERE " + GroupMemberModel.COLUMN_GROUP_ID + "=?",
diff --git a/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java b/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java
index 938222d4..08ba2807 100644
--- a/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java
+++ b/app/src/main/java/ch/threema/storage/factories/GroupModelFactory.java
@@ -104,18 +104,19 @@ public class GroupModelFactory extends ModelFactory {
 				@Override
 				public boolean next(CursorHelper cursorHelper) {
 					c
-							.setId(cursorHelper.getInt(GroupModel.COLUMN_ID))
-							.setApiGroupId(new GroupId(cursorHelper.getString(GroupModel.COLUMN_API_GROUP_ID)))
-							.setName(cursorHelper.getString(GroupModel.COLUMN_NAME))
-							.setCreatorIdentity(cursorHelper.getString(GroupModel.COLUMN_CREATOR_IDENTITY))
-							.setSynchronizedAt(cursorHelper.getDate(GroupModel.COLUMN_SYNCHRONIZED_AT))
-							.setCreatedAt(cursorHelper.getDateByString(GroupModel.COLUMN_CREATED_AT))
-							.setLastUpdate(cursorHelper.getDate(GroupModel.COLUMN_LAST_UPDATE))
-							.setDeleted(cursorHelper.getBoolean(GroupModel.COLUMN_DELETED))
-							.setArchived(cursorHelper.getBoolean(GroupModel.COLUMN_IS_ARCHIVED))
-							.setGroupDesc(cursorHelper.getString(GroupModel.COLUMN_GROUP_DESC))
-							.setGroupDescTimestamp(cursorHelper.getDateByString(GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP))
-							.setColorIndex(cursorHelper.getInt(GroupModel.COLUMN_COLOR_INDEX))
+						.setId(cursorHelper.getInt(GroupModel.COLUMN_ID))
+						.setApiGroupId(new GroupId(cursorHelper.getString(GroupModel.COLUMN_API_GROUP_ID)))
+						.setName(cursorHelper.getString(GroupModel.COLUMN_NAME))
+						.setCreatorIdentity(cursorHelper.getString(GroupModel.COLUMN_CREATOR_IDENTITY))
+						.setSynchronizedAt(cursorHelper.getDate(GroupModel.COLUMN_SYNCHRONIZED_AT))
+						.setCreatedAt(cursorHelper.getDateByString(GroupModel.COLUMN_CREATED_AT))
+						.setLastUpdate(cursorHelper.getDate(GroupModel.COLUMN_LAST_UPDATE))
+						.setDeleted(cursorHelper.getBoolean(GroupModel.COLUMN_DELETED))
+						.setArchived(cursorHelper.getBoolean(GroupModel.COLUMN_IS_ARCHIVED))
+						.setGroupDesc(cursorHelper.getString(GroupModel.COLUMN_GROUP_DESC))
+						.setGroupDescTimestamp(cursorHelper.getDateByString(GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP))
+						.setColorIndex(cursorHelper.getInt(GroupModel.COLUMN_COLOR_INDEX))
+						.setUserState(GroupModel.UserState.valueOf(cursorHelper.getInt(GroupModel.COLUMN_USER_STATE)))
 					;
 
 					return false;
@@ -173,6 +174,8 @@ public class GroupModelFactory extends ModelFactory {
 		contentValues.put(GroupModel.COLUMN_GROUP_DESC, groupModel.getGroupDesc());
 		contentValues.put(GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP, groupModel.getGroupDescTimestamp() !=null ? CursorHelper.dateAsStringFormat.get().format(groupModel.getGroupDescTimestamp()) : null);
 		contentValues.put(GroupModel.COLUMN_COLOR_INDEX, groupModel.getColorIndex());
+		// In case the user state is not set, we fall back to 'member'.
+		contentValues.put(GroupModel.COLUMN_USER_STATE, groupModel.getUserState() != null ? groupModel.getUserState().value : GroupModel.UserState.MEMBER.value);
 
 		return contentValues;
 	}
@@ -305,7 +308,8 @@ public class GroupModelFactory extends ModelFactory {
 				"`" + GroupModel.COLUMN_IS_ARCHIVED + "` TINYINT DEFAULT 0, " +
 				"`" + GroupModel.COLUMN_GROUP_DESC + "` VARCHAR DEFAULT NULL, " +
 				"`" + GroupModel.COLUMN_GROUP_DESC_CHANGED_TIMESTAMP + "` VARCHAR DEFAULT NULL, " +
-				"`" + GroupModel.COLUMN_COLOR_INDEX + "` INTEGER DEFAULT 0 NOT NULL" +
+				"`" + GroupModel.COLUMN_COLOR_INDEX + "` INTEGER DEFAULT 0 NOT NULL, " +
+				"`" + GroupModel.COLUMN_USER_STATE + "` INTEGER DEFAULT 0 NOT NULL " +
 				");",
 			"CREATE UNIQUE INDEX `apiGroupIdAndCreator` ON `" + GroupModel.TABLE + "` ( " +
 				"`" + GroupModel.COLUMN_API_GROUP_ID + "`, `" + GroupModel.COLUMN_CREATOR_IDENTITY + "` " +
diff --git a/app/src/main/java/ch/threema/storage/factories/IncomingGroupSyncRequestLogModelFactory.kt b/app/src/main/java/ch/threema/storage/factories/IncomingGroupSyncRequestLogModelFactory.kt
deleted file mode 100644
index b42c0d0d..00000000
--- a/app/src/main/java/ch/threema/storage/factories/IncomingGroupSyncRequestLogModelFactory.kt
+++ /dev/null
@@ -1,105 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage.factories
-
-import android.content.ContentValues
-import android.database.Cursor
-import android.database.SQLException
-import androidx.sqlite.db.SupportSQLiteQueryBuilder
-import ch.threema.storage.DatabaseServiceNew
-import ch.threema.storage.models.GroupModel
-import ch.threema.storage.models.IncomingGroupSyncRequestLogModel
-import net.zetetic.database.sqlcipher.SQLiteDatabase
-
-class IncomingGroupSyncRequestLogModelFactory(databaseService: DatabaseServiceNew) :
-    ModelFactory(databaseService, IncomingGroupSyncRequestLogModel.TABLE) {
-
-    /**
-     * Insert the provided model into the database.
-     *
-     * @throws [SQLException] if the provided local db group id is not valid
-     */
-    @Synchronized
-    fun createOrUpdate(groupSyncRequestLog: IncomingGroupSyncRequestLogModel) {
-        writableDatabase.insert(
-            tableName,
-            SQLiteDatabase.CONFLICT_REPLACE,
-            groupSyncRequestLog.toContentValues()
-        )
-    }
-
-    /**
-     * Get an [IncomingGroupSyncRequestLogModel] by [localDbGroupId] and [senderIdentity]. If there
-     * is no such entry in the database, a new model is returned where
-     * [IncomingGroupSyncRequestLogModel.lastHandledRequest] is set to 0.
-     */
-    @Synchronized
-    fun getByGroupIdAndSenderIdentity(localDbGroupId: Int, senderIdentity: String): IncomingGroupSyncRequestLogModel {
-        val groupIdSelection = "${IncomingGroupSyncRequestLogModel.COLUMN_GROUP_ID} = ?"
-        val senderIdentitySelection = "${IncomingGroupSyncRequestLogModel.COLUMN_SENDER_IDENTITY} = ?"
-        val selection = "$groupIdSelection AND $senderIdentitySelection"
-        val selectionArgs = arrayOf(localDbGroupId.toString(), senderIdentity)
-        readableDatabase.query(
-            SupportSQLiteQueryBuilder.builder(tableName)
-                .selection(selection, selectionArgs)
-                .create()
-        ).use {
-            return if (it.moveToFirst()) {
-                it.toGroupSyncRequestLogModel()
-            } else {
-                IncomingGroupSyncRequestLogModel(localDbGroupId, senderIdentity, 0)
-            }
-        }
-    }
-
-    override fun getStatements(): Array<String> {
-        return arrayOf(
-            """
-                CREATE TABLE `${IncomingGroupSyncRequestLogModel.TABLE}`(
-                    `${IncomingGroupSyncRequestLogModel.COLUMN_GROUP_ID}` INTEGER,
-                    `${IncomingGroupSyncRequestLogModel.COLUMN_SENDER_IDENTITY}` VARCHAR,
-                    `${IncomingGroupSyncRequestLogModel.COLUMN_LAST_HANDLED_REQUEST}` DATETIME,
-                    PRIMARY KEY (`${IncomingGroupSyncRequestLogModel.COLUMN_GROUP_ID}`, `${IncomingGroupSyncRequestLogModel.COLUMN_SENDER_IDENTITY}`),
-                    FOREIGN KEY(`${IncomingGroupSyncRequestLogModel.COLUMN_GROUP_ID}`) REFERENCES `${GroupModel.TABLE}`(`${GroupModel.COLUMN_ID}`) ON UPDATE CASCADE ON DELETE CASCADE
-                )
-            """
-        )
-    }
-
-    private fun Cursor.toGroupSyncRequestLogModel(): IncomingGroupSyncRequestLogModel {
-        val groupIdColumnIndex = getColumnIndexOrThrow(IncomingGroupSyncRequestLogModel.COLUMN_GROUP_ID)
-        val senderIdentityColumnIndex = getColumnIndexOrThrow(IncomingGroupSyncRequestLogModel.COLUMN_SENDER_IDENTITY)
-        val lastHandledRequestColumnIndex = getColumnIndexOrThrow(IncomingGroupSyncRequestLogModel.COLUMN_LAST_HANDLED_REQUEST)
-
-        return IncomingGroupSyncRequestLogModel(
-            getInt(groupIdColumnIndex),
-            getString(senderIdentityColumnIndex),
-            getLong(lastHandledRequestColumnIndex)
-        )
-    }
-
-    private fun IncomingGroupSyncRequestLogModel.toContentValues() = ContentValues().also {
-        it.put(IncomingGroupSyncRequestLogModel.COLUMN_GROUP_ID, groupId)
-        it.put(IncomingGroupSyncRequestLogModel.COLUMN_SENDER_IDENTITY, senderIdentity)
-        it.put(IncomingGroupSyncRequestLogModel.COLUMN_LAST_HANDLED_REQUEST, lastHandledRequest)
-    }
-}
diff --git a/app/src/main/java/ch/threema/storage/factories/OutgoingGroupSyncRequestLogModelFactory.java b/app/src/main/java/ch/threema/storage/factories/OutgoingGroupSyncRequestLogModelFactory.java
deleted file mode 100644
index 5a26ec27..00000000
--- a/app/src/main/java/ch/threema/storage/factories/OutgoingGroupSyncRequestLogModelFactory.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2015-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage.factories;
-
-import android.content.ContentValues;
-
-import android.database.Cursor;
-
-import ch.threema.storage.CursorHelper;
-import ch.threema.storage.DatabaseServiceNew;
-import ch.threema.storage.models.OutgoingGroupSyncRequestLogModel;
-
-public class OutgoingGroupSyncRequestLogModelFactory extends ModelFactory {
-	public OutgoingGroupSyncRequestLogModelFactory(DatabaseServiceNew databaseService) {
-		super(databaseService, OutgoingGroupSyncRequestLogModel.TABLE);
-	}
-
-	public OutgoingGroupSyncRequestLogModel get(String apiGroupId, String groupCreator) {
-		return getFirst(
-				OutgoingGroupSyncRequestLogModel.COLUMN_API_GROUP_ID + "=?"
-				+ " AND " + OutgoingGroupSyncRequestLogModel.COLUMN_CREATOR_IDENTITY + "=?",
-				new String[]{
-						apiGroupId,
-						groupCreator
-				});
-	}
-	public boolean createOrUpdate(OutgoingGroupSyncRequestLogModel outgoingGroupSyncRequestLogModel) {
-		boolean insert = true;
-		if(outgoingGroupSyncRequestLogModel.getId() > 0) {
-			Cursor cursor = this.databaseService.getReadableDatabase().query(
-					this.getTableName(),
-					null,
-					OutgoingGroupSyncRequestLogModel.COLUMN_ID + "=?",
-					new String[]{
-							String.valueOf(outgoingGroupSyncRequestLogModel.getId())
-					},
-					null,
-					null,
-					null
-			);
-
-			if (cursor != null) {
-				try {
-					insert = !cursor.moveToNext();
-				} finally {
-					cursor.close();
-				}
-			}
-		}
-
-		if(insert) {
-			return create(outgoingGroupSyncRequestLogModel);
-		}
-		else {
-			return update(outgoingGroupSyncRequestLogModel);
-		}
-	}
-
-	public boolean create(OutgoingGroupSyncRequestLogModel outgoingGroupSyncRequestLogModel) {
-		ContentValues contentValues = buildValues(outgoingGroupSyncRequestLogModel);
-		long newId = this.databaseService.getWritableDatabase().insertOrThrow(this.getTableName(), null, contentValues);
-		if (newId > 0) {
-			outgoingGroupSyncRequestLogModel.setId((int) newId);
-			return true;
-		}
-		return false;
-	}
-
-	public boolean update(OutgoingGroupSyncRequestLogModel outgoingGroupSyncRequestLogModel) {
-		ContentValues contentValues = buildValues(outgoingGroupSyncRequestLogModel);
-		this.databaseService.getWritableDatabase().update(this.getTableName(),
-				contentValues,
-				OutgoingGroupSyncRequestLogModel.COLUMN_ID + "=?",
-				new String[]{
-						String.valueOf(outgoingGroupSyncRequestLogModel.getId())
-				});
-		return true;
-	}
-
-	private ContentValues buildValues(OutgoingGroupSyncRequestLogModel outgoingGroupSyncRequestLogModel) {
-		ContentValues contentValues = new ContentValues();
-		contentValues.put(OutgoingGroupSyncRequestLogModel.COLUMN_API_GROUP_ID, outgoingGroupSyncRequestLogModel.getApiGroupId());
-		contentValues.put(OutgoingGroupSyncRequestLogModel.COLUMN_CREATOR_IDENTITY, outgoingGroupSyncRequestLogModel.getCreatorIdentity());
-		contentValues.put(OutgoingGroupSyncRequestLogModel.COLUMN_LAST_REQUEST, outgoingGroupSyncRequestLogModel.getLastRequest() != null
-				? CursorHelper.dateAsStringFormat.get().format(outgoingGroupSyncRequestLogModel.getLastRequest()) :
-				null);
-		return contentValues;
-	}
-
-	private OutgoingGroupSyncRequestLogModel getFirst(String selection, String[] selectionArgs) {
-		Cursor cursor = this.databaseService.getReadableDatabase().query (
-				this.getTableName(),
-				null,
-				selection,
-				selectionArgs,
-				null,
-				null,
-				null
-		);
-
-		if(cursor != null) {
-			try {
-				if (cursor.moveToFirst()) {
-					return convert(cursor);
-				}
-			}
-			finally {
-				cursor.close();
-			}
-		}
-
-		return null;
-	}
-
-	private OutgoingGroupSyncRequestLogModel convert(Cursor cursor) {
-		if(cursor != null && cursor.getPosition() >= 0) {
-			final OutgoingGroupSyncRequestLogModel c = new OutgoingGroupSyncRequestLogModel();
-
-			//convert default
-			new CursorHelper(cursor, columnIndexCache).current(new CursorHelper.Callback() {
-				@Override
-				public boolean next(CursorHelper cursorHelper) {
-					c
-							.setId(cursorHelper.getInt(OutgoingGroupSyncRequestLogModel.COLUMN_ID))
-							.setAPIGroupId(
-									cursorHelper.getString(OutgoingGroupSyncRequestLogModel.COLUMN_API_GROUP_ID),
-									cursorHelper.getString(OutgoingGroupSyncRequestLogModel.COLUMN_CREATOR_IDENTITY))
-							.setLastRequest(cursorHelper.getDateByString(OutgoingGroupSyncRequestLogModel.COLUMN_LAST_REQUEST))
-					;
-
-					return false;
-				}
-			});
-
-			return c;
-		}
-
-		return null;
-	}
-
-	@Override
-	public String[] getStatements() {
-		return new String[] {
-				"CREATE TABLE `m_group_request_sync_log` (`id` INTEGER PRIMARY KEY AUTOINCREMENT , `apiGroupId` VARCHAR , `creatorIdentity` VARCHAR , `lastRequest` VARCHAR )",
-				"CREATE UNIQUE INDEX `apiGroupIdAndCreatorGroupRequestSyncLogModel` ON `m_group_request_sync_log` ( `apiGroupId`, `creatorIdentity` );"
-		};
-	}
-}
diff --git a/app/src/main/java/ch/threema/storage/factories/RejectedGroupMessageFactory.kt b/app/src/main/java/ch/threema/storage/factories/RejectedGroupMessageFactory.kt
deleted file mode 100644
index f14f1d63..00000000
--- a/app/src/main/java/ch/threema/storage/factories/RejectedGroupMessageFactory.kt
+++ /dev/null
@@ -1,106 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage.factories
-
-import android.content.ContentValues
-import ch.threema.domain.models.MessageId
-import ch.threema.storage.DatabaseServiceNew
-import ch.threema.storage.models.GroupModel
-
-class RejectedGroupMessageFactory(databaseService: DatabaseServiceNew) :
-    ModelFactory(databaseService, "rejected_group_messages") {
-
-    companion object {
-        private const val COLUMN_MESSAGE_ID = "messageId"
-        private const val COLUMN_REJECTED_IDENTITY = "rejectedIdentity"
-        private const val COLUMN_GROUP_ID = "groupId"
-    }
-
-    fun insertMessageReject(
-        rejectedMessageId: MessageId,
-        rejectedIdentity: String,
-        groupModel: GroupModel,
-    ) {
-        val contentValues = ContentValues().apply {
-            put(COLUMN_MESSAGE_ID, rejectedMessageId.toString())
-            put(COLUMN_REJECTED_IDENTITY, rejectedIdentity)
-            put(COLUMN_GROUP_ID, groupModel.id)
-        }
-        writableDatabase.insert(tableName, null, contentValues)
-    }
-
-    fun getMessageRejects(
-        messageId: MessageId,
-        groupModel: GroupModel,
-    ): Set<String> {
-        val selection = "$COLUMN_MESSAGE_ID=? AND $COLUMN_GROUP_ID=?"
-        val selectionArgs = arrayOf(messageId.toString(), groupModel.id.toString())
-        readableDatabase.query(
-            tableName,
-            null,
-            selection,
-            selectionArgs,
-            null,
-            null,
-            null,
-        ).use {
-            val rejectedIdentities = mutableSetOf<String>()
-            val rejectedIdentityColumnIndex = it.getColumnIndexOrThrow(COLUMN_REJECTED_IDENTITY)
-            while (it.moveToNext()) {
-                rejectedIdentities.add(it.getString(rejectedIdentityColumnIndex))
-            }
-            return rejectedIdentities
-        }
-    }
-
-    fun removeMessageReject(
-        rejectedMessageId: MessageId,
-        rejectedIdentity: String,
-        groupModel: GroupModel,
-    ) {
-        val whereClause =
-            "$COLUMN_MESSAGE_ID=? AND $COLUMN_REJECTED_IDENTITY=? AND $COLUMN_GROUP_ID=?"
-        val whereArgs = arrayOf(rejectedMessageId.toString(), rejectedIdentity, groupModel.id)
-        writableDatabase.delete(tableName, whereClause, whereArgs)
-    }
-
-    fun removeAllMessageRejectsInGroup(group: GroupModel) {
-        val whereClause = "$COLUMN_GROUP_ID=?"
-        val whereArgs = arrayOf(group.id)
-        writableDatabase.delete(tableName, whereClause, whereArgs)
-    }
-
-    fun removeMessageRejectByGroupAndIdentity(group: GroupModel, identity: String) {
-        val whereClause = "$COLUMN_REJECTED_IDENTITY=? AND $COLUMN_GROUP_ID=?"
-        val whereArgs = arrayOf(identity, group.id)
-        writableDatabase.delete(tableName, whereClause, whereArgs)
-    }
-
-    override fun getStatements(): Array<String> = arrayOf(
-        "CREATE TABLE `$tableName` (" +
-                "`$COLUMN_MESSAGE_ID` INTEGER NOT NULL, " +
-                "`$COLUMN_REJECTED_IDENTITY` VARCHAR NOT NULL, " +
-                "`$COLUMN_GROUP_ID` INTEGER NOT NULL, " +
-                "PRIMARY KEY (`$COLUMN_MESSAGE_ID`, `$COLUMN_REJECTED_IDENTITY`, `$COLUMN_GROUP_ID`) ON CONFLICT IGNORE " +
-                ")"
-    )
-}
diff --git a/app/src/main/java/ch/threema/storage/factories/TaskArchiveFactory.kt b/app/src/main/java/ch/threema/storage/factories/TaskArchiveFactory.kt
deleted file mode 100644
index 13d6157a..00000000
--- a/app/src/main/java/ch/threema/storage/factories/TaskArchiveFactory.kt
+++ /dev/null
@@ -1,121 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage.factories
-
-import android.content.ContentValues
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.storage.DatabaseServiceNew
-
-private val logger = LoggingUtil.getThreemaLogger("TaskArchiveFactory")
-
-class TaskArchiveFactory(databaseService: DatabaseServiceNew) :
-    ModelFactory(databaseService, "tasks") {
-    companion object {
-        private const val COLUMN_ID = "id"
-        private const val COLUMN_TASK = "task"
-    }
-
-    /**
-     * Insert a new task. Note that leading and trailing whitespaces are ignored.
-     */
-    fun insert(task: String) {
-        val contentValues = ContentValues().apply { put(COLUMN_TASK, task.trim()) }
-        writableDatabase.insert(tableName, null, contentValues)
-    }
-
-    /**
-     * Removes the task that corresponds to this string. Note that leading and trailing whitespaces
-     * are ignored. If several tasks with the same string representation exist, only the oldest task
-     * is being removed. Note that older tasks are NOT deleted. Use this only to remove invalid
-     * tasks. To remove the task including all older tasks, use [remove].
-     */
-    fun removeOne(task: String) {
-        val taskId = getOldestIdForTask(task) ?: return
-        writableDatabase.delete(tableName, "$COLUMN_ID=?", arrayOf(taskId))
-    }
-
-    /**
-     * Removes the task that corresponds to this string. Note that leading and trailing whitespaces
-     * are ignored. If several tasks with the same string representation exist, only the oldest task
-     * is being removed. Note that all older tasks than the given task are deleted as well.
-     */
-    fun remove(task: String) {
-        val taskId = getOldestIdForTask(task) ?: return
-        val numDeleted = writableDatabase.delete(tableName, "$COLUMN_ID<=?", arrayOf(taskId))
-
-        // If several tasks have been deleted, then the just finished task was not the oldest one.
-        // This means that we skipped some tasks or have a task reordering!
-        if (numDeleted > 1) {
-            logger.error(
-                "{} instead of 1 tasks were deleted. Some tasks may have been skipped or reordered.",
-                numDeleted
-            )
-        }
-    }
-
-    /**
-     * Get all tasks currently stored in the queue. The list is ordered ascending, so that the
-     * oldest tasks are first.
-     */
-    fun getAll(): List<String> {
-        readableDatabase.query(
-            tableName,
-            null,
-            null,
-            null,
-            null,
-            null,
-            "$COLUMN_ID ASC"
-        ).use {
-            val tasks = mutableListOf<String>()
-            val taskColumnId = it.getColumnIndex(COLUMN_TASK)
-            while (it.moveToNext()) {
-                tasks.add(it.getString(taskColumnId))
-            }
-            return tasks
-        }
-    }
-
-    override fun getStatements() = arrayOf(
-        "CREATE TABLE `$tableName` (" +
-                "`$COLUMN_ID` INTEGER PRIMARY KEY AUTOINCREMENT, " +
-                "`$COLUMN_TASK` STRING NOT NULL)"
-    )
-
-    private fun getOldestIdForTask(task: String): Long? {
-        readableDatabase.query(
-            tableName,
-            null,
-            "$COLUMN_TASK=?",
-            arrayOf(task.trim()),
-            null,
-            null,
-            "$COLUMN_ID ASC",
-            "1"
-        ).use {
-            if (it.moveToFirst()) {
-                return it.getLong(it.getColumnIndexOrThrow(COLUMN_ID))
-            }
-        }
-        return null
-    }
-}
diff --git a/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java b/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java
index 1cd8154a..55ea7b81 100644
--- a/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java
+++ b/app/src/main/java/ch/threema/storage/models/AbstractMessageModel.java
@@ -35,6 +35,7 @@ import ch.threema.app.R;
 import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.QuoteUtil;
 import ch.threema.app.utils.TestUtil;
+import ch.threema.domain.protocol.blob.BlobScope;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode;
 import ch.threema.storage.models.data.DisplayTag;
 import ch.threema.storage.models.data.LocationDataModel;
@@ -346,11 +347,6 @@ public abstract class AbstractMessageModel {
 
     public AbstractMessageModel setModifiedAt(Date modifiedAt) {
         this.modifiedAt = modifiedAt;
-        if (getState() == MessageState.DELIVERED) {
-            this.deliveredAt = modifiedAt;
-        } else if (getState() == MessageState.READ) {
-            this.readAt = modifiedAt;
-        }
         return this;
     }
 
@@ -566,7 +562,7 @@ public abstract class AbstractMessageModel {
         return (FileDataModel) this.dataObject;
     }
 
-    public void setFileData(FileDataModel fileDataModel) {
+    public void setFileDataModel(@NonNull FileDataModel fileDataModel) {
         this.setType(MessageType.FILE);
         this.setBody(fileDataModel.toString());
         this.dataObject = fileDataModel;
@@ -672,9 +668,38 @@ public abstract class AbstractMessageModel {
     }
 
     /**
-     * TODO(ANDR-XXXX): evil code!
+     * This method only makes sense (finds its use) when multi device is active.
+     * The api call to download a blob without multi-device does not require a scope.
+     *
+     * @return The {@code BlobScope} to use when downloading the blob from the mirror server.
+     * If the message if outgoing ({@code isOutbox()}) we use the local scope to download the
+     * blob, as we know we received a reflected message. For every kind of incoming message we
+     * need to use the public scope, as the blob might only be present on the usual blob
+     * server (not mirror)
+     */
+    public BlobScope getBlobScopeForDownload() {
+        return isOutbox()
+            ? BlobScope.Local.INSTANCE
+            : BlobScope.Public.INSTANCE;
+    }
+
+    /**
+     * This method only makes sense (finds its use) when multi device is active.
+     * The api call to mark a blob as done without multi-device does not require a scope.
      *
-     * @param sourceModel
+     * @return The {@code BlobScope} to use when marking the blob as "done" on the blob mirror server.
+     * We only use the public scope here if the message is incoming and its not a group message. If
+     * the message in outgoing, always use local scope (because we got the reflection only). If the
+     * message is incoming but in a group, we use local scope (so that the blob is retained for other group members).
+     */
+    public BlobScope getBlobScopeForMarkAsDone() {
+        return (!this.isOutbox() && !(this instanceof GroupMessageModel))
+            ? BlobScope.Public.INSTANCE
+            : BlobScope.Local.INSTANCE;
+    }
+
+    /**
+     * TODO(ANDR-XXXX): evil code!
      */
     public void copyFrom(AbstractMessageModel sourceModel) {
         //copy all objects
diff --git a/app/src/main/java/ch/threema/storage/models/ContactModel.java b/app/src/main/java/ch/threema/storage/models/ContactModel.java
index a5b4a848..75559ff5 100644
--- a/app/src/main/java/ch/threema/storage/models/ContactModel.java
+++ b/app/src/main/java/ch/threema/storage/models/ContactModel.java
@@ -43,8 +43,11 @@ import ch.threema.app.utils.ConfigUtils;
 import ch.threema.app.utils.TestUtil;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
+import ch.threema.domain.models.IdentityState;
 import ch.threema.domain.models.IdentityType;
 import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.models.WorkVerificationLevel;
 
 import static ch.threema.app.utils.TextUtil.SPACE;
 import static ch.threema.app.utils.TextUtil.TILDE;
@@ -82,36 +85,21 @@ public class ContactModel extends Contact implements ReceiverModel {
 
     public static final byte[] NO_PROFILE_PICTURE_BLOB_ID = new byte[0];
 
-    public enum State {
-        /**
-         * Contact is active.
-         */
-        ACTIVE,
-        /**
-         * Contact is inactive.
-         */
-        INACTIVE,
-        /**
-         * Contact does not have a valid Threema-ID, or the ID was revoked.
-         */
-        INVALID
-    }
-
-    /**
-     * Acquaintance level of the contact.
-     */
-    public enum AcquaintanceLevel {
-        /**
-         * The contact was explicitly added by the user or a 1:1 conversation with the contact
-         * has been initiated.
-         */
-        DIRECT,
-        /**
-         * The contact is part of a group the user is also part of. The contact was not explicitly
-         * added and no 1:1 conversation has been initiated.
-         */
-        GROUP
-    }
+	/**
+	 * Acquaintance level of the contact.
+	 */
+	public enum AcquaintanceLevel {
+		/**
+		 * The contact was explicitly added by the user or a 1:1 conversation with the contact
+		 * has been initiated.
+		 */
+		DIRECT,
+		/**
+		 * The contact is part of a group the user is also part of. The contact was not explicitly
+		 * added and no 1:1 conversation has been initiated.
+		 */
+		GROUP
+	}
 
     /**
      * Policy for sending read receipts or typing indicators
@@ -140,19 +128,20 @@ public class ContactModel extends Contact implements ReceiverModel {
     // Timeout for avatars of linked contacts
     public static long DEFAULT_ANDROID_CONTACT_AVATAR_EXPIRY = DateUtils.DAY_IN_MILLIS * 14;
 
-    private String publicNickName;
-    private State state;
-    private String androidContactId;
-    private long featureMask;
-    private int colorIndex = -1;
-    private boolean isWork, isRestored, isArchived;
-    private AcquaintanceLevel acquaintanceLevel = AcquaintanceLevel.DIRECT;
-    private Date localAvatarExpires, dateCreated;
-    private @Nullable Date lastUpdate;
-    private byte[] profilePicBlobID;
-    private @Nullable IdentityType type;
-    private @OverridePolicy int readReceipts, typingIndicators;
-    private int forwardSecurityState; // TODO(ANDR-2452): Remove the forward security state when most of clients support 1.1 anyway
+	private String publicNickName;
+	private IdentityState state;
+	private String androidContactId;
+	private long featureMask;
+	private int colorIndex = -1;
+	private boolean isWork, isRestored, isArchived;
+	private AcquaintanceLevel acquaintanceLevel = AcquaintanceLevel.DIRECT;
+	private Date localAvatarExpires, dateCreated;
+	private @Nullable Date lastUpdate;
+	private byte[] profilePicBlobID;
+	private @Nullable IdentityType type;
+	private @OverridePolicy int readReceipts, typingIndicators;
+	// TODO(ANDR-2452): Remove the forward security state when most of clients support 1.1 anyway
+	private int forwardSecurityState;
     private @Nullable String jobTitle;
     private @Nullable String department;
 
@@ -293,14 +282,14 @@ public class ContactModel extends Contact implements ReceiverModel {
         return this;
     }
 
-    public State getState() {
-        return this.state;
-    }
+	public IdentityState getState() {
+		return this.state;
+	}
 
-    public ContactModel setState(State state) {
-        this.state = state;
-        return this;
-    }
+	public ContactModel setState(IdentityState state) {
+		this.state = state;
+		return this;
+	}
 
     /**
      * Get the expiration date of a local avatar (either a gateway contact avatar,
@@ -340,16 +329,30 @@ public class ContactModel extends Contact implements ReceiverModel {
         return this.isWork;
     }
 
-    /**
-     * Get the BlobId of the latest profile picture that was sent to this contact.
-     *
-     * @return The blobId of the latest profile-picture sent to this contact, {@code null} if no
-     * profile-picture has been sent or {@code new byte[0]} if a delete-profile-picture message has been sent
-     */
-    @Nullable
-    public byte[] getProfilePicBlobID() {
-        return profilePicBlobID;
-    }
+	/**
+	 * Get the work verification level of the contact. If {@link #isWork} is true,
+	 * {@link WorkVerificationLevel#WORK_SUBSCRIPTION_VERIFIED} is returned,
+	 * {@link WorkVerificationLevel#NONE} otherwise.
+	 */
+	@NonNull
+	public WorkVerificationLevel getWorkVerificationLevel() {
+		if (isWork) {
+			return WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED;
+		} else {
+			return WorkVerificationLevel.NONE;
+		}
+	}
+
+	/**
+	 * Get the BlobId of the latest profile picture that was sent to this contact.
+	 *
+	 * @return The blobId of the latest profile-picture sent to this contact, {@code null} if no
+	 *      profile-picture has been sent or {@code new byte[0]} if a delete-profile-picture message has been sent
+	 */
+	@Nullable
+	public byte[] getProfilePicBlobID() {
+		return profilePicBlobID;
+	}
 
     /**
      * Set the {@link AcquaintanceLevel} of the contact.
@@ -500,33 +503,48 @@ public class ContactModel extends Contact implements ReceiverModel {
         return this;
     }
 
-    public Object[] getModifiedValueCandidates() {
-        return new Object[]{
-            this.getPublicKey(),
-            this.getFirstName(),
-            this.getLastName(),
-            this.publicNickName,
-            this.verificationLevel,
-            this.androidContactId,
-            this.colorIndex,
-            this.state,
-            this.featureMask,
-            this.localAvatarExpires,
-            this.isWork,
-            this.profilePicBlobID,
-            this.type,
-            this.dateCreated,
-            this.acquaintanceLevel,
-            this.lastUpdate,
-            this.isRestored,
-            this.isArchived,
-            this.readReceipts,
-            this.typingIndicators,
-            this.forwardSecurityState,
-            this.jobTitle,
-            this.department
-        };
-    }
+	@NonNull
+	public BasicContact toBasicContact() {
+		if (type == null) {
+			logger.warn("Identity type is null. Using normal as default.");
+		}
+		if (state == null) {
+			logger.warn("Identity state is null. Using active as default.");
+		}
+		return BasicContact.javaCreate(
+			getIdentity(),
+			getPublicKey(),
+			featureMask,
+			state != null ? state : IdentityState.ACTIVE,
+			type != null ? type : IdentityType.NORMAL
+		);
+	}
+
+	public Object[] getModifiedValueCandidates() {
+		return new Object[] {
+			this.getPublicKey(),
+			this.getFirstName(),
+			this.getLastName(),
+			this.publicNickName,
+			this.verificationLevel,
+			this.androidContactId,
+			this.colorIndex,
+			this.state,
+			this.featureMask,
+			this.localAvatarExpires,
+			this.isWork,
+			this.profilePicBlobID,
+			this.type,
+			this.dateCreated,
+			this.acquaintanceLevel,
+			this.lastUpdate,
+			this.isRestored,
+			this.isArchived,
+			this.readReceipts,
+			this.typingIndicators,
+			this.forwardSecurityState
+		};
+	}
 
     @Override
     @NonNull
diff --git a/app/src/main/java/ch/threema/storage/models/GroupModel.java b/app/src/main/java/ch/threema/storage/models/GroupModel.java
index 0422c007..9946c544 100644
--- a/app/src/main/java/ch/threema/storage/models/GroupModel.java
+++ b/app/src/main/java/ch/threema/storage/models/GroupModel.java
@@ -59,6 +59,7 @@ public class GroupModel implements ReceiverModel {
 	public static final String COLUMN_GROUP_DESC = "groupDesc";
 	public static final String COLUMN_GROUP_DESC_CHANGED_TIMESTAMP = "changedGroupDescTimestamp";
 	public static final String COLUMN_COLOR_INDEX = "colorIndex";
+	public static final String COLUMN_USER_STATE = "userState";
 
 	private String groupDesc;
 	private Date changedGroupDescTimestamp;
@@ -73,6 +74,37 @@ public class GroupModel implements ReceiverModel {
 	private boolean deleted;
 	private boolean isArchived;
 	private int colorIndex = -1;
+	private @Nullable UserState userState;
+
+	/**
+	 * The user's state within the group.
+	 */
+	public enum UserState {
+
+		MEMBER(0),
+
+		KICKED(1),
+
+		LEFT(2);
+
+		public final int value;
+
+		UserState(int value) {
+			this.value = value;
+		}
+
+		@Nullable
+		public static UserState valueOf(int value) {
+			for (UserState userState : values()) {
+				if (userState.value == value) {
+					return userState;
+				}
+			}
+
+			return null;
+		}
+
+	}
 
 	// dummy class
 	@Nullable
@@ -222,6 +254,17 @@ public class GroupModel implements ReceiverModel {
 		return ColorUtil.getInstance().getIDColorDark(colorIndex);
 	}
 
+	@NonNull
+	public GroupModel setUserState(@Nullable UserState userState) {
+		this.userState = userState;
+		return this;
+	}
+
+	@Nullable
+	public UserState getUserState() {
+		return userState;
+	}
+
 	private void computeColorIndex() {
 		byte[] groupCreatorIdentity = creatorIdentity.getBytes(StandardCharsets.UTF_8);
 		byte[] apiGroupIdBin = apiGroupId.getGroupId();
diff --git a/app/src/main/java/ch/threema/storage/models/IncomingGroupSyncRequestLogModel.kt b/app/src/main/java/ch/threema/storage/models/IncomingGroupSyncRequestLogModel.kt
deleted file mode 100644
index 919baf1f..00000000
--- a/app/src/main/java/ch/threema/storage/models/IncomingGroupSyncRequestLogModel.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage.models
-
-/**
- * This model is used to track at what time a group sync request has been answered. This is required
- * to limit the number of answered group sync requests per group and sender of the request.
- */
-class IncomingGroupSyncRequestLogModel(
-
-    /**
-     * The database id of the group.
-     */
-    val groupId: Int,
-
-    /**
-     * The identity of the sender of the group sync request.
-     */
-    val senderIdentity: String,
-
-    /**
-     * The time when the last group request from [senderIdentity] in group [groupId] has been
-     * answered.
-     */
-    var lastHandledRequest: Long,
-) {
-    companion object {
-        const val TABLE = "incoming_group_sync_request_log"
-
-        const val COLUMN_GROUP_ID = "groupId"
-        const val COLUMN_SENDER_IDENTITY = "senderIdentity"
-        const val COLUMN_LAST_HANDLED_REQUEST = "lastHandledRequest"
-    }
-}
diff --git a/app/src/main/java/ch/threema/storage/models/OutgoingGroupSyncRequestLogModel.java b/app/src/main/java/ch/threema/storage/models/OutgoingGroupSyncRequestLogModel.java
deleted file mode 100644
index ac085f28..00000000
--- a/app/src/main/java/ch/threema/storage/models/OutgoingGroupSyncRequestLogModel.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2014-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.storage.models;
-
-
-import java.util.Date;
-
-import androidx.annotation.NonNull;
-
-/**
- * This model is used to track at what time a group sync request has been sent to what group. This
- * is required to prevent that group sync requests are sent too often per group.
- */
-public class OutgoingGroupSyncRequestLogModel {
-
-	public static final String TABLE = "m_group_request_sync_log";
-	public static final String COLUMN_ID = "id";
-	public static final String COLUMN_API_GROUP_ID = "apiGroupId";
-	public static final String COLUMN_CREATOR_IDENTITY = "creatorIdentity";
-	public static final String COLUMN_LAST_REQUEST = "lastRequest";
-
-	private int id;
-	private String apiGroupId;
-	private String creatorIdentity;
-	private Date lastRequest;
-
-	public OutgoingGroupSyncRequestLogModel() {
-	}
-
-	public int getId() {
-		return id;
-	}
-
-	public OutgoingGroupSyncRequestLogModel setId(int id) {
-		this.id = id;
-		return this;
-	}
-
-	@NonNull
-	@Override
-	public String toString() {
-		return "m_group_request_sync_log.id = " + this.getId();
-	}
-
-	public OutgoingGroupSyncRequestLogModel setAPIGroupId(String apiGroupId, String creatorIdentity) {
-		this.apiGroupId = apiGroupId;
-		this.creatorIdentity = creatorIdentity;
-		return this;
-	}
-
-	public String getCreatorIdentity() {
-		return this.creatorIdentity;
-	}
-
-	public String getApiGroupId() {
-		return this.apiGroupId;
-	}
-
-	public Date getLastRequest() {
-		return this.lastRequest;
-	}
-
-	public OutgoingGroupSyncRequestLogModel setLastRequest(Date lastRequest) {
-		this.lastRequest = lastRequest;
-		return this;
-	}
-}
diff --git a/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java b/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java
index a5367d1c..41ae2621 100644
--- a/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java
+++ b/app/src/main/java/ch/threema/storage/models/data/media/FileDataModel.java
@@ -33,6 +33,7 @@ import java.io.StringWriter;
 import java.util.Iterator;
 import java.util.Map;
 
+import ch.threema.app.utils.FileUtil;
 import ch.threema.app.utils.JsonUtil;
 import ch.threema.app.utils.ListReader;
 import ch.threema.app.utils.MimeUtil;
@@ -43,340 +44,364 @@ import ch.threema.base.utils.Utils;
 import ch.threema.domain.protocol.csp.messages.file.FileData;
 
 public class FileDataModel implements MediaMessageDataInterface {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("FileDataModel");
-
-	public static final String METADATA_KEY_DURATION = "d";
-	public static final String METADATA_KEY_WIDTH = "w";
-	public static final String METADATA_KEY_HEIGHT = "h";
-	public static final String METADATA_KEY_ANIMATED = "a";
-
-	private byte[] fileBlobId;
-	private byte[] encryptionKey;
-	private String mimeType;
-	private String thumbnailMimeType;
-	private long fileSize;
-	private @Nullable String fileName;
-	private @FileData.RenderingType int renderingType;
-	private boolean isDownloaded;
-	private String caption;
-	private Map<String, Object> metaData;
-
-	// incoming
-	public FileDataModel(byte[] fileBlobId,
-	                     byte[] encryptionKey,
-	                     String mimeType,
-	                     String thumbnailMimeType,
-	                     long fileSize,
-	                     @Nullable String fileName,
-	                     @FileData.RenderingType int renderingType,
-	                     String caption,
-	                     boolean isDownloaded,
-	                     Map<String, Object> metaData) {
-		this.fileBlobId = fileBlobId;
-		this.encryptionKey = encryptionKey;
-		this.mimeType = mimeType;
-		this.thumbnailMimeType = thumbnailMimeType;
-		this.fileSize = fileSize;
-		this.fileName = fileName;
-		this.renderingType = renderingType;
-		this.caption = caption;
-		this.isDownloaded = isDownloaded;
-		this.metaData = metaData;
-	}
-
-	// outgoing
-	public FileDataModel(String mimeType,
-	                     String thumbnailMimeType,
-	                     long fileSize,
-	                     @Nullable String fileName,
-	                     @FileData.RenderingType int renderingType,
-	                     String caption,
-	                     boolean isDownloaded,
-	                     Map<String, Object> metaData) {
-		this.mimeType = mimeType;
-		this.thumbnailMimeType = thumbnailMimeType;
-		this.fileSize = fileSize;
-		this.fileName = fileName;
-		this.renderingType = renderingType;
-		this.caption = caption;
-		this.isDownloaded = isDownloaded;
-		this.metaData = metaData;
-	}
-
-	private FileDataModel() {
-	}
-
-	public void setCaption(String caption) {
-		this.caption = caption;
-	}
-
-	public void setFileName(@Nullable String fileName) {
-		this.fileName = fileName;
-	}
-
-	public void setRenderingType(@FileData.RenderingType int renderingType) {
-		this.renderingType = renderingType;
-	}
-
-	public void setBlobId(byte[] blobId) {
-		this.fileBlobId = blobId;
-	}
-
-	@Override
-	public byte[] getBlobId() {
-		return this.fileBlobId;
-	}
-
-	public void setEncryptionKey(byte[] encryptionKey) {
-		this.encryptionKey = encryptionKey;
-	}
-
-	@Override
-	public byte[] getEncryptionKey() {
-		return this.encryptionKey;
-	}
-
-	@Override
-	public boolean isDownloaded() {
-		return this.isDownloaded;
-	}
-
-	@Override
-	public void isDownloaded(boolean isDownloaded) {
-		this.isDownloaded = isDownloaded;
-	}
-
-	@Override
-	public byte[] getNonce() {
-		return new byte[0];
-	}
-
-	@NonNull
-	public String getMimeType() {
-		if (this.mimeType == null) {
-			return MimeUtil.MIME_TYPE_DEFAULT;
-		}
-		return this.mimeType;
-	}
-
-	public void setMimeType(String mimeType) {
-		this.mimeType = mimeType;
-	}
-
-	@Nullable
-	public String getThumbnailMimeType() {
-		return this.thumbnailMimeType;
-	}
-
-	public void setThumbnailMimeType(String thumbnailMimeType) {
-		this.thumbnailMimeType = thumbnailMimeType;
-	}
-
-	public void setFileSize(long fileSize) {
-		this.fileSize = fileSize;
-	}
-
-	public long getFileSize() {
-		return this.fileSize;
-	}
-
-	public @Nullable String getFileName() {
-		return this.fileName;
-	}
-
-	public @FileData.RenderingType int getRenderingType() {
-		return this.renderingType;
-	}
-
-	public String getCaption() {
-		return this.caption;
-	}
-
-	public Map<String, Object> getMetaData() {
-		return this.metaData;
-	}
-
-	public void setMetaData(Map<String, Object> metaData) {
-		this.metaData = metaData;
-	}
-
-	@Nullable
-	public Integer getMetaDataInt(String metaDataKey) {
-		return this.metaData != null
-			&& this.metaData.containsKey(metaDataKey)
-			&& this.metaData.get(metaDataKey) instanceof Number ?
-			(Integer) this.metaData.get(metaDataKey) : null;
-	}
-
-	@Nullable
-	public String getMetaDataString(String metaDataKey) {
-		return this.metaData != null
-			&& this.metaData.containsKey(metaDataKey)
-			&& this.metaData.get(metaDataKey) instanceof String ?
-			(String) this.metaData.get(metaDataKey) : null;
-	}
-
-	@Nullable
-	public Boolean getMetaDataBool(String metaDataKey) {
-		return this.metaData != null
-			&& this.metaData.containsKey(metaDataKey)
-			&& this.metaData.get(metaDataKey) instanceof Boolean ?
-			(Boolean) this.metaData.get(metaDataKey) : null;
-	}
-
-	@Nullable
-	public Float getMetaDataFloat(String metaDataKey) {
-		if (this.metaData != null && this.metaData.containsKey(metaDataKey)) {
-
-			Object value = this.metaData.get(metaDataKey);
-			if (value instanceof Number) {
-				if (value instanceof Double) {
-					return ((Double) value).floatValue();
-				} else if (value instanceof Float) {
-					return (Float) value;
-				} else if (value instanceof Integer) {
-					return ((Integer) value).floatValue();
-				} else {
-					return 0F;
-				}
-			}
-		}
-		return null;
-	}
-
-	/**
-	 * Return a formatted string representing the duration as provided by the respective metadata field
-	 * in the format of hours:minutes:seconds
-	 * @return Formatted duration string or 00:00 in case of error
-	 */
-	public @NonNull String getDurationString() {
-		return StringConversionUtil.secondsToString(getDurationSeconds(), false);
-	}
-
-	/**
-	 * Return the duration in SECONDS as set in the metadata field.
-	 */
-	public long getDurationSeconds() {
-		try {
-			Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
-			if (durationF != null) {
-				return Math.round(durationF);
-			}
-		} catch (Exception ignored) {}
-		return 0L;
-	}
-
-	/**
-	 * Return the duration in MILLISECONDS as set in the metadata field.
-	 *
-	 * Note: Floats are converted to long integers. No rounding.
-	 */
-	public long getDurationMs() {
-		try {
-			Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
-			if (durationF != null) {
-				durationF *= 1000F;
-				return durationF.longValue();
-			}
-		} catch (Exception ignored) {}
-		return 0L;
-	}
-
-	private void fromString(String s) {
-		if (TestUtil.isEmptyOrNull(s)) {
-			return;
-		}
-
-		try {
-			ListReader reader  = new ListReader(JsonUtil.convertArray(s));
-			this.fileBlobId = reader.nextStringAsByteArray();
-			this.encryptionKey = reader.nextStringAsByteArray();
-			this.mimeType = reader.nextString();
-			this.fileSize = reader.nextInteger();
-			this.fileName = reader.nextString();
-			try {
-				Integer typeId = reader.nextInteger();
-				if (typeId != null) {
-					this.renderingType = typeId;
-				}
-			} catch (ClassCastException ignore) {
-				// ignore very old filedatamodel without rendering type
-			}
-			this.isDownloaded = reader.nextBool();
-			this.caption = reader.nextString();
-			this.thumbnailMimeType = reader.nextString();
-			this.metaData = reader.nextMap();
-		} catch (Exception e) {
-			// Ignore error, just log
-			logger.error("Extract file data model", e);
-		}
-	}
-
-	@Override
-	public String toString() {
-		StringWriter sw = new StringWriter();
-		JsonWriter j = new JsonWriter(sw);
-
-		try {
-			j.beginArray();
-			j
-					.value(Utils.byteArrayToHexString(this.getBlobId()))
-					.value(Utils.byteArrayToHexString(this.getEncryptionKey()))
-					.value(this.mimeType)
-					.value(this.fileSize)
-					.value(this.fileName)
-					.value(this.renderingType)
-					.value(this.isDownloaded)
-					.value(this.caption)
-					.value(this.thumbnailMimeType);
-
-			// Always write the meta data object
-			JsonWriter metaDataObject = j.beginObject();
-			if (this.metaData != null) {
-				Iterator<String> keys = this.metaData.keySet().iterator();
-
-				while (keys.hasNext()) {
-					String key = keys.next();
-					Object value = this.metaData.get(key);
-
-					metaDataObject.name(key);
-
-					try {
-						if (value instanceof Integer) {
-							metaDataObject.value((Integer) value);
-						} else if (value instanceof Float) {
-							metaDataObject.value((Float) value);
-						} else if (value instanceof Double) {
-							metaDataObject.value((Double) value);
-						} else if (value instanceof Boolean) {
-							metaDataObject.value((Boolean) value);
-						} else if (value == null) {
-							metaDataObject.nullValue();
-						} else {
-							metaDataObject.value(value.toString());
-						}
-					}
-					catch (IOException x) {
-						logger.error("Failed to write meta data", x);
-						// Write a NULL
-						metaDataObject.nullValue();
-					}
-				}
-			}
-			j.endObject();
-			j.endArray();
-		}
-		catch (Exception x) {
-			logger.error("Exception", x);
-			return null;
-		}
-
-		return sw.toString();
-	}
-
-	public static FileDataModel create(@NonNull String s) {
-		FileDataModel m = new FileDataModel();
-		m.fromString(s);
-		return m;
-	}
+    private static final Logger logger = LoggingUtil.getThreemaLogger("FileDataModel");
+
+    public static final String METADATA_KEY_DURATION = "d";
+    public static final String METADATA_KEY_WIDTH = "w";
+    public static final String METADATA_KEY_HEIGHT = "h";
+    public static final String METADATA_KEY_ANIMATED = "a";
+
+    private byte[] fileBlobId;
+    private byte[] encryptionKey;
+    private String mimeType;
+    private String thumbnailMimeType;
+    private long fileSize;
+    private @Nullable String fileName;
+    private @FileData.RenderingType int renderingType;
+    private boolean isDownloaded;
+    private String caption;
+    private Map<String, Object> metaData;
+
+    /**
+     * @return A new instance of {@code FileDataModel} with the field {@code isDownloaded} set to {@code false} (as its an incoming message file data).
+     */
+    @NonNull
+    public static FileDataModel fromIncomingFileData(@NonNull FileData fileData) {
+        return new FileDataModel(
+            /* fileBlobId = */ fileData.getFileBlobId(),
+            /* encryptionKey = */ fileData.getEncryptionKey(),
+            /* mimeType = */ fileData.getMimeType(),
+            /* thumbnailMimeType = */ fileData.getThumbnailMimeType(),
+            /* fileSize = */ fileData.getFileSize(),
+            /* fileName = */ FileUtil.sanitizeFileName(fileData.getFileName()),
+            /* renderingType = */ fileData.getRenderingType(),
+            /* caption = */ fileData.getCaption(),
+            /* isDownloaded = */ false,
+            /* metaData = */ fileData.getMetaData()
+        );
+    }
+
+    // incoming
+    public FileDataModel(
+        byte[] fileBlobId,
+        byte[] encryptionKey,
+        String mimeType,
+        String thumbnailMimeType,
+        long fileSize,
+        @Nullable String fileName,
+        @FileData.RenderingType int renderingType,
+        String caption,
+        boolean isDownloaded,
+        Map<String, Object> metaData
+    ) {
+        this.fileBlobId = fileBlobId;
+        this.encryptionKey = encryptionKey;
+        this.mimeType = mimeType;
+        this.thumbnailMimeType = thumbnailMimeType;
+        this.fileSize = fileSize;
+        this.fileName = fileName;
+        this.renderingType = renderingType;
+        this.caption = caption;
+        this.isDownloaded = isDownloaded;
+        this.metaData = metaData;
+    }
+
+    // outgoing
+    public FileDataModel(
+        String mimeType,
+        String thumbnailMimeType,
+        long fileSize,
+        @Nullable String fileName,
+        @FileData.RenderingType int renderingType,
+        String caption,
+        boolean isDownloaded,
+        Map<String, Object> metaData
+    ) {
+        this.mimeType = mimeType;
+        this.thumbnailMimeType = thumbnailMimeType;
+        this.fileSize = fileSize;
+        this.fileName = fileName;
+        this.renderingType = renderingType;
+        this.caption = caption;
+        this.isDownloaded = isDownloaded;
+        this.metaData = metaData;
+    }
+
+    private FileDataModel() {
+    }
+
+    public void setCaption(String caption) {
+        this.caption = caption;
+    }
+
+    public void setFileName(@Nullable String fileName) {
+        this.fileName = fileName;
+    }
+
+    public void setRenderingType(@FileData.RenderingType int renderingType) {
+        this.renderingType = renderingType;
+    }
+
+    public void setBlobId(byte[] blobId) {
+        this.fileBlobId = blobId;
+    }
+
+    @Override
+    public byte[] getBlobId() {
+        return this.fileBlobId;
+    }
+
+    public void setEncryptionKey(byte[] encryptionKey) {
+        this.encryptionKey = encryptionKey;
+    }
+
+    @Override
+    public byte[] getEncryptionKey() {
+        return this.encryptionKey;
+    }
+
+    @Override
+    public boolean isDownloaded() {
+        return this.isDownloaded;
+    }
+
+    @Override
+    public void isDownloaded(boolean isDownloaded) {
+        this.isDownloaded = isDownloaded;
+    }
+
+    @Override
+    public byte[] getNonce() {
+        return new byte[0];
+    }
+
+    @NonNull
+    public String getMimeType() {
+        if (this.mimeType == null) {
+            return MimeUtil.MIME_TYPE_DEFAULT;
+        }
+        return this.mimeType;
+    }
+
+    public void setMimeType(String mimeType) {
+        this.mimeType = mimeType;
+    }
+
+    @Nullable
+    public String getThumbnailMimeType() {
+        return this.thumbnailMimeType;
+    }
+
+    public void setThumbnailMimeType(String thumbnailMimeType) {
+        this.thumbnailMimeType = thumbnailMimeType;
+    }
+
+    public void setFileSize(long fileSize) {
+        this.fileSize = fileSize;
+    }
+
+    public long getFileSize() {
+        return this.fileSize;
+    }
+
+    public @Nullable String getFileName() {
+        return this.fileName;
+    }
+
+    public @FileData.RenderingType int getRenderingType() {
+        return this.renderingType;
+    }
+
+    public String getCaption() {
+        return this.caption;
+    }
+
+    public Map<String, Object> getMetaData() {
+        return this.metaData;
+    }
+
+    public void setMetaData(Map<String, Object> metaData) {
+        this.metaData = metaData;
+    }
+
+    @Nullable
+    public Integer getMetaDataInt(String metaDataKey) {
+        return this.metaData != null
+            && this.metaData.containsKey(metaDataKey)
+            && this.metaData.get(metaDataKey) instanceof Number ?
+            (Integer) this.metaData.get(metaDataKey) : null;
+    }
+
+    @Nullable
+    public String getMetaDataString(String metaDataKey) {
+        return this.metaData != null
+            && this.metaData.containsKey(metaDataKey)
+            && this.metaData.get(metaDataKey) instanceof String ?
+            (String) this.metaData.get(metaDataKey) : null;
+    }
+
+    @Nullable
+    public Boolean getMetaDataBool(String metaDataKey) {
+        return this.metaData != null
+            && this.metaData.containsKey(metaDataKey)
+            && this.metaData.get(metaDataKey) instanceof Boolean ?
+            (Boolean) this.metaData.get(metaDataKey) : null;
+    }
+
+    @Nullable
+    public Float getMetaDataFloat(String metaDataKey) {
+        if (this.metaData != null && this.metaData.containsKey(metaDataKey)) {
+
+            Object value = this.metaData.get(metaDataKey);
+            if (value instanceof Number) {
+                if (value instanceof Double) {
+                    return ((Double) value).floatValue();
+                } else if (value instanceof Float) {
+                    return (Float) value;
+                } else if (value instanceof Integer) {
+                    return ((Integer) value).floatValue();
+                } else {
+                    return 0F;
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Return a formatted string representing the duration as provided by the respective metadata field
+     * in the format of hours:minutes:seconds
+     *
+     * @return Formatted duration string or 00:00 in case of error
+     */
+    public @NonNull String getDurationString() {
+        return StringConversionUtil.secondsToString(getDurationSeconds(), false);
+    }
+
+    /**
+     * Return the duration in SECONDS as set in the metadata field.
+     */
+    public long getDurationSeconds() {
+        try {
+            Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
+            if (durationF != null) {
+                return Math.round(durationF);
+            }
+        } catch (Exception ignored) {
+        }
+        return 0L;
+    }
+
+    /**
+     * Return the duration in MILLISECONDS as set in the metadata field.
+     * <p>
+     * Note: Floats are converted to long integers. No rounding.
+     */
+    public long getDurationMs() {
+        try {
+            Float durationF = getMetaDataFloat(METADATA_KEY_DURATION);
+            if (durationF != null) {
+                durationF *= 1000F;
+                return durationF.longValue();
+            }
+        } catch (Exception ignored) {
+        }
+        return 0L;
+    }
+
+    private void fromString(String s) {
+        if (TestUtil.isEmptyOrNull(s)) {
+            return;
+        }
+
+        try {
+            ListReader reader = new ListReader(JsonUtil.convertArray(s));
+            this.fileBlobId = reader.nextStringAsByteArray();
+            this.encryptionKey = reader.nextStringAsByteArray();
+            this.mimeType = reader.nextString();
+            this.fileSize = reader.nextInteger();
+            this.fileName = reader.nextString();
+            try {
+                Integer typeId = reader.nextInteger();
+                if (typeId != null) {
+                    this.renderingType = typeId;
+                }
+            } catch (ClassCastException ignore) {
+                // ignore very old filedatamodel without rendering type
+            }
+            this.isDownloaded = reader.nextBool();
+            this.caption = reader.nextString();
+            this.thumbnailMimeType = reader.nextString();
+            this.metaData = reader.nextMap();
+        } catch (Exception e) {
+            // Ignore error, just log
+            logger.error("Extract file data model", e);
+        }
+    }
+
+    @Override
+    public String toString() {
+        StringWriter sw = new StringWriter();
+        JsonWriter j = new JsonWriter(sw);
+
+        try {
+            j.beginArray();
+            j
+                .value(Utils.byteArrayToHexString(this.getBlobId()))
+                .value(Utils.byteArrayToHexString(this.getEncryptionKey()))
+                .value(this.mimeType)
+                .value(this.fileSize)
+                .value(this.fileName)
+                .value(this.renderingType)
+                .value(this.isDownloaded)
+                .value(this.caption)
+                .value(this.thumbnailMimeType);
+
+            // Always write the meta data object
+            JsonWriter metaDataObject = j.beginObject();
+            if (this.metaData != null) {
+                Iterator<String> keys = this.metaData.keySet().iterator();
+
+                while (keys.hasNext()) {
+                    String key = keys.next();
+                    Object value = this.metaData.get(key);
+
+                    metaDataObject.name(key);
+
+                    try {
+                        if (value instanceof Integer) {
+                            metaDataObject.value((Integer) value);
+                        } else if (value instanceof Float) {
+                            metaDataObject.value((Float) value);
+                        } else if (value instanceof Double) {
+                            metaDataObject.value((Double) value);
+                        } else if (value instanceof Boolean) {
+                            metaDataObject.value((Boolean) value);
+                        } else if (value == null) {
+                            metaDataObject.nullValue();
+                        } else {
+                            metaDataObject.value(value.toString());
+                        }
+                    } catch (IOException x) {
+                        logger.error("Failed to write meta data", x);
+                        // Write a NULL
+                        metaDataObject.nullValue();
+                    }
+                }
+            }
+            j.endObject();
+            j.endArray();
+        } catch (Exception x) {
+            logger.error("Exception", x);
+            return null;
+        }
+
+        return sw.toString();
+    }
+
+    public static FileDataModel create(@NonNull String s) {
+        FileDataModel m = new FileDataModel();
+        m.fromString(s);
+        return m;
+    }
 }
diff --git a/app/src/none/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/none/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index 1f22f96c..00000000
--- a/app/src/none/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFF34C955)
-    override val onPrimary = Color(0xFF003910)
-    override val primaryContainer = Color(0xFF00531B)
-    override val onPrimaryContainer = Color(0xFFA2EDA8)
-    override val secondary = Color(0xFFB9CCB5)
-    override val onSecondary = Color(0xFF243424)
-    override val secondaryContainer = Color(0xFF444843)
-    override val onSecondaryContainer = Color(0xFFDFE9DD)
-    override val tertiary = Color(0xFFA1D1AB)
-    override val onTertiary = Color(0xFF003C1A)
-    override val tertiaryContainer = Color(0xFF1F4D53)
-    override val onTertiaryContainer = Color(0xFFBCEBF2)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C19)
-    override val onBackground = Color(0xFFE2E3DD)
-    override val surface = Color(0xFF1A1C19)
-    override val onSurface = Color(0xFFE2E3DD)
-    override val surfaceVariant = Color(0xFF203022)
-    override val onSurfaceVariant = Color(0xFFC2C9BD)
-    override val outline = Color(0xFF8C9389)
-    override val outlineVariant = Color(0xFF424940)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE2E3DD)
-    override val inverseOnSurface = Color(0xFF1A1C19)
-    override val inversePrimary = Color(0xFF006E26)
-}
diff --git a/app/src/none/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/none/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 0a89c13f..00000000
--- a/app/src/none/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF05A63F)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFBCEECA)
-    override val onPrimaryContainer = Color(0xFF002106)
-    override val secondary = Color(0xFF526350)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE8F6EA)
-    override val onSecondaryContainer = Color(0xFF101F10)
-    override val tertiary = Color(0xFF04370E)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFBCEBF2)
-    override val onTertiaryContainer = Color(0xFF001F23)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFEFFFE)
-    override val onBackground = Color(0xFF1A1C19)
-    override val surface = Color(0xFFFEFFFE)
-    override val onSurface = Color(0xFF1A1C19)
-    override val surfaceVariant = Color(0xFFE0E4DD)
-    override val onSurfaceVariant = Color(0xFF424940)
-    override val outline = Color(0xFF72796F)
-    override val outlineVariant = Color(0xFFC4C8C1)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F312D)
-    override val inverseOnSurface = Color(0xFFF0F1EB)
-    override val inversePrimary = Color(0xFF009C32)
-}
diff --git a/app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index f5271acf..00000000
--- a/app/src/none/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F4F1)
-)
diff --git a/app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index f4036ddc..00000000
--- a/app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFFFFB5A0)
-    override val onPrimary = Color(0xFF850005)
-    override val primaryContainer = Color(0xFF872100)
-    override val onPrimaryContainer = Color(0xFFFFDAD5)
-    override val secondary = Color(0xFFE7B7AA)
-    override val onSecondary = Color(0xFF211D1C)
-    override val secondaryContainer = Color(0xFF49403E)
-    override val onSecondaryContainer = Color(0xFFF1DDD7)
-    override val tertiary = Color(0xFFE5BB93)
-    override val onTertiary = Color(0xFF3F2A04)
-    override val tertiaryContainer = Color(0xFFC05D33)
-    override val onTertiaryContainer = Color(0xFFFFD2AF)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF111111)
-    override val onBackground = Color(0xFFEDE0DE)
-    override val surface = Color(0xFF111111)
-    override val onSurface = Color(0xFFEDE0DE)
-    override val surfaceVariant = Color(0xFF534341)
-    override val onSurfaceVariant = Color(0xFFD8C2BF)
-    override val outline = Color(0xFFA08C8A)
-    override val outlineVariant = Color(0xFF534341)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFEDE0DE)
-    override val inverseOnSurface = Color(0xFF201A19)
-    override val inversePrimary = Color(0xFFB6241F)
-}
diff --git a/app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 959ea907..00000000
--- a/app/src/onprem/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-
-    override val primary = Color(0xFFAB251D)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFF7D1CF)
-    override val onPrimaryContainer = Color(0xFF410001)
-    override val secondary = Color(0xFF775652)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFFAE0DD)
-    override val onSecondaryContainer = Color(0xFF2C1512)
-    override val tertiary = Color(0xFF715b2e)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFFFF1D3)
-    override val onTertiaryContainer = Color(0xFF261A00)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFFFBFF)
-    override val onBackground = Color(0xFF201A19)
-    override val surface = Color(0xFFFFFBFF)
-    override val onSurface = Color(0xFF201A19)
-    override val surfaceVariant = Color(0xFFFBE9E7)
-    override val onSurfaceVariant = Color(0xFF534341)
-    override val outline = Color(0xFF857370)
-    override val outlineVariant = Color(0xFFf5ddda)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFEDE0DE)
-    override val inverseOnSurface = Color(0xFFFBEEEC)
-    override val inversePrimary = Color(0xFFFFB4AA)
-}
diff --git a/app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index e9c22620..00000000
--- a/app/src/onprem/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF4F1F1)
-)
diff --git a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index ebffc29b..00000000
--- a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFFA4C8FF)
-    override val onPrimary = Color(0xFF00315E)
-    override val primaryContainer = Color(0xFF004784)
-    override val onPrimaryContainer = Color(0xFFD4E3FF)
-    override val secondary = Color(0xFFBCC7DC)
-    override val onSecondary = Color(0xFF263141)
-    override val secondaryContainer = Color(0xFF3D434E)
-    override val onSecondaryContainer = Color(0xFFDAE1EF)
-    override val tertiary = Color(0xFFD9BDE2)
-    override val onTertiary = Color(0xFF3D2946)
-    override val tertiaryContainer = Color(0xFF543F5E)
-    override val onTertiaryContainer = Color(0xFFF6D9FF)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C1E)
-    override val onBackground = Color(0xFFE3E2E6)
-    override val surface = Color(0xFF1A1C1E)
-    override val onSurface = Color(0xFFE3E2E6)
-    override val surfaceVariant = Color(0xFF282E35)
-    override val onSurfaceVariant = Color(0xFFC3C6CF)
-    override val outline = Color(0xFF8D9199)
-    override val outlineVariant = Color(0xFF43474E)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE3E2E6)
-    override val inverseOnSurface = Color(0xFF1A1C1E)
-    override val inversePrimary = Color(0xFF005FAD)
-}
diff --git a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 1154bdb4..00000000
--- a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF005FAD)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFD4E3FF)
-    override val onPrimaryContainer = Color(0xFF001C3A)
-    override val secondary = Color(0xFF545F71)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE9F5FE)
-    override val onSecondaryContainer = Color(0xFF111C2B)
-    override val tertiary = Color(0xFF6D5676)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFF6D9FF)
-    override val onTertiaryContainer = Color(0xFF271430)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFDFCFF)
-    override val onBackground = Color(0xFF1A1C1E)
-    override val surface = Color(0xFFFDFCFF)
-    override val onSurface = Color(0xFF1A1C1E)
-    override val surfaceVariant = Color(0xFFE2EBF6)
-    override val onSurfaceVariant = Color(0xFF43474E)
-    override val outline = Color(0xFF73777F)
-    override val outlineVariant = Color(0xFFC3C6CF)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F3033)
-    override val inverseOnSurface = Color(0xFFF1F0F4)
-    override val inversePrimary = Color(0xFFA4C8FF)
-}
diff --git a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index 9c780b33..00000000
--- a/app/src/sandbox_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F2F2)
-)
diff --git a/app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index 1f22f96c..00000000
--- a/app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFF34C955)
-    override val onPrimary = Color(0xFF003910)
-    override val primaryContainer = Color(0xFF00531B)
-    override val onPrimaryContainer = Color(0xFFA2EDA8)
-    override val secondary = Color(0xFFB9CCB5)
-    override val onSecondary = Color(0xFF243424)
-    override val secondaryContainer = Color(0xFF444843)
-    override val onSecondaryContainer = Color(0xFFDFE9DD)
-    override val tertiary = Color(0xFFA1D1AB)
-    override val onTertiary = Color(0xFF003C1A)
-    override val tertiaryContainer = Color(0xFF1F4D53)
-    override val onTertiaryContainer = Color(0xFFBCEBF2)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C19)
-    override val onBackground = Color(0xFFE2E3DD)
-    override val surface = Color(0xFF1A1C19)
-    override val onSurface = Color(0xFFE2E3DD)
-    override val surfaceVariant = Color(0xFF203022)
-    override val onSurfaceVariant = Color(0xFFC2C9BD)
-    override val outline = Color(0xFF8C9389)
-    override val outlineVariant = Color(0xFF424940)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE2E3DD)
-    override val inverseOnSurface = Color(0xFF1A1C19)
-    override val inversePrimary = Color(0xFF006E26)
-}
diff --git a/app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 0a89c13f..00000000
--- a/app/src/store_google/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF05A63F)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFBCEECA)
-    override val onPrimaryContainer = Color(0xFF002106)
-    override val secondary = Color(0xFF526350)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE8F6EA)
-    override val onSecondaryContainer = Color(0xFF101F10)
-    override val tertiary = Color(0xFF04370E)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFBCEBF2)
-    override val onTertiaryContainer = Color(0xFF001F23)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFEFFFE)
-    override val onBackground = Color(0xFF1A1C19)
-    override val surface = Color(0xFFFEFFFE)
-    override val onSurface = Color(0xFF1A1C19)
-    override val surfaceVariant = Color(0xFFE0E4DD)
-    override val onSurfaceVariant = Color(0xFF424940)
-    override val outline = Color(0xFF72796F)
-    override val outlineVariant = Color(0xFFC4C8C1)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F312D)
-    override val inverseOnSurface = Color(0xFFF0F1EB)
-    override val inversePrimary = Color(0xFF009C32)
-}
diff --git a/app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index f5271acf..00000000
--- a/app/src/store_google/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F4F1)
-)
diff --git a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index ebffc29b..00000000
--- a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFFA4C8FF)
-    override val onPrimary = Color(0xFF00315E)
-    override val primaryContainer = Color(0xFF004784)
-    override val onPrimaryContainer = Color(0xFFD4E3FF)
-    override val secondary = Color(0xFFBCC7DC)
-    override val onSecondary = Color(0xFF263141)
-    override val secondaryContainer = Color(0xFF3D434E)
-    override val onSecondaryContainer = Color(0xFFDAE1EF)
-    override val tertiary = Color(0xFFD9BDE2)
-    override val onTertiary = Color(0xFF3D2946)
-    override val tertiaryContainer = Color(0xFF543F5E)
-    override val onTertiaryContainer = Color(0xFFF6D9FF)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C1E)
-    override val onBackground = Color(0xFFE3E2E6)
-    override val surface = Color(0xFF1A1C1E)
-    override val onSurface = Color(0xFFE3E2E6)
-    override val surfaceVariant = Color(0xFF282E35)
-    override val onSurfaceVariant = Color(0xFFC3C6CF)
-    override val outline = Color(0xFF8D9199)
-    override val outlineVariant = Color(0xFF43474E)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE3E2E6)
-    override val inverseOnSurface = Color(0xFF1A1C1E)
-    override val inversePrimary = Color(0xFF005FAD)
-}
diff --git a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 1154bdb4..00000000
--- a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF005FAD)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFD4E3FF)
-    override val onPrimaryContainer = Color(0xFF001C3A)
-    override val secondary = Color(0xFF545F71)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE9F5FE)
-    override val onSecondaryContainer = Color(0xFF111C2B)
-    override val tertiary = Color(0xFF6D5676)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFF6D9FF)
-    override val onTertiaryContainer = Color(0xFF271430)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFDFCFF)
-    override val onBackground = Color(0xFF1A1C1E)
-    override val surface = Color(0xFFFDFCFF)
-    override val onSurface = Color(0xFF1A1C1E)
-    override val surfaceVariant = Color(0xFFE2EBF6)
-    override val onSurfaceVariant = Color(0xFF43474E)
-    override val outline = Color(0xFF73777F)
-    override val outlineVariant = Color(0xFFC3C6CF)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F3033)
-    override val inverseOnSurface = Color(0xFFF1F0F4)
-    override val inversePrimary = Color(0xFFA4C8FF)
-}
diff --git a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index 9c780b33..00000000
--- a/app/src/store_google_work/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F2F2)
-)
diff --git a/app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsDark.kt b/app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsDark.kt
deleted file mode 100644
index 1f22f96c..00000000
--- a/app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsDark.kt
+++ /dev/null
@@ -1,56 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsDark : ComposeColorPaletteDark() {
-
-    override val primary = Color(0xFF34C955)
-    override val onPrimary = Color(0xFF003910)
-    override val primaryContainer = Color(0xFF00531B)
-    override val onPrimaryContainer = Color(0xFFA2EDA8)
-    override val secondary = Color(0xFFB9CCB5)
-    override val onSecondary = Color(0xFF243424)
-    override val secondaryContainer = Color(0xFF444843)
-    override val onSecondaryContainer = Color(0xFFDFE9DD)
-    override val tertiary = Color(0xFFA1D1AB)
-    override val onTertiary = Color(0xFF003C1A)
-    override val tertiaryContainer = Color(0xFF1F4D53)
-    override val onTertiaryContainer = Color(0xFFBCEBF2)
-    override val error = Color(0xFFFFB4AB)
-    override val onError = Color(0xFF690005)
-    override val errorContainer = Color(0xFF93000A)
-    override val onErrorContainer = Color(0xFFFFDAD6)
-    override val background = Color(0xFF1A1C19)
-    override val onBackground = Color(0xFFE2E3DD)
-    override val surface = Color(0xFF1A1C19)
-    override val onSurface = Color(0xFFE2E3DD)
-    override val surfaceVariant = Color(0xFF203022)
-    override val onSurfaceVariant = Color(0xFFC2C9BD)
-    override val outline = Color(0xFF8C9389)
-    override val outlineVariant = Color(0xFF424940)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFFE2E3DD)
-    override val inverseOnSurface = Color(0xFF1A1C19)
-    override val inversePrimary = Color(0xFF006E26)
-}
diff --git a/app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsLight.kt b/app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsLight.kt
deleted file mode 100644
index 0a89c13f..00000000
--- a/app/src/store_threema/java/ch/threema/app/compose/theme/color/ColorsLight.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-object ColorsLight : ComposeColorPaletteLight() {
-    override val primary = Color(0xFF05A63F)
-    override val onPrimary = Color(0xFFFFFFFF)
-    override val primaryContainer = Color(0xFFBCEECA)
-    override val onPrimaryContainer = Color(0xFF002106)
-    override val secondary = Color(0xFF526350)
-    override val onSecondary = Color(0xFFFFFFFF)
-    override val secondaryContainer = Color(0xFFE8F6EA)
-    override val onSecondaryContainer = Color(0xFF101F10)
-    override val tertiary = Color(0xFF04370E)
-    override val onTertiary = Color(0xFFFFFFFF)
-    override val tertiaryContainer = Color(0xFFBCEBF2)
-    override val onTertiaryContainer = Color(0xFF001F23)
-    override val error = Color(0xFFBA1A1A)
-    override val onError = Color(0xFFFFFFFF)
-    override val errorContainer = Color(0xFFFFDAD6)
-    override val onErrorContainer = Color(0xFF410002)
-    override val background = Color(0xFFFEFFFE)
-    override val onBackground = Color(0xFF1A1C19)
-    override val surface = Color(0xFFFEFFFE)
-    override val onSurface = Color(0xFF1A1C19)
-    override val surfaceVariant = Color(0xFFE0E4DD)
-    override val onSurfaceVariant = Color(0xFF424940)
-    override val outline = Color(0xFF72796F)
-    override val outlineVariant = Color(0xFFC4C8C1)
-    override val scrim = Color(0xFF000000)
-    override val inverseSurface = Color(0xFF2F312D)
-    override val inverseOnSurface = Color(0xFFF0F1EB)
-    override val inversePrimary = Color(0xFF009C32)
-}
diff --git a/app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt b/app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
deleted file mode 100644
index cde40085..00000000
--- a/app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsDark.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorDark = CustomColor(
-    messageBubbleContainerReceive = Color(0xFF666666)
-)
diff --git a/app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt b/app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
deleted file mode 100644
index f5271acf..00000000
--- a/app/src/store_threema/java/ch/threema/app/compose/theme/color/CustomColorsLight.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.compose.theme.color
-
-import androidx.compose.ui.graphics.Color
-
-val CustomColorLight = CustomColor(
-    messageBubbleContainerReceive = Color(0xFFF2F4F1)
-)
diff --git a/app/src/test/java/ch/threema/app/connection/CspD2mDualConnectionSupplierTest.kt b/app/src/test/java/ch/threema/app/connection/CspD2mDualConnectionSupplierTest.kt
deleted file mode 100644
index 67d602de..00000000
--- a/app/src/test/java/ch/threema/app/connection/CspD2mDualConnectionSupplierTest.kt
+++ /dev/null
@@ -1,124 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.connection
-
-import ch.threema.app.multidevice.MultiDeviceManager
-import ch.threema.app.services.ServerAddressProviderService
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.ServerConnection
-import ch.threema.domain.protocol.connection.csp.CspConnection
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-import ch.threema.domain.protocol.connection.d2m.D2mConnection
-import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseListener
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.TaskManager
-import java8.util.function.Supplier
-import okhttp3.OkHttpClient
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.mockito.Mockito
-
-class CspD2mDualConnectionSupplierTest {
-
-    @Test
-    fun testMdInactive() {
-        val connectionSupplier = createSupplier(MdActiveHandle())
-
-        val connection = connectionSupplier.get()
-        assertTrue(connection is CspConnection)
-        // subsequent call must return the same instance
-        assertTrue(connection === connectionSupplier.get())
-    }
-
-    @Test
-    fun testMdActive() {
-        val connectionSupplier = createSupplier(MdActiveHandle(true))
-
-        val connection = connectionSupplier.get()
-        assertTrue(connection is D2mConnection)
-        // subsequent call must return the same instance
-        assertTrue(connection === connectionSupplier.get())
-    }
-
-    @Test
-    fun testMdInactiveToggleActive() {
-        val handle = MdActiveHandle(false)
-        val connectionSupplier = createSupplier(handle)
-
-        assertTrue(connectionSupplier.get() is CspConnection)
-        handle.isMdActive = true
-        assertTrue(connectionSupplier.get() is D2mConnection)
-        handle.isMdActive = false
-        assertTrue(connectionSupplier.get() is CspConnection)
-    }
-
-    @Test
-    fun testMdActiveToggleInactive() {
-        val handle = MdActiveHandle(true)
-        val connectionSupplier = createSupplier(handle)
-
-        assertTrue(connectionSupplier.get() is D2mConnection)
-        handle.isMdActive = false
-        assertTrue(connectionSupplier.get() is CspConnection)
-        handle.isMdActive = true
-        assertTrue(connectionSupplier.get() is D2mConnection)
-    }
-
-
-    private fun createSupplier(mdActiveHandle: MdActiveHandle): Supplier<ServerConnection> {
-        val multiDeviceManager = Mockito.mock(MultiDeviceManager::class.java)
-        val propertiesProvider = Mockito.mock(MultiDevicePropertyProvider::class.java)
-        val socketCloseListener = Mockito.mock(D2mSocketCloseListener::class.java)
-        Mockito.`when`(multiDeviceManager.isMultiDeviceActive).thenAnswer { mdActiveHandle.isMdActive }
-        Mockito.`when`(multiDeviceManager.propertiesProvider).thenReturn(propertiesProvider)
-        Mockito.`when`(multiDeviceManager.socketCloseListener).thenReturn(socketCloseListener)
-        val incomingMessageProcessor = Mockito.mock(IncomingMessageProcessor::class.java)
-        val taskManager = Mockito.mock(TaskManager::class.java)
-        val deviceCookieManager = Mockito.mock(DeviceCookieManager::class.java)
-        val serverAddressProviderService = Mockito.mock(ServerAddressProviderService::class.java)
-        val serverAddressProvider = Mockito.mock(ServerAddressProvider::class.java)
-        Mockito.`when`(serverAddressProviderService.serverAddressProvider).thenReturn(serverAddressProvider)
-        val identityStore = Mockito.mock(IdentityStoreInterface::class.java)
-        val version = Version()
-        val isIpv6Preferred = true
-        val okhttpClientSupplier = Supplier { Mockito.mock(OkHttpClient::class.java) }
-        val isTestBuild = false
-
-        return CspD2mDualConnectionSupplier(
-            multiDeviceManager,
-            incomingMessageProcessor,
-            taskManager,
-            deviceCookieManager,
-            serverAddressProviderService,
-            identityStore,
-            version,
-            isIpv6Preferred,
-            okhttpClientSupplier,
-            isTestBuild
-        )
-    }
-
-    class MdActiveHandle(var isMdActive: Boolean = false)
-}
diff --git a/app/src/test/java/ch/threema/app/logging/ThreemaLoggerTest.kt b/app/src/test/java/ch/threema/app/logging/ThreemaLoggerTest.kt
deleted file mode 100644
index 418d6790..00000000
--- a/app/src/test/java/ch/threema/app/logging/ThreemaLoggerTest.kt
+++ /dev/null
@@ -1,146 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.logging
-
-import ch.threema.logging.ThreemaLogger
-import ch.threema.logging.backend.LogBackend
-import org.junit.Assert
-import org.junit.Test
-import java.lang.reflect.Constructor
-
-class ThreemaLoggerTest {
-
-    private val expectedThrowable = IllegalStateException()
-    private val throwableExpectingBackend = object : LogBackend {
-        override fun isEnabled(level: Int) = true
-
-        override fun print(level: Int, tag: String, throwable: Throwable?, message: String?) {
-            Assert.assertEquals(expectedThrowable, throwable)
-        }
-
-        override fun print(
-            level: Int,
-            tag: String,
-            throwable: Throwable?,
-            messageFormat: String,
-            vararg args: Any?,
-        ) {
-            Assert.assertEquals(expectedThrowable, throwable)
-        }
-    }
-    private val noThrowableExpectingBackend = object : LogBackend {
-        override fun isEnabled(level: Int) = true
-
-        override fun print(level: Int, tag: String, throwable: Throwable?, message: String?) {
-            Assert.assertNull(throwable)
-        }
-
-        override fun print(
-            level: Int,
-            tag: String,
-            throwable: Throwable?,
-            messageFormat: String,
-            vararg args: Any?,
-        ) {
-            Assert.assertNull(throwable)
-        }
-    }
-
-    private val throwableExpectingLogger: ThreemaLogger by lazy {
-        val loggerConstructor: Constructor<ThreemaLogger> =
-            ThreemaLogger::class.java.getDeclaredConstructor(String::class.java, LogBackend::class.java)
-        loggerConstructor.isAccessible = true
-        loggerConstructor.newInstance("ThreemaLoggerTest", throwableExpectingBackend)
-    }
-
-    private val noThrowableExpectingLogger: ThreemaLogger by lazy {
-        val loggerConstructor: Constructor<ThreemaLogger> =
-            ThreemaLogger::class.java.getDeclaredConstructor(String::class.java, LogBackend::class.java)
-        loggerConstructor.isAccessible = true
-        loggerConstructor.newInstance("ThreemaLoggerTest", noThrowableExpectingBackend)
-    }
-
-    @Test
-    fun testThrowableProvided() {
-        throwableExpectingLogger.trace("Trace", expectedThrowable)
-        throwableExpectingLogger.debug("Debug", expectedThrowable)
-        throwableExpectingLogger.info("Info", expectedThrowable)
-        throwableExpectingLogger.warn("Warn", expectedThrowable)
-        throwableExpectingLogger.error("Error", expectedThrowable)
-    }
-
-    @Test
-    fun testThrowableProvidedOneArg() {
-        throwableExpectingLogger.trace("Trace {}", "arg", expectedThrowable)
-        throwableExpectingLogger.debug("Debug {}", "arg", expectedThrowable)
-        throwableExpectingLogger.info("Info {}", "arg", expectedThrowable)
-        throwableExpectingLogger.warn("Warn {}", "arg", expectedThrowable)
-        throwableExpectingLogger.error("Error {}", "arg", expectedThrowable)
-    }
-
-    @Test
-    fun testThrowableProvidedTwoArg() {
-        throwableExpectingLogger.trace("Trace {} {}", "arg", "arg", expectedThrowable)
-        throwableExpectingLogger.debug("Debug {} {}", "arg", "arg", expectedThrowable)
-        throwableExpectingLogger.info("Info {} {}", "arg", "arg", expectedThrowable)
-        throwableExpectingLogger.warn("Warn {} {}", "arg", "arg", expectedThrowable)
-        throwableExpectingLogger.error("Error {} {}", "arg", "arg", expectedThrowable)
-    }
-
-    @Test
-    fun testNoThrowableProvided() {
-        noThrowableExpectingLogger.trace("Trace")
-        noThrowableExpectingLogger.debug("Debug")
-        noThrowableExpectingLogger.info("Info")
-        noThrowableExpectingLogger.warn("Warn")
-        noThrowableExpectingLogger.error("Error")
-    }
-
-    @Test
-    fun testNoThrowableProvidedOneArg() {
-        noThrowableExpectingLogger.trace("Trace {}", "arg")
-        noThrowableExpectingLogger.debug("Debug {}", "arg")
-        noThrowableExpectingLogger.info("Info {}", "arg")
-        noThrowableExpectingLogger.warn("Warn {}", "arg")
-        noThrowableExpectingLogger.error("Error {}", "arg")
-    }
-
-    @Test
-    fun testNoThrowableProvidedTwoArg() {
-        noThrowableExpectingLogger.trace("Trace {} {}", "arg", "arg")
-        noThrowableExpectingLogger.debug("Debug {} {}", "arg", "arg")
-        noThrowableExpectingLogger.info("Info {} {}", "arg", "arg")
-        noThrowableExpectingLogger.warn("Warn {} {}", "arg", "arg")
-        noThrowableExpectingLogger.error("Error {} {}", "arg", "arg")
-    }
-
-    @Test
-    fun testTwoThrowablesProvided() {
-        val unexpectedThrowable = IllegalArgumentException()
-        throwableExpectingLogger.trace("Trace {}", unexpectedThrowable, expectedThrowable)
-        throwableExpectingLogger.debug("Debug {}", unexpectedThrowable, expectedThrowable)
-        throwableExpectingLogger.info("Info {}", unexpectedThrowable, expectedThrowable)
-        throwableExpectingLogger.warn("Warn {}", unexpectedThrowable, expectedThrowable)
-        throwableExpectingLogger.error("Error {}", unexpectedThrowable, expectedThrowable)
-    }
-
-}
diff --git a/app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java b/app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java
deleted file mode 100644
index ad0547f8..00000000
--- a/app/src/test/java/ch/threema/app/threemasafe/ThreemaSafeServiceTest.java
+++ /dev/null
@@ -1,397 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.app.threemasafe;
-
-import android.content.Context;
-
-import org.apache.commons.lang3.LocaleUtils;
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.powermock.api.mockito.PowerMockito;
-import org.powermock.core.classloader.annotations.PowerMockIgnore;
-import org.powermock.modules.junit4.PowerMockRunner;
-
-import java.util.Arrays;
-import java.util.Date;
-import java.util.Locale;
-import java.util.TimeZone;
-
-import ch.threema.app.BuildConfig;
-import ch.threema.app.services.ApiService;
-import ch.threema.app.services.ContactService;
-import ch.threema.app.services.DeadlineListService;
-import ch.threema.app.services.DistributionListService;
-import ch.threema.app.services.FileService;
-import ch.threema.app.services.GroupService;
-import ch.threema.app.services.IdListService;
-import ch.threema.app.services.LocaleService;
-import ch.threema.app.services.PreferenceService;
-import ch.threema.app.services.UserService;
-import ch.threema.app.stores.IdentityStore;
-import ch.threema.app.stores.PreferenceStoreInterface;
-import ch.threema.base.utils.JSONUtil;
-import ch.threema.base.utils.Utils;
-import ch.threema.domain.models.GroupId;
-import ch.threema.domain.protocol.ServerAddressProvider;
-import ch.threema.domain.protocol.api.APIConnector;
-import ch.threema.storage.DatabaseServiceNew;
-import ch.threema.storage.models.ContactModel;
-import ch.threema.storage.models.DistributionListModel;
-import ch.threema.storage.models.GroupModel;
-
-import static ch.threema.testhelpers.TestHelpersKt.nonSecureRandomArray;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.doCallRealMethod;
-import static org.powermock.api.mockito.PowerMockito.when;
-
-@RunWith(PowerMockRunner.class)
-@PowerMockIgnore("javax.crypto.*")
-public class ThreemaSafeServiceTest {
-    @Mock
-    private Context contextMock;
-    @Mock
-    private PreferenceService preferenceServiceMock;
-    @Mock
-    private UserService userServiceMock;
-    @Mock
-    private ContactService contactServiceMock;
-    @Mock
-    private GroupService groupServiceMock;
-    @Mock
-    private DistributionListService distributionListServiceMock;
-    @Mock
-    private LocaleService localeServiceMock;
-    @Mock
-    private FileService fileServiceMock;
-    @Mock
-    private DatabaseServiceNew databaseServiceNewMock;
-    @Mock
-    private IdentityStore identityStoreMock;
-    @Mock
-    private ApiService apiService;
-    @Mock
-    private APIConnector apiConnectorMock;
-    @Mock
-    private IdListService profilePicRecipientsServiceMock;
-    @Mock
-    private IdListService blockedContactsServiceMock;
-    @Mock
-    private IdListService excludedSyncIdentitiesServiceMock;
-    @Mock
-    private DeadlineListService hiddenContactsListMock;
-    @Mock
-    private ServerAddressProvider serverAddressProviderMock;
-    @Mock
-    private PreferenceStoreInterface preferenceStoreMock;
-
-    // Test vector: Password "shootdeathstar" and salt "ECHOECHO" should result in this master key
-    private static final String MASTER_KEY_HEX = "066384d3695fbbd9f31a7d533900fd0cd8d1373beb6a28678522d2a49980c9c351c3d8d752fb6e1fd3199ead7f0895d6e3893ff691f2a5ee1976ed0897fc2f66";
-
-    // Test data
-    private static final byte[] TEST_PRIVATE_KEY_BYTES = {
-        1, 2, 3, 4, 5, 6, 7, 8,
-        100, 101, 102, 103, 104, 105, 106, 107,
-        1, 2, 3, 4, 5, 6, 7, 8,
-        100, 101, 102, 103, 104, 105, 106, 107,
-    };
-    private static final String TEST_PRIVATE_KEY_BASE64 = "AQIDBAUGBwhkZWZnaGlqawECAwQFBgcIZGVmZ2hpams=";
-    private Date testDate1, testDate2;
-    private long testDate1Timestamp, testDate2Timestamp;
-
-    private ThreemaSafeServiceImpl getServiceImpl() {
-        return new ThreemaSafeServiceImpl(
-            contextMock, preferenceServiceMock, userServiceMock,
-            contactServiceMock, groupServiceMock, distributionListServiceMock,
-            localeServiceMock, fileServiceMock,
-            blockedContactsServiceMock, excludedSyncIdentitiesServiceMock, profilePicRecipientsServiceMock,
-            databaseServiceNewMock, identityStoreMock, apiService, apiConnectorMock,
-            hiddenContactsListMock, serverAddressProviderMock, preferenceStoreMock
-        );
-    }
-
-    private ThreemaSafeService getService() {
-        return getServiceImpl();
-    }
-
-    @Before
-    public void prepareMocks() {
-        Locale.setDefault(LocaleUtils.toLocale("de_CH"));// Private key
-        Mockito.when(identityStoreMock.getPrivateKey()).thenReturn(TEST_PRIVATE_KEY_BYTES);
-
-        // Identity lists
-        Mockito.when(blockedContactsServiceMock.getAll()).thenReturn(new String[]{});
-        Mockito.when(excludedSyncIdentitiesServiceMock.getAll()).thenReturn(new String[]{});
-    }
-
-    @Before
-    public void prepareTestDates() {
-        // For these tests, we assume a timezone of Europe/Zurich (CET/CEST).
-        final TimeZone testTimeZone = TimeZone.getTimeZone("Europe/Zurich");
-        TimeZone.setDefault(testTimeZone);
-        Locale.setDefault(LocaleUtils.toLocale("de_CH"));
-
-        Locale.setDefault(LocaleUtils.toLocale("de_CH"));testDate1 = new Date(2020 - 1900, 11, 1, 13, 14, 15);
-        testDate2 = new Date(2021 - 1900, 11, 1, 13, 14, 15);
-        testDate1Timestamp = 1606824855000L;
-        testDate2Timestamp = 1638360855000L;
-    }
-
-    @Test
-    public void testDeriveMasterKey() {
-        final ThreemaSafeService service = PowerMockito.mock(ThreemaSafeServiceImpl.class);
-        doCallRealMethod().when(service).deriveMasterKey(any(String.class), any(String.class));
-
-        // Test case as defined in specification (see confluence)
-        final byte[] masterKey = service.deriveMasterKey("shootdeathstar", "ECHOECHO");
-        final String masterKeyHex = Utils.byteArrayToHexString(masterKey).toLowerCase();
-        Assert.assertEquals(
-            MASTER_KEY_HEX,
-            masterKeyHex
-        );
-    }
-
-    @Test
-    public void testGetThreemaSafeBackupIdNull() {
-        final ThreemaSafeService service = getService();
-
-        when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(null);
-        final byte[] backupId1 = service.getThreemaSafeBackupId();
-        Assert.assertNull(backupId1);
-
-        when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(new byte[0]);
-        final byte[] backupId2 = service.getThreemaSafeBackupId();
-        Assert.assertNull(backupId2);
-    }
-
-    @Test
-    public void testGetThreemaSafeBackupId() {
-        final ThreemaSafeService service = getService();
-        when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(Utils.hexStringToByteArray(MASTER_KEY_HEX));
-        final byte[] backupId = service.getThreemaSafeBackupId();
-        final String backupIdHex = Utils.byteArrayToHexString(backupId).toLowerCase();
-        Assert.assertEquals(
-            "066384d3695fbbd9f31a7d533900fd0cd8d1373beb6a28678522d2a49980c9c3",
-            backupIdHex
-        );
-    }
-
-    @Test
-    public void testGetThreemaSafeEncryptionKeyNull() {
-        final ThreemaSafeService service = getService();
-
-        when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(null);
-        final byte[] encryptionKey1 = service.getThreemaSafeEncryptionKey();
-        Assert.assertNull(encryptionKey1);
-
-        when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(new byte[0]);
-        final byte[] encryptionKey2 = service.getThreemaSafeEncryptionKey();
-        Assert.assertNull(encryptionKey2);
-    }
-
-    @Test
-    public void testGetThreemaSafeEncryptionKey() {
-        final ThreemaSafeService service = getService();
-        when(preferenceServiceMock.getThreemaSafeMasterKey()).thenReturn(Utils.hexStringToByteArray(MASTER_KEY_HEX));
-        final byte[] encryptionKey = service.getThreemaSafeEncryptionKey();
-        final String encryptionKeyHex = Utils.byteArrayToHexString(encryptionKey).toLowerCase();
-        Assert.assertEquals(
-            "51c3d8d752fb6e1fd3199ead7f0895d6e3893ff691f2a5ee1976ed0897fc2f66",
-            encryptionKeyHex
-        );
-    }
-
-    private JSONObject getParsedSafeJson(ThreemaSafeServiceImpl service) throws JSONException {
-        final String jsonString = service.getSafeJson();
-        Assert.assertNotNull(jsonString);
-        return new JSONObject(jsonString);
-    }
-
-    @Test
-    public void testSafeJsonInfo() throws Exception {
-        final JSONObject parsed = getParsedSafeJson(getServiceImpl());
-        final JSONObject info = parsed.getJSONObject("info");
-        Assert.assertEquals(
-            1,
-            info.getInt("version")
-        );
-        Assert.assertEquals(
-            BuildConfig.VERSION_NAME + "A/de_CH",
-            info.getString("device")
-        );
-    }
-
-    @Test
-    public void testSafeJsonUser() throws Exception {
-        final JSONObject parsed = getParsedSafeJson(getServiceImpl());
-        final JSONObject user = parsed.getJSONObject("user");
-        Assert.assertEquals(
-            TEST_PRIVATE_KEY_BASE64,
-            user.getString("privatekey")
-        );
-        final JSONArray links = user.getJSONArray("links");
-        Assert.assertEquals(0, links.length());
-    }
-
-    @Test
-    public void testSafeJsonContacts() throws Exception {
-        // Set up mocks
-        when(contactServiceMock.find(null)).thenReturn(Arrays.asList(
-            new ContactModel("HELLO123", nonSecureRandomArray(32)).setLastUpdate(null),
-            new ContactModel("HELLO234", nonSecureRandomArray(32)).setLastUpdate(testDate1),
-            new ContactModel("HELLO345", nonSecureRandomArray(32)).setLastUpdate(testDate2)
-        ));
-
-        // Generate and parse JSON
-        final JSONObject parsed = getParsedSafeJson(getServiceImpl());
-        final JSONArray contacts = parsed.getJSONArray("contacts");
-        Assert.assertEquals(
-            3,
-            contacts.length()
-        );
-
-        // Get contacts
-        final JSONObject contact1 = contacts.getJSONObject(0);
-        final JSONObject contact2 = contacts.getJSONObject(1);
-        final JSONObject contact3 = contacts.getJSONObject(2);
-
-        // Validate identity
-        Assert.assertEquals("HELLO123", contact1.getString("identity"));
-        Assert.assertEquals("HELLO234", contact2.getString("identity"));
-        Assert.assertEquals("HELLO345", contact3.getString("identity"));
-
-        // lastUpdate should be set correctly
-        Assert.assertFalse(contact1.has("lastUpdate"));
-        Assert.assertEquals(testDate1Timestamp, contact2.getLong("lastUpdate"));
-        Assert.assertEquals(testDate2Timestamp, contact3.getLong("lastUpdate"));
-    }
-
-    @Test
-    public void testSafeJsonGroups() throws Exception {
-        // Set up mocks
-        final GroupModel model1 = new GroupModel().setApiGroupId(new GroupId(1L)).setCreatorIdentity("GROUPER1").setLastUpdate(null);
-        final GroupModel model2 = new GroupModel().setApiGroupId(new GroupId(2L)).setCreatorIdentity("GROUPER2").setLastUpdate(testDate1);
-        final GroupModel model3 = new GroupModel().setApiGroupId(new GroupId(3L)).setCreatorIdentity("GROUPER3").setLastUpdate(testDate2);
-        when(groupServiceMock.getAll(any())).thenReturn(Arrays.asList(model1, model2, model3));
-        when(groupServiceMock.getGroupIdentities(model1)).thenReturn(new String[]{"GROUPER1", "MEMBER01"});
-        when(groupServiceMock.getGroupIdentities(model2)).thenReturn(new String[]{"GROUPER2"});
-        when(groupServiceMock.getGroupIdentities(model3)).thenReturn(new String[]{"GROUPER3", "MEMBER01", "MEMBER02"});
-
-        // Generate and parse JSON
-        final JSONObject parsed = getParsedSafeJson(getServiceImpl());
-        final JSONArray groups = parsed.getJSONArray("groups");
-        Assert.assertEquals(
-            3,
-            groups.length()
-        );
-
-        // Get groups
-        final JSONObject group1 = groups.getJSONObject(0);
-        final JSONObject group2 = groups.getJSONObject(1);
-        final JSONObject group3 = groups.getJSONObject(2);
-
-        // Validate group ID
-        Assert.assertEquals("0100000000000000", group1.getString("id"));
-        Assert.assertEquals("0200000000000000", group2.getString("id"));
-        Assert.assertEquals("0300000000000000", group3.getString("id"));
-
-        // Validate creator
-        Assert.assertEquals("GROUPER1", group1.getString("creator"));
-        Assert.assertEquals("GROUPER2", group2.getString("creator"));
-        Assert.assertEquals("GROUPER3", group3.getString("creator"));
-
-        // lastUpdate should be set correctly
-        // Note: Groups always have a "lastUpdate" timestamp! For compatibility reasons,
-        // if no date was set, then timestamp 0 is returned.
-        Assert.assertEquals(0L, group1.getLong("lastUpdate"));
-        Assert.assertEquals(testDate1Timestamp, group2.getLong("lastUpdate"));
-        Assert.assertEquals(testDate2Timestamp, group3.getLong("lastUpdate"));
-    }
-
-    @Test
-    public void testSafeJsonDistributionLists() throws Exception {
-        // Set up mocks
-        final DistributionListModel model1 = new DistributionListModel().setId(1L).setLastUpdate(null);
-        final DistributionListModel model2 = new DistributionListModel().setId(2L).setLastUpdate(testDate1);
-        final DistributionListModel model3 = new DistributionListModel().setId(3L).setLastUpdate(testDate2);
-        when(distributionListServiceMock.getAll(any())).thenReturn(Arrays.asList(model1, model2, model3));
-        when(distributionListServiceMock.getDistributionListIdentities(model1)).thenReturn(new String[]{"MEMBER11"});
-        when(distributionListServiceMock.getDistributionListIdentities(model2)).thenReturn(new String[]{"MEMBER21"});
-        when(distributionListServiceMock.getDistributionListIdentities(model3)).thenReturn(new String[]{"MEMBER31", "MEMBER32", "MEMBER33"});
-
-        // Generate and parse JSON
-        final JSONObject parsed = getParsedSafeJson(getServiceImpl());
-        final JSONArray distributionLists = parsed.getJSONArray("distributionlists");
-        Assert.assertEquals(
-            3,
-            distributionLists.length()
-        );
-
-        // Get distribution lists
-        final JSONObject distributionList1 = distributionLists.getJSONObject(0);
-        final JSONObject distributionList2 = distributionLists.getJSONObject(1);
-        final JSONObject distributionList3 = distributionLists.getJSONObject(2);
-
-        // Validate distribution list ID
-        Assert.assertEquals("0100000000000000", distributionList1.getString("id"));
-        Assert.assertEquals("0200000000000000", distributionList2.getString("id"));
-        Assert.assertEquals("0300000000000000", distributionList3.getString("id"));
-
-        // Validate members
-        Assert.assertArrayEquals(new String[]{"MEMBER11"}, JSONUtil.getStringArray(distributionList1.getJSONArray("members")));
-        Assert.assertArrayEquals(new String[]{"MEMBER21"}, JSONUtil.getStringArray(distributionList2.getJSONArray("members")));
-        Assert.assertArrayEquals(new String[]{"MEMBER31", "MEMBER32", "MEMBER33"}, JSONUtil.getStringArray(distributionList3.getJSONArray("members")));
-
-        // lastUpdate should be set correctly
-        // Note: Distribution lists always have a "lastUpdate" timestamp! For compatibility reasons,
-        // if no date was set, then timestamp 0 is returned.
-        Assert.assertEquals(0L, distributionList1.getLong("lastUpdate"));
-        Assert.assertEquals(testDate1Timestamp, distributionList2.getLong("lastUpdate"));
-        Assert.assertEquals(testDate2Timestamp, distributionList3.getLong("lastUpdate"));
-    }
-
-    @Test
-    public void testSafeJsonSettingBlockedContacts() throws Exception {
-        Mockito.when(blockedContactsServiceMock.getAll()).thenReturn(new String[]{"NONONONO", "BLOCKED0"});
-
-        final JSONObject parsed = getParsedSafeJson(getServiceImpl());
-        final JSONObject settings = parsed.getJSONObject("settings");
-        final JSONArray identities = settings.getJSONArray("blockedContacts");
-        Assert.assertArrayEquals(new String[]{"NONONONO", "BLOCKED0"}, JSONUtil.getStringArray(identities));
-    }
-
-    @Test
-    public void testSafeJsonSettingsSyncExcludedIds() throws Exception {
-        Mockito.when(excludedSyncIdentitiesServiceMock.getAll()).thenReturn(new String[]{"ECHOECHO", "OCHEOCHE"});
-
-        final JSONObject parsed = getParsedSafeJson(getServiceImpl());
-        final JSONObject settings = parsed.getJSONObject("settings");
-        final JSONArray identities = settings.getJSONArray("syncExcludedIds");
-        Assert.assertArrayEquals(new String[]{"ECHOECHO", "OCHEOCHE"}, JSONUtil.getStringArray(identities));
-    }
-}
diff --git a/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java b/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java
index 7253787d..117bd557 100644
--- a/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java
+++ b/app/src/test/java/ch/threema/app/utils/ContactUtilTest.java
@@ -87,8 +87,8 @@ public class ContactUtilTest {
 
 		// Preferences disabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(false);
-		// No contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(false);
+		// No contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(false);
 
 		// Normal contact, not linked
 		Assert.assertTrue(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
@@ -103,8 +103,8 @@ public class ContactUtilTest {
 
 		// Preferences disabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(false);
-		// Contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(true);
+		// Contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(true);
 
 		// Normal contact, not linked
 		Assert.assertTrue(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
@@ -119,8 +119,8 @@ public class ContactUtilTest {
 
 		// Preferences enabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(true);
-		// No contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(false);
+		// No contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(false);
 
 		// Normal contact, not linked
 		Assert.assertTrue(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
@@ -135,8 +135,8 @@ public class ContactUtilTest {
 
 		// Preferences enabled
 		when(preferenceServiceMock.getProfilePicReceive()).thenReturn(true);
-		// Contact photo defined
-		when(fileServiceMock.hasContactPhotoFile(any(String.class))).thenReturn(true);
+		// Contact defined profile picture set
+		when(fileServiceMock.hasContactDefinedProfilePicture(any(String.class))).thenReturn(true);
 
 		// Normal contact, not linked
 		Assert.assertFalse(ContactUtil.canChangeAvatar(createModel("ECHOECHO").setAndroidContactLookupKey(null), preferenceServiceMock, fileServiceMock));
diff --git a/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java b/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java
index 86192865..a0af1608 100644
--- a/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java
+++ b/app/src/test/java/ch/threema/app/utils/MessageUtilTest.java
@@ -75,7 +75,7 @@ public class MessageUtilTest  {
 	private GroupMessageModel groupMessageModelInbox;
 	private GroupMessageModel groupMessageModelOutbox;
 
-	private ServiceManager serviceManagerMock = mock(ServiceManager.class);
+	private final ServiceManager serviceManagerMock = mock(ServiceManager.class);
 
 	private DistributionListMessageModel distributionListMessageModelOutbox;
 
@@ -591,7 +591,7 @@ public class MessageUtilTest  {
 		when(distributionListService.getMembers(any())).thenReturn(contacts);
 
 		ContactService contactService = mock(ContactService.class);
-		when(contactService.createReceiver(any())).thenAnswer(invocation -> {
+		when(contactService.createReceiver((ContactModel) any())).thenAnswer(invocation -> {
 			ContactModel contactModel = invocation.getArgument(0, ContactModel.class);
 			return new ContactMessageReceiver(contactModel, null, serviceManagerMock, null, null, null);
 		});
diff --git a/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java b/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java
index 249c3168..3340d920 100644
--- a/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java
+++ b/app/src/test/java/ch/threema/app/voip/services/VoipStateServiceTest.java
@@ -140,7 +140,8 @@ public class VoipStateServiceTest {
 		);
 	}
 
-	@Test
+	/** @noinspection deprecation*/
+    @Test
 	public void callCounterIncrement() {
 		// Initially at 0
 		assertEquals(0, service.getCallState().getIncomingCallCounter());
@@ -240,7 +241,7 @@ public class VoipStateServiceTest {
 
 		// Handling should not change the state
 		assertTrue(service.getCallState().isIdle());
-		assertTrue(service.handleCallOffer(msg));
+		assertFalse(service.handleCallOffer(msg));
 		assertTrue(service.getCallState().isIdle());
 	}
 
@@ -255,7 +256,7 @@ public class VoipStateServiceTest {
 
 		// Handling should not change the state
 		assertTrue(service.getCallState().isIdle());
-		assertTrue(service.handleCallOffer(msg));
+		assertFalse(service.handleCallOffer(msg));
 		assertTrue(service.getCallState().isIdle());
 	}
 
@@ -335,7 +336,6 @@ public class VoipStateServiceTest {
 
 	/**
 	 * Reject a call while another call is active.
-	 *
 	 * The call ID in the reject message should correspond to the incoming call,
 	 * not to the current call.
 	 */
diff --git a/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java b/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java
index dddde446..33afefc4 100644
--- a/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java
+++ b/app/src/test/java/ch/threema/architecture/LayerDependenciesTest.java
@@ -43,8 +43,8 @@ import ch.threema.app.utils.ZipUtil;
 import ch.threema.app.utils.executor.HandlerExecutor;
 import ch.threema.logging.LoggerManager;
 import ch.threema.logging.backend.DebugLogFileBackend;
-import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.DatabaseNonceStore;
+import ch.threema.storage.DatabaseServiceNew;
 import ch.threema.storage.factories.BallotModelFactory;
 import ch.threema.storage.models.ConversationModel;
 import ch.threema.storage.models.data.media.FileDataModel;
@@ -61,7 +61,8 @@ import static ch.threema.architecture.ArchitectureDefinitions.getLayeredArchitec
 import static com.tngtech.archunit.core.domain.properties.HasName.Predicates.nameMatching;
 
 @RunWith(ArchUnitRunner.class)
-@AnalyzeClasses(packages = THREEMA_ROOT_PACKAGE, importOptions = {ArchitectureTestUtils.DoNotIncludeAndroidTests.class})
+@AnalyzeClasses(packages = THREEMA_ROOT_PACKAGE, importOptions =
+    {ArchitectureTestUtils.DoNotIncludeAndroidTests.class})
 public class LayerDependenciesTest {
     @ArchTest
     public static final ArchRule appLayerAccess = getLayeredArchitecture()
@@ -75,7 +76,7 @@ public class LayerDependenciesTest {
             nameMatching("ch\\.threema\\.storage\\..*"),
             nameMatching("ch\\.threema\\.app\\.utils\\..*")
         )
-        // Data layer may access listeners and utils
+        // Data layer may access listeners, utils, multi-device, and reflection tasks
         .ignoreDependency(
             nameMatching("ch\\.threema\\.data\\..*"),
             nameMatching("ch\\.threema\\.app\\.managers\\..*")
@@ -88,6 +89,14 @@ public class LayerDependenciesTest {
             nameMatching("ch\\.threema\\.data\\..*"),
             nameMatching("ch\\.threema\\.app\\.utils\\..*")
         )
+        .ignoreDependency(
+            nameMatching("ch\\.threema\\.data\\..*"),
+            nameMatching("ch\\.threema\\.app\\.multidevice\\..*")
+        )
+        .ignoreDependency(
+            nameMatching("ch\\.threema\\.data\\..*"),
+            nameMatching("ch\\.threema\\.app\\.tasks\\..*")
+        )
         .ignoreDependency(DatabaseServiceNew.class, DatabaseMigrationFailedException.class)
         .ignoreDependency(DatabaseServiceNew.class, DatabaseMigrationLockedException.class)
         .ignoreDependency(DatabaseNonceStore.class, DatabaseMigrationFailedException.class)
@@ -125,6 +134,7 @@ public class LayerDependenciesTest {
 
     @ArchTest
     public static final ArchRule baseLayerAccess = getLayeredArchitecture()
-        .whereLayer(BASE).mayOnlyBeAccessedByLayers(APP, DATA, STORAGE, LOCALCRYPTO, DOMAIN, LOGGING);
+        .whereLayer(BASE).mayOnlyBeAccessedByLayers(APP, DATA, STORAGE, LOCALCRYPTO, DOMAIN,
+            LOGGING);
 
 }
diff --git a/app/src/test/java/ch/threema/architecture/LayerTest.java b/app/src/test/java/ch/threema/architecture/LayerTest.java
index 37a258c3..0aabcb21 100644
--- a/app/src/test/java/ch/threema/architecture/LayerTest.java
+++ b/app/src/test/java/ch/threema/architecture/LayerTest.java
@@ -42,6 +42,7 @@ import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;
 @RunWith(ArchUnitRunner.class)
 @AnalyzeClasses(packages = THREEMA_ROOT_PACKAGE, importOptions = { ArchitectureTestUtils.DoNotIncludeAndroidTests.class })
 public class LayerTest {
+	/** @noinspection unused*/
 	@ArchTest
 	public static final ArchRule classesInPredefinedLayers = classes().should().resideInAnyPackage(
 		PACKAGE_ANNOTATION,
@@ -56,7 +57,8 @@ public class LayerTest {
 		"ch.threema.protobuf..",
 		"ch.threema.webrtc..",
 		"ch.threema.taskmanager..",
-		"ch.threema.testhelpers.."
+		"ch.threema.testhelpers..",
+		"ch.threema.libthreema.."
 	);
 
 }
diff --git a/app/src/test/java/ch/threema/data/ContactModelJavaTest.java b/app/src/test/java/ch/threema/data/ContactModelJavaTest.java
deleted file mode 100644
index df9d79e8..00000000
--- a/app/src/test/java/ch/threema/data/ContactModelJavaTest.java
+++ /dev/null
@@ -1,708 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.math.BigInteger;
-import java.util.Date;
-
-import ch.threema.app.services.PreferenceService;
-import ch.threema.data.models.ContactModel;
-import ch.threema.data.models.ContactModelData;
-import ch.threema.data.storage.DatabaseBackend;
-import ch.threema.domain.models.ContactSyncState;
-import ch.threema.domain.models.IdentityType;
-import ch.threema.domain.models.ReadReceiptPolicy;
-import ch.threema.domain.models.TypingIndicatorPolicy;
-import ch.threema.domain.models.VerificationLevel;
-import ch.threema.domain.models.WorkVerificationLevel;
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel;
-import ch.threema.storage.models.ContactModel.State;
-
-import static junit.framework.TestCase.assertEquals;
-import static junit.framework.TestCase.assertNull;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.fail;
-import static org.powermock.api.mockito.PowerMockito.mock;
-import static org.powermock.api.mockito.PowerMockito.verifyZeroInteractions;
-import static org.powermock.api.mockito.PowerMockito.when;
-
-public class ContactModelJavaTest {
-    private final DatabaseBackend databaseBackendMock = mock(DatabaseBackend.class);
-
-    private final PreferenceService preferenceServiceMock = mock(PreferenceService.class);
-
-    /**
-     * Test the construction using the primary constructor from Java.
-     */
-    @Test
-    public void testConstruction() {
-        final Date createdAt = new Date();
-        final byte[] publicKey = new byte[32];
-        final BigInteger largeBigInteger = new BigInteger("18446744073709551600");
-        final String identity = "TESTTEST";
-        final ContactModel contact = new ContactModel(identity, ContactModelData.javaCreate(
-            identity,
-            publicKey,
-            createdAt,
-            "Test",
-            "Contact",
-            null,
-            42,
-            VerificationLevel.SERVER_VERIFIED,
-            WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
-            IdentityType.NORMAL,
-            AcquaintanceLevel.DIRECT,
-            State.ACTIVE,
-            largeBigInteger,
-            ContactSyncState.CUSTOM,
-            ReadReceiptPolicy.DONT_SEND,
-            TypingIndicatorPolicy.SEND,
-            "asdf",
-            null,
-            false,
-            new byte[]{1, 2, 3},
-            null,
-            null
-        ), databaseBackendMock);
-
-        final ContactModelData data = contact.getData().getValue();
-        assertEquals("TESTTEST", data.identity);
-        assertEquals(publicKey, data.publicKey);
-        assertEquals("Test", data.firstName);
-        assertEquals("Contact", data.lastName);
-        assertNull(data.nickname);
-        assertEquals(42, data.colorIndexInt());
-        assertEquals(VerificationLevel.SERVER_VERIFIED, data.verificationLevel);
-        assertEquals(WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED, data.workVerificationLevel);
-        assertEquals(IdentityType.NORMAL, data.identityType);
-        assertEquals(AcquaintanceLevel.DIRECT, data.acquaintanceLevel);
-        assertEquals(State.ACTIVE, data.activityState);
-        assertEquals(largeBigInteger, data.featureMaskBigInteger());
-        try {
-            data.featureMaskLong();
-            fail("featureMaskLong did not throw");
-        } catch (IllegalArgumentException exception) {
-            assertEquals("Feature mask does not fit in a signed long", exception.getMessage());
-        }
-        assertEquals(ContactSyncState.CUSTOM, data.syncState);
-        assertEquals(ReadReceiptPolicy.DONT_SEND, data.readReceiptPolicy);
-        assertEquals(TypingIndicatorPolicy.SEND, data.typingIndicatorPolicy);
-        assertEquals("asdf", data.androidContactLookupKey);
-        assertNull(data.localAvatarExpires);
-        assertFalse(data.isRestored);
-        assertArrayEquals(new byte[]{1, 2, 3}, data.profilePictureBlobId);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_firstname_trimmed_1() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("  Firstname  ");
-        javaContactModel.setLastName("");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(true);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Firstname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_firstname_trimmed_2() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("  Firstname  ");
-        javaContactModel.setLastName("  ");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(false);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Firstname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_lastname_trimmed_1() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("  ");
-        javaContactModel.setLastName("  Lastname  ");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(true);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Lastname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_lastname_trimmed_2() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("  ");
-        javaContactModel.setLastName("  Lastname  ");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(false);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Lastname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_firstname_lastname() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("Firstname");
-        javaContactModel.setLastName("Lastname");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(true);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Firstname Lastname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_lastname_firstname() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("Firstname");
-        javaContactModel.setLastName("Lastname");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(false);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Lastname Firstname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_firstname_lastname_trimmed() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("  Firstname  ");
-        javaContactModel.setLastName("  Lastname  ");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(true);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Firstname Lastname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_lastname_firstname_trimmed() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("  Firstname  ");
-        javaContactModel.setLastName("  Lastname  ");
-        javaContactModel.setPublicNickName("");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(false);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Lastname Firstname", contactListItemTextTopLeft);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_value_first_lastname_over_nickname() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("Firstname");
-        javaContactModel.setLastName("Lastname");
-        javaContactModel.setPublicNickName("Nickname");
-
-        when(preferenceServiceMock.isContactFormatFirstNameLastName()).thenReturn(true);
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("Firstname Lastname", contactListItemTextTopLeft);
-        Assert.assertFalse(contactListItemTextTopLeft.contains("Nickname"));
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_nickname() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("");
-        javaContactModel.setLastName("");
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("~Nickname", contactListItemTextTopLeft);
-        verifyZeroInteractions(preferenceServiceMock);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_nickname_when_first_lastname_blank() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("   ");
-        javaContactModel.setLastName("   ");
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("~Nickname", contactListItemTextTopLeft);
-        verifyZeroInteractions(preferenceServiceMock);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_nickname_trimmed() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("");
-        javaContactModel.setLastName("");
-        javaContactModel.setPublicNickName("   Nickname   ");
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals("~Nickname", contactListItemTextTopLeft);
-        verifyZeroInteractions(preferenceServiceMock);
-    }
-
-    @Test
-    public void getContactListItemTextTopLeft_should_return_identity() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setFirstName("  ");
-        javaContactModel.setLastName("  ");
-        javaContactModel.setPublicNickName("  ");
-
-        // act
-        final String contactListItemTextTopLeft = javaContactModel.getContactListItemTextTopLeft(
-            preferenceServiceMock
-        );
-
-        // assert
-        Assert.assertEquals(identity, contactListItemTextTopLeft);
-        verifyZeroInteractions(preferenceServiceMock);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_return_job_title() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setJobTitle("Android Dev");
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals("Android Dev", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_not_return_job_title() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(false);
-        javaContactModel.setJobTitle("Android Dev");
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals( "~Nickname", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_return_job_title_trimmed() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setJobTitle("   Android Dev   ");
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals("Android Dev", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_return_nickname_1() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setJobTitle("");
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals("~Nickname", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_return_nickname_2() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setJobTitle("  ");
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals("~Nickname", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_return_nickname_3() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setJobTitle(null);
-        javaContactModel.setPublicNickName("Nickname");
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals("~Nickname", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_return_nickname_trimmed() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setJobTitle(null);
-        javaContactModel.setPublicNickName("  Nickname  ");
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals("~Nickname", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomLeft_should_return_empty() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setJobTitle(null);
-        javaContactModel.setPublicNickName(null);
-
-        // act
-        final String contactListItemTextBottomLeft = javaContactModel.getContactListItemTextBottomLeft();
-
-        // assert
-        Assert.assertEquals("", contactListItemTextBottomLeft);
-    }
-
-    @Test
-    public void getContactListItemTextBottomRight_should_return_department_trimmed() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setDepartment("  Android  ");
-
-        // act
-        final String contactListItemTextBottomRight = javaContactModel.getContactListItemTextBottomRight();
-
-        // assert
-        Assert.assertEquals("Android", contactListItemTextBottomRight);
-    }
-
-    @Test
-    public void getContactListItemTextBottomRight_should_not_return_department() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(false);
-        javaContactModel.setDepartment("Android");
-
-        // act
-        final String contactListItemTextBottomRight = javaContactModel.getContactListItemTextBottomRight();
-
-        // assert
-        Assert.assertEquals(identity, contactListItemTextBottomRight);
-    }
-
-    @Test
-    public void getContactListItemTextBottomRight_should_return_identity_1() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setDepartment(null);
-
-        // act
-        final String contactListItemTextBottomRight = javaContactModel.getContactListItemTextBottomRight();
-
-        // assert
-        Assert.assertEquals(identity, contactListItemTextBottomRight);
-    }
-
-    @Test
-    public void getContactListItemTextBottomRight_should_return_identity_2() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setDepartment("");
-
-        // act
-        final String contactListItemTextBottomRight = javaContactModel.getContactListItemTextBottomRight();
-
-        // assert
-        Assert.assertEquals(identity, contactListItemTextBottomRight);
-    }
-
-    @Test
-    public void getContactListItemTextBottomRight_should_return_identity_3() {
-
-        // arrange
-        final String identity = "IDENTITY";
-        final byte[] publicKey = new byte[32];
-        final ch.threema.storage.models.ContactModel javaContactModel = new ch.threema.storage.models.ContactModel(
-            identity,
-            publicKey
-        );
-        javaContactModel.setIsWork(true);
-        javaContactModel.setDepartment("  ");
-
-        // act
-        final String contactListItemTextBottomRight = javaContactModel.getContactListItemTextBottomRight();
-
-        // assert
-        Assert.assertEquals(identity, contactListItemTextBottomRight);
-    }
-}
diff --git a/app/src/test/java/ch/threema/data/ContactModelTest.kt b/app/src/test/java/ch/threema/data/ContactModelTest.kt
deleted file mode 100644
index 51e60e42..00000000
--- a/app/src/test/java/ch/threema/data/ContactModelTest.kt
+++ /dev/null
@@ -1,383 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data
-
-import android.text.format.DateUtils
-import ch.threema.app.listeners.ContactListener
-import ch.threema.app.managers.ListenerManager
-import ch.threema.data.models.ContactModel
-import ch.threema.data.models.ContactModelData
-import ch.threema.data.repositories.RepositoryToken
-import ch.threema.data.storage.DatabaseBackend
-import ch.threema.domain.models.ContactSyncState
-import ch.threema.domain.models.IdentityType
-import ch.threema.domain.models.ReadReceiptPolicy
-import ch.threema.domain.models.TypingIndicatorPolicy
-import ch.threema.domain.models.VerificationLevel
-import ch.threema.domain.models.WorkVerificationLevel
-import ch.threema.storage.models.ContactModel.AcquaintanceLevel
-import ch.threema.storage.models.ContactModel.State
-import org.junit.After
-import org.junit.Assert
-import org.junit.Assert.assertArrayEquals
-import org.junit.Before
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mockito.Mockito.verifyNoInteractions
-import org.powermock.api.mockito.PowerMockito
-import java.util.Date
-import kotlin.random.Random
-import kotlin.test.Test
-import kotlin.test.assertEquals
-import kotlin.test.assertFalse
-import kotlin.test.assertNotNull
-import kotlin.test.assertNull
-import kotlin.test.assertTrue
-import kotlin.test.fail
-
-// Used for testing, this is fine
-class TestRepositoryToken : RepositoryToken
-
-/**
- * Track calls to the contact listener.
- */
-private class ContactListenerTracker {
-    val onNew = mutableListOf<String>()
-    val onModified = mutableListOf<String>()
-    val onAvatarChanged = mutableListOf<ch.threema.storage.models.ContactModel?>()
-    val onRemoved = mutableListOf<String>()
-
-    val listener = object : ContactListener {
-        override fun onNew(identity: String) {
-            onNew.add(identity)
-        }
-
-        override fun onModified(identity: String) {
-            onModified.add(identity)
-        }
-
-        override fun onAvatarChanged(contactModel: ch.threema.storage.models.ContactModel?) {
-            onAvatarChanged.add(contactModel)
-        }
-
-        override fun onRemoved(identity: String) {
-            onRemoved.add(identity)
-        }
-    }
-
-    fun subscribe() {
-        ListenerManager.contactListeners.add(this.listener)
-    }
-
-    fun unsubscribe() {
-        ListenerManager.contactListeners.remove(this.listener)
-    }
-}
-
-class ContactModelTest {
-    private val databaseBackendMock = PowerMockito.mock(DatabaseBackend::class.java)
-
-    private lateinit var contactListenerTracker: ContactListenerTracker
-
-    private fun createTestContact(isRestored: Boolean = false): ContactModel {
-        val identity = "TESTTEST"
-        return ContactModel(
-            identity, ContactModelData(
-                identity,
-                Random.nextBytes(32),
-                Date(),
-                "Test",
-                "Contact",
-                null,
-                13u,
-                VerificationLevel.FULLY_VERIFIED,
-                WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
-                IdentityType.NORMAL,
-                AcquaintanceLevel.DIRECT,
-                State.ACTIVE,
-                ContactSyncState.INITIAL,
-                7uL,
-                ReadReceiptPolicy.DONT_SEND,
-                TypingIndicatorPolicy.SEND,
-                null,
-                null,
-                isRestored,
-                null,
-                null,
-                null,
-            ), databaseBackendMock
-        )
-    }
-
-    @Before
-    fun beforeEach() {
-        this.contactListenerTracker = ContactListenerTracker()
-        this.contactListenerTracker.subscribe()
-    }
-
-    @After
-    fun afterEach() {
-        this.contactListenerTracker.unsubscribe()
-    }
-
-    /**
-     * Test the construction using the primary constructor.
-     *
-     * Data is accessed through the `data` state flow.
-     */
-    @Test
-    fun testConstruction() {
-        val publicKey = Random.nextBytes(32)
-        val createdAt = Date()
-        val localAvatarExpires = Date()
-        val identity = "TESTTEST"
-        val contact = ContactModel(
-            identity, ContactModelData(
-                identity,
-                publicKey,
-                createdAt,
-                "Test",
-                "Contact",
-                null,
-                13u,
-                VerificationLevel.FULLY_VERIFIED,
-                WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED,
-                IdentityType.NORMAL,
-                AcquaintanceLevel.DIRECT,
-                State.ACTIVE,
-                ContactSyncState.INITIAL,
-                7uL,
-                ReadReceiptPolicy.SEND,
-                TypingIndicatorPolicy.DONT_SEND,
-                null,
-                localAvatarExpires,
-                true,
-                byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8),
-                null,
-                null,
-            ), databaseBackendMock
-        )
-
-        val value = contact.data.value!!
-        assertEquals("TESTTEST", value.identity)
-        assertEquals(publicKey, value.publicKey)
-        assertEquals(createdAt, value.createdAt)
-        assertEquals("Test", value.firstName)
-        assertEquals("Contact", value.lastName)
-        assertNull(value.nickname)
-        assertEquals(13u, value.colorIndex)
-        assertEquals(VerificationLevel.FULLY_VERIFIED, value.verificationLevel)
-        assertEquals(WorkVerificationLevel.WORK_SUBSCRIPTION_VERIFIED, value.workVerificationLevel)
-        assertEquals(IdentityType.NORMAL, value.identityType)
-        assertEquals(AcquaintanceLevel.DIRECT, value.acquaintanceLevel)
-        assertEquals(State.ACTIVE, value.activityState)
-        assertEquals(ContactSyncState.INITIAL, value.syncState)
-        assertEquals(7uL, value.featureMask)
-        assertEquals(ReadReceiptPolicy.SEND, value.readReceiptPolicy)
-        assertEquals(TypingIndicatorPolicy.DONT_SEND, value.typingIndicatorPolicy)
-        assertNull(value.androidContactLookupKey)
-        assertEquals(localAvatarExpires, value.localAvatarExpires)
-        assertTrue { value.isRestored }
-        assertArrayEquals(byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8), value.profilePictureBlobId)
-    }
-
-    @Test
-    fun testSetNickname() {
-        val contact = createTestContact()
-        assertEquals(null, contact.data.value!!.nickname)
-        assertEquals(0, contactListenerTracker.onModified.size)
-
-        // Setting nickname should update data and notify modification listeners
-        contact.setNicknameFromSync("nicky")
-        assertEquals("nicky", contact.data.value!!.nickname)
-        assertEquals(1, contactListenerTracker.onModified.size)
-
-        // Setting nickname again to the same value should not notify listeners
-        contact.setNicknameFromSync("nicky")
-        assertEquals("nicky", contact.data.value!!.nickname)
-        assertEquals(1, contactListenerTracker.onModified.size)
-
-        // Removing nickname should notify listeners
-        contact.setNicknameFromSync(null)
-        assertEquals(null, contact.data.value!!.nickname)
-        assertEquals(2, contactListenerTracker.onModified.size)
-
-        // All listeners should have been notified for our test contact
-        assertTrue("Contact listener onModified called for wrong identity") {
-            contactListenerTracker.onModified.all { it == contact.identity }
-        }
-    }
-
-    @Test
-    fun testDisplayName() {
-        val contact = createTestContact()
-        contact.setNicknameFromSync("nicky")
-
-        contact.setNameFromLocal("Test", "Contact")
-        assertEquals("Test Contact", contact.data.value!!.getDisplayName())
-
-        contact.setNameFromLocal("", "Lastname")
-        assertEquals("Lastname", contact.data.value!!.getDisplayName())
-
-        contact.setNameFromLocal("", "")
-        assertEquals("~nicky", contact.data.value!!.getDisplayName())
-
-        contact.setNicknameFromSync(null)
-        assertEquals(contact.data.value!!.identity, contact.data.value!!.getDisplayName())
-
-        contact.setNicknameFromSync(contact.data.value!!.identity)
-        assertEquals(contact.data.value!!.identity, contact.data.value!!.getDisplayName())
-    }
-
-    @Test
-    fun testConstructorValidateIdentity() {
-        val data = createTestContact().data.value!!.copy(identity = "AAAAAAAA")
-        Assert.assertThrows(AssertionError::class.java) {
-            ContactModel("BBBBBBBB", data, databaseBackendMock)
-        }
-    }
-
-    @Test
-    fun testDeleteIndirect() {
-        val contact = createTestContact()
-        assertNotNull(contact.data.value)
-
-        // Delete only model state, not database entry
-        contact.delete(TestRepositoryToken(), false)
-        assertNull(contact.data.value)
-
-        // No interaction with database backend should take place
-        verifyNoInteractions(databaseBackendMock)
-
-        // Listeners should not be called
-        assertEquals(0, contactListenerTracker.onRemoved.size)
-    }
-
-    @Test
-    fun testDeleteDirect() {
-        val contact = createTestContact()
-        assertNotNull(contact.data.value)
-
-        // Delete only model state, not database entry
-        contact.delete(TestRepositoryToken(), true)
-        assertNull(contact.data.value)
-
-        // Ensure that the contact was deleted from the database backend
-        verify(databaseBackendMock, times(1))
-            .deleteContactByIdentity(contact.identity)
-
-        assertEquals(1, contactListenerTracker.onRemoved.size)
-        assertEquals(contact.identity, contactListenerTracker.onRemoved[0])
-    }
-
-    @Test
-    fun testAndroidContactLookupKey() {
-        val contact = createTestContact()
-
-        assertEquals(0, contactListenerTracker.onModified.size)
-
-        contact.data.value!!.let {
-            assertNull(it.androidContactLookupKey)
-            assertFalse { it.isLinkedToAndroidContact() }
-        }
-
-        contact.setAndroidLookupKey("foo/bar")
-        contact.data.value!!.let {
-            assertEquals("foo/bar", it.androidContactLookupKey)
-            assertTrue { it.isLinkedToAndroidContact() }
-        }
-        assertEquals(1, contactListenerTracker.onModified.size)
-    }
-
-    @Test
-    fun testLocalAvatarExpires() {
-        val contact = createTestContact()
-
-        // Initially null
-        assertNull(contact.data.value!!.androidContactLookupKey)
-
-        // Set date
-        val inOneDay = Date(System.currentTimeMillis() + DateUtils.DAY_IN_MILLIS)
-        contact.setLocalAvatarExpires(inOneDay)
-        assertEquals(inOneDay.time, contact.data.value!!.localAvatarExpires?.time)
-        assertFalse(contact.data.value?.isAvatarExpired() ?: fail("No data"))
-
-        // Reset to null
-        contact.setLocalAvatarExpires(null)
-        assertNull(contact.data.value!!.androidContactLookupKey)
-        assertTrue(contact.data.value?.isAvatarExpired() ?: fail("No data"))
-
-        // Change listener not called
-        assertEquals(0, contactListenerTracker.onModified.size)
-    }
-
-    @Test
-    fun testClearIsRestored() {
-        val contact = createTestContact(isRestored = true)
-
-        // Initially true
-        assertTrue { contact.data.value!!.isRestored }
-
-        // Clear
-        contact.clearIsRestored()
-        assertFalse { contact.data.value!!.isRestored }
-
-        // Change listener not called
-        assertEquals(0, contactListenerTracker.onModified.size)
-    }
-
-    @Test
-    fun testSetProfilePictureBlobId() {
-        val contact = createTestContact()
-        assertEquals(null, contact.data.value!!.profilePictureBlobId)
-        assertEquals(0, contactListenerTracker.onModified.size)
-
-        // Setting blob ID should update data and notify modification listeners
-        contact.setProfilePictureBlobId(byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8))
-        assertArrayEquals(
-            byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8),
-            contact.data.value!!.profilePictureBlobId
-        )
-        assertEquals(1, contactListenerTracker.onModified.size)
-
-        // Setting blob ID again to the same value should not notify listeners
-        contact.setProfilePictureBlobId(byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8))
-        assertArrayEquals(
-            byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8),
-            contact.data.value!!.profilePictureBlobId
-        )
-        assertEquals(1, contactListenerTracker.onModified.size)
-
-        // Blob ID can be set to an empty array or to null
-        contact.setProfilePictureBlobId(byteArrayOf())
-        assertArrayEquals(byteArrayOf(), contact.data.value!!.profilePictureBlobId)
-        assertEquals(2, contactListenerTracker.onModified.size)
-        contact.setProfilePictureBlobId(null)
-        assertNull(contact.data.value!!.profilePictureBlobId)
-        assertEquals(3, contactListenerTracker.onModified.size)
-
-        // All listeners should have been notified for our test contact
-        assertTrue("Contact listener onModified called for wrong identity") {
-            contactListenerTracker.onModified.all { it == contact.identity }
-        }
-    }
-}
diff --git a/app/src/test/java/ch/threema/data/GroupModelJavaTest.java b/app/src/test/java/ch/threema/data/GroupModelJavaTest.java
deleted file mode 100644
index 76c83463..00000000
--- a/app/src/test/java/ch/threema/data/GroupModelJavaTest.java
+++ /dev/null
@@ -1,184 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data;
-
-import org.junit.Test;
-
-import java.util.Collections;
-import java.util.Date;
-import java.util.Set;
-
-import ch.threema.data.models.GroupIdentity;
-import ch.threema.data.models.GroupModel;
-import ch.threema.data.models.GroupModelData;
-import ch.threema.data.storage.DatabaseBackend;
-import ch.threema.domain.models.GroupId;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertThrows;
-import static org.powermock.api.mockito.PowerMockito.mock;
-
-public class GroupModelJavaTest {
-	private final DatabaseBackend databaseBackendMock = mock(DatabaseBackend.class);
-
-	@Test
-	public void testConstruction() {
-		final String creatorIdentity = "TESTTEST";
-		final GroupId groupId = new GroupId(42);
-		final String name = "Group";
-		final Date createdAt = new Date();
-		final Date synchronizedAt = new Date();
-		final Date lastUpdate = null;
-		final boolean deleted = false;
-		final boolean isArchived = false;
-		final int colorIndex = 0;
-		final String groupDesc = "Description";
-		final Date groupDescChangedAt = new Date();
-		final Set<String> members = Set.of("AAAAAAAA", "BBBBBBBB");
-
-		final GroupModel groupModel = new GroupModel(
-			new GroupIdentity(creatorIdentity, groupId.toLong()),
-			GroupModelData.javaCreate(
-				creatorIdentity,
-				groupId.toLong(),
-				name,
-				createdAt,
-				synchronizedAt,
-				lastUpdate,
-				deleted,
-				isArchived,
-				colorIndex,
-				groupDesc,
-				groupDescChangedAt,
-				members
-			),
-			databaseBackendMock
-		);
-
-		final GroupModelData value = groupModel.getData().getValue();
-		assertEquals("TESTTEST", value.groupIdentity.getCreatorIdentity());
-		assertEquals(groupId, new GroupId(value.groupIdentity.getGroupId()));
-		assertEquals(name, value.name);
-		assertEquals(createdAt, value.createdAt);
-		assertEquals(synchronizedAt, value.synchronizedAt);
-		assertEquals(lastUpdate, value.lastUpdate);
-		assertEquals(deleted, value.deleted);
-		assertEquals(isArchived, value.isArchived);
-		assertEquals(colorIndex, value.colorIndexInt());
-		assertEquals(groupDesc, value.groupDescription);
-		assertEquals(groupDescChangedAt, value.groupDescriptionChangedAt);
-		assertEquals(members, value.members);
-	}
-
-	@Test
-	public void testGroupIdentityByteArray() {
-		String identity = "TESTTEST";
-		assertArrayEquals(
-			new byte[]{-42, -1, -1, -1, -1, -1, -1, -1},
-			new GroupIdentity(identity, -42).getGroupIdByteArray()
-		);
-		assertArrayEquals(
-			new byte[]{-1, -1, -1, -1, -1, -1, -1, -1},
-			new GroupIdentity(identity, -1).getGroupIdByteArray()
-		);
-		assertArrayEquals(
-			new byte[]{0, 0, 0, 0, 0, 0, 0, 0},
-			new GroupIdentity(identity, 0).getGroupIdByteArray()
-		);
-		assertArrayEquals(
-			new byte[]{1, 0, 0, 0, 0, 0, 0, 0},
-			new GroupIdentity(identity, 1).getGroupIdByteArray()
-		);
-		assertArrayEquals(
-			new byte[]{42, 0, 0, 0, 0, 0, 0, 0},
-			new GroupIdentity(identity, 42).getGroupIdByteArray()
-		);
-		assertArrayEquals(
-			new byte[]{0, 0, 0, 0, 0, 0, 0, -128},
-			new GroupIdentity(identity, Long.MIN_VALUE).getGroupIdByteArray())
-		;
-		assertArrayEquals(
-			new byte[]{-1, -1, -1, -1, -1, -1, -1, 127},
-			new GroupIdentity(identity, Long.MAX_VALUE).getGroupIdByteArray()
-		);
-		assertArrayEquals(
-			new byte[]{78, -88, 120, -3, -1, -1, -1, -1},
-			new GroupIdentity(identity, -42424242).getGroupIdByteArray()
-		);
-		assertArrayEquals(
-			new byte[]{-78, 87, -121, 2, 0, 0, 0, 0},
-			new GroupIdentity(identity, 42424242).getGroupIdByteArray()
-		);
-	}
-
-	@Test
-	public void testColorIndexRange() {
-		assertValidColorIndex(0);
-		assertValidColorIndex(42);
-		assertValidColorIndex(254);
-		assertValidColorIndex(255);
-
-		assertInvalidColorIndex(Integer.MIN_VALUE);
-		assertInvalidColorIndex(-1);
-		assertInvalidColorIndex(256);
-		assertInvalidColorIndex(Integer.MAX_VALUE);
-	}
-
-	private void assertValidColorIndex(int colorIndex) {
-		GroupModelData.javaCreate(
-			"",
-			42,
-			"Group",
-			new Date(),
-			new Date(),
-			null,
-			false,
-			false,
-			colorIndex,
-			"Description",
-			new Date(),
-			Collections.emptySet()
-		);
-	}
-
-	private void assertInvalidColorIndex(int colorIndex) {
-		assertThrows(
-			IllegalArgumentException.class,
-			() -> GroupModelData.javaCreate(
-				"",
-				42,
-				"Group",
-				new Date(),
-				new Date(),
-				null,
-				false,
-				false,
-				colorIndex,
-				"Description",
-				new Date(),
-				Collections.emptySet()
-			)
-		);
-	}
-
-}
diff --git a/app/src/test/java/ch/threema/data/GroupModelTest.kt b/app/src/test/java/ch/threema/data/GroupModelTest.kt
deleted file mode 100644
index 42b4e49b..00000000
--- a/app/src/test/java/ch/threema/data/GroupModelTest.kt
+++ /dev/null
@@ -1,180 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data
-
-import ch.threema.data.models.GroupIdentity
-import ch.threema.data.models.GroupModel
-import ch.threema.data.models.GroupModelData
-import ch.threema.data.storage.DatabaseBackend
-import org.junit.Assert
-import org.junit.Assert.assertArrayEquals
-import org.powermock.api.mockito.PowerMockito
-import java.util.Date
-import kotlin.test.Test
-import kotlin.test.assertEquals
-
-class GroupModelTest {
-    private val databaseBackendMock = PowerMockito.mock(DatabaseBackend::class.java)
-
-    private fun createTestGroup(): GroupModel {
-        val groupIdentity = GroupIdentity("TESTTEST", 42)
-        val members = setOf("AAAAAAAA", "BBBBBBBB")
-        return GroupModel(
-            groupIdentity,
-            GroupModelData(
-                groupIdentity,
-                "Group",
-                Date(),
-                Date(),
-                null,
-                deleted = false,
-                isArchived = false,
-                0.toUByte(),
-                "Description",
-                Date(),
-                members,
-            ),
-            databaseBackendMock
-        )
-    }
-
-    @Test
-    fun testGroupIdentityToHexString() {
-        val identity = "TESTTEST"
-        assertEquals("d6ffffffffffffff", GroupIdentity(identity, -42).groupIdHexString)
-        assertEquals("ffffffffffffffff", GroupIdentity(identity, -1).groupIdHexString)
-        assertEquals("0000000000000000", GroupIdentity(identity, 0).groupIdHexString)
-        assertEquals("0100000000000000", GroupIdentity(identity, 1).groupIdHexString)
-        assertEquals("2a00000000000000", GroupIdentity(identity, 42).groupIdHexString)
-        assertEquals("0000000000000080", GroupIdentity(identity, Long.MIN_VALUE).groupIdHexString)
-        assertEquals("ffffffffffffff7f", GroupIdentity(identity, Long.MAX_VALUE).groupIdHexString)
-        assertEquals("4ea878fdffffffff", GroupIdentity(identity, -42424242).groupIdHexString)
-        assertEquals("b257870200000000", GroupIdentity(identity, 42424242).groupIdHexString)
-    }
-
-    @Test
-    fun testGroupIdentityToByteArray() {
-        val identity = "TESTTEST"
-        assertArrayEquals(byteArrayOf(-42, -1, -1, -1, -1, -1, -1, -1), GroupIdentity(identity, -42).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(-1, -1, -1, -1, -1, -1, -1, -1), GroupIdentity(identity, -1).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(0, 0, 0, 0, 0, 0, 0, 0), GroupIdentity(identity, 0).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(1, 0, 0, 0, 0, 0, 0, 0), GroupIdentity(identity, 1).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(42, 0, 0, 0, 0, 0, 0, 0), GroupIdentity(identity, 42).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(0, 0, 0, 0, 0, 0, 0, -128), GroupIdentity(identity, Long.MIN_VALUE).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(-1, -1, -1, -1, -1, -1, -1, 127), GroupIdentity(identity, Long.MAX_VALUE).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(78, -88, 120, -3, -1, -1, -1, -1), GroupIdentity(identity, -42424242).groupIdByteArray)
-        assertArrayEquals(byteArrayOf(-78, 87, -121, 2, 0, 0, 0, 0), GroupIdentity(identity, 42424242).groupIdByteArray)
-    }
-
-    /**
-     * Test the construction using the primary constructor.
-     *
-     * Data is accessed through the `data` state flow.
-     */
-    @Test
-    fun testConstruction() {
-        val groupIdentity = GroupIdentity("TESTTEST", 42)
-        val name = "Group"
-        val createdAt = Date()
-        val synchronizedAt = Date()
-        val lastUpdate = null
-        val deleted = false
-        val isArchived = false
-        val colorIndex = 0.toUByte()
-        val groupDesc = "Description"
-        val groupDescChangedAt = Date()
-        val members = setOf("AAAAAAAA", "BBBBBBBB")
-        val group = GroupModel(
-            groupIdentity,
-            GroupModelData(
-                groupIdentity,
-                name,
-                createdAt,
-                synchronizedAt,
-                lastUpdate,
-                deleted,
-                isArchived,
-                colorIndex,
-                groupDesc,
-                groupDescChangedAt,
-                members,
-            ), databaseBackendMock
-        )
-
-        val value = group.data.value!!
-        assertEquals(groupIdentity, value.groupIdentity)
-        assertEquals(name, value.name)
-        assertEquals(createdAt, value.createdAt)
-        assertEquals(synchronizedAt, value.synchronizedAt)
-        assertEquals(lastUpdate, value.lastUpdate)
-        assertEquals(deleted, value.deleted)
-        assertEquals(isArchived, value.isArchived)
-        assertEquals(colorIndex, value.colorIndex)
-        assertEquals(groupDesc, value.groupDescription)
-        assertEquals(groupDescChangedAt, value.groupDescriptionChangedAt)
-        assertEquals(members, value.members)
-    }
-
-    @Test
-    fun testConstructorValidGroupIdentity() {
-        val data = createTestGroup().data.value!!.copy(
-            groupIdentity = GroupIdentity("AAAAAAAA", 42)
-        )
-        val model = GroupModel(
-            // The same identity but different object is provided
-            GroupIdentity("AAAAAAAA", 42),
-            data,
-            databaseBackendMock
-        )
-
-        assertEquals("AAAAAAAA", model.groupIdentity.creatorIdentity)
-        assertEquals(42, model.groupIdentity.groupId)
-    }
-
-    @Test
-    fun testConstructorValidateCreatorIdentity() {
-        val testData = createTestGroup().data.value!!
-        val groupIdentity = GroupIdentity("AAAAAAAA", 42)
-        val data = testData.copy(groupIdentity = groupIdentity)
-        Assert.assertThrows(AssertionError::class.java) {
-            GroupModel(
-                data.groupIdentity.copy(creatorIdentity = "BBBBBBBB"),
-                data,
-                databaseBackendMock
-            )
-        }
-    }
-
-    @Test
-    fun testConstructorValidateGroupId() {
-        val testData = createTestGroup().data.value!!
-        val groupIdentity = GroupIdentity("AAAAAAAA", 42)
-        val data = testData.copy(groupIdentity = groupIdentity)
-        Assert.assertThrows(AssertionError::class.java) {
-            GroupModel(
-                data.groupIdentity.copy(groupId = 0),
-                data,
-                databaseBackendMock
-            )
-        }
-    }
-}
diff --git a/app/src/test/java/ch/threema/data/WeakValueMapTest.kt b/app/src/test/java/ch/threema/data/WeakValueMapTest.kt
deleted file mode 100644
index 2fc53b6f..00000000
--- a/app/src/test/java/ch/threema/data/WeakValueMapTest.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.data
-
-import org.junit.Assert
-import java.util.Date
-import kotlin.test.Test
-
-class WeakValueMapTest {
-    @Test
-    fun testReferences() {
-        val map = WeakValueMap<String, Date>()
-        val date1 = map.getOrCreate("hello") { Date() }
-        val date2 = map.getOrCreate("hello") { Date() }
-        val date3 = map.getOrCreate("world") { Date() }
-        Assert.assertSame(date1, date2)
-        Assert.assertNotSame(date1, date3)
-        Assert.assertSame(date1, map.get("hello"))
-        Assert.assertSame(date3, map.get("world"))
-        Assert.assertNull(map.get("something-else"))
-    }
-
-    @Test
-    fun testMissNull() {
-        val map = WeakValueMap<String, String>()
-        val string1 = map.getOrCreate("hello") { "guten tag!" }
-        val string2 = map.getOrCreate("not-found") { null }
-        Assert.assertEquals("guten tag!", string1)
-        Assert.assertNull(string2)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/base/concurrent/TrulySingleThreadExecutorThreadFactory.kt b/domain/src/main/java/ch/threema/base/concurrent/TrulySingleThreadExecutorThreadFactory.kt
deleted file mode 100644
index 5b1e3d88..00000000
--- a/domain/src/main/java/ch/threema/base/concurrent/TrulySingleThreadExecutorThreadFactory.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.concurrent
-
-import ch.threema.base.utils.LoggingUtil
-import java.util.concurrent.ThreadFactory
-
-private val logger = LoggingUtil.getThreemaLogger("TrulySingleThreadExecutorThreadFactory")
-
-class TrulySingleThreadExecutorThreadFactory(
-    val name: String,
-    val created: (Thread) -> Unit,
-) : ThreadFactory {
-    var thread: Thread? = null
-
-    override fun newThread(runnable: Runnable): Thread {
-        thread?.also {
-            logger.error("Thread '{}' was already created", it.name)
-        }
-        return Thread(runnable, name).also {
-            thread = it
-            created(it)
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/base/crypto/NonceFactory.java b/domain/src/main/java/ch/threema/base/crypto/NonceFactory.java
deleted file mode 100644
index 6c2d6571..00000000
--- a/domain/src/main/java/ch/threema/base/crypto/NonceFactory.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.crypto;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.ThreemaException;
-import com.neilalexander.jnacl.NaCl;
-
-import java.security.SecureRandom;
-import java.util.List;
-
-/**
- * Interface for identity stores.
- */
-final public class NonceFactory {
-	private final SecureRandom secureRandom;
-	private final NonceStore nonceStore;
-
-	public NonceFactory(NonceStore nonceStore) {
-		this(new SecureRandom(), nonceStore);
-	}
-	public NonceFactory(SecureRandom secureRandom,
-						NonceStore nonceStore) {
-		this.secureRandom = secureRandom;
-		this.nonceStore = nonceStore;
-	}
-
-	/**
-	 * Create the next unique nonce
-	 * @return nonce
-	 */
-	public synchronized byte[] next() throws ThreemaException {
-		return this.next(true);
-	}
-
-	/**
-	 * Create the next unique nonce
-	 * @param save
-	 * @return nonce
-	 */
-	public synchronized byte[] next(boolean save) {
-		byte[] nonce = new byte[NaCl.NONCEBYTES];
-		boolean success;
-		do {
-			this.secureRandom.nextBytes(nonce);
-			// The nonce has been created successfully if it does not exist yet.
-			if (save) {
-				success = this.store(nonce);
-			} else {
-				success = !this.exists(nonce);
-			}
-		} while(!success);
-
-		return nonce;
-	}
-
-	/**
-	 * Store the nonce into the nonce store
-	 * @param nonce
-	 * @return
-	 */
-	public synchronized boolean store(byte[] nonce) {
-		return this.nonceStore.store(nonce);
-	}
-
-	/**
-	 * Return true if the given nonce already exists
-	 *
-	 * @param nonce
-	 * @return
-	 */
-	public boolean exists(byte[] nonce) {
-		return this.nonceStore.exists(nonce);
-	}
-
-	@NonNull
-	public List<byte[]> getAllHashedNonces() {
-		return this.nonceStore.getAllHashedNonces();
-	}
-}
diff --git a/domain/src/main/java/ch/threema/base/crypto/NonceStore.java b/domain/src/main/java/ch/threema/base/crypto/NonceStore.java
deleted file mode 100644
index e47666e2..00000000
--- a/domain/src/main/java/ch/threema/base/crypto/NonceStore.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.crypto;
-
-import java.util.List;
-
-import androidx.annotation.NonNull;
-
-public interface NonceStore {
-	/**
-	 * Return true if the given nonce already exists
-	 *
-	 * @param nonce The nonce bytes
-	 */
-	boolean exists(@NonNull byte[] nonce);
-
-	/**
-	 * Store a nonce
-	 *
-	 * @param nonce The nonce bytes
-	 * @return return true if the nonce was added, false if the nonce already existed
-	 */
-	boolean store(@NonNull byte[] nonce);
-
-	/**
-	 * @return all hashed nonces that are present in this store.
-	 */
-	@NonNull
-	List<byte[]> getAllHashedNonces();
-}
diff --git a/domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt b/domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt
deleted file mode 100644
index 2ed4c488..00000000
--- a/domain/src/main/java/ch/threema/base/utils/ByteArrayUtils.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.utils
-
-/**
- * Returns a string representation of this [ByteArray] with lowercase hex characters.
- *
- * @param maxBytes if set to a positive value smaller than the size of the array only [maxBytes] bytes
- *  will be visible in the string representation followed by an ellipse character.
- */
-fun ByteArray.toHexString(maxBytes: Int = 0): String {
-    return if (maxBytes in 1 until size) {
-        val bytes = copyOfRange(0, maxBytes)
-        // 0x2026: Horizontal ellipsis
-        "${Utils.byteArrayToHexString(bytes)}${Char(0x2026)}"
-    } else {
-        Utils.byteArrayToHexString(this)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/base/utils/SecureRandomUtil.kt b/domain/src/main/java/ch/threema/base/utils/SecureRandomUtil.kt
deleted file mode 100644
index ff1e3d53..00000000
--- a/domain/src/main/java/ch/threema/base/utils/SecureRandomUtil.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.utils
-
-import com.google.protobuf.ByteString
-import java.security.SecureRandom
-
-object SecureRandomUtil {
-    private val secureRandom: SecureRandom by lazy { SecureRandom() }
-
-    /**
-     * Creates between 0 (inclusive) and 256 (exclusive) bytes of PKCS#7 style padding.
-     * Each byte of the padding has the length of the padding as value.
-     */
-    private fun generateRandomPadding(): ByteArray {
-        val paddingLength = secureRandom.nextInt(256)
-        val paddingValue = paddingLength.toByte()
-        return ByteArray(paddingLength) { paddingValue }
-    }
-
-    /**
-     * Create random padding as described in [generateRandomPadding] and wraps
-     * it in a protobuf [ByteString].
-     */
-    fun generateRandomProtobufPadding(): ByteString {
-        return ByteString.copyFrom(generateRandomPadding())
-    }
-
-    /**
-     * @return [length] random bytes.
-     */
-    fun generateRandomBytes(length: Int): ByteArray {
-        val bytes = ByteArray(length)
-        secureRandom.nextBytes(bytes)
-        return bytes
-    }
-
-    fun generateRandomU64(): ULong {
-        return secureRandom.nextLong().toULong()
-    }
-}
diff --git a/domain/src/main/java/ch/threema/base/utils/TimeMeasureUtil.kt b/domain/src/main/java/ch/threema/base/utils/TimeMeasureUtil.kt
deleted file mode 100644
index d9a32c3e..00000000
--- a/domain/src/main/java/ch/threema/base/utils/TimeMeasureUtil.kt
+++ /dev/null
@@ -1,42 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.utils
-
-import java.util.Date
-
-class TimeMeasureUtil {
-    private var tStart = Date()
-    private var tStop: Date? = null
-
-    val elapsedTime
-        get() = (tStop ?: Date()).time - tStart.time
-
-    fun start() {
-        tStop = null
-        tStart = Date()
-    }
-
-    fun stop(): Long {
-        tStop = Date()
-        return elapsedTime
-    }
-}
diff --git a/domain/src/main/java/ch/threema/base/utils/UnsignedHelper.java b/domain/src/main/java/ch/threema/base/utils/UnsignedHelper.java
deleted file mode 100644
index 2603a1f4..00000000
--- a/domain/src/main/java/ch/threema/base/utils/UnsignedHelper.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.utils;
-
-import java.math.BigInteger;
-
-public class UnsignedHelper {
-	/**
-	 * Convert a signed int to an unsigned long.
-	 */
-	public static long getUnsignedInt(int val) {
-		return val & 0x00000000ffffffffL;
-	}
-
-	/**
-	 * Convert a "unsigned" long to a BigInteger.
-	 */
-	public static BigInteger unsignedLongToBigInteger(long val) {
-		if (val >= 0L) {
-			return BigInteger.valueOf(val);
-		} else {
-			int upper = (int) (val >>> 32);
-			int lower = (int) val;
-			return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32).
-				add(BigInteger.valueOf(Integer.toUnsignedLong(lower)));
-		}
-	}
-}
diff --git a/domain/src/main/java/ch/threema/base/utils/Utils.java b/domain/src/main/java/ch/threema/base/utils/Utils.java
index 3148ead4..ed5cb1af 100644
--- a/domain/src/main/java/ch/threema/base/utils/Utils.java
+++ b/domain/src/main/java/ch/threema/base/utils/Utils.java
@@ -113,6 +113,14 @@ public class Utils {
 		return ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN).getLong();
 	}
 
+	public static @NonNull byte[] shortToByteArrayLittleEndian(short value) {
+		return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(value).array();
+	}
+
+	public static @NonNull byte[] intToByteArrayLittleEndian(int value) {
+		return ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
+	}
+
 	public static @NonNull byte[] longToByteArrayLittleEndian(long value) {
 		return ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(value).array();
 	}
diff --git a/domain/src/main/java/ch/threema/domain/models/AppVersion.java b/domain/src/main/java/ch/threema/domain/models/AppVersion.java
index 558926fa..4254ca29 100644
--- a/domain/src/main/java/ch/threema/domain/models/AppVersion.java
+++ b/domain/src/main/java/ch/threema/domain/models/AppVersion.java
@@ -50,11 +50,16 @@ public class AppVersion extends Version {
 		this.appSystemVersion = appSystemVersion;
 	}
 
+	@Override
+	public String getVersionNumber() {
+		return appVersionNumber;
+	}
+
 	/**
 	 * Return the short version: Version;PlatformCode
 	 */
 	@Override
-	public String getVersion() {
+	public String getVersionString() {
 		return appVersionNumber + appPlatformCode;
 	}
 
@@ -64,7 +69,7 @@ public class AppVersion extends Version {
 	 * Format: `<app-version>;<platform>;<lang>/<country-code>;<device-model>;<os-version>`
 	 */
 	@Override
-	public String getFullVersion() {
+	public String getFullVersionString() {
 		return appVersionNumber.replace(";", "_") + ";"
 			+ appPlatformCode.replace(";", "_") + ";"
 			+ appLanguage.replace(";", "_") + "/"
diff --git a/domain/src/main/java/ch/threema/domain/models/Contact.kt b/domain/src/main/java/ch/threema/domain/models/Contact.kt
deleted file mode 100644
index b3cd72f7..00000000
--- a/domain/src/main/java/ch/threema/domain/models/Contact.kt
+++ /dev/null
@@ -1,150 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.models
-
-import ch.threema.base.utils.Utils
-import java.util.Objects
-
-const val CONTACT_NAME_MAX_LENGTH_BYTES = 256
-
-/**
- * Base class for contacts.
- */
-open class Contact(
-    val identity: String,
-    val publicKey: ByteArray,
-    @JvmField var verificationLevel: VerificationLevel = VerificationLevel.UNVERIFIED,
-) {
-    var firstName: String? = null
-        set(value) {
-            field = Utils.truncateUTF8String(value, CONTACT_NAME_MAX_LENGTH_BYTES)
-        }
-    var lastName: String? = null
-        set(value) {
-            field = Utils.truncateUTF8String(value, CONTACT_NAME_MAX_LENGTH_BYTES)
-        }
-
-    val hasFirstOrLastName: Boolean
-        get() = !firstName.isNullOrBlank() || !lastName.isNullOrBlank()
-
-    override fun toString(): String {
-        val sb = StringBuilder(identity)
-        sb.append(" (")
-        sb.append(Utils.byteArrayToHexString(publicKey))
-        sb.append(")")
-        if (firstName != null || lastName != null) {
-            sb.append(": ")
-            sb.append(firstName)
-            sb.append(" ")
-            sb.append(lastName)
-        }
-        return sb.toString()
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is Contact) return false
-        val contact = other
-        return identity == contact.identity && publicKey.contentEquals(contact.publicKey)
-    }
-
-    override fun hashCode(): Int {
-        var result = Objects.hash(identity)
-        result = 31 * result + publicKey.contentHashCode()
-        return result
-    }
-}
-
-enum class IdentityType {
-    /**
-     * A normal Threema identity.
-     */
-    NORMAL,
-
-    /**
-     * An identity using Threema Work.
-     */
-    WORK,
-}
-
-enum class WorkVerificationLevel {
-    NONE,
-
-    /**
-     * Contact is "work verified", i.e. has been added to the contact list in the management
-     * cockpit. These contacts are symbolized by a blue verification level.
-     */
-    WORK_SUBSCRIPTION_VERIFIED,
-}
-
-enum class ContactSyncState {
-    /**
-     * The contact data has not been imported and has not been edited by the user either.
-     */
-    INITIAL,
-
-    /**
-     * The contact data has been imported (e.g. via a local address book and an identity link).
-     * In this state, subsequent contact synchronisations must not alter the contact's data.
-     */
-    IMPORTED,
-
-    /**
-     * The contact data has been edited by the user.
-     * In this state, subsequent contact synchronisations must not alter the contact's data.
-     */
-    CUSTOM,
-}
-
-enum class ReadReceiptPolicy {
-    /**
-     * Default behavior (as configured in the global settings).
-     */
-    DEFAULT,
-
-    /**
-     * Send read receipt when an unread message has been read.
-     */
-    SEND,
-
-    /**
-     * Don't send read receipts.
-     */
-    DONT_SEND,
-}
-
-enum class TypingIndicatorPolicy {
-    /**
-     * Default behavior (as configured in the global settings).
-     */
-    DEFAULT,
-
-    /**
-     * Send typing indicator when a message is being composed.
-     */
-    SEND,
-
-    /**
-     * Don't send typing indicators.
-     */
-    DONT_SEND,
-}
diff --git a/domain/src/main/java/ch/threema/domain/models/IdentityState.java b/domain/src/main/java/ch/threema/domain/models/IdentityState.java
deleted file mode 100644
index b4379044..00000000
--- a/domain/src/main/java/ch/threema/domain/models/IdentityState.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.models;
-
-public class IdentityState {
-	public static final int ACTIVE = 0;
-	public static final int INACTIVE = 1;
-	public static final int INVALID = 2;
-}
diff --git a/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java b/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java
index 7a6b76bb..bc9bed09 100644
--- a/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java
+++ b/domain/src/main/java/ch/threema/domain/onprem/OnPremConfigBlob.java
@@ -22,6 +22,9 @@
 package ch.threema.domain.onprem;
 
 public class OnPremConfigBlob {
+
+    public static final String PLACEHOLDER_BLOB_ID = "{blobId}";
+
 	// Note: these are Strings instead of URLs so that they can include placeholders
 	private final String uploadUrl;
 	private final String downloadUrl;
diff --git a/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java b/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java
index 5a92319f..890665dd 100644
--- a/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java
+++ b/domain/src/main/java/ch/threema/domain/onprem/ServerAddressProviderOnPrem.java
@@ -26,141 +26,198 @@ import java.util.Objects;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
+import ch.threema.base.utils.Utils;
 import ch.threema.domain.protocol.ServerAddressProvider;
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider;
 
 public class ServerAddressProviderOnPrem implements ServerAddressProvider {
 
-	public interface FetcherProvider {
-		OnPremConfigFetcher getFetcher() throws ThreemaException;
-	}
-
-	private final FetcherProvider fetcherProvider;
-
-	public ServerAddressProviderOnPrem(FetcherProvider fetcherProvider) {
-		this.fetcherProvider = fetcherProvider;
-	}
-
-	@Override
-	public String getChatServerNamePrefix(boolean ipv6) throws ThreemaException {
-		return "";
-	}
-
-	@Override
-	public String getChatServerNameSuffix(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getChatConfig().getHostname();
-	}
-
-	@Override
-	public int[] getChatServerPorts() throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getChatConfig().getPorts();
-	}
-
-	@Override
-	public boolean getChatServerUseServerGroups() {
-		return false;
-	}
-
-	@Override
-	public byte[] getChatServerPublicKey() throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
-	}
-
-	@Override
-	public byte[] getChatServerPublicKeyAlt() throws ThreemaException {
-		// No alternate public key for OnPrem, as it can easily be switched in OPPF
-		return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
-	}
-
-	@Override
-	public String getDirectoryServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getDirectoryConfig().getUrl();
-	}
-
-	@Override
-	public String getWorkServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getWorkConfig().getUrl();
-	}
-
-	@Override
-	public String getBlobServerDownloadUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getBlobConfig().getDownloadUrl();
-	}
-
-	@Override
-	public String getBlobServerDoneUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getBlobConfig().getDoneUrl();
-	}
-
-	@Override
-	public String getBlobServerUploadUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getBlobConfig().getUploadUrl();
-	}
-
-	@Override
-	public String getAvatarServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getAvatarConfig().getUrl();
-	}
-
-	@Override
-	public String getSafeServerUrl(boolean ipv6) throws ThreemaException {
-		return getOnPremConfigFetcher().fetch().getSafeConfig().getUrl();
-	}
-
-	@Override
-	@Nullable
-	public String getWebServerUrl() throws ThreemaException {
-		OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
-
-		if (onPremConfigWeb != null) {
-			return onPremConfigWeb.getUrl();
-		}
-		throw new ThreemaException("Unable to fetch Threema Web server url");
-	}
-
-	@Override
-	public String getWebOverrideSaltyRtcHost() throws ThreemaException {
-		OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
-
-		if (onPremConfigWeb != null) {
-			return onPremConfigWeb.getOverrideSaltyRtcHost();
-		}
-		return null;
-	}
-
-	@Override
-	public int getWebOverrideSaltyRtcPort() throws ThreemaException {
-		OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
-
-		if (onPremConfigWeb != null) {
-			return onPremConfigWeb.getOverrideSaltyRtcPort();
-		}
-		return 0;
-	}
-
-	@Override
-	public byte[] getThreemaPushPublicKey() throws ThreemaException {
-		// TODO(ONPREM-164): Allow to configure for OnPrem
-		return null;
-	}
-
-	@NonNull
-	@Override
-	public String getMediatorUrl() throws ThreemaException {
-		OnPremConfigMediator onPremConfigMediator = getOnPremConfigFetcher().fetch().getMediatorConfig();
-
-		if (onPremConfigMediator == null) {
-			throw new ThreemaException("No mediator config available");
-		}
-		return Objects.requireNonNull(onPremConfigMediator.getUrl());
-	}
-
-	@NonNull
-	@Override
-	public String getAppRatingUrl() throws ThreemaException {
-		throw new ThreemaException("App rating is not supported in onprem");
-	}
-
-	private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
-		return fetcherProvider.getFetcher();
-	}
+    public interface FetcherProvider {
+        OnPremConfigFetcher getFetcher() throws ThreemaException;
+    }
+
+    private final FetcherProvider fetcherProvider;
+
+    public ServerAddressProviderOnPrem(FetcherProvider fetcherProvider) {
+        this.fetcherProvider = fetcherProvider;
+    }
+
+    @Override
+    public String getChatServerNamePrefix(boolean ipv6) throws ThreemaException {
+        return "";
+    }
+
+    @Override
+    public String getChatServerNameSuffix(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getChatConfig().getHostname();
+    }
+
+    @Override
+    public int[] getChatServerPorts() throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getChatConfig().getPorts();
+    }
+
+    @Override
+    public boolean getChatServerUseServerGroups() {
+        return false;
+    }
+
+    @Override
+    public byte[] getChatServerPublicKey() throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
+    }
+
+    @Override
+    public byte[] getChatServerPublicKeyAlt() throws ThreemaException {
+        // No alternate public key for OnPrem, as it can easily be switched in OPPF
+        return getOnPremConfigFetcher().fetch().getChatConfig().getPublicKey();
+    }
+
+    @Override
+    public String getDirectoryServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getDirectoryConfig().getUrl();
+    }
+
+    @Override
+    public String getWorkServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getWorkConfig().getUrl();
+    }
+
+    // TODO(ANDR-3375): Return correct base url of mirror server
+    @NonNull
+    @Override
+    public String getBlobBaseUrlMirrorServer(@NonNull MultiDevicePropertyProvider multiDevicePropertyProvider) throws ThreemaException {
+        throw new ThreemaException("Not yet implemented.");
+    }
+
+    @NonNull
+    @Override
+    public String getBlobServerDownloadUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+        final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+        if (blobIdHexString == null || blobIdHexString.isBlank()) {
+            throw new ThreemaException("Argument blobId is not in correct form");
+        }
+        return getOnPremConfigFetcher()
+            .fetch()
+            .getBlobConfig()
+            .getDownloadUrl()
+            .replace(OnPremConfigBlob.PLACEHOLDER_BLOB_ID, blobIdHexString);
+    }
+
+    @NonNull
+    @Override
+    public String getBlobServerUploadUrl(boolean useIpV6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getBlobConfig().getUploadUrl();
+    }
+
+    @NonNull
+    @Override
+    public String getBlobServerDoneUrl(boolean useIpV6, @NonNull byte[] blobId) throws ThreemaException {
+        final @Nullable String blobIdHexString = Utils.byteArrayToHexString(blobId);
+        if (blobIdHexString == null || blobIdHexString.isBlank()) {
+            throw new ThreemaException("Argument blobId is not in correct form");
+        }
+        return getOnPremConfigFetcher()
+            .fetch()
+            .getBlobConfig()
+            .getDoneUrl()
+            .replace(OnPremConfigBlob.PLACEHOLDER_BLOB_ID, blobIdHexString);
+    }
+
+    // TODO(ANDR-3375): Return correct url of mirror server
+    @NonNull
+    @Override
+    public String getBlobMirrorServerDownloadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException {
+        return getBlobServerDownloadUrl(false, blobId);
+    }
+
+    // TODO(ANDR-3375): Return correct url of mirror server
+    @NonNull
+    @Override
+    public String getBlobMirrorServerUploadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+    ) throws ThreemaException {
+        return getBlobServerUploadUrl(false);
+    }
+
+    // TODO(ANDR-3375): Return correct url of mirror server
+    @NonNull
+    @Override
+    public String getBlobMirrorServerDoneUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException {
+        return getBlobServerDoneUrl(false, blobId);
+    }
+
+    @Override
+    public String getAvatarServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getAvatarConfig().getUrl();
+    }
+
+    @Override
+    public String getSafeServerUrl(boolean ipv6) throws ThreemaException {
+        return getOnPremConfigFetcher().fetch().getSafeConfig().getUrl();
+    }
+
+    @Override
+    @Nullable
+    public String getWebServerUrl() throws ThreemaException {
+        OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
+
+        if (onPremConfigWeb != null) {
+            return onPremConfigWeb.getUrl();
+        }
+        throw new ThreemaException("Unable to fetch Threema Web server url");
+    }
+
+    @Override
+    public String getWebOverrideSaltyRtcHost() throws ThreemaException {
+        OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
+
+        if (onPremConfigWeb != null) {
+            return onPremConfigWeb.getOverrideSaltyRtcHost();
+        }
+        return null;
+    }
+
+    @Override
+    public int getWebOverrideSaltyRtcPort() throws ThreemaException {
+        OnPremConfigWeb onPremConfigWeb = getOnPremConfigFetcher().fetch().getWebConfig();
+
+        if (onPremConfigWeb != null) {
+            return onPremConfigWeb.getOverrideSaltyRtcPort();
+        }
+        return 0;
+    }
+
+    @Override
+    public byte[] getThreemaPushPublicKey() throws ThreemaException {
+        // TODO(ONPREM-164): Allow to configure for OnPrem
+        return null;
+    }
+
+    @NonNull
+    @Override
+    public String getMediatorUrl() throws ThreemaException {
+        OnPremConfigMediator onPremConfigMediator = getOnPremConfigFetcher().fetch().getMediatorConfig();
+
+        if (onPremConfigMediator == null) {
+            throw new ThreemaException("No mediator config available");
+        }
+        return Objects.requireNonNull(onPremConfigMediator.getUrl());
+    }
+
+    @NonNull
+    @Override
+    public String getAppRatingUrl() throws ThreemaException {
+        throw new ThreemaException("App rating is not supported in onprem");
+    }
+
+    private OnPremConfigFetcher getOnPremConfigFetcher() throws ThreemaException {
+        return fetcherProvider.getFetcher();
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/D2mProtocolDefines.kt b/domain/src/main/java/ch/threema/domain/protocol/D2mProtocolDefines.kt
deleted file mode 100644
index eced767a..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/D2mProtocolDefines.kt
+++ /dev/null
@@ -1,67 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol
-
-object D2mProtocolDefines {
-    const val D2M_PROTOCOL_VERSION_MIN = 0u
-    const val D2M_PROTOCOL_VERSION_MAX = 0u
-
-    const val D2M_FRAME_MIN_BYTES_LENGTH = 4
-    const val D2M_FRAME_MAX_BYTES_LENGTH = 65536
-
-    const val DGK_LENGTH_BYTES = 32
-}
-
-object D2mPayloadType {
-    // CSP proxying
-    const val PROXY: UByte = 0x00u
-
-    // Handshake
-    const val SERVER_HELLO: UByte = 0x10u
-    const val CLIENT_HELLO: UByte = 0x11u
-    const val SERVER_INFO: UByte = 0x12u
-
-    // States
-    const val REFLECTION_QUEUE_DRY: UByte = 0x20u
-    const val ROLE_PROMOTED_TO_LEADER: UByte = 0x21u
-
-    // Device Management
-    const val GET_DEVICES_INFO: UByte = 0x30u
-    const val DEVICES_INFO: UByte = 0x31u
-    const val DROP_DEVICE: UByte = 0x32u
-    const val DROP_DEVICE_ACK: UByte = 0x33u
-    const val SET_SHARED_DEVICE_DATA: UByte = 0x34u
-
-    // Transactions
-    const val BEGIN_TRANSACTION: UByte = 0x40u
-    const val BEGIN_TRANSACTION_ACK: UByte = 0x41u
-    const val COMMIT_TRANSACTION: UByte = 0x42u
-    const val COMMIT_TRANSACTION_ACK: UByte = 0x43u
-    const val TRANSACTION_REJECTED: UByte = 0x44u
-    const val TRANSACTION_ENDED: UByte = 0x45u
-
-    // Reflection
-    const val REFLECT: UByte = 0x80u
-    const val REFLECT_ACK: UByte = 0x81u
-    const val REFLECTED: UByte = 0x82u
-    const val REFLECTED_ACK: UByte = 0x83u
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java b/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java
index e87148ec..065716b0 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/ServerAddressProvider.java
@@ -24,34 +24,79 @@ package ch.threema.domain.protocol;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
+import ch.threema.domain.protocol.blob.BlobScope;
+import ch.threema.domain.protocol.connection.d2m.MultiDevicePropertyProvider;
 
 public interface ServerAddressProvider {
-	String getChatServerNamePrefix(boolean ipv6) throws ThreemaException;
-	String getChatServerNameSuffix(boolean ipv6) throws ThreemaException;
-	int[] getChatServerPorts() throws ThreemaException;
-	boolean getChatServerUseServerGroups() throws ThreemaException;
-	byte[] getChatServerPublicKey() throws ThreemaException;
-	byte[] getChatServerPublicKeyAlt() throws ThreemaException;
+    String getChatServerNamePrefix(boolean ipv6) throws ThreemaException;
 
-	String getDirectoryServerUrl(boolean ipv6) throws ThreemaException;
+    String getChatServerNameSuffix(boolean ipv6) throws ThreemaException;
 
-	String getWorkServerUrl(boolean ipv6) throws ThreemaException;
+    int[] getChatServerPorts() throws ThreemaException;
 
-	String getBlobServerDownloadUrl(boolean ipv6) throws ThreemaException;
-	String getBlobServerDoneUrl(boolean ipv6) throws ThreemaException;
-	String getBlobServerUploadUrl(boolean ipv6) throws ThreemaException;
+    boolean getChatServerUseServerGroups() throws ThreemaException;
 
-	String getAvatarServerUrl(boolean ipv6) throws ThreemaException;
+    byte[] getChatServerPublicKey() throws ThreemaException;
 
-	String getSafeServerUrl(boolean ipv6) throws ThreemaException;
-	String getWebServerUrl() throws ThreemaException;
-	String getWebOverrideSaltyRtcHost() throws ThreemaException;
-	int getWebOverrideSaltyRtcPort() throws ThreemaException;
-	@Nullable byte[] getThreemaPushPublicKey() throws ThreemaException;
+    byte[] getChatServerPublicKeyAlt() throws ThreemaException;
 
-	@NonNull
-	String getMediatorUrl() throws ThreemaException;
+    String getDirectoryServerUrl(boolean ipv6) throws ThreemaException;
 
-	@NonNull
-	String getAppRatingUrl() throws ThreemaException;
+    String getWorkServerUrl(boolean ipv6) throws ThreemaException;
+
+    @NonNull
+    String getBlobBaseUrlMirrorServer(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobServerDownloadUrl(
+        boolean useIpV6,
+        @NonNull byte[] blobId
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobServerUploadUrl(boolean useIpV6) throws ThreemaException;
+
+    @NonNull
+    String getBlobServerDoneUrl(
+        boolean useIpV6,
+        @NonNull byte[] blobId
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobMirrorServerDownloadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException, IllegalArgumentException;
+
+    @NonNull
+    String getBlobMirrorServerUploadUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider
+    ) throws ThreemaException;
+
+    @NonNull
+    String getBlobMirrorServerDoneUrl(
+        @NonNull MultiDevicePropertyProvider multiDevicePropertyProvider,
+        @NonNull byte[] blobId
+    ) throws ThreemaException, IllegalArgumentException;
+
+    String getAvatarServerUrl(boolean ipv6) throws ThreemaException;
+
+    String getSafeServerUrl(boolean ipv6) throws ThreemaException;
+
+    String getWebServerUrl() throws ThreemaException;
+
+    String getWebOverrideSaltyRtcHost() throws ThreemaException;
+
+    int getWebOverrideSaltyRtcPort() throws ThreemaException;
+
+    @Nullable
+    byte[] getThreemaPushPublicKey() throws ThreemaException;
+
+    @NonNull
+    String getMediatorUrl() throws ThreemaException;
+
+    @NonNull
+    String getAppRatingUrl() throws ThreemaException;
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/Version.java b/domain/src/main/java/ch/threema/domain/protocol/Version.java
index 9e5471ac..6a384574 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/Version.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/Version.java
@@ -25,11 +25,15 @@ public class Version {
 
 	private static final String VERSION = "0.2";
 
-	public String getVersion() {
+	public String getVersionNumber() {
+		return VERSION;
+	}
+
+	public String getVersionString() {
 		return VERSION + "J";
 	}
 
-	public String getFullVersion() {
+	public String getFullVersionString() {
 		return VERSION + ";J;;;" + System.getProperty("java.version");
 	}
 
diff --git a/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java b/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java
index 6dd30629..f5896cfb 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/api/APIConnector.java
@@ -34,7 +34,6 @@ import org.json.JSONException;
 import org.json.JSONObject;
 import org.slf4j.Logger;
 
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStreamWriter;
@@ -80,9 +79,8 @@ import ch.threema.domain.stores.TokenStoreInterface;
 import ove.crypto.digest.Blake2b;
 
 /**
- * Fetches data and executes commands on the Threema API (such as creating a new
- * identity, fetching public keys for a given identity, linking e-mail addresses
- * and mobile phone numbers, etc.).
+ * Fetches data and executes commands on the Threema API (such as creating a new identity, fetching
+ * public keys for a given identity, linking e-mail addresses and mobile phone numbers, etc.).
  * <p>
  * All calls run synchronously; if necessary the caller should dispatch a separate thread.
  */
@@ -94,8 +92,18 @@ public class APIConnector {
     private static final String JSON_FIELD_DEPARTMENT = "department";
 
     // HMAC-SHA256 keys for contact matching
-    private static final byte[] EMAIL_HMAC_KEY = new byte[]{(byte) 0x30, (byte) 0xa5, (byte) 0x50, (byte) 0x0f, (byte) 0xed, (byte) 0x97, (byte) 0x01, (byte) 0xfa, (byte) 0x6d, (byte) 0xef, (byte) 0xdb, (byte) 0x61, (byte) 0x08, (byte) 0x41, (byte) 0x90, (byte) 0x0f, (byte) 0xeb, (byte) 0xb8, (byte) 0xe4, (byte) 0x30, (byte) 0x88, (byte) 0x1f, (byte) 0x7a, (byte) 0xd8, (byte) 0x16, (byte) 0x82, (byte) 0x62, (byte) 0x64, (byte) 0xec, (byte) 0x09, (byte) 0xba, (byte) 0xd7};
-    private static final byte[] MOBILENO_HMAC_KEY = new byte[]{(byte) 0x85, (byte) 0xad, (byte) 0xf8, (byte) 0x22, (byte) 0x69, (byte) 0x53, (byte) 0xf3, (byte) 0xd9, (byte) 0x6c, (byte) 0xfd, (byte) 0x5d, (byte) 0x09, (byte) 0xbf, (byte) 0x29, (byte) 0x55, (byte) 0x5e, (byte) 0xb9, (byte) 0x55, (byte) 0xfc, (byte) 0xd8, (byte) 0xaa, (byte) 0x5e, (byte) 0xc4, (byte) 0xf9, (byte) 0xfc, (byte) 0xd8, (byte) 0x69, (byte) 0xe2, (byte) 0x58, (byte) 0x37, (byte) 0x07, (byte) 0x23};
+    private static final byte[] EMAIL_HMAC_KEY = new byte[]{(byte) 0x30, (byte) 0xa5, (byte) 0x50
+		    , (byte) 0x0f, (byte) 0xed, (byte) 0x97, (byte) 0x01, (byte) 0xfa, (byte) 0x6d,
+		    (byte) 0xef, (byte) 0xdb, (byte) 0x61, (byte) 0x08, (byte) 0x41, (byte) 0x90,
+		    (byte) 0x0f, (byte) 0xeb, (byte) 0xb8, (byte) 0xe4, (byte) 0x30, (byte) 0x88,
+		    (byte) 0x1f, (byte) 0x7a, (byte) 0xd8, (byte) 0x16, (byte) 0x82, (byte) 0x62,
+		    (byte) 0x64, (byte) 0xec, (byte) 0x09, (byte) 0xba, (byte) 0xd7};
+    private static final byte[] MOBILENO_HMAC_KEY = new byte[]{(byte) 0x85, (byte) 0xad,
+		    (byte) 0xf8, (byte) 0x22, (byte) 0x69, (byte) 0x53, (byte) 0xf3, (byte) 0xd9,
+		    (byte) 0x6c, (byte) 0xfd, (byte) 0x5d, (byte) 0x09, (byte) 0xbf, (byte) 0x29,
+		    (byte) 0x55, (byte) 0x5e, (byte) 0xb9, (byte) 0x55, (byte) 0xfc, (byte) 0xd8,
+		    (byte) 0xaa, (byte) 0x5e, (byte) 0xc4, (byte) 0xf9, (byte) 0xfc, (byte) 0xd8,
+		    (byte) 0x69, (byte) 0xe2, (byte) 0x58, (byte) 0x37, (byte) 0x07, (byte) 0x23};
 
     private static final int DEFAULT_MATCH_CHECK_INTERVAL = 86400;
     private static final int RESPONSE_LEN = 32;
@@ -215,8 +223,7 @@ public class APIConnector {
     }
 
     /**
-     * Fetch identity-related information (public key) for
-     * a given identity.
+     * Fetch identity-related information (public key) for a given identity.
      *
      * @param identity the desired identity
      * @return information related to identity
@@ -224,7 +231,8 @@ public class APIConnector {
      * @throws HttpConnectionException on http error
      * @throws NetworkException        on network error
      */
-    public FetchIdentityResult fetchIdentity(String identity) throws ThreemaException, NetworkException, HttpConnectionException {
+    public FetchIdentityResult fetchIdentity(String identity) throws ThreemaException,
+		    NetworkException, HttpConnectionException {
         try {
             String responseStr = doGet(getServerUrl() + "identity/" + identity);
             JSONObject jsonResponse = new JSONObject(responseStr);
@@ -247,39 +255,44 @@ public class APIConnector {
      *
      * @param identities the desired identities
      * @return array list of information related to identity
-     * @throws FileNotFoundException if identity not found
-     * @throws Exception             on network error
+     * @throws ThreemaException         if the server url cannot be fetched on onprem builds
+     * @throws IllegalArgumentException if the argument is null or empty
+     * @throws NetworkException         on network error
      */
-    public ArrayList<FetchIdentityResult> fetchIdentities(List<String> identities) throws Exception {
-        if (identities == null || identities.size() < 1) {
-            throw new ThreemaException("empty identities array");
+    public List<FetchIdentityResult> fetchIdentities(List<String> identities) throws ThreemaException, NetworkException {
+        if (identities == null || identities.isEmpty()) {
+            throw new IllegalArgumentException("empty identities array");
         }
 
-        JSONObject postObject = new JSONObject();
-        postObject.put("identities", new JSONArray(identities));
-        String postResponse = this.postJson(getServerUrl() + "identity/fetch_bulk", postObject);
-
-        if (postResponse == null) {
-            throw new ThreemaException("no valid response or network error");
-        }
-
-        JSONObject resultObject = new JSONObject(postResponse);
-        JSONArray resultArray = resultObject.getJSONArray("identities");
+        try {
+            JSONObject postObject = new JSONObject();
+            postObject.put("identities", new JSONArray(identities));
+            String postResponse = this.postJson(getServerUrl() + "identity/fetch_bulk", postObject);
 
-        ArrayList<FetchIdentityResult> fetchIdentityResults = new ArrayList<>();
-        for (int i = 0; i < resultArray.length(); i++) {
-            JSONObject jsonResponse = resultArray.getJSONObject(i);
-            FetchIdentityResult fetchIdentityResult = new FetchIdentityResult();
-            fetchIdentityResult.publicKey = Base64.decode(jsonResponse.getString("publicKey"));
-            fetchIdentityResult.featureLevel = jsonResponse.optInt("featureLevel");
-            fetchIdentityResult.featureMask = jsonResponse.optInt("featureMask");
-            fetchIdentityResult.identity = jsonResponse.getString("identity");
-            fetchIdentityResult.state = jsonResponse.optInt("state");
-            fetchIdentityResult.type = jsonResponse.optInt("type");
+            if (postResponse == null) {
+                throw new NetworkException("no valid response or network error");
+            }
 
-            fetchIdentityResults.add(fetchIdentityResult);
+            JSONObject resultObject = new JSONObject(postResponse);
+            JSONArray resultArray = resultObject.getJSONArray("identities");
+
+            List<FetchIdentityResult> fetchIdentityResults = new ArrayList<>();
+            for (int i = 0; i < resultArray.length(); i++) {
+                JSONObject jsonResponse = resultArray.getJSONObject(i);
+                FetchIdentityResult fetchIdentityResult = new FetchIdentityResult();
+                fetchIdentityResult.publicKey = Base64.decode(jsonResponse.getString("publicKey"));
+                fetchIdentityResult.featureLevel = jsonResponse.optInt("featureLevel");
+                fetchIdentityResult.featureMask = jsonResponse.optInt("featureMask");
+                fetchIdentityResult.identity = jsonResponse.getString("identity");
+                fetchIdentityResult.state = jsonResponse.optInt("state");
+                fetchIdentityResult.type = jsonResponse.optInt("type");
+
+                fetchIdentityResults.add(fetchIdentityResult);
+            }
+            return fetchIdentityResults;
+        } catch (JSONException | IOException e) {
+            throw new NetworkException(e);
         }
-        return fetchIdentityResults;
     }
 
     /**
@@ -329,8 +342,8 @@ public class APIConnector {
 
     /**
      * Link an e-mail address with the identity from the given store. The user gets a verification
-     * e-mail with a link. {@link #linkEmailCheckStatus(String, IdentityStoreInterface)} should be called
-     * to check whether the user has already confirmed.
+     * e-mail with a link. {@link #linkEmailCheckStatus(String, IdentityStoreInterface)} should be
+     * called to check whether the user has already confirmed.
      * <p>
      * To unlink, pass an empty string as the e-mail address. In that case, checking status is not
      * necessary as the unlink operation does not need e-mail verification.
@@ -339,7 +352,8 @@ public class APIConnector {
      * @param language      language for confirmation e-mail, ISO-639-1 (e.g. "de", "en", "fr")
      * @param identityStore identity store for authentication of request
      * @return true if e-mail address is accepted for verification, false if already linked
-     * @throws LinkEmailException if the server reports an error (should be displayed to the user verbatim)
+     * @throws LinkEmailException if the server reports an error (should be displayed to the user
+     *                            verbatim)
      * @throws Exception          if a network error occurs
      */
     public boolean linkEmail(String email, String language, IdentityStoreInterface identityStore) throws LinkEmailException, Exception {
@@ -379,8 +393,8 @@ public class APIConnector {
     }
 
     /**
-     * Check whether a given e-mail address is already linked to the identity (i.e. the user
-     * has confirmed the verification mail).
+     * Check whether a given e-mail address is already linked to the identity (i.e. the user has
+     * confirmed the verification mail).
      *
      * @param email         e-mail address to be linked
      * @param identityStore identity store for authentication of request
@@ -402,27 +416,33 @@ public class APIConnector {
     }
 
     /**
-     * Link a mobile phone number with the identity from the given store. The user gets a verification code via
-     * SMS; this code should be passed to {@link #linkMobileNoVerify(String, String)} along with the verification ID
-     * returned by this method to complete the operation.
+     * Link a mobile phone number with the identity from the given store. The user gets a
+     * verification code via SMS; this code should be passed to
+     * {@link #linkMobileNoVerify(String, String)} along with the verification ID returned by this
+     * method to complete the operation.
      * <p>
      * To unlink, pass an empty string as the mobile number.
      *
      * @param mobileNo      mobile phone number in E.164 format without + (e.g. 41791234567)
      * @param language      language for SMS text, ISO-639-1 (e.g. "de", "en", "fr")
      * @param identityStore identity store for authentication of request
-     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)}, or null if verification is already complete
-     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user verbatim)
+     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)},
+     * or null if verification is already complete
+     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user
+     *                               verbatim)
      * @throws Exception             if a network error occurs
      */
-    public String linkMobileNo(String mobileNo, String language, IdentityStoreInterface identityStore) throws LinkMobileNoException, Exception {
+    public String linkMobileNo(String mobileNo, String language,
+                               IdentityStoreInterface identityStore) throws LinkMobileNoException
+		    , Exception {
         return this.linkMobileNo(mobileNo, language, identityStore, null);
     }
 
     /**
-     * Link a mobile phone number with the identity from the given store. The user gets a verification code via
-     * SMS; this code should be passed to {@link #linkMobileNoVerify(String, String)} along with the verification ID
-     * returned by this method to complete the operation.
+     * Link a mobile phone number with the identity from the given store. The user gets a
+     * verification code via SMS; this code should be passed to
+     * {@link #linkMobileNoVerify(String, String)} along with the verification ID returned by this
+     * method to complete the operation.
      * <p>
      * To unlink, pass an empty string as the mobile number.
      *
@@ -430,11 +450,14 @@ public class APIConnector {
      * @param language      language for SMS text, ISO-639-1 (e.g. "de", "en", "fr")
      * @param identityStore identity store for authentication of request
      * @param urlScheme     optional parameter (url schema of the verification link)
-     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)}, or null if verification is already complete
-     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user verbatim)
+     * @return verification ID that should be passed to {@link #linkMobileNoVerify(String, String)},
+     * or null if verification is already complete
+     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user
+     *                               verbatim)
      * @throws Exception             if a network error occurs
      */
-    public String linkMobileNo(String mobileNo, String language, IdentityStoreInterface identityStore, String urlScheme) throws LinkMobileNoException, Exception {
+    public String linkMobileNo(String mobileNo, String language,
+                               IdentityStoreInterface identityStore, String urlScheme) throws LinkMobileNoException, Exception {
         String url = getServerUrl() + "identity/link_mobileno";
 
         // Phase 1: send identity and mobile no
@@ -480,9 +503,11 @@ public class APIConnector {
     /**
      * Complete verification of mobile number link.
      *
-     * @param verificationId the verification ID returned by {@link #linkMobileNo(String, String, IdentityStoreInterface)}
+     * @param verificationId the verification ID returned by
+     *                       {@link #linkMobileNo(String, String, IdentityStoreInterface)}
      * @param code           the SMS code (usually 6 digits)
-     * @throws LinkMobileNoException if the server reports an error, e.g. wrong code or too many attempts (should be displayed to the user verbatim)
+     * @throws LinkMobileNoException if the server reports an error, e.g. wrong code or too many
+     *                               attempts (should be displayed to the user verbatim)
      * @throws Exception             if a network error occurs
      */
     public void linkMobileNoVerify(String verificationId, String code) throws LinkMobileNoException, Exception {
@@ -500,12 +525,16 @@ public class APIConnector {
     }
 
     /**
-     * Trigger a phone call for the given verification ID. This should only be done if the SMS doesn't arrive
-     * in a normal amount of time (e.g. 10 minutes). The verification code will be read to the user twice,
-     * and {@link #linkMobileNoVerify(String, String)} should then be called with the code.
+     * Trigger a phone call for the given verification ID. This should only be done if the SMS
+     * doesn't arrive in a normal amount of time (e.g. 10 minutes). The verification code will be
+     * read to the user twice, and {@link #linkMobileNoVerify(String, String)} should then be called
+     * with the code.
      *
-     * @param verificationId verification ID returned from {@link #linkMobileNo(String, String, IdentityStoreInterface)}
-     * @throws LinkMobileNoException if the server reports an error, e.g. unable to call the destination, already called etc. (should be displayed to the user verbatim)
+     * @param verificationId verification ID returned from
+     *                       {@link #linkMobileNo(String, String, IdentityStoreInterface)}
+     * @throws LinkMobileNoException if the server reports an error, e.g. unable to call the
+     *                               destination, already called etc. (should be displayed to the
+     *                               user verbatim)
      * @throws Exception             if a network error occurs
      */
     public void linkMobileNoCall(String verificationId) throws LinkMobileNoException, Exception {
@@ -522,23 +551,28 @@ public class APIConnector {
     }
 
     /**
-     * Find identities that have been linked with the given e-mail addresses and/or mobile phone numbers.
-     * The mobile phone numbers can be provided in national or international format, as they will be automatically
-     * passed through libphonenumber (which also takes care of spaces, brackets etc.).
+     * Find identities that have been linked with the given e-mail addresses and/or mobile phone
+     * numbers. The mobile phone numbers can be provided in national or international format, as
+     * they will be automatically passed through libphonenumber (which also takes care of spaces,
+     * brackets etc.).
      * <p>
-     * The server also returns its desired check interval to the {@code APIConnector} object during this call.
-     * The caller should use {@link #getMatchCheckInterval()} to determine the earliest time for the next call
-     * after this call. This is important so that the server can request longer intervals from its clients during
-     * periods of heavy traffic or temporary capacity problems.
+     * The server also returns its desired check interval to the {@code APIConnector} object during
+     * this call. The caller should use {@link #getMatchCheckInterval()} to determine the earliest
+     * time for the next call after this call. This is important so that the server can request
+     * longer intervals from its clients during periods of heavy traffic or temporary capacity
+     * problems.
      *
-     * @param emails          map of e-mail addresses (key = e-mail, value = arbitrary object for reference that is returned with any found identities)
-     * @param mobileNos       map of phone numbers (key = phone number, value = arbitrary object for reference that is returned with any found identities)
-     * @param userCountry     the user's home country (for correct interpretation of national phone numbers), ISO 3166-1, e.g. "CH" (or null to disable normalization)
+     * @param emails          map of e-mail addresses (key = e-mail, value = arbitrary object for
+     *                        reference that is returned with any found identities)
+     * @param mobileNos       map of phone numbers (key = phone number, value = arbitrary object for
+     *                        reference that is returned with any found identities)
+     * @param userCountry     the user's home country (for correct interpretation of national phone
+     *                        numbers), ISO 3166-1, e.g. "CH" (or null to disable normalization)
      * @param includeInactive if true, inactive IDs will be included in the results also
      * @param identityStore   identity store to use for obtaining match token
      * @param matchTokenStore for storing match token for reuse (may be null)
-     * @return map of found identities (key = identity). The value objects from the {@code emails} and {@code mobileNos} parameters
-     * will be returned in {@code refObject}.
+     * @return map of found identities (key = identity). The value objects from the {@code emails}
+     * and {@code mobileNos} parameters will be returned in {@code refObject}.
      */
     @SuppressLint("DefaultLocale")
     public Map<String, MatchIdentityResult> matchIdentities(
@@ -557,7 +591,8 @@ public class APIConnector {
 
         for (Map.Entry<String, ?> entry : emails.entrySet()) {
             String normalizedEmail = entry.getKey().toLowerCase().trim();
-            byte[] emailHash = emailMac.doFinal(normalizedEmail.getBytes(StandardCharsets.US_ASCII));
+            byte[] emailHash =
+		            emailMac.doFinal(normalizedEmail.getBytes(StandardCharsets.US_ASCII));
             emailHashes.put(Base64.encodeBytes(emailHash), entry.getValue());
 
             // Gmail address? If so, hash with the other domain as well
@@ -569,7 +604,8 @@ public class APIConnector {
             }
 
             if (normalizedEmailAlt != null) {
-                byte[] emailHashAlt = emailMac.doFinal(normalizedEmailAlt.getBytes(StandardCharsets.US_ASCII));
+                byte[] emailHashAlt =
+		                emailMac.doFinal(normalizedEmailAlt.getBytes(StandardCharsets.US_ASCII));
                 emailHashes.put(Base64.encodeBytes(emailHashAlt), entry.getValue());
             }
         }
@@ -589,14 +625,17 @@ public class APIConnector {
             try {
                 String normalizedMobileNo;
                 if (phoneNumberUtil != null) {
-                    Phonenumber.PhoneNumber phoneNumber = phoneNumberUtil.parse(entry.getKey(), userCountry);
-                    String normalizedMobileNoWithPlus = phoneNumberUtil.format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164);
+                    Phonenumber.PhoneNumber phoneNumber = phoneNumberUtil.parse(entry.getKey(),
+		                    userCountry);
+                    String normalizedMobileNoWithPlus = phoneNumberUtil.format(phoneNumber,
+		                    PhoneNumberUtil.PhoneNumberFormat.E164);
                     normalizedMobileNo = normalizedMobileNoWithPlus.replace("+", "");
                 } else {
                     normalizedMobileNo = entry.getKey().replaceAll("[^0-9]", "");
                 }
 
-                byte[] mobileNoHash = mobileNoMac.doFinal(normalizedMobileNo.getBytes(StandardCharsets.US_ASCII));
+                byte[] mobileNoHash =
+		                mobileNoMac.doFinal(normalizedMobileNo.getBytes(StandardCharsets.US_ASCII));
                 mobileNoHashes.put(Base64.encodeBytes(mobileNoHash), entry.getValue());
             } catch (NumberParseException e) {
                 // Skip/ignore this number
@@ -604,7 +643,8 @@ public class APIConnector {
             }
         }
 
-        return matchIdentitiesHashed(emailHashes, mobileNoHashes, includeInactive, identityStore, matchTokenStore);
+        return matchIdentitiesHashed(emailHashes, mobileNoHashes, includeInactive, identityStore,
+		        matchTokenStore);
     }
 
     public Map<String, MatchIdentityResult> matchIdentitiesHashed(
@@ -616,12 +656,14 @@ public class APIConnector {
     ) throws Exception {
         String matchToken = obtainMatchToken(identityStore, matchTokenStore, false);
         try {
-            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive, matchToken);
+            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive,
+		            matchToken);
         } catch (Exception e) {
             // Match token may be invalid/expired, refresh and try again
             logger.debug("Match failed", e);
             matchToken = obtainMatchToken(identityStore, matchTokenStore, true);
-            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive, matchToken);
+            return matchIdentitiesHashedToken(emailHashes, mobileNoHashes, includeInactive,
+		            matchToken);
         }
     }
 
@@ -647,7 +689,8 @@ public class APIConnector {
         logger.debug(String.format("Match identities: sending to server: %s", request.toString()));
 
         JSONObject result = new JSONObject(postJson(url, request));
-        logger.debug(String.format("Match identities: response from server: %s", result.toString()));
+        logger.debug(String.format("Match identities: response from server: %s",
+		        result.toString()));
 
         matchCheckInterval = result.getInt("checkInterval");
         logger.debug("Server requested check interval of {} seconds", matchCheckInterval);
@@ -681,8 +724,8 @@ public class APIConnector {
      *
      * @param identityStore   Obtain a match token for the identity stored in this identity store.
      * @param matchTokenStore Optional cache used to store match tokens after lookup.
-     * @param forceRefresh    If set to true, then a match token will always be re-fetched.
-     *                        The `matchTokenStore` cache will be ignored.
+     * @param forceRefresh    If set to true, then a match token will always be re-fetched. The
+     *                        `matchTokenStore` cache will be ignored.
      * @return The match token as string
      */
     private String obtainMatchToken(
@@ -734,7 +777,8 @@ public class APIConnector {
      * Obtain an authentication token (for OnPrem only).
      *
      * @param authTokenStore the token store to use for caching the token
-     * @param forceRefresh   if true, a new token is always requested even if one is currently cached
+     * @param forceRefresh   if true, a new token is always requested even if one is currently
+     *                       cached
      * @return The authentication token
      */
     public String obtainAuthToken(
@@ -770,7 +814,8 @@ public class APIConnector {
      * <p>
      * The token will be prefixed with `3ma;`.
      *
-     * @param identityStore Obtain a Threema Push token for the identity stored in this identity store.
+     * @param identityStore Obtain a Threema Push token for the identity stored in this identity
+     *                      store.
      * @return The match token as string
      */
     public @NonNull String obtainThreemaPushToken(
@@ -867,7 +912,8 @@ public class APIConnector {
      *
      * @param featureMask   feature mask of the current identity
      * @param identityStore identity store for authentication of request
-     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user verbatim)
+     * @throws LinkMobileNoException if the server reports an error (should be displayed to the user
+     *                               verbatim)
      * @throws Exception             if a network error occurs
      */
     public void setFeatureMask(long featureMask, IdentityStoreInterface identityStore) throws Exception {
@@ -960,7 +1006,8 @@ public class APIConnector {
     /**
      * Set the revocation key for the stored identity
      */
-    public SetRevocationKeyResult setRevocationKey(IdentityStoreInterface identityStore, String revocationKey) throws Exception {
+    public SetRevocationKeyResult setRevocationKey(IdentityStoreInterface identityStore,
+                                                   String revocationKey) throws Exception {
 
         // Calculate key
         MessageDigest md = MessageDigest.getInstance("SHA-256");
@@ -993,8 +1040,8 @@ public class APIConnector {
     }
 
     /**
-     * This call is used to check a list of IDs and determine the status of each ID.
-     * The response contains a list of status codes, one for each ID in the same order as in the request.
+     * This call is used to check a list of IDs and determine the status of each ID. The response
+     * contains a list of status codes, one for each ID in the same order as in the request.
      */
     public CheckIdentityStatesResult checkIdentityStates(String[] identities) throws Exception {
         String url = getServerUrl() + "identity/check";
@@ -1078,13 +1125,15 @@ public class APIConnector {
         }
 
         String[] turnUrls = jsonArrayToStringArray(p2Result.getJSONArray("turnUrls"));
-        String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray("turnUrlsDualStack"));
+        String[] turnUrlsDualStack = jsonArrayToStringArray(p2Result.getJSONArray(
+				"turnUrlsDualStack"));
         String turnUsername = p2Result.getString("turnUsername");
         String turnPassword = p2Result.getString("turnPassword");
         int expiration = p2Result.getInt("expiration");
         Date expirationDate = new Date(new Date().getTime() + expiration * 1000L);
 
-        return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword, expirationDate);
+        return new TurnServerInfo(turnUrls, turnUrlsDualStack, turnUsername, turnPassword,
+		        expirationDate);
     }
 
     /**
@@ -1095,7 +1144,8 @@ public class APIConnector {
      * @param senderNickname Nickname of sender, if known
      * @throws Exception If junk report could not be sent
      */
-    public void reportJunk(IdentityStoreInterface identityStore, @NonNull String senderIdentity, @Nullable String senderNickname) throws Exception {
+    public void reportJunk(IdentityStoreInterface identityStore, @NonNull String senderIdentity,
+                           @Nullable String senderNickname) throws Exception {
         if (identityStore == null || identityStore.getIdentity() == null || identityStore.getIdentity().isEmpty()) {
             return;
         }
@@ -1181,7 +1231,7 @@ public class APIConnector {
     private CheckLicenseResult checkLicense(JSONObject request, String deviceId) throws Exception {
         String url = getServerUrl() + "check_license";
         request.put("deviceId", deviceId);
-        request.put("version", version.getFullVersion());
+        request.put("version", version.getFullVersionString());
         request.put("arch", version.getArchitecture());
 
         JSONObject result = new JSONObject(this.postJson(url, request));
@@ -1222,7 +1272,8 @@ public class APIConnector {
         }
         request.put("contacts", identityArray);
 
-        PostJsonResult postJsonResult = this.postJsonWithResult(getWorkServerUrl() + "fetch2", request);
+        PostJsonResult postJsonResult = this.postJsonWithResult(getWorkServerUrl() + "fetch2",
+		        request);
         if (postJsonResult.responseCode > 0 || postJsonResult.responseBody == null || postJsonResult.responseBody.length() == 0) {
             workData.responseCode = postJsonResult.responseCode;
             return workData;
@@ -1260,8 +1311,10 @@ public class APIConnector {
                             Base64.decode(contact.getString("pk")),
                             contact.has("first") ? contact.getString("first") : null,
                             contact.has("last") ? contact.getString("last") : null,
-                            contact.has(JSON_FIELD_JOB_TITLE) ? contact.getString(JSON_FIELD_JOB_TITLE) : null,
-                            contact.has(JSON_FIELD_DEPARTMENT) ? contact.getString(JSON_FIELD_DEPARTMENT) : null
+                            contact.has(JSON_FIELD_JOB_TITLE) ?
+		                            contact.getString(JSON_FIELD_JOB_TITLE) : null,
+                            contact.has(JSON_FIELD_DEPARTMENT) ?
+		                            contact.getString(JSON_FIELD_DEPARTMENT) : null
                         )
                     );
                 }
@@ -1290,7 +1343,8 @@ public class APIConnector {
         JSONObject jsonResponseOrganization = jsonResponse.optJSONObject("org");
         if (jsonResponseOrganization != null) {
             workData.organization.name =
-                jsonResponseOrganization.isNull("name") ? null : jsonResponseOrganization.optString("name");
+                jsonResponseOrganization.isNull("name") ? null :
+		                jsonResponseOrganization.optString("name");
         }
 
         JSONObject directory = jsonResponse.optJSONObject("directory");
@@ -1319,7 +1373,8 @@ public class APIConnector {
      * @param username   Threema Work license username
      * @param password   Threema Work license password
      * @param identities List of Threema IDs to check
-     * @return List of valid threema work contacts - empty list if there are no matching contacts in this package.
+     * @return List of valid threema work contacts - empty list if there are no matching contacts in
+     * this package.
      */
     @NonNull
     public List<WorkContact> fetchWorkContacts(
@@ -1361,8 +1416,10 @@ public class APIConnector {
                             Base64.decode(contact.getString("pk")),
                             contact.isNull("first") ? null : contact.getString("first"),
                             contact.isNull("last") ? null : contact.getString("last"),
-                            contact.isNull(JSON_FIELD_JOB_TITLE) ? null : contact.getString(JSON_FIELD_JOB_TITLE),
-                            contact.isNull(JSON_FIELD_DEPARTMENT) ? null : contact.getString(JSON_FIELD_DEPARTMENT)
+                            contact.isNull(JSON_FIELD_JOB_TITLE) ? null :
+		                            contact.getString(JSON_FIELD_JOB_TITLE),
+                            contact.isNull(JSON_FIELD_DEPARTMENT) ? null :
+		                            contact.getString(JSON_FIELD_DEPARTMENT)
                         )
                     );
                 }
@@ -1467,18 +1524,27 @@ public class APIConnector {
                     WorkDirectoryContact directoryContact = new WorkDirectoryContact(
                         contact.getString("id"),
                         Base64.decode(contact.getString("pk")),
-                        contact.has("first") ? (contact.isNull("first") ? null : contact.optString("first")) : null,
-                        contact.has("last") ? (contact.isNull("last") ? null : contact.optString("last")) : null,
-                        contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString("csi")) : null,
-                        contact.has(JSON_FIELD_JOB_TITLE) ? (contact.isNull(JSON_FIELD_JOB_TITLE) ? null : contact.optString(JSON_FIELD_JOB_TITLE)) : null,
-                        contact.has(JSON_FIELD_DEPARTMENT) ? (contact.isNull(JSON_FIELD_DEPARTMENT) ? null : contact.optString(JSON_FIELD_DEPARTMENT)) : null
+                        contact.has("first") ? (contact.isNull("first") ? null :
+		                        contact.optString("first")) : null,
+                        contact.has("last") ? (contact.isNull("last") ? null : contact.optString(
+								"last")) : null,
+                        contact.has("csi") ? (contact.isNull("csi") ? null : contact.optString(
+								"csi")) : null,
+                        contact.has(JSON_FIELD_JOB_TITLE) ?
+		                        (contact.isNull(JSON_FIELD_JOB_TITLE) ? null :
+				                        contact.optString(JSON_FIELD_JOB_TITLE)) : null,
+                        contact.has(JSON_FIELD_DEPARTMENT) ?
+		                        (contact.isNull(JSON_FIELD_DEPARTMENT) ? null :
+				                        contact.optString(JSON_FIELD_DEPARTMENT)) : null
                     );
 
                     if (!contact.isNull("org")) {
                         JSONObject jsonResponseOrganization = contact.optJSONObject("org");
 
-                        if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull("name")) {
-                            directoryContact.organization.name = jsonResponseOrganization.optString("name");
+                        if (jsonResponseOrganization != null && !jsonResponseOrganization.isNull(
+								"name")) {
+                            directoryContact.organization.name =
+		                            jsonResponseOrganization.optString("name");
                         }
                     }
 
@@ -1572,16 +1638,16 @@ public class APIConnector {
     /**
      * Get the full app version.
      * <p>
-     * If provided also append the mdm source to the version.
-     * This might seem to not be the appropriate location for this information
-     * but has been specified in ANDR-2213 and "Update Work Info" in documentation.
+     * If provided also append the mdm source to the version. This might seem to not be the
+     * appropriate location for this information but has been specified in ANDR-2213 and "Update
+     * Work Info" in documentation.
      *
      * @param mdmSource The source(s) of the active mdm parameters
      * @return The version string
      */
     @NonNull
     private String getUpdateWorkInfoVersion(@Nullable String mdmSource) {
-        StringBuilder updateWorkInfoVersion = new StringBuilder(version.getFullVersion());
+        StringBuilder updateWorkInfoVersion = new StringBuilder(version.getFullVersionString());
         if (mdmSource != null) {
             updateWorkInfoVersion.append(";");
             updateWorkInfoVersion.append(mdmSource);
@@ -1619,7 +1685,8 @@ public class APIConnector {
         urlConnection.setConnectTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000);
         urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000);
         urlConnection.setRequestMethod("GET");
-        urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
+        urlConnection.setRequestProperty("User-Agent",
+		        ProtocolStrings.USER_AGENT + "/" + version.getVersionString());
         if (language != null) {
             urlConnection.setRequestProperty("Accept-Language", language);
         }
@@ -1645,8 +1712,8 @@ public class APIConnector {
     /**
      * Send a HTTP POST request with the specified body to the specified URL.
      * <p>
-     * The `Content-Type` header will be set to `application/json`, and the `User-Agent`
-     * will be set appropriately as well.
+     * The `Content-Type` header will be set to `application/json`, and the `User-Agent` will be set
+     * appropriately as well.
      *
      * @param urlStr The target URL
      * @param body   The request body
@@ -1664,12 +1731,13 @@ public class APIConnector {
     /**
      * Send a HTTP POST request with the specified body to the specified URL.
      * <p>
-     * The `Content-Type` header will be set to `application/json`, and the `User-Agent`
-     * will be set appropriately as well.
+     * The `Content-Type` header will be set to `application/json`, and the `User-Agent` will be set
+     * appropriately as well.
      *
      * @param urlStr The target URL
      * @param body   The request body
-     * @return A PostJsonResult object containing the response body, UTF-8 decoded and the server's response code
+     * @return A PostJsonResult object containing the response body, UTF-8 decoded and the server's
+     * response code
      */
     @NonNull
     protected PostJsonResult postJsonWithResult(@NonNull String urlStr, @NonNull JSONObject body) throws IOException {
@@ -1683,7 +1751,8 @@ public class APIConnector {
         urlConnection.setReadTimeout(ProtocolDefines.API_REQUEST_TIMEOUT * 1000);
         urlConnection.setRequestMethod("POST");
         urlConnection.setRequestProperty("Content-Type", "application/json");
-        urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + this.version.getVersion());
+        urlConnection.setRequestProperty("User-Agent",
+		        ProtocolStrings.USER_AGENT + "/" + this.version.getVersionString());
         if (this.language != null) {
             urlConnection.setRequestProperty("Accept-Language", this.language);
         }
@@ -1695,7 +1764,8 @@ public class APIConnector {
 
         try {
             // Send request
-            try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(), StandardCharsets.UTF_8)) {
+            try (OutputStreamWriter osw = new OutputStreamWriter(urlConnection.getOutputStream(),
+		            StandardCharsets.UTF_8)) {
                 osw.write(body.toString());
             }
 
@@ -1713,8 +1783,8 @@ public class APIConnector {
     }
 
     /**
-     * Create a token response for a two-phase API request by updating
-     * the original request JSON object.
+     * Create a token response for a two-phase API request by updating the original request JSON
+     * object.
      *
      * @param p1Result      Phase 1 response.
      * @param request       Phase 1 request. This request will be updated with the signed token.
@@ -1739,7 +1809,7 @@ public class APIConnector {
     }
 
     public @Nullable APIConnector.FetchIdentityResult getFetchResultByIdentity(
-        ArrayList<APIConnector.FetchIdentityResult> results,
+        List<APIConnector.FetchIdentityResult> results,
         String identity
     ) {
         if (identity != null) {
@@ -1847,7 +1917,8 @@ public class APIConnector {
         public final String turnPassword;
         public final Date expirationDate;
 
-        public TurnServerInfo(String[] turnUrls, String[] turnUrlsDualStack, String turnUsername, String turnPassword, Date expirationDate) {
+        public TurnServerInfo(String[] turnUrls, String[] turnUrlsDualStack, String turnUsername,
+                              String turnPassword, Date expirationDate) {
             this.turnUrls = turnUrls;
             this.turnUrlsDualStack = turnUrlsDualStack;
             this.turnUsername = turnUsername;
@@ -1860,6 +1931,10 @@ public class APIConnector {
         public NetworkException(Throwable cause) {
             super(cause);
         }
+
+        public NetworkException(@Nullable String msg) {
+            super(msg);
+        }
     }
 
     public static class HttpConnectionException extends Exception {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java
index b7a14c5b..fcd8c2ec 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkContact.java
@@ -21,21 +21,22 @@
 
 package ch.threema.domain.protocol.api.work;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 public class WorkContact {
-    public final String firstName;
-    public final String lastName;
-    public final byte[] publicKey;
-    public final String threemaId;
+    public final @Nullable String firstName;
+    public final @Nullable String lastName;
+    public final @NonNull byte[] publicKey;
+    public final @NonNull String threemaId;
     public final @Nullable String jobTitle;
     public final @Nullable String department;
 
     public WorkContact(
-        String threemaId,
-        byte[] publicKey,
-        String firstName,
-        String lastName,
+        @NonNull String threemaId,
+        @NonNull byte[] publicKey,
+        @Nullable String firstName,
+        @Nullable String lastName,
         @Nullable String jobTitle,
         @Nullable String department
     ) {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java
index 7f810974..c4d9d79a 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/api/work/WorkDirectoryContact.java
@@ -24,19 +24,21 @@ package ch.threema.domain.protocol.api.work;
 import java.util.ArrayList;
 import java.util.List;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 public class WorkDirectoryContact extends WorkContact {
+    @Nullable
     public final String csi;
     public final List<String> categoryIds = new ArrayList<>();
     public final WorkOrganization organization = new WorkOrganization();
 
     public WorkDirectoryContact(
-        String threemaId,
-        byte[] publicKey,
-        String firstName,
-        String lastName,
-        String csi,
+        @NonNull String threemaId,
+        @NonNull byte[] publicKey,
+        @Nullable String firstName,
+        @Nullable String lastName,
+        @Nullable String csi,
         @Nullable String jobTitle,
         @Nullable String department
     ) {
@@ -55,7 +57,7 @@ public class WorkDirectoryContact extends WorkContact {
                 (firstName != null ? firstName : "");
         }
 
-        if (name.length() > 0) {
+        if (!name.isEmpty()) {
             return name.substring(0, 1);
         }
         return " ";
diff --git a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.java b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.java
deleted file mode 100644
index 3336f0ec..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobLoader.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.blob;
-
-import org.apache.commons.io.IOUtils;
-import org.slf4j.Logger;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.MalformedURLException;
-import java.net.URL;
-
-import javax.net.ssl.HttpsURLConnection;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.base.utils.Utils;
-import ch.threema.domain.protocol.SSLSocketFactoryFactory;
-import ch.threema.base.ProgressListener;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.ProtocolStrings;
-import ch.threema.domain.protocol.ServerAddressProvider;
-import ch.threema.domain.protocol.Version;
-
-/**
- * Helper class that loads blobs (images, videos etc.) from the blob server given a blob ID. No
- * processing is done on the loaded data; any decryption etc. must be done separately.
- */
-public class BlobLoader {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BlobLoader");
-
-	private static final int BUFFER_SIZE = 8192;
-
-	private final @NonNull SSLSocketFactoryFactory factory;
-	private final ServerAddressProvider serverAddressProvider;
-	private final boolean ipv6;
-
-	private final byte[] blobId;
-
-	private volatile boolean cancel;
-	private ProgressListener progressListener;
-	private Version version;
-
-	public BlobLoader(@NonNull SSLSocketFactoryFactory factory, byte[] blobId, boolean ipv6, ServerAddressProvider serverAddressProvider, ProgressListener progressListener) {
-		this.factory = factory;
-		this.blobId = blobId;
-		this.progressListener = progressListener;
-		this.version = new Version();
-		this.ipv6 = ipv6;
-		this.serverAddressProvider = serverAddressProvider;
-	}
-
-	/**
-	 * Attempt to load the given blob.
-	 *
-	 * @param markAsDone if true, the server is informed of successful download and will delete the
-	 * blob. Do not use for group messages.
-	 * @return blob data or null if download was cancelled
-	 */
-	public @Nullable byte[] load(boolean markAsDone) throws IOException, ThreemaException {
-
-		cancel = false;
-
-		InputStreamLength isl = getInputStream();
-
-		int read;
-		byte[] blob;
-		byte[] buffer = new byte[BUFFER_SIZE];
-		ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-		/* Content length known? */
-		if (isl.length != -1) {
-			logger.debug("Blob content length is {}", isl.length);
-
-			int offset = 0;
-			while ((read = isl.inputStream.read(buffer)) != -1 && !cancel) {
-				offset += read;
-
-				try {
-					bos.write(buffer, 0, read);
-				} catch (OutOfMemoryError e) {
-					throw new IOException("Out of memory on write");
-				}
-
-				if (progressListener != null) {
-					progressListener.updateProgress((int) ((float) 100 * offset / isl.length));
-				}
-			}
-
-			if (cancel) {
-				logger.info("Blob load cancelled");
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				return null;
-			}
-
-			if (offset != isl.length) {
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				throw new IOException("Unexpected read size. current: " + offset + ", excepted: " + isl.length);
-			}
-
-			blob = bos.toByteArray();
-		} else {
-			/* Content length is unknown - need to read until EOF */
-			logger.debug("Blob content length is unknown");
-
-			while ((read = isl.inputStream.read(buffer)) != -1 && !cancel) {
-				bos.write(buffer, 0, read);
-			}
-
-			if (cancel) {
-				logger.info("Blob load cancelled");
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				return null;
-			}
-
-			blob = bos.toByteArray();
-		}
-
-		logger.info("Blob load complete ({} bytes received)", blob.length);
-
-		if (progressListener != null) {
-			progressListener.onFinished(true);
-		}
-
-		if (markAsDone) {
-			if (blob.length > 0) {
-				this.markAsDone(blobId);
-			}
-		}
-
-		return blob;
-	}
-
-	private InputStreamLength getInputStream() throws IOException, ThreemaException {
-
-		URL blobUrl = getBlobUrl(blobId, false);
-
-		logger.info("Loading blob from {}", blobUrl.getHost());
-		HttpURLConnection connection = (HttpURLConnection)blobUrl.openConnection();
-		if (connection instanceof HttpsURLConnection) {
-			((HttpsURLConnection)connection).setSSLSocketFactory(this.factory.makeFactory(blobUrl.getHost()));
-		}
-		connection.setConnectTimeout(ProtocolDefines.BLOB_CONNECT_TIMEOUT * 1000);
-		connection.setReadTimeout(ProtocolDefines.BLOB_LOAD_TIMEOUT * 1000);
-		connection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
-		connection.setDoOutput(false);
-
-		BufferedInputStream inputStream = new BufferedInputStream(connection.getInputStream());
-		int contentLength = connection.getContentLength();
-		return new InputStreamLength(inputStream, contentLength);
-	}
-
-	public void markAsDone(byte[] blobId) {
-		try {
-			URL blobDoneUrl = getBlobUrl(blobId, true);
-
-			HttpURLConnection doneConnection = (HttpURLConnection)blobDoneUrl.openConnection();
-			if (doneConnection instanceof HttpsURLConnection) {
-				((HttpsURLConnection)doneConnection).setSSLSocketFactory(this.factory.makeFactory(blobDoneUrl.getHost()));
-			}
-			doneConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
-			doneConnection.setDoOutput(false);
-			doneConnection.setDoInput(true);
-			doneConnection.setRequestMethod("POST");
-			IOUtils.toByteArray(doneConnection.getInputStream());
-		} catch (IOException | ThreemaException e) {
-			logger.warn("Marking blob as done failed", e);
-		}
-	}
-
-	/**
-	 * Cancel a download in progress. load() will return null.
-	 */
-	public void cancel() {
-		cancel = true;
-	}
-
-	public void setProgressListener(ProgressListener progressListener) {
-		this.progressListener = progressListener;
-	}
-
-	public void setVersion(Version version) {
-		this.version = version;
-	}
-
-	private URL getBlobUrl(byte[] blobId, boolean done) throws ThreemaException, MalformedURLException {
-		String blobIdHex = Utils.byteArrayToHexString(blobId);
-		String blobIdPrefix = blobIdHex.substring(0, 2);
-		String blobUrl;
-		if (done) {
-			blobUrl = serverAddressProvider.getBlobServerDoneUrl(ipv6);
-		} else {
-			blobUrl = serverAddressProvider.getBlobServerDownloadUrl(ipv6);
-		}
-		blobUrl = blobUrl.replace("{blobIdPrefix}", blobIdPrefix)
-			.replace("{blobId}", blobIdHex);
-		return new URL(blobUrl);
-	}
-
-	private static class InputStreamLength {
-		public final BufferedInputStream inputStream;
-		public final int length;
-
-		public InputStreamLength(BufferedInputStream inputStream, int length) {
-			this.inputStream = inputStream;
-			this.length = length;
-		}
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.java b/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.java
deleted file mode 100644
index 24531d60..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/blob/BlobUploader.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.blob;
-
-import org.apache.commons.io.IOUtils;
-import org.slf4j.Logger;
-
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.URL;
-import java.nio.charset.StandardCharsets;
-
-import javax.net.ssl.HttpsURLConnection;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.base.utils.Utils;
-import ch.threema.domain.protocol.SSLSocketFactoryFactory;
-import ch.threema.base.ProgressListener;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.ProtocolStrings;
-import ch.threema.domain.protocol.ServerAddressProvider;
-import ch.threema.domain.protocol.Version;
-
-/**
- * Helper class that uploads a blob (image, video) to the blob server and returns the assigned blob
- * ID. No processing is done on the data; any encryption must happen separately.
- */
-public class BlobUploader {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BlobUploader");
-
-	private static final int CHUNK_SIZE = 16384;
-
-	private final @NonNull SSLSocketFactoryFactory factory;
-	private final ServerAddressProvider serverAddressProvider;
-	private final boolean ipv6;
-
-	private final @NonNull InputStream blobInputStream;
-	private final int blobLength;
-	private String authToken;
-	private boolean persist = false;
-
-	private volatile boolean cancel;
-	private ProgressListener progressListener;
-	private Version version;
-
-	public BlobUploader(@NonNull SSLSocketFactoryFactory factory, byte[] blobData, boolean ipv6, ServerAddressProvider serverAddressProvider, ProgressListener progressListener) {
-		this(factory, new ByteArrayInputStream(blobData), blobData.length, ipv6, serverAddressProvider, progressListener);
-	}
-
-	private BlobUploader(
-		@NonNull SSLSocketFactoryFactory factory,
-		@NonNull InputStream blobInputStream,
-		int blobLength,
-		boolean ipv6,
-		ServerAddressProvider serverAddressProvider,
-		ProgressListener progressListener
-	) {
-		this.factory = factory;
-		this.blobInputStream = blobInputStream;
-		this.blobLength = blobLength;
-		this.progressListener = progressListener;
-		this.version = new Version();
-		this.ipv6 = ipv6;
-		this.serverAddressProvider = serverAddressProvider;
-	}
-
-	/**
-	 * Upload the given blob and return the blob ID on success.
-	 *
-	 * @return blob ID
-	 * @throws IOException if a network error occurs
-	 * @throws ThreemaException if the server response is invalid
-	 */
-	public byte[] upload() throws IOException, ThreemaException {
-		cancel = false;
-
-		String urlStr = serverAddressProvider.getBlobServerUploadUrl(ipv6);
-		if (persist) {
-			urlStr += "?persist=1";
-		}
-		URL url = new URL(urlStr);
-		String boundary = "---------------------------Boundary_Line";
-
-		logger.info("Uploading blob ({} bytes)", blobLength);
-
-		HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection();
-		if (urlConnection instanceof HttpsURLConnection) {
-			((HttpsURLConnection)urlConnection).setSSLSocketFactory(this.factory.makeFactory(url.getHost()));
-		}
-		urlConnection.setConnectTimeout(ProtocolDefines.CONNECT_TIMEOUT * 1000);
-		urlConnection.setReadTimeout(ProtocolDefines.BLOB_LOAD_TIMEOUT * 1000);
-		urlConnection.setRequestMethod("POST");
-		urlConnection.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary);
-		urlConnection.setRequestProperty("User-Agent", ProtocolStrings.USER_AGENT + "/" + version.getVersion());
-		if (this.authToken != null) {
-			urlConnection.setRequestProperty("Authorization", "Token " + this.authToken);
-		}
-		String header = "--" + boundary + "\r\nContent-Disposition: form-data; name=\"blob\"; filename=\"blob.bin\"\r\n" + "Content-Type: application/octet-stream\r\n\r\n";
-		byte[] headerBytes = header.getBytes();
-
-		String footer = "\r\n--" + boundary + "--\r\n";
-		byte[] footerBytes = footer.getBytes();
-
-		urlConnection.setFixedLengthStreamingMode(headerBytes.length + blobLength + footerBytes.length);
-		urlConnection.setDoOutput(true);
-		urlConnection.setDoInput(true);
-
-		try (BufferedOutputStream bos = new BufferedOutputStream(urlConnection.getOutputStream())) {
-			bos.write(headerBytes);
-
-			int ndone = 0;
-			int nread;
-			byte[] buf = new byte[CHUNK_SIZE];
-			while ((nread = blobInputStream.read(buf)) > 0 && !cancel) {
-				bos.write(buf, 0, nread);
-				ndone += nread;
-
-				if (progressListener != null && blobLength > 0)
-					progressListener.updateProgress(100 * ndone / blobLength);
-			}
-
-			if (cancel) {
-				try {
-					bos.close();
-				} catch (ProtocolException x) {
-					//ignore this exception, the upload was canceled
-				}
-				logger.info("Blob upload cancelled");
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				return null;
-			}
-
-			bos.write(footerBytes);
-			bos.flush();
-
-			String blobIdHex;
-			try (InputStream blobIdInputStream = urlConnection.getInputStream()) {
-				blobIdHex = IOUtils.toString(blobIdInputStream, StandardCharsets.UTF_8);
-			}
-
-			if (blobIdHex == null) {
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				throw new ThreemaException("TB001");    /* Invalid blob ID received from server */
-			}
-
-			byte[] blobId = Utils.hexStringToByteArray(blobIdHex);
-			if (blobId.length != ProtocolDefines.BLOB_ID_LEN) {
-				if (progressListener != null) {
-					progressListener.onFinished(false);
-				}
-				throw new ThreemaException("TB001");    /* Invalid blob ID received from server */
-			}
-
-			if (progressListener != null) {
-				progressListener.onFinished(true);
-			}
-
-			logger.info("Blob upload completed; ID = {}", blobIdHex);
-
-			return blobId;
-		} finally {
-			urlConnection.disconnect();
-			try {
-				blobInputStream.close();
-			} catch (IOException ignored) {}
-		}
-	}
-
-	/**
-	 * Cancel an upload in progress. upload() will return null.
-	 */
-	public void cancel() {
-		cancel = true;
-	}
-
-	public void setProgressListener(ProgressListener progressListener) {
-		this.progressListener = progressListener;
-	}
-
-	public void setVersion(Version version) {
-		this.version = version;
-	}
-
-	public void setAuthToken(String authToken) {
-		this.authToken = authToken;
-	}
-
-	public void setPersist(boolean persist) { this.persist = persist; }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnection.kt
deleted file mode 100644
index 8a8dddb6..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnection.kt
+++ /dev/null
@@ -1,403 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import androidx.annotation.WorkerThread
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-import ch.threema.domain.protocol.connection.socket.ServerSocket
-import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.connection.util.MainConnectionController
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.TaskManager
-import kotlinx.coroutines.CancellationException
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.delay
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
-import java.io.IOException
-import java.net.SocketException
-import java.util.concurrent.atomic.AtomicBoolean
-import java.util.concurrent.locks.ReentrantLock
-import kotlin.concurrent.withLock
-import kotlin.math.min
-import kotlin.math.pow
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("BaseServerConnection")
-
-/**
- * The [BaseServerConnection] is an (abstract) implementation of the [ServerConnection] that utilises
- * different layers for handling different aspects of the connection:
- *  - Layer 1: Decodes the bytes received from the server into a container format
- *  - Layer 2: Demultiplexes the container into messages from different protocols (e.g. CSP, D2M)
- *  - Layer 3: Handles the authentication to the server and the transport encryption
- *  - Layer 4: Monitors the connection, reacts to some control message and sends keepalive echo requests
- *  - Layer 5: Dispatches the messages to the task manager for further processing
- *
- * Messages received in the layer 5 ([ch.threema.domain.protocol.connection.layer.EndToEndLayer]) are
- * passed on to the [ch.threema.domain.taskmanager.TaskManager] by the EndToEnd layer for further
- * processing.
- */
-internal abstract class BaseServerConnection(
-    private val dependencyProvider: ServerConnectionDependencyProvider,
-) : ServerConnection, ServerConnectionDispatcher.ExceptionHandler {
-
-    private val connectionStateListeners = mutableSetOf<ConnectionStateListener>()
-
-    private val stateLock = ReentrantLock()
-    @Volatile
-    private var state: ConnectionState = ConnectionState.DISCONNECTED
-
-    override val connectionState: ConnectionState
-        get() = stateLock.withLock { state }
-
-    private val running = AtomicBoolean(false)
-    override val isRunning: Boolean
-        get() = running.get() || connectionJob?.isActive == true
-
-    protected val socket: ServerSocket
-        get() = dependencies.socket
-
-    private lateinit var dependencies: ServerConnectionDependencies
-
-    private var reconnectAllowed = AtomicBoolean(true)
-
-    @Volatile
-    private var isReconnect = false
-
-    override val isNewConnectionSession: Boolean
-        get() = !isReconnect
-
-    private var reconnectAttemptsSinceLastLogin = 0
-    private var ioJob: Job? = null
-
-    private var connectionJob: Job? = null
-
-    private val canConnect: Boolean
-        get() = running.get() && reconnectAllowed.get()
-
-    protected val controller: MainConnectionController
-        get() = dependencies.mainController
-
-    override fun disableReconnect() {
-        reconnectAllowed.set(false)
-    }
-
-    override fun handleException(throwable: Throwable) {
-        logger.error("Exception in connection dispatcher; Cancel io processing")
-        if (this::dependencies.isInitialized) {
-            controller.ioProcessingStoppedSignal.completeExceptionally(throwable)
-            controller.dispatcher.close()
-        }
-    }
-
-    override fun addConnectionStateListener(listener: ConnectionStateListener) {
-        synchronized(connectionStateListeners) {
-            connectionStateListeners.add(listener)
-        }
-    }
-
-    override fun removeConnectionStateListener(listener: ConnectionStateListener) {
-        synchronized(connectionStateListeners) {
-            connectionStateListeners.remove(listener)
-        }
-    }
-
-    final override fun start() {
-        logger.debug("Start BaseServerConnection")
-
-        if (running.getAndSet(true) || connectionJob?.isActive == true) {
-            logger.warn("Connection is already running")
-            return
-        }
-
-        if (connectionState != ConnectionState.DISCONNECTED) {
-            logger.warn("Connection is not disconnected. Abort connecting.")
-            return
-        }
-
-        isReconnect = false
-        // Allow reconnect attempts in a new session
-        reconnectAllowed.set(true)
-
-        connectionJob = CoroutineScope(Dispatchers.Default).launch {
-            while (canConnect) {
-                var monitorCloseEventJob: Job? = null
-                try {
-                    setup()
-
-                    logger.debug("Start connecting")
-                    setConnectionState(ConnectionState.CONNECTING)
-                    socket.connect()
-                    setConnectionState(ConnectionState.CONNECTED)
-
-                    // To prevent races where this while loop has been entered just before stop()
-                    // has been called, and stop() has been called before the socket was
-                    // initialized, check again if a reconnect is still allowed. Otherwise, close
-                    // the socket and abort connection.
-                    if (!reconnectAllowed.get()) {
-                        socket.close(ServerSocketCloseReason("Reconnect not allowed"))
-                        break
-                    }
-
-                    // Handle IO until the connection dies
-                    ioJob = launch { processIo() }
-
-                    controller.connected.complete(Unit)
-                    onConnected()
-
-                    val waitForCspAuthenticatedJob = launch {
-                        controller.cspAuthenticated.await()
-                        onCspAuthenticated()
-                        reconnectAttemptsSinceLastLogin = 0
-                        setConnectionState(ConnectionState.LOGGEDIN)
-                    }
-                    // Monitor close events of the socket
-                    monitorCloseEventJob = launch {
-                        val reason = socket.closedSignal.await()
-                        logger.warn("Socket was closed, reason={}", reason)
-                        if (reason.reconnectAllowed == false) {
-                            disableReconnect()
-                        }
-                        onSocketClosed(reason)
-                        if (!waitForCspAuthenticatedJob.isCompleted) {
-                            // Cancel awaiting the csp authentication when the socket is closed
-                            // as it will never complete
-                            logger.debug("Cancel waiting for csp authentication.")
-                            waitForCspAuthenticatedJob.cancel()
-                        } else {
-                            logger.debug("Csp authentication already completed")
-                        }
-                        logger.debug("Socket watchdog completed")
-                    }
-
-                    waitForCspAuthenticatedJob.join()
-                    ioJob?.join()
-                } catch (exception: Exception) {
-                    logger.error("Connection exception", exception)
-
-                    onException(exception)
-                }
-
-                setConnectionState(ConnectionState.DISCONNECTED)
-
-                closeSocket("Disconnected")
-
-                controller.connectionClosed.complete(Unit)
-
-                if (canConnect) {
-                    prepareReconnect()
-                }
-                monitorCloseEventJob?.cancel()
-            }
-            logger.info("Connection ended")
-            running.set(false)
-        }
-    }
-
-    @WorkerThread
-    @Throws(InterruptedException::class)
-    override fun stop() {
-        synchronized(this) {
-            if (running.get()) {
-                logger.info("Stop connection")
-                disableReconnect()
-                closeSocket("Connection stopped")
-                logger.trace("Join connection job")
-                runBlocking { connectionJob?.join() }
-                logger.trace("Connection job joined")
-                controller.dispatcher.close()
-                logger.info("Connection is stopped")
-            } else {
-                logger.warn("Connection has not been started or is already stopped")
-            }
-            setConnectionState(ConnectionState.DISCONNECTED)
-        }
-    }
-
-    /**
-     * Called when the socket connection to the server has been established.
-     */
-    protected open fun onConnected() {}
-
-    /**
-     * Called when the csp handshake has been completed.
-     */
-    protected open fun onCspAuthenticated() {}
-
-    /**
-     * Called when an exception occurs during establishing the connection or if processing io has been
-     * stopped exceptionally.
-     * Note that exceptions that this method will not be called with exceptions that occurred while
-     * processing messages in the pipelines.
-     * If this method is called it means that the connection has failed and will be disconnected. It may
-     * be reconnected subsequently depending on the state of the connection.
-     */
-    protected open fun onException(t: Throwable) {}
-
-    /**
-     * Called when the server socket has been closed.
-     */
-    protected open fun onSocketClosed(reason: ServerSocketCloseReason) {}
-
-    private fun setConnectionState(state: ConnectionState) {
-        stateLock.withLock {
-            val previousState = this.state
-            this.state = state
-
-            synchronized(connectionStateListeners) {
-                if (previousState != this.state) {
-                    logger.debug("Notify connection state listeners. state={}, address={}", state, socket.address)
-                    connectionStateListeners.forEach { listener ->
-                        try {
-                            listener.updateConnectionState(state)
-                        } catch (e: Exception) {
-                            logger.warn("Exception while invoking connection state listener", e)
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private fun setup() {
-        dependencies = dependencyProvider.create(this)
-        dependencies.mainController.dispatcher.exceptionHandler = this
-
-        val socket = dependencies.socket
-        val layers = dependencies.layers
-
-        // Setup io pipeline
-        socket.source
-            .pipeThrough(layers.layer1Codec.decoder)
-            .pipeThrough(layers.layer2Codec.decoder)
-            .pipeThrough(layers.layer3Codec.decoder)
-            .pipeThrough(layers.layer4Codec.decoder)
-            .setHandler(layers.layer5Codec.sink)
-
-        layers.layer5Codec.source
-            .pipeThrough(layers.layer4Codec.encoder)
-            .pipeThrough(layers.layer3Codec.encoder)
-            .pipeThrough(layers.layer2Codec.encoder)
-            .pipeThrough(layers.layer1Codec.encoder)
-            .setHandler(socket.sink)
-    }
-
-    /**
-     * Process IO of the underlying socket.
-     *
-     * This will continue until there is either an exception while processing or the
-     * connection has been closed.
-     */
-    private suspend fun processIo() {
-        try {
-            socket.processIo()
-        } catch(e: SocketException) {
-            // This exception is thrown on a regular basis
-            // e.g. when the server closes the connection or when the socket is closed
-            // during device sleep.
-            // Since we do not want to flood the log with redundant stack traces only
-            // the exception message is logged
-            logger.warn("Socket exception while processing io: {}", e.message)
-        } catch (e: Exception) {
-            logger.error("Connection exception while processing io", e)
-        }
-    }
-
-    private fun joinIoProcessing() {
-        logger.trace("Join io processing job")
-        runBlocking { ioJob?.join() }
-        logger.trace("Io processing joined")
-    }
-
-    private fun closeSocket(msg: String) {
-        logger.info("Close socket")
-        try {
-            socket.close(ServerSocketCloseReason(msg))
-        } catch (e: IOException) {
-            logger.warn("Exception when closing socket", e)
-        }
-    }
-
-    /**
-     * Make sure [ServerSocket.close] has been called prior to reconnecting (or stopping of io processing
-     * has been initiated by other means).
-     * There might be deadlocks otherwise.
-     * This methods also waits for a calculated delay based on the previous reconnect attempts before
-     * returning.
-     */
-    private suspend fun prepareReconnect() {
-        logger.debug("Prepare reconnect")
-        isReconnect = true
-        reconnectAttemptsSinceLastLogin++
-        try {
-            joinIoProcessing()
-            /* Don't reconnect too quickly */
-            val reconnectDelay = getReconnectDelay()
-            logger.info("Waiting {} milliseconds before reconnecting", reconnectDelay)
-            delay(reconnectDelay)
-        } catch (e: CancellationException) {
-            logger.debug("Reconnect cancelled", e)
-            disableReconnect()
-        }
-    }
-
-    /**
-     * Calculate the reconnect delay with bounded exponential backoff.
-     */
-    private fun getReconnectDelay(): Long {
-        val base = ProtocolDefines.RECONNECT_BASE_INTERVAL.toDouble()
-        val exponent = min(reconnectAttemptsSinceLastLogin - 1, 10)
-        val reconnectDelayS = base.pow(exponent)
-        val delayS = min(reconnectDelayS, ProtocolDefines.RECONNECT_MAX_INTERVAL.toDouble())
-        return (delayS * 1000).toLong()
-    }
-}
-
-interface BaseServerConnectionConfiguration {
-    val identityStore: IdentityStoreInterface
-    val serverAddressProvider: ServerAddressProvider
-    val version: Version
-
-    /**
-     * If set to `true` it will be asserted that received messages
-     * are actually processed in the connection's [ServerConnectionDispatcher]'s
-     * context.
-     * If the messages are not processed in the correct context and
-     * [assertDispatcherContext] set to `true`, an [Error] will
-     * be thrown.
-     * This is meant for development purposes and should be disabled in production.
-     */
-    val assertDispatcherContext: Boolean
-
-    val deviceCookieManager: DeviceCookieManager
-
-    val incomingMessageProcessor: IncomingMessageProcessor
-
-    val taskManager: TaskManager
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnectionProvider.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnectionProvider.kt
deleted file mode 100644
index 18914694..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/BaseServerConnectionProvider.kt
+++ /dev/null
@@ -1,166 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import ch.threema.domain.protocol.connection.csp.CspConnectionConfiguration
-import ch.threema.domain.protocol.connection.csp.CspConnectionImpl
-import ch.threema.domain.protocol.connection.csp.CspControllers
-import ch.threema.domain.protocol.connection.csp.socket.ChatServerAddressProvider
-import ch.threema.domain.protocol.connection.csp.socket.ChatServerAddressProviderImpl
-import ch.threema.domain.protocol.connection.csp.socket.CspSocket
-import ch.threema.domain.protocol.connection.d2m.D2mConnectionConfiguration
-import ch.threema.domain.protocol.connection.d2m.D2mConnectionImpl
-import ch.threema.domain.protocol.connection.d2m.D2mControllers
-import ch.threema.domain.protocol.connection.d2m.socket.D2mServerAddressProvider
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocket
-import ch.threema.domain.protocol.connection.layer.AuthLayer
-import ch.threema.domain.protocol.connection.layer.CspFrameLayer
-import ch.threema.domain.protocol.connection.layer.D2mFrameLayer
-import ch.threema.domain.protocol.connection.layer.EndToEndLayer
-import ch.threema.domain.protocol.connection.layer.MonitoringLayer
-import ch.threema.domain.protocol.connection.layer.MultiplexLayer
-import ch.threema.domain.protocol.connection.layer.ServerConnectionLayers
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.InternalTaskManager
-import kotlin.coroutines.CoroutineContext
-
-object BaseServerConnectionProvider {
-    @JvmStatic
-    fun createConnection(configuration: BaseServerConnectionConfiguration): ServerConnection {
-        return when (configuration) {
-            is CspConnectionConfiguration -> createCspConnection(configuration)
-            is D2mConnectionConfiguration -> createD2mConnection(configuration)
-            else -> throw ServerConnectionException("Unsupported connection configuration")
-        }
-    }
-
-    private fun createD2mConnection(configuration: D2mConnectionConfiguration): ServerConnection {
-        val dependencyProvider = ServerConnectionDependencyProvider {
-            createD2mDependencies(it, configuration)
-        }
-
-        return D2mConnectionImpl(
-            dependencyProvider,
-            configuration.closeListener
-        )
-    }
-
-    private fun createD2mDependencies(
-        connection: ServerConnection,
-        configuration: D2mConnectionConfiguration
-    ): ServerConnectionDependencies {
-        val controllers = D2mControllers(configuration)
-
-        val addressProvider = D2mServerAddressProvider(
-            configuration.serverAddressProvider,
-            configuration.multiDevicePropertyProvider.get().keys.dgid,
-            configuration.identityStore.serverGroup
-        )
-
-        val socket = D2mSocket(
-            configuration.okHttpClient,
-            addressProvider,
-            controllers.mainController.ioProcessingStoppedSignal,
-            controllers.serverConnectionController.dispatcher.coroutineContext
-        )
-
-        val layers = createD2mLayers(
-            connection,
-            controllers,
-            controllers.serverConnectionController.dispatcher.coroutineContext,
-            configuration.incomingMessageProcessor,
-            configuration.taskManager as InternalTaskManager
-        )
-
-        return ServerConnectionDependencies(controllers.mainController, socket, layers)
-
-    }
-
-    private fun createD2mLayers(
-        connection: ServerConnection,
-        controllers: D2mControllers,
-        dispatcher: CoroutineContext,
-        incomingMessageProcessor: IncomingMessageProcessor,
-        taskManager: InternalTaskManager
-    ): ServerConnectionLayers {
-        return ServerConnectionLayers(
-            D2mFrameLayer(),
-            MultiplexLayer(controllers.serverConnectionController),
-            AuthLayer(controllers.layer3Controller),
-            MonitoringLayer(connection, controllers.layer4Controller),
-            EndToEndLayer(dispatcher, controllers.serverConnectionController, connection, incomingMessageProcessor, taskManager)
-        )
-    }
-
-    private fun createCspConnection(
-        configuration: CspConnectionConfiguration
-    ): ServerConnection {
-        val chatServerAddressProvider = ChatServerAddressProviderImpl(configuration)
-
-        val dependencyProvider = ServerConnectionDependencyProvider {
-            createCspDependencies(it, configuration, chatServerAddressProvider)
-        }
-
-        return CspConnectionImpl(dependencyProvider)
-    }
-
-    private fun createCspDependencies(
-        connection: ServerConnection,
-        configuration: CspConnectionConfiguration,
-        chatServerAddressProvider: ChatServerAddressProvider
-    ): ServerConnectionDependencies {
-        val controllers = CspControllers(configuration)
-
-        val socket = CspSocket(
-            configuration.socketFactory,
-            chatServerAddressProvider,
-            controllers.mainController.ioProcessingStoppedSignal,
-            controllers.serverConnectionController.dispatcher.coroutineContext
-        )
-
-        val layers = createCspLayers(
-            connection,
-            controllers,
-            controllers.serverConnectionController.dispatcher.coroutineContext,
-            configuration.incomingMessageProcessor,
-            configuration.taskManager as InternalTaskManager,
-        )
-
-        return ServerConnectionDependencies(controllers.mainController, socket, layers)
-    }
-
-    private fun createCspLayers(
-        connection: ServerConnection,
-        controllers: CspControllers,
-        dispatcher: CoroutineContext,
-        incomingMessageProcessor: IncomingMessageProcessor,
-        taskManager: InternalTaskManager,
-    ): ServerConnectionLayers {
-        return ServerConnectionLayers(
-            CspFrameLayer(),
-            MultiplexLayer(controllers.serverConnectionController),
-            AuthLayer(controllers.layer3Controller),
-            MonitoringLayer(connection, controllers.layer4Controller),
-            EndToEndLayer(dispatcher, controllers.serverConnectionController, connection, incomingMessageProcessor, taskManager),
-        )
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionState.java b/domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionState.java
deleted file mode 100644
index 3853963e..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionState.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection;
-
-public enum ConnectionState {
-	DISCONNECTED, CONNECTING, CONNECTED, LOGGEDIN
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionStateListener.java b/domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionStateListener.java
deleted file mode 100644
index b7956ef9..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ConnectionStateListener.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection;
-
-/**
- * Interface for objects that wish to be informed about changes in the server connection state.
- */
-public interface ConnectionStateListener {
-	void updateConnectionState(ConnectionState connectionState);
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ConvertibleServerConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/ConvertibleServerConnection.kt
deleted file mode 100644
index 7e525f88..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ConvertibleServerConnection.kt
+++ /dev/null
@@ -1,122 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import androidx.annotation.WorkerThread
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import java8.util.function.Supplier
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("ConvertibleServerConnection")
-
-/**
- * A wrapper that can handle changing connections. Every time the connection is started the used
- * connection is retrieved by calling [Supplier.get] of the [connectionSupplier].
- *
- * The [connectionSupplier] is responsible to provide a [ServerConnection] that can be used without
- * interfering with the previous connection.
- */
-open class ConvertibleServerConnection(
-    private val connectionSupplier: Supplier<ServerConnection>,
-) : ServerConnection, ConnectionStateListener, ReconnectableServerConnection {
-
-    private val connectionStateListeners = mutableSetOf<ConnectionStateListener>()
-
-    private var connection: ServerConnection? = null
-
-    override val isRunning: Boolean
-        get() = connection?.isRunning ?: false
-
-    override val connectionState: ConnectionState
-        get() = connection?.connectionState ?: ConnectionState.DISCONNECTED
-
-    override val isNewConnectionSession: Boolean
-        get() = connection?.isNewConnectionSession ?: true
-
-    override fun disableReconnect() {
-        connection?.disableReconnect()
-    }
-
-    override fun start() {
-        logger.debug("Start ConvertibleServerConnection")
-
-        if (connection?.isRunning == true) {
-            logger.warn("Connection is already running")
-            return
-        }
-
-        if (!connection.let { it == null || it.connectionState == ConnectionState.DISCONNECTED }) {
-            logger.warn("Connection is neither new nor disconnected. Abort connecting.")
-            return
-        }
-
-        connectionSupplier.get().also {
-            if (it != connection) {
-                logger.debug("Connection has changed")
-                connection?.removeConnectionStateListener(this)
-                it.addConnectionStateListener(this)
-                connection = it
-            }
-        }.start()
-    }
-
-    @WorkerThread
-    @Throws(InterruptedException::class)
-    override fun stop() {
-        synchronized(this) {
-            connection?.stop()
-        }
-    }
-
-    @WorkerThread
-    @Throws(InterruptedException::class)
-    override fun reconnect() {
-        synchronized(this) {
-            logger.info("Reconnect")
-            stop()
-            start()
-        }
-    }
-
-    override fun addConnectionStateListener(listener: ConnectionStateListener) {
-        synchronized(connectionStateListeners) {
-            connectionStateListeners.add(listener)
-        }
-    }
-
-    override fun removeConnectionStateListener(listener: ConnectionStateListener) {
-        synchronized(connectionStateListeners) {
-            connectionStateListeners.remove(listener)
-        }
-    }
-
-    override fun updateConnectionState(connectionState: ConnectionState?) {
-        synchronized(connectionStateListeners) {
-            connectionStateListeners.forEach { listener ->
-                try {
-                    listener.updateConnectionState(connectionState)
-                } catch (e: Exception) {
-                    logger.warn("Exception while invoking connection state listener", e)
-                }
-            }
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/PayloadProcessingException.java b/domain/src/main/java/ch/threema/domain/protocol/connection/PayloadProcessingException.java
deleted file mode 100644
index fcd46df3..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/PayloadProcessingException.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection;
-
-public class PayloadProcessingException extends Exception {
-
-	private static final long serialVersionUID = -2619972211818695496L;
-
-	public PayloadProcessingException(String msg) {
-		super(msg);
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ReconnectableServerConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/ReconnectableServerConnection.kt
deleted file mode 100644
index b3a37a95..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ReconnectableServerConnection.kt
+++ /dev/null
@@ -1,35 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import androidx.annotation.WorkerThread
-
-interface ReconnectableServerConnection {
-    /**
-     * Reconnect the [ServerConnection].
-     * This is usually accomplished by stopping and then starting the connection but may
-     * differ depending on the implementation.
-     */
-    @WorkerThread
-    @Throws(InterruptedException::class)
-    fun reconnect()
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnection.kt
deleted file mode 100644
index a5e3c7fb..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnection.kt
+++ /dev/null
@@ -1,68 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import androidx.annotation.WorkerThread
-
-/**
- * The [ServerConnection] connects to the server used for the exchange of messages. Different types
- * of servers (e.g. CSP-Server, Mediator-Server) will have different implementations.
- *
- * This interface only defines, how the connection is started, stopped and monitored. It does not
- * define how actual messages are exchanged with the server. This can be handled differently depending
- * on the implementation.
- */
-interface ServerConnection {
-
-    val isRunning: Boolean
-
-    val connectionState: ConnectionState
-
-    val isNewConnectionSession: Boolean
-
-    /**
-     * Disable the connection to attempt a reconnect in this session.
-     * If a new connection session is started (e.g. [start] or the app is restarted) the
-     * flag is reset.
-     */
-    fun disableReconnect()
-
-    /**
-     * Start the connection. The connection must handle sending and receiving of messages in an own thread.
-     */
-    fun start()
-
-    /**
-     * Stop the connection and wait for processing to terminate.
-     *
-     * There won't be an attempt to reconnect after the connection has been stopped by this method.
-     *
-     * This is a blocking call and should only be called
-     * from a worker thread, not from the main thread.
-     */
-    @WorkerThread
-    @Throws(InterruptedException::class)
-    fun stop()
-
-    fun addConnectionStateListener(listener: ConnectionStateListener)
-    fun removeConnectionStateListener(listener: ConnectionStateListener)
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDependencies.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDependencies.kt
deleted file mode 100644
index 60bdccf8..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDependencies.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import ch.threema.domain.protocol.connection.layer.ServerConnectionLayers
-import ch.threema.domain.protocol.connection.socket.ServerSocket
-import ch.threema.domain.protocol.connection.util.MainConnectionController
-
-internal fun interface ServerConnectionDependencyProvider {
-    fun create(connection: ServerConnection): ServerConnectionDependencies
-}
-
-internal data class ServerConnectionDependencies (
-    val mainController: MainConnectionController,
-    val socket: ServerSocket,
-    val layers: ServerConnectionLayers,
-)
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDispatcher.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDispatcher.kt
deleted file mode 100644
index 46b64262..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionDispatcher.kt
+++ /dev/null
@@ -1,96 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import ch.threema.base.concurrent.TrulySingleThreadExecutorThreadFactory
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import kotlinx.coroutines.CoroutineExceptionHandler
-import kotlinx.coroutines.ExecutorCoroutineDispatcher
-import kotlinx.coroutines.asCoroutineDispatcher
-import java.lang.ref.WeakReference
-import java.util.concurrent.Executors
-import kotlin.coroutines.CoroutineContext
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("ServerConnectionDispatcher")
-
-internal interface ServerConnectionDispatcher {
-    fun interface ExceptionHandler {
-        fun handleException(throwable: Throwable)
-    }
-
-    var exceptionHandler: ExceptionHandler?
-
-    val coroutineContext: CoroutineContext
-
-    fun assertDispatcherContext()
-
-    /**
-     * Close the dispatcher and shutdown the executor. Beware that the [coroutineContext] cannot be used
-     * after this call.
-     */
-    fun close()
-}
-
-internal class SingleThreadedServerConnectionDispatcher(private val assertContext: Boolean) : ServerConnectionDispatcher {
-
-    private companion object {
-        var THREADS_CREATED = 0
-    }
-
-    private lateinit var thread: Thread
-
-    private var exceptionHandlerReference: WeakReference<ServerConnectionDispatcher.ExceptionHandler>? = null
-    override var exceptionHandler: ServerConnectionDispatcher.ExceptionHandler?
-        get() = exceptionHandlerReference?.get()
-        set(value) {
-            exceptionHandlerReference = WeakReference(value)
-        }
-
-    private val dispatcher: ExecutorCoroutineDispatcher
-    override val coroutineContext: CoroutineContext
-
-    init {
-        val factory = TrulySingleThreadExecutorThreadFactory("ServerConnectionWorker-${THREADS_CREATED++}") {
-            thread = it
-        }
-        dispatcher = Executors.newSingleThreadExecutor(factory).asCoroutineDispatcher()
-
-        val handler = CoroutineExceptionHandler { _, throwable -> exceptionHandler?.handleException(throwable) }
-        coroutineContext = dispatcher.plus(handler)
-    }
-
-    override fun assertDispatcherContext() {
-        if (assertContext) {
-            val actual = Thread.currentThread()
-            if (actual !== thread) {
-                val msg = "Thread mismatch, expected '${thread.name}', got '${actual.name}'"
-                logger.error(msg)
-                throw Error(msg)
-            }
-        }
-    }
-
-    override fun close() {
-        logger.info("Close connection dispatcher")
-        dispatcher.close()
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionException.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionException.kt
deleted file mode 100644
index 663436ed..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/ServerConnectionException.kt
+++ /dev/null
@@ -1,31 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import ch.threema.base.ThreemaException
-
-open class ServerConnectionException : ThreemaException {
-    constructor(msg: String?) : super(msg)
-    constructor(msg: String?, cause: Throwable?) : super(msg, cause)
-}
-
-class InvalidSizeException(msg: String?) : ServerConnectionException(msg)
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspConnection.kt
deleted file mode 100644
index b41a63bf..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspConnection.kt
+++ /dev/null
@@ -1,84 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp
-
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.BaseServerConnection
-import ch.threema.domain.protocol.connection.BaseServerConnectionConfiguration
-import ch.threema.domain.protocol.connection.ConnectionState
-import ch.threema.domain.protocol.connection.ServerConnectionDependencyProvider
-import ch.threema.domain.protocol.connection.csp.socket.CspSocket
-import ch.threema.domain.protocol.connection.csp.socket.HostResolver
-import ch.threema.domain.protocol.connection.csp.socket.SocketFactory
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.TaskManager
-/**
- * Only this interface is exposed to other modules
- */
-interface CspConnection
-
-internal class CspConnectionImpl(
-    dependencyProvider: ServerConnectionDependencyProvider
-) : CspConnection, BaseServerConnection(dependencyProvider) {
-
-    override fun onConnected() {
-        socket.let {
-            if (it is CspSocket) {
-                it.setSocketSoTimeout(ProtocolDefines.READ_TIMEOUT * 1000)
-            }
-        }
-    }
-
-    override fun onCspAuthenticated() {
-        socket.let {
-            if (it is CspSocket) {
-                it.setSocketSoTimeout(0)
-            }
-        }
-    }
-
-    override fun onException(t: Throwable) {
-        if (connectionState != ConnectionState.LOGGEDIN) {
-            socket.let {
-                if (it is CspSocket) {
-                    it.advanceAddress()
-                }
-            }
-        }
-    }
-}
-
-data class CspConnectionConfiguration(
-    override val identityStore: IdentityStoreInterface,
-    override val serverAddressProvider: ServerAddressProvider,
-    override val version: Version,
-    override val assertDispatcherContext: Boolean,
-    override val deviceCookieManager: DeviceCookieManager,
-    override val incomingMessageProcessor: IncomingMessageProcessor,
-    override val taskManager: TaskManager,
-    val hostResolver: HostResolver,
-    val ipv6: Boolean,
-    val socketFactory: SocketFactory
-) : BaseServerConnectionConfiguration
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspController.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspController.kt
deleted file mode 100644
index d126ecb2..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspController.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp
-
-import ch.threema.domain.protocol.connection.SingleThreadedServerConnectionDispatcher
-import ch.threema.domain.protocol.connection.util.Layer3Controller
-import ch.threema.domain.protocol.connection.util.Layer4Controller
-import ch.threema.domain.protocol.connection.util.MainConnectionController
-import ch.threema.domain.protocol.connection.util.ServerConnectionController
-import kotlinx.coroutines.CompletableDeferred
-
-internal class CspController(configuration: CspConnectionConfiguration) :
-    ServerConnectionController,
-    Layer3Controller,
-    Layer4Controller,
-    MainConnectionController {
-
-    override val dispatcher = SingleThreadedServerConnectionDispatcher(
-        configuration.assertDispatcherContext
-    )
-
-    override val cspSession: CspSession = CspSession(configuration, dispatcher)
-
-    override val cspSessionState: CspSessionState = cspSession
-
-    override val connectionClosed = CompletableDeferred<Unit>()
-
-    override val connected = CompletableDeferred<Unit>()
-
-    override val cspAuthenticated = CompletableDeferred<Unit>()
-
-    override val ioProcessingStoppedSignal = CompletableDeferred<Unit>()
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspControllers.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspControllers.kt
deleted file mode 100644
index 02fe92a5..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspControllers.kt
+++ /dev/null
@@ -1,37 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp
-
-import ch.threema.domain.protocol.connection.util.Layer3Controller
-import ch.threema.domain.protocol.connection.util.Layer4Controller
-import ch.threema.domain.protocol.connection.util.MainConnectionController
-import ch.threema.domain.protocol.connection.util.ServerConnectionController
-import ch.threema.domain.protocol.connection.util.ServerConnectionControllers
-
-internal class CspControllers(cspConnectionConfiguration: CspConnectionConfiguration) : ServerConnectionControllers {
-    private val cspController = CspController(cspConnectionConfiguration)
-
-    override val serverConnectionController: ServerConnectionController = cspController
-    override val mainController: MainConnectionController = cspController
-    override val layer3Controller: Layer3Controller = cspController
-    override val layer4Controller: Layer4Controller = cspController
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt
deleted file mode 100644
index 420c7be6..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/CspSession.kt
+++ /dev/null
@@ -1,355 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp
-
-import ch.threema.base.crypto.NonceCounter
-import ch.threema.base.crypto.ThreemaKDF
-import ch.threema.base.utils.TimeMeasureUtil
-import ch.threema.base.utils.toHexString
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.BaseServerConnectionConfiguration
-import ch.threema.domain.protocol.connection.InputPipe
-import ch.threema.domain.protocol.connection.ServerConnectionDispatcher
-import ch.threema.domain.protocol.connection.ServerConnectionException
-import ch.threema.domain.protocol.connection.d2m.D2mConnectionConfiguration
-import ch.threema.domain.protocol.connection.data.CspContainer
-import ch.threema.domain.protocol.connection.data.CspFrame
-import ch.threema.domain.protocol.connection.data.CspLoginMessage
-import ch.threema.domain.protocol.connection.data.DeviceId
-import ch.threema.domain.protocol.connection.data.leBytes
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.stores.IdentityStoreInterface
-import com.neilalexander.jnacl.NaCl
-import org.apache.commons.io.EndianUtils
-import ove.crypto.digest.Blake2b
-import java.io.ByteArrayInputStream
-import java.io.ByteArrayOutputStream
-import java.io.IOException
-import java.io.InputStream
-import java.security.SecureRandom
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("CspSession")
-
-interface CspSessionState {
-    val isLoginDone: Boolean
-}
-internal class CspSession(
-    private val configuration: BaseServerConnectionConfiguration,
-    private val dispatcher: ServerConnectionDispatcher
-) : CspSessionState {
-    private enum class LoginState {
-        IDLE,
-        AWAIT_HELLO,
-        AWAIT_LOGIN_ACK,
-        DONE
-    }
-
-    private val timeMeasureUtil = TimeMeasureUtil()
-
-    private val version: Version
-        get() = configuration.version
-    private val identityStore: IdentityStoreInterface
-        get() = configuration.identityStore
-    private val cspDeviceId: DeviceId?
-        get() = when(configuration) {
-            is D2mConnectionConfiguration -> configuration.multiDevicePropertyProvider.get().cspDeviceId
-            else -> null
-        }
-    private val serverAddressProvider: ServerAddressProvider
-        get() = configuration.serverAddressProvider
-    private val deviceCookieManager: DeviceCookieManager
-        get() = configuration.deviceCookieManager
-
-    private var loginState = LoginState.IDLE
-
-    private lateinit var clientCookie: ByteArray
-    private lateinit var serverCookie: ByteArray
-
-    private lateinit var clientTempKeyPub: ByteArray
-    private lateinit var clientTempKeySec: ByteArray
-
-    private lateinit var serverPubKeyPerm: ByteArray
-
-    private lateinit var kClientTempServerTemp: NaCl
-
-    private lateinit var serverNonce: NonceCounter
-    private lateinit var clientNonce: NonceCounter
-
-    override val isLoginDone: Boolean
-        get() = loginState == LoginState.DONE
-
-    fun startLogin(outbound: InputPipe<in CspLoginMessage>) {
-        dispatcher.assertDispatcherContext()
-        logger.debug("Start csp login")
-
-        createTemporaryKeypair()
-
-        sendClientHello(outbound)
-        loginState = LoginState.AWAIT_HELLO
-    }
-
-    fun handleLoginMessage(message: CspLoginMessage, outbound: InputPipe<in CspLoginMessage>) {
-        dispatcher.assertDispatcherContext()
-
-        loginState = when (loginState) {
-            LoginState.AWAIT_HELLO -> {
-                timeMeasureUtil.stop()
-                val serverTempKeyPub = processServerHello(message)
-                sendClientLogin(serverTempKeyPub, outbound)
-                LoginState.AWAIT_LOGIN_ACK
-            }
-            LoginState.AWAIT_LOGIN_ACK -> {
-                timeMeasureUtil.stop()
-                processServerLoginAck(message)
-                LoginState.DONE
-            }
-            else -> throw ServerConnectionException("Unexpected CspLoginMessage message in login state $loginState")
-        }
-    }
-
-    fun encryptContainer(container: CspContainer): CspFrame {
-        dispatcher.assertDispatcherContext()
-
-        if (loginState != LoginState.DONE) {
-            throw ServerConnectionException("Message cannot be encrypted; login not completed")
-        }
-        val payload = byteArrayOf(container.payloadType.toByte()) +
-            ByteArray(3) +
-            container.data
-
-        logger.trace("Encrypt CspContainer with {} data bytes (payload size: {} bytes)", container.data.size, payload.size)
-        return CspFrame(kClientTempServerTemp.encrypt(payload, clientNonce.nextNonce()))
-    }
-
-    fun decryptBox(frame: CspFrame): CspContainer {
-        dispatcher.assertDispatcherContext()
-
-        if (loginState != LoginState.DONE) {
-            throw ServerConnectionException("CspFrame cannot be decrypted; login not completed")
-        }
-        val decrypted = kClientTempServerTemp.decrypt(frame.box, serverNonce.nextNonce())
-            ?: throw ServerConnectionException("Payload decryption failed")
-        val payloadType = decrypted[0].toUByte()
-        val dataLength = decrypted.size - 4
-        val data = ByteArray(dataLength)
-        System.arraycopy(decrypted, 4, data, 0, dataLength)
-        return CspContainer(payloadType, data)
-    }
-
-    private fun createTemporaryKeypair() {
-        clientTempKeyPub = ByteArray(NaCl.PUBLICKEYBYTES)
-        clientTempKeySec = ByteArray(NaCl.SECRETKEYBYTES)
-        NaCl.genkeypair(clientTempKeyPub, clientTempKeySec)
-    }
-
-    /**
-     * @return The server's temporary public key
-     */
-    private fun processServerHello(message: CspLoginMessage): ByteArray {
-        dispatcher.assertDispatcherContext()
-
-        if (message.bytes.size != ProtocolDefines.SERVER_HELLO_LEN) {
-            throw ServerConnectionException("Server hello has invalid length")
-        }
-
-        try {
-            ByteArrayInputStream(message.bytes).use {
-                readServerCookie(it)
-                val serverHello = decryptServerHello(it)
-                assertCorrectClientCookie(serverHello)
-                val serverTempKeyPub = processServerHello(serverHello)
-                logger.info("Server hello successful (rtt: {} ms)", timeMeasureUtil.elapsedTime)
-                return serverTempKeyPub
-            }
-        } catch (e: IOException) {
-            throw ServerConnectionException("Exception while handling server-hello", e)
-        }
-    }
-
-    private fun readServerCookie(input: InputStream) {
-        dispatcher.assertDispatcherContext()
-
-        serverCookie = readNBytes(input, ProtocolDefines.COOKIE_LEN)
-        if (logger.isDebugEnabled) {
-            logger.debug("Server cookie = {}", NaCl.asHex(serverCookie))
-        }
-        serverNonce = NonceCounter(serverCookie)
-    }
-
-    private fun decryptServerHello(input: InputStream): ByteArray {
-        dispatcher.assertDispatcherContext()
-
-        val serverHelloBox = readNBytes(input, ProtocolDefines.SERVER_HELLO_BOXLEN)
-        val nonce = serverNonce.nextNonce()
-        if (logger.isDebugEnabled) {
-            logger.debug("Server nonce = {}", NaCl.asHex(nonce))
-        }
-
-        serverPubKeyPerm = serverAddressProvider.chatServerPublicKey
-        var kClientTempServerPerm = NaCl(clientTempKeySec, serverPubKeyPerm)
-        var serverHello = kClientTempServerPerm.decrypt(serverHelloBox, nonce)
-
-        if (serverHello == null) {
-            /* Try again with alternate key */
-            serverPubKeyPerm = serverAddressProvider.chatServerPublicKeyAlt
-            kClientTempServerPerm = NaCl(clientTempKeySec, serverPubKeyPerm)
-            serverHello = kClientTempServerPerm.decrypt(serverHelloBox, nonce)
-            if (serverHello == null) {
-                throw ServerConnectionException("Decryption of server hello box failed")
-            }
-        }
-        return serverHello
-    }
-
-    /**
-     * Assert that the client cookie from server hello matches the local clientCookie
-     */
-    private fun assertCorrectClientCookie(serverHello: ByteArray) {
-        val clientCookieFromServer = ByteArray(ProtocolDefines.COOKIE_LEN)
-        System.arraycopy(serverHello, NaCl.PUBLICKEYBYTES, clientCookieFromServer, 0, ProtocolDefines.COOKIE_LEN)
-
-        if (!clientCookieFromServer.contentEquals(clientCookie)) {
-            throw ServerConnectionException("Client cookie mismatch")
-        }
-    }
-    /**
-     * Extract server tempkey from server hello.
-     *
-     * @return The server's temporary public key
-     */
-    private fun processServerHello(serverHello: ByteArray): ByteArray {
-        dispatcher.assertDispatcherContext()
-
-        val serverTempKeyPub = ByteArray(NaCl.PUBLICKEYBYTES)
-        System.arraycopy(serverHello, 0, serverTempKeyPub, 0, NaCl.PUBLICKEYBYTES)
-
-        kClientTempServerTemp = NaCl(clientTempKeySec, serverTempKeyPub)
-
-        return serverTempKeyPub
-    }
-
-    private fun readNBytes(input: InputStream, n: Int): ByteArray {
-        dispatcher.assertDispatcherContext()
-
-        val data = ByteArray(n)
-        if (input.read(data) != n) {
-            throw ServerConnectionException("Could not read $n bytes from input")
-        }
-        return data
-    }
-
-    /**
-     * This will create a client cookie and initalize the clientnonce.
-     *
-     * The clientCookie is then sent to the server as client-hello
-     */
-    private fun sendClientHello(outbound: InputPipe<in CspLoginMessage>) {
-        dispatcher.assertDispatcherContext()
-
-        clientCookie = ByteArray(ProtocolDefines.COOKIE_LEN)
-        SecureRandom().nextBytes(clientCookie)
-        if (logger.isDebugEnabled) {
-            logger.debug("Client cookie = {}", NaCl.asHex(clientCookie))
-        }
-        clientNonce = NonceCounter(clientCookie)
-        val clientHello = clientTempKeyPub + clientCookie
-        timeMeasureUtil.start()
-        outbound.send(CspLoginMessage(clientHello))
-    }
-
-    private fun sendClientLogin(serverTempKeyPub: ByteArray, outbound: InputPipe<in CspLoginMessage>) {
-        dispatcher.assertDispatcherContext()
-
-        val loginNonce = clientNonce.nextNonce()
-        val extensionsNonce = clientNonce.nextNonce()
-
-        val extensionsBox = kClientTempServerTemp.encrypt(createExtensions(), extensionsNonce)
-        val vouch = createVouch(serverTempKeyPub)
-
-        val login = identityStore.identity.encodeToByteArray() +
-            createExtensionIndicator(extensionsBox.size) +
-            serverCookie +
-            ByteArray(ProtocolDefines.RESERVED1_LEN) +
-            vouch +
-            ByteArray(ProtocolDefines.RESERVED2_LEN)
-
-        if (login.size != ProtocolDefines.LOGIN_LEN) {
-            throw ServerConnectionException("Invalid login packet length")
-        }
-
-        val loginBox = kClientTempServerTemp.encrypt(login, loginNonce)
-        timeMeasureUtil.start()
-        outbound.send(CspLoginMessage(loginBox + extensionsBox))
-        logger.debug("Sent login packet")
-    }
-
-    private fun createExtensions(): ByteArray {
-        /* Client info (0x00) */
-        val clientInfo = ProtocolExtension(ProtocolExtension.CLIENT_INFO_TYPE, version.fullVersion.encodeToByteArray())
-
-        /* Csp device id (0x01) if multi device is active, omit if md is not active */
-        val cspDeviceIdBytes = cspDeviceId
-            ?.let { ProtocolExtension(ProtocolExtension.CSP_DEVICE_ID_TYPE, it.leBytes()).bytes }
-            ?: ByteArray(0)
-        logger.trace("Csp  device id bytes {}", cspDeviceIdBytes.toHexString())
-
-        /* Message payload version (0x02) */
-        val messagePayloadVersion = ProtocolExtension(ProtocolExtension.MESSAGE_PAYLOAD_VERSION_TYPE, byteArrayOf(ProtocolExtension.MESSAGE_PAYLOAD_VERSION.toByte()))
-
-        /* Device cookie extension (0x03) */
-        val deviceCookie = ProtocolExtension(ProtocolExtension.DEVICE_COOKIE_TYPE, deviceCookieManager.obtainDeviceCookie())
-
-        return clientInfo.bytes + cspDeviceIdBytes +  messagePayloadVersion.bytes + deviceCookie.bytes
-    }
-
-    private fun createExtensionIndicator(extensionsBoxLength: Int): ByteArray {
-        if (extensionsBoxLength > UShort.MAX_VALUE.toInt()) {
-            throw ServerConnectionException("Extensions box is too long")
-        }
-        val bos = ByteArrayOutputStream(ProtocolDefines.EXTENSION_INDICATOR_LEN)
-        bos.write(ProtocolExtension.VERSION_MAGIC_STRING.encodeToByteArray())
-        EndianUtils.writeSwappedShort(bos, extensionsBoxLength.toShort())
-        return bos.toByteArray()
-    }
-
-    private fun createVouch(serverTempKeyPub: ByteArray): ByteArray {
-        val kdf = ThreemaKDF("3ma-csp")
-        val sharedSecrets = identityStore.calcSharedSecret(serverPubKeyPerm) + identityStore.calcSharedSecret(serverTempKeyPub)
-        val vouchKey = kdf.deriveKey("v2", sharedSecrets)
-        val input = serverCookie + clientTempKeyPub
-        return Blake2b.Mac.newInstance(vouchKey, ProtocolDefines.VOUCH_LEN).digest(input)
-    }
-
-    private fun processServerLoginAck(message: CspLoginMessage) {
-        dispatcher.assertDispatcherContext()
-
-        if (message.bytes.size != ProtocolDefines.SERVER_LOGIN_ACK_LEN) {
-            throw ServerConnectionException("Login ack has invalid length")
-        }
-
-        kClientTempServerTemp.decrypt(message.bytes, serverNonce.nextNonce())
-            ?: throw ServerConnectionException("Decryption of login ack box failed")
-        logger.info("Login ack received (rtt: {} ms)", timeMeasureUtil.elapsedTime)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/DeviceCookieManager.java b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/DeviceCookieManager.java
deleted file mode 100644
index 842e5865..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/DeviceCookieManager.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2022-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp;
-
-public interface DeviceCookieManager {
-	/**
-	 * Obtain an existing or new device cookie.
-	 * @return the device cookie (16 bytes)
-	 */
-	byte[] obtainDeviceCookie();
-
-	/**
-	 * Inform the manager that a device cookie change indication has been received from the server.
-	 */
-	void changeIndicationReceived();
-
-	/**
-	 * Delete the stored device cookie, if any.
-	 */
-	void deleteDeviceCookie();
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/ProtocolExtension.java b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/ProtocolExtension.java
deleted file mode 100644
index f8f24f48..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/ProtocolExtension.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2021-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp;
-
-import org.apache.commons.io.EndianUtils;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-
-public class ProtocolExtension {
-	public static final int CLIENT_INFO_TYPE = 0x00;
-	public static final int CSP_DEVICE_ID_TYPE = 0x01;
-	public static final int MESSAGE_PAYLOAD_VERSION_TYPE = 0x02;
-	public static final int DEVICE_COOKIE_TYPE = 0x03;
-	public static final String VERSION_MAGIC_STRING = "threema-clever-extension-field";
-	public static final int MESSAGE_PAYLOAD_VERSION = 0x01;
-
-	private final int type;
-	private final byte[] data;
-
-	ProtocolExtension(int type, byte[] data) {
-		this.type = type;
-		this.data = data;
-	}
-
-	public int getType() {
-		return type;
-	}
-
-	public byte[] getData() {
-		return data;
-	}
-
-	public byte[] getBytes() throws IOException {
-		ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-		bos.write(type);
-		EndianUtils.writeSwappedShort(bos, (short) data.length);
-		bos.write(data);
-		return bos.toByteArray();
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProvider.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProvider.kt
deleted file mode 100644
index ed6e8396..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProvider.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp.socket
-
-import java.net.InetSocketAddress
-
-interface ChatServerAddressProvider {
-    /**
-     * Move the internal pointer to the next available address.
-     * If the last address is reached, the pointer will wrap around and start with the first address again.
-     */
-    fun advance()
-
-    /**
-     * Get the [InetSocketAddress] the internal pointer is currently pointing to.
-     * If no addresses are available (e.g. when [update] has not been called prior to this call),
-     * `null` is returned
-     */
-    fun get(): InetSocketAddress?
-
-    /**
-     * Update the available [InetSocketAddress]es
-     */
-    fun update()
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProviderImpl.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProviderImpl.kt
deleted file mode 100644
index c6036bdf..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ChatServerAddressProviderImpl.kt
+++ /dev/null
@@ -1,136 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp.socket
-
-import ch.threema.base.ThreemaException
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.domain.protocol.connection.csp.CspConnectionConfiguration
-import ch.threema.domain.stores.IdentityStoreInterface
-import java.net.Inet4Address
-import java.net.Inet6Address
-import java.net.InetSocketAddress
-import java.net.UnknownHostException
-import java.util.concurrent.ExecutionException
-import java.util.concurrent.locks.ReentrantLock
-import kotlin.concurrent.withLock
-
-class ChatServerAddressProviderImpl(
-    configuration: CspConnectionConfiguration,
-    ) : ChatServerAddressProvider {
-    private val identityStore: IdentityStoreInterface = configuration.identityStore
-    private val serverAddressProvider: ServerAddressProvider = configuration.serverAddressProvider
-    private val hostResolver: HostResolver = configuration.hostResolver
-    private val ipv6 = configuration.ipv6
-
-    private val lock = ReentrantLock()
-
-    private var socketAddressIndex: Int = 0
-    private var serverSocketAddresses: List<InetSocketAddress> = listOf()
-
-    /**
-     * Move the internal pointer to the next available address.
-     * If the last address is reached, the pointer will wrap around and start with the first address again.
-     */
-    override fun advance(): Unit = lock.withLock {
-        socketAddressIndex++
-        if (socketAddressIndex >= serverSocketAddresses.size) {
-            socketAddressIndex = 0
-        }
-    }
-
-    /**
-     * Get the [InetSocketAddress] the internal pointer is currently pointing to.
-     */
-    override fun get(): InetSocketAddress? = lock.withLock {
-        if (socketAddressIndex >= serverSocketAddresses.size) {
-            null
-        } else {
-            serverSocketAddresses[socketAddressIndex]
-        }
-    }
-
-    /**
-     * Update the available [InetSocketAddress]es
-     */
-    @Throws(
-        UnknownHostException::class,
-        ExecutionException::class,
-        InterruptedException::class,
-        ThreemaException::class
-    )
-    override fun update(): Unit = lock.withLock {
-        val serverHost = getServerHost()
-
-        val addresses = if (ProxyAwareSocketFactory.shouldUseProxy(serverHost, serverAddressProvider.chatServerPorts[0])) {
-            getAddressesWithProxy(serverHost)
-        } else {
-            getAddressesWithoutProxy(serverHost)
-        }
-
-        if (addresses.size != serverSocketAddresses.size || hasChangedAddresses(addresses)) {
-            serverSocketAddresses = addresses
-            socketAddressIndex = 0
-        }
-    }
-
-    private fun hasChangedAddresses(addresses: List<InetSocketAddress>): Boolean = addresses.withIndex().any {
-        val newAddress = it.value.address
-        val previousAddress = serverSocketAddresses[it.index].address
-        (newAddress == null && previousAddress != null)
-            || (newAddress != null && previousAddress == null)
-            || (newAddress != null && !newAddress.hostAddress.equals(previousAddress.hostAddress))
-    }
-
-    private fun getServerHost(): String {
-        val serverNamePrefix = serverAddressProvider.getChatServerNamePrefix(ipv6)
-        val serverHost = if (serverNamePrefix.isNotEmpty()) {
-            val serverGroup = if (serverAddressProvider.chatServerUseServerGroups) identityStore.serverGroup else "."
-            "$serverNamePrefix$serverGroup"
-        } else {
-            ""
-        }
-        return "$serverHost${serverAddressProvider.getChatServerNameSuffix(ipv6)}"
-    }
-
-    private fun getAddressesWithProxy(serverHost: String): List<InetSocketAddress> {
-        return serverAddressProvider.chatServerPorts
-            .map { InetSocketAddress.createUnresolved(serverHost, it) }
-    }
-
-    private fun getAddressesWithoutProxy(serverHost: String): List<InetSocketAddress> {
-        val inetAddresses = hostResolver.getAllByName(serverHost)
-        if (inetAddresses.isEmpty()) {
-            throw UnknownHostException()
-        }
-        inetAddresses.sortWith {
-            o1, o2 -> when {
-                o1 is Inet6Address && o2 is Inet6Address -> o1.hostAddress.compareTo(o2.hostAddress)
-                o1 is Inet6Address -> -1
-                o2 is Inet4Address -> o1.hostAddress.compareTo(o2.hostAddress)
-                else -> 1
-            }
-        }
-        return inetAddresses.flatMap { address ->
-            serverAddressProvider.chatServerPorts.map { port -> InetSocketAddress(address, port) }
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/CspSocket.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/CspSocket.kt
deleted file mode 100644
index ececf081..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/CspSocket.kt
+++ /dev/null
@@ -1,177 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp.socket
-
-import ch.threema.domain.protocol.connection.socket.BaseSocket
-import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
-import ch.threema.domain.protocol.connection.socket.ServerSocketException
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.runInterruptible
-import kotlinx.coroutines.withContext
-import java.io.DataInputStream
-import java.io.OutputStream
-import java.net.Inet6Address
-import java.net.Socket
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-import kotlin.coroutines.CoroutineContext
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("CspSocket")
-
-internal class CspSocket(
-    private val socketFactory: SocketFactory,
-    private val addressProvider: ChatServerAddressProvider,
-    ioProcessingStoppedSignal: CompletableDeferred<Unit>,
-    inputDispatcher: CoroutineContext,
-    ) : BaseSocket(ioProcessingStoppedSignal, inputDispatcher) {
-
-    private var _address: String? = null
-    override val address: String? get() = _address
-
-    private lateinit var socket: Socket
-
-    override fun connect() {
-        if (this::socket.isInitialized && !socket.isClosed) {
-            logger.trace("Close socket (Connect)")
-            socket.close()
-        }
-
-        addressProvider.update()
-
-        val address = addressProvider.get() ?: throw ServerSocketException("No server address available")
-
-        ioProcessingStopped = false
-
-        logger.info("Connecting to {} ...", address)
-        socket = socketFactory.makeSocket(address)
-
-        val timeout = when (address.address) {
-            is Inet6Address -> ProtocolDefines.CONNECT_TIMEOUT_IPV6 * 1000
-            else -> ProtocolDefines.CONNECT_TIMEOUT * 1000
-        }
-        socket.connect(address, timeout)
-
-        _address = address.toString()
-    }
-
-    override fun closeSocket(reason: ServerSocketCloseReason) {
-        if (this::socket.isInitialized) {
-            if (!socket.isClosed) {
-                logger.trace("Close socket (reason={})", reason)
-                socket.close()
-                _address = null
-            }
-            logger.info("Socket is closed")
-        } else {
-            logger.info("Socket is not initialized. Ignore closing.")
-        }
-    }
-
-    /**
-     * Set the socket SO_TIMEOUT.
-     *
-     * This has no effect if the underlying socket has not been created e.g. by a call to [connect]
-     *
-     * @see Socket.setSoTimeout
-     */
-    fun setSocketSoTimeout(timeout: Int) {
-        if (this::socket.isInitialized) {
-            socket.soTimeout = timeout
-        }
-    }
-
-    /**
-     * Move the internal pointer to the next available address.
-     * The pointer will wrap around if the last available address is reached.
-     */
-    fun advanceAddress() {
-        addressProvider.advance()
-    }
-
-    override suspend fun setupReading() {
-        val dis = withContext(Dispatchers.IO) { DataInputStream(socket.getInputStream()) }
-        dis.use {
-            try {
-                readInput(it)
-            } finally {
-                logger.info("Reading stopped")
-            }
-        }
-    }
-
-    private suspend fun readInput(dis: DataInputStream) {
-        // Expect handshake messages first
-        // `server-hello`: https://clients.pages.threema.dev/protocols/threema-protocols/structbuf/csp/#m:handshake:server-hello
-        sendInbound(readNBytes(dis, ProtocolDefines.SERVER_HELLO_LEN))
-        // `login-ack`: https://clients.pages.threema.dev/protocols/threema-protocols/structbuf/csp/#m:handshake:login-ack
-        sendInbound(readNBytes(dis, ProtocolDefines.SERVER_LOGIN_ACK_LEN))
-
-        while(!ioProcessingStopped) {
-            val length = ByteBuffer.wrap(readNBytes(dis, 2))
-                .order(ByteOrder.LITTLE_ENDIAN)
-                .short.toUShort().toInt()
-            val data = readNBytes(dis, length)
-
-            // Send the received data inbound. Only carry on receiving data again after the
-            // sending has completed.
-            sendInbound(data)
-        }
-    }
-
-    override suspend fun setupWriting() {
-        val outputStream = runInterruptible(Dispatchers.IO) { socket.getOutputStream() }
-        outputStream.use {
-            try {
-                writeOutput(it)
-            } finally {
-                logger.info("Writing stopped")
-            }
-        }
-    }
-
-    private suspend fun writeOutput(outputStream: OutputStream) {
-        while (!ioProcessingStopped) {
-            val data = outbound.take()
-            logger.debug("Write {} bytes to output", data.size)
-            runInterruptible(Dispatchers.IO) {
-                outputStream.write(data)
-                outputStream.flush()
-            }
-        }
-    }
-
-    private suspend fun readNBytes(dis: DataInputStream, n: Int): ByteArray {
-        logger.debug("Read {} bytes from input", n)
-        return if (n == 0) {
-            ByteArray(0)
-        } else {
-            runInterruptible(Dispatchers.IO) {
-                val bytes = ByteArray(n)
-                dis.readFully(bytes)
-                bytes
-            }
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/HostResolver.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/HostResolver.kt
deleted file mode 100644
index 78208782..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/HostResolver.kt
+++ /dev/null
@@ -1,30 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp.socket
-
-import java.net.InetAddress
-import java.util.concurrent.ExecutionException
-
-fun interface HostResolver {
-    @Throws(ExecutionException::class, InterruptedException::class)
-    fun getAllByName(name: String): Array<InetAddress>
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ProxyAwareSocketFactory.java b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ProxyAwareSocketFactory.java
deleted file mode 100644
index e818a0f7..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/ProxyAwareSocketFactory.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp.socket;
-
-import org.slf4j.Logger;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.net.URI;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.api.HttpProxySocket;
-
-public class ProxyAwareSocketFactory {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("ProxyAwareSocketFactory");
-
-	public static boolean shouldUseProxy(String hostname, int port) {
-		List<Proxy> proxies = ProxySelector.getDefault().select(URI.create("https://" + hostname + ":" + port + "/"));
-		if (proxies.size() == 0 || proxies.get(0) == Proxy.NO_PROXY || proxies.get(0).type() == Proxy.Type.DIRECT) {
-			return false;
-		}
-		return true;
-	}
-
-	@NonNull
-	public static Socket makeSocket(InetSocketAddress address) {
-		List<Proxy> proxies = ProxySelector.getDefault().select(URI.create("https://" + address.getHostName() + ":" + address.getPort() + "/"));
-		if (proxies.size() == 0 || proxies.get(0) == Proxy.NO_PROXY || proxies.get(0).type() == Proxy.Type.DIRECT) {
-			// No proxy
-			logger.info("No proxy configured");
-			return new Socket();
-		}
-
-		// Look for a SOCKS proxy first, as we prefer that
-		Proxy chosenProxy = null;
-		for (Proxy proxy : proxies) {
-			if (proxy.type() == Proxy.Type.SOCKS) {
-				chosenProxy = proxy;
-				break;
-			}
-		}
-
-		if (chosenProxy == null) {
-			// Fall back to the first HTTP proxy
-			for (Proxy proxy : proxies) {
-				if (proxy.type() == Proxy.Type.HTTP) {
-					chosenProxy = proxy;
-					break;
-				}
-			}
-		}
-
-		if (chosenProxy == null) {
-			logger.info("No proxy chosen");
-			return new Socket();
-		}
-
-		// Check if the chosen proxy supports SOCKS or HTTP. For SOCKS, we can directly
-		// create a Socket with the proxy configuration. For HTTP, we need to supply our own
-		// implementation as JDK 7 does not support HTTP for Socket.
-		logger.info("Using proxy: " + chosenProxy);
-		switch (chosenProxy.type()) {
-			case SOCKS:
-				return new Socket(chosenProxy);
-			case HTTP:
-				return new HttpProxySocket(chosenProxy);
-			default:
-				// This should actually not be reachable as only Sockets with type SOCKS or HTTP are
-				// considered.
-				throw new RuntimeException("Invalid proxy type '" + chosenProxy.type() + "' set");
-		}
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/SocketFactory.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/SocketFactory.kt
deleted file mode 100644
index cf840884..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/csp/socket/SocketFactory.kt
+++ /dev/null
@@ -1,29 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.csp.socket
-
-import java.net.InetSocketAddress
-import java.net.Socket
-
-fun interface SocketFactory {
-    fun makeSocket(address: InetSocketAddress): Socket
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt
deleted file mode 100644
index 12b82fe8..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mConnection.kt
+++ /dev/null
@@ -1,67 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m
-
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.BaseServerConnection
-import ch.threema.domain.protocol.connection.BaseServerConnectionConfiguration
-import ch.threema.domain.protocol.connection.ServerConnectionDependencyProvider
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-import ch.threema.domain.protocol.connection.d2m.socket.D2mSocketCloseListener
-import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
-import ch.threema.domain.protocol.multidevice.MultiDeviceProperties
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.TaskManager
-import okhttp3.OkHttpClient
-
-/**
- * Only this interface is exposed to other modules
- */
-interface D2mConnection
-
-internal class D2mConnectionImpl(
-    dependencyProvider: ServerConnectionDependencyProvider,
-    private val closeListener: D2mSocketCloseListener
-) : D2mConnection, BaseServerConnection(dependencyProvider) {
-
-    override fun onSocketClosed(reason: ServerSocketCloseReason) {
-        closeListener.onSocketClosed(reason)
-    }
-}
-
-fun interface MultiDevicePropertyProvider {
-    fun get(): MultiDeviceProperties
-}
-data class D2mConnectionConfiguration(
-    override val identityStore: IdentityStoreInterface,
-    override val serverAddressProvider: ServerAddressProvider,
-    override val version: Version,
-    override val assertDispatcherContext: Boolean,
-    override val deviceCookieManager: DeviceCookieManager,
-    override val incomingMessageProcessor: IncomingMessageProcessor,
-    override val taskManager: TaskManager,
-    val multiDevicePropertyProvider: MultiDevicePropertyProvider,
-    val closeListener: D2mSocketCloseListener,
-    val okHttpClient: OkHttpClient
-) : BaseServerConnectionConfiguration
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mController.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mController.kt
deleted file mode 100644
index 5418a404..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mController.kt
+++ /dev/null
@@ -1,57 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m
-
-import ch.threema.domain.protocol.connection.SingleThreadedServerConnectionDispatcher
-import ch.threema.domain.protocol.connection.csp.CspSession
-import ch.threema.domain.protocol.connection.csp.CspSessionState
-import ch.threema.domain.protocol.connection.util.MainConnectionController
-import ch.threema.domain.protocol.connection.util.MdLayer3Controller
-import ch.threema.domain.protocol.connection.util.MdLayer4Controller
-import ch.threema.domain.protocol.connection.util.MdServerConnectionController
-import kotlinx.coroutines.CompletableDeferred
-
-internal class D2mController(configuration: D2mConnectionConfiguration) :
-    MdServerConnectionController,
-    MdLayer3Controller,
-    MdLayer4Controller,
-    MainConnectionController {
-
-    override val dispatcher = SingleThreadedServerConnectionDispatcher(
-        configuration.assertDispatcherContext
-    )
-
-    override val cspSession: CspSession = CspSession(configuration, dispatcher)
-    override val d2mSession: D2mSession = D2mSession(configuration, dispatcher)
-
-    override val cspSessionState: CspSessionState = cspSession
-
-    override val connectionClosed = CompletableDeferred<Unit>()
-
-    override val connected = CompletableDeferred<Unit>()
-
-    override val cspAuthenticated = CompletableDeferred<Unit>()
-
-    override val ioProcessingStoppedSignal = CompletableDeferred<Unit>()
-
-    override val reflectionQueueDry  = CompletableDeferred<Unit>()
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mControllers.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mControllers.kt
deleted file mode 100644
index bc34238d..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mControllers.kt
+++ /dev/null
@@ -1,37 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m
-
-import ch.threema.domain.protocol.connection.util.MainConnectionController
-import ch.threema.domain.protocol.connection.util.MdLayer3Controller
-import ch.threema.domain.protocol.connection.util.MdLayer4Controller
-import ch.threema.domain.protocol.connection.util.ServerConnectionController
-import ch.threema.domain.protocol.connection.util.ServerConnectionControllers
-
-internal class D2mControllers(d2mConnectionConfiguration: D2mConnectionConfiguration) : ServerConnectionControllers {
-    private val d2mController = D2mController(d2mConnectionConfiguration)
-
-    override val serverConnectionController: ServerConnectionController = d2mController
-    override val mainController: MainConnectionController = d2mController
-    override val layer3Controller: MdLayer3Controller = d2mController
-    override val layer4Controller: MdLayer4Controller = d2mController
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mSession.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mSession.kt
deleted file mode 100644
index e4b6d23c..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/D2mSession.kt
+++ /dev/null
@@ -1,127 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m
-
-import ch.threema.base.utils.TimeMeasureUtil
-import ch.threema.domain.protocol.connection.InputPipe
-import ch.threema.domain.protocol.connection.ServerConnectionDispatcher
-import ch.threema.domain.protocol.connection.data.D2mProtocolException
-import ch.threema.domain.protocol.connection.data.DeviceSlotExpirationPolicy
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.multidevice.MultiDeviceProperties
-import kotlin.math.min
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("D2mSession")
-
-internal interface D2mSessionState {
-    val isLoginDone: Boolean
-}
-
-internal class D2mSession(
-    configuration: D2mConnectionConfiguration,
-    private val dispatcher: ServerConnectionDispatcher
-) : D2mSessionState {
-    private enum class LoginState {
-        AWAIT_SERVER_HELLO,
-        AWAIT_SERVER_INFO,
-        DONE
-    }
-
-    private val timeMeasureUtil = TimeMeasureUtil()
-
-    private val propertiesProvider = configuration.multiDevicePropertyProvider
-
-    private var loginState = LoginState.AWAIT_SERVER_HELLO
-
-    override val isLoginDone: Boolean
-        get() = loginState == LoginState.DONE
-
-    fun handleHandshakeMessage(message: InboundD2mMessage, outbound: InputPipe<in OutboundD2mMessage>) {
-        dispatcher.assertDispatcherContext()
-
-        loginState = when (message) {
-            is InboundD2mMessage.ServerHello -> {
-                processServerHello(message, outbound)
-                LoginState.AWAIT_SERVER_INFO
-            }
-            is InboundD2mMessage.ServerInfo -> {
-                processServerInfo(message)
-                LoginState.DONE
-            }
-            else -> throw getUnexpectedMessageException(message)
-        }
-
-    }
-
-    private fun processServerHello(serverHello: InboundD2mMessage.ServerHello, outbound: InputPipe<in OutboundD2mMessage>) {
-        if (loginState != LoginState.AWAIT_SERVER_HELLO) {
-            throw getUnexpectedMessageException(serverHello)
-        }
-
-        val clientHello = createClientHello(serverHello)
-        timeMeasureUtil.start()
-        outbound.send(clientHello)
-    }
-
-    private fun createClientHello(
-        serverHello: InboundD2mMessage.ServerHello
-    ): OutboundD2mMessage.ClientHello = withProperties { properties ->
-        val serverVersion = serverHello.version
-        val localVersionMin = properties.protocolVersion.min
-        val localVersionMax = properties.protocolVersion.max
-        logger.trace("Check if server version ($serverVersion) in $localVersionMin..$localVersionMax")
-        if (serverVersion < localVersionMin || serverVersion > localVersionMax) {
-            throw D2mProtocolException("Unsupported d2m protocol version: $serverVersion not in $localVersionMin..$localVersionMax")
-        }
-
-        OutboundD2mMessage.ClientHello(
-            min(serverHello.version, properties.protocolVersion.max),
-            properties.keys.createServerHelloResponse(serverHello),
-            properties.mediatorDeviceId,
-            OutboundD2mMessage.ClientHello.DeviceSlotsExhaustedPolicy.REJECT,
-            DeviceSlotExpirationPolicy.PERSISTENT,
-            properties.deviceSlotState,
-            properties.keys.encryptDeviceInfo(properties.deviceInfo)
-        ).also { logger.trace("{}", it) }
-    }
-
-    private fun processServerInfo(serverInfo: InboundD2mMessage.ServerInfo) {
-        timeMeasureUtil.stop()
-        if (loginState != LoginState.AWAIT_SERVER_INFO) {
-            throw getUnexpectedMessageException(serverInfo)
-        }
-        logger.info("Server info received (rtt: {} ms)", timeMeasureUtil.elapsedTime)
-        withProperties { it.notifyServerInfo(serverInfo) }
-    }
-
-    private fun <T>withProperties(block: (MultiDeviceProperties) -> T): T {
-        return block.invoke(propertiesProvider.get())
-    }
-
-    private fun getUnexpectedMessageException(message: InboundD2mMessage): D2mProtocolException {
-        return D2mProtocolException(
-            "Unexpected message of type `${message.type}` in login state `${loginState}`"
-        )
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mCloseCode.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mCloseCode.kt
deleted file mode 100644
index 7e2b8c0f..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mCloseCode.kt
+++ /dev/null
@@ -1,64 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m.socket
-
-data class D2mCloseCode(val code: Int, val reason: String) {
-    companion object {
-        /*
-         * WebSocket internal close codes (1xxx)
-         */
-        const val NORMAL = 1000
-        const val SERVER_SHUTTING_DOWN = 1001
-        const val INTERNAL_SERVER_ERROR = 1011
-
-        /*
-         * Chat server close codes (400x and 410x)
-         */
-        const val CSP_CONNECTION_CLOSED = 4000
-        const val CSP_CONNECTION_COULD_NOT_BE_ESTABLISHED = 4001
-        const val CSP_INTERNAL_SERVER_ERROR = 4009
-
-        /*
-         * Mediator close codes (40[1-9]x and 41[1-9]x)
-         */
-        const val D2M_PROTOCOL_ERROR = 4010
-        const val D2M_TRANSACTION_TTL_EXCEEDED = 4011
-        // Unknown message acked
-        const val D2M_UNEXPECTED_ACK = 4012
-        // Client idle timeout exceeded
-        const val D2M_CLIENT_TIMEOUT = 4013
-        const val D2M_UNSUPPORTED_PROTOCOL_VERSION = 4110
-        const val D2M_DEVICE_LIMIT_REACHED = 4111
-        // Duplicate connection (i.e. the same device reconnected, terminating the previous connection)
-        const val D2M_DUPLICATE_CONNECTION = 4112
-        // Dropped by other device
-        const val D2M_DEVICE_DROPPED = 4113
-        // Dropped by server because the reflection queue length limit was reached
-        const val D2M_REFLECTION_QUEUE_LIMIT_REACHED = 4114
-        // Device slot state mismatch
-        const val D2M_EXPECTED_DEVICE_SLOT_MISMATCH = 4115
-    }
-
-    fun isReconnectAllowed(): Boolean {
-        return code < 4100 || code >= 4200
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mServerAddressProvider.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mServerAddressProvider.kt
deleted file mode 100644
index 11fbd5de..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mServerAddressProvider.kt
+++ /dev/null
@@ -1,53 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m.socket
-
-import ch.threema.base.utils.Utils
-import ch.threema.base.utils.toHexString
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.protobuf.d2m.MdD2M
-import com.google.protobuf.ByteString
-
-class D2mServerAddressProvider (
-    private val serverAddressProvider: ServerAddressProvider,
-    private val dgid: ByteArray,
-    private val serverGroup: String
-    ) {
-
-    fun get(): String {
-        val prefix8 = Utils.byteToHex(dgid[0], false, false)
-        val prefix4 = prefix8.substring(0, 1)
-
-        val mediatorUrl = serverAddressProvider.mediatorUrl
-            .replace("{deviceGroupIdPrefix4}", prefix4, false)
-            .replace("{deviceGroupIdPrefix8}", prefix8, false)
-
-        val clientUrlInfo = MdD2M.ClientUrlInfo.newBuilder()
-            .setDeviceGroupId(ByteString.copyFrom(dgid))
-            .setServerGroup(serverGroup)
-            .build()
-            .toByteArray()
-            .toHexString()
-
-        return "$mediatorUrl/$clientUrlInfo"
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocket.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocket.kt
deleted file mode 100644
index 34ccdaca..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocket.kt
+++ /dev/null
@@ -1,153 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m.socket
-
-import ch.threema.domain.protocol.connection.socket.BaseSocket
-import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.channels.Channel
-import kotlinx.coroutines.runBlocking
-import okhttp3.OkHttpClient
-import okhttp3.Request
-import okhttp3.Response
-import okhttp3.WebSocket
-import okhttp3.WebSocketListener
-import okio.ByteString
-import okio.ByteString.Companion.toByteString
-import kotlin.coroutines.CoroutineContext
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("D2mSocket")
-
-internal class D2mSocket(
-    private val okHttpClient: OkHttpClient,
-    private val addressProvider: D2mServerAddressProvider,
-    ioProcessingStoppedSignal: CompletableDeferred<Unit>,
-    inputDispatcher: CoroutineContext
-) : BaseSocket(ioProcessingStoppedSignal, inputDispatcher) {
-    private val inboundQueue = Channel<ByteArray>(Channel.UNLIMITED)
-
-    private var _address: String? = null
-    override val address: String? = _address
-
-    private val connectedSignal = CompletableDeferred<Unit>()
-
-    private var webSocket: WebSocket? = null
-    private val webSocketListener = object : WebSocketListener() {
-        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
-            logger.debug("WebSocket closed: code={}, reason={}", code, reason)
-            ioJob?.cancel()
-        }
-
-        override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
-            logger.debug("WebSocket closing: code={}, reason={}", code, reason)
-            val closeCode = D2mCloseCode(code, reason)
-            close(D2mSocketCloseReason(reason, closeCode))
-            ioProcessingStoppedSignal.completeExceptionally(D2mSocketCloseException("WebSocket closing", closeCode))
-        }
-
-        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
-            logger.warn("WebSocket failure", t)
-            ioJob?.cancel()
-            connectedSignal.completeExceptionally(t)
-        }
-
-        override fun onMessage(webSocket: WebSocket, text: String) {
-            logger.debug("Text message received: {}", text)
-        }
-
-        override fun onMessage(webSocket: WebSocket, bytes: ByteString) {
-            val result = inboundQueue.trySend(bytes.toByteArray())
-            result.exceptionOrNull()?.let {
-                logger.error("Error when receiving a message", it)
-            }
-        }
-
-        override fun onOpen(webSocket: WebSocket, response: Response) {
-            val url = response.request.url.toString()
-            logger.info("Connected to {}", url)
-            _address = url
-            connectedSignal.complete(Unit)
-        }
-    }
-
-    override fun connect() {
-        ioProcessingStopped = false
-
-        val url = addressProvider.get()
-
-        logger.info("Connecting to {} ...", url)
-
-        val request = Request.Builder()
-            .url(url)
-            .build()
-
-        webSocket = okHttpClient.newWebSocket(request, webSocketListener)
-        runBlocking { connectedSignal.await() }
-    }
-
-    override fun closeSocket(reason: ServerSocketCloseReason) {
-        webSocket?.let {
-            if (it.close(D2mCloseCode.NORMAL, reason.msg)) {
-                logger.trace("WebSocket shutdown initiated (reason={})", reason)
-            }
-            logger.debug("WebSocket shutdown underway or already closed")
-        } ?: run {
-            logger.debug("WebSocket is not initialized. Ignore closing")
-        }
-    }
-
-    override suspend fun setupWriting() {
-        try {
-            writeOutput()
-        } finally {
-            logger.trace("Writing stopped")
-        }
-    }
-
-    private suspend fun writeOutput() {
-        while (!ioProcessingStopped) {
-            val data = outbound.take()
-            logger.debug("Write {} bytes to output", data.size)
-            webSocket!!.send(data.toByteString())
-        }
-    }
-
-    override suspend fun setupReading() {
-        try {
-            readInput()
-        } finally {
-            logger.trace("Reading stopped")
-        }
-    }
-
-    private suspend fun readInput() {
-        while (!ioProcessingStopped) {
-            val data = inboundQueue.receive()
-            logger.debug("Received {} bytes", data.size)
-
-            // Send the received data inbound. Only carry on receiving data again after the
-            // sending has completed.
-            sendInbound(data)
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseException.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseException.kt
deleted file mode 100644
index d6075be3..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseException.kt
+++ /dev/null
@@ -1,29 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m.socket
-
-import ch.threema.domain.protocol.connection.socket.ServerSocketException
-
-class D2mSocketCloseException(msg: String, private val closeCode: D2mCloseCode) : ServerSocketException(msg) {
-    override val message: String
-        get() = "${super.message}, $closeCode"
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseListener.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseListener.kt
deleted file mode 100644
index 90d06faa..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseListener.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m.socket
-
-import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
-
-fun interface D2mSocketCloseListener {
-    fun onSocketClosed(reason: ServerSocketCloseReason)
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseReason.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseReason.kt
deleted file mode 100644
index 3c2de661..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/d2m/socket/D2mSocketCloseReason.kt
+++ /dev/null
@@ -1,30 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.d2m.socket
-
-import ch.threema.domain.protocol.connection.socket.ServerSocketCloseReason
-
-class D2mSocketCloseReason(msg: String, val closeCode: D2mCloseCode) : ServerSocketCloseReason(msg, closeCode.isReconnectAllowed()) {
-    override fun toString(): String {
-        return "D2mSocketCloseReason(msg='$msg', closeCode=$closeCode, reconnectAllowed=$reconnectAllowed)"
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/ByteContainer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/ByteContainer.kt
deleted file mode 100644
index 0be4c961..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/ByteContainer.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.data
-
-sealed class ByteContainer(val bytes: ByteArray) {
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is ByteContainer) return false
-
-        if (!bytes.contentEquals(other.bytes)) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        return bytes.contentHashCode()
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/D2mProtocolVersion.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/D2mProtocolVersion.kt
deleted file mode 100644
index e93e290e..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/D2mProtocolVersion.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.data
-
-data class D2mProtocolVersion(val min: UInt, val max: UInt)
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/TypedMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/TypedMessage.kt
deleted file mode 100644
index 4603a72d..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/TypedMessage.kt
+++ /dev/null
@@ -1,41 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.data
-
-internal interface TypedMessage {
-    val type: String
-}
-
-internal sealed interface InboundL1Message : TypedMessage
-
-internal sealed interface InboundL2Message : TypedMessage
-internal sealed interface OutboundL2Message : TypedMessage
-
-internal sealed interface InboundL3Message : TypedMessage
-internal sealed interface OutboundL3Message : TypedMessage
-
-internal sealed interface InboundL4Message : TypedMessage {
-    fun toInboundMessage(): InboundMessage
-}
-internal sealed interface OutboundL4Message : TypedMessage
-
-internal sealed interface OutboundL5Message : TypedMessage
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/csp.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/csp.kt
deleted file mode 100644
index 7738914f..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/csp.kt
+++ /dev/null
@@ -1,187 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.data
-
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.connection.InvalidSizeException
-import ch.threema.domain.protocol.connection.PayloadProcessingException
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-import java.nio.charset.StandardCharsets
-
-/**
- * A simple container for byte arrays that are exchanged with the chat server.
- * There is no special logic such as prepending the length. If the length is required (as in a CspFrame)
- * a [CspData] is typically acquired by utilising [CspFrame.toCspData].
- */
-internal class CspData(bytes: ByteArray)
-    :   ByteContainer(bytes),
-    InboundL1Message,
-    OutboundL2Message {
-    override val type: String = "CspData"
-}
-
-internal class CspLoginMessage(bytes: ByteArray)
-    :   ByteContainer(bytes),
-    InboundL2Message,
-    OutboundL3Message {
-    override val type: String = "CspLoginMessage"
-}
-
-internal class CspFrame(val box: ByteArray) :
-    InboundL2Message,
-    OutboundL3Message {
-    override val type: String = "CspFrame"
-
-    fun toCspData(): CspData {
-        // wrap messages with `frame`
-        // (https://clients.pages.threema.dev/protocols/threema-protocols/structbuf/csp/index.html#m:payload:frame)
-        if (box.size > ProtocolDefines.MAX_PKT_LEN) {
-            throw InvalidSizeException("Package is too big (${box.size} bytes)")
-        }
-        val length = ByteBuffer.wrap(ByteArray(2))
-            .order(ByteOrder.LITTLE_ENDIAN)
-            .putShort(box.size.toShort())
-            .array()
-        return CspData(length + box)
-    }
-}
-
-/**
- * Contains data of a decrypted csp message
- * https://clients.pages.threema.dev/protocols/threema-protocols/structbuf/csp/index.html#m:payload:container
- */
-internal class CspContainer(val payloadType: UByte, val data: ByteArray)
-    :   InboundL3Message,
-    InboundL4Message,
-    OutboundL4Message,
-    OutboundL5Message {
-    override val type: String = "CspContainer"
-
-    override fun toInboundMessage(): CspMessage {
-        return CspMessage(payloadType, data)
-    }
-}
-
-/**
- * A csp message that is ready to be processed (inbound) or sent to server (outbound)
- */
-class CspMessage(
-    override val payloadType: UByte,
-    private val data: ByteArray
-) : InboundMessage, OutboundMessage {
-
-    // Retrofit constructor that can also be called from java code (with signed payload type)
-    constructor(payloadType: Int, data: ByteArray) : this(payloadType.toUByte(), data)
-
-    @JvmInline
-    value class ServerErrorData(private val data: ByteArray) {
-        val canReconnect: Boolean
-            get() = data[0] != 0.toByte()
-
-        val message: String
-            get() = String(data, 1, data.size - 1, StandardCharsets.UTF_8)
-    }
-
-    @JvmInline
-    value class ServerAlertData(val data: ByteArray) {
-        val message: String
-            get() = String(data, StandardCharsets.UTF_8)
-    }
-
-    @JvmInline
-    value class MessageAck(val data: ByteArray) {
-        val recipient: String
-            get() {
-                if (data.size != ProtocolDefines.IDENTITY_LEN + ProtocolDefines.MESSAGE_ID_LEN) {
-                    throw PayloadProcessingException("Bad length (${data.size}) for message ack payload")
-                }
-
-                return String(
-                    data,
-                    0,
-                    ProtocolDefines.IDENTITY_LEN,
-                    StandardCharsets.UTF_8
-                )
-            }
-
-        val messageId: MessageId
-            get() {
-                if (data.size != ProtocolDefines.IDENTITY_LEN + ProtocolDefines.MESSAGE_ID_LEN) {
-                    throw PayloadProcessingException("Bad length (${data.size}) for message ack payload")
-                }
-
-                // Note that IDENTITY_LEN specifies the offset where the message id starts
-                return MessageId(data, ProtocolDefines.IDENTITY_LEN)
-            }
-    }
-
-    @JvmInline
-    value class IncomingMessageData(val data: ByteArray)
-
-    @JvmInline
-    value class OutgoingMessageData(val data: ByteArray)
-
-    fun toServerErrorData(): ServerErrorData {
-        assertPayloadType(ProtocolDefines.PLTYPE_ERROR)
-        if (data.isEmpty()) {
-            throw PayloadProcessingException("Bad length (${data.size}) for error payload")
-        }
-        return ServerErrorData(data)
-    }
-
-    fun toServerAlertData(): ServerAlertData {
-        assertPayloadType(ProtocolDefines.PLTYPE_ALERT)
-        return ServerAlertData(data)
-    }
-
-    fun toOutgoingMessageAck(): MessageAck {
-        assertPayloadType(ProtocolDefines.PLTYPE_OUTGOING_MESSAGE_ACK)
-        return MessageAck(data)
-    }
-
-    fun toIncomingMessageData(): IncomingMessageData {
-        assertPayloadType(ProtocolDefines.PLTYPE_INCOMING_MESSAGE)
-        return IncomingMessageData(data)
-    }
-
-    fun toOutgoingMessageData(): OutgoingMessageData {
-        assertPayloadType(ProtocolDefines.PLTYPE_OUTGOING_MESSAGE)
-        return OutgoingMessageData(data)
-    }
-
-    fun toIncomingMessageAck(): MessageAck {
-        assertPayloadType(ProtocolDefines.PLTYPE_INCOMING_MESSAGE_ACK)
-        return MessageAck(data)
-    }
-
-    internal fun toCspContainer(): CspContainer {
-        return CspContainer(payloadType, data)
-    }
-
-    private fun assertPayloadType(payloadType: Int) {
-        if (this.payloadType != payloadType.toUByte()) {
-            throw PayloadProcessingException("CspMessage has invalid payload type. Expected: ${payloadType.toUByte()}, actual: ${this.payloadType}")
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt
deleted file mode 100644
index 2e2084d8..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2d.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.data
-
-import ch.threema.base.utils.SecureRandomUtil.generateRandomProtobufPadding
-import ch.threema.protobuf.d2d.MdD2D
-
-
-sealed interface D2dMessage {
-    val bytes: ByteArray
-
-    data class DeviceInfo(
-        val platform: Platform,
-        val platformDetails: String,
-        val appVersion: String,
-        val label: String
-    ) : D2dMessage {
-        enum class Platform(val value: Int) {
-            UNSPECIFIED(0),
-            ANDROID(1),
-            IOS(2),
-            DESKTOP(3),
-            WEB(4)
-        }
-
-        override val bytes: ByteArray
-            get() = MdD2D.DeviceInfo.newBuilder()
-                .setPadding(generateRandomProtobufPadding())
-                .setPlatformValue(platform.value)
-                .setPlatformDetails(platformDetails)
-                .setAppVersion(appVersion)
-                .setLabel(label)
-                .build()
-                .toByteArray()
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt
deleted file mode 100644
index a83198da..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/d2m.kt
+++ /dev/null
@@ -1,429 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.data
-
-import ch.threema.base.utils.toHexString
-import ch.threema.domain.protocol.D2mPayloadType
-import ch.threema.domain.protocol.connection.ServerConnectionException
-import ch.threema.protobuf.d2m.MdD2M
-import com.google.protobuf.ByteString
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-
-class D2mContainer(val payloadType: UByte, val payload: ByteArray)
-    : InboundL1Message,
-    OutboundL2Message {
-    override val type: String = "D2mContainer"
-
-    val bytes: ByteArray
-        get() {
-            return byteArrayOf(payloadType.toByte()) + ByteArray(3) + payload
-        }
-}
-
-class D2mProtocolException(msg: String) : ServerConnectionException(msg)
-
-@JvmInline
-value class DeviceId(val id: ULong)
-
-fun DeviceId.leBytes(): ByteArray {
-    return ByteBuffer.wrap(ByteArray(ULong.SIZE_BYTES))
-        .order(ByteOrder.LITTLE_ENDIAN)
-        .putLong(id.toLong())
-        .array()
-}
-
-enum class DeviceSlotExpirationPolicy(val value: Int) {
-    VOLATILE(0),
-    PERSISTENT(1);
-
-    companion object {
-        fun fromProto(value: Int): DeviceSlotExpirationPolicy {
-            return when (value) {
-                0 -> VOLATILE
-                1 -> PERSISTENT
-                else -> throw D2mProtocolException("Unknown DeviceSlotExpirationPolicy `${value}`")
-            }
-        }
-    }
-}
-
-enum class DeviceSlotState(val value: Int) {
-    NEW(0),
-    EXISTING(1);
-
-    companion object {
-        fun fromProto(value: Int): DeviceSlotState {
-            return when (value) {
-                0 -> NEW
-                1 -> EXISTING
-                else -> throw D2mProtocolException("Unknown DeviceSlotState `${value}`")
-            }
-        }
-    }
-}
-
-sealed class OutboundD2mMessage(override val payloadType: UByte) :
-    OutboundL3Message,
-    OutboundL4Message,
-    OutboundL5Message,
-    OutboundMessage {
-    abstract fun toContainer(): D2mContainer
-
-    internal class ClientHello(
-        private val version: UInt,
-        private val response: ByteArray,
-        private val deviceId: DeviceId,
-        private val deviceSlotsExhaustedPolicy: DeviceSlotsExhaustedPolicy,
-        private val deviceSlotExpirationPolicy: DeviceSlotExpirationPolicy,
-        private val expectedDeviceSlotState: DeviceSlotState,
-        private val encryptedDeviceInfo: ByteArray
-    ) : OutboundD2mMessage(D2mPayloadType.CLIENT_HELLO) {
-        enum class DeviceSlotsExhaustedPolicy(val value: Int) {
-            REJECT(0),
-            DROP_LEAST_RECENT(1);
-        }
-
-        override val type: String = "D2mClientHello"
-
-        override fun toContainer(): D2mContainer {
-            val hello = MdD2M.ClientHello.newBuilder()
-                .setVersion(version.toInt())
-                .setResponse(ByteString.copyFrom(response))
-                .setDeviceId(deviceId.id.toLong())
-                .setDeviceSlotsExhaustedPolicyValue(deviceSlotsExhaustedPolicy.value)
-                .setDeviceSlotExpirationPolicyValue(deviceSlotExpirationPolicy.value)
-                .setExpectedDeviceSlotStateValue(expectedDeviceSlotState.value)
-                .setEncryptedDeviceInfo(ByteString.copyFrom(encryptedDeviceInfo))
-                .build()
-            return D2mContainer(
-                payloadType,
-                hello.toByteArray()
-            )
-        }
-
-        override fun toString(): String {
-            return "ClientHello(version=$version, response=${response.toHexString(4)}, deviceId=$deviceId, deviceSlotsExhaustedPolicy=$deviceSlotsExhaustedPolicy, deviceSlotExpirationPolicy=$deviceSlotExpirationPolicy, expectedDeviceSlotState=$expectedDeviceSlotState, encryptedDeviceInfo=${encryptedDeviceInfo.toHexString(4)}, type='$type')"
-        }
-
-
-    }
-
-    class GetDevicesInfo : OutboundD2mMessage(D2mPayloadType.GET_DEVICES_INFO) {
-        override val type: String = "D2mGetDevicesInfo"
-
-        override fun toContainer(): D2mContainer {
-            val getDevicesInfo = MdD2M.GetDevicesInfo.newBuilder().build()
-            return D2mContainer(payloadType, getDevicesInfo.toByteArray())
-        }
-    }
-
-    class DropDevice(val deviceId: DeviceId) : OutboundD2mMessage(D2mPayloadType.DROP_DEVICE), OutboundMessage {
-        override val type: String = "D2mDropDevice"
-
-        override fun toContainer(): D2mContainer {
-            val dropDevice = MdD2M.DropDevice.newBuilder()
-                .setDeviceId(deviceId.id.toLong())
-                .build()
-            return D2mContainer(payloadType, dropDevice.toByteArray())
-        }
-    }
-
-    class BeginTransaction(
-        private val encryptedScope: ByteArray,
-        private val ttl: UInt
-    ) : OutboundD2mMessage(D2mPayloadType.BEGIN_TRANSACTION) {
-        override val type: String = "D2mBeginTransaction"
-
-        override fun toContainer(): D2mContainer {
-            val beginTransaction = MdD2M.BeginTransaction.newBuilder()
-                .setEncryptedScope(ByteString.copyFrom(encryptedScope))
-                .setTtl(ttl.toInt())
-                .build()
-            return D2mContainer(payloadType, beginTransaction.toByteArray())
-        }
-    }
-
-    class SetSharedDeviceData(private val encryptedSharedDeviceData: ByteArray) : OutboundD2mMessage(D2mPayloadType.SET_SHARED_DEVICE_DATA) {
-        override val type: String = "D2mSetSharedDeviceData"
-
-        override fun toContainer(): D2mContainer {
-            val data = MdD2M.SetSharedDeviceData.newBuilder()
-                .setEncryptedSharedDeviceData(ByteString.copyFrom(encryptedSharedDeviceData))
-                .build()
-            return D2mContainer(payloadType, data.toByteArray())
-        }
-    }
-
-    class CommitTransaction : OutboundD2mMessage(D2mPayloadType.COMMIT_TRANSACTION) {
-        override val type: String = "D2mCommitTransaction"
-
-        override fun toContainer(): D2mContainer {
-            val commitTransaction = MdD2M.CommitTransaction.newBuilder()
-                .build()
-            return D2mContainer(payloadType, commitTransaction.toByteArray())
-        }
-    }
-}
-
-sealed class InboundD2mMessage(override val payloadType: UByte) : InboundL2Message, InboundL3Message, InboundL4Message, InboundMessage {
-    companion object {
-        fun decodeContainer(container: D2mContainer): InboundD2mMessage {
-            return when (container.payloadType) {
-                D2mPayloadType.SERVER_HELLO -> ServerHello.decodeContainer(container)
-                D2mPayloadType.SERVER_INFO -> ServerInfo.decodeContainer(container)
-                D2mPayloadType.REFLECTION_QUEUE_DRY -> ReflectionQueueDry.decodeContainer(container)
-                D2mPayloadType.ROLE_PROMOTED_TO_LEADER -> RolePromotedToLeader.decodeContainer(container)
-                D2mPayloadType.DEVICES_INFO -> DevicesInfo.decodeContainer(container)
-                D2mPayloadType.DROP_DEVICE_ACK -> DropDeviceAck.decodeContainer(container)
-                D2mPayloadType.BEGIN_TRANSACTION_ACK -> BeginTransactionAck.decodeContainer(container)
-                D2mPayloadType.COMMIT_TRANSACTION_ACK -> CommitTransactionAck.decodeContainer(container)
-                D2mPayloadType.TRANSACTION_REJECTED -> TransactionRejected.decodeContainer(container)
-                D2mPayloadType.TRANSACTION_ENDED -> TransactionEnded.decodeContainer(container)
-                else -> throw D2mProtocolException("Unsupported payload type `${container.payloadType.toHex()}`")
-            }
-        }
-    }
-
-    override fun toInboundMessage(): InboundMessage = this
-
-    internal class ServerHello(
-        val version: UInt,
-        val esk: ByteArray,
-        val challenge: ByteArray) : InboundD2mMessage(D2mPayloadType.SERVER_HELLO) {
-        override val type: String = "D2mServerHello"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): ServerHello {
-                if (container.payloadType != D2mPayloadType.SERVER_HELLO) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                val proto = MdD2M.ServerHello.parseFrom(container.payload)
-                return ServerHello(
-                    proto.version.toUInt(),
-                    proto.esk.toByteArray(),
-                    proto.challenge.toByteArray()
-                )
-            }
-        }
-    }
-
-    class ServerInfo(
-        val currentTime: ULong,
-        val maxDeviceSlots: UInt,
-        val deviceSlotState: DeviceSlotState,
-        val encryptedSharedDeviceData: ByteArray,
-        val reflectionQueueLength: UInt
-    ) : InboundD2mMessage(D2mPayloadType.SERVER_INFO) {
-        override val type: String = "D2mServerInfo"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): ServerInfo {
-                if (container.payloadType != D2mPayloadType.SERVER_INFO) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                val proto = MdD2M.ServerInfo.parseFrom(container.payload)
-                return ServerInfo(
-                    proto.currentTime.toULong(),
-                    proto.maxDeviceSlots.toUInt(),
-                    DeviceSlotState.fromProto(proto.deviceSlotStateValue),
-                    proto.encryptedSharedDeviceData.toByteArray(),
-                    proto.reflectionQueueLength.toUInt()
-                )
-            }
-        }
-    }
-
-    internal class ReflectionQueueDry : InboundD2mMessage(D2mPayloadType.REFLECTION_QUEUE_DRY) {
-        override val type: String = "D2mReflectionQueueDry"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): ReflectionQueueDry {
-                 if (container.payloadType != D2mPayloadType.REFLECTION_QUEUE_DRY) {
-                     throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                 }
-                return ReflectionQueueDry()
-            }
-        }
-    }
-
-    internal class RolePromotedToLeader : InboundD2mMessage(D2mPayloadType.ROLE_PROMOTED_TO_LEADER) {
-        override val type: String = "D2mRolePromotedToLeader"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): RolePromotedToLeader {
-                if (container.payloadType != D2mPayloadType.ROLE_PROMOTED_TO_LEADER) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                return RolePromotedToLeader()
-            }
-        }
-    }
-
-    class DevicesInfo(val augmentedDeviceInfo: Map<DeviceId, AugmentedDeviceInfo>) : InboundD2mMessage(D2mPayloadType.DEVICES_INFO) {
-        override val type: String = "D2mDevicesInfo"
-
-        data class AugmentedDeviceInfo (
-            val encryptedDeviceInfo: ByteArray,
-            val connectedSince: ULong,
-            val lastDisconnectAt: ULong,
-            val deviceSlotExpirationPolicy: DeviceSlotExpirationPolicy
-        ) {
-            companion object {
-                fun fromProto(augmentedDeviceInfo: MdD2M.DevicesInfo.AugmentedDeviceInfo): AugmentedDeviceInfo {
-                    return AugmentedDeviceInfo(
-                        augmentedDeviceInfo.encryptedDeviceInfo.toByteArray(),
-                        augmentedDeviceInfo.connectedSince.toULong(),
-                        augmentedDeviceInfo.lastDisconnectAt.toULong(),
-                        DeviceSlotExpirationPolicy.fromProto(augmentedDeviceInfo.deviceSlotExpirationPolicyValue)
-                    )
-                }
-            }
-
-            override fun equals(other: Any?): Boolean {
-                if (this === other) return true
-                if (other !is AugmentedDeviceInfo) return false
-
-                if (!encryptedDeviceInfo.contentEquals(other.encryptedDeviceInfo)) return false
-                if (connectedSince != other.connectedSince) return false
-                if (lastDisconnectAt != other.lastDisconnectAt) return false
-                if (deviceSlotExpirationPolicy != other.deviceSlotExpirationPolicy) return false
-
-                return true
-            }
-
-            override fun hashCode(): Int {
-                var result = encryptedDeviceInfo.contentHashCode()
-                result = 31 * result + connectedSince.hashCode()
-                result = 31 * result + lastDisconnectAt.hashCode()
-                result = 31 * result + deviceSlotExpirationPolicy.hashCode()
-                return result
-            }
-        }
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): DevicesInfo {
-                if (container.payloadType != D2mPayloadType.DEVICES_INFO) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                val proto = MdD2M.DevicesInfo.parseFrom(container.payload)
-                val info = proto.augmentedDeviceInfoMap.entries.associate {
-                    val deviceId = DeviceId(it.key.toULong())
-                    val info = AugmentedDeviceInfo(
-                        it.value.encryptedDeviceInfo.toByteArray(),
-                        it.value.connectedSince.toULong(),
-                        it.value.lastDisconnectAt.toULong(),
-                        DeviceSlotExpirationPolicy.fromProto(it.value.deviceSlotExpirationPolicyValue)
-                    )
-                    deviceId to info
-                }
-                return DevicesInfo(info)
-            }
-        }
-    }
-
-    class DropDeviceAck(val deviceId: DeviceId) : InboundD2mMessage(D2mPayloadType.DROP_DEVICE_ACK) {
-        override val type: String = "D2mDropDeviceAck"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): DropDeviceAck {
-                if (container.payloadType != D2mPayloadType.DROP_DEVICE_ACK) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                val proto = MdD2M.DropDeviceAck.parseFrom(container.payload)
-                return DropDeviceAck(DeviceId(proto.deviceId.toULong()))
-            }
-        }
-    }
-
-    class BeginTransactionAck : InboundD2mMessage(D2mPayloadType.BEGIN_TRANSACTION_ACK) {
-        override val type: String = "D2mBeginTransactionAck"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): BeginTransactionAck {
-                if (container.payloadType != D2mPayloadType.BEGIN_TRANSACTION_ACK) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                return BeginTransactionAck()
-            }
-        }
-    }
-
-    class CommitTransactionAck : InboundD2mMessage(D2mPayloadType.COMMIT_TRANSACTION_ACK) {
-        override val type: String = "D2mCommitTransactionAck"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): CommitTransactionAck {
-                if (container.payloadType != D2mPayloadType.COMMIT_TRANSACTION_ACK) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                return CommitTransactionAck()
-            }
-        }
-    }
-
-    class TransactionRejected(
-        val deviceId: DeviceId,
-        val encryptedScope: ByteArray
-    ) : InboundD2mMessage(D2mPayloadType.TRANSACTION_REJECTED) {
-        override val type: String = "D2mTransactionRejected"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): TransactionRejected {
-                if (container.payloadType != D2mPayloadType.TRANSACTION_REJECTED) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                val proto = MdD2M.TransactionRejected.parseFrom(container.payload)
-                return TransactionRejected(
-                    DeviceId(proto.deviceId.toULong()),
-                    proto.encryptedScope.toByteArray()
-                )
-            }
-        }
-    }
-
-    class TransactionEnded(
-        val deviceId: DeviceId,
-        val encryptedScope: ByteArray
-    ) : InboundD2mMessage(D2mPayloadType.TRANSACTION_ENDED) {
-        override val type: String = "D2mTransactionEnded"
-
-        companion object {
-            fun decodeContainer(container: D2mContainer): TransactionEnded {
-                if (container.payloadType != D2mPayloadType.TRANSACTION_ENDED) {
-                    throw D2mProtocolException("Invalid payload type `${container.payloadType}`")
-                }
-                val proto = MdD2M.TransactionEnded.parseFrom(container.payload)
-                return TransactionEnded(
-                    DeviceId(proto.deviceId.toULong()),
-                    proto.encryptedScope.toByteArray()
-                )
-            }
-        }
-    }
-
-    // TODO(ANDR-2475): Reflected messages
-    // class Reflect : OutboundD2mMessage
-    // class ReflectAck : D2mMessage
-    // class Reflected : D2mMessage
-    // class ReflectedAck : OutboundD2mMessage
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/data/data.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/data/data.kt
deleted file mode 100644
index 7fbfab2d..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/data/data.kt
+++ /dev/null
@@ -1,35 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.data
-
-import ch.threema.base.utils.Utils
-
-sealed interface InboundMessage {
-    val payloadType: UByte
-}
-sealed interface OutboundMessage {
-    val payloadType: UByte
-}
-
-fun UByte.toHex(): String {
-    return Utils.byteToHex(toByte(), false, false)
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/AuthLayer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/AuthLayer.kt
deleted file mode 100644
index a80b9c82..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/AuthLayer.kt
+++ /dev/null
@@ -1,130 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.connection.*
-import ch.threema.domain.protocol.connection.data.CspContainer
-import ch.threema.domain.protocol.connection.data.CspFrame
-import ch.threema.domain.protocol.connection.data.CspLoginMessage
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.InboundL2Message
-import ch.threema.domain.protocol.connection.data.InboundL3Message
-import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
-import ch.threema.domain.protocol.connection.data.OutboundL3Message
-import ch.threema.domain.protocol.connection.data.OutboundL4Message
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.connection.util.Layer3Controller
-import ch.threema.domain.protocol.connection.util.MdLayer3Controller
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.launch
-
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("AuthLayer")
-
-internal class AuthLayer(
-    private val controller: Layer3Controller
-) : Layer3Codec {
-
-    init {
-        CoroutineScope(controller.dispatcher.coroutineContext).launch {
-            controller.connected.await()
-            initiateCspHandshake()
-        }
-    }
-
-    private val mdController: MdLayer3Controller by lazy {
-        if (controller is MdLayer3Controller) {
-            controller
-        } else {
-            throw ServerConnectionException("Requested md controller in non-md configuration")
-        }
-    }
-
-    private val inbound = ProcessingPipe<InboundL2Message, InboundL3Message> { handleInbound(it) }
-    private val outbound = ProcessingPipe<OutboundL4Message, OutboundL3Message> { handleOutbound(it) }
-
-    override val encoder: PipeProcessor<OutboundL4Message, OutboundL3Message> = outbound
-    override val decoder: PipeProcessor<InboundL2Message, InboundL3Message> = inbound
-
-    private fun initiateCspHandshake() {
-        controller.dispatcher.assertDispatcherContext()
-
-        controller.cspSession.startLogin(outbound)
-    }
-
-    private fun handleInbound(message: InboundL2Message) {
-        controller.dispatcher.assertDispatcherContext()
-
-        logger.trace("Handle inbound message of type `{}`", message.type)
-        when (message) {
-            is CspLoginMessage -> handleInboundCspLoginMessage(message)
-            is CspFrame -> handleInboundCspFrame(message)
-            is InboundD2mMessage -> handleInboundD2mMessage(message)
-        }
-    }
-
-    private fun handleOutbound(message: OutboundL4Message) {
-        controller.dispatcher.assertDispatcherContext()
-
-        logger.trace("Handle outbound message of type `{}`", message.type)
-        when (message) {
-            is CspContainer -> handlePostHandshakeOutboundCspMessage(message)
-            is OutboundD2mMessage -> handleOutboundD2mMessage(message)
-        }
-    }
-
-    private fun handlePostHandshakeOutboundCspMessage(container: CspContainer) {
-        controller.dispatcher.assertDispatcherContext()
-
-        outbound.send(controller.cspSession.encryptContainer(container))
-    }
-
-    private fun handleInboundCspLoginMessage(message: CspLoginMessage) {
-        controller.cspSession.handleLoginMessage(message, outbound)
-        if (controller.cspSession.isLoginDone) {
-            controller.cspAuthenticated.complete(Unit)
-            logger.debug("Csp handshake completed")
-        }
-    }
-
-    private fun handleInboundCspFrame(frame: CspFrame) {
-        controller.dispatcher.assertDispatcherContext()
-
-        inbound.send(controller.cspSession.decryptBox(frame))
-    }
-
-    private fun handleOutboundD2mMessage(container: OutboundD2mMessage) {
-        controller.dispatcher.assertDispatcherContext()
-
-        outbound.send(container)
-    }
-
-    private fun handleInboundD2mMessage(message: InboundD2mMessage) {
-        controller.dispatcher.assertDispatcherContext()
-
-        if (mdController.d2mSession.isLoginDone) {
-            inbound.send(message)
-        } else {
-            mdController.d2mSession.handleHandshakeMessage(message, outbound)
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/CspFrameLayer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/CspFrameLayer.kt
deleted file mode 100644
index 079c3298..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/CspFrameLayer.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.connection.*
-import ch.threema.domain.protocol.connection.PipeProcessor
-import ch.threema.domain.protocol.connection.data.ByteContainer
-import ch.threema.domain.protocol.connection.data.CspData
-import ch.threema.domain.protocol.connection.data.InboundL1Message
-import ch.threema.domain.protocol.connection.data.OutboundL2Message
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("CspFrameLayer")
-internal class CspFrameLayer : Layer1Codec {
-    override val encoder: PipeProcessor<OutboundL2Message, ByteArray> = MappingPipe {
-        logger.trace("Handle outbound message of type `{}`", it.type)
-        if (it is ByteContainer) {
-            it.bytes
-        } else {
-            throw ServerConnectionException("OutboundL2Message has invalid type `${it.type}`")
-        }
-    }
-
-    override val decoder: PipeProcessor<ByteArray, InboundL1Message> = MappingPipe {
-        logger.trace("Handle inbound message with {} bytes", it.size)
-        CspData(it)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/D2mFrameLayer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/D2mFrameLayer.kt
deleted file mode 100644
index 293f8698..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/D2mFrameLayer.kt
+++ /dev/null
@@ -1,59 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.D2mProtocolDefines
-import ch.threema.domain.protocol.connection.InvalidSizeException
-import ch.threema.domain.protocol.connection.MappingPipe
-import ch.threema.domain.protocol.connection.PipeProcessor
-import ch.threema.domain.protocol.connection.ServerConnectionException
-import ch.threema.domain.protocol.connection.data.D2mContainer
-import ch.threema.domain.protocol.connection.data.InboundL1Message
-import ch.threema.domain.protocol.connection.data.OutboundL2Message
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("D2mFrameLayer")
-
-internal class D2mFrameLayer : Layer1Codec {
-    override val encoder: PipeProcessor<OutboundL2Message, ByteArray> = MappingPipe {
-        logger.trace("Handle outbound message of type `{}`", it.type)
-        if (it is D2mContainer) {
-            it.bytes
-        } else {
-            throw ServerConnectionException("OutboundL2Message has invalid type `${it.type}`")
-        }
-    }
-
-    override val decoder: PipeProcessor<ByteArray, InboundL1Message> = MappingPipe {
-        logger.trace("Handle inbound message with {} bytes", it.size)
-
-        if (it.size > D2mProtocolDefines.D2M_FRAME_MAX_BYTES_LENGTH) {
-            throw InvalidSizeException("Inbound frame too large: ${it.size} bytes")
-        }
-
-        if (it.size < D2mProtocolDefines.D2M_FRAME_MIN_BYTES_LENGTH) {
-            throw InvalidSizeException("Inbound frame too small: ${it.size} bytes")
-        }
-
-        D2mContainer(it[0].toUByte(), it.copyOfRange(4, it.size))
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/EndToEndLayer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/EndToEndLayer.kt
deleted file mode 100644
index 413fc630..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/EndToEndLayer.kt
+++ /dev/null
@@ -1,111 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.connection.InputPipe
-import ch.threema.domain.protocol.connection.Pipe
-import ch.threema.domain.protocol.connection.PipeHandler
-import ch.threema.domain.protocol.connection.ServerConnection
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.connection.data.InboundL4Message
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
-import ch.threema.domain.protocol.connection.data.OutboundL5Message
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.connection.util.ServerConnectionController
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.InternalTaskManager
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.channels.Channel
-import kotlinx.coroutines.delay
-import kotlinx.coroutines.flow.receiveAsFlow
-import kotlinx.coroutines.launch
-import kotlin.coroutines.CoroutineContext
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("EndToEndLayer")
-
-internal class EndToEndLayer(
-    private val outputDispatcher: CoroutineContext,
-    private val connectionController: ServerConnectionController,
-    private val connection: ServerConnection,
-    private val incomingMessageProcessor: IncomingMessageProcessor,
-    private val taskManager: InternalTaskManager,
-) : Layer5Codec {
-    private val inboundMessageChannel = Channel<InboundMessage>(capacity = Channel.UNLIMITED)
-
-    init {
-        CoroutineScope(connectionController.dispatcher.coroutineContext).launch {
-            launch {
-                connectionController.cspAuthenticated.await()
-                // Start task manager when csp has been authenticated
-                taskManager.startRunningTasks(this@EndToEndLayer, incomingMessageProcessor)
-
-                // Forward inbound messages to task manager after it has been started
-                inboundMessageChannel.receiveAsFlow().collect {
-                    taskManager.processInboundMessage(it)
-                }
-            }
-
-            launch {
-                connectionController.connectionClosed.await()
-                taskManager.pauseRunningTasks()
-            }
-        }
-    }
-
-    private val outbound = InputPipe<OutboundL5Message>()
-
-    override val source: Pipe<OutboundL5Message> = outbound
-
-    override val sink: PipeHandler<InboundL4Message> = PipeHandler { handleInboundMessage(it) }
-
-    override fun sendOutbound(message: OutboundMessage) {
-        CoroutineScope(outputDispatcher).launch {
-            val l5Message = mapMessage(message)
-            logger.debug("Send outbound message of type `{}`", l5Message.type)
-            outbound.send(l5Message)
-        }
-    }
-
-    override fun restartConnection(delayMs: Long) {
-        CoroutineScope(connectionController.dispatcher.coroutineContext).launch {
-            delay(delayMs)
-            if (!connectionController.connectionClosed.isCompleted) {
-                connection.stop()
-                connection.start()
-            }
-        }
-    }
-
-    private fun mapMessage(message: OutboundMessage): OutboundL5Message {
-        return when (message) {
-            is CspMessage -> message.toCspContainer()
-            is OutboundD2mMessage -> message
-        }
-    }
-
-    private fun handleInboundMessage(message: InboundL4Message) {
-        logger.debug("Handle inbound message of type `{}`", message.type)
-        inboundMessageChannel.trySend(message.toInboundMessage())
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt
deleted file mode 100644
index fa43b14d..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MonitoringLayer.kt
+++ /dev/null
@@ -1,267 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.connection.PayloadProcessingException
-import ch.threema.domain.protocol.connection.PipeProcessor
-import ch.threema.domain.protocol.connection.ProcessingPipe
-import ch.threema.domain.protocol.connection.ServerConnection
-import ch.threema.domain.protocol.connection.ServerConnectionException
-import ch.threema.domain.protocol.connection.data.CspContainer
-import ch.threema.domain.protocol.connection.data.D2mProtocolException
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.InboundL3Message
-import ch.threema.domain.protocol.connection.data.InboundL4Message
-import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
-import ch.threema.domain.protocol.connection.data.OutboundL4Message
-import ch.threema.domain.protocol.connection.data.OutboundL5Message
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.connection.util.Layer4Controller
-import ch.threema.domain.protocol.connection.util.MdLayer4Controller
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.delay
-import kotlinx.coroutines.launch
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-import java.util.Date
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("MonitoringLayer")
-internal class MonitoringLayer(
-    private val connection: ServerConnection,
-    private val controller: Layer4Controller
-    ) : Layer4Codec {
-    private companion object {
-        // Preserve echo sequence number across new instance creations
-        private var lastSentEchoSeq: Int = 0
-        private var lastRcvdEchoSeq: Int = 0
-
-        // The count of "another connection" error messages
-        // is reset, when a new connection session is started
-        private var anotherConnectionCount: Int = 0
-    }
-
-    private val mdController: MdLayer4Controller by lazy {
-            if (controller is MdLayer4Controller) {
-                controller
-            } else {
-                throw ServerConnectionException("Requested md controller in non-md configuration")
-            }
-        }
-
-    private var echoRequestJob: Job? = null
-
-    private val inbound = ProcessingPipe<InboundL3Message, InboundL4Message>(this::handleInbound)
-    private val outbound = ProcessingPipe<OutboundL5Message, OutboundL4Message>(this::handleOutbound)
-
-    override val encoder: PipeProcessor<OutboundL5Message, OutboundL4Message> = outbound
-    override val decoder: PipeProcessor<InboundL3Message, InboundL4Message> = inbound
-
-    private var stopped = false
-
-    init {
-        CoroutineScope(controller.dispatcher.coroutineContext).launch {
-            launch {
-                controller.cspAuthenticated.await()
-                startMonitoring(ProtocolDefines.CONNECTION_IDLE_TIMEOUT)
-            }
-            launch {
-                controller.connectionClosed.await()
-                stopMonitoring()
-            }
-        }
-        if (connection.isNewConnectionSession) {
-            logger.debug("Reset another connection count")
-            anotherConnectionCount = 0
-        }
-    }
-    private fun handleInbound(message: InboundL3Message) {
-        controller.dispatcher.assertDispatcherContext()
-
-        logger.trace("Handle inbound message of type `{}`", message.type)
-        when (message) {
-            is CspContainer -> handleInboundCspContainer(message)
-            is InboundD2mMessage -> handleInboundD2mMessage(message)
-        }
-    }
-
-    private fun handleOutbound(message: OutboundL5Message) {
-        logger.trace("Handle outbound message of type `{}`", message.type)
-        outbound.send(mapOutbound(message))
-    }
-    private fun mapOutbound(message: OutboundL5Message): OutboundL4Message {
-        controller.dispatcher.assertDispatcherContext()
-
-        return when(message) {
-            is CspContainer -> message
-            is OutboundD2mMessage -> message
-        }
-    }
-
-    private fun handleInboundD2mMessage(message: InboundD2mMessage) {
-        when (message) {
-            is InboundD2mMessage.RolePromotedToLeader -> handlePromotedToLeader()
-            is InboundD2mMessage.ReflectionQueueDry -> mdController.reflectionQueueDry.complete(Unit)
-            else -> inbound.send(message)
-        }
-    }
-
-    private fun handlePromotedToLeader() {
-        if (!mdController.reflectionQueueDry.isCompleted || mdController.reflectionQueueDry.isCancelled) {
-            throw D2mProtocolException("RolePromotedToLeader was received before ReflectionQueueDry")
-        }
-        CoroutineScope(controller.dispatcher.coroutineContext).launch {
-            controller.cspAuthenticated.await()
-            logger.debug("Send UnblockIncomingMessage to chat server")
-            // TODO(ANDR-2475): Only send this when all (supported) reflected messages have been processed and acked (ReflectedAck)
-            //  Should unsupported (yet) messages also be acked, or ignored for this?
-            outbound.send(CspContainer(ProtocolDefines.PLTYPE_UNBLOCK_INCOMING_MESSAGES.toUByte(), ByteArray(0)))
-        }
-    }
-
-    private fun handleInboundCspContainer(message: CspContainer) {
-        when (message.payloadType.toInt()) {
-            ProtocolDefines.PLTYPE_ECHO_REPLY -> handleEchoReply(message)
-            ProtocolDefines.PLTYPE_ERROR -> handleCloseError(message)
-            else -> inbound.send(message)
-        }
-    }
-
-    /**
-     * This only handles the `can-reconnect` flag of the close error.
-     * Handling of the message (e.g. Display it to the user) will be handled
-     * by the task manager
-     */
-    private fun handleCloseError(container: CspContainer) {
-        val closeError = container.toInboundMessage().toServerErrorData()
-
-        /* close-errors can be ignored to the extend that the message has not to be
-         * shown to the user. If there actually is another device connecting to the
-         * server this will be signaled by the device cookie change indication (a
-         * corresponding message will be displayed to the user).
-         *
-         * In order for the device cookie change indication to show up a reconnect
-         * has to be performed. Therefore we ignore the `canReconnect` flag for up
-         * to five times.
-         *
-         * There might be some strange situations where the `another connection` might occur
-         * on a single device due to weird timing when switching between networks. In this
-         * case it is still the same device and therefore no problem.
-         * If the second connection actually stems from another device, a device cookie change
-         * indication will be triggered upon the next connection to the chat server.
-         *
-         * Note: If there are two connections to the chat server from the same id, only the
-         * first connection will be closed and receive a server error. The Second connection
-         * will be left untouched and not be notified.
-         *
-         * TODO(ANDR-2474): Consolidate "another connection" behaviour
-         */
-        if (closeError.message.contains("Another connection") && anotherConnectionCount < 3) {
-            // Ignore `canReconnect` flag
-            anotherConnectionCount++
-            logger.warn("Ignore `another connection` error #{}", anotherConnectionCount)
-        } else {
-            if (!closeError.canReconnect) {
-                connection.disableReconnect()
-            }
-            inbound.send(container)
-        }
-    }
-
-    private fun handleEchoReply(message: CspContainer) {
-        logger.debug("Handle echo reply")
-        controller.dispatcher.assertDispatcherContext()
-
-        val data = message.data
-        if (data.size != 12) {
-            throw PayloadProcessingException("Bad length (${data.size}) for echo reply payload")
-        }
-        val buffer = ByteBuffer.wrap(data).order(ByteOrder.nativeOrder())
-        lastRcvdEchoSeq = buffer.int
-        val rttMs = Date().time - buffer.long
-        logger.info("Received echo reply (seq: {}, rtt: {} ms) ", lastRcvdEchoSeq, rttMs)
-    }
-
-    private fun startMonitoring(connectionIdleTimeoutS: Short) {
-        controller.dispatcher.assertDispatcherContext()
-
-        if (stopped) {
-            logger.warn("Ignore attempt to start monitoring after monitoring has already been stopped")
-        } else {
-            logger.trace("Set connection idle timeout to {} seconds", connectionIdleTimeoutS)
-            outbound.send(prepareSetConnectionIdleTimeout(connectionIdleTimeoutS))
-            logger.debug("Start periodic echo requests")
-            echoRequestJob = CoroutineScope(controller.dispatcher.coroutineContext).launch {
-                while(true) {
-                    delay(ProtocolDefines.ECHO_REQUEST_INTERVAL * 1000L)
-                    sendEchoRequest()
-                }
-            }
-        }
-    }
-
-    private fun stopMonitoring() {
-        controller.dispatcher.assertDispatcherContext()
-        logger.debug("Stop periodic echo requests")
-
-        stopped = true
-
-        echoRequestJob?.cancel()
-        echoRequestJob = null
-    }
-
-    private suspend fun sendEchoRequest() {
-        controller.dispatcher.assertDispatcherContext()
-
-        lastSentEchoSeq++
-        logger.info("Sending echo request (seq: $lastSentEchoSeq)")
-        outbound.send(prepareEchoRequest(lastSentEchoSeq))
-
-        delay(ProtocolDefines.ECHO_RESPONSE_TIMEOUT * 1000L)
-        if (lastRcvdEchoSeq < lastSentEchoSeq) {
-            logger.info("No reply to echo request (seq: {}); terminate connection", lastSentEchoSeq)
-            controller.ioProcessingStoppedSignal.completeExceptionally(ServerConnectionException("No reply to echo request"))
-        }
-    }
-
-    private fun prepareEchoRequest(sequenceNumber: Int): CspContainer {
-        val echoData = ByteBuffer.wrap(ByteArray(12))
-            .order(ByteOrder.nativeOrder())
-            .putInt(sequenceNumber)
-            .putLong(Date().time)
-            .array()
-        return CspContainer(ProtocolDefines.PLTYPE_ECHO_REQUEST.toUByte(), echoData)
-    }
-
-    private fun prepareSetConnectionIdleTimeout(idleTimeout: Short): CspContainer {
-        if (idleTimeout < 30 || idleTimeout > 600) {
-            throw ServerConnectionException("Invalid connection idle timeout: $idleTimeout")
-        }
-        val timeoutBytes = ByteBuffer
-            .allocate(Short.SIZE_BYTES)
-            .order(ByteOrder.LITTLE_ENDIAN)
-            .putShort(idleTimeout)
-            .array()
-        return CspContainer(ProtocolDefines.PLTYPE_SET_CONNECTION_IDLE_TIMEOUT.toUByte(), timeoutBytes)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MultiplexLayer.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MultiplexLayer.kt
deleted file mode 100644
index 3012509d..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/MultiplexLayer.kt
+++ /dev/null
@@ -1,168 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.D2mPayloadType
-import ch.threema.domain.protocol.connection.InvalidSizeException
-import ch.threema.domain.protocol.connection.ServerConnectionException
-import ch.threema.domain.protocol.connection.PipeProcessor
-import ch.threema.domain.protocol.connection.ProcessingPipe
-import ch.threema.domain.protocol.connection.data.CspData
-import ch.threema.domain.protocol.connection.data.CspFrame
-import ch.threema.domain.protocol.connection.data.CspLoginMessage
-import ch.threema.domain.protocol.connection.data.D2mContainer
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.D2mProtocolException
-import ch.threema.domain.protocol.connection.data.InboundL1Message
-import ch.threema.domain.protocol.connection.data.InboundL2Message
-import ch.threema.domain.protocol.connection.data.OutboundD2mMessage
-import ch.threema.domain.protocol.connection.data.OutboundL2Message
-import ch.threema.domain.protocol.connection.data.OutboundL3Message
-import ch.threema.domain.protocol.connection.data.toHex
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import ch.threema.domain.protocol.connection.util.MdServerConnectionController
-import ch.threema.domain.protocol.connection.util.ServerConnectionController
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("MultiplexLayer")
-
-internal class MultiplexLayer(private val controller: ServerConnectionController) : Layer2Codec {
-
-    private val inbound = ProcessingPipe<InboundL1Message, InboundL2Message> { handleInbound(it) }
-    private val outbound = ProcessingPipe<OutboundL3Message, OutboundL2Message> { handleOutbound(it) }
-
-    override val encoder: PipeProcessor<OutboundL3Message, OutboundL2Message> = outbound
-    override val decoder: PipeProcessor<InboundL1Message, InboundL2Message> = inbound
-
-    private fun handleInbound(message: InboundL1Message) {
-        controller.dispatcher.assertDispatcherContext()
-
-        logger.trace("Handle inbound message of type `{}`", message.type)
-        when (message) {
-            is CspData -> handleInboundCspMessage(message)
-            is D2mContainer -> handleInboundD2mContainer(message)
-        }
-    }
-
-    private fun handleInboundCspMessage(message: CspData) {
-        if (controller.cspSessionState.isLoginDone) {
-            // When the csp login is done the data should be treated as a csp frame
-            if (message.bytes.size < ProtocolDefines.OVERHEAD_PKT_HDR + ProtocolDefines.OVERHEAD_NACL_BOX) {
-                logger.error("Short payload received ({} bytes)", message.bytes.size)
-            } else {
-                logger.debug("Received payload ({} bytes)", message.bytes.size)
-                inbound.send(CspFrame(message.bytes))
-            }
-        } else {
-            // When the login is not yet completed the data has to be handled as a login message
-            inbound.send(CspLoginMessage(message.bytes))
-        }
-    }
-
-    private fun handleInboundD2mContainer(container: D2mContainer) {
-        if (controller !is MdServerConnectionController) {
-            throw ServerConnectionException("Received D2mContainer in non-md configuration")
-        }
-        logger.info("Handle inbound D2mContainer with payloadType={}", container.payloadType.toHex())
-        if (container.payloadType == D2mPayloadType.PROXY) {
-            handleInboundCspMessage(getCspDataFromD2mProxyMessage(container))
-        } else {
-            try {
-                inbound.send(InboundD2mMessage.decodeContainer(container))
-            } catch (e: D2mProtocolException) {
-                logger.error("Could not decode D2mContainer", e)
-            }
-        }
-    }
-
-    /**
-     * Extract the `CspData` from a D2m Proxy message.
-     * <p>
-     * If the csp login is not yet completed, the full payload is relevant data which must be passed
-     * on to the next layer as a [CspLoginMessage].
-     * If the csp login is already done, the length has to be stripped from the payload, as this is
-     * not required for further processing (will be passed on as a [CspFrame]).
-     * Note: The conversion to a [CspLoginMessage] or a [CspFrame] will be completed in [handleInboundCspMessage].
-     * <p>
-     * When the [ch.threema.domain.protocol.connection.CspConnection] is used, the differentiation between
-     * login messages and frames is already performed in the [ch.threema.domain.protocol.connection.socket.CspSocket].
-     */
-    private fun getCspDataFromD2mProxyMessage(container: D2mContainer): CspData {
-        if (container.payloadType != D2mPayloadType.PROXY) {
-            throw D2mProtocolException("Not a proxy message (payloadType=${container.payloadType})")
-        }
-        return if (controller.cspSessionState.isLoginDone) {
-            val length = ByteBuffer
-                .wrap(container.payload.copyOfRange(0, 2))
-                .order(ByteOrder.LITTLE_ENDIAN)
-                .short.toUShort().toInt()
-            val size = container.payload.size
-            val payload = container.payload.copyOfRange(2, size)
-            if (container.payload.size - 2 != length) {
-                throw InvalidSizeException("Encoded and actual data length do not match")
-            }
-            // Extract only the payload, as the length is not used anymore [CspFrame]
-            CspData(payload)
-        } else {
-            // Use the full payload [CspLoginMessage]
-            CspData(container.payload)
-        }
-    }
-
-    private fun handleOutbound(message: OutboundL3Message) {
-        logger.trace("Handle outbound message of type `{}`", message.type)
-        when (message) {
-            is CspFrame -> handleOutboundCspFrame(message)
-            is CspLoginMessage -> handleOutboundCspLoginMessage(message)
-            is OutboundD2mMessage -> handleOutboundD2mMessage(message)
-        }
-    }
-
-    private fun handleOutboundCspFrame(message: CspFrame) {
-        try {
-            sendOutboundCspData(message.toCspData())
-        } catch (e: InvalidSizeException) {
-            logger.info("Ignore packet with invalid size", e)
-        }
-    }
-
-    private fun handleOutboundCspLoginMessage(message: CspLoginMessage) {
-        sendOutboundCspData(CspData(message.bytes))
-    }
-
-    private fun sendOutboundCspData(data: CspData) {
-        val outboundData = if (controller is MdServerConnectionController) {
-            // MD Configuration -> wrap in proxy message
-            logger.debug("Send csp data as d2m proxy message")
-            D2mContainer(D2mPayloadType.PROXY, data.bytes)
-        } else {
-            data
-        }
-        outbound.send(outboundData)
-    }
-
-    private fun handleOutboundD2mMessage(message: OutboundD2mMessage) {
-        outbound.send(message.toContainer())
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/ServerConnectionLayers.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/ServerConnectionLayers.kt
deleted file mode 100644
index 42051779..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/ServerConnectionLayers.kt
+++ /dev/null
@@ -1,30 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-internal data class ServerConnectionLayers(
-    val layer1Codec: Layer1Codec,
-    val layer2Codec: Layer2Codec,
-    val layer3Codec: Layer3Codec,
-    val layer4Codec: Layer4Codec,
-    val layer5Codec: Layer5Codec,
-)
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/layers.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/layer/layers.kt
deleted file mode 100644
index 9d223af1..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/layer/layers.kt
+++ /dev/null
@@ -1,83 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.connection.InboundPipeProcessor
-import ch.threema.domain.protocol.connection.PipeSink
-import ch.threema.domain.protocol.connection.PipeSource
-import ch.threema.domain.protocol.connection.OutboundPipeProcessor
-import ch.threema.domain.protocol.connection.data.InboundL1Message
-import ch.threema.domain.protocol.connection.data.InboundL2Message
-import ch.threema.domain.protocol.connection.data.InboundL3Message
-import ch.threema.domain.protocol.connection.data.InboundL4Message
-import ch.threema.domain.protocol.connection.data.OutboundL2Message
-import ch.threema.domain.protocol.connection.data.OutboundL3Message
-import ch.threema.domain.protocol.connection.data.OutboundL4Message
-import ch.threema.domain.protocol.connection.data.OutboundL5Message
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-
-/**
- * The frame layer decodes incoming byte arrays to the correct container type.
- * The container type depends on the implementation and is different for multi device and
- * non-multi device environment.
- */
-internal interface Layer1Codec : InboundPipeProcessor<ByteArray, InboundL1Message>, OutboundPipeProcessor<OutboundL2Message, ByteArray>
-
-/**
- * The multiplex layer is primarly used in a multi device setup and has the responsibility to demultiplex
- * d2m.container to either D2M messages or CSP frames.
- * In a non-multi device environment it will probably only pass the messages on to the next layer.
- */
-internal interface Layer2Codec : InboundPipeProcessor<InboundL1Message, InboundL2Message>, OutboundPipeProcessor<OutboundL3Message, OutboundL2Message>
-
-/**
- * The authentication and transport encryption layer is responsible for the server handshakes
- * (chatserver, mediator) and the transport decryption of handshakes.
- */
-internal interface Layer3Codec : InboundPipeProcessor<InboundL2Message, InboundL3Message>, OutboundPipeProcessor<OutboundL4Message, OutboundL3Message>
-
-/**
- * The connection monitoring and keep alive layer.
- * This layer is responsible for sending and receiving echo requests and thereby keeping the connection
- * alive.
- * It is also responsible for correctly handle events, when the connection is closed by the server
- * e.g. with a close-error.
- */
-internal interface Layer4Codec : InboundPipeProcessor<InboundL3Message, InboundL4Message>, OutboundPipeProcessor<OutboundL5Message, OutboundL4Message>
-
-/**
- * The so called end-to-end layer which is responsible for linking the connection to the task manager.
- * This includes dispatching inbound messages to the task manager and passing on outbound messages to the
- * outer layers.
- */
-internal interface Layer5Codec : PipeSource<OutboundL5Message>, PipeSink<InboundL4Message> {
-    /**
-     * Send an outbound message.
-     */
-    fun sendOutbound(message: OutboundMessage)
-
-    /**
-     * Trigger a connection restart after waiting for [delayMs] milliseconds. Note that this does
-     * only have an effect, if the connection is still running.
-     */
-    fun restartConnection(delayMs: Long)
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/pipe.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/pipe.kt
deleted file mode 100644
index 51f406e8..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/pipe.kt
+++ /dev/null
@@ -1,156 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import kotlinx.coroutines.channels.Channel
-
-/**
- * A processable stream of messages that can be consumed by a handler
- * or transformed by piping it through a [PipeProcessor].
- *
- * Consuming a message means that the handler processes the message and does not emit it downstream.
- * Transforming a message means that the handler _can_ process the message and _can_ map it to
- * another format. When transforming a message it can also mean that the message is just passed on to
- * the next layer without any further processing or mapping of the data.
- */
-internal interface Pipe<T> {
-    fun setHandler(handler: PipeHandler<T>)
-
-    /**
-     * Transform the stream of messages by a [PipeProcessor]. A message can either be consumed or transformed.
-     * If a message is consumed, the message will not be emitted downstream [Pipe].
-     * A transformed message will be emitted downstream [Pipe]
-     *
-     * @param processor The processor handling this pipe's messages
-     * @return a pipe consisting of the transformed (not consumed) messages
-     */
-    fun <O> pipeThrough(processor: PipeProcessor<T, O>): Pipe<O>
-}
-
-/**
- * A handler for messages that are emitted by a pipe.
- */
-internal fun interface PipeHandler<T> {
-    fun handle(msg: T)
-}
-
-/**
- * The source of a [Pipe]. Used where a [Pipe] starts e.g. the output of the socket connection to a
- * server or the output of a task manager.
- */
-internal interface PipeSource<T> {
-    val source: Pipe<T>
-}
-
-/**
- * The sink of a [Pipe] denotes an object that can process the output of a pipe e.g. the input to a
- * connection to a server or the input to a task manager.
- */
-internal interface PipeSink<T> {
-    val sink: PipeHandler<T>
-}
-
-/**
- * An [InputPipe] is a [Pipe] that can be used to send messages into the [Pipe] with it's [send] method.
- */
-internal open class InputPipe<T> : Pipe<T> {
-    private var handler: PipeHandler<T>? = null
-
-    override fun setHandler(handler: PipeHandler<T>) {
-        this.handler = handler
-    }
-
-    fun send(msg: T) {
-        handler?.handle(msg)
-    }
-
-    override fun <O> pipeThrough(processor: PipeProcessor<T, O>): Pipe<O> {
-        return processor.process(this)
-    }
-}
-
-internal class ProcessingPipe<I, O>(private val handler: (I) -> Unit): InputPipe<O>(), PipeProcessor<I, O> {
-
-    override fun process(readable: Pipe<I>): Pipe<O> {
-        readable.setHandler(handler)
-        return this
-    }
-}
-
-/**
- * A [PipeProcessor] that transforms every message using the [mapper].
- */
-internal class MappingPipe<I, O>(private val mapper: (I) -> O): PipeProcessor<I, O> {
-    private val pipe = InputPipe<O>()
-
-    override fun process(readable: Pipe<I>): Pipe<O> {
-        readable.setHandler {
-            pipe.send(mapper(it))
-        }
-        return pipe
-    }
-}
-
-/**
- * A [QueuedPipeHandler] can be used to establish an asynchronous link to a pipe-chain.
- * Messages passed to [handle] will be sent to a queue and can later be retrieved using [take].
- */
-internal class QueuedPipeHandler<T> : PipeHandler<T> {
-    private val queue = Channel<T>(Channel.UNLIMITED)
-
-    override fun handle(msg: T) {
-        val result = queue.trySend(msg)
-        result.getOrThrow()
-    }
-
-    suspend fun take(): T = queue.receive()
-}
-
-/**
- * A processor for a [Pipe]. A [PipeProcessor] can consume messages or transform and re-emit them.
- */
-internal interface PipeProcessor<I, O> {
-    /**
-     * Setup the processing of a pipe's messages. Setting up the processing is a synchronous process
-     * that should return without significant processing time
-     * The actual processing of messages will take place when messages are received and in the scope
-     * of the handling routine.
-     *
-     * @param readable The pipe that shall be processed
-     * @return a [Pipe] of the transformed messages
-     */
-    fun process(readable: Pipe<I>): Pipe<O>
-}
-
-/**
- * A [PipeProcessor] that encodes outbound message e.g. applies transport encryption.
- */
-internal interface OutboundPipeProcessor<I, O> {
-    val encoder: PipeProcessor<I, O>
-}
-
-/**
- * A [PipeProcessor] that decodes inbound messages e.g. decrypts transport encryption.
- */
-internal interface InboundPipeProcessor<I, O> {
-    val decoder: PipeProcessor<I, O>
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/socket/BaseSocket.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/socket/BaseSocket.kt
deleted file mode 100644
index d39872f4..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/socket/BaseSocket.kt
+++ /dev/null
@@ -1,145 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.socket
-
-import ch.threema.domain.protocol.connection.InputPipe
-import ch.threema.domain.protocol.connection.Pipe
-import ch.threema.domain.protocol.connection.PipeHandler
-import ch.threema.domain.protocol.connection.QueuedPipeHandler
-import ch.threema.domain.protocol.connection.util.ConnectionLoggingUtil
-import kotlinx.coroutines.CancellationException
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.CoroutineExceptionHandler
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.cancelAndJoin
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
-import kotlinx.coroutines.withContext
-import java.io.InterruptedIOException
-import kotlin.coroutines.CoroutineContext
-
-private val logger = ConnectionLoggingUtil.getConnectionLogger("BaseSocket")
-
-internal abstract class BaseSocket(
-    protected val ioProcessingStoppedSignal: CompletableDeferred<Unit>,
-    private val inputDispatcher: CoroutineContext
-    ) : ServerSocket {
-
-    private val inbound = InputPipe<ByteArray>()
-    protected val outbound = QueuedPipeHandler<ByteArray>()
-
-    override val closedSignal = CompletableDeferred<ServerSocketCloseReason>()
-
-    final override val source: Pipe<ByteArray> = inbound
-    final override val sink: PipeHandler<ByteArray> = outbound
-
-    protected var ioJob: Job? = null
-
-    /**
-     * False, while the socket is connected and io should be processed. Set to true when no further data
-     * received should be processed.
-     */
-    protected var ioProcessingStopped = true
-
-    final override suspend fun processIo() {
-        synchronized(this) {
-            if (closedSignal.isCompleted) {
-                throw ServerSocketException("The socket is already closed")
-            }
-            launchIoJob()
-        }
-        ioProcessingStoppedSignal.await()
-    }
-
-    private fun launchIoJob() {
-        val errorHandler = CoroutineExceptionHandler { _, e ->
-            if (e is CancellationException || e is InterruptedIOException) {
-                logger.info("IO Processing cancelled")
-                ioProcessingStoppedSignal.complete(Unit)
-            } else {
-                // do not log the exception as it will be logged elsewhere
-                logger.warn("IO processing stopped exceptionally")
-                ioProcessingStoppedSignal.completeExceptionally(e)
-            }
-        }
-        ioJob = CoroutineScope(Dispatchers.Default + errorHandler).launch {
-            launch { setupReading() }
-            launch { setupWriting() }
-        }.also { it.invokeOnCompletion { throwable ->
-            val alreadyCompleted = !ioProcessingStoppedSignal.complete(Unit)
-            val exceptionally = throwable != null
-            logger.info(
-                "IO job completed (exceptionally={}, alreadyCompleted={})",
-                exceptionally,
-                alreadyCompleted
-            )
-            closeSocketAndCompleteClosedSignal(ServerSocketCloseReason("IO processing has stopped (exceptionally=$exceptionally)"))
-        } }
-    }
-
-    final override fun close(reason: ServerSocketCloseReason) {
-        synchronized(this) {
-            logger.info("Close ServerSocket (reason={})", reason)
-            if (closedSignal.isCompleted) {
-                logger.debug("Socket is already closed")
-                return
-            }
-            // when the socket is closed, io processing is stopped
-            ioProcessingStopped = true
-            runBlocking { ioJob?.cancelAndJoin() }
-            closeSocketAndCompleteClosedSignal(reason)
-        }
-    }
-
-    /**
-     * Perform the actual closing of the underlying socket and complete the socket closed signal.
-     *
-     * This should be called _after_ [ioJob] has completed.
-     */
-    private fun closeSocketAndCompleteClosedSignal(reason: ServerSocketCloseReason) {
-        logger.info("Close actual socket")
-        // set stopped, as depending on the code path it might not be set to stopped yet
-        ioProcessingStopped = true
-        closeSocket(reason)
-        if (!closedSignal.complete(reason)) {
-            logger.info("Close signal already completed")
-        }
-    }
-
-    protected abstract suspend fun setupReading()
-    protected abstract suspend fun setupWriting()
-    protected abstract fun closeSocket(reason: ServerSocketCloseReason)
-
-    /**
-     * Send an inbound message. This method only returns after the sending inbound has been completed.
-     * This does not necessarily mean that the message has already been completed, as it might be processed
-     * by an asynchronous task manager.
-     * In this case it only means that the parsed message has been passed over to the task manager.
-     */
-    protected suspend fun sendInbound(data: ByteArray) {
-        withContext(inputDispatcher) {
-            inbound.send(data)
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocket.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocket.kt
deleted file mode 100644
index 797c4693..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocket.kt
+++ /dev/null
@@ -1,66 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.socket
-
-import androidx.annotation.WorkerThread
-import ch.threema.domain.protocol.connection.PipeSink
-import ch.threema.domain.protocol.connection.PipeSource
-import ch.threema.domain.protocol.connection.ServerConnectionException
-import kotlinx.coroutines.Deferred
-import java.net.Socket
-
-internal interface ServerSocket : PipeSource<ByteArray>, PipeSink<ByteArray> {
-
-    val address: String?
-
-    val closedSignal: Deferred<ServerSocketCloseReason>
-
-    /**
-     * Connect the underlying [Socket].
-     * If the underlying [Socket] is already connected, it will be closed and a new [Socket] will be
-     * created.
-     */
-    @WorkerThread
-    @Throws(Exception::class)
-    fun connect()
-
-    /**
-     * Process io of the underlying socket.
-     * This will read data received by the underlying socket and make it available via the output pipe.
-     * [ByteArray]s written to the input pipe will be sent using the underlying socket.
-     *
-     * This Method will only return if the processing has either been cancelled exceptionally or by
-     * calling [close]
-     */
-    @WorkerThread
-    @Throws(Exception::class)
-    suspend fun processIo()
-
-    /**
-     * Close the underlying socket. If the [ServerSocket] is reconnected, a new underlying socket will be created.
-     */
-    @WorkerThread
-    @Throws(Exception::class)
-    fun close(reason: ServerSocketCloseReason)
-}
-
-open class ServerSocketException(msg: String?) : ServerConnectionException(msg)
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocketCloseReason.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocketCloseReason.kt
deleted file mode 100644
index 79cd159e..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/socket/ServerSocketCloseReason.kt
+++ /dev/null
@@ -1,37 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.socket
-
-/**
- * The reason for closing the socket.
- * It is also possible to indicate whether it is allowed to reconnect after the connection has been
- * closed. If this flag is set to `false` no reconnects will be attempted. If set to `true` reconnects
- * _might_ be attempted if it has not been prohibited by other mechanisms (e.g. the connection monitoring).
- *
- * @param msg A message explaining why the socket was closed. Only used for logging
- * @param reconnectAllowed Indicator whether it is allowed to attempt a reconnect
- */
-open class ServerSocketCloseReason(val msg: String, val reconnectAllowed: Boolean? = null) {
-    override fun toString(): String {
-        return "ServerSocketCloseReason(msg='$msg', reconnectAllowed=$reconnectAllowed)"
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/util/ConnectionLoggingUtil.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/util/ConnectionLoggingUtil.kt
deleted file mode 100644
index c41d51d0..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/util/ConnectionLoggingUtil.kt
+++ /dev/null
@@ -1,33 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.util
-
-import ch.threema.base.utils.LoggingUtil
-import org.slf4j.Logger
-
-class ConnectionLoggingUtil {
-    companion object {
-        fun getConnectionLogger(name: String): Logger {
-            return LoggingUtil.getThreemaLogger("ServerConnection.$name")
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/connection/util/ServerConnectionController.kt b/domain/src/main/java/ch/threema/domain/protocol/connection/util/ServerConnectionController.kt
deleted file mode 100644
index 1e9b39f2..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/connection/util/ServerConnectionController.kt
+++ /dev/null
@@ -1,80 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.util
-
-import ch.threema.domain.protocol.connection.ServerConnectionDispatcher
-import ch.threema.domain.protocol.connection.csp.CspSession
-import ch.threema.domain.protocol.connection.csp.CspSessionState
-import ch.threema.domain.protocol.connection.d2m.D2mSession
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.Deferred
-
-internal interface ServerConnectionControllers {
-    val serverConnectionController: ServerConnectionController
-    val mainController: MainConnectionController
-    val layer3Controller: Layer3Controller
-    val layer4Controller: Layer4Controller
-}
-
-/**
- * A controller that is valid during one "connection cycle".
- *
- * The controller will be re-instantiated on every connection attempt.
- *
- * Therefore the controller can only contain connection state that is valid during a single connection
- * cycle.
- */
-internal interface ServerConnectionController {
-    val connected: Deferred<Unit>
-    val cspSessionState: CspSessionState
-    val cspAuthenticated: Deferred<Unit>
-    val connectionClosed: Deferred<Unit>
-    val ioProcessingStoppedSignal: CompletableDeferred<Unit>
-    val dispatcher: ServerConnectionDispatcher
-}
-
-internal interface MdServerConnectionController : ServerConnectionController
-
-internal interface MainConnectionController : ServerConnectionController {
-    override val connected: CompletableDeferred<Unit>
-    override val connectionClosed: CompletableDeferred<Unit>
-    override val dispatcher: ServerConnectionDispatcher
-}
-
-internal interface Layer3Controller : ServerConnectionController {
-    override val cspAuthenticated: CompletableDeferred<Unit>
-    val cspSession: CspSession
-}
-
-/**
- * The [Layer3Controller] that must be used when multi device is activated.
- * With multi device active, both the [CspSession] AND the [D2mSession] are required.
- */
-internal interface MdLayer3Controller : Layer3Controller {
-    val d2mSession: D2mSession
-}
-
-internal interface Layer4Controller : ServerConnectionController
-
-internal interface MdLayer4Controller : Layer4Controller {
-    val reflectionQueueDry: CompletableDeferred<Unit>
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/MessageTooLongException.java b/domain/src/main/java/ch/threema/domain/protocol/csp/MessageTooLongException.java
deleted file mode 100644
index da415335..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/MessageTooLongException.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp;
-
-import ch.threema.base.ThreemaException;
-
-public class MessageTooLongException extends ThreemaException {
-	public MessageTooLongException() {
-		super("Message too long");
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java b/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java
index 74861511..0602570e 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/ProtocolDefines.java
@@ -39,9 +39,11 @@ public class ProtocolDefines {
 	public static final int RECONNECT_MAX_INTERVAL = 10;
 
 	// Echo request timeouts (in seconds)
-	public static final short ECHO_REQUEST_INTERVAL = 60;
-	public static final short CONNECTION_IDLE_TIMEOUT = 120;
 	public static final short ECHO_RESPONSE_TIMEOUT = 10;
+	public static final short ECHO_REQUEST_INTERVAL_CSP = 60;
+	public static final short CONNECTION_IDLE_TIMEOUT_CSP = 120;
+	public static final short ECHO_REQUEST_INTERVAL_MD = 15;
+	public static final short CONNECTION_IDLE_TIMEOUT_MD = 30;
 
 	/* object lengths */
 	public static final int COOKIE_LEN = 16;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java b/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java
index dbf7bc45..45253473 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/coders/MessageCoder.java
@@ -43,7 +43,6 @@ import java.util.HashMap;
 import java.util.Map;
 
 import ch.threema.base.ThreemaException;
-import ch.threema.base.crypto.NonceFactory;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.models.Contact;
 import ch.threema.domain.models.GroupId;
@@ -84,12 +83,9 @@ import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 import ch.threema.domain.protocol.csp.messages.TypingIndicatorMessage;
 import ch.threema.domain.protocol.csp.messages.WebSessionResumeMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.PollSetupMessage;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotData;
-import ch.threema.domain.protocol.csp.messages.ballot.BallotId;
 import ch.threema.domain.protocol.csp.messages.ballot.PollVoteMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.GroupPollSetupMessage;
 import ch.threema.domain.protocol.csp.messages.ballot.GroupPollVoteMessage;
-import ch.threema.domain.protocol.csp.messages.file.FileData;
 import ch.threema.domain.protocol.csp.messages.file.FileMessage;
 import ch.threema.domain.protocol.csp.messages.file.GroupFileMessage;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityData;
@@ -98,17 +94,11 @@ import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestData;
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinRequestMessage;
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseData;
 import ch.threema.domain.protocol.csp.messages.group.GroupJoinResponseMessage;
-import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartData;
 import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallAnswerMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallHangupMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallOfferMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipCallRingingMessage;
-import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesData;
 import ch.threema.domain.protocol.csp.messages.voip.VoipICECandidatesMessage;
 import ch.threema.domain.stores.ContactStore;
 import ch.threema.domain.stores.IdentityStoreInterface;
@@ -284,12 +274,16 @@ public class MessageCoder {
 	 * @return boxed message
 	 */
 	public @NonNull
-	MessageBox encode(@NonNull AbstractMessage message, @NonNull byte[] nonce, @NonNull NonceFactory nonceFactory) throws ThreemaException {
+	MessageBox encode(@NonNull AbstractMessage message, @NonNull byte[] nonce) throws ThreemaException {
 		try {
 			/* prepare data for box */
 			ByteArrayOutputStream bos = new ByteArrayOutputStream();
 			bos.write(message.getType());
-			bos.write(message.getBody());
+            byte[] body = message.getBody();
+            if (body == null) {
+                throw new ThreemaException("Message body is null");
+            }
+            bos.write(body);
 
 			/* PKCS7 padding */
 			SecureRandom rnd = new SecureRandom();
@@ -314,11 +308,6 @@ public class MessageCoder {
 				throw new ThreemaException("Missing public key for ID " + message.getToIdentity());
 			}
 
-			/* Only save the nonce if the message is protected against replay */
-			if (message.protectAgainstReplay()) {
-				nonceFactory.store(nonce);
-			}
-
 			/* sign/encrypt with our private key */
 			byte[] boxedData = identityStore.encryptData(boxData, nonce, receiverPublicKey);
 			if (boxedData == null) {
@@ -376,17 +365,11 @@ public class MessageCoder {
 	private @NonNull AbstractMessage deserializeData(byte[] data, int realDataLength, String fromIdentity, String toIdentity) throws BadMessageException {
 		/* first byte of data is type */
 		int type = data[0] & 0xFF;
-		AbstractMessage msg;
+		AbstractMessage message;
 
 		switch (type) {
 			case ProtocolDefines.MSGTYPE_TEXT: {
-				if (realDataLength < 2) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for text message");
-				}
-
-				TextMessage textmsg = new TextMessage();
-				textmsg.setText(new String(data, 1, realDataLength - 1, UTF_8));
-				msg = textmsg;
+				message = TextMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
@@ -408,7 +391,7 @@ public class MessageCoder {
 				System.arraycopy(data, 1 + 4 + ProtocolDefines.BLOB_ID_LEN, nonce, 0, nonce.length);
 				imagemsg.setNonce(nonce);
 
-				msg = imagemsg;
+				message = imagemsg;
 
 				break;
 			}
@@ -444,7 +427,7 @@ public class MessageCoder {
 					throw new RuntimeException(e);
 				}
 
-				msg = videomsg;
+				message = videomsg;
 
 				break;
 			}
@@ -489,7 +472,7 @@ public class MessageCoder {
 					throw new BadMessageException("Invalid coordinate values in location message");
 				}
 
-				msg = locationmsg;
+				message = locationmsg;
 
 				break;
 			}
@@ -519,7 +502,7 @@ public class MessageCoder {
 					throw new RuntimeException(e);
 				}
 
-				msg = audiomsg;
+				message = audiomsg;
 
 				break;
 			}
@@ -539,7 +522,7 @@ public class MessageCoder {
 					members[i] = new String(data, 1 + ProtocolDefines.GROUP_ID_LEN + i * ProtocolDefines.IDENTITY_LEN, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII);
 				}
 				groupcreatemsg.setMembers(members);
-				msg = groupcreatemsg;
+				message = groupcreatemsg;
 				break;
 			}
 
@@ -552,7 +535,7 @@ public class MessageCoder {
 				groupSyncRequestMessage.setGroupCreator(toIdentity);
 				groupSyncRequestMessage.setApiGroupId(new GroupId(data, 1));
 
-				msg = groupSyncRequestMessage;
+				message = groupSyncRequestMessage;
 
 				break;
 			}
@@ -566,7 +549,7 @@ public class MessageCoder {
 				grouprenamemsg.setGroupCreator(fromIdentity);
 				grouprenamemsg.setApiGroupId(new GroupId(data, 1));
 				grouprenamemsg.setGroupName(new String(data, 1 + ProtocolDefines.GROUP_ID_LEN, realDataLength - 1 - ProtocolDefines.GROUP_ID_LEN, UTF_8));
-				msg = grouprenamemsg;
+				message = grouprenamemsg;
 
 				break;
 			}
@@ -579,20 +562,12 @@ public class MessageCoder {
 				GroupLeaveMessage groupleavemsg = new GroupLeaveMessage();
 				groupleavemsg.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
 				groupleavemsg.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				msg = groupleavemsg;
+				message = groupleavemsg;
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_TEXT: {
-				if (realDataLength < (1 + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN)) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for group text message");
-				}
-
-				GroupTextMessage grouptextmsg = new GroupTextMessage();
-				grouptextmsg.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				grouptextmsg.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				grouptextmsg.setText(new String(data, 1 + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN, realDataLength - 1 - ProtocolDefines.IDENTITY_LEN - ProtocolDefines.GROUP_ID_LEN, UTF_8));
-				msg = grouptextmsg;
+				message = GroupTextMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
@@ -616,7 +591,7 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupsetphotomsg.setEncryptionKey(blobKey);
-				msg = groupsetphotomsg;
+				message = groupsetphotomsg;
 
 				break;
 			}
@@ -630,7 +605,7 @@ public class MessageCoder {
 				groupDeleteProfilePictureMessage.setGroupCreator(fromIdentity);
 				groupDeleteProfilePictureMessage.setApiGroupId(new GroupId(data, 1));
 
-				msg = groupDeleteProfilePictureMessage;
+				message = groupDeleteProfilePictureMessage;
 
 				break;
 			}
@@ -656,7 +631,7 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupimagemsg.setEncryptionKey(blobKey);
-				msg = groupimagemsg;
+				message = groupimagemsg;
 
 				break;
 			}
@@ -690,7 +665,7 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupvideomsg.setEncryptionKey(blobKey);
-				msg = groupvideomsg;
+				message = groupvideomsg;
 
 				break;
 			}
@@ -731,7 +706,7 @@ public class MessageCoder {
 					throw new BadMessageException("Invalid coordinate values in group location message");
 				}
 
-				msg = grouplocationmsg;
+				message = grouplocationmsg;
 
 				break;
 			}
@@ -759,169 +734,67 @@ public class MessageCoder {
 				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
 				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
 				groupaudiomsg.setEncryptionKey(blobKey);
-				msg = groupaudiomsg;
+				message = groupaudiomsg;
 
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_BALLOT_CREATE: {
-				PollSetupMessage groupPollSetupMessage = new PollSetupMessage();
-				int pos = 1;
-				groupPollSetupMessage.setBallotCreator(fromIdentity);
-				groupPollSetupMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-				groupPollSetupMessage.setData(BallotData.parse(new String(data, pos, realDataLength - pos, UTF_8)));
-				msg = groupPollSetupMessage;
+                message = PollSetupMessage.fromByteArray(data, 1, realDataLength - 1, fromIdentity);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_FILE: {
-				FileMessage fileMessage = new FileMessage();
-				int pos = 1;
-				fileMessage.setData(FileData.parse(new String(data, pos, realDataLength - pos, UTF_8)));
-				msg = fileMessage;
+				message = FileMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_BALLOT_VOTE: {
-				PollVoteMessage groupPollVoteMessage = new PollVoteMessage();
-				int pos = 1;
-
-				groupPollVoteMessage.setBallotCreator(new String(data, pos, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollVoteMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-
-				groupPollVoteMessage.parseVotes(new String(data, pos, realDataLength - pos, UTF_8));
-				msg = groupPollVoteMessage;
+				message = PollVoteMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_BALLOT_CREATE: {
-				GroupPollSetupMessage groupPollSetupMessage = new GroupPollSetupMessage();
-				int pos = 1;
-				groupPollSetupMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollSetupMessage.setApiGroupId(new GroupId(data, pos));
-				pos += ProtocolDefines.GROUP_ID_LEN;
-
-				groupPollSetupMessage.setBallotCreator(fromIdentity);
-				groupPollSetupMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-
-				String jsonObjectString = new String(data, pos, realDataLength - pos, UTF_8);
-				groupPollSetupMessage.setData(BallotData.parse(jsonObjectString));
-				groupPollSetupMessage.setRawBallotData(jsonObjectString);
-				msg = groupPollSetupMessage;
+				message = GroupPollSetupMessage.fromByteArray(data, 1, realDataLength - 1, fromIdentity);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_FILE: {
-				GroupFileMessage groupFileMessage = new GroupFileMessage();
-				int pos = 1;
-				groupFileMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupFileMessage.setApiGroupId(new GroupId(data, pos));
-				pos += ProtocolDefines.GROUP_ID_LEN;
-
-				final String jsonObjectString = new String(data, pos, realDataLength - pos, UTF_8);
-				groupFileMessage.setData(FileData.parse(jsonObjectString));
-				msg = groupFileMessage;
+				message = GroupFileMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_BALLOT_VOTE: {
-				GroupPollVoteMessage groupPollVoteMessage = new GroupPollVoteMessage();
-				int pos = 1;
-				groupPollVoteMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollVoteMessage.setApiGroupId(new GroupId(data, pos));
-				pos += ProtocolDefines.GROUP_ID_LEN;
-
-				groupPollVoteMessage.setBallotCreator(new String(data, pos, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				pos += ProtocolDefines.IDENTITY_LEN;
-
-				groupPollVoteMessage.setBallotId(new BallotId(data, pos));
-				pos += ProtocolDefines.BALLOT_ID_LEN;
-
-				groupPollVoteMessage.parseVotes(new String(data, pos, realDataLength - pos, UTF_8));
-				msg = groupPollVoteMessage;
+				message = GroupPollVoteMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_JOIN_REQUEST: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final GroupJoinRequestData groupJoinRequestData = GroupJoinRequestData.fromProtobuf(protobufPayload);
-				msg = new GroupJoinRequestMessage(groupJoinRequestData);
+				message = new GroupJoinRequestMessage(groupJoinRequestData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_JOIN_RESPONSE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final GroupJoinResponseData groupJoinResponseData = GroupJoinResponseData.fromProtobuf(protobufPayload);
-				msg = new GroupJoinResponseMessage(groupJoinResponseData);
+				message = new GroupJoinResponseMessage(groupJoinResponseData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_CALL_START: {
-				int headerLength = 1 + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
-				if (realDataLength < headerLength) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for group call start message");
-				}
-
-				final byte[] protobufPayload = Arrays.copyOfRange(data, headerLength, realDataLength);
-				final GroupCallStartData groupCallStartData = GroupCallStartData.fromProtobuf(protobufPayload);
-				final GroupCallStartMessage callStartMessage = new GroupCallStartMessage(groupCallStartData);
-				callStartMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				callStartMessage.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				msg = callStartMessage;
+                message = GroupCallStartMessage.fromByteArray(data, 1, realDataLength -1 );
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_DELIVERY_RECEIPT: {
-				if (realDataLength < ProtocolDefines.MESSAGE_ID_LEN + 2 || ((realDataLength - 2) % ProtocolDefines.MESSAGE_ID_LEN) != 0) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for delivery receipt");
-				}
-
-				DeliveryReceiptMessage receiptmsg = new DeliveryReceiptMessage();
-				receiptmsg.setReceiptType(data[1] & 0xFF);
-
-				int numMsgIds = ((realDataLength - 2) / ProtocolDefines.MESSAGE_ID_LEN);
-				MessageId[] receiptMessageIds = new MessageId[numMsgIds];
-				for (int i = 0; i < numMsgIds; i++) {
-					receiptMessageIds[i] = new MessageId(data, 2 + i * ProtocolDefines.MESSAGE_ID_LEN);
-				}
-
-				receiptmsg.setReceiptMessageIds(receiptMessageIds);
-				msg = receiptmsg;
-
+				message = DeliveryReceiptMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_GROUP_DELIVERY_RECEIPT: {
-				int groupHeaderLength = ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
-				if ((realDataLength - groupHeaderLength) < ProtocolDefines.MESSAGE_ID_LEN + 2 || ((realDataLength - groupHeaderLength - 2) % ProtocolDefines.MESSAGE_ID_LEN) != 0) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for group delivery receipt");
-				}
-
-				GroupDeliveryReceiptMessage receiptmsg = new GroupDeliveryReceiptMessage();
-				receiptmsg.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
-				receiptmsg.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
-				receiptmsg.setReceiptType(data[groupHeaderLength + 1] & 0xFF);
-
-				int numMsgIds = ((realDataLength - groupHeaderLength - 2) / ProtocolDefines.MESSAGE_ID_LEN);
-				MessageId[] receiptMessageIds = new MessageId[numMsgIds];
-				for (int i = 0; i < numMsgIds; i++) {
-					receiptMessageIds[i] = new MessageId(data, groupHeaderLength + 2 + i * ProtocolDefines.MESSAGE_ID_LEN);
-				}
-
-				receiptmsg.setReceiptMessageIds(receiptMessageIds);
-				msg = receiptmsg;
-
+                message = GroupDeliveryReceiptMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
@@ -932,100 +805,59 @@ public class MessageCoder {
 
 				TypingIndicatorMessage typingmsg = new TypingIndicatorMessage();
 				typingmsg.setTyping((data[1] & 0xFF) > 0);
-				msg = typingmsg;
+				message = typingmsg;
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_CONTACT_SET_PHOTO: {
-				if (realDataLength != (1 + ProtocolDefines.BLOB_ID_LEN + 4 + ProtocolDefines.BLOB_KEY_LEN)) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for contact set photo message");
-				}
-
-				SetProfilePictureMessage setProfilePictureMessage = new SetProfilePictureMessage();
-				setProfilePictureMessage.setFromIdentity(fromIdentity);
-
-				int i = 1;
-				byte[] blobId = new byte[ProtocolDefines.BLOB_ID_LEN];
-				System.arraycopy(data, i, blobId, 0, ProtocolDefines.BLOB_ID_LEN);
-				i += ProtocolDefines.BLOB_ID_LEN;
-				setProfilePictureMessage.setBlobId(blobId);
-				setProfilePictureMessage.setSize(EndianUtils.readSwappedInteger(data, i));
-				i += 4;
-				byte[] blobKey = new byte[ProtocolDefines.BLOB_KEY_LEN];
-				System.arraycopy(data, i, blobKey, 0, ProtocolDefines.BLOB_KEY_LEN);
-				setProfilePictureMessage.setEncryptionKey(blobKey);
-				msg = setProfilePictureMessage;
-
+                message = SetProfilePictureMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_CONTACT_DELETE_PHOTO: {
-				if (realDataLength != 1) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for contact delete photo message");
-				}
-				msg = new DeleteProfilePictureMessage();
-
+                message = DeleteProfilePictureMessage.fromByteArray(data, 1, realDataLength -1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_CONTACT_REQUEST_PHOTO: {
-				if (realDataLength != 1) {
-					throw new BadMessageException("Bad length (" + realDataLength + ") for contact request photo message");
-				}
-				msg = new ContactRequestProfilePictureMessage();
-
+                message = ContactRequestProfilePictureMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_OFFER: {
-				final VoipCallOfferData offerData = VoipCallOfferData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallOfferMessage().setData(offerData);
+				message = VoipCallOfferMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_ANSWER: {
-				final VoipCallAnswerData answerData = VoipCallAnswerData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallAnswerMessage().setData(answerData);
+				message = VoipCallAnswerMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_ICE_CANDIDATES: {
-				final VoipICECandidatesData candidatesData = VoipICECandidatesData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipICECandidatesMessage().setData(candidatesData);
+				message = VoipICECandidatesMessage.fromByteArray(data, 1, realDataLength -1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_HANGUP: {
-				final VoipCallHangupData hangupData = VoipCallHangupData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallHangupMessage().setData(hangupData);
+				message = VoipCallHangupMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_VOIP_CALL_RINGING: {
-				final VoipCallRingingData ringingData = VoipCallRingingData.parse(
-					new String(data, 1, realDataLength - 1, UTF_8)
-				);
-				msg = new VoipCallRingingMessage().setData(ringingData);
+				message = VoipCallRingingMessage.fromByteArray(data, 1, realDataLength - 1);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_FS_ENVELOPE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final ForwardSecurityData forwardSecurityData = ForwardSecurityData.fromProtobuf(protobufPayload);
-				msg = new ForwardSecurityEnvelopeMessage(forwardSecurityData);
+				message = new ForwardSecurityEnvelopeMessage(forwardSecurityData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_EMPTY: {
-				msg = new EmptyMessage();
+				message = new EmptyMessage();
 				break;
 			}
 
@@ -1042,21 +874,21 @@ public class MessageCoder {
 				} catch (JSONException e) {
 					throw new BadMessageException(e.getMessage());
 				}
-				msg = new WebSessionResumeMessage(webSessionResumeData);
+				message = new WebSessionResumeMessage(webSessionResumeData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_EDIT_MESSAGE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final EditMessageData editMessageData = EditMessageData.fromProtobuf(protobufPayload);
-				msg = new EditMessage(editMessageData);
+				message = new EditMessage(editMessageData);
 				break;
 			}
 
 			case ProtocolDefines.MSGTYPE_DELETE_MESSAGE: {
 				final byte[] protobufPayload = Arrays.copyOfRange(data, 1, realDataLength);
 				final DeleteMessageData deleteMessageData = DeleteMessageData.fromProtobuf(protobufPayload);
-				msg = new DeleteMessage(deleteMessageData);
+				message = new DeleteMessage(deleteMessageData);
 				break;
 			}
 
@@ -1074,7 +906,7 @@ public class MessageCoder {
 				editMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
 				editMessage.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
 
-				msg = editMessage;
+				message = editMessage;
 
 				break;
 			}
@@ -1093,7 +925,7 @@ public class MessageCoder {
 				deleteMessage.setGroupCreator(new String(data, 1, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
 				deleteMessage.setApiGroupId(new GroupId(data, 1 + ProtocolDefines.IDENTITY_LEN));
 
-				msg = deleteMessage;
+				message = deleteMessage;
 
 				break;
 			}
@@ -1102,6 +934,6 @@ public class MessageCoder {
 				throw new BadMessageException("Unsupported message type " + type);
 		}
 
-		return msg;
+		return message;
 	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt
deleted file mode 100644
index c66bf3b9..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessor.kt
+++ /dev/null
@@ -1,1204 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.fs
-
-import ch.threema.base.ThreemaException
-import ch.threema.base.crypto.NonceFactory
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.fs.DHSession
-import ch.threema.domain.fs.DHSession.RejectMessageError
-import ch.threema.domain.fs.DHSessionId
-import ch.threema.domain.fs.KDFRatchet.RatchetRotationException
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.coders.MessageCoder
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.BadMessageException
-import ch.threema.domain.protocol.csp.messages.EmptyMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityData
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataAccept
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataInit
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataReject
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataTerminate
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode
-import ch.threema.domain.stores.ContactStore
-import ch.threema.domain.stores.DHSessionStoreException
-import ch.threema.domain.stores.DHSessionStoreInterface
-import ch.threema.domain.stores.IdentityStoreInterface
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.toCspMessage
-import ch.threema.domain.taskmanager.waitForServerAck
-import ch.threema.protobuf.Common.GroupIdentity
-import ch.threema.protobuf.csp.e2e.fs.Encapsulated.DHType
-import ch.threema.protobuf.csp.e2e.fs.Reject
-import ch.threema.protobuf.csp.e2e.fs.Terminate
-import ch.threema.protobuf.csp.e2e.fs.Terminate.Cause
-import com.neilalexander.jnacl.NaCl
-import kotlinx.coroutines.runBlocking
-import java.io.ByteArrayOutputStream
-import java.io.IOException
-import java.util.Date
-
-private val logger = LoggingUtil.getThreemaLogger("ForwardSecurityMessageProcessor")
-
-class ForwardSecurityMessageProcessor(
-    private val dhSessionStoreInterface: DHSessionStoreInterface,
-    private val contactStore: ContactStore,
-    private val identityStoreInterface: IdentityStoreInterface,
-    private val nonceFactory: NonceFactory,
-    private val statusListener: ForwardSecurityStatusListener,
-) {
-
-    init {
-        dhSessionStoreInterface.setDHSessionStoreErrorHandler { peerIdentity, sessionId, handle ->
-            // Try to send a terminate to the peer contact
-            val contact = contactStore.getContactForIdentity(peerIdentity)
-            if (contact != null) {
-                runBlocking {
-                    sendTerminateAndDeleteSession(contact, sessionId, Cause.RESET, handle)
-                }
-            } else {
-                logger.error("Cannot send terminate to unknown contact where DH session is invalid")
-            }
-            // Show a status message to the user
-            if (contact != null) {
-                statusListener.postIllegalSessionState(sessionId, contact)
-            }
-        }
-    }
-
-    private var isFsEnabled = true
-
-    /**
-     * Set whether forward security is enabled.
-     *
-     * If disabled calls to [makeMessage] will throw an exception and received fs messages will be
-     * answered with a [Terminate].
-     *
-     * TODO(ANDR-2519): Remove when md allows fs
-     */
-    fun setForwardSecurityEnabled(fsEnabled: Boolean) {
-        this.isFsEnabled = fsEnabled
-    }
-
-    fun isForwardSecurityEnabled() = isFsEnabled
-
-    /**
-     * Check whether a forward security message from the given sender can be processed. If forward
-     * security is disabled because of md, this method sends a terminate to the contact and returns
-     * false.
-     *
-     * @param sender        the sender of the received message
-     * @param sessionId     the session id of the received message
-     * @param sendTerminate true if a terminate should be sent
-     * @param handle        the task handle to allow sending a terminate
-     * @return true if forward security is enabled, false otherwise
-     */
-    suspend fun canForwardSecurityMessageBeProcessed(
-        sender: Contact,
-        sessionId: DHSessionId,
-        sendTerminate: Boolean,
-        handle: ActiveTaskCodec,
-    ): Boolean {
-        if (!isFsEnabled) {
-            if (sendTerminate) {
-                sendTerminateAndDeleteSession(sender, sessionId, Cause.DISABLED_BY_LOCAL, handle)
-            }
-            return false
-        }
-
-        return true
-    }
-
-    /**
-     * Encapsulate the message for sending it with forward security. This method returns a
-     * [ForwardSecurityEncryptionResult] that contains a list of all message that should be sent out
-     * and the forward security mode of the given message. The list of messages may contain an init
-     * or an empty forward security message. The given inner message is always part of the returned
-     * list - either encapsulated or in its original form if it cannot be encapsulated in the
-     * existing session.
-     *
-     * Note that this result must be used to commit the forward security session after all messages
-     * of this result have been acknowledged by the server. To commit the forward security session
-     * use [commitSessionState].
-     *
-     * @param contact      the recipient identity
-     * @param innerMessage the inner message that may get encapsulated
-     * @param handle       the task codec that is only used to communicate an illegal state of a
-     *                     session to the chat partner
-     * @return a [ForwardSecurityEncryptionResult] that contains the encapsulated message
-     */
-    @Throws(ThreemaException::class)
-    fun makeMessage(
-        contact: Contact,
-        innerMessage: AbstractMessage,
-        handle: ActiveTaskCodec,
-    ): ForwardSecurityEncryptionResult {
-        // TODO(ANDR-2519): Remove when md allows fs
-        if (!isFsEnabled) {
-            throw IllegalStateException("Sending messages with fs is not supported locally")
-        }
-
-        var initMessage: ForwardSecurityEnvelopeMessage? = null
-
-        // Check if we already have a session with this contact
-        var session = dhSessionStoreInterface.getBestDHSession(
-            identityStoreInterface.identity,
-            contact.identity,
-            handle
-        )
-        var isExistingSession = true
-        if (session == null) {
-            // Establish a new DH session
-            session = DHSession(contact, identityStoreInterface)
-            // Set last outgoing message timestamp to now, as we will just send a message (init) in
-            // this session.
-            session.lastOutgoingMessageTimestamp = Date().time
-            // Do not yet save the session. In case the send task fails and is restarted, the init
-            // would not be sent if the session would already exist. Therefore, a new session should
-            // be created again.
-            logger.debug(
-                "Starting new DH session ID {} with {}",
-                session.id,
-                contact.identity
-            )
-            statusListener.newSessionInitiated(session, contact)
-            isExistingSession = false
-
-            // Create init message
-            val init = ForwardSecurityDataInit(
-                session.id,
-                DHSession.SUPPORTED_VERSION_RANGE,
-                session.myEphemeralPublicKey
-            )
-            initMessage = ForwardSecurityEnvelopeMessage(init, true)
-            initMessage.toIdentity = contact.identity
-
-            // Check that the message type is supported in the new session
-            val requiredVersion = innerMessage.minimumRequiredForwardSecurityVersion
-            if (requiredVersion == null || requiredVersion.number > DHSession.SUPPORTED_VERSION_MIN.number) {
-                logger.info(
-                    "As the session has just been created (with min version {}), we cannot send the message {} with forward security (required version {})",
-                    session.outgoingAppliedVersion,
-                    innerMessage.messageId,
-                    requiredVersion
-                )
-
-                // If the session has been newly created, add the inner message un-encapsulated
-                return ForwardSecurityEncryptionResult(
-                    initMessage,
-                    innerMessage,
-                    session
-                )
-            }
-        }
-
-        // Warn if we're trying to send something in an illegal state
-        if (session.state == DHSession.State.R20) {
-            logger.error("Encapsulating a message in R20 state is illegal")
-        }
-
-        // Check that the message type is supported in the current session
-        val appliedVersion = session.outgoingAppliedVersion
-        val requiredVersion = innerMessage.minimumRequiredForwardSecurityVersion
-        return if (requiredVersion == null || requiredVersion.number > appliedVersion.number) {
-            logger.info(
-                "The session's outgoing applied version ({}) is too low to send the message {} (that requires version {}) with forward security",
-                session.outgoingAppliedVersion,
-                innerMessage.messageId,
-                requiredVersion
-            )
-            val dayInMs = 1000L * 60 * 60 * 24
-            val now = Date().time
-            val lastOutgoingMessageTimestamp = session.lastOutgoingMessageTimestamp
-            var emptyMessage: ForwardSecurityEnvelopeMessage? = null
-            if (now - lastOutgoingMessageTimestamp >= dayInMs) {
-                logger.info(
-                    "Empty message to enforce fs session freshness required (last outgoing message {})",
-                    lastOutgoingMessageTimestamp
-                )
-                val innerEmptyMessage = EmptyMessage()
-                innerEmptyMessage.toIdentity = contact.identity
-                emptyMessage = encapsulateMessage(session, innerEmptyMessage, isExistingSession)
-                // Update the session, but do not yet persist this change. It must only be persisted
-                // after the outgoing messages have been acknowledged by the server.
-                session.lastOutgoingMessageTimestamp = now
-            }
-            ForwardSecurityEncryptionResult(
-                emptyMessage,
-                innerMessage,
-                session
-            )
-        } else {
-            // Update the session, but do not yet persist this change. It must only be persisted
-            // after the outgoing messages have been acknowledged by the server.
-            session.lastOutgoingMessageTimestamp = Date().time
-            ForwardSecurityEncryptionResult(
-                initMessage,
-                encapsulateMessage(session, innerMessage, isExistingSession),
-                session
-            )
-        }
-    }
-
-    /**
-     * Commit the session state after the encrypted forward security message has been successfully
-     * sent with the result obtained from {@link #makeMessage(Contact, AbstractMessage, ActiveTaskCodec)}.
-     *
-     * @param result the encryption result that was generated when encrypting the messages
-     */
-    fun commitSessionState(result: ForwardSecurityEncryptionResult) {
-        try {
-            dhSessionStoreInterface.storeDHSession(result.updatedSessionState)
-        } catch (e: DHSessionStoreException) {
-            logger.error("Could not store updated session state", e)
-        }
-    }
-
-    /**
-     * Refresh the session with the given contact. Note that this method must only be called if fs
-     * is enabled.
-     *
-     * @param contact the contact whose session should be refreshed
-     */
-    @Throws(
-        DHSessionStoreException::class,
-        ForwardSecurityData.InvalidEphemeralPublicKeyException::class
-    )
-    suspend fun runFsRefreshSteps(contact: Contact, handle: ActiveTaskCodec) {
-        val session = dhSessionStoreInterface.getBestDHSession(
-            identityStoreInterface.identity,
-            contact.identity,
-            handle
-        )
-        if (session == null) {
-            createAndSendNewSession(contact, handle)
-        } else {
-            // In case of an existing session, we create an encapsulated empty message and send it
-            createAndSendEmptyMessage(session, contact, handle)
-
-            // We update the session's timestamp and persist it. Note that at this point the server
-            // ack must have been received.
-            session.lastOutgoingMessageTimestamp = Date().time
-            dhSessionStoreInterface.storeDHSession(session)
-        }
-    }
-
-    fun warnIfMessageWithoutForwardSecurityReceived(
-        message: AbstractMessage,
-        handle: ActiveTaskCodec,
-    ) {
-        val contact = contactStore.getContactForIdentity(message.fromIdentity) ?: return
-        val bestSession = try {
-            dhSessionStoreInterface.getBestDHSession(
-                identityStoreInterface.identity,
-                message.fromIdentity,
-                handle
-            )
-        } catch (e: DHSessionStoreException) {
-            logger.error("Could not get best session", e)
-            return
-        }
-
-        if (bestSession != null) {
-            val minimumVersion = message.minimumRequiredForwardSecurityVersion
-            if (minimumVersion != null
-                && minimumVersion.number <= bestSession.minimumIncomingAppliedVersion.number
-            ) {
-                // TODO(ANDR-2452): Remove this feature mask update when enough clients have updated
-                // Check whether this contact still supports forward security when receiving a
-                // message without forward security.
-                if (statusListener.hasForwardSecuritySupport(contact)) {
-                    statusListener.updateFeatureMask(contact)
-                }
-
-                // Warn only if the contact still has forward security support, otherwise a status
-                // message that the contact has downgraded is shown to the user
-                if (statusListener.hasForwardSecuritySupport(contact)) {
-                    statusListener.messageWithoutFSReceived(contact, bestSession, message)
-                }
-            }
-        }
-    }
-
-    /**
-     * Turn and commit the peer ratchet. Call this method after an incoming message has been
-     * processed completely.
-     *
-     * @param peerRatchetIdentifier the information needed to identify the corresponding ratchet
-     */
-    @Throws(DHSessionStoreException::class)
-    fun commitPeerRatchet(peerRatchetIdentifier: PeerRatchetIdentifier, handle: ActiveTaskCodec) {
-        val sessionId = peerRatchetIdentifier.sessionId
-        val peerIdentity = peerRatchetIdentifier.peerIdentity
-        val dhType = peerRatchetIdentifier.dhType
-
-        val session = dhSessionStoreInterface.getDHSession(
-            identityStoreInterface.identity,
-            peerIdentity,
-            sessionId,
-            handle
-        )
-        if (session == null) {
-            logger.warn(
-                "Could not find session {}. Ratchet of type {} can not be turned for the last received message from {}",
-                sessionId,
-                dhType,
-                peerIdentity
-            )
-            return
-        }
-
-        val ratchet = when (dhType) {
-            DHType.TWODH -> session.peerRatchet2DH
-            DHType.FOURDH -> session.peerRatchet4DH
-            else -> null
-        }
-        if (ratchet == null) {
-            logger.warn(
-                "Ratchet of type {} is null in session {} with contact {}",
-                dhType,
-                sessionId,
-                peerIdentity
-            )
-            return
-        }
-
-        ratchet.turn()
-        dhSessionStoreInterface.storeDHSession(session)
-    }
-
-    @Throws(ThreemaException::class, BadMessageException::class)
-    suspend fun processInit(
-        contact: Contact,
-        init: ForwardSecurityDataInit,
-        handle: ActiveTaskCodec,
-    ) {
-        // Is there already a session with this ID?
-        if (dhSessionStoreInterface.getDHSession(
-                identityStoreInterface.identity,
-                contact.identity,
-                init.sessionId,
-                handle
-            ) != null
-        ) {
-            // Silently discard init message for existing session
-            logger.warn("Received init message for existing session")
-            return
-        }
-
-        // The initiator will only send an Init if it does not have an existing session. This means
-        // that any 4DH sessions that we have stored for this contact are obsolete and should be deleted.
-        // We will keep 2DH sessions (which will have been initiated by us), as otherwise messages may
-        // be lost during Init race conditions.
-        val existingSessionPreempted: Boolean = dhSessionStoreInterface.deleteAllSessionsExcept(
-            identityStoreInterface.identity,
-            contact.identity,
-            init.sessionId,
-            true
-        ) > 0
-
-        // TODO(ANDR-2452): Remove this check when enough clients have updated
-        if (!statusListener.hasForwardSecuritySupport(contact)) {
-            statusListener.updateFeatureMask(contact)
-        }
-
-        if (statusListener.hasForwardSecuritySupport(contact)) {
-            // Only create a new session from the init if the contact supports forward security
-            val session = DHSession(
-                init.sessionId,
-                init.versionRange,
-                init.ephemeralPublicKey,
-                contact,
-                identityStoreInterface
-            )
-
-            // Save the current timestamp to the session as we will send an accept in this session
-            session.lastOutgoingMessageTimestamp = Date().time
-            logger.debug(
-                "Responding to new DH session ID {} request from {}",
-                session.id,
-                contact.identity
-            )
-
-            // Send an accept
-            val accept = ForwardSecurityDataAccept(
-                init.sessionId,
-                DHSession.SUPPORTED_VERSION_RANGE,
-                session.myEphemeralPublicKey
-            )
-
-            // Send the accept to the contact. Note that if the accept has been sent, but the server
-            // ack got lost or the app is killed at this moment, the session won't be persisted.
-            // Therefore another key will be generated the next time the init is processed. The
-            // contact will discard the second accept and therefore stick to the old keys. The next
-            // message exchange will result in a session reset due to failing decryption (different
-            // keys).
-            sendControlMessageToContact(contact, accept, handle)
-
-            // Store the session
-            dhSessionStoreInterface.storeDHSession(session)
-
-            // Create status message of new session
-            statusListener.responderSessionEstablished(session, contact, existingSessionPreempted)
-        } else {
-            // We may still have a FS session to report that was terminated
-            if (existingSessionPreempted) {
-                statusListener.sessionTerminated(null, contact, false, false)
-            }
-
-            // If the contact does not have the feature mask set correctly, we assume that the
-            // `Init` is stale, then silently terminate this session.
-            sendTerminateAndDeleteSession(contact, init.sessionId, Cause.DISABLED_BY_REMOTE, handle)
-
-            // The feature mask update subroutine should have already detected the downgrade and
-            // removed any existing FS sessions. But we'll do it here again anyways for good
-            // measures and because the remote may be dishonest about its feature capabilities.
-            clearAndTerminateAllSessions(contact, Cause.DISABLED_BY_REMOTE, handle)
-        }
-    }
-
-    @Throws(ThreemaException::class, BadMessageException::class)
-    suspend fun processAccept(
-        contact: Contact,
-        accept: ForwardSecurityDataAccept,
-        handle: ActiveTaskCodec,
-    ) {
-        val session = dhSessionStoreInterface.getDHSession(
-            identityStoreInterface.identity,
-            contact.identity,
-            accept.sessionId,
-            handle
-        )
-        if (session == null) {
-            // Session not found, probably lost local data or old accept
-            logger.warn(
-                "No DH session found for accepted session ID {} from {}",
-                accept.sessionId,
-                contact.identity
-            )
-
-            // Send "terminate" message for this session ID
-            sendTerminateAndDeleteSession(contact, accept.sessionId, Cause.UNKNOWN_SESSION, handle)
-            statusListener.sessionNotFound(accept.sessionId, contact)
-            return
-        }
-
-        session.processAccept(
-            accept.versionRange,
-            accept.ephemeralPublicKey,
-            contact,
-            identityStoreInterface
-        )
-        dhSessionStoreInterface.storeDHSession(session)
-        logger.info(
-            "Established 4DH session {} with {}",
-            session,
-            contact.identity
-        )
-        statusListener.initiatorSessionEstablished(session, contact)
-    }
-
-    @Throws(DHSessionStoreException::class)
-    fun processReject(
-        contact: Contact,
-        reject: ForwardSecurityDataReject,
-        handle: ActiveTaskCodec,
-    ) {
-        logger.warn(
-            "Received reject for DH session ID {} from {}, cause: {}",
-            reject.sessionId,
-            contact.identity,
-            reject.cause
-        )
-        val session = dhSessionStoreInterface.getDHSession(
-            identityStoreInterface.identity,
-            contact.identity,
-            reject.sessionId,
-            handle
-        )
-        if (session != null) {
-            // Discard session
-            dhSessionStoreInterface.deleteDHSession(
-                identityStoreInterface.identity,
-                contact.identity,
-                reject.sessionId
-            )
-        } else {
-            // Session not found, probably lost local data or old reject
-            logger.info(
-                "No DH session found for rejected session ID {} from {}",
-                reject.sessionId,
-                contact.identity
-            )
-        }
-
-        // Refresh feature mask now, in case contact downgraded to a build without PFS
-        statusListener.updateFeatureMask(contact)
-
-        statusListener.rejectReceived(
-            reject,
-            contact,
-            session,
-            statusListener.hasForwardSecuritySupport(contact)
-        )
-    }
-
-    @Throws(DHSessionStoreException::class)
-    fun processTerminate(contact: Contact, message: ForwardSecurityDataTerminate) {
-        logger.debug(
-            "Terminating DH session ID {} with {}, cause: {}",
-            message.sessionId,
-            contact.identity,
-            message.cause
-        )
-        val sessionDeleted = dhSessionStoreInterface.deleteDHSession(
-            identityStoreInterface.identity,
-            contact.identity,
-            message.sessionId
-        )
-
-        // Refresh feature mask now, in case contact downgraded to a build without PFS
-        statusListener.updateFeatureMask(contact)
-
-        statusListener.sessionTerminated(
-            message.sessionId,
-            contact,
-            !sessionDeleted,
-            statusListener.hasForwardSecuritySupport(contact)
-        )
-    }
-
-    @Throws(ThreemaException::class, BadMessageException::class)
-    suspend fun processMessage(
-        contact: Contact,
-        envelopeMessage: ForwardSecurityEnvelopeMessage,
-        handle: ActiveTaskCodec,
-    ): ForwardSecurityDecryptionResult {
-        val message = envelopeMessage.data as ForwardSecurityDataMessage
-
-        val session = dhSessionStoreInterface.getDHSession(
-            identityStoreInterface.identity,
-            contact.identity,
-            message.sessionId,
-            handle
-        )
-        if (session == null) {
-            // Session not found, probably lost local data or old message
-            logger.warn(
-                "No DH session found for message {} in session ID {} from {}",
-                envelopeMessage.messageId,
-                message.sessionId,
-                contact.identity
-            )
-            sendReject(
-                contact,
-                message.sessionId,
-                envelopeMessage,
-                Reject.Cause.UNKNOWN_SESSION,
-                handle
-            )
-            statusListener.sessionForMessageNotFound(
-                message.sessionId,
-                envelopeMessage.messageId,
-                contact
-            )
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        // Validate offered and applied version
-        val processedVersions = try {
-            session.processIncomingMessageVersion(message)
-        } catch (e: RejectMessageError) {
-            // Message rejected by session validator, `Reject` and terminate the session
-            logger.warn(
-                "Rejecting message in session {} with {}, cause: {}",
-                session,
-                contact.identity,
-                e.message
-            )
-            sendReject(contact, session.id, envelopeMessage, Reject.Cause.STATE_MISMATCH, handle)
-            dhSessionStoreInterface.deleteDHSession(
-                identityStoreInterface.identity,
-                contact.identity,
-                session.id
-            )
-            // TODO(SE-354): Should we supply an error cause for the UI here? Otherwise this looks as if the remote willingly terminated.
-            statusListener.sessionTerminated(message.sessionId, contact, false, true)
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        // Obtain appropriate ratchet and turn to match the message's counter value
-        val (ratchet, mode) = when (message.type) {
-            DHType.TWODH -> session.peerRatchet2DH to ForwardSecurityMode.TWODH
-
-            DHType.FOURDH -> session.peerRatchet4DH to ForwardSecurityMode.FOURDH
-
-            else -> null to ForwardSecurityMode.NONE
-        }
-
-        if (ratchet == null) {
-            // This can happen if the Accept message from our peer has been lost. In that case
-            // they will think they are in 4DH mode, but we are still in 2DH. `Reject` and
-            // terminate the session.
-            logger.warn(
-                "Rejecting message in session {} with {}, cause: DH type mismatch (mode={})",
-                session,
-                contact.identity,
-                mode
-            )
-            sendReject(
-                contact,
-                message.sessionId,
-                envelopeMessage,
-                Reject.Cause.STATE_MISMATCH,
-                handle
-            )
-            dhSessionStoreInterface.deleteDHSession(
-                identityStoreInterface.identity,
-                contact.identity,
-                session.id
-            )
-            // TODO(SE-354): Should we supply an error cause for the UI here? Otherwise this looks as if the remote willingly terminated.
-            statusListener.sessionTerminated(message.sessionId, contact, false, true)
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        // We should already be at the correct ratchet count since we increment it after
-        // processing a message. If we have missed any messages, we will need to increment further.
-        try {
-            val numTurns = ratchet.turnUntil(message.counter)
-            if (numTurns > 0) {
-                statusListener.messagesSkipped(message.sessionId, contact, numTurns)
-            }
-        } catch (e: RatchetRotationException) {
-            statusListener.messageOutOfOrder(message.sessionId, contact, envelopeMessage.messageId)
-            throw BadMessageException("Out of order FS message, cannot decrypt")
-        }
-
-        // A new key is used for each message, so the nonce can be zero
-        val nonce = ByteArray(NaCl.NONCEBYTES)
-        val plaintext = NaCl.symmetricDecryptData(message.message, ratchet.currentEncryptionKey, nonce)
-        if (plaintext == null) {
-            logger.warn(
-                "Rejecting message in session {} with {}, cause: Message decryption failed (message-id={})",
-                session,
-                contact.identity,
-                envelopeMessage.messageId
-            )
-            sendReject(
-                contact,
-                message.sessionId,
-                envelopeMessage,
-                Reject.Cause.STATE_MISMATCH,
-                handle
-            )
-            dhSessionStoreInterface.deleteDHSession(
-                identityStoreInterface.identity,
-                contact.identity,
-                session.id
-            )
-            // TODO(SE-354): Should we supply an error cause for the UI here? Otherwise this looks as if the remote willingly terminated.
-            statusListener.sessionTerminated(message.sessionId, contact, false, true)
-            return ForwardSecurityDecryptionResult.NONE
-        }
-
-        logger.debug(
-            "Decapsulated message from {} (message-id={}, mode={}, session={}, offered-version={}, applied-version={})",
-            contact.identity,
-            envelopeMessage.messageId,
-            mode,
-            session,
-            processedVersions.offeredVersion,
-            processedVersions.appliedVersion
-        )
-
-        // Commit the updated version
-        val updatedVersionsSnapshot = session.commitVersions(processedVersions)
-        if (updatedVersionsSnapshot != null) {
-            statusListener.versionsUpdated(session, updatedVersionsSnapshot, contact)
-        }
-
-        if (mode == ForwardSecurityMode.FOURDH) {
-            // If this was a 4DH message, then we should erase the 2DH peer ratchet, as we shall not
-            // receive (or send) any further 2DH messages in this session. Note that this is also
-            // necessary to determine the correct session state.
-            if (session.peerRatchet2DH != null) {
-                session.discardPeerRatchet2DH()
-            }
-
-            // If this message was sent in what we also consider to be the "best" session (lowest ID),
-            // then we can delete any other sessions.
-            val bestSession = dhSessionStoreInterface.getBestDHSession(
-                identityStoreInterface.identity,
-                contact.identity,
-                handle
-            )
-            if (bestSession != null && bestSession.id == session.id) {
-                dhSessionStoreInterface.deleteAllSessionsExcept(
-                    identityStoreInterface.identity,
-                    contact.identity,
-                    session.id,
-                    false
-                )
-            }
-
-            // If this was the first 4DH message in this session, inform the user (only required in
-            // version 1.0)
-            if (ratchet.counter == 2L) {
-                statusListener.first4DhMessageReceived(session, contact)
-            }
-
-            // If the commonly supported (local) version is different, then we should send back an
-            // empty message
-            if (updatedVersionsSnapshot != null
-                && updatedVersionsSnapshot.before.local.number < updatedVersionsSnapshot.after.local.number
-            ) {
-                createAndSendEmptyMessage(session, contact, handle)
-            }
-        }
-
-        // Save session, as ratchets and negotiated version may have changed. Note that the peer
-        // ratchet is not yet turned at this point. This is required for being able to reprocess the
-        // last message when processing it is aborted.
-        dhSessionStoreInterface.storeDHSession(session)
-
-        // Collect the information needed to identify the used ratchet
-        val ratchetIdentifier = PeerRatchetIdentifier(session.id, contact.identity, message.type)
-
-        // Decode inner message
-        val innerMsg = try {
-            MessageCoder(contactStore, identityStoreInterface)
-                .decodeEncapsulated(plaintext, envelopeMessage, processedVersions.appliedVersion)
-                .also { it.forwardSecurityMode = mode }
-        } catch (e: BadMessageException) {
-            logger.warn("Inner message is invalid", e)
-            null
-        }
-
-        // Pass the inner message and the ratchet information to the message processor
-        return ForwardSecurityDecryptionResult(innerMsg, ratchetIdentifier)
-    }
-
-    /**
-     * Create a new session and send the corresponding init directly to the contact. Note that this
-     * method only creates a new session if there exists no session with this contact.
-     */
-    private suspend fun createAndSendNewSession(contact: Contact, handle: ActiveTaskCodec) {
-        val existingSession = dhSessionStoreInterface.getBestDHSession(
-            identityStoreInterface.identity,
-            contact.identity,
-            handle
-        )
-        if (existingSession != null) {
-            logger.warn("No session is created as there is already an existing session")
-            return
-        }
-
-        // When there is no existing session, we create a new session
-        val session = DHSession(contact, identityStoreInterface)
-        // Set last outgoing message timestamp
-        session.lastOutgoingMessageTimestamp = Date().time
-        // Do not yet save the session. In case the send task fails and is restarted, the init
-        // would not be sent if the session would already exist. Therefore, a new session should
-        // be created again.
-        logger.debug("Starting new DH session ID {} with {}", session.id, contact.identity)
-        statusListener.newSessionInitiated(session, contact)
-
-        // Create and send init message
-        val init = ForwardSecurityDataInit(
-            session.id,
-            DHSession.SUPPORTED_VERSION_RANGE,
-            session.myEphemeralPublicKey
-        )
-        val message = ForwardSecurityEnvelopeMessage(init, true)
-        message.toIdentity = contact.identity
-
-        handle.write(
-            message.toCspMessage(
-                identityStoreInterface, contactStore, nonceFactory, nonceFactory.next(false)
-            )
-        )
-
-        handle.waitForServerAck(message.messageId, message.toIdentity)
-
-        // As soon as the server ack has been received, we store the session locally.
-        dhSessionStoreInterface.storeDHSession(session)
-    }
-
-    private suspend fun createAndSendEmptyMessage(
-        session: DHSession,
-        contact: Contact,
-        handle: ActiveTaskCodec,
-    ) {
-        val emptyMessage = EmptyMessage()
-        emptyMessage.toIdentity = contact.identity
-        val fsMessage = encapsulateMessage(session, emptyMessage, true)
-        logger.info(
-            "Sending empty message {} to refresh session version to {}",
-            emptyMessage.messageId,
-            emptyMessage.toIdentity
-        )
-        handle.write(
-            fsMessage.toCspMessage(
-                identityStoreInterface,
-                contactStore,
-                nonceFactory,
-                nonceFactory.next(false)
-            )
-        )
-        handle.waitForServerAck(fsMessage.messageId, fsMessage.toIdentity)
-    }
-
-    @Throws(ThreemaException::class)
-    private fun encapsulateMessage(
-        session: DHSession,
-        message: AbstractMessage,
-        persistSession: Boolean,
-    ): ForwardSecurityEnvelopeMessage {
-        // Obtain encryption key from ratchet
-        var ratchet = session.myRatchet4DH
-        var dhType: DHType = DHType.FOURDH
-        if (ratchet == null) {
-            // 2DH mode
-            ratchet = session.myRatchet2DH
-            dhType = DHType.TWODH
-            if (ratchet == null) {
-                throw BadDHStateException(
-                    "No DH mode negotiated in session ${session.id} with ${session.peerIdentity}"
-                )
-            }
-        }
-        val currentKey = ratchet.currentEncryptionKey
-        val counter = ratchet.counter
-        ratchet.turn()
-
-        // Save session, as ratchet has turned. Note that this should only be done for existing
-        // sessions to prevent reusing the same key and nonce with a potentially different
-        // plaintext. For new sessions, we do not save the session, as in case we are re-encrypting,
-        // we would create a new session anyways.
-        if (persistSession) {
-            dhSessionStoreInterface.storeDHSession(session)
-        }
-
-        // Symmetrically encrypt message (type byte + body)
-        val bos = ByteArrayOutputStream()
-        bos.write(message.type)
-        try {
-            bos.write(message.body)
-        } catch (e: IOException) {
-            // Should never happen
-            throw RuntimeException(e)
-        }
-        val plaintext = bos.toByteArray()
-        // A new key is used for each message, so the nonce can be zero
-        val nonce = ByteArray(NaCl.NONCEBYTES)
-        val ciphertext = NaCl.symmetricEncryptData(plaintext, currentKey, nonce)
-
-        val groupIdentity = when (message) {
-            is AbstractGroupMessage ->
-                GroupIdentity.newBuilder()
-                    .setCreatorIdentity(message.groupCreator)
-                    .setGroupId(message.apiGroupId.toLong())
-                    .build()
-
-            else -> null
-        }
-        val dataMessage = ForwardSecurityDataMessage(
-            session.id,
-            (dhType),
-            counter,
-            session.outgoingOfferedVersion.number,
-            session.outgoingAppliedVersion.number,
-            groupIdentity,
-            ciphertext
-        )
-        val mode: ForwardSecurityMode = getForwardSecurityMode(dataMessage.type)
-        return ForwardSecurityEnvelopeMessage(dataMessage, message, mode)
-    }
-
-    @Throws(BadDHStateException::class)
-    private fun getForwardSecurityMode(dhType: DHType): ForwardSecurityMode {
-        return when (dhType) {
-            DHType.TWODH -> ForwardSecurityMode.TWODH
-            DHType.FOURDH -> ForwardSecurityMode.FOURDH
-            else -> {
-                logger.error("Invalid forward security mode")
-                throw BadDHStateException(
-                    String.format(
-                        "Invalid forward security type %d",
-                        dhType.number
-                    )
-                )
-            }
-        }
-    }
-
-    private suspend fun sendReject(
-        contact: Contact,
-        sessionId: DHSessionId,
-        rejectedMessage: ForwardSecurityEnvelopeMessage,
-        cause: Reject.Cause,
-        handle: ActiveTaskCodec,
-    ) {
-        val groupIdentity = when (val data = rejectedMessage.data) {
-            is ForwardSecurityDataMessage -> data.groupIdentity
-            else -> null
-        }
-
-        val reject =
-            ForwardSecurityDataReject(sessionId, rejectedMessage.messageId, groupIdentity, cause)
-        sendControlMessageToContact(contact, reject, handle)
-    }
-
-    /**
-     * The options when terminating a session.
-     */
-    private enum class TerminateOptions {
-        /**
-         * Remove the session after sending the terminate message. Note that in this case no new
-         * session is created - independent of the cause.
-         */
-        REMOVE,
-
-        /**
-         * Remove the session after sending the terminate message and additionally initiate a new
-         * session with the contact, if the cause is one of the following:
-         * - [Cause.UNKNOWN_SESSION]
-         * - [Cause.RESET]
-         */
-        RENEW,
-    }
-
-    private suspend fun sendTerminateAndDeleteSession(
-        contact: Contact,
-        sessionId: DHSessionId,
-        cause: Cause,
-        handle: ActiveTaskCodec,
-        options: TerminateOptions = TerminateOptions.RENEW,
-    ) {
-        val terminate = ForwardSecurityDataTerminate(sessionId, cause)
-        sendControlMessageToContact(contact, terminate, handle)
-
-        // Try to delete the dh session
-        try {
-            dhSessionStoreInterface.deleteDHSession(
-                identityStoreInterface.identity,
-                contact.identity,
-                sessionId
-            )
-        } catch (e: DHSessionStoreException) {
-            logger.error("Unable to delete DH session", e)
-        }
-
-        if (options == TerminateOptions.RENEW
-            && cause == Cause.UNKNOWN_SESSION || cause == Cause.RESET
-        ) {
-            createAndSendNewSession(contact, handle)
-        }
-    }
-
-    private suspend fun sendControlMessageToContact(
-        contact: Contact,
-        data: ForwardSecurityData,
-        handle: ActiveTaskCodec,
-    ) {
-        val message = ForwardSecurityEnvelopeMessage(data, true)
-        message.toIdentity = contact.identity
-        logger.info(
-            "Sending fs control message {} to contact {}",
-            message.messageId,
-            contact.identity
-        )
-
-        // Note that the nonce may be saved when it is sent (depending on message type)
-        val nonce = nonceFactory.next(false)
-        handle.write(
-            message.toCspMessage(
-                identityStoreInterface,
-                contactStore,
-                nonceFactory,
-                nonce
-            )
-        )
-        handle.waitForServerAck(message.messageId, message.toIdentity)
-    }
-
-    /**
-     * Clear all sessions with the peer contact and send a terminate message for each of those. Note
-     * that depending on the cause, a new session may be initiated afterwards.
-     *
-     * @param contact the peer contact
-     */
-    suspend fun clearAndTerminateAllSessions(
-        contact: Contact,
-        cause: Cause,
-        handle: ActiveTaskCodec,
-    ) {
-        try {
-            val myIdentity = identityStoreInterface.identity
-            val peerIdentity = contact.identity
-            val sessions = dhSessionStoreInterface.getAllDHSessions(myIdentity, peerIdentity, handle)
-
-            // Terminate and remove all sessions without renewing them except the last
-            sessions.dropLast(1).forEach {
-                sendTerminateAndDeleteSession(
-                    contact,
-                    it.id,
-                    cause,
-                    handle,
-                    TerminateOptions.REMOVE,
-                )
-            }
-
-            // Terminate and renew the last remaining session
-            sessions.lastOrNull()?.let {
-                sendTerminateAndDeleteSession(
-                    contact,
-                    it.id,
-                    cause,
-                    handle,
-                    TerminateOptions.RENEW,
-                )
-            }
-
-            if (sessions.isNotEmpty()) {
-                statusListener.allSessionsTerminated(contact, cause)
-            }
-        } catch (e: DHSessionStoreException) {
-            logger.error("Could not delete DH sessions", e)
-        }
-    }
-
-    /**
-     * Terminate all invalid sessions. If an invalid session has been removed and there is no
-     * session left afterwards, a new session will be initiated.
-     */
-    @Throws(DHSessionStoreException::class)
-    suspend fun terminateAllInvalidSessions(contact: Contact, handle: ActiveTaskCodec) {
-        val invalidSessions = dhSessionStoreInterface.getAllDHSessions(
-            identityStoreInterface.identity,
-            contact.identity,
-            handle
-        ).mapNotNull {
-            val state = try {
-                it.state
-            } catch (e: DHSession.IllegalDHSessionStateException) {
-                return@mapNotNull it
-            }
-
-            if (state == DHSession.State.RL44 && it.current4DHVersions == null) {
-                it
-            } else {
-                null
-            }
-        }
-
-        invalidSessions.forEach {
-            sendTerminateAndDeleteSession(contact, it.id, Cause.RESET, handle)
-        }
-    }
-
-}
-
-/**
- * Contains the information about the session and ratchet that was used to decrypt a message.
- */
-class PeerRatchetIdentifier(
-    /**
-     * The session id of the dh session.
-     */
-    val sessionId: DHSessionId,
-    /**
-     * The peer identity of the session.
-     */
-    val peerIdentity: String,
-    /**
-     * The dh type of the received message.
-     */
-    val dhType: DHType,
-)
-
-/**
- * When decrypting a message, we get this decryption result. It contains the unencrypted message as
- * well as information about the forward security session. This information is used to finalize the
- * peer ratchet state after the message has been completely processed.
- */
-class ForwardSecurityDecryptionResult(
-    /**
-     * The unencrypted message. Null if it is a forward security control message or an invalid
-     * message that could not be decoded. Note that in the case of an invalid message, the
-     * [PeerRatchetIdentifier] is not null as the message has been decrypted and the
-     * ratchet has been turned.
-     */
-    val message: AbstractMessage?,
-    /**
-     * The information to identify the ratchet that was used to decrypt the message.
-     */
-    val peerRatchetIdentifier: PeerRatchetIdentifier?,
-) {
-    companion object {
-        @JvmStatic
-        val NONE = ForwardSecurityDecryptionResult(null, null)
-    }
-}
-
-/**
- * This is the result we get when encrypting a message with forward security. It contains a list
- * of messages that should be sent out in the same order. After a server acknowledge has been
- * received, this result should be used to commit the session. For more details see
- * [ForwardSecurityMessageProcessor.makeMessage] and
- * [ForwardSecurityMessageProcessor.commitSessionState].
- */
-class ForwardSecurityEncryptionResult(
-    preFSMessage: ForwardSecurityEnvelopeMessage?,
-    message: AbstractMessage,
-    /**
-     * This is the updated session state of the session in which the message(s) should be sent. This
-     * state must be committed once all the messages have been successfully acknowledged by the
-     * server.
-     */
-    internal val updatedSessionState: DHSession,
-) {
-    /**
-     * This contains the outgoing messages including the aimed message. These messages must be sent
-     * in the same order as in this list.
-     */
-    val outgoingMessages: List<AbstractMessage>
-
-    /**
-     * The forward security mode of the aimed message.
-     */
-    val forwardSecurityMode: ForwardSecurityMode
-
-    init {
-        outgoingMessages = listOfNotNull(preFSMessage, message)
-        forwardSecurityMode = message.forwardSecurityMode
-    }
-}
-
-
-class UnknownMessageTypeException(msg: String) : ThreemaException(msg)
-
-class BadDHStateException(msg: String) : ThreemaException(msg)
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java
index 81fc51fb..d0213401 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AbstractMessage.java
@@ -23,6 +23,7 @@ package ch.threema.domain.protocol.csp.messages;
 
 import java.util.Date;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
 import ch.threema.domain.models.MessageId;
@@ -30,6 +31,7 @@ import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.coders.MessageBox;
 import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityMode;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
 
 /**
  * Abstract base class for messages that can be sent via the Threema server interface,
@@ -68,10 +70,13 @@ public abstract class AbstractMessage implements MessageTypeProperties, MessageF
 	public abstract Version getMinimumRequiredForwardSecurityVersion();
 
 	/**
-	 * Return the body of this message in network format (i.e. formatted as a byte array).
+	 * Return the body of this message in network format (i.e. formatted as a byte array). Note that
+     * a valid message should not return null. If null is returned, this is an indication that the
+     * message hasn't been initialized properly.
 	 *
 	 * @return message body
 	 */
+    @Nullable
 	public abstract byte[] getBody() throws ThreemaException;
 
 	/* Getters/Setters */
@@ -164,4 +169,25 @@ public abstract class AbstractMessage implements MessageTypeProperties, MessageF
 	public void setForwardSecurityMode(ForwardSecurityMode forwardSecurityMode) {
 		this.forwardSecurityMode = forwardSecurityMode;
 	}
+
+	/**
+	 * Initialize common properties from a reflected incoming message.
+	 *
+	 * @param message the incoming MdD2D message
+	 */
+	protected void initializeCommonProperties(@NonNull MdD2D.IncomingMessage message) {
+		this.fromIdentity = message.getSenderIdentity();
+		this.messageId = new MessageId(message.getMessageId());
+		this.date = new Date(message.getCreatedAt());
+	}
+
+    /**
+     * Initialize common properties for an outgoing message.
+     *
+     * @param message the outgoing MdD2D message
+     */
+	protected void initializeCommonProperties(@NonNull MdD2D.OutgoingMessage message) {
+		this.messageId = new MessageId((message.getMessageId()));
+		this.date = new Date(message.getCreatedAt());
+	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java
deleted file mode 100644
index f9f4e136..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/AudioMessage.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.apache.commons.io.EndianUtils;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A message that has an audio recording (stored on the blob server) as its content.
- *
- * The contents are referenced by the {@code audioBlobId}, the {@code audioSize} in bytes, and the
- * {@code encryptionKey} to be used when decrypting the audio blob.
- *
- * @Deprecated Use FileMessage instead
- */
-@Deprecated
-public class AudioMessage extends AbstractMessage {
-	private int duration;
-	private byte[] audioBlobId;
-	private int audioSize;
-	private byte[] encryptionKey;
-
-	public AudioMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_AUDIO;
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public byte[] getBody() {
-		ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-		try {
-			EndianUtils.writeSwappedShort(bos, (short)duration);
-			bos.write(audioBlobId);
-			EndianUtils.writeSwappedInteger(bos, audioSize);
-			bos.write(encryptionKey);
-		} catch (IOException e) {
-			throw new RuntimeException(e);
-		}
-
-		return bos.toByteArray();
-	}
-
-	public int getDuration() {
-		return duration;
-	}
-
-	public void setDuration(int duration) {
-		this.duration = duration;
-	}
-
-	public byte[] getAudioBlobId() {
-		return audioBlobId;
-	}
-
-	public void setAudioBlobId(byte[] audioBlobId) {
-		this.audioBlobId = audioBlobId;
-	}
-
-	public int getAudioSize() {
-		return audioSize;
-	}
-
-	public void setAudioSize(int audioSize) {
-		this.audioSize = audioSize;
-	}
-
-	public byte[] getEncryptionKey() {
-		return encryptionKey;
-	}
-
-	public void setEncryptionKey(byte[] encryptionKey) {
-		this.encryptionKey = encryptionKey;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.java
deleted file mode 100644
index 37ceca73..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ContactRequestProfilePictureMessage.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class ContactRequestProfilePictureMessage extends AbstractMessage {
-
-	public ContactRequestProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_CONTACT_REQUEST_PHOTO;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return false;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		return new byte[0];
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt
deleted file mode 100644
index 83155a7c..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessage.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.protobuf.AbstractProtobufMessage
-import ch.threema.protobuf.csp.e2e.fs.Version
-
-class DeleteMessage(payloadData: DeleteMessageData) : AbstractProtobufMessage<DeleteMessageData>(
-    ProtocolDefines.MSGTYPE_DELETE_MESSAGE,
-    payloadData
-) {
-    companion object {
-        const val DELETE_MESSAGES_MAX_AGE: Long = 6L * 60L * 60L * 1000L
-    }
-
-    override fun getMinimumRequiredForwardSecurityVersion() = Version.V1_1
-
-    override fun allowUserProfileDistribution() = false
-
-    override fun exemptFromBlocking() = false
-
-    override fun createImplicitlyDirectContact() = false
-
-    override fun protectAgainstReplay() = true
-
-    override fun reflectIncoming() = true
-
-    override fun reflectOutgoing() = true
-
-    override fun sendAutomaticDeliveryReceipt() = false
-
-    override fun bumpLastUpdate() = false
-
-    override fun flagSendPush() = true
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessageData.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessageData.kt
deleted file mode 100644
index 253f1e9c..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteMessageData.kt
+++ /dev/null
@@ -1,67 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.messages.protobuf.ProtobufDataInterface
-import ch.threema.protobuf.csp.e2e.DeleteMessage
-import com.google.protobuf.InvalidProtocolBufferException
-import java.util.Objects
-
-class DeleteMessageData(
-    val messageId: Long
-) : ProtobufDataInterface<DeleteMessage> {
-
-    companion object {
-        @JvmStatic
-        fun fromProtobuf(rawProtobufMessage: ByteArray): DeleteMessageData {
-            try {
-                val protobufMessage = DeleteMessage.parseFrom(rawProtobufMessage)
-                return DeleteMessageData(
-                    protobufMessage.messageId
-                )
-            } catch (e: InvalidProtocolBufferException) {
-                throw BadMessageException("Invalid DeleteMessage protobuf data")
-            } catch (e: IllegalArgumentException) {
-                throw BadMessageException("Could not create DeleteMessage data", e)
-            }
-        }
-    }
-
-    override fun toProtobufMessage(): DeleteMessage {
-        return DeleteMessage.newBuilder()
-            .setMessageId(messageId)
-            .build()
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is DeleteMessageData) return false
-
-        if (messageId != other.messageId) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        return Objects.hash(messageId)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.java
deleted file mode 100644
index 9d75e8e5..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeleteProfilePictureMessage.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class DeleteProfilePictureMessage extends AbstractMessage {
-
-	public DeleteProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_CONTACT_DELETE_PHOTO;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		return new byte[0];
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java
index 046c131f..fb68edd9 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/DeliveryReceiptMessage.java
@@ -26,11 +26,13 @@ import org.slf4j.Logger;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
 
 /**
  * A message that confirms delivery of one or multiple other messages, listed with their
@@ -93,6 +95,11 @@ public class DeliveryReceiptMessage extends AbstractMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -104,6 +111,7 @@ public class DeliveryReceiptMessage extends AbstractMessage {
 	}
 
 	@Override
+    @NonNull
 	public byte[] getBody() {
 
 		ByteArrayOutputStream bos = new ByteArrayOutputStream();
@@ -136,4 +144,64 @@ public class DeliveryReceiptMessage extends AbstractMessage {
 	public void setReceiptMessageIds(MessageId[] receiptMessageIds) {
 		this.receiptMessageIds = receiptMessageIds;
 	}
+
+	@NonNull
+	public static DeliveryReceiptMessage fromReflected(@NonNull MdD2D.IncomingMessage message) throws BadMessageException {
+		DeliveryReceiptMessage deliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+		deliveryReceiptMessage.initializeCommonProperties(message);
+		return deliveryReceiptMessage;
+	}
+
+	@NonNull
+	public static DeliveryReceiptMessage fromReflected(@NonNull MdD2D.OutgoingMessage message) throws BadMessageException {
+		DeliveryReceiptMessage deliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+		deliveryReceiptMessage.initializeCommonProperties(message);
+		return deliveryReceiptMessage;
+	}
+
+	@NonNull
+	public static DeliveryReceiptMessage fromByteArray(@NonNull byte[] data) throws BadMessageException {
+		return fromByteArray(data, 0, data.length);
+	}
+
+	/**
+	 * Get the delivery receipt message from the given array.
+	 *
+	 * @param data   the data that represents the message
+	 * @param offset the offset where the data starts
+	 * @param length the length of the data (needed to ignore the padding)
+	 * @return the delivery receipt message
+	 * @throws BadMessageException if the length is invalid
+	 */
+	@NonNull
+	public static DeliveryReceiptMessage fromByteArray(@NonNull byte[] data, int offset, int length) throws BadMessageException {
+		if (data.length < offset + length) {
+			throw new BadMessageException("Invalid byte array length (" + data.length + ") for " +
+				"offset " + offset + " and length " + length);
+		}
+
+		int deliveryReceiptTypeLength = 1;
+		int minDataLength = ProtocolDefines.MESSAGE_ID_LEN + deliveryReceiptTypeLength;
+		int messageIdsLength = length - deliveryReceiptTypeLength;
+
+		if (length < minDataLength || (messageIdsLength % ProtocolDefines.MESSAGE_ID_LEN) != 0) {
+			throw new BadMessageException("Bad length (" + length + ") for delivery receipt");
+		}
+
+		DeliveryReceiptMessage deliveryReceiptMessage = new DeliveryReceiptMessage();
+		deliveryReceiptMessage.setReceiptType(data[offset] & 0xFF);
+
+		// The offset where the message ids start
+		int messageIdsOffset = deliveryReceiptTypeLength + offset;
+
+		int numMsgIds = (messageIdsLength / ProtocolDefines.MESSAGE_ID_LEN);
+		MessageId[] receiptMessageIds = new MessageId[numMsgIds];
+		for (int i = 0; i < numMsgIds; i++) {
+			receiptMessageIds[i] = new MessageId(data, messageIdsOffset + i * ProtocolDefines.MESSAGE_ID_LEN);
+		}
+
+		deliveryReceiptMessage.setReceiptMessageIds(receiptMessageIds);
+
+		return deliveryReceiptMessage;
+	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt
deleted file mode 100644
index 04e7f6f5..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessage.kt
+++ /dev/null
@@ -1,55 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.protobuf.AbstractProtobufMessage
-import ch.threema.protobuf.csp.e2e.fs.Version
-
-class EditMessage(payloadData: EditMessageData) : AbstractProtobufMessage<EditMessageData>(
-        ProtocolDefines.MSGTYPE_EDIT_MESSAGE,
-        payloadData
-) {
-    companion object {
-        const val EDIT_MESSAGES_MAX_AGE: Long = 6L * 60L * 60L * 1000L
-    }
-
-    override fun getMinimumRequiredForwardSecurityVersion() = Version.V1_1
-
-    override fun allowUserProfileDistribution() = false
-
-    override fun exemptFromBlocking() = false
-
-    override fun createImplicitlyDirectContact() = false
-
-    override fun protectAgainstReplay() = true
-
-    override fun reflectIncoming() = true
-
-    override fun reflectOutgoing() = true
-
-    override fun sendAutomaticDeliveryReceipt() = false
-
-    override fun bumpLastUpdate() = false
-
-    override fun flagSendPush() = true
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessageData.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessageData.kt
deleted file mode 100644
index 2026ef7b..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EditMessageData.kt
+++ /dev/null
@@ -1,71 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.messages.protobuf.ProtobufDataInterface
-import ch.threema.protobuf.csp.e2e.EditMessage
-import com.google.protobuf.InvalidProtocolBufferException
-import java.util.Objects
-
-class EditMessageData(
-        val messageId: Long,
-        val text: String
-) : ProtobufDataInterface<EditMessage> {
-
-    companion object {
-        @JvmStatic
-        fun fromProtobuf(rawProtobufMessage: ByteArray): EditMessageData {
-            try {
-                val protobufMessage = EditMessage.parseFrom(rawProtobufMessage)
-                return EditMessageData(
-                        protobufMessage.messageId,
-                        protobufMessage.text
-                )
-            } catch (e: InvalidProtocolBufferException) {
-                throw BadMessageException("Invalid EditMessage protobuf data")
-            } catch (e: IllegalArgumentException) {
-                throw BadMessageException("Could not create EditMessage data", e)
-            }
-        }
-    }
-
-    override fun toProtobufMessage(): EditMessage {
-        return EditMessage.newBuilder()
-                .setMessageId(messageId)
-                .setText(text)
-                .build()
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is EditMessageData) return false
-
-        if (messageId != other.messageId) return false
-        if (text != other.text) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        return Objects.hash(messageId, text)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt
deleted file mode 100644
index db4a02e8..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/EmptyMessage.kt
+++ /dev/null
@@ -1,54 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.protobuf.csp.e2e.fs.Version
-
-class EmptyMessage : AbstractMessage() {
-
-    override fun getType() = ProtocolDefines.MSGTYPE_EMPTY
-
-    // We do never send empty messages like regular messages. Therefore, the version here is not
-    // checked when sending an empty message. However, we set it to version 1.0, as we want to get
-    // warned if such a message is being received without forward security. This warning is only
-    // useful for finding bugs.
-    override fun getMinimumRequiredForwardSecurityVersion() = Version.V1_0
-
-    override fun allowUserProfileDistribution() = false
-
-    override fun exemptFromBlocking() = true
-
-    override fun createImplicitlyDirectContact() = false
-
-    override fun protectAgainstReplay() = true
-
-    override fun reflectIncoming() = false
-
-    override fun reflectOutgoing() = false
-
-    override fun sendAutomaticDeliveryReceipt() = false
-
-    override fun bumpLastUpdate() = false
-
-    override fun getBody() = ByteArray(0)
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java
index 1cf44c62..15eb797b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupAudioMessage.java
@@ -22,12 +22,14 @@
 package ch.threema.domain.protocol.csp.messages;
 
 import org.apache.commons.io.EndianUtils;
+import org.slf4j.Logger;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 
 import androidx.annotation.Nullable;
+import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 
@@ -42,7 +44,9 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
 @Deprecated
 public class GroupAudioMessage extends AbstractGroupMessage {
 
-	private int duration;
+    private final static Logger logger = LoggingUtil.getThreemaLogger("GroupAudioMessage");
+
+    private int duration;
 	private byte[] audioBlobId;
 	private int audioSize;
 	private byte[] encryptionKey;
@@ -97,6 +101,11 @@ public class GroupAudioMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -108,6 +117,7 @@ public class GroupAudioMessage extends AbstractGroupMessage {
 	}
 
 	@Override
+    @Nullable
 	public byte[] getBody() {
 		ByteArrayOutputStream bos = new ByteArrayOutputStream();
 
@@ -118,11 +128,11 @@ public class GroupAudioMessage extends AbstractGroupMessage {
 			bos.write(audioBlobId);
 			EndianUtils.writeSwappedInteger(bos, audioSize);
 			bos.write(encryptionKey);
+            return bos.toByteArray();
 		} catch (IOException e) {
-			throw new RuntimeException(e);
+            logger.error("Cannot create body of message", e);
+            return null;
 		}
-
-		return bos.toByteArray();
 	}
 
 	public int getDuration() {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt
deleted file mode 100644
index 623dc1c6..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteMessage.kt
+++ /dev/null
@@ -1,51 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.protobuf.AbstractProtobufGroupMessage
-import ch.threema.protobuf.csp.e2e.fs.Version
-
-class GroupDeleteMessage(payloadData: DeleteMessageData) : AbstractProtobufGroupMessage<DeleteMessageData>(
-    ProtocolDefines.MSGTYPE_GROUP_DELETE_MESSAGE,
-    payloadData
-) {
-    override fun getMinimumRequiredForwardSecurityVersion() = Version.V1_2
-
-    override fun allowUserProfileDistribution() = false
-
-    override fun exemptFromBlocking() = false
-
-    override fun createImplicitlyDirectContact() = false
-
-    override fun protectAgainstReplay() = true
-
-    override fun reflectIncoming() = true
-
-    override fun reflectOutgoing() = true
-
-    override fun sendAutomaticDeliveryReceipt() = false
-
-    override fun bumpLastUpdate() = false
-
-    override fun flagSendPush() = true
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java
deleted file mode 100644
index 63c61f19..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessage.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * This message is sent by a group creator to the group members to request the group picture to be removed.
- */
-public class GroupDeleteProfilePictureMessage extends AbstractGroupMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupDeletePhotoMessage");
-
-	public GroupDeleteProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_DELETE_PHOTO;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			bos.write(getApiGroupId().getGroupId());
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java
index ab2f8d7b..b5b87ac1 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupDeliveryReceiptMessage.java
@@ -26,11 +26,14 @@ import org.slf4j.Logger;
 import java.io.ByteArrayOutputStream;
 import java.nio.charset.StandardCharsets;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
 
 /**
  * A message that confirms delivery of one or multiple other messages, listed with their
@@ -39,102 +42,172 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
  */
 public class GroupDeliveryReceiptMessage extends AbstractGroupMessage {
 
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupDeliveryReceiptMessage");
-
-	private int receiptType;
-	private MessageId[] receiptMessageIds;
-
-	public GroupDeliveryReceiptMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_DELIVERY_RECEIPT;
-	}
-
-	private boolean isReaction() {
-		return DeliveryReceiptUtils.isReaction(this.receiptType);
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return this.isReaction();
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return isReaction();
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		ByteArrayOutputStream bos = new ByteArrayOutputStream();
-		try {
-			bos.write(getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(getApiGroupId().getGroupId());
-			bos.write((byte) receiptType);
-
-			for (MessageId messageId : receiptMessageIds) {
-				bos.write(messageId.getMessageId());
-			}
-			return bos.toByteArray();
-
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-		}
-		return null;
-	}
-
-	public int getReceiptType() {
-		return receiptType;
-	}
-
-	public void setReceiptType(int receiptType) {
-		this.receiptType = receiptType;
-	}
-
-	public MessageId[] getReceiptMessageIds() {
-		return receiptMessageIds;
-	}
-
-	public void setReceiptMessageIds(MessageId[] receiptMessageIds) {
-		this.receiptMessageIds = receiptMessageIds;
-	}
+    private static final Logger logger = LoggingUtil.getThreemaLogger("GroupDeliveryReceiptMessage");
+
+    private int receiptType;
+    private MessageId[] receiptMessageIds;
+
+    public GroupDeliveryReceiptMessage() {
+        super();
+    }
+
+    @Override
+    public int getType() {
+        return ProtocolDefines.MSGTYPE_GROUP_DELIVERY_RECEIPT;
+    }
+
+    private boolean isReaction() {
+        return DeliveryReceiptUtils.isReaction(this.receiptType);
+    }
+
+    @Override
+    @Nullable
+    public Version getMinimumRequiredForwardSecurityVersion() {
+        return Version.V1_2;
+    }
+
+    @Override
+    public boolean allowUserProfileDistribution() {
+        return this.isReaction();
+    }
+
+    @Override
+    public boolean exemptFromBlocking() {
+        return false;
+    }
+
+    @Override
+    public boolean createImplicitlyDirectContact() {
+        return false;
+    }
+
+    @Override
+    public boolean protectAgainstReplay() {
+        return isReaction();
+    }
+
+    @Override
+    public boolean reflectIncoming() {
+        return true;
+    }
+
+    @Override
+    public boolean reflectOutgoing() {
+        return true;
+    }
+
+    @Override
+    public boolean reflectSentUpdate() {
+        return false;
+    }
+
+    @Override
+    public boolean sendAutomaticDeliveryReceipt() {
+        return false;
+    }
+
+    @Override
+    public boolean bumpLastUpdate() {
+        return false;
+    }
+
+    @Override
+    @Nullable
+    public byte[] getBody() {
+        ByteArrayOutputStream bos = new ByteArrayOutputStream();
+        try {
+            bos.write(getGroupCreator().getBytes(StandardCharsets.US_ASCII));
+            bos.write(getApiGroupId().getGroupId());
+            bos.write((byte) receiptType);
+
+            for (MessageId messageId : receiptMessageIds) {
+                bos.write(messageId.getMessageId());
+            }
+            return bos.toByteArray();
+
+        } catch (Exception e) {
+            logger.error(e.getMessage());
+        }
+        return null;
+    }
+
+    public int getReceiptType() {
+        return receiptType;
+    }
+
+    public void setReceiptType(int receiptType) {
+        this.receiptType = receiptType;
+    }
+
+    public MessageId[] getReceiptMessageIds() {
+        return receiptMessageIds;
+    }
+
+    public void setReceiptMessageIds(MessageId[] receiptMessageIds) {
+        this.receiptMessageIds = receiptMessageIds;
+    }
+
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromReflected(@NonNull MdD2D.IncomingMessage message) throws BadMessageException {
+        GroupDeliveryReceiptMessage groupDeliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+        groupDeliveryReceiptMessage.initializeCommonProperties(message);
+        return groupDeliveryReceiptMessage;
+    }
+
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromReflected(@NonNull MdD2D.OutgoingMessage message) throws BadMessageException {
+        GroupDeliveryReceiptMessage groupDeliveryReceiptMessage = fromByteArray(message.getBody().toByteArray());
+        groupDeliveryReceiptMessage.initializeCommonProperties(message);
+        return groupDeliveryReceiptMessage;
+    }
+
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromByteArray(@NonNull byte[] data) throws BadMessageException {
+        return fromByteArray(data, 0, data.length);
+    }
+
+    /**
+     * Get the delivery receipt group message from the given array.
+     *
+     * @param data   the data that represents the group message
+     * @param offset the offset where the data starts
+     * @param length the length of the data (needed to ignore the padding)
+     * @return the GroupDeliveryReceiptMessage
+     * @throws BadMessageException if the length is invalid
+     */
+    @NonNull
+    public static GroupDeliveryReceiptMessage fromByteArray(@NonNull byte[] data, int offset, int length) throws BadMessageException {
+
+        if (data.length < offset + length) {
+            throw new BadMessageException("Invalid byte array length (" + data.length + ") for offset " + offset + " and length " + length);
+        }
+
+        final int receiptTypeByteLength = 1;
+        int groupHeaderLength = ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
+        if (
+            (length - groupHeaderLength) < (ProtocolDefines.MESSAGE_ID_LEN + receiptTypeByteLength) ||
+                ((length - groupHeaderLength - receiptTypeByteLength) % ProtocolDefines.MESSAGE_ID_LEN) != 0
+        ) {
+            throw new BadMessageException("Bad length (" + length + ") for group delivery receipt");
+        }
+
+        GroupDeliveryReceiptMessage groupDeliveryReceiptMessage = new GroupDeliveryReceiptMessage();
+        groupDeliveryReceiptMessage.setGroupCreator(
+            new String(data, offset, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+        );
+        groupDeliveryReceiptMessage.setApiGroupId(new GroupId(data, offset + ProtocolDefines.IDENTITY_LEN));
+        groupDeliveryReceiptMessage.setReceiptType(data[groupHeaderLength + offset] & 0xFF);
+
+        int messageIdsCount = ((length - groupHeaderLength - receiptTypeByteLength) / ProtocolDefines.MESSAGE_ID_LEN);
+        MessageId[] receiptMessageIds = new MessageId[messageIdsCount];
+        for (int i = 0; i < messageIdsCount; i++) {
+            receiptMessageIds[i] = new MessageId(
+                data,
+                groupHeaderLength + receiptTypeByteLength + offset + (i * ProtocolDefines.MESSAGE_ID_LEN)
+            );
+        }
+
+        groupDeliveryReceiptMessage.setReceiptMessageIds(receiptMessageIds);
+        return groupDeliveryReceiptMessage;
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt
deleted file mode 100644
index 670bab4f..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupEditMessage.kt
+++ /dev/null
@@ -1,51 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.messages.protobuf.AbstractProtobufGroupMessage
-import ch.threema.protobuf.csp.e2e.fs.Version
-
-class GroupEditMessage(payloadData: EditMessageData) : AbstractProtobufGroupMessage<EditMessageData>(
-        ProtocolDefines.MSGTYPE_GROUP_EDIT_MESSAGE,
-        payloadData
-) {
-    override fun getMinimumRequiredForwardSecurityVersion() = Version.V1_2
-
-    override fun allowUserProfileDistribution() = false
-
-    override fun exemptFromBlocking() = false
-
-    override fun createImplicitlyDirectContact() = false
-
-    override fun protectAgainstReplay() = true
-
-    override fun reflectIncoming() = true
-
-    override fun reflectOutgoing() = true
-
-    override fun sendAutomaticDeliveryReceipt() = false
-
-    override fun bumpLastUpdate() = false
-
-    override fun flagSendPush() = true
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java
index 4f57939b..19d32fc3 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupImageMessage.java
@@ -99,6 +99,11 @@ public class GroupImageMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java
index 03baaebb..c1abb63b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLeaveMessage.java
@@ -78,6 +78,11 @@ public class GroupLeaveMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java
index f0501e92..f70c4614 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupLocationMessage.java
@@ -97,6 +97,11 @@ public class GroupLocationMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java
deleted file mode 100644
index 63cf37d1..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupNameMessage.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A group message send by the group creator that causes the group to be renamed.
- */
-public class GroupNameMessage extends AbstractGroupMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupRenameMessage");
-
-	private String groupName;
-
-	public GroupNameMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_RENAME;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			bos.write(getApiGroupId().getGroupId());
-			bos.write(groupName.getBytes(StandardCharsets.UTF_8));
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	public String getGroupName() {
-		return groupName;
-	}
-
-	public void setGroupName(String groupName) {
-		this.groupName = groupName;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java
deleted file mode 100644
index 5724aef0..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetProfilePictureMessage.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.apache.commons.io.EndianUtils;
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A group message sent by the group creator that causes a new photo to be set for the group.
- */
-public class GroupSetProfilePictureMessage extends AbstractGroupMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupSetPhotoMessage");
-
-	private byte[] blobId;
-	private int size;
-	private byte[] encryptionKey;
-
-	public GroupSetProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_SET_PHOTO;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			bos.write(getApiGroupId().getGroupId());
-			bos.write(blobId);
-			EndianUtils.writeSwappedInteger(bos, size);
-			bos.write(encryptionKey);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	public byte[] getBlobId() {
-		return blobId;
-	}
-
-	public void setBlobId(byte[] blobId) {
-		this.blobId = blobId;
-	}
-
-	public int getSize() {
-		return size;
-	}
-
-	public void setSize(int size) {
-		this.size = size;
-	}
-
-	public byte[] getEncryptionKey() {
-		return encryptionKey;
-	}
-
-	public void setEncryptionKey(byte[] encryptionKey) {
-		this.encryptionKey = encryptionKey;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java
deleted file mode 100644
index 3359bdb3..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSetupMessage.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A group creation message.
- */
-public class GroupSetupMessage extends AbstractGroupMessage {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupCreateMessage");
-
-	private String[] members;
-
-	public GroupSetupMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_CREATE;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		// Note: lastUpdate should be triggered only for new groups. This logic is handled
-		//       in the corresponding tasks, so we can set the flag below to false.
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			bos.write(getApiGroupId().getGroupId());
-			for (String member : members)
-				bos.write(member.getBytes(StandardCharsets.US_ASCII));
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	public String[] getMembers() {
-		return members;
-	}
-
-	public void setMembers(String[] members) {
-		this.members = members;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java
deleted file mode 100644
index ee2408d0..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupSyncRequestMessage.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * Request current group information to be sent back.
- */
-public class GroupSyncRequestMessage extends AbstractGroupMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupSyncRequestMessage");
-
-	public GroupSyncRequestMessage() {
-		super();
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_REQUEST_SYNC;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			bos.write(getApiGroupId().getGroupId());
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java
index d5b5b87f..d0c9c2e3 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupTextMessage.java
@@ -26,10 +26,15 @@ import org.slf4j.Logger;
 import java.io.ByteArrayOutputStream;
 import java.nio.charset.StandardCharsets;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.utils.LoggingUtil;
+import ch.threema.domain.models.GroupId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
+import ch.threema.protobuf.d2d.MdD2D;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
 
 /**
  * A group message that has plain text as its contents.
@@ -90,6 +95,11 @@ public class GroupTextMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -121,4 +131,45 @@ public class GroupTextMessage extends AbstractGroupMessage {
 	public void setText(String text) {
 		this.text = text;
 	}
+
+	@NonNull
+	public static GroupTextMessage fromReflected(MdD2D.IncomingMessage message) throws BadMessageException {
+		GroupTextMessage textMessage = fromByteArray(message.getBody().toByteArray());
+		textMessage.initializeCommonProperties(message);
+		return textMessage;
+	}
+
+	@NonNull
+	public static GroupTextMessage fromByteArray(@NonNull byte[] data) throws BadMessageException {
+		return fromByteArray(data, 0, data.length);
+	}
+
+	/**
+	 * Get the group text message from the given array.
+	 *
+	 * @param data   the data that represents the message
+	 * @param offset the offset where the data starts
+	 * @param length the length of the data (needed to ignore the padding)
+	 * @return the group text message
+	 * @throws BadMessageException if the length is invalid
+	 */
+	@NonNull
+	public static GroupTextMessage fromByteArray(@NonNull byte[] data, int offset, int length) throws BadMessageException {
+		if (data.length < offset + length) {
+			throw new BadMessageException("Invalid byte array length (" + data.length + ") for " +
+				"offset " + offset + " and length " + length);
+		}
+
+		int minTextLength = 1;
+		int minByteArrayLength = minTextLength + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN;
+		if (length < minByteArrayLength) {
+			throw new BadMessageException("Bad length (" + length + ") for group text message");
+		}
+
+		GroupTextMessage groupTextMessage = new GroupTextMessage();
+		groupTextMessage.setGroupCreator(new String(data, offset, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII));
+		groupTextMessage.setApiGroupId(new GroupId(data, offset + ProtocolDefines.IDENTITY_LEN));
+		groupTextMessage.setText(new String(data, offset + ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN, length - ProtocolDefines.IDENTITY_LEN - ProtocolDefines.GROUP_ID_LEN, UTF_8));
+		return groupTextMessage;
+	}
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java
index db4ea35f..091f269b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/GroupVideoMessage.java
@@ -22,12 +22,14 @@
 package ch.threema.domain.protocol.csp.messages;
 
 import org.apache.commons.io.EndianUtils;
+import org.slf4j.Logger;
 
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 
 import androidx.annotation.Nullable;
+import ch.threema.base.utils.LoggingUtil;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 
@@ -48,7 +50,9 @@ import ch.threema.protobuf.csp.e2e.fs.Version;
 @Deprecated
 public class GroupVideoMessage extends AbstractGroupMessage {
 
-	private int duration;
+    private final static Logger logger = LoggingUtil.getThreemaLogger("GroupVideoMessage");
+
+    private int duration;
 	private byte[] videoBlobId;
 	private int videoSize;
 	private byte[] thumbnailBlobId;
@@ -105,6 +109,11 @@ public class GroupVideoMessage extends AbstractGroupMessage {
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return true;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
@@ -128,11 +137,11 @@ public class GroupVideoMessage extends AbstractGroupMessage {
 			bos.write(thumbnailBlobId);
 			EndianUtils.writeSwappedInteger(bos, thumbnailSize);
 			bos.write(encryptionKey);
+            return bos.toByteArray();
 		} catch (IOException e) {
-			throw new RuntimeException(e);
+			logger.error("Cannot create body of message", e);
+            return null;
 		}
-
-		return bos.toByteArray();
 	}
 
 	public int getDuration() {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java
deleted file mode 100644
index ecf0dc27..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ImageMessage.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import com.neilalexander.jnacl.NaCl;
-
-import org.apache.commons.io.EndianUtils;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A message that has an image (stored on the blob server) as its content.
- *
- * The contents are referenced by the {@code blobId}, the file {@code size} in bytes,
- * and the nonce to be used when decrypting the image blob.
- *
- *  @Deprecated Use FileMessage instead
- */
-@Deprecated
-public class ImageMessage extends AbstractMessage {
-	private byte[] blobId;
-	private int size;
-	private byte[] nonce;
-
-	public ImageMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_IMAGE;
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public byte[] getBody() {
-		byte[] body = new byte[ProtocolDefines.BLOB_ID_LEN + 4 + NaCl.NONCEBYTES];
-
-		System.arraycopy(blobId, 0, body, 0, ProtocolDefines.BLOB_ID_LEN);
-		EndianUtils.writeSwappedInteger(body, ProtocolDefines.BLOB_ID_LEN, size);
-		System.arraycopy(nonce, 0, body, ProtocolDefines.BLOB_ID_LEN + 4, nonce.length);
-
-		return body;
-	}
-
-	public byte[] getBlobId() {
-		return blobId;
-	}
-
-	public void setBlobId(byte[] blobId) {
-		this.blobId = blobId;
-	}
-
-	public int getSize() {
-		return size;
-	}
-
-	public void setSize(int size) {
-		this.size = size;
-	}
-
-	public byte[] getNonce() {
-		return nonce;
-	}
-
-	public void setNonce(byte[] nonce) {
-		this.nonce = nonce;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java
deleted file mode 100644
index 46a25dab..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/LocationMessage.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import java.nio.charset.StandardCharsets;
-import java.util.Locale;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A message that has a GPS location with accuracy as its contents.
- *
- * Coordinates are in WGS 84, accuracy is in meters.
- */
-public class LocationMessage extends AbstractMessage {
-
-	private double latitude;
-	private double longitude;
-	private double accuracy;
-	private String poiName;
-	private String poiAddress;
-
-	public LocationMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_LOCATION;
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public byte[] getBody() {
-        String locStr = String.format(Locale.US, "%f,%f,%f", latitude, longitude, accuracy);
-        if (poiName != null)
-            locStr += "\n" + poiName;
-        if (poiAddress != null)
-            locStr += "\n" + poiAddress.replace("\n", "\\n");
-
-        return locStr.getBytes(StandardCharsets.UTF_8);
-    }
-
-	public double getLatitude() {
-		return latitude;
-	}
-
-	public void setLatitude(double latitude) {
-		this.latitude = latitude;
-	}
-
-	public double getLongitude() {
-		return longitude;
-	}
-
-	public void setLongitude(double longitude) {
-		this.longitude = longitude;
-	}
-
-	public double getAccuracy() {
-		return accuracy;
-	}
-
-	public void setAccuracy(double accuracy) {
-		this.accuracy = accuracy;
-	}
-
-	public String getPoiName() {
-		return poiName;
-	}
-
-	public void setPoiName(String poiName) {
-		this.poiName = poiName;
-	}
-
-	public String getPoiAddress() {
-		return poiAddress;
-	}
-
-	public void setPoiAddress(String poiAddress) {
-		this.poiAddress = poiAddress;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageFlags.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageFlags.java
deleted file mode 100644
index 024f3c0c..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageFlags.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-/**
- * This interface defines methods for all message flags.
- *
- * All methods have default implementations that disable all flags.
- */
-public interface MessageFlags {
-	/**
-	 * Flag 0x01: Send push notification
-	 * <p>
-	 * The server will send a push message to the receiver of the message.
-	 * Only use this for messages that require a notification. For example, do not
-	 * set this for delivery receipts.
-	 */
-	default boolean flagSendPush() {
-		return false;
-	}
-
-	/**
-	 * Flag 0x02: No server queuing
-	 * <p>
-	 * Use this for messages that can be discarded by the chat server in case the receiver
-	 * is not connected to the chat server, e.g. the typing indicator.
-	 */
-	default boolean flagNoServerQueuing() {
-		return false;
-	}
-
-	/**
-	 * Flag 0x04: No server acknowledgement
-	 * <p>
-	 * Use this for messages where reliable delivery and acknowledgement is not essential,
-	 * e.g. the typing indicator. Will not be acknowledged by the chat server when sending.
-	 * No acknowledgement should be sent by the receiver to the chat server.
-	 */
-	default boolean flagNoServerAck() {
-		return false;
-	}
-
-	/**
-	 * Flag 0x10: Group message marker (DEPRECATED)
-	 * <p>
-	 * Use this for all group messages. In iOS clients, this will be used for notifications
-	 * to reflect that a group message has been received in case no connection to the server
-	 * could be established.
-	 */
-	default boolean flagGroupMessage() {
-		return false;
-	}
-
-	/**
-	 * Flag 0x20: Short-lived server queuing
-	 * <p>
-	 * Messages with this flag will only be queued for 60 seconds.
-	 */
-	default boolean flagShortLivedServerQueuing() {
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java
deleted file mode 100644
index 72655ff2..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/MessageTypeProperties.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-/**
- * This interface defines methods for all per-message-type properties that the
- * chat server protocol defines.
- */
-public interface MessageTypeProperties {
-	/**
-	 * Return whether the user's profile information (nickname, picture etc.) is allowed to
-	 * be sent along with this message. This should be set to true for user-initiated messages only.
-	 */
-	boolean allowUserProfileDistribution();
-
-	/**
-	 * Return whether this message should be exempted from blocking.
-	 */
-	boolean exemptFromBlocking();
-
-	/**
-	 * Return whether this message should implicitly create a <b>direct</b> contact.
-	 */
-	boolean createImplicitlyDirectContact();
-
-	/**
-	 * Return whether the message should be protected against replay attacks. This is used in the
-	 * message processor to decide whether the nonce of the message should be stored or not.
-	 */
-	boolean protectAgainstReplay();
-
-	/**
-	 * Return whether this message should be reflected when incoming.
-	 */
-	boolean reflectIncoming();
-
-	/**
-	 * Return whether this message should be reflected when outgoing.
-	 */
-	boolean reflectOutgoing();
-
-	/**
-	 * Return whether an automatic delivery receipt should be send back when receiving a message of
-	 * this type. Note that sending automatic delivery receipts must be prevented for messages that
-	 * have flag 0x80 set.
-	 */
-	boolean sendAutomaticDeliveryReceipt();
-
-	/**
-	 * Return whether an incoming message should update the conversation timestamp. Note that this
-	 * is currently not called for all incoming messages.
-	 */
-	boolean bumpLastUpdate();
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.java
deleted file mode 100644
index 676ca39a..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/SetProfilePictureMessage.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.apache.commons.io.EndianUtils;
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A profile picture uploaded as a blob
- *
- * The contents are referenced by the {@code blobId}, the file {@code size} in bytes,
- * and the nonce to be used when decrypting the image blob.
- */
-public class SetProfilePictureMessage extends AbstractMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("ContactSetPhotoMessage");
-
-	private byte[] blobId;
-	private int size;
-	private byte[] encryptionKey;
-
-	public SetProfilePictureMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_CONTACT_SET_PHOTO;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			bos.write(blobId);
-			EndianUtils.writeSwappedInteger(bos, size);
-			bos.write(encryptionKey);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	public byte[] getBlobId() {
-		return blobId;
-	}
-
-	public void setBlobId(byte[] blobId) {
-		this.blobId = blobId;
-	}
-
-	public int getSize() {
-		return size;
-	}
-
-	public void setSize(int size) {
-		this.size = size;
-	}
-
-	public byte[] getEncryptionKey() {
-		return encryptionKey;
-	}
-
-	public void setEncryptionKey(byte[] encryptionKey) {
-		this.encryptionKey = encryptionKey;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java
deleted file mode 100644
index fbc4f778..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TextMessage.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import java.nio.charset.StandardCharsets;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A message that has plain text as its contents.
- */
-public class TextMessage extends AbstractMessage {
-	private String text;
-
-	public TextMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_TEXT;
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public byte[] getBody() {
-        return text.getBytes(StandardCharsets.UTF_8);
-    }
-
-	public String getText() {
-		return text;
-	}
-
-	public void setText(String text) {
-		this.text = text;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java
index b9f6d737..3e9e409b 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/TypingIndicatorMessage.java
@@ -78,6 +78,11 @@ public class TypingIndicatorMessage extends AbstractMessage {
 		return false;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java
deleted file mode 100644
index 4ccc32f9..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/VideoMessage.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.apache.commons.io.EndianUtils;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A message that has a video including thumbnail (stored on the blob server) as its content.
- *
- * The contents are referenced by the {@code videoBlobId}/{@code thumbnailBlobId},
- * the {@code videoSize}/{@code thumbnailSize} in bytes, and the {@code encryptionKey}
- * to be used when decrypting the video blob.
- *
- * The thumbnail uses the same key, the nonces are as follows:
- *
- * Video:     0x000000000000000000000000000000000000000000000001
- * Thumbnail: 0x000000000000000000000000000000000000000000000002
- *
- *  @Deprecated Use FileMessage instead
- */
-@Deprecated
-public class VideoMessage extends AbstractMessage {
-
-	private int duration;
-	private byte[] videoBlobId;
-	private int videoSize;
-	private byte[] thumbnailBlobId;
-	private int thumbnailSize;
-	private byte[] encryptionKey;
-
-	public VideoMessage() {
-		super();
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VIDEO;
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public byte[] getBody() {
-		ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-		try {
-			EndianUtils.writeSwappedShort(bos, (short)duration);
-			bos.write(videoBlobId);
-			EndianUtils.writeSwappedInteger(bos, videoSize);
-			bos.write(thumbnailBlobId);
-			EndianUtils.writeSwappedInteger(bos, thumbnailSize);
-			bos.write(encryptionKey);
-		} catch (IOException e) {
-			throw new RuntimeException(e);
-		}
-
-		return bos.toByteArray();
-	}
-
-	public int getDuration() {
-		return duration;
-	}
-
-	public void setDuration(int duration) {
-		this.duration = duration;
-	}
-
-	public byte[] getVideoBlobId() {
-		return videoBlobId;
-	}
-
-	public void setVideoBlobId(byte[] videoBlobId) {
-		this.videoBlobId = videoBlobId;
-	}
-
-	public int getVideoSize() {
-		return videoSize;
-	}
-
-	public void setVideoSize(int videoSize) {
-		this.videoSize = videoSize;
-	}
-
-	public byte[] getThumbnailBlobId() {
-		return thumbnailBlobId;
-	}
-
-	public void setThumbnailBlobId(byte[] thumbnailBlobId) {
-		this.thumbnailBlobId = thumbnailBlobId;
-	}
-
-	public int getThumbnailSize() {
-		return thumbnailSize;
-	}
-
-	public void setThumbnailSize(int thumbnailSize) {
-		this.thumbnailSize = thumbnailSize;
-	}
-
-	public byte[] getEncryptionKey() {
-		return encryptionKey;
-	}
-
-	public void setEncryptionKey(byte[] encryptionKey) {
-		this.encryptionKey = encryptionKey;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt
deleted file mode 100644
index 4b0d9df2..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/WebSessionResumeMessage.kt
+++ /dev/null
@@ -1,51 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages
-
-import ch.threema.domain.protocol.csp.ProtocolDefines
-
-class WebSessionResumeMessage(private val data: Map<String, String>) : AbstractMessage() {
-
-    override fun getType() = ProtocolDefines.MSGTYPE_WEB_SESSION_RESUME
-
-    override fun getMinimumRequiredForwardSecurityVersion() = null
-
-    override fun allowUserProfileDistribution() = false
-
-    override fun exemptFromBlocking() = true
-
-    override fun createImplicitlyDirectContact() = false
-
-    override fun protectAgainstReplay() = true
-
-    override fun reflectIncoming() = false
-
-    override fun reflectOutgoing() = false
-
-    override fun sendAutomaticDeliveryReceipt() = false
-
-    override fun bumpLastUpdate(): Boolean = false
-
-    override fun getBody() = ByteArray(0)
-
-    fun getData(): Map<String, String> = data
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotCreateInterface.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotCreateInterface.java
deleted file mode 100644
index acf66a04..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotCreateInterface.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-public interface BallotCreateInterface extends BallotMessageInterface  {
-	void setData(BallotData ballotData);
-	BallotData getData();
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java
index fc71d083..b0fb93e9 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotData.java
@@ -57,7 +57,6 @@ public class BallotData {
 			}
 			throw new IllegalArgumentException();
 		}
-
 	}
 
 	public enum AssessmentType {
@@ -228,7 +227,8 @@ public class BallotData {
 		return this.participants;
 	}
 
-	public static BallotData parse(String jsonObjectString) throws BadMessageException {
+	@NonNull
+    public static BallotData parse(String jsonObjectString) throws BadMessageException {
 		try {
 			JSONObject o = new JSONObject(jsonObjectString);
 
@@ -284,13 +284,12 @@ public class BallotData {
 
 			return ballotData;
 		}
-		catch (JSONException e) {
-			throw new BadMessageException("TM029");
+		catch (JSONException jsonException) {
+			throw new BadMessageException("TM029", jsonException);
 		}
-
 	}
 
-	public void write(ByteArrayOutputStream bos) throws Exception {
+	public void write(@NonNull ByteArrayOutputStream bos) throws Exception {
 		bos.write(this.generateString().getBytes(StandardCharsets.UTF_8));
 	}
 
@@ -316,8 +315,8 @@ public class BallotData {
 			}
 			o.put(KEY_PARTICIPANTS, p);
 		}
-		catch (Exception e) {
-			throw new BadMessageException("TM033");
+		catch (Exception jsonException) {
+			throw new BadMessageException("TM033", jsonException);
 		}
 
 		return o.toString();
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.java
deleted file mode 100644
index a30802f9..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotMessageInterface.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-public interface BallotMessageInterface {
-	void setBallotId(BallotId ballotId);
-	void setBallotCreator(String ballotCreator);
-
-	BallotId getBallotId();
-	String getBallotCreator();
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java
index 517182d9..462c72b2 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVote.java
@@ -21,7 +21,10 @@
 
 package ch.threema.domain.protocol.csp.messages.ballot;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 
@@ -30,63 +33,63 @@ import java.nio.charset.StandardCharsets;
 
 public class BallotVote {
 
-	private final static int POS_CHOICE_ID = 0;
-	private final static int POS_CHOICE_VALUE = 1;
-
-	private int id;
-	private int value;
-
-
-	public int getId() {
-		return id;
-	}
-
-	public void setId(int id) {
-		this.id = id;
-	}
-
-	public int getValue() {
-		return value;
-	}
-
-	public void setValue(int value) {
-		this.value = value;
-	}
-
-
-	public static BallotVote parse(JSONArray o) throws BadMessageException {
-		try {
-			if(o == null) {
-				throw new BadMessageException("TM036");
-			}
-
-			BallotVote ballotVote = new BallotVote();
-			ballotVote.id = o.getInt(POS_CHOICE_ID);
-			ballotVote.value = o.getInt(POS_CHOICE_VALUE);
-			return ballotVote;
-		}
-		catch (JSONException e) {
-			throw new BadMessageException("TM033");
-		}
-	}
-
-	public JSONArray getJsonArray() throws BadMessageException {
-		JSONArray o = new JSONArray();
-		try {
-			o.put(POS_CHOICE_ID, this.id);
-			o.put(POS_CHOICE_VALUE, this.value);
-		}
-		catch (Exception e) {
-			throw new BadMessageException("TM036");
-		}
-		return o;
-	}
-
-	public void write(ByteArrayOutputStream bos) throws Exception {
-		bos.write(this.generateString().getBytes(StandardCharsets.US_ASCII));
-	}
-
-	public String generateString() throws BadMessageException {
-		return this.getJsonArray().toString();
-	}
+    private final static int POS_CHOICE_ID = 0;
+    private final static int POS_CHOICE_VALUE = 1;
+
+    private int id;
+    private int value;
+
+    public BallotVote(int id, int value) {
+        this.id = id;
+        this.value = value;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public int getValue() {
+        return value;
+    }
+
+    public void setValue(int value) {
+        this.value = value;
+    }
+
+    @NonNull
+    public static BallotVote parse(@Nullable JSONArray jsonArray) throws BadMessageException {
+        try {
+            if (jsonArray == null) {
+                throw new BadMessageException("TM036");
+            }
+            int id = jsonArray.getInt(POS_CHOICE_ID);
+            int value = jsonArray.getInt(POS_CHOICE_VALUE);
+            return new BallotVote(id, value);
+        } catch (JSONException e) {
+            throw new BadMessageException("TM033", e);
+        }
+    }
+
+    public JSONArray getJsonArray() throws BadMessageException {
+        JSONArray jsonArray = new JSONArray();
+        try {
+            jsonArray.put(POS_CHOICE_ID, this.id);
+            jsonArray.put(POS_CHOICE_VALUE, this.value);
+        } catch (Exception e) {
+            throw new BadMessageException("TM036", e);
+        }
+        return jsonArray;
+    }
+
+    public void write(@NonNull ByteArrayOutputStream bos) throws Exception {
+        bos.write(this.generateString().getBytes(StandardCharsets.US_ASCII));
+    }
+
+    public String generateString() throws BadMessageException {
+        return this.getJsonArray().toString();
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.java
deleted file mode 100644
index 85e7d43f..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteInterface.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import java.util.Collection;
-import java.util.List;
-
-public interface BallotVoteInterface extends BallotMessageInterface  {
-	List<BallotVote> getBallotVotes();
-
-	void addVotes(Collection<BallotVote> votes);
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.java
deleted file mode 100644
index 88867ba0..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollSetupMessage.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A group ballot creation message.
- */
-public class GroupPollSetupMessage extends AbstractGroupMessage
-	implements BallotCreateInterface{
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupBallotCreateMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-	private BallotData ballotData;
-	// This is only used for debugging
-	private String rawBallotData;
-
-	public GroupPollSetupMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public void setData(BallotData ballotData) {
-		this.ballotData = ballotData;
-	}
-
-	@Override
-	public BallotData getData() {
-		return this.ballotData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getApiGroupId().getGroupId());
-			bos.write(this.getBallotId().getBallotId());
-			this.ballotData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_BALLOT_CREATE;
-	}
-
-	// This is only used for debugging
-	public void setRawBallotData(String rawBallotData) {
-		this.rawBallotData = rawBallotData;
-	}
-
-	// This is only used for debugging
-	public String getRawBallotData() {
-		return this.rawBallotData;
-	}
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.java
deleted file mode 100644
index 2d42afed..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/GroupPollVoteMessage.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
-import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A group ballot vote message.
- */
-public class GroupPollVoteMessage extends AbstractGroupMessage
-	implements BallotVoteInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupBallotVoteMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-
-	private final List<BallotVote> ballotVotes = new ArrayList<>();
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return true;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public List<BallotVote> getBallotVotes() {
-		return this.ballotVotes;
-	}
-
-	@Override
-	public void addVotes(Collection<BallotVote> votes) {
-		this.ballotVotes.addAll(votes);
-	}
-
-	public void parseVotes(String votes) throws BadMessageException{
-		try {
-			JSONArray array = new JSONArray(votes);
-			for(int n = 0; n < array.length(); n++) {
-				this.ballotVotes.add(BallotVote.parse(array.getJSONArray(n)));
-			}
-		} catch (JSONException e) {
-			throw new BadMessageException("TM035");
-		}
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getApiGroupId().getGroupId());
-			bos.write(this.getBallotCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getBallotId().getBallotId());
-
-			JSONArray jsonArray = new JSONArray();
-			for(BallotVote c: this.ballotVotes) {
-				jsonArray.put(c.getJsonArray());
-			}
-			bos.write(jsonArray.toString().getBytes(StandardCharsets.US_ASCII));
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_BALLOT_VOTE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.java
deleted file mode 100644
index a4f609dd..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollSetupMessage.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A ballot creation message.
- */
-public class PollSetupMessage extends AbstractMessage implements BallotCreateInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BallotCreateMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-	private BallotData ballotData;
-
-	public PollSetupMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public void setData(BallotData ballotData) {
-		this.ballotData = ballotData;
-	}
-
-	@Override
-	public BallotData getData() {
-		return this.ballotData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getBallotId().getBallotId());
-			this.ballotData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_BALLOT_CREATE;
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		sb.append(super.toString());
-		sb.append(": create message, description: ");
-		sb.append(this.ballotData.getDescription());
-
-		return sb.toString();
-	}
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.java
deleted file mode 100644
index f544ce8e..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/ballot/PollVoteMessage.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.ballot;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-/**
- * A ballot vote message.
- */
-public class PollVoteMessage extends AbstractMessage implements BallotVoteInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("BallotVoteMessage");
-
-	private BallotId ballotId;
-	private String ballotCreatorId;
-
-	private final List<BallotVote> ballotVotes = new ArrayList<>();
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-
-	@Override
-	public void setBallotId(BallotId ballotId) {
-		this.ballotId = ballotId;
-	}
-
-	@Override
-	public void setBallotCreator(String ballotCreator) {
-		this.ballotCreatorId = ballotCreator;
-	}
-
-	@Override
-	public BallotId getBallotId() {
-		return this.ballotId;
-	}
-
-	@Override
-	public String getBallotCreator() {
-		return this.ballotCreatorId;
-	}
-
-	@Override
-	public List<BallotVote> getBallotVotes() {
-		return this.ballotVotes;
-	}
-
-	@Override
-	public void addVotes(Collection<BallotVote> votes) {
-		this.ballotVotes.addAll(votes);
-	}
-
-	public void parseVotes(String votes) throws BadMessageException{
-		try {
-			JSONArray array = new JSONArray(votes);
-			for(int n = 0; n < array.length(); n++) {
-				this.ballotVotes.add(BallotVote.parse(array.getJSONArray(n)));
-			}
-		} catch (JSONException e) {
-			throw new BadMessageException("TM035");
-		}
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getBallotCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getBallotId().getBallotId());
-
-			JSONArray jsonArray = new JSONArray();
-			for(BallotVote c: this.ballotVotes) {
-				jsonArray.put(c.getJsonArray());
-			}
-			bos.write(jsonArray.toString().getBytes(StandardCharsets.US_ASCII));
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_BALLOT_VOTE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java
index c8488713..33e8d3b6 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileData.java
@@ -282,7 +282,7 @@ public class FileData {
 			}
 			return fileData;
 		} catch (JSONException e) {
-			throw new BadMessageException("TM037");
+			throw new BadMessageException("TM037", e);
 		}
 	}
 
@@ -320,7 +320,7 @@ public class FileData {
 			o.put(KEY_RENDERING_TYPE, this.renderingType);
 		}
 		catch (Exception e) {
-			throw new BadMessageException("TM037");
+			throw new BadMessageException("TM037", e);
 		}
 
 		return o.toString();
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.java
deleted file mode 100644
index 7cb891f7..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessage.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.file;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class FileMessage extends AbstractMessage implements FileMessageInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("FileMessage");
-
-	private FileData fileData;
-
-	public FileMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_0;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return true;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setData(FileData fileData) {
-		this.fileData = fileData;
-	}
-
-	@Override
-	public FileData getData() {
-		return this.fileData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.fileData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_FILE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.java
deleted file mode 100644
index 040cf900..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/FileMessageInterface.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.file;
-
-public interface FileMessageInterface  {
-	void setData(FileData ballotData);
-	FileData getData();
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.java
deleted file mode 100644
index 35e38758..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/file/GroupFileMessage.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.file;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-import java.nio.charset.StandardCharsets;
-
-import androidx.annotation.Nullable;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-import ch.threema.domain.protocol.csp.messages.AbstractGroupMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public class GroupFileMessage extends AbstractGroupMessage implements FileMessageInterface {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("GroupFileMessage");
-
-	private FileData fileData;
-
-	public GroupFileMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	@Nullable
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_2;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-
-	@Override
-	public void setData(FileData ballotData) {
-		this.fileData = ballotData;
-	}
-
-	@Override
-	public FileData getData() {
-		return this.fileData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-
-			//ballot stuff
-			bos.write(this.getGroupCreator().getBytes(StandardCharsets.US_ASCII));
-			bos.write(this.getApiGroupId().getGroupId());
-			this.fileData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_GROUP_FILE;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java
index 899e531b..7f2fe9ee 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityEnvelopeMessage.java
@@ -132,6 +132,14 @@ public class ForwardSecurityEnvelopeMessage extends AbstractProtobufMessage<Forw
 		return false;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		if (innerMessage == null) {
+			throw new IllegalStateException("Cannot check sent update reflection of incoming fs envelopes");
+		}
+		return innerMessage.reflectSentUpdate();
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		throw new IllegalStateException("Cannot check for sending automatic delivery receipt on fs envelopes");
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java
index 7e24b320..8d924306 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessage.java
@@ -68,6 +68,11 @@ public class GroupJoinRequestMessage extends AbstractProtobufMessage<GroupJoinRe
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java
index 1f79b333..2bf74e85 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessage.java
@@ -68,6 +68,11 @@ public class GroupJoinResponseMessage extends AbstractProtobufMessage<GroupJoinR
 		return true;
 	}
 
+	@Override
+	public boolean reflectSentUpdate() {
+		return false;
+	}
+
 	@Override
 	public boolean sendAutomaticDeliveryReceipt() {
 		return false;
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt
index a6674af3..cac085f1 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartData.kt
@@ -40,12 +40,12 @@ class GroupCallStartData(
             try {
                 val protobufMessage = GroupCallStart.parseFrom(rawProtobufMessage)
                 return GroupCallStartData(
-                        protobufMessage.protocolVersion.toUInt(),
-                        protobufMessage.gck.toByteArray(),
-                        protobufMessage.sfuBaseUrl
+                    protobufMessage.protocolVersion.toUInt(),
+                    protobufMessage.gck.toByteArray(),
+                    protobufMessage.sfuBaseUrl
                 )
             } catch (e: InvalidProtocolBufferException) {
-                throw BadMessageException("Invalid group call start protobuf data")
+                throw BadMessageException("Invalid group call start protobuf data", e)
             } catch (e: IllegalArgumentException) {
                 throw BadMessageException("Could not create group call start data", e)
             }
@@ -53,17 +53,17 @@ class GroupCallStartData(
     }
 
     init {
-    	if (gck.size != GCK_LENGTH) {
+        if (gck.size != GCK_LENGTH) {
             throw IllegalArgumentException("Invalid length of gck")
         }
     }
 
     override fun toProtobufMessage(): GroupCallStart {
         return GroupCallStart.newBuilder()
-                .setProtocolVersion(protocolVersion.toInt())
-                .setGck(ByteString.copyFrom(gck))
-                .setSfuBaseUrl(sfuBaseUrl)
-                .build()
+            .setProtocolVersion(protocolVersion.toInt())
+            .setGck(ByteString.copyFrom(gck))
+            .setSfuBaseUrl(sfuBaseUrl)
+            .build()
     }
 
     override fun equals(other: Any?): Boolean {
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt
index d19d0591..b94adf27 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/groupcall/GroupCallStartMessage.kt
@@ -21,13 +21,19 @@
 
 package ch.threema.domain.protocol.csp.messages.groupcall
 
+import ch.threema.domain.models.GroupId
 import ch.threema.domain.protocol.csp.ProtocolDefines
+import ch.threema.domain.protocol.csp.messages.BadMessageException
+import ch.threema.domain.protocol.csp.messages.groupcall.GroupCallStartData.Companion.fromProtobuf
 import ch.threema.domain.protocol.csp.messages.protobuf.AbstractProtobufGroupMessage
 import ch.threema.protobuf.csp.e2e.fs.Version
+import ch.threema.protobuf.d2d.MdD2D
+import java.nio.charset.StandardCharsets
+import java.util.Arrays
 
 class GroupCallStartMessage(payloadData: GroupCallStartData) : AbstractProtobufGroupMessage<GroupCallStartData>(
-        ProtocolDefines.MSGTYPE_GROUP_CALL_START,
-        payloadData
+    ProtocolDefines.MSGTYPE_GROUP_CALL_START,
+    payloadData
 ), GroupCallControlMessage {
     override fun flagSendPush() = true
 
@@ -45,7 +51,93 @@ class GroupCallStartMessage(payloadData: GroupCallStartData) : AbstractProtobufG
 
     override fun reflectOutgoing() = true
 
+    override fun reflectSentUpdate() = false
+
     override fun sendAutomaticDeliveryReceipt() = false
 
     override fun bumpLastUpdate(): Boolean = true
+
+    companion object {
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([fromIdentity], [messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the group-call-start message
+         *  @return Instance of [GroupCallStartMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.IncomingMessage): GroupCallStartMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val groupCallStartMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            groupCallStartMessage.initializeCommonProperties(message)
+            return groupCallStartMessage
+        }
+
+        /**
+         *  When the message bytes come from sync (reflected), they do not contain the one extra byte at the beginning.
+         *  So we set the offset in [fromByteArray] to zero.
+         *
+         *  In addition the common message model properties ([messageId] and [date]) get set.
+         *
+         *  @param message the MdD2D message representing the group-call-start message
+         *  @return Instance of [GroupCallStartMessage]
+         *  @see fromByteArray
+         */
+        @JvmStatic
+        fun fromReflected(message: MdD2D.OutgoingMessage, ownIdentity: String): GroupCallStartMessage {
+            val bodyBytes: ByteArray = message.body.toByteArray()
+            val groupCallStartMessage = fromByteArray(bodyBytes, 0, bodyBytes.size)
+            groupCallStartMessage.initializeCommonProperties(message)
+            groupCallStartMessage.fromIdentity = ownIdentity
+            return groupCallStartMessage
+        }
+
+        /**
+         * Build an instance of [GroupCallStartMessage] from the given [data] bytes. Note that
+         * the common message model properties ([fromIdentity], [messageId] and [date]) will **not** be set.
+         *
+         * The [data] byte array consists of:
+         *  - header field: group-creator (identity, length 8)
+         *  - header field: api-group-id (id, length 8)
+         *  - body protobuf bytes of [GroupCallStartData]
+         *
+         * @param data   the data that represents the group-call-start message
+         * @param offset the offset where the actual data starts (inclusive)
+         * @param length the length of the data (needed to ignore the padding)
+         * @return Instance of [GroupCallStartMessage]
+         * @throws BadMessageException if the length or the offset is invalid
+         * @see fromReflected
+         */
+        @JvmStatic
+        @Throws(BadMessageException::class)
+        fun fromByteArray(data: ByteArray, offset: Int, length: Int): GroupCallStartMessage {
+            if (length <= ProtocolDefines.IDENTITY_LEN + ProtocolDefines.GROUP_ID_LEN) {
+                throw BadMessageException("Bad length ($length) for text message")
+            } else if (offset < 0) {
+                throw BadMessageException("Bad offset ($offset) for text message")
+            } else if (data.size < length + offset) {
+                throw BadMessageException("Invalid byte array length (${data.size}) for offset $offset and length $length")
+            }
+
+            var positionIndex = offset
+
+            val groupCreator = String(data, positionIndex, ProtocolDefines.IDENTITY_LEN, StandardCharsets.US_ASCII)
+            positionIndex += ProtocolDefines.IDENTITY_LEN
+
+            val apiGroupId = GroupId(data, positionIndex)
+            positionIndex += ProtocolDefines.GROUP_ID_LEN
+
+            val protobufPayload = Arrays.copyOfRange(data, positionIndex, length + offset)
+            val groupCallStartData: GroupCallStartData = fromProtobuf(protobufPayload)
+
+            return GroupCallStartMessage(groupCallStartData).apply {
+                setGroupCreator(groupCreator)
+                setApiGroupId(apiGroupId)
+            }
+        }
+    }
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt
index 006bc871..d63b0b4d 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufGroupMessage.kt
@@ -31,12 +31,13 @@ private val logger = LoggingUtil.getThreemaLogger("AbstractProtobufGroupMessage"
 
 /**
  * @param type Protocol type of the message as defined in [ch.threema.domain.protocol.csp.ProtocolDefines]
- * @param protobufData Parsed protobuf data
+ * @param data Parsed protobuf data
  */
 abstract class AbstractProtobufGroupMessage<D : ProtobufDataInterface<*>?>(
     private val type: Int,
     val data: D
 ) : AbstractGroupMessage() {
+
     override fun getBody(): ByteArray? {
         return try {
             val bos = ByteArrayOutputStream()
@@ -46,11 +47,9 @@ abstract class AbstractProtobufGroupMessage<D : ProtobufDataInterface<*>?>(
             bos.toByteArray()
         } catch (e: Exception) {
             logger.error(e.message)
-            byteArrayOf()
+            null
         }
     }
 
-    override fun getType(): Int {
-        return type
-    }
+    override fun getType(): Int = type
 }
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.java
deleted file mode 100644
index 4739c987..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallAnswerMessage.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-public class VoipCallAnswerMessage extends VoipMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallAnswerMessage");
-
-	private VoipCallAnswerData callAnswerData;
-
-	public VoipCallAnswerMessage() {
-		super();
-	}
-
-	public VoipCallAnswerMessage setData(VoipCallAnswerData callAnswerData) {
-		this.callAnswerData = callAnswerData;
-		return this;
-	}
-
-	public VoipCallAnswerData getData() {
-		return this.callAnswerData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callAnswerData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_ANSWER;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		// True only if we're accepting the call
-		final VoipCallAnswerData answerData = this.callAnswerData;
-		if (answerData == null) {
-			return false;
-		}
-		final Byte action = answerData.getAction();
-		return action != null && action == VoipCallAnswerData.Action.ACCEPT;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java
index f9339adb..98b52634 100644
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java
+++ b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupData.java
@@ -38,7 +38,8 @@ public class VoipCallHangupData extends VoipCallData<VoipCallHangupData> {
 
 	//region Serialization
 
-	public static @NonNull VoipCallHangupData parse(@NonNull String jsonObjectString) throws BadMessageException {
+    @NonNull
+    public static VoipCallHangupData parse(@NonNull String jsonObjectString) throws BadMessageException {
 		final JSONObject o;
 		if (jsonObjectString.trim().isEmpty()) {
 			// Historically, hangup messages may be empty
@@ -71,7 +72,8 @@ public class VoipCallHangupData extends VoipCallData<VoipCallHangupData> {
 		bos.write(this.generateString().getBytes(UTF_8));
 	}
 
-	private @NonNull String generateString() {
+    @NonNull
+    private String generateString() {
 		final JSONObject o = this.buildJsonObject();
 		return o.toString();
 	}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.java
deleted file mode 100644
index a327a067..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallHangupMessage.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-/**
- * This packet is sent to indicate that one of the call participants has ended the call.
- */
-public class VoipCallHangupMessage extends VoipMessage {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallHangupMessage");
-
-	private @Nullable VoipCallHangupData callHangupData;
-
-	public VoipCallHangupMessage() {
-		super();
-	}
-
-	public VoipCallHangupMessage setData(@NonNull VoipCallHangupData callHangupData) {
-		this.callHangupData = callHangupData;
-		return this;
-	}
-
-	public @Nullable VoipCallHangupData getData() {
-		return this.callHangupData;
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_HANGUP;
-	}
-
-	@Override
-	@NonNull
-	public byte[] getBody() throws ThreemaException  {
-		try {
-			final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callHangupData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error("Could not serialize VoipCallHangupMessage", e);
-			throw new ThreemaException("Could not serialize VoipCallHangupMessage");
-		}
-	}
-
-	@Override
-	public boolean flagShortLivedServerQueuing() {
-		// Hangup messages should persist in the message queue
-		return false;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		// Note: Incoming hangup messages should trigger lastUpdate, but only if the call was
-		//       missed. Thus, we set the field to `false` here, and handle it in the "call missed"
-		//       logic instead.
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.java
deleted file mode 100644
index 806e74b3..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallOfferMessage.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-public class VoipCallOfferMessage extends VoipMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallOfferMessage");
-
-	private VoipCallOfferData callOfferData;
-
-	public VoipCallOfferMessage() {
-		super();
-	}
-
-	public VoipCallOfferMessage setData(VoipCallOfferData callOfferData) {
-		this.callOfferData = callOfferData;
-		return this;
-	}
-
-	public VoipCallOfferData getData() {
-		return this.callOfferData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callOfferData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_OFFER;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return true;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return true;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return true;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.java
deleted file mode 100644
index 4ecb80a2..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipCallRingingMessage.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-/**
- * This packet is sent by the receiver of a call.
- * It indicates towards the caller that the phone is ringing.
- */
-public class VoipCallRingingMessage extends VoipMessage {
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipCallRingingMessage");
-
-	private @Nullable VoipCallRingingData callRingingData;
-
-	public VoipCallRingingMessage() {
-		super();
-	}
-
-	public VoipCallRingingMessage setData(@NonNull VoipCallRingingData callRingingData) {
-		this.callRingingData = callRingingData;
-		return this;
-	}
-
-	public @Nullable VoipCallRingingData getData() {
-		return this.callRingingData;
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_CALL_RINGING;
-	}
-
-	@Override
-	@NonNull
-	public byte[] getBody() throws ThreemaException {
-		try {
-			final ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.callRingingData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error("Could not serialize VoipCallRingingMessage", e);
-			throw new ThreemaException("Could not serialize VoipCallRingingMessage");
-		}
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return true;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.java
deleted file mode 100644
index c0000598..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipICECandidatesMessage.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import org.slf4j.Logger;
-
-import java.io.ByteArrayOutputStream;
-
-import ch.threema.base.utils.LoggingUtil;
-import ch.threema.domain.protocol.csp.ProtocolDefines;
-
-public class VoipICECandidatesMessage extends VoipMessage {
-
-	private static final Logger logger = LoggingUtil.getThreemaLogger("VoipICECandidatesMessage");
-
-	private VoipICECandidatesData iceCandidatesData;
-
-	public VoipICECandidatesMessage() {
-		super();
-	}
-
-	public VoipICECandidatesMessage setData(VoipICECandidatesData iceCandidatesData) {
-		this.iceCandidatesData = iceCandidatesData;
-		return this;
-	}
-
-	public VoipICECandidatesData getData() {
-		return this.iceCandidatesData;
-	}
-
-	@Override
-	public byte[] getBody() {
-		try {
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			this.iceCandidatesData.write(bos);
-			return bos.toByteArray();
-		} catch (Exception e) {
-			logger.error(e.getMessage());
-			return null;
-		}
-	}
-
-	@Override
-	public int getType() {
-		return ProtocolDefines.MSGTYPE_VOIP_ICE_CANDIDATES;
-	}
-
-	@Override
-	public boolean allowUserProfileDistribution() {
-		return false;
-	}
-
-	@Override
-	public boolean exemptFromBlocking() {
-		return false;
-	}
-
-	@Override
-	public boolean protectAgainstReplay() {
-		return false;
-	}
-
-	@Override
-	public boolean createImplicitlyDirectContact() {
-		return false;
-	}
-
-	@Override
-	public boolean reflectIncoming() {
-		return true;
-	}
-
-	@Override
-	public boolean reflectOutgoing() {
-		return false;
-	}
-
-	@Override
-	public boolean sendAutomaticDeliveryReceipt() {
-		return false;
-	}
-
-	@Override
-	public boolean bumpLastUpdate() {
-		return false;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.java b/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.java
deleted file mode 100644
index f86e0caa..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/csp/messages/voip/VoipMessage.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages.voip;
-
-import androidx.annotation.Nullable;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.protobuf.csp.e2e.fs.Version;
-
-public abstract class VoipMessage extends AbstractMessage {
-
-	public VoipMessage() {
-		super();
-	}
-
-	@Override
-	public boolean flagSendPush() {
-		return true;
-	}
-
-	@Override
-	public boolean flagShortLivedServerQueuing() {
-		// Should be set for all VoIP messages except for the hangup message
-		return true;
-	}
-
-	@Nullable
-	@Override
-	public Version getMinimumRequiredForwardSecurityVersion() {
-		return Version.V1_1;
-	}
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt b/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt
deleted file mode 100644
index a7e55864..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeys.kt
+++ /dev/null
@@ -1,89 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.multidevice
-
-import ch.threema.base.crypto.ThreemaKDF
-import ch.threema.base.utils.SecureRandomUtil.generateRandomBytes
-import ch.threema.domain.protocol.connection.data.D2dMessage
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.D2mProtocolException
-import com.neilalexander.jnacl.NaCl
-
-data class MultiDeviceKeys(val dgk: ByteArray) {
-    companion object {
-        private val KDF: ThreemaKDF by lazy { ThreemaKDF("3ma-mdev") }
-        private const val SALT_DGPK = "p"
-        private const val SALT_DGRK = "r"
-        private const val SALT_DGDIK = "di"
-        private const val SALT_DGSDDK = "sdd"
-        private const val SALT_DGTSK = "ts"
-
-        private fun createNonce(): ByteArray {
-            return generateRandomBytes(NaCl.NONCEBYTES)
-        }
-    }
-
-    init {
-        // assert correct length of dgk
-        if (dgk.size != 32) {
-            throw D2mProtocolException("Invalid length of key material. Expected 32, actual ${dgk.size}")
-        }
-    }
-
-    internal val dgpk: ByteArray by lazy { KDF.deriveKey(SALT_DGPK, dgk) }
-    internal val dgid: ByteArray by lazy { NaCl.derivePublicKey(dgpk) }
-
-    internal val dgrk: ByteArray by lazy { KDF.deriveKey(SALT_DGRK, dgk) }
-    internal val dgdik: ByteArray by lazy { KDF.deriveKey(SALT_DGDIK, dgk) }
-    internal val dgsddk: ByteArray by lazy { KDF.deriveKey(SALT_DGSDDK, dgk) }
-    internal val dgtsk: ByteArray by lazy { KDF.deriveKey(SALT_DGTSK, dgk) }
-
-    internal fun createServerHelloResponse(serverHello: InboundD2mMessage.ServerHello): ByteArray {
-        val naCl = NaCl(dgpk, serverHello.esk)
-        val nonce = createNonce()
-        return nonce + naCl.encrypt(serverHello.challenge, nonce)
-    }
-
-    fun encryptDeviceInfo(deviceInfo: D2dMessage.DeviceInfo): ByteArray {
-        val nonce = createNonce()
-        return nonce + NaCl.symmetricEncryptData(deviceInfo.bytes, dgdik, nonce)
-    }
-
-    override fun equals(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is MultiDeviceKeys) return false
-
-        if (!dgk.contentEquals(other.dgk)) return false
-
-        return true
-    }
-
-    override fun hashCode(): Int {
-        return dgk.contentHashCode()
-    }
-
-    override fun toString(): String {
-        return "MultiDeviceKeys(dgk=********)"
-    }
-
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt b/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt
deleted file mode 100644
index 004df7e4..00000000
--- a/domain/src/main/java/ch/threema/domain/protocol/multidevice/MultiDeviceProperties.kt
+++ /dev/null
@@ -1,60 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.multidevice
-
-import androidx.annotation.AnyThread
-import ch.threema.domain.protocol.connection.data.D2dMessage
-import ch.threema.domain.protocol.connection.data.D2mProtocolVersion
-import ch.threema.domain.protocol.connection.data.DeviceId
-import ch.threema.domain.protocol.connection.data.DeviceSlotState
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-
-data class MultiDeviceProperties(
-    val registrationTime: ULong?,
-    val mediatorDeviceId: DeviceId,
-    val cspDeviceId: DeviceId,
-    val keys: MultiDeviceKeys,
-    val deviceInfo: D2dMessage.DeviceInfo,
-    val protocolVersion: D2mProtocolVersion,
-    val serverInfoListener: (serverInfo: InboundD2mMessage.ServerInfo) -> Unit
-) {
-    val deviceSlotState: DeviceSlotState = if (registrationTime == null) {
-        DeviceSlotState.NEW
-    } else {
-        DeviceSlotState.EXISTING
-    }
-
-    /**
-     * Call this method when a [InboundD2mMessage.ServerInfo] is received to propagate the info to the
-     * [serverInfoListener].
-     */
-    @AnyThread
-    fun notifyServerInfo(serverInfo: InboundD2mMessage.ServerInfo) {
-        serverInfoListener.invoke(serverInfo)
-    }
-
-    override fun toString(): String {
-        return "MultiDeviceProperties(registrationTime=$registrationTime, mediatorDeviceId=$mediatorDeviceId, cspDeviceId=$cspDeviceId, keys=********, deviceInfo=$deviceInfo, protocolVersion=$protocolVersion, serverInfoListener=$serverInfoListener, deviceSlotState=$deviceSlotState)"
-    }
-
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/stores/ContactStore.java b/domain/src/main/java/ch/threema/domain/stores/ContactStore.java
index 54bf85f5..69080a33 100644
--- a/domain/src/main/java/ch/threema/domain/stores/ContactStore.java
+++ b/domain/src/main/java/ch/threema/domain/stores/ContactStore.java
@@ -24,6 +24,7 @@ package ch.threema.domain.stores;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 
 /**
  * A contact store stores {@link Contact} instances.
@@ -44,7 +45,15 @@ public interface ContactStore {
 	 *
  	 * @param contact the contact that is temporarily saved
 	 */
-	void addCachedContact(@NonNull Contact contact);
+	void addCachedContact(@NonNull BasicContact contact);
+
+	/**
+	 * Get the cached contact for the given identity. If there is no cached contact, null is
+	 * returned. Note that if the contact with the given identity exists but is not in cache, null
+	 * is returned.
+	 */
+	@Nullable
+	BasicContact getCachedContact(@NonNull String identity);
 
 	/**
 	 * Get the cached or stored contact for the given identity. This method first checks if the
@@ -65,7 +74,8 @@ public interface ContactStore {
 	void addContact(@NonNull Contact contact);
 
 	/**
-	 * Remove a contact from the contact store.
+	 * Check whether the identity belongs to a special contact or not.
 	 */
-	void removeContact(@NonNull Contact contact);
+	boolean isSpecialContact(@NonNull String identity);
+
 }
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt
deleted file mode 100644
index 32ae7a33..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingCspMessageTask.kt
+++ /dev/null
@@ -1,90 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.PayloadProcessingException
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.coders.MessageBox
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingCspMessageTask")
-
-class IncomingCspMessageTask(
-    private val message: CspMessage,
-    private val incomingMessageProcessor: IncomingMessageProcessor,
-) : ActiveTask<Unit> {
-    override val type: String = "IncomingCspMessageTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        when(message.payloadType.toInt()) {
-            ProtocolDefines.PLTYPE_ERROR -> processError(message.toServerErrorData())
-            ProtocolDefines.PLTYPE_ALERT -> processAlert(message.toServerAlertData())
-            ProtocolDefines.PLTYPE_OUTGOING_MESSAGE_ACK -> processOutgoingMessageAck(message.toOutgoingMessageAck())
-            ProtocolDefines.PLTYPE_INCOMING_MESSAGE -> processIncomingMessage(message.toIncomingMessageData(), handle)
-            ProtocolDefines.PLTYPE_QUEUE_SEND_COMPLETE -> processQueueSendComplete()
-            ProtocolDefines.PLTYPE_DEVICE_COOKIE_CHANGE_INDICATION -> processDeviceCookieChangeIndication()
-            else -> throw PayloadProcessingException("Unknown payload type ${message.payloadType}")
-        }
-    }
-
-    private fun processError(data: CspMessage.ServerErrorData) {
-        logger.warn("Processed server error in incoming csp message task: '{}'", data.message)
-    }
-
-    private fun processAlert(data: CspMessage.ServerAlertData) {
-        logger.warn("Processed server alert in incoming csp message task: '{}'", data.message)
-    }
-
-    private fun processOutgoingMessageAck(data: CspMessage.MessageAck) {
-        logger.warn(
-            "Processed ack for outgoing message {} to {} in incoming csp message task",
-            data.messageId,
-            data.recipient
-        )
-    }
-
-    private suspend fun processIncomingMessage(
-        data: CspMessage.IncomingMessageData,
-        handle: ActiveTaskCodec,
-    ) {
-        if (data.data.size < ProtocolDefines.OVERHEAD_MSG_HDR) {
-            throw PayloadProcessingException("Bad length (${data.data.size}) for message payload")
-        }
-        suspend {
-            val messageBox = MessageBox.parseBinary(data.data)
-
-            incomingMessageProcessor.processIncomingMessage(messageBox, handle)
-        }.catchAllExceptNetworkException {
-            logger.error("Could not process incoming message", it)
-        }
-    }
-
-    private fun processQueueSendComplete() {
-        logger.warn("Processed queue send complete inside incoming csp message task")
-    }
-
-    private fun processDeviceCookieChangeIndication() {
-        logger.warn("Processed device cookie change indication inside incoming csp message task")
-    }
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt
deleted file mode 100644
index a80592d7..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingD2mMessageTask.kt
+++ /dev/null
@@ -1,42 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.toHex
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingD2mMessageTask")
-
-class IncomingD2mMessageTask(
-    private val message: InboundD2mMessage
-) : ActiveTask<Unit> {
-    override val type: String = "IncomingD2mMessageTask"
-
-    override suspend fun invoke(handle: ActiveTaskCodec) {
-        logger.warn(
-            "Ignore incoming d2m message with type={} and payloadType={}",
-            message.type,
-            message.payloadType.toHex()
-        )
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt
deleted file mode 100644
index 5654ea26..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageProcessor.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.csp.coders.MessageBox
-
-interface IncomingMessageProcessor {
-
-    /**
-     * Process an incoming message.
-     */
-    suspend fun processIncomingMessage(messageBox: MessageBox, handle: ActiveTaskCodec)
-
-    /**
-     * Process an incoming server alert
-     */
-    fun processIncomingServerAlert(alertData: CspMessage.ServerAlertData)
-
-    /**
-     * Process an incoming server error
-     */
-    fun processIncomingServerError(errorData: CspMessage.ServerErrorData)
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt b/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt
deleted file mode 100644
index 0cd3e7e2..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/IncomingMessageTaskQueue.kt
+++ /dev/null
@@ -1,167 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.channels.Channel
-
-private val logger = LoggingUtil.getThreemaLogger("IncomingMessageTaskQueue")
-
-internal class IncomingMessageTaskQueue(
-    private val incomingMessageProcessor: IncomingMessageProcessor,
-) {
-
-    /**
-     * True if an incoming message task is currently being executed.
-     */
-    private var hasRunningTask = false
-
-    /**
-     * The incoming message queue that holds the messages that have been received. This includes
-     * csp, d2m, and d2d messages.
-     */
-    private val incomingMessageQueue = Channel<IncomingMessageTaskQueueElement>(Channel.UNLIMITED)
-
-    /**
-     * Messages from the [incomingMessageQueue] that are not required by the current task may be
-     * moved in this queue. Note that this queue does not need any synchronization as only the
-     * executor dispatcher accesses it.
-     */
-    private val backlogQueue = ArrayDeque<IncomingMessageTaskQueueElement>()
-
-    /**
-     * Add a new inbound message to the queue.
-     */
-    internal suspend fun add(inboundMessage: InboundMessage) {
-        incomingMessageQueue.send(IncomingMessageTaskQueueElement(inboundMessage))
-    }
-
-    /**
-     * Get the next task or null.
-     */
-    internal fun getNextOrNull(): TaskQueue.TaskQueueElement? {
-        if (backlogQueue.isNotEmpty()) {
-            return backlogQueue.removeFirstOrNull().also { hasRunningTask = it != null }
-        }
-
-        return incomingMessageQueue.tryReceive().getOrNull().also {
-            hasRunningTask = it != null
-        }
-    }
-
-    /**
-     * Return whether there are pending tasks.
-     */
-    internal fun hasPendingTasks() = hasRunningTask
-
-    /**
-     *
-     */
-    internal suspend fun readMessage(
-        preProcess: (InboundMessage) -> MessageFilterInstruction,
-    ): ReadMessageResult {
-        val bypassMessages = mutableListOf<IncomingMessageTaskQueueElement>()
-
-        // First check backlog queue for the matching message
-        val backlogIterator = backlogQueue.iterator()
-        while (backlogIterator.hasNext()) {
-            val backlogMessage = backlogIterator.next()
-            when (preProcess(backlogMessage.inboundMessage)) {
-                MessageFilterInstruction.ACCEPT -> {
-                    backlogIterator.remove()
-                    return ReadMessageResult(bypassMessages, backlogMessage.inboundMessage)
-                }
-
-                // TODO(ANDR-2475): once we bypass messages, no bypassed message should be added to the backlog queue
-                MessageFilterInstruction.BYPASS_OR_BACKLOG -> continue
-
-                MessageFilterInstruction.REJECT -> TODO("Implement") // TODO(ANDR-2868)
-            }
-        }
-
-        // Then wait until the matching message arrives in the queue
-        while (true) {
-            val message = incomingMessageQueue.receive()
-            when (preProcess(message.inboundMessage)) {
-                MessageFilterInstruction.ACCEPT -> return ReadMessageResult(
-                    bypassMessages,
-                    message.inboundMessage
-                )
-
-                MessageFilterInstruction.BYPASS_OR_BACKLOG -> {
-                    // TODO(ANDR-2475): bypass d2d messages
-                    backlogQueue.add(message)
-                }
-
-                MessageFilterInstruction.REJECT -> TODO("Implement") // TODO(ANDR-2475)
-            }
-        }
-    }
-
-    internal fun flush() {
-        var nextIncomingMessage = incomingMessageQueue.tryReceive().getOrNull()
-        while (nextIncomingMessage != null) {
-            nextIncomingMessage = incomingMessageQueue.tryReceive().getOrNull()
-        }
-
-        backlogQueue.clear()
-    }
-
-    /**
-     * An element of the incoming message queue. This is an element that has been created from an
-     * incoming message.
-     */
-    private inner class IncomingMessageTaskQueueElement(
-        val inboundMessage: InboundMessage,
-    ) : TaskQueue.TaskQueueElement {
-        private val task by lazy {
-            when (inboundMessage) {
-                is CspMessage -> IncomingCspMessageTask(inboundMessage, incomingMessageProcessor)
-                is InboundD2mMessage -> IncomingD2mMessageTask(inboundMessage)
-            }
-        }
-        private val done: CompletableDeferred<Unit> = CompletableDeferred()
-
-        override val maximumNumberOfExecutions: Int = 1
-
-        override suspend fun run(handle: TaskCodec) {
-            logger.info("Running task {}", task.getDebugString())
-            done.complete(task.invoke(handle))
-            logger.info("Completed task {}", task.getDebugString())
-            // Note that we do not need to set 'hasRunningTask' to false here. It suffices to set it
-            // to false if 'getNextOrNull' returns null.
-        }
-
-        override fun isCompleted() = done.isCompleted
-
-        override suspend fun completeExceptionally(exception: Throwable) {
-            logger.warn("Completing task {} exceptionally", task.getDebugString(), exception)
-            done.completeExceptionally(exception)
-            // Note that we do not need to set 'hasRunningTask' to false here. It suffices to set it
-            // to false if 'getNextOrNull' returns null.
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/LocalTaskQueue.kt b/domain/src/main/java/ch/threema/domain/taskmanager/LocalTaskQueue.kt
deleted file mode 100644
index 654d872c..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/LocalTaskQueue.kt
+++ /dev/null
@@ -1,99 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.runBlocking
-import kotlinx.coroutines.sync.Mutex
-import kotlinx.coroutines.sync.withLock
-
-private val logger = LoggingUtil.getThreemaLogger("LocalTaskQueue")
-
-internal class LocalTaskQueue(private val taskArchiver: TaskArchiver) {
-    /**
-     * The mutex is required to access [taskQueue].
-     */
-    private val mutex = Mutex()
-
-    /**
-     * The task queue for tasks that have been initiated by this device. Note that this queue should
-     * only be accessed when holding the [mutex], as both the scheduler and executor modify this
-     * queue.
-     */
-    private val taskQueue by lazy {
-        ArrayDeque<LocalTaskQueueElement<*>>().also { queue ->
-            // First load all the persisted tasks and keep them persisted until they are completed
-            taskArchiver.loadAllTasks().forEach {
-                queue.add(LocalTaskQueueElement(it, CompletableDeferred()))
-            }
-        }
-    }
-
-    internal suspend fun <R> add(task: Task<R, TaskCodec>, done: CompletableDeferred<R>) {
-        mutex.withLock {
-            taskQueue.add(LocalTaskQueueElement(task, done))
-            taskArchiver.addTask(task)
-        }
-    }
-
-    internal fun getNextOrNull(): TaskQueue.TaskQueueElement? = runBlocking {
-        mutex.withLock { taskQueue.firstOrNull() }
-    }
-
-    internal fun hasPendingTasks() = runBlocking {
-        mutex.withLock { taskQueue.isNotEmpty() }
-    }
-
-    /**
-     * An element of the local task queue. This is a task that has not been initiated by an incoming
-     * message but has been scheduled locally.
-     */
-    private inner class LocalTaskQueueElement<R>(
-        private val task: Task<R, TaskCodec>,
-        private val done: CompletableDeferred<R>,
-    ) : TaskQueue.TaskQueueElement {
-        override val maximumNumberOfExecutions: Int = 5
-
-        override suspend fun run(handle: TaskCodec) {
-            logger.info("Running task {}", task.getDebugString())
-            done.complete(task.invoke(handle))
-            logger.info("Completed task {}", task.getDebugString())
-            mutex.withLock {
-                taskQueue.remove(this)
-                taskArchiver.removeTask(task)
-            }
-        }
-
-        override fun isCompleted() = done.isCompleted
-
-        override suspend fun completeExceptionally(exception: Throwable) {
-            logger.warn("Completing task {} exceptionally", task.getDebugString(), exception)
-            done.completeExceptionally(exception)
-            mutex.withLock {
-                taskQueue.remove(this)
-                taskArchiver.removeTask(task)
-            }
-        }
-
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt b/domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt
deleted file mode 100644
index 76d98fb5..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/OutgoingCspMessageUtils.kt
+++ /dev/null
@@ -1,57 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.crypto.NonceFactory
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.csp.MessageTooLongException
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.coders.MessageCoder
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.stores.ContactStore
-import ch.threema.domain.stores.IdentityStoreInterface
-
-fun AbstractMessage.toCspMessage(
-    identityStore: IdentityStoreInterface,
-    contactStore: ContactStore,
-    nonceFactory: NonceFactory,
-    nonce: ByteArray,
-): CspMessage {
-    // Add missing attributes, if necessary
-    if (fromIdentity == null) {
-        fromIdentity = identityStore.identity
-    }
-
-    // Make box
-    val messageCoder = MessageCoder(contactStore, identityStore)
-    val messageBox = messageCoder.encode(this, nonce, nonceFactory)
-
-    // For the sake of efficiency: simply deduct overhead size
-    val overhead = (ProtocolDefines.OVERHEAD_MSG_HDR
-            + ProtocolDefines.OVERHEAD_NACL_BOX
-            + ProtocolDefines.OVERHEAD_PKT_HDR)
-    if (messageBox.box != null && messageBox.box.size > ProtocolDefines.MAX_PKT_LEN - overhead) {
-        throw MessageTooLongException()
-    }
-
-    return messageBox.creatCspMessage()
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/QueueSendCompleteListener.java b/domain/src/main/java/ch/threema/domain/taskmanager/QueueSendCompleteListener.java
deleted file mode 100644
index 32506675..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/QueueSendCompleteListener.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2013-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager;
-
-/**
- * Interface for objects that wish to be notified when the server has signalled that the message
- * queue has been flushed completely.
- */
-public interface QueueSendCompleteListener {
-	void queueSendComplete();
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/Task.kt b/domain/src/main/java/ch/threema/domain/taskmanager/Task.kt
deleted file mode 100644
index 874628f2..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/Task.kt
+++ /dev/null
@@ -1,54 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-/**
- * A Task that executes a specific application action according to a complex execution plan.
- */
-interface Task<out R, in TaskCodecType> {
-    /**
-     * Run the task.
-     */
-    suspend fun invoke(handle: TaskCodecType): R
-
-    /**
-     * The type of the task. This is only used for logging purposes.
-     */
-    val type: String
-}
-
-/**
- * Get the task as debug string. This is only used for debugging.
- */
-fun <R, T> Task<R, T>.getDebugString(): String = "$type@${hashCode()}"
-
-/**
- * An active task may send messages.
- */
-interface ActiveTask<out R> : Task<R, ActiveTaskCodec>
-
-/**
- * A passive task can only retrieve messages.
- */
-interface PassiveTask<out R> : Task<R, PassiveTaskCodec>
-
-interface TransactionTask<out R> : Task<R, ActiveTaskCodec>
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskArchiver.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskArchiver.kt
deleted file mode 100644
index b9db6292..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskArchiver.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-/**
- * This interface defines the functionality of a task archiver to achieve persistence.
- */
-interface TaskArchiver {
-
-    /**
-     * Add another task to the archive.
-     */
-    fun addTask(task: Task<*, TaskCodec>)
-
-    /**
-     * Remove the given task from the archive. Note that if we have several archived tasks that
-     * cannot be distinguished from each other, then we should only delete the oldest archived task.
-     */
-    fun removeTask(task: Task<*, TaskCodec>)
-
-    /**
-     * Load all tasks in the same order they have been archived.
-     */
-    fun loadAllTasks(): List<Task<*, TaskCodec>>
-
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt
deleted file mode 100644
index 881438c9..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManager.kt
+++ /dev/null
@@ -1,300 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.PayloadProcessingException
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.connection.data.InboundD2mMessage
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import ch.threema.domain.protocol.connection.data.toHex
-import ch.threema.domain.protocol.connection.layer.Layer5Codec
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Deferred
-import kotlinx.coroutines.launch
-
-private val logger = LoggingUtil.getThreemaLogger("TaskManager")
-
-/**
- * This is the public task manager interface. It can be used by the client to schedule new tasks.
- */
-interface TaskManager {
-
-    /**
-     * Schedule a new task asynchronously. The task is executed when all prior tasks have finished
-     * and when a connection to the server is available. If the task is not persisted by the
-     * [TaskArchiver], then the task is discarded if the application is stopped before the task
-     * could have been executed.
-     */
-    @Suppress("DeferredIsResult")
-    fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R>
-
-    /**
-     * Return true when there are some pending tasks in the task manager left, false otherwise.
-     */
-    fun hasPendingTasks(): Boolean
-
-    // This is only used for the migration phase until we fully use the task manager
-    @Deprecated(
-        "We should only be able to send and receive messages from within tasks.",
-        ReplaceWith("TaskManager#schedule")
-    )
-    fun getMigrationTaskHandle(): ActiveTaskCodec
-
-    /**
-     * Add a queue send complete listener.
-     */
-    fun addQueueSendCompleteListener(listener: QueueSendCompleteListener)
-
-    /**
-     * Remove a queue send complete listener.
-     */
-    fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener)
-}
-
-/**
- * This is the internal task manager interface that is used by the server connection.
- */
-internal interface InternalTaskManager {
-    /**
-     * Process an inbound message. Depending on the message type, the message is processed
-     * immediately or it is scheduled to run in the task manager context.
-     */
-    fun processInboundMessage(message: InboundMessage)
-
-    /**
-     * Start the task runner with the given layer 5 codec.
-     */
-    suspend fun startRunningTasks(
-        layer5Codec: Layer5Codec,
-        incomingMessageProcessor: IncomingMessageProcessor,
-    )
-
-    /**
-     * Pause running tasks as there is no network connection.
-     */
-    suspend fun pauseRunningTasks()
-}
-
-/**
- * The task manager that runs the tasks.
- */
-internal class TaskManagerImpl(
-    taskArchiverCreator: () -> TaskArchiver,
-    private val deviceCookieManager: DeviceCookieManager,
-    private val dispatchers: TaskManagerDispatchers,
-) : InternalTaskManager, TaskManager {
-    private val queueSendCompleteListeners: MutableSet<QueueSendCompleteListener> = mutableSetOf()
-
-    private var incomingMessageProcessor: IncomingMessageProcessor? = null
-
-    /**
-     * This is the smart task queue that contains the local tasks as well as the incoming message
-     * tasks.
-     */
-    private val taskQueue by lazy {
-        TaskQueue(taskArchiverCreator(), dispatchers)
-    }
-
-    /**
-     * The task runner runs the tasks of the message queue while the task manager only schedules
-     * them.
-     */
-    private val taskRunner: Lazy<TaskRunner> = lazy {
-        TaskRunner(dispatchers, taskQueue)
-    }
-
-    @Deprecated(
-        "We should only be able to send and receive messages from within tasks.",
-        replaceWith = ReplaceWith("TaskManager#schedule")
-    )
-    override fun getMigrationTaskHandle(): ActiveTaskCodec = taskRunner.value.getTaskCodec()
-
-    override suspend fun startRunningTasks(
-        layer5Codec: Layer5Codec,
-        incomingMessageProcessor: IncomingMessageProcessor,
-    ) {
-        this.incomingMessageProcessor = incomingMessageProcessor
-
-        taskRunner.value.startTaskRunner(layer5Codec, incomingMessageProcessor)
-    }
-
-    override suspend fun pauseRunningTasks() {
-        if (taskRunner.isInitialized()) {
-            taskRunner.value.stopTaskRunner()
-        }
-    }
-
-    override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> {
-        logger.info("Scheduling new task: {}", task.getDebugString())
-
-        val done = CompletableDeferred<R>()
-        CoroutineScope(dispatchers.scheduleDispatcher.coroutineContext).launch {
-            // Enqueue the task
-            taskQueue.enqueueTask(task, done)
-
-            logger.info("Task scheduled: {}", task.getDebugString())
-        }
-        return done
-    }
-
-    override fun hasPendingTasks(): Boolean = taskQueue.hasPendingTasks()
-
-    override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
-        synchronized(queueSendCompleteListeners) {
-            queueSendCompleteListeners.add(listener)
-        }
-    }
-
-    override fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener) {
-        synchronized(queueSendCompleteListeners) {
-            queueSendCompleteListeners.remove(listener)
-        }
-    }
-
-    override fun processInboundMessage(message: InboundMessage) {
-        when (message) {
-            is CspMessage -> processInboundCspMessage(message)
-            is InboundD2mMessage -> processInboundD2mMessage(message)
-        }
-    }
-
-    private fun processInboundD2mMessage(message: InboundD2mMessage) {
-        logger.debug(
-            "Processing inbound d2m message with payload type `{}`",
-            message.payloadType.toHex()
-        )
-        schedule(message)
-    }
-
-    private fun processInboundCspMessage(message: CspMessage) {
-        logger.debug(
-            "Processing inbound csp message with payload type `{}`",
-            message.payloadType.toHex()
-        )
-
-        when (message.payloadType.toInt()) {
-            ProtocolDefines.PLTYPE_ERROR -> incomingMessageProcessor.get {
-                logger.error("Got inbound server error before task manager has been started")
-            }.processIncomingServerError(
-                message.toServerErrorData()
-            )
-
-            ProtocolDefines.PLTYPE_ALERT -> incomingMessageProcessor.get {
-                logger.error("Got inbound server alert before task manager has been started")
-            }.processIncomingServerAlert(
-                message.toServerAlertData()
-            )
-
-            ProtocolDefines.PLTYPE_OUTGOING_MESSAGE_ACK -> schedule(message)
-            ProtocolDefines.PLTYPE_INCOMING_MESSAGE -> schedule(message)
-            ProtocolDefines.PLTYPE_QUEUE_SEND_COMPLETE -> notifyQueueSendComplete()
-            ProtocolDefines.PLTYPE_DEVICE_COOKIE_CHANGE_INDICATION -> processDeviceCookieChangeIndication()
-            else -> throw PayloadProcessingException("Unknown payload type ${message.payloadType}")
-        }
-    }
-
-    private fun schedule(inboundMessage: InboundMessage) {
-        logger.info(
-            "Scheduling inbound message with payload type {}",
-            inboundMessage.payloadType.toHex()
-        )
-
-        CoroutineScope(dispatchers.scheduleDispatcher.coroutineContext).launch {
-            // Enqueue the message
-            taskQueue.enqueueInboundMessage(inboundMessage)
-        }
-    }
-
-    private fun processDeviceCookieChangeIndication() {
-        deviceCookieManager.changeIndicationReceived()
-        sendClearDeviceCookieChangeIndication()
-    }
-
-    private fun notifyQueueSendComplete() {
-        synchronized(queueSendCompleteListeners) {
-            // Iterate over a copy of the set to prevent concurrent modification. This is necessary,
-            // because the queue complete listeners may remove themselves from the list inside
-            // 'queueSendComplete'.
-            queueSendCompleteListeners.toList().forEach {
-                try {
-                    it.queueSendComplete()
-                } catch (e: Exception) {
-                    logger.warn("Exception while invoking queue send complete listener", e)
-                }
-            }
-        }
-    }
-
-    private fun sendClearDeviceCookieChangeIndication() {
-        logger.debug("Clearing device cookie change indication")
-        taskRunner.value.sendImmediately(
-            CspMessage(
-                ProtocolDefines.PLTYPE_CLEAR_DEVICE_COOKIE_CHANGE_INDICATION.toUByte(),
-                byteArrayOf()
-            )
-        )
-    }
-
-    /**
-     * Get the incoming message processor. Otherwise throws an illegal state exception.
-     */
-    private fun IncomingMessageProcessor?.get(runIfNull: () -> Unit = { }): IncomingMessageProcessor {
-        if (this == null) {
-            runIfNull()
-            throw IllegalStateException("Cannot access incoming message queue as it is null")
-        }
-        return this
-    }
-
-    internal interface TaskManagerDispatcherAsserters {
-        /**
-         * The executor dispatcher is used for running the tasks. This asserter can be used to check
-         * if a method is running with the correct dispatcher.
-         */
-        val executorDispatcher: TaskManagerDispatcherAsserter
-
-        /**
-         * The schedule dispatcher is used for scheduling tasks and incoming messages in the task
-         * task manager. It is also used for persisting and loading tasks. The main goal of this
-         * dispatcher is to keep the tasks in the correct order. This asserter can be used to check
-         * if a method is running with the correct dispatcher.
-         */
-        val scheduleDispatcher: TaskManagerDispatcherAsserter
-    }
-
-    internal data class TaskManagerDispatchers(
-        /**
-         * The executor dispatcher is used for running the tasks.
-         */
-        override val executorDispatcher: TaskManagerDispatcher,
-        /**
-         * The schedule dispatcher is used for scheduling tasks and incoming messages in the task
-         * task manager. It is also used for persisting and loading tasks. The main goal of this
-         * dispatcher is to keep the tasks in the correct order.
-         */
-        override val scheduleDispatcher: TaskManagerDispatcher,
-    ) : TaskManagerDispatcherAsserters
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerDispatcher.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerDispatcher.kt
deleted file mode 100644
index 2b7ef2d0..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerDispatcher.kt
+++ /dev/null
@@ -1,70 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.concurrent.TrulySingleThreadExecutorThreadFactory
-import ch.threema.base.utils.LoggingUtil
-import kotlinx.coroutines.ExecutorCoroutineDispatcher
-import kotlinx.coroutines.asCoroutineDispatcher
-import java.util.concurrent.Executors
-import kotlin.coroutines.CoroutineContext
-
-private val logger = LoggingUtil.getThreemaLogger("TaskManagerDispatcher")
-
-internal interface TaskManagerDispatcherAsserter {
-    fun assertDispatcherContext()
-}
-
-internal interface TaskManagerDispatcher : TaskManagerDispatcherAsserter {
-    val coroutineContext: CoroutineContext
-}
-
-internal class SingleThreadedTaskManagerDispatcher(
-    private val assertContext: Boolean,
-    threadName: String,
-) : TaskManagerDispatcher {
-    private lateinit var thread: Thread
-
-    private val dispatcher: ExecutorCoroutineDispatcher
-    override val coroutineContext: CoroutineContext
-
-    init {
-        val factory = TrulySingleThreadExecutorThreadFactory(threadName) {
-            thread = it
-        }
-
-        dispatcher = Executors.newSingleThreadExecutor(factory).asCoroutineDispatcher()
-
-        coroutineContext = dispatcher
-    }
-
-    override fun assertDispatcherContext() {
-        if (assertContext) {
-            val actual = Thread.currentThread()
-            if (actual !== thread) {
-                val msg = "Thread mismatch, expected '${thread.name}', got '${actual.name}'"
-                logger.error(msg)
-                throw Error(msg)
-            }
-        }
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerProvider.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerProvider.kt
deleted file mode 100644
index 2c93c5e0..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskManagerProvider.kt
+++ /dev/null
@@ -1,51 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-
-data class TaskManagerConfiguration(
-    val taskArchiver: () -> TaskArchiver,
-    val deviceCookieManager: DeviceCookieManager,
-    val assertContext: Boolean,
-)
-
-interface TaskManagerProvider {
-    companion object {
-        @JvmStatic
-        fun getTaskManager(configuration: TaskManagerConfiguration): TaskManager =
-            TaskManagerImpl(
-                configuration.taskArchiver,
-                configuration.deviceCookieManager,
-                TaskManagerImpl.TaskManagerDispatchers(
-                    SingleThreadedTaskManagerDispatcher(
-                        configuration.assertContext,
-                        "ExecutorDispatcher"
-                    ),
-                    SingleThreadedTaskManagerDispatcher(
-                        configuration.assertContext,
-                        "ScheduleDispatcher"
-                    ),
-                )
-            )
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskQueue.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskQueue.kt
deleted file mode 100644
index bf79b82d..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskQueue.kt
+++ /dev/null
@@ -1,167 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.channels.BufferOverflow
-import kotlinx.coroutines.channels.Channel
-import kotlinx.coroutines.runBlocking
-
-internal class TaskQueue(
-    taskArchiver: TaskArchiver,
-    private val dispatcherAsserters: TaskManagerImpl.TaskManagerDispatcherAsserters,
-) {
-
-    /**
-     * A channel that allows the schedule dispatcher to notify the executor dispatcher that a new
-     * task (or incoming message) is available. It has a capacity of one and drops the latest
-     * channel message if it is full. This guarantees that sending a message to it is not blocking
-     * for the sender.
-     */
-    private val newTaskChannel = Channel<Unit>(1, BufferOverflow.DROP_LATEST)
-
-    /**
-     * This queue contains the locally created tasks.
-     */
-    private val localTaskQueue = LocalTaskQueue(taskArchiver)
-
-    /**
-     * This queue contains the task created from inbound messages.
-     */
-    private var incomingMessageQueue: IncomingMessageTaskQueue? = null
-
-    /**
-     * Enqueue a new local task. Note that this method must be called from the schedule dispatcher.
-     */
-    internal suspend fun <R> enqueueTask(task: Task<R, TaskCodec>, done: CompletableDeferred<R>) {
-        dispatcherAsserters.scheduleDispatcher.assertDispatcherContext()
-
-        // Add the task to the local queue
-        localTaskQueue.add(task, done)
-
-        // Notify that a new task is available
-        newTaskChannel.send(Unit)
-    }
-
-    /**
-     * Enqueue a new inbound message. Note that this method must be called from the schedule
-     * dispatcher.
-     */
-    internal fun enqueueInboundMessage(inboundMessage: InboundMessage) = runBlocking {
-        dispatcherAsserters.scheduleDispatcher.assertDispatcherContext()
-
-        // Add the inbound message to the incoming message queue
-        incomingMessageQueue.get().add(inboundMessage)
-
-        // Notify that a new message (task) is available
-        newTaskChannel.send(Unit)
-    }
-
-    /**
-     * Recreates the incoming message queue. This is needed when the server connection has been re-
-     * established. Locally created tasks aren't affected by this.
-     */
-    internal fun recreateIncomingMessageQueue(incomingMessageProcessor: IncomingMessageProcessor) {
-        dispatcherAsserters.executorDispatcher.assertDispatcherContext()
-
-        incomingMessageQueue = IncomingMessageTaskQueue(incomingMessageProcessor)
-    }
-
-    /**
-     * Read a message from the incoming message queue. Depending on the result of [preProcess], the
-     * message is accepted, bypassed, backlogged, or rejected.
-     */
-    internal suspend fun readMessage(preProcess: (InboundMessage) -> MessageFilterInstruction): ReadMessageResult {
-        dispatcherAsserters.executorDispatcher.assertDispatcherContext()
-
-        return incomingMessageQueue.get().readMessage(preProcess)
-    }
-
-    /**
-     * Return whether there are pending tasks.
-     */
-    internal fun hasPendingTasks(): Boolean =
-        localTaskQueue.hasPendingTasks() || incomingMessageQueue?.hasPendingTasks() ?: false
-
-    /**
-     * Get the next task.
-     */
-    internal suspend fun getNextTask(): TaskQueueElement {
-        // Clear the notification from the new task channel as we are processing the task now anyway
-        newTaskChannel.tryReceive().getOrNull()
-
-        // Get next task if available
-        var queueEntity = poll()
-        while (queueEntity == null) {
-            // If currently there is no task, suspend until a new task has been signaled
-            newTaskChannel.receive()
-            queueEntity = poll()
-        }
-
-        return queueEntity
-    }
-
-    /**
-     * Get the next task or incoming message if available. Otherwise null is returned.
-     */
-    private fun poll(): TaskQueueElement? =
-        localTaskQueue.getNextOrNull() ?: incomingMessageQueue?.getNextOrNull()
-
-    /**
-     * Get the incoming message task queue. Otherwise throws an illegal state exception.
-     */
-    private fun IncomingMessageTaskQueue?.get(runIfNull: () -> Unit = { }): IncomingMessageTaskQueue {
-        if (this == null) {
-            runIfNull()
-            throw  IllegalStateException("Cannot access incoming message queue as it is null")
-        }
-        return this
-    }
-
-    /**
-     * A task queue element that defines some properties of the task.
-     */
-    internal sealed interface TaskQueueElement {
-        /**
-         * The number of attempts to execute the task. Note that only unexpected exceptions are
-         * counted towards this limit.
-         */
-        val maximumNumberOfExecutions: Int
-
-        /**
-         * Run the task.
-         */
-        suspend fun run(handle: TaskCodec)
-
-        /**
-         * Check whether the task is completed.
-         */
-        fun isCompleted(): Boolean
-
-        /**
-         * Complete this task exceptionally. This must only be called, when the
-         * [maximumNumberOfExecutions] is reached.
-         */
-        suspend fun completeExceptionally(exception: Throwable)
-    }
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt b/domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt
deleted file mode 100644
index 99d207d0..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/TaskRunner.kt
+++ /dev/null
@@ -1,363 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-import ch.threema.domain.protocol.connection.layer.Layer5Codec
-import kotlinx.coroutines.CancellationException
-import kotlinx.coroutines.CoroutineExceptionHandler
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.awaitCancellation
-import kotlinx.coroutines.isActive
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
-import kotlinx.coroutines.sync.Semaphore
-import kotlin.math.min
-
-private val logger = LoggingUtil.getThreemaLogger("TaskRunner")
-
-internal class TaskRunner(
-    dispatchers: TaskManagerImpl.TaskManagerDispatchers,
-    private val taskQueue: TaskQueue,
-) {
-    private val executorCoroutineContext = dispatchers.executorDispatcher.coroutineContext
-    private val scheduleCoroutineContext = dispatchers.scheduleDispatcher.coroutineContext
-
-    private var reconnectDelayMs = RECONNECT_MIN_DELAY_MS
-
-    /**
-     * The executor job that is currently active.
-     */
-    private var executorJob: Job? = null
-
-    /**
-     * The semaphore that the executor must acquire while starting.
-     */
-    private val executorSemaphore = Semaphore(1, 0)
-
-    /**
-     * The current layer 5 codec. This is used to send outbound messages.
-     */
-    private var layer5Codec: Layer5Codec? = null
-
-    /**
-     * The task handle that allows tasks to receive and send messages.
-     */
-    private val taskCodec = object : TaskCodec {
-        override suspend fun read(
-            preProcess: (InboundMessage) -> MessageFilterInstruction,
-        ): InboundMessage {
-            val (bypassMessages, inboundMessage) = taskQueue.readMessage(preProcess)
-            // TODO(ANDR-2475): Carefully handle exceptions here. Note that these should be logged.
-            bypassMessages.forEach { it.run(this) }
-            return inboundMessage
-        }
-
-        override suspend fun write(message: OutboundMessage) {
-            layer5Codec?.sendOutbound(message) ?: awaitCancellation()
-        }
-
-        override suspend fun reflect(message: OutboundMessage) {
-            // TODO(ANDR-2475)
-        }
-    }
-
-    /**
-     * Start the task runner after the connection has been established.
-     *
-     * @param layer5Codec the current layer 5 codec for sending messages
-     */
-    internal suspend fun startTaskRunner(layer5Codec: Layer5Codec, incomingMessageProcessor: IncomingMessageProcessor) {
-        logger.info("Starting task runner")
-
-        // Stop old executor job to allow tasks to detect faster that they cannot send or receive
-        // messages anymore
-        if (executorJob?.isActive == true) {
-            logger.info("Stopping previous executor job")
-            stopTaskRunner()
-        }
-
-        // Acquire the executor semaphore during startup
-        executorSemaphore.acquire()
-
-        // Stop old executor job in case it has been started while waiting for the executor
-        // semaphore
-        if (executorJob?.isActive == true) {
-            logger.info("Old executor job is still active. Stopping it.")
-            stopTaskRunner()
-        }
-
-        this.layer5Codec = layer5Codec
-
-        // Clear incoming message queue to get rid of old unprocessed messages
-        runBlocking(executorCoroutineContext) {
-            logger.info("Flushing incoming message queues")
-            // As the connection just has been initiated, we will again receive un-acked messages
-            taskQueue.recreateIncomingMessageQueue(incomingMessageProcessor)
-        }
-
-        // We handle the exceptions in invokeOnCompletion instead of the exception handler
-        val exceptionHandler = CoroutineExceptionHandler { _, _ -> }
-
-        // Start actually processing the tasks while the executor is active. Do not use the schedule
-        // dispatcher. Otherwise multiple tasks can be launched simultaneously.
-        executorJob = CoroutineScope(executorCoroutineContext).launch(exceptionHandler) {
-            logger.debug("Executing tasks in coroutine scope {}", this)
-            while (isActive) {
-                runNextTask()
-
-                // Set the delay to the minimum reconnect delay. Note that the task that just has
-                // been successfully run may not be the same task that caused the trouble.
-                reconnectDelayMs = RECONNECT_MIN_DELAY_MS
-            }
-        }.also {
-            it.invokeOnCompletion { cause ->
-                when (cause) {
-                    // The task manager has detected that the server connection has been stopped or
-                    // a new server connection has been established and the current executor job is
-                    // running with a stale layer 5. In both cases, a new connection is being
-                    // initiated which will trigger a start of the task runner again.
-                    is ConnectionStoppedException -> logger.info("Task executor stopped", cause)
-                    // A protocol exception has been detected by a task. This means, that the
-                    // connection must be restarted.
-                    is ProtocolException -> {
-                        logger.warn(
-                            "Task executor stopped. Restarting connection in {}ms.",
-                            reconnectDelayMs,
-                            cause
-                        )
-                        restartConnection()
-                    }
-                    // If the connection is lost after the last task has just completed successfully
-                    // or if a task has caught the network exception and decided to complete
-                    // successfully, then the executor job also completes successfully. Therefore,
-                    // the cause is null and the task runner will be started when a new connection
-                    // has been established.
-                    null -> logger.info("Task executor finished")
-                    // Any other exception means that the task manager is behaving faulty. In this
-                    // case we need to start the task manager again. This should never happen.
-                    else -> {
-                        logger.error("Task manager failed", cause)
-                        CoroutineScope(scheduleCoroutineContext).launch {
-                            startTaskRunner(layer5Codec, incomingMessageProcessor)
-                        }
-                    }
-                }
-            }
-        }
-
-        logger.info("Task runner started")
-        executorSemaphore.release()
-    }
-
-    @Deprecated("Do not use the task codec outside of a task")
-    internal fun getTaskCodec(): TaskCodec = taskCodec
-
-    /**
-     * Send an outbound message immediately. This method must only be used by the task manager to
-     * send messages that are required to be sent outside of a task. This functionality must not be
-     * provided to the rest of the application.
-     */
-    internal fun sendImmediately(outboundMessage: OutboundMessage) {
-        layer5Codec?.sendOutbound(outboundMessage)
-    }
-
-    /**
-     * Stop the task runner. Call this method only when the connection has been lost or a new
-     * connection has been established while the task runner is still running (should not happen).
-     */
-    internal suspend fun stopTaskRunner() {
-        layer5Codec = null
-
-        if (executorJob == null) {
-            logger.warn("Tried to stop task runner before starting it.")
-            return
-        }
-
-        logger.info("Stopping task runner")
-
-        executorJob?.cancelAndJoin(ConnectionStoppedException("The server connection has been ended"))
-        logger.info("Executor job canceled and joined")
-    }
-
-    private suspend fun runNextTask() {
-        val taskQueueElement = taskQueue.getNextTask()
-
-        var executionAttempts = 0
-        while (!taskQueueElement.isCompleted()) {
-            // As we are starting an attempt, we increase the amount of the execution attempts
-            executionAttempts++
-            // Invoke the task and catch any unexpected exception
-            try {
-                taskQueueElement.run(taskCodec)
-            } catch (exception: Exception) {
-                when (exception) {
-                    is NetworkException -> throw exception
-                    else -> {
-                        logger.error(
-                            "Error occurred on attempt $executionAttempts when running task",
-                            exception
-                        )
-                        // If we had an unexpected exception, we check if we have a retry left. If
-                        // we don't, we complete the completable deferred exceptionally which ends
-                        // the loop and notifies the task scheduler that it has failed.
-                        if (executionAttempts >= taskQueueElement.maximumNumberOfExecutions) {
-                            logger.error("Maximum number of retries reached. Task is completed exceptionally.")
-                            taskQueueElement.completeExceptionally(exception)
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private fun restartConnection() {
-        layer5Codec?.let {
-            // Run reconnect runnable
-            it.restartConnection(reconnectDelayMs)
-
-            // Increase reconnect delay
-            reconnectDelayMs = min(reconnectDelayMs * 2, RECONNECT_MAX_DELAY_MS)
-        }
-    }
-
-    companion object {
-        // The initial delay for reconnections are 2 seconds
-        private const val RECONNECT_MIN_DELAY_MS = 2_000L
-
-        // The maximum delay until a reconnection is triggered is 512 seconds (~8.5 minutes)
-        private const val RECONNECT_MAX_DELAY_MS = 512_000L
-    }
-
-}
-
-/**
- * This is a special exception, which means that there are problems with the server connection.
- * Tasks should only catch this exception if they can continue without server connection. If all
- * other exceptions ought to be caught, [catchAllExceptNetworkException] can be used.
- */
-sealed class NetworkException(message: String) : CancellationException(message)
-
-/**
- * This exception is only thrown by the task manager, when a new connection is being established or
- * the current connection has been stopped or lost. Tasks may catch this exception, if they can
- * continue without server connection.
- */
-class ConnectionStoppedException internal constructor(message: String) : NetworkException(message) {
-
-    /**
-     * Note that this constructor should only be used in tests.
-     */
-    constructor() : this("Test")
-}
-
-/**
- * This exception must be thrown by tasks to enforce a reconnection to the server. The tasks are
- * retried when the connection is back. When this exception is thrown, it may indicate that there is
- * no connection (e.g. directory server unreachable), or an unexpected message has been received.
- */
-class ProtocolException(message: String) : NetworkException(message)
-
-/**
- * Runs this code and catches all exceptions except [NetworkException]. This method is intended to
- * be used within tasks where [NetworkException]s must not be caught.
- */
-suspend inline fun <R, reified T> (suspend () -> R).catchExceptNetworkException(then: (e: T) -> R): R {
-    return try {
-        this()
-    } catch (e: Exception) {
-        when (e) {
-            is NetworkException -> throw e
-            is T -> then(e)
-            else -> throw e
-        }
-    }
-}
-
-/**
- * Runs this code and catches all exceptions except [NetworkException]. This method is intended to
- * be used within tasks where [NetworkException]s must not be caught.
- */
-inline fun <R> (() -> R).catchAllExceptNetworkException(then: (e: Exception) -> R): R {
-    return try {
-        this()
-    } catch (e: Exception) {
-        when (e) {
-            is NetworkException -> throw e
-            else -> then(e)
-        }
-    }
-}
-
-/**
- * Runs this code and catches all exceptions except [NetworkException]. This method is intended to
- * be used within tasks where [NetworkException]s must not be caught.
- */
-suspend inline fun <R> (suspend () -> R).catchAllExceptNetworkException(then: (e: Exception) -> R): R {
-    return try {
-        this()
-    } catch (e: Exception) {
-        when (e) {
-            is NetworkException -> throw e
-            else -> then(e)
-        }
-    }
-}
-
-/**
- * The message filter instruction is used by tasks to specify if they need a certain message (e.g.
- * an outgoing message ack) or if it is not related to the task.
- */
-enum class MessageFilterInstruction {
-
-    /**
-     * Bypass or backlog message depending on type:
-     *
-     * d2d messages: process them directly (bypass)
-     * csp messages: keep them in order, but do not yet process them (backlog)
-     */
-    BYPASS_OR_BACKLOG,
-
-    /**
-     * This is the message that is expected by the task. This message should be removed from the
-     * queue. The message is handled directly in the calling task.
-     */
-    ACCEPT,
-
-    /**
-     * Reject the message. TODO(ANDR-2475): handle this correctly
-     */
-    REJECT,
-}
-
-internal data class ReadMessageResult(
-    val bypassMessages: List<TaskQueue.TaskQueueElement>,
-    val readMessage: InboundMessage,
-)
-
-private suspend fun Job.cancelAndJoin(networkException: NetworkException) {
-    cancel(networkException)
-    return join()
-}
diff --git a/domain/src/main/java/ch/threema/domain/taskmanager/codec.kt b/domain/src/main/java/ch/threema/domain/taskmanager/codec.kt
deleted file mode 100644
index 4e649225..00000000
--- a/domain/src/main/java/ch/threema/domain/taskmanager/codec.kt
+++ /dev/null
@@ -1,96 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-import ch.threema.domain.protocol.csp.ProtocolDefines
-
-/**
- * A passive task codec is used to retrieve messages from the server. To send messages we need an
- * [ActiveTaskCodec].
- */
-sealed interface PassiveTaskCodec {
-
-    /**
-     * Wait for a message by the server. All messages that are received by the server are checked
-     * with the given [preProcess] argument. The message where the preprocessor returns
-     * [MessageFilterInstruction.ACCEPT] will be returned for potential further processing. For
-     * messages that are not needed by the current task, the preprocessor should return
-     * [MessageFilterInstruction.BYPASS_OR_BACKLOG]. Messages that should be rejected at this point,
-     * should result in [MessageFilterInstruction.REJECT].
-     */
-    suspend fun read(preProcess: (InboundMessage) -> MessageFilterInstruction): InboundMessage
-}
-
-/**
- * An active task codec can be used to retrieve, send, and reflect messages from and to the server.
- */
-sealed interface ActiveTaskCodec : PassiveTaskCodec {
-
-    /**
-     * Write a message to the server. If the connection is lost, this suspends. Note that there is
-     * no guarantee that a message has been sent to the server if this method returns successfully.
-     */
-    suspend fun write(message: OutboundMessage)
-
-    /**
-     * Reflect the given message.
-     */
-    suspend fun reflect(message: OutboundMessage)
-}
-
-interface TaskCodec : ActiveTaskCodec
-
-private val logger = LoggingUtil.getThreemaLogger("TaskCodec")
-
-suspend fun PassiveTaskCodec.waitForServerAck(
-    messageId: MessageId,
-    recipientIdentity: String,
-) {
-    read { inboundMessage ->
-        return@read when (inboundMessage.payloadType.toInt()) {
-            ProtocolDefines.PLTYPE_OUTGOING_MESSAGE_ACK -> {
-                val ack = (inboundMessage as CspMessage).toOutgoingMessageAck()
-
-                logger.debug(
-                    "Checking message ack for message {} to {}",
-                    ack.messageId,
-                    ack.recipient
-                )
-
-                if (ack.messageId == messageId && ack.recipient == recipientIdentity) {
-                    MessageFilterInstruction.ACCEPT
-                } else {
-                    MessageFilterInstruction.BYPASS_OR_BACKLOG
-                }
-            }
-
-            else -> {
-                MessageFilterInstruction.BYPASS_OR_BACKLOG
-            }
-        }
-    }
-}
diff --git a/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.java b/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.java
deleted file mode 100644
index aafa51bd..00000000
--- a/domain/src/test/java/ch/threema/base/crypto/NonceFactoryTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.crypto;
-import static org.mockito.Mockito.*;
-
-import ch.threema.base.ThreemaException;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.security.SecureRandom;
-
-public class NonceFactoryTest {
-
-	// Hack to "Mock" the Secure Random
-	private class SecureRandomMocken extends SecureRandom {
-		private byte[][] next;
-		private int nextPos = 0;
-
-		public void nextNonces(byte[]... next) {
-			this.next = next;
-		}
-
-		@Override
-		public void nextBytes(byte[] bytes) {
-			// Check length
-			Assert.assertEquals(bytes.length, 24);
-
-			if (this.next != null && this.nextPos < this.next.length) {
-				for(int n = 0; n < bytes.length; n++) {
-					bytes[n] = this.next[this.nextPos][n];
-				}
-				this.nextPos++;
-				return;
-			}
-
-			super.nextBytes(bytes);
-		}
-	}
-
-	@Test
-	public void testNext() throws Exception {
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-		SecureRandomMocken secureRandomMock = new SecureRandomMocken();
-
-		// Store always return true
-		when(nonceStoreMock.store(any())).thenReturn(true);
-
-		NonceFactory factory = new NonceFactory(secureRandomMock, nonceStoreMock);
-		byte[] result = factory.next();
-
-		// Check if store is called
-		verify(nonceStoreMock, times(1)).store(any());
-
-		// Verify the result
-		Assert.assertEquals(24, result.length);
-	}
-
-	@Test
-	public void testNext2Times() throws Exception {
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-		SecureRandomMocken secureRandomMock = new SecureRandomMocken();
-
-		byte[] existingNonce = new byte[]{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01};
-
-		byte[] newNonce = new byte[]{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x02};
-
-		// Store always return true
-		when(nonceStoreMock.store(eq(existingNonce))).thenReturn(false);
-		when(nonceStoreMock.store(eq(newNonce))).thenReturn(true);
-
-		NonceFactory factory = new NonceFactory(secureRandomMock, nonceStoreMock);
-		secureRandomMock.nextNonces(existingNonce, newNonce);
-		byte[] result = factory.next();
-
-		// Check if store is called twice
-		verify(nonceStoreMock, times(2)).store(any());
-
-		// Verify the result
-		Assert.assertEquals(24, result.length);
-	}
-
-	@Test
-	public void testNextWithoutStore() throws Exception {
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-
-		NonceFactory factory = new NonceFactory(new SecureRandom(), nonceStoreMock);
-		factory.next(false);
-
-		verify(nonceStoreMock, never()).store(any());
-	}
-
-	@Test
-	public void textNextWithoutStore() throws Exception {
-		byte[] existingNonce = new byte[]{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
-				0x01,0x01,0x01,0x01};
-
-		NonceStore nonceStoreMock = mock(NonceStore.class);
-		when(nonceStoreMock.exists(eq(existingNonce))).thenReturn(true);
-		NonceFactory factory = new NonceFactory(new SecureRandom(), nonceStoreMock);
-		Assert.assertTrue(factory.exists(existingNonce));
-
-
-		when(nonceStoreMock.exists(eq(existingNonce))).thenReturn(false);
-		Assert.assertFalse(factory.exists(existingNonce));
-	}
-
-}
diff --git a/domain/src/test/java/ch/threema/base/utils/UnsignedHelperTest.java b/domain/src/test/java/ch/threema/base/utils/UnsignedHelperTest.java
deleted file mode 100644
index b731f6ec..00000000
--- a/domain/src/test/java/ch/threema/base/utils/UnsignedHelperTest.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2020-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.base.utils;
-
-import org.junit.Assert;
-import org.junit.Test;
-
-import java.math.BigInteger;
-import java.util.Random;
-
-import ch.threema.base.utils.UnsignedHelper;
-
-public class UnsignedHelperTest {
-	@Test
-	public void testGetUnsignedInt() {
-		Assert.assertEquals(0L, UnsignedHelper.getUnsignedInt(0));
-		Assert.assertEquals(1L, UnsignedHelper.getUnsignedInt(1));
-		Assert.assertEquals((1L<<15)-1, UnsignedHelper.getUnsignedInt(32767));
-		Assert.assertEquals((1L<<31)-1, UnsignedHelper.getUnsignedInt(2147483647));
-		Assert.assertEquals((1L<<32)-1, UnsignedHelper.getUnsignedInt(-1));
-		Assert.assertEquals((1L<<31), UnsignedHelper.getUnsignedInt(-2147483648));
-	}
-
-	@Test
-	public void testGetUnsignedIntNeverNegative() {
-		final Random random = new Random();
-		for (int i = 0; i < 10000; i++) {
-			Assert.assertTrue(UnsignedHelper.getUnsignedInt(random.nextInt()) >= 0);
-		}
-	}
-
-	@Test
-	public void testUnsignedLongToBigInteger() {
-		final BigInteger bigInteger = new BigInteger("18446744073709551610");
-		final long unsignedLong = bigInteger.longValue();
-		Assert.assertTrue(unsignedLong < 0);
-		final BigInteger bigInteger2 = UnsignedHelper.unsignedLongToBigInteger(unsignedLong);
-		Assert.assertEquals(bigInteger, bigInteger2);
-	}
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt b/domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt
deleted file mode 100644
index efe7d263..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/connection/ConnectionTestUtils.kt
+++ /dev/null
@@ -1,204 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import ch.threema.domain.protocol.ServerAddressProvider
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-import ch.threema.domain.protocol.connection.csp.socket.ChatServerAddressProvider
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.stores.IdentityStoreInterface
-import com.neilalexander.jnacl.NaCl
-import java.io.InputStream
-import java.io.OutputStream
-import java.io.PipedInputStream
-import java.io.PipedOutputStream
-import java.net.InetSocketAddress
-import java.net.Socket
-import java.net.SocketAddress
-
-internal class TestIdentityStore : IdentityStoreInterface {
-    companion object {
-        const val CLIENT_IDENTITY = "ABCD1234"
-        val ckPublic = ByteArray(NaCl.PUBLICKEYBYTES)
-        val ckSecret = ByteArray(NaCl.SECRETKEYBYTES)
-
-        private val cache: MutableMap<ByteArray, NaCl> = mutableMapOf()
-
-        fun getFromCache(publicKey: ByteArray): NaCl = cache
-            .computeIfAbsent(publicKey) { NaCl(ckSecret, it) }
-    }
-
-    override fun encryptData(plaintext: ByteArray, nonce: ByteArray, receiverPublicKey: ByteArray): ByteArray {
-        return getFromCache(receiverPublicKey).encrypt(plaintext, nonce)
-    }
-
-    override fun decryptData(ciphertext: ByteArray, nonce: ByteArray, senderPublicKey: ByteArray): ByteArray {
-        return getFromCache(senderPublicKey).decrypt(ciphertext, nonce)
-    }
-
-    override fun calcSharedSecret(publicKey: ByteArray): ByteArray {
-        return getFromCache(publicKey).precomputed
-    }
-
-    override fun getIdentity(): String {
-        return CLIENT_IDENTITY
-    }
-
-    override fun getServerGroup(): String {
-        MUST_NOT_BE_CALLED()
-    }
-
-    override fun getPublicKey(): ByteArray = ckPublic
-
-    override fun getPrivateKey(): ByteArray = ckSecret
-
-    override fun getPublicNickname(): String = "Test"
-
-    override fun storeIdentity(identity: String, serverGroup: String, publicKey: ByteArray, privateKey: ByteArray) {
-        MUST_NOT_BE_CALLED()
-    }
-}
-internal class TestServerAddressProvider(
-    private val skPublic: ByteArray,
-    private val skPublicAlt: ByteArray,
-    private val mediatorUrl: String? = null
-) : ServerAddressProvider {
-    var keyFetchCount = 0
-    var altKeyFetchCount = 0
-
-    override fun getChatServerNamePrefix(ipv6: Boolean): String = "prefix"
-
-    override fun getChatServerNameSuffix(ipv6: Boolean): String = "suffix"
-
-    override fun getChatServerPorts(): IntArray = intArrayOf(1234)
-
-    override fun getChatServerUseServerGroups(): Boolean = false
-
-    override fun getChatServerPublicKey(): ByteArray {
-        keyFetchCount++
-        return skPublic
-    }
-
-    override fun getChatServerPublicKeyAlt(): ByteArray {
-        altKeyFetchCount++
-        return skPublicAlt
-    }
-
-    override fun getMediatorUrl(): String {
-        return mediatorUrl ?: MUST_NOT_BE_CALLED()
-    }
-
-    override fun getAppRatingUrl(): String {
-        MUST_NOT_BE_CALLED()
-    }
-
-    // The following methods should not be used by the connection
-    override fun getDirectoryServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getWorkServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getBlobServerDownloadUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getBlobServerDoneUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getBlobServerUploadUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getAvatarServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getSafeServerUrl(ipv6: Boolean): String { MUST_NOT_BE_CALLED() }
-    override fun getWebServerUrl(): String { MUST_NOT_BE_CALLED() }
-    override fun getWebOverrideSaltyRtcHost(): String { MUST_NOT_BE_CALLED() }
-    override fun getWebOverrideSaltyRtcPort(): Int { MUST_NOT_BE_CALLED() }
-    override fun getThreemaPushPublicKey(): ByteArray? { MUST_NOT_BE_CALLED() }
-
-}
-
-internal class TestSocket : Socket() {
-    private val outputPipe = PipedInputStream(UShort.MAX_VALUE.toInt() * 2)
-    private val outputStream = PipedOutputStream(outputPipe)
-
-    private val inputPipe = PipedOutputStream()
-    private val inputStream = PipedInputStream(inputPipe, UShort.MAX_VALUE.toInt() * 2)
-
-    var closed = false
-
-    fun read(length: Int): ByteArray {
-        return outputPipe.readNBytes(length)
-    }
-
-    fun write(bytes: ByteArray) {
-        inputPipe.write(bytes)
-        inputPipe.flush()
-    }
-
-    override fun connect(endpoint: SocketAddress?, timeout: Int) {}
-    override fun connect(endpoint: SocketAddress?) {}
-
-    override fun close() {
-        outputPipe.close()
-        outputStream.close()
-        inputPipe.close()
-        inputStream.close()
-        closed = true
-    }
-
-    override fun getInputStream(): InputStream = inputStream
-
-    override fun getOutputStream(): OutputStream = outputStream
-
-    override fun setSoTimeout(timeout: Int) {}
-}
-
-internal class TestChatServerAddressProvider : ChatServerAddressProvider {
-    private var updated = false
-    override fun advance() {
-        // No-op
-    }
-
-    override fun get(): InetSocketAddress? {
-        return if (updated) {
-            InetSocketAddress.createUnresolved("dummy", 4711)
-        } else {
-            null
-        }
-    }
-
-    override fun update() {
-        updated = true
-    }
-}
-
-internal class TestNoopDeviceCookieManager : DeviceCookieManager {
-    override fun obtainDeviceCookie() = ByteArray(16)
-    override fun changeIndicationReceived() { MUST_NOT_BE_CALLED() }
-    override fun deleteDeviceCookie() { MUST_NOT_BE_CALLED() }
-}
-
-@Suppress("TestFunctionName")
-internal fun MUST_NOT_BE_CALLED(): Nothing {
-    throw UnsupportedOperationException("This method must not be called")
-}
-
-fun getFromOutboundMessage(message: OutboundMessage): MessageBox? {
-    return try {
-        val cspMessage = message as CspMessage
-        MessageBox.parseBinary(cspMessage.toCspContainer().data)
-    } catch (e: Exception) {
-        throw AssertionError("Could not parse csp message: " + e.message)
-    }
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt b/domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt
deleted file mode 100644
index a60486b3..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/connection/CspConnectionTest.kt
+++ /dev/null
@@ -1,157 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import ch.threema.domain.protocol.Version
-import ch.threema.domain.protocol.connection.csp.CspConnectionConfiguration
-import ch.threema.domain.protocol.connection.csp.CspConnectionImpl
-import ch.threema.domain.protocol.connection.csp.CspControllers
-import ch.threema.domain.protocol.connection.csp.socket.CspSocket
-import ch.threema.domain.protocol.connection.csp.socket.SocketFactory
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import ch.threema.domain.protocol.connection.layer.AuthLayer
-import ch.threema.domain.protocol.connection.layer.CspFrameLayer
-import ch.threema.domain.protocol.connection.layer.EndToEndLayer
-import ch.threema.domain.protocol.connection.layer.Layer5Codec
-import ch.threema.domain.protocol.connection.layer.MonitoringLayer
-import ch.threema.domain.protocol.connection.layer.MultiplexLayer
-import ch.threema.domain.protocol.connection.layer.ServerConnectionLayers
-import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.InternalTaskManager
-import ch.threema.domain.taskmanager.QueueSendCompleteListener
-import ch.threema.domain.taskmanager.Task
-import ch.threema.domain.taskmanager.TaskArchiver
-import ch.threema.domain.taskmanager.TaskCodec
-import ch.threema.domain.taskmanager.TaskManager
-import ch.threema.domain.taskmanager.TaskManagerConfiguration
-import ch.threema.domain.taskmanager.TaskManagerProvider
-import ch.threema.domain.helpers.UnusedTaskCodec
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.Deferred
-
-internal class CspConnectionTest : ServerConnectionTest() {
-    override fun createChatServerConnection(): ServerConnection {
-        val configuration = createConfiguration()
-
-        val taskManager = object : TaskManager, InternalTaskManager {
-            override fun processInboundMessage(message: InboundMessage) {
-                // Nothing to do
-            }
-
-            override suspend fun startRunningTasks(layer5Codec: Layer5Codec, incomingMessageProcessor: IncomingMessageProcessor) {
-                // Nothing to do
-            }
-
-            override suspend fun pauseRunningTasks() {
-                // Nothing to do
-            }
-
-            override fun <R> schedule(task: Task<R, TaskCodec>): Deferred<R> = CompletableDeferred()
-
-            @Deprecated(
-                "We should only be able to send and receive messages from within tasks.",
-                replaceWith = ReplaceWith("TaskManager#schedule")
-            )
-            override fun getMigrationTaskHandle(): ActiveTaskCodec = UnusedTaskCodec()
-
-            override fun hasPendingTasks(): Boolean = false
-
-            override fun addQueueSendCompleteListener(listener: QueueSendCompleteListener) {
-                // Nothing to do
-            }
-
-            override fun removeQueueSendCompleteListener(listener: QueueSendCompleteListener) {
-                // Nothing to do
-            }
-        }
-
-        val dependencyProvider = ServerConnectionDependencyProvider {
-            val controllers = CspControllers(configuration)
-
-            val socket = CspSocket(
-                configuration.socketFactory,
-                TestChatServerAddressProvider(),
-                controllers.serverConnectionController.ioProcessingStoppedSignal,
-                controllers.serverConnectionController.dispatcher.coroutineContext
-            )
-
-            ServerConnectionDependencies(
-                controllers.mainController,
-                socket,
-                createConnectionLayers(it, controllers, configuration.incomingMessageProcessor, taskManager)
-            )
-        }
-
-        return CspConnectionImpl(dependencyProvider)
-    }
-
-    private fun createConfiguration(): CspConnectionConfiguration {
-        val incomingMessageProcessor = object : IncomingMessageProcessor {
-            override suspend fun processIncomingMessage(messageBox: MessageBox, handle: ActiveTaskCodec) { }
-            override fun processIncomingServerAlert(alertData: CspMessage.ServerAlertData) { }
-            override fun processIncomingServerError(errorData: CspMessage.ServerErrorData) { }
-        }
-        val taskManager = TaskManagerProvider.getTaskManager(TaskManagerConfiguration(
-            {
-                object : TaskArchiver {
-                    override fun addTask(task: Task<*, TaskCodec>) {}
-                    override fun removeTask(task: Task<*, TaskCodec>) {}
-                    override fun loadAllTasks(): List<Task<*, TaskCodec>> = emptyList()
-                }
-            },
-            TestNoopDeviceCookieManager(),
-            true
-        ))
-        return CspConnectionConfiguration(
-            TestIdentityStore(),
-            serverAddressProvider,
-            Version(),
-            assertDispatcherContext = true,
-            TestNoopDeviceCookieManager(),
-            incomingMessageProcessor,
-            taskManager,
-            { arrayOf() },
-            ipv6 = false,
-            createSocketFactory()
-        )
-    }
-
-    private fun createConnectionLayers(
-        connection: ServerConnection,
-        controllers: CspControllers,
-        incomingMessageProcessor: IncomingMessageProcessor,
-        taskManager: InternalTaskManager,
-    ): ServerConnectionLayers {
-        return ServerConnectionLayers(
-            CspFrameLayer(),
-            MultiplexLayer(controllers.serverConnectionController),
-            AuthLayer(controllers.layer3Controller),
-            MonitoringLayer(connection, controllers.layer4Controller),
-            EndToEndLayer(controllers.serverConnectionController.dispatcher.coroutineContext, controllers.serverConnectionController, connection, incomingMessageProcessor, taskManager)
-        )
-    }
-
-    private fun createSocketFactory() = SocketFactory { testSocket }
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/connection/ServerConnectionTest.kt b/domain/src/test/java/ch/threema/domain/protocol/connection/ServerConnectionTest.kt
deleted file mode 100644
index 9b862851..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/connection/ServerConnectionTest.kt
+++ /dev/null
@@ -1,238 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection
-
-import ch.threema.base.crypto.NonceCounter
-import ch.threema.base.crypto.ThreemaKDF
-import ch.threema.domain.protocol.ServerAddressProvider
-import com.neilalexander.jnacl.NaCl
-import org.junit.Assert
-import org.junit.Before
-import org.junit.Test
-import ove.crypto.digest.Blake2b
-import java.io.ByteArrayInputStream
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-import java.security.SecureRandom
-
-internal abstract class ServerConnectionTest {
-    private companion object {
-        private val skPublicPrimary = ByteArray(NaCl.PUBLICKEYBYTES)
-        private val skSecretPrimary = ByteArray(NaCl.SECRETKEYBYTES)
-        private val skPublicAlt = ByteArray(NaCl.PUBLICKEYBYTES)
-        private val skSecretAlt = ByteArray(NaCl.SECRETKEYBYTES)
-        private val random = SecureRandom()
-
-        init {
-            NaCl.genkeypair(skPublicPrimary, skSecretPrimary)
-            NaCl.genkeypair(skPublicAlt, skSecretAlt)
-            NaCl.genkeypair(TestIdentityStore.ckPublic, TestIdentityStore.ckSecret)
-        }
-    }
-
-    protected lateinit var testSocket: TestSocket
-    protected val serverAddressProvider = TestServerAddressProvider(skPublicPrimary, skPublicAlt)
-
-    private lateinit var skSecret: ByteArray
-    private lateinit var skPublic: ByteArray
-
-    private lateinit var tskSecret: ByteArray
-    private lateinit var tskPublic: ByteArray
-    private lateinit var sck: ByteArray
-    private lateinit var serverNonce: NonceCounter
-
-    private lateinit var tckPublic: ByteArray
-    private lateinit var cck: ByteArray
-    private lateinit var clientNonce: NonceCounter
-
-    private lateinit var kClientServer: NaCl
-
-    /**
-     * Create a [ServerConnection] which would be used to connect to the chatserver and uses [testSocket] as the server Socket.
-     * [serverAddressProvider] must be used as the [ServerAddressProvider].
-     */
-    abstract fun createChatServerConnection(): ServerConnection
-
-    @Before
-    @Throws(Exception::class)
-    fun setUp() {
-        testSocket = TestSocket()
-    }
-
-    @Test
-    fun `test initial connection state is DISCONNECTED`() {
-        val connection = createChatServerConnection()
-        Assert.assertEquals(ConnectionState.DISCONNECTED, connection.connectionState)
-    }
-
-    @Test(timeout = 1000L)
-    fun testChatServerConnection() {
-        prepareServerKeys(skPublicPrimary, skSecretPrimary)
-
-        val connection = createChatServerConnection()
-        val connectionStates = observeConnectionStates(connection)
-        connection.start()
-
-        assertHandshake()
-
-        // stop the connection
-        connection.stop()
-
-        // assert expected states
-        Assert.assertEquals(1, serverAddressProvider.keyFetchCount)
-        Assert.assertEquals(0, serverAddressProvider.altKeyFetchCount)
-        Assert.assertEquals(4, connectionStates.size)
-        Assert.assertEquals(ConnectionState.CONNECTING, connectionStates[0])
-        Assert.assertEquals(ConnectionState.CONNECTED, connectionStates[1])
-        Assert.assertEquals(ConnectionState.LOGGEDIN, connectionStates[2])
-        Assert.assertEquals(ConnectionState.DISCONNECTED, connectionStates[3])
-    }
-
-    @Test
-    fun testChatServerConnectionAltKey() {
-        prepareServerKeys(skPublicAlt, skSecretAlt)
-
-        val connection = createChatServerConnection()
-        val connectionStates = observeConnectionStates(connection)
-        connection.start()
-
-        assertHandshake()
-
-        // stop the connection
-        connection.stop()
-
-        // assert expected states
-        Assert.assertEquals(1, serverAddressProvider.keyFetchCount)
-        Assert.assertEquals(1, serverAddressProvider.altKeyFetchCount)
-        Assert.assertEquals(4, connectionStates.size)
-        Assert.assertEquals(ConnectionState.CONNECTING, connectionStates[0])
-        Assert.assertEquals(ConnectionState.CONNECTED, connectionStates[1])
-        Assert.assertEquals(ConnectionState.LOGGEDIN, connectionStates[2])
-        Assert.assertEquals(ConnectionState.DISCONNECTED, connectionStates[3])
-    }
-
-    private fun assertHandshake() {
-        expectClientHello()
-        sendServerHello()
-
-        expectClientLogin()
-        sendLoginAck()
-
-        // Wait some time until the connection has processed the reservedBox response
-        Thread.sleep(100)
-    }
-
-    private fun expectClientHello() {
-        tckPublic = testSocket.read(32)
-        cck = testSocket.read(16)
-        clientNonce = NonceCounter(cck)
-        kClientServer = NaCl(tskSecret, tckPublic)
-    }
-
-    private fun sendServerHello() {
-        val serverHelloNaCl = NaCl(skSecret, tckPublic)
-        val serverHello = serverHelloNaCl.encrypt(tskPublic + cck, serverNonce.nextNonce())
-        testSocket.write(sck + serverHello)
-    }
-
-    private fun expectClientLogin() {
-        val extensionLength = expectLoginBox()
-        expectExtensionBox(extensionLength)
-    }
-
-    private fun expectLoginBox(): Int {
-        // expect `login`
-        val loginBox = testSocket.read(144)
-        val loginBoxDecrypted = kClientServer.decrypt(loginBox, clientNonce.nextNonce())
-        Assert.assertNotNull(loginBoxDecrypted)
-        val decryptedLoginStream = ByteArrayInputStream(loginBoxDecrypted)
-
-        // read identity
-        val clientIdentity = decryptedLoginStream.readNBytes(8).decodeToString()
-        Assert.assertEquals(TestIdentityStore.CLIENT_IDENTITY, clientIdentity)
-
-        // read extension-indicator
-        val extensionIndicator = decryptedLoginStream.readNBytes(30).decodeToString()
-        Assert.assertEquals("threema-clever-extension-field", extensionIndicator)
-        val bb = ByteBuffer.wrap(decryptedLoginStream.readNBytes(2))
-        bb.order(ByteOrder.LITTLE_ENDIAN)
-        val extensionLength = bb.short.toUShort().toInt()
-
-        // read repeated sck
-        val repeatedSck = decryptedLoginStream.readNBytes(16)
-        Assert.assertArrayEquals(sck, repeatedSck)
-
-        // read reserved1
-        val reserved1 = decryptedLoginStream.readNBytes(24)
-        Assert.assertArrayEquals(ByteArray(24), reserved1)
-
-        // read vouch
-        val ss1 = NaCl(skSecret, TestIdentityStore.ckPublic).precomputed
-        val ss2 = NaCl(tskSecret, TestIdentityStore.ckPublic).precomputed
-        val vouchKey = ThreemaKDF("3ma-csp").deriveKey("v2", ss1 + ss2)
-        val expectedVouch = Blake2b.Mac.newInstance(vouchKey, 32).digest(sck + tckPublic)
-        val vouch = decryptedLoginStream.readNBytes(32)
-        Assert.assertArrayEquals(expectedVouch, vouch)
-
-        // read reserved2
-        val reserved2 = decryptedLoginStream.readNBytes(16)
-        Assert.assertArrayEquals(ByteArray(16), reserved2)
-
-        // assert login data consumed
-        Assert.assertEquals(0, decryptedLoginStream.available())
-
-        return extensionLength
-    }
-
-    private fun expectExtensionBox(length: Int) {
-        // read extension box
-        val extensionBox = testSocket.read(length)
-        val extensionBoxDecrypted = kClientServer.decrypt(extensionBox, clientNonce.nextNonce())
-        Assert.assertNotNull(extensionBoxDecrypted)
-    }
-
-    private fun sendLoginAck() {
-        val reservedBox = kClientServer.encrypt(ByteArray(16), serverNonce.nextNonce())
-        testSocket.write(reservedBox)
-    }
-
-    private fun prepareServerKeys(skPublic: ByteArray, skSecret: ByteArray) {
-        this.skPublic = skPublic
-        this.skSecret = skSecret
-        sck = ByteArray(16)
-        random.nextBytes(sck)
-        tskPublic = ByteArray(NaCl.PUBLICKEYBYTES)
-        tskSecret = ByteArray(NaCl.SECRETKEYBYTES)
-        NaCl.genkeypair(tskPublic, tskSecret)
-        serverNonce = NonceCounter(sck)
-    }
-
-    /**
-     * Prepare the connection to collect the different connection states during the test and return a list of these states which
-     * can be evaluated at the end of the test.
-     */
-    private fun observeConnectionStates(connection: ServerConnection): List<ConnectionState> {
-        val connectionStates = mutableListOf<ConnectionState>()
-        connection.addConnectionStateListener { connectionState -> connectionStates.add(connectionState) }
-        return connectionStates
-    }
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/connection/layer/MultiplexLayerTest.kt b/domain/src/test/java/ch/threema/domain/protocol/connection/layer/MultiplexLayerTest.kt
deleted file mode 100644
index 7a103433..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/connection/layer/MultiplexLayerTest.kt
+++ /dev/null
@@ -1,250 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.layer
-
-import ch.threema.domain.protocol.connection.InputPipe
-import ch.threema.domain.protocol.connection.PipeHandler
-import ch.threema.domain.protocol.connection.ServerConnectionDispatcher
-import ch.threema.domain.protocol.connection.csp.CspSessionState
-import ch.threema.domain.protocol.connection.data.CspData
-import ch.threema.domain.protocol.connection.data.CspFrame
-import ch.threema.domain.protocol.connection.data.CspLoginMessage
-import ch.threema.domain.protocol.connection.data.InboundL1Message
-import ch.threema.domain.protocol.connection.data.InboundL2Message
-import ch.threema.domain.protocol.connection.data.OutboundL2Message
-import ch.threema.domain.protocol.connection.data.OutboundL3Message
-import ch.threema.domain.protocol.connection.util.ServerConnectionController
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import org.junit.Assert.assertArrayEquals
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertTrue
-import org.junit.Test
-import org.mockito.Mockito
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-import kotlin.math.pow
-
-class MultiplexLayerTest {
-    @Test
-    fun `outbound packages exceeding the maximum allowed size must be ignored`() {
-        // Arrange
-        val controller = mockController()
-
-        val layer = MultiplexLayer(controller)
-
-        val source = InputPipe<OutboundL3Message>()
-        val handler = PipeHandlerHelper<OutboundL2Message>()
-
-        source.pipeThrough(layer.encoder).setHandler(handler)
-
-        // Act
-        // Maximum allowed frame size is 8192
-        source.send(CspFrame(ByteArray(8193)))
-
-        // Assert
-        assertEquals(0, handler.messages.size)
-    }
-
-    @Test
-    fun `outbound CspLoginMessages must be processed`() {
-        // Arrange
-        val controller = mockController()
-
-        val layer = MultiplexLayer(controller)
-
-        val source = InputPipe<OutboundL3Message>()
-        val handler = PipeHandlerHelper<OutboundL2Message>()
-
-        source.pipeThrough(layer.encoder).setHandler(handler)
-
-        // Act & Assert
-
-        source.send(CspLoginMessage(ByteArray(1)))
-        source.send(CspLoginMessage(ByteArray(2)))
-        source.send(CspLoginMessage(ByteArray(4)))
-        source.send(CspLoginMessage(ByteArray(8)))
-        source.send(CspLoginMessage(ByteArray(16)))
-        source.send(CspLoginMessage(ByteArray(32)))
-        source.send(CspLoginMessage(ByteArray(64)))
-        source.send(CspLoginMessage(ByteArray(128)))
-        source.send(CspLoginMessage(ByteArray(256)))
-        source.send(CspLoginMessage(ByteArray(512)))
-        source.send(CspLoginMessage(ByteArray(1024)))
-        source.send(CspLoginMessage(ByteArray(2048)))
-        source.send(CspLoginMessage(ByteArray(4096)))
-        source.send(CspLoginMessage(ByteArray(8192)))
-
-        // Assert
-        assertEquals(14, handler.messages.size)
-        handler.messages.forEachIndexed { idx, msg ->
-            assertTrue(msg is CspData)
-            assertEquals(2.toDouble().pow(idx).toInt(), (msg as CspData).bytes.size)
-        }
-    }
-
-    @Test
-    fun `outbound CspFrames must be prepended with the size`() {
-        // Arrange
-        val controller = mockController()
-
-        val layer = MultiplexLayer(controller)
-
-        val source = InputPipe<OutboundL3Message>()
-        val handler = PipeHandlerHelper<OutboundL2Message>()
-
-        source.pipeThrough(layer.encoder).setHandler(handler)
-
-        // Act & Assert
-        source.send(CspFrame(ByteArray(1)))
-        source.send(CspFrame(ByteArray(2)))
-        source.send(CspFrame(ByteArray(4)))
-        source.send(CspFrame(ByteArray(8)))
-        source.send(CspFrame(ByteArray(16)))
-        source.send(CspFrame(ByteArray(32)))
-        source.send(CspFrame(ByteArray(64)))
-        source.send(CspFrame(ByteArray(128)))
-        source.send(CspFrame(ByteArray(256)))
-        source.send(CspFrame(ByteArray(512)))
-        source.send(CspFrame(ByteArray(1024)))
-        source.send(CspFrame(ByteArray(2048)))
-        source.send(CspFrame(ByteArray(4096)))
-        // Maximum allowed frame size is 8192 bytes
-        source.send(CspFrame(ByteArray(8192)))
-
-        // Assert
-        assertEquals(14, handler.messages.size)
-        handler.messages.forEachIndexed { idx, msg ->
-            assertTrue(msg is CspData)
-            val expectedDataLength = 2.toDouble().pow(idx).toInt()
-            val expectedFrameLength = expectedDataLength + 2 // 2 bytes for length prepended
-            val lengthBytes = ByteBuffer.wrap(ByteArray(2))
-                .order(ByteOrder.LITTLE_ENDIAN)
-                .putShort(expectedDataLength.toShort())
-                .array()
-            val msgBytes = (msg as CspData).bytes
-            assertArrayEquals(lengthBytes, msgBytes.copyOfRange(0, 2))
-            assertEquals(expectedFrameLength, msgBytes.size)
-        }
-    }
-
-    @Test
-    fun `inbound CspFrames with fewer than 20 bytes must be ignored`() {
-        // Arrange
-        val controller = mockController()
-        val cspSessionState = Mockito.mock(CspSessionState::class.java)
-        Mockito.`when`(controller.cspSessionState).thenReturn(cspSessionState)
-        Mockito.`when`(cspSessionState.isLoginDone).thenReturn(true)
-
-        val layer = MultiplexLayer(controller)
-
-        val source = InputPipe<InboundL1Message>()
-        val handler = PipeHandlerHelper<InboundL2Message>()
-
-        source.pipeThrough(layer.decoder).setHandler(handler)
-
-        (0..19).forEach {
-            source.send(CspData(ByteArray(it)))
-            assertEquals("Size: $it", 0, handler.messages.size)
-        }
-    }
-
-    @Test
-    fun `inbound CspFrames with more than 19 bytes must be processed`() {
-        // Arrange
-        val controller = mockController()
-        val cspSessionState = Mockito.mock(CspSessionState::class.java)
-        Mockito.`when`(controller.cspSessionState).thenReturn(cspSessionState)
-        // login done; map to frames
-        Mockito.`when`(cspSessionState.isLoginDone).thenReturn(true)
-
-        val layer = MultiplexLayer(controller)
-
-        val source = InputPipe<InboundL1Message>()
-        val handler = PipeHandlerHelper<InboundL2Message>()
-
-        source.pipeThrough(layer.decoder).setHandler(handler)
-
-        val sizes = intArrayOf(20, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192)
-
-        sizes.forEach { size ->
-            val expectedBytes = ByteArray(size) { size.toByte() }
-            source.send(CspData(expectedBytes))
-        }
-        assertEquals(sizes.size, handler.messages.size)
-        handler.messages.forEachIndexed { idx, msg ->
-            val expectedSize = sizes[idx]
-
-            assertTrue(msg is CspFrame)
-            val frame = msg as CspFrame
-            assertEquals(expectedSize, frame.box.size)
-        }
-    }
-
-    @Test
-    fun `inbound CspLoginMessages must correctly be mapped`() {
-        // Arrange
-        val controller = mockController()
-        val cspSessionState = Mockito.mock(CspSessionState::class.java)
-        Mockito.`when`(controller.cspSessionState).thenReturn(cspSessionState)
-        // Login is not done, map to login messages
-        Mockito.`when`(cspSessionState.isLoginDone).thenReturn(false)
-
-        val layer = MultiplexLayer(controller)
-
-        val source = InputPipe<InboundL1Message>()
-        val handler = PipeHandlerHelper<InboundL2Message>()
-
-        source.pipeThrough(layer.decoder).setHandler(handler)
-
-        val sizes = intArrayOf(ProtocolDefines.SERVER_HELLO_LEN, ProtocolDefines.SERVER_LOGIN_ACK_LEN)
-
-        sizes.forEach { size ->
-            val expectedBytes = ByteArray(size) { size.toByte() }
-            source.send(CspData(expectedBytes))
-        }
-        assertEquals(sizes.size, handler.messages.size)
-        handler.messages.forEachIndexed { idx, msg ->
-            val expectedSize = sizes[idx]
-
-            assertTrue(msg is CspLoginMessage)
-            val loginMessage = msg as CspLoginMessage
-            assertEquals(expectedSize, loginMessage.bytes.size)
-        }
-    }
-
-    private fun mockController(): ServerConnectionController {
-        val controller = Mockito.mock(ServerConnectionController::class.java)
-        val dispatcher = Mockito.mock(ServerConnectionDispatcher::class.java)
-        Mockito.`when`(controller.dispatcher).thenReturn(dispatcher)
-        return controller
-    }
-}
-
-private class PipeHandlerHelper<T> : PipeHandler<T> {
-    private val _messages = mutableListOf<T>()
-
-    val messages: List<T> = _messages
-
-    override fun handle(msg: T) {
-        _messages.add(msg)
-    }
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/connection/socket/CspSocketTest.kt b/domain/src/test/java/ch/threema/domain/protocol/connection/socket/CspSocketTest.kt
deleted file mode 100644
index 25bad778..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/connection/socket/CspSocketTest.kt
+++ /dev/null
@@ -1,168 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.connection.socket
-
-import ch.threema.domain.protocol.connection.SingleThreadedServerConnectionDispatcher
-import ch.threema.domain.protocol.connection.TestChatServerAddressProvider
-import ch.threema.domain.protocol.connection.TestSocket
-import ch.threema.domain.protocol.connection.csp.socket.CspSocket
-import ch.threema.domain.protocol.connection.csp.socket.SocketFactory
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import kotlinx.coroutines.*
-import kotlinx.coroutines.test.runTest
-import org.junit.Assert.*
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.Timeout
-import java.nio.ByteBuffer
-import java.nio.ByteOrder
-
-// `runTest` requires opt-in for experimental api
-@OptIn(ExperimentalCoroutinesApi::class)
-class CspSocketTest {
-    private lateinit var testSocket: TestSocket
-
-    // /* in order to debug the tests the timeout should be disabled
-    @Rule
-    @JvmField
-    val timeout: Timeout = Timeout.seconds(5)
-    // */
-
-    @Before
-    fun setUp() {
-        testSocket = TestSocket()
-    }
-
-    @Test
-    fun testSocketCloseWithoutIoProcessing() = runTest {
-        val socket = createSocket()
-        assertFalse(testSocket.closed)
-        socket.connect()
-        withContext(Dispatchers.Default) { delay(200) }
-        socket.close(ServerSocketCloseReason("Close"))
-        assertTrue(testSocket.closed)
-    }
-
-    @Test
-    fun `test handling of handshake messages`() = test {
-        // The handshake messages from the server have a fixed length.
-        // Therefore the length is not prepended to the messages.
-        // Make sure they are processed as separate messages with the correct length
-        assertServerHello(it)
-        assertServerLoginAck(it)
-    }
-
-    @Test
-    fun `test correct handling of received frames with prepended length`() = test {
-        simulateServerLoginMessages(it)
-
-        // shortest valid message
-        testDataFrame(it, 20u)
-
-        // maximum allowed frame length according to protocol (8192)
-        testDataFrame(it, ProtocolDefines.MAX_PKT_LEN.toUShort())
-
-        // maximum length (with two bytes for length indication)
-        testDataFrame(it, 0xffffu)
-
-        testDataFrame(it, 0xffu) // 255u
-        testDataFrame(it, 0x100u) // 256u
-        testDataFrame(it, 0xff00u) // 65280
-    }
-
-    /**
-     * Set the receiving part of the socket to the logged in state
-     * by simulating server login messages.
-     */
-    private suspend fun simulateServerLoginMessages(socket: CspSocket) {
-        testSocket.write(ByteArray(ProtocolDefines.SERVER_HELLO_LEN))
-        receiveMessageAsync(socket).await()
-        testSocket.write(ByteArray(ProtocolDefines.SERVER_LOGIN_ACK_LEN))
-        receiveMessageAsync(socket).await()
-    }
-
-    private suspend fun testDataFrame(socket: CspSocket, length: UShort) {
-        val msg = receiveMessageAsync(socket)
-        testSocket.write(createFrame(length))
-
-        val expected = ByteArray(length.toInt()) { length.toByte() }
-        assertArrayEquals("Length: $length", expected, msg.await())
-    }
-
-    private suspend fun assertServerHello(socket: CspSocket) {
-        val serverHello = ByteArray(ProtocolDefines.SERVER_HELLO_LEN) { 0x1F }
-        val msg = receiveMessageAsync(socket)
-        testSocket.write(serverHello)
-        val bytes = msg.await()
-        assertArrayEquals(serverHello, bytes)
-    }
-
-    private suspend fun assertServerLoginAck(socket: CspSocket) {
-        val serverLoginAck = ByteArray(ProtocolDefines.SERVER_LOGIN_ACK_LEN) { 0x1F }
-        val msg = receiveMessageAsync(socket)
-        testSocket.write(serverLoginAck)
-        assertArrayEquals(serverLoginAck, msg.await())
-    }
-
-    private fun receiveMessageAsync(socket: CspSocket): Deferred<ByteArray?> {
-        val frame = CompletableDeferred<ByteArray>()
-        socket.source.setHandler { msg -> frame.complete(msg) }
-        return frame
-    }
-
-    private fun createFrame(length: UShort): ByteArray {
-        val lengthBytes = ByteBuffer.wrap(ByteArray(2))
-            .order(ByteOrder.LITTLE_ENDIAN)
-            .putShort(length.toShort())
-            .array()
-        val data = ByteArray(length.toInt()) { length.toByte() }
-        return lengthBytes + data
-    }
-
-    private fun test(testBody: suspend (CspSocket) -> Unit) = runTest {
-        val socket = createSocket()
-        assertFalse(testSocket.closed)
-        socket.connect()
-        launch(Dispatchers.Default) {
-            testBody(socket)
-            delay(100)
-            socket.close(ServerSocketCloseReason("Close"))
-            assertTrue(testSocket.closed)
-        }
-        // start processing io; the test will only complete _after_ this method returns
-        // which must happen, when the socket has been closed.
-        socket.processIo()
-    }
-
-    private fun createSocket(): CspSocket {
-        val socketFactory = SocketFactory { testSocket }
-        val addressProvider = TestChatServerAddressProvider()
-        val dispatcher = SingleThreadedServerConnectionDispatcher(true)
-        return CspSocket(
-            socketFactory,
-            addressProvider,
-            CompletableDeferred(),
-            dispatcher.coroutineContext
-        )
-    }
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java
index c8850437..cb7e0878 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MessageCoderTest.java
@@ -21,30 +21,96 @@
 
 package ch.threema.domain.protocol.csp.coders;
 
+import com.neilalexander.jnacl.NaCl;
+
+import androidx.annotation.NonNull;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
+import ch.threema.domain.helpers.InMemoryContactStore;
+import ch.threema.domain.helpers.InMemoryIdentityStore;
+import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.GroupId;
+import ch.threema.domain.models.MessageId;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.messages.AbstractMessage;
+import ch.threema.domain.protocol.csp.messages.BadMessageException;
+import ch.threema.domain.protocol.csp.messages.DeliveryReceiptMessage;
+import ch.threema.domain.protocol.csp.messages.GroupTextMessage;
+import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
+import ch.threema.domain.protocol.csp.messages.TextMessage;
+import ch.threema.domain.stores.ContactStore;
+import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.domain.testhelpers.TestHelpers;
 import ch.threema.domain.protocol.csp.messages.voip.*;
+
 import org.junit.Assert;
 import org.junit.Test;
 
+import static ch.threema.domain.testhelpers.TestHelpers.setMessageDefaultSenderAndReceiver;
+
 public class MessageCoderTest {
 
+	@NonNull
+	private final MessageCoder encoder;
+	@NonNull
+	private final MessageCoder decoder;
+
+	public MessageCoderTest() {
+		byte[] myPublicKey = new byte[NaCl.PUBLICKEYBYTES];
+		byte[] myPrivateKey = new byte[NaCl.SECRETKEYBYTES];
+		byte[] peerPublicKey = new byte[NaCl.PUBLICKEYBYTES];
+		byte[] peerPrivateKey = new byte[NaCl.SECRETKEYBYTES];
+
+		NaCl.genkeypair(myPublicKey, myPrivateKey);
+		NaCl.genkeypair(peerPublicKey, peerPrivateKey);
+
+		IdentityStoreInterface myIdentityStore = new InMemoryIdentityStore(
+			"01234567",
+			null,
+			myPrivateKey,
+			"Me"
+		);
+
+		IdentityStoreInterface peerIdentityStore = new InMemoryIdentityStore(
+			"0ABCDEFG",
+			null,
+			peerPrivateKey,
+			"Peer"
+		);
+
+		ContactStore myContactStore = new InMemoryContactStore();
+		myContactStore.addContact(new Contact("0ABCDEFG", peerPublicKey, VerificationLevel.UNVERIFIED));
+
+		ContactStore peerContactStore = new InMemoryContactStore();
+		peerContactStore.addContact(new Contact("01234567", myPublicKey, VerificationLevel.UNVERIFIED));
+
+		encoder = new MessageCoder(
+			myContactStore,
+			myIdentityStore
+		);
+
+		decoder = new MessageCoder(
+			peerContactStore,
+			peerIdentityStore
+		);
+	}
+
 	private MessageBox box(AbstractMessage msg) throws ThreemaException {
 		MessageCoder messageCoder = new MessageCoder(
 			TestHelpers.getNoopContactStore(),
 			TestHelpers.getNoopIdentityStore()
 		);
 		NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
-		byte[] nonce = nonceFactory.next(false);
-		return messageCoder.encode(msg, nonce, nonceFactory);
+		byte[] nonce = nonceFactory.nextNonce(NonceScope.CSP);
+		return messageCoder.encode(msg, nonce);
 	}
 
 	@Test
 	public void testVoipFlagsOffer() throws ThreemaException {
 		final VoipCallOfferMessage msg = new VoipCallOfferMessage();
-		msg.setToIdentity("TESTTEST");
+		setMessageDefaultSenderAndReceiver(msg);
 		final VoipCallOfferData offerData = new VoipCallOfferData();
 		final VoipCallOfferData.OfferData data = new VoipCallOfferData.OfferData()
 			.setSdp("testsdp")
@@ -59,12 +125,12 @@ public class MessageCoderTest {
 	@Test
 	public void testVoipFlagsAnswer() throws ThreemaException {
 		final VoipCallAnswerMessage msg = new VoipCallAnswerMessage();
-		msg.setToIdentity("TESTTEST");
 		final VoipCallAnswerData answerData = new VoipCallAnswerData()
 			.setAction(VoipCallAnswerData.Action.REJECT)
 			.setAnswerData(null)
 			.setRejectReason(VoipCallAnswerData.RejectReason.BUSY);
 		msg.setData(answerData);
+		setMessageDefaultSenderAndReceiver(msg);
 		final MessageBox boxed = this.box(msg);
 		// Flags: Voip + Push
 		Assert.assertEquals(0x20 | 0x01, boxed.getFlags());
@@ -73,13 +139,13 @@ public class MessageCoderTest {
 	@Test
 	public void testVoipFlagsCandidates() throws ThreemaException {
 		final VoipICECandidatesMessage msg = new VoipICECandidatesMessage();
-		msg.setToIdentity("TESTTEST");
 		final VoipICECandidatesData candidatesData = new VoipICECandidatesData()
 			.setCandidates(new VoipICECandidatesData.Candidate[]{
 				new VoipICECandidatesData.Candidate("testcandidate1", "testmid1", 42, "testufrag1"),
 				new VoipICECandidatesData.Candidate("testcandidate2", "testmid2", 23, "testufrag2"),
 			});
 		msg.setData(candidatesData);
+		setMessageDefaultSenderAndReceiver(msg);
 		final MessageBox boxed = this.box(msg);
 		// Flags: Voip + Push
 		Assert.assertEquals(0x20 | 0x01, boxed.getFlags());
@@ -88,11 +154,141 @@ public class MessageCoderTest {
 	@Test
 	public void testVoipFlagsHangup() throws ThreemaException {
 		final VoipCallHangupMessage msg = new VoipCallHangupMessage();
-		msg.setToIdentity("TESTTEST");
 		msg.setData(new VoipCallHangupData());
+		setMessageDefaultSenderAndReceiver(msg);
 		final MessageBox boxed = this.box(msg);
 		// Flags: Push only
 		Assert.assertEquals(0x01, boxed.getFlags());
 	}
 
+	@Test
+	public void testDeserializeTextMessage() throws MissingPublicKeyException, BadMessageException, ThreemaException {
+		TextMessage textMessage = new TextMessage();
+
+		setAndAssertText(textMessage, "Hello");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, ".");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, new String(Character.toChars(0x1F4A1)));
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "");
+		Assert.assertThrows(BadMessageException.class, () -> encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "a");
+		byte[] body = encode(textMessage).getBox();
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid offset
+			TextMessage.fromByteArray(body, body.length, body.length)
+		);
+
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid length
+			TextMessage.fromByteArray(body, 1, body.length)
+		);
+	}
+
+	private void setAndAssertText(@NonNull TextMessage message, @NonNull String text) {
+		message.setText(text);
+		Assert.assertEquals(text, message.getText());
+	}
+
+	@Test
+	public void testDeserializeGroupTextMessage() throws MissingPublicKeyException, BadMessageException, ThreemaException {
+		GroupTextMessage textMessage = new GroupTextMessage();
+		textMessage.setGroupCreator("01234567");
+		textMessage.setApiGroupId(new GroupId());
+
+		setAndAssertText(textMessage, "Hello");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, ".");
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, new String(Character.toChars(0x1F4A1)));
+		assertEqualMessage(textMessage, encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "");
+		Assert.assertThrows(BadMessageException.class, () -> encodeAndDecode(textMessage));
+
+		setAndAssertText(textMessage, "a");
+		byte[] body = encode(textMessage).getBox();
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid offset
+			GroupTextMessage.fromByteArray(body, body.length, body.length)
+		);
+
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid length
+			GroupTextMessage.fromByteArray(body, 1, body.length)
+		);
+	}
+
+	private void setAndAssertText(@NonNull GroupTextMessage message, @NonNull String text) {
+		message.setText(text);
+		Assert.assertEquals(text, message.getText());
+	}
+
+	@Test
+	public void testDeliveryReceiptMessage() throws MissingPublicKeyException, BadMessageException, ThreemaException {
+		DeliveryReceiptMessage deliveryReceiptMessage = new DeliveryReceiptMessage();
+
+		setAndAssertReceiptType(deliveryReceiptMessage, ProtocolDefines.MSGTYPE_DELIVERY_RECEIPT);
+		setAndAssertMessageIds(deliveryReceiptMessage, new MessageId[]{new MessageId()});
+		assertEqualMessage(deliveryReceiptMessage, encodeAndDecode(deliveryReceiptMessage));
+
+		setAndAssertMessageIds(deliveryReceiptMessage, new MessageId[]{});
+		Assert.assertThrows(BadMessageException.class, () -> encodeAndDecode(deliveryReceiptMessage));
+
+		setAndAssertMessageIds(deliveryReceiptMessage, new MessageId[]{
+			new MessageId(), new MessageId(), new MessageId(), new MessageId()
+		});
+		assertEqualMessage(deliveryReceiptMessage, encodeAndDecode(deliveryReceiptMessage));
+
+		MessageBox messageBox = encode(deliveryReceiptMessage);
+		byte[] invalidLengthBody = new byte[messageBox.getBox().length + 1];
+		Assert.assertThrows(BadMessageException.class, () -> DeliveryReceiptMessage.fromByteArray(invalidLengthBody, 1, invalidLengthBody.length - 1));
+
+		byte[] body = messageBox.getBox();
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid offset
+			TextMessage.fromByteArray(body, body.length, body.length)
+		);
+
+		Assert.assertThrows(BadMessageException.class, () ->
+			// Invalid length
+			TextMessage.fromByteArray(body, 1, body.length)
+		);
+	}
+
+	private void setAndAssertReceiptType(@NonNull DeliveryReceiptMessage message, int type) {
+		message.setReceiptType(type);
+		Assert.assertEquals(type, message.getType());
+	}
+
+	private void setAndAssertMessageIds(
+		@NonNull DeliveryReceiptMessage message,
+		@NonNull MessageId[] messageIds
+	) {
+		message.setReceiptMessageIds(messageIds);
+		Assert.assertArrayEquals(messageIds, message.getReceiptMessageIds());
+	}
+
+	private void assertEqualMessage(@NonNull AbstractMessage expected, @NonNull AbstractMessage actual) throws ThreemaException {
+		Assert.assertArrayEquals(expected.getBody(), actual.getBody());
+	}
+
+	private MessageBox encode(@NonNull AbstractMessage message) throws ThreemaException {
+		message.setToIdentity("0ABCDEFG");
+		message.setFromIdentity("01234567");
+		return encoder.encode(message, new byte[NaCl.NONCEBYTES]);
+	}
+
+	@NonNull
+	private AbstractMessage encodeAndDecode(@NonNull AbstractMessage message) throws ThreemaException, MissingPublicKeyException, BadMessageException {
+		return decoder.decode(encode(message));
+	}
+
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java
index d4726e8a..66ed07a0 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/coders/MetadataCoderTest.java
@@ -22,6 +22,7 @@
 package ch.threema.domain.protocol.csp.coders;
 
 import ch.threema.base.ThreemaException;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.base.utils.Utils;
 import ch.threema.domain.models.MessageId;
 import ch.threema.domain.testhelpers.TestHelpers;
@@ -47,7 +48,7 @@ public class MetadataCoderTest {
 	@Test
 	public void testEncodeDecode() throws ThreemaException, InvalidProtocolBufferException {
 
-		byte[] nonce = TestHelpers.getNoopNonceFactory().next();
+		byte[] nonce = TestHelpers.getNoopNonceFactory().nextNonce(NonceScope.CSP);
 		MessageId messageId = new MessageId();
 
 		Date createdAt = new Date();
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java
index 62ac93a8..1cf333b7 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/fs/ForwardSecurityMessageProcessorTest.java
@@ -28,17 +28,17 @@ import org.mockito.exceptions.base.MockitoException;
 import org.powermock.reflect.Whitebox;
 
 import java.lang.reflect.Field;
-import java.util.Collections;
 import java.util.Date;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Objects;
+import java.util.stream.Collectors;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
-import ch.threema.base.crypto.NonceStore;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.domain.fs.DHSession;
 import ch.threema.domain.fs.DHSessionId;
 import ch.threema.domain.fs.KDFRatchet;
@@ -95,12 +95,14 @@ import ch.threema.domain.stores.DHSessionStoreInterface;
 import ch.threema.domain.stores.DummyContactStore;
 import ch.threema.domain.stores.IdentityStoreInterface;
 import ch.threema.domain.taskmanager.ActiveTaskCodec;
+import ch.threema.domain.testhelpers.TestHelpers;
 import ch.threema.protobuf.csp.e2e.fs.Terminate;
 import ch.threema.protobuf.csp.e2e.fs.Version;
 import ch.threema.protobuf.csp.e2e.fs.VersionRange;
+import kotlin.Pair;
 
 import static ch.threema.domain.protocol.connection.ConnectionTestUtilsKt.getFromOutboundMessage;
-import static ch.threema.domain.taskmanager.OutgoingCspMessageUtilsKt.toCspMessage;
+import static ch.threema.domain.taskmanager.OutgoingCspMessageUtilsKt.toCspMessageJava;
 
 public class ForwardSecurityMessageProcessorTest {
 
@@ -122,23 +124,7 @@ public class ForwardSecurityMessageProcessorTest {
 
 	private final ActiveTaskCodec testCodec = new UnusedTaskCodec();
 
-	private final NonceFactory nonceFactory = new NonceFactory(new NonceStore() {
-		@Override
-		public boolean exists(@NonNull byte[] nonce) {
-			return false;
-		}
-
-		@Override
-		public boolean store(@NonNull byte[] nonce) {
-			return true;
-		}
-
-		@Override
-		@NonNull
-		public List<byte[]> getAllHashedNonces() {
-			return Collections.emptyList();
-		}
-	});
+	private final NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
 
 	private final ForwardSecurityStatusListener forwardSecurityStatusListener = new ForwardSecurityStatusListener() {
 		@Override
@@ -647,7 +633,7 @@ public class ForwardSecurityMessageProcessorTest {
 		Field appliedVersionField = ForwardSecurityDataMessage.class.getDeclaredField("offeredVersion");
 		appliedVersionField.setAccessible(true);
 		appliedVersionField.setInt(data, 0x01FF);
-		aliceContext.handle.writeAsync(toCspMessage(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory, nonceFactory.next(false)));
+		aliceContext.handle.writeAsync(toCspMessageJava(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory.nextNonce(NonceScope.CSP)));
 
 		// Now Bob processes the text message from Alice. This should not fail, even if the offered
 		// version is not known.
@@ -700,7 +686,7 @@ public class ForwardSecurityMessageProcessorTest {
 		Field appliedVersionField = ForwardSecurityDataMessage.class.getDeclaredField("appliedVersion");
 		appliedVersionField.setAccessible(true);
 		appliedVersionField.setInt(data, 0x0100);
-		aliceContext.handle.writeAsync(toCspMessage(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory, nonceFactory.next(false)));
+		aliceContext.handle.writeAsync(toCspMessageJava(message, aliceContext.identityStore, aliceContext.contactStore, nonceFactory.nextNonce(NonceScope.CSP)));
 
 		// Now Bob processes the text message from Alice. Note that the message should be rejected
 		// and therefore return an empty list.
@@ -799,7 +785,7 @@ public class ForwardSecurityMessageProcessorTest {
 		assertMessageNotEncapsulated(new VoipICECandidatesMessage(), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new DeliveryReceiptMessage(), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new TypingIndicatorMessage(), aliceContext, DummyUsers.BOB);
-		assertMessageNotEncapsulated(new SetProfilePictureMessage(), aliceContext, DummyUsers.BOB);
+		assertMessageNotEncapsulated(new SetProfilePictureMessage(new byte[0], 0, new byte[0]), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new DeleteProfilePictureMessage(), aliceContext, DummyUsers.BOB);
 		assertMessageNotEncapsulated(new ContactRequestProfilePictureMessage(), aliceContext, DummyUsers.BOB);
 	}
@@ -842,7 +828,7 @@ public class ForwardSecurityMessageProcessorTest {
 			new VoipICECandidatesMessage(),
 			new DeliveryReceiptMessage(),
 			new TypingIndicatorMessage(),
-			new SetProfilePictureMessage(),
+			new SetProfilePictureMessage(new byte[0], 0, new byte[0]),
 			new DeleteProfilePictureMessage(),
 			new ContactRequestProfilePictureMessage()
 		).forEach( fs1_1_message -> {
@@ -923,14 +909,16 @@ public class ForwardSecurityMessageProcessorTest {
 		// Set the (non-sense) group identity
 		textMessage.setGroupCreator(DummyUsers.ALICE.getIdentity());
 		textMessage.setApiGroupId(new GroupId(0));
-
-		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.makeMessage(
-			DummyUsers.getContactForUser(DummyUsers.BOB),
+		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(DummyUsers.BOB),
 			textMessage,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
 			aliceContext.handle
 		);
 
-		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages();
+		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		Assert.assertEquals(2, outgoingMessages.size());
 
 		// Assert that the first message is sent with FS
@@ -941,11 +929,10 @@ public class ForwardSecurityMessageProcessorTest {
 
 		for (AbstractMessage message : outgoingMessages) {
 			aliceContext.handle.writeAsync(
-				toCspMessage(message,
+				toCspMessageJava(message,
 					aliceContext.identityStore,
 					aliceContext.contactStore,
-					nonceFactory,
-					nonceFactory.next(false))
+					nonceFactory.nextNonce(NonceScope.CSP))
 			);
 		}
 
@@ -972,21 +959,23 @@ public class ForwardSecurityMessageProcessorTest {
 		textMessage.setText(ALICE_MESSAGE_2);
 		textMessage.setToIdentity(DummyUsers.BOB.getIdentity());
 
-		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.makeMessage(
-			DummyUsers.getContactForUser(DummyUsers.BOB),
+		ForwardSecurityEncryptionResult encryptionResult = aliceContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(DummyUsers.BOB),
 			textMessage,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
 			aliceContext.handle
 		);
 
-		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages();
+		List<AbstractMessage> outgoingMessages = encryptionResult.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		Assert.assertEquals(1, outgoingMessages.size());
 
 		aliceContext.handle.writeAsync(
-			toCspMessage(outgoingMessages.get(0),
+			toCspMessageJava(outgoingMessages.get(0),
 				aliceContext.identityStore,
 				aliceContext.contactStore,
-				nonceFactory,
-				nonceFactory.next(false))
+				nonceFactory.nextNonce(NonceScope.CSP))
 		);
 
 		TextMessage receivedMessage = (TextMessage) processOneReceivedMessage(
@@ -1404,7 +1393,7 @@ public class ForwardSecurityMessageProcessorTest {
 
 	private List<AbstractMessage> processReceivedMessages(ServerAckTaskCodec sourceHandle, UserContext recipientContext) throws BadMessageException, ThreemaException, MissingPublicKeyException {
 		List<AbstractMessage> decapsulatedMessages = new LinkedList<>();
-		while (sourceHandle.getOutboundMessages().size() > 0) {
+		while (!sourceHandle.getOutboundMessages().isEmpty()) {
 			AbstractMessage decapMsg = processOneReceivedMessage(sourceHandle, recipientContext, 0, false);
 			if (decapMsg != null) {
 				decapsulatedMessages.add(decapMsg);
@@ -1485,7 +1474,7 @@ public class ForwardSecurityMessageProcessorTest {
 	private AbstractMessage sendTextMessage(String text, UserContext senderContext, DummyUsers.User recipient) throws ThreemaException {
 		List<AbstractMessage> messages = makeEncapTextMessage(text, senderContext, recipient);
 		for (AbstractMessage message : messages) {
-			senderContext.handle.writeAsync(toCspMessage(message, senderContext.identityStore, senderContext.contactStore, nonceFactory, nonceFactory.next(false)));
+			senderContext.handle.writeAsync(toCspMessageJava(message, senderContext.identityStore, senderContext.contactStore, nonceFactory.nextNonce(NonceScope.CSP)));
 		}
 		return getEncapsulatedMessageFromOutgoingMessageList(messages);
 	}
@@ -1519,9 +1508,16 @@ public class ForwardSecurityMessageProcessorTest {
 		TextMessage textMessage = new TextMessage();
 		textMessage.setText(text);
 		textMessage.setToIdentity(recipient.getIdentity());
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(DummyUsers.getContactForUser(recipient), textMessage, senderContext.handle);
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
+			textMessage,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
+			senderContext.handle
+		);
 		senderContext.fsmp.commitSessionState(result);
-		List<AbstractMessage> outgoingMessages = result.getOutgoingMessages();
+		List<AbstractMessage> outgoingMessages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		for (AbstractMessage message : outgoingMessages) {
 			message.setToIdentity(recipient.getIdentity());
 		}
@@ -1540,13 +1536,16 @@ public class ForwardSecurityMessageProcessorTest {
 			// mocking usually only works for the empty message.
 			messageMock = message;
 		}
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(
-			DummyUsers.getContactForUser(recipient),
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
 			messageMock,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
 			senderContext.handle
 		);
 
-		List<AbstractMessage> messages = result.getOutgoingMessages();
+		List<AbstractMessage> messages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 
 		Assert.assertEquals(2, messages.size());
 		Assert.assertTrue(((ForwardSecurityEnvelopeMessage) messages.get(0)).getData() instanceof ForwardSecurityDataInit);
@@ -1554,9 +1553,16 @@ public class ForwardSecurityMessageProcessorTest {
 	}
 
 	private void assertNewSessionMessageNotEncapsulated(AbstractMessage message, UserContext senderContext, DummyUsers.User recipient) throws ThreemaException {
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(DummyUsers.getContactForUser(recipient), message, senderContext.handle);
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
+			message,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
+			senderContext.handle
+		);
 		senderContext.fsmp.commitSessionState(result);
-		List<AbstractMessage> messages = result.getOutgoingMessages();
+		List<AbstractMessage> messages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		// As the message type is not supported for the available forward security session, it is
 		// sent without being encapsulated. Therefore the message equals the original message.
 		Assert.assertEquals(2, messages.size());
@@ -1565,9 +1571,16 @@ public class ForwardSecurityMessageProcessorTest {
 	}
 
 	private void assertMessageNotEncapsulated(AbstractMessage message, UserContext senderContext, DummyUsers.User recipient) throws ThreemaException {
-		ForwardSecurityEncryptionResult result = senderContext.fsmp.makeMessage(DummyUsers.getContactForUser(recipient), message, senderContext.handle);
+		ForwardSecurityEncryptionResult result = senderContext.fsmp.runFsEncapsulationSteps(
+			DummyUsers.getBasicContactForUser(recipient),
+			message,
+			nonceFactory.nextNonce(NonceScope.CSP),
+			nonceFactory,
+			senderContext.handle
+		);
 		senderContext.fsmp.commitSessionState(result);
-		List<AbstractMessage> messages = result.getOutgoingMessages();
+		List<AbstractMessage> messages = result.getOutgoingMessages()
+			.stream().map(Pair::getFirst).collect(Collectors.toList());
 		// As the message type is not supported for the available forward security session, it is
 		// sent without being encapsulated. Therefore the message equals the original message.
 		// If the size does not match, then check that this method is used for existing and fresh
@@ -1609,7 +1622,7 @@ public class ForwardSecurityMessageProcessorTest {
 		Contact contact,
 		ForwardSecurityEnvelopeMessage msg,
 		ActiveTaskCodec handle
-	) throws BadMessageException, ThreemaException {
+	) throws ThreemaException, BadMessageException {
 		ForwardSecurityData data = msg.getData();
 		if (data instanceof ForwardSecurityDataInit) {
 			fsmp.processInit(contact, (ForwardSecurityDataInit) data, handle);
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java
deleted file mode 100644
index 60ff8f03..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/GroupDeleteProfilePictureMessageTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2018-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.csp.messages;
-
-import org.junit.Test;
-
-import ch.threema.domain.models.GroupId;
-
-public class GroupDeleteProfilePictureMessageTest {
-
-	@Test
-	public void testGetBody() throws Exception {
-		final GroupDeleteProfilePictureMessage msg = new GroupDeleteProfilePictureMessage();
-		msg.setGroupCreator("GRCREATE");
-		GroupId groupId = new GroupId();
-		msg.setApiGroupId(groupId);
-
-		org.junit.Assert.assertArrayEquals(
-			groupId.getGroupId(),
-			msg.getBody()
-		);
-	}
-
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java
index 353e796e..dba0f588 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/BallotVoteTest.java
@@ -22,75 +22,79 @@
 package ch.threema.domain.protocol.csp.messages.ballot;
 
 import ch.threema.domain.protocol.csp.messages.BadMessageException;
+
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.junit.Assert;
 import org.junit.Test;
 
 public class BallotVoteTest {
-	class BallotVotString extends BallotVote {
-		@Override
-		public String toString() {
-			try {
-				return this.generateString();
-			} catch (BadMessageException e) {
-				return "ERROR " + e.getMessage();
-			}
-		}
-	}
 
-	@Test
-	public void parseValidString() {
-		String correct = "[10,1]";
+    static class BallotVoteString extends BallotVote {
+
+        public BallotVoteString(int id, int value) {
+            super(id, value);
+        }
+
+        @Override
+        public String toString() {
+            try {
+                return this.generateString();
+            } catch (BadMessageException e) {
+                return "ERROR " + e.getMessage();
+            }
+        }
+    }
 
-		try {
-			Assert.assertNotNull(BallotVote.parse(new JSONArray(correct)));
-		} catch (Exception e) {
-			Assert.fail(e.getMessage());
-		}
-	}
+    @Test
+    public void parseValidString() {
+        String correct = "[10,1]";
 
-	@Test
-	public void parseInvalidType() {
-		String correct = "[\"a\",\"b\"]";
+        try {
+            Assert.assertNotNull(BallotVote.parse(new JSONArray(correct)));
+        } catch (Exception e) {
+            Assert.fail(e.getMessage());
+        }
+    }
 
-		try {
-			try {
-				BallotVote.parse(new JSONArray(correct));
-			} catch (JSONException e) {
-				e.printStackTrace();
-			}
-			Assert.fail("wrong type parsed");
-		} catch (BadMessageException e) {
-			//cool!
-		}
-	}
+    @Test
+    public void parseInvalidType() {
+        String correct = "[\"a\",\"b\"]";
 
-	@Test
-	public void parseInvalidString() {
-		try {
-			BallotDataChoice.parse("i want to be a hippie");
-			Assert.fail("invalid string parsed");
-		} catch (BadMessageException e) {
-			//ok! exception received
-		}
-	}
+        try {
+            try {
+                BallotVote.parse(new JSONArray(correct));
+            } catch (JSONException e) {
+                e.printStackTrace();
+            }
+            Assert.fail("wrong type parsed");
+        } catch (BadMessageException e) {
+            //cool!
+        }
+    }
 
-	@Test
-	public void toStringTest() {
-		BallotVote v = new BallotVotString();
-		v.setId(100);
-		v.setValue(1);
+    @Test
+    public void parseInvalidString() {
+        try {
+            BallotDataChoice.parse("i want to be a hippie");
+            Assert.fail("invalid string parsed");
+        } catch (BadMessageException e) {
+            //ok! exception received
+        }
+    }
 
-		try {
-			JSONArray o = new JSONArray("[100, 1]");
-			Assert.assertEquals(
-					o.toString(),
-					v.toString()
-			);
-		} catch (JSONException e) {
-			Assert.fail("internal error");
-		}
+    @Test
+    public void toStringTest() {
+        BallotVote v = new BallotVoteString(100, 1);
 
-	}
+        try {
+            JSONArray o = new JSONArray("[100, 1]");
+            Assert.assertEquals(
+                o.toString(),
+                v.toString()
+            );
+        } catch (JSONException e) {
+            Assert.fail("internal error");
+        }
+    }
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java
index 9e971a23..9687cd53 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/ballot/ProtocolTest.java
@@ -26,6 +26,7 @@ import org.junit.Test;
 
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
 import ch.threema.domain.protocol.csp.coders.MessageBox;
@@ -42,7 +43,7 @@ public class ProtocolTest {
 	@Test
 	public void groupTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
 		//create a new ballot
-		final String myIdentity = "TESTTST";
+		final String myIdentity = "TESTTEST";
 		final String toIdentity = "ABCDEFGH";
 
 		BallotId ballotId = new BallotId(new byte[ProtocolDefines.BALLOT_ID_LEN]);
@@ -57,7 +58,7 @@ public class ProtocolTest {
 		b.setApiGroupId(groupId);
 		b.setGroupCreator(groupCreator);
 		b.setBallotId(ballotId);
-		b.setBallotCreator(ballotCreator);
+		b.setBallotCreatorIdentity(ballotCreator);
 		BallotData data = new BallotData();
 		data.setDescription("Test Ballot");
 		data.setType(BallotData.Type.RESULT_ON_CLOSE);
@@ -75,14 +76,14 @@ public class ProtocolTest {
 			c.setTotalVotes(2);
 			data.getChoiceList().add(c);
 		}
-		b.setData(data);
+		b.setBallotData(data);
 
 		ContactStore contactStore = TestHelpers.getNoopContactStore();
 		IdentityStoreInterface identityStore = TestHelpers.getNoopIdentityStore();
 		NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
 		MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
 
-		MessageBox boxmsg = messageCoder.encode(b, nonceFactory.next(false), nonceFactory);
+		MessageBox boxmsg = messageCoder.encode(b, nonceFactory.nextNonce(NonceScope.CSP));
 		Assert.assertNotNull("BoxMessage failed", boxmsg);
 
 		//now decode again
@@ -92,34 +93,33 @@ public class ProtocolTest {
 
 		GroupPollSetupMessage db = (GroupPollSetupMessage) decodedBoxMessage;
 
-		BallotData d = db.getData();
+		BallotData d = db.getBallotData();
 		Assert.assertNotNull(d);
 
 		Assert.assertEquals(BallotData.State.OPEN,  d.getState());
 		Assert.assertEquals(BallotData.AssessmentType.SINGLE, d.getAssessmentType());
 		Assert.assertEquals(BallotData.Type.RESULT_ON_CLOSE, d.getType());
-		Assert.assertEquals(10, b.getData().getChoiceList().size());
-		Assert.assertEquals("Choice 7", b.getData().getChoiceList().get(6).getName());
-		Assert.assertEquals(1, (int) b.getData().getChoiceList().get(2).getResult(0));
-		Assert.assertEquals(0, (int) b.getData().getChoiceList().get(2).getResult(1));
+		Assert.assertEquals(10, b.getBallotData().getChoiceList().size());
+		Assert.assertEquals("Choice 7", b.getBallotData().getChoiceList().get(6).getName());
+		Assert.assertEquals(1, (int) b.getBallotData().getChoiceList().get(2).getResult(0));
+		Assert.assertEquals(0, (int) b.getBallotData().getChoiceList().get(2).getResult(1));
 	}
 
 
 	@Test
 	public void identityTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
 		//create a new ballot
-		final String myIdentity = "TESTTST";
+		final String myIdentity = "TESTTEST";
 		final String toIdentity = "ABCDEFGH";
 
 		BallotId ballotId = new BallotId(new byte[ProtocolDefines.BALLOT_ID_LEN]);
 		String ballotCreator = toIdentity;
 
-
-		PollSetupMessage b = new PollSetupMessage();
-		b.setFromIdentity(ballotCreator);
-		b.setToIdentity(myIdentity);
-		b.setBallotId(ballotId);
-		b.setBallotCreator(ballotCreator);
+		PollSetupMessage pollSetupMessage = new PollSetupMessage();
+		pollSetupMessage.setFromIdentity(ballotCreator);
+		pollSetupMessage.setToIdentity(myIdentity);
+		pollSetupMessage.setBallotId(ballotId);
+		pollSetupMessage.setBallotCreatorIdentity(ballotCreator);
 		BallotData data = new BallotData();
 		data.setDescription("Test Ballot");
 		data.setType(BallotData.Type.RESULT_ON_CLOSE);
@@ -135,7 +135,7 @@ public class ProtocolTest {
 			c.addResult(0, 1).addResult(1,0);
 			data.getChoiceList().add(c);
 		}
-		b.setData(data);
+		pollSetupMessage.setBallotData(data);
 
 		ContactStore contactStore = TestHelpers.getNoopContactStore();
 		IdentityStoreInterface identityStore = TestHelpers.getNoopIdentityStore();
@@ -143,7 +143,7 @@ public class ProtocolTest {
 
 		NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
 
-		MessageBox boxmsg = messageCoder.encode(b, nonceFactory.next(false), nonceFactory);
+		MessageBox boxmsg = messageCoder.encode(pollSetupMessage, nonceFactory.nextNonce(NonceScope.CSP));
 		Assert.assertNotNull("BoxMessage failed", boxmsg);
 
 		//now decode again
@@ -153,15 +153,15 @@ public class ProtocolTest {
 
 		PollSetupMessage db = (PollSetupMessage) decodedBoxMessage;
 
-		BallotData d = db.getData();
-		Assert.assertNotNull(d);
+		BallotData ballotData = db.getBallotData();
+		Assert.assertNotNull(ballotData);
 
-		Assert.assertEquals(BallotData.State.OPEN,  d.getState());
-		Assert.assertEquals(BallotData.AssessmentType.SINGLE, d.getAssessmentType());
-		Assert.assertEquals(BallotData.Type.RESULT_ON_CLOSE, d.getType());
-		Assert.assertEquals(10, b.getData().getChoiceList().size());
-		Assert.assertEquals("Choice 7", b.getData().getChoiceList().get(6).getName());
-		Assert.assertEquals(1, (int) b.getData().getChoiceList().get(2).getResult(0));
-		Assert.assertEquals(0, (int) b.getData().getChoiceList().get(2).getResult(1));
+		Assert.assertEquals(BallotData.State.OPEN,  ballotData.getState());
+		Assert.assertEquals(BallotData.AssessmentType.SINGLE, ballotData.getAssessmentType());
+		Assert.assertEquals(BallotData.Type.RESULT_ON_CLOSE, ballotData.getType());
+		Assert.assertEquals(10, pollSetupMessage.getBallotData().getChoiceList().size());
+		Assert.assertEquals("Choice 7", pollSetupMessage.getBallotData().getChoiceList().get(6).getName());
+		Assert.assertEquals(1, (int) pollSetupMessage.getBallotData().getChoiceList().get(2).getResult(0));
+		Assert.assertEquals(0, (int) pollSetupMessage.getBallotData().getChoiceList().get(2).getResult(1));
 	}
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java
index 15ed65f6..561a114b 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/file/ProtocolTest.java
@@ -26,15 +26,12 @@ import androidx.annotation.NonNull;
 import org.junit.Assert;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
 import androidx.annotation.Nullable;
 import ch.threema.base.ThreemaException;
 import ch.threema.base.crypto.NonceFactory;
-import ch.threema.base.crypto.NonceStore;
+import ch.threema.base.crypto.NonceScope;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.models.GroupId;
 import ch.threema.domain.models.VerificationLevel;
 import ch.threema.domain.protocol.csp.ProtocolDefines;
@@ -45,220 +42,200 @@ import ch.threema.domain.protocol.csp.messages.BadMessageException;
 import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 import ch.threema.domain.stores.ContactStore;
 import ch.threema.domain.stores.IdentityStoreInterface;
+import ch.threema.domain.testhelpers.TestHelpers;
 
 public class ProtocolTest {
 
-	/**
-	 * Encrypt a file for a group.
-	 */
-	@Test
-	public void groupTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
-		//create a new file message
-		final String myIdentity = "TESTTEST";
-		final String toIdentity = "ABCDEFGH";
-
-		byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
-
-		GroupId groupId = new GroupId(new byte[ProtocolDefines.GROUP_ID_LEN]);
-		String groupCreator = myIdentity;
-
-		GroupFileMessage groupFileMessage = new GroupFileMessage();
-		groupFileMessage.setFromIdentity(toIdentity);
-		groupFileMessage.setToIdentity(myIdentity);
-		groupFileMessage.setApiGroupId(groupId);
-		groupFileMessage.setGroupCreator(groupCreator);
-		FileData data = new FileData();
-		data
-				.setFileBlobId(blobIdFile)
-				.setThumbnailBlobId(blobIdThumbnail)
-				.setEncryptionKey(key)
-				.setMimeType("image/jpg")
-				.setFileName("therme.jpg")
-				.setFileSize(123)
-				.setRenderingType(FileData.RENDERING_DEFAULT);
-		groupFileMessage.setData(data);
-
-		ContactStore contactStore = createFakeContactStore();
-		IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
-		MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
-
-		NonceFactory nonceFactory = new NonceFactory(new NonceStore() {
-			@Override
-			public boolean exists(@NonNull byte[] nonce) {
-				return false;
-			}
-
-			@Override
-			public boolean store(@NonNull byte[] nonce) {
-				return true;
-			}
-
-			@NonNull
-			@Override
-			public List<byte[]> getAllHashedNonces() {
-				return Collections.emptyList();
-			}
-		});
-
-		MessageBox boxmsg = messageCoder.encode(groupFileMessage, nonceFactory.next(false), nonceFactory);
-		Assert.assertNotNull("BoxMessage failed", boxmsg);
-
-		//now decode again
-		AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
-		Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
-		Assert.assertTrue(decodedBoxMessage instanceof GroupFileMessage);
-
-		GroupFileMessage groupFileMessageDecoded = (GroupFileMessage)decodedBoxMessage;
-		FileData fileData = groupFileMessageDecoded.getData();
-		Assert.assertNotNull(fileData);
-
-		Assert.assertArrayEquals(blobIdFile, fileData.getFileBlobId());
-		Assert.assertArrayEquals(blobIdThumbnail, fileData.getThumbnailBlobId());
-		Assert.assertArrayEquals(key, fileData.getEncryptionKey());
-		Assert.assertEquals("image/jpg", fileData.getMimeType());
-		Assert.assertEquals("therme.jpg", fileData.getFileName());
-		Assert.assertEquals(123, fileData.getFileSize());
-		Assert.assertEquals(FileData.RENDERING_DEFAULT, fileData.getRenderingType());
-	}
-
-	@Test
-	public void identityTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
-		//create a new file message
-		final String myIdentity = "TESTTEST";
-		final String toIdentity = "ABCDEFGH";
-
-		byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
-		byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
-
-		FileMessage fileMessage = new FileMessage();
-		fileMessage.setFromIdentity(toIdentity);
-		fileMessage.setToIdentity(myIdentity);
-		FileData data = new FileData();
-		data
-				.setFileBlobId(blobIdFile)
-				.setThumbnailBlobId(blobIdThumbnail)
-				.setEncryptionKey(key)
-				.setMimeType("image/jpg")
-				.setFileName("therme.jpg")
-				.setFileSize(123)
-				.setRenderingType(FileData.RENDERING_MEDIA);
-		fileMessage.setData(data);
-
-		ContactStore contactStore = createFakeContactStore();
-		IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
-		MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
-
-		NonceFactory nonceFactory = new NonceFactory(new NonceStore() {
-			@Override
-			public boolean exists(@NonNull byte[] nonce) {
-				return false;
-			}
-
-			@Override
-			public boolean store(@NonNull byte[] nonce) {
-				return true;
-			}
-
-			@NonNull
-			@Override
-			public List<byte[]> getAllHashedNonces() {
-				return Collections.emptyList();
-			}
-		});
-
-		MessageBox boxmsg = messageCoder.encode(fileMessage, nonceFactory.next(false), nonceFactory);
-		Assert.assertNotNull("BoxMessage failed", boxmsg);
-
-		//now decode again
-		AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
-		Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
-		Assert.assertTrue(decodedBoxMessage instanceof FileMessage);
-
-		FileMessage fileMessageDecoded = (FileMessage)decodedBoxMessage;
-		FileData fileData = fileMessageDecoded.getData();
-		Assert.assertNotNull(fileData);
-
-		Assert.assertTrue(Arrays.equals(blobIdFile, fileData.getFileBlobId()));
-		Assert.assertTrue(Arrays.equals(blobIdThumbnail, fileData.getThumbnailBlobId()));
-		Assert.assertTrue(Arrays.equals(key, fileData.getEncryptionKey()));
-		Assert.assertEquals("image/jpg", fileData.getMimeType());
-		Assert.assertEquals("therme.jpg", fileData.getFileName());
-		Assert.assertEquals(123, fileData.getFileSize());
-		Assert.assertEquals(FileData.RENDERING_MEDIA, fileData.getRenderingType());
-	}
-
-	private static ContactStore createFakeContactStore() {
-		return new ContactStore() {
-			@Override
-			public void addCachedContact(@NonNull Contact contact) { }
-
-			@Nullable
-			@Override
-			public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
-				return getContactForIdentity(identity);
-			}
-
-			@Override
-			public Contact getContactForIdentity(@NonNull String identity) {
-				return new Contact(identity, new byte[256], VerificationLevel.UNVERIFIED);
-			}
-
-			@Override
-			public void addContact(@NonNull Contact contact) { }
-
-			@Override
-			public void removeContact(@NonNull Contact contact) { }
-		};
-	}
-
-	private static IdentityStoreInterface createFakeIdentityStore(final String myIdentity) {
-		return new IdentityStoreInterface() {
-			@Override
-			public byte[] encryptData(byte[] plaintext, byte[] nonce, byte[] receiverPublicKey) {
-				return plaintext;
-			}
-
-			@Override
-			public byte[] decryptData(byte[] ciphertext, byte[] nonce, byte[] senderPublicKey) {
-				return ciphertext;
-			}
-
-			@Override
-			public byte[] calcSharedSecret(@NonNull byte[] publicKey) {
-				return new byte[32];
-			}
-
-			@Override
-			public String getIdentity() {
-				return myIdentity;
-			}
-
-			@Override
-			public String getServerGroup() {
-				return null;
-			}
-
-			@Override
-			public byte[] getPublicKey() {
-				return new byte[256];
-			}
-
-			@Override
-			public byte[] getPrivateKey() {
-				return new byte[32];
-			}
-
-			@Override
-			@NonNull
-			public String getPublicNickname() {
-				return "";
-			}
-
-			@Override
-			public void storeIdentity(String identity, String serverGroup, byte[] publicKey, byte[] privateKey) { }
-		};
-	}
+    /**
+     * Encrypt a file for a group.
+     */
+    @Test
+    public void groupTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
+        //create a new file message
+        final String myIdentity = "TESTTEST";
+        final String toIdentity = "ABCDEFGH";
+
+        byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
+
+        GroupId groupId = new GroupId(new byte[ProtocolDefines.GROUP_ID_LEN]);
+        String groupCreator = myIdentity;
+
+        GroupFileMessage groupFileMessage = new GroupFileMessage();
+        groupFileMessage.setFromIdentity(toIdentity);
+        groupFileMessage.setToIdentity(myIdentity);
+        groupFileMessage.setApiGroupId(groupId);
+        groupFileMessage.setGroupCreator(groupCreator);
+        FileData data = new FileData();
+        data
+            .setFileBlobId(blobIdFile)
+            .setThumbnailBlobId(blobIdThumbnail)
+            .setEncryptionKey(key)
+            .setMimeType("image/jpg")
+            .setFileName("therme.jpg")
+            .setFileSize(123)
+            .setRenderingType(FileData.RENDERING_DEFAULT);
+        groupFileMessage.setFileData(data);
+
+        ContactStore contactStore = createFakeContactStore();
+        IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
+        MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
+
+        NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
+
+        MessageBox boxmsg = messageCoder.encode(groupFileMessage, nonceFactory.nextNonce(NonceScope.CSP));
+        Assert.assertNotNull("BoxMessage failed", boxmsg);
+
+        //now decode again
+        AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
+        Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
+        Assert.assertTrue(decodedBoxMessage instanceof GroupFileMessage);
+
+        GroupFileMessage groupFileMessageDecoded = (GroupFileMessage) decodedBoxMessage;
+        FileData fileData = groupFileMessageDecoded.getFileData();
+        Assert.assertNotNull(fileData);
+
+        Assert.assertArrayEquals(blobIdFile, fileData.getFileBlobId());
+        Assert.assertArrayEquals(blobIdThumbnail, fileData.getThumbnailBlobId());
+        Assert.assertArrayEquals(key, fileData.getEncryptionKey());
+        Assert.assertEquals("image/jpg", fileData.getMimeType());
+        Assert.assertEquals("therme.jpg", fileData.getFileName());
+        Assert.assertEquals(123, fileData.getFileSize());
+        Assert.assertEquals(FileData.RENDERING_DEFAULT, fileData.getRenderingType());
+    }
+
+    @Test
+    public void identityTest() throws ThreemaException, MissingPublicKeyException, BadMessageException {
+        //create a new file message
+        final String myIdentity = "TESTTEST";
+        final String toIdentity = "ABCDEFGH";
+
+        byte[] blobIdFile = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] blobIdThumbnail = new byte[ProtocolDefines.BLOB_ID_LEN];
+        byte[] key = new byte[ProtocolDefines.BLOB_KEY_LEN];
+
+        FileMessage fileMessage = new FileMessage();
+        fileMessage.setFromIdentity(toIdentity);
+        fileMessage.setToIdentity(myIdentity);
+        FileData data = new FileData();
+        data
+            .setFileBlobId(blobIdFile)
+            .setThumbnailBlobId(blobIdThumbnail)
+            .setEncryptionKey(key)
+            .setMimeType("image/jpg")
+            .setFileName("therme.jpg")
+            .setFileSize(123)
+            .setRenderingType(FileData.RENDERING_MEDIA);
+        fileMessage.setFileData(data);
+
+        ContactStore contactStore = createFakeContactStore();
+        IdentityStoreInterface identityStore = createFakeIdentityStore(myIdentity);
+        MessageCoder messageCoder = new MessageCoder(contactStore, identityStore);
+
+        NonceFactory nonceFactory = TestHelpers.getNoopNonceFactory();
+
+        MessageBox boxmsg = messageCoder.encode(fileMessage, nonceFactory.nextNonce(NonceScope.CSP));
+        Assert.assertNotNull("BoxMessage failed", boxmsg);
+
+        //now decode again
+        AbstractMessage decodedBoxMessage = messageCoder.decode(boxmsg);
+        Assert.assertNotNull("decodedBox failed", decodedBoxMessage);
+        Assert.assertTrue(decodedBoxMessage instanceof FileMessage);
+
+        FileMessage fileMessageDecoded = (FileMessage) decodedBoxMessage;
+        FileData fileData = fileMessageDecoded.getFileData();
+        Assert.assertNotNull(fileData);
+
+        Assert.assertArrayEquals(blobIdFile, fileData.getFileBlobId());
+        Assert.assertArrayEquals(blobIdThumbnail, fileData.getThumbnailBlobId());
+        Assert.assertArrayEquals(key, fileData.getEncryptionKey());
+        Assert.assertEquals("image/jpg", fileData.getMimeType());
+        Assert.assertEquals("therme.jpg", fileData.getFileName());
+        Assert.assertEquals(123, fileData.getFileSize());
+        Assert.assertEquals(FileData.RENDERING_MEDIA, fileData.getRenderingType());
+    }
+
+    private static ContactStore createFakeContactStore() {
+        return new ContactStore() {
+            @Override
+            public void addCachedContact(@NonNull BasicContact contact) {
+            }
+
+            @Nullable
+            @Override
+            public BasicContact getCachedContact(@NonNull String identity) {
+                return null;
+            }
+
+            @NonNull
+            @Override
+            public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
+                return getContactForIdentity(identity);
+            }
+
+            @Override
+            public Contact getContactForIdentity(@NonNull String identity) {
+                return new Contact(identity, new byte[256], VerificationLevel.UNVERIFIED);
+            }
+
+            @Override
+            public void addContact(@NonNull Contact contact) {
+            }
+
+            @Override
+            public boolean isSpecialContact(@NonNull String identity) {
+                return false;
+            }
+        };
+    }
+
+    private static IdentityStoreInterface createFakeIdentityStore(final String myIdentity) {
+        return new IdentityStoreInterface() {
+            @Override
+            public byte[] encryptData(@NonNull byte[] plaintext, @NonNull byte[] nonce, @NonNull byte[] receiverPublicKey) {
+                return plaintext;
+            }
+
+            @Override
+            public byte[] decryptData(@NonNull byte[] ciphertext, @NonNull byte[] nonce, @NonNull byte[] senderPublicKey) {
+                return ciphertext;
+            }
+
+            @Override
+            public byte[] calcSharedSecret(@NonNull byte[] publicKey) {
+                return new byte[32];
+            }
+
+            @Override
+            public String getIdentity() {
+                return myIdentity;
+            }
+
+            @Override
+            public String getServerGroup() {
+                return null;
+            }
+
+            @Override
+            public byte[] getPublicKey() {
+                return new byte[256];
+            }
+
+            @Override
+            public byte[] getPrivateKey() {
+                return new byte[32];
+            }
+
+            @Override
+            @NonNull
+            public String getPublicNickname() {
+                return "";
+            }
+
+            @Override
+            public void storeIdentity(@NonNull String identity, @NonNull String serverGroup, @NonNull byte[] publicKey, @NonNull byte[] privateKey) {
+            }
+        };
+    }
 }
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java
index 39da698f..c4acac5d 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/fs/ForwardSecurityMessageTest.java
@@ -32,7 +32,7 @@ import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
 
 import static ch.threema.domain.testhelpers.TestHelpers.boxMessage;
 import static ch.threema.domain.testhelpers.TestHelpers.decodeMessageFromBox;
-import static ch.threema.domain.testhelpers.TestHelpers.setMessageDefaults;
+import static ch.threema.domain.testhelpers.TestHelpers.setMessageDefaultSenderAndReceiver;
 
 public class ForwardSecurityMessageTest {
 
@@ -42,7 +42,7 @@ public class ForwardSecurityMessageTest {
 
 	private static ForwardSecurityEnvelopeMessage getEnvelopeMessageTestInstance() {
 		final ForwardSecurityEnvelopeMessage msg = new ForwardSecurityEnvelopeMessage(getDataTestInstance(), true);
-		setMessageDefaults(msg);
+		setMessageDefaultSenderAndReceiver(msg);
 		return msg;
 	}
 
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java
index dde0587d..515a11ca 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinRequestMessageTest.java
@@ -43,7 +43,7 @@ public class GroupJoinRequestMessageTest {
 	}
 	static GroupJoinRequestMessage getMessageTestInstance() throws BadMessageException {
 		final GroupJoinRequestMessage msg = new GroupJoinRequestMessage(getDataTestInstance());
-		setMessageDefaults(msg);
+		setMessageDefaultSenderAndReceiver(msg);
 		return msg;
 	}
 
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java
index 04ba232f..47987ca8 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/group/GroupJoinResponseMessageTest.java
@@ -42,7 +42,7 @@ public class GroupJoinResponseMessageTest {
 	}
 	static GroupJoinResponseMessage getMessageTestInstance() throws BadMessageException {
 		final GroupJoinResponseMessage msg = new GroupJoinResponseMessage(getDataTestInstance());
-		setMessageDefaults(msg);
+		setMessageDefaultSenderAndReceiver(msg);
 		return msg;
 	}
 
diff --git a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java
index e90994fb..56cfd733 100644
--- a/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java
+++ b/domain/src/test/java/ch/threema/domain/protocol/csp/messages/protobuf/AbstractProtobufMessageTest.java
@@ -79,6 +79,11 @@ public class AbstractProtobufMessageTest {
 					return false;
 				}
 
+				@Override
+				public boolean reflectSentUpdate() {
+					return false;
+				}
+
 				@Override
 				public boolean sendAutomaticDeliveryReceipt() {
 					return false;
diff --git a/domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt b/domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt
deleted file mode 100644
index 1b95edf8..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/multidevice/MultiDeviceKeysTest.kt
+++ /dev/null
@@ -1,88 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.multidevice
-
-import ch.threema.base.utils.Utils
-import org.junit.Assert.*
-import org.junit.Test
-
-/**
- * Test vectors according to the `multidevice-kdf` repository
- */
-class MultiDeviceKeysTest {
-    private companion object {
-        private val DGK1 = Utils.hexStringToByteArray("1b35ed7e1ba9993171fe4a7eed30c2831905c3a583616d61e93782da900bf8ba")
-        private val DGPK1 = Utils.hexStringToByteArray( "60c0ed9098902c0b6093be4a819bf344900bc7473504ccdb61004b1b58aa2233")
-        private val DGRK1 = Utils.hexStringToByteArray( "a4bf34ff67ed3b731a2aa6e023335f7eba6c914e877da3d15bff41d84f7f75f8")
-        private val DGDIK1 = Utils.hexStringToByteArray( "5953fb9775d8c23fae573e245534dac2c7aa16b62ea73b954ea4177d192e8c50")
-        private val DGSDDK1 = Utils.hexStringToByteArray( "7a91ad36bc9537ccfd6fd76b23d7f5319e506e6a5294c988c9a75c8e34a3c9dd")
-        private val DGTSK1 = Utils.hexStringToByteArray( "7c6b94affb171c564bfd375d50c4781d72ab2671ae4035ab4307dedce67ef30e")
-
-        private val DGK2 = Utils.hexStringToByteArray("7cf1c4847fb32d6c3702747018d0cccdc2f724c115bfca1036ae6208d2b7c68c")
-        private val DGPK2 = Utils.hexStringToByteArray( "2b59e83e5a93ce4a09eeb4db91ec30e63cc3f173385742dd4a27ef83e5bef4f3")
-        private val DGRK2 = Utils.hexStringToByteArray( "fa33785f528439c2bfd9b7220ff03ebca919c1c127aca91878f2038b65a79c73")
-        private val DGDIK2 = Utils.hexStringToByteArray( "8a8199023dfeda5793e06552fb968282d7e7e29452c1229dcb212fb7d48f1e6a")
-        private val DGSDDK2 = Utils.hexStringToByteArray( "bd96dd0f700c5d77da666990854eb4287d5f20a9be0deda6d88b875963c39b3f")
-        private val DGTSK2 = Utils.hexStringToByteArray( "351e81590fb0115f8d1ab604c7eaf6996f3e079ea0a591db62caea4dcd7c6bda")
-
-        private val DGK3 = Utils.hexStringToByteArray("0000000000000000000000000000000000000000000000000000000000000000")
-        private val DGPK3 = Utils.hexStringToByteArray("4b464e5d33debe0d3f9be535b9a1449f79caac615c852da734b47ef3a23e14ca")
-        private val DGRK3 = Utils.hexStringToByteArray("d597f6380d1ecf6f1a7fd265c49bc53cff04c0efc1236a542dae338bba4bc6e9")
-        private val DGDIK3 = Utils.hexStringToByteArray("8bb45615b2982e8d6aefcfbe46a44bcea0df048df7a05d9d50afd01911ed10d8")
-        private val DGSDDK3 = Utils.hexStringToByteArray("86fa7962c7d85e01876de9a90cad95cf83b4605d40b83b6580b80618f56fa4d4")
-        private val DGTSK3 = Utils.hexStringToByteArray("7ab0a7c3239323e1b9f697eb59196d888747f027df356a305f58f55ebb8c23aa")
-    }
-
-
-    @Test
-    fun testKeyDerivationDgk1() {
-        val keys = MultiDeviceKeys(DGK1)
-
-        assertArrayEquals(DGPK1, keys.dgpk)
-        assertArrayEquals(DGRK1, keys.dgrk)
-        assertArrayEquals(DGDIK1, keys.dgdik)
-        assertArrayEquals(DGSDDK1, keys.dgsddk)
-        assertArrayEquals(DGTSK1, keys.dgtsk)
-    }
-
-    @Test
-    fun testKeyDerivationDgk2() {
-        val keys = MultiDeviceKeys(DGK2)
-
-        assertArrayEquals(DGPK2, keys.dgpk)
-        assertArrayEquals(DGRK2, keys.dgrk)
-        assertArrayEquals(DGDIK2, keys.dgdik)
-        assertArrayEquals(DGSDDK2, keys.dgsddk)
-        assertArrayEquals(DGTSK2, keys.dgtsk)
-    }
-
-    @Test
-    fun testKeyDerivationDgk3() {
-        val keys = MultiDeviceKeys(DGK3)
-
-        assertArrayEquals(DGPK3, keys.dgpk)
-        assertArrayEquals(DGRK3, keys.dgrk)
-        assertArrayEquals(DGDIK3, keys.dgdik)
-        assertArrayEquals(DGSDDK3, keys.dgsddk)
-        assertArrayEquals(DGTSK3, keys.dgtsk)
-    }
-}
diff --git a/domain/src/test/java/ch/threema/domain/protocol/taskmanager/TaskExecutionTest.kt b/domain/src/test/java/ch/threema/domain/protocol/taskmanager/TaskExecutionTest.kt
deleted file mode 100644
index fd8e975e..00000000
--- a/domain/src/test/java/ch/threema/domain/protocol/taskmanager/TaskExecutionTest.kt
+++ /dev/null
@@ -1,334 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.protocol.taskmanager
-
-import ch.threema.base.utils.LoggingUtil
-import ch.threema.domain.protocol.connection.csp.DeviceCookieManager
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-import ch.threema.domain.protocol.connection.layer.Layer5Codec
-import ch.threema.domain.protocol.taskmanager.TaskExecutionTest.UnexpectedExceptionTask.UnexpectedException
-import ch.threema.domain.taskmanager.ConnectionStoppedException
-import ch.threema.domain.taskmanager.IncomingMessageProcessor
-import ch.threema.domain.taskmanager.PassiveTask
-import ch.threema.domain.taskmanager.PassiveTaskCodec
-import ch.threema.domain.taskmanager.ProtocolException
-import ch.threema.domain.taskmanager.SingleThreadedTaskManagerDispatcher
-import ch.threema.domain.taskmanager.TaskArchiver
-import ch.threema.domain.taskmanager.TaskManagerImpl
-import junit.framework.TestCase.assertEquals
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.TimeoutCancellationException
-import kotlinx.coroutines.asCoroutineDispatcher
-import kotlinx.coroutines.awaitAll
-import kotlinx.coroutines.delay
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
-import kotlinx.coroutines.withTimeout
-import org.junit.Assert.assertThrows
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.Timeout
-import org.mockito.AdditionalAnswers
-import org.mockito.Mockito.anyLong
-import org.mockito.Mockito.mock
-import org.mockito.Mockito.`when`
-import java.util.concurrent.Executors
-
-private val logger = LoggingUtil.getThreemaLogger("TaskExecutionTest")
-
-class TaskExecutionTest {
-
-    @Rule
-    @JvmField
-    val timeout: Timeout = Timeout.seconds(300)
-
-    /**
-     * This is the number of retries the task manager allows per (local) task.
-     */
-    private val maximumNumberOfAttempts = 5
-
-    /**
-     * The task manager that is tested.
-     */
-    private val taskManager: TaskManagerImpl = TaskManagerImpl(
-        { mock(TaskArchiver::class.java) },
-        mock(DeviceCookieManager::class.java),
-        TaskManagerImpl.TaskManagerDispatchers(
-            SingleThreadedTaskManagerDispatcher(
-                true,
-                "ExecutorDispatcher"
-            ),
-            SingleThreadedTaskManagerDispatcher(
-                true,
-                "ScheduleDispatcher"
-            ),
-        )
-    )
-
-    /**
-     * Provides some (pointless) work to perform.
-     */
-    private open class TaskWork(protected val number: Int) {
-        protected suspend fun doWork() {
-            // Just do something to simulate a task that does something
-            for (i in 0..number) {
-                logger.debug("Logging number $i of $number")
-            }
-            // Suspend the work a bit, so that the task manager is tempted to run the next task
-            // already (which would be faulty!!)
-            when (number) {
-                // Delay a little longer for task with number 5 (not a specific reason for number 5)
-                5 -> delay(1000)
-                // Delay a little shorter for other tasks (to reduce total test execution time)
-                else -> delay(10)
-            }
-        }
-    }
-
-    /**
-     * Executes some work and finally adds its number to the result list and returns the number
-     * with the result list.
-     */
-    private class SuccessfulTask(
-        number: Int,
-        private val resultList: MutableList<Int>,
-    ) : TaskWork(number), PassiveTask<Int> {
-        override val type = "SuccessfulTask"
-        override suspend fun invoke(handle: PassiveTaskCodec): Int {
-            doWork()
-            resultList.add(number)
-            return number
-        }
-    }
-
-    /**
-     * An exception task that runs [expectedFailedAttempts] times with a certain exception, and then
-     * completes successfully returning the number of times it has been tried to be executed.
-     */
-    private abstract inner class ExceptionTask(private val expectedFailedAttempts: Int) :
-        PassiveTask<Int> {
-        protected var actualFailedAttempts = 0
-
-        override suspend fun invoke(handle: PassiveTaskCodec): Int {
-            val succeed = expectedFailedAttempts <= actualFailedAttempts
-            if (succeed) {
-                return actualFailedAttempts
-            }
-
-            // As we are still running now, this is another failed attempt to run this task
-            actualFailedAttempts++
-
-            // Fail
-            throwException()
-        }
-
-        protected abstract fun throwException(): Nothing
-    }
-
-    /**
-     * This task throws [expectedFailedAttempts] times an [UnexpectedException].
-     */
-    private inner class UnexpectedExceptionTask(expectedFailedAttempts: Int) :
-        ExceptionTask(expectedFailedAttempts) {
-        inner class UnexpectedException(val actualFailedAttempts: Int) : Exception()
-
-        override val type = "UnexpectedExceptionTask"
-
-        override fun throwException() = throw UnexpectedException(actualFailedAttempts)
-    }
-
-    /**
-     * This task throws [expectedFailedAttempts] times a [ProtocolException].
-     */
-    private inner class ProtocolExceptionTask : ExceptionTask(1) {
-        override val type = "ProtocolExceptionTask"
-
-        override fun throwException() = throw ProtocolException("Test")
-    }
-
-    /**
-     * This task throws [expectedFailedAttempts] times a [ConnectionStoppedException]. Note that
-     * [ConnectionStoppedException]s should only be thrown by the task manager or for testing
-     * purposes.
-     */
-    private inner class ConnectionStoppedExceptionTask : ExceptionTask(1) {
-        override val type = "ConnectionStoppedExceptionTask"
-
-        override fun throwException() = throw ConnectionStoppedException()
-    }
-
-    @Before
-    fun setup() {
-        runBlocking {
-            startConnection()
-        }
-    }
-
-    @Test
-    fun testExecutionOfSuccessfulTask(): Unit = runBlocking {
-        // Test ascending list
-        assertSuccessfulTaskExecution((0..50).toList())
-
-        // Test descending list
-        assertSuccessfulTaskExecution((0..50).reversed().toList())
-
-        // Test random numbers
-        assertSuccessfulTaskExecution(List(50) { (0..1000).random() })
-
-        // Test all the same
-        assertSuccessfulTaskExecution(List(50) { 10 })
-    }
-
-    @Test
-    fun testExecutionOfFailingTask(): Unit = runBlocking {
-        // Test number of failed attempts below the maximum amount of attempts
-        (0 until maximumNumberOfAttempts).forEach { assertNumberOfFailedAttempts(it) }
-    }
-
-    @Test
-    fun testMaxAttempts(): Unit = runBlocking {
-        // Test for the exact number of attempts
-        assertNumberOfFailedAttempts(maximumNumberOfAttempts)
-    }
-
-    @Test
-    fun testMoreThanMaxAttempts(): Unit = runBlocking {
-        // Test for one more execution attempts
-        assertNumberOfFailedAttempts(maximumNumberOfAttempts + 1)
-        // Test for many more execution attempts
-        assertNumberOfFailedAttempts(Int.MAX_VALUE)
-    }
-
-    @Test
-    fun testProtocolException() {
-        val done = taskManager.schedule(ProtocolExceptionTask())
-        // Assert that the deferred won't be completed immediately, as there is a minimum delay to
-        // wait until the connection will be restarted.
-        assertThrows(TimeoutCancellationException::class.java) {
-            runBlocking {
-                withTimeout(1000) {
-                    done.await()
-                }
-            }
-        }
-
-        // The server connection should be restarted soon, and the current task should be executed
-        // again. It will complete successfully in its second execution and therefore the deferred
-        // will complete as soon as the new connection could be established.
-        runBlocking {
-            assertEquals(1, done.await())
-        }
-    }
-
-    @Test
-    fun testConnectionStoppedException() {
-        val done = taskManager.schedule(ConnectionStoppedExceptionTask())
-        // Assert that awaiting the deferred is pointless, as the task will be retried after the
-        // connection has been started again. Note that we wait for 5 seconds, which is longer than
-        // the minimum delay in the task runner. Therefore, this additionally tests that the task
-        // manager does not restart the connection when a ConnectionStoppedException has been
-        // thrown.
-        assertThrows(TimeoutCancellationException::class.java) {
-            runBlocking {
-                withTimeout(5000) {
-                    done.await()
-                }
-            }
-        }
-
-        restartConnection()
-
-        // Now, as the server connection has been restarted, the current task should be executed
-        // again and as a cancellation exception task completes successfully in its second
-        // execution, the deferred should complete.
-        runBlocking {
-            assertEquals(1, done.await())
-        }
-    }
-
-    private suspend fun assertSuccessfulTaskExecution(expectedResults: List<Int>) {
-        // The result list will contain the task numbers in the actually executed order
-        val resultList = mutableListOf<Int>()
-        // The return list contains the numbers in the order the task have been scheduled
-        val returnList = expectedResults.map { SuccessfulTask(it, resultList) }
-            .map { taskManager.schedule(it) }
-            .awaitAll()
-
-        // Assert that the actual execution order matches the expected order
-        assertEquals(expectedResults, resultList)
-        // Assert that the scheduling order matches the expected order
-        assertEquals(expectedResults, returnList)
-    }
-
-    private suspend fun assertNumberOfFailedAttempts(numFailedAttempts: Int) {
-        if (numFailedAttempts < maximumNumberOfAttempts) {
-            // Expect the exact number of failed attempts as the number of failed attempts is lower
-            // than the maximum number of attempts which allows the task to complete in the last
-            // attempt.
-            val failedAttempts =
-                taskManager.schedule(UnexpectedExceptionTask(numFailedAttempts)).await()
-            assertEquals(numFailedAttempts, failedAttempts)
-        } else {
-            // If the number of failed attempts is the maximum number of attempts or higher, the
-            // task will not complete successfully and therefore the task will complete
-            // exceptionally.
-            // Note that scheduling the task must not trigger any exceptions!
-            val done = taskManager.schedule(UnexpectedExceptionTask(numFailedAttempts))
-            // Only when awaiting the completable deferred results in an exception
-            val exception = assertThrows(UnexpectedException::class.java) {
-                runBlocking {
-                    done.await()
-                }
-            }
-            // Expect that the task has been executed as often as possible
-            assertEquals(maximumNumberOfAttempts, exception.actualFailedAttempts)
-        }
-    }
-
-    private fun restartConnection() {
-        runBlocking {
-            stopConnection()
-            startConnection()
-        }
-    }
-
-    private suspend fun startConnection() {
-        val layer5Codec = mock(Layer5Codec::class.java)
-        `when`(layer5Codec.restartConnection(anyLong())).then {
-            // Wait until reconnection (connection is mocked)
-            Thread.sleep(AdditionalAnswers.returnsFirstArg<Long>().answer(it))
-            // Launch new coroutine to restart the task manager
-            CoroutineScope(Dispatchers.Default).launch {
-                taskManager.pauseRunningTasks()
-                taskManager.startRunningTasks(layer5Codec, mock(IncomingMessageProcessor::class.java))
-            }
-        }
-        taskManager.startRunningTasks(layer5Codec, mock(IncomingMessageProcessor::class.java))
-    }
-
-    private suspend fun stopConnection() {
-        taskManager.pauseRunningTasks()
-    }
-
-}
diff --git a/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java b/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java
index 9565dfb5..51bb44e1 100644
--- a/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java
+++ b/domain/src/test/java/ch/threema/domain/stores/DummyContactStore.java
@@ -27,10 +27,11 @@ import java.util.Map;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 
 public class DummyContactStore implements ContactStore {
 	private final Map<String, Contact> contactMap;
-	private final Map<String, Contact> contactCache = new HashMap<>();
+	private final Map<String, BasicContact> contactCache = new HashMap<>();
 
 	public DummyContactStore() {
 		this.contactMap = new HashMap<>();
@@ -48,13 +49,14 @@ public class DummyContactStore implements ContactStore {
 	}
 
 	@Override
-	public void removeContact(@NonNull Contact contact) {
-		contactMap.remove(contact.getIdentity());
+	public void addCachedContact(@NonNull BasicContact contact) {
+		this.contactCache.put(contact.getIdentity(), contact);
 	}
 
+	@Nullable
 	@Override
-	public void addCachedContact(@NonNull Contact contact) {
-		this.contactCache.put(contact.getIdentity(), contact);
+	public BasicContact getCachedContact(@NonNull String identity) {
+		return this.contactCache.get(identity);
 	}
 
 	@Nullable
@@ -66,4 +68,9 @@ public class DummyContactStore implements ContactStore {
 		}
 		return getContactForIdentity(identity);
 	}
+
+	@Override
+	public boolean isSpecialContact(@NonNull String identity) {
+		return false;
+	}
 }
diff --git a/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.java b/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.java
deleted file mode 100644
index c9600ed9..00000000
--- a/domain/src/test/java/ch/threema/domain/testhelpers/TestHelpers.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2017-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.testhelpers;
-
-import java.util.Collections;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.ThreemaException;
-import ch.threema.base.crypto.NonceFactory;
-import ch.threema.base.crypto.NonceStore;
-import ch.threema.domain.models.Contact;
-import ch.threema.domain.models.VerificationLevel;
-import ch.threema.domain.protocol.csp.coders.MessageBox;
-import ch.threema.domain.protocol.csp.coders.MessageCoder;
-import ch.threema.domain.protocol.csp.messages.AbstractMessage;
-import ch.threema.domain.protocol.csp.messages.BadMessageException;
-import ch.threema.domain.protocol.csp.messages.MissingPublicKeyException;
-import ch.threema.domain.stores.ContactStore;
-import ch.threema.domain.stores.IdentityStoreInterface;
-
-public class TestHelpers {
-
-	public final static String myIdentity = "TESTTST";
-
-	public static ContactStore getNoopContactStore() {
-		return new ContactStore() {
-			@Override
-			public Contact getContactForIdentity(@NonNull String identity) {
-				return new Contact(identity, new byte[256], VerificationLevel.UNVERIFIED);
-			}
-
-			@Override
-			public void addCachedContact(@NonNull Contact contact) {
-
-			}
-
-			@Override
-			public Contact getContactForIdentityIncludingCache(@NonNull String identity) {
-				return getContactForIdentity(identity);
-			}
-
-			@Override
-			public void addContact(@NonNull Contact contact) { }
-
-			@Override
-			public void removeContact(@NonNull Contact contact) { }
-		};
-	}
-
-	public static IdentityStoreInterface getNoopIdentityStore() {
-		return new IdentityStoreInterface() {
-			@Override
-			public byte[] encryptData(@NonNull byte[] plaintext, @NonNull byte[] nonce, @NonNull byte[] receiverPublicKey) {
-				return plaintext;
-			}
-
-			@Override
-			public byte[] decryptData(@NonNull byte[] ciphertext, @NonNull byte[] nonce, @NonNull byte[] senderPublicKey) {
-				return ciphertext;
-			}
-
-			@Override
-			public byte[] calcSharedSecret(@NonNull byte[] publicKey) {
-				return new byte[32];
-			}
-
-			@Override
-			public String getIdentity() {
-				return myIdentity;
-			}
-
-			@Override
-			public String getServerGroup() {
-				return null;
-			}
-
-			@Override
-			public byte[] getPublicKey() {
-				return new byte[256];
-			}
-
-			@Override
-			public byte[] getPrivateKey() {
-				return new byte[32];
-			}
-
-			@Override
-			@NonNull
-			public String getPublicNickname() {
-				return "";
-			}
-
-			@Override
-			public void storeIdentity(@NonNull String identity, @NonNull String serverGroup, @NonNull byte[] publicKey, @NonNull byte[] privateKey) { }
-		};
-	}
-
-	public static NonceFactory getNoopNonceFactory() {
-		return new NonceFactory(new NonceStore() {
-			@Override
-			public boolean exists(@NonNull byte[] nonce) {
-				return false;
-			}
-
-			@Override
-			public boolean store(@NonNull byte[] nonce) {
-				return true;
-			}
-
-			@NonNull
-			@Override
-			public List<byte[]> getAllHashedNonces() {
-				return Collections.emptyList();
-			}
-		});
-	}
-
-	/**
-	 * Adds a default sender and receiver to a message
-	 */
-	public static AbstractMessage setMessageDefaults(AbstractMessage msg) {
-		final String toIdentity = "ABCDEFGH";
-
-		msg.setFromIdentity(toIdentity);
-		msg.setToIdentity(myIdentity);
-
-		return msg;
-	}
-
-	public static MessageBox boxMessage(AbstractMessage msg) throws ThreemaException {
-		MessageCoder messageCoder = new MessageCoder(getNoopContactStore(), getNoopIdentityStore());
-		NonceFactory nonceFactory = getNoopNonceFactory();
-		byte[] nonce = nonceFactory.next(false);
-		return messageCoder.encode(msg, nonce, nonceFactory);
-	}
-
-	public static AbstractMessage decodeMessageFromBox(@NonNull MessageBox boxedMessage) throws MissingPublicKeyException, BadMessageException {
-		MessageCoder messageCoder = new MessageCoder(getNoopContactStore(), getNoopIdentityStore());
-		return messageCoder.decode(boxedMessage);
-	}
-
-
-}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/DecryptTaskCodec.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/DecryptTaskCodec.kt
deleted file mode 100644
index a266f870..00000000
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/DecryptTaskCodec.kt
+++ /dev/null
@@ -1,123 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2023-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.helpers
-
-import ch.threema.base.utils.Utils
-import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.protocol.csp.coders.MessageCoder
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataAccept
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataInit
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataMessage
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataReject
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataTerminate
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.stores.ContactStore
-import ch.threema.domain.stores.IdentityStoreInterface
-import java.util.LinkedList
-import java.util.Queue
-
-/**
- * This task codec is used only for tests. It creates server acknowledgements and automatically
- * decrypts outgoing fs messages. Note that this therefore also changes the state of the recipient's
- * forward security message processor.
- */
-open class DecryptTaskCodec(
-    private val contactStore: ContactStore,
-    private val identityStores: Map<String, IdentityStoreInterface>,
-    private val forwardSecurityMessageProcessors: Map<String, ForwardSecurityMessageProcessor>,
-) : ServerAckTaskCodec() {
-    val outboundAbstractMessages: Queue<AbstractMessage> = LinkedList()
-
-    override suspend fun handleOutgoingMessageBox(messageBox: MessageBox) {
-        // This creates the server ack
-        super.handleOutgoingMessageBox(messageBox)
-
-        // Decode and decapsulate message to add it to the outgoing abstract message list
-        val abstractMessage = decodeMessage(messageBox)
-        val decapsulatedMessage = decapsulateMessage(abstractMessage)
-
-        if (decapsulatedMessage != null) {
-            // Note that in case of a forward security message, the decapsulated message is
-            // null and therefore not added here. However, the message is still processed by
-            // the forward security message processor.
-            outboundAbstractMessages.add(decapsulatedMessage)
-        }
-    }
-
-    private fun decodeMessage(messageBox: MessageBox): AbstractMessage {
-        val identityStore = identityStores[messageBox.toIdentity]
-            ?: throw AssertionError("No identity store provided for identity ${messageBox.toIdentity}")
-        return MessageCoder(contactStore, identityStore).decode(messageBox)
-    }
-
-    private suspend fun decapsulateMessage(message: AbstractMessage): AbstractMessage? {
-        val sender = contactStore.getContactForIdentityIncludingCache(message.fromIdentity)!!
-
-        val forwardSecurityMessageProcessor = forwardSecurityMessageProcessors[message.toIdentity]
-            ?: throw AssertionError("No forward security message processor provided for identity ${message.toIdentity}")
-        if (message is ForwardSecurityEnvelopeMessage) {
-            when (val data = message.data) {
-                is ForwardSecurityDataInit -> forwardSecurityMessageProcessor.processInit(
-                    sender,
-                    data,
-                    this
-                )
-
-                is ForwardSecurityDataAccept -> forwardSecurityMessageProcessor.processAccept(
-                    sender,
-                    data,
-                    this
-                )
-
-                is ForwardSecurityDataReject -> forwardSecurityMessageProcessor.processReject(
-                    sender,
-                    data,
-                    this
-                )
-
-                is ForwardSecurityDataTerminate -> forwardSecurityMessageProcessor.processTerminate(
-                    sender,
-                    data
-                )
-
-                is ForwardSecurityDataMessage -> return forwardSecurityMessageProcessor.processMessage(
-                    sender,
-                    message,
-                    this
-                ).message
-            }
-            return null
-        } else {
-            throw AssertionError(
-                "Expected forward secure message but got a message of type ${
-                    Utils.byteToHex(
-                        message.type.toByte(),
-                        true,
-                        true
-                    )
-                }"
-            )
-        }
-    }
-}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java b/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java
index 0ed014f2..88a4bee5 100644
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/DummyUsers.java
@@ -21,29 +21,58 @@
 
 package ch.threema.domain.helpers;
 
-import ch.threema.domain.models.Contact;
-import ch.threema.domain.models.VerificationLevel;
-import ch.threema.domain.stores.IdentityStoreInterface;
-import ch.threema.base.utils.Utils;
 import com.neilalexander.jnacl.NaCl;
 
 import java.util.Arrays;
 import java.util.Objects;
 
+import androidx.annotation.NonNull;
+import ch.threema.base.utils.Utils;
+import ch.threema.domain.models.BasicContact;
+import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.IdentityState;
+import ch.threema.domain.models.IdentityType;
+import ch.threema.domain.models.VerificationLevel;
+import ch.threema.domain.protocol.ThreemaFeature;
+import ch.threema.domain.stores.IdentityStoreInterface;
+
 public class DummyUsers {
 	public static final User ALICE = new User("000ALICE", Utils.hexStringToByteArray("6eda2ebb8527ff5bd0e8719602f710c13e162a3be612de0ad2a2ff66f5050630"));
 	public static final User BOB = new User("00000BOB", Utils.hexStringToByteArray("533058227925006d86bb8dd88b0442ed73fbc49216b6e94b0870a7761d979eca"));
 	public static final User CAROL = new User("000CAROL", Utils.hexStringToByteArray("2ac0f894ef1504d63eef743ffd3cdd2a0604689f2bed6d10cc7895b589f4f821"));
 	public static final User DAVE = new User("0000DAVE", Utils.hexStringToByteArray("2b3d181bbf1eb84a01326c5dc79c70be32688cb3a797a2a0acdd6c067b614b44"));
 
+	private static final long featureMask = new ThreemaFeature.Builder()
+		.audio(true)
+		.group(true)
+		.ballot(true)
+		.file(true)
+		.voip(true)
+		.videocalls(true)
+		.forwardSecurity(true)
+		.groupCalls(true)
+		.editMessages(true)
+		.deleteMessages(true)
+		.build();
+
 	public static IdentityStoreInterface getIdentityStoreForUser(User user) {
 		return new InMemoryIdentityStore(user.identity, null, user.privateKey, user.identity);
 	}
 
-	public static Contact getContactForUser(User user) {
+	public static Contact getContactForUser(@NonNull User user) {
 		return new DummyContact(user.identity, NaCl.derivePublicKey(user.privateKey));
 	}
 
+	public static BasicContact getBasicContactForUser(@NonNull User user) {
+		return BasicContact.javaCreate(
+			user.identity,
+			NaCl.derivePublicKey(user.privateKey),
+			featureMask,
+			IdentityState.ACTIVE,
+			IdentityType.NORMAL
+		);
+	}
+
 	public static class User {
 		final String identity;
 		final byte[] privateKey;
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt
deleted file mode 100644
index fc1ee2c6..00000000
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/ForwardSecurityMessageProcessorWrapper.kt
+++ /dev/null
@@ -1,126 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.helpers
-
-import ch.threema.base.ThreemaException
-import ch.threema.domain.models.Contact
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityDecryptionResult
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityEncryptionResult
-import ch.threema.domain.protocol.csp.fs.ForwardSecurityMessageProcessor
-import ch.threema.domain.protocol.csp.fs.PeerRatchetIdentifier
-import ch.threema.domain.protocol.csp.messages.AbstractMessage
-import ch.threema.domain.protocol.csp.messages.BadMessageException
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityData
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataAccept
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataInit
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataReject
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityDataTerminate
-import ch.threema.domain.protocol.csp.messages.fs.ForwardSecurityEnvelopeMessage
-import ch.threema.domain.stores.DHSessionStoreException
-import ch.threema.domain.taskmanager.ActiveTaskCodec
-import ch.threema.protobuf.csp.e2e.fs.Terminate.Cause
-import kotlinx.coroutines.runBlocking
-
-/**
- * This class can be used for testing the forward security message processor. It can be used to call
- * the suspend functions blocking and is therefore compatible with java code. Note that this must be
- * only used for testing as this does not make use of suspendable functions.
- */
-class ForwardSecurityMessageProcessorWrapper(
-    private val fsmp: ForwardSecurityMessageProcessor,
-) {
-    @Throws(ThreemaException::class)
-    fun makeMessage(
-        contact: Contact,
-        innerMessage: AbstractMessage,
-        handle: ActiveTaskCodec,
-    ): ForwardSecurityEncryptionResult {
-        return fsmp.makeMessage(contact, innerMessage, handle)
-    }
-
-    @Throws(
-        DHSessionStoreException::class,
-        ForwardSecurityData.InvalidEphemeralPublicKeyException::class
-    )
-    fun runFsRefreshSteps(contact: Contact, handle: ActiveTaskCodec) {
-        runBlocking {
-            fsmp.runFsRefreshSteps(contact, handle)
-        }
-    }
-
-    fun commitSessionState(result: ForwardSecurityEncryptionResult) {
-        fsmp.commitSessionState(result)
-    }
-
-    @Throws(DHSessionStoreException::class)
-    fun commitPeerRatchet(peerRatchetIdentifier: PeerRatchetIdentifier, handle: ActiveTaskCodec) {
-        fsmp.commitPeerRatchet(peerRatchetIdentifier, handle)
-    }
-
-    @Throws(ThreemaException::class, BadMessageException::class)
-    fun processInit(contact: Contact, init: ForwardSecurityDataInit, handle: ActiveTaskCodec) {
-        runBlocking {
-            fsmp.processInit(contact, init, handle)
-        }
-    }
-
-    @Throws(ThreemaException::class, BadMessageException::class)
-    fun processAccept(contact: Contact, accept: ForwardSecurityDataAccept, handle: ActiveTaskCodec) {
-        runBlocking {
-            fsmp.processAccept(contact, accept, handle)
-        }
-    }
-
-    @Throws(DHSessionStoreException::class)
-    fun processReject(contact: Contact, reject: ForwardSecurityDataReject, handle: ActiveTaskCodec) {
-        runBlocking {
-            fsmp.processReject(contact, reject, handle)
-        }
-    }
-
-    @Throws(ThreemaException::class, BadMessageException::class)
-    fun processMessage(contact: Contact, envelopeMessage: ForwardSecurityEnvelopeMessage, handle: ActiveTaskCodec): ForwardSecurityDecryptionResult {
-        return runBlocking {
-            fsmp.processMessage(contact, envelopeMessage, handle)
-        }
-    }
-
-    @Throws(DHSessionStoreException::class)
-    fun processTerminate(contact: Contact, message: ForwardSecurityDataTerminate) {
-        runBlocking {
-            fsmp.processTerminate(contact, message)
-        }
-    }
-
-    fun clearAndTerminateAllSessions(contact: Contact, cause: Cause, handle: ActiveTaskCodec) {
-        runBlocking {
-            fsmp.clearAndTerminateAllSessions(contact, cause, handle)
-        }
-    }
-
-    @Throws(DHSessionStoreException::class)
-    fun terminateAllInvalidSessions(contact: Contact, handle: ActiveTaskCodec) {
-        runBlocking {
-            fsmp.terminateAllInvalidSessions(contact, handle)
-        }
-    }
-}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java
index 18a5bb5c..17a28e28 100644
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java
+++ b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryContactStore.java
@@ -27,6 +27,7 @@ import java.util.Map;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import ch.threema.domain.models.Contact;
+import ch.threema.domain.models.BasicContact;
 import ch.threema.domain.stores.ContactStore;
 
 /**
@@ -34,7 +35,7 @@ import ch.threema.domain.stores.ContactStore;
  */
 public class InMemoryContactStore implements ContactStore {
 	private final Map<String, Contact> contacts = new HashMap<>();
-	private final Map<String, Contact> contactsCache = new HashMap<>();
+	private final Map<String, BasicContact> contactsCache = new HashMap<>();
 
 	@Override
 	public Contact getContactForIdentity(@NonNull String identity) {
@@ -47,13 +48,14 @@ public class InMemoryContactStore implements ContactStore {
 	}
 
 	@Override
-	public void removeContact(@NonNull Contact contact) {
-		this.contacts.remove(contact.getIdentity());
+	public void addCachedContact(@NonNull BasicContact contact) {
+		this.contactsCache.put(contact.getIdentity(), contact);
 	}
 
+	@Nullable
 	@Override
-	public void addCachedContact(@NonNull Contact contact) {
-		this.contactsCache.put(contact.getIdentity(), contact);
+	public BasicContact getCachedContact(@NonNull String identity) {
+		return this.contactsCache.get(identity);
 	}
 
 	@Nullable
@@ -66,4 +68,9 @@ public class InMemoryContactStore implements ContactStore {
 
 		return getContactForIdentity(identity);
 	}
+
+	@Override
+	public boolean isSpecialContact(@NonNull String identity) {
+		return false;
+	}
 }
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryDHSessionStore.java b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryDHSessionStore.java
deleted file mode 100644
index 15ee777b..00000000
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryDHSessionStore.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2022-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.helpers;
-
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import ch.threema.domain.fs.DHSession;
-import ch.threema.domain.fs.DHSessionId;
-import ch.threema.domain.stores.DHSessionStoreInterface;
-import ch.threema.domain.taskmanager.ActiveTaskCodec;
-
-/**
- * Dummy DH session store for testing purposes only (not optimized).
- */
-public class InMemoryDHSessionStore implements DHSessionStoreInterface {
-	final private List<DHSession> dhSessionList;
-
-	public InMemoryDHSessionStore() {
-		this.dhSessionList = new LinkedList<>();
-	}
-
-	@Nullable
-	@Override
-	public DHSession getDHSession(String myIdentity, String peerIdentity, DHSessionId sessionId, @NonNull ActiveTaskCodec handle) {
-		for (DHSession session : dhSessionList) {
-			if (session.getMyIdentity().equals(myIdentity) &&
-				session.getPeerIdentity().equals(peerIdentity) &&
-				session.getId().equals(sessionId)
-			) {
-				return session;
-			}
-		}
-		return null;
-	}
-
-	@Nullable
-	@Override
-	public DHSession getBestDHSession(String myIdentity, String peerIdentity, @NonNull ActiveTaskCodec handle) {
-		DHSession currentBestSession = null;
-
-		for (DHSession session : dhSessionList) {
-			if (!session.getMyIdentity().equals(myIdentity) || !session.getPeerIdentity().equals(peerIdentity)) {
-				continue;
-			}
-
-			if (currentBestSession == null ||
-				(currentBestSession.getMyRatchet4DH() == null && session.getMyRatchet4DH() != null) ||
-				(session.getMyRatchet4DH() != null && currentBestSession.getId().compareTo(session.getId()) > 0)) {
-				currentBestSession = session;
-			}
-		}
-
-		return currentBestSession;
-	}
-
-	@NonNull
-	@Override
-	public List<DHSession> getAllDHSessions(@NonNull String myIdentity,
-	                                        @NonNull String peerIdentity,
-	                                        @NonNull ActiveTaskCodec handle) {
-		List<DHSession> sessions = new ArrayList<>();
-
-		for (DHSession session : dhSessionList) {
-			if (session.getMyIdentity().equals(myIdentity) && session.getPeerIdentity().equals(peerIdentity)) {
-				sessions.add(session);
-			}
-		}
-
-		return sessions;
-	}
-
-	@Override
-	public void storeDHSession(DHSession session) {
-		deleteDHSession(session.getMyIdentity(), session.getPeerIdentity(), session.getId());
-		dhSessionList.add(session);
-	}
-
-	@Override
-	public boolean deleteDHSession(String myIdentity, String peerIdentity, DHSessionId sessionId) {
-		for (Iterator<DHSession> it = this.dhSessionList.iterator(); it.hasNext(); ) {
-			DHSession curSession = it.next();
-			if (curSession.getMyIdentity().equals(myIdentity) &&
-				curSession.getPeerIdentity().equals(peerIdentity) &&
-				curSession.getId().equals(sessionId)) {
-				it.remove();
-				return true;
-			}
-		}
-		return false;
-	}
-
-	@Override
-	public int deleteAllDHSessions(String myIdentity, String peerIdentity) {
-		int numDeleted = 0;
-		for (Iterator<DHSession> it = this.dhSessionList.iterator(); it.hasNext(); ) {
-			DHSession session = it.next();
-			if (session.getMyIdentity().equals(myIdentity) && session.getPeerIdentity().equals(peerIdentity)) {
-				it.remove();
-				numDeleted++;
-			}
-		}
-		return numDeleted;
-	}
-
-	@Override
-	public int deleteAllSessionsExcept(String myIdentity, String peerIdentity, DHSessionId exceptSessionId, boolean fourDhOnly) {
-		int numDeleted = 0;
-		for (Iterator<DHSession> it = this.dhSessionList.iterator(); it.hasNext(); ) {
-			DHSession session = it.next();
-			if (session.getMyIdentity().equals(myIdentity) &&
-				session.getPeerIdentity().equals(peerIdentity) &&
-				(!fourDhOnly || session.getMyRatchet4DH() != null) &&
-				!exceptSessionId.equals(session.getId())) {
-				it.remove();
-				numDeleted++;
-			}
-		}
-		return numDeleted;
-	}
-
-	@Override
-	public void setDHSessionStoreErrorHandler(@NonNull DHSessionStoreErrorHandler errorHandler) {
-		// Nothing to do here
-	}
-
-	@Override
-	public void executeNull() {
-		// Nothing to do as the in memory dh session store does not support upgrades and downgrades
-	}
-}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.java b/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.java
deleted file mode 100644
index 369ca5a7..00000000
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/InMemoryNonceStore.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2021-2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.helpers;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import ch.threema.base.crypto.NonceStore;
-
-/**
- * An in-memory identity store, used for testing.
- */
-public class InMemoryNonceStore implements NonceStore {
-	private final HashSet<byte[]> nonces = new HashSet<>();
-
-	@Override
-	public boolean exists(@NonNull byte[] nonce) {
-		return this.nonces.contains(nonce);
-	}
-
-	@Override
-	public boolean store(@NonNull byte[] nonce) {
-		return this.nonces.add(nonce);
-	}
-
-	@NonNull
-	@Override
-	public List<byte[]> getAllHashedNonces() {
-		List<byte[]> hashedNonces = new ArrayList<>(nonces.size());
-		hashedNonces.addAll(nonces);
-		return hashedNonces;
-	}
-}
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt
deleted file mode 100644
index ee67f836..00000000
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/ServerAckTaskCodec.kt
+++ /dev/null
@@ -1,130 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.helpers
-
-import ch.threema.domain.models.MessageId
-import ch.threema.domain.protocol.connection.data.CspMessage
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-import ch.threema.domain.protocol.csp.ProtocolDefines
-import ch.threema.domain.protocol.csp.coders.MessageBox
-import ch.threema.domain.taskmanager.MessageFilterInstruction
-import ch.threema.domain.taskmanager.TaskCodec
-import kotlinx.coroutines.runBlocking
-
-/**
- * This task codec is used only for tests. It acts as the server and creates server acknowledgements
- * for the sent messages. Messages sent using this task codec are never sent to the server.
- */
-open class ServerAckTaskCodec : TaskCodec {
-    val inboundMessages = mutableListOf<InboundMessage>()
-    val outboundMessages = mutableListOf<OutboundMessage>()
-    val ackedIncomingMessages = mutableListOf<MessageId>()
-    val reflectedMessages = mutableListOf<OutboundMessage>()
-
-    override suspend fun read(preProcess: (InboundMessage) -> MessageFilterInstruction): InboundMessage {
-        for (inboundMessage in inboundMessages) {
-            when (preProcess(inboundMessage)) {
-                MessageFilterInstruction.ACCEPT -> {
-                    inboundMessages.remove(inboundMessage)
-                    return inboundMessage
-                }
-
-                // No need to bypass or backlog messages in test codec
-                MessageFilterInstruction.BYPASS_OR_BACKLOG -> continue
-
-                // No need to reject messages in test codec
-                MessageFilterInstruction.REJECT -> continue
-            }
-        }
-
-        throw AssertionError("No message provided that was expected")
-    }
-
-    open fun writeAsync(message: OutboundMessage) {
-        runBlocking {
-            write(message)
-        }
-    }
-
-    override suspend fun write(message: OutboundMessage) {
-        outboundMessages.add(message)
-
-        val cspMessage = message as CspMessage
-        when (cspMessage.payloadType.toInt()) {
-            ProtocolDefines.PLTYPE_OUTGOING_MESSAGE -> {
-                handleOutgoingMessage(cspMessage)
-            }
-
-            ProtocolDefines.PLTYPE_INCOMING_MESSAGE_ACK -> {
-                handleIncomingMessageAck(cspMessage)
-            }
-        }
-    }
-
-    override suspend fun reflect(message: OutboundMessage) {
-        reflectedMessages.add(message)
-    }
-
-    /**
-     * The server ack task codec creates the server ack here. Other tasks may perform additional
-     * tasks or override this behavior completely.
-     */
-    protected open suspend fun handleOutgoingMessageBox(messageBox: MessageBox) {
-        if ((messageBox.flags and ProtocolDefines.MESSAGE_FLAG_NO_SERVER_ACK) == 0) {
-            // Create a server ack and add it to the inbound message queue, as the server
-            val serverAck = createServerAck(messageBox)
-            inboundMessages.add(serverAck)
-        }
-    }
-
-    /**
-     * This is called when a message has been sent using this task codec.
-     */
-    private suspend fun handleOutgoingMessage(cspMessage: CspMessage) {
-        val messageBox = parseMessageBox(cspMessage)
-        handleOutgoingMessageBox(messageBox)
-    }
-
-    /**
-     * This is called when an ack for an incoming message has been sent using this task codec.
-     */
-    private fun handleIncomingMessageAck(cspMessage: CspMessage) {
-        val data = cspMessage.toIncomingMessageAck()
-        ackedIncomingMessages.add(data.messageId)
-    }
-
-    private fun parseMessageBox(cspMessage: CspMessage): MessageBox {
-        val data = cspMessage.toOutgoingMessageData()
-        return MessageBox.parseBinary(data.data)
-    }
-
-    private fun createServerAck(messageBox: MessageBox): CspMessage {
-        val outgoingMessageAckData =
-            messageBox.toIdentity.encodeToByteArray() + messageBox.messageId.messageId
-        return CspMessage(
-            ProtocolDefines.PLTYPE_OUTGOING_MESSAGE_ACK.toUByte(),
-            outgoingMessageAckData
-        )
-    }
-}
-
diff --git a/domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt b/domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt
deleted file mode 100644
index 983b84b3..00000000
--- a/domain/src/testFixtures/java/ch/threema/domain/helpers/UnusedTaskCodec.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.domain.helpers
-
-import ch.threema.domain.protocol.connection.data.InboundMessage
-import ch.threema.domain.protocol.connection.data.OutboundMessage
-import ch.threema.domain.taskmanager.MessageFilterInstruction
-import ch.threema.domain.taskmanager.TaskCodec
-
-/**
- * This task codec can be used in tests as placeholder. Note that this task codec throws
- * [IllegalStateException] when one of its methods is called.
- */
-class UnusedTaskCodec : TaskCodec {
-    override suspend fun read(preProcess: (InboundMessage) -> MessageFilterInstruction): InboundMessage {
-        throw IllegalStateException("This task codec should not be used.")
-    }
-
-    override suspend fun write(message: OutboundMessage) {
-        throw IllegalStateException("This task codec should not be used.")
-    }
-
-    override suspend fun reflect(message: OutboundMessage) {
-        throw IllegalStateException("This task codec should not be used.")
-    }
-}
diff --git a/test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt b/test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt
deleted file mode 100644
index 8412b66f..00000000
--- a/test-helpers/src/main/java/ch/threema/testhelpers/TestHelpers.kt
+++ /dev/null
@@ -1,46 +0,0 @@
-/*  _____ _
- * |_   _| |_  _ _ ___ ___ _ __  __ _
- *   | | | ' \| '_/ -_) -_) '  \/ _` |_
- *   |_| |_||_|_| \___\___|_|_|_\__,_(_)
- *
- * Threema for Android
- * Copyright (c) 2024 Threema GmbH
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License, version 3,
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program. If not, see <https://www.gnu.org/licenses/>.
- */
-
-package ch.threema.testhelpers
-
-import kotlin.random.Random
-
-/**
- * Generate an array of length `length` and fill it using a non-cryptographically-secure
- * random number generator.
- *
- * (This is fine since it's only a test util.)
- */
-fun nonSecureRandomArray(length: Int): ByteArray {
-    return Random.nextBytes(length)
-}
-
-/**
- * Generate a random Threema ID using a non-cryptographically-secure random number generator.
- *
- * (This is fine since it's only a test util.)
- */
-fun randomIdentity(): String {
-    val allowedChars = ('A'..'Z') + ('0'..'9')
-    return (1..8)
-        .map { allowedChars.random() }
-        .joinToString("")
-}
