diff --git a/project/AcDisplay/src/main/java/android/media/RemoteController.java b/project/AcDisplay/src/main/java/android/media/RemoteController.java
new file mode 100644
index 00000000..3c676bdd
--- /dev/null
+++ b/project/AcDisplay/src/main/java/android/media/RemoteController.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package android.media;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.view.KeyEvent;
+
+public class RemoteController {
+
+    public RemoteController(Context context, OnClientUpdateListener l) {
+        throw new RuntimeException("Shit happened!");
+    }
+
+    public boolean setArtworkConfiguration(int width, int height) {
+        return false;
+    }
+
+    public boolean sendMediaKeyEvent(KeyEvent keyEvent) { return true; }
+
+    public class MetadataEditor {
+
+        public synchronized String getString(int key, String defaultValue) {
+            return null;
+        }
+
+        public synchronized long getLong(int key, long defaultValue) {
+            return 0;
+        }
+
+        public synchronized Bitmap getBitmap(int key, Bitmap defaultValue) {
+            return null;
+        }
+
+    }
+
+    public interface OnClientUpdateListener {
+
+        public void onClientChange(boolean clearing);
+
+        public void onClientMetadataUpdate(RemoteController.MetadataEditor metadataEditor);
+
+        public void onClientPlaybackStateUpdate(int state, long stateChangeTimeMs, long currentPosMs, float speed);
+
+        public void onClientPlaybackStateUpdate(int state);
+
+        public void onClientTransportControlUpdate(int transportControlFlags);
+
+    }
+}
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/App.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/App.java
index d230dc5d..f9087a14 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/App.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/App.java
@@ -19,20 +19,30 @@
 package com.achep.acdisplay;
 
 import android.app.Application;
+import android.content.Context;
 
-import com.achep.acdisplay.activemode.ActiveModeService;
 import com.achep.acdisplay.blacklist.Blacklist;
 import com.achep.acdisplay.services.KeyguardService;
+import com.achep.acdisplay.services.activemode.ActiveModeService;
+import com.achep.acdisplay.utils.ToastUtils;
 
 /**
  * Created by Artem on 22.02.14.
  */
 public class App extends Application {
 
-    public static final int ID_NOTIFY_KEYGUARD = 10;
-    public static final int ID_NOTIFY_ACTIVE_MODE = 20;
     public static final int ID_NOTIFY_INIT = 30;
     public static final int ID_NOTIFY_TEST = 40;
+    public static final int ID_NOTIFY_BATH = 50;
+
+    public static final String ACTION_BIND_MEDIA_CONTROL_SERVICE = "com.achep.acdisplay.BIND_MEDIA_CONTROL_SERVICE";
+
+    public static final String ACTION_ENABLE = "com.achep.acdisplay.ENABLE";
+    public static final String ACTION_DISABLE = "com.achep.acdisplay.DISABLE";
+    public static final String ACTION_TOGGLE = "com.achep.acdisplay.TOGGLE";
+
+    public static final String ACTION_EAT_HOME_PRESS_START = "com.achep.acdisplay.EAT_HOME_PRESS_START";
+    public static final String ACTION_EAT_HOME_PRESS_STOP = "com.achep.acdisplay.EAT_HOME_PRESS_STOP";
 
     @Override
     public void onCreate() {
@@ -46,4 +56,13 @@ public class App extends Application {
         KeyguardService.handleState(this);
         ActiveModeService.handleState(this);
     }
+
+    /**
+     * Starts Easter Eggs' activity.
+     */
+    // TODO: Put an Easter egg here.
+    public static void startEasterEggs(Context context) {
+        if (Build.DEBUG) ToastUtils.showShort(context, "There will be an Easter Egg.");
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/AsyncTask.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/AsyncTask.java
index e5e06dd2..4e1ddffc 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/AsyncTask.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/AsyncTask.java
@@ -19,6 +19,16 @@
 
 package com.achep.acdisplay;
 
+import android.util.Log;
+
+import com.achep.acdisplay.utils.FileUtils;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.lang.ref.WeakReference;
+import java.net.URL;
+
 /**
  * A better {@link com.achep.acdisplay.AsyncTask}.
  *
@@ -40,4 +50,63 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
         cancel(false);
     }
 
+    public static void stop(AsyncTask asyncTask) {
+        if (asyncTask != null && !asyncTask.isFinished()) {
+            asyncTask.cancel();
+        }
+    }
+
+    /**
+     * Downloads text file from internet.
+     *
+     * @author Artem Chepurnoy
+     */
+    public static class DownloadText extends AsyncTask<String, Void, String> {
+
+        private static final String TAG = "DownloadText";
+        private WeakReference<Callback> mCallback;
+
+        /**
+         * Interface definition for a callback to be invoked
+         * when downloading finished or failed.
+         */
+        public interface Callback {
+
+            /**
+             * Called when downloading finished or failed.
+             *
+             * @param text downloaded text, or {@code null} if failed.
+             */
+            void onDownloaded(String text);
+        }
+
+        public DownloadText(Callback callback) {
+            mCallback = new WeakReference<>(callback);
+        }
+
+        @Override
+        protected String doInBackground(String... urls) {
+            try {
+                URL url = new URL(urls[0]);
+                InputStreamReader isr = new InputStreamReader(url.openStream());
+                BufferedReader br = new BufferedReader(isr);
+                return FileUtils.readTextFromBufferedReader(br);
+            } catch (IOException e) {
+                return null;
+            }
+        }
+
+        @Override
+        protected void onPostExecute(String s) {
+            super.onPostExecute(s);
+
+            // Notify listener that downloading done.
+            Callback callback = mCallback.get();
+            if (callback != null) {
+                callback.onDownloaded(s);
+            } else {
+                if (Build.DEBUG) Log.w(TAG, "Finished loading text, but callback is null!");
+            }
+        }
+    }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/Build.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/Build.java
index 7decd919..63800d2b 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/Build.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/Build.java
@@ -29,4 +29,22 @@ public final class Build {
 
     public static final String SUPPORT_EMAIL = "support@artemchep.com";
 
+    /**
+     * It contains most of links of AcDisplay.
+     */
+    public static class Links {
+
+        public static final String REPOSITORY_RAW = "https://raw.githubusercontent.com/AChep/AcDisplay/master/project/AcDisplay/";
+        public static final String REPOSITORY = "https://www.github.com/AChep/AcDisplay";
+
+        public static final String DEVELOPER_PROFILE = "https://plus.google.com/+АртёмЧепурной";
+
+        public static final String TRANSLATE = "https://crowdin.net/project/acdisplay";
+        public static final String FAQ = "https://crowdin.net/project/acdisplay";
+        public static final String DONATE = "https://crowdin.net/project/acdisplay";
+
+        public static final String LIST_OF_DONATORS = "https://plus.google.com/102696863054832206920/posts/7wi3WfWGSfH";
+
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/Config.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/Config.java
index ec57bbab..330ae709 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/Config.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/Config.java
@@ -21,14 +21,24 @@ package com.achep.acdisplay;
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.res.Resources;
+import android.preference.CheckBoxPreference;
+import android.preference.Preference;
+import android.util.DisplayMetrics;
 import android.util.Log;
 import android.util.TypedValue;
 
-import com.achep.acdisplay.activemode.ActiveModeService;
+import com.achep.acdisplay.powertoggles.ToggleReceiver;
 import com.achep.acdisplay.services.KeyguardService;
+import com.achep.acdisplay.services.activemode.ActiveModeService;
 import com.achep.acdisplay.utils.AccessUtils;
 
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.ArrayList;
+import java.util.HashMap;
 
 /**
  * Saves all the configurations for the app.
@@ -67,6 +77,7 @@ public class Config {
     public static final String KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS = "active_mode_without_notifications";
 
     // interface
+    public static final String KEY_UI_FULLSCREEN = "ui_fullscreen";
     public static final String KEY_UI_WALLPAPER_SHOWN = "wallpaper_shown";
     public static final String KEY_UI_SHADOW_TOGGLE = "shadow_toggle";
     public static final String KEY_UI_DYNAMIC_BACKGROUND_MODE = "dynamic_background_mode";
@@ -74,9 +85,19 @@ public class Config {
     public static final int DYNAMIC_BG_NOTIFICATION_MASK = 2;
     public static final String KEY_UI_MIRRORED_TIMEOUT_BAR = "mirrored_timeout_progress_bar";
     public static final String KEY_UI_NOTIFY_CIRCLED_ICON = "notify_circled_icon";
-    public static final String KEY_UI_STATUS_BATTERY_ALWAYS_VISIBLE = "ui_status_battery_always_visible";
-    public static final String KEY_UI_IMMERSIVE_MODE = "immersive_mode_kitkat";
-    public static final String KEY_UI_ICON_SIZE = "ui_icon_size";
+    public static final String KEY_UI_STATUS_BATTERY_STICKY = "ui_status_battery_sticky";
+    public static final String KEY_UI_ICON_SIZE = "ui_condensed_view_size";
+    public static final String ICON_SIZE_PX = "px";
+    public static final String ICON_SIZE_DP = "dp";
+
+    // behavior
+    public static final String KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY = "feel_widget_screen_off_after_last_notify";
+    public static final String KEY_FEEL_WIDGET_PINNABLE = "feel_widget_pinnable";
+    public static final String KEY_FEEL_WIDGET_READABLE = "feel_widget_readable";
+
+    // triggers
+    public static final String KEY_TRIG_PREVIOUS_VERSION = "trigger_previous_version";
+    public static final String KEY_TRIG_HELP_READ = "trigger_help_read";
 
     private static Config sConfig;
 
@@ -85,29 +106,119 @@ public class Config {
     private boolean mActiveMode;
     private boolean mActiveModeWithoutNotifies;
     private boolean mEnabledOnlyWhileCharging;
+    private boolean mScreenOffAfterLastNotify;
+    private boolean mFeelWidgetPinnable;
+    private boolean mFeelWidgetReadable;
     private boolean mNotifyLowPriority;
     private boolean mNotifyWakeUpOn;
     private boolean mTimeoutEnabled;
-    private int mIconSize;
     private int mTimeoutNormal;
     private int mTimeoutShort;
     private int mInactiveTimeFrom;
     private int mInactiveTimeTo;
     private int mUiDynamicBackground;
+    private int mUiIconSize; // dp.
     private boolean mInactiveTimeEnabled;
+    private boolean mUiFullScreen;
     private boolean mUiWallpaper;
     private boolean mUiWallpaperShadow;
     private boolean mUiMirroredTimeoutBar;
-    private boolean mUiBatteryAlwaysVisible;
+    private boolean mUiBatterySticky;
     private boolean mUiNotifyCircledIcon;
-    private boolean mImmersiveMode;
 
-    private boolean mConstAlternativePayments;
+    private Triggers mTriggers;
+    private int mTrigPreviousVersion;
+    private boolean mTrigHelpRead;
+
+    HashMap<String, Option> hashMap;
+
+    public static class Option {
+        private final String setterName;
+        private final String getterName;
+        private final Class clazz;
+
+        public Option(String setterName,
+                      String getterName,
+                      Class clazz) {
+            this.setterName = setterName;
+            this.getterName = getterName;
+            this.clazz = clazz;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return new HashCodeBuilder(11, 31)
+                    .append(setterName)
+                    .append(getterName)
+                    .append(clazz)
+                    .toHashCode();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(Object o) {
+            if (o == null)
+                return false;
+            if (o == this)
+                return true;
+            if (!(o instanceof Option))
+                return false;
+
+            Option option = (Option) o;
+            return new EqualsBuilder()
+                    .append(setterName, option.setterName)
+                    .append(getterName, option.getterName)
+                    .append(clazz, option.clazz)
+                    .isEquals();
+        }
+
+        /**
+         * Reads an option from given config instance.</br>
+         * Reading is done using reflections!
+         *
+         * @param config a config to read from.
+         * @throws java.lang.RuntimeException if failed to read given config.
+         */
+        public Object read(Config config) {
+            try {
+                Method method = Config.class.getDeclaredMethod(getterName);
+                method.setAccessible(true);
+                return method.invoke(config);
+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+                throw new RuntimeException(e.getMessage());
+            }
+        }
+
+
+        /**
+         * Writes new value to the option to given config instance.</br>
+         * Writing is done using reflections!
+         *
+         * @param config a config to write to.
+         * @throws java.lang.RuntimeException if failed to read given config.
+         */
+        public void write(Config config, Context context, Object newValue, OnConfigChangedListener listener) {
+            try {
+                Method method = Config.class.getDeclaredMethod(setterName,
+                        Context.class, clazz,
+                        Config.OnConfigChangedListener.class);
+                method.setAccessible(true);
+                method.invoke(config, context, newValue, listener);
+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+                throw new RuntimeException(e.getMessage());
+            }
+        }
+
+    }
 
     private ArrayList<OnConfigChangedListener> mListeners;
     private Context mContext;
 
-
     // //////////////////////////////////////////
     // /////////// -- LISTENERS -- //////////////
     // //////////////////////////////////////////
@@ -116,11 +227,11 @@ public class Config {
         public void onConfigChanged(Config config, String key, Object value);
     }
 
-    public void addOnConfigChangedListener(OnConfigChangedListener listener) {
+    public void registerListener(OnConfigChangedListener listener) {
         mListeners.add(listener);
     }
 
-    public void removeOnConfigChangedListener(OnConfigChangedListener listener) {
+    public void unregisterListener(OnConfigChangedListener listener) {
         mListeners.remove(listener);
     }
 
@@ -135,7 +246,9 @@ public class Config {
         return sConfig;
     }
 
-    private Config() { /* unused */ }
+    private Config() {
+        mTriggers = new Triggers();
+    }
 
     /**
      * Loads saved values from shared preferences.
@@ -144,6 +257,50 @@ public class Config {
     void init(Context context) {
         mListeners = new ArrayList<>(6);
 
+        hashMap = new HashMap<>();
+        hashMap.put(KEY_ENABLED, new Option(
+                "setEnabled", "isEnabled", boolean.class));
+        hashMap.put(KEY_KEYGUARD, new Option(
+                "setKeyguardEnabled", "isKeyguardEnabled", boolean.class));
+        hashMap.put(KEY_ACTIVE_MODE, new Option(
+                "setActiveModeEnabled", "isActiveModeEnabled", boolean.class));
+        hashMap.put(KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS, new Option(
+                "setActiveModeWithoutNotificationsEnabled",
+                "isActiveModeWithoutNotifiesEnabled", boolean.class));
+        hashMap.put(KEY_NOTIFY_LOW_PRIORITY, new Option(
+                "setLowPriorityNotificationsAllowed",
+                "isLowPriorityNotificationsAllowed", boolean.class));
+        hashMap.put(KEY_NOTIFY_WAKE_UP_ON, new Option(
+                "setWakeUpOnNotifyEnabled",
+                "isNotifyWakingUp", boolean.class));
+        hashMap.put(KEY_ONLY_WHILE_CHARGING, new Option(
+                "setEnabledOnlyWhileCharging",
+                "isEnabledOnlyWhileCharging", boolean.class));
+        hashMap.put(KEY_UI_FULLSCREEN, new Option(
+                "setFullScreen", "isFullScreen", boolean.class));
+        hashMap.put(KEY_UI_WALLPAPER_SHOWN, new Option(
+                "setWallpaperShown", "isWallpaperShown", boolean.class));
+        hashMap.put(KEY_UI_SHADOW_TOGGLE, new Option(
+                "setShadowEnabled", "isShadowEnabled", boolean.class));
+        hashMap.put(KEY_UI_MIRRORED_TIMEOUT_BAR, new Option(
+                "setMirroredTimeoutProgressBarEnabled",
+                "isMirroredTimeoutProgressBarEnabled", boolean.class));
+        hashMap.put(KEY_UI_NOTIFY_CIRCLED_ICON, new Option(
+                "setCircledLargeIconEnabled",
+                "isCircledLargeIconEnabled", boolean.class));
+        hashMap.put(KEY_UI_STATUS_BATTERY_STICKY, new Option(
+                "setStatusBatterySticky",
+                "isStatusBatterySticky", boolean.class));
+        hashMap.put(KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY, new Option(
+                "setScreenOffAfterLastNotify",
+                "isScreenOffAfterLastNotify", boolean.class));
+        hashMap.put(KEY_FEEL_WIDGET_PINNABLE, new Option(
+                "setWidgetPinnable",
+                "isWidgetPinnable", boolean.class));
+        hashMap.put(KEY_FEEL_WIDGET_READABLE, new Option(
+                "setWidgetReadable",
+                "isWidgetReadable", boolean.class));
+
         Resources res = context.getResources();
         SharedPreferences prefs = getSharedPreferences(context);
         mAcDisplayEnabled = prefs.getBoolean(KEY_ENABLED,
@@ -188,20 +345,26 @@ public class Config {
                 res.getBoolean(R.bool.config_default_ui_mirrored_timeout_bar));
         mUiNotifyCircledIcon = prefs.getBoolean(KEY_UI_NOTIFY_CIRCLED_ICON,
                 res.getBoolean(R.bool.config_default_ui_notify_circled_icon));
-        mUiBatteryAlwaysVisible = prefs.getBoolean(KEY_UI_STATUS_BATTERY_ALWAYS_VISIBLE,
-                res.getBoolean(R.bool.config_default_ui_status_battery_always_visible));
-        mImmersiveMode = prefs.getBoolean(KEY_UI_IMMERSIVE_MODE,
-                res.getBoolean(R.bool.config_default_ui_immersive_mode_kitkat));
-        mIconSize = prefs.getInt(KEY_UI_ICON_SIZE,
-                res.getInteger(R.integer.config_default_ui_icon_size));
+        mUiBatterySticky = prefs.getBoolean(KEY_UI_STATUS_BATTERY_STICKY,
+                res.getBoolean(R.bool.config_default_ui_status_battery_sticky));
+        mUiFullScreen = prefs.getBoolean(KEY_UI_FULLSCREEN,
+                res.getBoolean(R.bool.config_default_ui_full_screen));
+        mUiIconSize = prefs.getInt(KEY_UI_ICON_SIZE,
+                res.getInteger(R.integer.config_default_ui_icon_size_dp));
 
         // other
         mEnabledOnlyWhileCharging = prefs.getBoolean(KEY_ONLY_WHILE_CHARGING,
                 res.getBoolean(R.bool.config_default_enabled_only_while_charging));
+        mScreenOffAfterLastNotify = prefs.getBoolean(KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY,
+                res.getBoolean(R.bool.config_default_feel_screen_off_after_last_notify));
+        mFeelWidgetPinnable = prefs.getBoolean(KEY_FEEL_WIDGET_PINNABLE,
+                res.getBoolean(R.bool.config_default_feel_widget_pinnable));
+        mFeelWidgetReadable = prefs.getBoolean(KEY_FEEL_WIDGET_READABLE,
+                res.getBoolean(R.bool.config_default_feel_widget_readable));
 
-        // const
-        mConstAlternativePayments =
-                res.getBoolean(R.bool.config_alternative_payments);
+        // triggers
+        mTrigHelpRead = prefs.getBoolean(KEY_TRIG_HELP_READ, false);
+        mTrigPreviousVersion = prefs.getInt(KEY_TRIG_PREVIOUS_VERSION, 0);
     }
 
     static SharedPreferences getSharedPreferences(Context context) {
@@ -216,6 +379,17 @@ public class Config {
         return mContext;
     }
 
+    public HashMap<String, Option> getHashMap() {
+        return hashMap;
+    }
+
+    /**
+     * Separated group of different internal triggers.
+     */
+    public Triggers getTriggers() {
+        return mTriggers;
+    }
+
     private void notifyConfigChanged(String key, Object value, OnConfigChangedListener listener) {
         for (OnConfigChangedListener l : mListeners) {
             if (l == listener) continue;
@@ -230,13 +404,15 @@ public class Config {
             return;
         }
 
-        if (Build.DEBUG) Log.d(TAG, "Saving \"" + key + "\" to config as \"" + value + "\"");
+        if (Build.DEBUG) Log.d(TAG, "Writing \"" + key + "=" + value + "\" to config.");
 
         SharedPreferences.Editor editor = getSharedPreferences(context).edit();
         if (value instanceof Boolean) {
             editor.putBoolean(key, (Boolean) value);
         } else if (value instanceof Integer) {
             editor.putInt(key, (Integer) value);
+        } else if (value instanceof Float) {
+            editor.putFloat(key, (Float) value);
         } else throw new IllegalArgumentException("Unknown option type.");
         editor.apply();
 
@@ -254,19 +430,25 @@ public class Config {
      */
     public boolean setEnabled(Context context, boolean enabled,
                               OnConfigChangedListener listener) {
+        boolean changed = mAcDisplayEnabled != (mAcDisplayEnabled = enabled);
+
+        if (!changed) {
+            return true;
+        }
         if (enabled
-                && !(AccessUtils.isNotificationAccessEnabled(context)
-                && AccessUtils.isDeviceAdminEnabled(context))) {
+                && !(AccessUtils.isNotificationAccessGranted(context)
+                && AccessUtils.isDeviceAdminAccessGranted(context))) {
             return false;
         }
 
-        boolean changed = mAcDisplayEnabled != (mAcDisplayEnabled = enabled);
         saveOption(context, KEY_ENABLED, enabled, listener, changed);
 
         if (changed) {
             ActiveModeService.handleState(context);
             KeyguardService.handleState(context);
         }
+
+        ToggleReceiver.sendStateUpdate(ToggleReceiver.class, enabled, context);
         return true;
     }
 
@@ -302,8 +484,8 @@ public class Config {
     /**
      * Setter to only have the app running while charging.
      */
-    public void setActiveDisplayEnabledOnlyWhileCharging(Context context, boolean enabled,
-                                                         OnConfigChangedListener listener) {
+    public void setEnabledOnlyWhileCharging(Context context, boolean enabled,
+                                            OnConfigChangedListener listener) {
         boolean changed = mEnabledOnlyWhileCharging != (mEnabledOnlyWhileCharging = enabled);
         saveOption(context, KEY_ONLY_WHILE_CHARGING, enabled, listener, changed);
 
@@ -323,7 +505,7 @@ public class Config {
     }
 
     public void setWakeUpOnNotifyEnabled(Context context, boolean enabled,
-                                                   OnConfigChangedListener listener) {
+                                         OnConfigChangedListener listener) {
         boolean changed = mNotifyWakeUpOn != (mNotifyWakeUpOn = enabled);
         saveOption(context, KEY_NOTIFY_WAKE_UP_ON, enabled, listener, changed);
     }
@@ -412,27 +594,49 @@ public class Config {
         saveOption(context, KEY_UI_NOTIFY_CIRCLED_ICON, enabled, listener, changed);
     }
 
-    public void setBatteryAlwaysVisible(Context context, boolean visible, OnConfigChangedListener listener) {
-        boolean changed = mUiBatteryAlwaysVisible != (mUiBatteryAlwaysVisible = visible);
-        saveOption(context, KEY_UI_STATUS_BATTERY_ALWAYS_VISIBLE, visible, listener, changed);
+    public void setStatusBatterySticky(Context context, boolean visible, OnConfigChangedListener listener) {
+        boolean changed = mUiBatterySticky != (mUiBatterySticky = visible);
+        saveOption(context, KEY_UI_STATUS_BATTERY_STICKY, visible, listener, changed);
+    }
+
+    public void setWidgetPinnable(Context context, boolean pinnable, OnConfigChangedListener listener) {
+        boolean changed = mFeelWidgetPinnable != (mFeelWidgetPinnable = pinnable);
+        saveOption(context, KEY_FEEL_WIDGET_PINNABLE, pinnable, listener, changed);
+    }
+
+    public void setWidgetReadable(Context context, boolean readable, OnConfigChangedListener listener) {
+        boolean changed = mFeelWidgetReadable != (mFeelWidgetReadable = readable);
+        saveOption(context, KEY_FEEL_WIDGET_READABLE, readable, listener, changed);
     }
 
     /**
      * Setter for Immersive Mode
      */
-    public void setImmersiveMode(Context context, boolean enabled, OnConfigChangedListener listener) {
-        boolean changed = mImmersiveMode != (mImmersiveMode = enabled);
-        saveOption(context, KEY_UI_IMMERSIVE_MODE, enabled, listener, changed);
+    public void setFullScreen(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mUiFullScreen != (mUiFullScreen = enabled);
+        saveOption(context, KEY_UI_FULLSCREEN, enabled, listener, changed);
     }
 
     /**
-     * Setter for Icon Size
+     * Sets the size (or height only) of collapsed views.
+     *
+     * @param size preferred size in dip.
+     * @see #getIconSizePx()
+     * @see #getIconSize(String)
      */
-    public void setIconSize(Context context, int size, OnConfigChangedListener listener) {
-        boolean changed = mIconSize != (mIconSize = size);
+    public void setIconSizeDp(Context context, int size, OnConfigChangedListener listener) {
+        boolean changed = mUiIconSize != (mUiIconSize = size);
         saveOption(context, KEY_UI_ICON_SIZE, size, listener, changed);
     }
 
+    /**
+     * Setter to turn the screen off after dismissing the last notification.
+     */
+    public void setScreenOffAfterLastNotify(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mScreenOffAfterLastNotify != (mScreenOffAfterLastNotify = enabled);
+        saveOption(context, KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY, enabled, listener, changed);
+    }
+
     public int getTimeoutNormal() {
         return mTimeoutNormal;
     }
@@ -449,22 +653,34 @@ public class Config {
         return mInactiveTimeTo;
     }
 
-    public int getIconSize(){ return getIconSize("dip");}
+    public int getDynamicBackgroundMode() {
+        return mUiDynamicBackground;
+    }
 
-    public int getIconSize(String s) {
-        if(s == "px"){
-            Resources r = Resources.getSystem();
-            int mIconPX = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, mIconSize, r.getDisplayMetrics());
-            Log.d(TAG, ""+mIconPX);
-            return mIconPX;
-        }else{
-            Log.d(TAG, ""+mIconSize);
-            return mIconSize;
-        }
+    /**
+     * @return the size (or height only) of collapsed views in pixels.
+     * @see #getIconSize(String)
+     */
+    public int getIconSizePx() {
+        return getIconSize(ICON_SIZE_PX);
     }
 
-    public int getDynamicBackgroundMode() {
-        return mUiDynamicBackground;
+    /**
+     * @return the size (or height only) of collapsed views.
+     * @see #getIconSizePx()
+     * @see #ICON_SIZE_DP
+     * @see #ICON_SIZE_PX
+     */
+    public int getIconSize(String type) {
+        switch (type) {
+            case ICON_SIZE_PX:
+                DisplayMetrics dm = Resources.getSystem().getDisplayMetrics();
+                return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, mUiIconSize, dm);
+            case ICON_SIZE_DP:
+                return mUiIconSize;
+            default:
+                throw new IllegalArgumentException(type + " is not a valid icon size type.");
+        }
     }
 
     public boolean isEnabled() {
@@ -507,8 +723,16 @@ public class Config {
         return mUiNotifyCircledIcon;
     }
 
-    public boolean isBatteryAlwaysVisible() {
-        return mUiBatteryAlwaysVisible;
+    public boolean isStatusBatterySticky() {
+        return mUiBatterySticky;
+    }
+
+    public boolean isWidgetPinnable() {
+        return mFeelWidgetPinnable;
+    }
+
+    public boolean isWidgetReadable() {
+        return mFeelWidgetReadable;
     }
 
     public boolean isMirroredTimeoutProgressBarEnabled() {
@@ -523,16 +747,188 @@ public class Config {
         return mTimeoutEnabled;
     }
 
-    public boolean isAlternativePaymentsEnabled() {
-        return mConstAlternativePayments;
+    public boolean isFullScreen() {
+        return mUiFullScreen;
     }
 
-    public boolean isImmersible(){
-        if(Device.hasKitKatApi()) {
-            return mImmersiveMode;
-        }else{
-            return false;
+    public boolean isScreenOffAfterLastNotify() {
+        return mScreenOffAfterLastNotify;
+    }
+
+    /**
+     * A class that syncs {@link android.preference.Preference} with its
+     * value in config.
+     *
+     * @author Artem Chepurnoy
+     */
+    public static class Syncer {
+
+        private final ArrayList<Group> mGroups;
+        private final Context mContext;
+        private final Config mConfig;
+
+        private boolean mBroadcasting;
+        private boolean mStarted;
+
+        private Preference.OnPreferenceChangeListener mPreferenceListener = new Preference.OnPreferenceChangeListener() {
+            @Override
+            public boolean onPreferenceChange(Preference preference, Object newValue) {
+                if (mBroadcasting) {
+                    return true;
+                }
+
+                Group group = null;
+                for (Group c : mGroups) {
+                    if (preference == c.preference) {
+                        group = c;
+                        break;
+                    }
+                }
+
+                assert group != null;
+
+                group.option.write(mConfig, mContext, newValue, mConfigListener);
+                return true;
+            }
+        };
+
+        private OnConfigChangedListener mConfigListener = new OnConfigChangedListener() {
+
+            @Override
+            public void onConfigChanged(Config config, String key, Object value) {
+                Group group = null;
+                for (Group c : mGroups) {
+                    if (key.equals(c.preference.getKey())) {
+                        group = c;
+                        break;
+                    }
+                }
+
+                if (group == null) {
+                    return;
+                }
+
+                setPreferenceValue(group, value);
+            }
+
+        };
+
+        private void setPreferenceValue(Group group, Object value) {
+            mBroadcasting = true;
+
+            Option option = group.option;
+            if (option.clazz.equals(boolean.class)) {
+                CheckBoxPreference preference = (CheckBoxPreference) group.preference;
+                preference.setChecked((boolean) value);
+            }
+
+            mBroadcasting = false;
+        }
+
+        /**
+         * A class-merge of {@link android.preference.Preference}
+         * and its {@link com.achep.acdisplay.Config.Option}.
+         *
+         * @author Artem Chepurnoy
+         */
+        private static class Group {
+            Preference preference;
+            Option option;
+
+            public Group(Config config, Preference preference) {
+                this.preference = preference;
+                this.option = config.getHashMap().get(preference.getKey());
+            }
+        }
+
+        public Syncer(Context context, Config config) {
+            mGroups = new ArrayList<>(10);
+            mContext = context;
+            mConfig = config;
+        }
+
+        public Syncer addPreference(Preference preference) {
+            if (preference instanceof CheckBoxPreference) {
+                Group group = new Group(mConfig, preference);
+                mGroups.add(group);
+
+                if (mStarted) {
+                    startListeningGroup(group);
+                }
+                return this;
+            }
+
+            throw new IllegalArgumentException("Syncer only supports some kinds of Preferences");
+        }
+
+        /**
+         * Updates all preferences and starts to listen to the changes.
+         */
+        public void start() {
+            mStarted = true;
+            mConfig.registerListener(mConfigListener);
+            for (Group group : mGroups) {
+                startListeningGroup(group);
+            }
+        }
+
+        private void startListeningGroup(Group group) {
+            group.preference.setOnPreferenceChangeListener(mPreferenceListener);
+            setPreferenceValue(group, group.option.read(mConfig));
+        }
+
+        /**
+         * Stops to listen to the changes.
+         */
+        public void stop() {
+            mStarted = false;
+            mConfig.unregisterListener(mConfigListener);
+            for (Group group : mGroups) {
+                group.preference.setOnPreferenceChangeListener(null);
+            }
         }
     }
 
+    // //////////////////////////////////////////
+    // //////////// -- TRIGGERS -- //////////////
+    // //////////////////////////////////////////
+
+    /**
+     * Contains
+     *
+     * @author Artem Chepurnoy
+     */
+    public class Triggers {
+
+        public void setPreviousVersion(Context context, int versionCode, OnConfigChangedListener listener) {
+            boolean changed = mTrigPreviousVersion != (mTrigPreviousVersion = versionCode);
+            saveOption(context, KEY_TRIG_PREVIOUS_VERSION, versionCode, listener, changed);
+        }
+
+        public void setHelpRead(Context context, boolean isRead, OnConfigChangedListener listener) {
+            boolean changed = mTrigHelpRead != (mTrigHelpRead = isRead);
+            saveOption(context, KEY_TRIG_HELP_READ, isRead, listener, changed);
+        }
+
+        /**
+         * As set by {@link com.achep.acdisplay.activities.MainActivity}, it returns version
+         * code of previously installed AcDisplay, {@code 0} if first install.
+         *
+         * @return version code of previously installed AcDisplay, {@code 0} if first install.
+         * @see #setPreviousVersion(android.content.Context, int, Config.OnConfigChangedListener)
+         */
+        public int getPreviousVersion() {
+            return mTrigPreviousVersion;
+        }
+
+        /**
+         * @return {@code true} if {@link com.achep.acdisplay.fragments.HelpDialog} been read, {@code false} otherwise
+         * @see #setHelpRead(android.content.Context, boolean, Config.OnConfigChangedListener)
+         */
+        public boolean isHelpRead() {
+            return mTrigHelpRead;
+        }
+
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/Device.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/Device.java
index 5dfafa2b..e6d213c6 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/Device.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/Device.java
@@ -29,16 +29,16 @@ import android.os.Build;
 public class Device {
 
     /**
-     * @return True if device is running
-     * {@link Build.VERSION_CODES#KITKAT KitKat} or higher, False otherwise.
+     * @return {@code true} if device is running
+     * {@link Build.VERSION_CODES#KITKAT KitKat} or higher, {@code false} otherwise.
      */
     public static boolean hasKitKatApi() {
         return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
     }
 
     /**
-     * @return True if device is running
-     * {@link Build.VERSION_CODES#JELLY_BEAN_MR2 Jelly Bean 4.3} or higher, False otherwise.
+     * @return {@code true} if device is running
+     * {@link Build.VERSION_CODES#JELLY_BEAN_MR2 Jelly Bean 4.3} or higher, {@code false} otherwise.
      */
     public static boolean hasJellyBeanMR2Api() {
         return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/DialogHelper.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/DialogHelper.java
index 24345275..132ed079 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/DialogHelper.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/DialogHelper.java
@@ -132,7 +132,7 @@ public class DialogHelper {
          */
         @Override
         public int hashCode() {
-            return new HashCodeBuilder(201, 32)
+            return new HashCodeBuilder(201, 17)
                     .append(mContext)
                     .append(mIcon)
                     .append(mTitleText)
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/InactiveHoursHelper.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/InactiveTimeHelper.java
similarity index 97%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/InactiveHoursHelper.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/InactiveTimeHelper.java
index e37c6a36..4c4b0e0f 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/InactiveHoursHelper.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/InactiveTimeHelper.java
@@ -23,7 +23,7 @@ import android.text.format.Time;
 /**
  * Created by Artem on 10.03.14.
  */
-public class InactiveHoursHelper {
+public class InactiveTimeHelper {
 
     public static boolean isInactiveTime(Config config) {
         Time time = new Time();
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/Presenter.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/Presenter.java
index a65c5a0f..f054b2c7 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/Presenter.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/Presenter.java
@@ -26,7 +26,7 @@ import android.telephony.TelephonyManager;
 import android.util.Log;
 
 import com.achep.acdisplay.acdisplay.AcDisplayActivity;
-import com.achep.acdisplay.services.KeyguardService;
+import com.achep.acdisplay.activities.KeyguardActivity;
 import com.achep.acdisplay.utils.PowerUtils;
 
 import java.util.ArrayList;
@@ -48,7 +48,6 @@ public class Presenter {
     public boolean stop(Context context) {
         //noinspection SimplifiableIfStatement
         if (mActivity != null
-                && mActivity.isCloseableBySensor()
                 && PowerUtils.isScreenOn(context)) {
             return mActivity.lock();
         }
@@ -76,15 +75,13 @@ public class Presenter {
         Config config = Config.getInstance();
 
         kill();
-        KeyguardService.ignoreCurrentTurningOn();
         context.startActivity(new Intent(Intent.ACTION_MAIN, null)
                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
                         | Intent.FLAG_ACTIVITY_NO_USER_ACTION
                         | Intent.FLAG_ACTIVITY_NO_ANIMATION
                         | Intent.FLAG_FROM_BACKGROUND)
-                .putExtra(AcDisplayActivity.EXTRA_TURN_SCREEN_ON, true)
-                .putExtra(AcDisplayActivity.EXTRA_FINISH_ON_SCREEN_OFF, !config.isKeyguardEnabled())
+                .putExtra(KeyguardActivity.EXTRA_TURN_SCREEN_ON, true)
+                .putExtra(KeyguardActivity.EXTRA_FINISH_ON_SCREEN_OFF, !config.isKeyguardEnabled())
                 .setClass(context, AcDisplayActivity.class));
 
         Log.i(TAG, "Launching AcDisplay activity.");
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/Timeout.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/Timeout.java
index bd8cb94b..1cd5dcd8 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/Timeout.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/Timeout.java
@@ -201,8 +201,7 @@ public class Timeout {
     }
 
     /**
-     * Updates given {@link com.achep.acdisplay.widgets.ProgressBar}
-     * due to timeout's event.
+     * Displays timeout's events in given {@link com.achep.acdisplay.widgets.ProgressBar}.
      */
     public static class Gui implements Timeout.OnTimeoutEventListener {
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayActivity.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayActivity.java
index 1c00c6b7..bfe9c303 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayActivity.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayActivity.java
@@ -20,19 +20,10 @@ package com.achep.acdisplay.acdisplay;
 
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.content.Intent;
+import android.annotation.SuppressLint;
 import android.graphics.Bitmap;
-import android.hardware.SensorManager;
-import android.media.AudioManager;
-import android.os.Build;
 import android.os.Bundle;
-import android.os.Handler;
-import android.os.SystemClock;
-import android.view.GestureDetector;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
+import android.util.Log;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
@@ -44,109 +35,71 @@ import com.achep.acdisplay.Operator;
 import com.achep.acdisplay.Presenter;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.Timeout;
-import com.achep.acdisplay.activemode.ActiveModeSensor;
-import com.achep.acdisplay.activemode.ActiveModeService;
 import com.achep.acdisplay.activities.KeyguardActivity;
-import com.achep.acdisplay.widgets.CircleView;
+import com.achep.acdisplay.services.media.MediaController;
 
 /**
  * Created by Artem on 25.01.14.
  */
 public class AcDisplayActivity extends KeyguardActivity implements
-        Timeout.OnTimeoutEventListener, CircleView.Callback {
+        Timeout.OnTimeoutEventListener {
 
     private static final String TAG = "AcDisplayActivity";
 
-    // pending finish
-    private static final int PENDING_FINISH_MAX_TIME = 1000; // ms.
-    private static final int PENDING_FINISH_DELAY = 600; // ms.
-
-    // timeout
-    private static final int TIMEOUT_PANIC_MIN_TIME = 1000; // ms.
-
-    private CircleView mCircleView;
     private ImageView mBackgroundView;
-
     private boolean mCustomBackgroundShown;
-    private boolean mImmersiveMode, mImmersiveModeToggle;
-
-    private GestureDetector mGestureDetector;
-    private Handler mHandler = new Handler();
-    private Timeout mTimeout = new T();
-    private Config mConfig;
-
-    private ActiveModeSensor[] mSensors;
-    private ActiveModeSensor.Callback mSensorCallback = new ActiveModeSensor.Callback() {
-        @Override
-        public void show(ActiveModeSensor sensor) { /* unused */ }
 
-        @Override
-        public void hide(ActiveModeSensor sensor) {
-            if (isCloseableBySensor()) {
-                lock();
-            }
-        }
-    };
-
-    private long mPendingFinishTime;
-    private Runnable mPendingFinishRunnable = new Runnable() {
-        @Override
-        public void run() {
-            unlock(null, true);
-        }
-    };
+    private Timeout mTimeout;
+    private Config mConfig = Config.getInstance();
 
-    private class T extends Timeout {
-
-        @Override
-        public void setTimeoutDelayed(long delayMillis, boolean resetOld) {
-            // This is a "workaround" solution for the
-            // never time out option.
-            if (mConfig.isTimeoutEnabled()) {
-                super.setTimeoutDelayed(delayMillis, resetOld);
-            }
-        }
-    }
-
-    private class GestureListener extends GestureDetector.SimpleOnGestureListener {
-
-        @Override
-        public boolean onSingleTapUp(MotionEvent e) {
-            return false;
-        }
-
-        @Override
-        public boolean onDoubleTap(MotionEvent e) {
-            return lock();
-        }
-    }
+    private MediaController mMediaController;
 
     @Override
     public void onWindowFocusChanged(boolean hasFocus) {
         super.onWindowFocusChanged(hasFocus);
-        handleWindowFocusChanged(hasFocus);
+        populateFlags(hasFocus);
     }
 
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    private void handleWindowFocusChanged(boolean hasFocus) {
+    @SuppressLint("NewApi")
+    private void populateFlags(boolean windowHasFocus) {
         Window window = getWindow();
+        View decorView = window.getDecorView();
 
         int windowFlags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
-        if (hasFocus) {
-            if (mImmersiveModeToggle) {
-                int visibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
-                        | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+
+        if (windowHasFocus) {
+            int visibilityUi = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+                    | View.SYSTEM_UI_FLAG_LOW_PROFILE;
+
+            if (mConfig.isFullScreen()) {
+                // Hide status bar if fullscreen mode is enabled.
+                visibilityUi = visibilityUi
                         | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                         | View.SYSTEM_UI_FLAG_FULLSCREEN;
-                if (mImmersiveMode) visibility |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
-                window.getDecorView().setSystemUiVisibility(visibility);
             }
+
+            if (Device.hasKitKatApi()) {
+                // Hide navigation bar and flag sticky.
+                visibilityUi = visibilityUi
+                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
+                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+            }
+
+            decorView.setSystemUiVisibility(visibilityUi);
             window.addFlags(windowFlags);
 
-            // Start ticking.
             mTimeout.resume();
+            mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
         } else {
+            int visibilityUi = decorView.getSystemUiVisibility();
+            if (Device.hasKitKatApi()) {
+                // Clear immersive sticky flag.
+                // Hopefully it will fix annoying Android feature: IMMERSIVE_PANIC
+                visibilityUi ^= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
+            }
+
+            decorView.setSystemUiVisibility(visibilityUi);
             window.clearFlags(windowFlags);
 
             mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
@@ -156,8 +109,14 @@ public class AcDisplayActivity extends KeyguardActivity implements
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
+        mMediaController = new MediaController();
+        mMediaController.onCreate(this);
+
+        mTimeout = new Timeout();
+        mTimeout.registerListener(this);
+
         super.onCreate(savedInstanceState);
-        mConfig = Config.getInstance();
+
         if (mConfig.isWallpaperShown()) {
             if (mConfig.isShadowEnabled()) {
                 setTheme(R.style.AcDisplayTheme_Wallpaper_WithShadow);
@@ -168,16 +127,6 @@ public class AcDisplayActivity extends KeyguardActivity implements
 
         setContentView(R.layout.acdisplay);
         mBackgroundView = (ImageView) findViewById(R.id.background);
-        mCircleView = (CircleView) findViewById(R.id.circle);
-        mCircleView.setCallback(this);
-
-        mImmersiveMode = Device.hasKitKatApi();
-        mImmersiveModeToggle = getConfig().isImmersible();
-        mGestureDetector = new GestureDetector(this, new GestureListener());
-        mSensors = ActiveModeService.buildAvailableSensorsList(this);
-
-        mTimeout.registerListener(this);
-        mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal());
 
         Presenter.getInstance().attachActivity(this);
     }
@@ -185,77 +134,29 @@ public class AcDisplayActivity extends KeyguardActivity implements
     @Override
     protected void onResume() {
         super.onResume();
-        handleWindowFocusChanged(true);
-        mHandler.removeCallbacks(mPendingFinishRunnable);
 
-        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
-        for (ActiveModeSensor sensor : mSensors) {
-            sensor.registerCallback(mSensorCallback);
-            sensor.onAttached(sensorManager, this);
-        }
+        populateFlags(true);
+        mMediaController.onStart();
     }
 
     @Override
     protected void onPause() {
         super.onPause();
-        mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
-        mTimeout.pause();
-
-        if (SystemClock.elapsedRealtime() - mPendingFinishTime < PENDING_FINISH_MAX_TIME) {
-            mPendingFinishTime = 0;
-            mHandler.postDelayed(
-                    mPendingFinishRunnable,
-                    PENDING_FINISH_DELAY);
-        }
 
-        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
-        for (ActiveModeSensor sensor : mSensors) {
-            sensor.onDetached(sensorManager);
-            sensor.unregisterCallback(mSensorCallback);
-        }
+        populateFlags(false);
+        mMediaController.onStop();
     }
 
     @Override
     protected void onDestroy() {
         super.onDestroy();
+        mMediaController.onDestroy();
+
         mTimeout.unregisterListener(this);
         mTimeout.clear();
-        Presenter.getInstance().detachActivity();
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        boolean handled = false;
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-            case KeyEvent.KEYCODE_VOLUME_UP:
-                if (Operator.bitAnd(event.getFlags(), KeyEvent.FLAG_LONG_PRESS)) {
-
-                    AudioManager am = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
-                    if (am.isMusicActive()) {
-                        handled = true;
-
-                        // sendMediaButtonClick(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN
-                        //         ? KeyEvent.KEYCODE_MEDIA_NEXT
-                        //         : KeyEvent.KEYCODE_MEDIA_PREVIOUS);
-                        // TODO: Go to previous / next track on long press of volume keys (if music is playing).
-                    }
-                }
-                break;
-            default:
-                return super.onKeyDown(keyCode, event);
-        }
-        return super.onKeyDown(keyCode, event);
-    }
+        mTimeout = null;
 
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        // TODO: Skip "Leave immersive mode swipes".
-
-        mCircleView.onTouchEvent2(event);
-        mGestureDetector.onTouchEvent(event);
-
-        return super.onTouchEvent(event);
+        Presenter.getInstance().detachActivity();
     }
 
     @Override
@@ -267,53 +168,6 @@ public class AcDisplayActivity extends KeyguardActivity implements
         }
     }
 
-    @Override
-    public void onCircleEvent(float radius, float ratio, int event) {
-        switch (event) {
-            case CircleView.ACTION_START:
-                mTimeout.pause();
-                break;
-            case CircleView.ACTION_UNLOCK:
-                unlock(null, true);
-                break;
-            case CircleView.ACTION_CANCELED:
-                mTimeout.resume();
-
-                // If remaining time is very low - increase
-                // it to provide user a bit more time to fap
-                // on features.
-                if (mTimeout.getRemainingTime() < TIMEOUT_PANIC_MIN_TIME) {
-                    mTimeout.delay(TIMEOUT_PANIC_MIN_TIME);
-                }
-                break;
-        }
-    }
-
-    @Override
-    public void unlock(Runnable runnable, boolean finish) {
-        super.unlock(runnable, finish);
-        if (!finish) {
-            mPendingFinishTime = SystemClock.elapsedRealtime();
-        }
-    }
-
-    /**
-     * Sends media button's click with given key code.
-     *
-     * @param keyCode May be one of media key events.
-     * @see KeyEvent#KEYCODE_MEDIA_NEXT
-     * @see KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE
-     * @see KeyEvent#KEYCODE_MEDIA_PREVIOUS
-     */
-    private void sendMediaButtonClick(int keyCode) {
-        Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-        KeyEvent keyDown = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
-        KeyEvent keyUp = new KeyEvent(KeyEvent.ACTION_UP, keyCode);
-
-        sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyDown), null);
-        sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyUp), null);
-    }
-
     /**
      * @return an instance of timeout handler.
      */
@@ -322,26 +176,27 @@ public class AcDisplayActivity extends KeyguardActivity implements
     }
 
     /**
-     * @return an instance of timeout config.
+     * @return an instance of config.
      */
     public Config getConfig() {
         return mConfig;
     }
 
-    /**
-     * @return True is this activity may be closed by
-     * {@link com.achep.acdisplay.activemode.ActiveModeSensor active sensors}.
-     */
-    // TODO: Write something better
-    public boolean isCloseableBySensor() {
-        return !mTimeout.isPaused() && hasWindowFocus();
+    public MediaController getMediaController() {
+        return mMediaController;
     }
 
-    public boolean isBackground(int mask) {
-        return Operator.bitAnd(mConfig.getDynamicBackgroundMode(), mask);
+    public void dispatchClearBackground() {
+        dispatchSetBackground(null);
     }
 
-    public void dispatchSetBackground(Bitmap bitmap) {
+    public void dispatchSetBackground(Bitmap bitmap, int mask) {
+        if (mask == 0 || Operator.bitAnd(mConfig.getDynamicBackgroundMode(), mask)) {
+            dispatchSetBackground(bitmap);
+        }
+    }
+
+    private void dispatchSetBackground(Bitmap bitmap) {
         if (bitmap == null) {
             if (mCustomBackgroundShown) {
                 mBackgroundView.animate().cancel();
@@ -360,6 +215,7 @@ public class AcDisplayActivity extends KeyguardActivity implements
             return;
         }
 
+        // TODO: Crossfade background change animation would be really nice.
         float alphaStart = mBackgroundView.getVisibility() == View.GONE ? 0f : 0.4f;
 
         mCustomBackgroundShown = true;
@@ -370,5 +226,4 @@ public class AcDisplayActivity extends KeyguardActivity implements
         mBackgroundView.animate().cancel();
         mBackgroundView.animate().alpha(0.8f).setListener(null);
     }
-
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment.java
index 69da5d69..865017d6 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment.java
@@ -20,14 +20,16 @@
 package com.achep.acdisplay.acdisplay;
 
 import android.animation.Animator;
+import android.animation.AnimatorInflater;
 import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.Fragment;
-import android.content.Context;
-import android.graphics.Bitmap;
 import android.os.Bundle;
 import android.os.Handler;
+import android.os.Message;
 import android.os.SystemClock;
 import android.transition.ChangeBounds;
 import android.transition.Fade;
@@ -42,27 +44,20 @@ import android.view.VelocityTracker;
 import android.view.View;
 import android.view.ViewConfiguration;
 import android.view.ViewGroup;
-import android.view.ViewStub;
-import android.widget.LinearLayout;
 
 import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.Timeout;
-import com.achep.acdisplay.acdisplay.components.NotificationUI;
+import com.achep.acdisplay.acdisplay.components.NotifyWidget;
 import com.achep.acdisplay.acdisplay.components.Widget;
-import com.achep.acdisplay.activities.KeyguardActivity;
 import com.achep.acdisplay.compat.SceneCompat;
 import com.achep.acdisplay.notifications.NotificationPresenter;
 import com.achep.acdisplay.notifications.NotificationUtils;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
+import com.achep.acdisplay.notifications.OpenNotification;
 import com.achep.acdisplay.utils.MathUtils;
-import com.achep.acdisplay.utils.ViewUtils;
-import com.achep.acdisplay.view.ElasticValue;
 import com.achep.acdisplay.view.ForwardingLayout;
 import com.achep.acdisplay.view.ForwardingListener;
-import com.achep.acdisplay.widgets.ProgressBar;
 
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -71,69 +66,60 @@ import java.util.HashMap;
  * This is main fragment of ActiveDisplay app.
  */
 public class AcDisplayFragment extends Fragment implements
-        View.OnTouchListener {
+        NotificationPresenter.OnNotificationListChangedListener,
+        ForwardingLayout.OnForwardedEventListener, View.OnTouchListener,
+        Widget.Callback, Config.OnConfigChangedListener {
 
     private static final String TAG = "AcDisplayFragment";
 
-    public static final int SCENE_UNLOCK = 1;
-    public static final int SCENE_NOTIFICATION = 2;
-    public static final int SCENE_MUSIC_CONTROLS = 3;
-
-    private Config mConfig;
-    private NotificationPresenter mPresenter;
-    private NotificationListener mNotificationListener = new NotificationListener();
+    private static final int MSG_RESET_SCENE = 0;
 
     private ForwardingLayout mSceneContainer;
-    private LinearLayout mCollapsedViewsContainer;
-    private HashMap<View, Widget> mWidgetsMap = new HashMap<>();
-    private HashMap<String, SceneCompat> mScenesMap = new HashMap<>();
-    private boolean mCollapsedViewsNeedsUpdate;
-
-    private Widget mSelectedWidget;
-
-    private SceneCompat mCurrentScene;
-    private SceneCompat mSceneMain;
-    private Transition mTransition;
+    private ForwardingLayout mIconsContainer;
+    private ForwardingListener mSceneForwardingListener;
+    private ForwardingListener mIconsForwardingListener;
+    private Handler mTouchHandler = new Handler();
 
-    private boolean mTouched;
+    // Pinnable widgets
+    private boolean mPinCanReadAloud = false;
+    private Handler mPinHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            super.handleMessage(msg);
+            switch (msg.what) {
+                case MSG_RESET_SCENE:
+                    resetScene();
+            }
+        }
+    };
 
-    private Timeout mTimeout;
-    private Timeout.Gui mTimeoutGui;
-    private ForwardingListener mForwardingListener;
+    // Animations
+    private AnimatorSet mSceneContainerPinAnim;
 
+    // Swipe to dismiss
+    private VelocityTracker mVelocityTracker;
     private int mMaxFlingVelocity;
     private int mMinFlingVelocity;
 
-    public void unlock(Runnable runnable, boolean finish) {
-        Activity activity = getActivity();
-        if (activity instanceof KeyguardActivity) {
-            KeyguardActivity keyguard = (KeyguardActivity) activity;
-            keyguard.unlock(runnable, finish);
-        } else {
-            if (runnable != null) {
-                runnable.run();
-            }
-        }
-    }
+    private HashMap<View, Widget> mWidgetsMap = new HashMap<>();
+    private HashMap<String, SceneCompat> mScenesMap = new HashMap<>();
+    private Widget mSelectedWidget;
+    private View mPressedIconView;
 
-    public void dispatchSetBackground(Bitmap bitmap, int mask) {
-        Activity activity = getActivity();
-        if (activity instanceof AcDisplayActivity) {
-            AcDisplayActivity a = (AcDisplayActivity) activity;
-            a.dispatchSetBackground(a.isBackground(mask) ? bitmap : null);
-        }
-    }
+    private SceneCompat mCurrentScene;
+    private SceneCompat mSceneMain;
+    private Transition mTransition;
 
-    public Config getConfig() {
-        return mConfig;
+    private boolean isPinnable() {
+        return Config.getInstance().isWidgetPinnable();
     }
 
-    private SceneCompat findSceneByWidget(Widget fragment) {
-        return fragment.hasExpandedView() ? mScenesMap.get(fragment.getClass().getName()) : null;
+    private boolean isReadable() {
+        return Config.getInstance().isWidgetReadable();
     }
 
-    private Widget findWidgetByCollapsedView(View view) {
-        return mWidgetsMap.get(view);
+    protected int getViewResource() {
+        return R.layout.acdisplay_fragment;
     }
 
     @Override
@@ -143,397 +129,519 @@ public class AcDisplayFragment extends Fragment implements
         ViewConfiguration vc = ViewConfiguration.get(activity);
         mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
         mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
+
+        mSceneContainerPinAnim = (AnimatorSet) AnimatorInflater.loadAnimator(activity, R.animator.pin);
     }
 
     @TargetApi(android.os.Build.VERSION_CODES.KITKAT)
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View root = inflater.inflate(R.layout.acdisplay_fragment, container, false);
+        View root = inflater.inflate(getViewResource(), container, false);
         assert root != null;
 
-        mSceneContainer = (ForwardingLayout) root.findViewById(R.id.container);
-        mSceneContainer.setVibrateOnForwardedEventEnabled(true);
-        mCollapsedViewsContainer = (LinearLayout) root.findViewById(R.id.list);
-        mCollapsedViewsContainer.setOnTouchListener(this);
+        mSceneContainer = (ForwardingLayout) root.findViewById(R.id.scene);
+        mIconsContainer = (ForwardingLayout) root.findViewById(R.id.list);
+        mIconsContainer.setOnForwardedEventListener(this);
+        mIconsContainer.setAllViewsForwardable(true, 0);
+        mIconsContainer.setOnTouchListener(this);
 
-        mForwardingListener = new ForwardingListener(mCollapsedViewsContainer) {
-            @Override
-            public ForwardingLayout getForwardingLayout() {
-                return mSceneContainer;
-            }
-        };
-        mWidgetTranslatorX = new ElasticValue.TranslationX(mSceneContainer, 500);
-        mWidgetTranslatorX.setListener(new ElasticValue.Listener() {
-            @Override
-            public void onValueChanged(View view, float value) {
-                final int width = view.getWidth();
-                final float alh = 1f - Math.min(width, Math.abs(value)) / width;
-                view.setAlpha(alh);
-            }
-        });
+        mSceneForwardingListener = new ForwardingListener(mIconsContainer, false, mSceneContainer);
+        mIconsForwardingListener = new ForwardingListener(mIconsContainer, true, mIconsContainer);
 
         ViewGroup sceneMain = (ViewGroup) inflater.inflate(R.layout.acdisplay_scene_clock, mSceneContainer, false);
-        if (Device.hasKitKatApi()) {
-            mSceneMain = new SceneCompat(mSceneContainer, sceneMain);
-            if (getResources().getBoolean(R.bool.config_transition_fade)) {
-                mTransition = new TransitionSet()
-                        .setOrdering(TransitionSet.ORDERING_TOGETHER)
-                        .addTransition(new Fade())
-                        .addTransition(new ChangeBounds());
-            } else {
-                mTransition = new ChangeBounds();
-            }
-        } else {
-            mSceneMain = new SceneCompat(mSceneContainer, sceneMain);
-        }
-        mCurrentScene = mSceneMain;
-        mSceneMain.enter();
-
-        Config config = Config.getInstance();
-
-        // /////////////////
-        // ~~ TIMEOUT GUI ~~
-        // /////////////////
-        ProgressBar progressBar;
-        ViewStub progressBarStub = (ViewStub) root.findViewById(R.id.progress_bar_stub);
-        if (config.isMirroredTimeoutProgressBarEnabled()) {
-            progressBarStub.setLayoutResource(R.layout.acdisplay_progress_bar_mirrored);
-            progressBar = (ProgressBar) progressBarStub.inflate().findViewById(R.id.progress_bar);
-
-            // Redirect all changes from the main progress bar
-            // to mirrored one.
-            final ProgressBar progressBarMirrored = (ProgressBar)
-                    root.findViewById(R.id.progress_bar_mirrored);
-            progressBar.setOnProgressChangeListener(new ProgressBar.OnProgressChangeListener() {
-
-                @Override
-                public void onProgressChanged(ProgressBar progressBar, int progress) {
-                    progressBarMirrored.setProgress(progress);
-                }
+        mSceneMain = new SceneCompat(mSceneContainer, sceneMain);
 
-                @Override
-                public void onMaxChanged(ProgressBar progressBar, int max) {
-                    progressBarMirrored.setMax(max);
-                }
-            });
-        } else {
-            progressBar = (ProgressBar) progressBarStub.inflate().findViewById(R.id.progress_bar);
-        }
-
-        Activity activity = getActivity();
-        if (activity instanceof AcDisplayActivity) {
-            mTimeoutGui = new Timeout.Gui(progressBar);
-
-            AcDisplayActivity a = (AcDisplayActivity) activity;
-            mTimeout = a.getTimeout();
-            mTimeout.registerListener(mTimeoutGui);
-        } else {
-            mTimeout = new Timeout(); // fake timeout that does nothing
-            progressBar.setProgress(progressBar.getMax());
+        if (Device.hasKitKatApi()) {
+            mTransition = new TransitionSet()
+                    .setOrdering(TransitionSet.ORDERING_TOGETHER)
+                    .addTransition(new Fade())
+                    .addTransition(new ChangeBounds())
+            ;
         }
-
         return root;
     }
 
+    @Override
+    public void onViewCreated(View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        showWidget(getFirstWidget(), false);
+    }
+
     @Override
     public void onStart() {
         super.onStart();
-        Context context = getActivity();
-        assert context != null;
 
-        mConfig = Config.getInstance();
-        mPresenter = NotificationPresenter.getInstance();
-        mPresenter.addOnNotificationListChangedListener(mNotificationListener);
+        NotificationPresenter.getInstance().registerListener(this);
         updateNotificationList();
 
-        getView().setOnTouchListener(this);
+        Config config = Config.getInstance();
+        config.registerListener(this);
+        updateIconsSize();
+
+        resetScene();
     }
 
     @Override
     public void onStop() {
-        mPresenter.removeOnNotificationListChangedListener(mNotificationListener);
+        mPinHandler.removeCallbacksAndMessages(null);
+        mTouchHandler.removeCallbacksAndMessages(null);
+
+        NotificationPresenter.getInstance().unregisterListener(this);
+
+        Config config = Config.getInstance();
+        config.unregisterListener(this);
         super.onStop();
     }
 
     @Override
-    public void onDestroyView() {
-        super.onDestroyView();
-        if (mTimeout != null) {
-            mTimeout.unregisterListener(mTimeoutGui);
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_UI_ICON_SIZE:
+                updateIconsSize();
+                break;
         }
     }
 
-    private float[] mStdTouchGen = new float[2];
-    private float[] mStdTouchPrev = new float[2];
+    @Override
+    public void onNotificationListChanged(NotificationPresenter np,
+                                          OpenNotification osbn,
+                                          int event) {
+        switch (event) { // don't update on spam-change.
+            case NotificationPresenter.EVENT_POSTED:
+            case NotificationPresenter.EVENT_CHANGED:
+            case NotificationPresenter.EVENT_REMOVED:
+            case NotificationPresenter.EVENT_BATH:
+                if (getActivity() != null) {
+                    updateNotificationList();
+                } else {
+                    Log.wtf(TAG, "List of notifications changed while fragment doesn't have an Activity! ");
+                }
+                break;
+        }
+    }
 
-    private VelocityTracker mVelocityTracker;
-    private ElasticValue mWidgetTranslatorX;
-    private Handler mTouchHandler = new Handler();
+    public void requestBackgroundUpdate(Widget widget) { /* unused */ }
+
+    public void unlock(Runnable runnable, boolean pendingFinish) {
+        if (runnable != null) {
+            runnable.run();
+        }
+    }
+
+    @Override
+    public void onPressedView(MotionEvent event, int activePointerId, View view) {
+        mTouchHandler.removeCallbacksAndMessages(null);
+        mPressedIconView = view;
+
+        if (view != null) {
+            final boolean isTouchDown = event.getActionMasked() == MotionEvent.ACTION_DOWN;
+            final Widget widget = findWidgetByIcon(view);
+            if (mSelectedWidget != widget) { // otherwise redundant
+                int delay = 0;
+                if (!isTouchDown) {
+                    delay = getResources().getInteger(R.integer.config_iconSelectDelayMillis);
+                }
+
+                mPinCanReadAloud = false;
+                mTouchHandler.postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        showWidget(widget);
+                    }
+                }, delay);
+            } else if (mSelectedWidget != null) {
+                // Speech engine
+                mPinCanReadAloud = isTouchDown && mSelectedWidget.isReadable();
+            }
+        }
+    }
 
     @Override
     public boolean onTouch(View v, MotionEvent event) {
-        if (v == mCollapsedViewsContainer) {
-            mForwardingListener.onTouch(mCollapsedViewsContainer, event);
-
-            final int action = event.getAction();
-            switch (action) {
-                case MotionEvent.ACTION_DOWN:
-                    mTouched = true;
-
-                    // Restart timeout and immediately pause it to
-                    // get full line of timeout.
-                    mTimeout.setTimeoutDelayed(mConfig.getTimeoutShort(), true);
-                    mTimeout.pause();
-
-                    // Track the velocity of movement, so we
-                    // can do swipe-to-dismiss.
-                    mVelocityTracker = VelocityTracker.obtain();
-                    mStdTouchGen[0] = 0;
-                    mStdTouchGen[1] = 0;
-
-                    // ///////////////
-                    // ~~ FALL DOWN ~~
-                    // ///////////////
-                case MotionEvent.ACTION_MOVE:
-
-                    // Probably best solution would be to use
-                    // motion forwarding... But it's more complex.
-                    final float rawX = event.getRawX();
-                    final float rawY = event.getRawY();
-
-                    boolean anythingPressed = false;
-                    final int length = mCollapsedViewsContainer.getChildCount();
-                    for (int i = 0; i < length; i++) {
-                        final View child = mCollapsedViewsContainer.getChildAt(i);
-                        assert child != null;
-                        if (child.getVisibility() != View.VISIBLE) continue;
-
-                        // Check if current touch is on view, simulate pressing
-                        // and update its state so view can update background etc.
-                        final boolean pressedOld = child.isPressed();
-                        final boolean pressed = ViewUtils.isTouchPointInView(child, rawX, rawY);
-                        child.setPressed(pressed);
-
-                        if (pressed) anythingPressed = true;
-                        if (pressed != pressedOld && !child.isSelected()) {
-                            child.refreshDrawableState();
-                            if (pressed) {
-                                mTouchHandler.removeCallbacksAndMessages(null);
-                                mTouchHandler.postDelayed(new Runnable() {
-                                    @Override
-                                    public void run() {
-                                        showWidget(findWidgetByCollapsedView(child));
-                                    }
-                                }, action == MotionEvent.ACTION_DOWN ? 0 : 120);
-                            }
+        if (v == mIconsContainer) {
+            mSceneForwardingListener.onTouch(v, event);
+            mIconsForwardingListener.onTouch(v, event);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void onForwardedEvent(MotionEvent event, int activePointerId) {
+        boolean dismiss = false;
+
+        int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+                updateIconsSize();
+                // Track the velocity of movement, so we
+                // can do swipe-to-dismiss.
+                mVelocityTracker = VelocityTracker.obtain();
+            case MotionEvent.ACTION_MOVE:
+            case MotionEvent.ACTION_UP:
+                populateSwipeToDismiss(event);
+
+                if (action != MotionEvent.ACTION_UP) {
+                    return; // Don't fall down.
+                }
+
+                long elapsedTime = event.getEventTime() - event.getDownTime();
+
+                //noinspection LoopStatementThatDoesntLoop
+                while (isDismissible(mSelectedWidget) && elapsedTime > 20) {
+                    mVelocityTracker.computeCurrentVelocity(1000);
+
+                    float velocityX = mVelocityTracker.getXVelocity();
+                    float velocityY = mVelocityTracker.getYVelocity();
+                    float absVelocityX = Math.abs(velocityX);
+                    float absVelocityY = Math.abs(velocityY);
+
+                    float deltaY = mSceneContainer.getTranslationY();
+                    float absDeltaY = Math.abs(deltaY);
+
+                    int height = getSceneView().getHeight();
+                    if (absDeltaY < height / 2) {
+                        if (mMinFlingVelocity <= absVelocityY
+                                && absVelocityY <= mMaxFlingVelocity
+                                && absVelocityY > absVelocityX * 2
+                                && absDeltaY > height / 5) {
+                            // Dismiss only if flinging in the same direction as dragging
+                            dismiss = (velocityY < 0) == (deltaY < 0);
+                        }
+
+                        if (!dismiss) {
+                            break; // Exits from loop not from the switch!
                         }
-                    }
-                    if (!anythingPressed) {
-                        mTouchHandler.removeCallbacksAndMessages(null);
                     }
 
-                    addSwipeMovement(event, action == MotionEvent.ACTION_DOWN);
+                    dismiss = true;
+
+                    if (height > absDeltaY) {
+                        int duration;
+                        duration = Math.round(1000f /* ms. */ * (height - absDeltaY) / absVelocityX);
+                        duration = Math.min(duration, 300);
+                        float rotation = mSceneContainer.getRotationX() - 30;
+
+                        // TODO: Make animation use #populateSceneContainerDismissAnimation(float) method.
+                        final Widget widget = mSelectedWidget;
+                        mSceneContainer.animate()
+                                .alpha(0)
+                                .rotationX(rotation)
+                                .translationY(height)
+                                .setDuration(duration)
+                                .setListener(new AnimatorListenerAdapter() {
+                                    @Override
+                                    public void onAnimationEnd(Animator animation) {
+                                        onAnimationCancel(animation);
+                                        resetScene();
+                                    }
 
-                    break;
-                case MotionEvent.ACTION_UP:
-
-                    if (mSelectedWidget != null && mSelectedWidget.isDismissible()) {
-                        addSwipeMovement(event, false);
-                        mVelocityTracker.computeCurrentVelocity(1000);
-                        float velocityX = mVelocityTracker.getXVelocity();
-                        velocityX = velocityX >= 0
-                                ? Math.max(0, velocityX - mWidgetTranslatorX.getStrength())
-                                : Math.min(0, velocityX + mWidgetTranslatorX.getStrength());
-
-                        boolean dismiss = false;
-                        final boolean dismissRight;
-
-                        int width = mWidgetTranslatorX.getView().getWidth();
-                        float absVelocityX = Math.abs(velocityX);
-                        float absVelocityY = Math.abs(mVelocityTracker.getYVelocity());
-                        float deltaX = mWidgetTranslatorX.getValue();
-                        float absDeltaX = Math.abs(deltaX);
-                        if (absDeltaX > width / 4) {
-                            dismiss = true;
-                            dismissRight = deltaX > 0;
-                        } else if (mMinFlingVelocity <= absVelocityX
-                                && absVelocityX <= mMaxFlingVelocity
-                                && absVelocityY * 2 < absVelocityX
-                                && absDeltaX > width / 6) {
-                            // dismiss only if flinging in the same direction as dragging
-                            dismiss = (velocityX < 0) == (deltaX < 0);
-                            dismissRight = mVelocityTracker.getXVelocity() > 0;
-                        } else {
-                            dismissRight = false;
-                        }
+                                    @Override
+                                    public void onAnimationCancel(Animator animation) {
+                                        onWidgetDismiss(widget);
+                                        resetSceneContainerParams();
+                                    }
+                                });
+
+                        break; // Exits from loop not from the switch!
+                    }
 
-                        if (dismiss) {
-                            mTouched = false;
-                            mTouchHandler.removeCallbacksAndMessages(null);
-
-                            int duration = Math.round(absDeltaX * 1000f / Math.max(absVelocityX, 500f));
-
-                            mWidgetTranslatorX.stop();
-                            mWidgetTranslatorX.getView().animate()
-                                    .alpha(0)
-                                    .translationX(deltaX + width * MathUtils.charge(deltaX))
-                                    .setDuration(duration)
-                                    .setListener(new AnimatorListenerAdapter() {
-                                        @Override
-                                        public void onAnimationEnd(Animator animation) {
-                                            onAnimationCancel(animation);
-                                            endTouch();
-                                        }
-
-                                        @Override
-                                        public void onAnimationCancel(Animator animation) {
-                                            mSelectedWidget.onDismissed(!dismissRight);
-                                            mWidgetTranslatorX.setValue(0f);
-                                        }
-                                    });
-                            break;
+                    // Instant dismissing.
+                    mSelectedWidget.onDismissed();
+                    resetScene();
+                }
+
+                // Don't not reset scene while dismissing, or if
+                // pinnable.
+                if (!dismiss) {
+                    if (mPressedIconView == null || !isPinnable()){
+                        resetScene();
+                    } else {
+                        onWidgetPinned(mSelectedWidget);
+
+                        // TODO: Detect animation by Android API, not by delay.
+                        elapsedTime = event.getEventTime() - event.getDownTime();
+                        if (elapsedTime > 150) {
+                            mSceneContainerPinAnim.setTarget(getSceneView());
+                            mSceneContainerPinAnim.start();
+                        } else if (mPinCanReadAloud && isReadable()) {
+                            onWidgetReadAloud(mSelectedWidget);
                         }
                     }
+                }
+            case MotionEvent.ACTION_CANCEL:
+                mTouchHandler.removeCallbacksAndMessages(null);
+                mVelocityTracker.recycle();
+                mVelocityTracker = null;
 
-                    // ///////////////
-                    // ~~ FALL DOWN ~~
-                    // ///////////////
-                case MotionEvent.ACTION_CANCEL:
-                    mTouchHandler.removeCallbacksAndMessages(null);
-                    endTouch();
-                    break;
-            }
-            return true;
+                if (action == MotionEvent.ACTION_CANCEL) {
+                    resetScene();
+                }
+                break;
         }
-        return false;
     }
 
-    private void addSwipeMovement(MotionEvent srcEvent, boolean ignoreMovement) {
-        final float x = srcEvent.getX();
-        final float y = srcEvent.getY();
+    protected boolean isWidgetPinned() {
+        return mPinHandler.hasMessages(MSG_RESET_SCENE);
+    }
 
-        if (y > 0 || ignoreMovement) {
-            MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
-            assert dstEvent != null;
+    protected void onWidgetPinned(Widget widget) {
+        mPinHandler.sendEmptyMessageDelayed(MSG_RESET_SCENE, 4000);
+    }
 
-            final float deltaX = x - mStdTouchPrev[0];
-            final float deltaY = y - mStdTouchPrev[1];
-            dstEvent.offsetLocation(
-                    (mStdTouchGen[0] += deltaX) - x,
-                    (mStdTouchGen[1] += deltaY) - y);
-            mVelocityTracker.addMovement(dstEvent);
+    protected void onWidgetReadAloud(Widget widget) {
+        // TODO: Read widget aloud
+    }
 
-            if (mSelectedWidget != null  && mSelectedWidget.isDismissible()) {
-                mWidgetTranslatorX.move(deltaX);
-            }
+    /**
+     * Called when widget is going to be dismissed.
+     */
+    protected void onWidgetDismiss(Widget widget) {
+        widget.onDismissed();
+        // TODO: Clear widget from different maps and layouts
+    }
 
-            dstEvent.recycle();
-        }
+    private View getSceneView() {
+        return mSceneContainer.getChildAt(0);
+    }
 
-        writeCoordinate(mStdTouchPrev, srcEvent);
+    /**
+     * Resets {@link #mSceneContainer scene container}'s params and
+     * {@link #showMainWidget() shows main widget}.
+     *
+     * @see #resetSceneContainerParams()
+     */
+    protected void resetScene() {
+        resetSceneContainerParams();
+        showMainWidget();
     }
 
-    private void writeCoordinate(float[] array, MotionEvent event) {
-        array[0] = event.getX();
-        array[1] = event.getY();
+    /**
+     * Resets {@link #mSceneContainer scene container}'s params, such
+     * as: alpha level, translation, rotation etc.
+     *
+     * @see #resetScene()
+     */
+    private void resetSceneContainerParams() {
+        mSceneContainer.setAlpha(1f);
+        mSceneContainer.setTranslationY(0);
+        mSceneContainer.setRotationX(0);
     }
 
-    private void endTouch() {
-        int length = mCollapsedViewsContainer.getChildCount();
-        for (int i = 0; i < length; i++) {
-            View child = mCollapsedViewsContainer.getChildAt(i);
-            assert child != null;
-            child.setPressed(false);
-            child.refreshDrawableState();
-        }
+    private void populateSceneContainerDismissAnimation(float progress) {
+        float height = getSceneView().getHeight();
+        float y = height * progress;
+        double degrees = Math.toDegrees(Math.acos((height - y) / height));
 
-        showMainWidget();
+        mSceneContainer.setAlpha(1f - progress);
+        mSceneContainer.setTranslationY(y);
+        mSceneContainer.setRotationX((float) (-degrees / 2f));
+    }
+
+    private void populateSwipeToDismiss(MotionEvent srcEvent) {
+        float y = srcEvent.getY() - mIconsContainer.getHeight();
+
+        MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
+        mVelocityTracker.addMovement(MotionEvent.obtainNoHistory(srcEvent));
+        dstEvent.recycle();
+
+        if (!isDismissible(mSelectedWidget)) {
+            return;
+        }
 
-        if (mCollapsedViewsNeedsUpdate) updateNotificationList();
-        if (mTimeout != null) {
-            mTimeout.resume();
+        if (y < 0) {
+            if (mSceneContainer.getTranslationY() != 0) {
+                resetSceneContainerParams();
+            }
+            return;
         }
 
-        mTouched = false;
-        mCollapsedViewsNeedsUpdate = false;
+        float height = getSceneView().getHeight();
+        float progress = MathUtils.range(y / height, 0f, 1f);
+        populateSceneContainerDismissAnimation(progress);
     }
 
-    private void showWidget(Widget widget) {
-        if (mSelectedWidget != null) {
-            mSelectedWidget.getCollapsedView().setSelected(false);
-            mSelectedWidget.onExpandedViewDetached();
-        }
+    @SuppressLint("NewApi")
+    protected void showWidget(Widget widget) {
+        showWidget(widget, true);
+    }
 
-        mSelectedWidget = widget;
+    @SuppressLint("NewApi")
+    protected void showWidget(Widget widget, boolean animate) {
+        mPinHandler.removeMessages(MSG_RESET_SCENE);
 
-        mVelocityTracker.clear();
-        mWidgetTranslatorX.reset();
+        if (mSelectedWidget != null) {
+            if (mSelectedWidget.getCollapsedView() != null) {
+                mSelectedWidget.getCollapsedView().setSelected(false);
+            }
 
-        dispatchSetBackground(null, 0);
+            mSelectedWidget.onExpandedViewDetached();
+        }
 
-        if (mSelectedWidget == null) {
-            goScene(mSceneMain);
+        if ((mSelectedWidget = widget) == null) {
+            goScene(getMainScene(), animate);
         } else {
             SceneCompat scene = findSceneByWidget(mSelectedWidget);
             if (scene == null) {
 
                 // Widget doesn't have a large view, so
                 // display clock.
-                goScene(mSceneMain);
+                goScene(getMainScene(), animate);
             } else if (mCurrentScene != scene) {
-                goScene(scene);
-            } else if (Device.hasKitKatApi() && mSelectedWidget.hasExpandedView()) {
-                TransitionManager.beginDelayedTransition(
-                        mSelectedWidget.getExpandedView(),
-                        mTransition);
+                goScene(scene, animate);
+            } else if (Device.hasKitKatApi() && animate) {
+                ViewGroup viewGroup = mSelectedWidget.getExpandedView();
+                if (viewGroup != null && viewGroup.isLaidOut()) {
+
+                    // Automatically animate content change.
+                    beginDelayedTransition(viewGroup, mTransition);
+                }
             }
 
             mSelectedWidget.onExpandedViewAttached();
-            mSelectedWidget.getCollapsedView().setSelected(true);
-            mSelectedWidget.getCollapsedView().performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
-            dispatchSetBackground(mSelectedWidget.getBackground(), Config.DYNAMIC_BG_NOTIFICATION_MASK);
+
+            if (mSelectedWidget.getCollapsedView() != null) {
+                mSelectedWidget.getCollapsedView().setSelected(true);
+                mSelectedWidget.getCollapsedView().performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
+            }
         }
     }
 
+    @TargetApi(android.os.Build.VERSION_CODES.KITKAT)
+    private static void beginDelayedTransition(ViewGroup viewGroup) {
+        beginDelayedTransition(viewGroup, null);
+    }
+
+    @TargetApi(android.os.Build.VERSION_CODES.KITKAT)
+    private static void beginDelayedTransition(ViewGroup viewGroup, Transition transition) {
+        TransitionManager.beginDelayedTransition(viewGroup, transition);
+    }
+
+    /**
+     * Shows main clock widget.<br/>
+     * Same as calling {@code showWidget(null)}.
+     *
+     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget)
+     */
     public void showMainWidget() {
         showWidget(null);
     }
 
+    /**
+     * @return The widget to be shown on create, or {@code null} to
+     * show main scene.
+     */
+    protected Widget getFirstWidget() {
+        return null;
+    }
+
+    /**
+     * @return Currently displayed widget, or {@code null} if on main widget.
+     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget)
+     * @see #showMainWidget()
+     */
+    protected final Widget getCurrentWidget() {
+        return mSelectedWidget;
+    }
+
     /**
      * Changes current scene to given one.
+     *
+     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget)
+     * @see #showMainWidget()
      */
-    private void goScene(SceneCompat sceneCompat) {
+    @SuppressLint("NewApi")
+    protected final void goScene(SceneCompat sceneCompat, boolean transitions) {
         if (mCurrentScene != sceneCompat) {
             mCurrentScene = sceneCompat;
-            if (Device.hasKitKatApi()) {
-                TransitionManager.go(sceneCompat.scene, mTransition);
+            if (transitions) {
+                if (Device.hasKitKatApi()) {
+                    TransitionManager.go(sceneCompat.scene, mTransition);
+                } else {
+                    // TODO: Better animation for Jelly Bean users.
+                    sceneCompat.enter();
+
+                    float density = getResources().getDisplayMetrics().density;
+                    sceneCompat.getView().setAlpha(0.4f);
+                    sceneCompat.getView().setRotationX(10f);
+                    sceneCompat.getView().setTranslationY(10f * density);
+                    sceneCompat.getView().animate().alpha(1).rotationX(0).translationY(0);
+                }
             } else sceneCompat.enter();
         }
     }
 
     /**
-     * <pre>
-     *     Items sorted by priority:
-     *          [ UNLOCK ]
-     *          [ MUSIC ]
-     *          [ NOTIFICATION ]
-     * </pre>
-     * This method is full of black magic!
+     * @return The main scene with huge clock.
+     */
+    protected final SceneCompat getMainScene() {
+        return mSceneMain;
+    }
+
+    /**
+     * @return Currently displayed scene.
+     * @see #goScene(com.achep.acdisplay.compat.SceneCompat, boolean)
+     * @see #getMainScene()
+     */
+    protected final SceneCompat getCurrentScene() {
+        return mCurrentScene;
+    }
+
+    protected final ViewGroup getSceneContainer() {
+        return mSceneContainer;
+    }
+
+    /**
+     * @return {@code true} if widget is not null and
+     * {@link Widget#isDismissible() dismissible}, {@code false} otherwise.
+     */
+    public final boolean isDismissible(Widget widget) {
+        return widget != null && widget.isDismissible();
+    }
+
+    protected SceneCompat findSceneByWidget(Widget widget) {
+        if (widget.hasExpandedView()) {
+            String className = widget.getClass().getName();
+            return mScenesMap.get(className);
+        }
+        return null;
+    }
+
+    private Widget findWidgetByIcon(View view) {
+        return mWidgetsMap.get(view);
+    }
+
+    /**
+     * Updates the size of all widget's icons as
+     * {@link com.achep.acdisplay.Config#getIconSizePx() set} in config.
      */
+    private void updateIconsSize() {
+        final int sizePx = Config.getInstance().getIconSizePx();
+        final int childCount = mIconsContainer.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            View child = mIconsContainer.getChildAt(i);
+            updateIconSize(child, sizePx);
+        }
+    }
+
+    private void updateIconSize(View view, int size) {
+        ViewGroup.LayoutParams lp = view.getLayoutParams();
+        lp.height = size;
+        lp.width = size;
+        view.setLayoutParams(lp);
+    }
+
     // TODO: Optimize it
     // Spent hours on optimizing with no result: 0h
     private void updateNotificationList() {
-        if (getActivity() == null) {
-            return;
-        }
 
         long now = SystemClock.elapsedRealtime();
 
-        ViewGroup container = mCollapsedViewsContainer;
+        ViewGroup container = mIconsContainer;
         final int childCount = container.getChildCount();
 
         if (Device.hasKitKatApi()) {
-            TransitionManager.beginDelayedTransition(container);
+            beginDelayedTransition(container);
         }
 
         // Count the number of non-notification fragments
@@ -541,8 +649,8 @@ public class AcDisplayFragment extends Fragment implements
         int fragmentsExtraCount = 0;
         for (int i = 0; i < childCount; i++) {
             View child = container.getChildAt(i);
-            Widget fragment = findWidgetByCollapsedView(child);
-            if (!(fragment instanceof NotificationUI)) {
+            Widget fragment = findWidgetByIcon(child);
+            if (!(fragment instanceof NotifyWidget)) {
                 fragmentsExtraCount++;
             } else {
                 // Those fragments are placed at the begin of layout
@@ -551,7 +659,7 @@ public class AcDisplayFragment extends Fragment implements
             }
         }
 
-        final ArrayList<OpenStatusBarNotification> list = mPresenter.getList();
+        final ArrayList<OpenNotification> list = NotificationPresenter.getInstance().getList();
         final int notifyCount = list.size();
 
         final boolean[] notifyUsed = new boolean[notifyCount];
@@ -564,13 +672,13 @@ public class AcDisplayFragment extends Fragment implements
         // Does not need an update
         for (int i = fragmentsExtraCount; i < childCount; i++) {
             View child = container.getChildAt(i);
-            NotificationUI widget = (NotificationUI) findWidgetByCollapsedView(child);
-            OpenStatusBarNotification target = widget.getNotification();
+            NotifyWidget widget = (NotifyWidget) findWidgetByIcon(child);
+            OpenNotification target = widget.getNotification();
 
             // Try to find the notification with the same
             // id, tag and package name as in present.
             for (int j = 0; j < notifyCount; j++) {
-                OpenStatusBarNotification n = list.get(j);
+                OpenNotification n = list.get(j);
                 if (NotificationUtils.equals(target, n)) {
 
                     notifyUsed[j] = true;
@@ -600,7 +708,7 @@ public class AcDisplayFragment extends Fragment implements
                         assert child != null;
                         notifyUsed[j] = true;
 
-                        NotificationUI fragment = (NotificationUI) findWidgetByCollapsedView(child);
+                        NotifyWidget fragment = (NotifyWidget) findWidgetByIcon(child);
                         fragment.setNotification(list.get(j));
                         break removing_all_next_views;
                     }
@@ -614,12 +722,15 @@ public class AcDisplayFragment extends Fragment implements
 
         assert getActivity() != null;
         LayoutInflater inflater = getActivity().getLayoutInflater();
+        Config config = Config.getInstance();
+        int iconSize = config.getIconSizePx();
 
         for (int i = 0; i < notifyCount; i++) {
             if (notifyUsed[i]) continue;
 
-            NotificationUI fragment = new NotificationUI(this);
+            NotifyWidget fragment = new NotifyWidget(this, this);
             View view = fragment.createCollapsedView(inflater, container);
+            updateIconSize(view, iconSize);
             container.addView(view);
 
             fragment.setNotification(list.get(i));
@@ -650,7 +761,7 @@ public class AcDisplayFragment extends Fragment implements
 
         for (int i = fragmentsExtraCount - 1; i >= 0; i--) {
             View child = container.getChildAt(i);
-            Widget fragment = findWidgetByCollapsedView(child);
+            Widget fragment = findWidgetByIcon(child);
 
             boolean found = false;
             for (int j = 0; j < extras.length; j++) {
@@ -709,45 +820,9 @@ public class AcDisplayFragment extends Fragment implements
             }
         }
 
-        //ViewUtils.setVisible(mCollapsedUnlockFake, empty);
-
         if (Build.DEBUG) {
             long delta = SystemClock.elapsedRealtime() - now;
             Log.d(TAG, "Fragment list updated in " + delta + "ms.");
         }
-
-        if (Device.hasKitKatApi()) {
-
-            // Make sure that container will be updated
-            // to end delayed transition.
-            container.invalidate();
-        }
     }
-
-    // //////////////////////////////////////////
-    // ///////////// -- CLASSES -- //////////////
-    // //////////////////////////////////////////
-
-    private class NotificationListener implements NotificationPresenter.OnNotificationListChangedListener {
-
-        @Override
-        public void onNotificationListChanged(NotificationPresenter nm,
-                                              OpenStatusBarNotification notification,
-                                              final int event) {
-            if (mTouched) {
-                mCollapsedViewsNeedsUpdate = true;
-            } else {
-                switch (event) {
-                    case NotificationPresenter.EVENT_BATH:
-                    case NotificationPresenter.EVENT_POSTED:
-                    case NotificationPresenter.EVENT_CHANGED:
-                    case NotificationPresenter.EVENT_REMOVED:
-                        mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
-                        updateNotificationList();
-                        break;
-                }
-            }
-        }
-    }
-
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment2.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment2.java
new file mode 100644
index 00000000..fccc39b0
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment2.java
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.acdisplay;
+
+import android.app.Activity;
+import android.content.res.Resources;
+import android.os.Bundle;
+import android.view.GestureDetector;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.Timeout;
+import com.achep.acdisplay.acdisplay.components.MediaWidget;
+import com.achep.acdisplay.acdisplay.components.NotifyWidget;
+import com.achep.acdisplay.acdisplay.components.Widget;
+import com.achep.acdisplay.animations.CircleDarkeningAnimation;
+import com.achep.acdisplay.compat.SceneCompat;
+import com.achep.acdisplay.notifications.NotificationPresenter;
+import com.achep.acdisplay.services.media.MediaController;
+import com.achep.acdisplay.utils.ViewUtils;
+import com.achep.acdisplay.widgets.CircleView;
+import com.achep.acdisplay.widgets.NotificationWidget;
+import com.achep.acdisplay.widgets.ProgressBar;
+
+/**
+ * This is main fragment of ActiveDisplay app.
+ */
+public class AcDisplayFragment2 extends AcDisplayFragment implements
+        CircleView.Callback, MediaController.MediaListener {
+
+    private AcDisplayActivity mActivity;
+    private Config mConfig;
+
+    private Timeout mTimeout;
+    private Timeout.Gui mTimeoutGui;
+
+    private CircleView mCircleView;
+
+    // Media widget
+    private MediaController mMediaController;
+    private MediaWidget mMediaWidget;
+    private SceneCompat mSceneMainMedia;
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        mActivity = (AcDisplayActivity) activity;
+
+        mMediaController = mActivity.getMediaController();
+        mMediaController.registerListener(this);
+
+        mConfig = mActivity.getConfig();
+        mTimeout = mActivity.getTimeout();
+    }
+
+    @Override
+    protected int getViewResource() {
+        return R.layout.fragment_acdisplay;
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View root = super.onCreateView(inflater, container, savedInstanceState);
+        assert root != null;
+        root.setOnTouchListener(new View.OnTouchListener() {
+
+            private boolean transferring;
+            private GestureDetector gestureDetector =
+                    new GestureDetector(mActivity, new GestureListener());
+
+            class GestureListener extends GestureDetector.SimpleOnGestureListener {
+
+                @Override
+                public boolean onSingleTapUp(MotionEvent e) {
+                    return false;
+                }
+
+                @Override
+                public boolean onDoubleTap(MotionEvent e) {
+                    return mActivity.lock();
+                }
+            }
+
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                gestureDetector.onTouchEvent(event);
+                int action = event.getAction();
+                if (action == MotionEvent.ACTION_DOWN) {
+                    float x = event.getX();
+                    float y = event.getY();
+                    int padding = 20;
+                    transferring = ViewUtils.isTouchPointInView(v, x - padding, y - padding)
+                            && ViewUtils.isTouchPointInView(v, x + padding, y + padding);
+                }
+                if (transferring) {
+                    mCircleView.onTouchEvent2(event);
+                }
+                return transferring;
+            }
+        });
+
+        View divider = root.findViewById(R.id.divider);
+        ViewGroup vg = (ViewGroup) divider.getParent();
+
+        int position = 0;
+        int length = vg.getChildCount();
+        for (int i = 0; i < length; i++) {
+            View child = vg.getChildAt(i);
+            assert child != null;
+
+            if (child.getId() == divider.getId()) {
+                position = i;
+                break;
+            }
+        }
+
+        boolean mirrored = mConfig.isMirroredTimeoutProgressBarEnabled();
+        View pb = inflater.inflate(mirrored
+                ? R.layout.acdisplay_progress_bar_mirrored
+                : R.layout.acdisplay_progress_bar, vg, false);
+        vg.removeViewAt(position);
+        vg.addView(pb, position);
+        ProgressBar progressBar = (ProgressBar) pb.findViewById(R.id.progress_bar);
+        if (mirrored) {
+            // Redirect all changes from the main progress bar
+            // to mirrored one.
+            final ProgressBar progressBarMirrored = (ProgressBar)
+                    root.findViewById(R.id.progress_bar_mirrored);
+            progressBar.setOnProgressChangeListener(new ProgressBar.OnProgressChangeListener() {
+
+                @Override
+                public void onProgressChanged(ProgressBar progressBar, int progress) {
+                    progressBarMirrored.setProgress(progress);
+                }
+
+                @Override
+                public void onMaxChanged(ProgressBar progressBar, int max) {
+                    progressBarMirrored.setMax(max);
+                }
+            });
+        }
+        mTimeoutGui = new Timeout.Gui(progressBar);
+        mTimeout.registerListener(mTimeoutGui);
+
+        mCircleView = (CircleView) root.findViewById(R.id.circle);
+        mCircleView.setDarkening(1f);
+        mCircleView.setCallback(this);
+
+        ViewGroup sceneContainer = getSceneContainer();
+        mMediaWidget = new MediaWidget(this, this);
+        mMediaWidget.onCreate();
+        ViewGroup sceneMainMusic = mMediaWidget.createExpandedView(inflater, sceneContainer, null);
+        mSceneMainMedia = new SceneCompat(sceneContainer, sceneMainMusic);
+
+        return root;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        Resources res = getResources();
+
+        // Smooth turning screen on.
+        CircleDarkeningAnimation anim = new CircleDarkeningAnimation(mCircleView, 1f, 0f);
+        anim.setInterpolator(getActivity(), android.R.interpolator.accelerate_cubic);
+        anim.setDuration(res.getInteger(android.R.integer.config_shortAnimTime));
+        mCircleView.startAnimation(anim);
+    }
+
+    @Override
+    public void onDestroyView() {
+        mMediaWidget.onDestroy();
+        mTimeout.unregisterListener(mTimeoutGui);
+        super.onDestroyView();
+    }
+
+    @Override
+    public void onDetach() {
+        mMediaController.unregisterListener(this);
+        super.onDetach();
+    }
+
+    @Override
+    public void onCircleEvent(float radius, float ratio, int event) {
+        switch (event) {
+            case CircleView.ACTION_START:
+                if (isWidgetPinned()) {
+                    resetScene();
+                }
+
+                mTimeout.pause();
+                break;
+            case CircleView.ACTION_UNLOCK:
+                mActivity.unlock(null);
+            case CircleView.ACTION_CANCELED:
+                mTimeout.resume();
+
+                int delta = (int) (2200 - mTimeout.getRemainingTime());
+                if (delta > 0) {
+                    mTimeout.delay(delta);
+                }
+                break;
+        }
+    }
+
+    public MediaController getMediaController() {
+        return mActivity.getMediaController();
+    }
+
+    /**
+     * @param runnable
+     * @param pendingFinish
+     */
+    @Override
+    public void unlock(Runnable runnable, boolean pendingFinish) {
+        mActivity.unlockWithPendingFinish(runnable);
+    }
+
+    /**
+     * Updates dynamic background as was requested by widget.
+     */
+    @Override
+    public void requestBackgroundUpdate(Widget widget) {
+        if (widget == getCurrentWidget()) {
+            mActivity.dispatchSetBackground(
+                    widget.getBackground(),
+                    widget.getBackgroundMask());
+        }
+    }
+
+    @Override
+    protected void showWidget(Widget widget) {
+        super.showWidget(widget);
+
+        // Add support for dynamic background
+        if (widget == null) {
+            mActivity.dispatchClearBackground();
+        } else {
+            mActivity.dispatchSetBackground(
+                    widget.getBackground(),
+                    widget.getBackgroundMask());
+        }
+
+        if (widget == null || widget == mMediaWidget) {
+            mTimeout.resume();
+        } else {
+            mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
+            mTimeout.pause();
+        }
+
+        // boolean smallClock = widget != null && !widget.hasClock() && widget == mMediaWidget;
+        // ViewUtils.setVisible(mClockSmallView, smallClock);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onWidgetDismiss(Widget widget) {
+        super.onWidgetDismiss(widget);
+
+        if (widget instanceof NotifyWidget) {
+            // Screen off on dismiss last notification.
+            NotificationPresenter np = NotificationPresenter.getInstance();
+            if (np.getList().size() <= 1 && mActivity.getConfig().isScreenOffAfterLastNotify()) {
+                mActivity.lock();
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onMediaChanged(MediaController controller, int event) {
+        switch (event) {
+            case MediaController.EVENT_UISTATE_CHANGED:
+                updateUiState(controller.getUiState());
+                break;
+        }
+    }
+
+    /**
+     * Shows or hides media widget.
+     *
+     * @see #isUiStateMedia()
+     */
+    private void updateUiState(int currentUiState) {
+        Widget currentWidget = getCurrentWidget();
+        switch (currentUiState) {
+            case MediaController.UISTATE_MUSIC:
+                if (currentWidget == null) {
+                    showWidget(mMediaWidget);
+                }
+                break;
+            case MediaController.UISTATE_NORMAL:
+                if (currentWidget == mMediaWidget) {
+                    showMainWidget();
+                }
+                break;
+        }
+    }
+
+    /**
+     * @return {@code true} is media widget may be shown, {@code false} otherwise.
+     * @see com.achep.acdisplay.services.media.MediaController#getUiState()
+     */
+    private boolean isUiStateMedia() {
+        int state = mMediaController.getUiState();
+        return state == MediaController.UISTATE_MUSIC;
+    }
+
+    @Override
+    public void showMainWidget() {
+        if (isUiStateMedia()) {
+            showWidget(mMediaWidget);
+            return;
+        }
+
+        super.showMainWidget();
+    }
+
+    @Override
+    protected Widget getFirstWidget() {
+        return isUiStateMedia() ? mMediaWidget : super.getFirstWidget();
+    }
+
+    @Override
+    protected SceneCompat findSceneByWidget(Widget widget) {
+        // Manually add media widget's scene
+        return widget == mMediaWidget ? mSceneMainMedia : super.findSceneByWidget(widget);
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/Helper.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/Helper.java
deleted file mode 100644
index 62b35b97..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/Helper.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.acdisplay;
-
-import android.content.Context;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.widget.LinearLayout;
-
-import com.achep.acdisplay.notifications.NotificationUtils;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
-import com.achep.acdisplay.widgets.NotificationView;
-
-import java.util.ArrayList;
-
-/**
- * Created by achep on 14.05.14 for AcDisplay.
- *
- * @author Artem Chepurnoy
- */
-public class Helper {
-
-    private void updateNotificationList(Context context, LinearLayout container, int itemLayoutRes) {
-        final ArrayList<OpenStatusBarNotification> list = null;//mPresenter.getList();
-        final int notifyCount = list.size();
-
-        final int childCount = container.getChildCount();
-        final boolean[] notifyUsed = new boolean[notifyCount];
-        final boolean[] childUsed = new boolean[childCount];
-
-        // ///////////////////
-        // ~~ NOTIFICATIONS ~~
-        // ///////////////////
-
-        // Does not need an update
-        for (int i = 0; i < childCount; i++) {
-            NotificationView item = (NotificationView) container.getChildAt(i);
-            assert item != null;
-            OpenStatusBarNotification target = item.getNotification();
-
-            // Try to find the notification with the same
-            // id, tag and package name as in present.
-            for (int j = 0; j < notifyCount; j++) {
-                OpenStatusBarNotification n = list.get(j);
-                if (NotificationUtils.equals(target, n)) {
-
-                    notifyUsed[j] = true;
-                    childUsed[i] = true;
-
-                    if (target != n) {
-                        item.setNotification(n);
-                    }
-                    break;
-                }
-            }
-        }
-
-        // Re-use free views and remove redundant views.
-        boolean removeAllAfter = false;
-        for (int a = 0, j = 0, offset = 0; a < childCount; a++) {
-            if (childUsed[a]) continue;
-            final int i = a + offset;
-
-            removing_all_next_views:
-            {
-                if (!removeAllAfter) {
-                    for (; j < notifyCount; j++) {
-                        if (notifyUsed[j]) continue;
-
-                        notifyUsed[j] = true;
-
-                        NotificationView item = (NotificationView) container.getChildAt(i);
-                        assert item != null;
-                        item.setNotification(list.get(j));
-
-                        break removing_all_next_views;
-                    }
-                }
-                removeAllAfter = true;
-                container.removeViewAt(i);
-                offset--;
-            }
-        }
-
-        LayoutInflater inflater = null;//context.getLayoutInflater();
-
-        for (int i = 0; i < notifyCount; i++) {
-            if (notifyUsed[i]) continue;
-
-            View view = inflater.inflate(itemLayoutRes, container, false);
-            assert view != null;
-            container.addView(view);
-
-            NotificationView item = (NotificationView) view;
-            item.setNotification(list.get(i));
-        }
-    }
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/MediaWidget.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/MediaWidget.java
new file mode 100644
index 00000000..58e51ead
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/MediaWidget.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.acdisplay.components;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.media.RemoteControlClient;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.achep.acdisplay.AsyncTask;
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.acdisplay.AcDisplayFragment2;
+import com.achep.acdisplay.acdisplay.BackgroundFactoryThread;
+import com.achep.acdisplay.services.media.MediaController;
+import com.achep.acdisplay.services.media.Metadata;
+import com.achep.acdisplay.utils.ViewUtils;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+
+/**
+ * Created by Artem on 02.04.2014.
+ */
+public class MediaWidget extends Widget implements
+        MediaController.MediaListener,
+        View.OnClickListener,
+        View.OnLongClickListener {
+
+    private MediaController mMediaController;
+
+    private ImageView mArtwork;
+    private TextView mTrack;
+    private TextView mArtist;
+    private ImageButton mButtonPrevious;
+    private ImageButton mButtonPlayPause;
+    private ImageButton mButtonNext;
+
+    private Bitmap mArtworkOrigin;
+    private Bitmap mArtworkBlurred;
+
+    private BackgroundFactoryThread mBlurThread;
+    private BackgroundFactoryThread.Callback mBlurThreadCallback = new BackgroundFactoryThread.Callback() {
+        @Override
+        public void onBackgroundCreated(Bitmap bitmap) {
+            mArtworkBlurred = bitmap;
+            populateBackground();
+        }
+    };
+
+    public MediaWidget(Callback callback, AcDisplayFragment2 fragment) {
+        super(callback, fragment);
+        mMediaController = fragment.getMediaController();
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        mMediaController.registerListener(this);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        mMediaController.unregisterListener(this);
+    }
+
+    @Override
+    public void onMediaChanged(MediaController controller, int event) {
+        switch (event) {
+            case MediaController.EVENT_METADATA_CHANGED:
+                updateMetadata(controller.getMetadata());
+                break;
+            case MediaController.EVENT_PLAYSTATE_CHANGED:
+                updatePlayState(controller.getPlayState());
+                break;
+        }
+    }
+
+    private void updateMetadata(Metadata metadata) {
+        if (mArtworkOrigin == null || !mArtworkOrigin.sameAs(metadata.bitmap)) {
+            mArtworkOrigin = metadata.bitmap;
+
+            AsyncTask.stop(mBlurThread);
+            if (metadata.bitmap != null) {
+                Context context = getHostFragment().getActivity();
+                mBlurThread = new BackgroundFactoryThread(context, metadata.bitmap, mBlurThreadCallback);
+                mBlurThread.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+            } else {
+                mArtworkBlurred = null;
+                populateBackground();
+            }
+        }
+
+        populateMetadata();
+    }
+
+    private void updatePlayState(int currentPlayState) {
+        final int imageResId;
+        final int imageDescId;
+        switch (currentPlayState) {
+            case RemoteControlClient.PLAYSTATE_ERROR:
+                imageResId = android.R.drawable.stat_sys_warning;
+                imageDescId = R.string.media_play_description;
+                break;
+            case RemoteControlClient.PLAYSTATE_PLAYING:
+                imageResId = R.drawable.ic_media_pause;
+                imageDescId = R.string.media_pause_description;
+                break;
+            case RemoteControlClient.PLAYSTATE_BUFFERING:
+                imageResId = R.drawable.ic_media_stop;
+                imageDescId = R.string.media_stop_description;
+                break;
+            case RemoteControlClient.PLAYSTATE_PAUSED:
+            default:
+                imageResId = R.drawable.ic_media_play;
+                imageDescId = R.string.media_play_description;
+                break;
+        }
+
+        mButtonPlayPause.setImageResource(imageResId);
+        mButtonPlayPause.setContentDescription(getHostFragment().getString(imageDescId));
+    }
+
+    /**
+     * Updates the content of the view to latest metadata
+     * provided by {@link com.achep.acdisplay.services.media.MediaController#getMetadata()}.
+     */
+    private void populateMetadata() {
+        Metadata metadata = mMediaController.getMetadata();
+        ViewUtils.safelySetText(mTrack, metadata.trackTitle);
+        ViewUtils.safelySetText(mArtist, metadata.artist);
+
+        if (mArtwork != null) {
+            mArtwork.setImageBitmap(metadata.bitmap);
+        }
+    }
+
+    /**
+     * Requests host to update dynamic background.
+     *
+     * @see #getBackground()
+     * @see #getBackgroundMask()
+     */
+    private void populateBackground() {
+        mCallback.requestBackgroundUpdate(this);
+    }
+
+    @Override
+    public Bitmap getBackground() {
+        return mArtworkBlurred;
+    }
+
+    @Override
+    public int getBackgroundMask() {
+        return Config.DYNAMIC_BG_ARTWORK_MASK;
+    }
+
+    @Override
+    protected ViewGroup onCreateExpandedView(LayoutInflater inflater, ViewGroup container, ViewGroup sceneView) {
+        boolean initialize = sceneView == null;
+        if (initialize) {
+            sceneView = (ViewGroup) inflater.inflate(R.layout.acdisplay_scene_music, container, false);
+            assert sceneView != null;
+        }
+
+        mArtwork = (ImageView) sceneView.findViewById(R.id.artwork);
+        mTrack = (TextView) sceneView.findViewById(R.id.track);
+        mArtist = (TextView) sceneView.findViewById(R.id.artist_album);
+        mButtonPrevious = (ImageButton) sceneView.findViewById(R.id.previous);
+        mButtonPlayPause = (ImageButton) sceneView.findViewById(R.id.play);
+        mButtonNext = (ImageButton) sceneView.findViewById(R.id.next);
+
+        if (!initialize) {
+            return sceneView;
+        }
+
+        mButtonPrevious.setOnClickListener(this);
+        mButtonPlayPause.setOnClickListener(this);
+        mButtonPlayPause.setOnLongClickListener(this);
+        mButtonNext.setOnClickListener(this);
+
+        return sceneView;
+    }
+
+    @Override
+    public void onClick(View v) {
+        int keyCode;
+        if (v == mButtonPrevious) {
+            keyCode = KeyEvent.KEYCODE_MEDIA_PREVIOUS;
+        } else if (v == mButtonPlayPause) {
+            keyCode = KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE;
+        } else if (v == mButtonNext) {
+            keyCode = KeyEvent.KEYCODE_MEDIA_NEXT;
+        } else {
+            return;
+        }
+
+        mMediaController.sendMediaButtonClick(keyCode);
+    }
+
+    @Override
+    public boolean onLongClick(View v) {
+        if (v == mButtonPlayPause) {
+            mMediaController.sendMediaButtonClick(KeyEvent.KEYCODE_MEDIA_STOP);
+        } else {
+            return false;
+        }
+        return true;
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/NotificationUI.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/NotifyWidget.java
similarity index 84%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/NotificationUI.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/NotifyWidget.java
index c7a234f3..c3922b76 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/NotificationUI.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/NotifyWidget.java
@@ -28,7 +28,7 @@ import android.view.ViewGroup;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.acdisplay.AcDisplayFragment;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
+import com.achep.acdisplay.notifications.OpenNotification;
 import com.achep.acdisplay.utils.BitmapUtils;
 import com.achep.acdisplay.utils.PendingIntentUtils;
 import com.achep.acdisplay.widgets.NotificationIconWidget;
@@ -41,14 +41,14 @@ import org.apache.commons.lang.builder.HashCodeBuilder;
 /**
  * Created by Artem on 02.04.2014.
  */
-public class NotificationUI extends Widget implements NotificationView {
+public class NotifyWidget extends Widget implements NotificationView {
 
     private NotificationIconWidget mIconView;
-    private OpenStatusBarNotification mNotification;
+    private OpenNotification mNotification;
     private NotificationWidget mNotifyWidget;
 
-    public NotificationUI(AcDisplayFragment fragment) {
-        super(fragment);
+    public NotifyWidget(Callback callback, AcDisplayFragment fragment) {
+        super(callback, fragment);
     }
 
     /**
@@ -56,7 +56,7 @@ public class NotificationUI extends Widget implements NotificationView {
      */
     @Override
     public int hashCode() {
-        return new HashCodeBuilder(65, 810)
+        return new HashCodeBuilder(65, 3)
                 .append(mIconView)
                 .append(mNotification)
                 .append(mNotifyWidget)
@@ -71,10 +71,10 @@ public class NotificationUI extends Widget implements NotificationView {
     public boolean equals(Object o) {
         if (o == this)
             return true;
-        if (!(o instanceof NotificationUI))
+        if (!(o instanceof NotifyWidget))
             return false;
 
-        NotificationUI widget = (NotificationUI) o;
+        NotifyWidget widget = (NotifyWidget) o;
         return new EqualsBuilder()
                 .append(mIconView, widget.mIconView)
                 .append(mNotification, widget.mNotification)
@@ -88,24 +88,32 @@ public class NotificationUI extends Widget implements NotificationView {
     }
 
     @Override
-    public void onDismissed(boolean right) {
+    public void onDismissed() {
         mNotifyWidget.getNotification().dismiss();
     }
 
+    @Override
+    public boolean isReadable() {
+        return false;
+    }
+
     @Override
     public Bitmap getBackground() {
         Bitmap bitmap = mNotification.getNotificationData().getBackground();
         return bitmap != null && !BitmapUtils.hasTransparentCorners(bitmap) ? bitmap : null;
     }
 
+    @Override
+    public int getBackgroundMask() {
+        return Config.DYNAMIC_BG_NOTIFICATION_MASK;
+    }
+
     @Override
     protected View onCreateCollapsedView(LayoutInflater inflater, ViewGroup container) {
         View view = inflater.inflate(R.layout.widget_notification_icon, container, false);
         assert view != null;
 
         mIconView = (NotificationIconWidget) view;
-        int size = Config.getInstance().getIconSize("px");
-        mIconView.setLayoutParams(new ViewGroup.LayoutParams(size, size));
         mIconView.setNotification(mNotification);
         return view;
     }
@@ -124,13 +132,13 @@ public class NotificationUI extends Widget implements NotificationView {
             return sceneView;
         }
 
+        // mNotifyWidget.setActionButtonsAlignment(RelativeLayout.ALIGN_BOTTOM);
         mNotifyWidget.setOnClickListener(new NotificationWidget.OnClickListener() {
 
             @Override
             public void onClick(View v) {
-                final OpenStatusBarNotification osbn = mNotifyWidget.getNotification();
+                final OpenNotification osbn = mNotifyWidget.getNotification();
                 if (osbn != null) {
-                    getHostFragment().showMainWidget();
                     getHostFragment().unlock(new Runnable() {
                         @Override
                         public void run() {
@@ -142,7 +150,6 @@ public class NotificationUI extends Widget implements NotificationView {
 
             @Override
             public void onActionButtonClick(View v, final PendingIntent pendingIntent) {
-                getHostFragment().showMainWidget();
                 getHostFragment().unlock(new Runnable() {
                     @Override
                     public void run() {
@@ -163,7 +170,7 @@ public class NotificationUI extends Widget implements NotificationView {
     }
 
     @Override
-    public void setNotification(OpenStatusBarNotification notification) {
+    public void setNotification(OpenNotification notification) {
         mNotification = notification;
         mIconView.setNotification(notification);
 
@@ -175,7 +182,7 @@ public class NotificationUI extends Widget implements NotificationView {
     }
 
     @Override
-    public OpenStatusBarNotification getNotification() {
+    public OpenNotification getNotification() {
         return mNotification;
     }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/Widget.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/Widget.java
index 28794c11..2d62cad6 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/Widget.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/acdisplay/components/Widget.java
@@ -25,6 +25,7 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 
+import com.achep.acdisplay.Config;
 import com.achep.acdisplay.acdisplay.AcDisplayFragment;
 
 import org.apache.commons.lang.builder.EqualsBuilder;
@@ -42,9 +43,16 @@ public abstract class Widget {
     private ViewGroup mExpandedViewGroup;
     private View mCollapsedView;
 
+    protected Callback mCallback;
+
     private boolean mShown;
 
-    public Widget(AcDisplayFragment fragment) {
+    public interface Callback {
+        void requestBackgroundUpdate(Widget widget);
+    }
+
+    public Widget(Callback callback, AcDisplayFragment fragment) {
+        mCallback = callback;
         mAcDisplayFragment = fragment;
     }
 
@@ -86,7 +94,7 @@ public abstract class Widget {
 
     /**
      * @return {@code true} if the widget can be dismissed, {@code false} otherwise
-     * @see #onDismissed(boolean)
+     * @see #onDismissed()
      */
     public boolean isDismissible() {
         return false;
@@ -95,26 +103,24 @@ public abstract class Widget {
     /**
      * Called when widget (may be not widget, but its content) has been dismissed.
      *
-     * @param right {@code true} if dismissed by swipe to right, {@code false} otherwise.
      * @see #isDismissible()
      */
-    public void onDismissed(boolean right) { /* reserved for children */ }
+    public void onDismissed() { /* reserved for children */ }
 
     /**
      * @return {@code true} if the widget can be read aloud, {@code false} otherwise
-     * @see #onReadAloud(android.speech.tts.TextToSpeech)
+     * @see #getReadAloudText()
      */
     public boolean isReadable() {
         return false;
     }
 
     /**
-     * Called when widget need to read its content aloud.
-     *
+     * @return Text to be read aloud.
      * @see #isReadable()
      */
-    public void onReadAloud(TextToSpeech tts) {
-        // TODO: Add an ability to read widgets aloud.
+    public String getReadAloudText() {
+        return null;
     }
 
     /**
@@ -124,6 +130,17 @@ public abstract class Widget {
         return null;
     }
 
+    /**
+     * @return The mask of widget's background, or {@code 0} to show always.
+     * @see Config#DYNAMIC_BG_ARTWORK_MASK
+     * @see Config#DYNAMIC_BG_NOTIFICATION_MASK
+     */
+    public int getBackgroundMask() {
+        return 0;
+    }
+
+    public void onCreate() { /* empty */ }
+
     public boolean isExpandedViewAttached() {
         return mShown;
     }
@@ -136,6 +153,8 @@ public abstract class Widget {
         mShown = false;
     }
 
+    public void onDestroy() { /* empty */ }
+
     /**
      * @return {@code true} if the widget contains large view, {@code false} otherwise
      */
@@ -160,9 +179,13 @@ public abstract class Widget {
         return (mExpandedViewGroup = onCreateExpandedView(inflater, container, sceneView));
     }
 
-    protected abstract View onCreateCollapsedView(LayoutInflater inflater, ViewGroup container);
+    protected View onCreateCollapsedView(LayoutInflater inflater, ViewGroup container) {
+        return null;
+    }
 
-    protected abstract ViewGroup onCreateExpandedView(LayoutInflater inflater, ViewGroup container,
-                                                      ViewGroup view);
+    protected ViewGroup onCreateExpandedView(LayoutInflater inflater, ViewGroup container,
+                                             ViewGroup view) {
+        return null;
+    }
 
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeSensor.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeSensor.java
deleted file mode 100644
index 68f97492..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeSensor.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.activemode;
-
-import android.content.Context;
-import android.hardware.SensorManager;
-import android.os.SystemClock;
-
-import java.util.ArrayList;
-
-/**
- * Provides a callback when {@link com.achep.acdisplay.acdisplay.AcDisplayActivity}
- * should be started and stopped.
- *
- * @author Artem Chepurnoy
- */
-public abstract class ActiveModeSensor {
-
-    /**
-     * Provides a callback when AcDisplay should be shown / hidden.
-     *
-     * @author Artem Chepurnoy
-     */
-    public interface Callback {
-
-        /**
-         * Requests to show the AcDisplay.
-         */
-        public void show(ActiveModeSensor sensor);
-
-        /**
-         * Requests to hide the AcDisplay.
-         */
-        public void hide(ActiveModeSensor sensor);
-    }
-
-    private ArrayList<Callback> mCallbacks;
-
-    protected ActiveModeSensor() {
-        mCallbacks = new ArrayList<>(4);
-    }
-
-    /**
-     * Registers given callback to listen to this sensor.
-     * You must call {@link #unregisterCallback(ActiveModeSensor.Callback)}
-     * later.
-     *
-     * @see #unregisterCallback(ActiveModeSensor.Callback)
-     */
-    public void registerCallback(Callback callback) {
-        mCallbacks.add(callback);
-    }
-
-    /**
-     * Unregisters given callback from listening to this sensor.
-     *
-     * @see #registerCallback(ActiveModeSensor.Callback)
-     */
-    public void unregisterCallback(Callback callback) {
-        mCallbacks.remove(callback);
-    }
-
-    protected void requestShowAcDisplay() {
-        for (Callback callback : mCallbacks) {
-            callback.show(this);
-        }
-    }
-
-    protected void requestHideAcDisplay() {
-        for (Callback callback : mCallbacks) {
-            callback.hide(this);
-        }
-    }
-
-    /**
-     * Checks if this sensor is supported by device.
-     * By default it does the following code:
-     * {@code sensorManager.getSensorList(getType()).size() > 0}
-     *
-     * @return {@code true} if the sensor is supported by device, {@code false} otherwise.
-     */
-    protected boolean isSupported(SensorManager sensorManager, Context context) {
-        return sensorManager.getSensorList(getType()).size() > 0;
-    }
-
-    /**
-     * @return The type of used sensor.
-     * @see android.hardware.Sensor#TYPE_ACCELEROMETER
-     * @see android.hardware.Sensor#TYPE_PROXIMITY
-     */
-    public abstract int getType();
-
-    /**
-     * Called when the sensor is attached to main class.
-     * Tou may start to listen to your sensor here.
-     */
-    public abstract void onAttached(SensorManager sensorManager, Context context);
-
-    /**
-     * Called when the sensor is detached from main class.
-     * You must unregister all sensors here.
-     */
-    public abstract void onDetached(SensorManager sensorManager);
-
-    /**
-     * @return {@code SystemClock.elapsedRealtime()}
-     */
-    protected static long getTimeNow() {
-        return SystemClock.elapsedRealtime();
-    }
-
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/sensors/ProximitySensor.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/sensors/ProximitySensor.java
deleted file mode 100644
index 0737f023..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/sensors/ProximitySensor.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.activemode.sensors;
-
-import android.content.Context;
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-import android.os.Handler;
-import android.os.PowerManager;
-import android.util.Log;
-
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.activemode.ActiveModeSensor;
-
-import java.lang.ref.WeakReference;
-
-/**
- * Basing on results of proximity sensor it notifies when
- * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
- * should be shown or hidden.
- *
- * @author Artem Chepurnoy
- */
-public class ProximitySensor extends ActiveModeSensor implements
-        SensorEventListener {
-
-    private static final String TAG = "ProximitySensor";
-
-    private static final long CHANGE_TO_FAR_MIN_DELAY = 2500; // ms.
-    private static final long CHANGE_TO_NEAR_MIN_DELAY = 0; // ms.
-
-    /**
-     * The delay in millis between sensor's change and hiding
-     * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
-     */
-    private static final long REQUEST_HIDE_ACDISPLAY_DELAY = 1400; // ms.
-
-    /**
-     * The delay in millis between sensor's change and showing
-     * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
-     */
-    private static final long REQUEST_SHOW_ACDISPLAY_DELAY = 0; // ms.
-
-    private static WeakReference<ProximitySensor> sProximitySensorWeak;
-    private static long sLastEventTime;
-    private static boolean sAttached;
-    private static boolean sNear;
-
-    private float mAttachedNumber;
-    private float mMaximumRange;
-    private boolean mFirstChange;
-
-    private PowerManager mPowerManager;
-
-    private Handler mHandler = new Handler();
-    private Runnable mHideRunnable = new Runnable() {
-        @Override
-        public void run() {
-            requestHideAcDisplay();
-        }
-    };
-    private Runnable mShowRunnable = new Runnable() {
-        @Override
-        public void run() {
-            requestShowAcDisplay();
-        }
-    };
-
-    private ProximitySensor() {
-        super();
-    }
-
-    public static synchronized ProximitySensor getInstance() {
-        ProximitySensor sensor = sProximitySensorWeak != null
-                ? sProximitySensorWeak.get() : null;
-        if (sensor == null) {
-            sensor = new ProximitySensor();
-            sProximitySensorWeak = new WeakReference<>(sensor);
-        }
-        return sensor;
-    }
-
-    /**
-     * @return {@code true} if sensor is currently in "near" state, and {@code false} otherwise.
-     */
-    public static boolean isNear() {
-        return (getTimeNow() - sLastEventTime < 1000 || sAttached) && sNear;
-    }
-
-    @Override
-    public int getType() {
-        return Sensor.TYPE_PROXIMITY;
-    }
-
-    @Override
-    public void onAttached(SensorManager sensorManager, Context context) {
-        synchronized (this) {
-            // Register sensors only once.
-            if (mAttachedNumber++ > 0) {
-                return;
-            }
-
-            Sensor proximitySensor = sensorManager.getDefaultSensor(getType());
-            sensorManager.registerListener(this, proximitySensor, SensorManager.SENSOR_DELAY_NORMAL);
-
-            mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-            mMaximumRange = proximitySensor.getMaximumRange();
-
-            sAttached = true;
-            mFirstChange = true;
-        }
-    }
-
-    @Override
-    public void onDetached(SensorManager sensorManager) {
-        synchronized (this) {
-            if (--mAttachedNumber > 0) {
-                return;
-            }
-
-            sensorManager.unregisterListener(this);
-            mHandler.removeCallbacks(mHideRunnable);
-            mHandler.removeCallbacks(mShowRunnable);
-
-            sAttached = false;
-        }
-    }
-
-    @Override
-    public void onSensorChanged(SensorEvent event) {
-        final float distance = event.values[0];
-        final boolean isNear = distance < mMaximumRange || distance < 1.0f;
-        final boolean changed = sNear != (sNear = isNear) || mFirstChange;
-
-        if (Build.DEBUG) {
-            Log.d(TAG, "distance=" + distance
-                    + " is_near=" + isNear
-                    + " changed=" + changed);
-        }
-
-        if (!changed) {
-            // Well just in cause if proximity sensor is NOT always eventual.
-            // This should not happen, but who knows... I found maximum
-            // range buggy enough.
-            return;
-        }
-
-        mHandler.removeCallbacks(mHideRunnable);
-        mHandler.removeCallbacks(mShowRunnable);
-        long now = getTimeNow();
-
-        long delay = isNear ? CHANGE_TO_NEAR_MIN_DELAY : CHANGE_TO_FAR_MIN_DELAY;
-        if (now > sLastEventTime + delay && isNear == isScreenOn() && !mFirstChange) {
-
-            // Hide or show the AcDisplay after a short delay
-            // during which this action can be canceled.
-            if (isNear) {
-                mHandler.postDelayed(mHideRunnable,
-                        REQUEST_HIDE_ACDISPLAY_DELAY);
-            } else {
-                mHandler.postDelayed(mShowRunnable,
-                        REQUEST_SHOW_ACDISPLAY_DELAY);
-            }
-        }
-
-        sLastEventTime = now;
-        mFirstChange = false;
-    }
-
-    @Override
-    public void onAccuracyChanged(Sensor sensor, int accuracy) { /* unused */ }
-
-    private boolean isScreenOn() {
-        return mPowerManager.isScreenOn();
-    }
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/KeyguardActivity.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/KeyguardActivity.java
index a9722f57..66540833 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/KeyguardActivity.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/KeyguardActivity.java
@@ -26,11 +26,14 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.Bundle;
-import android.os.Handler;
+import android.os.SystemClock;
 import android.util.Log;
+import android.view.MotionEvent;
 import android.view.WindowManager;
 
+import com.achep.acdisplay.App;
 import com.achep.acdisplay.Build;
+import com.achep.acdisplay.R;
 
 /**
  * Created by Artem on 23.02.14.
@@ -42,14 +45,36 @@ public abstract class KeyguardActivity extends Activity {
     public static final String EXTRA_TURN_SCREEN_ON = "turn_screen_on";
     public static final String EXTRA_FINISH_ON_SCREEN_OFF = "finish_on_screen_off";
 
-    public static final String INTENT_EAT_HOME_PRESS_START = "com.achep.acdisplay.EAT_HOME_PRESS_START";
-    public static final String INTENT_EAT_HOME_PRESS_STOP = "com.achep.acdisplay.EAT_HOME_PRESS_STOP";
-
     private BroadcastReceiver mScreenOffReceiver;
 
     private boolean mLocking;
     private boolean mUnlocking;
 
+    private long mPendingFinishStartTime;
+    private int mPendingFinishMax;
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+
+        if (!hasFocus) {
+            long now = SystemClock.elapsedRealtime();
+            long elapsedTime = now - mPendingFinishStartTime;
+            if (elapsedTime < mPendingFinishMax) {
+                if (Build.DEBUG) Log.d(TAG, "Doing pending finish: elapsed_time=" + elapsedTime);
+                finish();
+            }
+        }
+    }
+
+    @Override
+    public boolean dispatchTouchEvent(MotionEvent ev) {
+        if (ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
+            mPendingFinishStartTime -= 500;
+        }
+        return super.dispatchTouchEvent(ev);
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
@@ -70,6 +95,7 @@ public abstract class KeyguardActivity extends Activity {
 
         mLocking = false;
         mUnlocking = false;
+        mPendingFinishMax = getResources().getInteger(R.integer.config_maxPendingFinishDelayMillis);
 
         if (finishOnScreenOff) {
             IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
@@ -91,19 +117,28 @@ public abstract class KeyguardActivity extends Activity {
         mUnlocking = false;
         mLocking = false;
 
-        // Notifies Xposed module to start ignoring
-        // home button press.
-        Intent intent = new Intent(INTENT_EAT_HOME_PRESS_START);
-        sendBroadcast(intent);
+        overrideHomePress(true);
     }
 
     @Override
     protected void onPause() {
         super.onPause();
+        overrideHomePress(false);
+    }
 
-        // Notifies Xposed module to stop ignoring
-        // home button press.
-        Intent intent = new Intent(INTENT_EAT_HOME_PRESS_STOP);
+    /**
+     * Notifies Xposed module to start ignoring home button press.
+     * Please, notice that it will ignore home button click everywhere
+     * until you call {@code overrideHomePress(false)}
+     *
+     * @param override {@code true} to start ignoring, {@code false} to stop.
+     * @see com.achep.acdisplay.xposed.OverrideHomeButton
+     * @see #sendBroadcast(android.content.Intent)
+     */
+    private void overrideHomePress(boolean override) {
+        Intent intent = new Intent(override
+                ? App.ACTION_EAT_HOME_PRESS_START
+                : App.ACTION_EAT_HOME_PRESS_STOP);
         sendBroadcast(intent);
     }
 
@@ -118,7 +153,7 @@ public abstract class KeyguardActivity extends Activity {
     /**
      * Turns screen off.
      *
-     * @return True if successful, False otherwise.
+     * @return {@code true} if successful, {@code false} otherwise.
      */
     public boolean lock() {
         DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
@@ -132,25 +167,38 @@ public abstract class KeyguardActivity extends Activity {
     }
 
     /**
-     * Unlocks device and runs {@link Runnable runnable} when unlocked.
+     * Unlocks keyguard and runs {@link Runnable runnable} when unlocked.
+     */
+    public void unlock(Runnable runnable) {
+        unlock(runnable, true);
+    }
+
+    public void unlockWithPendingFinish(Runnable runnable) {
+        mPendingFinishStartTime = SystemClock.elapsedRealtime();
+        unlock(runnable, false);
+    }
+
+    /**
+     * Unlocks keyguard and runs {@link Runnable runnable} when unlocked.
      *
-     * @param runnable may be null
+     * @param finish {@code true} to finish activity, {@code false} to keep it
+     * @see #unlock(Runnable)
+     * @see #unlockWithPendingFinish(Runnable)
+     * @see #isUnlocking()
      */
     public void unlock(final Runnable runnable, final boolean finish) {
         if (Build.DEBUG) Log.d(TAG, "Unlocking with params: finish=" + finish);
 
-        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
-
         // If keyguard is disabled no need to make
         // a delay between calling this method and
         // unlocking.
         // Otherwise we need this delay to get new
         // flags applied.
         KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
-        int delay = km.isKeyguardLocked() ? 120 : 0;
+        int delay = km.isKeyguardLocked() ? 40 : 0; // TODO: Find the way to get rid of this delay
 
-        mUnlocking = true;
-        new Handler().postDelayed(new Runnable() {
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
+        getWindow().getDecorView().postDelayed(new Runnable() {
             @Override
             public void run() {
                 if (runnable != null) runnable.run();
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/MainActivity.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/MainActivity.java
index f909a7e4..dbb22349 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/MainActivity.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/activities/MainActivity.java
@@ -23,11 +23,12 @@ import android.app.Fragment;
 import android.app.FragmentManager;
 import android.app.Notification;
 import android.app.NotificationManager;
+import android.app.PendingIntent;
 import android.app.admin.DevicePolicyManager;
+import android.content.ActivityNotFoundException;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.graphics.BitmapFactory;
@@ -35,7 +36,6 @@ import android.media.RingtoneManager;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.PowerManager;
-import android.preference.PreferenceManager;
 import android.text.Html;
 import android.util.Log;
 import android.view.Menu;
@@ -43,13 +43,16 @@ import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewStub;
+import android.widget.Button;
 import android.widget.CompoundButton;
 import android.widget.Switch;
 
 import com.achep.acdisplay.App;
+import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
+import com.achep.acdisplay.acdisplay.AcDisplayActivity;
 import com.achep.acdisplay.admin.AdminReceiver;
 import com.achep.acdisplay.blacklist.activities.BlacklistActivity;
 import com.achep.acdisplay.fragments.AboutDialog;
@@ -57,6 +60,7 @@ import com.achep.acdisplay.iab.DonationFragment;
 import com.achep.acdisplay.settings.Settings;
 import com.achep.acdisplay.utils.AccessUtils;
 import com.achep.acdisplay.utils.PackageUtils;
+import com.achep.acdisplay.utils.ToastUtils;
 import com.achep.acdisplay.utils.ViewUtils;
 
 /**
@@ -66,28 +70,40 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
 
     private static final String TAG = "MainActivity";
 
-    private static final String ACTION_NOTIFICATION_LISTENER_SETTINGS =
-            "android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS";
-
-    private static final int SLEEP_SEND_NOTIFICATION_DELAY = 3000;
-
     private Switch mSwitch;
     private Config mConfig;
     private boolean mBroadcasting;
 
     private ViewGroup mAccessWarningPanel;
-    private View mAccessAllowNotification;
-    private View mAccessAllowDeviceAdmin;
+    private Button mAccessAllowNotification;
+    private Button mAccessAllowDeviceAdmin;
 
     private MenuItem mSendTestNotificationMenuItem;
 
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+
+        // Transfer in-app-billing service's events to
+        // its fragment.
+        if (requestCode == DonationFragment.RC_REQUEST) {
+            FragmentManager fm = getFragmentManager();
+            Fragment fragment = fm.findFragmentByTag(DialogHelper.TAG_FRAGMENT_DONATION);
+            if (fragment instanceof DonationFragment) {
+                fragment.onActivityResult(requestCode, resultCode, data);
+                return;
+            }
+        }
+
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.main);
 
         mConfig = Config.getInstance();
-        mConfig.addOnConfigChangedListener(this);
+        mConfig.registerListener(this);
 
         getActionBar().setDisplayShowCustomEnabled(true);
         getActionBar().setCustomView(R.layout.layout_ab_switch);
@@ -115,11 +131,11 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
 
         try {
             PackageInfo pi = getPackageManager().getPackageInfo(PackageUtils.getName(this), 0);
-            SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
+            Config.Triggers triggers = mConfig.getTriggers();
 
-            int oldVersionCode = prefs.getInt("previous_version_code", 0);
+            int oldVersionCode = triggers.getPreviousVersion();
             if (oldVersionCode < pi.versionCode) {
-                prefs.edit().putInt("previous_version_code", pi.versionCode).apply();
+                triggers.setPreviousVersion(this, pi.versionCode, null);
 
                 // Show the warning message for Paranoid Android users.
                 if (android.os.Build.DISPLAY.startsWith("pa_") && oldVersionCode == 0) {
@@ -140,36 +156,33 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
     }
 
     private void showAlertParanoidAndroidBug() {
-        CharSequence messageText = Html.fromHtml(getString(R.string.pa_message));
-        new DialogHelper.Builder(this)
-                .setIcon(R.drawable.ic_dialog_bug)
-                .setTitle(R.string.pa_title)
-                .setMessage(messageText)
-                .wrap()
-                .setPositiveButton(android.R.string.ok, null)
-                .create()
-                .show();
+        showSimpleDialog(
+                R.drawable.ic_dialog_bug,
+                getString(R.string.pa_title),
+                Html.fromHtml(getString(R.string.pa_message)));
     }
 
     private void showAlertSpeech() {
-        CharSequence messageText = Html.fromHtml(getString(R.string.speech_message));
-        new DialogHelper.Builder(this)
-                .setIcon(R.drawable.ic_dialog_me)
-                .setTitle(R.string.speech_title)
-                .setMessage(messageText)
-                .wrap()
-                .setPositiveButton(android.R.string.ok, null)
-                .create()
-                .show();
+        showSimpleDialog(
+                R.drawable.ic_dialog_me,
+                getString(R.string.speech_title),
+                Html.fromHtml(getString(R.string.speech_message)));
     }
 
     private void showAlertWelcome() {
+        showSimpleDialog(
+                R.mipmap.ic_launcher,
+                AboutDialog.getVersionName(this),
+                Html.fromHtml(getString(R.string.news_message)));
+    }
+
+    private void showSimpleDialog(int iconRes, CharSequence title, CharSequence message) {
         new DialogHelper.Builder(this)
-                .setIcon(R.mipmap.ic_launcher)
-                .setTitle(AboutDialog.getVersionName(this))
-                .setMessage(Html.fromHtml(getString(R.string.news_message)))
+                .setIcon(iconRes)
+                .setTitle(title)
+                .setMessage(message)
                 .wrap()
-                .setPositiveButton(R.string.close, null)
+                .setPositiveButton(android.R.string.ok, null)
                 .create()
                 .show();
     }
@@ -180,31 +193,50 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         updateAccessPanel();
     }
 
+    /**
+     * Inflates access panel's layout and sets it up.
+     *
+     * @see #updateAccessPanel()
+     */
     private void initAccessPanel() {
         mAccessWarningPanel = (ViewGroup) ((ViewStub) findViewById(R.id.access)).inflate();
-        mAccessAllowNotification = mAccessWarningPanel.findViewById(R.id.access_notification);
+        mAccessAllowNotification = (Button) mAccessWarningPanel.findViewById(R.id.access_notification);
         mAccessAllowNotification.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
-                Intent intent = new Intent(ACTION_NOTIFICATION_LISTENER_SETTINGS);
-                startActivity(intent);
+                Context context = MainActivity.this;
+                Intent intent = new Intent("android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS");
+                try {
+                    startActivity(intent);
+                } catch (ActivityNotFoundException e) {
+                    ToastUtils.showLong(context, R.string.access_notifications_grant_manually);
+                    Log.e(TAG, "Notification listeners activity not found.");
+                }
             }
         });
-        mAccessAllowDeviceAdmin = mAccessWarningPanel.findViewById(R.id.access_device_admin);
+        mAccessAllowDeviceAdmin = (Button) mAccessWarningPanel.findViewById(R.id.access_device_admin);
         mAccessAllowDeviceAdmin.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
-                ComponentName admin = new ComponentName(MainActivity.this, AdminReceiver.class);
-                Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN)
+                Context context = MainActivity.this;
+                ComponentName admin = new ComponentName(context, AdminReceiver.class);
+                Intent intent = new Intent()
+                        .setAction(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN)
                         .putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, admin);
-                startActivity(intent);
+
+                try {
+                    startActivity(intent);
+                } catch (ActivityNotFoundException e) {
+                    ToastUtils.showLong(context, R.string.access_device_admin_grant_manually);
+                    Log.e(TAG, "Device admins activity not found.");
+                }
             }
         });
     }
 
     private void updateAccessPanel() {
-        boolean showDeviceAdminBtn = !AccessUtils.isDeviceAdminEnabled(this);
-        boolean showNotifiesBtn = !AccessUtils.isNotificationAccessEnabled(this);
+        boolean showDeviceAdminBtn = !AccessUtils.isDeviceAdminAccessGranted(this);
+        boolean showNotifiesBtn = !AccessUtils.isNotificationAccessGranted(this);
 
         if (showDeviceAdminBtn || showNotifiesBtn || mAccessWarningPanel != null) {
             if (mAccessWarningPanel == null) initAccessPanel();
@@ -215,31 +247,34 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         }
 
         mSwitch.setEnabled(!showDeviceAdminBtn && !showNotifiesBtn);
+        mSwitch.setChecked(mSwitch.isEnabled() && mSwitch.isChecked());
         updateSendTestNotificationMenuItem();
     }
 
     private void updateSendTestNotificationMenuItem() {
-        if (mSendTestNotificationMenuItem == null) {
-            return;
+        if (mSendTestNotificationMenuItem != null) {
+            mSendTestNotificationMenuItem.setVisible(mSwitch.isChecked());
         }
-
-        mSendTestNotificationMenuItem.setVisible(mSwitch.isEnabled() && mSwitch.isChecked());
     }
 
     @Override
     protected void onDestroy() {
         super.onDestroy();
-        mConfig.removeOnConfigChangedListener(this);
+        mConfig.unregisterListener(this);
     }
 
     @Override
     public void onConfigChanged(Config config, String key, Object value) {
-        if (key.equals(Config.KEY_ENABLED)) {
-            if (!mBroadcasting) {
+        if (mBroadcasting) {
+            return;
+        }
+
+        switch (key) {
+            case Config.KEY_ENABLED:
                 mBroadcasting = true;
                 mSwitch.setChecked((Boolean) value);
                 mBroadcasting = false;
-            }
+                break;
         }
     }
 
@@ -252,23 +287,6 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         return true;
     }
 
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-
-        // Transfer in-app-billing service's events to
-        // its fragment.
-        if (requestCode == DonationFragment.RC_REQUEST) {
-            FragmentManager fm = getFragmentManager();
-            Fragment fragment = fm.findFragmentByTag(DialogHelper.TAG_FRAGMENT_DONATION);
-            if (fragment instanceof DonationFragment) {
-                fragment.onActivityResult(requestCode, resultCode, data);
-                return;
-            }
-        }
-
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
     @Override
     public boolean onMenuItemSelected(int featureId, MenuItem item) {
         switch (item.getItemId()) {
@@ -279,37 +297,7 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
                 startActivity(new Intent(this, BlacklistActivity.class));
                 break;
             case R.id.action_test:
-                PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-                PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Test notification.");
-                wakeLock.acquire(SLEEP_SEND_NOTIFICATION_DELAY);
-
-                try {
-                    // Go sleep
-                    DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
-                    dpm.lockNow();
-
-                    new Handler().postDelayed(new Runnable() {
-                        @Override
-                        public void run() {
-                            Notification.Builder builder = new Notification.Builder(MainActivity.this)
-                                    .setContentTitle(getString(R.string.app_name))
-                                    .setContentText(getString(R.string.test_notification_message))
-                                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
-                                    .setSmallIcon(R.drawable.stat_test)
-                                    .setAutoCancel(true)
-                                    .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION));
-                            Notification.BigTextStyle builderBigText = new Notification.BigTextStyle(builder)
-                                    .bigText(getString(R.string.test_notification_message_large));
-
-                            NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-                            nm.notify(App.ID_NOTIFY_TEST, builderBigText.build());
-                        }
-                    }, SLEEP_SEND_NOTIFICATION_DELAY);
-                } catch (SecurityException e) {
-                    Log.wtf(TAG, "Failed to turn screen off");
-
-                    wakeLock.release();
-                }
+                startAcDisplayTest(Build.DEBUG);
                 break;
             case R.id.action_donate:
                 DialogHelper.showDonateDialog(this);
@@ -328,4 +316,64 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         }
         return true;
     }
+
+    /**
+     * Turns screen off and sends a test notification.
+     *
+     * @param fake {@code true} if it simply starts {@link AcDisplayActivity},
+     *             {@code false} if it uses notification
+     */
+    private void startAcDisplayTest(boolean fake) {
+        if (fake) {
+            sendTestNotification();
+            startActivity(new Intent(this, AcDisplayActivity.class)
+                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                            | Intent.FLAG_ACTIVITY_NO_ANIMATION));
+            return;
+        }
+
+        int delay = getResources().getInteger(R.integer.config_test_notification_delay);
+
+        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Test notification.");
+        wakeLock.acquire(delay);
+
+        try {
+            // Go sleep
+            DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
+            dpm.lockNow();
+
+            new Handler().postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    sendTestNotification();
+                }
+            }, delay);
+        } catch (SecurityException e) {
+            Log.wtf(TAG, "Failed to turn screen off");
+
+            wakeLock.release();
+        }
+    }
+
+    private void sendTestNotification() {
+        int notificationId = App.ID_NOTIFY_TEST;
+        PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.this,
+                notificationId, new Intent(MainActivity.this, MainActivity.class),
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        Notification.Builder builder = new Notification.Builder(MainActivity.this)
+                .setContentTitle(getString(R.string.app_name))
+                .setContentText(getString(R.string.test_notification_message))
+                .setContentIntent(pendingIntent)
+                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
+                .setSmallIcon(R.drawable.stat_test)
+                .setAutoCancel(true)
+                .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION));
+        Notification.BigTextStyle builderBigText = new Notification.BigTextStyle(builder)
+                .bigText(getString(R.string.test_notification_message_large));
+
+        NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
+        nm.notify(notificationId, builderBigText.build());
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/admin/AdminReceiver.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/admin/AdminReceiver.java
index a17207bb..ccff2c44 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/admin/AdminReceiver.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/admin/AdminReceiver.java
@@ -31,8 +31,8 @@ import com.achep.acdisplay.R;
  */
 public class AdminReceiver extends android.app.admin.DeviceAdminReceiver {
 
-    public static final String ACTION_DISABLED = "device_admin_action_disabled";
-    public static final String ACTION_ENABLED = "device_admin_action_enabled";
+    public static final String ACTION_DISABLED = "device_admin_disabled";
+    public static final String ACTION_ENABLED = "device_admin_enabled";
 
     @Override
     public void onDisabled(Context context, Intent intent) {
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleDarkeningAnimation.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleDarkeningAnimation.java
new file mode 100644
index 00000000..5a52b7a0
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleDarkeningAnimation.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.animations;
+
+import android.view.animation.Animation;
+import android.view.animation.Transformation;
+
+import com.achep.acdisplay.widgets.CircleView;
+
+/**
+ * Created by achep on 19.04.14.
+ */
+public class CircleDarkeningAnimation extends Animation {
+
+    private final CircleView mCircleView;
+    private float from;
+    private float to;
+
+    public CircleDarkeningAnimation(CircleView circleView, float from, float to) {
+        super();
+        mCircleView = circleView;
+        this.from = from;
+        this.to = to;
+    }
+
+    @Override
+    protected void applyTransformation(float interpolatedTime, Transformation t) {
+        super.applyTransformation(interpolatedTime, t);
+        float value = (from + (to - from) * interpolatedTime);
+
+        mCircleView.setDarkening(value);
+    }
+
+    public void setRange(float from, float to) {
+        this.from = from;
+        this.to = to;
+    }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleViewAnimation.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleRadiusAnimation.java
similarity index 85%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleViewAnimation.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleRadiusAnimation.java
index 225c6c6e..c5b03202 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleViewAnimation.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/animations/CircleRadiusAnimation.java
@@ -8,13 +8,13 @@ import com.achep.acdisplay.widgets.CircleView;
 /**
  * Created by achep on 19.04.14.
  */
-public class CircleViewAnimation extends Animation {
+public class CircleRadiusAnimation extends Animation {
 
     private final CircleView mCircleView;
     private float from;
     private float to;
 
-    public CircleViewAnimation(CircleView circleView, float from, float to) {
+    public CircleRadiusAnimation(CircleView circleView, float from, float to) {
         super();
         mCircleView = circleView;
         this.from = from;
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java
index 3cc36a88..aeb5c649 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java
@@ -43,8 +43,8 @@ public class AppConfig {
 
     public String packageName;
     public boolean enabled = DEFAULT_ENABLED;
-    public boolean[] restricted = new boolean[] { DEFAULT_RESTRICTED };
-    public boolean[] hidden = new boolean[] { DEFAULT_HIDDEN };
+    public boolean[] restricted = new boolean[]{DEFAULT_RESTRICTED};
+    public boolean[] hidden = new boolean[]{DEFAULT_HIDDEN};
 
     public AppConfig(String packageName) {
         this(packageName, DEFAULT_ENABLED, DEFAULT_RESTRICTED, DEFAULT_HIDDEN);
@@ -71,7 +71,7 @@ public class AppConfig {
      * Copies data of the first config into the second one.
      *
      * @param config origin config
-     * @param clone clone config
+     * @param clone  clone config
      * @return Cloned config
      * @see #reset(AppConfig)
      */
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java
index b16a82bc..893a11e8 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java
@@ -24,9 +24,9 @@ import android.util.Log;
 /**
  * The blacklist (also known as per-app-features.)
  *
+ * @author Artem Chepurnoy
  * @see #saveAppConfig(android.content.Context, AppConfig, SharedList.OnSharedListChangedListener)
  * @see #getAppConfig(String)
- * @author Artem Chepurnoy
  */
 public final class Blacklist extends SharedList<AppConfig, AppConfig.AppConfigSaver> {
 
@@ -50,7 +50,7 @@ public final class Blacklist extends SharedList<AppConfig, AppConfig.AppConfigSa
          *
          * @param configNew An instance of new app's config.
          * @param configOld An instance of previous app's config (can not be null.)
-         * @param diff The difference between two configs.
+         * @param diff      The difference between two configs.
          */
         public abstract void onBlacklistChanged(AppConfig configNew, AppConfig configOld, int diff);
 
@@ -64,6 +64,7 @@ public final class Blacklist extends SharedList<AppConfig, AppConfig.AppConfigSa
 
         /**
          * Should never be called.
+         *
          * @see #onBlacklistChanged(AppConfig, AppConfig, int)
          */
         @Override
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/SharedList.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/SharedList.java
index ee03d4a4..308b7c28 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/SharedList.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/SharedList.java
@@ -81,8 +81,8 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
     /**
      * The provider of the diffs between "old" and "new" objects in list.
      *
-     * @see OnSharedListChangedListener#onPut(Object, Object, int)
      * @author Artem Chepurnoy
+     * @see OnSharedListChangedListener#onPut(Object, Object, int)
      */
     public static abstract class Comparator<V> {
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/activities/BlacklistActivity.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/activities/BlacklistActivity.java
index 38ea5f20..ade602f8 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/activities/BlacklistActivity.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/blacklist/activities/BlacklistActivity.java
@@ -511,6 +511,7 @@ public class BlacklistActivity extends PreferenceActivity {
             mHeaders = headers;
 
             // Set the default icon till the actual app icon is loaded in async task
+            //noinspection ResourceType
             mDefaultImg = context.getResources().getDrawable(android.R.mipmap.sym_def_app_icon);
 
             mBlacklistEnablers = new HashSet<>();
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/AboutDialog.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/AboutDialog.java
index 8c7aa72f..cbfc97a4 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/AboutDialog.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/AboutDialog.java
@@ -28,8 +28,11 @@ import android.content.res.Resources;
 import android.os.Bundle;
 import android.text.Html;
 import android.view.View;
+import android.view.animation.AnimationSet;
+import android.view.animation.AnimationUtils;
 import android.widget.Toast;
 
+import com.achep.acdisplay.App;
 import com.achep.acdisplay.Build;
 import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
@@ -40,11 +43,12 @@ import com.achep.acdisplay.utils.ToastUtils;
  *
  * @author Artem Chepurnoy
  */
-public class AboutDialog extends DialogFragment {
+public class AboutDialog extends DialogFragment implements View.OnClickListener {
 
     private static final String VERSION_UNAVAILABLE = "N/A";
+    private static final int EASTER_EGGS_CLICK_NUMBER = 5;
 
-    private int mEasterEggClicks;
+    private int mTitleClickNumber;
     private Toast mTimeStampToast;
 
     /**
@@ -75,36 +79,41 @@ public class AboutDialog extends DialogFragment {
 
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
-        final Context context = getActivity();
+        Context context = getActivity();
         assert context != null;
 
+        CharSequence message = Html.fromHtml(getString(
+                R.string.about_message, getString(R.string.about_thanks)));
+
         View view = new DialogHelper.Builder(context)
                 .setIcon(R.mipmap.ic_launcher)
                 .setTitle(getVersionName(context))
-                .setMessage(Html.fromHtml(getString(R.string.about_message)))
+                .setMessage(message)
                 .createCommonView();
-        view.findViewById(R.id.title).setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                if (mTimeStampToast != null) {
-                    mTimeStampToast.cancel();
-                }
-
-                if (++mEasterEggClicks == 5) {
-                    if (Build.DEBUG) ToastUtils.showShort(getActivity(), "There will be an Easter Egg.");
-
-                    mEasterEggClicks = 0;
-                    // TODO: Put an Easter egg here.
-                } else {
-                    mTimeStampToast = Toast.makeText(context, Build.TIME_STAMP, Toast.LENGTH_LONG);
-                    mTimeStampToast.show();
-                }
-            }
-        });
+        View title = view.findViewById(R.id.title);
+        title.setOnClickListener(this);
 
         return new AlertDialog.Builder(context)
                 .setView(view)
                 .setNeutralButton(R.string.close, null)
                 .create();
     }
+
+    @Override
+    public void onClick(View v) {
+        if (mTimeStampToast != null) {
+            // Cancel previous toast to avoid of
+            // continuous spam after.
+            mTimeStampToast.cancel();
+        }
+
+        Context context = getActivity();
+
+        if (++mTitleClickNumber == EASTER_EGGS_CLICK_NUMBER) {
+            App.startEasterEggs(context);
+            mTitleClickNumber = 0;
+        } else {
+            mTimeStampToast = ToastUtils.showLong(context, Build.TIME_STAMP);
+        }
+    }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/FeedbackDialog.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/FeedbackDialog.java
index b425f7b8..63676729 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/FeedbackDialog.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/FeedbackDialog.java
@@ -22,22 +22,17 @@ import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Dialog;
 import android.app.DialogFragment;
-import android.content.ContentProvider;
-import android.content.ContentValues;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.database.Cursor;
-import android.database.MatrixCursor;
 import android.net.Uri;
 import android.os.Bundle;
-import android.os.ParcelFileDescriptor;
-import android.provider.OpenableColumns;
 import android.util.Log;
-import android.view.LayoutInflater;
 import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
 import android.widget.AdapterView;
 import android.widget.Button;
 import android.widget.CheckBox;
@@ -46,9 +41,11 @@ import android.widget.EditText;
 import android.widget.Spinner;
 
 import com.achep.acdisplay.Build;
+import com.achep.acdisplay.Config;
 import com.achep.acdisplay.Device;
 import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
+import com.achep.acdisplay.providers.LogAttachmentProvider;
 import com.achep.acdisplay.utils.FileUtils;
 import com.achep.acdisplay.utils.IntentUtils;
 import com.achep.acdisplay.utils.PackageUtils;
@@ -58,14 +55,12 @@ import com.achep.acdisplay.utils.ViewUtils;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
 import java.text.SimpleDateFormat;
 import java.util.Date;
-import java.util.List;
 import java.util.Locale;
 import java.util.TimeZone;
 
@@ -74,46 +69,98 @@ import java.util.TimeZone;
  * <p/>
  * Provides an UI for sending bugs & suggestions on my email.
  */
-public class FeedbackDialog extends DialogFragment {
+public class FeedbackDialog extends DialogFragment implements Config.OnConfigChangedListener {
 
     private static final String TAG = "FeedbackDialog";
 
+    private View mFaqContainer;
+
     private Spinner mSpinner;
     private EditText mEditText;
     private CheckBox mAttachLogCheckBox;
 
-    private boolean mTriedToSendShortMessage;
+    private AdapterView.OnItemSelectedListener mListener =
+            new AdapterView.OnItemSelectedListener() {
+                @Override
+                public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                    // Show "Attach log" checkbox only if the type
+                    // of this message is "Bug".
+                    ViewUtils.setVisible(mAttachLogCheckBox, position == 0);
+                }
 
-    private boolean mBroadcasting;
+                @Override
+                public void onNothingSelected(AdapterView<?> parent) {
+                    ViewUtils.setVisible(mAttachLogCheckBox, false);
+                }
+            };
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        Config config = Config.getInstance();
+        Config.Triggers triggers = config.getTriggers();
+
+        config.registerListener(this);
+        updateFaqPanel(triggers.isHelpRead());
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        Config config = Config.getInstance();
+        config.unregisterListener(this);
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_TRIG_HELP_READ:
+                updateFaqPanel((boolean) value);
+                break;
+        }
+    }
 
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
         Activity activity = getActivity();
         assert activity != null;
 
-        LayoutInflater inflater = (LayoutInflater) activity
-                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        View root = inflater.inflate(R.layout.fragment_dialog_feedback, null);
-        assert root != null;
+        View view = new DialogHelper.Builder(activity)
+                .setIcon(getResources().getDrawable(R.drawable.ic_dialog_mail))
+                .setTitle(getString(R.string.feedback))
+                .setView(R.layout.fragment_dialog_feedback)
+                .createSkeletonView();
+        final AlertDialog alertDialog = new AlertDialog.Builder(activity)
+                .setView(view)
+                .setNegativeButton(android.R.string.cancel, null)
+                .setPositiveButton(R.string.feedback_send, null)
+                .create();
+        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
 
-        mSpinner = (Spinner) root.findViewById(R.id.type);
-        mSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
             @Override
-            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
-                ViewUtils.setVisible(mAttachLogCheckBox, position == 0);
-            }
+            public void onShow(DialogInterface dialog) {
+                Button button = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                assert button != null;
+                button.setOnClickListener(new View.OnClickListener() {
 
-            @Override
-            public void onNothingSelected(AdapterView<?> parent) {
-                ViewUtils.setVisible(mAttachLogCheckBox, false);
+                    @Override
+                    public void onClick(View view) {
+                        send();
+                    }
+                });
             }
         });
-        mEditText = (EditText) root.findViewById(R.id.message);
-        mAttachLogCheckBox = (CheckBox) root.findViewById(R.id.checkbox);
+
+        mSpinner = (Spinner) view.findViewById(R.id.type);
+        mSpinner.setOnItemSelectedListener(mListener);
+        mEditText = (EditText) view.findViewById(R.id.message);
+        mAttachLogCheckBox = (CheckBox) view.findViewById(R.id.checkbox);
         mAttachLogCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
             @Override
             public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-                if (mBroadcasting || !isChecked) {
+                if (!isChecked) {
                     return;
                 }
 
@@ -121,73 +168,70 @@ public class FeedbackDialog extends DialogFragment {
                 new DialogHelper.Builder(getActivity())
                         .setMessage(messageText)
                         .wrap()
-                        .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {
-                            @Override
-                            public void onClick(DialogInterface dialog, int which) {
-                                mBroadcasting = true;
-                                mAttachLogCheckBox.setChecked(false);
-                                mBroadcasting = false;
-                            }
-                        })
                         .setPositiveButton(android.R.string.ok, null)
                         .create()
                         .show();
             }
         });
 
-        final AlertDialog alertDialog = new DialogHelper.Builder(getActivity())
-                .setIcon(getResources().getDrawable(R.drawable.ic_dialog_mail))
-                .setTitle(getString(R.string.feedback))
-                .setView(root)
-                .wrap()
-                .setNegativeButton(android.R.string.cancel, null)
-                .setPositiveButton(R.string.feedback_send, null)
-                .create();
-        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+        // Frequently asked questions panel
+        Config.Triggers triggers = Config.getInstance().getTriggers();
+        if (!triggers.isHelpRead()) initFaqPanel((ViewGroup) view);
 
-            @Override
-            public void onShow(DialogInterface dialog) {
-                Button button = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
-                assert button != null;
-                button.setOnClickListener(new View.OnClickListener() {
+        return alertDialog;
+    }
 
-                    @Override
-                    public void onClick(View view) {
-                        send();
-                    }
-                });
+    /**
+     * Initialize Frequently asked questions panel. This panel is here to reduce
+     * the number of already answered questions.
+     */
+    private void initFaqPanel(ViewGroup root) {
+        mFaqContainer = ((ViewStub) root.findViewById(R.id.faq)).inflate();
+        mFaqContainer.findViewById(R.id.faq).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                DialogHelper.showHelpDialog(getActivity());
             }
         });
+    }
 
-        return alertDialog;
+    /**
+     * Removes Frequently asked questions panel from the view
+     * and sets {@link #mFaqContainer} to null.
+     * After calling this method you no longer able to get panel back.
+     */
+    private void recycleFaqPanel() {
+        ViewGroup viewGroup = (ViewGroup) mFaqContainer.getParent();
+        viewGroup.removeView(mFaqContainer);
+        mFaqContainer = null;
+    }
+
+    /**
+     * {@link #recycleFaqPanel() Recycles} Frequently asked questions panel when it's not needed
+     * anymore.
+     *
+     * @param isHelpRead {@code true} to recycle panel, {@code false} to do nothing.
+     */
+    private void updateFaqPanel(boolean isHelpRead) {
+        if (mFaqContainer != null && isHelpRead) {
+            recycleFaqPanel();
+        }
     }
 
     private void send() {
-        Activity activity = getActivity();
+        Activity context = getActivity();
         CharSequence message = mEditText.getText();
 
         // Check for message's length
-        int messageMinLength = getResources().getInteger(
-                R.integer.config_feedback_minMessageLength);
-        if (message == null || (message.length() < messageMinLength && !Build.DEBUG)) {
-            String toastText = getString(R.string.feedback_error_msg_too_short, messageMinLength);
-            ToastUtils.showShort(activity, toastText);
-            mTriedToSendShortMessage = true;
+        int msgMinLength = getResources().getInteger(R.integer.config_feedback_minMessageLength);
+        if (message == null || (message.length() < msgMinLength && !Build.DEBUG)) {
+            String toastText = getString(R.string.feedback_error_msg_too_short, msgMinLength);
+            ToastUtils.showShort(context, toastText);
             return;
         }
 
-        PackageInfo pi;
-        try {
-            pi = activity
-                    .getPackageManager()
-                    .getPackageInfo(PackageUtils.getName(activity), 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.wtf(TAG, "Failed to find my PackageInfo.");
-            return;
-        }
-
-        CharSequence title = createTitleMessage(activity, mSpinner.getSelectedItemPosition());
-        CharSequence body = createBodyMessage(pi, message);
+        CharSequence title = createTitleMessage(context, mSpinner.getSelectedItemPosition());
+        CharSequence body = createBodyMessage(context, message);
         Intent intent = new Intent()
                 .putExtra(Intent.EXTRA_EMAIL, new String[]{Build.SUPPORT_EMAIL})
                 .putExtra(Intent.EXTRA_SUBJECT, title)
@@ -202,22 +246,32 @@ public class FeedbackDialog extends DialogFragment {
             intent.setData(Uri.parse("mailto:")); // only email apps should handle it
         }
 
-        if (IntentUtils.hasActivityForThat(activity, intent)) {
+        if (IntentUtils.hasActivityForThat(context, intent)) {
             startActivity(intent);
             dismiss();
         } else {
             String toastText = getString(R.string.feedback_error_no_app);
-            ToastUtils.showLong(activity, toastText);
+            ToastUtils.showLong(context, toastText);
         }
     }
 
     private CharSequence createTitleMessage(Context context, int type) {
-        CharSequence osVersion = Device.hasKitKatApi() ? "KK" : Device.hasJellyBeanMR2Api() ? "JB" : "XX";
+        CharSequence osVersion = Device.hasKitKatApi() ? "KK" : Device.hasJellyBeanMR2Api() ? "JB" : "WTF";
         CharSequence[] typeNames = new CharSequence[]{"bug", "suggestion", "other"};
         return AboutDialog.getVersionName(context) + ": " + osVersion + ", " + typeNames[type];
     }
 
-    private CharSequence createBodyMessage(PackageInfo pi, CharSequence msg) {
+    private CharSequence createBodyMessage(Context context, CharSequence msg) {
+        PackageInfo pi;
+        try {
+            pi = context
+                    .getPackageManager()
+                    .getPackageInfo(PackageUtils.getName(context), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.wtf(TAG, "Failed to find my own PackageInfo.");
+            return msg;
+        }
+
         return "" + msg +
                 '\n' +
                 '\n' +
@@ -227,10 +281,10 @@ public class FeedbackDialog extends DialogFragment {
                 "build_display:" + android.os.Build.DISPLAY + '\n' +
                 "build_brand:" + android.os.Build.BRAND + '\n' +
                 "build_model:" + android.os.Build.MODEL + '\n' +
-                "had_short_message:" + mTriedToSendShortMessage + '\n' +
                 "language:" + Locale.getDefault().getLanguage();
     }
 
+    // TODO: If root is available, get normal (system events included) logcat.
     private void attachLog(Intent intent) {
         Context context = getActivity();
         StringBuilder log = new StringBuilder();
@@ -273,89 +327,4 @@ public class FeedbackDialog extends DialogFragment {
             ToastUtils.showShort(context, getString(R.string.feedback_error_accessing_log));
         }
     }
-
-    public static class LogAttachmentProvider extends ContentProvider {
-
-        private static final String TAG = "LogAttachmentProvider";
-
-        static final String AUTHORITY = "com.achep.acdisplay.logs";
-        static final String DIRECTORY = "logs";
-
-        private static final String COLUMN_DATA = "_data";
-
-        @Override
-        public boolean onCreate() {
-            return true;
-        }
-
-        @Override
-        public Cursor query(Uri uri, String[] projection, String selection,
-                            String[] selectionArgs, String orderBy) {
-            List<String> pathSegments = uri.getPathSegments();
-            String fileName = pathSegments.get(0);
-            File logFile = getContext().getCacheDir();
-            if (logFile == null) {
-                Log.e(TAG, "No cache dir.");
-                return null;
-            }
-
-            logFile = new File(new File(logFile, DIRECTORY), fileName);
-            if (!logFile.exists()) {
-                Log.e(TAG, "Requested log file doesn't exist.");
-                return null;
-            }
-
-            if (projection == null) {
-                projection = new String[]{
-                        COLUMN_DATA,
-                        OpenableColumns.DISPLAY_NAME,
-                        OpenableColumns.SIZE,
-                };
-            }
-
-            MatrixCursor matrixCursor = new MatrixCursor(projection, 1);
-            Object[] row = new Object[projection.length];
-            for (int col = 0; col < projection.length; col++) {
-                switch (projection[col]) {
-                    case COLUMN_DATA:
-                        row[col] = logFile.getAbsolutePath();
-                        break;
-                    case OpenableColumns.DISPLAY_NAME:
-                        row[col] = fileName;
-                        break;
-                    case OpenableColumns.SIZE:
-                        row[col] = logFile.length();
-                        break;
-                }
-            }
-            matrixCursor.addRow(row);
-            return matrixCursor;
-        }
-
-        @Override
-        public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
-            return openFileHelper(uri, "r");
-        }
-
-        @Override
-        public String getType(Uri uri) {
-            return "text/plain";
-        }
-
-        @Override
-        public Uri insert(Uri uri, ContentValues values) {
-            throw new UnsupportedOperationException("insert not supported");
-        }
-
-        @Override
-        public int delete(Uri uri, String selection, String[] selectionArgs) {
-            throw new UnsupportedOperationException("delete not supported");
-        }
-
-        @Override
-        public int update(Uri uri, ContentValues contentValues, String selection,
-                          String[] selectionArgs) {
-            throw new UnsupportedOperationException("update not supported");
-        }
-    }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/HelpDialog.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/HelpDialog.java
index 309ec7ec..824b1872 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/HelpDialog.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/fragments/HelpDialog.java
@@ -18,18 +18,29 @@
  */
 package com.achep.acdisplay.fragments;
 
+import android.app.Activity;
+import android.app.AlertDialog;
 import android.app.Dialog;
 import android.app.DialogFragment;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.net.Uri;
 import android.os.Bundle;
+import android.os.SystemClock;
 import android.text.Html;
+import android.text.method.LinkMovementMethod;
+import android.view.View;
+import android.widget.ProgressBar;
+import android.widget.TextView;
 
+import com.achep.acdisplay.AsyncTask;
+import com.achep.acdisplay.Build;
+import com.achep.acdisplay.Config;
 import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.IntentUtils;
+import com.achep.acdisplay.utils.FileUtils;
+import com.achep.acdisplay.utils.NetworkUtils;
+import com.achep.acdisplay.utils.RawReader;
+
+import java.io.File;
+import java.util.Locale;
 
 /**
  * Dialog fragment that shows FAQ.
@@ -38,26 +49,135 @@ import com.achep.acdisplay.utils.IntentUtils;
  */
 public class HelpDialog extends DialogFragment {
 
-    private static final String HELP_FULL_FAQ = "https://github.com/AChep/AcDisplay/blob/master/FAQ.md";
+    private static final String FILE_NAME = "faq.html";
+    private static final String FILE_URL = Build.Links.REPOSITORY_RAW + "src/main/res/raw-%1$s/faq.html";
+
+    private ProgressBar mProgressBar;
+    private TextView mTextView;
+
+    private CharSequence mFaqMessage;
+
+    private AsyncTask.DownloadText mDownloaderTask;
+    private AsyncTask.DownloadText.Callback mDownloaderCallback =
+            new AsyncTask.DownloadText.Callback() {
+                @Override
+                public void onDownloaded(String text) {
+                    updateFaq(text);
+                }
+            };
+
+    private long mResumedAtTime;
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        if (NetworkUtils.isOnline(activity)) {
+            // Download latest FAQ from the GitHub
+            // and store to file if available.
+            // TODO: Fix url to English version of FAQ
+            String url = String.format(FILE_URL, Locale.getDefault().getLanguage());
+            mDownloaderTask = new AsyncTask.DownloadText(mDownloaderCallback);
+            mDownloaderTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, url);
+        } else {
+            updateFaq(null);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mResumedAtTime = SystemClock.elapsedRealtime();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+
+        // Make sure that user really read the Help dialog.
+        long elapsedTime = SystemClock.elapsedRealtime() - mResumedAtTime;
+        if (elapsedTime > getResources().getInteger(R.integer.config_maxHelpUserReadFuckyou)) {
+            Config.Triggers triggers = Config.getInstance().getTriggers();
+            triggers.setHelpRead(getActivity(), true, null);
+        }
+    }
+
+    @Override
+    public void onDetach() {
+        super.onDetach();
+        AsyncTask.stop(mDownloaderTask);
+        mDownloaderTask = null;
+    }
 
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
-        return new DialogHelper.Builder(getActivity())
+        View view = new DialogHelper.Builder(getActivity())
                 .setIcon(R.drawable.ic_dialog_help)
                 .setTitle(R.string.help)
-                .setMessage(Html.fromHtml(getString(R.string.help_message)))
-                .wrap()
+                .setView(R.layout.fragment_help)
+                .createCommonView();
+        mTextView = (TextView) view.findViewById(R.id.message);
+        mTextView.setVisibility(View.GONE);
+        mTextView.setMovementMethod(new LinkMovementMethod());
+        mProgressBar = (ProgressBar) view.findViewById(R.id.progress_bar);
+        mProgressBar.setVisibility(View.VISIBLE);
+
+        if (mFaqMessage != null) {
+            populateFaq();
+        }
+
+        return new AlertDialog.Builder(getActivity())
                 .setNegativeButton(R.string.close, null)
-                .setPositiveButton(R.string.help_read_more, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        Context context = getActivity();
-                        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(HELP_FULL_FAQ));
-                        if (IntentUtils.hasActivityForThat(context, intent)) {
-                            context.startActivity(intent);
-                        }
-                    }
-                })
+                .setView(view)
                 .create();
     }
+
+    /**
+     * @param text latest FAQ to update from, or {@code null} to keep old.
+     */
+    private void updateFaq(String text) {
+        if (text != null) {
+            // Save text to file on internal storage
+            // to keep latest FAQ offline.
+            FileUtils.writeToFile(getFile(), text);
+        } else {
+            text = readFromFile();
+            if (text == null) text = readFromRaw();
+        }
+
+        mFaqMessage = Html.fromHtml(text);
+        populateFaq();
+    }
+
+    /**
+     * Applies current {@link #mFaqMessage FAQ message} to views, or does nothing
+     * if {@link #mTextView views} are not created yet.
+     */
+    private void populateFaq() {
+        if (mTextView != null) {
+            mTextView.setText(mFaqMessage);
+            mTextView.setVisibility(View.VISIBLE);
+            mProgressBar.setVisibility(View.GONE);
+        }
+    }
+
+    /**
+     * @return Built-in FAQ, that may be not up-to-date.
+     * @see #readFromFile()
+     */
+    private String readFromRaw() {
+        return RawReader.readTextFileFromRawResource(getActivity(), R.raw.faq);
+    }
+
+    /**
+     * @return Previously downloaded FAQ, that may be not up-to-date.
+     * @see #readFromRaw()
+     */
+    private String readFromFile() {
+        return FileUtils.readTextFile(getFile());
+    }
+
+    private File getFile() {
+        return new File(getActivity().getFilesDir(), FILE_NAME);
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/Donation.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/Donation.java
index 7dd9e9ee..dd3f88d1 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/Donation.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/Donation.java
@@ -47,7 +47,7 @@ public class Donation {
      */
     @Override
     public int hashCode() {
-        return new HashCodeBuilder(2, 51)
+        return new HashCodeBuilder(9, 51)
                 .append(amount)
                 .append(text)
                 .append(sku)
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationFragment.java
index 2a41b226..be5429f7 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationFragment.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationFragment.java
@@ -26,10 +26,12 @@ import android.app.DialogFragment;
 import android.content.ActivityNotFoundException;
 import android.content.DialogInterface;
 import android.content.Intent;
-import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Bundle;
 import android.text.Html;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.style.ImageSpan;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.AdapterView;
@@ -40,11 +42,10 @@ import android.widget.ProgressBar;
 import android.widget.TextView;
 
 import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Config;
 import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.cryptocoin.Bitcoin;
-import com.achep.acdisplay.cryptocoin.Coin;
+import com.achep.acdisplay.iab.cryptocoin.Bitcoin;
+import com.achep.acdisplay.iab.cryptocoin.Coin;
 import com.achep.acdisplay.iab.utils.IabHelper;
 import com.achep.acdisplay.iab.utils.IabResult;
 import com.achep.acdisplay.iab.utils.Inventory;
@@ -66,7 +67,6 @@ public class DonationFragment extends DialogFragment {
 
     private static final String TAG = "DonationFragment";
 
-    private static final Uri PAY_PAL_DONATION_URI = Uri.parse("http://goo.gl/UrecGo");
     public static final int RC_REQUEST = 10001;
 
     private GridView mGridView;
@@ -131,9 +131,9 @@ public class DonationFragment extends DialogFragment {
         // Alternative payment methods
         Coin bitcoin = new Bitcoin();
         final Intent bitcoinIntent = Coin.getPaymentIntent(bitcoin);
-        final Intent paypalIntent = new Intent(Intent.ACTION_VIEW, PAY_PAL_DONATION_URI);
+        final Intent paypalIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(Build.Links.DONATE));
 
-        if (Config.getInstance().isAlternativePaymentsEnabled()) {
+        if (getResources().getBoolean(R.bool.config_alternative_payments)) {
             if (IntentUtils.hasActivityForThat(activity, bitcoinIntent)) {
                 builder.setPositiveButton(bitcoin.getNameResource(), null);
             }
@@ -159,7 +159,7 @@ public class DonationFragment extends DialogFragment {
 
             @Override
             public void onShow(DialogInterface dialog) {
-                Data[] datas = new Data[] {
+                Data[] datas = new Data[]{
                         new Data(
                                 alertDialog.getButton(DialogInterface.BUTTON_NEUTRAL),
                                 paypalIntent, R.drawable.ic_action_paypal),
@@ -168,13 +168,17 @@ public class DonationFragment extends DialogFragment {
                                 paypalIntent, R.drawable.ic_action_bitcoin),
                 };
 
+                ImageSpan span;
+                SpannableString string;
                 for (final Data data : datas) {
                     final Button btn = data.button;
                     if (btn != null) {
-                        final Drawable icon = getResources().getDrawable(data.iconResource);
+                        span = new ImageSpan(getActivity(), data.iconResource);
 
-                        btn.setText(null);
-                        btn.setCompoundDrawablesRelativeWithIntrinsicBounds(icon, null, null, null);
+                        string = new SpannableString(" ");
+                        string.setSpan(span, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+
+                        btn.setText(string);
                         btn.setLayoutParams(new LinearLayout.LayoutParams(
                                 ViewGroup.LayoutParams.WRAP_CONTENT,
                                 ViewGroup.LayoutParams.WRAP_CONTENT));
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationItems.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationItems.java
index 4455ade2..8f459876 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationItems.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/DonationItems.java
@@ -31,7 +31,7 @@ import com.achep.acdisplay.R;
 public class DonationItems {
 
     public static Donation[] get(Resources res) {
-        int[] data = new int[] {
+        int[] data = new int[]{
                 1, R.string.donation_1,
                 4, R.string.donation_4,
                 10, R.string.donation_10,
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/cryptocoin/Bitcoin.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/cryptocoin/Bitcoin.java
similarity index 98%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/cryptocoin/Bitcoin.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/iab/cryptocoin/Bitcoin.java
index 8382c3df..3e8ce530 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/cryptocoin/Bitcoin.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/cryptocoin/Bitcoin.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.cryptocoin;
+package com.achep.acdisplay.iab.cryptocoin;
 
 import android.net.Uri;
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/cryptocoin/Coin.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/cryptocoin/Coin.java
similarity index 98%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/cryptocoin/Coin.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/iab/cryptocoin/Coin.java
index f6bbffaf..107c3357 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/cryptocoin/Coin.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/cryptocoin/Coin.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.cryptocoin;
+package com.achep.acdisplay.iab.cryptocoin;
 
 import android.content.Intent;
 import android.net.Uri;
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Base64.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Base64.java
index c815d545..6ee44b9c 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Base64.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Base64.java
@@ -34,84 +34,92 @@ package com.achep.acdisplay.iab.utils;
 /**
  * Base64 converter class. This code is not a complete MIME encoder;
  * it simply converts binary data to base64 data and back.
- *
+ * <p/>
  * <p>Note {@link CharBase64} is a GWT-compatible implementation of this
  * class.
  */
 public class Base64 {
-    /** Specify encoding (value is {@code true}). */
+    /**
+     * Specify encoding (value is {@code true}).
+     */
     public final static boolean ENCODE = true;
 
-    /** Specify decoding (value is {@code false}). */
+    /**
+     * Specify decoding (value is {@code false}).
+     */
     public final static boolean DECODE = false;
 
-    /** The equals sign (=) as a byte. */
+    /**
+     * The equals sign (=) as a byte.
+     */
     private final static byte EQUALS_SIGN = (byte) '=';
 
-    /** The new line character (\n) as a byte. */
+    /**
+     * The new line character (\n) as a byte.
+     */
     private final static byte NEW_LINE = (byte) '\n';
 
     /**
      * The 64 valid Base64 values.
      */
     private final static byte[] ALPHABET =
-        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
-        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
-        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
-        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
-        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
-        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
-        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
-        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
-        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
-        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
-        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
-        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
-        (byte) '9', (byte) '+', (byte) '/'};
+            {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+                    (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+                    (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+                    (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+                    (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+                    (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+                    (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+                    (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+                    (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+                    (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+                    (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+                    (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+                    (byte) '9', (byte) '+', (byte) '/'};
 
     /**
      * The 64 valid web safe Base64 values.
      */
     private final static byte[] WEBSAFE_ALPHABET =
-        {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
-        (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
-        (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
-        (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
-        (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
-        (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
-        (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
-        (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
-        (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
-        (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
-        (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
-        (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
-        (byte) '9', (byte) '-', (byte) '_'};
+            {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
+                    (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
+                    (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
+                    (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
+                    (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
+                    (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+                    (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
+                    (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
+                    (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
+                    (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
+                    (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
+                    (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+                    (byte) '9', (byte) '-', (byte) '_'};
 
     /**
      * Translates a Base64 value to either its 6-bit reconstruction value
      * or a negative number indicating some other meaning.
-     **/
+     */
     private final static byte[] DECODABET = {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
-        -5, -5, // Whitespace: Tab and Linefeed
-        -9, -9, // Decimal 11 - 12
-        -5, // Whitespace: Carriage Return
-        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
-        -9, -9, -9, -9, -9, // Decimal 27 - 31
-        -5, // Whitespace: Space
-        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
-        62, // Plus sign at decimal 43
-        -9, -9, -9, // Decimal 44 - 46
-        63, // Slash at decimal 47
-        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
-        -9, -9, -9, // Decimal 58 - 60
-        -1, // Equals sign at decimal 61
-        -9, -9, -9, // Decimal 62 - 64
-        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
-        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
-        -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
-        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
-        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
-        -9, -9, -9, -9, -9 // Decimal 123 - 127
+            -5, -5, // Whitespace: Tab and Linefeed
+            -9, -9, // Decimal 11 - 12
+            -5, // Whitespace: Carriage Return
+            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+            -9, -9, -9, -9, -9, // Decimal 27 - 31
+            -5, // Whitespace: Space
+            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
+            62, // Plus sign at decimal 43
+            -9, -9, -9, // Decimal 44 - 46
+            63, // Slash at decimal 47
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+            -9, -9, -9, // Decimal 58 - 60
+            -1, // Equals sign at decimal 61
+            -9, -9, -9, // Decimal 62 - 64
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
+            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+            -9, -9, -9, -9, -9 // Decimal 123 - 127
         /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
@@ -124,30 +132,32 @@ public class Base64 {
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
     };
 
-    /** The web safe decodabet */
+    /**
+     * The web safe decodabet
+     */
     private final static byte[] WEBSAFE_DECODABET =
-        {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
-        -5, -5, // Whitespace: Tab and Linefeed
-        -9, -9, // Decimal 11 - 12
-        -5, // Whitespace: Carriage Return
-        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
-        -9, -9, -9, -9, -9, // Decimal 27 - 31
-        -5, // Whitespace: Space
-        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
-        62, // Dash '-' sign at decimal 45
-        -9, -9, // Decimal 46-47
-        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
-        -9, -9, -9, // Decimal 58 - 60
-        -1, // Equals sign at decimal 61
-        -9, -9, -9, // Decimal 62 - 64
-        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
-        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
-        -9, -9, -9, -9, // Decimal 91-94
-        63, // Underscore '_' at decimal 95
-        -9, // Decimal 96
-        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
-        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
-        -9, -9, -9, -9, -9 // Decimal 123 - 127
+            {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
+                    -5, -5, // Whitespace: Tab and Linefeed
+                    -9, -9, // Decimal 11 - 12
+                    -5, // Whitespace: Carriage Return
+                    -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
+                    -9, -9, -9, -9, -9, // Decimal 27 - 31
+                    -5, // Whitespace: Space
+                    -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
+                    62, // Dash '-' sign at decimal 45
+                    -9, -9, // Decimal 46-47
+                    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+                    -9, -9, -9, // Decimal 58 - 60
+                    -1, // Equals sign at decimal 61
+                    -9, -9, -9, // Decimal 62 - 64
+                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
+                    14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
+                    -9, -9, -9, -9, // Decimal 91-94
+                    63, // Underscore '_' at decimal 95
+                    -9, // Decimal 96
+                    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
+                    39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
+                    -9, -9, -9, -9, -9 // Decimal 123 - 127
         /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
@@ -158,14 +168,16 @@ public class Base64 {
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-        };
+            };
 
     // Indicates white space in encoding
     private final static byte WHITE_SPACE_ENC = -5;
     // Indicates equals sign in encoding
     private final static byte EQUALS_SIGN_ENC = -1;
 
-    /** Defeats instantiation. */
+    /**
+     * Defeats instantiation.
+     */
     private Base64() {
     }
 
@@ -184,17 +196,17 @@ public class Base64 {
      * The actual number of significant bytes in your array is
      * given by <var>numSigBytes</var>.
      *
-     * @param source the array to convert
-     * @param srcOffset the index where conversion begins
+     * @param source      the array to convert
+     * @param srcOffset   the index where conversion begins
      * @param numSigBytes the number of significant bytes in your array
      * @param destination the array to hold the conversion
-     * @param destOffset the index where output will be put
-     * @param alphabet is the encoding alphabet
+     * @param destOffset  the index where output will be put
+     * @param alphabet    is the encoding alphabet
      * @return the <var>destination</var> array
      * @since 1.3
      */
     private static byte[] encode3to4(byte[] source, int srcOffset,
-            int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
+                                     int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
         //           1         2         3
         // 01234567890123456789012345678901 Bit position
         // --------000000001111111122222222 Array position from threeBytes
@@ -208,8 +220,8 @@ public class Base64 {
         // when Java treats a value as negative that is cast from a byte to an int.
         int inBuff =
                 (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
-                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
-                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
+                        | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
+                        | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
 
         switch (numSigBytes) {
             case 3:
@@ -250,9 +262,9 @@ public class Base64 {
     /**
      * Encodes a byte array into web safe Base64 notation.
      *
-     * @param source The data to convert
+     * @param source    The data to convert
      * @param doPadding is {@code true} to pad result with '=' chars
-     *        if it does not fall on 3 byte boundaries
+     *                  if it does not fall on 3 byte boundaries
      */
     public static String encodeWebSafe(byte[] source, boolean doPadding) {
         return encode(source, 0, source.length, WEBSAFE_ALPHABET, doPadding);
@@ -261,16 +273,16 @@ public class Base64 {
     /**
      * Encodes a byte array into Base64 notation.
      *
-     * @param source the data to convert
-     * @param off offset in array where conversion should begin
-     * @param len length of data to convert
-     * @param alphabet the encoding alphabet
+     * @param source    the data to convert
+     * @param off       offset in array where conversion should begin
+     * @param len       length of data to convert
+     * @param alphabet  the encoding alphabet
      * @param doPadding is {@code true} to pad result with '=' chars
-     * if it does not fall on 3 byte boundaries
+     *                  if it does not fall on 3 byte boundaries
      * @since 1.4
      */
     public static String encode(byte[] source, int off, int len, byte[] alphabet,
-            boolean doPadding) {
+                                boolean doPadding) {
         byte[] outBuff = encode(source, off, len, alphabet, Integer.MAX_VALUE);
         int outLen = outBuff.length;
 
@@ -289,19 +301,19 @@ public class Base64 {
     /**
      * Encodes a byte array into Base64 notation.
      *
-     * @param source the data to convert
-     * @param off offset in array where conversion should begin
-     * @param len length of data to convert
-     * @param alphabet is the encoding alphabet
+     * @param source        the data to convert
+     * @param off           offset in array where conversion should begin
+     * @param len           length of data to convert
+     * @param alphabet      is the encoding alphabet
      * @param maxLineLength maximum length of one line.
      * @return the BASE64-encoded byte array
      */
     public static byte[] encode(byte[] source, int off, int len, byte[] alphabet,
-            int maxLineLength) {
+                                int maxLineLength) {
         int lenDiv3 = (len + 2) / 3; // ceil(len / 3)
         int len43 = lenDiv3 * 4;
         byte[] outBuff = new byte[len43 // Main 4:3
-                                  + (len43 / maxLineLength)]; // New lines
+                + (len43 / maxLineLength)]; // New lines
 
         int d = 0;
         int e = 0;
@@ -314,8 +326,8 @@ public class Base64 {
             // but inlined for faster encoding (~20% improvement)
             int inBuff =
                     ((source[d + off] << 24) >>> 8)
-                    | ((source[d + 1 + off] << 24) >>> 16)
-                    | ((source[d + 2 + off] << 24) >>> 24);
+                            | ((source[d + 1 + off] << 24) >>> 16)
+                            | ((source[d + 2 + off] << 24) >>> 24);
             outBuff[e] = alphabet[(inBuff >>> 18)];
             outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];
             outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];
@@ -363,22 +375,21 @@ public class Base64 {
      * This method returns the actual number of bytes that
      * were converted from the Base64 encoding.
      *
-     *
-     * @param source the array to convert
-     * @param srcOffset the index where conversion begins
+     * @param source      the array to convert
+     * @param srcOffset   the index where conversion begins
      * @param destination the array to hold the conversion
-     * @param destOffset the index where output will be put
-     * @param decodabet the decodabet for decoding Base64 content
+     * @param destOffset  the index where output will be put
+     * @param decodabet   the decodabet for decoding Base64 content
      * @return the number of decoded bytes converted
      * @since 1.3
      */
     private static int decode4to3(byte[] source, int srcOffset,
-            byte[] destination, int destOffset, byte[] decodabet) {
+                                  byte[] destination, int destOffset, byte[] decodabet) {
         // Example: Dk==
         if (source[srcOffset + 2] == EQUALS_SIGN) {
             int outBuff =
                     ((decodabet[source[srcOffset]] << 24) >>> 6)
-                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);
+                            | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);
 
             destination[destOffset] = (byte) (outBuff >>> 16);
             return 1;
@@ -386,8 +397,8 @@ public class Base64 {
             // Example: DkL=
             int outBuff =
                     ((decodabet[source[srcOffset]] << 24) >>> 6)
-                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
-                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);
+                            | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                            | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);
 
             destination[destOffset] = (byte) (outBuff >>> 16);
             destination[destOffset + 1] = (byte) (outBuff >>> 8);
@@ -396,9 +407,9 @@ public class Base64 {
             // Example: DkLE
             int outBuff =
                     ((decodabet[source[srcOffset]] << 24) >>> 6)
-                    | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
-                    | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
-                    | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);
+                            | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
+                            | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
+                            | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);
 
             destination[destOffset] = (byte) (outBuff >> 16);
             destination[destOffset + 1] = (byte) (outBuff >> 8);
@@ -438,8 +449,8 @@ public class Base64 {
      *
      * @param source The Base64 encoded data
      * @return decoded data
-     * @since 1.3
      * @throws Base64DecoderException
+     * @since 1.3
      */
     public static byte[] decode(byte[] source) throws Base64DecoderException {
         return decode(source, 0, source.length);
@@ -466,8 +477,8 @@ public class Base64 {
      * @param off    the offset of where to begin decoding
      * @param len    the length of characters to decode
      * @return decoded data
-     * @since 1.3
      * @throws Base64DecoderException
+     * @since 1.3
      */
     public static byte[] decode(byte[] source, int off, int len)
             throws Base64DecoderException {
@@ -493,9 +504,9 @@ public class Base64 {
      * Decodes Base64 content using the supplied decodabet and returns
      * the decoded byte array.
      *
-     * @param source the Base64 encoded data
-     * @param off the offset of where to begin decoding
-     * @param len the length of characters to decode
+     * @param source    the Base64 encoded data
+     * @param off       the offset of where to begin decoding
+     * @param len       the length of characters to decode
      * @param decodabet the decodabet for decoding Base64 content
      * @return decoded data
      */
@@ -528,7 +539,8 @@ public class Base64 {
                                 || (b4Posn == 4 && bytesLeft > 1)) {
                             throw new Base64DecoderException(
                                     "padding byte '=' falsely signals end of encoded value "
-                                            + "at offset " + i);
+                                            + "at offset " + i
+                            );
                         } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {
                             throw new Base64DecoderException(
                                     "encoded value has invalid trailing byte");
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabException.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabException.java
index 42f73295..81969d85 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabException.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabException.java
@@ -27,17 +27,24 @@ public class IabException extends Exception {
     public IabException(IabResult r) {
         this(r, null);
     }
+
     public IabException(int response, String message) {
         this(new IabResult(response, message));
     }
+
     public IabException(IabResult r, Exception cause) {
         super(r.getMessage(), cause);
         mResult = r;
     }
+
     public IabException(int response, String message, Exception cause) {
         this(new IabResult(response, message), cause);
     }
 
-    /** Returns the IAB result (error) that this exception signals. */
-    public IabResult getResult() { return mResult; }
+    /**
+     * Returns the IAB result (error) that this exception signals.
+     */
+    public IabResult getResult() {
+        return mResult;
+    }
 }
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabHelper.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabHelper.java
index 4f016223..5283ffec 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabHelper.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabHelper.java
@@ -22,13 +22,13 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentSender.SendIntentException;
 import android.content.ServiceConnection;
+import android.content.pm.ResolveInfo;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.text.TextUtils;
 import android.util.Log;
-import android.content.pm.ResolveInfo;
 
 import com.android.vending.billing.IInAppBillingService;
 
@@ -44,22 +44,22 @@ import java.util.List;
  * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
  * many common in-app billing operations, as well as automatic signature
  * verification.
- *
+ * <p/>
  * After instantiating, you must perform setup in order to start using the object.
  * To perform setup, call the {@link #startSetup} method and provide a listener;
  * that listener will be notified when setup is complete, after which (and not before)
  * you may call other methods.
- *
+ * <p/>
  * After setup is complete, you will typically want to request an inventory of owned
  * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
  * and related methods.
- *
+ * <p/>
  * When you are done with this object, don't forget to call {@link #dispose}
  * to ensure proper cleanup. This object holds a binding to the in-app billing
  * service, which will leak unless you dispose of it correctly. If you created
  * the object on an Activity's onCreate method, then the recommended
  * place to dispose of it is the Activity's onDestroy method.
- *
+ * <p/>
  * A note about threading: When using this object from a background thread, you may
  * call the blocking versions of methods; when using from a UI thread, call
  * only the asynchronous versions and handle the results via callbacks.
@@ -68,7 +68,6 @@ import java.util.List;
  * has not yet completed will result in an exception being thrown.
  *
  * @author Bruno Oliveira (Google)
- *
  */
 public class IabHelper {
     // Is debug logging enabled?
@@ -157,11 +156,11 @@ public class IabHelper {
      * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
      * block and is safe to call from a UI thread.
      *
-     * @param ctx Your application or Activity context. Needed to bind to the in-app billing service.
+     * @param ctx             Your application or Activity context. Needed to bind to the in-app billing service.
      * @param base64PublicKey Your application's public key, encoded in base64.
-     *     This is used for verification of purchase signatures. You can find your app's base64-encoded
-     *     public key in your application's page on Google Play Developer Console. Note that this
-     *     is NOT your "developer public key".
+     *                        This is used for verification of purchase signatures. You can find your app's base64-encoded
+     *                        public key in your application's page on Google Play Developer Console. Note that this
+     *                        is NOT your "developer public key".
      */
     public IabHelper(Context ctx, String base64PublicKey) {
         mContext = ctx.getApplicationContext();
@@ -243,17 +242,15 @@ public class IabHelper {
                     if (response == BILLING_RESPONSE_RESULT_OK) {
                         logDebug("Subscriptions AVAILABLE.");
                         mSubscriptionsSupported = true;
-                    }
-                    else {
+                    } else {
                         logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
                     }
 
                     mSetupDone = true;
-                }
-                catch (RemoteException e) {
+                } catch (RemoteException e) {
                     if (listener != null) {
                         listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
-                                                    "RemoteException while setting up in-app billing."));
+                                "RemoteException while setting up in-app billing."));
                     }
                     e.printStackTrace();
                     return;
@@ -271,13 +268,13 @@ public class IabHelper {
         if (ri != null && !ri.isEmpty()) {
             // service available to handle that Intent
             mIsBound = mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
-        }
-        else {
+        } else {
             // no service available to handle that Intent
             if (listener != null) {
                 listener.onIabSetupFinished(
                         new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
-                        "Billing service unavailable on device."));
+                                "Billing service unavailable on device.")
+                );
             }
         }
     }
@@ -305,10 +302,13 @@ public class IabHelper {
     }
 
     private void checkNotDisposed() {
-        if (mDisposed) throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
+        if (mDisposed)
+            throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
     }
 
-    /** Returns whether subscriptions are supported. */
+    /**
+     * Returns whether subscriptions are supported.
+     */
     public boolean subscriptionsSupported() {
         checkNotDisposed();
         return mSubscriptionsSupported;
@@ -326,7 +326,7 @@ public class IabHelper {
          * process went.
          *
          * @param result The result of the purchase.
-         * @param info The purchase information (null if purchase failed)
+         * @param info   The purchase information (null if purchase failed)
          */
         public void onIabPurchaseFinished(IabResult result, Purchase info);
     }
@@ -340,17 +340,17 @@ public class IabHelper {
     }
 
     public void launchPurchaseFlow(Activity act, String sku, int requestCode,
-            OnIabPurchaseFinishedListener listener, String extraData) {
+                                   OnIabPurchaseFinishedListener listener, String extraData) {
         launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
     }
 
     public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
-            OnIabPurchaseFinishedListener listener) {
+                                               OnIabPurchaseFinishedListener listener) {
         launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
     }
 
     public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
-            OnIabPurchaseFinishedListener listener, String extraData) {
+                                               OnIabPurchaseFinishedListener listener, String extraData) {
         launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
     }
 
@@ -362,18 +362,18 @@ public class IabHelper {
      * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
      * MUST be called from the UI thread of the Activity.
      *
-     * @param act The calling activity.
-     * @param sku The sku of the item to purchase.
-     * @param itemType indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
+     * @param act         The calling activity.
+     * @param sku         The sku of the item to purchase.
+     * @param itemType    indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
      * @param requestCode A request code (to differentiate from other responses --
-     *     as in {@link android.app.Activity#startActivityForResult}).
-     * @param listener The listener to notify when the purchase process finishes
-     * @param extraData Extra data (developer payload), which will be returned with the purchase data
-     *     when the purchase completes. This extra data will be permanently bound to that purchase
-     *     and will always be returned when the purchase is queried.
+     *                    as in {@link android.app.Activity#startActivityForResult}).
+     * @param listener    The listener to notify when the purchase process finishes
+     * @param extraData   Extra data (developer payload), which will be returned with the purchase data
+     *                    when the purchase completes. This extra data will be permanently bound to that purchase
+     *                    and will always be returned when the purchase is queried.
      */
     public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
-                        OnIabPurchaseFinishedListener listener, String extraData) {
+                                   OnIabPurchaseFinishedListener listener, String extraData) {
         checkNotDisposed();
         checkSetupDone("launchPurchaseFlow");
         flagStartAsync("launchPurchaseFlow");
@@ -405,19 +405,17 @@ public class IabHelper {
             mPurchaseListener = listener;
             mPurchasingItemType = itemType;
             act.startIntentSenderForResult(pendingIntent.getIntentSender(),
-                                           requestCode, new Intent(),
+                    requestCode, new Intent(),
                     0, 0,
                     0);
-        }
-        catch (SendIntentException e) {
+        } catch (SendIntentException e) {
             logError("SendIntentException while launching purchase flow for sku " + sku);
             e.printStackTrace();
             flagEndAsync();
 
             result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
             if (listener != null) listener.onIabPurchaseFinished(result, null);
-        }
-        catch (RemoteException e) {
+        } catch (RemoteException e) {
             logError("RemoteException while launching purchase flow for sku " + sku);
             e.printStackTrace();
             flagEndAsync();
@@ -434,11 +432,11 @@ public class IabHelper {
      * MUST be called from the UI thread of the Activity.
      *
      * @param requestCode The requestCode as you received it.
-     * @param resultCode The resultCode as you received it.
-     * @param data The data (Intent) as you received it.
+     * @param resultCode  The resultCode as you received it.
+     * @param data        The data (Intent) as you received it.
      * @return Returns true if the result was related to a purchase flow and was handled;
-     *     false if the result was not related to a purchase, in which case you should
-     *     handle it normally.
+     * false if the result was not related to a purchase, in which case you should
+     * handle it normally.
      */
     public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
         IabResult result;
@@ -472,7 +470,8 @@ public class IabHelper {
                 logError("BUG: either purchaseData or dataSignature is null.");
                 logDebug("Extras: " + data.getExtras().toString());
                 result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
-                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                if (mPurchaseListener != null)
+                    mPurchaseListener.onIabPurchaseFinished(result, null);
                 return true;
             }
 
@@ -485,37 +484,35 @@ public class IabHelper {
                 if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
                     logError("Purchase signature verification FAILED for sku " + sku);
                     result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
-                    if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, purchase);
+                    if (mPurchaseListener != null)
+                        mPurchaseListener.onIabPurchaseFinished(result, purchase);
                     return true;
                 }
                 logDebug("Purchase signature successfully verified.");
-            }
-            catch (JSONException e) {
+            } catch (JSONException e) {
                 logError("Failed to parse purchase data.");
                 e.printStackTrace();
                 result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
-                if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
+                if (mPurchaseListener != null)
+                    mPurchaseListener.onIabPurchaseFinished(result, null);
                 return true;
             }
 
             if (mPurchaseListener != null) {
                 mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
             }
-        }
-        else if (resultCode == Activity.RESULT_OK) {
+        } else if (resultCode == Activity.RESULT_OK) {
             // result code was OK, but in-app billing response was not OK.
             logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
             if (mPurchaseListener != null) {
                 result = new IabResult(responseCode, "Problem purchashing item.");
                 mPurchaseListener.onIabPurchaseFinished(result, null);
             }
-        }
-        else if (resultCode == Activity.RESULT_CANCELED) {
+        } else if (resultCode == Activity.RESULT_CANCELED) {
             logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
             result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
             if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
-        }
-        else {
+        } else {
             logError("Purchase failed. Result code: " + Integer.toString(resultCode)
                     + ". Response: " + getResponseDesc(responseCode));
             result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
@@ -534,15 +531,15 @@ public class IabHelper {
      * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
      *
      * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
-     *     as purchase information.
-     * @param moreItemSkus additional PRODUCT skus to query information on, regardless of ownership.
-     *     Ignored if null or if querySkuDetails is false.
-     * @param moreSubsSkus additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
-     *     Ignored if null or if querySkuDetails is false.
+     *                        as purchase information.
+     * @param moreItemSkus    additional PRODUCT skus to query information on, regardless of ownership.
+     *                        Ignored if null or if querySkuDetails is false.
+     * @param moreSubsSkus    additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
+     *                        Ignored if null or if querySkuDetails is false.
      * @throws IabException if a problem occurs while refreshing the inventory.
      */
     public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
-                                        List<String> moreSubsSkus) throws IabException {
+                                    List<String> moreSubsSkus) throws IabException {
         checkNotDisposed();
         checkSetupDone("queryInventory");
         try {
@@ -575,11 +572,9 @@ public class IabHelper {
             }
 
             return inv;
-        }
-        catch (RemoteException e) {
+        } catch (RemoteException e) {
             throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
-        }
-        catch (JSONException e) {
+        } catch (JSONException e) {
             throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
         }
     }
@@ -592,7 +587,7 @@ public class IabHelper {
          * Called to notify that an inventory query operation completed.
          *
          * @param result The result of the operation.
-         * @param inv The inventory.
+         * @param inv    The inventory.
          */
         public void onQueryInventoryFinished(IabResult result, Inventory inv);
     }
@@ -605,12 +600,12 @@ public class IabHelper {
      * call from a UI thread.
      *
      * @param querySkuDetails as in {@link #queryInventory}
-     * @param moreSkus as in {@link #queryInventory}
-     * @param listener The listener to notify when the refresh operation completes.
+     * @param moreSkus        as in {@link #queryInventory}
+     * @param listener        The listener to notify when the refresh operation completes.
      */
     public void queryInventoryAsync(final boolean querySkuDetails,
-                               final List<String> moreSkus,
-                               final QueryInventoryFinishedListener listener) {
+                                    final List<String> moreSkus,
+                                    final QueryInventoryFinishedListener listener) {
         final Handler handler = new Handler();
         checkNotDisposed();
         checkSetupDone("queryInventory");
@@ -621,8 +616,7 @@ public class IabHelper {
                 Inventory inv = null;
                 try {
                     inv = queryInventory(querySkuDetails, moreSkus);
-                }
-                catch (IabException ex) {
+                } catch (IabException ex) {
                     result = ex.getResult();
                 }
 
@@ -672,22 +666,20 @@ public class IabHelper {
             String token = itemInfo.getToken();
             String sku = itemInfo.getSku();
             if (token == null || token.equals("")) {
-               logError("Can't consume "+ sku + ". No token.");
-               throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
-                   + sku + " " + itemInfo);
+                logError("Can't consume " + sku + ". No token.");
+                throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
+                        + sku + " " + itemInfo);
             }
 
             logDebug("Consuming sku: " + sku + ", token: " + token);
             int response = mService.consumePurchase(3, mContext.getPackageName(), token);
             if (response == BILLING_RESPONSE_RESULT_OK) {
-               logDebug("Successfully consumed sku: " + sku);
+                logDebug("Successfully consumed sku: " + sku);
+            } else {
+                logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
+                throw new IabException(response, "Error consuming sku " + sku);
             }
-            else {
-               logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
-               throw new IabException(response, "Error consuming sku " + sku);
-            }
-        }
-        catch (RemoteException e) {
+        } catch (RemoteException e) {
             throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
         }
     }
@@ -700,7 +692,7 @@ public class IabHelper {
          * Called to notify that a consumption has finished.
          *
          * @param purchase The purchase that was (or was to be) consumed.
-         * @param result The result of the consumption operation.
+         * @param result   The result of the consumption operation.
          */
         public void onConsumeFinished(Purchase purchase, IabResult result);
     }
@@ -713,8 +705,8 @@ public class IabHelper {
          * Called to notify that a consumption of multiple items has finished.
          *
          * @param purchases The purchases that were (or were to be) consumed.
-         * @param results The results of each consumption operation, corresponding to each
-         *     sku.
+         * @param results   The results of each consumption operation, corresponding to each
+         *                  sku.
          */
         public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
     }
@@ -737,8 +729,9 @@ public class IabHelper {
 
     /**
      * Same as {@link consumeAsync}, but for multiple items at once.
+     *
      * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
-     * @param listener The listener to notify when the consumption operation finishes.
+     * @param listener  The listener to notify when the consumption operation finishes.
      */
     public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
         checkNotDisposed();
@@ -751,7 +744,7 @@ public class IabHelper {
      *
      * @param code The response code
      * @return A human-readable string explaining the result code.
-     *     It also includes the result code numerically.
+     * It also includes the result code numerically.
      */
     public static String getResponseDesc(int code) {
         String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
@@ -759,22 +752,21 @@ public class IabHelper {
                 "5:Developer Error/6:Error/7:Item Already Owned/" +
                 "8:Item not owned").split("/");
         String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
-                                   "-1002:Bad response received/" +
-                                   "-1003:Purchase signature verification failed/" +
-                                   "-1004:Send intent failed/" +
-                                   "-1005:User cancelled/" +
-                                   "-1006:Unknown purchase response/" +
-                                   "-1007:Missing token/" +
-                                   "-1008:Unknown error/" +
-                                   "-1009:Subscriptions not available/" +
-                                   "-1010:Invalid consumption attempt").split("/");
+                "-1002:Bad response received/" +
+                "-1003:Purchase signature verification failed/" +
+                "-1004:Send intent failed/" +
+                "-1005:User cancelled/" +
+                "-1006:Unknown purchase response/" +
+                "-1007:Missing token/" +
+                "-1008:Unknown error/" +
+                "-1009:Subscriptions not available/" +
+                "-1010:Invalid consumption attempt").split("/");
 
         if (code <= IABHELPER_ERROR_BASE) {
             int index = IABHELPER_ERROR_BASE - code;
             if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
             else return String.valueOf(code) + ":Unknown IAB Helper Error";
-        }
-        else if (code < 0 || code >= iab_msgs.length)
+        } else if (code < 0 || code >= iab_msgs.length)
             return String.valueOf(code) + ":Unknown";
         else
             return iab_msgs[code];
@@ -795,9 +787,8 @@ public class IabHelper {
         if (o == null) {
             logDebug("Bundle with null response code, assuming OK (known issue)");
             return BILLING_RESPONSE_RESULT_OK;
-        }
-        else if (o instanceof Integer) return (Integer) o;
-        else if (o instanceof Long) return (int)((Long)o).longValue();
+        } else if (o instanceof Integer) return (Integer) o;
+        else if (o instanceof Long) return (int) ((Long) o).longValue();
         else {
             logError("Unexpected type for bundle response code.");
             logError(o.getClass().getName());
@@ -811,9 +802,8 @@ public class IabHelper {
         if (o == null) {
             logError("Intent with no response code, assuming OK (known issue)");
             return BILLING_RESPONSE_RESULT_OK;
-        }
-        else if (o instanceof Integer) return (Integer) o;
-        else if (o instanceof Long) return (int)((Long)o).longValue();
+        } else if (o instanceof Integer) return (Integer) o;
+        else if (o instanceof Long) return (int) ((Long) o).longValue();
         else {
             logError("Unexpected type for intent response code.");
             logError(o.getClass().getName());
@@ -862,11 +852,11 @@ public class IabHelper {
             }
 
             ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
-                        RESPONSE_INAPP_ITEM_LIST);
+                    RESPONSE_INAPP_ITEM_LIST);
             ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
-                        RESPONSE_INAPP_PURCHASE_DATA_LIST);
+                    RESPONSE_INAPP_PURCHASE_DATA_LIST);
             ArrayList<String> signatureList = ownedItems.getStringArrayList(
-                        RESPONSE_INAPP_SIGNATURE_LIST);
+                    RESPONSE_INAPP_SIGNATURE_LIST);
 
             for (int i = 0; i < purchaseDataList.size(); ++i) {
                 String purchaseData = purchaseDataList.get(i);
@@ -883,8 +873,7 @@ public class IabHelper {
 
                     // Record ownership and token
                     inv.addPurchase(purchase);
-                }
-                else {
+                } else {
                     logWarn("Purchase signature verification **FAILED**. Not adding item.");
                     logDebug("   Purchase data: " + purchaseData);
                     logDebug("   Signature: " + signature);
@@ -900,7 +889,7 @@ public class IabHelper {
     }
 
     int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
-                                throws RemoteException, JSONException {
+            throws RemoteException, JSONException {
         logDebug("Querying SKU details.");
         ArrayList<String> skuList = new ArrayList<>();
         skuList.addAll(inv.getAllOwnedSkus(itemType));
@@ -927,8 +916,7 @@ public class IabHelper {
             if (response != BILLING_RESPONSE_RESULT_OK) {
                 logDebug("getSkuDetails() failed: " + getResponseDesc(response));
                 return response;
-            }
-            else {
+            } else {
                 logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
                 return IABHELPER_BAD_RESPONSE;
             }
@@ -958,8 +946,7 @@ public class IabHelper {
                     try {
                         consume(purchase);
                         results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
-                    }
-                    catch (IabException ex) {
+                    } catch (IabException ex) {
                         results.add(ex.getResult());
                     }
                 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabResult.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabResult.java
index f646f4b6..f5ef0128 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabResult.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/IabResult.java
@@ -31,15 +31,29 @@ public class IabResult {
         mResponse = response;
         if (message == null || message.trim().length() == 0) {
             mMessage = IabHelper.getResponseDesc(response);
-        }
-        else {
+        } else {
             mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
         }
     }
-    public int getResponse() { return mResponse; }
-    public String getMessage() { return mMessage; }
-    public boolean isSuccess() { return mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK; }
-    public boolean isFailure() { return !isSuccess(); }
-    public String toString() { return "IabResult: " + getMessage(); }
+
+    public int getResponse() {
+        return mResponse;
+    }
+
+    public String getMessage() {
+        return mMessage;
+    }
+
+    public boolean isSuccess() {
+        return mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK;
+    }
+
+    public boolean isFailure() {
+        return !isSuccess();
+    }
+
+    public String toString() {
+        return "IabResult: " + getMessage();
+    }
 }
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Inventory.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Inventory.java
index 54d7915e..d0e915d7 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Inventory.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Inventory.java
@@ -25,27 +25,36 @@ import java.util.Map;
  * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
  */
 public class Inventory {
-    Map<String,SkuDetails> mSkuMap = new HashMap<>();
-    Map<String,Purchase> mPurchaseMap = new HashMap<>();
+    Map<String, SkuDetails> mSkuMap = new HashMap<>();
+    Map<String, Purchase> mPurchaseMap = new HashMap<>();
 
-    Inventory() { }
+    Inventory() {
+    }
 
-    /** Returns the listing details for an in-app product. */
+    /**
+     * Returns the listing details for an in-app product.
+     */
     public SkuDetails getSkuDetails(String sku) {
         return mSkuMap.get(sku);
     }
 
-    /** Returns purchase information for a given product, or null if there is no purchase. */
+    /**
+     * Returns purchase information for a given product, or null if there is no purchase.
+     */
     public Purchase getPurchase(String sku) {
         return mPurchaseMap.get(sku);
     }
 
-    /** Returns whether or not there exists a purchase of the given product. */
+    /**
+     * Returns whether or not there exists a purchase of the given product.
+     */
     public boolean hasPurchase(String sku) {
         return mPurchaseMap.containsKey(sku);
     }
 
-    /** Return whether or not details about the given product are available. */
+    /**
+     * Return whether or not details about the given product are available.
+     */
     public boolean hasDetails(String sku) {
         return mSkuMap.containsKey(sku);
     }
@@ -62,12 +71,16 @@ public class Inventory {
         if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
     }
 
-    /** Returns a list of all owned product IDs. */
+    /**
+     * Returns a list of all owned product IDs.
+     */
     List<String> getAllOwnedSkus() {
         return new ArrayList<>(mPurchaseMap.keySet());
     }
 
-    /** Returns a list of all owned product IDs of a given type */
+    /**
+     * Returns a list of all owned product IDs of a given type
+     */
     List<String> getAllOwnedSkus(String itemType) {
         List<String> result = new ArrayList<>();
         for (Purchase p : mPurchaseMap.values()) {
@@ -76,7 +89,9 @@ public class Inventory {
         return result;
     }
 
-    /** Returns a list of all purchases. */
+    /**
+     * Returns a list of all purchases.
+     */
     List<Purchase> getAllPurchases() {
         return new ArrayList<>(mPurchaseMap.values());
     }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Purchase.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Purchase.java
index 8c85989e..6192db3c 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Purchase.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Purchase.java
@@ -47,17 +47,48 @@ public class Purchase {
         mSignature = signature;
     }
 
-    public String getItemType() { return mItemType; }
-    public String getOrderId() { return mOrderId; }
-    public String getPackageName() { return mPackageName; }
-    public String getSku() { return mSku; }
-    public long getPurchaseTime() { return mPurchaseTime; }
-    public int getPurchaseState() { return mPurchaseState; }
-    public String getDeveloperPayload() { return mDeveloperPayload; }
-    public String getToken() { return mToken; }
-    public String getOriginalJson() { return mOriginalJson; }
-    public String getSignature() { return mSignature; }
+    public String getItemType() {
+        return mItemType;
+    }
+
+    public String getOrderId() {
+        return mOrderId;
+    }
+
+    public String getPackageName() {
+        return mPackageName;
+    }
+
+    public String getSku() {
+        return mSku;
+    }
+
+    public long getPurchaseTime() {
+        return mPurchaseTime;
+    }
+
+    public int getPurchaseState() {
+        return mPurchaseState;
+    }
+
+    public String getDeveloperPayload() {
+        return mDeveloperPayload;
+    }
+
+    public String getToken() {
+        return mToken;
+    }
+
+    public String getOriginalJson() {
+        return mOriginalJson;
+    }
+
+    public String getSignature() {
+        return mSignature;
+    }
 
     @Override
-    public String toString() { return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson; }
+    public String toString() {
+        return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson;
+    }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Security.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Security.java
index 5f7d31c1..a6fe1346 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Security.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/Security.java
@@ -47,9 +47,10 @@ public class Security {
      * the verified purchase. The data is in JSON format and signed
      * with a private key. The data also contains the {@link PurchaseState}
      * and product ID of the purchase.
+     *
      * @param base64PublicKey the base64-encoded public key to use for verifying.
-     * @param signedData the signed JSON string (signed, not encrypted)
-     * @param signature the signature for the data, signed with the private key
+     * @param signedData      the signed JSON string (signed, not encrypted)
+     * @param signature       the signature for the data, signed with the private key
      */
     public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
         if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
@@ -89,9 +90,9 @@ public class Security {
      * Verifies that the signature from the server matches the computed
      * signature on the data.  Returns true if the data is correctly signed.
      *
-     * @param publicKey public key associated with the developer account
+     * @param publicKey  public key associated with the developer account
      * @param signedData signed data from server
-     * @param signature server signature
+     * @param signature  server signature
      * @return true if the data and signature match
      */
     public static boolean verify(PublicKey publicKey, String signedData, String signature) {
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/SkuDetails.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/SkuDetails.java
index 48c35461..0286af4a 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/SkuDetails.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/iab/utils/SkuDetails.java
@@ -45,11 +45,25 @@ public class SkuDetails {
         mDescription = o.optString("description");
     }
 
-    public String getSku() { return mSku; }
-    public String getType() { return mType; }
-    public String getPrice() { return mPrice; }
-    public String getTitle() { return mTitle; }
-    public String getDescription() { return mDescription; }
+    public String getSku() {
+        return mSku;
+    }
+
+    public String getType() {
+        return mType;
+    }
+
+    public String getPrice() {
+        return mPrice;
+    }
+
+    public String getTitle() {
+        return mTitle;
+    }
+
+    public String getDescription() {
+        return mDescription;
+    }
 
     @Override
     public String toString() {
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationData.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationData.java
index 8993e00d..c4ee5b26 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationData.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationData.java
@@ -122,11 +122,11 @@ public class NotificationData {
         public void onNotificationDataChanged(NotificationData data, int changeId);
     }
 
-    public void addOnNotificationDataChangedListener(OnNotificationDataChangedListener listener) {
+    public void registerListener(OnNotificationDataChangedListener listener) {
         mListeners.add(listener);
     }
 
-    public void removeOnNotificationDataChangedListener(OnNotificationDataChangedListener listener) {
+    public void unregisterListener(OnNotificationDataChangedListener listener) {
         mListeners.remove(listener);
     }
 
@@ -146,11 +146,11 @@ public class NotificationData {
     private BackgroundFactoryThread mBackgroundLoader;
     private BackgroundFactoryThread.Callback mBackgroundLoaderCallback =
             new BackgroundFactoryThread.Callback() {
-        @Override
-        public void onBackgroundCreated(Bitmap bitmap) {
-            setBackground(bitmap);
-        }
-    };
+                @Override
+                public void onBackgroundCreated(Bitmap bitmap) {
+                    setBackground(bitmap);
+                }
+            };
 
     public void markAsRead(boolean value) {
         if (isRead == (isRead = value)) return;
@@ -158,12 +158,12 @@ public class NotificationData {
     }
 
     private void setIcon(Bitmap bitmap) {
-        icon = bitmap;
+        if (icon == (icon = bitmap)) return;
         notifyListeners(ICON);
     }
 
     public void setBackground(Bitmap bitmap) {
-        background = bitmap;
+        if (background == (background = bitmap)) return;
         notifyListeners(BACKGROUND);
     }
 
@@ -270,6 +270,8 @@ public class NotificationData {
         private final WeakReference<StatusBarNotification> mStatusBarNotification;
         private final WeakReference<Context> mContext;
 
+        private volatile long time;
+
         private IconLoaderThread(Context context, StatusBarNotification sbn, NotificationData data) {
             mNotificationData = new WeakReference<>(data);
             mStatusBarNotification = new WeakReference<>(sbn);
@@ -277,9 +279,13 @@ public class NotificationData {
         }
 
         @Override
-        protected Bitmap doInBackground(Void... params) {
-            final long start = SystemClock.elapsedRealtime();
+        protected void onPreExecute() {
+            super.onPreExecute();
+            time = SystemClock.elapsedRealtime();
+        }
 
+        @Override
+        protected Bitmap doInBackground(Void... params) {
             StatusBarNotification sbn = mStatusBarNotification.get();
             Context context = mContext.get();
 
@@ -292,10 +298,7 @@ public class NotificationData {
 
             if (drawable == null) {
                 Log.w(TAG, "No notification icon found.");
-                Bitmap icon = Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_4444);
-                Canvas canvas = new Canvas(icon);
-                canvas.drawColor(0x60000000);
-                return icon;
+                return createEmptyIcon();
             }
 
             Resources res = context.getResources();
@@ -306,19 +309,25 @@ public class NotificationData {
             Canvas canvas = new Canvas(icon);
             drawable.draw(canvas);
 
-            if (Build.DEBUG) {
-                long delta = SystemClock.elapsedRealtime() - start;
-                Log.d(TAG, "Notification icon loaded in " + delta + " millis:"
-                        + " width=" + icon.getWidth()
-                        + " height=" + icon.getHeight());
-            }
+            return icon;
+        }
 
+        private Bitmap createEmptyIcon() {
+            Bitmap icon = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_4444);
+            Canvas canvas = new Canvas(icon);
+            canvas.drawColor(0x60FF0000);
             return icon;
         }
 
         @Override
         protected void onPostExecute(Bitmap bitmap) {
             super.onPostExecute(bitmap);
+            if (Build.DEBUG) {
+                long delta = SystemClock.elapsedRealtime() - time;
+                Log.d(TAG, "Notification icon loaded in " + delta + " millis:"
+                        + " bitmap=" + bitmap);
+            }
+
             NotificationData data = mNotificationData.get();
             if (bitmap == null || data == null) {
                 return;
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationHandleService.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationHandleService.java
deleted file mode 100644
index 4226d5df..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationHandleService.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.notifications;
-
-import android.app.ActivityManager;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Looper;
-import android.service.notification.NotificationListenerService;
-import android.service.notification.StatusBarNotification;
-import android.util.Log;
-
-/**
- * Created by Artem on 27.12.13.
- */
-public class NotificationHandleService extends NotificationListenerService {
-
-    private static final String TAG = "NotificationHandleService";
-
-    public static NotificationHandleService sService;
-    public static boolean isNotificationAccessEnabled;
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        isNotificationAccessEnabled = true;
-        sService = this;
-
-        // What is the idea of init notification?
-        // Well the main goal is to access #getActiveNotifications()
-        // what seems to be not possible without dirty and buggy
-        // workarounds.
-        NotificationPresenter
-                .getInstance()
-                .tryStartInitProcess();
-
-        return super.onBind(intent);
-    }
-
-    @Override
-    public boolean onUnbind(Intent intent) {
-        boolean unbind = super.onUnbind(intent);
-        isNotificationAccessEnabled = false;
-        sService = null;
-
-        return unbind;
-    }
-
-    public static boolean isServiceRunning(Context context) {
-        ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
-        for (ActivityManager.RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) {
-            if (NotificationHandleService.class.getName().equals(service.service.getClassName())) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Override
-    public void onNotificationPosted(final StatusBarNotification statusBarNotification) {
-        perform(statusBarNotification, true);
-    }
-
-    @Override
-    public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
-        perform(statusBarNotification, false);
-    }
-
-    private void perform(final StatusBarNotification statusBarNotification,
-                         final boolean post) {
-        final StatusBarNotification[] activeNotifications = getActiveNotifications();
-        new Handler(Looper.getMainLooper()).post(new Runnable() {
-
-            @Override
-            public void run() {
-                NotificationPresenter np = NotificationPresenter.getInstance();
-
-                try {
-                    if (!np.isInitialized()) {
-                        np.tryInit(sService, statusBarNotification, activeNotifications);
-
-                    }
-                    if (post) {
-                        np.postNotification(sService, statusBarNotification);
-                    } else {
-                        np.removeNotification(sService, statusBarNotification);
-                    }
-                } catch (Exception e) { // don't die
-                    Log.wtf(TAG, "The world of pink unicorns just crashed:");
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationHelper.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationHelper.java
index d0ef2ee4..0d89557f 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationHelper.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationHelper.java
@@ -24,6 +24,7 @@ import android.service.notification.StatusBarNotification;
 import android.util.Log;
 
 import com.achep.acdisplay.Operator;
+import com.achep.acdisplay.services.MediaService;
 import com.achep.acdisplay.utils.PendingIntentUtils;
 
 /**
@@ -48,7 +49,7 @@ public class NotificationHelper {
     }
 
     public static void dismissNotification(StatusBarNotification notification) {
-        NotificationHandleService service = NotificationHandleService.sService;
+        MediaService service = MediaService.sService;
         if (service != null) {
             service.cancelNotification(
                     notification.getPackageName(),
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationList.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
index 4f278ab2..2bb108de 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
@@ -28,15 +28,15 @@ import java.util.ArrayList;
  */
 final class NotificationList {
 
-    private ArrayList<OpenStatusBarNotification> mList;
+    private ArrayList<OpenNotification> mList;
     private Callback mCallback;
 
     public interface Callback {
-        public int onNotificationAdded(OpenStatusBarNotification n);
+        public int onNotificationAdded(OpenNotification n);
 
-        public int onNotificationChanged(OpenStatusBarNotification n);
+        public int onNotificationChanged(OpenNotification n, OpenNotification old);
 
-        public int onNotificationRemoved(OpenStatusBarNotification n);
+        public int onNotificationRemoved(OpenNotification n);
     }
 
     public NotificationList(Callback callback) {
@@ -44,7 +44,7 @@ final class NotificationList {
         mList = new ArrayList<>(10);
     }
 
-    public int pushOrRemove(OpenStatusBarNotification n, boolean push, boolean silently) {
+    public int pushOrRemove(OpenNotification n, boolean push, boolean silently) {
         Callback cb = mCallback;
         if (silently) mCallback = null;
         final int callback = push ? push(n) : remove(n);
@@ -55,23 +55,24 @@ final class NotificationList {
     /**
      * Replace or add notification to the list.
      *
-     * @return {@link com.achep.acdisplay.notifications.NotificationList.Callback#onNotificationAdded(com.achep.acdisplay.notifications.OpenStatusBarNotification n)} or
-     * {@link com.achep.acdisplay.notifications.NotificationList.Callback#onNotificationChanged(com.achep.acdisplay.notifications.OpenStatusBarNotification n)}
+     * @return {@link com.achep.acdisplay.notifications.NotificationList.Callback#onNotificationAdded(OpenNotification n)} or
+     * {@link com.achep.acdisplay.notifications.NotificationList.Callback#onNotificationChanged(OpenNotification n)}
      */
-    public int push(OpenStatusBarNotification n) {
+    public int push(OpenNotification n) {
         int index = indexOf(n);
         if (index < 0) {
             mList.add(n);
             if (mCallback != null) return mCallback.onNotificationAdded(n);
         } else {
+            OpenNotification old = mList.get(index);
             mList.remove(index);
             mList.add(index, n);
-            if (mCallback != null) return mCallback.onNotificationChanged(n);
+            if (mCallback != null) return mCallback.onNotificationChanged(n, old);
         }
         return 0;
     }
 
-    public int remove(OpenStatusBarNotification n) {
+    public int remove(OpenNotification n) {
         int index = indexOf(n);
         if (index >= 0) {
             mList.get(index).getNotificationData().stopLoading();
@@ -81,14 +82,14 @@ final class NotificationList {
         return 0;
     }
 
-    public ArrayList<OpenStatusBarNotification> list() {
+    public ArrayList<OpenNotification> list() {
         return mList;
     }
 
-    public int indexOf(OpenStatusBarNotification n) {
+    public int indexOf(OpenNotification n) {
         int size = mList.size();
         for (int i = 0; i < size; i++) {
-            OpenStatusBarNotification o = mList.get(i);
+            OpenNotification o = mList.get(i);
             if (o == null || o.getStatusBarNotification() == null) {
                 throw new RuntimeException("Null-notification found! Notification list is probably corrupted. ");
             } else if (NotificationUtils.equals(n, o)) {
@@ -97,4 +98,4 @@ final class NotificationList {
         }
         return -1;
     }
-}
+}
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
index d6ac8d02..755ca6d2 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
@@ -25,18 +25,20 @@ import android.content.Context;
 import android.content.res.Resources;
 import android.os.Handler;
 import android.service.notification.StatusBarNotification;
+import android.text.TextUtils;
 import android.util.Log;
 
 import com.achep.acdisplay.App;
 import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.InactiveHoursHelper;
+import com.achep.acdisplay.InactiveTimeHelper;
 import com.achep.acdisplay.Operator;
 import com.achep.acdisplay.Presenter;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.activemode.sensors.ProximitySensor;
 import com.achep.acdisplay.blacklist.AppConfig;
 import com.achep.acdisplay.blacklist.Blacklist;
+import com.achep.acdisplay.services.MediaService;
+import com.achep.acdisplay.services.activemode.sensors.ProximitySensor;
 import com.achep.acdisplay.utils.PackageUtils;
 import com.achep.acdisplay.utils.PowerUtils;
 
@@ -52,7 +54,8 @@ public class NotificationPresenter implements NotificationList.Callback {
     public static final int EVENT_BATH = 0;
     public static final int EVENT_POSTED = 1;
     public static final int EVENT_CHANGED = 2;
-    public static final int EVENT_REMOVED = 3;
+    public static final int EVENT_CHANGED_SPAM = 3;
+    public static final int EVENT_REMOVED = 4;
 
     private static final int INITIALIZING_PROCESS_NONE = 0;
     private static final int INITIALIZING_PROCESS_STARTED = 1;
@@ -83,9 +86,9 @@ public class NotificationPresenter implements NotificationList.Callback {
                     break;
                 case Config.KEY_UI_DYNAMIC_BACKGROUND_MODE:
                     enabled = Operator.bitAnd((int) value, Config.DYNAMIC_BG_NOTIFICATION_MASK);
-                    for (OpenStatusBarNotification osbn : mGList.list()) {
-                        StatusBarNotification sbn = osbn.getStatusBarNotification();
-                        NotificationData data = osbn.getNotificationData();
+                    for (OpenNotification n : mGList.list()) {
+                        StatusBarNotification sbn = n.getStatusBarNotification();
+                        NotificationData data = n.getNotificationData();
 
                         if (enabled) {
                             data.loadBackground(config.getContext(), sbn);
@@ -96,9 +99,9 @@ public class NotificationPresenter implements NotificationList.Callback {
                     break;
                 case Config.KEY_UI_NOTIFY_CIRCLED_ICON:
                     enabled = (boolean) value;
-                    for (OpenStatusBarNotification osbn : mGList.list()) {
-                        StatusBarNotification sbn = osbn.getStatusBarNotification();
-                        NotificationData data = osbn.getNotificationData();
+                    for (OpenNotification n : mGList.list()) {
+                        StatusBarNotification sbn = n.getStatusBarNotification();
+                        NotificationData data = n.getNotificationData();
 
                         if (enabled) {
                             data.loadCircleIcon(sbn);
@@ -113,7 +116,7 @@ public class NotificationPresenter implements NotificationList.Callback {
         private void handleLowPriorityNotificationsPreferenceChanged() {
             rebuildLocalList(new Comparator() {
                 @Override
-                public boolean needsRebuild(OpenStatusBarNotification osbn) {
+                public boolean needsRebuild(OpenNotification osbn) {
                     StatusBarNotification sbn = osbn.getStatusBarNotification();
                     return sbn.getNotification().priority <= Notification.PRIORITY_LOW;
                 }
@@ -133,7 +136,7 @@ public class NotificationPresenter implements NotificationList.Callback {
         private void handlePackageVisibilityChanged(final String packageName) {
             rebuildLocalList(new Comparator() {
                 @Override
-                public boolean needsRebuild(OpenStatusBarNotification osbn) {
+                public boolean needsRebuild(OpenNotification osbn) {
                     StatusBarNotification sbn = osbn.getStatusBarNotification();
                     return sbn.getPackageName().equals(packageName);
                 }
@@ -142,12 +145,12 @@ public class NotificationPresenter implements NotificationList.Callback {
     }
 
     private interface Comparator {
-        public boolean needsRebuild(OpenStatusBarNotification osbn);
+        public boolean needsRebuild(OpenNotification osbn);
     }
 
     private void rebuildLocalList(Comparator comparator) {
-        for (OpenStatusBarNotification osbn : mGList.list()) {
-            if (comparator.needsRebuild(osbn)) {
+        for (OpenNotification n : mGList.list()) {
+            if (comparator.needsRebuild(n)) {
                 rebuildLocalList();
                 break;
             }
@@ -169,15 +172,15 @@ public class NotificationPresenter implements NotificationList.Callback {
          *              {@link #EVENT_CHANGED}, {@link #EVENT_REMOVED}
          */
         public void onNotificationListChanged(NotificationPresenter np,
-                                              OpenStatusBarNotification osbn, int event);
+                                              OpenNotification osbn, int event);
 
     }
 
-    public void addOnNotificationListChangedListener(OnNotificationListChangedListener listener) {
+    public void registerListener(OnNotificationListChangedListener listener) {
         mListeners.add(listener);
     }
 
-    public void removeOnNotificationListChangedListener(OnNotificationListChangedListener listener) {
+    public void unregisterListener(OnNotificationListChangedListener listener) {
         mListeners.remove(listener);
     }
 
@@ -187,7 +190,7 @@ public class NotificationPresenter implements NotificationList.Callback {
         mLList = new NotificationList(this);
 
         mConfig = Config.getInstance();
-        mConfig.addOnConfigChangedListener(new ConfigListener());
+        mConfig.registerListener(new ConfigListener());
 
         mBlacklist = Blacklist.getInstance();
         mBlacklist.registerListener(new BlacklistListener());
@@ -200,27 +203,31 @@ public class NotificationPresenter implements NotificationList.Callback {
         return sNotificationPresenter;
     }
 
-    /**
-     * Called on {@link NotificationHandleService#onNotificationPosted(android.service.notification.StatusBarNotification)}
-     */
+    public void postOrRemoveNotification(Context context, StatusBarNotification n, boolean post) {
+        if (post) {
+            postNotification(context, n);
+        } else {
+            removeNotification(context, n);
+        }
+    }
+
     public void postNotification(Context context, StatusBarNotification n) {
         postNotification(context, n, false);
     }
 
-    public void postNotification(Context context, StatusBarNotification n, boolean silently) {
-        logNotification(n, "posted");
-        OpenStatusBarNotification osbn = new OpenStatusBarNotification(n);
+    public void postNotification(Context context, StatusBarNotification sbn, boolean silently) {
+        logNotification(sbn, "posted");
+        OpenNotification n = new OpenNotification(sbn);
 
-        boolean globalValid = isValidForGlobal(n);
-        boolean localValid = globalValid && isValidForLocal(n);
+        boolean globalValid = isValidForGlobal(sbn);
+        boolean localValid = globalValid && isValidForLocal(sbn);
 
         // If notification will not be added to the
         // list there's no point of loading its data.
         if (globalValid) {
-            osbn.loadData(context);
+            n.loadData(context);
 
-            StatusBarNotification sbn = osbn.getStatusBarNotification();
-            NotificationData data = osbn.getNotificationData();
+            NotificationData data = n.getNotificationData();
             Config config = Config.getInstance();
 
             // Selective load exactly what we need and nothing more.
@@ -233,39 +240,40 @@ public class NotificationPresenter implements NotificationList.Callback {
                 data.loadBackground(context, sbn);
         }
 
-        mGList.pushOrRemove(osbn, globalValid, silently);
-        mLList.pushOrRemove(osbn, localValid, silently);
+        mGList.pushOrRemove(n, globalValid, silently);
+        int result = mLList.pushOrRemove(n, localValid, silently);
 
-        if (localValid && !silently) {
-            tryStartGui(context, osbn);
+        if (localValid && !silently && result != -1) {
+            tryStartGui(context, n);
         }
     }
 
     /**
      * Called on {@link NotificationHandleService#onNotificationRemoved(android.service.notification.StatusBarNotification)}
      */
-    public void removeNotification(Context context, StatusBarNotification n) {
-        logNotification(n, "removed");
-        OpenStatusBarNotification osbn = new OpenStatusBarNotification(n);
-        mGList.remove(osbn);
-        mLList.remove(osbn);
+    public void removeNotification(Context context, StatusBarNotification sbn) {
+        logNotification(sbn, "removed");
+        OpenNotification n = new OpenNotification(sbn);
+        mGList.remove(n);
+        mLList.remove(n);
     }
 
     private void rebuildLocalList() {
         if (Build.DEBUG) Log.d(TAG, "Rebuilding local list of notifications.");
 
-        ArrayList<OpenStatusBarNotification> list = mLList.list();
+        ArrayList<OpenNotification> list = mLList.list();
         list.clear();
 
-        for (OpenStatusBarNotification notification : mGList.list()) {
-            if (isValidForLocal(notification.getStatusBarNotification()))
-                list.add(notification);
+        for (OpenNotification n : mGList.list()) {
+            if (isValidForLocal(n.getStatusBarNotification())) {
+                list.add(n);
+            }
         }
 
         notifyListeners(null, EVENT_BATH);
     }
 
-    public ArrayList<OpenStatusBarNotification> getList() {
+    public ArrayList<OpenNotification> getList() {
         return mLList.list();
     }
 
@@ -274,19 +282,40 @@ public class NotificationPresenter implements NotificationList.Callback {
     // //////////////////////////////////////////
 
     @Override
-    public int onNotificationAdded(OpenStatusBarNotification n) {
+    public int onNotificationAdded(OpenNotification n) {
         notifyListeners(n, EVENT_POSTED);
         return 0;
     }
 
     @Override
-    public int onNotificationChanged(OpenStatusBarNotification n) {
+    public int onNotificationChanged(OpenNotification n, OpenNotification old) {
+        // Prevent god damn notification spam by
+        // checking texts' equality.
+
+        // An example of notification spammer is well-known
+        // DownloadProvider (seriously, Google?)
+        NotificationData dataOld = old.getNotificationData();
+        NotificationData dataNew = n.getNotificationData();
+
+        if (dataNew.number == dataOld.number
+                && TextUtils.equals(dataNew.titleText, dataOld.titleText)
+                && TextUtils.equals(dataNew.messageText, dataOld.messageText)
+                && TextUtils.equals(dataNew.messageTextLarge, dataOld.messageTextLarge)
+                && TextUtils.equals(dataNew.infoText, dataOld.infoText)) {
+            // Technically notification was changed, but it was a fault
+            // of dumb developer. Mark notification as read, if old one was.
+            n.getNotificationData().markAsRead(old.getNotificationData().isRead);
+
+            notifyListeners(n, EVENT_CHANGED_SPAM);
+            return -1; // Don't wake up.
+        }
+
         notifyListeners(n, EVENT_CHANGED);
         return 0;
     }
 
     @Override
-    public int onNotificationRemoved(OpenStatusBarNotification n) {
+    public int onNotificationRemoved(OpenNotification n) {
         notifyListeners(n, EVENT_REMOVED);
         return 0;
     }
@@ -295,9 +324,9 @@ public class NotificationPresenter implements NotificationList.Callback {
     // //////// -- NOTIFICATION UTILS -- ////////
     // //////////////////////////////////////////
 
-    private void notifyListeners(OpenStatusBarNotification notification, int event) {
+    private void notifyListeners(OpenNotification n, int event) {
         for (OnNotificationListChangedListener listener : mListeners) {
-            listener.onNotificationListChanged(this, notification, event);
+            listener.onNotificationListChanged(this, n, event);
         }
     }
 
@@ -305,51 +334,56 @@ public class NotificationPresenter implements NotificationList.Callback {
      * Returns {@code false} if the notification doesn't fit
      * the requirements (such as not ongoing and clearable).
      */
-    private boolean isValidForLocal(StatusBarNotification n) {
-        AppConfig config = mBlacklist.getAppConfig(n.getPackageName());
+    private boolean isValidForLocal(StatusBarNotification sbn) {
+        AppConfig config = mBlacklist.getAppConfig(sbn.getPackageName());
 
-        boolean hidden = config.enabled && config.isHidden();
-        boolean priorityNormal = n.getNotification().priority >= Notification.PRIORITY_LOW;
+        boolean hidden = config.isHiddenReal();
+        boolean priorityNormal = sbn.getNotification().priority >= Notification.PRIORITY_LOW;
         boolean lowPriorPassed = priorityNormal || mConfig.isLowPriorityNotificationsAllowed();
 
         return lowPriorPassed && !hidden;
     }
 
-    private boolean isValidForGlobal(StatusBarNotification n) {
-        return !n.isOngoing() && n.isClearable();
+    private boolean isValidForGlobal(StatusBarNotification sbn) {
+        return !sbn.isOngoing() && sbn.isClearable();
     }
 
-    private void logNotification(StatusBarNotification n, String action) {
-        Log.d(TAG, "Notification " + action + ": package=" + n.getPackageName()
-                + " id=" + n.getId()
-                + " user_id=" + n.getUserId()
-                + " tag=" + n.getTag()
-                + " post_time=" + n.getPostTime()
-                + " is_valid_global=" + isValidForGlobal(n)
-                + " is_valid_local=" + isValidForLocal(n));
+    private void logNotification(StatusBarNotification sbn, String action) {
+        Log.d(TAG, "Notification " + action + ": package=" + sbn.getPackageName()
+                + " id=" + sbn.getId()
+                + " user_id=" + sbn.getUserId()
+                + " tag=" + sbn.getTag()
+                + " post_time=" + sbn.getPostTime()
+                + " is_valid_global=" + isValidForGlobal(sbn)
+                + " is_valid_local=" + isValidForLocal(sbn));
     }
 
     // //////////////////////////////////////////
     // ///////// -- USER INTERFACE -- ///////////
     // //////////////////////////////////////////
 
+    private boolean isTestNotification(Context context, OpenNotification n) {
+        StatusBarNotification sbn = n.getStatusBarNotification();
+        return sbn.getId() == App.ID_NOTIFY_INIT
+                && sbn.getPackageName().equals(PackageUtils.getName(context));
+    }
+
     /**
      * Starts {@link com.achep.acdisplay.acdisplay.AcDisplayActivity activity} if active display
      * is enabled and screen is turned off and...
      */
-    private boolean tryStartGui(Context context, OpenStatusBarNotification notification) {
-        String packageName = notification.getStatusBarNotification().getPackageName();
-        if (ProximitySensor.isNear()
-                || mConfig.isEnabled() == false
-                || mConfig.isNotifyWakingUp() == false
-                || mConfig.isEnabledOnlyWhileCharging() /* show only      */
-                && !PowerUtils.isPlugged(context)       /* while charging */
-                || mBlacklist.getAppConfig(packageName).isRestrictedReal())
-            return false;
-
-        // Inactive time
-        if (mConfig.isInactiveTimeEnabled() && InactiveHoursHelper.isInactiveTime(mConfig)) {
-            return false;
+    private boolean tryStartGui(Context context, OpenNotification n) {
+        if (!isTestNotification(context, n)) { // force test notification to be shown
+            String packageName = n.getStatusBarNotification().getPackageName();
+            if (ProximitySensor.isNear()
+                    || mConfig.isEnabled() == false
+                    || mConfig.isNotifyWakingUp() == false
+                    || mConfig.isEnabledOnlyWhileCharging() /* show only      */
+                    && !PowerUtils.isPlugged(context)       /* while charging */
+                    || mBlacklist.getAppConfig(packageName).isRestrictedReal()
+                    || mConfig.isInactiveTimeEnabled()            /* inactive */
+                    && InactiveTimeHelper.isInactiveTime(mConfig) /* time     */)
+                return false;
         }
 
         Presenter.getInstance().start(context);
@@ -364,7 +398,7 @@ public class NotificationPresenter implements NotificationList.Callback {
      * Should be called when notification listener service is ready to receive new notifications.
      */
     // Running on wrong thread
-    void tryStartInitProcess() {
+    public void tryStartInitProcess() {
         if (mInitProcess != INITIALIZING_PROCESS_NONE) {
             return;
         }
@@ -376,7 +410,7 @@ public class NotificationPresenter implements NotificationList.Callback {
         new Handler().postDelayed(new Runnable() {
             @Override
             public void run() {
-                NotificationHandleService service = NotificationHandleService.sService;
+                MediaService service = MediaService.sService;
 
                 if (service == null) {
                     Log.w(TAG, "Tried to send an init-notification but notification service is offline.");
@@ -399,7 +433,7 @@ public class NotificationPresenter implements NotificationList.Callback {
     }
 
     @SuppressWarnings("PointlessBooleanExpression")
-    void tryInit(NotificationHandleService service, final StatusBarNotification n, StatusBarNotification[] activeNotifications) {
+    public void tryInit(MediaService service, final StatusBarNotification n, StatusBarNotification[] activeNotifications) {
         if (mInitProcess != INITIALIZING_PROCESS_STARTED
                 // Is posted notification equals to init notification?
                 || n.getId() != App.ID_NOTIFY_INIT
@@ -421,13 +455,12 @@ public class NotificationPresenter implements NotificationList.Callback {
             public void run() {
                 NotificationHelper.dismissNotification(n);
             }
-        }, 1000);
+        }, 500);
     }
 
-    boolean isInitialized() {
+    public boolean isInitialized() {
         return mInitProcess == INITIALIZING_PROCESS_DONE;
     }
 
 }
 
-
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java
index 4fda0832..a1623921 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java
@@ -43,6 +43,15 @@ public class NotificationUtils {
         return null;
     }
 
+    public static Context createContext(Context context, StatusBarNotification n) {
+        try {
+            return context.createPackageContext(n.getPackageName(), Context.CONTEXT_RESTRICTED);
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.w(TAG, "Failed to create notification\'s context");
+            return null;
+        }
+    }
+
     public static boolean equals(StatusBarNotification n, StatusBarNotification n2) {
         return n == n2 || n != null && n2 != null && new EqualsBuilder()
                 .append(n.getId(), n2.getId())
@@ -51,18 +60,9 @@ public class NotificationUtils {
                 .isEquals();
     }
 
-    public static boolean equals(OpenStatusBarNotification n, OpenStatusBarNotification n2) {
+    public static boolean equals(OpenNotification n, OpenNotification n2) {
         return n == n2 || n != null && n2 != null && equals(
                 n.getStatusBarNotification(),
                 n2.getStatusBarNotification());
     }
-
-    public static Context createContext(Context context, StatusBarNotification n) {
-        try {
-            return context.createPackageContext(n.getPackageName(), Context.CONTEXT_RESTRICTED);
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.w(TAG, "Failed to create notification\'s context");
-            return null;
-        }
-    }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/OpenStatusBarNotification.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
similarity index 92%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/OpenStatusBarNotification.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
index 4d5c8fca..0c592af9 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/OpenStatusBarNotification.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
@@ -24,12 +24,12 @@ import android.service.notification.StatusBarNotification;
 /**
  * Created by Artem on 23.01.14.
  */
-public class OpenStatusBarNotification {
+public class OpenNotification {
 
     private StatusBarNotification mStatusBarNotification;
     private NotificationData mNotificationData;
 
-    public OpenStatusBarNotification(StatusBarNotification notification) {
+    public OpenNotification(StatusBarNotification notification) {
         mStatusBarNotification = notification;
     }
 
@@ -74,7 +74,7 @@ public class OpenStatusBarNotification {
 
     /**
      * Performs a click on notification.<br/>
-     * To be clear it is not a a click but launching its content intent.
+     * To be clear it is not a real click but launching its content intent.
      *
      * @see NotificationHelper#startContentIntent(StatusBarNotification)
      */
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/NativeExtractor.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/NativeExtractor.java
index 948165db..6b01d3ce 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/NativeExtractor.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/NativeExtractor.java
@@ -26,7 +26,6 @@ import android.service.notification.StatusBarNotification;
 import android.util.Log;
 
 import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.notifications.NotificationData;
 
 /**
@@ -38,16 +37,16 @@ public final class NativeExtractor implements Extractor {
 
     @TargetApi(android.os.Build.VERSION_CODES.KITKAT)
     @Override
-    public NotificationData loadTexts(Context context, StatusBarNotification statusBarNotification, NotificationData data) {
+    public NotificationData loadTexts(Context context,
+                                      StatusBarNotification statusBarNotification,
+                                      NotificationData data) {
         if (Build.DEBUG) Log.d(TAG, "Extracting notification data via native API.");
-        if (!Device.hasKitKatApi())
-            throw new RuntimeException("You must run KitKat to be able to access to native things.");
 
         Notification notification = statusBarNotification.getNotification();
         Bundle extras = notification.extras;
 
         if (extras == null) {
-            Log.i(TAG, "");
+            Log.i(TAG, "Shit happens: notification is empty.");
             return data;
         }
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/Utils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/Utils.java
index b16bfa20..edfb21d0 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/Utils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/notifications/parser/Utils.java
@@ -54,7 +54,7 @@ final class Utils {
     static CharSequence mergeLargeMessage(CharSequence[] messages) {
         int length = messages.length;
 
-        boolean highlight = length > 1;
+        boolean highlight = length > 1; // highlight first letters of messages or no?
         int[] trackStart = new int[length];
         int[] trackEnd = new int[length];
 
@@ -88,9 +88,6 @@ final class Utils {
                 textSpannable.setSpan(new UnderlineSpan(),
                         trackStart[i], trackStart[i] + 1,
                         Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                        /*textSpannable.setSpan(new AbsoluteSizeSpan(19, true),
-                                trackStart[i], trackStart[i] + 1,
-                                Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);*/
             }
             text = textSpannable;
         }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/MediaWidget.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/powertoggles/ToggleReceiver.java
similarity index 62%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/MediaWidget.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/powertoggles/ToggleReceiver.java
index f227ef7b..9353580a 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/MediaWidget.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/powertoggles/ToggleReceiver.java
@@ -17,26 +17,24 @@
  * MA  02110-1301, USA.
  */
 
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.powertoggles;
+
+import com.achep.acdisplay.Config;
+import com.painless.pc.PowerTogglesPlugin;
 
 import android.content.Context;
-import android.util.AttributeSet;
-import android.widget.LinearLayout;
 
 /**
- * This is the widget responsible for showing music controls.
+ * AcDisplay toggle plugin for PowerToggles <http://powertoggles.com>
+ *
+ * @author Artem Chepurnoy
  */
-public class MediaWidget extends LinearLayout {
+public class ToggleReceiver extends PowerTogglesPlugin {
 
-    public MediaWidget(Context context) {
-        super(context);
+    @Override
+    protected void changeState(Context context, boolean newState) {
+        Config.getInstance().setEnabled(context, newState, null);
+        sendStateUpdate(context, Config.getInstance().isEnabled());
     }
 
-    public MediaWidget(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-
-    public MediaWidget(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-    }
 }
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/providers/LogAttachmentProvider.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/providers/LogAttachmentProvider.java
new file mode 100644
index 00000000..9a8d856c
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/providers/LogAttachmentProvider.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.providers;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.provider.OpenableColumns;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.List;
+
+/**
+ * Created by achep on 16.06.14.
+ */
+public class LogAttachmentProvider extends ContentProvider {
+
+    private static final String TAG = "LogAttachmentProvider";
+
+    public static final String AUTHORITY = "com.achep.acdisplay.logs";
+    public static final String DIRECTORY = "logs";
+
+    private static final String COLUMN_DATA = "_data";
+
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+                        String[] selectionArgs, String orderBy) {
+        List<String> pathSegments = uri.getPathSegments();
+        String fileName = pathSegments.get(0);
+        File logFile = getContext().getCacheDir();
+        if (logFile == null) {
+            Log.e(TAG, "No cache dir.");
+            return null;
+        }
+
+        logFile = new File(new File(logFile, DIRECTORY), fileName);
+        if (!logFile.exists()) {
+            Log.e(TAG, "Requested log file doesn't exist.");
+            return null;
+        }
+
+        if (projection == null) {
+            projection = new String[]{
+                    COLUMN_DATA,
+                    OpenableColumns.DISPLAY_NAME,
+                    OpenableColumns.SIZE,
+            };
+        }
+
+        MatrixCursor matrixCursor = new MatrixCursor(projection, 1);
+        Object[] row = new Object[projection.length];
+        for (int col = 0; col < projection.length; col++) {
+            switch (projection[col]) {
+                case COLUMN_DATA:
+                    row[col] = logFile.getAbsolutePath();
+                    break;
+                case OpenableColumns.DISPLAY_NAME:
+                    row[col] = fileName;
+                    break;
+                case OpenableColumns.SIZE:
+                    row[col] = logFile.length();
+                    break;
+            }
+        }
+        matrixCursor.addRow(row);
+        return matrixCursor;
+    }
+
+    @Override
+    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
+        return openFileHelper(uri, "r");
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        return "text/plain";
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException("insert not supported");
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException("delete not supported");
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues contentValues, String selection,
+                      String[] selectionArgs) {
+        throw new UnsupportedOperationException("update not supported");
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java
index 2cc1f4b8..c6308913 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java
@@ -30,10 +30,10 @@ import android.net.Uri;
 import android.util.Log;
 import android.widget.RemoteViews;
 
+import com.achep.acdisplay.App;
 import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.receiver.ReceiverActivity;
 
 /**
  * Toggle widget provider.
@@ -46,7 +46,6 @@ public class ToggleWidgetProvider extends AppWidgetProvider
     private static final String TAG = "AppWidgetProvider";
 
     private Config mConfig;
-    private Context mContext;
 
     @Override
     public void onEnabled(Context context) {
@@ -70,29 +69,29 @@ public class ToggleWidgetProvider extends AppWidgetProvider
     public void onConfigChanged(Config config, String key, Object value) {
         switch (key) {
             case Config.KEY_ENABLED:
-                updateWidgets(mContext);
+                updateWidgets(config.getContext());
                 break;
         }
     }
 
     private void onEnabledInternal(Context context) {
-        if (mContext != null) {
+        if (mConfig != null) {
             return; // already initialized
         }
 
-        mContext = context;
         mConfig = Config.getInstance();
-        mConfig.addOnConfigChangedListener(this);
+        mConfig.registerListener(this);
 
         if (Build.DEBUG) Log.d(TAG, "Toggle widget enabled");
     }
 
     private void onDisabledInternal(Context context) {
-        if (mContext == null) {
+        if (mConfig == null) {
             return; // not initialized
         }
 
-        mConfig.removeOnConfigChangedListener(this);
+        mConfig.unregisterListener(this);
+        mConfig = null;
 
         if (Build.DEBUG) Log.d(TAG, "Toggle widget disabled");
     }
@@ -106,9 +105,8 @@ public class ToggleWidgetProvider extends AppWidgetProvider
 
             // Create an Intent to launch ReceiverActivity to toggle AcDisplay.
             // Probably doing same using BroadcastReceiver would be better solution.
-            Intent intent = new Intent(context, ReceiverActivity.class)
-                    .setData(Uri.parse("acdisplay://" + ReceiverActivity.HOST_TOGGLE));
-            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
+            Intent intent = new Intent(App.ACTION_TOGGLE);
+            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
             Resources res = context.getResources();
 
             // Get the layout for the App Widget and attach an on-click listener
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java
index d1a12bbd..a7892790 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java
@@ -19,14 +19,19 @@
 package com.achep.acdisplay.receiver;
 
 import android.app.Activity;
+import android.app.admin.DevicePolicyManager;
+import android.content.ActivityNotFoundException;
 import android.content.ComponentName;
+import android.content.Context;
 import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
+import android.provider.Settings;
 import android.support.v4.content.LocalBroadcastManager;
 import android.util.Log;
 
 import com.achep.acdisplay.R;
+import com.achep.acdisplay.admin.AdminReceiver;
 import com.achep.acdisplay.utils.IntentUtils;
 import com.achep.acdisplay.utils.PackageUtils;
 import com.achep.acdisplay.utils.ToastUtils;
@@ -39,7 +44,8 @@ public class LocalReceiverActivity extends Activity {
     private static final String TAG = "LocalReceiverActivity";
 
     private static final String HOST_UNINSTALL = "uninstall";
-    private static final String HOST_LAUNCH_DEVICE_ADMINS = "launch_device_admins_activity";
+    private static final String HOST_LAUNCH_APP_INFO = "launch_app_info";
+    private static final String HOST_REMOVE_ADMIN_ACCESS = "remove_admin_access";
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -68,25 +74,34 @@ public class LocalReceiverActivity extends Activity {
         }
 
         switch (host) {
-            case HOST_LAUNCH_DEVICE_ADMINS:
-                Intent launchIntent = new Intent().setComponent(new ComponentName(
-                        "com.android.settings",
-                        "com.android.settings.DeviceAdminSettings"));
-                if (IntentUtils.hasActivityForThat(this, launchIntent)) {
-                    startActivity(launchIntent);
-                } else {
-                    ToastUtils.showShort(this,
-                            getString(R.string.device_admin_could_not_be_started));
+            case HOST_REMOVE_ADMIN_ACCESS:
+                ComponentName admin = new ComponentName(this, AdminReceiver.class);
+                DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
+
+                try {
+                    dpm.removeActiveAdmin(admin);
+                    ToastUtils.showShort(this, R.string.access_device_admin_removed_successful);
+                } catch (SecurityException e) {
+                    Log.i(TAG, "Failed to remove AcDisplay from active device admins.");
                 }
+                Log.i(TAG, "asdasdasd");
                 break;
             case HOST_UNINSTALL:
-                Uri packageUri = Uri.parse("package:" + PackageUtils.getName(this));
-                launchIntent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageUri);
-                if (IntentUtils.hasActivityForThat(this, launchIntent)) {
-                    startActivity(launchIntent);
-                } else {
-                    ToastUtils.showShort(this,
-                            getString(R.string.package_could_not_be_uninstalled));
+                try {
+                    startActivity(new Intent(
+                            Intent.ACTION_UNINSTALL_PACKAGE,
+                            Uri.fromParts("package", PackageUtils.getName(this), null)));
+                } catch (ActivityNotFoundException e) {
+                    Log.wtf(TAG, "Failed to start Uninstall activity.");
+                }
+                break;
+            case HOST_LAUNCH_APP_INFO:
+                try {
+                    startActivity(new Intent(
+                            Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
+                            Uri.fromParts("package", PackageUtils.getName(this), null)));
+                } catch (ActivityNotFoundException e) {
+                    Log.wtf(TAG, "Failed to start ApplicationDetails activity.");
                 }
                 break;
             default:
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/Receiver.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/Receiver.java
index 3e181123..dc8daabe 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/Receiver.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/Receiver.java
@@ -23,8 +23,12 @@ import android.content.Context;
 import android.content.Intent;
 import android.util.Log;
 
-import com.achep.acdisplay.activemode.ActiveModeService;
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
 import com.achep.acdisplay.services.KeyguardService;
+import com.achep.acdisplay.services.activemode.ActiveModeService;
+import com.achep.acdisplay.utils.ToastUtils;
 
 /**
  * Created by Artem on 11.03.14.
@@ -35,15 +39,34 @@ public class Receiver extends BroadcastReceiver {
 
     @Override
     public void onReceive(Context context, Intent intent) {
-        Log.d(TAG, "action=" + intent.getAction() + " intent=" + intent.toString());
-
-        switch (intent.getAction()) {
+        String action = intent.getAction();
+        switch (action) {
             case Intent.ACTION_BOOT_COMPLETED:
             case Intent.ACTION_POWER_CONNECTED:
             case Intent.ACTION_POWER_DISCONNECTED:
                 ActiveModeService.handleState(context);
                 KeyguardService.handleState(context);
                 break;
+            case App.ACTION_ENABLE:
+            case App.ACTION_DISABLE:
+            case App.ACTION_TOGGLE:
+                Config config = Config.getInstance();
+                if (action.equals(App.ACTION_ENABLE)) {
+                    Log.i(TAG, "Enabling AcDisplay from broadcast receiver.");
+                    ToastUtils.showLong(context, R.string.remote_enable_acdisplay);
+                    config.setEnabled(context, true, null);
+                } else if (action.equals(App.ACTION_DISABLE)) {
+                    Log.i(TAG, "Disabling AcDisplay from broadcast receiver.");
+                    ToastUtils.showLong(context, R.string.remote_disable_acdisplay);
+                    config.setEnabled(context, false, null);
+                } else {
+                    Log.i(TAG, "Toggling from broadcast receiver.");
+                    config.setEnabled(context, !config.isEnabled(), null);
+                    ToastUtils.showLong(context, config.isEnabled()
+                            ? R.string.remote_enable_acdisplay
+                            : R.string.remote_disable_acdisplay);
+                }
+                break;
         }
     }
 }
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/ReceiverActivity.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/ReceiverActivity.java
deleted file mode 100644
index cade636b..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/receiver/ReceiverActivity.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.receiver;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.ToastUtils;
-
-/**
- * Created by Artem on 26.03.2014.
- */
-public class ReceiverActivity extends Activity {
-
-    private static final String TAG = "PublicReceiverActivity";
-
-    public static final String HOST_ENABLE = "enable";
-    public static final String HOST_DISABLE = "disable";
-    public static final String HOST_TOGGLE = "toggle";
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        Intent intent = getIntent();
-        if (intent != null) {
-            handleIntent(intent);
-        } else {
-            Log.i(TAG, "Got an empty launch intent.");
-        }
-
-        finish();
-    }
-
-    private void handleIntent(Intent intent) {
-        String host = LocalReceiverActivity.extractHost(intent);
-        if (host == null) {
-            Log.i(TAG, "Got an empty launch intent.");
-            return;
-        }
-
-        Config config;
-        switch (host) {
-            case HOST_ENABLE:
-                Log.i(TAG, "Enabling active display by remote intent.");
-                ToastUtils.showLong(this, getString(R.string.remote_enable_acdisplay));
-
-                Config.getInstance().setEnabled(this, true, null);
-                break;
-
-            case HOST_DISABLE:
-                Log.i(TAG, "Disabling active display by remote intent.");
-                ToastUtils.showLong(this, getString(R.string.remote_disable_acdisplay));
-
-                Config.getInstance().setEnabled(this, false, null);
-                break;
-
-            case HOST_TOGGLE:
-                Log.i(TAG, "Toggling active display by remote intent.");
-                config = Config.getInstance();
-                config.setEnabled(this, !config.isEnabled(), null);
-
-                ToastUtils.showLong(this, getString(config.isEnabled()
-                        ? R.string.remote_enable_acdisplay
-                        : R.string.remote_disable_acdisplay));
-                break;
-
-            default:
-                Log.i(TAG, "Got an unknown intent: " + host);
-                break;
-        }
-    }
-
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/BathService.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/BathService.java
new file mode 100644
index 00000000..c9a0e9d9
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/BathService.java
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.services;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.IBinder;
+import android.support.v4.content.LocalBroadcastManager;
+import android.util.Log;
+
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.Build;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.activities.MainActivity;
+
+import java.util.Enumeration;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Created by achep on 26.05.14.
+ *
+ * @author Artem Chepurnoy
+ */
+public class BathService extends Service {
+
+    private static final String TAG = "BathService";
+
+    private static final String ACTION_ADD_SERVICE = TAG + ":add_service";
+    private static final String ACTION_REMOVE_SERVICE = TAG + ":remove_service";
+    private static final String EXTRA_SERVICE_CLASS = "class";
+
+    public static void startService(Context context, Class<? extends ChildService> clazz) {
+        synchronized (monitor) {
+            if (sCreated) {
+                Intent intent = new Intent(ACTION_ADD_SERVICE);
+                intent.putExtra(EXTRA_SERVICE_CLASS, clazz);
+                LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
+            } else if (!sServiceMap.containsKey(clazz)) {
+                try {
+                    // Adding child to parent service.
+                    ChildService child = clazz.newInstance();
+                    sServiceMap.put(clazz, child);
+                } catch (InstantiationException | IllegalAccessException e) {
+                    // Should never happen
+                    throw new RuntimeException(e.getMessage());
+                }
+
+                context.startService(new Intent(context, BathService.class));
+            }
+        }
+    }
+
+    public static void stopService(Context context, Class<? extends ChildService> clazz) {
+        synchronized (monitor) {
+            if (sCreated) {
+                Intent intent = new Intent(ACTION_REMOVE_SERVICE);
+                intent.putExtra(EXTRA_SERVICE_CLASS, clazz);
+                LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
+            } else if (sServiceMap.containsKey(clazz)) {
+                ChildService child = sServiceMap.remove(clazz);
+                child.onDestroy();
+            }
+        }
+    }
+
+    private static final ConcurrentHashMap<Class, ChildService> sServiceMap = new ConcurrentHashMap<>(2);
+    private static final Object monitor = new Object();
+    private static boolean sCreated;
+
+    private LocalBroadcastManager mLocalBroadcastManager;
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            boolean add = false;
+            switch (intent.getAction()) {
+                case ACTION_ADD_SERVICE:
+                    add = true;
+                case ACTION_REMOVE_SERVICE:
+                    break;
+                default:
+                    return;
+            }
+
+            synchronized (monitor) {
+                Class clazz = (Class) intent.getSerializableExtra(EXTRA_SERVICE_CLASS);
+                boolean containsClazz = sServiceMap.containsKey(clazz);
+
+                if (containsClazz == add) {
+                    if (Build.DEBUG) Log.e(TAG, "Trying to add an existing service.");
+                    return;
+                }
+
+                if (add) {
+                    try {
+                        // Adding child to parent service.
+                        ChildService child = (ChildService) clazz.newInstance();
+                        child.setContext(BathService.this);
+                        child.onCreate();
+                        sServiceMap.put(clazz, child);
+                    } catch (InstantiationException | IllegalAccessException e) {
+                        throw new RuntimeException(e.getMessage()); // Should never happen
+                    }
+                    updateNotification();
+                    return;
+                }
+
+                // Removing child from parent service.
+                ChildService child = sServiceMap.remove(clazz);
+                child.onDestroy();
+
+                if (sServiceMap.isEmpty()) {
+                    BathService.this.stopSelf();
+                } else {
+                    updateNotification();
+                }
+            }
+        }
+    };
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        synchronized (monitor) {
+            sCreated = true;
+
+            IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction(ACTION_ADD_SERVICE);
+            intentFilter.addAction(ACTION_REMOVE_SERVICE);
+            mLocalBroadcastManager = LocalBroadcastManager.getInstance(this);
+            mLocalBroadcastManager.registerReceiver(mReceiver, intentFilter);
+
+            Enumeration<ChildService> elements = sServiceMap.elements();
+            while (elements.hasMoreElements()) {
+                ChildService child = elements.nextElement();
+                child.setContext(this);
+                child.onCreate();
+            }
+
+            startForeground(App.ID_NOTIFY_BATH, buildNotification());
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        synchronized (monitor) {
+            sCreated = false;
+
+            mLocalBroadcastManager.unregisterReceiver(mReceiver);
+            mLocalBroadcastManager = null;
+
+            Enumeration<ChildService> elements = sServiceMap.elements();
+            while (elements.hasMoreElements()) {
+                ChildService child = elements.nextElement();
+                child.onDestroy();
+            }
+            sServiceMap.clear();
+        }
+    }
+
+    private void updateNotification() {
+        NotificationManager nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
+        nm.notify(App.ID_NOTIFY_BATH, buildNotification());
+    }
+
+    private Notification buildNotification() {
+        boolean empty = true;
+
+        StringBuilder builder = new StringBuilder();
+        String divider = getString(R.string.settings_multi_list_divider);
+        Enumeration<ChildService> elements = sServiceMap.elements();
+        while (elements.hasMoreElements()) {
+            if (!empty) {
+                builder.append(divider);
+            }
+            ChildService child = elements.nextElement();
+            builder.append(child.getName());
+            empty = false;
+        }
+
+        String contentText = builder.toString();
+        contentText = contentText.charAt(0) + contentText.substring(1).toLowerCase();
+
+        PendingIntent pendingIntent = PendingIntent.getActivity(this,
+                App.ID_NOTIFY_BATH, new Intent(this, MainActivity.class),
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        return new Notification.Builder(this)
+                .setContentTitle(getString(R.string.service_bath))
+                .setContentText(contentText)
+                .setContentIntent(pendingIntent)
+                .setSmallIcon(R.drawable.stat_acdisplay)
+                .setPriority(Notification.PRIORITY_MIN)
+                .build();
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    /**
+     * An implementation of fake service.
+     *
+     * @author Artem Chepurnoy
+     */
+    public abstract static class ChildService {
+
+        private Context mContext;
+
+        public ChildService() {
+            if (Build.DEBUG) Log.d(TAG, "Creating child service...");
+        }
+
+        void setContext(Context context) {
+            mContext = context;
+        }
+
+        /**
+         * Called when fake-service is attached to main one.
+         *
+         * @see android.app.Service#onCreate()
+         */
+        public abstract void onCreate();
+
+        /**
+         * Called when fake-service is detached from main one.
+         *
+         * @see android.app.Service#onDestroy()
+         */
+        public abstract void onDestroy();
+
+        public abstract String getName();
+
+        public Context getContext() {
+            return mContext;
+        }
+
+    }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/KeyguardService.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/KeyguardService.java
index 28244301..03785ef8 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/KeyguardService.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/KeyguardService.java
@@ -19,32 +19,30 @@
 package com.achep.acdisplay.services;
 
 import android.app.ActivityManager;
-import android.app.Notification;
-import android.app.PendingIntent;
-import android.app.Service;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.os.IBinder;
 import android.os.SystemClock;
 import android.telephony.TelephonyManager;
 import android.util.Log;
 
-import com.achep.acdisplay.App;
 import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.Presenter;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.acdisplay.AcDisplayActivity;
-import com.achep.acdisplay.settings.Settings;
 import com.achep.acdisplay.utils.PackageUtils;
 import com.achep.acdisplay.utils.PowerUtils;
 
+import java.util.List;
+
 /**
  * Created by Artem on 16.02.14.
+ *
+ * @author Artem Chepurnoy
  */
-public class KeyguardService extends Service {
+public class KeyguardService extends BathService.ChildService {
 
     private static final String TAG = "KeyguardService";
 
@@ -52,18 +50,6 @@ public class KeyguardService extends Service {
 
     private ActivityMonitorThread mActivityMonitorThread;
 
-    public static long sIgnoreTillTime;
-
-    /**
-     * Prevents launching keyguard on soonest turning screen on.
-     *
-     * @deprecated hopefully the bug with it is fixed now, so no need to use it. Just in case...
-     */
-    @Deprecated
-    public static void ignoreCurrentTurningOn() {
-        sIgnoreTillTime = SystemClock.elapsedRealtime() + 2000;
-    }
-
     /**
      * Starts or stops this service as required by settings and device's state.
      */
@@ -71,15 +57,15 @@ public class KeyguardService extends Service {
         Intent intent = new Intent(context, KeyguardService.class);
         Config config = Config.getInstance();
 
-        boolean onlyWhileChangingOption = !config.isEnabledOnlyWhileCharging()
+        boolean onlyWhileChargingOption = !config.isEnabledOnlyWhileCharging()
                 || PowerUtils.isPlugged(context);
 
         if (config.isEnabled()
                 && config.isKeyguardEnabled()
-                && onlyWhileChangingOption) {
-            context.startService(intent);
+                && onlyWhileChargingOption) {
+            BathService.startService(context, KeyguardService.class);
         } else {
-            context.stopService(intent);
+            BathService.stopService(context, KeyguardService.class);
         }
     }
 
@@ -96,21 +82,19 @@ public class KeyguardService extends Service {
                     long activityChangeTime = 0;
                     if (mActivityMonitorThread != null) {
                         mActivityMonitorThread.monitor();
-                        activityName = mActivityMonitorThread.activityName;
-                        activityChangeTime = mActivityMonitorThread.activityChangeTime;
+                        activityName = mActivityMonitorThread.topActivityName;
+                        activityChangeTime = mActivityMonitorThread.topActivityTime;
                     }
 
                     stopMonitoringActivities();
 
                     long now = SystemClock.elapsedRealtime();
-                    boolean becauseOfIgnoringPolicy = now < sIgnoreTillTime;
                     boolean becauseOfActivityLaunch =
                             now - activityChangeTime < ACTIVITY_LAUNCH_MAX_TIME
                                     && activityName != null && !activityName.startsWith(
-                                    PackageUtils.getName(KeyguardService.this));
+                                    PackageUtils.getName(getContext()));
 
-                    if (isCall || becauseOfIgnoringPolicy) {
-                        sIgnoreTillTime = 0;
+                    if (isCall) {
                         return;
                     }
 
@@ -136,9 +120,9 @@ public class KeyguardService extends Service {
     };
 
     private void startGui() {
-        startActivity(new Intent(this, AcDisplayActivity.class)
+        Context context = getContext();
+        context.startActivity(new Intent(context, AcDisplayActivity.class)
                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
                         | Intent.FLAG_ACTIVITY_NO_ANIMATION));
     }
 
@@ -146,7 +130,8 @@ public class KeyguardService extends Service {
         stopMonitoringActivities();
         if (Build.DEBUG) Log.d(TAG, "Starting to monitor activities.");
 
-        ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager am = (ActivityManager) getContext()
+                .getSystemService(Context.ACTIVITY_SERVICE);
         mActivityMonitorThread = new ActivityMonitorThread(am);
         mActivityMonitorThread.start();
     }
@@ -157,61 +142,43 @@ public class KeyguardService extends Service {
 
             mActivityMonitorThread.running = false;
             mActivityMonitorThread.interrupt();
+            mActivityMonitorThread = null;
         }
     }
 
     @Override
     public void onCreate() {
-        super.onCreate();
         IntentFilter intentFilter = new IntentFilter();
         intentFilter.addAction(Intent.ACTION_SCREEN_ON);
         intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
         intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1); // highest priority
-        registerReceiver(mReceiver, intentFilter);
-
-        int notificationId = App.ID_NOTIFY_KEYGUARD;
-        Intent intent = new Intent(this, Settings.LockscreenSettingsActivity.class);
-        PendingIntent pendingIntent = PendingIntent.getActivity(this,
-                notificationId, intent, PendingIntent.FLAG_UPDATE_CURRENT);
-        Notification notification = new Notification.Builder(this)
-                .setSmallIcon(R.drawable.stat_lock)
-                .setContentTitle(getString(
-                        R.string.service_lockscreen,
-                        getString(R.string.app_name)))
-                .setContentText(getString(R.string.service_lockscreen_text))
-                .setPriority(Notification.PRIORITY_MIN)
-                .setContentIntent(pendingIntent)
-                .setOngoing(true)
-                .build();
-
-        startForeground(notificationId, notification);
+        getContext().registerReceiver(mReceiver, intentFilter);
     }
 
     @Override
     public void onDestroy() {
-        super.onDestroy();
-        unregisterReceiver(mReceiver);
+        getContext().unregisterReceiver(mReceiver);
         stopMonitoringActivities();
     }
 
     @Override
-    public IBinder onBind(Intent intent) {
-        return null;
+    public String getName() {
+        return getContext().getString(R.string.service_bath_keyguard);
     }
 
     /**
      * Thread that monitors current top activity.
-     * This is needed to prevent launching AcDisplay on any other
-     * activity launched with
+     * This is needed to prevent launching AcDisplay above any other
+     * activity which launched with
      * {@link android.view.WindowManager.LayoutParams#FLAG_TURN_SCREEN_ON} flag.
      */
     private static class ActivityMonitorThread extends Thread {
 
-        private static final long MONITORING_PERIOD = 15 * 60 * 1000; // ms.
+        private static final long MONITORING_PERIOD = 15 * 60 * 1000; // 15 min.
 
+        public volatile long topActivityTime;
+        public volatile String topActivityName;
         public volatile boolean running = true;
-        public volatile long activityChangeTime;
-        public volatile String activityName;
 
         private final ActivityManager mActivityManager;
 
@@ -236,24 +203,22 @@ public class KeyguardService extends Service {
          * Checks what activity is the latest.
          */
         public synchronized void monitor() {
-            String latestActivityName;
-            try {
-                ActivityManager.RunningTaskInfo task = mActivityManager.getRunningTasks(1).get(0);
-                latestActivityName = task.topActivity.getClassName();
-            } catch (NullPointerException e) {
-                return; // Not a problem, just too lazy :)
+            List<ActivityManager.RunningTaskInfo> tasks = mActivityManager.getRunningTasks(1);
+            if (tasks == null || tasks.size() == 0) {
+                return;
             }
 
-            assert latestActivityName != null;
+            String topActivity = tasks.get(0).topActivity.getClassName();
+            if (!topActivity.equals(topActivityName)) {
 
-            if (!latestActivityName.equals(activityName)) {
-                if (activityName != null) { // first start
-                    this.activityChangeTime = SystemClock.elapsedRealtime(); // deep sleep
+                // Update time if it's not first try.
+                if (topActivityName != null) {
+                    topActivityTime = SystemClock.elapsedRealtime();
                 }
 
-                activityName = latestActivityName;
+                topActivityName = topActivity;
 
-                if (Build.DEBUG) Log.d(TAG, "Current latest activity is " + activityName);
+                if (Build.DEBUG) Log.d(TAG, "Current latest activity is " + topActivityName);
             }
         }
     }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/MediaService.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/MediaService.java
new file mode 100644
index 00000000..0bf2f567
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/MediaService.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.services;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.content.Intent;
+import android.media.AudioManager;
+import android.media.RemoteController;
+import android.os.Binder;
+import android.os.Build;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.service.notification.NotificationListenerService;
+import android.service.notification.StatusBarNotification;
+import android.util.Log;
+
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.Device;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.notifications.NotificationPresenter;
+
+/**
+ * Created by achep on 07.06.14.
+ *
+ * @author Artem Chepurnoy
+ */
+@TargetApi(Build.VERSION_CODES.KITKAT)
+public class MediaService extends NotificationListenerService implements
+        RemoteController.OnClientUpdateListener {
+
+    private static final String TAG = "MediaService";
+
+    public static MediaService sService;
+
+    private IBinder mBinder = new B();
+    private AudioManager mAudioManager;
+
+    private boolean mRegistered;
+    private RemoteController mRemoteController;
+    private RemoteController.OnClientUpdateListener mExternalListener;
+
+    private Handler mHandler = new Handler(Looper.getMainLooper());
+
+    public class B extends Binder {
+
+        public MediaService getService() {
+            return MediaService.this;
+        }
+
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        switch (intent.getAction()) {
+            case App.ACTION_BIND_MEDIA_CONTROL_SERVICE:
+                if (!Device.hasKitKatApi()) {
+                    throw new RuntimeException("Required Android API version 19 or more!");
+                }
+                return mBinder;
+            default:
+                sService = this;
+
+                // What is the idea of init notification?
+                // Well the main goal is to access #getActiveNotifications()
+                // what seems to be not possible without dirty and buggy
+                // workarounds.
+                NotificationPresenter
+                        .getInstance()
+                        .tryStartInitProcess();
+
+                return super.onBind(intent);
+        }
+    }
+
+    @Override
+    public boolean onUnbind(Intent intent) {
+        switch (intent.getAction()) {
+            case App.ACTION_BIND_MEDIA_CONTROL_SERVICE:
+                break;
+            default:
+                sService = null;
+                break;
+        }
+        return super.onUnbind(intent);
+    }
+
+    @Override
+    public void onNotificationPosted(StatusBarNotification notification) {
+        rockNotification(notification, true);
+    }
+
+    @Override
+    public void onNotificationRemoved(final StatusBarNotification notification) {
+        rockNotification(notification, false);
+    }
+
+    private void rockNotification(final StatusBarNotification sbn, final boolean post) {
+        final StatusBarNotification[] activeNotifies = getActiveNotifications();
+        runOnMainLooper(new Runnable() {
+            @Override
+            public void run() {
+                NotificationPresenter np = NotificationPresenter.getInstance();
+                np.postOrRemoveNotification(MediaService.this, sbn, post);
+                np.tryInit(MediaService.this, sbn, activeNotifies);
+            }
+        });
+    }
+
+    private void runOnMainLooper(Runnable runnable) {
+        mHandler.post(runnable);
+    }
+
+    @Override
+    public void onCreate() {
+        if (Device.hasKitKatApi()) {
+            mRemoteController = new RemoteController(this, this);
+            mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
+        }
+    }
+
+    @Override
+    public void onDestroy() {
+        if (Device.hasKitKatApi()) {
+            setRemoteControllerDisabled();
+        }
+    }
+
+    public void setRemoteControllerEnabled() {
+        if (mRegistered) {
+            return;
+        }
+
+        mRegistered = mAudioManager.registerRemoteController(mRemoteController);
+
+        if (mRegistered) {
+            final int size = getResources().getDimensionPixelSize(R.dimen.artwork_size);
+            mRemoteController.setArtworkConfiguration(size, size);
+            //setSynchronizationMode(mRemoteController, RemoteController.POSITION_SYNCHRONIZATION_CHECK);
+        } else {
+            Log.e(TAG, "Error while registering RemoteController!");
+        }
+    }
+
+    public void setRemoteControllerDisabled() {
+        if (!mRegistered) {
+            return;
+        }
+
+        mAudioManager.unregisterRemoteController(mRemoteController);
+        mRegistered = false;
+    }
+
+    public RemoteController getRemoteController() {
+        return mRemoteController;
+    }
+
+    /**
+     * Sets up external callback for client update events.
+     */
+    public void setClientUpdateListener(RemoteController.OnClientUpdateListener listener) {
+        mExternalListener = listener;
+    }
+
+    @Override
+    public void onClientChange(boolean clearing) {
+        if (mExternalListener != null) {
+            mExternalListener.onClientChange(clearing);
+        }
+    }
+
+    @Override
+    public void onClientPlaybackStateUpdate(int state) {
+        if (mExternalListener != null) {
+            mExternalListener.onClientPlaybackStateUpdate(state);
+        }
+    }
+
+    @Override
+    public void onClientPlaybackStateUpdate(int state, long stateChangeTimeMs, long currentPosMs, float speed) {
+        if (mExternalListener != null) {
+            mExternalListener.onClientPlaybackStateUpdate(state, stateChangeTimeMs, currentPosMs, speed);
+        }
+    }
+
+    @Override
+    public void onClientTransportControlUpdate(int transportControlFlags) {
+        if (mExternalListener != null) {
+            mExternalListener.onClientTransportControlUpdate(transportControlFlags);
+        }
+    }
+
+    @Override
+    public void onClientMetadataUpdate(RemoteController.MetadataEditor metadataEditor) {
+        if (mExternalListener != null) {
+            mExternalListener.onClientMetadataUpdate(metadataEditor);
+        }
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeHandler.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeHandler.java
similarity index 86%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeHandler.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeHandler.java
index d7a5c78d..dd68a900 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeHandler.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeHandler.java
@@ -17,7 +17,7 @@
  * MA  02110-1301, USA.
  */
 
-package com.achep.acdisplay.activemode;
+package com.achep.acdisplay.services.activemode;
 
 import android.content.Context;
 
@@ -31,6 +31,7 @@ public abstract class ActiveModeHandler {
 
     private final Context mContext;
     private final Callback mCallback;
+    private boolean mCreated;
 
     /**
      * Provides control callback to main service.
@@ -86,8 +87,8 @@ public abstract class ActiveModeHandler {
 
     /**
      * @return Callback to control {@link ActiveModeService service}.
-     * @see com.achep.acdisplay.activemode.ActiveModeHandler.Callback#requestActive()
-     * @see com.achep.acdisplay.activemode.ActiveModeHandler.Callback#requestInactive()
+     * @see com.achep.acdisplay.services.activemode.ActiveModeHandler.Callback#requestActive()
+     * @see com.achep.acdisplay.services.activemode.ActiveModeHandler.Callback#requestInactive()
      */
     public Callback getCallback() {
         return mCallback;
@@ -118,4 +119,18 @@ public abstract class ActiveModeHandler {
      */
     public abstract boolean isActive();
 
+    final void create() {
+        mCreated = true;
+        onCreate();
+    }
+
+    final void destroy() {
+        onDestroy();
+        mCreated = false;
+    }
+
+    final boolean isCreated() {
+        return mCreated;
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeSensor.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeSensor.java
new file mode 100644
index 00000000..e04b7772
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeSensor.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.services.activemode;
+
+import android.content.Context;
+import android.hardware.SensorManager;
+import android.os.Handler;
+import android.os.Message;
+import android.os.PowerManager;
+import android.os.SystemClock;
+
+import java.util.ArrayList;
+
+/**
+ * Provides a callback when {@link com.achep.acdisplay.acdisplay.AcDisplayActivity}
+ * should be started and stopped.
+ *
+ * @author Artem Chepurnoy
+ */
+public abstract class ActiveModeSensor {
+
+    int mAttachedNumber;
+    private Context mContext;
+    private SensorManager mSensorManager;
+
+    private final ArrayList<Callback> mCallbacks;
+
+    /**
+     * Provides a callback when AcDisplay should be shown / hidden.
+     *
+     * @author Artem Chepurnoy
+     */
+    public interface Callback {
+
+        /**
+         * Requests to show the AcDisplay.
+         */
+        public void onWakeRequested(ActiveModeSensor sensor);
+
+    }
+
+    protected ActiveModeSensor() {
+        mCallbacks = new ArrayList<>(4);
+    }
+
+    /**
+     * Registers given callback to listen to this sensor.
+     * You must call {@link #unregisterCallback(ActiveModeSensor.Callback)}
+     * later.
+     *
+     * @see #unregisterCallback(ActiveModeSensor.Callback)
+     */
+    public void registerCallback(Callback callback) {
+        mCallbacks.add(callback);
+    }
+
+    /**
+     * Unregisters given callback from this sensor.
+     *
+     * @see #registerCallback(ActiveModeSensor.Callback)
+     */
+    public void unregisterCallback(Callback callback) {
+        mCallbacks.remove(callback);
+    }
+
+    protected void requestWakeUp/*, Neo!*/() {
+        for (Callback callback : mCallbacks) {
+            callback.onWakeRequested(this);
+        }
+    }
+
+    /**
+     * Checks if this sensor is supported by device.
+     * By default it does the following code:
+     * {@code sensorManager.getSensorList(getType()).size() > 0}
+     *
+     * @return {@code true} if the sensor is supported by device, {@code false} otherwise.
+     */
+    protected boolean isSupported(SensorManager sensorManager, Context context) {
+        return sensorManager.getSensorList(getType()).size() > 0;
+    }
+
+    /**
+     * @return The type of used sensor.
+     * @see android.hardware.Sensor#TYPE_ACCELEROMETER
+     * @see android.hardware.Sensor#TYPE_PROXIMITY
+     */
+    public abstract int getType();
+
+    public abstract void onStart();
+
+    public abstract void onStop();
+
+    /**
+     * Called when the sensor is attached to main class.
+     */
+    public void onAttached(SensorManager sensorManager, Context context) {
+        // Register sensors only once.
+        if (mAttachedNumber++ > 0) {
+            return;
+        }
+
+        setup(sensorManager, context);
+        onStart();
+    }
+
+    /**
+     * Called when the sensor is detached from main class.
+     */
+    public void onDetached() {
+        if (--mAttachedNumber > 0) {
+            return;
+        }
+
+        onStop();
+        setup(null, null);
+    }
+
+    void setup(SensorManager sensorManager, Context context) {
+        mContext = context;
+        mSensorManager = sensorManager;
+    }
+
+    public boolean isAttached() {
+        return mAttachedNumber > 0;
+    }
+
+    public Context getContext() {
+        return mContext;
+    }
+
+    public SensorManager getSensorManager() {
+        return mSensorManager;
+    }
+
+    /**
+     * @return {@code SystemClock.elapsedRealtime()}
+     */
+    protected static long getTimeNow() {
+        return SystemClock.elapsedRealtime();
+    }
+
+    public abstract static class Consuming extends ActiveModeSensor {
+
+        private static final String TAG = "ConsumingSensor";
+        private static final String WAKE_LOCK_TAG = TAG;
+
+        private static final int START = 0;
+        private static final int STOP = 1;
+
+        private PowerManager.WakeLock mWakeLock;
+        private boolean mRunning;
+        private final Handler mHandler = new Handler() {
+            @Override
+            public void handleMessage(Message msg) {
+                super.handleMessage(msg);
+                switch (msg.what) {
+                    case START:
+                        mRunning = true;
+                        onStart();
+                        break;
+                    case STOP:
+                        mRunning = false;
+                        onStop();
+                        break;
+                }
+            }
+        };
+
+        public abstract int getRemainingTime();
+
+        @Override
+        public void onAttached(SensorManager sensorManager, Context context) {
+            // Register sensors only once.
+            if (mAttachedNumber++ > 0) {
+                return;
+            }
+
+            setup(sensorManager, context);
+        }
+
+        @Override
+        public void onDetached() {
+            if (--mAttachedNumber > 0) {
+                return;
+            }
+
+            if (mRunning) { // Now die
+                mHandler.sendEmptyMessage(STOP);
+                mHandler.removeCallbacksAndMessages(null);
+            }
+
+            setup(null, null);
+        }
+
+        public void ping() {
+            int remainingTime = getRemainingTime();
+
+            if (mWakeLock != null && mWakeLock.isHeld()) {
+                mWakeLock.release();
+            }
+
+            PowerManager pm = (PowerManager) getContext().getSystemService(Context.POWER_SERVICE);
+            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKE_LOCK_TAG);
+            mWakeLock.acquire(remainingTime);
+
+            if (!mRunning) {
+                mHandler.sendEmptyMessage(START);
+            }
+
+            mHandler.removeMessages(STOP);
+            mHandler.sendEmptyMessageDelayed(STOP, remainingTime);
+        }
+    }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeService.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeService.java
similarity index 63%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeService.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeService.java
index 63b0c80f..a789549e 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/ActiveModeService.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeService.java
@@ -16,39 +16,38 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.activemode;
+package com.achep.acdisplay.services.activemode;
 
-import android.app.Notification;
-import android.app.PendingIntent;
-import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
 import android.hardware.SensorManager;
-import android.os.IBinder;
 import android.util.Log;
 
-import com.achep.acdisplay.App;
 import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.Presenter;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.activemode.handlers.InactiveTimeHandler;
-import com.achep.acdisplay.activemode.handlers.ScreenHandler;
-import com.achep.acdisplay.activemode.handlers.WithoutNotifiesHandler;
-import com.achep.acdisplay.activemode.sensors.AccelerometerSensor;
-import com.achep.acdisplay.activemode.sensors.ProximitySensor;
-import com.achep.acdisplay.settings.Settings;
+import com.achep.acdisplay.notifications.NotificationPresenter;
+import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.acdisplay.services.BathService;
+import com.achep.acdisplay.services.activemode.handlers.InactiveTimeHandler;
+import com.achep.acdisplay.services.activemode.handlers.ScreenHandler;
+import com.achep.acdisplay.services.activemode.handlers.WithoutNotifiesHandler;
+import com.achep.acdisplay.services.activemode.sensors.AccelerometerSensor;
+import com.achep.acdisplay.services.activemode.sensors.GyroscopeSensor;
+import com.achep.acdisplay.services.activemode.sensors.ProximitySensor;
 import com.achep.acdisplay.utils.PowerUtils;
 
 /**
  * Service that turns on AcDisplay exactly when it's needed.
  *
  * @author Artem Chepurnoy
- * @see com.achep.acdisplay.activemode.ActiveModeHandler
- * @see com.achep.acdisplay.activemode.ActiveModeSensor
+ * @see com.achep.acdisplay.services.activemode.ActiveModeHandler
+ * @see com.achep.acdisplay.services.activemode.ActiveModeSensor
  */
-public class ActiveModeService extends Service implements
-        ActiveModeSensor.Callback, ActiveModeHandler.Callback {
+public class ActiveModeService extends BathService.ChildService implements
+        ActiveModeSensor.Callback, ActiveModeHandler.Callback,
+        NotificationPresenter.OnNotificationListChangedListener {
 
     private static final String TAG = "ActiveModeService";
 
@@ -70,9 +69,9 @@ public class ActiveModeService extends Service implements
         if (config.isEnabled()
                 && config.isActiveModeEnabled()
                 && onlyWhileChangingOption) {
-            context.startService(intent);
+            BathService.startService(context, ActiveModeService.class);
         } else {
-            context.stopService(intent);
+            BathService.stopService(context, ActiveModeService.class);
         }
     }
 
@@ -83,9 +82,10 @@ public class ActiveModeService extends Service implements
      * @see ActiveModeSensor
      */
     public static ActiveModeSensor[] buildAvailableSensorsList(Context context) {
-        SensorManager sensorManager = (SensorManager) context.getSystemService(SENSOR_SERVICE);
+        SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
         ActiveModeSensor[] sensors = new ActiveModeSensor[]{ // all available sensors
                 AccelerometerSensor.getInstance(),
+                GyroscopeSensor.getInstance(),
                 ProximitySensor.getInstance()
         };
 
@@ -113,54 +113,54 @@ public class ActiveModeService extends Service implements
 
     @Override
     public void onCreate() {
-        super.onCreate();
-        mSensors = buildAvailableSensorsList(this);
+        Context context = getContext();
+        mSensors = buildAvailableSensorsList(context);
         mHandlers = new ActiveModeHandler[]{
-                new ScreenHandler(this, this),
-                new InactiveTimeHandler(this, this),
-                new WithoutNotifiesHandler(this, this),
+                new ScreenHandler(context, this),
+                new InactiveTimeHandler(context, this),
+                new WithoutNotifiesHandler(context, this),
         };
 
         for (ActiveModeHandler handler : mHandlers) {
-            handler.onCreate();
+            handler.create();
         }
 
         requestActive();
+
+        NotificationPresenter.getInstance().registerListener(this);
     }
 
     @Override
     public void onDestroy() {
-        super.onDestroy();
         for (ActiveModeHandler handler : mHandlers) {
-            handler.onDestroy();
+            handler.destroy();
         }
 
         stopListening();
+
+        NotificationPresenter.getInstance().unregisterListener(this);
+    }
+
+    @Override
+    public String getName() {
+        return getContext().getString(R.string.service_bath_active_mode);
     }
 
     @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-
-        // Show foreground notification to prove that
-        // this service will not be killed when system
-        // needs some RAM or whatever.
-        int notificationId = App.ID_NOTIFY_ACTIVE_MODE;
-        PendingIntent pendingIntent = PendingIntent.getActivity(this,
-                notificationId, new Intent(this, Settings.ActiveModeSettingsActivity.class),
-                PendingIntent.FLAG_UPDATE_CURRENT);
-        Notification notification = new Notification.Builder(this)
-                .setSmallIcon(R.drawable.stat_active)
-                .setContentTitle(getString(
-                        R.string.service_active_mode,
-                        getString(R.string.app_name)))
-                .setContentText(getString(R.string.service_active_mode_text))
-                .setPriority(Notification.PRIORITY_MIN)
-                .setContentIntent(pendingIntent)
-                .setOngoing(true)
-                .build();
-
-        startForeground(notificationId, notification);
-        return Service.START_STICKY;
+    public void onNotificationListChanged(NotificationPresenter np,
+                                          OpenNotification osbn, int event) {
+        if (Config.getInstance().isNotifyWakingUp()) {
+            // Notification will wake up device without
+            // any sensors' callback.
+            return;
+        }
+
+        switch (event) {
+            case NotificationPresenter.EVENT_CHANGED:
+            case NotificationPresenter.EVENT_POSTED:
+                pingConsumingSensors();
+                break;
+        }
     }
 
     @Override
@@ -171,7 +171,7 @@ public class ActiveModeService extends Service implements
 
         // Check through all available handlers.
         for (ActiveModeHandler handler : mHandlers) {
-            if (!handler.isActive()) {
+            if (!handler.isCreated() || !handler.isActive()) {
                 return;
             }
         }
@@ -194,9 +194,8 @@ public class ActiveModeService extends Service implements
         if (!mListening & !(mListening = false)) return;
         if (Build.DEBUG) Log.d(TAG, "Stopping listening to sensors.");
 
-        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
         for (ActiveModeSensor sensor : mSensors) {
-            sensor.onDetached(sensorManager);
+            sensor.onDetached();
             sensor.unregisterCallback(this);
         }
     }
@@ -211,24 +210,24 @@ public class ActiveModeService extends Service implements
         if (mListening & (mListening = true)) return;
         if (Build.DEBUG) Log.d(TAG, "Starting listening to sensors.");
 
-        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
+        Context context = getContext();
+        SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
         for (ActiveModeSensor sensor : mSensors) {
             sensor.registerCallback(this);
-            sensor.onAttached(sensorManager, this);
+            sensor.onAttached(sensorManager, context);
         }
     }
 
-    @Override
-    public void show(ActiveModeSensor sensor) {
-        Presenter.getInstance().start(this);
+    private void pingConsumingSensors() {
+        for (ActiveModeSensor sensor : mSensors) {
+            if (sensor.isAttached() && sensor instanceof ActiveModeSensor.Consuming) {
+                ((ActiveModeSensor.Consuming) sensor).ping();
+            }
+        }
     }
 
     @Override
-    public void hide(ActiveModeSensor sensor) { /* handled by AcDisplay activity */ }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
+    public void onWakeRequested(ActiveModeSensor sensor) {
+        Presenter.getInstance().start(getContext());
     }
-
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/InactiveTimeHandler.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/InactiveTimeHandler.java
similarity index 87%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/InactiveTimeHandler.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/InactiveTimeHandler.java
index 59beee9a..8cbe9b7b 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/InactiveTimeHandler.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/InactiveTimeHandler.java
@@ -17,7 +17,7 @@
  * MA  02110-1301, USA.
  */
 
-package com.achep.acdisplay.activemode.handlers;
+package com.achep.acdisplay.services.activemode.handlers;
 
 import android.content.Context;
 import android.os.SystemClock;
@@ -25,18 +25,18 @@ import android.util.Log;
 
 import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.InactiveHoursHelper;
-import com.achep.acdisplay.activemode.ActiveModeHandler;
+import com.achep.acdisplay.InactiveTimeHelper;
+import com.achep.acdisplay.services.activemode.ActiveModeHandler;
 
 import java.util.Timer;
 import java.util.TimerTask;
 
 /**
- * Prevents {@link com.achep.acdisplay.activemode.ActiveModeService} from listening to
+ * Prevents {@link com.achep.acdisplay.services.activemode.ActiveModeService} from listening to
  * sensors on inactive time (if corresponding option is enabled.)
  *
  * @author Artem Chepurnoy
- * @see com.achep.acdisplay.settings.MoreFragment
+ * @see com.achep.acdisplay.settings.MoreSettings
  */
 // TODO: Implement event based inactive time handling.
 public final class InactiveTimeHandler extends ActiveModeHandler implements
@@ -54,13 +54,13 @@ public final class InactiveTimeHandler extends ActiveModeHandler implements
     @Override
     public void onCreate() {
         mConfig = Config.getInstance();
-        mConfig.addOnConfigChangedListener(this);
+        mConfig.registerListener(this);
         updateState();
     }
 
     @Override
     public void onDestroy() {
-        mConfig.removeOnConfigChangedListener(this);
+        mConfig.unregisterListener(this);
 
         if (mTimer != null) {
             mTimer.cancel();
@@ -71,7 +71,7 @@ public final class InactiveTimeHandler extends ActiveModeHandler implements
     @Override
     public boolean isActive() {
         boolean enabled = mConfig.isInactiveTimeEnabled();
-        return !enabled || !InactiveHoursHelper.isInactiveTime(mConfig);
+        return !enabled || !InactiveTimeHelper.isInactiveTime(mConfig);
     }
 
     private void updateState() {
@@ -90,7 +90,7 @@ public final class InactiveTimeHandler extends ActiveModeHandler implements
 
                 @Override
                 public void run() {
-                    boolean inactive = InactiveHoursHelper.isInactiveTime(mConfig);
+                    boolean inactive = InactiveTimeHelper.isInactiveTime(mConfig);
                     boolean changed = inactive != inactivePrev || firstTick;
 
                     firstTick = false;
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/ScreenHandler.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/ScreenHandler.java
similarity index 88%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/ScreenHandler.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/ScreenHandler.java
index 46cd5119..9daf5b04 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/ScreenHandler.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/ScreenHandler.java
@@ -17,25 +17,25 @@
  * MA  02110-1301, USA.
  */
 
-package com.achep.acdisplay.activemode.handlers;
+package com.achep.acdisplay.services.activemode.handlers;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 
-import com.achep.acdisplay.activemode.ActiveModeHandler;
+import com.achep.acdisplay.services.activemode.ActiveModeHandler;
 import com.achep.acdisplay.utils.PowerUtils;
 
 /**
- * Prevents {@link com.achep.acdisplay.activemode.ActiveModeService} from listening to
+ * Prevents {@link com.achep.acdisplay.services.activemode.ActiveModeService} from listening to
  * sensors while screen is turned on.
  *
  * @author Artem Chepurnoy
  */
 public final class ScreenHandler extends ActiveModeHandler {
 
-    private Receiver mReceiver = new Receiver();
+    private final Receiver mReceiver = new Receiver();
 
     private class Receiver extends BroadcastReceiver {
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/WithoutNotifiesHandler.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/WithoutNotifiesHandler.java
similarity index 75%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/WithoutNotifiesHandler.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/WithoutNotifiesHandler.java
index 46c49ea2..70021e48 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/handlers/WithoutNotifiesHandler.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/handlers/WithoutNotifiesHandler.java
@@ -17,21 +17,21 @@
  * MA  02110-1301, USA.
  */
 
-package com.achep.acdisplay.activemode.handlers;
+package com.achep.acdisplay.services.activemode.handlers;
 
 import android.content.Context;
 
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.activemode.ActiveModeHandler;
 import com.achep.acdisplay.notifications.NotificationPresenter;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
+import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.acdisplay.services.activemode.ActiveModeHandler;
 
 /**
- * Prevents {@link com.achep.acdisplay.activemode.ActiveModeService} from listening to
+ * Prevents {@link com.achep.acdisplay.services.activemode.ActiveModeService} from listening to
  * sensors while notification list is empty (if corresponding option is enabled.)
  *
  * @author Artem Chepurnoy
- * @see com.achep.acdisplay.settings.ActiveFragment
+ * @see com.achep.acdisplay.settings.ActiveModeSettings
  */
 public final class WithoutNotifiesHandler extends ActiveModeHandler implements
         NotificationPresenter.OnNotificationListChangedListener,
@@ -47,17 +47,16 @@ public final class WithoutNotifiesHandler extends ActiveModeHandler implements
     @Override
     public void onCreate() {
         mConfig = Config.getInstance();
-        mConfig.addOnConfigChangedListener(this);
+        mConfig.registerListener(this);
 
         mNotificationPresenter = NotificationPresenter.getInstance();
-        mNotificationPresenter.addOnNotificationListChangedListener(this);
-        updateState();
+        mNotificationPresenter.registerListener(this);
     }
 
     @Override
     public void onDestroy() {
-        mConfig.removeOnConfigChangedListener(this);
-        mNotificationPresenter.removeOnNotificationListChangedListener(this);
+        mConfig.unregisterListener(this);
+        mNotificationPresenter.unregisterListener(this);
     }
 
     @Override
@@ -66,14 +65,6 @@ public final class WithoutNotifiesHandler extends ActiveModeHandler implements
         return enabled || mNotificationPresenter.getList().size() > 0;
     }
 
-    private void updateState() {
-        if (isActive()) {
-            requestActive();
-        } else {
-            requestInactive();
-        }
-    }
-
     @Override
     public void onConfigChanged(Config config, String key, Object value) {
         switch (key) {
@@ -84,7 +75,7 @@ public final class WithoutNotifiesHandler extends ActiveModeHandler implements
                     // If you've disabled the active mode, check the
                     // amount of notifications and probably stop
                     // listening.
-                    updateState();
+                    requestActive();
                 }
                 break;
         }
@@ -92,13 +83,13 @@ public final class WithoutNotifiesHandler extends ActiveModeHandler implements
 
     @Override
     public void onNotificationListChanged(NotificationPresenter np,
-                                          OpenStatusBarNotification osbn,
+                                          OpenNotification osbn,
                                           int event) {
         switch (event) {
             case NotificationPresenter.EVENT_BATH:
             case NotificationPresenter.EVENT_POSTED:
             case NotificationPresenter.EVENT_REMOVED:
-                updateState();
+                requestActive();
                 break;
         }
     }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/sensors/AccelerometerSensor.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/AccelerometerSensor.java
similarity index 67%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/sensors/AccelerometerSensor.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/AccelerometerSensor.java
index 90c4ac0d..8c9c99c7 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/activemode/sensors/AccelerometerSensor.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/AccelerometerSensor.java
@@ -16,39 +16,39 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.activemode.sensors;
+package com.achep.acdisplay.services.activemode.sensors;
 
 import android.content.Context;
 import android.hardware.Sensor;
 import android.hardware.SensorEvent;
 import android.hardware.SensorEventListener;
 import android.hardware.SensorManager;
+import android.util.Log;
 
-import com.achep.acdisplay.activemode.ActiveModeSensor;
+import com.achep.acdisplay.Build;
+import com.achep.acdisplay.services.activemode.ActiveModeSensor;
 
 import java.lang.ref.WeakReference;
 
 /**
  * Basing on results of accelerometer sensor it notifies when
  * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
- * should be shown or hidden.
+ * should be shown.
  *
  * @author Artem Chepurnoy
  */
-public class AccelerometerSensor extends ActiveModeSensor implements
+public final class AccelerometerSensor extends ActiveModeSensor implements
         SensorEventListener {
 
     private static final String TAG = "AccelerometerSensor";
 
     private static WeakReference<AccelerometerSensor> sAccelerometerSensorWeak;
 
-    private int mAttachedNumber;
-
     private AccelerometerSensor() {
         super();
     }
 
-    public static synchronized AccelerometerSensor getInstance() {
+    public static AccelerometerSensor getInstance() {
         AccelerometerSensor sensor = sAccelerometerSensorWeak != null
                 ? sAccelerometerSensorWeak.get() : null;
         if (sensor == null) {
@@ -69,32 +69,24 @@ public class AccelerometerSensor extends ActiveModeSensor implements
     }
 
     @Override
-    public void onAttached(SensorManager sensorManager, Context context) {
-        synchronized (this) {
-            // Register sensors only once.
-            if (mAttachedNumber++ > 0) {
-                return;
-            }
-
-            Sensor accelerationSensor = sensorManager.getDefaultSensor(getType());
-            sensorManager.registerListener(this, accelerationSensor, SensorManager.SENSOR_DELAY_NORMAL);
-        }
+    public void onStart() {
+        if (Build.DEBUG) Log.d(TAG, "Starting accelerometer sensor...");
+
+        SensorManager sensorManager = getSensorManager();
+        Sensor accelerationSensor = sensorManager.getDefaultSensor(getType());
+        sensorManager.registerListener(this, accelerationSensor, SensorManager.SENSOR_DELAY_NORMAL);
     }
 
     @Override
-    public void onDetached(SensorManager sensorManager) {
-        synchronized (this) {
-            if (--mAttachedNumber > 0) {
-                return;
-            }
+    public void onStop() {
+        if (Build.DEBUG) Log.d(TAG, "Stopping accelerometer sensor...");
 
-            sensorManager.unregisterListener(this);
-        }
+        SensorManager sensorManager = getSensorManager();
+        sensorManager.unregisterListener(this);
     }
 
     @Override
-    public void onSensorChanged(SensorEvent event) {
-    }
+    public void onSensorChanged(SensorEvent event) { /* placeholder */ }
 
     @Override
     public void onAccuracyChanged(Sensor sensor, int accuracy) { /* unused */ }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/GyroscopeSensor.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/GyroscopeSensor.java
new file mode 100644
index 00000000..170ab335
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/GyroscopeSensor.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.services.activemode.sensors;
+
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.util.Log;
+
+import com.achep.acdisplay.Build;
+import com.achep.acdisplay.services.activemode.ActiveModeSensor;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * Basing on results of accelerometer sensor it notifies when
+ * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
+ * should be shown.
+ *
+ * @author Artem Chepurnoy
+ */
+public final class GyroscopeSensor extends ActiveModeSensor.Consuming implements
+        SensorEventListener {
+
+    private static final String TAG = "GyroscopeSensor";
+
+    private static WeakReference<GyroscopeSensor> sGyroscopeSensorWeak;
+
+    private GyroscopeSensor() {
+        super();
+    }
+
+    public static GyroscopeSensor getInstance() {
+        GyroscopeSensor sensor = sGyroscopeSensorWeak != null
+                ? sGyroscopeSensorWeak.get() : null;
+        if (sensor == null) {
+            sensor = new GyroscopeSensor();
+            sGyroscopeSensorWeak = new WeakReference<>(sensor);
+        }
+        return sensor;
+    }
+
+    @Override
+    public int getType() {
+        return Sensor.TYPE_GYROSCOPE;
+    }
+
+    @Override
+    public int getRemainingTime() {
+        return 10000; // 10 sec.
+    }
+
+    @Override
+    public void onStart() {
+        if (Build.DEBUG) Log.d(TAG, "Starting gyroscope sensor...");
+
+        SensorManager sensorManager = getSensorManager();
+        Sensor accelerationSensor = sensorManager.getDefaultSensor(getType());
+        sensorManager.registerListener(this, accelerationSensor, SensorManager.SENSOR_DELAY_GAME);
+    }
+
+    @Override
+    public void onStop() {
+        if (Build.DEBUG) Log.d(TAG, "Stopping gyroscope sensor...");
+
+        SensorManager sensorManager = getSensorManager();
+        sensorManager.unregisterListener(this);
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) { /* placeholder */ }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) { /* unused */ }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/ProximitySensor.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/ProximitySensor.java
new file mode 100644
index 00000000..fcf1af8f
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/activemode/sensors/ProximitySensor.java
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.services.activemode.sensors;
+
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.os.Handler;
+import android.util.Log;
+
+import com.achep.acdisplay.Build;
+import com.achep.acdisplay.services.activemode.ActiveModeSensor;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+/**
+ * Basing on results of proximity sensor it notifies when
+ * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
+ * should be shown.
+ *
+ * @author Artem Chepurnoy
+ */
+public final class ProximitySensor extends ActiveModeSensor implements
+        SensorEventListener {
+
+    private static final String TAG = "ProximitySensor";
+
+    private static final int LAST_EVENT_MAX_TIME = 1000; // ms.
+
+    private static WeakReference<ProximitySensor> sProximitySensorWeak;
+    private static long sLastEventTime;
+    private static boolean sAttached;
+    private static boolean sNear;
+
+    private float mMaximumRange;
+    private boolean mFirstChange;
+
+    private final ArrayList<Program> mPrograms;
+    private final ArrayList<Event> mHistory;
+    private final Handler mHandler;
+    private int mHistoryMaximumSize;
+
+    private static class Program {
+
+        final Data[] mDatas;
+
+        private static class Data {
+            final boolean isNear;
+            final int timeMin;
+            final long timeMax;
+
+            public Data(boolean isNear, int timeMin, long timeMax) {
+                this.isNear = isNear;
+                this.timeMin = timeMin;
+                this.timeMax = timeMax;
+            }
+        }
+
+        private Program(Data[] datas) {
+            mDatas = datas;
+        }
+
+        public int fits(ArrayList<Event> history) {
+            int historySize = history.size();
+            int programSize = mDatas.length;
+            if (historySize < programSize) {
+                return -1;
+            }
+
+            int historyOffset = historySize - programSize;
+            Event eventPrevious = history.get(historyOffset);
+
+            for (int i = 1; i < programSize; i++) {
+                Data data = mDatas[i - 1];
+                Event eventFuture = history.get(historyOffset + i);
+
+                final long delta = eventFuture.time - eventPrevious.time;
+
+                if (eventPrevious.isNear != data.isNear
+                        || delta <= data.timeMin
+                        || delta >= data.timeMax) {
+                    return -1;
+                }
+
+                eventPrevious = eventFuture;
+            }
+
+            Data data = mDatas[programSize - 1];
+            if (eventPrevious.isNear == data.isNear) {
+                return data.timeMin;
+            }
+
+            return -1;
+        }
+
+        public static class Builder {
+
+            private final ArrayList<Data> mProgram = new ArrayList<>(10);
+            private boolean mLastNear;
+
+            public Builder begin(boolean isNear, int timeMin) {
+                return add(isNear, timeMin, Long.MAX_VALUE);
+            }
+
+            public Builder add(int timeMin, long timeMax) {
+                return add(!mLastNear, timeMin, timeMax);
+            }
+
+            public Builder end(int timeMin) {
+                return add(timeMin, 0);
+            }
+
+            private Builder add(boolean isNear, int timeMin, long timeMax) {
+                Data data = new Data(isNear, timeMin, timeMax);
+                mProgram.add(data);
+                mLastNear = isNear;
+                return this;
+            }
+
+            public Program build() {
+                return new Program(mProgram.toArray(new Data[mProgram.size()]));
+            }
+
+        }
+
+    }
+
+    /**
+     * Proximity event.
+     */
+    private static class Event {
+        final boolean isNear;
+        final long time;
+
+        public Event(boolean isNear, long time) {
+            this.isNear = isNear;
+            this.time = time;
+        }
+
+    }
+
+    private ProximitySensor() {
+        super();
+        Program programPocket = new Program.Builder()
+                .begin(true, 3000) /* is near at least for 3 seconds */
+                .end(0) /* and after: is far  at least for 0 seconds */
+                .build();
+        Program programWave2Wake = new Program.Builder()
+                .begin(true, 200) /*        is near at least for 200 millis */
+                .add(0, 1000) /* and after: is far  not more than 1 second  */
+                .add(0, 1000) /* and after: is near not more than 1 second  */
+                .end(0)       /* and after: is far  at least for  0 second  */
+                .build();
+
+        mPrograms = new ArrayList<>();
+        mPrograms.add(programWave2Wake);
+        mPrograms.add(programPocket);
+
+        for (Program program : mPrograms) {
+            int size = program.mDatas.length;
+            if (size > mHistoryMaximumSize) {
+                mHistoryMaximumSize = size;
+            }
+        }
+
+        mHistory = new ArrayList<>(mHistoryMaximumSize);
+        mHandler = new Handler();
+    }
+
+    public static ProximitySensor getInstance() {
+        ProximitySensor sensor = sProximitySensorWeak != null
+                ? sProximitySensorWeak.get() : null;
+        if (sensor == null) {
+            sensor = new ProximitySensor();
+            sProximitySensorWeak = new WeakReference<>(sensor);
+        }
+        return sensor;
+    }
+
+    /**
+     * @return {@code true} if sensor is currently in "near" state, and {@code false} otherwise.
+     */
+    public static boolean isNear() {
+        return (getTimeNow() - sLastEventTime < LAST_EVENT_MAX_TIME || sAttached) && sNear;
+    }
+
+    @Override
+    public int getType() {
+        return Sensor.TYPE_PROXIMITY;
+    }
+
+    @Override
+    public void onStart() {
+        if (Build.DEBUG) Log.d(TAG, "Starting proximity sensor...");
+
+        SensorManager sensorManager = getSensorManager();
+        Sensor proximitySensor = sensorManager.getDefaultSensor(getType());
+        sensorManager.registerListener(this, proximitySensor, SensorManager.SENSOR_DELAY_NORMAL);
+
+        mMaximumRange = proximitySensor.getMaximumRange();
+        mHistory.clear();
+        mHistory.add(new Event(false, getTimeNow()));
+
+        sAttached = true;
+        mFirstChange = true;
+    }
+
+    @Override
+    public void onStop() {
+        if (Build.DEBUG) Log.d(TAG, "Stopping proximity sensor...");
+
+        SensorManager sensorManager = getSensorManager();
+        sensorManager.unregisterListener(this);
+        mHandler.removeCallbacksAndMessages(null);
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        final float distance = event.values[0];
+        final boolean isNear = distance < mMaximumRange || distance < 1.0f;
+        final boolean changed = sNear != (sNear = isNear) || mFirstChange;
+
+        long now = getTimeNow();
+        if (Build.DEBUG) {
+            int historySize = mHistory.size();
+            String delta = (historySize > 0
+                    ? " delta=" + (now - mHistory.get(historySize - 1).time)
+                    : " first_event");
+            Log.d(TAG + ":SensorEvent", "distance=" + distance
+                    + " is_near=" + isNear
+                    + " changed=" + changed
+                    + delta);
+        }
+
+        if (!changed) {
+            // Well just in cause if proximity sensor is NOT always eventual.
+            // This should not happen, but who knows... I found maximum
+            // range buggy enough.
+            return;
+        }
+
+        if (mHistory.size() >= mHistoryMaximumSize)
+            mHistory.remove(0);
+
+        mHandler.removeCallbacksAndMessages(null);
+        mHistory.add(new Event(isNear, now));
+        for (Program program : mPrograms) {
+            int delay = program.fits(mHistory);
+            if (delay >= 0) {
+                mHandler.postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        mHandler.removeCallbacksAndMessages(null);
+                        mHistory.clear();
+                        requestWakeUp();
+                    }
+                }, delay);
+            }
+        }
+
+        sLastEventTime = now;
+        mFirstChange = false;
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) { /* unused */ }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/media/MediaController.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/media/MediaController.java
new file mode 100644
index 00000000..49f5b159
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/media/MediaController.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.services.media;
+
+import android.annotation.TargetApi;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.media.MediaMetadataEditor;
+import android.media.MediaMetadataRetriever;
+import android.media.RemoteControlClient;
+import android.media.RemoteController;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.util.Log;
+import android.view.KeyEvent;
+
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.Build;
+import com.achep.acdisplay.Device;
+import com.achep.acdisplay.services.MediaService;
+
+import java.util.ArrayList;
+
+/**
+ * Class-wrapper of {@link android.media.RemoteController}.
+ *
+ * @author Artem Chepurnoy
+ */
+@TargetApi(android.os.Build.VERSION_CODES.KITKAT)
+public class MediaController {
+
+    private static final String TAG = "MediaController";
+    private static final boolean DEBUG = false && Build.DEBUG;
+
+    public static final int EVENT_METADATA_CHANGED = 1;
+    public static final int EVENT_PLAYSTATE_CHANGED = 2;
+    public static final int EVENT_UISTATE_CHANGED = 4;
+
+    public static final int UISTATE_NORMAL = 0;
+    public static final int UISTATE_MUSIC = 1;
+
+    private static final int MSG_MEDIA_HIDE = 0;
+
+    private Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            super.handleMessage(msg);
+            switch (msg.what) {
+                case MSG_MEDIA_HIDE:
+                    mUiState = UISTATE_NORMAL;
+                    notifyListeners(EVENT_UISTATE_CHANGED);
+                    break;
+            }
+        }
+    };
+
+    private Context mContext;
+    protected MediaService mService;
+    protected boolean mBound = false;
+
+    private ArrayList<MediaListener> mListeners = new ArrayList<>();
+    private boolean mStarted;
+
+    private int mCurrentPlayState = RemoteControlClient.PLAYSTATE_STOPPED;
+    private int mUiState = UISTATE_NORMAL;
+
+    private Metadata mMetadata = new Metadata();
+    private RemoteController.MetadataEditor mPopulateMetadataWhenStarted;
+    private RemoteController.OnClientUpdateListener mRCClientUpdateListener =
+            new RemoteController.OnClientUpdateListener() {
+                @Override
+                public void onClientChange(boolean clearing) {
+                    if (clearing) {
+                        clearMetadata();
+                    }
+                }
+
+                @Override
+                public void onClientPlaybackStateUpdate(int state) {
+                    updatePlayPauseState(state);
+                }
+
+                @Override
+                public void onClientPlaybackStateUpdate(int state, long stateChangeTimeMs,
+                                                        long currentPosMs, float speed) {
+                    updatePlayPauseState(state);
+                    // TODO: Bring more music control.
+                }
+
+                @Override
+                public void onClientTransportControlUpdate(int transportControlFlags) {
+                    // TODO: Bring more music control.
+                }
+
+                @Override
+                public void onClientMetadataUpdate(RemoteController.MetadataEditor metadataEditor) {
+                    updateMetadata(metadataEditor);
+                }
+            };
+
+    private ServiceConnection mConnection = new ServiceConnection() {
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            MediaService.B binder = (MediaService.B) service;
+            mService = binder.getService();
+            mService.setRemoteControllerEnabled();
+            mService.setClientUpdateListener(mRCClientUpdateListener);
+
+            mBound = true;
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            mBound = false;
+        }
+    };
+
+
+    /**
+     * Interface definition for a callback to be invoked
+     * when media state changed.
+     *
+     * @see #registerListener(MediaController.MediaListener)
+     * @see #unregisterListener(MediaController.MediaListener)
+     */
+    public interface MediaListener {
+
+        /**
+         * Called when something is changed.
+         *
+         * @param event one of following:
+         *              {@link #EVENT_PLAYSTATE_CHANGED},
+         *              {@link #EVENT_METADATA_CHANGED},
+         *              {@link #EVENT_UISTATE_CHANGED}
+         */
+        void onMediaChanged(MediaController controller, int event);
+    }
+
+    public void registerListener(MediaListener listener) {
+        mListeners.add(listener);
+    }
+
+    public void unregisterListener(MediaListener listener) {
+        mListeners.remove(listener);
+    }
+
+    /**
+     * Notifies all listeners with given {@code event} as a parameter.
+     *
+     * @param event parameter of {@link MediaListener#onMediaChanged(MediaController, int)}.
+     */
+    private void notifyListeners(int event) {
+        for (MediaListener listener : mListeners) {
+            listener.onMediaChanged(this, event);
+        }
+    }
+
+    /**
+     * @see #onStart()
+     * @see #onDestroy()
+     */
+    public void onCreate(Context context) {
+        mContext = context;
+    }
+
+    /**
+     * Called when media controller may register all listeners
+     * and setup all bindings. You must call {@link #onStop()} later!
+     *
+     * @see #onStop()
+     */
+    public void onStart() {
+        mStarted = true;
+
+        if (mPopulateMetadataWhenStarted != null) {
+            updateMetadata(mPopulateMetadataWhenStarted);
+            mPopulateMetadataWhenStarted = null;
+        }
+
+        mMetadata.clear();
+
+        if (Device.hasKitKatApi()) {
+            Intent intent = new Intent(App.ACTION_BIND_MEDIA_CONTROL_SERVICE);
+            mContext.bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
+        }
+    }
+
+    /**
+     * Called when media controller should unregister all listeners
+     * and close all bindings.
+     *
+     * @see #onStart()
+     * @see #onDestroy()
+     */
+    public void onStop() {
+        mStarted = false;
+        mMetadata.clear();
+        mHandler.removeCallbacksAndMessages(null);
+
+        if (Device.hasKitKatApi()) {
+            if (mBound) {
+                mService.setClientUpdateListener(null);
+                mService.setRemoteControllerDisabled();
+            }
+
+            mContext.unbindService(mConnection);
+        }
+    }
+
+    /**
+     *
+     */
+    public void onDestroy() {
+        mContext = null;
+    }
+
+    private void updatePlayPauseState(int state) {
+        if (DEBUG) Log.d(TAG, "state: old=" + mCurrentPlayState + ", state=" + state);
+        if (state == mCurrentPlayState) {
+            return;
+        }
+
+        // boolean clientSupportsSeek = mMetadata != null && mMetadata.duration > 0;
+        // setSeekBarsEnabled(clientSupportsSeek);
+
+        switch (state) {
+            case RemoteControlClient.PLAYSTATE_PLAYING:
+                mHandler.removeMessages(MSG_MEDIA_HIDE);
+                mUiState = UISTATE_MUSIC;
+                notifyListeners(EVENT_UISTATE_CHANGED);
+                break;
+            default:
+
+                // Hide media widget delayed to give user some
+                // time to start playing music.
+                int msg = MSG_MEDIA_HIDE;
+                if (!mHandler.hasMessages(msg)) {
+                    mHandler.sendEmptyMessageDelayed(msg, 3000);
+                }
+                break;
+        }
+
+        mCurrentPlayState = state;
+        notifyListeners(EVENT_PLAYSTATE_CHANGED);
+    }
+
+    public int getPlayState() {
+        return mCurrentPlayState;
+    }
+
+    /**
+     * If {@link #getPlayState() play state} equals to
+     * {@link android.media.RemoteControlClient#PLAYSTATE_PLAYING}, then
+     * ui state is {@link #UISTATE_MUSIC}, otherwise it switches (with a little delay)
+     * to {@link #UISTATE_NORMAL}.
+     *
+     * @return the state of media user interface
+     */
+    public int getUiState() {
+        return mUiState;
+    }
+
+    /**
+     * Clears {@link #mMetadata metadata}. Same as calling
+     * {@link #updateMetadata(android.media.RemoteController.MetadataEditor)}
+     * with {@code null} parameter.
+     *
+     * @see #updateMetadata(android.media.RemoteController.MetadataEditor)
+     */
+    private void clearMetadata() {
+        updateMetadata(null);
+    }
+
+    /**
+     * Updates {@link #mMetadata metadata} from given remote metadata class.
+     * This also updates play state.
+     *
+     * @param data Object of metadata to update from, or {@code null} to clear local metadata.
+     * @see #clearMetadata()
+     */
+    private void updateMetadata(RemoteController.MetadataEditor data) {
+        if (data == null) {
+            mMetadata.clear();
+        } else {
+            if (mStarted) {
+                mMetadata.artist = trim(data.getString(MediaMetadataRetriever.METADATA_KEY_ALBUMARTIST, mMetadata.artist));
+                mMetadata.trackTitle = trim(data.getString(MediaMetadataRetriever.METADATA_KEY_TITLE, mMetadata.trackTitle));
+                mMetadata.albumTitle = trim(data.getString(MediaMetadataRetriever.METADATA_KEY_ALBUM, mMetadata.albumTitle));
+                mMetadata.duration = data.getLong(MediaMetadataRetriever.METADATA_KEY_DURATION, -1);
+                mMetadata.bitmap = data.getBitmap(MediaMetadataEditor.BITMAP_KEY_ARTWORK, mMetadata.bitmap);
+            } else {
+                mPopulateMetadataWhenStarted = data;
+                return;
+            }
+        }
+
+        updatePlayPauseState(mCurrentPlayState);
+        notifyListeners(EVENT_METADATA_CHANGED);
+    }
+
+    /**
+     * @return {@code string == null ? null : string.trim()}
+     */
+    private String trim(String string) {
+        return string == null ? null : string.trim();
+    }
+
+    /**
+     * @return {@link com.achep.acdisplay.services.media.Metadata} of playing track,
+     * or {@code null} if music is not playing.
+     */
+    public Metadata getMetadata() {
+        return mMetadata;
+    }
+
+    /**
+     * Sends media button's click with given key code.
+     *
+     * @param keyCode May be one of media key events.
+     * @see android.view.KeyEvent#KEYCODE_MEDIA_NEXT
+     * @see android.view.KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE
+     * @see android.view.KeyEvent#KEYCODE_MEDIA_PREVIOUS
+     */
+    public void sendMediaButtonClick(int keyCode) {
+        if (Device.hasKitKatApi()) {
+            // TODO We should think about sending these up/down events accurately with touch up/down
+            // on the buttons, but in the near term this will interfere with the long press behavior.
+            // Note from Artem Chepurnoy: This is from Android sources, so check them if this fixed.
+            RemoteController rc = mService.getRemoteController();
+            rc.sendMediaKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));
+            rc.sendMediaKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, keyCode));
+        } else {
+            Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+            KeyEvent keyDown = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
+            KeyEvent keyUp = new KeyEvent(KeyEvent.ACTION_UP, keyCode);
+
+            mContext.sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyDown), null);
+            mContext.sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyUp), null);
+        }
+    }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/services/media/Metadata.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/media/Metadata.java
new file mode 100644
index 00000000..8b75d926
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/services/media/Metadata.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.services.media;
+
+import android.graphics.Bitmap;
+
+/**
+ * Created by achep on 08.06.14.
+ */
+public class Metadata {
+    public String artist;
+    public String trackTitle;
+    public String albumTitle;
+    public Bitmap bitmap;
+    public long duration;
+
+    public void clear() {
+        artist = null;
+        trackTitle = null;
+        albumTitle = null;
+        bitmap = null;
+        duration = -1;
+    }
+
+    @Override
+    public String toString() {
+        return "Metadata[artist=" + artist
+                + " trackTitle=" + trackTitle
+                + " albumTitle=" + albumTitle
+                + " duration=" + duration + "]";
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/ActiveFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/ActiveFragment.java
deleted file mode 100644
index 274bffe1..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/ActiveFragment.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings;
-
-import android.app.ActionBar;
-import android.app.Activity;
-import android.os.Bundle;
-import android.preference.CheckBoxPreference;
-import android.preference.Preference;
-import android.preference.PreferenceFragment;
-import android.widget.Switch;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.settings.enablers.ActiveModeEnabler;
-
-/**
- * Created by Artem on 09.02.14.
- */
-public class ActiveFragment extends PreferenceFragment implements
-        Config.OnConfigChangedListener, Preference.OnPreferenceChangeListener {
-
-    private ActiveModeEnabler mActiveModeEnabler;
-    private CheckBoxPreference mActiveModeWithoutNotifiesPreference;
-
-    private boolean mBroadcasting;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.active_settings);
-
-        Activity activity = getActivity();
-        ActionBar actionBar = activity.getActionBar();
-
-        actionBar.setDisplayShowCustomEnabled(true);
-        actionBar.setCustomView(R.layout.layout_ab_switch);
-        Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
-        mActiveModeEnabler = new ActiveModeEnabler(activity, switch_);
-
-        mActiveModeWithoutNotifiesPreference = (CheckBoxPreference) findPreference(
-                Config.KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS);
-
-        mActiveModeWithoutNotifiesPreference.setOnPreferenceChangeListener(this);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mActiveModeEnabler.resume();
-        Config config = Config.getInstance();
-        config.addOnConfigChangedListener(this);
-
-        updateActiveModeWithoutNotifiesPreference(config);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mActiveModeEnabler.pause();
-        Config config = Config.getInstance();
-        config.removeOnConfigChangedListener(this);
-    }
-
-    @Override
-    public boolean onPreferenceChange(Preference preference, Object newValue) {
-        if (mBroadcasting) {
-            return true;
-        }
-
-        Config config = Config.getInstance();
-        if (preference == mActiveModeWithoutNotifiesPreference) {
-            config.setActiveModeWithoutNotificationsEnabled(getActivity(), (Boolean) newValue, this);
-        } else
-            return false;
-        return true;
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS:
-                updateActiveModeWithoutNotifiesPreference(config);
-                break;
-        }
-    }
-
-    private void updateActiveModeWithoutNotifiesPreference(Config config) {
-        updatePreference(mActiveModeWithoutNotifiesPreference, config.isActiveModeWithoutNotifiesEnabled());
-    }
-
-    private void updatePreference(CheckBoxPreference preference, boolean checked) {
-        mBroadcasting = true;
-        preference.setChecked(checked);
-        mBroadcasting = false;
-    }
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/ActiveModeSettings.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/ActiveModeSettings.java
new file mode 100644
index 00000000..16d35ced
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/ActiveModeSettings.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.settings;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.os.Bundle;
+import android.widget.Switch;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class ActiveModeSettings extends PreferenceFragment {
+
+    private Enabler mActiveModeEnabler;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.active_settings);
+        syncPreference(Config.KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS);
+
+        Activity activity = getActivity();
+        ActionBar actionBar = activity.getActionBar();
+        assert actionBar != null;
+
+        actionBar.setDisplayShowCustomEnabled(true);
+        actionBar.setCustomView(R.layout.layout_ab_switch);
+        Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
+        mActiveModeEnabler = new Enabler(activity, switch_, Config.KEY_ACTIVE_MODE);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mActiveModeEnabler.resume();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mActiveModeEnabler.pause();
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/Enabler.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/Enabler.java
similarity index 59%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/Enabler.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/settings/Enabler.java
index 1a52132e..021ec0c5 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/Enabler.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/Enabler.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.settings.enablers;
+package com.achep.acdisplay.settings;
 
 import android.content.Context;
 import android.widget.CompoundButton;
@@ -27,30 +27,44 @@ import com.achep.acdisplay.Config;
 /**
  * Created by Artem on 21.02.14.
  */
-public abstract class Enabler implements
+public class Enabler implements
         Config.OnConfigChangedListener,
         CompoundButton.OnCheckedChangeListener {
 
-    protected final Context mContext;
-    protected final Config mConfig;
-    protected Switch mSwitch;
+    private final Context mContext;
 
-    public Enabler(Context context, Switch switch_) {
+    private final String mKey;
+    private final Config mConfig;
+    private final Config.Option mOption;
+
+    private Switch mSwitch;
+
+    private boolean mBroadcasting;
+
+    public Enabler(Context context, Switch switch_, String key) {
         mContext = context;
+
+        mKey = key;
         mConfig = Config.getInstance();
+        mOption = mConfig.getHashMap().get(mKey);
+
         mSwitch = switch_;
     }
 
-    abstract protected void updateState();
+    private void updateState() {
+        mBroadcasting = true;
+        mSwitch.setChecked((Boolean) mOption.read(mConfig));
+        mBroadcasting = false;
+    }
 
     public void resume() {
-        mConfig.addOnConfigChangedListener(this);
+        mConfig.registerListener(this);
         mSwitch.setOnCheckedChangeListener(this);
         updateState();
     }
 
     public void pause() {
-        mConfig.removeOnConfigChangedListener(this);
+        mConfig.unregisterListener(this);
         mSwitch.setOnCheckedChangeListener(null);
     }
 
@@ -63,4 +77,20 @@ public abstract class Enabler implements
         mSwitch.setOnCheckedChangeListener(this);
         updateState();
     }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        if (mBroadcasting) {
+            return;
+        }
+
+        mOption.write(mConfig, mContext, isChecked, this);
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        if (mKey.equals(key)) {
+            updateState();
+        }
+    }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/InterfaceFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/InterfaceFragment.java
deleted file mode 100644
index b7192bf2..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/InterfaceFragment.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings;
-
-import android.content.Context;
-import android.os.Bundle;
-import android.preference.CheckBoxPreference;
-import android.preference.MultiSelectListPreference;
-import android.preference.Preference;
-import android.preference.PreferenceFragment;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Operator;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.settings.preferences.IconSizePreference;
-
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Locale;
-import java.util.Set;
-
-/**
- * Interface settings fragment.
- *
- * @author Artem Chepurnoy
- */
-public class InterfaceFragment extends PreferenceFragment implements
-        Preference.OnPreferenceChangeListener,
-        Config.OnConfigChangedListener {
-
-    private CheckBoxPreference mShowWallpaper;
-    private CheckBoxPreference mShadowToggle;
-    private CheckBoxPreference mMirroredTimeoutToggle;
-    private CheckBoxPreference mCircledIconToggle;
-    private CheckBoxPreference mBatteryAlwaysVisibleToggle;
-    private CheckBoxPreference mImmersiveMode;
-    private IconSizePreference mIconSize;
-    private MultiSelectListPreference mDynamicBackground;
-
-    private boolean mBroadcasting;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.interface_settings);
-
-        mShowWallpaper = (CheckBoxPreference) findPreference(
-                Config.KEY_UI_WALLPAPER_SHOWN);
-        mShadowToggle = (CheckBoxPreference) findPreference(
-                Config.KEY_UI_SHADOW_TOGGLE);
-        mDynamicBackground = (MultiSelectListPreference) findPreference(
-                Config.KEY_UI_DYNAMIC_BACKGROUND_MODE);
-        mMirroredTimeoutToggle = (CheckBoxPreference) findPreference(
-                Config.KEY_UI_MIRRORED_TIMEOUT_BAR);
-        mCircledIconToggle = (CheckBoxPreference) findPreference(
-                Config.KEY_UI_NOTIFY_CIRCLED_ICON);
-        mBatteryAlwaysVisibleToggle = (CheckBoxPreference) findPreference(
-                Config.KEY_UI_STATUS_BATTERY_ALWAYS_VISIBLE);
-        mImmersiveMode = (CheckBoxPreference) findPreference(
-                Config.KEY_UI_IMMERSIVE_MODE);
-        mIconSize = (IconSizePreference) findPreference(
-                Config.KEY_UI_ICON_SIZE);
-
-        mShowWallpaper.setOnPreferenceChangeListener(this);
-        mShadowToggle.setOnPreferenceChangeListener(this);
-        mDynamicBackground.setOnPreferenceChangeListener(this);
-        mMirroredTimeoutToggle.setOnPreferenceChangeListener(this);
-        mCircledIconToggle.setOnPreferenceChangeListener(this);
-        mBatteryAlwaysVisibleToggle.setOnPreferenceChangeListener(this);
-        mImmersiveMode.setOnPreferenceChangeListener(this);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        Config config = Config.getInstance();
-        config.addOnConfigChangedListener(this);
-
-        updateShowWallpaperPreference(config);
-        updateShowShadowPreference(config);
-        updateMirroredTimeoutPreference(config);
-        updateCircledIconPreference(config);
-        updateBatteryAlwaysVisiblePreference(config);
-        updateDynamicBackgroundPreference(config);
-        updateImmersiveMode(config);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        Config config = Config.getInstance();
-        config.removeOnConfigChangedListener(this);
-    }
-
-    @Override
-    public boolean onPreferenceChange(Preference preference, Object newValue) {
-        if (mBroadcasting) {
-            return true;
-        }
-
-        Context context = getActivity();
-        Config config = Config.getInstance();
-        if (preference == mShowWallpaper) {
-            config.setWallpaperShown(context, (Boolean) newValue, this);
-        } else if (preference == mShadowToggle) {
-            config.setShadowEnabled(context, (Boolean) newValue, this);
-        } else if (preference == mMirroredTimeoutToggle) {
-            config.setMirroredTimeoutProgressBarEnabled(context, (Boolean) newValue, this);
-        } else if (preference == mCircledIconToggle) {
-            config.setCircledLargeIconEnabled(context, (Boolean) newValue, this);
-        } else if (preference == mBatteryAlwaysVisibleToggle) {
-            config.setBatteryAlwaysVisible(context, (Boolean) newValue, this);
-        } else if (preference == mDynamicBackground) {
-            int mode = 0;
-
-            Set<String> values = (Set<String>) newValue;
-            for (String v : values) {
-                mode |= Integer.parseInt(v);
-            }
-
-            config.setDynamicBackgroundMode(context, mode, this);
-            updateDynamicBackgroundPreferenceSummary(config);
-        } else if (preference == mImmersiveMode){
-            config.setImmersiveMode(context, (Boolean) newValue, this);
-        }else
-            return false;
-        return true;
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_UI_WALLPAPER_SHOWN:
-                updateShowWallpaperPreference(config);
-                break;
-            case Config.KEY_UI_SHADOW_TOGGLE:
-                updateShowShadowPreference(config);
-                break;
-            case Config.KEY_UI_MIRRORED_TIMEOUT_BAR:
-                updateMirroredTimeoutPreference(config);
-                break;
-            case Config.KEY_UI_NOTIFY_CIRCLED_ICON:
-                updateCircledIconPreference(config);
-                break;
-            case Config.KEY_UI_STATUS_BATTERY_ALWAYS_VISIBLE:
-                updateBatteryAlwaysVisiblePreference(config);
-                break;
-            case Config.KEY_UI_DYNAMIC_BACKGROUND_MODE:
-                updateDynamicBackgroundPreference(config);
-                break;
-            case Config.KEY_UI_IMMERSIVE_MODE:
-                updateImmersiveMode(config);
-                break;
-        }
-    }
-
-    private void updateShowWallpaperPreference(Config config) {
-        updatePreference(mShowWallpaper, config.isWallpaperShown());
-    }
-
-    private void updateShowShadowPreference(Config config) {
-        updatePreference(mShadowToggle, config.isShadowEnabled());
-    }
-
-    private void updateMirroredTimeoutPreference(Config config) {
-        updatePreference(mMirroredTimeoutToggle, config.isMirroredTimeoutProgressBarEnabled());
-    }
-
-    private void updateCircledIconPreference(Config config) {
-        updatePreference(mCircledIconToggle, config.isCircledLargeIconEnabled());
-    }
-
-    private void updateBatteryAlwaysVisiblePreference(Config config) {
-        updatePreference(mBatteryAlwaysVisibleToggle, config.isBatteryAlwaysVisible());
-    }
-
-    private void updateImmersiveMode(Config config) {
-        updatePreference(mImmersiveMode, config.isImmersible());
-    }
-
-    private void updatePreference(CheckBoxPreference preference, boolean checked) {
-        mBroadcasting = true;
-        preference.setChecked(checked);
-        mBroadcasting = false;
-    }
-
-    private void updateDynamicBackgroundPreference(Config config) {
-        mBroadcasting = true;
-
-        int mode = config.getDynamicBackgroundMode();
-        String[] values = new String[Integer.bitCount(mode)];
-        for (int i = 1, j = 0; j < values.length; i <<= 1) {
-            if (Operator.bitAnd(mode, i)) {
-                values[j++] = Integer.toString(i);
-            }
-        }
-
-        Set<String> valuesSet = new HashSet<>();
-        Collections.addAll(valuesSet, values);
-        mDynamicBackground.setValues(valuesSet);
-
-        mBroadcasting = false;
-        updateDynamicBackgroundPreferenceSummary(config);
-    }
-
-    private void updateDynamicBackgroundPreferenceSummary(Config config) {
-        CharSequence summary;
-        if (config.getDynamicBackgroundMode() != 0) {
-            CharSequence[] entries = mDynamicBackground.getEntries();
-            CharSequence[] values = mDynamicBackground.getEntryValues();
-            int mode = config.getDynamicBackgroundMode();
-
-            String divider = getString(R.string.settings_multi_list_divider);
-            StringBuilder sb = new StringBuilder();
-            boolean empty = true;
-
-            assert entries != null;
-            assert values != null;
-
-            // Append selected items.
-            for (int i = 0; i < values.length; i++) {
-                int a = Integer.parseInt(values[i].toString());
-                if (Operator.bitAnd(mode, a)) {
-                    if (!empty) {
-                        sb.append(divider);
-                    }
-                    sb.append(entries[i]);
-                    empty = false;
-                }
-            }
-
-            String itemsText = sb.toString().toLowerCase(Locale.getDefault());
-            summary = getString(R.string.settings_dynamic_background_summary, itemsText);
-        } else {
-            summary = getString(R.string.settings_dynamic_background_disabled);
-        }
-        mDynamicBackground.setSummary(summary);
-    }
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/InterfaceSettings.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/InterfaceSettings.java
new file mode 100644
index 00000000..350bd033
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/InterfaceSettings.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.settings;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.preference.MultiSelectListPreference;
+import android.preference.Preference;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.Operator;
+import com.achep.acdisplay.R;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Interface settings fragment.
+ *
+ * @author Artem Chepurnoy
+ */
+public class InterfaceSettings extends PreferenceFragment implements
+        Preference.OnPreferenceChangeListener,
+        Config.OnConfigChangedListener {
+
+    private MultiSelectListPreference mDynamicBackground;
+    private Preference mIconSizePreference;
+
+    private boolean mBroadcasting;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.interface_settings);
+        syncPreference(Config.KEY_UI_WALLPAPER_SHOWN);
+        syncPreference(Config.KEY_UI_SHADOW_TOGGLE);
+        syncPreference(Config.KEY_UI_MIRRORED_TIMEOUT_BAR);
+        syncPreference(Config.KEY_UI_NOTIFY_CIRCLED_ICON);
+        syncPreference(Config.KEY_UI_STATUS_BATTERY_STICKY);
+        syncPreference(Config.KEY_UI_FULLSCREEN);
+
+        mDynamicBackground = (MultiSelectListPreference) findPreference(
+                Config.KEY_UI_DYNAMIC_BACKGROUND_MODE);
+        mIconSizePreference = findPreference("icon_size");
+
+        mDynamicBackground.setOnPreferenceChangeListener(this);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        Config config = getConfig();
+        config.registerListener(this);
+
+        updateDynamicBackgroundPreference(config);
+        updateIconSizeSummary(config);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        Config config = getConfig();
+        config.unregisterListener(this);
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (mBroadcasting) {
+            return true;
+        }
+
+        Context context = getActivity();
+        Config config = Config.getInstance();
+        if (preference == mDynamicBackground) {
+            int mode = 0;
+
+            Set<String> values = (Set<String>) newValue;
+            for (String v : values) {
+                mode |= Integer.parseInt(v);
+            }
+
+            config.setDynamicBackgroundMode(context, mode, this);
+            updateDynamicBackgroundPreferenceSummary(config);
+        } else
+            return false;
+        return true;
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_UI_DYNAMIC_BACKGROUND_MODE:
+                updateDynamicBackgroundPreference(config);
+                break;
+            case Config.KEY_UI_ICON_SIZE:
+                updateIconSizeSummary(config);
+                break;
+        }
+    }
+
+    private void updateIconSizeSummary(Config config) {
+        mIconSizePreference.setSummary(getString(R.string.settings_icon_size_summary,
+                Integer.toString(config.getIconSize(Config.ICON_SIZE_DP))));
+    }
+
+    private void updateDynamicBackgroundPreference(Config config) {
+        mBroadcasting = true;
+
+        int mode = config.getDynamicBackgroundMode();
+        String[] values = new String[Integer.bitCount(mode)];
+        for (int i = 1, j = 0; j < values.length; i <<= 1) {
+            if (Operator.bitAnd(mode, i)) {
+                values[j++] = Integer.toString(i);
+            }
+        }
+
+        Set<String> valuesSet = new HashSet<>();
+        Collections.addAll(valuesSet, values);
+        mDynamicBackground.setValues(valuesSet);
+
+        mBroadcasting = false;
+        updateDynamicBackgroundPreferenceSummary(config);
+    }
+
+    private void updateDynamicBackgroundPreferenceSummary(Config config) {
+        CharSequence summary;
+        if (config.getDynamicBackgroundMode() != 0) {
+            CharSequence[] entries = mDynamicBackground.getEntries();
+            CharSequence[] values = mDynamicBackground.getEntryValues();
+            int mode = config.getDynamicBackgroundMode();
+
+            String divider = getString(R.string.settings_multi_list_divider);
+            StringBuilder sb = new StringBuilder();
+            boolean empty = true;
+
+            assert entries != null;
+            assert values != null;
+
+            // Append selected items.
+            for (int i = 0; i < values.length; i++) {
+                int a = Integer.parseInt(values[i].toString());
+                if (Operator.bitAnd(mode, a)) {
+                    if (!empty) {
+                        sb.append(divider);
+                    }
+                    sb.append(entries[i]);
+                    empty = false;
+                }
+            }
+
+            String itemsText = sb.toString().toLowerCase();
+            summary = getString(R.string.settings_dynamic_background_summary, itemsText);
+        } else {
+            summary = getString(R.string.settings_dynamic_background_disabled);
+        }
+        mDynamicBackground.setSummary(summary);
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/LockscreenFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/KeyguardSettings.java
similarity index 84%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/settings/LockscreenFragment.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/settings/KeyguardSettings.java
index 24b04ced..5fd62b33 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/LockscreenFragment.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/KeyguardSettings.java
@@ -24,15 +24,15 @@ import android.os.Bundle;
 import android.preference.PreferenceFragment;
 import android.widget.Switch;
 
+import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.settings.enablers.LockscreenEnabler;
 
 /**
  * Created by Artem on 09.02.14.
  */
-public class LockscreenFragment extends PreferenceFragment {
+public class KeyguardSettings extends PreferenceFragment {
 
-    private LockscreenEnabler mLockscreenEnabler;
+    private Enabler mKeyguardEnabler;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -41,22 +41,23 @@ public class LockscreenFragment extends PreferenceFragment {
 
         Activity activity = getActivity();
         ActionBar actionBar = activity.getActionBar();
+        assert actionBar != null;
 
         actionBar.setDisplayShowCustomEnabled(true);
         actionBar.setCustomView(R.layout.layout_ab_switch);
         Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
-        mLockscreenEnabler = new LockscreenEnabler(activity, switch_);
+        mKeyguardEnabler = new Enabler(activity, switch_, Config.KEY_KEYGUARD);
     }
 
     @Override
     public void onResume() {
         super.onResume();
-        mLockscreenEnabler.resume();
+        mKeyguardEnabler.resume();
     }
 
     @Override
     public void onPause() {
         super.onPause();
-        mLockscreenEnabler.pause();
+        mKeyguardEnabler.pause();
     }
-}
+}
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/MoreFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/MoreSettings.java
similarity index 61%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/settings/MoreFragment.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/settings/MoreSettings.java
index 88d9a174..ab6513b0 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/MoreFragment.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/MoreSettings.java
@@ -19,10 +19,7 @@
 package com.achep.acdisplay.settings;
 
 import android.os.Bundle;
-import android.preference.CheckBoxPreference;
-import android.preference.ListPreference;
 import android.preference.Preference;
-import android.preference.PreferenceFragment;
 
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
@@ -32,37 +29,30 @@ import com.achep.acdisplay.utils.MathUtils;
 /**
  * Created by Artem on 09.02.14.
  */
-public class MoreFragment extends PreferenceFragment implements
-        Config.OnConfigChangedListener,
-        Preference.OnPreferenceChangeListener {
+public class MoreSettings extends PreferenceFragment implements
+        Config.OnConfigChangedListener {
 
-    private CheckBoxPreference mOnlyWhileChargingPreference;
     private Preference mInactiveHoursPreference;
     private Preference mTimeoutPreference;
 
-    private boolean mBroadcasting;
-
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         addPreferencesFromResource(R.xml.more_settings);
+        syncPreference(Config.KEY_ONLY_WHILE_CHARGING);
+        syncPreference(Config.KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY);
+        syncPreference(Config.KEY_FEEL_WIDGET_PINNABLE);
+        syncPreference(Config.KEY_FEEL_WIDGET_READABLE);
 
         mInactiveHoursPreference = findPreference("inactive_hours");
         mTimeoutPreference = findPreference("timeout");
-
-        mOnlyWhileChargingPreference = (CheckBoxPreference) findPreference(
-                Config.KEY_ONLY_WHILE_CHARGING);
-
-        mOnlyWhileChargingPreference.setOnPreferenceChangeListener(this);
     }
 
     @Override
     public void onResume() {
         super.onResume();
-        Config config = Config.getInstance();
-        config.addOnConfigChangedListener(this);
-
-        updateOnlyWhileChargingPreference(config);
+        Config config = getConfig();
+        config.registerListener(this);
 
         updateInactiveHoursSummary(config);
         updateTimeoutSummary(config);
@@ -71,22 +61,8 @@ public class MoreFragment extends PreferenceFragment implements
     @Override
     public void onPause() {
         super.onPause();
-        Config config = Config.getInstance();
-        config.removeOnConfigChangedListener(this);
-    }
-
-    @Override
-    public boolean onPreferenceChange(Preference preference, Object newValue) {
-        if (mBroadcasting) {
-            return true;
-        }
-
-        Config config = Config.getInstance();
-        if (preference == mOnlyWhileChargingPreference) {
-            config.setActiveDisplayEnabledOnlyWhileCharging(getActivity(), (Boolean) newValue, this);
-        } else
-            return false;
-        return true;
+        Config config = getConfig();
+        config.unregisterListener(this);
     }
 
     @Override
@@ -102,32 +78,9 @@ public class MoreFragment extends PreferenceFragment implements
             case Config.KEY_TIMEOUT_ENABLED:
                 updateTimeoutSummary(config);
                 break;
-            case Config.KEY_ONLY_WHILE_CHARGING:
-                updateOnlyWhileChargingPreference(config);
-                break;
         }
     }
 
-    private void updateOnlyWhileChargingPreference(Config config) {
-        updatePreference(mOnlyWhileChargingPreference, config.isEnabledOnlyWhileCharging());
-    }
-
-    private void updatePreference(CheckBoxPreference preference, boolean checked) {
-        mBroadcasting = true;
-        preference.setChecked(checked);
-        mBroadcasting = false;
-    }
-
-    private void updatePreference(ListPreference preference, int item) {
-        mBroadcasting = true;
-        preference.setValue(Integer.toString(item));
-        mBroadcasting = false;
-    }
-
-    private void updatePreferenceListSummary(ListPreference preference) {
-        preference.setSummary(preference.getEntry());
-    }
-
     private void updateInactiveHoursSummary(Config config) {
         if (config.isInactiveTimeEnabled()) {
             int from = config.getInactiveTimeFrom();
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/NotificationFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/NotificationFragment.java
deleted file mode 100644
index a27ca79b..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/NotificationFragment.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings;
-
-import android.os.Bundle;
-import android.preference.CheckBoxPreference;
-import android.preference.Preference;
-import android.preference.PreferenceFragment;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-
-/**
- * Created by Artem on 09.02.14.
- */
-public class NotificationFragment extends PreferenceFragment implements
-        Preference.OnPreferenceChangeListener,
-        Config.OnConfigChangedListener {
-
-    private CheckBoxPreference mLowPriorityPreference;
-    private CheckBoxPreference mWakeUpOnPreference;
-
-    private boolean mBroadcasting;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.notification_settings);
-
-        mLowPriorityPreference = (CheckBoxPreference) findPreference(
-                Config.KEY_NOTIFY_LOW_PRIORITY);
-        mWakeUpOnPreference = (CheckBoxPreference) findPreference(
-                Config.KEY_NOTIFY_WAKE_UP_ON);
-
-        mLowPriorityPreference.setOnPreferenceChangeListener(this);
-        mWakeUpOnPreference.setOnPreferenceChangeListener(this);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        Config config = Config.getInstance();
-        config.addOnConfigChangedListener(this);
-
-        updateLowPriorityPreference(config);
-        updateWakeUpOnPreference(config);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        Config config = Config.getInstance();
-        config.removeOnConfigChangedListener(this);
-    }
-
-    @Override
-    public boolean onPreferenceChange(Preference preference, Object newValue) {
-        if (mBroadcasting) {
-            return true;
-        }
-
-        Config config = Config.getInstance();
-        if (preference == mLowPriorityPreference) {
-            config.setLowPriorityNotificationsAllowed(getActivity(), (Boolean) newValue, this);
-        } else if (preference == mWakeUpOnPreference) {
-            config.setWakeUpOnNotifyEnabled(getActivity(), (Boolean) newValue, this);
-        } else
-            return false;
-        return true;
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_NOTIFY_LOW_PRIORITY:
-                updateLowPriorityPreference(config);
-                break;
-            case Config.KEY_NOTIFY_WAKE_UP_ON:
-                updateLowPriorityPreference(config);
-                break;
-        }
-    }
-
-    private void updateLowPriorityPreference(Config config) {
-        updatePreference(mLowPriorityPreference, config.isLowPriorityNotificationsAllowed());
-    }
-
-    private void updateWakeUpOnPreference(Config config) {
-        updatePreference(mWakeUpOnPreference, config.isNotifyWakingUp());
-    }
-
-    private void updatePreference(CheckBoxPreference preference, boolean checked) {
-        mBroadcasting = true;
-        preference.setChecked(checked);
-        mBroadcasting = false;
-    }
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/NotificationSettings.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/NotificationSettings.java
new file mode 100644
index 00000000..28bfe485
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/NotificationSettings.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.settings;
+
+import android.os.Bundle;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class NotificationSettings extends PreferenceFragment {
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.notification_settings);
+        syncPreference(Config.KEY_NOTIFY_LOW_PRIORITY);
+        syncPreference(Config.KEY_NOTIFY_WAKE_UP_ON);
+    }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/PreferenceFragment.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/PreferenceFragment.java
new file mode 100644
index 00000000..702159df
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/PreferenceFragment.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.settings;
+
+import android.app.Activity;
+import android.preference.Preference;
+import android.util.Log;
+
+import com.achep.acdisplay.Build;
+import com.achep.acdisplay.Config;
+
+/**
+ * Created by achep on 04.06.14.
+ */
+public class PreferenceFragment extends android.preference.PreferenceFragment {
+
+    private static final String TAG = "PreferenceFragment";
+
+    private Config.Syncer mSyncer;
+    private Config mConfig;
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        mConfig = Config.getInstance();
+        mSyncer = new Config.Syncer(activity, mConfig);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mSyncer.start();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mSyncer.stop();
+    }
+
+    protected Config getConfig() {
+        return mConfig;
+    }
+
+    protected void syncPreference(String key) {
+        Preference preference = findPreference(key);
+        if (preference != null) {
+            mSyncer.addPreference(preference);
+        } else if (Build.DEBUG) {
+            Log.d(TAG, "Tried to sync non-existent preference with config.");
+        }
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/Settings.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/Settings.java
index cb949b71..f645ed6a 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/Settings.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/Settings.java
@@ -41,10 +41,8 @@ import android.widget.ListAdapter;
 import android.widget.Switch;
 import android.widget.TextView;
 
+import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.settings.enablers.ActiveModeEnabler;
-import com.achep.acdisplay.settings.enablers.Enabler;
-import com.achep.acdisplay.settings.enablers.LockscreenEnabler;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -164,11 +162,11 @@ public class Settings extends PreferenceActivity {
     }
 
     private static final String[] ENTRY_FRAGMENTS = {
-            LockscreenFragment.class.getName(),
-            ActiveFragment.class.getName(),
-            NotificationFragment.class.getName(),
-            InterfaceFragment.class.getName(),
-            MoreFragment.class.getName()
+            KeyguardSettings.class.getName(),
+            ActiveModeSettings.class.getName(),
+            NotificationSettings.class.getName(),
+            InterfaceSettings.class.getName(),
+            MoreSettings.class.getName()
     };
 
     @Override
@@ -397,7 +395,7 @@ public class Settings extends PreferenceActivity {
         static int getHeaderType(Header header) {
             if (header.fragment == null && header.intent == null) {
                 return HEADER_TYPE_CATEGORY;
-            } else if (header.id == R.id.lockscreen_settings
+            } else if (header.id == R.id.keyguard_settings
                     || header.id == R.id.active_settings) {
                 return HEADER_TYPE_SWITCH;
             } else {
@@ -438,8 +436,8 @@ public class Settings extends PreferenceActivity {
 
             // Temp Switches provided as placeholder until the adapter replaces these with actual
             // Switches inflated from their layouts. Must be done before adapter is set in super
-            mLockscreenEnabler = new LockscreenEnabler(context, new Switch(context));
-            mActiveEnabler = new ActiveModeEnabler(context, new Switch(context));
+            mLockscreenEnabler = new Enabler(context, new Switch(context), Config.KEY_KEYGUARD);
+            mActiveEnabler = new Enabler(context, new Switch(context), Config.KEY_ACTIVE_MODE);
         }
 
         @Override
@@ -490,7 +488,7 @@ public class Settings extends PreferenceActivity {
                     break;
 
                 case HEADER_TYPE_SWITCH:
-                    if (header.id == R.id.lockscreen_settings) {
+                    if (header.id == R.id.keyguard_settings) {
                         mLockscreenEnabler.setSwitch(holder.switch_);
                     } else if (header.id == R.id.active_settings) {
                         mActiveEnabler.setSwitch(holder.switch_);
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/SubSettings.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/SubSettings.java
index 7a275c0a..63525a84 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/SubSettings.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/SubSettings.java
@@ -29,6 +29,8 @@ import com.achep.acdisplay.Build;
  */
 public class SubSettings extends Settings {
 
+    private static final String TAG = "SubSettings";
+
     @Override
     public boolean onNavigateUp() {
         if (!popFragment()) {
@@ -39,7 +41,7 @@ public class SubSettings extends Settings {
 
     @Override
     protected boolean isValidFragment(String fragmentName) {
-        if (Build.DEBUG) Log.d("SubSettings", "Launching fragment " + fragmentName);
+        if (Build.DEBUG) Log.d(TAG, "Launching fragment " + fragmentName);
         return true;
     }
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/ActiveModeEnabler.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/ActiveModeEnabler.java
deleted file mode 100644
index 01aa1f41..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/ActiveModeEnabler.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings.enablers;
-
-import android.content.Context;
-import android.widget.CompoundButton;
-import android.widget.Switch;
-
-import com.achep.acdisplay.Config;
-
-/**
- * Created by Artem on 21.02.14.
- */
-public final class ActiveModeEnabler extends Enabler {
-
-    private boolean mBroadcasting;
-
-    public ActiveModeEnabler(Context context, Switch switch_) {
-        super(context, switch_);
-    }
-
-    @Override
-    protected void updateState() {
-        mSwitch.setEnabled(mConfig.isEnabled());
-        mBroadcasting = true;
-        mSwitch.setChecked(mConfig.isActiveModeEnabled());
-        mBroadcasting = false;
-    }
-
-    @Override
-    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-        if (mBroadcasting) {
-            return;
-        }
-
-        mConfig.setActiveModeEnabled(mContext, isChecked, this);
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_ENABLED:
-            case Config.KEY_ACTIVE_MODE:
-                updateState();
-                break;
-        }
-    }
-}
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/LockscreenEnabler.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/LockscreenEnabler.java
deleted file mode 100644
index bf187ebb..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/enablers/LockscreenEnabler.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings.enablers;
-
-import android.content.Context;
-import android.widget.CompoundButton;
-import android.widget.Switch;
-
-import com.achep.acdisplay.Config;
-
-/**
- * Created by Artem on 21.02.14.
- */
-public final class LockscreenEnabler extends Enabler {
-
-    private boolean mBroadcasting;
-
-    public LockscreenEnabler(Context context, Switch switch_) {
-        super(context, switch_);
-    }
-
-    @Override
-    protected void updateState() {
-        mSwitch.setEnabled(mConfig.isEnabled());
-        mBroadcasting = true;
-        mSwitch.setChecked(mConfig.isKeyguardEnabled());
-        mBroadcasting = false;
-    }
-
-    @Override
-    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-        if (mBroadcasting) {
-            return;
-        }
-
-        mConfig.setKeyguardEnabled(mContext, isChecked, this);
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_ENABLED:
-            case Config.KEY_KEYGUARD:
-                updateState();
-                break;
-        }
-    }
-}
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/IconSizePreference.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/IconSizePreference.java
index 8bd029a6..8b9fb9f9 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/IconSizePreference.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/IconSizePreference.java
@@ -16,6 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
+
 package com.achep.acdisplay.settings.preferences;
 
 import android.content.Context;
@@ -23,9 +24,11 @@ import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
 import android.preference.DialogPreference;
 import android.util.AttributeSet;
-import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
 import android.widget.SeekBar;
 import android.widget.TextView;
 
@@ -34,12 +37,9 @@ import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
 
 import java.lang.ref.SoftReference;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 
 /**
- * Preference to configure icon sizes.
- * Creates the dialog in settings to change the Icon Size settings.
+ * Preference to configure the size of collapsed views.
  *
  * @author Artem Chepurnoy
  */
@@ -54,10 +54,12 @@ public class IconSizePreference extends DialogPreference implements
     private final String mValueLabel;
     private SoftReference<String>[] mSoftStoredLabels;
 
-    private Group[] mGroups;
-    private int[] mProgresses = new int[1];
     private int mMin;
 
+    private SeekBar mSeekBar;
+    private TextView mValueTextView;
+    private LinearLayout mContainer;
+
     public IconSizePreference(Context context, AttributeSet attrs) {
         super(context, attrs);
 
@@ -66,49 +68,44 @@ public class IconSizePreference extends DialogPreference implements
         mTitle = getDialogTitle();
         setDialogTitle(null);
 
-        mValueLabel = getContext().getResources().getString(R.string.preference_resize_dpi);
+        mValueLabel = context.getResources().getString(R.string.preference_icon_size_dpi);
     }
 
     @Override
     protected View onCreateDialogView() {
+        Resources res = getContext().getResources();
+
         LayoutInflater inflater = (LayoutInflater) getContext()
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        View root = inflater.inflate(R.layout.preference_dialog_resize, null);
+        View root = inflater.inflate(R.layout.preference_dialog_size, null);
         assert root != null;
 
-        mProgresses = new int[1];
-        mGroups = new Group[1];
-        mGroups[0] = new Group(
-                (SeekBar) root.findViewById(R.id.icon_resize_seekbar),
-                (TextView) root.findViewById(R.id.icon_resize_value),
-                "setIconSize", "getIconSize");
-
-        Resources res = getContext().getResources();
-        final int max = res.getInteger(R.integer.config_maxIconSize);
-        mMin = res.getInteger(R.integer.config_minIconSize);
-        mSoftStoredLabels = new SoftReference[max + 1];
+        final int max = res.getInteger(R.integer.config_icon_size_max_dp);
+        mMin = res.getInteger(R.integer.config_icon_size_min_dp);
+        mSoftStoredLabels = new SoftReference[max + 1 - mMin];
 
         Config config = Config.getInstance();
 
-
-        for (Group group : mGroups) {
-            int progress = 0;
-            try {
-                Method method = Config.class.getDeclaredMethod(group.getterName);
-                method.setAccessible(true);
-                progress = (int) method.invoke(config);
-            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
-                e.printStackTrace();
-            }
-
-            group.seekBar.setOnSeekBarChangeListener(this);
-            group.seekBar.setMax(max);
-            group.seekBar.setProgress(progress);
-            Log.e(TAG, "Progress: "+progress);
-            Log.e(TAG, "Min: "+mMin);
-            Log.e(TAG, "Max: "+max);
+        mContainer = (LinearLayout) root.findViewById(R.id.container);
+        mValueTextView = (TextView) root.findViewById(R.id.info);
+        mSeekBar = (SeekBar) root.findViewById(R.id.seek_bar);
+        mSeekBar.setOnSeekBarChangeListener(this);
+        mSeekBar.setMax(max - mMin);
+        mSeekBar.setProgress(config.getIconSize(Config.ICON_SIZE_DP) - mMin);
+
+        // Init preview
+        for (int i = 0; i < 3; i++) {
+            View view = inflater.inflate(R.layout.widget_notification_icon, mContainer, false);
+            view.setBackgroundColor(res.getColor(R.color.selector_pressed_dark));
+            ImageView icon = (ImageView) view.findViewById(R.id.icon);
+            icon.setImageResource(R.drawable.stat_notify);
+            TextView text = (TextView) view.findViewById(R.id.number);
+            text.setText(Integer.toString(i * 3));
+            mContainer.addView(view);
         }
 
+        onStopTrackingTouch(mSeekBar);
+
         // Build custom dialog.
         return new DialogHelper.Builder(getContext())
                 .setIcon(mIcon)
@@ -127,77 +124,43 @@ public class IconSizePreference extends DialogPreference implements
 
         // Save changes to config.
         Config config = Config.getInstance();
-        for (Group group : mGroups) {
-            try {
-                Method method = Config.class.getDeclaredMethod(group.setterName,
-                        Context.class, int.class,
-                        Config.OnConfigChangedListener.class);
-                method.setAccessible(true);
-                method.invoke(config, getContext(), group.seekBar.getProgress(), null);
-            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
-                e.printStackTrace();
-            }
-        }
+        config.setIconSizeDp(getContext(), mSeekBar.getProgress() + mMin, null);
     }
 
     @Override
     public void onProgressChanged(SeekBar seekBar, int progress, boolean byUser) {
-        int i = 0;
-        Group group = null;
-        for (; i < mGroups.length; i++)
-            if (mGroups[i].seekBar == seekBar) {
-                group = mGroups[i];
-                break;
-            }
-        assert group != null;
 
         // Store labels to soft references array
         // to prevent lots of new strings.
         String label;
         SoftReference<String> cached = mSoftStoredLabels[progress];
         if (cached == null || cached.get() == null) {
-            label = String.format(mValueLabel, Float.toString(progress));
+            label = String.format(mValueLabel, Integer.toString(progress + mMin));
             mSoftStoredLabels[progress] = new SoftReference<>(label);
         } else {
             label = cached.get();
         }
 
-        group.textView.setText(label);
-
-        if (!byUser) {
-            return;
-        }
-
-        if (progress < mMin) {
-            seekBar.setProgress(mMin);
-            return;
-        }
+        mValueTextView.setText(label);
     }
 
     @Override
-    public void onStartTrackingTouch(SeekBar seekBar) {
-        for (int i = 0; i < mProgresses.length; i++) {
-            mProgresses[i] = mGroups[i].seekBar.getProgress();
-        }
-    }
+    public void onStartTrackingTouch(SeekBar seekBar) { /* unused */ }
 
     @Override
-    public void onStopTrackingTouch(SeekBar seekBar) { /* unused */ }
-
-    /**
-     * An object to store the seekbars and variables in that are used in the dialog
-     */
-    private static class Group {
-        SeekBar seekBar;
-        TextView textView;
-        String setterName;
-        String getterName;
-
-        public Group(SeekBar seekBar, TextView textView, String setterName, String getterName) {
-            this.seekBar = seekBar;
-            this.textView = textView;
-            this.setterName = setterName;
-            this.getterName = getterName;
+    public void onStopTrackingTouch(SeekBar seekBar) {
+        // Update the preview of the collapsed views
+        // list.
+        float density = getContext().getResources().getDisplayMetrics().density;
+        int size = Math.round((seekBar.getProgress() + mMin) * density);
+        int length = mContainer.getChildCount();
+        for (int i = 0; i < length; i++) {
+            View child = mContainer.getChildAt(i);
+            ViewGroup.LayoutParams lp = child.getLayoutParams();
+            lp.height = size;
+            lp.width = size;
+            child.setLayoutParams(lp);
         }
     }
+
 }
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/InactiveHoursPreference.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/InactiveTimePreference.java
similarity index 84%
rename from project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/InactiveHoursPreference.java
rename to project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/InactiveTimePreference.java
index 8785aabd..ed72add5 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/InactiveHoursPreference.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/InactiveTimePreference.java
@@ -39,8 +39,10 @@ import com.achep.acdisplay.utils.MathUtils;
 
 /**
  * Preference to configure timeouts.
+ *
+ * @author Artem Chepurnoy
  */
-public class InactiveHoursPreference extends DialogPreference implements View.OnClickListener {
+public class InactiveTimePreference extends DialogPreference implements View.OnClickListener {
 
     private static final String TAG = "InactiveHoursPreference";
 
@@ -71,7 +73,7 @@ public class InactiveHoursPreference extends DialogPreference implements View.On
         }
     }
 
-    public InactiveHoursPreference(Context context, AttributeSet attrs) {
+    public InactiveTimePreference(Context context, AttributeSet attrs) {
         super(context, attrs);
 
         // Get data from default dialog and hide it.
@@ -83,9 +85,8 @@ public class InactiveHoursPreference extends DialogPreference implements View.On
     @Override
     protected View onCreateDialogView() {
         Context context = getContext();
-        LayoutInflater inflater = (LayoutInflater) context
-                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        final ViewGroup root = (ViewGroup) inflater.inflate(R.layout.preference_dialog_inactive_hours, null);
+        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        ViewGroup root = (ViewGroup) inflater.inflate(R.layout.preference_dialog_inactive_hours, null);
         assert root != null;
 
         TextView fromTextView = (TextView) root.findViewById(R.id.from);
@@ -132,12 +133,14 @@ public class InactiveHoursPreference extends DialogPreference implements View.On
     public void onClick(View v) {
         final Data data = v == mFrom.labelTextView ? mFrom : mTo;
 
-        TimePickerDialog timePickerDialog = new TimePickerDialog(getContext(), new TimePickerDialog.OnTimeSetListener() {
-            @Override
-            public void onTimeSet(TimePicker timePicker, int selectedHour, int selectedMinute) {
-                data.setTime(getContext(), selectedHour, selectedMinute);
-            }
-        }, data.hours, data.minutes, true);
+        TimePickerDialog timePickerDialog = new TimePickerDialog(getContext(),
+                new TimePickerDialog.OnTimeSetListener() {
+                    @Override
+                    public void onTimeSet(TimePicker timePicker, int selectedHour, int selectedMinute) {
+                        data.setTime(getContext(), selectedHour, selectedMinute);
+                    }
+                }, data.hours, data.minutes, true
+        );
         timePickerDialog.show();
     }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/TimeoutPreference.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/TimeoutPreference.java
index da38dd72..dbf2d4fa 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/TimeoutPreference.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/settings/preferences/TimeoutPreference.java
@@ -71,11 +71,13 @@ public class TimeoutPreference extends DialogPreference implements
         mTitle = getDialogTitle();
         setDialogTitle(null);
 
-        mValueLabel = getContext().getResources().getString(R.string.preference_timeout_sec);
+        mValueLabel = context.getResources().getString(R.string.preference_timeout_sec);
     }
 
     @Override
     protected View onCreateDialogView() {
+        Resources res = getContext().getResources();
+
         LayoutInflater inflater = (LayoutInflater) getContext()
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
         View root = inflater.inflate(R.layout.preference_dialog_timeout, null);
@@ -92,7 +94,6 @@ public class TimeoutPreference extends DialogPreference implements
                 (TextView) root.findViewById(R.id.short_timeout_value),
                 "setTimeoutShort", "getTimeoutShort");
 
-        Resources res = getContext().getResources();
         final int max = res.getInteger(R.integer.config_timeout_maxDurationMillis) / MULTIPLIER;
         mMin = res.getInteger(R.integer.config_timeout_minDurationMillis) / MULTIPLIER;
         mSoftStoredLabels = new SoftReference[max + 1];
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/AccessUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/AccessUtils.java
index 06b6b411..d0f4e9fa 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/AccessUtils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/AccessUtils.java
@@ -23,33 +23,20 @@ import android.content.ComponentName;
 import android.content.Context;
 
 import com.achep.acdisplay.admin.AdminReceiver;
-import com.achep.acdisplay.notifications.NotificationHandleService;
-
-import java.lang.ref.WeakReference;
+import com.achep.acdisplay.services.MediaService;
 
 /**
  * Created by Artem on 23.01.14.
  */
 public class AccessUtils {
 
-    private static WeakReference<ComponentName> mAdminComponentName;
-
-    public static boolean isDeviceAdminEnabled(Context context) {
-        ComponentName admin;
-        if (mAdminComponentName == null || mAdminComponentName.get() == null) {
-            admin = new ComponentName(context, AdminReceiver.class);
-            mAdminComponentName = new WeakReference<>(admin);
-        } else {
-            admin = mAdminComponentName.get();
-        }
-
-        DevicePolicyManager dpm = (DevicePolicyManager)
-                context.getSystemService(Context.DEVICE_POLICY_SERVICE);
-        return dpm.isAdminActive(admin);
+    public static boolean isDeviceAdminAccessGranted(Context context) {
+        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
+        return dpm.isAdminActive(new ComponentName(context, AdminReceiver.class));
     }
 
-    public static boolean isNotificationAccessEnabled(Context context) {
-        return NotificationHandleService.isServiceRunning(context);
+    public static boolean isNotificationAccessGranted(Context context) {
+        return MediaService.sService != null;//.isServiceRunning(context);
     }
 
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java
index 67c24da2..4ed9eb24 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java
@@ -77,6 +77,8 @@ public class BitmapUtils {
         // http://www.kayenko.com
         // ported april 5th, 2012
 
+        // Modified by Artem Chepurnoy <artemchep@gmail.com> for AcDisplay
+
         // This is a compromise between Gaussian Blur and Box blur
         // It creates much better looking blurs than Box Blur, but is
         // 7x faster than my Gaussian Blur implementation.
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/DateUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/DateUtils.java
index bd388fad..233cf15d 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/DateUtils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/DateUtils.java
@@ -29,7 +29,8 @@ import android.text.format.DateFormat;
 public class DateUtils {
 
     /**
-     * Formats given hours and minutes to 24 / 12 hours format (depends on current settings.)
+     * Formats given hours and minutes to 24 / 12 hours format
+     * (depends on current system settings.)
      *
      * @return Formatted string time
      */
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/FileUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/FileUtils.java
index 8b0ac3ed..8a504aba 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/FileUtils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/FileUtils.java
@@ -18,7 +18,16 @@
  */
 package com.achep.acdisplay.utils;
 
+import android.util.Log;
+
+import com.achep.acdisplay.Build;
+
+import java.io.BufferedReader;
 import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
 
 /**
  * Helper class with utils related to file system and files.
@@ -27,10 +36,13 @@ import java.io.File;
  */
 public class FileUtils {
 
+    private static final String TAG = "FileUtils";
+
     /**
      * Deletes all files from given directory recursively.
      *
-     * @return True if all files were deleted successfully, False otherwise or if given file is null.
+     * @return {@code true} if all files were deleted successfully,
+     * {@code false} otherwise or if given file is null.
      */
     public static boolean deleteRecursive(File file) {
         if (file != null) {
@@ -53,4 +65,81 @@ public class FileUtils {
         return false;
     }
 
+    /**
+     * Writes given text to file (deletes original file).
+     *
+     * @param file file to write in
+     * @return {@code true} is succeed, {@code false} if failed (file state is undefined!).
+     */
+    public static boolean writeToFile(File file, String text) {
+        if (file.exists()) {
+            if (!deleteRecursive(file)) {
+                return false;
+            }
+        }
+
+        String errorMessage = "";
+        FileOutputStream fos = null;
+        OutputStreamWriter osw = null;
+        try {
+            fos = new FileOutputStream(file);
+            osw = new OutputStreamWriter(fos);
+            osw.append(text);
+            return true;
+        } catch (IOException e) {
+            errorMessage = "Failed to write to file. ";
+        } finally {
+            try {
+                if (osw != null) {
+                    osw.close();
+                } else if (fos != null) {
+                    fos.close();
+                }
+            } catch (IOException e) {
+                errorMessage += "Failed to close the stream.";
+            }
+        }
+        if (Build.DEBUG) Log.e(TAG, errorMessage + " file=" + file);
+        return false;
+    }
+
+    /**
+     * @return Text read from given file, or {@code null}
+     * if file does not exist or reading failed.
+     */
+    public static String readTextFile(File file) {
+        if (!file.exists()) return null;
+        try {
+            BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
+            return FileUtils.readTextFromBufferedReader(bufferedReader);
+        } catch (IOException e) {
+            if (Build.DEBUG) Log.e(TAG, "Failed to read file=" + file);
+            return null;
+        }
+    }
+
+    /**
+     * Reads text from given {@link BufferedReader} line-by-line.
+     *
+     * @return text from given {@link BufferedReader}.
+     * @throws IOException
+     */
+    public static String readTextFromBufferedReader(BufferedReader bufferedReader) throws IOException {
+
+        // Store all lines to string builder to
+        // reduce memory using.
+        final StringBuilder body = new StringBuilder();
+        String nextLine;
+        try {
+            while ((nextLine = bufferedReader.readLine()) != null) {
+                body.append(nextLine);
+                body.append('\n');
+            }
+        } finally {
+            bufferedReader.close();
+        }
+
+        return body.toString();
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/NetworkUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/NetworkUtils.java
new file mode 100644
index 00000000..bf95709e
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/NetworkUtils.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.utils;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+
+/**
+ * Helper class with utils related to internet and networking.
+ *
+ * @author Artem Chepurnoy
+ */
+public class NetworkUtils {
+
+    /**
+     * @return {@code true} if device is connected to internet, {@code false} otherwise.
+     */
+    public static boolean isOnline(Context context) {
+        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        return cm.getActiveNetworkInfo() != null && cm.getActiveNetworkInfo().isConnectedOrConnecting();
+    }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/RawReader.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/RawReader.java
new file mode 100644
index 00000000..288762fc
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/RawReader.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.utils;
+
+import android.content.Context;
+import android.util.Log;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+/**
+ * Created by achep on 22.06.13.
+ */
+public final class RawReader {
+
+    private static final String TAG = "RawReader";
+
+    public static String readTextFileFromRawResource(Context context, int rawRes) {
+        final InputStream inputStream = context.getResources().openRawResource(rawRes);
+        final InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
+        final BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
+
+        try {
+            return FileUtils.readTextFromBufferedReader(bufferedReader);
+        } catch (IOException e) {
+            Log.e(TAG, "Failed to read raw resource: " + rawRes);
+            return null;
+        }
+    }
+
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ToastUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ToastUtils.java
index b5bb4ba3..ea3e56cc 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ToastUtils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ToastUtils.java
@@ -34,8 +34,12 @@ public class ToastUtils {
      * @param text message to show
      * @see #showLong(android.content.Context, CharSequence)
      */
-    public static void showShort(Context context, CharSequence text) {
-        show(context, text, Toast.LENGTH_SHORT);
+    public static Toast showShort(Context context, CharSequence text) {
+        return show(context, text, Toast.LENGTH_SHORT);
+    }
+
+    public static Toast showShort(Context context, int stringRes) {
+        return showShort(context, context.getString(stringRes));
     }
 
     /**
@@ -44,12 +48,18 @@ public class ToastUtils {
      * @param text message to show
      * @see #showShort(android.content.Context, CharSequence)
      */
-    public static void showLong(Context context, CharSequence text) {
-        show(context, text, Toast.LENGTH_LONG);
+    public static Toast showLong(Context context, CharSequence text) {
+        return show(context, text, Toast.LENGTH_LONG);
+    }
+
+    public static Toast showLong(Context context, int stringRes) {
+        return showLong(context, context.getString(stringRes));
     }
 
-    private static void show(Context context, CharSequence text, int duration) {
-        Toast.makeText(context, text, duration).show();
+    private static Toast show(Context context, CharSequence text, int duration) {
+        Toast toast = Toast.makeText(context, text, duration);
+        toast.show();
+        return toast;
     }
 
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ViewUtils.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ViewUtils.java
index 36ea9e58..cef18168 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ViewUtils.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/utils/ViewUtils.java
@@ -216,10 +216,10 @@ public class ViewUtils {
             transformMotionEventToLocal(vp, ev);
             ev.offsetLocation(vp.getScrollX(), vp.getScrollY());
         } // TODO: Use reflections to access ViewRootImpl
-          // else if (parent instanceof ViewRootImpl) {
-          //    final ViewRootImpl vr = (ViewRootImpl) parent;
-          //    ev.offsetLocation(0, vr.mCurScrollY);
-          // }
+        // else if (parent instanceof ViewRootImpl) {
+        //    final ViewRootImpl vr = (ViewRootImpl) parent;
+        //    ev.offsetLocation(0, vr.mCurScrollY);
+        // }
 
         ev.offsetLocation(-view.getLeft(), -view.getTop());
 
@@ -248,10 +248,10 @@ public class ViewUtils {
             ev.offsetLocation(-vp.getScrollX(), -vp.getScrollY());
             transformMotionEventToGlobal(vp, ev);
         } // TODO: Use reflections to access ViewRootImpl
-          // else if (parent instanceof ViewRootImpl) {
-          //    final ViewRootImpl vr = (ViewRootImpl) parent;
-          //    ev.offsetLocation(0, -vr.mCurScrollY);
-          // }
+        // else if (parent instanceof ViewRootImpl) {
+        //    final ViewRootImpl vr = (ViewRootImpl) parent;
+        //    ev.offsetLocation(0, -vr.mCurScrollY);
+        // }
     }
 
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ElasticValue.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ElasticValue.java
deleted file mode 100644
index d7cb5219..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ElasticValue.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.view;
-
-import android.os.Handler;
-import android.os.Message;
-import android.os.SystemClock;
-import android.view.View;
-
-import com.achep.acdisplay.utils.MathUtils;
-
-/**
- * Created by achep on 14.05.14 for AcDisplay.
- *
- * @author Artem Chepurnoy
- */
-public abstract class ElasticValue {
-
-    private static final int PERIOD = 16; // ~60 fps.
-
-    private float mMove;
-    private float mStrength;
-    private float mCenter;
-
-    private long mCurTime;
-
-    private boolean mBroadcasting;
-    private Listener mListener;
-
-    private final View mView;
-    private final float mDensity;
-    private final Handler mHandler = new Handler() {
-
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-
-            float force = mStrength;
-            float value = getValue() - mCenter + mMove + (mMove = 0);
-            if (value != 0f) {
-                if (Math.abs(value) < force) {
-                    setValue(0f);
-                    return;
-                }
-
-                int charge = MathUtils.charge(value);
-                setValue((Math.abs(value) - force) * charge);
-                sendEmptyMessageAtTime(0, (mCurTime += PERIOD));
-            }
-        }
-
-        private void setValue(float value) {
-            ElasticValue.this.setValue(value + mCenter);
-        }
-
-        private float getValue() {
-            return ElasticValue.this.getValue() - mCenter;
-        }
-
-    };
-
-    private void start() {
-        if (!mHandler.hasMessages(0)) {
-            mCurTime = SystemClock.uptimeMillis();
-            mHandler.sendEmptyMessage(0);
-        }
-    }
-
-    public void stop() {
-        mHandler.removeMessages(0);
-    }
-
-    /**
-     * Interface definition for a callback to be invoked
-     * when a view's param is changed.
-     */
-    public interface Listener {
-
-        /**
-         * Called on {@link #setValue(float) setting value}.
-         *
-         * @param view Changed view
-         */
-        public void onValueChanged(View view, float value);
-    }
-
-    public ElasticValue(View view, float strengthDpi) {
-        mDensity = view.getResources().getDisplayMetrics().density;
-        mView = view;
-
-        setStrength(strengthDpi);
-    }
-
-    /**
-     * Sets a callback to be invoked when a view's param is changed.
-     *
-     * @see Listener#onValueChanged(android.view.View, float)
-     */
-    public void setListener(Listener listener) {
-        mListener = listener;
-    }
-
-    /**
-     * @return the view set on creating instance.
-     */
-    public View getView() {
-        return mView;
-    }
-
-    /**
-     * Returns how powerful is the desire to reach {@link #setCenter(float) center}.
-     *
-     * @return dpi-per-second in normal mode.
-     * @see #setStrength(float)
-     */
-    public float getStrength() {
-        return mStrength / mDensity / PERIOD * 1000f;
-    }
-
-    public void reset() {
-        stop();
-        setValue(mCenter);
-    }
-
-    public void move(float value) {
-        mMove += value;
-        start();
-    }
-
-    /**
-     * Defines the neutral value.
-     *
-     * @see #setStrength(float)
-     */
-    public void setCenter(float center) {
-        mCenter = center;
-    }
-
-    /**
-     * Defines how powerful is the desire to reach {@link #setCenter(float) center}.
-     *
-     * @param strengthDpi dpi-per-second in normal mode.
-     * @see #getStrength()
-     * @see #setCenter(float)
-     */
-    public void setStrength(float strengthDpi) {
-        mStrength = strengthDpi * mDensity / 1000f * PERIOD;
-    }
-
-    public void setValue(float value) {
-
-        // Notify listeners about the change.
-        // Broadcasting check is here to prevent looping
-        // if setValue() is calling in listener.
-        if (!mBroadcasting && mListener != null) {
-            mBroadcasting = true;
-            mListener.onValueChanged(mView, value);
-            mBroadcasting = false;
-        }
-    }
-
-    public abstract float getValue();
-
-    /**
-     * Elastic setter of view's translation.
-     *
-     * @author Artem Chepurnoy
-     */
-    public static class TranslationX extends ElasticValue {
-
-        public TranslationX(View view, float strengthDpi) {
-            super(view, strengthDpi);
-        }
-
-        @Override
-        public void setValue(float value) {
-            getView().setTranslationX(value);
-            super.setValue(value);
-        }
-
-        @Override
-        public float getValue() {
-            return getView().getTranslationX();
-        }
-
-    }
-
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingLayout.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingLayout.java
index 09e4cecc..d58bb308 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingLayout.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingLayout.java
@@ -40,6 +40,8 @@ public class ForwardingLayout extends LinearLayout {
 
     private OnForwardedEventListener mOnForwardedEventListener;
     private boolean mVibrateOnForwarded;
+    private boolean mForwardAll;
+    private int mForwardDepth;
 
     public ForwardingLayout(Context context) {
         super(context);
@@ -54,7 +56,10 @@ public class ForwardingLayout extends LinearLayout {
     }
 
     public interface OnForwardedEventListener {
+
         public void onForwardedEvent(MotionEvent event, int activePointerId);
+
+        public void onPressedView(MotionEvent event, int activePointerId, View view);
     }
 
     public void setOnForwardedEventListener(OnForwardedEventListener listener) {
@@ -69,6 +74,11 @@ public class ForwardingLayout extends LinearLayout {
         mVibrateOnForwarded = enabled;
     }
 
+    public void setAllViewsForwardable(boolean enabled, int depth) {
+        mForwardAll = enabled;
+        mForwardDepth = depth;
+    }
+
     /**
      * Handles forwarded events.
      *
@@ -87,6 +97,7 @@ public class ForwardingLayout extends LinearLayout {
             case MotionEvent.ACTION_UP:
                 handledEvent = false;
                 // $FALL-THROUGH$
+            case MotionEvent.ACTION_DOWN:
             case MotionEvent.ACTION_MOVE:
                 final int activeIndex = event.findPointerIndex(activePointerId);
                 if (activeIndex < 0) {
@@ -97,12 +108,16 @@ public class ForwardingLayout extends LinearLayout {
                 final int x = (int) event.getX(activeIndex);
                 final int y = (int) event.getY(activeIndex);
 
-                View pressedView = findViewByCoordinate(this, x, y);
+                View pressedView = findViewByCoordinate(this, x, y, 0);
                 if (mPressedChild != pressedView) {
                     vibrateView = pressedView != null ? pressedView : mPressedChild;
                     if (pressedView != null) pressedView.setPressed(true);
                     if (mPressedChild != null) mPressedChild.setPressed(false);
                     mPressedChild = pressedView;
+
+                    if (mOnForwardedEventListener != null) {
+                        mOnForwardedEventListener.onPressedView(event, activePointerId, mPressedChild);
+                    }
                 }
 
                 if (actionMasked == MotionEvent.ACTION_UP) {
@@ -128,7 +143,7 @@ public class ForwardingLayout extends LinearLayout {
         return handledEvent;
     }
 
-    private View findViewByCoordinate(ViewGroup viewGroup, float x, float y) {
+    private View findViewByCoordinate(ViewGroup viewGroup, float x, float y, int depth) {
         final int childCount = viewGroup.getChildCount();
         for (int i = childCount - 1; i >= 0; i--) {
             final View child = viewGroup.getChildAt(i);
@@ -138,16 +153,16 @@ public class ForwardingLayout extends LinearLayout {
                 continue;
             }
 
-            if (child instanceof ViewGroup) {
+            if (child instanceof ViewGroup && (depth < mForwardDepth || !mForwardAll)) {
                 View view = findViewByCoordinate((ViewGroup) child,
                         x - child.getLeft(),
-                        y - child.getTop());
+                        y - child.getTop(), depth + 1);
                 if (view != null) {
                     return view;
                 }
             }
 
-            if (child.isClickable() && ViewUtils.pointInView(child, x, y, 0)) {
+            if ((child.isClickable() || mForwardAll) && ViewUtils.pointInView(child, x, y, 0)) {
                 return child;
             }
         }
@@ -162,6 +177,7 @@ public class ForwardingLayout extends LinearLayout {
 
         mPressedChild.setPressed(false);
         mPressedChild.refreshDrawableState();
+        mPressedChild = null;
     }
 
     private void clickPressedItem() {
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingListener.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingListener.java
index 7f0c50e6..1b1ac0b5 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingListener.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/view/ForwardingListener.java
@@ -29,7 +29,7 @@ import com.achep.acdisplay.utils.ViewUtils;
 /**
  * Abstract class that forwards touch events to a {@link ForwardingLayout}.
  */
-public abstract class ForwardingListener implements
+public class ForwardingListener implements
         View.OnTouchListener, View.OnAttachStateChangeListener {
     /**
      * Scaled touch slop, used for detecting movement outside bounds.
@@ -45,6 +45,7 @@ public abstract class ForwardingListener implements
      * Source view from which events are forwarded.
      */
     private final View mSrc;
+    private final ForwardingLayout mDst;
 
     /**
      * Runnable used to prevent conflicts with scrolling parents.
@@ -68,7 +69,12 @@ public abstract class ForwardingListener implements
     }
 
     public ForwardingListener(View src, boolean immediately) {
+        this(src, immediately, null);
+    }
+
+    public ForwardingListener(View src, boolean immediately, ForwardingLayout dst) {
         mSrc = src;
+        mDst = dst;
         mImmediately = immediately;
         mScaledTouchSlop = ViewConfiguration.get(src.getContext()).getScaledTouchSlop();
         mTapTimeout = ViewConfiguration.getTapTimeout();
@@ -86,7 +92,9 @@ public abstract class ForwardingListener implements
      *
      * @return the layout to which this listener is forwarding events
      */
-    public abstract ForwardingLayout getForwardingLayout();
+    public ForwardingLayout getForwardingLayout() {
+        return null;
+    }
 
     @Override
     public boolean onTouch(View v, MotionEvent event) {
@@ -96,6 +104,11 @@ public abstract class ForwardingListener implements
             forwarding = onTouchForwarded(event) || !onForwardingStopped();
         } else {
             forwarding = onTouchObserved(event) && onForwardingStarted();
+
+            if (mImmediately && forwarding) {
+                mForwarding = true;
+                onTouch(v, event);
+            }
         }
 
         mForwarding = forwarding;
@@ -150,11 +163,13 @@ public abstract class ForwardingListener implements
         switch (actionMasked) {
             case MotionEvent.ACTION_DOWN:
                 mActivePointerId = srcEvent.getPointerId(0);
-                if (mDisallowIntercept == null) {
-                    mDisallowIntercept = new DisallowIntercept();
+                if (!mImmediately) {
+                    if (mDisallowIntercept == null) {
+                        mDisallowIntercept = new DisallowIntercept();
+                    }
+                    src.postDelayed(mDisallowIntercept, mTapTimeout);
+                    break;
                 }
-                src.postDelayed(mDisallowIntercept, mTapTimeout);
-                break;
             case MotionEvent.ACTION_MOVE:
                 final int activePointerIndex = srcEvent.findPointerIndex(mActivePointerId);
                 if (activePointerIndex >= 0) {
@@ -190,7 +205,7 @@ public abstract class ForwardingListener implements
      */
     private boolean onTouchForwarded(MotionEvent srcEvent) {
         final View src = mSrc;
-        final ForwardingLayout dst = getForwardingLayout();
+        final ForwardingLayout dst = mDst != null ? mDst : getForwardingLayout();
         if (dst == null || !dst.isShown()) {
             return false;
         }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/CircleView.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/CircleView.java
index aaba2adc..350e38f2 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/CircleView.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/CircleView.java
@@ -32,7 +32,8 @@ import android.view.View;
 import android.view.animation.AccelerateDecelerateInterpolator;
 
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.animations.CircleViewAnimation;
+import com.achep.acdisplay.animations.CircleRadiusAnimation;
+import com.achep.acdisplay.utils.MathUtils;
 
 /**
  * Created by achep on 19.04.14.
@@ -53,9 +54,11 @@ public class CircleView extends View {
     private float mRadius;
     private Paint mPaint;
 
+    private float mDarkening;
+
     private Drawable mDrawable;
 
-    private CircleViewAnimation mAnimationOut;
+    private CircleRadiusAnimation mAnimationOut;
     private Callback mCallback;
 
     private Handler mHandler;
@@ -92,14 +95,13 @@ public class CircleView extends View {
             }
         };
 
-        mAnimationOut = new CircleViewAnimation(this, 0, 0);
+        mAnimationOut = new CircleRadiusAnimation(this, 0, 0);
         mAnimationOut.setInterpolator(new AccelerateDecelerateInterpolator());
         mAnimationOut.setDuration(res.getInteger(android.R.integer.config_mediumAnimTime));
 
         mPaint = new Paint();
         mPaint.setAntiAlias(true);
         mPaint.setColor(Color.WHITE);
-        mPaint.setStrokeWidth(2);
 
         mRadiusTarget = res.getDimension(R.dimen.circle_radius_target);
         mRadiusDecreaseThreshold = res.getDimension(R.dimen.circle_radius_decrease_threshold);
@@ -120,15 +122,8 @@ public class CircleView extends View {
         float radius;
 
         // Darkening background
-        canvas.drawColor(Color.argb((int) (200 * calculateRatio()), 0, 0, 0));
-
-        if (mRadiusAimed) {
-
-            // Indicate that target radius is aimed.
-            mPaint.setAlpha(35);
-            radius = (float) Math.sqrt(mRadius / 70) * 70;
-            canvas.drawCircle(mPoint[0], mPoint[1], radius, mPaint);
-        }
+        int alpha = (int) (mDarkening * 255);
+        canvas.drawColor(Color.argb(alpha + (int) ((255 - alpha) * ratio * 0.7f), 0, 0, 0));
 
         // Draw unlock circle
         mPaint.setAlpha((int) (255 * Math.pow(ratio, 0.33f)));
@@ -136,14 +131,16 @@ public class CircleView extends View {
         canvas.drawCircle(mPoint[0], mPoint[1], radius, mPaint);
 
         // Draw unlock icon at the center of circle
-        float scale = 0.5f + 0.5f * ratio;
-        canvas.save();
-        canvas.translate(
-                mPoint[0] - mDrawable.getMinimumWidth() / 2 * scale,
-                mPoint[1] - mDrawable.getMinimumHeight() / 2 * scale);
-        canvas.scale(scale, scale);
-        mDrawable.draw(canvas);
-        canvas.restore();
+        if (mRadiusAimed) {
+            float scale = 0.5f + 0.5f * ratio;
+            canvas.save();
+            canvas.translate(
+                    mPoint[0] - mDrawable.getMinimumWidth() / 2 * scale,
+                    mPoint[1] - mDrawable.getMinimumHeight() / 2 * scale);
+            canvas.scale(scale, scale);
+            mDrawable.draw(canvas);
+            canvas.restore();
+        }
     }
 
     @Override
@@ -209,7 +206,7 @@ public class CircleView extends View {
             default:
                 return super.onTouchEvent(event);
         }
-        return false;
+        return true;
     }
 
     private void cancelCircle(boolean unlockAnimation) {
@@ -248,4 +245,13 @@ public class CircleView extends View {
         mCallback = callback;
     }
 
+    public void setDarkening(float darkening) {
+        mDarkening = MathUtils.range(darkening, 0f, 1f);
+        invalidate();
+    }
+
+    public float getDarkening() {
+        return mDarkening;
+    }
+
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIcon.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIcon.java
index 9d3dde29..700a959f 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIcon.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIcon.java
@@ -25,7 +25,7 @@ import android.util.AttributeSet;
 import android.widget.ImageView;
 
 import com.achep.acdisplay.notifications.NotificationData;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
+import com.achep.acdisplay.notifications.OpenNotification;
 
 /**
  * Created by Artem on 25.03.2014.
@@ -34,7 +34,7 @@ public class NotificationIcon extends ImageView implements NotificationView, Not
 
     private boolean mAttached;
 
-    private OpenStatusBarNotification mNotification;
+    private OpenNotification mNotification;
     private int mIconAlpha;
 
     private boolean mAdjustAlphaEnabled = true;
@@ -85,14 +85,14 @@ public class NotificationIcon extends ImageView implements NotificationView, Not
         NotificationData data = mNotification.getNotificationData();
         handleIconChanged(data.getIcon());
         handleReadStateChanged(data.isRead);
-        data.addOnNotificationDataChangedListener(this);
+        data.registerListener(this);
     }
 
     private void unregisterListener() {
         if (mNotification == null) return;
 
         NotificationData data = mNotification.getNotificationData();
-        data.removeOnNotificationDataChangedListener(this);
+        data.unregisterListener(this);
     }
 
     @Override
@@ -115,7 +115,7 @@ public class NotificationIcon extends ImageView implements NotificationView, Not
     }
 
     @Override
-    public void setNotification(OpenStatusBarNotification notification) {
+    public void setNotification(OpenNotification notification) {
         if (mAttached) {
             unregisterListener();
             mNotification = notification;
@@ -149,7 +149,7 @@ public class NotificationIcon extends ImageView implements NotificationView, Not
     }
 
     @Override
-    public OpenStatusBarNotification getNotification() {
+    public OpenNotification getNotification() {
         return mNotification;
     }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIconWidget.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIconWidget.java
index d777b52c..570bf5ef 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIconWidget.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationIconWidget.java
@@ -25,7 +25,7 @@ import android.widget.TextView;
 
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.notifications.NotificationData;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
+import com.achep.acdisplay.notifications.OpenNotification;
 import com.achep.acdisplay.utils.ViewUtils;
 
 /**
@@ -33,7 +33,7 @@ import com.achep.acdisplay.utils.ViewUtils;
  */
 public class NotificationIconWidget extends FrameLayout implements NotificationView {
 
-    private OpenStatusBarNotification mNotification;
+    private OpenNotification mNotification;
 
     private NotificationIcon mIcon;
     private TextView mNumberTextView;
@@ -51,18 +51,19 @@ public class NotificationIconWidget extends FrameLayout implements NotificationV
     }
 
     @Override
-    public void setNotification(OpenStatusBarNotification notification) {
+    public void setNotification(OpenNotification notification) {
         if (mNotification == notification) return;
         mNotification = notification;
 
         mIcon.setNotification(mNotification);
+
         NotificationData data = mNotification.getNotificationData();
         String tileText = data.number > 0 ? Integer.toString(data.number) : null;
         ViewUtils.safelySetText(mNumberTextView, tileText);
     }
 
     @Override
-    public OpenStatusBarNotification getNotification() {
+    public OpenNotification getNotification() {
         return mNotification;
     }
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationPreview.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationPreview.java
deleted file mode 100644
index 5c8e80be..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationPreview.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.widgets;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.service.notification.StatusBarNotification;
-import android.text.TextUtils;
-import android.util.AttributeSet;
-import android.widget.RelativeLayout;
-import android.widget.TextView;
-
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.notifications.NotificationData;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
-
-/**
- * Simple notification widget that shows the title of notification and
- * its message.
- *
- * @see com.achep.acdisplay.widgets.NotificationWidget
- * @author Artem Chepurnoy
- */
-public class NotificationPreview extends RelativeLayout implements NotificationView {
-
-    private NotificationIcon mIcon;
-    private TextView mTitleTextView;
-    private TextView mMessageTextView;
-
-    private OpenStatusBarNotification mNotification;
-
-    public NotificationPreview(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-
-    public NotificationPreview(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-    }
-
-    @Override
-    protected void onFinishInflate() {
-        super.onFinishInflate();
-
-        mIcon = (NotificationIcon) findViewById(R.id.icon);
-        mTitleTextView = (TextView) findViewById(R.id.title);
-        mMessageTextView = (TextView) findViewById(R.id.message);
-
-        mIcon.setNotificationIndicateReadStateEnabled(true);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public OpenStatusBarNotification getNotification() {
-        return mNotification;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void setNotification(OpenStatusBarNotification osbn) {
-        mNotification = osbn;
-        if (osbn == null) {
-            // TODO: Hide everything or show a notice to user.
-            return;
-        }
-
-        StatusBarNotification sbn = osbn.getStatusBarNotification();
-        NotificationData data = osbn.getNotificationData();
-
-        CharSequence message = data.getLargeMessage();
-
-        // If message is empty hide the view to free space
-        // taken by margins.
-        if (!TextUtils.isEmpty(message)) {
-            mMessageTextView.setText(message);
-            mMessageTextView.setVisibility(VISIBLE);
-        } else {
-            mMessageTextView.setVisibility(GONE);
-        }
-
-        mTitleTextView.setText(data.titleText);
-
-        Bitmap bitmap = data.getCircleIcon();
-        if (bitmap == null) bitmap = sbn.getNotification().largeIcon;
-        if (bitmap != null) {
-
-            // Disable tracking notification's icon
-            // and set large icon.
-            mIcon.setNotification(null);
-            mIcon.setImageBitmap(bitmap);
-        } else {
-            mIcon.setNotification(osbn);
-        }
-    }
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationView.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationView.java
index 0c3344ca..29c1b6ae 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationView.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationView.java
@@ -18,15 +18,15 @@
  */
 package com.achep.acdisplay.widgets;
 
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
+import com.achep.acdisplay.notifications.OpenNotification;
 
 /**
  * Created by Artem on 02.02.14.
  */
 public interface NotificationView {
 
-    public void setNotification(OpenStatusBarNotification notification);
+    public void setNotification(OpenNotification notification);
 
-    public OpenStatusBarNotification getNotification();
+    public OpenNotification getNotification();
 
 }
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationWidget.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationWidget.java
index bf782371..7631c799 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationWidget.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/NotificationWidget.java
@@ -41,7 +41,7 @@ import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.notifications.NotificationData;
 import com.achep.acdisplay.notifications.NotificationUtils;
-import com.achep.acdisplay.notifications.OpenStatusBarNotification;
+import com.achep.acdisplay.notifications.OpenNotification;
 import com.achep.acdisplay.utils.ViewUtils;
 
 /**
@@ -60,9 +60,11 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
     private LinearLayout mActionsContainer;
 
     private OnClickListener mOnClickListener;
-    private OpenStatusBarNotification mNotification;
+    private OpenNotification mNotification;
     private ViewGroup mContent;
 
+    private int mActionContainerAlignment = ALIGN_TOP;
+
     /**
      * Interface definition for a callback to be invoked
      * when a notification's views are clicked.
@@ -81,7 +83,7 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
         /**
          * Called on action button click.
          *
-         * @param v clicked view
+         * @param v      clicked view
          * @param intent action's intent
          */
         void onActionButtonClick(View v, PendingIntent intent);
@@ -104,6 +106,39 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
         mOnClickListener = l;
     }
 
+    /**
+     * Sets an alignment of action buttons.
+     *
+     * @param alignment may be {@link #ALIGN_TOP} or {@link #ALIGN_BOTTOM}
+     */
+    public void setActionButtonsAlignment(int alignment) {
+        if (alignment != ALIGN_BOTTOM && alignment != ALIGN_TOP) {
+            throw new IllegalArgumentException("It may be ALIGN_BOTTOM or ALIGN_TOP only!");
+        }
+
+        mActionContainerAlignment = alignment;
+
+        if (mContent != null && mActionsContainer != null) {
+            updateActionButtonsAlignment();
+        }
+    }
+
+    private void updateActionButtonsAlignment() {
+        RelativeLayout.LayoutParams lp = (LayoutParams) mActionsContainer.getLayoutParams();
+        lp.removeRule(RelativeLayout.ABOVE);
+        lp.removeRule(RelativeLayout.BELOW);
+        if (mActionContainerAlignment == ALIGN_BOTTOM)
+            lp.addRule(RelativeLayout.BELOW, mContent.getId());
+        mActionsContainer.setLayoutParams(lp);
+
+        lp = (LayoutParams) mContent.getLayoutParams();
+        lp.removeRule(RelativeLayout.ABOVE);
+        lp.removeRule(RelativeLayout.BELOW);
+        if (mActionContainerAlignment == ALIGN_TOP)
+            lp.addRule(RelativeLayout.BELOW, mActionsContainer.getId());
+        mContent.setLayoutParams(lp);
+    }
+
     @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
@@ -117,13 +152,14 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
         mActionsContainer = (LinearLayout) findViewById(R.id.actions);
 
         mIcon.setNotificationIndicateReadStateEnabled(false);
+        updateActionButtonsAlignment();
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public OpenStatusBarNotification getNotification() {
+    public OpenNotification getNotification() {
         return mNotification;
     }
 
@@ -131,7 +167,7 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
      * {@inheritDoc}
      */
     @Override
-    public void setNotification(OpenStatusBarNotification osbn) {
+    public void setNotification(OpenNotification osbn) {
         mNotification = osbn;
         if (osbn == null) {
             // TODO: Hide everything or show a notice to user.
@@ -172,7 +208,7 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
         }
 
         if (Device.hasKitKatApi()) {
-            updateNotificationActions(osbn);
+            updateActionButtons(osbn);
         }
     }
 
@@ -182,7 +218,7 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
      * or higher Android version.
      */
     @TargetApi(Build.VERSION_CODES.KITKAT)
-    private void updateNotificationActions(OpenStatusBarNotification osbn) {
+    private void updateActionButtons(OpenNotification osbn) {
         StatusBarNotification sbn = osbn.getStatusBarNotification();
         Notification.Action[] actions = sbn.getNotification().actions;
 
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/ProgressBar.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/ProgressBar.java
index 3f56dc6f..25069e0b 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/ProgressBar.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/ProgressBar.java
@@ -31,6 +31,10 @@ import com.achep.acdisplay.R;
  */
 public class ProgressBar extends android.widget.ProgressBar {
 
+    private boolean mMirrored;
+
+    private OnProgressChangeListener mListener;
+
     /**
      * A callback that notifies clients when the progress/max level has been changed.
      */
@@ -47,29 +51,35 @@ public class ProgressBar extends android.widget.ProgressBar {
         public void onMaxChanged(ProgressBar progressBar, int max);
     }
 
-    private boolean mMirrored;
-    private OnProgressChangeListener mListener;
-
     public ProgressBar(Context context) {
-        this(context, null);
+        super(context);
+        init(null, 0);
     }
 
     public ProgressBar(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
+        super(context, attrs);
+        init(attrs, 0);
     }
 
     public ProgressBar(Context context, AttributeSet attrs, int defStyle) {
         super(context, attrs, defStyle);
+        init(attrs, defStyle);
+    }
+
+    private void init(AttributeSet attrs, int defStyle) {
+        if (attrs == null) {
+            return;
+        }
 
-        if (attrs != null) {
-            final TypedArray attributes = context.obtainStyledAttributes(
-                    attrs, R.styleable.ProgressBar, defStyle, 0);
+        Context context = getContext();
+        assert context != null;
 
-            assert attributes != null;
-            setMirrored(attributes.getBoolean(R.styleable.ProgressBar_mirrored, mMirrored));
+        TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.ProgressBar, defStyle, 0);
+        assert arr != null;
 
-            attributes.recycle();
-        }
+        setMirrored(arr.getBoolean(R.styleable.ProgressBar_mirrored, mMirrored));
+
+        arr.recycle();
     }
 
     @Override
@@ -96,10 +106,10 @@ public class ProgressBar extends android.widget.ProgressBar {
             canvas.save();
             canvas.translate(getWidth() - getPaddingEnd(), getPaddingTop());
             canvas.scale(-1.0f, 1.0f);
-        }
-        super.onDraw(canvas);
-        if (mMirrored) {
+            super.onDraw(canvas);
             canvas.restore();
+        } else {
+            super.onDraw(canvas);
         }
     }
 
@@ -108,7 +118,8 @@ public class ProgressBar extends android.widget.ProgressBar {
     }
 
     /**
-     * Sets a listener to receive notifications of changes to the ProgressBar's progress/max level.
+     * Sets a listener to receive notifications
+     * of changes to the ProgressBar's progress/max level.
      */
     public void setOnProgressChangeListener(OnProgressChangeListener listener) {
         mListener = listener;
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/StatusTextView.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/StatusTextView.java
deleted file mode 100644
index 9ff38c7c..00000000
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/StatusTextView.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.widgets;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.BatteryManager;
-import android.text.format.DateFormat;
-import android.util.AttributeSet;
-import android.widget.TextView;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.PowerUtils;
-
-import java.util.Calendar;
-
-/**
- * Created by Artem on 19.03.14.
- */
-public class StatusTextView extends TextView implements Config.OnConfigChangedListener {
-
-    private boolean mBatteryVisible;
-    private boolean mBatteryVisibleAlways;
-    private int mBatteryLevel;
-
-    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            switch (intent.getAction()) {
-                case Intent.ACTION_DATE_CHANGED:
-                case Intent.ACTION_TIMEZONE_CHANGED:
-                    break;
-                case Intent.ACTION_BATTERY_CHANGED:
-                    updateBatteryLevel(intent);
-                    break;
-                default:
-                    return;
-            }
-            updateText();
-        }
-    };
-
-    private String mDateFormat;
-    private String mBatteryDateFormat;
-
-    public StatusTextView(Context context) {
-        super(context);
-        init();
-    }
-
-    public StatusTextView(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        init();
-    }
-
-    public StatusTextView(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-        init();
-    }
-
-    private void init() {
-        mDateFormat = getResources().getString(R.string.status_format_date);
-        mBatteryDateFormat = getResources().getString(R.string.status_format_battery_plus_date);
-    }
-
-    @Override
-    protected void onAttachedToWindow() {
-        super.onAttachedToWindow();
-
-        Context context = getContext();
-        assert context != null;
-
-        IntentFilter filter = new IntentFilter();
-        filter.addAction(Intent.ACTION_DATE_CHANGED);
-        filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
-        filter.addAction(Intent.ACTION_BATTERY_CHANGED);
-        context.registerReceiver(mIntentReceiver, filter, null, null);
-
-        Config config = Config.getInstance();
-        config.addOnConfigChangedListener(this);
-        setBatteryAlwaysVisible(config.isBatteryAlwaysVisible());
-
-        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
-        Intent batteryStats = context.registerReceiver(null, intentFilter);
-
-        updateBatteryLevel(batteryStats);
-        updateText();
-    }
-
-    @Override
-    protected void onDetachedFromWindow() {
-        super.onDetachedFromWindow();
-        getContext().unregisterReceiver(mIntentReceiver);
-        Config.getInstance().removeOnConfigChangedListener(this);
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_UI_STATUS_BATTERY_ALWAYS_VISIBLE:
-                setBatteryAlwaysVisible((boolean) value);
-                break;
-        }
-    }
-
-    /**
-     * By default battery status is visible when charge level is lower than 15% or
-     * device is plugged. This adds an ability to show battery constantly.
-     *
-     * @param visible {@code true} to show battery, {@code false} to make it eventual
-     */
-    private void setBatteryAlwaysVisible(boolean visible) {
-        mBatteryVisibleAlways = visible;
-        updateText();
-    }
-
-    private void updateBatteryLevel(Intent intent) {
-        if (intent == null) {
-            return;
-        }
-
-        int level = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
-        int scale = intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
-
-        mBatteryLevel = Math.round(level / (float) scale * 100);
-        mBatteryVisible = mBatteryLevel < 15 || PowerUtils.isPlugged(intent);
-    }
-
-    private void updateText() {
-        final Calendar calendar = Calendar.getInstance();
-        final CharSequence format;
-
-        if (mBatteryVisible || mBatteryVisibleAlways) {
-            format = String.format(mBatteryDateFormat, mBatteryLevel);
-        } else {
-            format = mDateFormat;
-        }
-
-        setText(DateFormat.format(format, calendar));
-        setContentDescription(DateFormat.format(format, calendar));
-    }
-}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/status/BatteryMeterView.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/status/BatteryMeterView.java
new file mode 100644
index 00000000..791bc8aa
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/status/BatteryMeterView.java
@@ -0,0 +1,476 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// Modified 2014 AChep@xda <artemchep@gmail.com>
+
+package com.achep.acdisplay.widgets.status;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.RectF;
+import android.graphics.Typeface;
+import android.os.BatteryManager;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.TextView;
+
+import com.achep.acdisplay.R;
+
+// TODO: Bring RTL support
+public class BatteryMeterView extends TextView {
+    public static final String TAG = BatteryMeterView.class.getSimpleName();
+
+    public static final int EVENT_LEVEL = 1;
+    public static final int EVENT_CHARGING = 2;
+
+    public static enum BatteryMeterMode {
+        BATTERY_METER_ICON_PORTRAIT,
+    }
+
+    protected class BatteryTracker extends BroadcastReceiver {
+
+        public static final int UNKNOWN_LEVEL = -1;
+
+        // current battery status
+        boolean present = true;
+        boolean plugged;
+        int plugType;
+        int status;
+        int level = UNKNOWN_LEVEL;
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            switch (intent.getAction()) {
+                case Intent.ACTION_BATTERY_CHANGED:
+                    final boolean chargingOld = indicateCharging();
+                    final int levelOld = level;
+
+                    // Get battery level
+                    level = 100
+                            * intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1)
+                            / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
+
+                    present = intent.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);
+                    plugType = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0);
+                    plugged = plugType != 0;
+                    status = intent.getIntExtra(BatteryManager.EXTRA_STATUS,
+                            BatteryManager.BATTERY_STATUS_UNKNOWN);
+
+                    // Update view
+                    setText(String.format(mBatteryFormat, this.level));
+                    setContentDescription(context.getString(R.string.accessibility_battery_level, level));
+
+                    // Notify listener
+                    if (mOnBatteryChangedListener != null) {
+                        int event = 0;
+                        event |= chargingOld != indicateCharging() ? EVENT_CHARGING : 0;
+                        event |= levelOld != level ? EVENT_LEVEL : 0;
+
+                        if (event != 0) {
+                            mOnBatteryChangedListener.onBatteryChanged(BatteryMeterView.this, event);
+                        }
+                    }
+                    break;
+            }
+        }
+
+        /**
+         * @return {@code true} if device is charging, {@code false} otherwise.
+         */
+        protected boolean indicateCharging() {
+            return status == BatteryManager.BATTERY_STATUS_CHARGING
+                    || status == BatteryManager.BATTERY_STATUS_FULL && plugged;
+        }
+    }
+
+    /**
+     * Interface definition for a callback to be invoked
+     * when battery status/level/other changed.
+     *
+     * @see #setOnBatteryChangedListener(OnBatteryChangedListener)
+     */
+    public interface OnBatteryChangedListener {
+
+        /**
+         * Invoked when battery status/level/other changed.
+         *
+         * @param event bit-set of events: {@link #EVENT_LEVEL}, {@link #EVENT_CHARGING} or other.
+         */
+        public void onBatteryChanged(BatteryMeterView view, int event);
+
+    }
+
+    protected BatteryMeterMode mBatteryMeterMode;
+
+    final int[] mColors;
+
+    private String mBatteryFormat;
+    private String mWarningString;
+    private final int mChargeColor;
+    private final int mBatteryHeight;
+    private final int mBatteryWidth;
+    private final int mBatteryPadding;
+
+    private OnBatteryChangedListener mOnBatteryChangedListener;
+
+    private boolean mAttached;
+    private Context mContext;
+
+    protected BatteryTracker mTracker = new BatteryTracker();
+    private BatteryMeterDrawable mBatteryDrawable;
+    private final Object mLock = new Object();
+
+    private int mPaddingLeft;
+
+    @Override
+    public void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        mAttached = true;
+
+        IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
+        Intent sticky = getContext().registerReceiver(mTracker, filter);
+
+        // Pre-load the battery level
+        if (sticky != null) {
+            mTracker.onReceive(getContext(), sticky);
+        }
+    }
+
+    @Override
+    public void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        mAttached = false;
+        getContext().unregisterReceiver(mTracker);
+    }
+
+    public BatteryMeterView(Context context) {
+        this(context, null, 0);
+    }
+
+    public BatteryMeterView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public BatteryMeterView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        mContext = context;
+
+        TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.BatteryMeterView, defStyle, 0);
+        mBatteryHeight = arr.getDimensionPixelSize(R.styleable.BatteryMeterView_battery_height, 0);
+        mBatteryWidth = arr.getDimensionPixelSize(R.styleable.BatteryMeterView_battery_width, 0);
+        mBatteryPadding = arr.getDimensionPixelSize(R.styleable.BatteryMeterView_battery_padding, 0);
+        setPadding(getPaddingLeft(), getPaddingTop(), getPaddingRight(), getPaddingBottom());
+
+        final Resources res = context.getResources();
+        TypedArray levels = res.obtainTypedArray(R.array.batterymeter_color_levels);
+        TypedArray colors = res.obtainTypedArray(R.array.batterymeter_color_values);
+
+        final int n = levels.length();
+        mColors = new int[2 * n];
+        for (int i = 0; i < n; i++) {
+            mColors[2 * i] = levels.getInt(i, 0);
+            mColors[2 * i + 1] = colors.getColor(i, 0);
+        }
+        levels.recycle();
+        colors.recycle();
+
+        mChargeColor = getResources().getColor(R.color.batterymeter_charge_color);
+        mBatteryFormat = getResources().getString(R.string.batterymeter_precise);
+        mWarningString = context.getString(R.string.batterymeter_very_low_overlay_symbol);
+
+        setMode(BatteryMeterMode.BATTERY_METER_ICON_PORTRAIT);
+        mBatteryDrawable.onSizeChanged(mBatteryWidth, mBatteryHeight, 0, 0);
+
+        setLayerType(View.LAYER_TYPE_SOFTWARE, null);
+    }
+
+    @Override
+    public void setPadding(int left, int top, int right, int bottom) {
+        // Apply additional padding to leave free space
+        // for battery meter drawing.
+        final int leftExtended = (left += mBatteryPadding) + mBatteryWidth + mBatteryPadding;
+        super.setPadding(leftExtended, top, right, bottom);
+        mPaddingLeft = left;
+    }
+
+    @Override
+    public int getPaddingLeft() {
+        return mPaddingLeft;
+    }
+
+    private BatteryMeterDrawable createBatteryMeterDrawable(BatteryMeterMode mode) {
+        Resources res = mContext.getResources();
+        return new NormalBatteryMeterDrawable(res);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+
+        int heightMin = mBatteryHeight + getTotalPaddingTop() + getTotalPaddingBottom();
+        int height = Math.max(getMeasuredHeight(), heightMin);
+        setMeasuredDimension(getMeasuredWidth(), height);
+    }
+
+    public void setOnBatteryChangedListener(OnBatteryChangedListener listener) {
+        mOnBatteryChangedListener = listener;
+    }
+
+    /**
+     * @return battery charge level, from {@code [0...100]}
+     */
+    public int getBatteryLevel() {
+        return mTracker.level;
+    }
+
+    /**
+     * @return {@code true} if charging, {@code false} otherwise
+     */
+    public boolean getBatteryCharging() {
+        return mTracker.indicateCharging();
+    }
+
+    public int getColorForLevel(int percent) {
+        int thresh, color;
+        for (int i = 0; i < mColors.length; i += 2) {
+            thresh = mColors[i];
+            color = mColors[i + 1];
+            if (percent <= thresh) {
+                return color;
+            }
+        }
+
+        throw new RuntimeException("Broken color levels!");
+    }
+
+    public void setMode(BatteryMeterMode mode) {
+        synchronized (mLock) {
+            if (mBatteryMeterMode == mode) {
+                return;
+            }
+
+            mBatteryMeterMode = mode;
+
+            if (mBatteryDrawable != null)
+                mBatteryDrawable.onDispose();
+            mBatteryDrawable = createBatteryMeterDrawable(mode);
+
+            if (mBatteryMeterMode == BatteryMeterMode.BATTERY_METER_ICON_PORTRAIT) {
+                NormalBatteryMeterDrawable drawable = (NormalBatteryMeterDrawable) mBatteryDrawable;
+                drawable.loadBoltPoints(mContext.getResources());
+            }
+
+            if (mAttached) {
+                postInvalidate();
+            }
+        }
+    }
+
+    @Override
+    public void onDraw(Canvas c) {
+        super.onDraw(c);
+
+        synchronized (mLock) {
+            if (mBatteryDrawable != null) {
+                mBatteryDrawable.onDraw(c, mTracker);
+            }
+        }
+    }
+
+    protected interface BatteryMeterDrawable {
+        void onDraw(Canvas c, BatteryTracker tracker);
+
+        void onSizeChanged(int w, int h, int oldw, int oldh);
+
+        void onDispose();
+    }
+
+    protected class NormalBatteryMeterDrawable implements BatteryMeterDrawable {
+
+        public static final int FULL = 96;
+        public static final int EMPTY = 4;
+
+        public static final float SUBPIXEL = 0.4f;  // inset rects for softer edges
+
+        private boolean mDisposed;
+
+        private Paint mFramePaint, mBatteryPaint, mWarningTextPaint, mBoltPaint;
+        private int mButtonHeight;
+        private float mWarningTextHeight;
+
+        private final float[] mBoltPoints;
+        private final Path mBoltPath = new Path();
+
+        private final RectF mFrame = new RectF();
+        private final RectF mButtonFrame = new RectF();
+        private final RectF mClipFrame = new RectF();
+        private final RectF mBoltFrame = new RectF();
+
+        public NormalBatteryMeterDrawable(Resources res) {
+            super();
+            mDisposed = false;
+
+            mFramePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            mFramePaint.setColor(res.getColor(R.color.batterymeter_frame_color));
+            mFramePaint.setDither(true);
+            mFramePaint.setStrokeWidth(0);
+            mFramePaint.setStyle(Paint.Style.FILL_AND_STROKE);
+            mFramePaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP));
+
+            mBatteryPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            mBatteryPaint.setDither(true);
+            mBatteryPaint.setStrokeWidth(0);
+            mBatteryPaint.setStyle(Paint.Style.FILL_AND_STROKE);
+
+            mWarningTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+            mWarningTextPaint.setColor(mColors[1]);
+            Typeface font = Typeface.create("sans-serif", Typeface.BOLD);
+            mWarningTextPaint.setTypeface(font);
+            mWarningTextPaint.setTextAlign(Paint.Align.CENTER);
+
+            mBoltPaint = new Paint();
+            mBoltPaint.setAntiAlias(true);
+            mBoltPaint.setColor(res.getColor(R.color.batterymeter_bolt_color));
+            mBoltPoints = loadBoltPoints(res);
+        }
+
+        @Override
+        public void onDraw(Canvas c, BatteryTracker tracker) {
+            if (mDisposed) return;
+
+            final int level = tracker.level;
+
+            if (level == BatteryTracker.UNKNOWN_LEVEL) return;
+
+            float drawFrac = (float) level / 100f;
+            final int pt = getTotalPaddingTop() + (getHeight() - getTotalPaddingTop() - getTotalPaddingBottom() - mBatteryHeight) / 2;
+            final int pl = getPaddingLeft();
+            int height = mBatteryHeight;
+            int width = mBatteryWidth;
+
+            mButtonHeight = (int) (height * 0.12f);
+
+            mFrame.set(0, 0, width, height);
+            mFrame.offset(pl, pt);
+
+            mButtonFrame.set(
+                    mFrame.left + width * 0.25f,
+                    mFrame.top,
+                    mFrame.right - width * 0.25f,
+                    mFrame.top + mButtonHeight + 5 /*cover frame border of intersecting area*/);
+
+            mButtonFrame.top += SUBPIXEL;
+            mButtonFrame.left += SUBPIXEL;
+            mButtonFrame.right -= SUBPIXEL;
+
+            mFrame.top += mButtonHeight;
+            mFrame.left += SUBPIXEL;
+            mFrame.top += SUBPIXEL;
+            mFrame.right -= SUBPIXEL;
+            mFrame.bottom -= SUBPIXEL;
+
+            // first, draw the battery shape
+            c.drawRect(mFrame, mFramePaint);
+
+            // fill 'er up
+            final int color = tracker.plugged ? mChargeColor : getColorForLevel(level);
+            mBatteryPaint.setColor(color);
+
+            if (level >= FULL) {
+                drawFrac = 1f;
+            } else if (level <= EMPTY) {
+                drawFrac = 0f;
+            }
+
+            c.drawRect(mButtonFrame, drawFrac == 1f ? mBatteryPaint : mFramePaint);
+
+            mClipFrame.set(mFrame);
+            mClipFrame.top += (mFrame.height() * (1f - drawFrac));
+
+            c.save(Canvas.CLIP_SAVE_FLAG);
+            c.clipRect(mClipFrame);
+            c.drawRect(mFrame, mBatteryPaint);
+            c.restore();
+
+            if (tracker.indicateCharging()) {
+                // draw the bolt
+                final float bl = (int) (mFrame.left + mFrame.width() / 4.5f);
+                final float bt = (int) (mFrame.top + mFrame.height() / 6f);
+                final float br = (int) (mFrame.right - mFrame.width() / 7f);
+                final float bb = (int) (mFrame.bottom - mFrame.height() / 10f);
+                if (mBoltFrame.left != bl || mBoltFrame.top != bt
+                        || mBoltFrame.right != br || mBoltFrame.bottom != bb) {
+                    mBoltFrame.set(bl, bt, br, bb);
+                    mBoltPath.reset();
+                    mBoltPath.moveTo(
+                            mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(),
+                            mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
+                    for (int i = 2; i < mBoltPoints.length; i += 2) {
+                        mBoltPath.lineTo(
+                                mBoltFrame.left + mBoltPoints[i] * mBoltFrame.width(),
+                                mBoltFrame.top + mBoltPoints[i + 1] * mBoltFrame.height());
+                    }
+                    mBoltPath.lineTo(
+                            mBoltFrame.left + mBoltPoints[0] * mBoltFrame.width(),
+                            mBoltFrame.top + mBoltPoints[1] * mBoltFrame.height());
+                }
+                c.drawPath(mBoltPath, mBoltPaint);
+            } else if (level <= EMPTY) {
+                final float x = pl + mBatteryWidth * 0.5f;
+                final float y = pt + (mBatteryHeight + mWarningTextHeight) * 0.48f;
+                c.drawText(mWarningString, x, y, mWarningTextPaint);
+            }
+        }
+
+        @Override
+        public void onDispose() {
+            mDisposed = true;
+        }
+
+        @Override
+        public void onSizeChanged(int w, int h, int oldw, int oldh) {
+            mWarningTextPaint.setTextSize(h * 0.75f);
+            mWarningTextHeight = -mWarningTextPaint.getFontMetrics().ascent;
+        }
+
+        private float[] loadBoltPoints(Resources res) {
+            final int[] pts = res.getIntArray(getBoltPointsArrayResource());
+            int maxX = 0, maxY = 0;
+            for (int i = 0; i < pts.length; i += 2) {
+                maxX = Math.max(maxX, pts[i]);
+                maxY = Math.max(maxY, pts[i + 1]);
+            }
+            final float[] ptsF = new float[pts.length];
+            for (int i = 0; i < pts.length; i += 2) {
+                ptsF[i] = (float) pts[i] / maxX;
+                ptsF[i + 1] = (float) pts[i + 1] / maxY;
+            }
+            return ptsF;
+        }
+
+        protected int getBoltPointsArrayResource() {
+            return R.array.batterymeter_bolt_points;
+        }
+    }
+}
\ No newline at end of file
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/status/StatusWidget.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/status/StatusWidget.java
new file mode 100644
index 00000000..b3520db4
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/widgets/status/StatusWidget.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.acdisplay.widgets.status;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.widget.LinearLayout;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.Operator;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.utils.ViewUtils;
+
+/**
+ * Created by achep on 17.06.14.
+ */
+public class StatusWidget extends LinearLayout implements
+        Config.OnConfigChangedListener,
+        BatteryMeterView.OnBatteryChangedListener {
+
+    private BatteryMeterView mBatteryMeterView;
+
+    public StatusWidget(Context context) {
+        super(context);
+    }
+
+    public StatusWidget(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public StatusWidget(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        mBatteryMeterView = (BatteryMeterView) findViewById(R.id.battery);
+        mBatteryMeterView.setOnBatteryChangedListener(this);
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+
+        Config config = Config.getInstance();
+        config.registerListener(this);
+        updateBatteryVisibility();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+
+        Config config = Config.getInstance();
+        config.unregisterListener(this);
+    }
+
+    @Override
+    public void onBatteryChanged(BatteryMeterView view, int event) {
+        if (Operator.bitAnd(event, BatteryMeterView.EVENT_CHARGING)
+                || Operator.bitAnd(event, BatteryMeterView.EVENT_LEVEL)) {
+            updateBatteryVisibility();
+        }
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_UI_STATUS_BATTERY_STICKY:
+                updateBatteryVisibility();
+                break;
+        }
+    }
+
+    private void updateBatteryVisibility() {
+        boolean visible = Config.getInstance().isStatusBatterySticky()
+                || mBatteryMeterView.getBatteryCharging()
+                || mBatteryMeterView.getBatteryLevel() < 15;
+        ViewUtils.setVisible(mBatteryMeterView, visible);
+    }
+}
diff --git a/project/AcDisplay/src/main/java/com/achep/acdisplay/xposed/OverrideHomeButton.java b/project/AcDisplay/src/main/java/com/achep/acdisplay/xposed/OverrideHomeButton.java
index 857a760d..f5a50ac2 100644
--- a/project/AcDisplay/src/main/java/com/achep/acdisplay/xposed/OverrideHomeButton.java
+++ b/project/AcDisplay/src/main/java/com/achep/acdisplay/xposed/OverrideHomeButton.java
@@ -24,6 +24,9 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.activities.KeyguardActivity;
+
 import de.robv.android.xposed.IXposedHookZygoteInit;
 import de.robv.android.xposed.XC_MethodHook;
 
@@ -32,44 +35,40 @@ import static de.robv.android.xposed.XposedHelpers.getObjectField;
 
 public class OverrideHomeButton implements IXposedHookZygoteInit {
 
-    public static final String INTENT_EAT_HOME_PRESS_START = "com.achep.acdisplay.EAT_HOME_PRESS_START";
-    public static final String INTENT_EAT_HOME_PRESS_STOP = "com.achep.acdisplay.EAT_HOME_PRESS_STOP";
-
     private static boolean active = false;
-    
+
     @Override
     public void initZygote(StartupParam startupParam) throws Throwable {
 
         /**
-        * Register BroadcastReceiver in PhoneWindowManager.init(…) so that we
-        * can enable and disable the home button on demand.
-        */
+         * Register BroadcastReceiver in PhoneWindowManager.init(…) so that we
+         * can enable and disable the home button on demand.
+         */
         findAndHookMethod("com.android.internal.policy.impl.PhoneWindowManager", null, "init",
                 Context.class, "android.view.IWindowManager", "android.view.WindowManagerPolicy.WindowManagerFuncs",
                 new XC_MethodHook() {
                     @Override
                     protected void afterHookedMethod(MethodHookParam param) throws Throwable {
-                        BroadcastReceiver mAcDisplayReceiver = new BroadcastReceiver() {
+                        BroadcastReceiver receiver = new BroadcastReceiver() {
                             @Override
                             public void onReceive(Context context, Intent intent) {
                                 switch (intent.getAction()) {
-                                    case INTENT_EAT_HOME_PRESS_START:
+                                    case App.ACTION_EAT_HOME_PRESS_START:
                                         active = true;
                                         break;
-                                    case INTENT_EAT_HOME_PRESS_STOP:
+                                    case App.ACTION_EAT_HOME_PRESS_STOP:
                                         active = false;
                                         break;
                                 }
                             }
                         };
                         IntentFilter filter = new IntentFilter();
-                        filter.addAction(INTENT_EAT_HOME_PRESS_START);
-                        filter.addAction(INTENT_EAT_HOME_PRESS_STOP);
+                        filter.addAction(App.ACTION_EAT_HOME_PRESS_START);
+                        filter.addAction(App.ACTION_EAT_HOME_PRESS_STOP);
                         Context context = (Context) getObjectField(param.thisObject, "mContext");
-                        context.registerReceiver(mAcDisplayReceiver, filter);
+                        context.registerReceiver(receiver, filter);
                     }
                 }
-
         );
 
         /**
@@ -83,7 +82,6 @@ public class OverrideHomeButton implements IXposedHookZygoteInit {
                             param.setResult(null);
                     }
                 }
-
         );
     }
 }
diff --git a/project/AcDisplay/src/main/java/com/painless/pc/PowerTogglesPlugin.java b/project/AcDisplay/src/main/java/com/painless/pc/PowerTogglesPlugin.java
new file mode 100644
index 00000000..36c52474
--- /dev/null
+++ b/project/AcDisplay/src/main/java/com/painless/pc/PowerTogglesPlugin.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.painless.pc;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+public abstract class PowerTogglesPlugin extends BroadcastReceiver {
+
+    // Intent send by PowerToggles asking for a state change
+    public static final String ACTION_SET_STATE = "com.painless.pc.ACTION_SET_STATE";
+
+    // Intent send to PowerToggles notifying it of state changes
+    public static final String ACTION_STATE_CHANGED = "com.painless.pc.ACTION_STATE_CHANGED";
+
+    // Intent extra denoting the state. Value must be a boolean.
+    public static final String EXTRA_STATE = "state";
+
+    // Must be set to the class name of the receiver, when informing PowerToggles
+    // of a state change.
+    public static final String EXTRA_VARID = "varID";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        if (ACTION_SET_STATE.equals(intent.getAction())) {
+            changeState(context, intent.getBooleanExtra(EXTRA_STATE, false));
+        }
+    }
+
+    /**
+     * Called when the PowerToggles widget requests a state change because
+     * the user clicked the corresponding toggle.
+     */
+    protected abstract void changeState(Context context, boolean newState);
+
+    /**
+     * Updates the plugin state in PowerToggles widget.
+     */
+    public final void sendStateUpdate(Context context, boolean newState) {
+        sendStateUpdate(this.getClass(), newState, context);
+    }
+
+    /**
+     * Updates the plugin state in PowerToggles widget.
+     *
+     * @param pluginClass The receiver implementing the plugin. An application can
+     *                    define multiple plugins, with one receiver per plugin.
+     * @param newState
+     * @param context
+     */
+    public static final void sendStateUpdate(Class<? extends PowerTogglesPlugin> pluginClass,
+                                             boolean newState, Context context) {
+        context.sendBroadcast(new Intent(ACTION_STATE_CHANGED)
+                .putExtra(EXTRA_VARID, pluginClass.getName())
+                .putExtra(EXTRA_STATE, newState));
+    }
+}
