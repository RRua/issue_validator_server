diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/ActionStatus.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/ActionStatus.java
index 0e2739f..955a573 100644
--- a/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/ActionStatus.java
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/ActionStatus.java
@@ -22,7 +22,7 @@ public class ActionStatus {
 
 
     @SerializedName("status")
-    private int status;
+    private int status = 0;
 
     public ActionStatus(int status) {
         this.status = status;
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageError.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageError.java
new file mode 100644
index 0000000..a308c95
--- /dev/null
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageError.java
@@ -0,0 +1,37 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+public class CameraImageError {
+    private String errorCode;
+    private String errorCause;
+    private boolean displayRetry = true;
+
+    public CameraImageError(String errorCode, String errorCause, boolean displayRetry) {
+        this.errorCode = errorCode;
+        this.errorCause = errorCause;
+        this.displayRetry = displayRetry;
+    }
+
+    public String getErrorCode() {
+        return errorCode;
+    }
+
+    public void setErrorCode(String errorCode) {
+        this.errorCode = errorCode;
+    }
+
+    public String getErrorCause() {
+        return errorCause;
+    }
+
+    public void setErrorCause(String errorCause) {
+        this.errorCause = errorCause;
+    }
+
+    public boolean isDisplayRetry() {
+        return displayRetry;
+    }
+
+    public void setDisplayRetry(boolean displayRetry) {
+        this.displayRetry = displayRetry;
+    }
+}
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageFrame.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageFrame.java
new file mode 100644
index 0000000..f966612
--- /dev/null
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageFrame.java
@@ -0,0 +1,81 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+import android.graphics.Bitmap;
+
+import java.sql.Time;
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * This class is for video frame transmitting to the RecyclerView
+ */
+public class CameraImageFrame {
+    private Camera camera;
+    private Device device;
+    private Bitmap bitmap;
+    private boolean initialLoadDone = false;
+    private String frameRateText = "";
+    private CameraImageError error = null;
+    private List<Long> times = new ArrayList<>();
+
+
+    public CameraImageFrame(Camera camera, Device device, Bitmap bitmap, boolean initialLoadDone) {
+        this.camera = camera;
+        this.device = device;
+        this.bitmap = bitmap;
+        this.initialLoadDone = initialLoadDone;
+    }
+
+    public List<Long> getTimes() {
+        return times;
+    }
+
+    public CameraImageError getError() {
+        return error;
+    }
+
+    public void setError(CameraImageError error) {
+        this.error = error;
+    }
+
+    public String getFrameRateText() {
+        return frameRateText;
+    }
+
+    public void setFrameRateText(String frameRateText) {
+        this.frameRateText = frameRateText;
+    }
+
+    public Camera getCamera() {
+        return camera;
+    }
+
+    public void setCamera(Camera camera) {
+        this.camera = camera;
+    }
+
+    public Device getDevice() {
+        return device;
+    }
+
+    public void setDevice(Device device) {
+        this.device = device;
+    }
+
+    public Bitmap getBitmap() {
+        return bitmap;
+    }
+
+    public void setBitmap(Bitmap bitmap) {
+        this.bitmap = bitmap;
+    }
+
+    public boolean isInitialLoadDone() {
+        return initialLoadDone;
+    }
+
+    public void setInitialLoadDone(boolean initialLoadDone) {
+        this.initialLoadDone = initialLoadDone;
+    }
+}
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/ErrorResponse.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/ErrorResponse.java
new file mode 100644
index 0000000..e5fd5d3
--- /dev/null
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/classes/ErrorResponse.java
@@ -0,0 +1,31 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+public class ErrorResponse {
+    @SerializedName("prompt")
+    private boolean prompt;
+    @SerializedName("error")
+    private String error;
+
+    public ErrorResponse(boolean prompt, String error) {
+        this.prompt = prompt;
+        this.error = error;
+    }
+
+    public boolean isPrompt() {
+        return prompt;
+    }
+
+    public void setPrompt(boolean prompt) {
+        this.prompt = prompt;
+    }
+
+    public String getError() {
+        return error;
+    }
+
+    public void setError(String error) {
+        this.error = error;
+    }
+}
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/CameraViewer.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/CameraViewer.java
index 2e41933..c15cbe4 100644
--- a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/CameraViewer.java
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/CameraViewer.java
@@ -18,27 +18,42 @@ package com.developerfromjokela.motioneyeclient.ui.activities;
 
 import android.content.Context;
 import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
+import android.os.AsyncTask;
 import android.os.Bundle;
+import android.os.Handler;
 import android.support.annotation.Nullable;
 import android.support.v7.app.AppCompatActivity;
 import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.LinearLayoutManager;
 import android.support.v7.widget.RecyclerView;
 import android.support.v7.widget.Toolbar;
 import android.util.Log;
+import android.util.Range;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
 import android.view.View;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+import android.widget.TextView;
 
 import com.developerfromjokela.motioneyeclient.R;
 import com.developerfromjokela.motioneyeclient.api.ApiInterface;
 import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
 import com.developerfromjokela.motioneyeclient.api.ServiceGenerator;
 import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.CameraImage;
+import com.developerfromjokela.motioneyeclient.classes.CameraImageError;
+import com.developerfromjokela.motioneyeclient.classes.CameraImageFrame;
 import com.developerfromjokela.motioneyeclient.classes.Cameras;
 import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.ErrorResponse;
 import com.developerfromjokela.motioneyeclient.database.Source;
 import com.developerfromjokela.motioneyeclient.other.Utils;
 import com.developerfromjokela.motioneyeclient.ui.adapters.HttpCamerasAdapter;
@@ -49,12 +64,22 @@ import org.jsoup.nodes.Document;
 import org.jsoup.select.Elements;
 
 import java.io.IOException;
+import java.io.InputStream;
+import java.lang.annotation.Annotation;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
+import java.util.Map;
 
 import okhttp3.ResponseBody;
 import retrofit2.Call;
 import retrofit2.Callback;
+import retrofit2.Converter;
 import retrofit2.Response;
+import retrofit2.Retrofit;
 
 import static android.app.DownloadManager.Request.NETWORK_MOBILE;
 
@@ -64,6 +89,9 @@ public class CameraViewer extends AppCompatActivity {
     private Device device;
     private String ID;
     private Source source;
+    private List<CameraImageFrame> cameraImageFrames = new ArrayList<>();
+    private boolean sleeping = false;
+    private GridLayoutManager manager;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -82,8 +110,6 @@ public class CameraViewer extends AppCompatActivity {
         source = new Source(this);
         if (intent.getExtras() != null) {
             ID = intent.getStringExtra("DeviceId");
-
-
         } else {
             finish();
         }
@@ -93,22 +119,35 @@ public class CameraViewer extends AppCompatActivity {
     @Override
     public void onResume() {
         super.onResume();
+        sleeping = false;
         try {
             device = source.get(ID);
+
             setTitle(device.getDeviceName());
             Log.e(CameraViewer.class.getSimpleName(), new Gson().toJson(device));
             RecyclerView recyclerView = findViewById(R.id.cameras);
-            recyclerView.setLayoutManager(new GridLayoutManager(this, 1));
-            adapter = new HttpCamerasAdapter(this, new HttpCamerasAdapter.CamerasAdapterListener() {
+            manager = new GridLayoutManager(this, 1);
+            recyclerView.setLayoutManager(manager);
+            recyclerView.setItemAnimator(null);
+            for (Camera camera : device.getCameras()) {
+                CameraImageFrame frame = new CameraImageFrame(camera, device, null, false);
+                cameraImageFrames.add(frame);
+            }
+            adapter = new HttpCamerasAdapter(new HttpCamerasAdapter.CamerasAdapterListener() {
                 @Override
-                public void onImageClick(int position, Camera camera) {
+                public void onImageClick(int position, CameraImageFrame camera) {
                     Intent fullscreen = new Intent(CameraViewer.this, FullCameraViewer.class);
                     fullscreen.putExtra("DeviceId", ID);
-                    fullscreen.putExtra("Camera", new Gson().toJson(camera));
+                    fullscreen.putExtra("Camera", new Gson().toJson(camera.getCamera()));
                     startActivity(fullscreen);
                 }
 
-            }, device);
+                @Override
+                public void onRefreshRequest(int position, CameraImageFrame cameraImageFrame) {
+                    getRunnableForCamera(position).run();
+                }
+
+            }, cameraImageFrames);
             recyclerView.setAdapter(adapter);
             adapter.notifyDataSetChanged();
             String baseurl;
@@ -144,7 +183,6 @@ public class CameraViewer extends AppCompatActivity {
                 public void onResponse(Call<Cameras> call, Response<Cameras> response) {
                     Cameras cameras = response.body();
                     if (response.isSuccessful()) {
-<<<<<<< HEAD
                         device.setCameras(cameras.getCameras());
                         apiInterface.getMotionDetails(baseurl + "/version").enqueue(new Callback<ResponseBody>() {
                             @Override
@@ -169,6 +207,15 @@ public class CameraViewer extends AppCompatActivity {
                                                 device.setMotioneyeVersion(paramValue);
 
                                         }
+
+                                        cameraImageFrames.clear();
+
+                                        for (Camera camera : device.getCameras()) {
+                                            CameraImageFrame frame = new CameraImageFrame(camera, device, null, false);
+                                            cameraImageFrames.add(frame);
+                                            getRunnableForCamera(cameraImageFrames.size() - 1).run();
+                                        }
+
                                         adapter.notifyDataSetChanged();
                                         setTitle(device.getDeviceName());
 
@@ -176,71 +223,46 @@ public class CameraViewer extends AppCompatActivity {
 
 
                                     } catch (IOException e) {
-                                        e.printStackTrace();
+                                        for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                                            cameraImageFrame.setError(new CameraImageError("motioneye_error5", e.getMessage(), true));
+                                        }
+                                        adapter.notifyDataSetChanged();
                                     } catch (Exception e) {
-                                        e.printStackTrace();
-=======
-                    device.setCameras(cameras.getCameras());
-                    apiInterface.getMotionDetails(baseurl + "/version").enqueue(new Callback<ResponseBody>() {
-                        @Override
-                        public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
-                            if (response.headers().get("Server").toLowerCase().contains("motioneye")) {
-                                try {
-                                    final String stringResponse = response.body().string();
-                                    Document html = Jsoup.parse(stringResponse);
-                                    Elements elements = html.select("body");
-                                    String[] lines = elements.html().replace("\"", "").replace("\n", "").split("<br>");
-                                    for (String string : lines) {
-                                        String[] paramParts = string.split("=");
-                                        String paramName = paramParts[0].trim();
-                                        String paramValue = paramParts[1];
-                                        if (paramName.contains("hostname"))
-                                            device.setDeviceName(paramValue);
-                                        else if (paramName.contains("motion_version"))
-                                            device.setMotionVersion(paramValue);
-                                        else if (paramName.contains("os_version"))
-                                            device.setOsVersion(paramValue);
-                                        else if (paramName.equals("version"))
-                                            device.setMotioneyeVersion(paramValue);
-
->>>>>>> parent of cfc8134... * Fixed stream performance, now it will load only visible cameras.
+                                        for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                                            cameraImageFrame.setError(new CameraImageError("motioneye_error6", e.getMessage(), true));
+                                        }
+                                        adapter.notifyDataSetChanged();
                                     }
-                                    adapter.notifyDataSetChanged();
-                                    setTitle(device.getDeviceName());
-
-                                    source.editEntry(device);
 
 
-                                } catch (IOException e) {
-                                    e.printStackTrace();
-                                } catch (Exception e) {
-                                    e.printStackTrace();
                                 }
+                            }
 
 
-<<<<<<< HEAD
                             @Override
                             public void onFailure(Call<ResponseBody> call, Throwable t) {
-
-                        }
-                        });
-=======
+                                for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                                    cameraImageFrame.setError(new CameraImageError("motioneye_error2", t.getMessage(), true));
+                                }
+                                adapter.notifyDataSetChanged();
                             }
-                        }
-
-
-                        @Override
-                        public void onFailure(Call<ResponseBody> call, Throwable t) {
+                        });
+                    } else {
 
+                        ErrorResponse message = new Gson().fromJson(response.errorBody().charStream(), ErrorResponse.class);
+                        for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                            cameraImageFrame.setError(new CameraImageError("motioneye_error4", message.getError(), true));
                         }
-                    });
->>>>>>> parent of cfc8134... * Fixed stream performance, now it will load only visible cameras.
+                        adapter.notifyDataSetChanged();
                     }
                 }
 
                 @Override
                 public void onFailure(Call<Cameras> call, Throwable t) {
-
+                    for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                        cameraImageFrame.setError(new CameraImageError("motioneye_error3", t.getMessage(), true));
+                    }
+                    adapter.notifyDataSetChanged();
                 }
             });
 
@@ -248,23 +270,20 @@ public class CameraViewer extends AppCompatActivity {
         } catch (Exception e) {
             e.printStackTrace();
         }
-        if (adapter != null)
-            adapter.onResume();
+
 
     }
 
     @Override
     public void onPause() {
         super.onPause();
-        if (adapter != null)
-            adapter.onPause();
+        sleeping = true;
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
-        if (adapter != null)
-            adapter.onDestroy();
+        sleeping = true;
     }
 
     @Override
@@ -286,6 +305,144 @@ public class CameraViewer extends AppCompatActivity {
         }
     }
 
+    private Runnable getRunnableForCamera(int position) {
+        return new Runnable() {
+            @Override
+            public void run() {
+                MotionEyeHelper helper = new MotionEyeHelper();
+                helper.setUsername(device.getUser().getUsername());
+                try {
+                    helper.setPasswordHash(device.getUser().getPassword());
+                } catch (NoSuchAlgorithmException e) {
+                    e.printStackTrace();
+                }
+
+
+                CameraImageFrame frame = cameraImageFrames.get(position);
+                String cameraId = frame.getCamera().getId();
+                String serverurl;
+                if (device.getDdnsURL().length() > 5) {
+                    if ((Utils.getNetworkType(CameraViewer.this)) == NETWORK_MOBILE) {
+                        serverurl = device.getDDNSUrlCombo();
+                    } else if (device.getWlan().networkId == Utils.getCurrentWifiNetworkId(CameraViewer.this)) {
+                        serverurl = device.getDeviceUrlCombo();
+
+                    } else {
+                        serverurl = device.getDDNSUrlCombo();
+
+                    }
+                } else {
+                    serverurl = device.getDeviceUrlCombo();
+
+                }
+                String baseurl;
+                if (!serverurl.contains("://"))
+                    baseurl = removeSlash("http://" + serverurl);
+                else
+                    baseurl = removeSlash(serverurl);
+
+                String url = baseurl + "/picture/" + cameraId + "/current?_=" + new Date().getTime();
+                url = helper.addAuthParams("GET", url, "");
+                String finalUrl = url;
+                boolean visible = position >= manager.findFirstVisibleItemPosition() && position <= manager.findLastVisibleItemPosition();
+                if (!sleeping) {
+                    if (visible)
+                        new DownloadImageFromInternet(position, frame, this).execute(finalUrl);
+                    if (!visible)
+                        new Handler().postDelayed(this, Utils.imageRefreshInterval); //Start timer after 1 sec
+                }
+
+            }
+        };
+    }
+
+
+    private class DownloadImageFromInternet extends AsyncTask<String, Void, CameraImage> {
+        Runnable timerRunnable;
+        CameraImageFrame camera;
+        int position;
+        Handler timeHandler;
+
+        public DownloadImageFromInternet(int position, CameraImageFrame camera, Runnable timerRunnable) {
+            this.camera = camera;
+            this.timerRunnable = timerRunnable;
+            this.position = position;
+            timeHandler = new Handler();
+        }
+
+        protected void onPreExecute() {
+        }
+
+        protected CameraImage doInBackground(String... urls) {
+
+            String imageURL = urls[0];
+
+
+            try {
+                URL url = new URL(imageURL);
+                URLConnection connection = url.openConnection();
+                Map<String, List<String>> fps = connection.getHeaderFields();
+                InputStream in = url.openStream();
+                final Bitmap decoded = BitmapFactory.decodeStream(in);
+                in.close();
+                for (Map.Entry<String, List<String>> key : fps.entrySet()) {
+                    for (String string : key.getValue()) {
+                        if (string.contains("capture_fps")) {
+                            double d = Double.parseDouble(string.split("capture_fps_" + camera.getCamera().getId() + "=")[1].split(";")[0].trim());
+                            String humanReadableFPS = String.valueOf(Math.round((int) d));
+                            return new CameraImage(humanReadableFPS, decoded, true);
+
+                        }
+
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                return new CameraImage(false, e.getMessage());
+            }
+            return null;
+
+        }
+
+        protected void onPostExecute(CameraImage result) {
+
+            camera.setError(null);
+            if (result.isSuccessful()) {
+                if (!camera.isInitialLoadDone()) {
+                    camera.setInitialLoadDone(true);
+                }
+                camera.setBitmap(result.getBitmap());
+                List<Long> time = camera.getTimes();
+
+                if (time.size() == Utils.fpsLen) {
+
+                    long streamingFps = time.size() * 1000 / (time.get(time.size() - 1) - time.get(0));
+                    int fpsDeliv = Math.round(streamingFps);
+                    camera.setFrameRateText((fpsDeliv + "/" + result.getFps() + " fps"));
+
+                }
+
+                long timeNow = new Date().getTime();
+                time.add(timeNow);
+                if (time.size() > Utils.fpsLen) {
+                    time.remove(0);
+                }
+
+                if (!isFinishing()) {
+                    timeHandler.postDelayed(timerRunnable, Utils.imageRefreshInterval); //Start timer after 1 sec
+                }
+
+            } else {
+                camera.setInitialLoadDone(false);
+                camera.setError(new CameraImageError("motioneye_err1", result.getErrorString(), true));
+            }
+
+            adapter.notifyItemChanged(position);
+
+        }
+    }
+
+
 
 
     private static String removeSlash(String url) {
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/DeviceSettings.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/DeviceSettings.java
index 1093f2b..377897e 100644
--- a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/DeviceSettings.java
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/DeviceSettings.java
@@ -63,6 +63,8 @@ import org.jsoup.nodes.Document;
 import org.jsoup.select.Elements;
 
 import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
 import java.security.NoSuchAlgorithmException;
 import java.util.Date;
 
@@ -124,8 +126,8 @@ public class DeviceSettings extends AppCompatActivity {
             {
                 String autoOpenID = PreferenceManager.getDefaultSharedPreferences(getContext()).getString("autoOpenID", null);
                 if (autoOpenID != null)
-                   if (autoOpenID.equals(device.getID()))
-                       ((CheckBoxPreference)findPreference("open_by_default")).setChecked(true);
+                    if (autoOpenID.equals(device.getID()))
+                        ((CheckBoxPreference) findPreference("open_by_default")).setChecked(true);
                 findPreference("open_by_default").setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                     @Override
                     public boolean onPreferenceChange(Preference preference, Object o) {
@@ -515,18 +517,15 @@ public class DeviceSettings extends AppCompatActivity {
                                     @Override
                                     public void afterTextChanged(Editable s) {
                                         String url = s.toString();
-                                        if (Utils.validIP(url)) {
 
+                                        if (!url.isEmpty()) {
 
                                             if (checkForDuplicate(device.getDeviceUrl(), url)) {
                                                 b.setEnabled(false);
-                                            }
-                                            else
+                                            } else
                                                 b.setEnabled(true);
 
-                                        } else {
 
-<<<<<<< HEAD
                                             if (url.split("://").length >= 2) {
                                                 String nUrl = url.split("://")[1];
                                                 if (nUrl.contains(":")) {
@@ -536,29 +535,25 @@ public class DeviceSettings extends AppCompatActivity {
                                                     b.setEnabled(true);
                                             } else {
                                                 if (url.contains(":")) {
-=======
-                                            b.setEnabled(false);
-                                        }
-                                        if (url.contains(":")) {
-                                            final String[] portparts = url.split(":");
-                                            editText.setText(portparts[0]);
-                                            editText.setSelection(url.length());
-
-                                            if (Utils.validIP(portparts[0])) {
-
-                                                if (checkForDuplicate(device.getDeviceUrl(), url)) {
->>>>>>> parent of cfc8134... * Fixed stream performance, now it will load only visible cameras.
                                                     b.setEnabled(false);
-                                                }
-                                                else
+                                                    return;
+                                                } else
                                                     b.setEnabled(true);
+                                            }
 
-                                            } else {
+                                            if (!URLUtil.isValidUrl(url)) {
+                                                url = "http://" + url;
+                                                b.setEnabled(URLUtil.isValidUrl(url));
+                                            } else
+                                                b.setEnabled(true);
 
-                                                b.setEnabled(false);
-                                            }
+
+                                        } else {
+                                            b.setEnabled(false);
 
                                         }
+
+
                                     }
                                 });
                                 b.setOnClickListener(new View.OnClickListener() {
@@ -627,16 +622,12 @@ public class DeviceSettings extends AppCompatActivity {
                                     public void afterTextChanged(Editable s) {
                                         String url = editText.getText().toString();
                                         if (!url.isEmpty()) {
-                                            if (Utils.isValidURL(url)) {
 
+                                            if (checkForDuplicate(device.getDdnsURL(), url)) {
+                                                b.setEnabled(false);
+                                            } else
+                                                b.setEnabled(true);
 
-                                                if (checkForDuplicate(device.getDdnsURL(), url)) {
-                                                    b.setEnabled(false);
-                                                }
-                                                else
-                                                    b.setEnabled(true);
-
-<<<<<<< HEAD
                                             if (!URLUtil.isValidUrl(url)) {
                                                 url = "http://" + url;
                                                 b.setEnabled(URLUtil.isValidUrl(url));
@@ -654,37 +645,15 @@ public class DeviceSettings extends AppCompatActivity {
                                                     b.setEnabled(false);
                                                 } else
                                                     b.setEnabled(true);
-=======
-                                            } else {
->>>>>>> parent of cfc8134... * Fixed stream performance, now it will load only visible cameras.
 
-                                                b.setEnabled(false);
                                             }
 
-                                            if (url.contains(":")) {
-                                                final String[] portparts = url.split(":");
-                                                editText.setText(portparts[0]);
-                                                editText.setSelection(url.length());
-
-                                                if (Utils.isValidURL(portparts[0])) {
-
-                                                    if (checkForDuplicate(device.getDdnsURL(), url)) {
-                                                        b.setEnabled(false);
-                                                    }
-                                                    else
-                                                        b.setEnabled(true);
-
-                                                } else {
-
-                                                    b.setEnabled(false);
-                                                }
-
-                                            }
                                         } else {
                                             b.setEnabled(true);
 
                                         }
 
+
                                     }
                                 });
                                 b.setOnClickListener(new View.OnClickListener() {
@@ -755,11 +724,10 @@ public class DeviceSettings extends AppCompatActivity {
                                         String url = s.toString();
 
 
-                                            if (checkForDuplicate(device.getDdnsURL(), url)) {
-                                                b.setEnabled(false);
-                                            }
-                                            else
-                                                b.setEnabled(true);
+                                        if (checkForDuplicate(device.getDdnsURL(), url)) {
+                                            b.setEnabled(false);
+                                        } else
+                                            b.setEnabled(true);
 
 
                                     }
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/FullCameraViewer.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/FullCameraViewer.java
index dd3dec9..6f84b75 100644
--- a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/FullCameraViewer.java
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/FullCameraViewer.java
@@ -91,11 +91,15 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
     private String baseurl;
     private Device device;
     private Camera camera;
-
-<<<<<<< HEAD
-=======
-
->>>>>>> parent of cfc8134... * Fixed stream performance, now it will load only visible cameras.
+    private ImageView cameraImage;
+    private LinearLayout loadingBar;
+    private RelativeLayout cameraFrame;
+    private LinearLayout bottomBar;
+    private LinearLayout topBar;
+    private TextView fps;
+    private ProgressBar loadingCircle;
+    private List<Long> time;
+    private String finalUrl;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -106,13 +110,13 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
         getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                 WindowManager.LayoutParams.FLAG_FULLSCREEN);
         setContentView(R.layout.activity_full_camera_viewer);
-        ImageView cameraImage = findViewById(R.id.cameraFullImage);
-        LinearLayout loadingBar = findViewById(R.id.progressBar);
-        RelativeLayout cameraFrame = findViewById(R.id.cameraFrame);
-        LinearLayout bottomBar = findViewById(R.id.bottomBar);
-        LinearLayout topBar = findViewById(R.id.topBar);
-        TextView fps = findViewById(R.id.cameraFPS);
-        ProgressBar loadingCircle = findViewById(R.id.progressBar2);
+        cameraImage = findViewById(R.id.cameraFullImage);
+        loadingBar = findViewById(R.id.progressBar);
+        cameraFrame = findViewById(R.id.cameraFrame);
+        bottomBar = findViewById(R.id.bottomBar);
+        topBar = findViewById(R.id.topBar);
+        fps = findViewById(R.id.cameraFPS);
+        loadingCircle = findViewById(R.id.progressBar2);
         TextView cameraName = findViewById(R.id.cameraName);
         RecyclerView actions = findViewById(R.id.actions);
         LinearLayout joystick = findViewById(R.id.dircontrols);
@@ -208,7 +212,7 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
                         }
                     }
                 });
-                List<Long> time = new ArrayList<>();
+                time = new ArrayList<>();
 
                 Device finalDevice = device;
                 timerRunnable = new Runnable() {
@@ -247,7 +251,7 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
                 };
                 String url = baseurl + "/picture/" + cameraId + "/current?_=" + new Date().getTime();
                 url = helper.addAuthParams("GET", url, "");
-                String finalUrl = url;
+                finalUrl = url;
                 new DownloadImageFromInternet(cameraImage, loadingBar, fps, status, loadingCircle, camera, time, cameraFrame).execute(finalUrl);
 
 
@@ -266,8 +270,9 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
     }
 
     @Override
-    public void onActionClicked(int position, String action, View button) {
+    public void onActionClicked(String action, View button) {
 
+        Log.e("FCV", "Action clicked");
         try {
             String url = baseurl + "/action/" + camera.getId() + "/" + action + "/?_=" + new Date().getTime();
             MotionEyeHelper helper = new MotionEyeHelper();
@@ -279,6 +284,9 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
             apiInterface.peformAction(url).enqueue(new Callback<ActionStatus>() {
                 @Override
                 public void onResponse(Call<ActionStatus> call, Response<ActionStatus> response) {
+                    if (response.body() != null && response.body().getStatus() != 0)
+                        Toast.makeText(FullCameraViewer.this, getString(R.string.task_failed, String.valueOf(response.body().getStatus())), Toast.LENGTH_SHORT).show();
+
                     button.setEnabled(true);
 
                 }
@@ -286,8 +294,7 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
                 @Override
                 public void onFailure(Call<ActionStatus> call, Throwable t) {
                     button.setEnabled(true);
-
-                    Toast.makeText(FullCameraViewer.this, t.getMessage(), Toast.LENGTH_SHORT).show();
+                    Toast.makeText(FullCameraViewer.this, t.getMessage(), Toast.LENGTH_LONG).show();
                 }
             });
         } catch (NoSuchAlgorithmException e) {
@@ -469,6 +476,8 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
     public void onResume() {
         super.onResume();
         attached = true;
+        new DownloadImageFromInternet(cameraImage, loadingBar, fps, status, loadingCircle, camera, time, cameraFrame).execute(finalUrl);
+
     }
 
     @Override
@@ -527,19 +536,19 @@ public class FullCameraViewer extends Activity implements ActionsAdapter.Actions
             if (actionString.contains("up")) {
                 dircontrols.setVisibility(View.VISIBLE);
                 up.setVisibility(View.VISIBLE);
-                up.setOnClickListener(v -> listener.onActionClicked(-1, "up", up));
+                up.setOnClickListener(v -> listener.onActionClicked("up", up));
             } else if (actionString.contains("right")) {
                 dircontrols.setVisibility(View.VISIBLE);
                 right.setVisibility(View.VISIBLE);
-                right.setOnClickListener(v -> listener.onActionClicked(-1, "right", right));
+                right.setOnClickListener(v -> listener.onActionClicked("right", right));
             } else if (actionString.contains("down")) {
                 dircontrols.setVisibility(View.VISIBLE);
                 down.setVisibility(View.VISIBLE);
-                down.setOnClickListener(v -> listener.onActionClicked(-1, "down", down));
+                down.setOnClickListener(v -> listener.onActionClicked("down", down));
             } else if (actionString.contains("left")) {
                 dircontrols.setVisibility(View.VISIBLE);
                 left.setVisibility(View.VISIBLE);
-                left.setOnClickListener(v -> listener.onActionClicked(-1, "left", left));
+                left.setOnClickListener(v -> listener.onActionClicked("left", left));
             }
         }
         if (left.getVisibility() == View.GONE && right.getVisibility() == View.GONE)
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/ActionsAdapter.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/ActionsAdapter.java
index 52c5dad..ba9f79d 100644
--- a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/ActionsAdapter.java
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/ActionsAdapter.java
@@ -20,6 +20,7 @@ import android.content.Context;
 import android.support.v7.widget.AppCompatImageView;
 import android.support.v7.widget.CardView;
 import android.support.v7.widget.RecyclerView;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -129,14 +130,16 @@ public class ActionsAdapter extends RecyclerView.Adapter<ActionsAdapter.ActionsV
         holder.action.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                listener.onActionClicked(position, actionString, v);
+                Log.e("AA", "Action clicked");
+                listener.onActionClicked(actionString, v);
             }
         });
+
     }
 
     public interface ActionsAdapterListener {
 
-        void onActionClicked(int position, String action, View button);
+        void onActionClicked(String action, View button);
     }
 
     @Override
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/HttpCamerasAdapter.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/HttpCamerasAdapter.java
index 553633f..8de2c6b 100644
--- a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/HttpCamerasAdapter.java
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/HttpCamerasAdapter.java
@@ -21,8 +21,10 @@ import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.os.AsyncTask;
 import android.os.Handler;
+import android.support.annotation.NonNull;
 import android.support.v7.widget.CardView;
 import android.support.v7.widget.RecyclerView;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -36,6 +38,7 @@ import com.developerfromjokela.motioneyeclient.R;
 import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
 import com.developerfromjokela.motioneyeclient.classes.Camera;
 import com.developerfromjokela.motioneyeclient.classes.CameraImage;
+import com.developerfromjokela.motioneyeclient.classes.CameraImageFrame;
 import com.developerfromjokela.motioneyeclient.classes.Device;
 import com.developerfromjokela.motioneyeclient.other.Utils;
 
@@ -47,17 +50,15 @@ import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
+import java.util.Random;
 
 import static android.app.DownloadManager.Request.NETWORK_MOBILE;
 
 public class HttpCamerasAdapter extends RecyclerView.Adapter<HttpCamerasAdapter.CamerasViewHolder> {
 
-    private Context mContext;
     private CamerasAdapterListener listener;
-    private Device device;
+    private List<CameraImageFrame> cameraImageFrames;
 
-    private boolean attached = true;
-    private Handler timerHandler = new Handler();
 
 
     public class CamerasViewHolder extends RecyclerView.ViewHolder {
@@ -68,9 +69,11 @@ public class HttpCamerasAdapter extends RecyclerView.Adapter<HttpCamerasAdapter.
         ProgressBar progressBar;
         Button tryagain;
         CardView itemCard;
+        boolean attached;
 
         CamerasViewHolder(View itemView) {
             super(itemView);
+
             cameraImage = itemView.findViewById(R.id.cameraImage);
             loadingBar = itemView.findViewById(R.id.cameraBar);
             itemCard = itemView.findViewById(R.id.itemCard);
@@ -78,15 +81,25 @@ public class HttpCamerasAdapter extends RecyclerView.Adapter<HttpCamerasAdapter.
             status = itemView.findViewById(R.id.status);
             progressBar = itemView.findViewById(R.id.progressar);
             tryagain = itemView.findViewById(R.id.tryagain);
+            attached = false;
         }
+
+
     }
 
-    public HttpCamerasAdapter(Context mContext, CamerasAdapterListener listener, Device device) {
-        this.mContext = mContext;
+    public HttpCamerasAdapter(CamerasAdapterListener listener, List<CameraImageFrame> cameraImageFrames) {
         this.listener = listener;
+        this.cameraImageFrames = cameraImageFrames;
+    }
 
-        this.device = device;
+    @Override
+    public void onViewDetachedFromWindow(@NonNull CamerasViewHolder holder) {
+        holder.attached = false;
+    }
 
+    @Override
+    public void onViewAttachedToWindow(@NonNull CamerasViewHolder holder) {
+        holder.attached = true;
     }
 
     @Override
@@ -96,240 +109,64 @@ public class HttpCamerasAdapter extends RecyclerView.Adapter<HttpCamerasAdapter.
     }
 
     @Override
-    public void onBindViewHolder(final HttpCamerasAdapter.CamerasViewHolder holder, final int position) {
-        boolean loaded = false;
-        final Camera camera = device.getCameras().get(position);
-        holder.cameraImage.setId(Integer.valueOf(camera.getId()));
-        holder.loadingBar.setId(Integer.valueOf(camera.getId()) + 4495);
-
-        int framerate = Integer.valueOf(camera.getFramerate());
-        List<Long> time = new ArrayList<>();
-        Runnable timerRunnable = new Runnable() {
-            @Override
-            public void run() {
-                // Here you can update your adapter data
-                MotionEyeHelper helper = new MotionEyeHelper();
-                helper.setUsername(device.getUser().getUsername());
-                try {
-                    helper.setPasswordHash(device.getUser().getPassword());
-                } catch (NoSuchAlgorithmException e) {
-                    e.printStackTrace();
-                }
-
-                String cameraId = camera.getId();
-                String serverurl;
-                if (device.getDdnsURL().length() > 5) {
-                    if ((Utils.getNetworkType(mContext)) == NETWORK_MOBILE) {
-                        serverurl = device.getDDNSUrlCombo();
-                    } else if (device.getWlan().networkId == Utils.getCurrentWifiNetworkId(mContext)) {
-                        serverurl = device.getDeviceUrlCombo();
-
-                    } else {
-                        serverurl = device.getDDNSUrlCombo();
-
-                    }
-                } else {
-                    serverurl = device.getDeviceUrlCombo();
-
-                }
-                String baseurl;
-                if (!serverurl.contains("://"))
-                    baseurl = removeSlash("http://" + serverurl);
-                else
-                    baseurl = removeSlash(serverurl);
-
-                String url = baseurl + "/picture/" + cameraId + "/current?_=" + new Date().getTime();
-                url = helper.addAuthParams("GET", url, "");
-                String finalUrl = url;
-
-                new DownloadImageFromInternet(holder, camera, this, time, loaded).execute(finalUrl);
-
-
+    public void onBindViewHolder(final HttpCamerasAdapter.CamerasViewHolder holder, int position) {
+        final CameraImageFrame camera = cameraImageFrames.get(position);
+
+        if (camera.getError() != null) {
+            holder.cameraImage.setVisibility(View.GONE);
+            holder.fps.setVisibility(View.GONE);
+            holder.loadingBar.setVisibility(View.VISIBLE);
+            holder.progressBar.setVisibility(View.GONE);
+            holder.tryagain.setVisibility(camera.getError().isDisplayRetry() ? View.VISIBLE : View.GONE);
+            holder.status.setText(camera.getError().getErrorCause());
+
+
+        } else {
+            if (camera.getBitmap() != null && camera.isInitialLoadDone()) {
+                holder.loadingBar.setVisibility(View.GONE);
+                holder.cameraImage.setVisibility(View.VISIBLE);
+                holder.fps.setVisibility(View.VISIBLE);
+                holder.cameraImage.setImageBitmap(camera.getBitmap());
+                holder.fps.setText(camera.getFrameRateText());
+            } else {
+                holder.cameraImage.setVisibility(View.GONE);
+                holder.fps.setVisibility(View.GONE);
+                holder.loadingBar.setVisibility(View.VISIBLE);
+                holder.progressBar.setVisibility(View.VISIBLE);
+                holder.status.setText(R.string.loading);
             }
-        };
+        }
+
 
         holder.tryagain.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                timerHandler.postDelayed(timerRunnable, Utils.imageRefreshInterval); //Start timer after 1 sec
-
+                listener.onRefreshRequest(position, camera);
             }
         });
-        timerHandler.postDelayed(timerRunnable, Utils.imageRefreshInterval); //Start timer after 1 sec
 
-        holder.itemCard.setOnClickListener(new View.OnClickListener() {
+        holder.itemView.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
                 listener.onImageClick(position, camera);
             }
         });
-    }
 
-    public interface CamerasAdapterListener {
 
-        void onImageClick(int position, Camera camera);
     }
 
-    @Override
-    public int getItemCount() {
-        return device.getCameras().size();
-    }
-
-    private static String removeSlash(String url) {
-        if (!url.endsWith("/"))
-            return url;
-        String[] parts = url.split("/");
-
-        return parts[0];
-    }
-
-    private class DownloadImageFromInternet extends AsyncTask<String, Void, CameraImage> {
-        ImageView imageView;
-        LinearLayout progressBar;
-        ProgressBar loading;
-        TextView fps, status;
-        Camera camera;
-        boolean loaded;
-        Runnable timerRunnable;
-        Button tryagain;
-        List<Long> time;
-
-        public DownloadImageFromInternet(CamerasViewHolder viewholder, Camera camera, Runnable timerRunnable, List<Long> time, boolean loaded) {
-            this.imageView = viewholder.cameraImage;
-            this.progressBar = viewholder.loadingBar;
-            this.loaded = loaded;
-            this.fps = viewholder.fps;
-            this.loading = viewholder.progressBar;
-            this.status = viewholder.status;
-            this.camera = camera;
-            this.timerRunnable = timerRunnable;
-            this.tryagain = viewholder.tryagain;
-            this.time = time;
-
-        }
-
-        protected void onPreExecute() {
-
-            status.setText(R.string.loading);
-            loading.setVisibility(View.VISIBLE);
-            tryagain.setVisibility(View.GONE);
-        }
-
-        protected CameraImage doInBackground(String... urls) {
-            String imageURL = urls[0];
-
-
-            try {
-                URL url = new URL(imageURL);
-                URLConnection connection = url.openConnection();
-                Map<String, List<String>> fps = connection.getHeaderFields();
-                String humanReadableFPS = "0";
-                InputStream in = url.openStream();
-                final Bitmap decoded = BitmapFactory.decodeStream(in);
-                in.close();
-                for (Map.Entry<String, List<String>> key : fps.entrySet()) {
-                    for (String string : key.getValue()) {
-                        if (string.contains("capture_fps")) {
-                            int ii = 0;
-
-                            double d = Double.parseDouble(string.split("capture_fps_" + camera.getId() + "=")[1].split(";")[0].trim());
-                            ii = (int) d;
-                            humanReadableFPS = String.valueOf(Math.round(ii));
-                            return new CameraImage(humanReadableFPS, decoded, true);
-
-                        }
-
-                    }
-                }
-
-
-<<<<<<< HEAD
-=======
-
-
->>>>>>> parent of cfc8134... * Fixed stream performance, now it will load only visible cameras.
-            } catch (Exception e) {
-                e.printStackTrace();
-                return new CameraImage(false, e.getMessage());
-            }
-            return null;
-
-        }
-
-        protected void onPostExecute(CameraImage result) {
-            if (result.isSuccessful()) {
-                if (!loaded) {
-                    progressBar.setVisibility(View.GONE);
-
-                    imageView.setVisibility(View.VISIBLE);
-                    loaded = true;
-
-                }
-                imageView.setImageBitmap(result.getBitmap());
-                cameraViewVisible(loaded, progressBar, imageView);
-
-                if (time.size() == Utils.fpsLen) {
-
-<<<<<<< HEAD
-                    long streamingFps = time.size() * 1000 / (time.get(time.size() - 1) - time.get(0));
-                    int fpsDeliv = Math.round(streamingFps);
-                    fps.setText(fpsDeliv + "/" + result.getFps() + " fps");
-=======
-                    long streamingFps = time.size() * 1000 / (time.get(time.size()-1) - time.get(0));
-                    int fpsDeliv = Math.round(streamingFps);
-                    fps.setText(fpsDeliv + "/"+result.getFps()+" fps");
->>>>>>> parent of cfc8134... * Fixed stream performance, now it will load only visible cameras.
-
-                }
-
-                long timeNow = new Date().getTime();
-                time.add(timeNow);
-                if (time.size() > Utils.fpsLen) {
-                    time.remove(0);
-                }
-
-                if (attached) {
-                    timerHandler.postDelayed(timerRunnable, Utils.imageRefreshInterval); //Start timer after 1 sec
-
-                }
-
-            } else {
-                loaded = false;
-                imageView.setVisibility(View.GONE);
-                progressBar.setVisibility(View.VISIBLE);
-                loading.setVisibility(View.GONE);
-                tryagain.setVisibility(View.VISIBLE);
-                status.setText(result.getErrorString());
-            }
-
-
-        }
-    }
+    public interface CamerasAdapterListener {
 
+        void onImageClick(int position, CameraImageFrame cameraImageFrame);
 
-    public void onPause() {
-        attached = false;
+        void onRefreshRequest(int position, CameraImageFrame cameraImageFrame);
     }
 
-    public void onResume() {
-        attached = true;
-        notifyDataSetChanged();
-    }
-
-    public void onDestroy() {
-        attached = false;
+    @Override
+    public int getItemCount() {
+        return cameraImageFrames.size();
     }
 
 
-    private void cameraViewVisible(boolean loaded, LinearLayout progressBar, ImageView imageView) {
-        if (!loaded) {
-            progressBar.setVisibility(View.GONE);
-            imageView.setVisibility(View.VISIBLE);
-            loaded = true;
-
-
-        }
-    }
-
 
 }
diff --git a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/setup/activities/SetupStartScreen.java b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/setup/activities/SetupStartScreen.java
index 18bd218..af9b7f0 100644
--- a/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/setup/activities/SetupStartScreen.java
+++ b/app/src/main/java/com/developerfromjokela/motioneyeclient/ui/setup/activities/SetupStartScreen.java
@@ -438,7 +438,7 @@ public class SetupStartScreen extends AppCompatActivity {
 
                                     Log.e("Setup", "Set Local Port " + portparts[1]);
                                 }
-                            }, 900);
+                            }, 1000);
                         }
 
 
diff --git a/app/src/src/androidTest/java/com/developerfromjokela/motioneyeclient/ExampleInstrumentedTest.java b/app/src/src/androidTest/java/com/developerfromjokela/motioneyeclient/ExampleInstrumentedTest.java
new file mode 100644
index 0000000..1e8d4c0
--- /dev/null
+++ b/app/src/src/androidTest/java/com/developerfromjokela/motioneyeclient/ExampleInstrumentedTest.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumented test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("com.developerfromjokela.motioneyeclient", appContext.getPackageName());
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/ApiInterface.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/ApiInterface.java
new file mode 100644
index 0000000..3af6870
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/ApiInterface.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.api;
+
+
+import com.developerfromjokela.motioneyeclient.classes.ActionStatus;
+import com.developerfromjokela.motioneyeclient.classes.Cameras;
+import com.developerfromjokela.motioneyeclient.classes.MainConfig;
+import com.developerfromjokela.motioneyeclient.classes.Media;
+import com.developerfromjokela.motioneyeclient.classes.MediaList;
+
+import okhttp3.RequestBody;
+import retrofit2.Call;
+import retrofit2.http.Body;
+import retrofit2.http.Field;
+import retrofit2.http.FormUrlEncoded;
+import retrofit2.http.GET;
+import retrofit2.http.POST;
+import retrofit2.http.Url;
+
+public interface ApiInterface {
+
+
+    @GET()
+    Call<MediaList> getMedia(@Url String url);
+
+    @GET()
+    Call<Cameras> getCameras(@Url String url);
+
+    @POST()
+    Call<okhttp3.ResponseBody> powerOff(@Url String url);
+
+    @GET()
+    Call<MainConfig> getMainConfig(@Url String url);
+
+    @POST()
+    Call<ActionStatus> peformAction(@Url String url);
+
+    @GET()
+    Call<okhttp3.ResponseBody> getMotionDetails(@Url String url);
+
+    @FormUrlEncoded
+    @POST()
+    Call<okhttp3.ResponseBody> login(@Url String url, @Field("username") String username, @Field("password") String password, @Field("login") String login);
+
+    @POST()
+    Call<okhttp3.ResponseBody> changeMainConfig(@Url String url, @Body RequestBody body);
+
+    @GET()
+    Call<okhttp3.ResponseBody> loginResult(@Url String url);
+}
\ No newline at end of file
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/MotionEyeHelper.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/MotionEyeHelper.java
new file mode 100644
index 0000000..95e7687
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/MotionEyeHelper.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.api;
+
+
+import android.os.Build;
+import android.text.TextUtils;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+
+public class MotionEyeHelper {
+
+
+    private String username;
+    private boolean loggedIn;
+    private String passwordHash = "";
+    private static String TAG = MotionEyeHelper.class.getSimpleName();
+
+    public MotionEyeHelper() {
+
+    }
+
+    public String getUsername() {
+        return username;
+    }
+
+    public void setUsername(String username) {
+        this.username = username;
+    }
+
+
+    public boolean isLoggedIn() {
+        return loggedIn;
+    }
+
+    public void setLoggedIn(boolean loggedIn) {
+        this.loggedIn = loggedIn;
+    }
+
+    public String getPasswordHash() {
+        return passwordHash;
+    }
+
+    public void setPasswordHash(String passwordHash) throws NoSuchAlgorithmException {
+        this.passwordHash = sha1(passwordHash);
+    }
+
+    public String addAuthParams(String method, String url, String body) {
+        if (url.indexOf('?') < 0) {
+            url += '?';
+        } else {
+            url += '&';
+        }
+
+        url += "_username=" + username;
+        if (loggedIn) {
+            url += "&_login=true";
+            loggedIn = false;
+        }
+
+        try {
+            String signature = computeSignature(method, url, body);
+            url += "&_signature=" + signature;
+
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+        return url;
+    }
+
+    private String computeSignature(String method, String path, String body) throws NoSuchAlgorithmException {
+        String basePath = removeAllAfterShash(qualifyPath(""));
+
+        path = qualifyPath(path);
+
+        TreeMap<String, String> query = new TreeMap<>(getQueryMap(path));
+        path = removeAllAfterShash(qualifyPath(path));
+        path = '/' + path.substring(getBaseUrl(basePath).length());
+
+        // do what you have to do here
+        // In your case, another loop.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            query.keySet().removeIf(key -> key.contains("_signature"));
+        } else {
+            Iterator<String> keyiterator = query.keySet().iterator();
+            while (keyiterator.hasNext()) {
+                String key = keyiterator.next();
+                if (key.contains("_signature"))
+                    keyiterator.remove();
+            }
+        }
+        List<String> paramsStr = new ArrayList<>();
+        for (Map.Entry<String, String> entry : query.entrySet()) {
+            StringBuilder builder = new StringBuilder();
+            String key = entry.getKey();
+            String value = entry.getValue();
+            builder.append(key);
+            builder.append("=");
+            builder.append(value);
+            paramsStr.add(builder.toString());
+        }
+        path = path + '?' + TextUtils.join("&", paramsStr.toArray(new String[]{}));
+        path = path.replace("[^a-zA-Z0-9/?_.=&{}\\[\\]\":, -]", "-");
+
+        body = body.replace("[^a-zA-Z0-9/?_.=&{}\\[\\]\":, -]", "-");
+        if (body.isEmpty()) {
+            body = "";
+        }
+        return sha1(method + ':' + path + ':' + body + ':' + passwordHash).toLowerCase();
+
+
+    }
+
+    private static String sha1(String input) throws NoSuchAlgorithmException {
+        MessageDigest mDigest = MessageDigest.getInstance("SHA1");
+        byte[] result = mDigest.digest(input.getBytes());
+        StringBuilder sb = new StringBuilder();
+        for (byte aResult : result) {
+            sb.append(Integer.toString((aResult & 0xff) + 0x100, 16).substring(1));
+        }
+
+        return sb.toString();
+    }
+
+    private static String qualifyPath(String path) {
+        String url = qualifyUrl(path);
+        int pos = url.indexOf("//");
+        if (pos < 0) { // Not a Full URL
+            return url;
+        }
+
+        url = url.substring(pos + 2);
+        pos = url.indexOf('/');
+        if (pos < 0) { /* root with no trailing slash */
+            return "";
+        }
+
+        return url.substring(pos);
+    }
+
+    private static String qualifyUrl(String url) {
+        String finalUrl;
+        int start = url.indexOf("//");
+        if (start < 0) {
+            finalUrl = "http://" + url;
+        } else {
+            finalUrl = url.substring(start);
+        }
+        return finalUrl;
+    }
+
+
+    private static String removeAllAfterShash(String url) {
+        String[] parts = url.split("\\?");
+
+        return parts[0];
+    }
+
+    private static String getBaseUrl(String url) {
+        String[] parts = url.split("\\?");
+
+        String finalUrl = parts[0];
+
+        if (!finalUrl.endsWith("/"))
+            finalUrl = finalUrl + "/";
+
+        return finalUrl;
+    }
+
+
+    private static Map<String, String> getQueryMap(String query) {
+        List<String> params = new ArrayList<>(Arrays.asList(query.split("[&?]")));
+
+        params.remove(0); // Removing Domain or something else which is not the Param
+        Map<String, String> map = new HashMap<>();
+
+        for (String param : params) {
+
+            String name = param.split("=")[0];
+            String value = param.split("=")[1];
+            map.put(name, value);
+        }
+        return map;
+    }
+
+
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/ServiceGenerator.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/ServiceGenerator.java
new file mode 100644
index 0000000..fa7096a
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/api/ServiceGenerator.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.api;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import java.util.concurrent.TimeUnit;
+
+import okhttp3.OkHttpClient;
+import okhttp3.logging.HttpLoggingInterceptor;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+
+public class ServiceGenerator {
+    private static Retrofit retrofit = null;
+    private static Gson gson = new GsonBuilder().create();
+    private static OkHttpClient.Builder client = new OkHttpClient.Builder();
+
+
+    public static <T> T createService(Class<T> serviceClass, String BASE_URL) {
+        if (retrofit == null) {
+
+
+            retrofit = new Retrofit.Builder()
+                    .client(createOkHttpClient(false))
+                    .baseUrl(BASE_URL)
+                    .addConverterFactory(GsonConverterFactory.create(gson))
+                    .build();
+        }
+        return retrofit.create(serviceClass);
+    }
+
+    private static OkHttpClient createOkHttpClient(boolean canCache) {
+        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
+        logging.setLevel(HttpLoggingInterceptor.Level.BODY);
+        return new OkHttpClient.Builder()
+                .readTimeout(60, TimeUnit.SECONDS)
+                .connectTimeout(60 / 2, TimeUnit.SECONDS)
+                .addInterceptor(logging)
+                .writeTimeout(60, TimeUnit.SECONDS)
+                .cache(null)
+                .build();
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/ActionStatus.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/ActionStatus.java
new file mode 100644
index 0000000..955a573
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/ActionStatus.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+public class ActionStatus {
+
+
+    @SerializedName("status")
+    private int status = 0;
+
+    public ActionStatus(int status) {
+        this.status = status;
+    }
+
+    public int getStatus() {
+        return status;
+    }
+
+    public void setStatus(int status) {
+        this.status = status;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Camera.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Camera.java
new file mode 100644
index 0000000..3c9b109
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Camera.java
@@ -0,0 +1,1194 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.developerfromjokela.motioneyeclient.classes.disks.Disk;
+import com.google.gson.annotations.SerializedName;
+
+import java.io.Serializable;
+import java.util.List;
+
+public class Camera implements Serializable {
+
+
+    @SerializedName("show_frame_changes")
+    private boolean show_frame_changes;
+    @SerializedName("actions")
+    private List<String> actions;
+    @SerializedName("preserve_movies")
+    private String preserve_movies;
+    @SerializedName("recording_mode")
+    private String recording_mode;
+    @SerializedName("monday_to")
+    private String monday_to;
+    @SerializedName("light_switch_detect")
+    private String light_switch_detect;
+    @SerializedName("command_end_notifications_enabled")
+    private boolean command_end_notifications_enabled;
+    @SerializedName("smb_shares")
+    private boolean smb_shares;
+    @SerializedName("upload_server")
+    private String upload_server;
+    @SerializedName("monday_from")
+    private String monday_from;
+    @SerializedName("audo_brightness")
+    private boolean audo_brightness;
+    @SerializedName("frame_change_threshold")
+    private String frame_change_threshold;
+    @SerializedName("name")
+    private String name;
+    @SerializedName("movie_format")
+    private String movie_format;
+    @SerializedName("network_username")
+    private String network_username;
+    @SerializedName("preserve_pictures")
+    private String preserve_pictures;
+    @SerializedName("event_gap")
+    private String event_gap;
+    @SerializedName("capture_mode")
+    private String capture_mode;
+    @SerializedName("upload_movie")
+    private boolean upload_movie;
+    @SerializedName("video_streaming")
+    private boolean video_streaming;
+    @SerializedName("upload_location")
+    private String upload_location;
+    @SerializedName("max_movie_length")
+    private String max_movie_length;
+    @SerializedName("movie_file_name")
+    private String movie_file_name;
+    @SerializedName("upload_authorization_key")
+    private String upload_authorization_key;
+    @SerializedName("still_images")
+    private boolean still_images;
+    @SerializedName("upload_method")
+
+    private String upload_method;
+    @SerializedName("streaming_resolution")
+
+    private String streaming_resolution;
+    @SerializedName("device_url")
+
+    private String device_url;
+    @SerializedName("text_overlay")
+
+    private boolean text_overlay;
+    @SerializedName("right_text")
+
+    private String right_text;
+    @SerializedName("upload_picture")
+
+    private boolean upload_picture;
+    @SerializedName("email_notifications_enabled")
+
+    private boolean email_notifications_enabled;
+    @SerializedName("working_schedule_type")
+
+    private String working_schedule_type;
+    @SerializedName("enabled")
+
+    private boolean enabled;
+    @SerializedName("movie_quality")
+
+    private String movie_quality;
+    @SerializedName("disk_total")
+
+    private String disk_total;
+    @SerializedName("upload_service")
+
+    private String upload_service;
+    @SerializedName("upload_password")
+
+    private String upload_password;
+    @SerializedName("wednesday_to")
+
+    private String wednesday_to;
+    @SerializedName("mask_type")
+
+    private String mask_type;
+    @SerializedName("command_storage_enabled")
+
+    private boolean command_storage_enabled;
+    @SerializedName("disk_used")
+
+    private String disk_used;
+    @SerializedName("streaming_motion")
+
+    private String streaming_motion;
+    @SerializedName("manual_snapshots")
+
+    private boolean manual_snapshots;
+    @SerializedName("noise_level")
+
+    private String noise_level;
+    @SerializedName("mask_lines")
+
+    private List<String> mask_lines;
+    @SerializedName("upload_enabled")
+
+    private boolean upload_enabled;
+    @SerializedName("root_directory")
+
+    private String root_directory;
+    @SerializedName("working_schedule")
+
+    private boolean working_schedule;
+    @SerializedName("pre_capture")
+
+    private String pre_capture;
+    @SerializedName("command_notifications_enabled")
+
+    private boolean command_notifications_enabled;
+    @SerializedName("streaming_framerate")
+
+    private String streaming_framerate;
+    @SerializedName("email_notifications_picture_time_span")
+
+    private String email_notifications_picture_time_span;
+    @SerializedName("thursday_to")
+
+    private String thursday_to;
+    @SerializedName("streaming_server_resize")
+
+    private boolean streaming_server_resize;
+    @SerializedName("upload_subfolders")
+
+    private boolean upload_subfolders;
+    @SerializedName("sunday_to")
+
+    private String sunday_to;
+    @SerializedName("left_text")
+
+    private String left_text;
+    @SerializedName("image_file_name")
+
+    private String image_file_name;
+    @SerializedName("rotation")
+
+    private String rotation;
+    @SerializedName("framerate")
+
+    private String framerate;
+    @SerializedName("movies")
+
+    private boolean movies;
+    @SerializedName("motion_detection")
+
+    private boolean motion_detection;
+    @SerializedName("upload_username")
+
+    private String upload_username;
+    @SerializedName("upload_port")
+
+    private String upload_port;
+    @SerializedName("available_disks")
+
+    private List<Disk> available_disks;
+    @SerializedName("network_smb_ver")
+
+    private String network_smb_ver;
+    @SerializedName("streaming_auth_mode")
+
+    private String streaming_auth_mode;
+    @SerializedName("despeckle_filter")
+
+    private String despeckle_filter;
+    @SerializedName("snapshot_Stringerval")
+
+    private String snapshot_Stringerval;
+    @SerializedName("minimum_motion_frames")
+
+    private String minimum_motion_frames;
+
+    @SerializedName("auto_noise_detect")
+    private boolean auto_noise_detect;
+    @SerializedName("network_share_name")
+
+    private String network_share_name;
+    @SerializedName("sunday_from")
+
+    private String sunday_from;
+    @SerializedName("friday_from")
+
+    private String friday_from;
+    @SerializedName("web_hook_storage_enabled")
+
+    private boolean web_hook_storage_enabled;
+    @SerializedName("custom_left_text")
+
+    private String custom_left_text;
+    @SerializedName("streaming_port")
+
+    private String streaming_port;
+    @SerializedName("id")
+
+    private String id;
+    @SerializedName("post_capture")
+
+    private String post_capture;
+    @SerializedName("streaming_quality")
+
+    private String streaming_quality;
+    @SerializedName("wednesday_from")
+
+    private String wednesday_from;
+    @SerializedName("proto")
+
+    private String proto;
+    @SerializedName("extra_options")
+
+    private List<List<String>> extra_options;
+    @SerializedName("image_quality")
+
+    private String image_quality;
+    @SerializedName("create_debug_media")
+
+    private boolean create_debug_media;
+    @SerializedName("friday_to")
+
+    private String friday_to;
+    @SerializedName("custom_right_text")
+
+    private String custom_right_text;
+    @SerializedName("web_hook_notifications_enabled")
+
+    private boolean web_hook_notifications_enabled;
+    @SerializedName("saturday_from")
+
+    private String saturday_from;
+    @SerializedName("tuesday_from")
+
+    private String tuesday_from;
+    @SerializedName("network_password")
+
+    private String network_password;
+    @SerializedName("saturday_to")
+
+    private String saturday_to;
+    @SerializedName("newtork_server")
+
+    private String newtork_server;
+    @SerializedName("smart_mask_sluggishness")
+
+    private String smart_mask_sluggishness;
+    @SerializedName("mask")
+
+    private boolean mask;
+    @SerializedName("tuesday_to")
+
+    private String tuesday_to;
+    @SerializedName("thursday_from")
+
+    private String thursday_from;
+    @SerializedName("storage_device")
+
+    private String storage_device;
+
+    public Camera(boolean show_frame_changes, List<String> actions, String preserve_movies, String recording_mode, String monday_to, String light_switch_detect, boolean command_end_notifications_enabled, boolean smb_shares, String upload_server, String monday_from, boolean audo_brightness, String frame_change_threshold, String name, String movie_format, String network_username, String preserve_pictures, String event_gap, String capture_mode, boolean upload_movie, boolean video_streaming, String upload_location, String max_movie_length, String movie_file_name, String upload_authorization_key, boolean still_images, String upload_method, String streaming_resolution, String device_url, boolean text_overlay, String right_text, boolean upload_picture, boolean email_notifications_enabled, String working_schedule_type, boolean enabled, String movie_quality, String disk_total, String upload_service, String upload_password, String wednesday_to, String mask_type, boolean command_storage_enabled, String disk_used, String streaming_motion, boolean manual_snapshots, String noise_level, List<String> mask_lines, boolean upload_enabled, String root_directory, boolean working_schedule, String pre_capture, boolean command_notifications_enabled, String streaming_framerate, String email_notifications_picture_time_span, String thursday_to, boolean streaming_server_resize, boolean upload_subfolders, String sunday_to, String left_text, String image_file_name, String rotation, String framerate, boolean movies, boolean motion_detection, String upload_username, String upload_port, List<Disk> available_disks, String network_smb_ver, String streaming_auth_mode, String despeckle_filter, String snapshot_Stringerval, String minimum_motion_frames, boolean auto_noise_detect, String network_share_name, String sunday_from, String friday_from, boolean web_hook_storage_enabled, String custom_left_text, String streaming_port, String id, String post_capture, String streaming_quality, String wednesday_from, String proto, List<List<String>> extra_options, String image_quality, boolean create_debug_media, String friday_to, String custom_right_text, boolean web_hook_notifications_enabled, String saturday_from, String tuesday_from, String network_password, String saturday_to, String newtork_server, String smart_mask_sluggishness, boolean mask, String tuesday_to, String thursday_from, String storage_device) {
+        this.show_frame_changes = show_frame_changes;
+        this.actions = actions;
+        this.preserve_movies = preserve_movies;
+        this.recording_mode = recording_mode;
+        this.monday_to = monday_to;
+        this.light_switch_detect = light_switch_detect;
+        this.command_end_notifications_enabled = command_end_notifications_enabled;
+        this.smb_shares = smb_shares;
+        this.upload_server = upload_server;
+        this.monday_from = monday_from;
+        this.audo_brightness = audo_brightness;
+        this.frame_change_threshold = frame_change_threshold;
+        this.name = name;
+        this.movie_format = movie_format;
+        this.network_username = network_username;
+        this.preserve_pictures = preserve_pictures;
+        this.event_gap = event_gap;
+        this.capture_mode = capture_mode;
+        this.upload_movie = upload_movie;
+        this.video_streaming = video_streaming;
+        this.upload_location = upload_location;
+        this.max_movie_length = max_movie_length;
+        this.movie_file_name = movie_file_name;
+        this.upload_authorization_key = upload_authorization_key;
+        this.still_images = still_images;
+        this.upload_method = upload_method;
+        this.streaming_resolution = streaming_resolution;
+        this.device_url = device_url;
+        this.text_overlay = text_overlay;
+        this.right_text = right_text;
+        this.upload_picture = upload_picture;
+        this.email_notifications_enabled = email_notifications_enabled;
+        this.working_schedule_type = working_schedule_type;
+        this.enabled = enabled;
+        this.movie_quality = movie_quality;
+        this.disk_total = disk_total;
+        this.upload_service = upload_service;
+        this.upload_password = upload_password;
+        this.wednesday_to = wednesday_to;
+        this.mask_type = mask_type;
+        this.command_storage_enabled = command_storage_enabled;
+        this.disk_used = disk_used;
+        this.streaming_motion = streaming_motion;
+        this.manual_snapshots = manual_snapshots;
+        this.noise_level = noise_level;
+        this.mask_lines = mask_lines;
+        this.upload_enabled = upload_enabled;
+        this.root_directory = root_directory;
+        this.working_schedule = working_schedule;
+        this.pre_capture = pre_capture;
+        this.command_notifications_enabled = command_notifications_enabled;
+        this.streaming_framerate = streaming_framerate;
+        this.email_notifications_picture_time_span = email_notifications_picture_time_span;
+        this.thursday_to = thursday_to;
+        this.streaming_server_resize = streaming_server_resize;
+        this.upload_subfolders = upload_subfolders;
+        this.sunday_to = sunday_to;
+        this.left_text = left_text;
+        this.image_file_name = image_file_name;
+        this.rotation = rotation;
+        this.framerate = framerate;
+        this.movies = movies;
+        this.motion_detection = motion_detection;
+        this.upload_username = upload_username;
+        this.upload_port = upload_port;
+        this.available_disks = available_disks;
+        this.network_smb_ver = network_smb_ver;
+        this.streaming_auth_mode = streaming_auth_mode;
+        this.despeckle_filter = despeckle_filter;
+        this.snapshot_Stringerval = snapshot_Stringerval;
+        this.minimum_motion_frames = minimum_motion_frames;
+        this.auto_noise_detect = auto_noise_detect;
+        this.network_share_name = network_share_name;
+        this.sunday_from = sunday_from;
+        this.friday_from = friday_from;
+        this.web_hook_storage_enabled = web_hook_storage_enabled;
+        this.custom_left_text = custom_left_text;
+        this.streaming_port = streaming_port;
+        this.id = id;
+        this.post_capture = post_capture;
+        this.streaming_quality = streaming_quality;
+        this.wednesday_from = wednesday_from;
+        this.proto = proto;
+        this.extra_options = extra_options;
+        this.image_quality = image_quality;
+        this.create_debug_media = create_debug_media;
+        this.friday_to = friday_to;
+        this.custom_right_text = custom_right_text;
+        this.web_hook_notifications_enabled = web_hook_notifications_enabled;
+        this.saturday_from = saturday_from;
+        this.tuesday_from = tuesday_from;
+        this.network_password = network_password;
+        this.saturday_to = saturday_to;
+        this.newtork_server = newtork_server;
+        this.smart_mask_sluggishness = smart_mask_sluggishness;
+        this.mask = mask;
+        this.tuesday_to = tuesday_to;
+        this.thursday_from = thursday_from;
+        this.storage_device = storage_device;
+    }
+
+    public boolean isShow_frame_changes() {
+        return show_frame_changes;
+    }
+
+    public void setShow_frame_changes(boolean show_frame_changes) {
+        this.show_frame_changes = show_frame_changes;
+    }
+
+    public List<String> getActions() {
+        return actions;
+    }
+
+    public void setActions(List<String> actions) {
+        this.actions = actions;
+    }
+
+    public String getPreserve_movies() {
+        return preserve_movies;
+    }
+
+    public void setPreserve_movies(String preserve_movies) {
+        this.preserve_movies = preserve_movies;
+    }
+
+    public String getRecording_mode() {
+        return recording_mode;
+    }
+
+    public void setRecording_mode(String recording_mode) {
+        this.recording_mode = recording_mode;
+    }
+
+    public String getMonday_to() {
+        return monday_to;
+    }
+
+    public void setMonday_to(String monday_to) {
+        this.monday_to = monday_to;
+    }
+
+    public String getLight_switch_detect() {
+        return light_switch_detect;
+    }
+
+    public void setLight_switch_detect(String light_switch_detect) {
+        this.light_switch_detect = light_switch_detect;
+    }
+
+    public boolean isCommand_end_notifications_enabled() {
+        return command_end_notifications_enabled;
+    }
+
+    public void setCommand_end_notifications_enabled(boolean command_end_notifications_enabled) {
+        this.command_end_notifications_enabled = command_end_notifications_enabled;
+    }
+
+    public boolean isSmb_shares() {
+        return smb_shares;
+    }
+
+    public void setSmb_shares(boolean smb_shares) {
+        this.smb_shares = smb_shares;
+    }
+
+    public String getUpload_server() {
+        return upload_server;
+    }
+
+    public void setUpload_server(String upload_server) {
+        this.upload_server = upload_server;
+    }
+
+    public String getMonday_from() {
+        return monday_from;
+    }
+
+    public void setMonday_from(String monday_from) {
+        this.monday_from = monday_from;
+    }
+
+    public boolean isAudo_brightness() {
+        return audo_brightness;
+    }
+
+    public void setAudo_brightness(boolean audo_brightness) {
+        this.audo_brightness = audo_brightness;
+    }
+
+    public String getFrame_change_threshold() {
+        return frame_change_threshold;
+    }
+
+    public void setFrame_change_threshold(String frame_change_threshold) {
+        this.frame_change_threshold = frame_change_threshold;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getMovie_format() {
+        return movie_format;
+    }
+
+    public void setMovie_format(String movie_format) {
+        this.movie_format = movie_format;
+    }
+
+    public String getNetwork_username() {
+        return network_username;
+    }
+
+    public void setNetwork_username(String network_username) {
+        this.network_username = network_username;
+    }
+
+    public String getPreserve_pictures() {
+        return preserve_pictures;
+    }
+
+    public void setPreserve_pictures(String preserve_pictures) {
+        this.preserve_pictures = preserve_pictures;
+    }
+
+    public String getEvent_gap() {
+        return event_gap;
+    }
+
+    public void setEvent_gap(String event_gap) {
+        this.event_gap = event_gap;
+    }
+
+    public String getCapture_mode() {
+        return capture_mode;
+    }
+
+    public void setCapture_mode(String capture_mode) {
+        this.capture_mode = capture_mode;
+    }
+
+    public boolean isUpload_movie() {
+        return upload_movie;
+    }
+
+    public void setUpload_movie(boolean upload_movie) {
+        this.upload_movie = upload_movie;
+    }
+
+    public boolean isVideo_streaming() {
+        return video_streaming;
+    }
+
+    public void setVideo_streaming(boolean video_streaming) {
+        this.video_streaming = video_streaming;
+    }
+
+    public String getUpload_location() {
+        return upload_location;
+    }
+
+    public void setUpload_location(String upload_location) {
+        this.upload_location = upload_location;
+    }
+
+    public String getMax_movie_length() {
+        return max_movie_length;
+    }
+
+    public void setMax_movie_length(String max_movie_length) {
+        this.max_movie_length = max_movie_length;
+    }
+
+    public String getMovie_file_name() {
+        return movie_file_name;
+    }
+
+    public void setMovie_file_name(String movie_file_name) {
+        this.movie_file_name = movie_file_name;
+    }
+
+    public String getUpload_authorization_key() {
+        return upload_authorization_key;
+    }
+
+    public void setUpload_authorization_key(String upload_authorization_key) {
+        this.upload_authorization_key = upload_authorization_key;
+    }
+
+    public boolean isStill_images() {
+        return still_images;
+    }
+
+    public void setStill_images(boolean still_images) {
+        this.still_images = still_images;
+    }
+
+    public String getUpload_method() {
+        return upload_method;
+    }
+
+    public void setUpload_method(String upload_method) {
+        this.upload_method = upload_method;
+    }
+
+    public String getStreaming_resolution() {
+        return streaming_resolution;
+    }
+
+    public void setStreaming_resolution(String streaming_resolution) {
+        this.streaming_resolution = streaming_resolution;
+    }
+
+    public String getDevice_url() {
+        return device_url;
+    }
+
+    public void setDevice_url(String device_url) {
+        this.device_url = device_url;
+    }
+
+    public boolean isText_overlay() {
+        return text_overlay;
+    }
+
+    public void setText_overlay(boolean text_overlay) {
+        this.text_overlay = text_overlay;
+    }
+
+    public String getRight_text() {
+        return right_text;
+    }
+
+    public void setRight_text(String right_text) {
+        this.right_text = right_text;
+    }
+
+    public boolean isUpload_picture() {
+        return upload_picture;
+    }
+
+    public void setUpload_picture(boolean upload_picture) {
+        this.upload_picture = upload_picture;
+    }
+
+    public boolean isEmail_notifications_enabled() {
+        return email_notifications_enabled;
+    }
+
+    public void setEmail_notifications_enabled(boolean email_notifications_enabled) {
+        this.email_notifications_enabled = email_notifications_enabled;
+    }
+
+    public String getWorking_schedule_type() {
+        return working_schedule_type;
+    }
+
+    public void setWorking_schedule_type(String working_schedule_type) {
+        this.working_schedule_type = working_schedule_type;
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    public String getMovie_quality() {
+        return movie_quality;
+    }
+
+    public void setMovie_quality(String movie_quality) {
+        this.movie_quality = movie_quality;
+    }
+
+    public String getDisk_total() {
+        return disk_total;
+    }
+
+    public void setDisk_total(String disk_total) {
+        this.disk_total = disk_total;
+    }
+
+    public String getUpload_service() {
+        return upload_service;
+    }
+
+    public void setUpload_service(String upload_service) {
+        this.upload_service = upload_service;
+    }
+
+    public String getUpload_password() {
+        return upload_password;
+    }
+
+    public void setUpload_password(String upload_password) {
+        this.upload_password = upload_password;
+    }
+
+    public String getWednesday_to() {
+        return wednesday_to;
+    }
+
+    public void setWednesday_to(String wednesday_to) {
+        this.wednesday_to = wednesday_to;
+    }
+
+    public String getMask_type() {
+        return mask_type;
+    }
+
+    public void setMask_type(String mask_type) {
+        this.mask_type = mask_type;
+    }
+
+    public boolean isCommand_storage_enabled() {
+        return command_storage_enabled;
+    }
+
+    public void setCommand_storage_enabled(boolean command_storage_enabled) {
+        this.command_storage_enabled = command_storage_enabled;
+    }
+
+    public String getDisk_used() {
+        return disk_used;
+    }
+
+    public void setDisk_used(String disk_used) {
+        this.disk_used = disk_used;
+    }
+
+    public String getStreaming_motion() {
+        return streaming_motion;
+    }
+
+    public void setStreaming_motion(String streaming_motion) {
+        this.streaming_motion = streaming_motion;
+    }
+
+    public boolean isManual_snapshots() {
+        return manual_snapshots;
+    }
+
+    public void setManual_snapshots(boolean manual_snapshots) {
+        this.manual_snapshots = manual_snapshots;
+    }
+
+    public String getNoise_level() {
+        return noise_level;
+    }
+
+    public void setNoise_level(String noise_level) {
+        this.noise_level = noise_level;
+    }
+
+    public List<String> getMask_lines() {
+        return mask_lines;
+    }
+
+    public void setMask_lines(List<String> mask_lines) {
+        this.mask_lines = mask_lines;
+    }
+
+    public boolean isUpload_enabled() {
+        return upload_enabled;
+    }
+
+    public void setUpload_enabled(boolean upload_enabled) {
+        this.upload_enabled = upload_enabled;
+    }
+
+    public String getRoot_directory() {
+        return root_directory;
+    }
+
+    public void setRoot_directory(String root_directory) {
+        this.root_directory = root_directory;
+    }
+
+    public boolean isWorking_schedule() {
+        return working_schedule;
+    }
+
+    public void setWorking_schedule(boolean working_schedule) {
+        this.working_schedule = working_schedule;
+    }
+
+    public String getPre_capture() {
+        return pre_capture;
+    }
+
+    public void setPre_capture(String pre_capture) {
+        this.pre_capture = pre_capture;
+    }
+
+    public boolean isCommand_notifications_enabled() {
+        return command_notifications_enabled;
+    }
+
+    public void setCommand_notifications_enabled(boolean command_notifications_enabled) {
+        this.command_notifications_enabled = command_notifications_enabled;
+    }
+
+    public String getStreaming_framerate() {
+        return streaming_framerate;
+    }
+
+    public void setStreaming_framerate(String streaming_framerate) {
+        this.streaming_framerate = streaming_framerate;
+    }
+
+    public String getEmail_notifications_picture_time_span() {
+        return email_notifications_picture_time_span;
+    }
+
+    public void setEmail_notifications_picture_time_span(String email_notifications_picture_time_span) {
+        this.email_notifications_picture_time_span = email_notifications_picture_time_span;
+    }
+
+    public String getThursday_to() {
+        return thursday_to;
+    }
+
+    public void setThursday_to(String thursday_to) {
+        this.thursday_to = thursday_to;
+    }
+
+    public boolean isStreaming_server_resize() {
+        return streaming_server_resize;
+    }
+
+    public void setStreaming_server_resize(boolean streaming_server_resize) {
+        this.streaming_server_resize = streaming_server_resize;
+    }
+
+    public boolean isUpload_subfolders() {
+        return upload_subfolders;
+    }
+
+    public void setUpload_subfolders(boolean upload_subfolders) {
+        this.upload_subfolders = upload_subfolders;
+    }
+
+    public String getSunday_to() {
+        return sunday_to;
+    }
+
+    public void setSunday_to(String sunday_to) {
+        this.sunday_to = sunday_to;
+    }
+
+    public String getLeft_text() {
+        return left_text;
+    }
+
+    public void setLeft_text(String left_text) {
+        this.left_text = left_text;
+    }
+
+    public String getImage_file_name() {
+        return image_file_name;
+    }
+
+    public void setImage_file_name(String image_file_name) {
+        this.image_file_name = image_file_name;
+    }
+
+    public String getRotation() {
+        return rotation;
+    }
+
+    public void setRotation(String rotation) {
+        this.rotation = rotation;
+    }
+
+    public String getFramerate() {
+        return framerate;
+    }
+
+    public void setFramerate(String framerate) {
+        this.framerate = framerate;
+    }
+
+    public boolean isMovies() {
+        return movies;
+    }
+
+    public void setMovies(boolean movies) {
+        this.movies = movies;
+    }
+
+    public boolean isMotion_detection() {
+        return motion_detection;
+    }
+
+    public void setMotion_detection(boolean motion_detection) {
+        this.motion_detection = motion_detection;
+    }
+
+    public String getUpload_username() {
+        return upload_username;
+    }
+
+    public void setUpload_username(String upload_username) {
+        this.upload_username = upload_username;
+    }
+
+    public String getUpload_port() {
+        return upload_port;
+    }
+
+    public void setUpload_port(String upload_port) {
+        this.upload_port = upload_port;
+    }
+
+    public List<Disk> getAvailable_disks() {
+        return available_disks;
+    }
+
+    public void setAvailable_disks(List<Disk> available_disks) {
+        this.available_disks = available_disks;
+    }
+
+    public String getNetwork_smb_ver() {
+        return network_smb_ver;
+    }
+
+    public void setNetwork_smb_ver(String network_smb_ver) {
+        this.network_smb_ver = network_smb_ver;
+    }
+
+    public String getStreaming_auth_mode() {
+        return streaming_auth_mode;
+    }
+
+    public void setStreaming_auth_mode(String streaming_auth_mode) {
+        this.streaming_auth_mode = streaming_auth_mode;
+    }
+
+    public String getDespeckle_filter() {
+        return despeckle_filter;
+    }
+
+    public void setDespeckle_filter(String despeckle_filter) {
+        this.despeckle_filter = despeckle_filter;
+    }
+
+    public String getSnapshot_Stringerval() {
+        return snapshot_Stringerval;
+    }
+
+    public void setSnapshot_Stringerval(String snapshot_Stringerval) {
+        this.snapshot_Stringerval = snapshot_Stringerval;
+    }
+
+    public String getMinimum_motion_frames() {
+        return minimum_motion_frames;
+    }
+
+    public void setMinimum_motion_frames(String minimum_motion_frames) {
+        this.minimum_motion_frames = minimum_motion_frames;
+    }
+
+    public boolean isAuto_noise_detect() {
+        return auto_noise_detect;
+    }
+
+    public void setAuto_noise_detect(boolean auto_noise_detect) {
+        this.auto_noise_detect = auto_noise_detect;
+    }
+
+    public String getNetwork_share_name() {
+        return network_share_name;
+    }
+
+    public void setNetwork_share_name(String network_share_name) {
+        this.network_share_name = network_share_name;
+    }
+
+    public String getSunday_from() {
+        return sunday_from;
+    }
+
+    public void setSunday_from(String sunday_from) {
+        this.sunday_from = sunday_from;
+    }
+
+    public String getFriday_from() {
+        return friday_from;
+    }
+
+    public void setFriday_from(String friday_from) {
+        this.friday_from = friday_from;
+    }
+
+    public boolean isWeb_hook_storage_enabled() {
+        return web_hook_storage_enabled;
+    }
+
+    public void setWeb_hook_storage_enabled(boolean web_hook_storage_enabled) {
+        this.web_hook_storage_enabled = web_hook_storage_enabled;
+    }
+
+    public String getCustom_left_text() {
+        return custom_left_text;
+    }
+
+    public void setCustom_left_text(String custom_left_text) {
+        this.custom_left_text = custom_left_text;
+    }
+
+    public String getStreaming_port() {
+        return streaming_port;
+    }
+
+    public void setStreaming_port(String streaming_port) {
+        this.streaming_port = streaming_port;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    public String getPost_capture() {
+        return post_capture;
+    }
+
+    public void setPost_capture(String post_capture) {
+        this.post_capture = post_capture;
+    }
+
+    public String getStreaming_quality() {
+        return streaming_quality;
+    }
+
+    public void setStreaming_quality(String streaming_quality) {
+        this.streaming_quality = streaming_quality;
+    }
+
+    public String getWednesday_from() {
+        return wednesday_from;
+    }
+
+    public void setWednesday_from(String wednesday_from) {
+        this.wednesday_from = wednesday_from;
+    }
+
+    public String getProto() {
+        return proto;
+    }
+
+    public void setProto(String proto) {
+        this.proto = proto;
+    }
+
+    public List<List<String>> getExtra_options() {
+        return extra_options;
+    }
+
+    public void setExtra_options(List<List<String>> extra_options) {
+        this.extra_options = extra_options;
+    }
+
+    public String getImage_quality() {
+        return image_quality;
+    }
+
+    public void setImage_quality(String image_quality) {
+        this.image_quality = image_quality;
+    }
+
+    public boolean isCreate_debug_media() {
+        return create_debug_media;
+    }
+
+    public void setCreate_debug_media(boolean create_debug_media) {
+        this.create_debug_media = create_debug_media;
+    }
+
+    public String getFriday_to() {
+        return friday_to;
+    }
+
+    public void setFriday_to(String friday_to) {
+        this.friday_to = friday_to;
+    }
+
+    public String getCustom_right_text() {
+        return custom_right_text;
+    }
+
+    public void setCustom_right_text(String custom_right_text) {
+        this.custom_right_text = custom_right_text;
+    }
+
+    public boolean isWeb_hook_notifications_enabled() {
+        return web_hook_notifications_enabled;
+    }
+
+    public void setWeb_hook_notifications_enabled(boolean web_hook_notifications_enabled) {
+        this.web_hook_notifications_enabled = web_hook_notifications_enabled;
+    }
+
+    public String getSaturday_from() {
+        return saturday_from;
+    }
+
+    public void setSaturday_from(String saturday_from) {
+        this.saturday_from = saturday_from;
+    }
+
+    public String getTuesday_from() {
+        return tuesday_from;
+    }
+
+    public void setTuesday_from(String tuesday_from) {
+        this.tuesday_from = tuesday_from;
+    }
+
+    public String getNetwork_password() {
+        return network_password;
+    }
+
+    public void setNetwork_password(String network_password) {
+        this.network_password = network_password;
+    }
+
+    public String getSaturday_to() {
+        return saturday_to;
+    }
+
+    public void setSaturday_to(String saturday_to) {
+        this.saturday_to = saturday_to;
+    }
+
+    public String getNewtork_server() {
+        return newtork_server;
+    }
+
+    public void setNewtork_server(String newtork_server) {
+        this.newtork_server = newtork_server;
+    }
+
+    public String getSmart_mask_sluggishness() {
+        return smart_mask_sluggishness;
+    }
+
+    public void setSmart_mask_sluggishness(String smart_mask_sluggishness) {
+        this.smart_mask_sluggishness = smart_mask_sluggishness;
+    }
+
+    public boolean isMask() {
+        return mask;
+    }
+
+    public void setMask(boolean mask) {
+        this.mask = mask;
+    }
+
+    public String getTuesday_to() {
+        return tuesday_to;
+    }
+
+    public void setTuesday_to(String tuesday_to) {
+        this.tuesday_to = tuesday_to;
+    }
+
+    public String getThursday_from() {
+        return thursday_from;
+    }
+
+    public void setThursday_from(String thursday_from) {
+        this.thursday_from = thursday_from;
+    }
+
+    public String getStorage_device() {
+        return storage_device;
+    }
+
+    public void setStorage_device(String storage_device) {
+        this.storage_device = storage_device;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImage.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImage.java
new file mode 100644
index 0000000..335e512
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImage.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import android.graphics.Bitmap;
+
+public class CameraImage {
+    private String fps = "0";
+    private Bitmap bitmap = null;
+    private boolean successful;
+    private String errorString;
+
+
+    public String getFps() {
+        return fps;
+    }
+
+    public CameraImage(String fps, Bitmap bitmap, boolean successful) {
+        this.fps = fps;
+        this.bitmap = bitmap;
+        this.successful = successful;
+    }
+
+    public CameraImage(boolean successful, String errorString) {
+        this.successful = successful;
+        this.errorString = errorString;
+    }
+
+    public boolean isSuccessful() {
+        return successful;
+    }
+
+
+    public String getErrorString() {
+        return errorString;
+    }
+
+
+    public Bitmap getBitmap() {
+        return bitmap;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageError.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageError.java
new file mode 100644
index 0000000..a308c95
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageError.java
@@ -0,0 +1,37 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+public class CameraImageError {
+    private String errorCode;
+    private String errorCause;
+    private boolean displayRetry = true;
+
+    public CameraImageError(String errorCode, String errorCause, boolean displayRetry) {
+        this.errorCode = errorCode;
+        this.errorCause = errorCause;
+        this.displayRetry = displayRetry;
+    }
+
+    public String getErrorCode() {
+        return errorCode;
+    }
+
+    public void setErrorCode(String errorCode) {
+        this.errorCode = errorCode;
+    }
+
+    public String getErrorCause() {
+        return errorCause;
+    }
+
+    public void setErrorCause(String errorCause) {
+        this.errorCause = errorCause;
+    }
+
+    public boolean isDisplayRetry() {
+        return displayRetry;
+    }
+
+    public void setDisplayRetry(boolean displayRetry) {
+        this.displayRetry = displayRetry;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageFrame.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageFrame.java
new file mode 100644
index 0000000..f966612
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraImageFrame.java
@@ -0,0 +1,81 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+import android.graphics.Bitmap;
+
+import java.sql.Time;
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * This class is for video frame transmitting to the RecyclerView
+ */
+public class CameraImageFrame {
+    private Camera camera;
+    private Device device;
+    private Bitmap bitmap;
+    private boolean initialLoadDone = false;
+    private String frameRateText = "";
+    private CameraImageError error = null;
+    private List<Long> times = new ArrayList<>();
+
+
+    public CameraImageFrame(Camera camera, Device device, Bitmap bitmap, boolean initialLoadDone) {
+        this.camera = camera;
+        this.device = device;
+        this.bitmap = bitmap;
+        this.initialLoadDone = initialLoadDone;
+    }
+
+    public List<Long> getTimes() {
+        return times;
+    }
+
+    public CameraImageError getError() {
+        return error;
+    }
+
+    public void setError(CameraImageError error) {
+        this.error = error;
+    }
+
+    public String getFrameRateText() {
+        return frameRateText;
+    }
+
+    public void setFrameRateText(String frameRateText) {
+        this.frameRateText = frameRateText;
+    }
+
+    public Camera getCamera() {
+        return camera;
+    }
+
+    public void setCamera(Camera camera) {
+        this.camera = camera;
+    }
+
+    public Device getDevice() {
+        return device;
+    }
+
+    public void setDevice(Device device) {
+        this.device = device;
+    }
+
+    public Bitmap getBitmap() {
+        return bitmap;
+    }
+
+    public void setBitmap(Bitmap bitmap) {
+        this.bitmap = bitmap;
+    }
+
+    public boolean isInitialLoadDone() {
+        return initialLoadDone;
+    }
+
+    public void setInitialLoadDone(boolean initialLoadDone) {
+        this.initialLoadDone = initialLoadDone;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraUser.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraUser.java
new file mode 100644
index 0000000..393a87f
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CameraUser.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import java.io.Serializable;
+
+public class CameraUser implements Serializable {
+    private String Username = "";
+    private String Password = "";
+
+    public CameraUser(String username, String password) {
+        this.Username = username;
+        this.Password = password;
+    }
+
+    public String getPassword() {
+        return Password;
+    }
+
+    public String getUsername() {
+        return Username;
+    }
+
+    public void setPassword(String password) {
+        if (password == null)
+            Password = "";
+        else
+            Password = password;
+    }
+
+    public void setUsername(String username) {
+        if (username == null)
+            Username = "";
+        else
+            Username = username;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Cameras.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Cameras.java
new file mode 100644
index 0000000..33255e9
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Cameras.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+import java.util.ArrayList;
+
+public class Cameras {
+    @SerializedName("cameras")
+
+    private ArrayList<Camera> cameras;
+
+    public Cameras(ArrayList<Camera> cameras) {
+        this.cameras = cameras;
+    }
+
+    public ArrayList<Camera> getCameras() {
+        return cameras;
+    }
+
+    public void setCameras(ArrayList<Camera> cameras) {
+        this.cameras = cameras;
+    }
+
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CheckIP.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CheckIP.java
new file mode 100644
index 0000000..8be66dd
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/CheckIP.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+public class CheckIP {
+    @SerializedName("prompt")
+
+    private boolean prompt;
+
+    public CheckIP(boolean prompt) {
+        this.prompt = prompt;
+    }
+
+    public boolean isPrompt() {
+        return prompt;
+    }
+
+    public void setPrompt(boolean prompt) {
+        this.prompt = prompt;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Device.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Device.java
new file mode 100644
index 0000000..556be98
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Device.java
@@ -0,0 +1,330 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import android.net.wifi.WifiConfiguration;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+public class Device implements Serializable {
+    private String ID;
+    private String deviceName;
+    private String deviceUrl;
+    private String ddnsURL;
+    private String localPort, DDNSPort;
+    private CameraUser user;
+    private String motioneyeVersion = "";
+    private String motionVersion = "";
+    private String osVersion = "";
+    private ArrayList<Camera> cameras = new ArrayList<>();
+    private WifiConfiguration wlan;
+
+
+    public Device(String ID, String deviceName, String deviceUrl, String ddnsURL, String localPort, String DDNSPort, CameraUser user, String motioneyeVersion, String motionVersion, String osVersion, ArrayList<Camera> cameras, WifiConfiguration wlan) {
+        this.ID = ID;
+        this.deviceName = deviceName;
+        this.deviceUrl = deviceUrl;
+        this.ddnsURL = ddnsURL;
+        this.localPort = localPort;
+        this.DDNSPort = DDNSPort;
+        this.user = user;
+        this.motioneyeVersion = motioneyeVersion;
+        this.motionVersion = motionVersion;
+        this.osVersion = osVersion;
+        this.cameras = cameras;
+        this.wlan = wlan;
+    }
+
+    public String getDeviceUrlCombo() {
+        if (localPort.length() > 0)
+            return deviceUrl + ":" + localPort;
+        else
+            return deviceUrl;
+    }
+
+    public String getDDNSUrlCombo() {
+        if (DDNSPort.length() > 0)
+            return ddnsURL + ":" + DDNSPort;
+        else
+            return ddnsURL;
+    }
+
+    public String getMotioneyeVersion() {
+        return motioneyeVersion;
+    }
+
+    public void setMotioneyeVersion(String motioneyeVersion) {
+        this.motioneyeVersion = motioneyeVersion;
+    }
+
+    public String getMotionVersion() {
+        return motionVersion;
+    }
+
+    public void setMotionVersion(String motionVersion) {
+        this.motionVersion = motionVersion;
+    }
+
+    public String getOsVersion() {
+        return osVersion;
+    }
+
+    public void setOsVersion(String osVersion) {
+        this.osVersion = osVersion;
+    }
+
+    public String getLocalPort() {
+        return localPort;
+    }
+
+    public void setLocalPort(String localPort) {
+        this.localPort = localPort;
+    }
+
+    public String getDDNSPort() {
+        return DDNSPort;
+    }
+
+    public void setDDNSPort(String DDNSPort) {
+        this.DDNSPort = DDNSPort;
+    }
+
+    public void setUser(CameraUser user) {
+        this.user = user;
+    }
+
+    public List<Camera> getCameras() {
+        return cameras;
+    }
+
+    public String getDdnsURL() {
+        return ddnsURL;
+    }
+
+    public CameraUser getUser() {
+        return user;
+    }
+
+    public String getID() {
+        return ID;
+    }
+
+    public WifiConfiguration getWlan() {
+        return wlan;
+    }
+
+    public String getPort() {
+        return localPort;
+    }
+
+    public void setCameras(ArrayList<Camera> cameras) {
+        this.cameras = cameras;
+    }
+
+    public void setPort(String port) {
+        this.localPort = port;
+    }
+
+    public void setWlan(WifiConfiguration wlan) {
+        this.wlan = wlan;
+    }
+
+    public String getDeviceName() {
+        return deviceName;
+    }
+
+    public String getDeviceUrl() {
+        return deviceUrl;
+    }
+
+    public void setDeviceName(String deviceName) {
+        this.deviceName = deviceName;
+    }
+
+    public void setDeviceUrl(String deviceUrl) {
+        this.deviceUrl = deviceUrl;
+    }
+
+    public void setID(String ID) {
+        this.ID = ID;
+    }
+
+    public List<Camera> getCamera() {
+        return cameras;
+    }
+
+    public void setCamera(ArrayList<Camera> cameras) {
+        this.cameras = cameras;
+    }
+
+    public void setDdnsURL(String ddnsURL) {
+        this.ddnsURL = ddnsURL;
+    }
+
+    public static class Builder {
+        private String ID = "";
+        private String deviceName = "";
+        private String deviceUrl = "";
+        private CameraUser user;
+        private String ddnsURL = "";
+        private String localPort = "", DDNSPort = "";
+        private String motioneyeVersion = "";
+        private String motionVersion = "";
+        private String osVersion = "";
+        private WifiConfiguration wlan;
+        private ArrayList<Camera> cameras = new ArrayList<>();
+
+
+        public String getMotioneyeVersion() {
+            return motioneyeVersion;
+        }
+
+        public void setMotioneyeVersion(String motioneyeVersion) {
+            this.motioneyeVersion = motioneyeVersion;
+        }
+
+        public String getMotionVersion() {
+            return motionVersion;
+        }
+
+        public void setMotionVersion(String motionVersion) {
+            this.motionVersion = motionVersion;
+        }
+
+        public String getOsVersion() {
+            return osVersion;
+        }
+
+        public void setOsVersion(String osVersion) {
+            this.osVersion = osVersion;
+        }
+
+        public Builder setWlan(WifiConfiguration wlan) {
+            this.wlan = wlan;
+            return this;
+
+        }
+
+        public Builder setLocalPort(String port) {
+            this.localPort = port;
+            return this;
+
+        }
+
+        public Builder setDDNSPort(String DDNSPort) {
+            this.DDNSPort = DDNSPort;
+            return this;
+
+        }
+
+        public String getDeviceUrlCombo() {
+            if (localPort.length() > 0)
+                return deviceUrl + ":" + localPort;
+            else
+                return deviceUrl;
+        }
+
+        public String getDDNSUrlCombo() {
+            if (DDNSPort.length() > 0)
+                return ddnsURL + ":" + DDNSPort;
+            else
+                return ddnsURL;
+        }
+
+        public void setCameras(ArrayList<Camera> cameras) {
+            this.cameras = cameras;
+        }
+
+        public String getPort() {
+            return localPort;
+        }
+
+
+        public Builder setDeviceName(String deviceName) {
+            this.deviceName = deviceName;
+            return this;
+        }
+
+        public Builder setDeviceUrl(String deviceUrl) {
+            this.deviceUrl = deviceUrl;
+            return this;
+        }
+
+        public Builder setID(String ID) {
+            this.ID = ID;
+            return this;
+        }
+
+
+        public Builder setCamera(ArrayList<Camera> cameras) {
+            this.cameras = cameras;
+            return this;
+        }
+
+        public Builder setUser(CameraUser user) {
+            this.user = user;
+            return this;
+        }
+
+        public Builder setDdnsURL(String ddnsURL) {
+            this.ddnsURL = ddnsURL;
+            return this;
+        }
+
+        public String getDdnsURL() {
+            return ddnsURL;
+        }
+
+        public List<Camera> getCameras() {
+            return cameras;
+        }
+
+        public String getDeviceUrl() {
+            return deviceUrl;
+        }
+
+        public String getDeviceName() {
+            return deviceName;
+        }
+
+        public CameraUser getUser() {
+            return user;
+        }
+
+        public String getID() {
+            return ID;
+        }
+
+        public WifiConfiguration getWlan() {
+            return wlan;
+        }
+
+        public String getDDNSPort() {
+            return DDNSPort;
+        }
+
+        public String getLocalPort() {
+            return localPort;
+        }
+
+        public Device build() {
+            return new Device(ID, deviceName, deviceUrl, ddnsURL, localPort, DDNSPort, user, motioneyeVersion, motionVersion, osVersion, cameras, wlan);
+        }
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/ErrorResponse.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/ErrorResponse.java
new file mode 100644
index 0000000..e5fd5d3
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/ErrorResponse.java
@@ -0,0 +1,31 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+public class ErrorResponse {
+    @SerializedName("prompt")
+    private boolean prompt;
+    @SerializedName("error")
+    private String error;
+
+    public ErrorResponse(boolean prompt, String error) {
+        this.prompt = prompt;
+        this.error = error;
+    }
+
+    public boolean isPrompt() {
+        return prompt;
+    }
+
+    public void setPrompt(boolean prompt) {
+        this.prompt = prompt;
+    }
+
+    public String getError() {
+        return error;
+    }
+
+    public void setError(String error) {
+        this.error = error;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/LoginResult.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/LoginResult.java
new file mode 100644
index 0000000..846d508
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/LoginResult.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+public class LoginResult {
+    @SerializedName("prompt")
+
+    private boolean prompt;
+
+    @SerializedName("error")
+
+    private String error = "no";
+
+    public LoginResult(boolean prompt) {
+        this.prompt = prompt;
+    }
+
+    public boolean isPrompt() {
+        return prompt;
+    }
+
+    public void setPrompt(boolean prompt) {
+        this.prompt = prompt;
+    }
+
+    public String getError() {
+        return error;
+    }
+
+    public void setError(String error) {
+        this.error = error;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/MainConfig.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/MainConfig.java
new file mode 100644
index 0000000..f345fa7
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/MainConfig.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+public class MainConfig {
+
+    @SerializedName("normal_password")
+    private String normal_password;
+    @SerializedName("normal_username")
+    private String normal_username;
+    @SerializedName("show_advanced")
+    private boolean show_advanced;
+    @SerializedName("admin_username")
+    private String admin_username;
+    @SerializedName("admin_password")
+    private String admin_password;
+
+    public MainConfig(String normal_password, String normal_username, boolean show_advanced, String admin_username, String admin_password) {
+        this.normal_password = normal_password;
+        this.normal_username = normal_username;
+        this.show_advanced = show_advanced;
+        this.admin_username = admin_username;
+        this.admin_password = admin_password;
+    }
+
+
+    public String getNormal_password() {
+        return normal_password;
+    }
+
+    public void setNormal_password(String normal_password) {
+        this.normal_password = normal_password;
+    }
+
+    public String getNormal_username() {
+        return normal_username;
+    }
+
+    public void setNormal_username(String normal_username) {
+        this.normal_username = normal_username;
+    }
+
+    public boolean isShow_advanced() {
+        return show_advanced;
+    }
+
+    public void setShow_advanced(boolean show_advanced) {
+        this.show_advanced = show_advanced;
+    }
+
+    public String getAdmin_username() {
+        return admin_username;
+    }
+
+    public void setAdmin_username(String admin_username) {
+        this.admin_username = admin_username;
+    }
+
+    public String getAdmin_password() {
+        return admin_password;
+    }
+
+    public void setAdmin_password(String admin_password) {
+        this.admin_password = admin_password;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Media.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Media.java
new file mode 100644
index 0000000..36b61f1
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/Media.java
@@ -0,0 +1,78 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+import java.io.Serializable;
+import java.util.Date;
+
+public class Media implements Serializable {
+    @SerializedName("mimeType")
+    private String mimeType;
+    @SerializedName("sizeStr")
+    private String size;
+    @SerializedName("momentStrShort")
+    private String shortMonent;
+    @SerializedName("timestamp")
+    private double timestamp;
+    @SerializedName("momentStr")
+    private String moment;
+    @SerializedName("path")
+    private String path;
+
+    public Media(String mimeType, String size, String shortMonent, double timestamp, String moment, String path) {
+        this.mimeType = mimeType;
+        this.size = size;
+        this.shortMonent = shortMonent;
+        this.timestamp = timestamp;
+        this.moment = moment;
+        this.path = path;
+    }
+
+    public String getMimeType() {
+        return mimeType;
+    }
+
+    public void setMimeType(String mimeType) {
+        this.mimeType = mimeType;
+    }
+
+    public String getSize() {
+        return size;
+    }
+
+    public void setSize(String size) {
+        this.size = size;
+    }
+
+    public String getShortMonent() {
+        return shortMonent;
+    }
+
+    public void setShortMonent(String shortMonent) {
+        this.shortMonent = shortMonent;
+    }
+
+    public double getTimestamp() {
+        return timestamp;
+    }
+
+    public void setTimestamp(double timestamp) {
+        this.timestamp = timestamp;
+    }
+
+    public String getMoment() {
+        return moment;
+    }
+
+    public void setMoment(String moment) {
+        this.moment = moment;
+    }
+
+    public String getPath() {
+        return path;
+    }
+
+    public void setPath(String path) {
+        this.path = path;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/MediaList.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/MediaList.java
new file mode 100644
index 0000000..24d2845
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/MediaList.java
@@ -0,0 +1,33 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+import com.google.gson.annotations.SerializedName;
+
+import java.util.List;
+
+public class MediaList {
+    @SerializedName("mediaList")
+    private List<Media> media;
+    @SerializedName("cameraName")
+    private String cameraName;
+
+    public MediaList(List<Media> media, String cameraName) {
+        this.media = media;
+        this.cameraName = cameraName;
+    }
+
+    public List<Media> getMedia() {
+        return media;
+    }
+
+    public void setMedia(List<Media> media) {
+        this.media = media;
+    }
+
+    public String getCameraName() {
+        return cameraName;
+    }
+
+    public void setCameraName(String cameraName) {
+        this.cameraName = cameraName;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/RecordingDevice.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/RecordingDevice.java
new file mode 100644
index 0000000..f522aa6
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/RecordingDevice.java
@@ -0,0 +1,27 @@
+package com.developerfromjokela.motioneyeclient.classes;
+
+public class RecordingDevice {
+    private Device device;
+    private Camera camera;
+
+    public RecordingDevice(Device device, Camera camera) {
+        this.device = device;
+        this.camera = camera;
+    }
+
+    public Device getDevice() {
+        return device;
+    }
+
+    public void setDevice(Device device) {
+        this.device = device;
+    }
+
+    public Camera getCamera() {
+        return camera;
+    }
+
+    public void setCamera(Camera camera) {
+        this.camera = camera;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/WifiNetwork.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/WifiNetwork.java
new file mode 100644
index 0000000..fe86e12
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/WifiNetwork.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes;
+
+import android.net.wifi.WifiConfiguration;
+
+public class WifiNetwork {
+
+    private WifiConfiguration configuration;
+    private boolean selected;
+
+    public WifiNetwork(WifiConfiguration configuration, boolean selected) {
+        this.configuration = configuration;
+        this.selected = selected;
+    }
+
+    public WifiConfiguration getConfiguration() {
+        return configuration;
+    }
+
+    public void setConfiguration(WifiConfiguration configuration) {
+        this.configuration = configuration;
+    }
+
+    public boolean isSelected() {
+        return selected;
+    }
+
+    public void setSelected(boolean selected) {
+        this.selected = selected;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/disks/Disk.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/disks/Disk.java
new file mode 100644
index 0000000..c6ae5aa
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/disks/Disk.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes.disks;
+
+import java.io.Serializable;
+import java.util.List;
+
+public class Disk implements Serializable {
+    private String bus;
+    private String model;
+    private String vendor;
+    private String target;
+    private List<Partition> partitions;
+
+    public Disk(String bus, String model, String vendor, String target, List<Partition> partitions) {
+        this.bus = bus;
+        this.model = model;
+        this.target = target;
+        this.vendor = vendor;
+        this.partitions = partitions;
+    }
+
+    public List<Partition> getPartitions() {
+        return partitions;
+    }
+
+    public String getBus() {
+        return bus;
+    }
+
+    public String getModel() {
+        return model;
+    }
+
+    public String getTarget() {
+        return target;
+    }
+
+    public String getVendor() {
+        return vendor;
+    }
+
+    public void setBus(String bus) {
+        this.bus = bus;
+    }
+
+    public void setModel(String model) {
+        this.model = model;
+    }
+
+    public void setPartitions(List<Partition> partitions) {
+        this.partitions = partitions;
+    }
+
+    public void setTarget(String target) {
+        this.target = target;
+    }
+
+    public void setVendor(String vendor) {
+        this.vendor = vendor;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/disks/Partition.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/disks/Partition.java
new file mode 100644
index 0000000..0978952
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/classes/disks/Partition.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.classes.disks;
+
+import java.io.Serializable;
+
+public class Partition implements Serializable {
+    private String mount_point;
+    private String vendor;
+    private String target;
+    private int part_no;
+    private String bus;
+    private String fstype;
+    private String model;
+    private String opts;
+
+    public Partition(String mount_point, String vendor, String target, int part_no, String bus, String fstype, String model, String opts) {
+        this.mount_point = mount_point;
+        this.vendor = vendor;
+        this.target = target;
+        this.part_no = part_no;
+        this.bus = bus;
+        this.fstype = fstype;
+        this.model = model;
+        this.opts = opts;
+    }
+
+    public void setVendor(String vendor) {
+        this.vendor = vendor;
+    }
+
+    public void setTarget(String target) {
+        this.target = target;
+    }
+
+    public void setModel(String model) {
+        this.model = model;
+    }
+
+    public void setBus(String bus) {
+        this.bus = bus;
+    }
+
+    public String getVendor() {
+        return vendor;
+    }
+
+    public String getTarget() {
+        return target;
+    }
+
+    public String getModel() {
+        return model;
+    }
+
+    public String getBus() {
+        return bus;
+    }
+
+    public int getPart_no() {
+        return part_no;
+    }
+
+    public String getFstype() {
+        return fstype;
+    }
+
+    public String getMount_point() {
+        return mount_point;
+    }
+
+    public String getOpts() {
+        return opts;
+    }
+
+    public void setFstype(String fstype) {
+        this.fstype = fstype;
+    }
+
+    public void setMount_point(String mount_point) {
+        this.mount_point = mount_point;
+    }
+
+    public void setOpts(String opts) {
+        this.opts = opts;
+    }
+
+    public void setPart_no(int part_no) {
+        this.part_no = part_no;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/AESCryptor.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/AESCryptor.java
new file mode 100644
index 0000000..13c5fda
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/AESCryptor.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.database;
+
+import android.annotation.SuppressLint;
+import android.util.Base64;
+
+import java.nio.charset.StandardCharsets;
+import java.security.Key;
+
+import javax.crypto.Cipher;
+import javax.crypto.spec.SecretKeySpec;
+
+public class AESCryptor {
+    private static final String ALGORITHM = "AES";
+    private static final String KEY = "tsbfJMP22tJhAkp8";
+
+    public static String encrypt(String value) throws Exception {
+        Key key = generateKey();
+        @SuppressLint("GetInstance") Cipher cipher = Cipher.getInstance(AESCryptor.ALGORITHM);
+        cipher.init(Cipher.ENCRYPT_MODE, key);
+        byte[] encryptedByteValue = cipher.doFinal(value.getBytes(StandardCharsets.UTF_8));
+        return Base64.encodeToString(encryptedByteValue, Base64.DEFAULT);
+
+    }
+
+    public static String decrypt(String value) throws Exception {
+        Key key = generateKey();
+        @SuppressLint("GetInstance") Cipher cipher = Cipher.getInstance(AESCryptor.ALGORITHM);
+        cipher.init(Cipher.DECRYPT_MODE, key);
+        byte[] decryptedValue64 = Base64.decode(value, Base64.DEFAULT);
+        byte[] decryptedByteValue = cipher.doFinal(decryptedValue64);
+        return new String(decryptedByteValue, StandardCharsets.UTF_8);
+
+    }
+
+    private static Key generateKey() {
+        return new SecretKeySpec(AESCryptor.KEY.getBytes(), AESCryptor.ALGORITHM);
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/Helper.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/Helper.java
new file mode 100644
index 0000000..bcae348
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/Helper.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.database;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+
+
+public final class Helper extends SQLiteOpenHelper {
+
+    /**
+     * The name of the database containing device's details.
+     */
+    public static final String DATABASE_NAME = "Devices.db";
+
+    public static final String TABLE_DEVICE = "DEVICES";
+
+    /**
+     * The current version of the database containing devices.
+     */
+    private static final int DATABASE_VERSION = 1;
+
+    /**
+     * The command when first creating the database.
+     */
+    private static final String TABLE_CREATE_DEVICES = "create table DEVICES(ID integer primary key autoincrement,DEVICENAME text,DEVICEURL text,USERNAME text,PASSWORD text, CAMERAS text, WLAN text, LOCALPORT text, DDNSPORT text, MOTIONEYEVER text, MOTIONVER text, OSVER text, DDNSURL text)";
+
+    public Helper(final Context context) {
+        super(context, DATABASE_NAME, null, DATABASE_VERSION);
+    }
+
+    @Override
+    public final void onCreate(final SQLiteDatabase database) {
+        database.execSQL(TABLE_CREATE_DEVICES);
+    }
+
+    @Override
+    public final void onUpgrade(final SQLiteDatabase db, final int oldVersion, final int newVersion) {
+        // Upgrade from first to third version
+
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/Source.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/Source.java
new file mode 100644
index 0000000..8352af0
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/database/Source.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.database;
+
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.net.wifi.WifiConfiguration;
+import android.util.Log;
+
+import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.CameraUser;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.google.gson.Gson;
+
+import org.json.JSONArray;
+
+import java.util.ArrayList;
+
+public final class Source {
+
+    /**
+     * All columns used in the database.
+     */
+    public static final String[] devicesColumns = {"ID", "DEVICENAME", "DEVICEURL", "USERNAME", "PASSWORD", "CAMERAS", "WLAN", "LOCALPORT", "DDNSPORT", "MOTIONEYEVER", "MOTIONVER", "OSVER", "DDNSURL"};
+
+
+    private final Helper dbHelper;
+
+    private SQLiteDatabase database;
+
+    private Context context;
+
+
+    public Source(final Context context) {
+        dbHelper = new Helper(context);
+        this.context = context;
+    }
+
+
+    public final void open() throws SQLException {
+        database = dbHelper.getWritableDatabase();
+    }
+
+
+    public final void close() {
+        dbHelper.close();
+    }
+
+    /**
+     * Adds a camera device.
+     *
+     * @param device The Device Class whcih will be saved in the database.
+     */
+    public final void createEntry(final Device device) throws Exception {
+
+        open();
+
+        final ContentValues values = new ContentValues();
+        values.put(devicesColumns[1], AESCryptor.encrypt(device.getDeviceName()));
+        values.put(devicesColumns[2], AESCryptor.encrypt(device.getDeviceUrl()));
+        values.put(devicesColumns[12], AESCryptor.encrypt(device.getDdnsURL()));
+        values.put(devicesColumns[3], AESCryptor.encrypt(device.getUser().getUsername()));
+        values.put(devicesColumns[4], AESCryptor.encrypt(device.getUser().getPassword()));
+        Log.e("Source", new Gson().toJson(device.getCamera()));
+        values.put(devicesColumns[5], AESCryptor.encrypt(new Gson().toJson(device.getCamera())));
+        values.put(devicesColumns[6], AESCryptor.encrypt(new Gson().toJson(device.getWlan())));
+        values.put(devicesColumns[7], AESCryptor.encrypt(device.getLocalPort()));
+        values.put(devicesColumns[8], AESCryptor.encrypt(device.getDDNSPort()));
+        values.put(devicesColumns[9], AESCryptor.encrypt(device.getMotioneyeVersion()));
+        values.put(devicesColumns[10], AESCryptor.encrypt(device.getMotionVersion()));
+        values.put(devicesColumns[11], AESCryptor.encrypt(device.getOsVersion()));
+
+        String insertId = "ID = " + database.insert("DEVICES", null, values);
+
+        open();
+
+
+        final Cursor cursor = database.query("DEVICES", devicesColumns, insertId, null,
+                null, null, null);
+        cursor.close();
+        close();
+
+    }
+
+    /**
+     * Adds a camera device.
+     *
+     * @param device The Device Class whcih will be saved in the database.
+     */
+    public final void editEntry(final Device device) throws Exception {
+
+
+        final ContentValues values = new ContentValues();
+        values.put(devicesColumns[1], AESCryptor.encrypt(device.getDeviceName()));
+        values.put(devicesColumns[2], AESCryptor.encrypt(device.getDeviceUrl()));
+        values.put(devicesColumns[12], AESCryptor.encrypt(device.getDdnsURL()));
+        values.put(devicesColumns[3], AESCryptor.encrypt(device.getUser().getUsername()));
+        values.put(devicesColumns[4], AESCryptor.encrypt(device.getUser().getPassword()));
+        Log.e("Source", new Gson().toJson(device.getCamera()));
+        values.put(devicesColumns[5], AESCryptor.encrypt(new Gson().toJson(device.getCamera())));
+        values.put(devicesColumns[6], AESCryptor.encrypt(new Gson().toJson(device.getWlan())));
+        values.put(devicesColumns[7], AESCryptor.encrypt(device.getLocalPort()));
+        values.put(devicesColumns[8], AESCryptor.encrypt(device.getDDNSPort()));
+        values.put(devicesColumns[9], AESCryptor.encrypt(device.getMotioneyeVersion()));
+        values.put(devicesColumns[10], AESCryptor.encrypt(device.getMotionVersion()));
+        values.put(devicesColumns[11], AESCryptor.encrypt(device.getOsVersion()));
+
+        String insertId = "ID = ?";
+
+        open();
+
+
+        database.update("DEVICES", values, insertId, new String[]{device.getID()});
+        close();
+
+    }
+
+    /**
+     * Deletes an item in the database.
+     *
+     * @param device Device to delete.
+     */
+    public final void delete_item(final Device device) throws Exception {
+        Log.e("Source", device.getID());
+        open();
+        database.delete(Helper.TABLE_DEVICE, "ID = ?", new String[]{device.getID()});
+        close();
+    }
+
+    /**
+     * Returns an ArrayList containing Device classes.
+     */
+    public final ArrayList<Device> getAll() throws Exception {
+        open();
+        final ArrayList<Device> devices = new ArrayList<>();
+
+        final Cursor cursor = database.query(Helper.TABLE_DEVICE, devicesColumns, "", null,
+                null, null, null);
+        cursor.moveToFirst();
+
+        if (cursor.getCount() == 0)
+            return devices;
+
+        while (!cursor.isAfterLast()) {
+            String ID = cursor.getString(cursor.getColumnIndex(devicesColumns[0]));
+            String deviceName = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[1])));
+            String deviceURL = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[2])));
+            String ddnsURL = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[12])));
+
+            String username = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[3])));
+            String password = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[4])));
+            String cameras_jsonstr = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[5])));
+            String wlan = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[6])));
+            String localPort = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[7])));
+            String DDNSPort = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[8])));
+            String motioneyeversion = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[9])));
+            String motionversion = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[10])));
+            String osversion = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[11])));
+
+
+            ArrayList<Camera> cameras = new ArrayList<>();
+            Log.e("Source", cameras_jsonstr);
+            JSONArray cameras_json = new JSONArray(cameras_jsonstr);
+            for (int i = 0; i < cameras_json.length(); i++) {
+                cameras.add(new Gson().fromJson(cameras_json.getString(i), Camera.class));
+            }
+
+            WifiConfiguration wifiConfig = new Gson().fromJson(wlan, WifiConfiguration.class);
+            devices.add(new Device(ID, deviceName, deviceURL, ddnsURL, localPort, DDNSPort, new CameraUser(username, password), motioneyeversion, motionversion, osversion, cameras, wifiConfig));
+
+            cursor.moveToNext();
+        }
+        cursor.close();
+        close();
+
+
+        return devices;
+    }
+
+    public final Device get(String selectionID) throws Exception {
+        open();
+        String selection = devicesColumns[0] + " =  ?";
+        String[] seletion_args = {selectionID};
+        final Cursor cursor = database.query(Helper.TABLE_DEVICE, devicesColumns, selection, seletion_args,
+                null, null, null);
+        cursor.moveToFirst();
+
+        if (cursor.getCount() == 0)
+            return null;
+
+
+        String ID = cursor.getString(cursor.getColumnIndex(devicesColumns[0]));
+        String deviceName = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[1])));
+        String deviceURL = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[2])));
+        String ddnsURL = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[12])));
+
+        String username = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[3])));
+        String password = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[4])));
+        String cameras_jsonstr = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[5])));
+        String wlan = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[6])));
+        String localPort = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[7])));
+        String DDNSPort = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[8])));
+        String motioneyeversion = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[9])));
+        String motionversion = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[10])));
+        String osversion = AESCryptor.decrypt(cursor.getString(cursor.getColumnIndex(devicesColumns[11])));
+
+
+        ArrayList<Camera> cameras = new ArrayList<>();
+        Log.e("Source", cameras_jsonstr);
+        JSONArray cameras_json = new JSONArray(cameras_jsonstr);
+        for (int i = 0; i < cameras_json.length(); i++) {
+            cameras.add(new Gson().fromJson(cameras_json.getString(i), Camera.class));
+        }
+
+        WifiConfiguration wifiConfig = new Gson().fromJson(wlan, WifiConfiguration.class);
+        cursor.close();
+        close();
+        return new Device(ID, deviceName, deviceURL, ddnsURL, localPort, DDNSPort, new CameraUser(username, password), motioneyeversion, motionversion, osversion, cameras, wifiConfig);
+
+
+    }
+
+    public final Cursor getCursor() {
+
+        return database.query(Helper.TABLE_DEVICE, devicesColumns, null, null,
+                null, null, null);
+
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/other/Utils.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/other/Utils.java
new file mode 100644
index 0000000..6259b49
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/other/Utils.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.other;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Rect;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.support.v7.widget.RecyclerView;
+import android.util.TypedValue;
+import android.view.View;
+import android.webkit.URLUtil;
+
+import org.jsoup.helper.StringUtil;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+import static android.app.DownloadManager.Request.NETWORK_WIFI;
+
+public class Utils {
+
+    public static final boolean DEBUG = true;
+    public static int imageRefreshInterval = 15;
+    public static int framerateFactor = 1;
+    public static int fpsLen = 4;
+    public static class GridSpacingItemDecoration extends RecyclerView.ItemDecoration {
+
+        private int spanCount;
+        private int spacing;
+        private boolean includeEdge;
+
+        public GridSpacingItemDecoration(int spanCount, int spacing, boolean includeEdge) {
+            this.spanCount = spanCount;
+            this.spacing = spacing;
+            this.includeEdge = includeEdge;
+        }
+
+        @Override
+        public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
+            int position = parent.getChildAdapterPosition(view); // item position
+            int column = position % spanCount; // item column
+
+            if (includeEdge) {
+                outRect.left = spacing - column * spacing / spanCount; // spacing - column * ((1f / spanCount) * spacing)
+                outRect.right = (column + 1) * spacing / spanCount; // (column + 1) * ((1f / spanCount) * spacing)
+
+                if (position < spanCount) { // top edge
+                    outRect.top = spacing;
+                }
+                outRect.bottom = spacing; // item bottom
+            } else {
+                outRect.left = column * spacing / spanCount; // column * ((1f / spanCount) * spacing)
+                outRect.right = spacing - (column + 1) * spacing / spanCount; // spacing - (column + 1) * ((1f /    spanCount) * spacing)
+                if (position >= spanCount) {
+                    outRect.top = spacing; // item top
+                }
+            }
+        }
+    }
+
+    public static String removeSlash(String url) {
+        if (!url.endsWith("/"))
+            return url;
+        String[] parts = url.split("/");
+
+        return parts[0];
+    }
+
+
+
+    public static int dpToPx(Context c) {
+        Resources r = c.getResources();
+        return Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, r.getDisplayMetrics()));
+    }
+
+
+    private static boolean isNetworkAvailable(Context context) {
+        ConnectivityManager connectivityManager
+                = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
+        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
+    }
+
+    public static String getCurrentWifiBSSID(Context context) {
+        String bSSID = null;
+        ConnectivityManager connManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo networkInfo = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+        if (networkInfo.isConnected()) {
+            final WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+            final WifiInfo connectionInfo = wifiManager.getConnectionInfo();
+            if (connectionInfo != null && !StringUtil.isBlank(connectionInfo.getBSSID())) {
+                bSSID = connectionInfo.getBSSID();
+            }
+        }
+        return bSSID;
+    }
+
+    public static int getCurrentWifiNetworkId(Context context) {
+        int networkId = -1;
+        ConnectivityManager connManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo networkInfo = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+        if (networkInfo.isConnected()) {
+            final WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+            final WifiInfo connectionInfo = wifiManager.getConnectionInfo();
+            if (connectionInfo != null) {
+                networkId = connectionInfo.getNetworkId();
+            }
+        }
+        return networkId;
+    }
+
+    public static boolean validIP(String ip) {
+        try {
+            if (ip == null || ip.isEmpty()) {
+                return false;
+            }
+
+            String[] parts = ip.split("\\.");
+            if (parts.length != 4) {
+                return false;
+            }
+
+            for (String s : parts) {
+                int i = Integer.parseInt(s);
+                if ((i < 0) || (i > 255)) {
+                    return false;
+                }
+            }
+            return !ip.endsWith(".");
+        } catch (NumberFormatException nfe) {
+            return false;
+        }
+    }
+
+    public static boolean isValidURL(String url) {
+
+            boolean ret = true;
+
+            if("".equals(url) || url==null)
+            {
+                ret = false;
+            }else if(url.startsWith("-")||url.endsWith("-"))
+            {
+                ret = false;
+            }else if(url.indexOf(".")==-1)
+            {
+                ret = false;
+            }else
+            {
+                // Split domain into String array.
+                String[] domainEle = url.split("\\.");
+                int size = domainEle.length;
+                // Loop in the domain String array.
+                for(int i=0;i<size;i++)
+                {
+                    // If one domain part string is empty, then reutrn false.
+                    String domainEleStr = domainEle[i];
+                    if("".equals(domainEleStr.trim()))
+                    {
+                        return false;
+                    }
+                }
+
+                // Get domain char array.
+                char[] domainChar = url.toCharArray();
+                size = domainChar.length;
+                // Loop in the char array.
+                for(int i=0;i<size;i++)
+                {
+                    // Get each char in the array.
+                    char eleChar = domainChar[i];
+                    String charStr = String.valueOf(eleChar);
+
+                    // If char value is not a valid domain character then return false.
+                    if(!".".equals(charStr) && !"-".equals(charStr) && !charStr.matches("[a-zA-Z]") && !charStr.matches("[0-9]"))
+                    {
+                        ret = false;
+                        break;
+                    }
+                }
+            }
+            return ret;
+    }
+
+    public static int getNetworkType(Context context) {
+        if (!isNetworkAvailable(context))
+            return -1;
+        ConnectivityManager conMan = (ConnectivityManager) context.
+                getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        //mobile
+        NetworkInfo.State mobile = conMan.getNetworkInfo(0).getState();
+        //wifi
+        NetworkInfo.State wifi = conMan.getNetworkInfo(1).getState();
+
+        int result = 0;
+
+        if (mobile == NetworkInfo.State.CONNECTED || mobile == NetworkInfo.State.CONNECTING) {
+            result |= NETWORK_MOBILE;
+        }
+
+        if (wifi == NetworkInfo.State.CONNECTED || wifi == NetworkInfo.State.CONNECTING) {
+            result |= NETWORK_WIFI;
+        }
+
+        return result;
+    }
+
+    public static String removeLastChar(String str) {
+        return str.substring(0, str.length() - 1);
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/CameraViewer.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/CameraViewer.java
new file mode 100644
index 0000000..c15cbe4
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/CameraViewer.java
@@ -0,0 +1,477 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.activities;
+
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Handler;
+import android.support.annotation.Nullable;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.Toolbar;
+import android.util.Log;
+import android.util.Range;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.ApiInterface;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.api.ServiceGenerator;
+import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.CameraImage;
+import com.developerfromjokela.motioneyeclient.classes.CameraImageError;
+import com.developerfromjokela.motioneyeclient.classes.CameraImageFrame;
+import com.developerfromjokela.motioneyeclient.classes.Cameras;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.ErrorResponse;
+import com.developerfromjokela.motioneyeclient.database.Source;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+import com.developerfromjokela.motioneyeclient.ui.adapters.HttpCamerasAdapter;
+import com.google.gson.Gson;
+
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.select.Elements;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.annotation.Annotation;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Converter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+
+public class CameraViewer extends AppCompatActivity {
+
+    private HttpCamerasAdapter adapter;
+    private Device device;
+    private String ID;
+    private Source source;
+    private List<CameraImageFrame> cameraImageFrames = new ArrayList<>();
+    private boolean sleeping = false;
+    private GridLayoutManager manager;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_cameraviewer);
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        setSupportActionBar(toolbar);
+        toolbar.setNavigationIcon(R.drawable.ic_back);
+        toolbar.setNavigationOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                finish();
+            }
+        });
+        Intent intent = getIntent();
+        source = new Source(this);
+        if (intent.getExtras() != null) {
+            ID = intent.getStringExtra("DeviceId");
+        } else {
+            finish();
+        }
+
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        sleeping = false;
+        try {
+            device = source.get(ID);
+
+            setTitle(device.getDeviceName());
+            Log.e(CameraViewer.class.getSimpleName(), new Gson().toJson(device));
+            RecyclerView recyclerView = findViewById(R.id.cameras);
+            manager = new GridLayoutManager(this, 1);
+            recyclerView.setLayoutManager(manager);
+            recyclerView.setItemAnimator(null);
+            for (Camera camera : device.getCameras()) {
+                CameraImageFrame frame = new CameraImageFrame(camera, device, null, false);
+                cameraImageFrames.add(frame);
+            }
+            adapter = new HttpCamerasAdapter(new HttpCamerasAdapter.CamerasAdapterListener() {
+                @Override
+                public void onImageClick(int position, CameraImageFrame camera) {
+                    Intent fullscreen = new Intent(CameraViewer.this, FullCameraViewer.class);
+                    fullscreen.putExtra("DeviceId", ID);
+                    fullscreen.putExtra("Camera", new Gson().toJson(camera.getCamera()));
+                    startActivity(fullscreen);
+                }
+
+                @Override
+                public void onRefreshRequest(int position, CameraImageFrame cameraImageFrame) {
+                    getRunnableForCamera(position).run();
+                }
+
+            }, cameraImageFrames);
+            recyclerView.setAdapter(adapter);
+            adapter.notifyDataSetChanged();
+            String baseurl;
+            String serverurl;
+            if (device.getDdnsURL().length() > 5) {
+                if ((Utils.getNetworkType(CameraViewer.this)) == NETWORK_MOBILE) {
+                    serverurl = device.getDDNSUrlCombo();
+                } else if (device.getWlan().networkId == Utils.getCurrentWifiNetworkId(CameraViewer.this)) {
+                    serverurl = device.getDeviceUrlCombo();
+
+                } else {
+                    serverurl = device.getDDNSUrlCombo();
+
+                }
+            } else {
+                serverurl = device.getDeviceUrlCombo();
+
+            }
+            Log.e("Setup", String.valueOf(serverurl.split("//").length));
+            if (!serverurl.contains("://"))
+                baseurl = removeSlash("http://" + serverurl);
+            else
+                baseurl = removeSlash(serverurl);
+            String url = baseurl + "/config/list?_=" + new Date().getTime();
+            MotionEyeHelper helper = new MotionEyeHelper();
+            helper.setUsername(device.getUser().getUsername());
+            helper.setPasswordHash(device.getUser().getPassword());
+            url = helper.addAuthParams("GET", url, "");
+            ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+
+            apiInterface.getCameras(url).enqueue(new Callback<Cameras>() {
+                @Override
+                public void onResponse(Call<Cameras> call, Response<Cameras> response) {
+                    Cameras cameras = response.body();
+                    if (response.isSuccessful()) {
+                        device.setCameras(cameras.getCameras());
+                        apiInterface.getMotionDetails(baseurl + "/version").enqueue(new Callback<ResponseBody>() {
+                            @Override
+                            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                                if (response.headers().get("Server").toLowerCase().contains("motioneye")) {
+                                    try {
+                                        final String stringResponse = response.body().string();
+                                        Document html = Jsoup.parse(stringResponse);
+                                        Elements elements = html.select("body");
+                                        String[] lines = elements.html().replace("\"", "").replace("\n", "").split("<br>");
+                                        for (String string : lines) {
+                                            String[] paramParts = string.split("=");
+                                            String paramName = paramParts[0].trim();
+                                            String paramValue = paramParts[1];
+                                            if (paramName.contains("hostname"))
+                                                device.setDeviceName(paramValue);
+                                            else if (paramName.contains("motion_version"))
+                                                device.setMotionVersion(paramValue);
+                                            else if (paramName.contains("os_version"))
+                                                device.setOsVersion(paramValue);
+                                            else if (paramName.equals("version"))
+                                                device.setMotioneyeVersion(paramValue);
+
+                                        }
+
+                                        cameraImageFrames.clear();
+
+                                        for (Camera camera : device.getCameras()) {
+                                            CameraImageFrame frame = new CameraImageFrame(camera, device, null, false);
+                                            cameraImageFrames.add(frame);
+                                            getRunnableForCamera(cameraImageFrames.size() - 1).run();
+                                        }
+
+                                        adapter.notifyDataSetChanged();
+                                        setTitle(device.getDeviceName());
+
+                                        source.editEntry(device);
+
+
+                                    } catch (IOException e) {
+                                        for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                                            cameraImageFrame.setError(new CameraImageError("motioneye_error5", e.getMessage(), true));
+                                        }
+                                        adapter.notifyDataSetChanged();
+                                    } catch (Exception e) {
+                                        for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                                            cameraImageFrame.setError(new CameraImageError("motioneye_error6", e.getMessage(), true));
+                                        }
+                                        adapter.notifyDataSetChanged();
+                                    }
+
+
+                                }
+                            }
+
+
+                            @Override
+                            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                                for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                                    cameraImageFrame.setError(new CameraImageError("motioneye_error2", t.getMessage(), true));
+                                }
+                                adapter.notifyDataSetChanged();
+                            }
+                        });
+                    } else {
+
+                        ErrorResponse message = new Gson().fromJson(response.errorBody().charStream(), ErrorResponse.class);
+                        for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                            cameraImageFrame.setError(new CameraImageError("motioneye_error4", message.getError(), true));
+                        }
+                        adapter.notifyDataSetChanged();
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<Cameras> call, Throwable t) {
+                    for (CameraImageFrame cameraImageFrame : cameraImageFrames) {
+                        cameraImageFrame.setError(new CameraImageError("motioneye_error3", t.getMessage(), true));
+                    }
+                    adapter.notifyDataSetChanged();
+                }
+            });
+
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        sleeping = true;
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        sleeping = true;
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.device, menu);
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        // Handle item selection
+        switch (item.getItemId()) {
+            case R.id.deviceSettings:
+                startDeviceSettings(device.getID());
+                return true;
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+    }
+
+    private Runnable getRunnableForCamera(int position) {
+        return new Runnable() {
+            @Override
+            public void run() {
+                MotionEyeHelper helper = new MotionEyeHelper();
+                helper.setUsername(device.getUser().getUsername());
+                try {
+                    helper.setPasswordHash(device.getUser().getPassword());
+                } catch (NoSuchAlgorithmException e) {
+                    e.printStackTrace();
+                }
+
+
+                CameraImageFrame frame = cameraImageFrames.get(position);
+                String cameraId = frame.getCamera().getId();
+                String serverurl;
+                if (device.getDdnsURL().length() > 5) {
+                    if ((Utils.getNetworkType(CameraViewer.this)) == NETWORK_MOBILE) {
+                        serverurl = device.getDDNSUrlCombo();
+                    } else if (device.getWlan().networkId == Utils.getCurrentWifiNetworkId(CameraViewer.this)) {
+                        serverurl = device.getDeviceUrlCombo();
+
+                    } else {
+                        serverurl = device.getDDNSUrlCombo();
+
+                    }
+                } else {
+                    serverurl = device.getDeviceUrlCombo();
+
+                }
+                String baseurl;
+                if (!serverurl.contains("://"))
+                    baseurl = removeSlash("http://" + serverurl);
+                else
+                    baseurl = removeSlash(serverurl);
+
+                String url = baseurl + "/picture/" + cameraId + "/current?_=" + new Date().getTime();
+                url = helper.addAuthParams("GET", url, "");
+                String finalUrl = url;
+                boolean visible = position >= manager.findFirstVisibleItemPosition() && position <= manager.findLastVisibleItemPosition();
+                if (!sleeping) {
+                    if (visible)
+                        new DownloadImageFromInternet(position, frame, this).execute(finalUrl);
+                    if (!visible)
+                        new Handler().postDelayed(this, Utils.imageRefreshInterval); //Start timer after 1 sec
+                }
+
+            }
+        };
+    }
+
+
+    private class DownloadImageFromInternet extends AsyncTask<String, Void, CameraImage> {
+        Runnable timerRunnable;
+        CameraImageFrame camera;
+        int position;
+        Handler timeHandler;
+
+        public DownloadImageFromInternet(int position, CameraImageFrame camera, Runnable timerRunnable) {
+            this.camera = camera;
+            this.timerRunnable = timerRunnable;
+            this.position = position;
+            timeHandler = new Handler();
+        }
+
+        protected void onPreExecute() {
+        }
+
+        protected CameraImage doInBackground(String... urls) {
+
+            String imageURL = urls[0];
+
+
+            try {
+                URL url = new URL(imageURL);
+                URLConnection connection = url.openConnection();
+                Map<String, List<String>> fps = connection.getHeaderFields();
+                InputStream in = url.openStream();
+                final Bitmap decoded = BitmapFactory.decodeStream(in);
+                in.close();
+                for (Map.Entry<String, List<String>> key : fps.entrySet()) {
+                    for (String string : key.getValue()) {
+                        if (string.contains("capture_fps")) {
+                            double d = Double.parseDouble(string.split("capture_fps_" + camera.getCamera().getId() + "=")[1].split(";")[0].trim());
+                            String humanReadableFPS = String.valueOf(Math.round((int) d));
+                            return new CameraImage(humanReadableFPS, decoded, true);
+
+                        }
+
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                return new CameraImage(false, e.getMessage());
+            }
+            return null;
+
+        }
+
+        protected void onPostExecute(CameraImage result) {
+
+            camera.setError(null);
+            if (result.isSuccessful()) {
+                if (!camera.isInitialLoadDone()) {
+                    camera.setInitialLoadDone(true);
+                }
+                camera.setBitmap(result.getBitmap());
+                List<Long> time = camera.getTimes();
+
+                if (time.size() == Utils.fpsLen) {
+
+                    long streamingFps = time.size() * 1000 / (time.get(time.size() - 1) - time.get(0));
+                    int fpsDeliv = Math.round(streamingFps);
+                    camera.setFrameRateText((fpsDeliv + "/" + result.getFps() + " fps"));
+
+                }
+
+                long timeNow = new Date().getTime();
+                time.add(timeNow);
+                if (time.size() > Utils.fpsLen) {
+                    time.remove(0);
+                }
+
+                if (!isFinishing()) {
+                    timeHandler.postDelayed(timerRunnable, Utils.imageRefreshInterval); //Start timer after 1 sec
+                }
+
+            } else {
+                camera.setInitialLoadDone(false);
+                camera.setError(new CameraImageError("motioneye_err1", result.getErrorString(), true));
+            }
+
+            adapter.notifyItemChanged(position);
+
+        }
+    }
+
+
+
+
+    private static String removeSlash(String url) {
+        if (!url.endsWith("/"))
+            return url;
+        String[] parts = url.split("/");
+
+        return parts[0];
+    }
+
+
+    private boolean isNetworkAvailable() {
+        ConnectivityManager connectivityManager
+                = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
+        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
+    }
+
+    private void startDeviceSettings(String deviceID) {
+        Intent fullscreen = new Intent(CameraViewer.this, DeviceSettings.class);
+        fullscreen.putExtra("DeviceId", deviceID);
+        startActivityForResult(fullscreen, 5300);
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+        if (requestCode == 5300)
+            if (resultCode == RESULT_CANCELED)
+                finish();
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/DeviceSettings.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/DeviceSettings.java
new file mode 100644
index 0000000..33b5a35
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/DeviceSettings.java
@@ -0,0 +1,1622 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.activities;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.design.widget.FloatingActionButton;
+import android.support.design.widget.TextInputLayout;
+import android.support.v7.app.AlertDialog;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.preference.CheckBoxPreference;
+import android.support.v7.preference.Preference;
+import android.support.v7.preference.PreferenceManager;
+import android.support.v7.preference.SwitchPreferenceCompat;
+import android.support.v7.widget.Toolbar;
+import android.text.Editable;
+import android.text.InputType;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.webkit.URLUtil;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.ApiInterface;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.api.ServiceGenerator;
+import com.developerfromjokela.motioneyeclient.classes.Cameras;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.MainConfig;
+import com.developerfromjokela.motioneyeclient.database.Source;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+import com.google.gson.Gson;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.select.Elements;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.security.NoSuchAlgorithmException;
+import java.util.Date;
+
+import okhttp3.MediaType;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+
+public class DeviceSettings extends AppCompatActivity {
+
+
+
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_devicesettings);
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        setSupportActionBar(toolbar);
+        toolbar.setNavigationIcon(R.drawable.ic_back);
+        toolbar.setNavigationOnClickListener(v -> finish());
+        DevicePreferences preferencesFragment = new DevicePreferences();
+        Intent intent = getIntent();
+        if (intent.getExtras() != null) {
+            preferencesFragment.setDeviceId(intent.getStringExtra("DeviceId"), findViewById(R.id.validateSettingsFab), this);
+            getSupportFragmentManager().beginTransaction().add(R.id.devPreferencesFrame, preferencesFragment).commit();
+        } else {
+            finish();
+        }
+
+
+    }
+
+
+    public static class DevicePreferences extends android.support.v7.preference.PreferenceFragmentCompat
+    {
+
+        private MainConfig config;
+        private Device device;
+        public static final MediaType JSON
+                = MediaType.parse("application/json; charset=utf-8");
+
+        private boolean networkChangesMade = false;
+        private FloatingActionButton validateButton;
+
+
+        @Override
+        public void onCreate(Bundle savedInstanceState)
+        {
+            super.onCreate(savedInstanceState);
+            addPreferencesFromResource(R.xml.devicepreferences);
+            disableMEYESettings();
+            initNewtorkSettings();
+
+            {
+                String autoOpenID = PreferenceManager.getDefaultSharedPreferences(getContext()).getString("autoOpenID", null);
+                if (autoOpenID != null)
+                   if (autoOpenID.equals(device.getID()))
+                       ((CheckBoxPreference)findPreference("open_by_default")).setChecked(true);
+                findPreference("open_by_default").setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
+                    @Override
+                    public boolean onPreferenceChange(Preference preference, Object o) {
+                        boolean autoStart = (boolean) o;
+                        if (autoStart)
+                            PreferenceManager.getDefaultSharedPreferences(getContext()).edit().putString("autoOpenID", device.getID()).apply();
+                        else
+                            PreferenceManager.getDefaultSharedPreferences(getContext()).edit().putString("autoOpenID", null).apply();
+                        return true;
+                    }
+                });
+            }
+            {
+                findPreference("admin_username").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+                        editText.setText(preference.getSummary());
+                        editText.setInputType(InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
+
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(config.getAdmin_username(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+                                        if (checkForDuplicate(config.getAdmin_username(), editText.getText().toString()))
+                                            b.setEnabled(false);
+                                        else
+                                            b.setEnabled(true);
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        disableMEYESettings();
+
+                                        try {
+                                            if (device.getUser().getUsername().equals(preference.getSummary()))
+                                                device.getUser().setUsername(editText.getText().toString());
+                                            changeSettings(getAdminUsernameSettingsJSON(editText.getText().toString()));
+                                        } catch (JSONException e) {
+                                            e.printStackTrace();
+                                            Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_LONG).show();
+
+                                        }
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+                        return false;
+                    }
+                });
+            }
+            {
+                findPreference("delete_camera").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        dialogBuilder.setTitle(R.string.delete_camera);
+                        dialogBuilder.setMessage(R.string.delete_camera_caution);
+                        dialogBuilder.setNegativeButton(R.string.cancel, null);
+                        dialogBuilder.setPositiveButton(R.string.delete_camera, new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                Source source = new Source(getContext());
+                                try {
+                                    source.delete_item(device);
+                                    getActivity().setResult(RESULT_CANCELED);
+                                    getActivity().finish();
+                                } catch (Exception e) {
+                                    e.printStackTrace();
+                                    Toast.makeText(getActivity(), getString(R.string.failed_device_delete, e.getMessage()), Toast.LENGTH_SHORT).show();
+                                }
+                            }
+                        });
+                        AlertDialog alertDialog = dialogBuilder.create();
+                        alertDialog.show();
+                        return false;
+                    }
+                });
+            }
+            {
+                findPreference("admin_password").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+                        editText.setText(preference.getSummary());
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(config.getAdmin_password(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+                                        if (checkForDuplicate(config.getAdmin_password(), editText.getText().toString()))
+                                            b.setEnabled(false);
+                                        else
+                                            b.setEnabled(true);
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        disableMEYESettings();
+                                        try {
+                                            JSONObject settings = getBasicSettingsJSON();
+                                            if (device.getUser().getUsername().equals(findPreference("admin_username").getSummary()))
+                                                device.getUser().setPassword(editText.getText().toString());
+                                            settings.getJSONObject("main").put("admin_password", editText.getText().toString());
+                                            changeSettings(settings);
+                                            dialog.dismiss();
+                                        } catch (JSONException e) {
+                                            e.printStackTrace();
+                                            Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_LONG).show();
+
+                                        }
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+                        return false;
+                    }
+                });
+            }
+
+            {
+                findPreference("surv_username").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+                        editText.setText(preference.getSummary());
+                        editText.setInputType(InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
+
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(config.getNormal_username(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+                                        if (checkForDuplicate(config.getNormal_username(), editText.getText().toString()))
+                                            b.setEnabled(false);
+                                        else
+                                            b.setEnabled(true);
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        disableMEYESettings();
+
+
+                                        try {
+                                            if (device.getUser().getUsername().equals(preference.getSummary()))
+                                                device.getUser().setUsername(editText.getText().toString());
+                                            changeSettings(getNormalUsernameSettingsJSON(editText.getText().toString()));
+                                        } catch (JSONException e) {
+                                            e.printStackTrace();
+                                            Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_LONG).show();
+
+                                        }
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+                        return false;
+                    }
+                });
+            }
+            {
+                findPreference("surv_password").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+                        editText.setText(preference.getSummary());
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(config.getNormal_password(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+                                        if (checkForDuplicate(config.getNormal_password(), editText.getText().toString()))
+                                            b.setEnabled(false);
+                                        else
+                                            b.setEnabled(true);
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        disableMEYESettings();
+
+                                        try {
+                                            JSONObject settings = getBasicSettingsJSON();
+                                            if (device.getUser().getUsername().equals(findPreference("surv_username").getSummary()))
+                                                device.getUser().setPassword(editText.getText().toString());
+
+                                            settings.getJSONObject("main").put("normal_password", editText.getText().toString());
+                                            changeSettings(settings);
+                                            dialog.dismiss();
+                                        } catch (JSONException e) {
+                                            e.printStackTrace();
+                                            Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_LONG).show();
+
+                                        }
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+
+                        return false;
+                    }
+                });
+            }
+
+            {
+                findPreference("ip_addr").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+
+                        editText.setText(preference.getSummary());
+                        editText.setInputType(InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT);
+
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(device.getDeviceUrl(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                        String url = s.toString();
+
+                                        if (!url.isEmpty()) {
+
+                                            if (checkForDuplicate(device.getDeviceUrl(), url)) {
+                                                b.setEnabled(false);
+                                            } else
+                                                b.setEnabled(true);
+
+
+                                            if (url.split("://").length >= 2) {
+                                                String nUrl = url.split("://")[1];
+                                                if (nUrl.contains(":")) {
+                                                    Log.e("DS", "PORT D");
+                                                    b.setEnabled(false);
+                                                    return;
+                                                } else
+                                                    b.setEnabled(true);
+                                            } else {
+                                                if (url.contains(":")) {
+                                                    Log.e("DS", "PORT D");
+                                                    b.setEnabled(false);
+                                                    return;
+                                                } else
+                                                    b.setEnabled(true);
+                                            }
+
+                                            if (!URLUtil.isValidUrl(url)) {
+                                                url = "http://" + url;
+                                                b.setEnabled(URLUtil.isValidUrl(url));
+                                            } else
+                                                b.setEnabled(true);
+
+
+                                        } else {
+                                            b.setEnabled(false);
+
+                                        }
+
+
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        device.setDeviceUrl(editText.getText().toString());
+                                        networkChangesMade = true;
+                                        replaceDeviceInDB();
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+
+                        return false;
+                    }
+                });
+            }
+            {
+                findPreference("ddns_addr").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+
+                        editText.setText(preference.getSummary());
+                        editText.setInputType(InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT);
+
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(device.getDdnsURL(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                        String url = editText.getText().toString();
+                                        if (!url.isEmpty()) {
+
+                                                if (checkForDuplicate(device.getDdnsURL(), url)) {
+                                                    b.setEnabled(false);
+                                                }
+                                                else
+                                                    b.setEnabled(true);
+
+                                            if (!URLUtil.isValidUrl(url)) {
+                                                url = "http://" + url;
+                                                b.setEnabled(URLUtil.isValidUrl(url));
+                                            } else
+                                                b.setEnabled(true);
+
+                                            if (url.contains("://") && url.split("://").length >= 2) {
+                                                String nUrl = url.split("://")[1];
+                                                if (nUrl.contains(":")) {
+                                                    Log.e("DS", "PORT D2");
+                                                    b.setEnabled(false);
+                                                } else
+                                                    b.setEnabled(true);
+                                            } else {
+                                                if (url.contains(":")) {
+                                                    Log.e("DS", "PORT D");
+                                                    b.setEnabled(false);
+                                                } else
+                                                    b.setEnabled(true);
+
+                                            }
+
+                                        } else {
+                                            b.setEnabled(true);
+
+                                        }
+
+
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        device.setDdnsURL(editText.getText().toString());
+                                        networkChangesMade = true;
+
+                                        replaceDeviceInDB();
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+
+                        return false;
+                    }
+                });
+            }
+            {
+                findPreference("port").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+
+                        editText.setText(preference.getSummary());
+                        editText.setInputType(InputType.TYPE_CLASS_NUMBER);
+
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(device.getLocalPort(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                        String url = s.toString();
+
+
+                                            if (checkForDuplicate(device.getDdnsURL(), url)) {
+                                                b.setEnabled(false);
+                                            }
+                                            else
+                                                b.setEnabled(true);
+
+
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        device.setLocalPort(editText.getText().toString());
+                                        networkChangesMade = true;
+
+                                        replaceDeviceInDB();
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+
+                        return false;
+                    }
+                });
+            }
+
+            {
+                findPreference("ddns_port").setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                    @Override
+                    public boolean onPreferenceClick(Preference preference) {
+                        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+                        LayoutInflater inflater = getActivity().getLayoutInflater();
+                        View dialogView = inflater.inflate(R.layout.settingdialog, null);
+                        dialogBuilder.setView(dialogView);
+
+                        dialogBuilder.setNegativeButton(R.string.close, null);
+
+                        TextInputLayout layout = dialogView.findViewById(R.id.settingHead);
+                        EditText editText = dialogView.findViewById(R.id.settingParam);
+
+                        editText.setText(preference.getSummary());
+                        editText.setInputType(InputType.TYPE_CLASS_NUMBER);
+
+                        layout.setHint(preference.getTitle());
+                        dialogBuilder.setPositiveButton(R.string.save, null);
+                        AlertDialog alertDialog = dialogBuilder.create();
+
+                        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                            @Override
+                            public void onShow(DialogInterface dialog) {
+
+                                Button b = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+                                if (checkForDuplicate(device.getDDNSPort(), editText.getText().toString()))
+                                    b.setEnabled(false);
+                                else
+                                    b.setEnabled(true);
+                                editText.addTextChangedListener(new TextWatcher() {
+                                    @Override
+                                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                                    }
+
+                                    @Override
+                                    public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+
+                                    }
+
+                                    @Override
+                                    public void afterTextChanged(Editable s) {
+                                        String url = s.toString();
+
+
+                                        if (checkForDuplicate(device.getDDNSPort(), url)) {
+                                            b.setEnabled(false);
+                                        }
+                                        else
+                                            b.setEnabled(true);
+
+
+                                    }
+                                });
+                                b.setOnClickListener(new View.OnClickListener() {
+
+                                    @Override
+                                    public void onClick(View view) {
+
+                                        device.setDDNSPort(editText.getText().toString());
+                                        networkChangesMade = true;
+
+                                        replaceDeviceInDB();
+                                        dialog.dismiss();
+                                    }
+                                });
+                            }
+                        });
+                        alertDialog.show();
+
+                        return false;
+                    }
+                });
+            }
+
+
+            loadConfig();
+
+
+        }
+
+        private void initNewtorkSettings() {
+            findPreference("ip_addr").setSummary(device.getDeviceUrl());
+            findPreference("ddns_addr").setSummary(device.getDdnsURL());
+            findPreference("port").setSummary(device.getLocalPort());
+            findPreference("ddns_port").setSummary(device.getDDNSPort());
+
+        }
+
+        public void loadConfig() {
+            try {
+                String url = getFullUrl() + "/config/main/get/?_=" + new Date().getTime();
+                MotionEyeHelper helper = new MotionEyeHelper();
+                helper.setUsername(device.getUser().getUsername());
+                helper.setPasswordHash(device.getUser().getPassword());
+                url = helper.addAuthParams("GET", url, "");
+                ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, getFullUrl());
+                apiInterface.getMainConfig(url).enqueue(new Callback<MainConfig>() {
+                    @Override
+                    public void onResponse(Call<MainConfig> call, Response<MainConfig> response) {
+                        if (response.isSuccessful()) {
+                            config = response.body();
+                            getAdvancedDetails();
+
+                        }
+
+                    }
+
+                    @Override
+                    public void onFailure(Call<MainConfig> call, Throwable t) {
+                        Toast.makeText(getActivity(), t.getMessage(), Toast.LENGTH_LONG).show();
+                    }
+                });
+            } catch (NoSuchAlgorithmException e) {
+                e.printStackTrace();
+                Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_LONG).show();
+
+            }
+        }
+
+        private void validateSettings() {
+            AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+            LayoutInflater inflater = getActivity().getLayoutInflater();
+            View validateView = inflater.inflate(R.layout.validatedialog, null);
+            dialogBuilder.setView(validateView);
+
+            dialogBuilder.setPositiveButton(R.string.close, null);
+            dialogBuilder.setCancelable(false);
+            AlertDialog validateDialog = dialogBuilder.create();
+            validateDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+                @Override
+                public void onShow(DialogInterface dialog) {
+
+
+
+                    TextView Errorstatus = validateView.findViewById(R.id.errorDetails);
+                    // Root Layouts
+                    LinearLayout rootLayout2 = validateView.findViewById(R.id.ddns_connection_test);
+                    // Progressbars
+                    ProgressBar progressBar1 = validateView.findViewById(R.id.progress1);
+                    ProgressBar progressBar2 = validateView.findViewById(R.id.progress2);
+                    ProgressBar progressBar3 = validateView.findViewById(R.id.progress3);
+                    ProgressBar progressBar4 = validateView.findViewById(R.id.progress4);
+
+                    // Icons
+                    ImageView status1 = validateView.findViewById(R.id.statusimage1);
+                    ImageView status2 = validateView.findViewById(R.id.statusimage2);
+                    ImageView status3 = validateView.findViewById(R.id.statusimage3);
+                    ImageView status4 = validateView.findViewById(R.id.statusimage4);
+                    Button continue_btn = validateDialog.getButton(AlertDialog.BUTTON_POSITIVE);
+
+                    continue_btn.setOnClickListener(new View.OnClickListener() {
+                        @Override
+                        public void onClick(View v) {
+                            validateDialog.dismiss();
+                        }
+                    });
+                    continue_btn.setEnabled(false);
+
+                    if (device.getDdnsURL().length() > 0) {
+                        rootLayout2.setVisibility(View.VISIBLE);
+                    }
+
+
+                    validateServer(new TestInterface() {
+                        @Override
+                        public void TestSuccessful(String response, int status) {
+                            progressBar1.setVisibility(View.GONE);
+                            status1.setVisibility(View.VISIBLE);
+                            status1.setImageResource(R.drawable.ic_check_green);
+                            status2.setVisibility(View.GONE);
+                            progressBar2.setVisibility(View.VISIBLE);
+                            if (device.getDdnsURL().length() > 0) {
+                                validateServer(new TestInterface() {
+                                    @Override
+                                    public void TestSuccessful(String response, int status) {
+
+                                        progressBar2.setVisibility(View.GONE);
+                                        status2.setVisibility(View.VISIBLE);
+                                        status2.setImageResource(R.drawable.ic_check_green);
+                                        try {
+                                            checkLogin(device.getDeviceUrlCombo(), new TestInterface() {
+                                                @Override
+                                                public void TestSuccessful(String response, int status) {
+                                                    progressBar3.setVisibility(View.GONE);
+                                                    status3.setVisibility(View.VISIBLE);
+                                                    status3.setImageResource(R.drawable.ic_check_green);
+                                                    status4.setVisibility(View.GONE);
+                                                    progressBar4.setVisibility(View.VISIBLE);
+                                                    getServerDetails(new TestInterface() {
+                                                        @Override
+                                                        public void TestSuccessful(String response, int status) {
+                                                            validateDialog.setCancelable(true);
+                                                            continue_btn.setEnabled(true);
+                                                            status4.setVisibility(View.VISIBLE);
+                                                            progressBar4.setVisibility(View.GONE);
+                                                            status4.setImageResource(R.drawable.ic_check_green);
+
+                                                        }
+
+                                                        @Override
+                                                        public void TestFailed(String response, int status) {
+                                                            validateDialog.setCancelable(true);
+                                                            continue_btn.setEnabled(true);
+                                                            status4.setVisibility(View.VISIBLE);
+                                                            progressBar4.setVisibility(View.GONE);
+                                                            status4.setImageResource(R.drawable.ic_error_red);
+                                                            Errorstatus.setVisibility(View.VISIBLE);
+                                                            Errorstatus.setText(response);
+                                                        }
+                                                    }, device.getDeviceUrlCombo());
+                                                }
+
+                                                @Override
+                                                public void TestFailed(String response, int status) {
+                                                    validateDialog.setCancelable(true);
+                                                    continue_btn.setEnabled(true);
+                                                    progressBar3.setVisibility(View.GONE);
+                                                    status3.setVisibility(View.VISIBLE);
+                                                    status3.setImageResource(R.drawable.ic_error_red);
+                                                    Errorstatus.setVisibility(View.VISIBLE);
+                                                    Errorstatus.setText(response);
+                                                }
+                                            });
+                                        } catch (NoSuchAlgorithmException e) {
+                                            e.printStackTrace();
+                                            progressBar3.setVisibility(View.GONE);
+                                            status3.setVisibility(View.VISIBLE);
+                                            status3.setImageResource(R.drawable.ic_error_red);
+                                            Errorstatus.setVisibility(View.VISIBLE);
+                                            Errorstatus.setText(e.getMessage());
+                                            validateDialog.setCancelable(true);
+                                            continue_btn.setEnabled(true);
+                                        }
+                                    }
+
+                                    @Override
+                                    public void TestFailed(String response, int status) {
+                                        validateDialog.setCancelable(true);
+                                        continue_btn.setEnabled(true);
+                                        progressBar2.setVisibility(View.GONE);
+                                        status2.setVisibility(View.VISIBLE);
+                                        status2.setImageResource(R.drawable.ic_error_red);
+                                        Errorstatus.setVisibility(View.VISIBLE);
+                                        Errorstatus.setText(response);
+                                    }
+                                }, device.getDDNSUrlCombo());
+                            } else {
+
+                                try {
+                                    checkLogin(device.getDeviceUrlCombo(), new TestInterface() {
+                                        @Override
+                                        public void TestSuccessful(String response, int status) {
+                                            progressBar3.setVisibility(View.GONE);
+                                            status3.setVisibility(View.VISIBLE);
+                                            status3.setImageResource(R.drawable.ic_check_green);
+                                            status4.setVisibility(View.GONE);
+                                            progressBar4.setVisibility(View.VISIBLE);
+                                            getServerDetails(new TestInterface() {
+                                                @Override
+                                                public void TestSuccessful(String response, int status) {
+                                                    validateDialog.setCancelable(true);
+                                                    continue_btn.setEnabled(true);
+                                                    status4.setVisibility(View.VISIBLE);
+                                                    progressBar4.setVisibility(View.GONE);
+                                                    status4.setImageResource(R.drawable.ic_check_green);
+
+
+                                                }
+
+                                                @Override
+                                                public void TestFailed(String response, int status) {
+                                                    validateDialog.setCancelable(true);
+                                                    continue_btn.setEnabled(true);
+                                                    status4.setVisibility(View.VISIBLE);
+                                                    progressBar4.setVisibility(View.GONE);
+                                                    status4.setImageResource(R.drawable.ic_error_red);
+                                                    Errorstatus.setVisibility(View.VISIBLE);
+                                                    Errorstatus.setText(response);
+                                                }
+                                            }, device.getDeviceUrlCombo());
+                                        }
+
+                                        @Override
+                                        public void TestFailed(String response, int status) {
+                                            validateDialog.setCancelable(true);
+                                            continue_btn.setEnabled(true);
+                                            progressBar3.setVisibility(View.GONE);
+                                            status3.setVisibility(View.VISIBLE);
+                                            status3.setImageResource(R.drawable.ic_error_red);
+                                            Errorstatus.setVisibility(View.VISIBLE);
+                                            Errorstatus.setText(response);
+                                        }
+                                    });
+                                } catch (NoSuchAlgorithmException e) {
+                                    e.printStackTrace();
+                                    progressBar3.setVisibility(View.GONE);
+                                    status3.setVisibility(View.VISIBLE);
+                                    status3.setImageResource(R.drawable.ic_error_red);
+                                    Errorstatus.setVisibility(View.VISIBLE);
+                                    Errorstatus.setText(e.getMessage());
+                                    validateDialog.setCancelable(true);
+                                    continue_btn.setEnabled(true);
+
+                                }
+                            }
+
+                        }
+
+                        @Override
+                        public void TestFailed(String response, int status2) {
+                            progressBar1.setVisibility(View.GONE);
+                            status1.setVisibility(View.VISIBLE);
+                            status1.setImageResource(R.drawable.ic_error_red);
+                            Errorstatus.setVisibility(View.VISIBLE);
+                            validateDialog.setCancelable(true);
+                            continue_btn.setEnabled(true);
+
+                            Errorstatus.setText(response);
+                        }
+                    }, device.getDeviceUrlCombo());
+                }
+            });
+
+            validateDialog.show();
+
+
+
+
+        }
+
+        private void setConfigValues() {
+            SwitchPreferenceCompat advancedSettings = (SwitchPreferenceCompat) findPreference("advancedSettings") ;
+            advancedSettings.setChecked(config.isShow_advanced());
+            advancedSettings.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {
+                @Override
+                public boolean onPreferenceClick(Preference preference) {
+
+                    try {
+                        changeSettings(getAdvancedSettingsJSON(advancedSettings.isChecked()));
+                    } catch (JSONException e) {
+                        e.printStackTrace();
+                        Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_LONG).show();
+
+                    }
+                    return false;
+                }
+            });
+            findPreference("admin_username").setSummary(config.getAdmin_username());
+            findPreference("admin_password").setSummary(config.getAdmin_password());
+            findPreference("surv_username").setSummary(config.getNormal_username());
+            findPreference("surv_password").setSummary(config.getNormal_password());
+            Preference motionEyeVersion = findPreference("motionEyeVersion");
+            Preference motionVersion = findPreference("motionVersion");
+            Preference OSVersion = findPreference("OSVersion");
+            if (config.isShow_advanced()) {
+                motionEyeVersion.setVisible(true);
+
+                OSVersion.setVisible(true);
+                motionVersion.setVisible(true);
+
+                motionEyeVersion.setSummary(device.getMotioneyeVersion());
+                motionVersion.setSummary(device.getMotionVersion());
+                OSVersion.setSummary(device.getOsVersion());
+            } else {
+                motionEyeVersion.setVisible(false);
+
+                OSVersion.setVisible(false);
+                motionVersion.setVisible(false);
+            }
+
+
+
+        }
+
+        private void enableMEYESettings() {
+            findPreference("advancedSettings").setEnabled(true);
+            findPreference("admin_username").setEnabled(true);
+            findPreference("admin_password").setEnabled(true);
+            findPreference("surv_username").setEnabled(true);
+            findPreference("surv_password").setEnabled(true);
+
+        }
+
+        private void disableMEYESettings() {
+            findPreference("advancedSettings").setEnabled(false);
+            findPreference("admin_username").setEnabled(false);
+            findPreference("admin_password").setEnabled(false);
+            findPreference("surv_username").setEnabled(false);
+            findPreference("surv_password").setEnabled(false);
+
+        }
+
+        private void validateServer(TestInterface testInterface, String serverurl) {
+            String baseurl;
+
+            if (!serverurl.contains("://"))
+                baseurl = removeSlash("http://" + serverurl);
+            else
+                baseurl = removeSlash(serverurl);
+
+            ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+            Call<ResponseBody> call = apiInterface.login(baseurl + "/login", device.getUser().getUsername(), device.getUser().getPassword(), "login");
+            call.enqueue(new Callback<ResponseBody>() {
+
+                @Override
+                public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                    if (response.headers().get("Server").toLowerCase().contains("motioneye")) {
+                        try {
+                            testInterface.TestSuccessful(response.body().string(), response.code());
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                            testInterface.TestFailed(e.getMessage(), 700);
+
+                        }
+
+
+                    } else {
+                        testInterface.TestFailed(getString(R.string.wizard_not_motioneye), 404);
+
+                    }
+
+
+                }
+
+                @Override
+                public void onFailure(Call<ResponseBody> call, Throwable t) {
+                    t.printStackTrace();
+                    t.fillInStackTrace();
+                    testInterface.TestFailed(t.getMessage(), 700);
+
+                }
+            });
+        }
+
+        private void getServerDetails(TestInterface testInterface, String serverurl) {
+            String baseurl;
+
+            if (!serverurl.contains("://"))
+                baseurl = removeSlash("http://" + serverurl);
+            else
+                baseurl = removeSlash(serverurl);
+
+            ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+            Call<ResponseBody> call = apiInterface.getMotionDetails(baseurl + "/version");
+            call.enqueue(new Callback<ResponseBody>() {
+
+                @Override
+                public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                    if (response.headers().get("Server").toLowerCase().contains("motioneye")) {
+                        try {
+                            final String stringResponse = response.body().string();
+                            Document html = Jsoup.parse(stringResponse);
+                            Elements elements = html.select("body");
+                            String[] lines = elements.html().replace("\"", "").replace("\n", "").split("<br>");
+                            for (String string : lines) {
+                                String[] paramParts = string.split("=");
+                                String paramName = paramParts[0].trim();
+                                String paramValue = paramParts[1];
+                                if (paramName.contains("hostname"))
+                                    device.setDeviceName(paramValue);
+                                else if (paramName.contains("motion_version"))
+                                    device.setMotionVersion(paramValue);
+                                else if (paramName.contains("os_version"))
+                                    device.setOsVersion(paramValue);
+                                else if (paramName.equals("version"))
+                                    device.setMotioneyeVersion(paramValue);
+
+                            }
+                            String url = baseurl + "/config/list?_=" + new Date().getTime();
+                            MotionEyeHelper helper = new MotionEyeHelper();
+                            helper.setUsername(device.getUser().getUsername());
+                            helper.setPasswordHash(device.getUser().getPassword());
+                            url = helper.addAuthParams("GET", url, "");
+
+                            Call<Cameras> call2 = apiInterface.getCameras(url);
+                            call2.enqueue(new Callback<Cameras>() {
+                                @Override
+                                public void onResponse(Call<Cameras> call, Response<Cameras> response) {
+                                    Cameras cameras = response.body();
+                                    device.setCameras(cameras.getCameras());
+                                    testInterface.TestSuccessful(stringResponse, response.code());
+
+                                }
+
+                                @Override
+                                public void onFailure(Call<Cameras> call, Throwable t) {
+                                    t.printStackTrace();
+                                    t.fillInStackTrace();
+                                    testInterface.TestFailed(t.getMessage(), 700);
+                                }
+                            });
+
+
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                            testInterface.TestFailed(e.getMessage(), 700);
+
+                        } catch (NoSuchAlgorithmException e) {
+                            e.printStackTrace();
+                            testInterface.TestFailed(e.getMessage(), 700);
+
+                        }
+
+
+                    } else {
+                        testInterface.TestFailed(getString(R.string.wizard_not_motioneye), 404);
+
+                    }
+
+
+                }
+
+                @Override
+                public void onFailure(Call<ResponseBody> call, Throwable t) {
+                    t.printStackTrace();
+                    t.fillInStackTrace();
+                    testInterface.TestFailed(t.getMessage(), 700);
+
+                }
+            });
+        }
+
+        public static boolean isValidURL(String url) {
+            return URLUtil.isValidUrl(url);
+        }
+
+        private interface TestInterface {
+            void TestSuccessful(String response, int status);
+
+            void TestFailed(String response, int status);
+
+        }
+
+        private void checkLogin(String serverurl, TestInterface testInterface) throws NoSuchAlgorithmException {
+            String baseurl;
+            if (!serverurl.contains("://"))
+                baseurl = removeSlash("http://" + serverurl);
+            else
+                baseurl = removeSlash(serverurl);
+            ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+
+            MotionEyeHelper helper = new MotionEyeHelper();
+            helper.setUsername(device.getUser().getUsername());
+            helper.setPasswordHash(device.getUser().getPassword());
+            String url = baseurl;
+
+            url += "/login?_=" + new Date().getTime();
+            helper.setLoggedIn(true);
+            url = helper.addAuthParams("GET", url, "");
+            Call<okhttp3.ResponseBody> checkLoginCall = apiInterface.loginResult(url);
+            checkLoginCall.enqueue(new Callback<okhttp3.ResponseBody>() {
+                @Override
+                public void onResponse(Call<okhttp3.ResponseBody> call2, Response<okhttp3.ResponseBody> response2) {
+                    if (!response2.isSuccessful()) {
+                        try (ResponseBody responseBody2 = response2.errorBody()) {
+                            final String responseString = responseBody2.string();
+                            if (response2.code() == 403)
+                                testInterface.TestFailed(getString(R.string.wizard_wrong_credentials), response2.code());
+                            else
+                                testInterface.TestFailed(responseString, response2.code());
+
+
+                        } catch (Exception e) {
+                            e.fillInStackTrace();
+                            e.printStackTrace();
+                            testInterface.TestFailed(e.getMessage(), 700);
+                        }
+                    } else {
+                        try (ResponseBody responseBody2 = response2.body()) {
+                            final String stringResponse2 = responseBody2.string();
+                            testInterface.TestSuccessful(stringResponse2, response2.code());
+
+
+                        } catch (Exception e) {
+                            e.fillInStackTrace();
+                            e.printStackTrace();
+                            testInterface.TestFailed(e.getMessage(), 700);
+                        }
+                    }
+
+                }
+
+                @Override
+                public void onFailure(Call<ResponseBody> call, Throwable t) {
+                    t.fillInStackTrace();
+
+                    t.printStackTrace();
+                    testInterface.TestFailed(t.getMessage(), 700);
+
+                }
+            });
+        }
+
+        private static String removeSlash(String url) {
+            if (!url.endsWith("/"))
+                return url;
+            String[] parts = url.split("/");
+
+            return parts[0];
+        }
+
+
+        private String getFullUrl() {
+            String serverurl;
+            if (device.getDdnsURL().length() > 5) {
+                if ((Utils.getNetworkType(getActivity())) == NETWORK_MOBILE) {
+                    serverurl = device.getDDNSUrlCombo();
+                } else if (device.getWlan().networkId == Utils.getCurrentWifiNetworkId(getActivity())) {
+                    serverurl = device.getDeviceUrlCombo();
+
+                } else {
+                    serverurl = device.getDDNSUrlCombo();
+
+                }
+            } else {
+                serverurl = device.getDeviceUrlCombo();
+
+            }
+            String baseurl;
+            if (!serverurl.contains("://"))
+                baseurl = Utils.removeSlash("http://" + serverurl);
+            else
+                baseurl = Utils.removeSlash(serverurl);
+            return baseurl;
+        }
+
+        public void setDeviceId(String ID, FloatingActionButton button,  Context context) {
+            Source source = new Source(context);
+            try {
+                device = source.get(ID);
+            } catch (Exception e) {
+                e.printStackTrace();
+                getActivity().finish();
+            }
+
+            this.validateButton = button;
+
+        }
+
+        private JSONObject getBasicSettingsJSON() throws JSONException {
+
+            JSONObject settings = new JSONObject();
+            settings.put("admin_username", config.getAdmin_username());
+            settings.put("normal_username", config.getNormal_username());
+            settings.put("show_advanced", config.isShow_advanced());
+            JSONObject finalObject = new JSONObject();
+            finalObject.put("main", settings);
+            return finalObject;
+        }
+
+        private JSONObject getAdminUsernameSettingsJSON(String username) throws JSONException {
+
+            JSONObject settings = new JSONObject();
+            settings.put("admin_username", username);
+            settings.put("normal_username", config.getNormal_username());
+            settings.put("show_advanced", config.isShow_advanced());
+            JSONObject finalObject = new JSONObject();
+            finalObject.put("main", settings);
+            return finalObject;
+        }
+
+        private JSONObject getNormalUsernameSettingsJSON(String username) throws JSONException {
+
+            JSONObject settings = new JSONObject();
+
+            settings.put("admin_username", config.getAdmin_username());
+            settings.put("normal_username", username);
+            settings.put("show_advanced", config.isShow_advanced());
+            JSONObject finalObject = new JSONObject();
+            finalObject.put("main", settings);
+            return finalObject;
+        }
+
+        private JSONObject getAdvancedSettingsJSON(boolean showAdvanced) throws JSONException {
+
+            JSONObject settings = new JSONObject();
+
+            settings.put("admin_username", config.getAdmin_username());
+            settings.put("normal_username", config.getNormal_username());
+            settings.put("show_advanced", showAdvanced);
+            JSONObject finalObject = new JSONObject();
+            finalObject.put("main", settings);
+            return finalObject;
+        }
+
+        @Override
+        public void onCreatePreferences(Bundle bundle, String s) {
+
+        }
+
+        private boolean checkForDuplicate(String original, String newValue) {
+            return original.equals(newValue);
+        }
+
+
+        private void changeSettings(JSONObject changes) {
+            try {
+                String url = getFullUrl() + "/config/0/set/?_=" + new Date().getTime();
+                MotionEyeHelper helper = new MotionEyeHelper();
+                helper.setUsername(device.getUser().getUsername());
+                helper.setPasswordHash(device.getUser().getPassword());
+                RequestBody body = RequestBody.create(JSON, changes.toString());
+
+                url = helper.addAuthParams("POST", url, changes.toString());
+                ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, getFullUrl());
+                disableMEYESettings();
+
+
+                apiInterface.changeMainConfig(url, body).enqueue(new Callback<ResponseBody>() {
+                    @Override
+                    public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                        try (ResponseBody body = response.body()) {
+                            assert body != null;
+                            String responseString = body.string();
+                            JSONObject object = new JSONObject(responseString);
+                            if (!object.getString("error").equals("null")) {
+                                Toast.makeText(getActivity(), object.getString("error"), Toast.LENGTH_SHORT).show();
+                            }
+
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                        replaceDeviceInDB();
+
+                        loadConfig();
+                    }
+
+                    @Override
+                    public void onFailure(Call<ResponseBody> call, Throwable t) {
+                        Toast.makeText(getActivity(), t.getMessage(), Toast.LENGTH_LONG).show();
+                        loadConfig();
+
+                    }
+                });
+
+            } catch (NoSuchAlgorithmException e) {
+                e.printStackTrace();
+                Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_LONG).show();
+
+            }
+        }
+
+        private void getAdvancedDetails() {
+
+
+            ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, getFullUrl());
+            disableMEYESettings();
+
+            apiInterface.getMotionDetails(getFullUrl() + "/version").enqueue(new Callback<ResponseBody>() {
+                @Override
+                public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                    setConfigValues();
+                    enableMEYESettings();
+                    if (response.headers().get("Server").toLowerCase().contains("motioneye")) {
+                        try {
+                            final String stringResponse = response.body().string();
+                            Document html = Jsoup.parse(stringResponse);
+                            Elements elements = html.select("body");
+                            String[] lines = elements.html().replace("\"", "").replace("\n", "").split("<br>");
+                            for (String string : lines) {
+                                String[] paramParts = string.split("=");
+                                String paramName = paramParts[0].trim();
+                                String paramValue = paramParts[1];
+                                if (paramName.contains("hostname"))
+                                    device.setDeviceName(paramValue);
+                                else if (paramName.contains("motion_version"))
+                                    device.setMotionVersion(paramValue);
+                                else if (paramName.contains("os_version"))
+                                    device.setOsVersion(paramValue);
+                                else if (paramName.equals("version"))
+                                    device.setMotioneyeVersion(paramValue);
+
+                            }
+                            try {
+                                if (Double.valueOf(device.getMotioneyeVersion()) > 0.4 || Double.valueOf(device.getMotioneyeVersion()) == 0.4) {
+                                    hideAdvancedSettingsSwitch();
+                                    getActivity().setTitle(device.getDeviceName()+" "+getString(R.string.settings));
+                                    config.setShow_advanced(true);
+                                    setConfigValues();
+                                    enableMEYESettings();
+
+                                } else {
+                                    if (config.isShow_advanced()) {
+                                        getActivity().setTitle(device.getDeviceName()+" "+getString(R.string.settings));
+                                        setConfigValues();
+                                        enableMEYESettings();
+                                    }
+                                }
+                            } catch (Exception ignored) {
+                                if (config.isShow_advanced()) {
+                                    getActivity().setTitle(device.getDeviceName()+" "+getString(R.string.settings));
+                                    setConfigValues();
+                                    enableMEYESettings();
+                                }
+                            }
+
+
+                        } catch (IOException e) {
+                            e.printStackTrace();
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+
+
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<ResponseBody> call, Throwable t) {
+                    setConfigValues();
+                    enableMEYESettings();
+                }
+            });
+
+
+        }
+
+
+        private void hideAdvancedSettingsSwitch() {
+            Preference advancedSettings = findPreference("advancedSettings");
+            advancedSettings.setVisible(false);
+        }
+
+
+
+
+        @SuppressLint("RestrictedApi")
+        private void replaceDeviceInDB() {
+            Source source = new Source(getActivity());
+            try {
+                source.editEntry(device);
+                loadConfig();
+                initNewtorkSettings();
+
+            } catch (Exception e) {
+                e.printStackTrace();
+                Toast.makeText(getActivity(), e.getMessage(), Toast.LENGTH_SHORT).show();
+            }
+            if (networkChangesMade) {
+                validateButton.setVisibility(View.VISIBLE);
+                validateButton.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        validateSettings();
+                        validateButton.setVisibility(View.GONE);
+                    }
+                });
+            }
+        }
+    }
+
+
+
+
+
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/FullCameraViewer.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/FullCameraViewer.java
new file mode 100644
index 0000000..6f84b75
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/FullCameraViewer.java
@@ -0,0 +1,558 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.activities;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Handler;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+import android.view.Window;
+import android.view.WindowManager;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.Button;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+import android.widget.Toast;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.ApiInterface;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.api.ServiceGenerator;
+import com.developerfromjokela.motioneyeclient.classes.ActionStatus;
+import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.CameraImage;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.database.Source;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+import com.developerfromjokela.motioneyeclient.ui.adapters.ActionsAdapter;
+import com.developerfromjokela.motioneyeclient.ui.adapters.HttpCamerasAdapter;
+import com.google.gson.Gson;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+import static android.app.DownloadManager.Request.NETWORK_WIFI;
+
+
+public class FullCameraViewer extends Activity implements ActionsAdapter.ActionsAdapterListener {
+
+    private Source source;
+    private boolean loaded = false;
+    private boolean attached = true;
+    private TextView status;
+    private Runnable timerRunnable;
+    private Handler timerHandler = new Handler();
+    private ActionsAdapter adapter;
+    private String baseurl;
+    private Device device;
+    private Camera camera;
+    private ImageView cameraImage;
+    private LinearLayout loadingBar;
+    private RelativeLayout cameraFrame;
+    private LinearLayout bottomBar;
+    private LinearLayout topBar;
+    private TextView fps;
+    private ProgressBar loadingCircle;
+    private List<Long> time;
+    private String finalUrl;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        requestWindowFeature(Window.FEATURE_NO_TITLE);
+
+
+        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
+                WindowManager.LayoutParams.FLAG_FULLSCREEN);
+        setContentView(R.layout.activity_full_camera_viewer);
+        cameraImage = findViewById(R.id.cameraFullImage);
+        loadingBar = findViewById(R.id.progressBar);
+        cameraFrame = findViewById(R.id.cameraFrame);
+        bottomBar = findViewById(R.id.bottomBar);
+        topBar = findViewById(R.id.topBar);
+        fps = findViewById(R.id.cameraFPS);
+        loadingCircle = findViewById(R.id.progressBar2);
+        TextView cameraName = findViewById(R.id.cameraName);
+        RecyclerView actions = findViewById(R.id.actions);
+        LinearLayout joystick = findViewById(R.id.dircontrols);
+
+
+        status = findViewById(R.id.status);
+
+        source = new Source(this);
+
+        Intent intent = getIntent();
+        if (intent.getExtras() != null) {
+
+            String ID = intent.getStringExtra("DeviceId");
+
+            try {
+                device = source.get(ID);
+                camera = new Gson().fromJson(intent.getStringExtra("Camera"), Camera.class);
+                MotionEyeHelper helper = new MotionEyeHelper();
+                helper.setUsername(device.getUser().getUsername());
+                try {
+                    helper.setPasswordHash(device.getUser().getPassword());
+                } catch (NoSuchAlgorithmException e) {
+                    e.printStackTrace();
+                }
+                String serverurl;
+                String cameraId = camera.getId();
+                List<String> customActions = new ArrayList<>(camera.getActions());
+                Iterator cIterator = customActions.iterator();
+                while (cIterator.hasNext()) {
+                    String actionString = (String) cIterator.next();
+                    if (actionString.contains("up")) {
+                        cIterator.remove();
+                    } else if (actionString.contains("right")) {
+                        cIterator.remove();
+                    } else if (actionString.contains("down")) {
+                        cIterator.remove();
+                    } else if (actionString.contains("left")) {
+                        cIterator.remove();
+                    }
+                }
+
+
+                adapter = new ActionsAdapter(this, customActions, this);
+                actions.setAdapter(adapter);
+                LinearLayoutManager layoutManager
+                        = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);
+                actions.setLayoutManager(layoutManager);
+                adapter.notifyDataSetChanged();
+                initControls(camera, joystick, this);
+                if (device.getDdnsURL().length() > 5) {
+                    if ((Utils.getNetworkType(FullCameraViewer.this)) == NETWORK_MOBILE) {
+                        serverurl = device.getDDNSUrlCombo();
+                    } else if (device.getWlan().networkId == Utils.getCurrentWifiNetworkId(FullCameraViewer.this)) {
+                        serverurl = device.getDeviceUrlCombo();
+
+                    } else {
+                        serverurl = device.getDDNSUrlCombo();
+
+                    }
+                } else {
+                    serverurl = device.getDeviceUrlCombo();
+
+                }
+                if (!serverurl.contains("://"))
+                    baseurl = Utils.removeSlash("http://" + serverurl);
+                else
+                    baseurl = Utils.removeSlash(serverurl);
+
+
+                int framerate = Integer.valueOf(camera.getFramerate());
+                cameraName.setText(camera.getName());
+
+                cameraImage.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        if ((topBar.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE) == View.VISIBLE) {
+                            topBar.setVisibility(topBar.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);
+                            Animation slide = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.slide_in_bar);
+                            Animation slide_bottom = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.slide_in_bottom_bar);
+
+                            topBar.startAnimation(slide);
+                            bottomBar.setVisibility(bottomBar.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);
+                            bottomBar.startAnimation(slide_bottom);
+
+                        } else {
+                            topBar.setVisibility(topBar.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);
+                            Animation slide = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.slide_out_bar);
+                            Animation slide_bottom = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.slide_out_bottom_bar);
+
+                            topBar.startAnimation(slide);
+                            bottomBar.setVisibility(bottomBar.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);
+                            bottomBar.startAnimation(slide_bottom);
+                        }
+                    }
+                });
+                time = new ArrayList<>();
+
+                Device finalDevice = device;
+                timerRunnable = new Runnable() {
+                    @Override
+                    public void run() {
+                        String serverurl;
+                        String cameraId = camera.getId();
+
+                        if (finalDevice.getDdnsURL().length() > 5) {
+                            if ((Utils.getNetworkType(FullCameraViewer.this)) == NETWORK_MOBILE) {
+                                serverurl = finalDevice.getDDNSUrlCombo();
+                            } else if (finalDevice.getWlan().networkId == Utils.getCurrentWifiNetworkId(FullCameraViewer.this)) {
+                                serverurl = finalDevice.getDeviceUrlCombo();
+
+                            } else {
+                                serverurl = finalDevice.getDDNSUrlCombo();
+
+                            }
+                        } else {
+                            serverurl = finalDevice.getDeviceUrlCombo();
+
+                        }
+                        String baseurl;
+                        if (!serverurl.contains("://"))
+                            baseurl = Utils.removeSlash("http://" + serverurl);
+                        else
+                            baseurl = Utils.removeSlash(serverurl);
+
+                        String url = baseurl + "/picture/" + cameraId + "/current?_=" + new Date().getTime();
+                        url = helper.addAuthParams("GET", url, "");
+                        String finalUrl = url;
+                        new DownloadImageFromInternet(cameraImage, loadingBar, fps, status, loadingCircle, camera, time, cameraFrame).execute(finalUrl);
+
+
+                    }
+                };
+                String url = baseurl + "/picture/" + cameraId + "/current?_=" + new Date().getTime();
+                url = helper.addAuthParams("GET", url, "");
+                finalUrl = url;
+                new DownloadImageFromInternet(cameraImage, loadingBar, fps, status, loadingCircle, camera, time, cameraFrame).execute(finalUrl);
+
+
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+
+        } else {
+            finish();
+        }
+
+
+        // Upon interacting with UI controls, delay any scheduled hide()
+        // operations to prevent the jarring behavior of controls going away
+        // while interacting with the UI.
+    }
+
+    @Override
+    public void onActionClicked(String action, View button) {
+
+        Log.e("FCV", "Action clicked");
+        try {
+            String url = baseurl + "/action/" + camera.getId() + "/" + action + "/?_=" + new Date().getTime();
+            MotionEyeHelper helper = new MotionEyeHelper();
+            helper.setUsername(device.getUser().getUsername());
+            helper.setPasswordHash(device.getUser().getPassword());
+            url = helper.addAuthParams("GET", url, "");
+            ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+            button.setEnabled(false);
+            apiInterface.peformAction(url).enqueue(new Callback<ActionStatus>() {
+                @Override
+                public void onResponse(Call<ActionStatus> call, Response<ActionStatus> response) {
+                    if (response.body() != null && response.body().getStatus() != 0)
+                        Toast.makeText(FullCameraViewer.this, getString(R.string.task_failed, String.valueOf(response.body().getStatus())), Toast.LENGTH_SHORT).show();
+
+                    button.setEnabled(true);
+
+                }
+
+                @Override
+                public void onFailure(Call<ActionStatus> call, Throwable t) {
+                    button.setEnabled(true);
+                    Toast.makeText(FullCameraViewer.this, t.getMessage(), Toast.LENGTH_LONG).show();
+                }
+            });
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+
+    }
+
+
+
+
+    private class DownloadImageFromInternet extends AsyncTask<String, Void, CameraImage> {
+        ImageView imageView;
+        LinearLayout progressBar;
+        TextView fps, status;
+        Camera camera;
+        ProgressBar loadingCircle;
+        RelativeLayout cameraFrame;
+        List<Long> time;
+
+        public DownloadImageFromInternet(ImageView imageView, LinearLayout progressBar, TextView fps, TextView status, ProgressBar loadingCircle, Camera camera, List<Long> time, RelativeLayout cameraFrame) {
+            this.imageView = imageView;
+            this.progressBar = progressBar;
+            this.fps = fps;
+            this.camera = camera;
+            this.status = status;
+            this.cameraFrame = cameraFrame;
+            this.loadingCircle = loadingCircle;
+            this.time = time;
+        }
+
+        protected void onPreExecute() {
+
+            status.setText(R.string.loading);
+            loadingCircle.setVisibility(View.VISIBLE);
+            if (!loaded) {
+                progressBar.setVisibility(View.VISIBLE);
+            }
+            ViewParent parent = status.getParent();
+            LinearLayout r;
+            if (parent != null)
+                if (parent instanceof ViewGroup) {
+                    ViewParent grandparent = ((ViewGroup) parent).getParent();
+                    if (grandparent != null) {
+                        if (parent instanceof LinearLayout) {
+                            r = (LinearLayout) grandparent;
+                            Button button = r.findViewById(R.id.tryagain);
+                            button.setVisibility(View.GONE);
+                            button.setOnClickListener(new View.OnClickListener() {
+                                @Override
+                                public void onClick(View v) {
+                                    timerRunnable.run();
+                                }
+                            });
+                        }
+
+                    }
+                }
+        }
+
+        protected CameraImage doInBackground(String... urls) {
+            String imageURL = urls[0];
+
+
+            try {
+                URL url = new URL(imageURL);
+                URLConnection connection = url.openConnection();
+                Map<String, List<String>> fps = connection.getHeaderFields();
+                String humanReadableFPS = "0";
+                InputStream in = url.openStream();
+                final Bitmap decoded = BitmapFactory.decodeStream(in);
+                in.close();
+                for (Map.Entry<String, List<String>> key : fps.entrySet()) {
+                    for (String string : key.getValue()) {
+                        if (string.contains("capture_fps")) {
+                            int ii = 0;
+
+                            double d = Double.parseDouble(string.split("capture_fps_" + camera.getId() + "=")[1].split(";")[0].trim());
+                            ii = (int) d;
+                            humanReadableFPS = String.valueOf(Math.round(ii));
+                            return new CameraImage(humanReadableFPS, decoded, true);
+
+                        }
+
+                    }
+                }
+
+
+            } catch (Exception e) {
+                Log.e("Error Message", e.getMessage());
+                e.printStackTrace();
+                return new CameraImage(false, e.getMessage());
+            }
+            return null;
+
+        }
+
+        protected void onPostExecute(CameraImage result) {
+            if (result.isSuccessful()) {
+
+                imageView.setVisibility(View.VISIBLE);
+                if (!loaded) {
+                    progressBar.animate()
+                            .translationY(progressBar.getHeight())
+                            .alpha(0.0f)
+                            .setDuration(300)
+                            .setListener(new AnimatorListenerAdapter() {
+                                @Override
+                                public void onAnimationEnd(Animator animation) {
+                                    super.onAnimationEnd(animation);
+                                    progressBar.setVisibility(View.GONE);
+                                    cameraFrame.setVisibility(View.VISIBLE);
+                                }
+                            });
+
+                    loaded = true;
+                }
+                imageView.setImageBitmap(result.getBitmap());
+
+                if (time.size() == Utils.fpsLen) {
+
+                    long streamingFps = time.size() * 1000 / (time.get(time.size()-1) - time.get(0));
+                    int fpsDeliv = Math.round(streamingFps);
+                    fps.setText(fpsDeliv + "/"+result.getFps()+" fps");
+
+                }
+
+                long timeNow = new Date().getTime();
+                time.add(timeNow);
+                if (time.size() > Utils.fpsLen) {
+                    time.remove(0);
+                }
+
+
+
+                if (attached) {
+                    timerHandler.postDelayed(timerRunnable, Utils.imageRefreshInterval); //Start timer after 1 sec
+
+                }
+
+
+
+            } else {
+                loaded = false;
+                loadingCircle.setVisibility(View.GONE);
+                imageView.setVisibility(View.GONE);
+                status.setVisibility(View.VISIBLE);
+                status.setText(result.getErrorString());
+                ViewParent parent = status.getParent();
+                LinearLayout r;
+                if (parent != null)
+                    if (parent instanceof ViewGroup) {
+                        ViewParent grandparent = ((ViewGroup) parent).getParent();
+                        if (grandparent != null) {
+                            if (parent instanceof LinearLayout) {
+                                r = (LinearLayout) grandparent;
+                                Button button = r.findViewById(R.id.tryagain);
+                                button.setVisibility(View.VISIBLE);
+                                button.setOnClickListener(new View.OnClickListener() {
+                                    @Override
+                                    public void onClick(View v) {
+                                        timerRunnable.run();
+                                    }
+                                });
+                            }
+
+                        }
+                    }
+            }
+
+        }
+
+
+    }
+
+
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        attached = true;
+        new DownloadImageFromInternet(cameraImage, loadingBar, fps, status, loadingCircle, camera, time, cameraFrame).execute(finalUrl);
+
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        attached = false;
+
+
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        attached = false;
+    }
+
+
+    private boolean isNetworkAvailable() {
+        ConnectivityManager connectivityManager
+                = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();
+        return activeNetworkInfo != null && activeNetworkInfo.isConnected();
+    }
+
+    public int getNetworkType(Context context) {
+        if (!isNetworkAvailable())
+            return -1;
+        ConnectivityManager conMan = (ConnectivityManager) context.
+                getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        //mobile
+        NetworkInfo.State mobile = conMan.getNetworkInfo(0).getState();
+        //wifi
+        NetworkInfo.State wifi = conMan.getNetworkInfo(1).getState();
+
+        int result = 0;
+
+        if (mobile == NetworkInfo.State.CONNECTED || mobile == NetworkInfo.State.CONNECTING) {
+            result |= NETWORK_MOBILE;
+        }
+
+        if (wifi == NetworkInfo.State.CONNECTED || wifi == NetworkInfo.State.CONNECTING) {
+            result |= NETWORK_WIFI;
+        }
+
+        return result;
+    }
+
+    public void initControls(Camera camera, LinearLayout dircontrols, ActionsAdapter.ActionsAdapterListener listener) {
+        ImageButton up = dircontrols.findViewById(R.id.up);
+        ImageButton down = dircontrols.findViewById(R.id.down);
+        ImageButton left = dircontrols.findViewById(R.id.left);
+        ImageButton right = dircontrols.findViewById(R.id.right);
+        View lrlayout = dircontrols.findViewById(R.id.lrlayout);
+        for (String actionString : camera.getActions()) {
+            if (actionString.contains("up")) {
+                dircontrols.setVisibility(View.VISIBLE);
+                up.setVisibility(View.VISIBLE);
+                up.setOnClickListener(v -> listener.onActionClicked("up", up));
+            } else if (actionString.contains("right")) {
+                dircontrols.setVisibility(View.VISIBLE);
+                right.setVisibility(View.VISIBLE);
+                right.setOnClickListener(v -> listener.onActionClicked("right", right));
+            } else if (actionString.contains("down")) {
+                dircontrols.setVisibility(View.VISIBLE);
+                down.setVisibility(View.VISIBLE);
+                down.setOnClickListener(v -> listener.onActionClicked("down", down));
+            } else if (actionString.contains("left")) {
+                dircontrols.setVisibility(View.VISIBLE);
+                left.setVisibility(View.VISIBLE);
+                left.setOnClickListener(v -> listener.onActionClicked("left", left));
+            }
+        }
+        if (left.getVisibility() == View.GONE && right.getVisibility() == View.GONE)
+            lrlayout.setVisibility(View.GONE);
+    }
+
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/MainActivity.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/MainActivity.java
new file mode 100644
index 0000000..de84f9a
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/MainActivity.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.activities;
+
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.design.widget.BottomNavigationView;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentTransaction;
+import android.support.v7.app.AppCompatActivity;
+import android.view.MenuItem;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.ui.fragments.DevicesFragment;
+import com.developerfromjokela.motioneyeclient.ui.fragments.RecordingsFragment;
+
+public class MainActivity extends AppCompatActivity implements DevicesFragment.startupExecListener {
+
+    private boolean startupExec = false;
+    private BottomNavigationView.OnNavigationItemSelectedListener mOnNavigationItemSelectedListener
+            = new BottomNavigationView.OnNavigationItemSelectedListener() {
+
+        @Override
+        public boolean onNavigationItemSelected(@NonNull MenuItem item) {
+            switch (item.getItemId()) {
+                case R.id.navigation_devices:
+                    Bundle a = new Bundle();
+                    a.putBoolean("startupExec", startupExec);
+                    DevicesFragment devicesFragment = new DevicesFragment();
+                    devicesFragment.setArguments(a);
+                    loadFragment(devicesFragment);
+                    return true;
+                case R.id.navigation_recordings:
+                    loadFragment(new RecordingsFragment());
+                    return true;
+            }
+            return false;
+        }
+    };
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_main);
+
+        BottomNavigationView navigation = findViewById(R.id.navigation);
+        navigation.setOnNavigationItemSelectedListener(mOnNavigationItemSelectedListener);
+        loadFragment(new DevicesFragment());
+        navigation.setSelectedItemId(R.id.navigation_devices);
+    }
+
+    private void loadFragment(Fragment fragment) {
+        final FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+        transaction.replace(R.id.fragmentLayout, fragment);
+        transaction.addToBackStack(null);
+        transaction.commit();
+    }
+
+
+    @Override
+    public void paramChanged(boolean newParam) {
+        startupExec = newParam;
+    }
+
+    @Override
+    public void onBackPressed() {
+        finish();
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/MovieView.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/MovieView.java
new file mode 100644
index 0000000..8131dbb
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/activities/MovieView.java
@@ -0,0 +1,96 @@
+package com.developerfromjokela.motioneyeclient.ui.activities;
+
+import android.content.Intent;
+import android.media.MediaPlayer;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.UserHandle;
+import android.support.design.widget.FloatingActionButton;
+import android.support.design.widget.Snackbar;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
+import android.util.Log;
+import android.view.View;
+import android.widget.MediaController;
+import android.widget.TextView;
+import android.widget.VideoView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.CameraUser;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.Media;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+import com.squareup.picasso.Picasso;
+
+import java.security.NoSuchAlgorithmException;
+import java.util.Date;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+import static com.developerfromjokela.motioneyeclient.other.Utils.removeSlash;
+
+public class MovieView extends AppCompatActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_movie_view);
+        Toolbar toolbar = findViewById(R.id.toolbar);
+        setSupportActionBar(toolbar);
+
+        toolbar.setNavigationIcon(R.drawable.ic_back);
+        toolbar.setNavigationOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                finish();
+            }
+        });
+        Intent intent = getIntent();
+        if (intent.getExtras() != null) {
+            String baseurl = intent.getStringExtra("baseurl");
+            CameraUser user = (CameraUser) intent.getSerializableExtra("user");
+
+            Camera camera = (Camera) intent.getSerializableExtra("camera");
+            Media media = (Media) intent.getSerializableExtra("media");
+
+            setTitle(media.getPath().split("/")[media.getPath().split("/").length-1]);
+            try {
+                String url = baseurl + "/movie/"+camera.getId()+"/playback"+media.getPath()+"?_=" + new Date().getTime();
+                MotionEyeHelper helper = new MotionEyeHelper();
+                helper.setUsername(user.getUsername());
+                helper.setPasswordHash(user.getPassword());
+                url = helper.addAuthParams("GET", url, "");
+                Log.e("RA", url);
+                VideoView videoView = findViewById(R.id.videoView);
+                TextView loadText = findViewById(R.id.videoLoadText);
+                videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
+                    @Override
+                    public void onPrepared(MediaPlayer mp) {
+                        Log.e("MovView", "Load done!");
+                        findViewById(R.id.loadingLayout).setVisibility(View.GONE);
+                    }
+                });
+                MediaController mc = new MediaController(this);
+                mc.show(500);
+                mc.setAnchorView(videoView);
+                mc.setMediaPlayer(videoView);
+                Uri video = Uri.parse(url);
+                videoView.setMediaController(mc);
+
+                videoView.getBufferPercentage();
+                videoView.setVideoURI(video);
+                videoView.requestFocus();
+                videoView.start();
+
+            } catch (NoSuchAlgorithmException e) {
+                e.printStackTrace();
+            }
+
+        } else
+            finish();
+
+    }
+
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/ActionsAdapter.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/ActionsAdapter.java
new file mode 100644
index 0000000..ba9f79d
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/ActionsAdapter.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.adapters;
+
+import android.content.Context;
+import android.support.v7.widget.AppCompatImageView;
+import android.support.v7.widget.CardView;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+
+import java.util.List;
+
+public class ActionsAdapter extends RecyclerView.Adapter<ActionsAdapter.ActionsViewHolder> {
+
+    private Context mContext;
+    private List<String> actionsList;
+    private ActionsAdapterListener listener;
+
+    public class ActionsViewHolder extends RecyclerView.ViewHolder {
+
+        TextView number;
+        CardView action;
+        AppCompatImageView icon;
+
+        ActionsViewHolder(View itemView) {
+            super(itemView);
+            number = itemView.findViewById(R.id.number);
+            action = itemView.findViewById(R.id.action);
+            icon = itemView.findViewById(R.id.actionicon);
+        }
+    }
+
+    public ActionsAdapter(Context mContext, List<String> actionsList, ActionsAdapterListener listener) {
+        this.mContext = mContext;
+        this.listener = listener;
+
+
+        this.actionsList = actionsList;
+    }
+
+    @Override
+    public ActionsViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        View mView = LayoutInflater.from(parent.getContext()).inflate(R.layout.action, parent, false);
+        return new ActionsViewHolder(mView);
+    }
+
+    @Override
+    public void onBindViewHolder(final ActionsAdapter.ActionsViewHolder holder, final int position) {
+        String actionString = actionsList.get(position);
+        if (actionString.contains("preset")) {
+            holder.icon.setVisibility(View.GONE);
+            holder.number.setText(actionString.split("preset")[1]);
+            holder.number.setVisibility(View.VISIBLE);
+        } else if (actionString.contains("lock")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_lock);
+        } else if (actionString.contains("unlock")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_unlock);
+        } else if (actionString.contains("light_on")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_light_on);
+        } else if (actionString.contains("light_off")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_light_off);
+        } else if (actionString.contains("alarm_on")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_alarm_on);
+        } else if (actionString.contains("alarm_off")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_alarm_off);
+        } else if (actionString.contains("up")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_up);
+        } else if (actionString.contains("right")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_right);
+        } else if (actionString.contains("down")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_down);
+        } else if (actionString.contains("left")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_back);
+        } else if (actionString.contains("zoom_in")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_zoom_in);
+        } else if (actionString.contains("zoom_out")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_zoom_out);
+        } else if (actionString.contains("snapshot")) {
+            holder.number.setVisibility(View.GONE);
+            holder.icon.setVisibility(View.VISIBLE);
+            holder.icon.setImageResource(R.drawable.ic_snapshot);
+        }
+
+
+        holder.action.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                Log.e("AA", "Action clicked");
+                listener.onActionClicked(actionString, v);
+            }
+        });
+
+    }
+
+    public interface ActionsAdapterListener {
+
+        void onActionClicked(String action, View button);
+    }
+
+    @Override
+    public int getItemCount() {
+        return actionsList.size();
+    }
+}
\ No newline at end of file
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/DevicesAdapter.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/DevicesAdapter.java
new file mode 100644
index 0000000..95ecc73
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/DevicesAdapter.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.adapters;
+
+import android.content.Context;
+import android.support.v7.widget.CardView;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.ContextMenu;
+import android.view.LayoutInflater;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.PopupMenu;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+
+import java.util.List;
+
+public class DevicesAdapter extends RecyclerView.Adapter<DevicesAdapter.DevicesViewHolder> {
+
+    private Context mContext;
+    private List<Device> deviceList;
+    private DevicesAdapterListener listener;
+
+    public class DevicesViewHolder extends RecyclerView.ViewHolder {
+
+        TextView deviceName, deviceURL, cameras;
+        CardView itemCard;
+
+        DevicesViewHolder(View itemView) {
+            super(itemView);
+            deviceName = itemView.findViewById(R.id.deviceName);
+            cameras = itemView.findViewById(R.id.camerasCount);
+            deviceURL = itemView.findViewById(R.id.deviceURL);
+            itemCard = itemView.findViewById(R.id.itemCard);
+
+        }
+
+    }
+
+
+
+    public DevicesAdapter(Context mContext, List<Device> deviceList, DevicesAdapterListener listener) {
+        this.mContext = mContext;
+        this.listener = listener;
+
+
+        this.deviceList = deviceList;
+    }
+
+    @Override
+    public DevicesViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        View mView = LayoutInflater.from(parent.getContext()).inflate(R.layout.device, parent, false);
+        return new DevicesViewHolder(mView);
+    }
+
+    @Override
+    public void onBindViewHolder(final DevicesAdapter.DevicesViewHolder holder, final int position) {
+        final Device device = deviceList.get(position);
+        holder.deviceName.setText(device.getDeviceName());
+        if (device.getDdnsURL().length() > 5)
+            holder.deviceURL.setText(device.getDeviceUrl() + " (" + mContext.getString(R.string.ddns_available) + ")");
+        else
+            holder.deviceURL.setText(device.getDeviceUrl());
+        String suffix = mContext.getString(R.string.cameras_count_morethan1);
+        if (device.getCamera().size() == 1)
+            suffix = "";
+        holder.cameras.setText(mContext.getString(R.string.cameras_count, String.valueOf(device.getCamera().size()), suffix));
+        holder.itemCard.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                listener.onDeviceClicked(position, device);
+            }
+        });
+
+        holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {
+            @Override
+            public boolean onLongClick(View v) {
+                Log.e("DA", "Longclick");
+                PopupMenu popup = new PopupMenu(mContext, holder.itemView);
+                //inflating menu from xml resource
+                popup.inflate(R.menu.device_menu);
+                //adding click listener
+                popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
+                    @Override
+                    public boolean onMenuItemClick(MenuItem item) {
+
+                        return false;
+                    }
+                });
+                //displaying the popup
+                popup.show();
+                return false;
+            }
+        });
+
+    }
+
+    public interface DevicesAdapterListener {
+
+        void onDeviceClicked(int position, Device device);
+        void onDeviceDeleteRequest(int position, Device device);
+    }
+
+    @Override
+    public int getItemCount() {
+        return deviceList.size();
+    }
+
+
+
+}
\ No newline at end of file
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/HttpCamerasAdapter.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/HttpCamerasAdapter.java
new file mode 100644
index 0000000..8de2c6b
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/HttpCamerasAdapter.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.adapters;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.AsyncTask;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.v7.widget.CardView;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.Button;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.CameraImage;
+import com.developerfromjokela.motioneyeclient.classes.CameraImageFrame;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+
+public class HttpCamerasAdapter extends RecyclerView.Adapter<HttpCamerasAdapter.CamerasViewHolder> {
+
+    private CamerasAdapterListener listener;
+    private List<CameraImageFrame> cameraImageFrames;
+
+
+
+    public class CamerasViewHolder extends RecyclerView.ViewHolder {
+
+        ImageView cameraImage;
+        LinearLayout loadingBar;
+        TextView fps, status;
+        ProgressBar progressBar;
+        Button tryagain;
+        CardView itemCard;
+        boolean attached;
+
+        CamerasViewHolder(View itemView) {
+            super(itemView);
+
+            cameraImage = itemView.findViewById(R.id.cameraImage);
+            loadingBar = itemView.findViewById(R.id.cameraBar);
+            itemCard = itemView.findViewById(R.id.itemCard);
+            fps = itemView.findViewById(R.id.fps);
+            status = itemView.findViewById(R.id.status);
+            progressBar = itemView.findViewById(R.id.progressar);
+            tryagain = itemView.findViewById(R.id.tryagain);
+            attached = false;
+        }
+
+
+    }
+
+    public HttpCamerasAdapter(CamerasAdapterListener listener, List<CameraImageFrame> cameraImageFrames) {
+        this.listener = listener;
+        this.cameraImageFrames = cameraImageFrames;
+    }
+
+    @Override
+    public void onViewDetachedFromWindow(@NonNull CamerasViewHolder holder) {
+        holder.attached = false;
+    }
+
+    @Override
+    public void onViewAttachedToWindow(@NonNull CamerasViewHolder holder) {
+        holder.attached = true;
+    }
+
+    @Override
+    public CamerasViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        View mView = LayoutInflater.from(parent.getContext()).inflate(R.layout.camera, parent, false);
+        return new CamerasViewHolder(mView);
+    }
+
+    @Override
+    public void onBindViewHolder(final HttpCamerasAdapter.CamerasViewHolder holder, int position) {
+        final CameraImageFrame camera = cameraImageFrames.get(position);
+
+        if (camera.getError() != null) {
+            holder.cameraImage.setVisibility(View.GONE);
+            holder.fps.setVisibility(View.GONE);
+            holder.loadingBar.setVisibility(View.VISIBLE);
+            holder.progressBar.setVisibility(View.GONE);
+            holder.tryagain.setVisibility(camera.getError().isDisplayRetry() ? View.VISIBLE : View.GONE);
+            holder.status.setText(camera.getError().getErrorCause());
+
+
+        } else {
+            if (camera.getBitmap() != null && camera.isInitialLoadDone()) {
+                holder.loadingBar.setVisibility(View.GONE);
+                holder.cameraImage.setVisibility(View.VISIBLE);
+                holder.fps.setVisibility(View.VISIBLE);
+                holder.cameraImage.setImageBitmap(camera.getBitmap());
+                holder.fps.setText(camera.getFrameRateText());
+            } else {
+                holder.cameraImage.setVisibility(View.GONE);
+                holder.fps.setVisibility(View.GONE);
+                holder.loadingBar.setVisibility(View.VISIBLE);
+                holder.progressBar.setVisibility(View.VISIBLE);
+                holder.status.setText(R.string.loading);
+            }
+        }
+
+
+        holder.tryagain.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                listener.onRefreshRequest(position, camera);
+            }
+        });
+
+        holder.itemView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                listener.onImageClick(position, camera);
+            }
+        });
+
+
+    }
+
+    public interface CamerasAdapterListener {
+
+        void onImageClick(int position, CameraImageFrame cameraImageFrame);
+
+        void onRefreshRequest(int position, CameraImageFrame cameraImageFrame);
+    }
+
+    @Override
+    public int getItemCount() {
+        return cameraImageFrames.size();
+    }
+
+
+
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/MediaDeviceAdapter.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/MediaDeviceAdapter.java
new file mode 100644
index 0000000..80daf97
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/MediaDeviceAdapter.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.adapters;
+
+import android.content.Context;
+import android.support.v7.widget.CardView;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.PopupMenu;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.RecordingDevice;
+
+import java.util.List;
+
+public class MediaDeviceAdapter extends RecyclerView.Adapter<MediaDeviceAdapter.DevicesViewHolder> {
+
+    private Context mContext;
+    private List<RecordingDevice> deviceList;
+    private DevicesAdapterListener listener;
+
+    public class DevicesViewHolder extends RecyclerView.ViewHolder {
+
+        TextView deviceName, deviceURL, cameras;
+        CardView itemCard;
+
+        DevicesViewHolder(View itemView) {
+            super(itemView);
+            deviceName = itemView.findViewById(R.id.deviceName);
+            cameras = itemView.findViewById(R.id.camerasCount);
+            deviceURL = itemView.findViewById(R.id.deviceURL);
+            itemCard = itemView.findViewById(R.id.itemCard);
+
+        }
+
+    }
+
+
+
+    public MediaDeviceAdapter(Context mContext, List<RecordingDevice> deviceList, DevicesAdapterListener listener) {
+        this.mContext = mContext;
+        this.listener = listener;
+
+
+        this.deviceList = deviceList;
+    }
+
+    @Override
+    public DevicesViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        View mView = LayoutInflater.from(parent.getContext()).inflate(R.layout.device, parent, false);
+        return new DevicesViewHolder(mView);
+    }
+
+    @Override
+    public void onBindViewHolder(final MediaDeviceAdapter.DevicesViewHolder holder, final int position) {
+        final RecordingDevice device = deviceList.get(position);
+        holder.deviceName.setText(device.getCamera().getName());
+        holder.deviceURL.setText(device.getDevice().getDeviceName());
+        if (device.getDevice().getDdnsURL().length() > 5)
+            holder.cameras.setText(device.getDevice().getDeviceUrl() + " (" + mContext.getString(R.string.ddns_available) + ")");
+        else
+            holder.cameras.setText(device.getDevice().getDeviceUrl());
+        holder.itemCard.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                listener.onDeviceClicked(position, device);
+            }
+        });
+
+
+    }
+
+    public interface DevicesAdapterListener {
+
+        void onDeviceClicked(int position, RecordingDevice device);
+    }
+
+    @Override
+    public int getItemCount() {
+        return deviceList.size();
+    }
+
+
+
+}
\ No newline at end of file
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/RecordingsAdapter.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/RecordingsAdapter.java
new file mode 100644
index 0000000..436c94a
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/RecordingsAdapter.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.adapters;
+
+import android.content.Context;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.Media;
+import com.developerfromjokela.motioneyeclient.classes.RecordingDevice;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+import com.squareup.picasso.Picasso;
+
+import java.security.NoSuchAlgorithmException;
+import java.util.Date;
+import java.util.List;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+import static com.developerfromjokela.motioneyeclient.other.Utils.removeSlash;
+
+public class RecordingsAdapter extends RecyclerView.Adapter<RecordingsAdapter.DevicesViewHolder> {
+
+    private Context mContext;
+    private List<Media> mediaList;
+    private MediaAdapterListener listener;
+    private RecordingDevice device;
+
+    public class DevicesViewHolder extends RecyclerView.ViewHolder {
+
+        TextView mediaName, itemSize, itemDate;
+        ImageView preview;
+
+        DevicesViewHolder(View itemView) {
+            super(itemView);
+            mediaName = itemView.findViewById(R.id.mediaName);
+            itemSize = itemView.findViewById(R.id.itemSize);
+            itemDate = itemView.findViewById(R.id.itemDate);
+            preview = itemView.findViewById(R.id.preview);
+
+        }
+
+    }
+
+
+
+    public RecordingsAdapter(Context mContext, List<Media> mediaList, MediaAdapterListener listener, RecordingDevice device) {
+        this.mContext = mContext;
+        this.listener = listener;
+        this.device = device;
+        this.mediaList = mediaList;
+    }
+
+    @Override
+    public DevicesViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        View mView = LayoutInflater.from(parent.getContext()).inflate(R.layout.media, parent, false);
+        return new DevicesViewHolder(mView);
+    }
+
+    @Override
+    public void onBindViewHolder(final RecordingsAdapter.DevicesViewHolder holder, final int position) {
+        final Media media = mediaList.get(position);
+        holder.mediaName.setText(media.getPath().split("/")[media.getPath().split("/").length-1]);
+        holder.itemDate.setText(media.getShortMonent());
+        holder.itemSize.setText(media.getSize());
+        String baseurl;
+        String serverurl;
+        if (device.getDevice().getDdnsURL().length() > 5) {
+            if ((Utils.getNetworkType(mContext)) == NETWORK_MOBILE) {
+                serverurl = device.getDevice().getDDNSUrlCombo();
+            } else if (device.getDevice().getWlan().networkId == Utils.getCurrentWifiNetworkId(mContext)) {
+                serverurl = device.getDevice().getDeviceUrlCombo();
+
+            } else {
+                serverurl = device.getDevice().getDDNSUrlCombo();
+
+            }
+        } else {
+            serverurl = device.getDevice().getDeviceUrlCombo();
+
+        }
+        Log.e("Setup", String.valueOf(serverurl.split("//").length));
+        if (!serverurl.contains("://"))
+            baseurl = removeSlash("http://" + serverurl);
+        else
+            baseurl = removeSlash(serverurl);
+
+        try {
+            String url = baseurl + "/movie/"+device.getCamera().getId()+"/preview"+media.getPath()+"?_=" + new Date().getTime();
+            MotionEyeHelper helper = new MotionEyeHelper();
+            helper.setUsername(device.getDevice().getUser().getUsername());
+            helper.setPasswordHash(device.getDevice().getUser().getPassword());
+            url = helper.addAuthParams("GET", url, "");
+            Log.e("RA", url);
+
+            Picasso.get().load(url).into(holder.preview);
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+
+        holder.itemView.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                listener.onMediaClicked(position, media);
+            }
+        });
+
+
+    }
+
+    public interface MediaAdapterListener {
+
+        void onMediaClicked(int position, Media media);
+    }
+
+    @Override
+    public int getItemCount() {
+        return mediaList.size();
+    }
+
+
+    public void updateDetails(RecordingDevice device) {
+        this.device = device;
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/WifisAdapter.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/WifisAdapter.java
new file mode 100644
index 0000000..c2ca908
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/adapters/WifisAdapter.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.adapters;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.Color;
+import android.support.annotation.NonNull;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.classes.WifiNetwork;
+
+import java.util.List;
+
+public class WifisAdapter extends ArrayAdapter {
+
+
+    private List<WifiNetwork> networks;
+
+    public WifisAdapter(@NonNull Context context, int resource, int textViewResourceId, @NonNull List<WifiNetwork> objects) {
+        super(context, resource, textViewResourceId, objects);
+        networks = objects;
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        @SuppressLint("ViewHolder") final View view = View.inflate(getContext(), android.R.layout.simple_list_item_1, null);
+
+        if (networks.get(position).isSelected()) {
+            // set your color
+            view.setBackgroundColor(Color.parseColor("#1d7031"));
+
+        }
+
+        TextView textView = view.findViewById(android.R.id.text1);
+        if (networks.get(position).getConfiguration().status == 0)
+            textView.setText(networks.get(position).getConfiguration().SSID + " (" + getContext().getString(R.string.connected) + ")");
+        else
+            textView.setText(networks.get(position).getConfiguration().SSID);
+
+        return view;
+    }
+
+
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/fragments/DevicesFragment.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/fragments/DevicesFragment.java
new file mode 100644
index 0000000..97b64c7
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/fragments/DevicesFragment.java
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.fragments;
+
+
+import android.app.Fragment;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.Nullable;
+import android.support.design.widget.FloatingActionButton;
+import android.support.v7.app.AlertDialog;
+import android.support.v7.preference.PreferenceManager;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.view.ContextMenu;
+import android.view.LayoutInflater;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.LinearLayout;
+import android.widget.Toast;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.database.Source;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+import com.developerfromjokela.motioneyeclient.ui.activities.CameraViewer;
+import com.developerfromjokela.motioneyeclient.ui.adapters.DevicesAdapter;
+import com.developerfromjokela.motioneyeclient.ui.setup.activities.SetupStartScreen;
+import com.developerfromjokela.motioneyeclient.ui.utils.DevicesView;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A simple {@link Fragment} subclass.
+ */
+public class DevicesFragment extends android.support.v4.app.Fragment implements DevicesAdapter.DevicesAdapterListener {
+
+    private DevicesView camerasRecyclerView;
+    private DevicesAdapter adapter;
+    private Source database;
+    private FloatingActionButton addCamera;
+    private LinearLayout emptyView;
+    private List<Device> deviceList = new ArrayList<>();
+    private boolean startupExec = false;
+    private startupExecListener startupExecListener;
+
+    public DevicesFragment() {
+        // Required empty public constructor
+    }
+
+    @Override
+    public void setArguments(@Nullable Bundle args) {
+        super.setArguments(args);
+        if (args != null) {
+            if (args.containsKey("startupExec"))
+                startupExec = args.getBoolean("startupExec");
+        }
+
+
+    }
+
+
+    @Override
+    public void onAttach(Context context) {
+        super.onAttach(context);
+        if (context instanceof startupExecListener)
+            startupExecListener = (startupExecListener) context;
+        else
+            throw new RuntimeException("Listener not found! Can't continue");
+    }
+
+    public interface startupExecListener {
+        void paramChanged(boolean newParam);
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        // Inflate the layout for this fragment
+        return inflater.inflate(R.layout.fragment_cameras, container, false);
+    }
+
+    @Override
+    public void onViewCreated(View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        setupViews(view);
+    }
+
+    @Override
+    public void onDeviceClicked(int position, Device device) {
+       startViewer(device);
+    }
+
+    private void startViewer(Device device) {
+        Intent viewer = new Intent(getActivity(), CameraViewer.class);
+        viewer.putExtra("DeviceId", device.getID());
+        startActivity(viewer);
+    }
+
+    @Override
+    public void onDeviceDeleteRequest(int position, Device device) {
+        deleteDevice(device);
+    }
+
+    private void setListeners() {
+        adapter.registerAdapterDataObserver(new RecyclerView.AdapterDataObserver() {
+
+            @Override
+            public void onChanged() {
+                super.onChanged();
+                checkEmpty();
+            }
+
+            @Override
+            public void onItemRangeInserted(int positionStart, int itemCount) {
+                super.onItemRangeInserted(positionStart, itemCount);
+                checkEmpty();
+            }
+
+            @Override
+            public void onItemRangeRemoved(int positionStart, int itemCount) {
+                super.onItemRangeRemoved(positionStart, itemCount);
+                checkEmpty();
+            }
+
+
+        });
+        addCamera.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                getActivity().startActivity(new Intent(getActivity(), SetupStartScreen.class));
+            }
+        });
+
+    }
+
+    @Override
+    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
+        super.onCreateContextMenu(menu, v, menuInfo);
+
+        // Inflate Menu from xml resource
+        MenuInflater menuInflater = getActivity().getMenuInflater();
+        menuInflater.inflate(R.menu.device_menu, menu);
+    }
+
+    @Override
+    public boolean onContextItemSelected(MenuItem item) {
+
+        switch (item.getItemId()) {
+            case R.id.deleteDevice:
+                DevicesView.RecyclerContextMenuInfo info = (DevicesView.RecyclerContextMenuInfo) item.getMenuInfo();
+                deleteDevice(deviceList.get(info.position));
+                break;
+        }
+
+        return false;
+    }
+
+    private void deleteDevice(Device device) {
+        AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(getActivity());
+        dialogBuilder.setTitle(R.string.delete_camera);
+        dialogBuilder.setMessage(R.string.delete_camera_caution);
+        dialogBuilder.setNegativeButton(R.string.cancel, null);
+        dialogBuilder.setPositiveButton(R.string.delete_camera, new DialogInterface.OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                Source source = new Source(getContext());
+                try {
+                    source.delete_item(device);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                    Toast.makeText(getActivity(), getString(R.string.failed_device_delete, e.getMessage()), Toast.LENGTH_SHORT).show();
+                }
+            }
+        });
+        AlertDialog alertDialog = dialogBuilder.create();
+        alertDialog.show();
+    }
+
+    private void loadFromDatabase() {
+        try {
+            deviceList.clear();
+            deviceList.addAll(database.getAll());
+            for (Device device : deviceList) {
+                adapter.notifyItemInserted(deviceList.indexOf(device));
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        checkEmpty();
+        String autoOpenID = PreferenceManager.getDefaultSharedPreferences(getContext()).getString("autoOpenID", null);
+        if (autoOpenID !=  null && !startupExec) {
+            startupExec = true;
+            startupExecListener.paramChanged(startupExec);
+            for (Device device : deviceList) {
+                if (device.getID().equals(autoOpenID))
+                    startViewer(device);
+
+            }
+        }
+
+    }
+
+    private void setupViews(View view) {
+        emptyView = view.findViewById(R.id.emptyView);
+        addCamera = view.findViewById(R.id.addItem);
+        camerasRecyclerView = view.findViewById(R.id.camerasRecyclerView);
+        camerasRecyclerView.setLayoutManager(new GridLayoutManager(getActivity(), 1));
+        camerasRecyclerView.addItemDecoration(new Utils.GridSpacingItemDecoration(1, Utils.dpToPx(getActivity()), true));
+
+    }
+
+    private void initializeObjects() {
+        adapter = new DevicesAdapter(getActivity(), deviceList, this);
+        camerasRecyclerView.setAdapter(adapter);
+        database = new Source(getActivity());
+    }
+
+    private void checkEmpty() {
+        emptyView.setVisibility(adapter.getItemCount() > 0 ? View.VISIBLE : View.GONE);
+
+        emptyView.setVisibility(adapter.getItemCount() == 0 ? View.VISIBLE : View.GONE);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        initializeObjects();
+        setListeners();
+        loadFromDatabase();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        startupExecListener = null;
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/fragments/RecordingsFragment.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/fragments/RecordingsFragment.java
new file mode 100644
index 0000000..1614834
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/fragments/RecordingsFragment.java
@@ -0,0 +1,243 @@
+package com.developerfromjokela.motioneyeclient.ui.fragments;
+
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.design.widget.BottomSheetBehavior;
+import android.support.v4.app.Fragment;
+import android.support.v7.widget.GridLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.ApiInterface;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.api.ServiceGenerator;
+import com.developerfromjokela.motioneyeclient.classes.Camera;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.Media;
+import com.developerfromjokela.motioneyeclient.classes.MediaList;
+import com.developerfromjokela.motioneyeclient.classes.RecordingDevice;
+import com.developerfromjokela.motioneyeclient.database.Source;
+import com.developerfromjokela.motioneyeclient.other.Utils;
+import com.developerfromjokela.motioneyeclient.ui.activities.MovieView;
+import com.developerfromjokela.motioneyeclient.ui.adapters.DevicesAdapter;
+import com.developerfromjokela.motioneyeclient.ui.adapters.MediaDeviceAdapter;
+import com.developerfromjokela.motioneyeclient.ui.adapters.RecordingsAdapter;
+import com.google.gson.Gson;
+
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.List;
+
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+import static android.app.DownloadManager.Request.NETWORK_MOBILE;
+import static com.developerfromjokela.motioneyeclient.other.Utils.removeSlash;
+
+
+/**
+ * A simple {@link Fragment} subclass.
+ */
+public class RecordingsFragment extends Fragment implements MediaDeviceAdapter.DevicesAdapterListener, RecordingsAdapter.MediaAdapterListener {
+
+    private BottomSheetBehavior sheetBehavior;
+    private LinearLayout bottom_sheet;
+    private RecyclerView devicesView;
+    private MediaDeviceAdapter adapter;
+    private Source source;
+    private List<RecordingDevice> devices = new ArrayList<>();
+    private RecyclerView recordings;
+    private RecordingDevice selectedDevice;
+    private String TAG = this.getClass().getSimpleName();
+    private List<Media> mediaList = new ArrayList<>();
+
+    private ProgressBar recordingsProgress;
+
+    private RecordingsAdapter recordingsAdapter;
+    public RecordingsFragment() {
+        // Required empty public constructor
+    }
+
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        // Inflate the layout for this fragment
+        return inflater.inflate(R.layout.fragment_recordings, container, false);
+    }
+
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        bottom_sheet = view.findViewById(R.id.bottom_sheet);
+        sheetBehavior = BottomSheetBehavior.from(bottom_sheet);// click event for show-dismiss bottom sheet
+        sheetBehavior.setState(BottomSheetBehavior.STATE_COLLAPSED);
+        devicesView = view.findViewById(R.id.devices);
+        adapter = new MediaDeviceAdapter(getContext(), devices, this);
+        source = new Source(getContext());
+        recordingsProgress = view.findViewById(R.id.recordingsProgress);
+        try {
+            for (Device device : source.getAll()) {
+                for (Camera camera : device.getCameras()) {
+                    devices.add(new RecordingDevice(device, camera));
+                }
+            }
+
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        devicesView.setAdapter(adapter);
+        devicesView.setLayoutManager(new GridLayoutManager(getActivity(), 1));
+        devicesView.addItemDecoration(new Utils.GridSpacingItemDecoration(1, Utils.dpToPx(getActivity()), true));
+        adapter.notifyDataSetChanged();
+        recordingsAdapter = new RecordingsAdapter(getContext(), mediaList, this, selectedDevice);
+
+        recordings = view.findViewById(R.id.recordings);
+
+        recordings.setAdapter(recordingsAdapter);
+        recordings.setLayoutManager(new GridLayoutManager(getActivity(), 1));
+        recordings.addItemDecoration(new Utils.GridSpacingItemDecoration(1, Utils.dpToPx(getActivity()), true));
+
+
+        if (!devices.isEmpty()) {
+            selectedDevice = devices.get(0);
+            loadRecordings();
+        } else {
+            View view1 = view.findViewById(R.id.emptyView);
+            view1.setVisibility(View.VISIBLE);
+            devicesView.setVisibility(View.GONE);
+            recordings.setVisibility(View.GONE);
+            view.findViewById(R.id.bottom_sheet);
+
+        }
+
+    }
+
+    private void displayProgress() {
+        recordingsProgress.setVisibility(View.VISIBLE);
+    }
+
+    private void hideProgress() {
+        recordingsProgress.setVisibility(View.INVISIBLE);
+    }
+
+
+    private void loadRecordings() {
+        displayProgress();
+        try {
+            String baseurl;
+            String serverurl;
+            if (selectedDevice.getDevice().getDdnsURL().length() > 5) {
+                if ((Utils.getNetworkType(getContext())) == NETWORK_MOBILE) {
+                    serverurl = selectedDevice.getDevice().getDDNSUrlCombo();
+                } else if (selectedDevice.getDevice().getWlan().networkId == Utils.getCurrentWifiNetworkId(getContext())) {
+                    serverurl = selectedDevice.getDevice().getDeviceUrlCombo();
+
+                } else {
+                    serverurl = selectedDevice.getDevice().getDDNSUrlCombo();
+
+                }
+            } else {
+                serverurl = selectedDevice.getDevice().getDeviceUrlCombo();
+
+            }
+            Log.e("Setup", String.valueOf(serverurl.split("//").length));
+            if (!serverurl.contains("://"))
+                baseurl = removeSlash("http://" + serverurl);
+            else
+                baseurl = removeSlash(serverurl);
+            String url = baseurl + "/movie/"+selectedDevice.getCamera().getId()+"/list?_=" + new Date().getTime();
+            MotionEyeHelper helper = new MotionEyeHelper();
+            helper.setUsername(selectedDevice.getDevice().getUser().getUsername());
+
+            helper.setPasswordHash(selectedDevice.getDevice().getUser().getPassword());
+
+            url = helper.addAuthParams("GET", url, "");
+            ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+
+            apiInterface.getMedia(url).enqueue(new Callback<MediaList>() {
+                @Override
+                public void onResponse(Call<MediaList> call, Response<MediaList> response) {
+                    hideProgress();
+                    MediaList mediaListObj = response.body();
+                    mediaList.clear();
+                    recordingsAdapter.notifyDataSetChanged();
+                    recordingsAdapter.updateDetails(selectedDevice);
+                    Collections.sort(mediaListObj.getMedia(), new Comparator<Media>() {
+                        @Override
+                        public int compare(Media o1, Media o2) {
+                            return (int)o2.getTimestamp()-(int)o1.getTimestamp();
+                        }
+                    });
+                    for (Media media : mediaListObj.getMedia()) {
+                        mediaList.add(media);
+                        recordingsAdapter.notifyItemInserted(mediaList.size()-1);
+                    }
+                }
+
+                @Override
+                public void onFailure(Call<MediaList> call, Throwable t) {
+                    hideProgress();
+                    t.printStackTrace();
+                    t.fillInStackTrace();
+                }
+            });
+        } catch (NoSuchAlgorithmException e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void onMediaClicked(int position, Media media) {
+        String baseurl;
+        String serverurl;
+        if (selectedDevice.getDevice().getDdnsURL().length() > 5) {
+            if ((Utils.getNetworkType(getContext())) == NETWORK_MOBILE) {
+                serverurl = selectedDevice.getDevice().getDDNSUrlCombo();
+            } else if (selectedDevice.getDevice().getWlan().networkId == Utils.getCurrentWifiNetworkId(getContext())) {
+                serverurl = selectedDevice.getDevice().getDeviceUrlCombo();
+
+            } else {
+                serverurl = selectedDevice.getDevice().getDDNSUrlCombo();
+
+            }
+        } else {
+            serverurl = selectedDevice.getDevice().getDeviceUrlCombo();
+
+        }
+        Log.e("Setup", String.valueOf(serverurl.split("//").length));
+        if (!serverurl.contains("://"))
+            baseurl = removeSlash("http://" + serverurl);
+        else
+            baseurl = removeSlash(serverurl);
+        Intent playbackIntent = new Intent(getContext(), MovieView.class);
+        playbackIntent.putExtra("baseurl", baseurl);
+        playbackIntent.putExtra("user", selectedDevice.getDevice().getUser());
+
+        playbackIntent.putExtra("camera", selectedDevice.getCamera());
+        playbackIntent.putExtra("media", media);
+        startActivity(playbackIntent);
+    }
+
+    @Override
+    public void onDeviceClicked(int position, RecordingDevice device) {
+        selectedDevice = device;
+        loadRecordings();
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/setup/activities/SetupStartScreen.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/setup/activities/SetupStartScreen.java
new file mode 100644
index 0000000..3c46bfd
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/setup/activities/SetupStartScreen.java
@@ -0,0 +1,1038 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient.ui.setup.activities;
+
+import android.Manifest;
+import android.content.pm.PackageManager;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiManager;
+import android.os.Bundle;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+import android.support.v4.app.ActivityCompat;
+import android.support.v4.content.ContextCompat;
+import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.CardView;
+import android.text.Editable;
+import android.text.TextWatcher;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.Animation;
+import android.view.animation.AnimationSet;
+import android.view.animation.AnimationUtils;
+import android.view.animation.TranslateAnimation;
+import android.webkit.URLUtil;
+import android.widget.AdapterView;
+import android.widget.Button;
+import android.widget.EditText;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.ProgressBar;
+import android.widget.TextView;
+
+import com.developerfromjokela.motioneyeclient.R;
+import com.developerfromjokela.motioneyeclient.api.ApiInterface;
+import com.developerfromjokela.motioneyeclient.api.MotionEyeHelper;
+import com.developerfromjokela.motioneyeclient.api.ServiceGenerator;
+import com.developerfromjokela.motioneyeclient.classes.CameraUser;
+import com.developerfromjokela.motioneyeclient.classes.Cameras;
+import com.developerfromjokela.motioneyeclient.classes.Device;
+import com.developerfromjokela.motioneyeclient.classes.WifiNetwork;
+import com.developerfromjokela.motioneyeclient.database.Source;
+import com.developerfromjokela.motioneyeclient.ui.adapters.WifisAdapter;
+
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.select.Elements;
+
+import java.io.IOException;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.List;
+
+import okhttp3.ResponseBody;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+
+public class SetupStartScreen extends AppCompatActivity {
+
+    int currentView = 0;
+    private Button continue_btn;
+    private Button previous;
+    private final int[] views = {R.layout.setup_main_screen, R.layout.setup_device_network, R.layout.setup_device_credentials, R.layout.setup_device_wifi, R.layout.setup_device_validate, R.layout.setup_device_finish};
+    private Device.Builder device;
+    private View.OnClickListener previousListener;
+    private View.OnClickListener continueListener;
+    private int locPermissionRequest = 54454;
+
+    private View currentViewObject;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_setup_screen_template);
+        continue_btn = findViewById(R.id.continue_btn);
+        previous = findViewById(R.id.back_btn);
+        device = new Device.Builder();
+        previousListener = new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (views.length > currentView) {
+                    currentView = currentView - 1;
+
+                    setCurrentViewToViewStub(currentView);
+                    if (currentView == 0)
+                        previous.setEnabled(false);
+                    else
+                        previous.setEnabled(true);
+                    if (currentView == views.length - 1)
+                        continue_btn.setEnabled(false);
+                    else
+                        continue_btn.setEnabled(true);
+                } else {
+                    previous.setEnabled(false);
+                }
+            }
+        };
+        continueListener = new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (currentView < views.length) {
+                    currentView = currentView + 1;
+                    setCurrentViewToViewStub(currentView);
+                    if (currentView == views.length - 1)
+                        continue_btn.setEnabled(false);
+                    else
+                        continue_btn.setEnabled(true);
+                    previous.setEnabled(true);
+                } else {
+                    continue_btn.setEnabled(false);
+                }
+            }
+        };
+
+        initializeViewStub();
+
+
+    }
+
+    private void initializeViewStub() {
+        final LinearLayout ll = findViewById(R.id.ll);
+
+        final View inflated = LayoutInflater.from(SetupStartScreen.this).inflate(views[0], ll, false);
+        ll.addView(inflated);
+        Animation animation = AnimationUtils.loadAnimation(getBaseContext(), R.anim.slide_right_in);
+        animation.setStartOffset(0);
+        inflated.startAnimation(animation);
+        previous.setEnabled(false);
+        setListenersForSetupItems(inflated, 0);
+
+    }
+
+    private View setCurrentViewToViewStub(final int view) {
+
+        final LinearLayout ll = findViewById(R.id.ll);
+        final View[] inflated = {null};
+
+
+        final View viewToDelete = ll.getChildAt(0);
+        AlphaAnimation fadeOut = new AlphaAnimation(1f, 0f);
+        fadeOut.setDuration(300);
+        fadeOut.setFillAfter(true);
+//Create move up animation
+        TranslateAnimation moveUp = new TranslateAnimation(0, 0, 0, -viewToDelete.getHeight() / 6);
+        moveUp.setDuration(300);
+        moveUp.setFillAfter(true);
+//Merge both animations into an animation set
+        AnimationSet animations = new AnimationSet(false);
+        animations.addAnimation(fadeOut);
+        animations.addAnimation(moveUp);
+        animations.setDuration(200);
+        animations.setAnimationListener(new Animation.AnimationListener() {
+            @Override
+            public void onAnimationStart(Animation animation) {
+            }
+
+            @Override
+            public void onAnimationEnd(Animation animation) {
+                //Hide the view after the animation is done to prevent it to show before it is removed from the parent view
+                viewToDelete.setVisibility(View.GONE);
+                //Create handler on the current thread (UI thread)
+                Handler h = new Handler();
+                //Run a runnable after 100ms (after that time it is safe to remove the view)
+                h.postDelayed(new Runnable() {
+                    @Override
+                    public void run() {
+                        ll.removeView(viewToDelete);
+                        inflated[0] = LayoutInflater.from(SetupStartScreen.this).inflate(views[view], ll, false);
+                        ll.addView(inflated[0]);
+                        Animation animation = AnimationUtils.loadAnimation(getBaseContext(), R.anim.slide_right_in);
+                        animation.setStartOffset(0);
+                        animation.setAnimationListener(new Animation.AnimationListener() {
+                            @Override
+                            public void onAnimationStart(Animation animation) {
+
+                            }
+
+                            @Override
+                            public void onAnimationEnd(Animation animation) {
+                                setListenersForSetupItems(inflated[0], currentView);
+                            }
+
+                            @Override
+                            public void onAnimationRepeat(Animation animation) {
+
+                            }
+                        });
+                        inflated[0].startAnimation(animation);
+                        fillItems(inflated[0], currentView);
+                        currentViewObject = inflated[0];
+
+
+                    }
+                }, 100);
+            }
+
+            @Override
+            public void onAnimationRepeat(Animation animation) {
+            }
+        });
+        viewToDelete.startAnimation(animations);
+        //Create fade out animation
+
+        return inflated[0];
+
+
+    }
+
+    private void fillItems(View view, final int position) {
+        if (currentView == 1) {
+            continue_btn.setEnabled(false);
+
+            final EditText local_hostname = view.findViewById(R.id.local_hostname);
+            final EditText ddns_hostname = view.findViewById(R.id.ddns_hostname);
+            final EditText ddns_port = view.findViewById(R.id.ddns_port);
+            final EditText local_port = view.findViewById(R.id.local_port);
+            local_hostname.setText(device.getDeviceUrl());
+            ddns_hostname.setText(device.getDdnsURL());
+            ddns_port.setText(device.getDDNSPort());
+            local_port.setText(device.getPort());
+            if (validIP(device.getDeviceUrl())) {
+
+
+                continue_btn.setEnabled(true);
+            } else {
+
+                continue_btn.setEnabled(false);
+            }
+            if (!device.getDdnsURL().contains("//") && device.getDdnsURL().length() > 7) {
+                ddns_hostname.setText("http://" + device.getDdnsURL());
+            }
+
+        } else if (currentView == 2) {
+            final EditText username = view.findViewById(R.id.login);
+            final EditText password = view.findViewById(R.id.password);
+            if (device.getUser() != null) {
+                username.setText(device.getUser().getUsername());
+                password.setText(device.getUser().getPassword());
+                if (!device.getUser().getUsername().isEmpty()) {
+                    continue_btn.setEnabled(true);
+                } else
+                    continue_btn.setEnabled(false);
+            } else {
+                continue_btn.setEnabled(false);
+            }
+
+        } else if (currentView == 3) {
+            continue_btn.setEnabled(false);
+            final ListView wifiNetwork = view.findViewById(R.id.wifiNetwork);
+
+            if(ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)!= PackageManager.PERMISSION_GRANTED) {
+                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, locPermissionRequest);
+                wifiNetwork.setVisibility(View.GONE);
+                CardView noLocationLayout = view.findViewById(R.id.permissionWarning);
+                noLocationLayout.setVisibility(View.VISIBLE);
+            } else {
+                initWifiPicker(wifiNetwork);
+            }
+
+        } else if (currentView == 4) {
+            continue_btn.setEnabled(false);
+
+        } else if (currentView == 5) {
+            try {
+                Source source = new Source(SetupStartScreen.this);
+                source.createEntry(device.build());
+            } catch (Exception e) {
+                e.printStackTrace();
+                Log.e("Setup", "CurrentView 5 " + e.getMessage());
+            }
+            previous.setEnabled(false);
+            continue_btn.setEnabled(true);
+            continue_btn.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    finish();
+                }
+            });
+            continue_btn.setText(R.string.wizard_finish);
+            TextView successtext = view.findViewById(R.id.successtext);
+            successtext.setText(getString(R.string.wizard_completed, device.getDeviceName()));
+        }
+    }
+
+    private void initWifiPicker(ListView wifiNetwork) {
+        WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(WIFI_SERVICE);
+        int netId = -1;
+        final List<WifiNetwork> SSIDCONFIGS = new ArrayList<>();
+
+
+        for (WifiConfiguration tmp : wifiManager.getConfiguredNetworks()) {
+            SSIDCONFIGS.add(new WifiNetwork(tmp, false));
+
+            Log.e("Setup", "Wifi " + tmp.SSID + ": " + tmp.status + " & " + tmp.networkId);
+        }
+
+        final int[] itemPosition = {-1};
+
+        if (device.getWlan() != null) {
+            Log.e("Setup", String.valueOf(device.getWlan().networkId));
+
+
+            for (int i = 0; i < wifiManager.getConfiguredNetworks().size(); i++) {
+                WifiConfiguration tmp = wifiManager.getConfiguredNetworks().get(i);
+                Log.e("Setup", String.valueOf(tmp.networkId));
+
+                if (tmp.networkId == device.getWlan().networkId) {
+                    SSIDCONFIGS.get(i).setSelected(true);
+                    itemPosition[0] = i;
+                    continue_btn.setEnabled(true);
+                }
+            }
+        } else {
+            continue_btn.setEnabled(false);
+
+        }
+
+        Collections.sort(SSIDCONFIGS, new Comparator<WifiNetwork>() {
+            @Override
+            public int compare(WifiNetwork o1, WifiNetwork o2) {
+                return o1.getConfiguration().SSID.compareTo(o2.getConfiguration().SSID);
+            }
+        });
+
+        WifisAdapter adapter = new WifisAdapter(this,
+                android.R.layout.simple_list_item_1, android.R.id.text1, SSIDCONFIGS);
+
+        continue_btn.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                device.setWlan(SSIDCONFIGS.get(itemPosition[0]).getConfiguration());
+                continueListener.onClick(v);
+            }
+        });
+        // Assign adapter to ListView
+        wifiNetwork.setAdapter(adapter);
+        TextView textView = new TextView(this);
+        textView.setText(R.string.no_wifi_networks_saved);
+        wifiNetwork.setEmptyView(textView);
+        // ListView Item Click Listener
+        wifiNetwork.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view,
+                                    int position, long id) {
+                // ListView Clicked item index
+                if (itemPosition[0] != -1) {
+                    SSIDCONFIGS.get(itemPosition[0]).setSelected(false);
+                }
+                itemPosition[0] = position;
+
+                SSIDCONFIGS.get(position).setSelected(true);
+
+                adapter.notifyDataSetChanged();
+
+                device.setWlan(SSIDCONFIGS.get(itemPosition[0]).getConfiguration());
+                // Show Alert
+
+                continue_btn.setEnabled(true);
+            }
+        });
+    }
+
+
+    private void setListenersForSetupItems(View view, final int position) {
+
+        Log.e("Setup", String.valueOf(position));
+        Log.e("Setup", String.valueOf(currentView));
+
+        if (currentView == 0) {
+            continue_btn.setOnClickListener(continueListener);
+            previous.setOnClickListener(previousListener);
+        } else if (currentView == 1) {
+
+            final EditText local_hostname = view.findViewById(R.id.local_hostname);
+            final EditText ddns_hostname = view.findViewById(R.id.ddns_hostname);
+            final EditText ddns_port = view.findViewById(R.id.ddns_port);
+            final EditText local_port = view.findViewById(R.id.local_port);
+            continue_btn.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    device.setDeviceUrl(local_hostname.getText().toString());
+                    device.setLocalPort(local_port.getText().toString());
+                    device.setDdnsURL(ddns_hostname.getText().toString());
+                    device.setDDNSPort(ddns_port.getText().toString());
+                    continueListener.onClick(v);
+                }
+            });
+            local_hostname.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    String url = s.toString();
+                    if (validIP(url)) {
+                        device.setDeviceUrl(url);
+
+                        Log.e("SetupStartScreen", "Valid IP");
+
+                        continue_btn.setEnabled(true);
+                    } else {
+                        Log.e("SetupStartScreen", "Invalid IP");
+
+                        continue_btn.setEnabled(false);
+                    }
+                    if (url.contains(":")) {
+                        final String[] portparts = url.split(":");
+                        if (portparts.length == 2) {
+                            device.setDeviceUrl(portparts[0]);
+                            local_port.setText(portparts[portparts.length - 1]);
+                            new Handler().postDelayed(new Runnable() {
+                                @Override
+                                public void run() {
+                                    local_hostname.setText(portparts[0]);
+                                    local_hostname.setSelection(local_hostname.getText().length());
+
+                                    Log.e("Setup", "Set Local Port " + portparts[1]);
+                                }
+                            }, 1000);
+                        }
+                        if (validIP(portparts[0])) {
+                            device.setDeviceUrl(url);
+
+                            Log.e("SetupStartScreen", "Valid IP");
+
+                            continue_btn.setEnabled(true);
+                        } else {
+                            Log.e("SetupStartScreen", "Invalid IP");
+
+                            continue_btn.setEnabled(false);
+                        }
+
+                    }
+                }
+            });
+            ddns_hostname.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    String url = s.toString();
+                    if (!isValidURL(url) && url.length() > 2) {
+
+                        if (isValidURL("http://" + url)) {
+                            device.setDdnsURL("http://" + url);
+                            continue_btn.setEnabled(true);
+
+                        } else {
+                            continue_btn.setEnabled(false);
+
+                        }
+
+                    } else {
+                        device.setDdnsURL(url);
+                        continue_btn.setEnabled(true);
+                    }
+                    if (url.contains(":")) {
+                        final String[] portparts = url.split(":");
+                        if (portparts.length == 3) {
+                            device.setDdnsURL(url);
+
+                            ddns_port.setText(portparts[portparts.length - 1]);
+
+                            device.setDdnsURL(portparts[0]);
+
+                            new Handler().postDelayed(new Runnable() {
+                                @Override
+                                public void run() {
+                                    ddns_hostname.setText(portparts[0]);
+                                    ddns_hostname.setSelection(ddns_hostname.getText().length());
+
+                                }
+                            }, 900);
+                        }
+
+                    }
+                }
+            });
+            ddns_port.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    if (ddns_hostname.getText().toString().split(":").length > 2) {
+                        String url_noports = ddns_hostname.getText().toString().split(":")[0] + ddns_hostname.getText().toString().split(":")[1];
+                        device.setDdnsURL(url_noports + ":" + s.toString());
+                    } else if (ddns_hostname.getText().toString().split(":").length > 1) {
+                        device.setDdnsURL(ddns_hostname.getText().toString() + ":" + s.toString());
+
+                    }
+                    device.setDDNSPort(s.toString());
+
+                }
+            });
+            local_port.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    device.setLocalPort(s.toString());
+
+                }
+            });
+        } else if (currentView == 2) {
+            final EditText username = view.findViewById(R.id.login);
+            final EditText password = view.findViewById(R.id.password);
+            continue_btn.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    device.setUser(new CameraUser(username.getText().toString(), password.getText().toString()));
+                    continueListener.onClick(v);
+                }
+            });
+            username.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    device.setUser(new CameraUser(s.toString(), password.getText().toString()));
+                    if (s.length() > 0)
+                        continue_btn.setEnabled(true);
+                    else
+                        continue_btn.setEnabled(false);
+                }
+            });
+            password.addTextChangedListener(new TextWatcher() {
+                @Override
+                public void beforeTextChanged(CharSequence s, int start, int count, int after) {
+
+                }
+
+                @Override
+                public void onTextChanged(CharSequence s, int start, int before, int count) {
+
+                }
+
+                @Override
+                public void afterTextChanged(Editable s) {
+                    device.setUser(new CameraUser(username.getText().toString(), s.toString()));
+                }
+            });
+        } else if (currentView == 3) {
+            Button requestLocation = view.findViewById(R.id.loc_request);
+            requestLocation.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    ActivityCompat.requestPermissions(SetupStartScreen.this, new String[]{Manifest.permission.ACCESS_FINE_LOCATION}, locPermissionRequest);
+                }
+            });
+        } else if (currentView == 4) {
+            // Result Textview
+            TextView Errorstatus = view.findViewById(R.id.errorDetails);
+            // Root Layouts
+            LinearLayout rootLayout2 = view.findViewById(R.id.ddns_connection_test);
+            // Progressbars
+            ProgressBar progressBar1 = view.findViewById(R.id.progress1);
+            ProgressBar progressBar2 = view.findViewById(R.id.progress2);
+            ProgressBar progressBar3 = view.findViewById(R.id.progress3);
+            ProgressBar progressBar4 = view.findViewById(R.id.progress4);
+
+            // Icons
+            ImageView status1 = view.findViewById(R.id.statusimage1);
+            ImageView status2 = view.findViewById(R.id.statusimage2);
+            ImageView status3 = view.findViewById(R.id.statusimage3);
+            ImageView status4 = view.findViewById(R.id.statusimage4);
+
+
+            if (device.getDdnsURL().length() > 0) {
+                rootLayout2.setVisibility(View.VISIBLE);
+            }
+
+
+            validateServer(new TestInterface() {
+                @Override
+                public void TestSuccessful(String response, int status) {
+                    progressBar1.setVisibility(View.GONE);
+                    status1.setVisibility(View.VISIBLE);
+                    status1.setImageResource(R.drawable.ic_check_green);
+                    status2.setVisibility(View.GONE);
+                    progressBar2.setVisibility(View.VISIBLE);
+                    if (device.getDdnsURL().length() > 0) {
+                        validateServer(new TestInterface() {
+                            @Override
+                            public void TestSuccessful(String response, int status) {
+                                progressBar2.setVisibility(View.GONE);
+                                status2.setVisibility(View.VISIBLE);
+                                status2.setImageResource(R.drawable.ic_check_green);
+                                try {
+                                    checkLogin(device.getDeviceUrlCombo(), new TestInterface() {
+                                        @Override
+                                        public void TestSuccessful(String response, int status) {
+                                            progressBar3.setVisibility(View.GONE);
+                                            status3.setVisibility(View.VISIBLE);
+                                            status3.setImageResource(R.drawable.ic_check_green);
+                                            status4.setVisibility(View.GONE);
+                                            progressBar4.setVisibility(View.VISIBLE);
+                                            getServerDetails(new TestInterface() {
+                                                @Override
+                                                public void TestSuccessful(String response, int status) {
+                                                    continue_btn.setEnabled(true);
+                                                    status4.setVisibility(View.VISIBLE);
+                                                    progressBar4.setVisibility(View.GONE);
+                                                    status4.setImageResource(R.drawable.ic_check_green);
+
+                                                }
+
+                                                @Override
+                                                public void TestFailed(String response, int status) {
+                                                    continue_btn.setEnabled(false);
+
+                                                    status4.setVisibility(View.VISIBLE);
+                                                    progressBar4.setVisibility(View.GONE);
+                                                    status4.setImageResource(R.drawable.ic_error_red);
+                                                    Errorstatus.setVisibility(View.VISIBLE);
+                                                    Errorstatus.setText(response);
+                                                }
+                                            }, device.getDeviceUrlCombo());
+                                        }
+
+                                        @Override
+                                        public void TestFailed(String response, int status) {
+                                            continue_btn.setEnabled(false);
+                                            progressBar3.setVisibility(View.GONE);
+                                            status3.setVisibility(View.VISIBLE);
+                                            status3.setImageResource(R.drawable.ic_error_red);
+                                            Errorstatus.setVisibility(View.VISIBLE);
+                                            Errorstatus.setText(response);
+                                        }
+                                    });
+                                } catch (NoSuchAlgorithmException e) {
+                                    e.printStackTrace();
+                                    progressBar3.setVisibility(View.GONE);
+                                    status3.setVisibility(View.VISIBLE);
+                                    status3.setImageResource(R.drawable.ic_error_red);
+                                    Errorstatus.setVisibility(View.VISIBLE);
+                                    Errorstatus.setText(e.getMessage());
+                                }
+                            }
+
+                            @Override
+                            public void TestFailed(String response, int status) {
+                                progressBar2.setVisibility(View.GONE);
+                                status2.setVisibility(View.VISIBLE);
+                                status2.setImageResource(R.drawable.ic_error_red);
+                                Errorstatus.setVisibility(View.VISIBLE);
+                                Errorstatus.setText(response);
+                            }
+                        }, device.getDDNSUrlCombo());
+                    } else {
+
+                        try {
+                            checkLogin(device.getDeviceUrlCombo(), new TestInterface() {
+                                @Override
+                                public void TestSuccessful(String response, int status) {
+                                    continue_btn.setEnabled(true);
+                                    progressBar3.setVisibility(View.GONE);
+                                    status3.setVisibility(View.VISIBLE);
+                                    status3.setImageResource(R.drawable.ic_check_green);
+                                    status4.setVisibility(View.GONE);
+                                    progressBar4.setVisibility(View.VISIBLE);
+                                    getServerDetails(new TestInterface() {
+                                        @Override
+                                        public void TestSuccessful(String response, int status) {
+                                            continue_btn.setEnabled(true);
+
+                                            status4.setVisibility(View.VISIBLE);
+                                            progressBar4.setVisibility(View.GONE);
+                                            status4.setImageResource(R.drawable.ic_check_green);
+
+                                        }
+
+                                        @Override
+                                        public void TestFailed(String response, int status) {
+                                            continue_btn.setEnabled(false);
+
+                                            status4.setVisibility(View.VISIBLE);
+                                            progressBar4.setVisibility(View.GONE);
+                                            status4.setImageResource(R.drawable.ic_error_red);
+                                            Errorstatus.setVisibility(View.VISIBLE);
+                                            Errorstatus.setText(response);
+                                        }
+                                    }, device.getDeviceUrlCombo());
+                                }
+
+                                @Override
+                                public void TestFailed(String response, int status) {
+                                    continue_btn.setEnabled(false);
+                                    progressBar3.setVisibility(View.GONE);
+                                    status3.setVisibility(View.VISIBLE);
+                                    status3.setImageResource(R.drawable.ic_error_red);
+                                    Errorstatus.setVisibility(View.VISIBLE);
+                                    Errorstatus.setText(response);
+                                }
+                            });
+                        } catch (NoSuchAlgorithmException e) {
+                            e.printStackTrace();
+                            progressBar3.setVisibility(View.GONE);
+                            status3.setVisibility(View.VISIBLE);
+                            status3.setImageResource(R.drawable.ic_error_red);
+                            Errorstatus.setVisibility(View.VISIBLE);
+                            Errorstatus.setText(e.getMessage());
+                        }
+                    }
+
+                }
+
+                @Override
+                public void TestFailed(String response, int status2) {
+                    progressBar1.setVisibility(View.GONE);
+                    status1.setVisibility(View.VISIBLE);
+                    status1.setImageResource(R.drawable.ic_error_red);
+                    Errorstatus.setVisibility(View.VISIBLE);
+                    Errorstatus.setText(response);
+                }
+            }, device.getDeviceUrlCombo());
+
+        }
+
+    }
+
+    public static boolean validIP(String ip) {
+        try {
+            if (ip == null || ip.isEmpty()) {
+                return false;
+            }
+
+            String[] parts = ip.split("\\.");
+            if (parts.length != 4) {
+                return false;
+            }
+
+            for (String s : parts) {
+                int i = Integer.parseInt(s);
+                if ((i < 0) || (i > 255)) {
+                    return false;
+                }
+            }
+            return !ip.endsWith(".");
+        } catch (NumberFormatException nfe) {
+            return false;
+        }
+    }
+
+    private void validateServer(TestInterface testInterface, String serverurl) {
+        Log.e("Setup", serverurl);
+        String baseurl;
+
+        Log.e("Setup", String.valueOf(serverurl.split("//").length));
+        if (!serverurl.contains("://"))
+            baseurl = removeSlash("http://" + serverurl);
+        else
+            baseurl = removeSlash(serverurl);
+
+        Log.e("Setup", baseurl);
+        ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+        Call<ResponseBody> call = apiInterface.login(baseurl + "/login", device.getUser().getUsername(), device.getUser().getPassword(), "login");
+        Log.e("Setup", baseurl);
+        call.enqueue(new Callback<ResponseBody>() {
+
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                if (response.headers().get("Server").toLowerCase().contains("motioneye")) {
+                    Log.e("Setup", call.request().body().contentType().toString());
+                    try {
+                        testInterface.TestSuccessful(response.body().string(), response.code());
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                        testInterface.TestFailed(e.getMessage(), 700);
+
+                    }
+
+
+                } else {
+                    testInterface.TestFailed(getString(R.string.wizard_not_motioneye), 404);
+
+                }
+
+
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                t.printStackTrace();
+                t.fillInStackTrace();
+                testInterface.TestFailed(t.getMessage(), 700);
+
+            }
+        });
+    }
+
+    private void getServerDetails(TestInterface testInterface, String serverurl) {
+        Log.e("Setup", serverurl);
+        String baseurl;
+
+        Log.e("Setup", String.valueOf(serverurl.split("//").length));
+        if (!serverurl.contains("://"))
+            baseurl = removeSlash("http://" + serverurl);
+        else
+            baseurl = removeSlash(serverurl);
+
+        Log.e("Setup", baseurl);
+        ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+        Call<ResponseBody> call = apiInterface.getMotionDetails(baseurl + "/version");
+        Log.e("Setup", baseurl);
+        call.enqueue(new Callback<ResponseBody>() {
+
+            @Override
+            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
+                if (response.headers().get("Server").toLowerCase().contains("motioneye")) {
+                    try {
+                        final String stringResponse = response.body().string();
+                        Document html = Jsoup.parse(stringResponse);
+                        Elements elements = html.select("body");
+                        String[] lines = elements.html().replace("\"", "").replace("\n", "").split("<br>");
+                        for (String string : lines) {
+                            String[] paramParts = string.split("=");
+                            String paramName = paramParts[0].trim();
+                            String paramValue = paramParts[1];
+                            if (paramName.contains("hostname"))
+                                device.setDeviceName(paramValue);
+                            else if (paramName.contains("motion_version"))
+                                device.setMotionVersion(paramValue);
+                            else if (paramName.contains("os_version"))
+                                device.setOsVersion(paramValue);
+                            else if (paramName.equals("version"))
+                                device.setMotioneyeVersion(paramValue);
+
+                        }
+                        String url = baseurl + "/config/list?_=" + new Date().getTime();
+                        MotionEyeHelper helper = new MotionEyeHelper();
+                        helper.setUsername(device.getUser().getUsername());
+                        helper.setPasswordHash(device.getUser().getPassword());
+                        url = helper.addAuthParams("GET", url, "");
+
+                        Call<Cameras> call2 = apiInterface.getCameras(url);
+                        call2.enqueue(new Callback<Cameras>() {
+                            @Override
+                            public void onResponse(Call<Cameras> call, Response<Cameras> response) {
+                                Cameras cameras = response.body();
+                                device.setCameras(cameras.getCameras());
+                                Log.e("Setup", cameras.getCameras().size() + " cameras found");
+                                testInterface.TestSuccessful(stringResponse, response.code());
+
+                            }
+
+                            @Override
+                            public void onFailure(Call<Cameras> call, Throwable t) {
+                                t.printStackTrace();
+                                t.fillInStackTrace();
+                                testInterface.TestFailed(t.getMessage(), 700);
+                            }
+                        });
+
+
+                    } catch (IOException e) {
+                        e.printStackTrace();
+                        testInterface.TestFailed(e.getMessage(), 700);
+
+                    } catch (NoSuchAlgorithmException e) {
+                        e.printStackTrace();
+                        testInterface.TestFailed(e.getMessage(), 700);
+
+                    }
+
+
+                } else {
+                    testInterface.TestFailed(getString(R.string.wizard_not_motioneye), 404);
+
+                }
+
+
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                t.printStackTrace();
+                t.fillInStackTrace();
+                testInterface.TestFailed(t.getMessage(), 700);
+
+            }
+        });
+    }
+
+    public static boolean isValidURL(String url) {
+        return URLUtil.isValidUrl(url);
+    }
+
+    private interface TestInterface {
+        void TestSuccessful(String response, int status);
+
+        void TestFailed(String response, int status);
+
+    }
+
+    private void checkLogin(String serverurl, TestInterface testInterface) throws NoSuchAlgorithmException {
+        String baseurl;
+        if (!serverurl.contains("://"))
+            baseurl = removeSlash("http://" + serverurl);
+        else
+            baseurl = removeSlash(serverurl);
+        ApiInterface apiInterface = ServiceGenerator.createService(ApiInterface.class, baseurl);
+
+        MotionEyeHelper helper = new MotionEyeHelper();
+        helper.setUsername(device.getUser().getUsername());
+        helper.setPasswordHash(device.getUser().getPassword());
+        String url = baseurl;
+
+        url += "/login?_=" + new Date().getTime();
+        helper.setLoggedIn(true);
+        url = helper.addAuthParams("GET", url, "");
+        Call<okhttp3.ResponseBody> checkLoginCall = apiInterface.loginResult(url);
+        checkLoginCall.enqueue(new Callback<okhttp3.ResponseBody>() {
+            @Override
+            public void onResponse(Call<okhttp3.ResponseBody> call2, Response<okhttp3.ResponseBody> response2) {
+                if (!response2.isSuccessful()) {
+                    try (ResponseBody responseBody2 = response2.errorBody()) {
+                        final String responseString = responseBody2.string();
+                        if (response2.code() == 403)
+                            testInterface.TestFailed(getString(R.string.wizard_wrong_credentials), response2.code());
+                        else
+                            testInterface.TestFailed(responseString, response2.code());
+
+
+                    } catch (Exception e) {
+                        e.fillInStackTrace();
+                        e.printStackTrace();
+                        testInterface.TestFailed(e.getMessage(), 700);
+                    }
+                } else {
+                    try (ResponseBody responseBody2 = response2.body()) {
+                        final String stringResponse2 = responseBody2.string();
+                        testInterface.TestSuccessful(stringResponse2, response2.code());
+
+
+                    } catch (Exception e) {
+                        e.fillInStackTrace();
+                        e.printStackTrace();
+                        testInterface.TestFailed(e.getMessage(), 700);
+                    }
+                }
+
+            }
+
+            @Override
+            public void onFailure(Call<ResponseBody> call, Throwable t) {
+                t.fillInStackTrace();
+
+                t.printStackTrace();
+                testInterface.TestFailed(t.getMessage(), 700);
+
+            }
+        });
+    }
+
+    private static String removeSlash(String url) {
+        if (!url.endsWith("/"))
+            return url;
+        String[] parts = url.split("/");
+
+        return parts[0];
+    }
+
+    @Override
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
+        if (requestCode == locPermissionRequest) {
+            if (grantResults.length > 0
+                    && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+
+                if (currentView == 3) {
+                    currentViewObject.findViewById(R.id.permissionWarning).setVisibility(View.GONE);
+                    currentViewObject.findViewById(R.id.wifiNetwork).setVisibility(View.VISIBLE);
+                    initWifiPicker(currentViewObject.findViewById(R.id.wifiNetwork));
+                }
+            }
+        }
+    }
+}
diff --git a/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/utils/DevicesView.java b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/utils/DevicesView.java
new file mode 100644
index 0000000..c2d2b2d
--- /dev/null
+++ b/app/src/src/main/java/com/developerfromjokela/motioneyeclient/ui/utils/DevicesView.java
@@ -0,0 +1,54 @@
+package com.developerfromjokela.motioneyeclient.ui.utils;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v7.widget.RecyclerView;
+import android.util.AttributeSet;
+import android.view.ContextMenu;
+import android.view.View;
+
+public class DevicesView extends RecyclerView {
+
+    private RecyclerContextMenuInfo mContextMenuInfo;
+
+    public DevicesView(@NonNull Context context) {
+        super(context);
+    }
+
+    public DevicesView(@NonNull Context context, @Nullable AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public DevicesView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    @Override
+    protected ContextMenu.ContextMenuInfo getContextMenuInfo() {
+        return mContextMenuInfo;
+    }
+
+    @Override
+    public boolean showContextMenuForChild(View originalView) {
+        final int longPressPosition = getChildAdapterPosition(originalView);
+        if (longPressPosition >= 0) {
+            final long longPressId = getAdapter().getItemId(longPressPosition);
+            mContextMenuInfo = new RecyclerContextMenuInfo(longPressPosition, longPressId);
+            return super.showContextMenuForChild(originalView);
+        }
+        return false;
+    }
+
+    public static class RecyclerContextMenuInfo implements ContextMenu.ContextMenuInfo {
+
+        public RecyclerContextMenuInfo(int position, long id) {
+            this.position = position;
+            this.id = id;
+        }
+
+        final public int position;
+        final public long id;
+    }
+
+}
diff --git a/app/src/src/test/java/com/developerfromjokela/motioneyeclient/ExampleUnitTest.java b/app/src/src/test/java/com/developerfromjokela/motioneyeclient/ExampleUnitTest.java
new file mode 100644
index 0000000..a1e5b75
--- /dev/null
+++ b/app/src/src/test/java/com/developerfromjokela/motioneyeclient/ExampleUnitTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2019. MotionEye Client by Developer From Jokela, All Rights Reserved.
+ * Licenced with MIT:
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
+ *  and associated documentation files (the "Software"), to deal in the Software without restriction,including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ *    SOFTWARE.
+ */
+
+package com.developerfromjokela.motioneyeclient;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
