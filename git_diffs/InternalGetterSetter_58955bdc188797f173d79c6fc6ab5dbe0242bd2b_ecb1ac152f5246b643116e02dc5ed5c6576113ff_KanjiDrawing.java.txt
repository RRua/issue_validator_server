diff --git a/src/com/leafdigital/kanji/DotsComparer.java b/src/com/leafdigital/kanji/DotsComparer.java
new file mode 100644
index 0000000..6a47c73
--- /dev/null
+++ b/src/com/leafdigital/kanji/DotsComparer.java
@@ -0,0 +1,228 @@
+/*
+This file is part of leafdigital kanjirecog.
+
+kanjirecog is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+kanjirecog is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with kanjirecog.  If not, see <http://www.gnu.org/licenses/>.
+
+Copyright 2011 Samuel Marshall.
+*/
+package com.leafdigital.kanji;
+
+/**
+ * Compares entered strokes with other kanji based on the number of points
+ * (start or end) in different areas of the kanji.
+ * This comparer is very fast, but works very poorly; not suitable for any use.
+ */
+public class DotsComparer implements KanjiComparer
+{
+	final static int NUM_RANGES = 5;
+
+	private int[] countsX, countsY;
+
+	/**
+	 * Initialises with given drawn kanji.
+	 * @param info Drawn kanji
+	 */
+	@Override
+	public void init(KanjiInfo info)
+	{
+		countsX = new int[NUM_RANGES];
+		countsY = new int[NUM_RANGES];
+		fillCounts(countsX, countsY, info);
+	}
+
+	/**
+	 * Compares against the given other kanji.
+	 * @param other Other kanji
+	 * @return Score in range 0 to 100
+	 */
+	@Override
+	public float getMatchScore(KanjiInfo other)
+	{
+		// Get counts for other kanji
+		int[] otherX, otherY;
+		otherX = new int[NUM_RANGES];
+		otherY = new int[NUM_RANGES];
+		fillCounts(otherX, otherY, other);
+
+		// Compare the two count arrays and use that as score
+		float score = 0f;
+		score +=  compareArrays(countsX, otherX, false);
+		score += compareArrays(countsY, otherY, false);
+
+		score = score * 100f / 2f;
+		return score;
+	}
+
+	/**
+	 * Calculates start and end position counts.
+	 * @param countsX X counts array
+	 * @param countsY Y counts array
+	 * @param info Kanji
+	 */
+	static void fillCounts(int[] countsX, int[] countsY, KanjiInfo info)
+	{
+		for(int i=0; i<info.getStrokeCount(); i++)
+		{
+			Stroke s = info.getStroke(i);
+			countsX[(s.getStartX() * NUM_RANGES) >> 8]++;
+			countsY[(s.getStartY() * NUM_RANGES) >> 8]++;
+			countsX[(s.getEndX() * NUM_RANGES) >> 8]++;
+			countsY[(s.getEndY() * NUM_RANGES) >> 8]++;
+		}
+	}
+
+	/**
+	 * Compares two arrays of length NUM_RANGES. Score 2 points for each exact
+	 * match (where an item from counts1[4] matches one in counts2[4]) and 1
+	 * point for each neighbour match. Points are then scaled out of maximum
+	 * possible (given any difference in counts).
+	 * @param counts1 First array
+	 * @param counts2 Second array
+	 * @param wrap True if the last item is considered a neighbour of the first
+	 * @return Score from 0 to 1.
+	 */
+	static float compareArrays(int[] counts1, int[] counts2, boolean wrap)
+	{
+		int n = counts1.length;
+		int score = 0;
+		int[] left1 = new int[n], left2 = new int[n];
+		int total1 = 0, total2 = 0;
+
+		// Remove exact matches
+		for(int i=0; i<n; i++)
+		{
+			int count1 = counts1[i], count2 = counts2[i];
+			total1 += count1;
+			total2 += count2;
+			if(count1 > count2)
+			{
+				score += count2;
+				left1[i] = count1 - count2;
+				left2[i] = 0;
+			}
+			else if(count2 > count1)
+			{
+				score += count1;
+				left1[i] = 0;
+				left2[i] = count2 - count1;
+			}
+			else // equal
+			{
+				score += count1;
+				// Set it to zero - but don't bother because that's the default
+			}
+		}
+
+		// If there are none in either, give it a match
+		if(total1 == 0 && total2 == 0)
+		{
+			return 1f;
+		}
+
+		// Double score (because you get 2 points for exact matches)
+		score *= 2;
+
+		// Loop through all matches to match against neighbours
+		for(int i=0; i<n; i++)
+		{
+			// Any left?
+			int remaining = left1[i];
+			if(remaining == 0)
+			{
+				continue;
+			}
+
+			// Try either side
+			if(i > 0)
+			{
+				int before = left2[i-1];
+				if(before >= remaining)
+				{
+					score += remaining;
+					left2[i-1] = before - remaining;
+					remaining = 0;
+				}
+				else if(before > 0)
+				{
+					score += before;
+					left2[i-1] = 0;
+					remaining -= before;
+				}
+			}
+			else if(wrap)
+			{
+				int before = left2[n-1];
+				if(before >= remaining)
+				{
+					score += remaining;
+					left2[n-1] = before - remaining;
+					remaining = 0;
+				}
+				else if(before > 0)
+				{
+					score += before;
+					left2[n-1] = 0;
+					remaining -= before;
+				}
+			}
+
+			if(remaining > 0)
+			{
+				if(i < n-1)
+				{
+					int after = left2[i+1];
+					if(after >= remaining)
+					{
+						score += remaining;
+						left2[i+1] = after - remaining;
+						remaining = 0;
+					}
+					else if(after > 0)
+					{
+						score += after;
+						left2[i+1] = 0;
+						remaining -= after;
+					}
+				}
+				else if(wrap)
+				{
+					int after = left2[0];
+					if(after >= remaining)
+					{
+						score += remaining;
+						left2[0] = after - remaining;
+						remaining = 0;
+					}
+					else if(after > 0)
+					{
+						score += after;
+						left2[0] = 0;
+						remaining -= after;
+					}
+				}
+			}
+		}
+
+		// Max score is a score where everything matches every other thing, except
+		// that you have leftovers equal to the difference in counts
+		int maxScore = Math.min(total1, total2) * 2;
+		if(maxScore==0)
+		{
+			return 0f;
+		}
+
+		// Return scaled score
+		return (float)score / (float)maxScore;
+	}
+}
diff --git a/src/com/leafdigital/kanji/FuzzyComparer.java b/src/com/leafdigital/kanji/FuzzyComparer.java
index a70a8b8..c47a59e 100644
--- a/src/com/leafdigital/kanji/FuzzyComparer.java
+++ b/src/com/leafdigital/kanji/FuzzyComparer.java
@@ -21,11 +21,11 @@ package com.leafdigital.kanji;
 /**
  * Compares entered strokes with other kanji using slightly fuzzy logic.
  */
-public class FuzzyComparer
+public class FuzzyComparer implements KanjiComparer
 {
 	private Pair[] drawnPairs;
 	private Point[] drawnPoints;
-	
+
 	private final static float SCOREMULTI_NOT_PAIR = 0.9f;
 	private final static float SCOREMULTI_WRONG_DIRECTION = 0.97f;
 
@@ -34,21 +34,21 @@ public class FuzzyComparer
 	private static class Pair
 	{
 		private Point a, b;
-		
+
 		private int pointCount;
-		
+
 		private float[][] scores;
 		private float maxBScore, maxAScore;
-		
+
 		private float bestScore;
 		private int bestAIndex, bestBIndex;
-		
+
 		private Pair(Point a, Point b)
 		{
 			this.a = a;
 			this.b = b;
 		}
-		
+
 		void initDrawn(int maxStrokes)
 		{
 			scores = new float[maxStrokes * 2][];
@@ -59,13 +59,13 @@ public class FuzzyComparer
 			a.initDrawn(maxStrokes);
 			b.initDrawn(maxStrokes);
 		}
-		
+
 		private void score(Point[] availablePoints)
 		{
 			pointCount = availablePoints.length;
 			maxBScore = -1;
 			maxAScore = -1;
-			
+
 			// Get max B score
 			for(int bIndex=0; bIndex < pointCount; bIndex++)
 			{
@@ -75,7 +75,7 @@ public class FuzzyComparer
 					maxBScore = bScore;
 				}
 			}
-			
+
 			for(int aIndex=0; aIndex < pointCount; aIndex++)
 			{
 				// Track max A score
@@ -86,16 +86,16 @@ public class FuzzyComparer
 				}
 				Pair aPair = availablePoints[aIndex].pair;
 				boolean wrongDirection = aPair.a != availablePoints[aIndex];
-				
+
 				for(int bIndex=0; bIndex < pointCount; bIndex++)
 				{
 					int bScore = b.score[bIndex];
-					
+
 					if(bIndex==aIndex)
 					{
 						continue;
 					}
-					
+
 					// Basic score is sum of individual scores
 					float score = aScore + bScore;
 
@@ -106,15 +106,15 @@ public class FuzzyComparer
 					else if(wrongDirection)
 					{
 						score *= SCOREMULTI_WRONG_DIRECTION;
-					}					
-					
+					}
+
 					scores[aIndex][bIndex] = score;
 				}
 			}
-			
+
 			bestScore = -1f;
 		}
-		
+
 		private void scoreAvailable(Point[] otherPoints, float mustBeOver)
 		{
 			// If it hasn't changed since last time, do nothing
@@ -128,7 +128,7 @@ public class FuzzyComparer
 			{
 				return;
 			}
-			
+
 			// Consider all combinations of point A and B
 			bestScore = -1f;
 //			int loopCount = 0;
@@ -136,14 +136,14 @@ public class FuzzyComparer
 			{
 				ScoreAndIndex aScore = a.sortedScore[aIndex];
 				int aPointIndex = aScore.index;
-				if(aScore.score + maxBScore < mustBeOver 
+				if(aScore.score + maxBScore < mustBeOver
 					|| otherPoints[aPointIndex] == null)
 				{
 					// If A score + any B score can't beat min score, then continue, or
 					// also if point is done
 					continue;
 				}
-				
+
 				float[] correspondingScores = scores[aPointIndex];
 				for(int bIndex=0; bIndex < pointCount; bIndex++)
 				{
@@ -153,19 +153,19 @@ public class FuzzyComparer
 					{
 						continue;
 					}
-					
+
 //					loopCount++;
-					
+
 					// Basic score is sum of individual scores
 					float score = correspondingScores[bPointIndex];
-					
+
 					// Is this best?
 					if(score > bestScore)
 					{
 						bestScore = score;
 						bestAIndex = aPointIndex;
 						bestBIndex = bPointIndex;
-						
+
 						if(bestScore > mustBeOver)
 						{
 							mustBeOver = bestScore;
@@ -173,12 +173,12 @@ public class FuzzyComparer
 					}
 				}
 			}
-			
+
 //			System.err.println(loopCount + "/" + (pointCount * pointCount));
-			
+
 		}
 	}
-	
+
 	private static class ScoreAndIndex implements Comparable<ScoreAndIndex>
 	{
 		int score, index;
@@ -200,7 +200,7 @@ public class FuzzyComparer
 				return index - o.index;
 			}
 		}
-		
+
 		@Override
 		public String toString()
 		{
@@ -211,27 +211,27 @@ public class FuzzyComparer
 	private static class Point
 	{
 		private final static int SIMILAR_RANGE = 13;
-		
+
 		private int x, y;
 		private int xLess, xMore, xSimilar, yLess, yMore, ySimilar;
-		
+
 		private Pair pair;
-		
+
 		private int[] score;
 		private ScoreAndIndex[] sortedScore, preSortedScore;
 		private int[] best = new int[BEST_SCORES_SORT_FIRST];
-		
+
 		private Point(int x, int y)
 		{
 			this.x = (int) ((x + 0.5f) * 255);
 			this.y = (int) ((y + 0.5f) * 255);
 		}
-		
+
 		private void setPair(Pair pair)
 		{
 			this.pair = pair;
 		}
-		
+
 		private void count(Point[] allPoints)
 		{
 			for(Point point : allPoints)
@@ -266,7 +266,7 @@ public class FuzzyComparer
 				}
 			}
 		}
-		
+
 		private void initDrawn(int maxStrokes)
 		{
 			// Initialise the array only once per drawn character
@@ -280,8 +280,8 @@ public class FuzzyComparer
 			// Dummy score to use for 'best' marker
 			preSortedScore[maxStrokes * 2] = new ScoreAndIndex();
 		}
-		
-		
+
+
 		private void score(Point[] otherPoints, int maxScore)
 		{
 			for(int i=0; i<BEST_SCORES_SORT_FIRST; i++)
@@ -292,19 +292,19 @@ public class FuzzyComparer
 			for(int i=0; i<otherPoints.length; i++)
 			{
 				Point other = otherPoints[i];
-				
+
 				// Work out difference between each element of these points
-				int difference = Math.abs(xLess - other.xLess) 
+				int difference = Math.abs(xLess - other.xLess)
 					+ Math.abs(xMore - other.xMore) + Math.abs(xSimilar - other.xSimilar)
 					+ Math.abs(yLess - other.yLess) + Math.abs(yMore - other.yMore)
 					+ Math.abs(ySimilar - other.ySimilar);
-				
+
 				int thisScore = maxScore - difference;
 				preSortedScore[i].index = i;
 				preSortedScore[i].score = thisScore;
 				preSortedScore[i].used = false;
 				score[i] = thisScore;
-				
+
 				if(thisScore >= worstBestScore)
 				{
 					int bestIndex=0;
@@ -326,13 +326,13 @@ public class FuzzyComparer
 					}
 				}
 			}
-			
+
 			for(int i=0; i<BEST_SCORES_SORT_FIRST; i++)
 			{
 				sortedScore[i] = preSortedScore[best[i]];
 				preSortedScore[best[i]].used = true;
 			}
-			
+
 			int index = BEST_SCORES_SORT_FIRST;
 			for(int i=0; i<otherPoints.length; i++)
 			{
@@ -342,7 +342,7 @@ public class FuzzyComparer
 				}
 			}
 //			System.err.println(Arrays.toString(sortedScore));
-			
+
 //			for(int i=otherPoints.length; i<sortedScore.length; i++)
 //			{
 //				sortedScore[i] = new ScoreAndIndex(0, i);
@@ -352,12 +352,13 @@ public class FuzzyComparer
 //			Arrays.sort(sortedScore);
 		}
 	}
-	
+
 	/**
 	 * Construct comparer for a particular drawn kanji.
 	 * @param drawn Drawn kanji
 	 */
-	public FuzzyComparer(KanjiInfo drawn)
+	@Override
+	public void init(KanjiInfo drawn)
 	{
 		// Set up data about drawn pairs/points
 		drawnPairs = convertKanjiInfo(drawn);
@@ -367,7 +368,7 @@ public class FuzzyComparer
 			pair.initDrawn(drawnPairs.length + 2);
 		}
 	}
-	
+
 	private static Pair[] convertKanjiInfo(KanjiInfo info)
 	{
 		Pair[] result = new Pair[info.getStrokeCount()];
@@ -385,7 +386,7 @@ public class FuzzyComparer
 		}
 		return result;
 	}
-	
+
 	private static Point[] getPairPoints(Pair[] pairs)
 	{
 		Point[] result = new Point[pairs.length * 2];
@@ -401,43 +402,44 @@ public class FuzzyComparer
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Compares against the given other kanji.
 	 * @param other Other kanji
 	 * @return Score in range 0 to 100
 	 */
+	@Override
 	public float getMatchScore(KanjiInfo other)
 	{
 		// Get data from match kanji
 		Pair[] otherPairs = convertKanjiInfo(other);
 		Point[] otherPoints = getPairPoints(otherPairs);
-		
+
 		// Max difference is (less than) the highest number of strokes *
 		// 6 facets.
 		int maxScore = Math.max(drawnPoints.length, otherPoints.length) * 6;
-		
+
 		// Score all points against all points; O(points^2)
 		for(Point point : drawnPoints)
 		{
 			point.score(otherPoints, maxScore);
 		}
-		
-		// Score all pairs 
+
+		// Score all pairs
 		for(Pair pair : drawnPairs)
 		{
 			pair.score(otherPoints);
 		}
-		
+
 		// Copy source pairs into list of remaining ones
 		Pair[] remainingPairs = new Pair[drawnPairs.length];
 		System.arraycopy(drawnPairs, 0, remainingPairs, 0, remainingPairs.length);
-		
+
 		// How many remaining things to match?
 		int pairsLeft = remainingPairs.length;
 		int pointsLeft = otherPoints.length;
 		float totalScore = 0f;
-		
+
 		while(pointsLeft > 0 && pairsLeft > 0)
 		{
 			// Score all pairs to find best match
@@ -459,7 +461,7 @@ public class FuzzyComparer
 					bestPairScore = pair.bestScore;
 				}
 			}
-			
+
 			// Eat that pair and its points, and add to total score
 			remainingPairs[bestPairIndex] = null;
 			int aIndex = bestPair.bestAIndex, bIndex = bestPair.bestBIndex;
@@ -469,10 +471,10 @@ public class FuzzyComparer
 			pairsLeft--;
 			pointsLeft-=2;
 		}
-		
+
 		// Scale score (it is now up to 2 * max * number of pairs matched)
 		totalScore /= 2 * maxScore * (drawnPairs.length - pairsLeft);
-		
+
 		// Return as percentage
 		return totalScore * 100f;
 	}
diff --git a/src/com/leafdigital/kanji/InputStroke.java b/src/com/leafdigital/kanji/InputStroke.java
index bd0d7f0..56112a9 100644
--- a/src/com/leafdigital/kanji/InputStroke.java
+++ b/src/com/leafdigital/kanji/InputStroke.java
@@ -18,18 +18,18 @@ Copyright 2011 Samuel Marshall.
 */
 package com.leafdigital.kanji;
 
-/** 
+/**
  * Single kanji stroke as represented in floating-point numbers.
  * <p>
- * This class has two main functions: first, to represent strokes loaded from 
- * the KanjiVG file as SVG paths, and second, to represent strokes being drawn 
- * by user input. These need to be stored as float values so that they can be 
+ * This class has two main functions: first, to represent strokes loaded from
+ * the KanjiVG file as SVG paths, and second, to represent strokes being drawn
+ * by user input. These need to be stored as float values so that they can be
  * scaled later when all strokes are available.
  */
 public class InputStroke
 {
 	private float startX, startY, endX, endY;
-	
+
 	/**
 	 * Class to make it easier to read path data.
 	 */
@@ -42,7 +42,7 @@ public class InputStroke
 		{
 			this.remaining = path;
 		}
-		
+
 		/**
 		 * Reads the next non-whitespace character.
 		 * @return Character or EOL if end of string or NUMBER if number/comma not letter
@@ -69,7 +69,7 @@ public class InputStroke
 				pos++;
 			}
 		}
-		
+
 		/**
 		 * Reads the next number, skipping whitespace and comma and +
 		 * @return Number
@@ -91,7 +91,7 @@ public class InputStroke
 				}
 				start++;
 			}
-			
+
 			int end = start + 1;
 			while(true)
 			{
@@ -106,10 +106,10 @@ public class InputStroke
 				}
 				end++;
 			}
-			
+
 			String number = remaining.substring(start, end);
 			remaining = remaining.substring(end);
-			
+
 			try
 			{
 				return Float.parseFloat(number);
@@ -119,9 +119,9 @@ public class InputStroke
 				throw new IllegalArgumentException("Invalid number: " + number);
 			}
 		}
-		
+
 	}
-	
+
 	/**
 	 * Constructs from an SVG path. The full SVG path sequence is not accepted.
 	 * Instead all paths must begin with a single M or m followed by commands from
@@ -139,12 +139,12 @@ public class InputStroke
 		{
 			throw new IllegalArgumentException("Path must start with M");
 		}
-		
+
 		// Read start co-ordinates (note: 'm' is not really relative at start
 		// of path, so treated the same as M; see SVG spec)
 		startX = data.readNumber();
 		startY = data.readNumber();
-		
+
 		// Handle all other commands
 		float x = startX, y = startY;
 		int lastCommand = -1;
@@ -165,7 +165,7 @@ public class InputStroke
 			}
 			switch(command)
 			{
-			case PathData.EOL : 
+			case PathData.EOL :
 				break loop; // End of line
 			case 'c' :
 				data.readNumber();
@@ -175,7 +175,7 @@ public class InputStroke
 				x += data.readNumber();
 				y += data.readNumber();
 				break;
-			case 'C' : 
+			case 'C' :
 				data.readNumber();
 				data.readNumber();
 				data.readNumber();
@@ -201,15 +201,15 @@ public class InputStroke
 				y = startY;
 				break;
 			default :
-				throw new IllegalArgumentException("Unexpected path command: " 
+				throw new IllegalArgumentException("Unexpected path command: "
 					+	(char)command);
 			}
 		}
-		
+
 		endX = x;
 		endY = y;
 	}
-	
+
 	/**
 	 * Constructs from raw data.
 	 * @param startX Start position (x) 0-1
@@ -224,39 +224,39 @@ public class InputStroke
 		this.startY = startY;
 		this.endY = endY;
 	}
-	
-	/** 
+
+	/**
 	 * @return Start X position
 	 */
 	public float getStartX()
 	{
 		return startX;
 	}
-	
-	/** 
-	 * @return End X position 
+
+	/**
+	 * @return End X position
 	 */
 	public float getEndX()
 	{
 		return endX;
 	}
-	
-	/** 
+
+	/**
 	 * @return Start Y position
 	 */
 	public float getStartY()
 	{
 		return startY;
 	}
-	
-	/** 
+
+	/**
 	 * @return End Y position
 	 */
 	public float getEndY()
 	{
 		return endY;
 	}
-	
+
 	/**
 	 * Normalises an array of strokes by converting their co-ordinates to range
 	 * from 0 to 1 in each direction. If the stroke bounding rectangle
@@ -270,7 +270,7 @@ public class InputStroke
 	public static Stroke[] normalise(InputStroke[] strokes)
 	{
 		// Find range
-		float minX = Float.MAX_VALUE, minY = Float.MAX_VALUE, 
+		float minX = Float.MAX_VALUE, minY = Float.MAX_VALUE,
 			maxX = Float.MIN_VALUE, maxY = Float.MIN_VALUE;
 		for(InputStroke stroke : strokes)
 		{
@@ -290,7 +290,7 @@ public class InputStroke
 			{
 				maxY = stroke.startY;
 			}
-			
+
 			if(stroke.endX < minX)
 			{
 				minX = stroke.endX;
@@ -308,7 +308,7 @@ public class InputStroke
 				maxY = stroke.endY;
 			}
 		}
-		
+
 		// Adjust max/min to avoid divide by zero
 		if(abs(minX - maxX) < 0.0000000001f)
 		{
@@ -329,11 +329,11 @@ public class InputStroke
 			{
 				adjust = 0.1f;
 			}
-			
+
 			minY -= adjust;
 			maxY += adjust;
 		}
-		
+
 		// Now sort out a maximum scale factor, so that very long/thin kanji
 		// don't get stretched to square
 		float xRange = abs(minX - maxX), yRange = abs(minY - maxY);
@@ -349,7 +349,7 @@ public class InputStroke
 			minX -= adjust;
 			maxX += adjust;
 		}
-		
+
 		// Convert all points according to range
 		Stroke[] output = new Stroke[strokes.length];
 		for(int i=0; i<strokes.length; i++)
@@ -360,15 +360,15 @@ public class InputStroke
 				(strokes[i].endX - minX) / (maxX - minX),
 				(strokes[i].endY - minY) / (maxY - minY));
 		}
-		
+
 		return output;
 	}
-	
-	private static float abs(float value)	
-	{	
+
+	private static float abs(float value)
+	{
 		return value < 0 ? -value : value;
 	}
-	
+
 	@Override
 	public String toString()
 	{
diff --git a/src/com/leafdigital/kanji/KanjiComparer.java b/src/com/leafdigital/kanji/KanjiComparer.java
new file mode 100644
index 0000000..cbcbee9
--- /dev/null
+++ b/src/com/leafdigital/kanji/KanjiComparer.java
@@ -0,0 +1,39 @@
+/*
+This file is part of leafdigital kanjirecog.
+
+kanjirecog is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+kanjirecog is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with kanjirecog.  If not, see <http://www.gnu.org/licenses/>.
+
+Copyright 2011 Samuel Marshall.
+*/
+package com.leafdigital.kanji;
+
+/**
+ * Interface for a method that can compare different kanji.
+ */
+public interface KanjiComparer
+{
+	/**
+	 * Initialises the comparer. Should be called immediately after the
+	 * constructor.
+	 * @param info Kanji that the user drew
+	 */
+	public void init(KanjiInfo info);
+
+	/**
+	 * Compares against the given other kanji.
+	 * @param other Other kanji
+	 * @return Score in range 0 to 100
+	 */
+	public float getMatchScore(KanjiInfo other);
+}
diff --git a/src/com/leafdigital/kanji/KanjiInfo.java b/src/com/leafdigital/kanji/KanjiInfo.java
index 51fc1a4..ba24ce3 100644
--- a/src/com/leafdigital/kanji/KanjiInfo.java
+++ b/src/com/leafdigital/kanji/KanjiInfo.java
@@ -19,49 +19,151 @@ Copyright 2011 Samuel Marshall.
 package com.leafdigital.kanji;
 
 import java.io.*;
-import java.util.LinkedList;
+import java.util.*;
 
 import com.leafdigital.kanji.Stroke.*;
 
-/** 
+/**
  * Holds stroke info about a single kanji.
  */
 public class KanjiInfo
 {
-	/** 
-	 * Algorithm used for comparing kanji. 
+	/**
+	 * Algorithm used for comparing kanji.
 	 */
 	public enum MatchAlgorithm
 	{
-		/** 
+		/**
 		 * Accurate, fast, but strict algorithm (requires precise stroke count
 		 * and order).
 		 */
-		STRICT, 
+		STRICT(0, StrictComparer.class),
 		/**
-		 * Fuzzy matching algorithm  which allows arbitrary stroke order. Very slow.
+		 * Fuzzy matching algorithm which allows arbitrary stroke order. Very slow.
 		 */
-		FUZZY,
+		FUZZY(0, FuzzyComparer.class),
 		/**
-		 * Fuzzy matching algorithm  which allows arbitrary stroke order; with
+		 * Fuzzy matching algorithm which allows arbitrary stroke order; with
 		 * either +1 or -1 stroke count (does not include =). Even slower.
 		 */
-		FUZZY_1OUT,
+		FUZZY_1OUT(1, FuzzyComparer.class),
 		/**
-		 * Fuzzy matching algorithm  which allows arbitrary stroke order; with
+		 * Fuzzy matching algorithm which allows arbitrary stroke order; with
 		 * either +2 or -2 stroke count. Also slow
 		 */
-		FUZZY_2OUT
+		FUZZY_2OUT(2, FuzzyComparer.class),
+		/**
+		 * Second fuzzy matching algorithm based on the 'dots' of each stroke.
+		 */
+		DOTS(0, DotsComparer.class),
+		/**
+		 * Second fuzzy matching algorithm based on the 'dots' of each stroke.
+		 * Allows +1 or -1 stroke count.
+		 */
+		DOTS_1OUT(1, DotsComparer.class),
+		/**
+		 * Second fuzzy matching algorithm based on the 'dots' of each stroke.
+		 * Allows +2 or -2 stroke count.
+		 */
+		DOTS_2OUT(2, DotsComparer.class),
+		/**
+		 * Second fuzzy matching algorithm based on the 'dots' of each stroke.
+		 */
+		SPANS(0, SpansComparer.class),
+		/**
+		 * Second fuzzy matching algorithm based on the 'dots' of each stroke.
+		 * Allows +1 or -1 stroke count.
+		 */
+		SPANS_1OUT(1, SpansComparer.class),
+		/**
+		 * Second fuzzy matching algorithm based on the 'dots' of each stroke.
+		 * Allows +2 or -2 stroke count.
+		 */
+		SPANS_2OUT(2, SpansComparer.class);
+
+		private int out;
+		private Class<? extends KanjiComparer> c;
+
+		MatchAlgorithm(int out, Class<? extends KanjiComparer> c)
+		{
+			this.out = out;
+			this.c = c;
+		}
+
+		/**
+		 * @return The number of strokes difference from correct for this algorithm
+		 *   (e.g. 1 for FUZZY_1OUT)
+		 */
+		public int getOut()
+		{
+			return out;
+		}
+
+		/**
+		 * Constructs a new comparer object with the given drawn kanji
+		 * @param drawn Drawn kanji
+		 * @return Comparer object, already inited
+		 */
+		public KanjiComparer newComparer(KanjiInfo drawn)
+		{
+			KanjiComparer comparer;
+			try
+			{
+				comparer = c.newInstance();
+			}
+			catch(InstantiationException e)
+			{
+				throw new Error("Incorrectly defined comparer", e);
+			}
+			catch(IllegalAccessException e)
+			{
+				throw new Error("Incorrectly defined comparer", e);
+			}
+			comparer.init(drawn);
+			return comparer;
+		}
 	};
-	
+
 	private String kanji;
 	private LinkedList<InputStroke> loadingStrokes;
 	private Stroke[] strokes;
 	private Direction[] strokeDirections, moveDirections;
 	private Location[] strokeStarts, strokeEnds;
-	
-	private FuzzyComparer fuzzyComparer;
-	
+
+	private HashMap<MatchAlgorithm, KanjiComparer> comparers;
+
+	/**
+	 * @return Stroke starts array
+	 */
+	public Location[] getStrokeStarts()
+	{
+		return strokeStarts;
+	}
+
+	/**
+	 * @return Stroke ends array
+	 */
+	public Location[] getStrokeEnds()
+	{
+		return strokeEnds;
+	}
+
+	/**
+	 * @return Stroke directions array
+	 */
+	public Direction[] getStrokeDirections()
+	{
+		return strokeDirections;
+	}
+
+	/**
+	 * @return Move directions array
+	 */
+	public Direction[] getMoveDirections()
+	{
+		return moveDirections;
+	}
+
 	/**
 	 * @param kanji Kanji character (should be a single character, but may be
 	 *   a UTF-16 surrogate pair)
@@ -71,7 +173,7 @@ public class KanjiInfo
 		this.kanji = kanji;
 		loadingStrokes = new LinkedList<InputStroke>();
 	}
-	
+
 	/**
 	 * @param kanji Kanji character (should be a single character, but may be
 	 *   a UTF-16 surrogate pair)
@@ -85,10 +187,10 @@ public class KanjiInfo
 		int count = (full.length()+1) / 12;
 		if((count * 12 - 1) != full.length())
 		{
-			throw new IllegalArgumentException("Invalid full (" + full 
+			throw new IllegalArgumentException("Invalid full (" + full
 				+ ") for kanji (" + kanji + ")");
 		}
-		
+
 		try
 		{
 			strokes = new Stroke[count];
@@ -99,7 +201,7 @@ public class KanjiInfo
 				{
 					offset++; // Skip colon
 				}
-				
+
 				strokes[i] = new Stroke(
 					getTwoDigitHexInt(full, offset),
 					getTwoDigitHexInt(full, offset+3),
@@ -114,10 +216,10 @@ public class KanjiInfo
 			throw new IllegalArgumentException("Invalid summary(" + full
 				+ ") for kanji (" + kanji + ")");
 		}
-		
+
 		findDirections();
 	}
-	
+
 	/**
 	 * Converts a two-digit, lowercase hex string to an integer. (This is a lot
 	 * faster than doing a substring and Integer.parseInt; I profiled it and
@@ -148,20 +250,20 @@ public class KanjiInfo
 		int count = (full.length()+1) / 12;
 		if(count < 1 || (count * 6 -3) != directions.length())
 		{
-			throw new IllegalArgumentException("Invalid directions (" + directions 
+			throw new IllegalArgumentException("Invalid directions (" + directions
 				+ ") for kanji (" + kanji + ")");
 		}
 		if((count * 12 - 1) != full.length())
 		{
-			throw new IllegalArgumentException("Invalid full (" + full 
+			throw new IllegalArgumentException("Invalid full (" + full
 				+ ") for kanji (" + kanji + ")");
 		}
-		
+
 		strokeDirections = new Direction[count];
 		strokeStarts = new Location[count];
 		strokeEnds = new Location[count];
 		moveDirections = new Direction[count-1];
-		
+
 		try
 		{
 			int offset = 0;
@@ -173,7 +275,7 @@ public class KanjiInfo
 					moveDirections[i-1] = Direction.fromString(directions.charAt(offset++) + "");
 					offset++; // Skip colon
 				}
-	
+
 				strokeStarts[i] = Location.fromString(directions.charAt(offset++) + "");
 				strokeDirections[i] = Direction.fromString(directions.charAt(offset++) + "");
 				strokeEnds[i] = Location.fromString(directions.charAt(offset++) + "");
@@ -195,11 +297,11 @@ public class KanjiInfo
 				{
 					offset++; // Skip colon
 				}
-				
+
 				strokes[i] = new Stroke(
-					Integer.parseInt(full.substring(offset, offset+2), 16),				
-					Integer.parseInt(full.substring(offset+3, offset+5), 16),				
-					Integer.parseInt(full.substring(offset+6, offset+8), 16),				
+					Integer.parseInt(full.substring(offset, offset+2), 16),
+					Integer.parseInt(full.substring(offset+3, offset+5), 16),
+					Integer.parseInt(full.substring(offset+6, offset+8), 16),
 					Integer.parseInt(full.substring(offset+9, offset+11), 16));
 				offset+=11;
 			}
@@ -217,7 +319,7 @@ public class KanjiInfo
 	 * @param stroke New stroke
 	 * @throws IllegalStateException If already finished
 	 */
-	public synchronized void addStroke(InputStroke stroke) throws IllegalStateException	
+	public synchronized void addStroke(InputStroke stroke) throws IllegalStateException
 	{
 		if(loadingStrokes == null)
 		{
@@ -225,23 +327,23 @@ public class KanjiInfo
 		}
 		loadingStrokes.add(stroke);
 	}
-	
+
 	/**
 	 * Marks kanji as finished, normalising all strokes.
 	 * @throws IllegalStateException If already finished
 	 */
-	public synchronized void finish() throws IllegalStateException	
+	public synchronized void finish() throws IllegalStateException
 	{
 		if(loadingStrokes == null)
 		{
 			throw new IllegalStateException("Cannot finish more than once");
 		}
-		
+
 		// Get stroke array and normalise it
 		InputStroke[] inputStrokes = loadingStrokes.toArray(
 			new InputStroke[loadingStrokes.size()]);
 		strokes = InputStroke.normalise(inputStrokes);
-		
+
 		// Find directions
 		findDirections();
 	}
@@ -267,7 +369,7 @@ public class KanjiInfo
 			moveDirections[i-1] = strokes[i].getMoveDirection(strokes[i-1]);
 		}
 	}
-	
+
 	/**
 	 * Checks that this kanji has been finished.
 	 * @throws IllegalStateException If not finished
@@ -279,15 +381,15 @@ public class KanjiInfo
 			throw new IllegalStateException("Cannot call on unfinished kanji");
 		}
 	}
-	
-	/** 
+
+	/**
 	 * @return Kanji character (one character or a two-character surrogate pair)
 	 */
 	public String getKanji()
 	{
 		return kanji;
 	}
-	
+
 	/**
 	 * @return Stroke count
 	 * @throws IllegalStateException If not finished
@@ -297,11 +399,11 @@ public class KanjiInfo
 		checkFinished();
 		return strokeDirections.length;
 	}
-	
+
 	/**
 	 * @param index Stroke index
 	 * @return Stroke
-	 * @throws ArrayIndexOutOfBoundsException If index >= 
+	 * @throws ArrayIndexOutOfBoundsException If index >=
 	 *   {@link #getStrokeCount()}
 	 * @throws IllegalStateException If loaded in a way that doesn't give
 	 *   these
@@ -313,10 +415,10 @@ public class KanjiInfo
 		{
 			throw new IllegalStateException("Cannot call getStroke in this state");
 		}
-		
+
 		return strokes[index];
 	}
-	
+
 	/**
 	 * Obtains all the directions (stroke and move).
 	 * @return All the direction arrows
@@ -338,7 +440,7 @@ public class KanjiInfo
 		}
 		return out.toString();
 	}
-	
+
 	private String getTwoDigitPosition(int intPos)
 	{
 		String result = Integer.toHexString(intPos);
@@ -348,7 +450,7 @@ public class KanjiInfo
 		}
 		return result;
 	}
-	
+
 	/**
 	 * Obtains all stroke details as a from/to summary.
 	 * @return Full details as string
@@ -357,9 +459,9 @@ public class KanjiInfo
 	{
 		if(strokes == null)
 		{
-			throw new IllegalStateException("Strokes not available");			
+			throw new IllegalStateException("Strokes not available");
 		}
-		
+
 		StringBuilder out = new StringBuilder();
 		for(Stroke stroke : strokes)
 		{
@@ -378,7 +480,7 @@ public class KanjiInfo
 
 		return out.toString();
 	}
-	
+
 	/**
 	 * Writes the basic info from this kanji to short XML format data.
 	 * @param out Writer that receives data
@@ -390,104 +492,34 @@ public class KanjiInfo
 			+ Integer.toHexString(Character.codePointAt(kanji, 0)).toUpperCase()
 			+ "' strokes='" + getFullSummary() + "'/>\n");
 	}
-	
-	private final static float STROKE_DIRECTION_WEIGHT = 1.0f;
-	private final static float MOVE_DIRECTION_WEIGHT = 0.8f;
-	private final static float STROKE_LOCATION_WEIGHT = 0.6f;
-	
-	private final static float CLOSE_WEIGHT = 0.7f;
-	
+
 	/**
 	 * Gets a score for matching with the specified other kanji. Scores are
 	 * only comparable against other kanji with same stroke count.
 	 * @param other Other kanji
 	 * @param algo Match algorithm to use
 	 * @return Score
-	 * @throws IllegalArgumentException If other kanji has different stroke count
+	 * @throws IllegalArgumentException If other kanji has inappropriate stroke count
 	 */
-	public float getMatchScore(KanjiInfo other, MatchAlgorithm algo) 
+	public float getMatchScore(KanjiInfo other, MatchAlgorithm algo)
 		throws IllegalArgumentException
 	{
-		switch(algo)
-		{
-		case STRICT:
-			return getStrictMatchScore(other);
-		case FUZZY:
-		case FUZZY_1OUT:
-		case FUZZY_2OUT:
-			if(fuzzyComparer == null)
-			{
-				fuzzyComparer = new FuzzyComparer(this);
-			}
-			return fuzzyComparer.getMatchScore(other);
-		default:
-			throw new IllegalArgumentException("Unknown algorithm");
-		}
-	}
-	
-	/**
-	 * Gets a score for matching with the specified other kanji. Scores are
-	 * only comparable against other kanji with same stroke count.
-	 * @param other Other kanji
-	 * @return Score
-	 * @throws IllegalArgumentException If other kanji has different stroke count
-	 */
-	private float getStrictMatchScore(KanjiInfo other) throws IllegalArgumentException
-	{
-		if(other.strokeStarts.length != strokeStarts.length)
-		{
-			throw new IllegalArgumentException(
-				"Can only compare with same match length");
-		}
-		
-		float score = 0;
-		for(int i=0; i<strokeStarts.length; i++)
+		KanjiComparer comparer;
+		synchronized(this)
 		{
-			// Stroke direction
-			if(strokeDirections[i] == other.strokeDirections[i])
-			{
-				score += STROKE_DIRECTION_WEIGHT;
-			}
-			else if(strokeDirections[i].isClose(other.strokeDirections[i]))
-			{
-				score += STROKE_DIRECTION_WEIGHT * CLOSE_WEIGHT;
-			}
-			
-			// Move direction
-			if(i>0)
-			{
-				if(moveDirections[i-1] == other.moveDirections[i-1])
-				{
-					score += MOVE_DIRECTION_WEIGHT;
-				}
-				else if(moveDirections[i-1].isClose(other.moveDirections[i-1]))
-				{
-					score += MOVE_DIRECTION_WEIGHT * CLOSE_WEIGHT;
-				}
-			}
-			
-			// Start and end locations
-			if(strokeStarts[i] == other.strokeStarts[i])
-			{
-				score += STROKE_LOCATION_WEIGHT;
-			}
-			else if(strokeStarts[i].isClose(other.strokeStarts[i]))
+			if(comparers == null)
 			{
-				score += STROKE_LOCATION_WEIGHT * CLOSE_WEIGHT;
+				comparers = new HashMap<MatchAlgorithm, KanjiComparer>();
 			}
-			if(strokeEnds[i] == other.strokeEnds[i])
-			{
-				score += STROKE_LOCATION_WEIGHT;
-			}
-			else if(strokeEnds[i].isClose(other.strokeEnds[i]))
+
+			comparer = comparers.get(algo);
+			if(comparer == null)
 			{
-				score += STROKE_LOCATION_WEIGHT * CLOSE_WEIGHT;
+				comparer = algo.newComparer(this);
+				comparers.put(algo, comparer);
 			}
 		}
-		
-		float max = strokeStarts.length * (STROKE_DIRECTION_WEIGHT + 2 * STROKE_LOCATION_WEIGHT) +
-			(strokeStarts.length - 1) * MOVE_DIRECTION_WEIGHT;
-		
-		return 100.0f * score / max;
+
+		return comparer.getMatchScore(other);
 	}
 }
diff --git a/src/com/leafdigital/kanji/KanjiList.java b/src/com/leafdigital/kanji/KanjiList.java
index dcf92c6..159a209 100644
--- a/src/com/leafdigital/kanji/KanjiList.java
+++ b/src/com/leafdigital/kanji/KanjiList.java
@@ -26,8 +26,6 @@ import javax.xml.parsers.*;
 import org.xml.sax.*;
 import org.xml.sax.helpers.DefaultHandler;
 
-import com.leafdigital.kanji.KanjiInfo.MatchAlgorithm;
-
 /**
  * Stores list of all {@link KanjiInfo} objects loaded, organised by
  * stroke count.
@@ -197,88 +195,48 @@ public class KanjiList
 		throws IllegalArgumentException
 	{
 		TreeSet<KanjiMatch> matches = new TreeSet<KanjiMatch>();
-		switch(algo)
+
+		List<KanjiInfo> list = new LinkedList<KanjiInfo>();
+		if(compare.getStrokeCount() > 0)
 		{
-		case STRICT:
-			{
-				List<KanjiInfo> list;
-				synchronized(this)
-				{
-					list = new LinkedList<KanjiInfo>(kanji.get(compare.getStrokeCount()));
-				}
-				if(list != null)
-				{
-					int max = list.size();
-					if(progress != null)
-					{
-						progress.progress(0, max);
-					}
-					int i = 0;
-					for(KanjiInfo other : list)
-					{
-						float score = compare.getMatchScore(other, algo);
-						if(score > 0)
-						{
-							KanjiMatch match = new KanjiMatch(other, score);
-							matches.add(match);
-						}
-						if(progress != null)
-						{
-							progress.progress(++i, max);
-						}
-					}
-				}
-			} break;
-		case FUZZY:
-		case FUZZY_1OUT:
-		case FUZZY_2OUT:
+			synchronized(this)
 			{
-				List<KanjiInfo> list = new LinkedList<KanjiInfo>();
-				if(compare.getStrokeCount() > 0)
+				// Do either -2 and +2, -1 and +1, or just 0
+				int range = algo.getOut();
+				int count = compare.getStrokeCount() - range;
+				for(int i=0; i<2; i++)
 				{
-					synchronized(this)
+					if(count > 0)
 					{
-						// Do either -2 and +2, -1 and +1, or just 0
-						int range = (algo==MatchAlgorithm.FUZZY_2OUT) ? 2
-							: (algo==MatchAlgorithm.FUZZY_1OUT) ? 1 : 0;
-						int count = compare.getStrokeCount() - range;
-						for(int i=0; i<2; i++)
+						List<KanjiInfo> countList = kanji.get(count);
+						if(countList != null)
 						{
-							if(count > 0)
-							{
-								List<KanjiInfo> countList = kanji.get(count);
-								if(countList != null)
-								{
-									list.addAll(countList);
-								}
-							}
-							count += 2 * range;
-							if (range == 0)
-							{
-								break;
-							}
+							list.addAll(countList);
 						}
 					}
-				}
-				int max = list.size();
-				if(progress != null)
-				{
-					progress.progress(0, max);
-				}
-				int i = 0;
-				for(KanjiInfo other : list)
-				{
-					float score = compare.getMatchScore(other, algo);
-					KanjiMatch match = new KanjiMatch(other, score);
-					matches.add(match);
-					if(progress != null)
+					count += 2 * range;
+					if (range == 0)
 					{
-						progress.progress(++i, max);
+						break;
 					}
 				}
-			} break;
-		default:
-			throw new IllegalArgumentException("Unknown algorithm");
+			}
+		}
+		int max = list.size();
+		if(progress != null)
+		{
+			progress.progress(0, max);
+		}
+		int i = 0;
+		for(KanjiInfo other : list)
+		{
+			float score = compare.getMatchScore(other, algo);
+			KanjiMatch match = new KanjiMatch(other, score);
+			matches.add(match);
+			if(progress != null)
+			{
+				progress.progress(++i, max);
+			}
 		}
 
 		// Pull everything down to half match score
diff --git a/src/com/leafdigital/kanji/SpansComparer.java b/src/com/leafdigital/kanji/SpansComparer.java
new file mode 100644
index 0000000..3388e5e
--- /dev/null
+++ b/src/com/leafdigital/kanji/SpansComparer.java
@@ -0,0 +1,142 @@
+/*
+This file is part of leafdigital kanjirecog.
+
+kanjirecog is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+kanjirecog is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with kanjirecog.  If not, see <http://www.gnu.org/licenses/>.
+
+Copyright 2011 Samuel Marshall.
+*/
+package com.leafdigital.kanji;
+
+import static com.leafdigital.kanji.DotsComparer.compareArrays;
+
+/**
+ * Compares entered strokes with other kanji using two factors:
+ * - The number of strokes of different start/end locations in X and Y axes
+ * - The number of strokes of different directions
+ * This algorithm is a lot faster than the fuzzy algorithm, but is currently
+ * distinctly worse.
+ */
+public class SpansComparer implements KanjiComparer
+{
+	final static int NUM_RANGES = 5;
+	final static int NUM_DIRECTIONS = 4;
+
+	private final static float DIRECTION_IMPORTANCE = 0.6f;
+
+	private int[][] xThis, yThis;
+	private int[] directionThis;
+
+	static int[][] makeSpansArray()
+	{
+		int[][] spans = new int[NUM_RANGES][];
+		for(int i=0; i<NUM_RANGES; i++)
+		{
+			spans[i] = new int[NUM_RANGES];
+		}
+		return spans;
+	}
+
+	static void fillSpans(int[][] xSpans, int[][] ySpans, KanjiInfo info)
+	{
+		for(int i=0; i<info.getStrokeCount(); i++)
+		{
+			Stroke s = info.getStroke(i);
+			int startX = (s.getStartX() * NUM_RANGES) >> 8;
+			int startY = (s.getStartY() * NUM_RANGES) >> 8;
+			int endX = (s.getEndX() * NUM_RANGES) >> 8;
+			int endY = (s.getEndY() * NUM_RANGES) >> 8;
+
+			xSpans[startX][endX]++;
+			xSpans[endX][startX]++; // Keeping this is a waste of time
+			ySpans[startY][endY]++;
+			ySpans[endY][startY]++;
+		}
+	}
+
+	/**
+	 * Initialises with given drawn kanji.
+	 * @param info Drawn kanji
+	 */
+	@Override
+	public void init(KanjiInfo info)
+	{
+		xThis = makeSpansArray();
+		yThis = makeSpansArray();
+		fillSpans(xThis, yThis, info);
+		directionThis = new int[NUM_DIRECTIONS];
+		fillDirections(directionThis, info);
+	}
+
+	/**
+	 * Compares against the given other kanji.
+	 * @param other Other kanji
+	 * @return Score in range 0 to 100
+	 */
+	@Override
+	public float getMatchScore(KanjiInfo other)
+	{
+		// Get counts for other kanji
+		int[][] xOther = makeSpansArray();
+		int[][] yOther = makeSpansArray();
+		fillSpans(xOther, yOther, other);
+
+		// Compare the two count arrays and use that as score
+		float score = 0f;
+		for(int i=0; i<NUM_RANGES; i++)
+		{
+			score += compareArrays(xThis[i], xOther[i], false);
+			score += compareArrays(yThis[i], yOther[i], false);
+		}
+		score = score * 100f / (2*NUM_RANGES);
+
+		// Get directions for other kanji
+		int[] directionOther = new int[NUM_DIRECTIONS];
+		fillDirections(directionOther, other);
+		float directionScore = compareArrays(directionThis, directionOther, true) * 100f;
+
+		// Return balance of direction and span score
+		return score * (1f-DIRECTION_IMPORTANCE) + directionScore * DIRECTION_IMPORTANCE;
+	}
+
+	static void fillDirections(int[] directions, KanjiInfo info)
+	{
+		for(int i=0; i<info.getStrokeCount(); i++)
+		{
+			Stroke s = info.getStroke(i);
+			switch(s.getDirectionNoThreshold())
+			{
+			case W:
+			case E:
+				// This direction: -
+				directions[0]++;
+				break;
+			case NW:
+			case SE:
+				// This direction: \
+				directions[1]++;
+				break;
+			case N:
+			case S:
+				// This direction: |
+				directions[2]++;
+				break;
+			case NE:
+			case SW:
+				// This direction: /
+				directions[3]++;
+				break;
+			}
+		}
+	}
+}
diff --git a/src/com/leafdigital/kanji/StrictComparer.java b/src/com/leafdigital/kanji/StrictComparer.java
new file mode 100644
index 0000000..359a304
--- /dev/null
+++ b/src/com/leafdigital/kanji/StrictComparer.java
@@ -0,0 +1,121 @@
+/*
+This file is part of leafdigital kanjirecog.
+
+kanjirecog is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+kanjirecog is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with kanjirecog.  If not, see <http://www.gnu.org/licenses/>.
+
+Copyright 2011 Samuel Marshall.
+*/
+package com.leafdigital.kanji;
+
+import com.leafdigital.kanji.Stroke.Direction;
+import com.leafdigital.kanji.Stroke.Location;
+
+/**
+ * Compares entered strokes with other kanji using slightly fuzzy logic.
+ */
+public class StrictComparer implements KanjiComparer
+{
+	private final static float STROKE_DIRECTION_WEIGHT = 1.0f;
+	private final static float MOVE_DIRECTION_WEIGHT = 0.8f;
+	private final static float STROKE_LOCATION_WEIGHT = 0.6f;
+
+	private final static float CLOSE_WEIGHT = 0.7f;
+
+	private Location[] drawnStarts, drawnEnds;
+	private Direction[] drawnDirections, drawnMoves;
+
+	/**
+	 * Initialises with given drawn kanji.
+	 * @param info Drawn kanji
+	 */
+	@Override
+	public void init(KanjiInfo info)
+	{
+		drawnStarts = info.getStrokeStarts();
+		drawnEnds = info.getStrokeEnds();
+		drawnDirections = info.getStrokeDirections();
+		drawnMoves = info.getMoveDirections();
+	}
+
+	/**
+	 * Compares against the given other kanji.
+	 * @param other Other kanji
+	 * @return Score in range 0 to 100
+	 */
+	@Override
+	public float getMatchScore(KanjiInfo other)
+	{
+		Location[] otherStarts = other.getStrokeStarts(),
+			otherEnds = other.getStrokeEnds();
+		Direction[] otherDirections = other.getStrokeDirections(),
+			otherMoves = other.getMoveDirections();
+
+		if(otherStarts.length != drawnStarts.length)
+		{
+			throw new IllegalArgumentException(
+				"Can only compare with same match length");
+		}
+
+		float score = 0;
+		for(int i=0; i<drawnStarts.length; i++)
+		{
+			// Stroke direction
+			if(drawnDirections[i] == otherDirections[i])
+			{
+				score += STROKE_DIRECTION_WEIGHT;
+			}
+			else if(drawnDirections[i].isClose(otherDirections[i]))
+			{
+				score += STROKE_DIRECTION_WEIGHT * CLOSE_WEIGHT;
+			}
+
+			// Move direction
+			if(i>0)
+			{
+				if(drawnMoves[i-1] == otherMoves[i-1])
+				{
+					score += MOVE_DIRECTION_WEIGHT;
+				}
+				else if(drawnMoves[i-1].isClose(otherMoves[i-1]))
+				{
+					score += MOVE_DIRECTION_WEIGHT * CLOSE_WEIGHT;
+				}
+			}
+
+			// Start and end locations
+			if(drawnStarts[i] == otherStarts[i])
+			{
+				score += STROKE_LOCATION_WEIGHT;
+			}
+			else if(drawnStarts[i].isClose(otherStarts[i]))
+			{
+				score += STROKE_LOCATION_WEIGHT * CLOSE_WEIGHT;
+			}
+			if(drawnEnds[i] == otherEnds[i])
+			{
+				score += STROKE_LOCATION_WEIGHT;
+			}
+			else if(drawnEnds[i].isClose(otherEnds[i]))
+			{
+				score += STROKE_LOCATION_WEIGHT * CLOSE_WEIGHT;
+			}
+		}
+
+		float max = drawnStarts.length * (STROKE_DIRECTION_WEIGHT
+			+ 2 * STROKE_LOCATION_WEIGHT)
+			+	(drawnStarts.length - 1) * MOVE_DIRECTION_WEIGHT;
+
+		return 100.0f * score / max;
+	}
+}
diff --git a/src/com/leafdigital/kanji/Stroke.java b/src/com/leafdigital/kanji/Stroke.java
index 6f53487..88ce862 100644
--- a/src/com/leafdigital/kanji/Stroke.java
+++ b/src/com/leafdigital/kanji/Stroke.java
@@ -18,14 +18,14 @@ Copyright 2011 Samuel Marshall.
 */
 package com.leafdigital.kanji;
 
-/** 
+/**
  * Single kanji stroke.
  */
 public class Stroke
 {
 	// All values in range 0-255
 	private int startX, startY, endX, endY;
-	
+
 	/**
 	 * Constructs from float data.
 	 * @param startX Start position (x) 0-1
@@ -39,7 +39,7 @@ public class Stroke
 	{
 		this(convert(startX), convert(startY), convert(endX), convert(endY));
 	}
-	
+
 	private static int convert(float value)
 	{
 		return (int)(value * 255 + 0.49999);
@@ -56,7 +56,7 @@ public class Stroke
 	Stroke(int startX, int startY, int endX, int endY)
 		throws IllegalArgumentException
 	{
-		if(startX < 0 || startX > 255 || startY < 0 || startY > 255 
+		if(startX < 0 || startX > 255 || startY < 0 || startY > 255
 			|| endX < 0 || endX > 255 || endY < 0 || endY > 255) {
 			throw new IllegalArgumentException("Value out of range");
 		}
@@ -65,56 +65,56 @@ public class Stroke
 		this.startY = startY;
 		this.endY = endY;
 	}
-	
-	/** 
+
+	/**
 	 * @return Start X position
 	 */
 	public int getStartX()
 	{
 		return startX;
 	}
-	
-	/** 
-	 * @return End X position 
+
+	/**
+	 * @return End X position
 	 */
 	public int getEndX()
 	{
 		return endX;
 	}
-	
-	/** 
+
+	/**
 	 * @return Start Y position
 	 */
 	public int getStartY()
 	{
 		return startY;
 	}
-	
-	/** 
+
+	/**
 	 * @return End Y position
 	 */
 	public int getEndY()
 	{
 		return endY;
 	}
-	
+
 	/**
 	 * Represents approximate location of start/end points of stroke.
 	 */
 	public enum Location
 	{
 		/** Basically N */
-		N(1, 0, "\u2580"), 
+		N(1, 0, "\u2580"),
 		/** Basically NE */
-		NE(2, 0, "\u259c"), 
+		NE(2, 0, "\u259c"),
 		/** Basically E */
-		E(2, 1, "\u2590"), 
+		E(2, 1, "\u2590"),
 		/** Basically SE */
 		SE(2, 2, "\u259f"),
 		/** Basically S */
-		S(1, 2, "\u2584"), 
+		S(1, 2, "\u2584"),
 		/** Basically SW */
-		SW(0, 2, "\u2599"), 
+		SW(0, 2, "\u2599"),
 		/** Basically W */
 		W(0, 1, "\u258c"),
 		/** Basically NW */
@@ -124,20 +124,20 @@ public class Stroke
 
 		private int x, y;
 		private String display;
-		
+
 		Location(int x, int y, String display)
 		{
 			this.x = x;
 			this.y = y;
 			this.display = display;
 		}
-		
+
 		@Override
 		public String toString()
 		{
 			return display;
 		}
-		
+
 		/**
 		 * Reads from string.
 		 * @param s Input string
@@ -155,7 +155,7 @@ public class Stroke
 			}
 			throw new IllegalArgumentException("Unknown location (" + s + ")");
 		}
-		
+
 		/**
 		 * @param other Another direction
 		 * @return True if this direction is within one step of the other direction
@@ -164,7 +164,7 @@ public class Stroke
 		{
 			return Math.abs(x - other.x) <= 1 && Math.abs(y - other.y) <= 1;
 		}
-		
+
 		/**
 		 * @param x Normalised X
 		 * @param y Normalised Y
@@ -219,46 +219,46 @@ public class Stroke
 			}
 		}
 	}
-	
+
 	/**
 	 * The direction of a stroke.
 	 */
 	public enum Direction
 	{
 		/** Basically N */
-		N(0, "\u2191"), 
+		N(0, "\u2191"),
 		/** Basically NE */
-		NE(1, "\u2197"), 
+		NE(1, "\u2197"),
 		/** Basically E */
-		E(2, "\u2192"), 
+		E(2, "\u2192"),
 		/** Basically SE */
 		SE(3, "\u2198"),
 		/** Basically S */
-		S(4, "\u2193"), 
+		S(4, "\u2193"),
 		/** Basically SW */
-		SW(5, "\u2199"), 
+		SW(5, "\u2199"),
 		/** Basically W */
 		W(6, "\u2190"),
 		/** Basically NW */
 		NW(7, "\u2196"),
 		/** No clear movement */
 		X(-1, "\u26aa");
-		
+
 		private int index;
 		private String display;
-		
+
 		Direction(int index, String display)
 		{
 			this.index = index;
 			this.display = display;
 		}
-		
+
 		@Override
 		public String toString()
 		{
 			return display;
 		}
-		
+
 		/**
 		 * Reads from string.
 		 * @param s Input string
@@ -276,7 +276,7 @@ public class Stroke
 			}
 			throw new IllegalArgumentException("Unknown direction (" + s + ")");
 		}
-		
+
 		/**
 		 * @param other Another direction
 		 * @return True if this direction is within one step of the other direction
@@ -287,10 +287,10 @@ public class Stroke
 			{
 				return true;
 			}
-			return (this.index == ( (other.index + 1) % 8 ) ) 
+			return (this.index == ( (other.index + 1) % 8 ) )
 				|| ( ((this.index + 1) % 8 ) == other.index);
 		}
-		
+
 		/**
 		 * Threshold above which something counts as directional.
 		 */
@@ -302,29 +302,30 @@ public class Stroke
 		 * be at least 10 * 77 / 256 in order to count as SE).
 		 */
 		private static int DIAGONAL_THRESHOLD = 77;
-		
+
 		/**
 		 * Calculates the direction between two points.
 		 * @param startX Start X
 		 * @param startY Start Y
 		 * @param endX End X
 		 * @param endY End Y
+		 * @param threshold Direction threshold (movement under this is not counted as directional)
 		 * @return Direction of stroke
 		 * @throws IllegalStateException If not normalised
 		 */
 		private static Direction get(int startX, int startY,
-			int endX, int endY) throws IllegalStateException
+			int endX, int endY, int threshold) throws IllegalStateException
 		{
 			// Get movement in each direction
 			int deltaX = endX - startX, deltaY = endY - startY;
-			
+
 			// Check if it's not really movement at all (under threshold)
 			int absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY);
-			if(absDeltaX < DIRECTION_THRESHOLD && absDeltaY < DIRECTION_THRESHOLD)
+			if(absDeltaX < threshold && absDeltaY < threshold)
 			{
 				return Direction.X;
 			}
-			
+
 			if(absDeltaX > absDeltaY)
 			{
 				// X movement is more significant
@@ -379,18 +380,29 @@ public class Stroke
 					}
 				}
 			}
-		}		
+		}
 	}
-	
+
 	/**
 	 * Calculates the direction of this stroke.
 	 * @return Direction of stroke
 	 */
 	public Direction getDirection()
 	{
-		return Direction.get(startX, startY, endX, endY);
+		return Direction.get(startX, startY, endX, endY,
+			Direction.DIRECTION_THRESHOLD);
 	}
-	
+
+	/**
+	 * Calculates the direction of this stroke without imposing a threshold
+	 * that considers short moves as nondirectional.
+	 * @return Direction of stroke (will not be Direction.X)
+	 */
+	public Direction getDirectionNoThreshold()
+	{
+		return Direction.get(startX, startY, endX, endY, 0);
+	}
+
 	/**
 	 * Calculates the direction that the pen moved between the end of the
 	 * last stroke and the start of this one.
@@ -399,17 +411,18 @@ public class Stroke
 	 */
 	public Direction getMoveDirection(Stroke previous)
 	{
-		return Direction.get(previous.endX, previous.endY, startX, startY);
+		return Direction.get(previous.endX, previous.endY, startX, startY,
+			Direction.DIRECTION_THRESHOLD);
 	}
-	
+
 	/**
 	 * @return Approximate location of start of stroke
 	 */
-	public Location getStartLocation() 
+	public Location getStartLocation()
 	{
 		return Location.get(startX, startY);
 	}
-	
+
 	/**
 	 * @return Approximate location of end of stroke
 	 */
@@ -417,7 +430,7 @@ public class Stroke
 	{
 		return Location.get(endX, endY);
 	}
-	
+
 	@Override
 	public String toString()
 	{
diff --git a/src/com/leafdigital/kanji/package-info.java b/src/com/leafdigital/kanji/package-info.java
index 39f4a8f..35d3267 100644
--- a/src/com/leafdigital/kanji/package-info.java
+++ b/src/com/leafdigital/kanji/package-info.java
@@ -54,7 +54,7 @@ drawing.
 
 <p>
 To compare and rank the user's drawing, use 
-{@link com.leafdigital.kanji.KanjiList#getTopMatches(KanjiInfo, KanjiInfo.MatchAlgorithm)}
+{@link com.leafdigital.kanji.KanjiList#getTopMatches(KanjiInfo, KanjiInfo.MatchAlgorithm, KanjiList.Progress)}
 to obtain matches.
 </p>
 
@@ -79,7 +79,7 @@ correct stroke count.</li>
 
 <p>
 The
-{@link com.leafdigital.kanji.KanjiList#getTopMatches(KanjiInfo, KanjiInfo.MatchAlgorithm)}
+{@link com.leafdigital.kanji.KanjiList#getTopMatches(KanjiInfo, KanjiInfo.MatchAlgorithm, KanjiList.Progress)}
 function returns a number of {@link com.leafdigital.kanji.KanjiMatch} objects, in order. Each
 one contains information about the matched kanji and the match percentage.
 </p> 
diff --git a/test/com/leafdigital/kanji/AnalyseRecognition.java b/test/com/leafdigital/kanji/AnalyseRecognition.java
index 90928f6..b7700e0 100644
--- a/test/com/leafdigital/kanji/AnalyseRecognition.java
+++ b/test/com/leafdigital/kanji/AnalyseRecognition.java
@@ -59,7 +59,8 @@ public class AnalyseRecognition
 	private final static String[] DEFAULT_WHERE_CLAUSES =
 	{
 		"clientname like 'leafdigital %'",
-		"clientname like 'leafdigital %' and ranking=1 and algo='STRICT'"
+		"clientname like 'leafdigital %' and ranking=1 and algo='STRICT'",
+		"clientname like 'leafdigital %' and algo='FUZZY'"
 	};
 
 	/**
@@ -164,6 +165,8 @@ public class AnalyseRecognition
 
 	private Map<MatchAlgorithm, AlgoResults> results;
 
+	private long startTime;
+
 	/**
 	 * Tracks results for a specific algorithm.
 	 */
@@ -285,6 +288,8 @@ public class AnalyseRecognition
 		list = new KanjiList(new FileInputStream("data/strokes-20100823.xml"));
 		results = new TreeMap<MatchAlgorithm, AlgoResults>();
 
+		startTime = System.currentTimeMillis();
+
 		// Start the thread pool
 		threadPool = Executors.newFixedThreadPool(
 			Runtime.getRuntime().availableProcessors());
@@ -318,23 +323,13 @@ public class AnalyseRecognition
 				int actualStrokes = list.find(kanji).getStrokeCount();
 
 				// Decide which algorithms to use based on stroke count
-				MatchAlgorithm[] algorithms;
-				if(actualStrokes == drawingInfo.getStrokeCount())
-				{
-					algorithms = new MatchAlgorithm[] { MatchAlgorithm.STRICT,
-						MatchAlgorithm.FUZZY };
-				}
-				else if(Math.abs(actualStrokes - drawingInfo.getStrokeCount()) == 1)
-				{
-					algorithms = new MatchAlgorithm[] { MatchAlgorithm.FUZZY_1OUT };
-				}
-				else if(Math.abs(actualStrokes - drawingInfo.getStrokeCount()) == 2)
+				List<MatchAlgorithm> algorithms = new LinkedList<MatchAlgorithm>();
+				for(MatchAlgorithm algo : MatchAlgorithm.values())
 				{
-					algorithms = new MatchAlgorithm[] { MatchAlgorithm.FUZZY_1OUT };
-				}
-				else
-				{
-					algorithms = new MatchAlgorithm[0];
+					if(algo.getOut() == Math.abs(actualStrokes - drawingInfo.getStrokeCount()))
+					{
+						algorithms.add(algo);
+					}
 				}
 
 				// Process for each algorithm
@@ -396,6 +391,7 @@ public class AnalyseRecognition
 	{
 		threadPool.shutdown();
 		threadPool.awaitTermination(1, TimeUnit.DAYS);
+		long endTime = System.currentTimeMillis();
 		System.err.println();
 		for(Map.Entry<MatchAlgorithm,AlgoResults> entry : results.entrySet())
 		{
@@ -413,5 +409,12 @@ public class AnalyseRecognition
 			// Print results
 			entry.getValue().display();
 		}
+		System.out.println();
+		System.out.println("PERFORMANCE");
+		System.out.println("===========");
+		System.out.println();
+		double msPerCharacter = (double)(endTime - startTime) / (double)processed;
+		System.out.println(String.format("%.1f ms / character",
+			msPerCharacter));
 	}
 }
diff --git a/test/com/leafdigital/kanji/DotsComparerTest.java b/test/com/leafdigital/kanji/DotsComparerTest.java
new file mode 100644
index 0000000..6735cd2
--- /dev/null
+++ b/test/com/leafdigital/kanji/DotsComparerTest.java
@@ -0,0 +1,146 @@
+/*
+This file is part of leafdigital kanjirecog.
+
+kanjirecog is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+kanjirecog is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with kanjirecog.  If not, see <http://www.gnu.org/licenses/>.
+
+Copyright 2011 Samuel Marshall.
+*/
+package com.leafdigital.kanji;
+
+import static org.junit.Assert.*;
+
+import java.io.FileInputStream;
+
+import org.junit.Test;
+
+/** Test fuzzy comparer. */
+public class DotsComparerTest
+{
+	/**
+	 * Set this flag on to enable timing comparison by testing 100 characters
+	 * instead of just 5.
+	 */
+	private static boolean DEBUG = false;
+
+	/**
+	 * Test the point fill function.
+	 */
+	@Test
+	public void testFillCounts()
+	{
+		// Simple example
+		KanjiInfo info = new KanjiInfo("?");
+		info.addStroke(new InputStroke(0, 0, 1, 0));
+		info.finish();
+		int[] x = new int[5], y = new int[5];
+		DotsComparer.fillCounts(x, y, info);
+		assertArrayEquals(new int[] { 1, 0, 0, 0, 1 }, x);
+		assertArrayEquals(new int[] { 0, 0, 2, 0, 0 }, y);
+	}
+
+	/**
+	 * Test the array comparison function
+	 */
+	@Test
+	public void testCompareArrays()
+	{
+		// Basic equal case
+		assertEquals(1.0, DotsComparer.compareArrays(
+			new int[] { 1, 0, 7, 4, 0 },
+			new int[] { 1, 0, 7, 4, 0 }, false), 0.00001);
+
+		// Shift one (various locations)
+		assertEquals(0.5, DotsComparer.compareArrays(
+			new int[] { 1, 0, 0, 0, 0 },
+			new int[] { 0, 1, 0, 0, 0 }, false), 0.00001);
+		assertEquals(0.5, DotsComparer.compareArrays(
+			new int[] { 0, 1, 0, 0, 0 },
+			new int[] { 1, 0, 0, 0, 0 }, false), 0.00001);
+		assertEquals(0.5, DotsComparer.compareArrays(
+			new int[] { 0, 0, 0, 0, 1 },
+			new int[] { 0, 0, 0, 1, 0 }, false), 0.00001);
+		assertEquals(0.5, DotsComparer.compareArrays(
+			new int[] { 0, 0, 0, 1, 0 },
+			new int[] { 0, 0, 0, 0, 1 }, false), 0.00001);
+
+		// Shift some left over
+		assertEquals(0.25, DotsComparer.compareArrays(
+			new int[] { 2, 0, 0, 0, 0 },
+			new int[] { 0, 1, 1, 0, 0 }, false), 0.00001);
+
+		// Ensure shift can't be used twice
+		assertEquals(0.5, DotsComparer.compareArrays(
+			new int[] { 0, 1, 0, 1, 0 },
+			new int[] { 0, 0, 1, 0, 0 }, false), 0.00001);
+
+		// Some equal, some shift
+		assertEquals(0.75, DotsComparer.compareArrays(
+			new int[] { 1, 0, 1, 0, 0 },
+			new int[] { 0, 1, 1, 0, 0 }, false), 0.00001);
+
+		// One equal, one left over (both ways)
+		assertEquals(1.0, DotsComparer.compareArrays(
+			new int[] { 1, 0, 1, 0, 0 },
+			new int[] { 0, 0, 1, 0, 0 }, false), 0.00001);
+		assertEquals(1.0, DotsComparer.compareArrays(
+			new int[] { 0, 0, 1, 0, 0 },
+			new int[] { 1, 0, 1, 0, 0 }, false), 0.00001);
+
+		// Arrays filled with zeros
+		assertEquals(1.0, DotsComparer.compareArrays(
+			new int[] { 0, 0, 0, 0, 0 },
+			new int[] { 0, 0, 0, 0, 0 }, false), 0.00001);
+
+		// First array has zeros
+		assertEquals(0.0, DotsComparer.compareArrays(
+			new int[] { 0, 0, 0, 0, 0 },
+			new int[] { 0, 0, 0, 0, 1 }, false), 0.00001);
+
+		// Second array has zeros
+		assertEquals(0.0, DotsComparer.compareArrays(
+			new int[] { 0, 0, 0, 0, 1 },
+			new int[] { 0, 0, 0, 0, 0 }, false), 0.00001);
+	}
+
+	/**
+	 * Tests basic functionality
+	 * @throws Exception Any error
+	 */
+	@Test
+	public void testBigMatch() throws Exception
+	{
+		// This compares the first 5 20-stroke kanji characters against all the
+		// others and checks that they match themselves. In addition to correctness
+		// checking it can be used for timing comparison (increasing the limit may
+		// give more stable results).
+		KanjiList list = new KanjiList(
+			new FileInputStream("data/strokes-20100823.xml"));
+		KanjiInfo[] all20 = list.getKanji(20);
+		for(int i=0; i<all20.length && i<(DEBUG ? 100 : 5); i++)
+		{
+			KanjiInfo big = all20[i];
+			if(DEBUG)
+			{
+				System.err.print(big.getKanji());
+				if(i%10 == 9)
+				{
+					System.err.println();
+				}
+			}
+			KanjiMatch[] matches =
+				list.getTopMatches(big, KanjiInfo.MatchAlgorithm.DOTS, null);
+			assertEquals(big.getKanji(), matches[0].getKanji().getKanji());
+		}
+	}
+}
