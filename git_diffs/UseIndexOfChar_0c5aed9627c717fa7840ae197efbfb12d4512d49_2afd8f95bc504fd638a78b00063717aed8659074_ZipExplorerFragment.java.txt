diff --git a/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java b/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java
index 653104095..1259b4251 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/PreferencesActivity.java
@@ -51,7 +51,7 @@ import com.readystatesoftware.systembartint.SystemBarTintManager;
 
 import static android.os.Build.VERSION.SDK_INT;
 
-public class PreferencesActivity extends ThemedActivity implements ActivityCompat.OnRequestPermissionsResultCallback {
+public class PreferencesActivity extends ThemedActivity {
 
     //Start is the first activity you see
     public static final int START_PREFERENCE = 0;
@@ -194,20 +194,6 @@ public class PreferencesActivity extends ThemedActivity implements ActivityCompa
         }
     }
 
-    @Override
-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
-                                           @NonNull int[] grantResults) {
-        if (requestCode == 66) {
-            PrefFrag prefFrag = (PrefFrag) getFragmentManager().findFragmentById(R.id.prefsfragment);
-
-            if (prefFrag != null) {
-
-                prefFrag.invalidateGplus();
-            }
-        }
-
-    }
-
     private void loadPrefFragment(PreferenceFragment fragment, @StringRes int titleBarName) {
         FragmentTransaction t = getFragmentManager().beginTransaction();
         t.replace(R.id.prefsfragment, fragment);
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java
new file mode 100644
index 000000000..0da525da2
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/adapters/CompressedExplorerAdapter.java
@@ -0,0 +1,309 @@
+package com.amaze.filemanager.adapters;
+
+import android.app.Activity;
+import android.content.Context;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.GradientDrawable;
+import android.os.Build;
+import android.support.v7.widget.RecyclerView;
+import android.text.format.Formatter;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.Toast;
+
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.adapters.holders.CompressedItemViewHolder;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.compressed.CompressedInterface;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.ui.icons.Icons;
+import com.amaze.filemanager.ui.views.CircleGradientDrawable;
+import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.Utils;
+import com.amaze.filemanager.utils.color.ColorUtils;
+import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
+import com.amaze.filemanager.utils.theme.AppTheme;
+
+import java.util.ArrayList;
+
+/**
+ * Created by Arpit on 25-01-2015 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
+ */
+public class CompressedExplorerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
+
+    private static final int TYPE_HEADER = 0, TYPE_ITEM = 1;
+
+    public boolean stoppedAnimation = false;
+
+    private Context context;
+    private UtilitiesProviderInterface utilsProvider;
+    private Drawable folder;
+    private ArrayList<CompressedObjectParcelable> items;
+    private CompressedExplorerFragment compressedExplorerFragment;
+    private CompressedInterface compressedInterface;
+    private LayoutInflater mInflater;
+    private boolean[] itemsChecked;
+    private int offset = 0;
+
+    public CompressedExplorerAdapter(Context c, UtilitiesProviderInterface utilsProvider,
+                                     ArrayList<CompressedObjectParcelable> items,
+                                     CompressedExplorerFragment compressedExplorerFragment,
+                                     CompressedInterface compressedInterface) {
+        this.utilsProvider = utilsProvider;
+        this.items = items;
+        this.compressedInterface = compressedInterface;
+
+        itemsChecked = new boolean[items.size()];
+
+        context = c;
+        if (c == null) return;
+        folder = c.getResources().getDrawable(R.drawable.ic_grid_folder_new);
+        this.compressedExplorerFragment = compressedExplorerFragment;
+        mInflater = (LayoutInflater) c.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
+    }
+
+    public void toggleChecked(boolean check) {
+        int k = 0;
+
+        for (int i = k; i < items.size(); i++) {
+            itemsChecked[i] = check;
+            notifyItemChanged(i);
+        }
+    }
+
+    public ArrayList<Integer> getCheckedItemPositions() {
+        ArrayList<Integer> checkedItemPositions = new ArrayList<>();
+
+        for (int i = 0; i < itemsChecked.length; i++) {
+            if (itemsChecked[i]) {
+                (checkedItemPositions).add(i);
+            }
+        }
+
+        return checkedItemPositions;
+    }
+
+    /**
+     * called as to toggle selection of any item in adapter
+     *
+     * @param position  the position of the item
+     * @param imageView the circular {@link CircleGradientDrawable} that is to be animated
+     */
+    private void toggleChecked(int position, ImageView imageView) {
+        compressedExplorerFragment.stopAnim();
+        stoppedAnimation = true;
+
+        Animation animation;
+        if (itemsChecked[position]) {
+            animation = AnimationUtils.loadAnimation(context, R.anim.check_out);
+        } else {
+            animation = AnimationUtils.loadAnimation(context, R.anim.check_in);
+        }
+
+        if (imageView != null) {
+            imageView.setAnimation(animation);
+        } else {
+            // TODO: we don't have the check icon object probably because of config change
+        }
+
+        itemsChecked[position] = !itemsChecked[position];
+
+        notifyDataSetChanged();
+        if (!compressedExplorerFragment.selection || compressedExplorerFragment.mActionMode == null) {
+            compressedExplorerFragment.selection = true;
+            /*compressedExplorerFragment.mActionMode = compressedExplorerFragment.getActivity().startActionMode(
+                   compressedExplorerFragment.mActionModeCallback);*/
+            compressedExplorerFragment.mActionMode = compressedExplorerFragment.mainActivity.getAppbar().getToolbar().startActionMode(compressedExplorerFragment.mActionModeCallback);
+        }
+        compressedExplorerFragment.mActionMode.invalidate();
+        if (getCheckedItemPositions().size() == 0) {
+            compressedExplorerFragment.selection = false;
+            compressedExplorerFragment.mActionMode.finish();
+            compressedExplorerFragment.mActionMode = null;
+        }
+    }
+
+    private void animate(CompressedItemViewHolder holder) {
+        holder.rl.clearAnimation();
+        Animation localAnimation = AnimationUtils.loadAnimation(compressedExplorerFragment.getActivity(), R.anim.fade_in_top);
+        localAnimation.setStartOffset(this.offset);
+        holder.rl.startAnimation(localAnimation);
+        this.offset = (30 + this.offset);
+    }
+
+    public void generateZip(ArrayList<CompressedObjectParcelable> arrayList) {
+        offset = 0;
+        stoppedAnimation = false;
+        items = arrayList;
+        notifyDataSetChanged();
+        itemsChecked = new boolean[items.size()];
+    }
+
+    @Override
+    public int getItemViewType(int position) {
+        if (isPositionHeader(position))
+            return TYPE_HEADER;
+
+        return TYPE_ITEM;
+    }
+
+    @Override
+    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+        if (viewType == TYPE_HEADER) {
+            View v = mInflater.inflate(R.layout.rowlayout, parent, false);
+            v.findViewById(R.id.picture_icon).setVisibility(View.INVISIBLE);
+            return new CompressedItemViewHolder(v);
+        } else if(viewType == TYPE_ITEM) {
+            View v = mInflater.inflate(R.layout.rowlayout, parent, false);
+            CompressedItemViewHolder vh = new CompressedItemViewHolder(v);
+            ImageButton about = (ImageButton) v.findViewById(R.id.properties);
+            about.setVisibility(View.INVISIBLE);
+            return vh;
+        } else {
+            throw new IllegalStateException();
+        }
+    }
+
+    @Override
+    public void onBindViewHolder(final RecyclerView.ViewHolder vholder, int position) {
+        CompressedItemViewHolder holder = (CompressedItemViewHolder) vholder;
+
+        if (!stoppedAnimation) {
+            animate((CompressedItemViewHolder) vholder);
+        }
+
+        final CompressedObjectParcelable rowItem = items.get(position);
+        GradientDrawable gradientDrawable = (GradientDrawable) holder.genericIcon.getBackground();
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+            holder.checkImageView.setBackground(new CircleGradientDrawable(compressedExplorerFragment.accentColor,
+                    utilsProvider.getAppTheme(), compressedExplorerFragment.getResources().getDisplayMetrics()));
+        } else
+            holder.checkImageView.setBackgroundDrawable(new CircleGradientDrawable(compressedExplorerFragment.accentColor,
+                    utilsProvider.getAppTheme(), compressedExplorerFragment.getResources().getDisplayMetrics()));
+
+        if (rowItem.getType() == CompressedObjectParcelable.TYPE_GOBACK) {
+            holder.genericIcon.setImageDrawable(compressedExplorerFragment.getResources().getDrawable(R.drawable.ic_arrow_left_white_24dp));
+            gradientDrawable.setColor(Utils.getColor(context, R.color.goback_item));
+            holder.txtTitle.setText("..");
+            holder.txtDesc.setText("");
+            holder.date.setText(R.string.goback);
+        } else {
+            holder.genericIcon.setImageDrawable(Icons.loadMimeIcon(rowItem.getName(), false, context.getResources()));
+            final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
+            if (compressedExplorerFragment.showLastModified)
+                holder.date.setText(Utils.getDate(rowItem.getTime(), compressedExplorerFragment.year));
+            if (rowItem.isDirectory()) {
+                holder.genericIcon.setImageDrawable(folder);
+                gradientDrawable.setColor(Color.parseColor(compressedExplorerFragment.iconskin));
+                if (stringBuilder.toString().length() > 0) {
+                    stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
+                    try {
+                        holder.txtTitle.setText(stringBuilder.toString().substring(stringBuilder.toString().lastIndexOf("/") + 1));
+                    } catch (Exception e) {
+                        holder.txtTitle.setText(rowItem.getName().substring(0, rowItem.getName().lastIndexOf("/")));
+                    }
+                }
+            } else {
+                if (compressedExplorerFragment.showSize)
+                    holder.txtDesc.setText(Formatter.formatFileSize(context, rowItem.getSize()));
+                holder.txtTitle.setText(rowItem.getName().substring(rowItem.getName().lastIndexOf("/") + 1));
+                if (compressedExplorerFragment.coloriseIcons) {
+                    ColorUtils.colorizeIcons(context, Icons.getTypeOfFile(rowItem.getName()),
+                            gradientDrawable, Color.parseColor(compressedExplorerFragment.iconskin));
+                } else gradientDrawable.setColor(Color.parseColor(compressedExplorerFragment.iconskin));
+            }
+        }
+
+        holder.rl.setOnLongClickListener(view -> {
+            if (rowItem.getType() != CompressedObjectParcelable.TYPE_GOBACK) {
+                toggleChecked(position, holder.checkImageView);
+            }
+            return true;
+        });
+        holder.genericIcon.setOnClickListener(view -> {
+            if (rowItem.getType() != CompressedObjectParcelable.TYPE_GOBACK) {
+                toggleChecked(position, holder.checkImageView);
+            }
+        });
+        if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
+            holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
+        } else {
+            holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
+        }
+        holder.rl.setSelected(false);
+        if (itemsChecked[position]) {
+            //holder.genericIcon.setImageDrawable(compressedExplorerFragment.getResources().getDrawable(R.drawable.abc_ic_cab_done_holo_dark));
+            holder.checkImageView.setVisibility(View.VISIBLE);
+            gradientDrawable.setColor(Utils.getColor(context, R.color.goback_item));
+            holder.rl.setSelected(true);
+        } else holder.checkImageView.setVisibility(View.INVISIBLE);
+
+        holder.rl.setOnClickListener(p1 -> {
+            if (rowItem.getType() == CompressedObjectParcelable.TYPE_GOBACK)
+                compressedExplorerFragment.goBack();
+            else {
+                if (compressedExplorerFragment.selection) {
+                    toggleChecked(position, holder.checkImageView);
+                } else {
+                    final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
+                    if (rowItem.isDirectory())
+                        stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
+
+                    if (rowItem.isDirectory()) {
+                        compressedExplorerFragment.changePath(stringBuilder.toString());
+                    } else {
+                        String fileName = compressedExplorerFragment.compressedFile.getName().substring(0,
+                                compressedExplorerFragment.compressedFile.getName().lastIndexOf("."));
+                        String archiveCacheDirPath = compressedExplorerFragment.getActivity().getExternalCacheDir().getPath() +
+                                "/" + fileName;
+
+                        HybridFileParcelable file = new HybridFileParcelable(archiveCacheDirPath + "/"
+                                + rowItem.getName().replaceAll("\\\\", "/"));
+                        file.setMode(OpenMode.FILE);
+                        // this file will be opened once service finishes up it's extraction
+                        compressedExplorerFragment.files.add(file);
+                        // setting flag for binder to know
+                        compressedExplorerFragment.isOpen = true;
+
+                        Toast.makeText(compressedExplorerFragment.getContext(),
+                                compressedExplorerFragment.getContext().getResources().getString(R.string.please_wait),
+                                Toast.LENGTH_SHORT).show();
+                        compressedInterface.decompress(compressedExplorerFragment.getActivity().getExternalCacheDir().getPath(),
+                                new String[]{rowItem.getName()});
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    public int getItemCount() {
+        return items.size();
+    }
+
+    @Override
+    public void onViewDetachedFromWindow(RecyclerView.ViewHolder holder) {
+        super.onViewAttachedToWindow(holder);
+        ((CompressedItemViewHolder) holder).rl.clearAnimation();
+    }
+
+    @Override
+    public boolean onFailedToRecycleView(RecyclerView.ViewHolder holder) {
+        ((CompressedItemViewHolder) holder).rl.clearAnimation();
+        return super.onFailedToRecycleView(holder);
+    }
+
+    private boolean isPositionHeader(int position) {
+        return false;// TODO:
+    }
+
+}
+
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java
index a397d2c3d..f6ffa1f3e 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/HiddenAdapter.java
@@ -7,20 +7,18 @@ import android.support.v7.widget.RecyclerView;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.TextView;
 
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.adapters.holders.HiddenViewHolder;
+import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
 import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
-import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.files.FileUtils;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -29,16 +27,15 @@ import java.util.ArrayList;
 /**
  * Created by Arpit on 16-11-2014 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com>
  */
-public class HiddenAdapter extends RecyclerView.Adapter<HiddenAdapter.ViewHolder> {
+public class HiddenAdapter extends RecyclerView.Adapter<HiddenViewHolder> {
 
     private SharedPreferences sharedPrefs;
     private MainFragment context;
     private Context c;
-    public ArrayList<HybridFile> items;
+    private ArrayList<HybridFile> items;
     private MaterialDialog materialDialog;
     private boolean hide;
     private DataUtils dataUtils = DataUtils.getInstance();
-    ///	public HashMap<Integer, Boolean> myChecked = new HashMap<Integer, Boolean>();
 
     public HiddenAdapter(Context context, MainFragment mainFrag, SharedPreferences sharedPreferences,
                          ArrayList<HybridFile> items, MaterialDialog materialDialog, boolean hide) {
@@ -51,72 +48,55 @@ public class HiddenAdapter extends RecyclerView.Adapter<HiddenAdapter.ViewHolder
     }
 
     @Override
-    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
+    public HiddenViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
         LayoutInflater mInflater = (LayoutInflater) c
                 .getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
         View view = mInflater.inflate(R.layout.bookmarkrow, parent, false);
 
-        return new ViewHolder(view);
+        return new HiddenViewHolder(view);
     }
 
     @Override
-    public void onBindViewHolder(ViewHolder holder, int position) {
-        holder.render(position, items.get(position));
-    }
-
-    class ViewHolder extends RecyclerView.ViewHolder {
-        private ImageButton image;
-        private TextView txtTitle;
-        private TextView txtDesc;
-        private LinearLayout row;
+    public void onBindViewHolder(HiddenViewHolder holder, int position) {
+        HybridFile file = items.get(position);
 
-        ViewHolder(View view) {
-            super(view);
+        holder.getTxtTitle().setText(file.getName());
+        String a = file.getReadablePath(file.getPath());
+        holder.getTxtDesc().setText(a);
 
-            txtTitle = (TextView) view.findViewById(R.id.text1);
-            image = (ImageButton) view.findViewById(R.id.delete_button);
-            txtDesc = (TextView) view.findViewById(R.id.text2);
-            row = (LinearLayout) view.findViewById(R.id.bookmarkrow);
+        if (hide) {
+            holder.getImage().setVisibility(View.GONE);
         }
 
-        void render(final int position, final HybridFile file) {
-            txtTitle.setText(file.getName());
-            String a = file.getReadablePath(file.getPath());
-            txtDesc.setText(a);
-
-            if (hide)
-                image.setVisibility(View.GONE);
-
-            // TODO: move the listeners to the constructor
-            image.setOnClickListener(view -> {
-                if (!file.isSmb() && file.isDirectory()) {
-                    ArrayList<HybridFileParcelable> a1 = new ArrayList<>();
-                    HybridFileParcelable baseFile = new HybridFileParcelable(items.get(position).getPath() + "/.nomedia");
-                    baseFile.setMode(OpenMode.FILE);
-                    a1.add(baseFile);
-                    new DeleteTask(context.getActivity().getContentResolver(), c).execute((a1));
-                }
-                dataUtils.removeHiddenFile(items.get(position).getPath());
-                items.remove(items.get(position));
-                notifyDataSetChanged();
-            });
-            row.setOnClickListener(view -> {
-                materialDialog.dismiss();
-                new Thread(() -> {
-                    if (file.isDirectory()) {
+        // TODO: move the listeners to the constructor
+        holder.getImage().setOnClickListener(view -> {
+            if (!file.isSmb() && file.isDirectory()) {
+                ArrayList<HybridFileParcelable> a1 = new ArrayList<>();
+                HybridFileParcelable baseFile = new HybridFileParcelable(items.get(position).getPath() + "/.nomedia");
+                baseFile.setMode(OpenMode.FILE);
+                a1.add(baseFile);
+                new DeleteTask(context.getActivity().getContentResolver(), c).execute((a1));
+            }
+            dataUtils.removeHiddenFile(items.get(position).getPath());
+            items.remove(items.get(position));
+            notifyDataSetChanged();
+        });
+        holder.getRow().setOnClickListener(view -> {
+            materialDialog.dismiss();
+            new Thread(() -> {
+                if (file.isDirectory()) {
+                    context.getActivity().runOnUiThread(() -> {
+                        context.loadlist(file.getPath(), false, OpenMode.UNKNOWN);
+                    });
+                } else {
+                    if (!file.isSmb()) {
                         context.getActivity().runOnUiThread(() -> {
-                            context.loadlist(file.getPath(), false, OpenMode.UNKNOWN);
+                            FileUtils.openFile(new File(file.getPath()), (MainActivity) context.getActivity(), sharedPrefs);
                         });
-                    } else {
-                        if (!file.isSmb()) {
-                            context.getActivity().runOnUiThread(() -> {
-                                FileUtils.openFile(new File(file.getPath()), (MainActivity) context.getActivity(), sharedPrefs);
-                            });
-                        }
                     }
-                }).start();
-            });
-        }
+                }
+            }).start();
+        });
     }
 
     public void updateDialog(MaterialDialog dialog) {
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/ZipExplorerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/ZipExplorerAdapter.java
deleted file mode 100644
index f6af0eac9..000000000
--- a/app/src/main/java/com/amaze/filemanager/adapters/ZipExplorerAdapter.java
+++ /dev/null
@@ -1,430 +0,0 @@
-package com.amaze.filemanager.adapters;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.graphics.Color;
-import android.graphics.drawable.Drawable;
-import android.graphics.drawable.GradientDrawable;
-import android.os.Build;
-import android.support.v7.widget.RecyclerView;
-import android.text.format.Formatter;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.Toast;
-
-import com.amaze.filemanager.R;
-import com.amaze.filemanager.adapters.holders.CompressedItemViewHolder;
-import com.amaze.filemanager.asynchronous.services.ExtractService;
-import com.amaze.filemanager.filesystem.HybridFileParcelable;
-import com.amaze.filemanager.fragments.ZipExplorerFragment;
-import com.amaze.filemanager.ui.ZipObjectParcelable;
-import com.amaze.filemanager.ui.icons.Icons;
-import com.amaze.filemanager.ui.views.CircleGradientDrawable;
-import com.amaze.filemanager.utils.OpenMode;
-import com.amaze.filemanager.utils.ServiceWatcherUtil;
-import com.amaze.filemanager.utils.Utils;
-import com.amaze.filemanager.utils.color.ColorUtils;
-import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
-import com.amaze.filemanager.utils.theme.AppTheme;
-import com.github.junrar.rarfile.FileHeader;
-
-import java.util.ArrayList;
-
-/**
- * Created by Arpit on 25-01-2015 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
- */
-public class ZipExplorerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
-
-    private static final int TYPE_HEADER = 0, TYPE_ITEM = 1;
-
-    public boolean stoppedAnimation = false;
-
-    private Context context;
-    private UtilitiesProviderInterface utilsProvider;
-    private Drawable folder;
-    private ArrayList<FileHeader> enterRar;
-    private ArrayList<ZipObjectParcelable> enterZip;
-    private ZipExplorerFragment zipExplorerFragment;
-    private LayoutInflater mInflater;
-    private boolean[] itemsChecked;
-    private boolean zipMode = false;  // flag specify whether adapter is based on a Rar file or not
-    private int offset = 0;
-
-    public ZipExplorerAdapter(Context c, UtilitiesProviderInterface utilsProvider,
-                              ArrayList<ZipObjectParcelable> enterZip, ArrayList<FileHeader> enterRar,
-                              ZipExplorerFragment zipExplorerFragment, boolean isZip) {
-        this.utilsProvider = utilsProvider;
-
-        zipMode = isZip;
-
-        if(zipMode) this.enterZip = enterZip;
-        else this.enterRar = enterRar;
-
-        itemsChecked = new boolean[zipMode? enterZip.size():enterRar.size()];
-
-        context = c;
-        if (c == null) return;
-        folder = c.getResources().getDrawable(R.drawable.ic_grid_folder_new);
-        this.zipExplorerFragment = zipExplorerFragment;
-        mInflater = (LayoutInflater) c.getSystemService(Activity.LAYOUT_INFLATER_SERVICE);
-    }
-
-    public void toggleChecked(boolean check) {
-        int k = 0;
-
-        for (int i = k; i < (zipMode ? enterZip.size() : enterRar.size()); i++) {
-            itemsChecked[i] = check;
-            notifyItemChanged(i);
-        }
-    }
-
-    public ArrayList<Integer> getCheckedItemPositions() {
-        ArrayList<Integer> checkedItemPositions = new ArrayList<>();
-
-        for (int i = 0; i < itemsChecked.length; i++) {
-            if (itemsChecked[i]) {
-                (checkedItemPositions).add(i);
-            }
-        }
-
-        return checkedItemPositions;
-    }
-
-    /**
-     * called as to toggle selection of any item in adapter
-     *
-     * @param position  the position of the item
-     * @param imageView the circular {@link CircleGradientDrawable} that is to be animated
-     */
-    private void toggleChecked(int position, ImageView imageView) {
-        zipExplorerFragment.stopAnim();
-        stoppedAnimation = true;
-
-        Animation animation;
-        if (itemsChecked[position]) {
-            animation = AnimationUtils.loadAnimation(context, R.anim.check_out);
-        } else {
-            animation = AnimationUtils.loadAnimation(context, R.anim.check_in);
-        }
-
-        if (imageView != null) {
-            imageView.setAnimation(animation);
-        } else {
-            // TODO: we don't have the check icon object probably because of config change
-        }
-
-        itemsChecked[position] = !itemsChecked[position];
-
-        notifyDataSetChanged();
-        if (!zipExplorerFragment.selection || zipExplorerFragment.mActionMode == null) {
-            zipExplorerFragment.selection = true;
-            /*zipExplorerFragment.mActionMode = zipExplorerFragment.getActivity().startActionMode(
-                   zipExplorerFragment.mActionModeCallback);*/
-            zipExplorerFragment.mActionMode = zipExplorerFragment.mainActivity.getAppbar().getToolbar().startActionMode(zipExplorerFragment.mActionModeCallback);
-        }
-        zipExplorerFragment.mActionMode.invalidate();
-        if (getCheckedItemPositions().size() == 0) {
-            zipExplorerFragment.selection = false;
-            zipExplorerFragment.mActionMode.finish();
-            zipExplorerFragment.mActionMode = null;
-        }
-    }
-
-    private void animate(CompressedItemViewHolder holder) {
-        holder.rl.clearAnimation();
-        Animation localAnimation = AnimationUtils.loadAnimation(zipExplorerFragment.getActivity(), R.anim.fade_in_top);
-        localAnimation.setStartOffset(this.offset);
-        holder.rl.startAnimation(localAnimation);
-        this.offset = (30 + this.offset);
-    }
-
-    public void generateRar(ArrayList<FileHeader> arrayList) {
-        offset = 0;
-        stoppedAnimation = false;
-        enterRar = arrayList;
-        notifyDataSetChanged();
-        itemsChecked = new boolean[enterRar.size()];
-    }
-
-    public void generateZip(ArrayList<ZipObjectParcelable> arrayList) {
-        offset = 0;
-        stoppedAnimation = false;
-        enterZip = arrayList;
-        notifyDataSetChanged();
-        itemsChecked = new boolean[enterZip.size()];
-    }
-
-    @Override
-    public int getItemViewType(int position) {
-        if (isPositionHeader(position))
-            return TYPE_HEADER;
-
-        return TYPE_ITEM;
-    }
-
-    @Override
-    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        if (viewType == TYPE_HEADER) {
-            View v = mInflater.inflate(R.layout.rowlayout, parent, false);
-            v.findViewById(R.id.picture_icon).setVisibility(View.INVISIBLE);
-            return new CompressedItemViewHolder(v);
-        } else if(viewType == TYPE_ITEM) {
-            View v = mInflater.inflate(R.layout.rowlayout, parent, false);
-            CompressedItemViewHolder vh = new CompressedItemViewHolder(v);
-            ImageButton about = (ImageButton) v.findViewById(R.id.properties);
-            about.setVisibility(View.INVISIBLE);
-            return vh;
-        } else {
-            throw new IllegalStateException();
-        }
-    }
-
-    @Override
-    public void onBindViewHolder(final RecyclerView.ViewHolder vholder, int position1) {
-        if (!stoppedAnimation) {
-            animate((CompressedItemViewHolder) vholder);
-        }
-
-        if (zipMode) onBindViewZip((CompressedItemViewHolder) vholder, position1);
-        else onBindViewHolderRar((CompressedItemViewHolder) vholder, position1);
-    }
-
-    private void onBindViewZip(final CompressedItemViewHolder holder, final int position) {
-        final ZipObjectParcelable rowItem = enterZip.get(position);
-        GradientDrawable gradientDrawable = (GradientDrawable) holder.genericIcon.getBackground();
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-            holder.checkImageView.setBackground(new CircleGradientDrawable(zipExplorerFragment.accentColor,
-                    utilsProvider.getAppTheme(), zipExplorerFragment.getResources().getDisplayMetrics()));
-        } else
-            holder.checkImageView.setBackgroundDrawable(new CircleGradientDrawable(zipExplorerFragment.accentColor,
-                    utilsProvider.getAppTheme(), zipExplorerFragment.getResources().getDisplayMetrics()));
-
-        if (rowItem.getEntry() == null) {
-            holder.genericIcon.setImageDrawable(zipExplorerFragment.getResources().getDrawable(R.drawable.ic_arrow_left_white_24dp));
-            gradientDrawable.setColor(Utils.getColor(context, R.color.goback_item));
-            holder.txtTitle.setText("..");
-            holder.txtDesc.setText("");
-            holder.date.setText(R.string.goback);
-        } else {
-            holder.genericIcon.setImageDrawable(Icons.loadMimeIcon(rowItem.getName(), false, context.getResources()));
-            final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
-            if (zipExplorerFragment.showLastModified)
-                holder.date.setText(Utils.getDate(rowItem.getTime(), zipExplorerFragment.year));
-            if (rowItem.isDirectory()) {
-                holder.genericIcon.setImageDrawable(folder);
-                gradientDrawable.setColor(Color.parseColor(zipExplorerFragment.iconskin));
-                if (stringBuilder.toString().length() > 0) {
-                    stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
-                    try {
-                        holder.txtTitle.setText(stringBuilder.toString().substring(stringBuilder.toString().lastIndexOf("/") + 1));
-                    } catch (Exception e) {
-                        holder.txtTitle.setText(rowItem.getName().substring(0, rowItem.getName().lastIndexOf("/")));
-                    }
-                }
-            } else {
-                if (zipExplorerFragment.showSize)
-                    holder.txtDesc.setText(Formatter.formatFileSize(context, rowItem.getSize()));
-                holder.txtTitle.setText(rowItem.getName().substring(rowItem.getName().lastIndexOf("/") + 1));
-                if (zipExplorerFragment.coloriseIcons) {
-                    ColorUtils.colorizeIcons(context, Icons.getTypeOfFile(rowItem.getName()),
-                            gradientDrawable, Color.parseColor(zipExplorerFragment.iconskin));
-                } else gradientDrawable.setColor(Color.parseColor(zipExplorerFragment.iconskin));
-            }
-        }
-
-        holder.rl.setOnLongClickListener(view -> {
-            if (rowItem.getEntry() != null) {
-                toggleChecked(position, holder.checkImageView);
-            }
-            return true;
-        });
-        holder.genericIcon.setOnClickListener(view -> {
-            if (rowItem.getEntry() != null) {
-                toggleChecked(position, holder.checkImageView);
-            }
-        });
-        if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
-            holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
-        } else {
-            holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
-        }
-        holder.rl.setSelected(false);
-        if (itemsChecked[position]) {
-            //holder.genericIcon.setImageDrawable(zipExplorerFragment.getResources().getDrawable(R.drawable.abc_ic_cab_done_holo_dark));
-            holder.checkImageView.setVisibility(View.VISIBLE);
-            gradientDrawable.setColor(Utils.getColor(context, R.color.goback_item));
-            holder.rl.setSelected(true);
-        } else holder.checkImageView.setVisibility(View.INVISIBLE);
-
-        holder.rl.setOnClickListener(p1 -> {
-            if (rowItem.getEntry() == null)
-                zipExplorerFragment.goBack();
-            else {
-                if (zipExplorerFragment.selection) {
-                    toggleChecked(position, holder.checkImageView);
-                } else {
-                    final StringBuilder stringBuilder = new StringBuilder(rowItem.getName());
-                    if (rowItem.isDirectory())
-                        stringBuilder.deleteCharAt(rowItem.getName().length() - 1);
-
-                    if (rowItem.isDirectory()) {
-                        zipExplorerFragment.changeZipPath(stringBuilder.toString());
-                    } else {
-                        String fileName = zipExplorerFragment.realZipFile.getName().substring(0,
-                                zipExplorerFragment.realZipFile.getName().lastIndexOf("."));
-                        String archiveCacheDirPath = zipExplorerFragment.getActivity().getExternalCacheDir().getPath() +
-                                "/" + fileName;
-
-                        HybridFileParcelable file = new HybridFileParcelable(archiveCacheDirPath + "/"
-                                + rowItem.getName().replaceAll("\\\\", "/"));
-                        file.setMode(OpenMode.FILE);
-                        // this file will be opened once service finishes up it's extraction
-                        zipExplorerFragment.files.add(file);
-                        // setting flag for binder to know
-                        zipExplorerFragment.isOpen = true;
-
-                        Toast.makeText(zipExplorerFragment.getContext(),
-                                zipExplorerFragment.getContext().getResources().getString(R.string.please_wait),
-                                Toast.LENGTH_SHORT).show();
-                        Intent intent = new Intent(zipExplorerFragment.getContext(), ExtractService.class);
-                        ArrayList<String> a = new ArrayList<>();
-
-                        // adding name of entry to extract from zip, before opening it
-                        a.add(rowItem.getName());
-                        intent.putExtra(ExtractService.KEY_PATH_ZIP, zipExplorerFragment.realZipFile.getPath());
-                        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, a);
-                        intent.putExtra(ExtractService.KEY_PATH_EXTRACT,
-                                zipExplorerFragment.getActivity().getExternalCacheDir().getPath());
-                        ServiceWatcherUtil.runService(zipExplorerFragment.getContext(), intent);
-                    }
-                }
-            }
-        });
-    }
-
-    private void onBindViewHolderRar(final CompressedItemViewHolder holder, int position) {
-        if (position < 0) return;
-        final FileHeader rowItem = enterRar.get(position);
-
-        GradientDrawable gradientDrawable = (GradientDrawable) holder.genericIcon.getBackground();
-
-        holder.genericIcon.setImageDrawable(Icons.loadMimeIcon(rowItem.getFileNameString(), false, context.getResources()));
-        holder.txtTitle.setText(rowItem.getFileNameString().substring(rowItem.getFileNameString().lastIndexOf("\\") + 1));
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-            holder.checkImageView.setBackground(new CircleGradientDrawable(zipExplorerFragment.accentColor,
-                    utilsProvider.getAppTheme(), zipExplorerFragment.getResources().getDisplayMetrics()));
-        } else
-            holder.checkImageView.setBackgroundDrawable(new CircleGradientDrawable(zipExplorerFragment.accentColor,
-                    utilsProvider.getAppTheme(), zipExplorerFragment.getResources().getDisplayMetrics()));
-
-        if (rowItem.isDirectory()) {
-            holder.genericIcon.setImageDrawable(folder);
-            gradientDrawable.setColor(Color.parseColor(zipExplorerFragment.iconskin));
-        } else {
-            if (zipExplorerFragment.coloriseIcons) {
-                ColorUtils.colorizeIcons(context, Icons.getTypeOfFile(rowItem.getFileNameString()),
-                        gradientDrawable, Color.parseColor(zipExplorerFragment.iconskin));
-            } else gradientDrawable.setColor(Color.parseColor(zipExplorerFragment.iconskin));
-        }
-
-        holder.rl.setOnLongClickListener(view -> {
-            toggleChecked(holder.getAdapterPosition(), holder.checkImageView);
-            return true;
-        });
-        holder.genericIcon.setOnClickListener(view -> {
-            toggleChecked(holder.getAdapterPosition(), holder.checkImageView);
-        });
-        if (utilsProvider.getAppTheme().equals(AppTheme.LIGHT)) {
-            holder.rl.setBackgroundResource(R.drawable.safr_ripple_white);
-        } else {
-            holder.rl.setBackgroundResource(R.drawable.safr_ripple_black);
-        }
-        holder.rl.setSelected(false);
-        if (itemsChecked[position]) {
-            //holder.genericIcon.setImageDrawable(zipExplorerFragment.getResources().getDrawable(R.drawable.abc_ic_cab_done_holo_dark));
-            holder.checkImageView.setVisibility(View.VISIBLE);
-            gradientDrawable.setColor(Utils.getColor(context, R.color.goback_item));
-            holder.rl.setSelected(true);
-        } else holder.checkImageView.setVisibility(View.INVISIBLE);
-        holder.rl.setOnClickListener(p1 -> {
-            if (zipExplorerFragment.selection) {
-                toggleChecked(holder.getAdapterPosition(), holder.checkImageView);
-            } else {
-                if (rowItem.isDirectory()) {
-                    zipExplorerFragment.elementsRar.clear();
-                    zipExplorerFragment.changeRarPath(rowItem.getFileNameString().replace("\\", "/"));
-                } else {
-                    String fileName = zipExplorerFragment.realZipFile.getName().substring(0,
-                            zipExplorerFragment.realZipFile.getName().lastIndexOf("."));
-                    String archiveCacheDirPath = zipExplorerFragment.getActivity().getExternalCacheDir().getPath() +
-                            "/" + fileName;
-
-                    HybridFileParcelable file1 = new HybridFileParcelable(archiveCacheDirPath + "/"
-                            + rowItem.getFileNameString().replaceAll("\\\\", "/"));
-                    file1.setMode(OpenMode.FILE);
-
-                    // this file will be opened once service finishes up it's extraction
-                    zipExplorerFragment.files.add(file1);
-                    // setting flag for binder to know
-                    zipExplorerFragment.isOpen = true;
-
-                    Toast.makeText(zipExplorerFragment.getContext(),
-                            zipExplorerFragment.getContext().getResources().getString(R.string.please_wait),
-                            Toast.LENGTH_SHORT).show();
-                    Intent intent = new Intent(zipExplorerFragment.getContext(), ExtractService.class);
-                    ArrayList<String> a = new ArrayList<>();
-
-                    // adding name of entry to extract from zip, before opening it
-                    a.add(rowItem.getFileNameString());
-                    intent.putExtra(ExtractService.KEY_PATH_ZIP, zipExplorerFragment.realZipFile.getPath());
-                    intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, a);
-                    intent.putExtra(ExtractService.KEY_PATH_EXTRACT,
-                            zipExplorerFragment.getActivity().getExternalCacheDir().getPath());
-                    ServiceWatcherUtil.runService(zipExplorerFragment.getContext(), intent);
-                }
-            }
-        });
-    }
-
-    @Override
-    public int getItemCount() {
-        return zipMode ? enterZip.size() : enterRar.size();
-    }
-
-    @Override
-    public void onViewDetachedFromWindow(RecyclerView.ViewHolder holder) {
-        super.onViewAttachedToWindow(holder);
-        ((CompressedItemViewHolder) holder).rl.clearAnimation();
-    }
-
-    @Override
-    public boolean onFailedToRecycleView(RecyclerView.ViewHolder holder) {
-        ((CompressedItemViewHolder) holder).rl.clearAnimation();
-        return super.onFailedToRecycleView(holder);
-    }
-
-    private boolean isPositionHeader(int position) {
-        return false;// TODO:
-    }
-
-    private FileHeader headerRequired(FileHeader rowItem) {
-        if(zipExplorerFragment.archive != null) {
-            for (FileHeader fileHeader : zipExplorerFragment.archive.getFileHeaders()) {
-                String req = fileHeader.getFileNameString();
-                if (rowItem.getFileNameString().equals(req))
-                    return fileHeader;
-            }
-        }
-        return null;
-    }
-
-}
-
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/holders/HiddenViewHolder.java b/app/src/main/java/com/amaze/filemanager/adapters/holders/HiddenViewHolder.java
new file mode 100644
index 000000000..20658fa3b
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/adapters/holders/HiddenViewHolder.java
@@ -0,0 +1,46 @@
+package com.amaze.filemanager.adapters.holders;
+
+import android.support.v7.widget.RecyclerView;
+import android.view.View;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.amaze.filemanager.R;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 18:38.
+ */
+
+public class HiddenViewHolder extends RecyclerView.ViewHolder {
+    private final ImageButton image;
+    private final TextView txtTitle;
+    private final TextView txtDesc;
+    private final LinearLayout row;
+
+    public HiddenViewHolder(View view) {
+        super(view);
+
+        txtTitle = (TextView) view.findViewById(R.id.text1);
+        image = (ImageButton) view.findViewById(R.id.delete_button);
+        txtDesc = (TextView) view.findViewById(R.id.text2);
+        row = (LinearLayout) view.findViewById(R.id.bookmarkrow);
+    }
+
+    public ImageButton getImage() {
+        return image;
+    }
+
+    public TextView getTxtTitle() {
+        return txtTitle;
+    }
+
+    public TextView getTxtDesc() {
+        return txtDesc;
+    }
+
+    public LinearLayout getRow() {
+        return row;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
index 08b4d995f..3806eac60 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
@@ -34,7 +34,7 @@ import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.exceptions.RootNotPermittedException;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
-import com.amaze.filemanager.fragments.ZipExplorerFragment;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.cloud.CloudUtil;
@@ -50,7 +50,7 @@ public class DeleteTask extends AsyncTask<ArrayList<HybridFileParcelable>, Strin
     private ArrayList<HybridFileParcelable> files;
     private Context cd;
     private boolean rootMode;
-    private ZipExplorerFragment zipExplorerFragment;
+    private CompressedExplorerFragment compressedExplorerFragment;
     private DataUtils dataUtils = DataUtils.getInstance();
 
     public DeleteTask(ContentResolver c, Context cd) {
@@ -58,10 +58,10 @@ public class DeleteTask extends AsyncTask<ArrayList<HybridFileParcelable>, Strin
         rootMode = PreferenceManager.getDefaultSharedPreferences(cd).getBoolean("rootmode", false);
     }
 
-    public DeleteTask(ContentResolver c, Context cd, ZipExplorerFragment zipExplorerFragment) {
+    public DeleteTask(ContentResolver c, Context cd, CompressedExplorerFragment compressedExplorerFragment) {
         this.cd = cd;
         rootMode = PreferenceManager.getDefaultSharedPreferences(cd).getBoolean("rootmode", false);
-        this.zipExplorerFragment = zipExplorerFragment;
+        this.compressedExplorerFragment = compressedExplorerFragment;
     }
 
     @Override
@@ -170,12 +170,12 @@ public class DeleteTask extends AsyncTask<ArrayList<HybridFileParcelable>, Strin
 
         if (!b) {
             Toast.makeText(cd, cd.getResources().getString(R.string.error), Toast.LENGTH_SHORT).show();
-        } else if (zipExplorerFragment ==null) {
+        } else if (compressedExplorerFragment ==null) {
             Toast.makeText(cd, cd.getResources().getString(R.string.done), Toast.LENGTH_SHORT).show();
         }
 
-        if (zipExplorerFragment !=null) {
-            zipExplorerFragment.files.clear();
+        if (compressedExplorerFragment !=null) {
+            compressedExplorerFragment.files.clear();
         }
     }
 
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
index 49bcecc89..f06de3ee9 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
@@ -32,7 +32,6 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.exceptions.CloudPluginException;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
@@ -56,8 +55,8 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.Date;
+import java.util.LinkedList;
 
 import jcifs.smb.SmbAuthException;
 import jcifs.smb.SmbException;
@@ -376,7 +375,7 @@ public class LoadFilesListTask extends AsyncTask<Void, Void, Pair<OpenMode, Arra
 
     private ArrayList<LayoutElementParcelable> listRecent() {
         UtilsHandler utilsHandler = new UtilsHandler(c);
-        final ArrayList<String> paths = utilsHandler.getHistoryList();
+        final LinkedList<String> paths = utilsHandler.getHistoryLinkedList();
         ArrayList<LayoutElementParcelable> songs = new ArrayList<>();
         for (String f : paths) {
             if (!f.equals("/")) {
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/RarHelperTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/RarHelperTask.java
index f4804193f..ceb1ffba5 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/RarHelperTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/RarHelperTask.java
@@ -1,9 +1,9 @@
 package com.amaze.filemanager.asynchronous.asynctasks;
 
-import android.content.Context;
 import android.os.AsyncTask;
-import android.support.v4.util.Pair;
 
+import com.amaze.filemanager.filesystem.compressed.RarHelper;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
 import com.amaze.filemanager.utils.OnAsyncTaskFinished;
 import com.github.junrar.Archive;
 import com.github.junrar.exception.RarException;
@@ -11,37 +11,41 @@ import com.github.junrar.rarfile.FileHeader;
 
 import java.io.File;
 import java.io.IOException;
-import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 
 /**
  * Created by Arpit on 25-01-2015 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
  */
-public class RarHelperTask extends AsyncTask<Void, Void, Pair<Archive, ArrayList<FileHeader>>> {
+public class RarHelperTask extends AsyncTask<Void, Void, ArrayList<CompressedObjectParcelable>> {
 
-    private WeakReference<Context> context;
     private String fileLocation;
     private String relativeDirectory;
-    private OnAsyncTaskFinished<Pair<Archive, ArrayList<FileHeader>>> onFinish;
+    private boolean createBackItem;
+    private OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish;
 
     /**
      * AsyncTask to load RAR file items.
      * @param realFileDirectory the location of the zip file
      * @param dir relativeDirectory to access inside the zip file
      */
-    public RarHelperTask(Context c, String realFileDirectory, String dir, OnAsyncTaskFinished<Pair<Archive, ArrayList<FileHeader>>> l) {
-        context = new WeakReference<>(c);
+    public RarHelperTask(String realFileDirectory, String dir, boolean goBack,
+                         OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> l) {
         fileLocation = realFileDirectory;
         relativeDirectory = dir;
+        createBackItem = goBack;
         onFinish = l;
     }
 
     @Override
-    protected Pair<Archive, ArrayList<FileHeader>> doInBackground(Void... params) {
+    protected ArrayList<CompressedObjectParcelable> doInBackground(Void... params) {
+        ArrayList<CompressedObjectParcelable> elements = new ArrayList<>();
+
         try {
-            ArrayList<FileHeader> elements = new ArrayList<>();
+            if (createBackItem) {
+                elements.add(0, new CompressedObjectParcelable());
+            }
+
             Archive zipfile = new Archive(new File(fileLocation));
             String relativeDirDiffSeparator = relativeDirectory.replace("/", "\\");
 
@@ -52,34 +56,22 @@ public class RarHelperTask extends AsyncTask<Void, Void, Pair<Archive, ArrayList
                         && name.substring(0, name.lastIndexOf("\\")).equals(relativeDirDiffSeparator);
 
                 if (isInBaseDir || isInRelativeDir) {
-                    elements.add(header);
+                    elements.add(new CompressedObjectParcelable(RarHelper.convertName(header), 0, header.getDataSize(), header.isDirectory()));
                 }
             }
-            Collections.sort(elements, new FileListSorter());
-            return new Pair<>(zipfile, elements);
+            Collections.sort(elements, new CompressedObjectParcelable.Sorter());
         } catch (RarException | IOException e) {
             e.printStackTrace();
-            return null;
         }
+
+        return elements;
     }
 
     @Override
-    protected void onPostExecute(Pair<Archive, ArrayList<FileHeader>> ArchivePairZipEntries) {
-        super.onPostExecute(ArchivePairZipEntries);
-        onFinish.onAsyncTaskFinished(ArchivePairZipEntries);
+    protected void onPostExecute(ArrayList<CompressedObjectParcelable> zipEntries) {
+        super.onPostExecute(zipEntries);
+        onFinish.onAsyncTaskFinished(zipEntries);
     }
 
-    private class FileListSorter implements Comparator<FileHeader> {
-        @Override
-        public int compare(FileHeader file1, FileHeader file2) {
-            if (file1.isDirectory() && !file2.isDirectory()) {
-                return -1;
-            } else if (file2.isDirectory() && !(file1).isDirectory()) {
-                return 1;
-            }
-
-            return file1.getFileNameString().compareToIgnoreCase(file2.getFileNameString());
-        }
-    }
 }
 
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ZipHelperTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ZipHelperTask.java
index 3a78a5d4a..c3d35a104 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ZipHelperTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ZipHelperTask.java
@@ -4,7 +4,7 @@ import android.content.Context;
 import android.net.Uri;
 import android.os.AsyncTask;
 
-import com.amaze.filemanager.ui.ZipObjectParcelable;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
 import com.amaze.filemanager.utils.OnAsyncTaskFinished;
 
 import java.io.File;
@@ -12,7 +12,6 @@ import java.io.IOException;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.Enumeration;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -21,47 +20,54 @@ import java.util.zip.ZipInputStream;
 /**
  * Created by Vishal on 11/23/2014 edited by Emmanuel Messulam<emmanuelbendavid@gmail.com>
  */
-public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<ZipObjectParcelable>> {
+public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<CompressedObjectParcelable>> {
 
     private WeakReference<Context> context;
     private Uri fileLocation;
     private String relativeDirectory;
-    private OnAsyncTaskFinished<ArrayList<ZipObjectParcelable>> onFinish;
+    private boolean createBackItem;
+    private OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish;
 
     /**
      * AsyncTask to load ZIP file items.
      * @param realFileDirectory the location of the zip file
      * @param dir relativeDirectory to access inside the zip file
      */
-    public ZipHelperTask(Context c, String realFileDirectory, String dir, OnAsyncTaskFinished<ArrayList<ZipObjectParcelable>> l) {
+    public ZipHelperTask(Context c, String realFileDirectory, String dir, boolean goback,
+                         OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> l) {
         context = new WeakReference<>(c);
         fileLocation = Uri.parse(realFileDirectory);
         relativeDirectory = dir;
+        createBackItem = goback;
         onFinish = l;
     }
 
     @Override
-    protected ArrayList<ZipObjectParcelable> doInBackground(Void... params) {
-        ArrayList<ZipObjectParcelable> elements = new ArrayList<>();
+    protected ArrayList<CompressedObjectParcelable> doInBackground(Void... params) {
+        ArrayList<CompressedObjectParcelable> elements = new ArrayList<>();
+
+        if (createBackItem) {
+            elements.add(0, new CompressedObjectParcelable());
+        }
 
         try {
-            ArrayList<ZipObjectParcelable> wholelist = new ArrayList<>();
+            ArrayList<CompressedObjectParcelable> wholelist = new ArrayList<>();
             if (new File(fileLocation.getPath()).canRead()) {
                 ZipFile zipfile = new ZipFile(fileLocation.getPath());
                 for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
                     ZipEntry entry = (ZipEntry) e.nextElement();
-                    wholelist.add(new ZipObjectParcelable(entry, entry.getTime(), entry.getSize(), entry.isDirectory()));
+                    wholelist.add(new CompressedObjectParcelable(entry.getName(), entry.getTime(), entry.getSize(), entry.isDirectory()));
                 }
             } else {
                 ZipInputStream zipfile1 = new ZipInputStream(context.get().getContentResolver().openInputStream(fileLocation));
                 for (ZipEntry entry = zipfile1.getNextEntry(); entry != null; entry = zipfile1.getNextEntry()) {
-                    wholelist.add(new ZipObjectParcelable(entry, entry.getTime(), entry.getSize(), entry.isDirectory()));
+                    wholelist.add(new CompressedObjectParcelable(entry.getName(), entry.getTime(), entry.getSize(), entry.isDirectory()));
                 }
             }
 
             ArrayList<String> strings = new ArrayList<>();
 
-            for (ZipObjectParcelable entry : wholelist) {
+            for (CompressedObjectParcelable entry : wholelist) {
                 File file = new File(entry.getName());
                 if (relativeDirectory == null || relativeDirectory.trim().length() == 0) {
                     String y = entry.getName();
@@ -69,13 +75,13 @@ public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<ZipObjectParc
                         y = y.substring(1, y.length());
                     if (file.getParent() == null || file.getParent().length() == 0 || file.getParent().equals("/")) {
                         if (!strings.contains(y)) {
-                            elements.add(new ZipObjectParcelable(new ZipEntry(y), entry.getTime(), entry.getSize(), entry.isDirectory()));
+                            elements.add(new CompressedObjectParcelable(y, entry.getTime(), entry.getSize(), entry.isDirectory()));
                             strings.add(y);
                         }
                     } else {
                         String path = y.substring(0, y.indexOf("/") + 1);
                         if (!strings.contains(path)) {
-                            ZipObjectParcelable zipObj = new ZipObjectParcelable(new ZipEntry(path), entry.getTime(), entry.getSize(), true);
+                            CompressedObjectParcelable zipObj = new CompressedObjectParcelable(path, entry.getTime(), entry.getSize(), true);
                             strings.add(path);
                             elements.add(zipObj);
                         }
@@ -87,7 +93,7 @@ public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<ZipObjectParc
 
                     if (file.getParent() != null && (file.getParent().equals(relativeDirectory) || file.getParent().equals("/" + relativeDirectory))) {
                         if (!strings.contains(y)) {
-                            elements.add(new ZipObjectParcelable(new ZipEntry(y), entry.getTime(), entry.getSize(), entry.isDirectory()));
+                            elements.add(new CompressedObjectParcelable(y, entry.getTime(), entry.getSize(), entry.isDirectory()));
                             strings.add(y);
                         }
                     } else {
@@ -97,7 +103,7 @@ public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<ZipObjectParc
                             int index = relativeDirectory.length() + 1 + path1.indexOf("/");
                             String path = y.substring(0, index + 1);
                             if (!strings.contains(path)) {
-                                ZipObjectParcelable zipObj = new ZipObjectParcelable(new ZipEntry(y.substring(0, index + 1)), entry.getTime(), entry.getSize(), true);
+                                CompressedObjectParcelable zipObj = new CompressedObjectParcelable(y.substring(0, index + 1), entry.getTime(), entry.getSize(), true);
                                 strings.add(path);
                                 elements.add(zipObj);
                             }
@@ -107,7 +113,7 @@ public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<ZipObjectParc
                 }
             }
 
-            Collections.sort(elements, new FileListSorter());
+            Collections.sort(elements, new CompressedObjectParcelable.Sorter());
         } catch (IOException e) {
             e.printStackTrace();
         }
@@ -116,22 +122,9 @@ public class ZipHelperTask extends AsyncTask<Void, Void, ArrayList<ZipObjectParc
     }
 
     @Override
-    protected void onPostExecute(ArrayList<ZipObjectParcelable> zipEntries) {
+    protected void onPostExecute(ArrayList<CompressedObjectParcelable> zipEntries) {
         super.onPostExecute(zipEntries);
         onFinish.onAsyncTaskFinished(zipEntries);
     }
 
-    private class FileListSorter implements Comparator<ZipObjectParcelable> {
-        @Override
-        public int compare(ZipObjectParcelable file1, ZipObjectParcelable file2) {
-            if (file1.isDirectory() && !file2.isDirectory()) {
-                return -1;
-            } else if (file2.isDirectory() && !(file1).isDirectory()) {
-                return 1;
-            }
-            return file1.getEntry().getName().compareToIgnoreCase(file2.getEntry().getName());
-        }
-
-    }
-
 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
index 8e9ceb057..0f822ef1c 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ExtractService.java
@@ -28,9 +28,8 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.AsyncTask;
 import android.os.Binder;
-import android.os.Bundle;
 import android.os.IBinder;
-import android.preference.PreferenceManager;
+import android.support.annotation.NonNull;
 import android.support.v4.app.NotificationCompat;
 import android.text.format.Formatter;
 import android.util.Log;
@@ -38,13 +37,14 @@ import android.util.Log;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.filesystem.FileUtil;
-import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.fragments.ProcessViewerFragment;
 import com.amaze.filemanager.utils.CopyDataParcelable;
-import com.amaze.filemanager.utils.files.GenericCopyUtil;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
+import com.amaze.filemanager.utils.application.AppConfig;
+import com.amaze.filemanager.utils.files.GenericCopyUtil;
 import com.github.junrar.Archive;
+import com.github.junrar.exception.RarException;
 import com.github.junrar.rarfile.FileHeader;
 
 import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
@@ -55,6 +55,7 @@ import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.zip.GZIPInputStream;
@@ -62,19 +63,13 @@ import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
 public class ExtractService extends Service {
 
-    Context cd;
+    Context context;
 
     // list of data packages,// to initiate chart in process viewer fragment
     private ArrayList<CopyDataParcelable> dataPackages = new ArrayList<>();
 
-    // total size of file, can change later
-    private long totalSize = 0L;
-
     private NotificationManager mNotifyManager;
     private NotificationCompat.Builder mBuilder;
-    // names of entries to be extracted
-    private ArrayList<String> entries = new ArrayList<>();
-    private String epath;
     private ProgressHandler progressHandler;
 
     public static final String KEY_PATH_ZIP = "zip";
@@ -85,29 +80,18 @@ public class ExtractService extends Service {
     @Override
     public void onCreate() {
         registerReceiver(receiver1, new IntentFilter(TAG_BROADCAST_EXTRACT_CANCEL));
-        cd = getApplicationContext();
+        context = getApplicationContext();
     }
 
     @Override
     public int onStartCommand(Intent intent, int flags, final int startId) {
-        Bundle b = new Bundle();
         String file = intent.getStringExtra(KEY_PATH_ZIP);
         String extractPath = intent.getStringExtra(KEY_PATH_EXTRACT);
+        String[] entries = intent.getStringArrayExtra(KEY_ENTRIES_ZIP);
 
-        if (extractPath != null) {
-            // a custom dynamic path to extract files to
-            epath = extractPath;
-        } else {
-
-            epath = PreferenceManager.getDefaultSharedPreferences(this).getString(KEY_PATH_EXTRACT, file);
-        }
         mNotifyManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
 
-        entries = intent.getStringArrayListExtra(KEY_ENTRIES_ZIP);
-
-        b.putString(KEY_PATH_ZIP, file);
-
-        totalSize = getTotalSize(file);
+        long totalSize = getTotalSize(file);
         progressHandler = new ProgressHandler(1, totalSize);
 
         progressHandler.setProgressListener((fileName, sourceFiles, sourceProgress, totalSize1, writtenSize, speed) -> {
@@ -118,14 +102,14 @@ public class ExtractService extends Service {
         notificationIntent.setAction(Intent.ACTION_MAIN);
         notificationIntent.putExtra(MainActivity.KEY_INTENT_PROCESS_VIEWER, true);
         PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
-        mBuilder = new NotificationCompat.Builder(cd);
+        mBuilder = new NotificationCompat.Builder(context);
         mBuilder.setContentIntent(pendingIntent);
         mBuilder.setContentTitle(getResources().getString(R.string.extracting))
                 .setContentText(new File(file).getName())
                 .setSmallIcon(R.drawable.ic_zip_box_grey600_36dp);
         startForeground(Integer.parseInt("123" + startId), mBuilder.build());
 
-        new DoWork().execute(b);
+        new DoWork(this, progressHandler, file, extractPath, entries).execute();
         return START_STICKY;
     }
 
@@ -169,13 +153,13 @@ public class ExtractService extends Service {
             float progressPercent = ((float) done / total) * 100;
             mBuilder.setProgress(100, Math.round(progressPercent), false);
             mBuilder.setOngoing(true);
-            mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(cd, done) + "/"
-                    + Formatter.formatFileSize(cd, total));
+            mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(context, done) + "/"
+                    + Formatter.formatFileSize(context, total));
             int id1 = Integer.parseInt("123" + id);
             mNotifyManager.notify(id1, mBuilder.build());
             if (progressPercent == 100 || total == 0) {
                 mBuilder.setContentTitle(getString(R.string.extract_complete));
-                mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(cd, total));
+                mBuilder.setContentText(fileName + " " + Formatter.formatFileSize(context, total));
                 mBuilder.setProgress(100, 100, false);
                 mBuilder.setOngoing(false);
                 mNotifyManager.notify(id1, mBuilder.build());
@@ -208,29 +192,72 @@ public class ExtractService extends Service {
         }
     }
 
-    public class DoWork extends AsyncTask<Bundle, Void, Integer> {
+    public static class DoWork extends AsyncTask<Void, Void, Void> {
 
-        long totalBytes = 0L;
+        private WeakReference<ExtractService> extractService;
+        private String[] entriesToExtract;
+        private String extractionPath, compressedPath;
+        private ProgressHandler progressHandler;
+        private long totalBytes = 0L;
         private ServiceWatcherUtil watcherUtil;
 
-        private void createDir(File dir) {
-            FileUtil.mkdir(dir, cd);
+
+        private DoWork(ExtractService extractService, ProgressHandler progressHandler, String cpath, String epath,
+                       String[] entries) {
+            this.extractService = new WeakReference<>(extractService);
+            this.progressHandler = progressHandler;
+            compressedPath = cpath;
+            extractionPath = epath;
+            entriesToExtract = entries;
+        }
+
+        @Override
+        protected Void doInBackground(Void... p) {
+            final Context context = this.extractService.get();
+            if(context == null) return null;
+
+            File f = new File(compressedPath);
+
+            if (!compressedPath.equals(extractionPath)) {// custom extraction path not set, extract at default path
+                extractionPath = f.getParent() + "/" + f.getName().substring(0, f.getName().lastIndexOf("."));
+            } else if (extractionPath.endsWith("/")) {
+                extractionPath = extractionPath + f.getName().substring(0, f.getName().lastIndexOf("."));
+            }
+
+            try {
+                String path = f.getPath().toLowerCase();
+                boolean isZip = path.endsWith(".zip") || path.endsWith(".jar") || path.endsWith(".apk");
+                boolean isTar = path.endsWith(".tar") || path.endsWith(".tar.gz");
+                boolean isRar = path.endsWith(".rar");
+
+                if (entriesToExtract != null && entriesToExtract.length != 0) {
+                    if (isZip) extract(context, f, extractionPath, entriesToExtract);
+                    else if (isRar) extractRar(context, f, extractionPath, entriesToExtract);
+                } else {
+                    if (isZip) extract(context, f, extractionPath);
+                    else if (isRar) extractRar(context, f, extractionPath);
+                    else if (isTar) extractTar(context, f, extractionPath);
+                }
+            } catch (IOException | RarException e) {
+                Log.e("amaze", "Error while extracting file " + compressedPath, e);
+                AppConfig.toast(context, context.getString(R.string.error));
+            }
+            return null;
         }
 
         /**
          * Method extracts {@link ZipEntry} from {@link ZipFile}
          *
-         * @param zipFile   zip file from which entries are to be extracted
+         * @param zipFile   zip file from which entriesToExtract are to be extracted
          * @param entry     zip entry that is to be extracted
          * @param outputDir output directory
-         * @throws Exception
          */
-        private void unzipEntry(ZipFile zipFile, ZipEntry entry, String outputDir)
-                throws Exception {
+        private void unzipEntry(@NonNull final Context context, ZipFile zipFile, ZipEntry entry, String outputDir)
+                throws IOException {
 
             if (entry.isDirectory()) {
                 // zip entry is a directory, return after creating new directory
-                createDir(new File(outputDir, entry.getName()));
+                FileUtil.mkdir(new File(outputDir, entry.getName()), context);
                 return;
             }
 
@@ -239,13 +266,13 @@ public class ExtractService extends Service {
             if (!outputFile.getParentFile().exists()) {
                 // creating directory if not already exists
 
-                createDir(outputFile.getParentFile());
+                FileUtil.mkdir(outputFile.getParentFile(), context);
             }
 
             BufferedInputStream inputStream = new BufferedInputStream(
                     zipFile.getInputStream(entry));
             BufferedOutputStream outputStream = new BufferedOutputStream(
-                    FileUtil.getOutputStream(outputFile, cd, 0));
+                    FileUtil.getOutputStream(outputFile, context, 0));
             try {
                 int len;
                 byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
@@ -260,23 +287,23 @@ public class ExtractService extends Service {
             }
         }
 
-        private void unzipRAREntry(Archive zipFile, FileHeader entry, String outputDir)
-                throws Exception {
+        private void unzipRAREntry(@NonNull final Context context, Archive zipFile, FileHeader entry, String outputDir)
+                throws RarException, IOException {
             String name = entry.getFileNameString();
             name = name.replaceAll("\\\\", "/");
             if (entry.isDirectory()) {
-                createDir(new File(outputDir, name));
+                FileUtil.mkdir(new File(outputDir, name), context);
                 return;
             }
             File outputFile = new File(outputDir, name);
             if (!outputFile.getParentFile().exists()) {
-                createDir(outputFile.getParentFile());
+                FileUtil.mkdir(outputFile.getParentFile(), context);
             }
             //	Log.i("Amaze", "Extracting: " + entry);
             BufferedInputStream inputStream = new BufferedInputStream(
                     zipFile.getInputStream(entry));
             BufferedOutputStream outputStream = new BufferedOutputStream(
-                    FileUtil.getOutputStream(outputFile, cd, entry.getFullUnpackSize()));
+                    FileUtil.getOutputStream(outputFile, context, entry.getFullUnpackSize()));
             try {
                 int len;
                 byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
@@ -285,29 +312,26 @@ public class ExtractService extends Service {
                     outputStream.write(buf, 0, len);
                     ServiceWatcherUtil.POSITION += len;
                 }
-            } catch (Exception e) {
-
-                throw new Exception();
             } finally {
                 outputStream.close();
                 inputStream.close();
             }
         }
 
-        private void unzipTAREntry(TarArchiveInputStream zipFileStream, TarArchiveEntry entry,
-                                   String outputDir) throws Exception {
+        private void unzipTAREntry(@NonNull final Context context, TarArchiveInputStream zipFileStream, TarArchiveEntry entry,
+                                   String outputDir) throws IOException {
             String name = entry.getName();
             if (entry.isDirectory()) {
-                createDir(new File(outputDir, name));
+                FileUtil.mkdir(new File(outputDir, name), context);
                 return;
             }
             File outputFile = new File(outputDir, name);
             if (!outputFile.getParentFile().exists()) {
-                createDir(outputFile.getParentFile());
+                FileUtil.mkdir(outputFile.getParentFile(), context);
             }
 
             BufferedOutputStream outputStream = new BufferedOutputStream(
-                    FileUtil.getOutputStream(outputFile, cd, entry.getRealSize()));
+                    FileUtil.getOutputStream(outputFile, context, entry.getRealSize()));
             try {
                 int len;
                 byte buf[] = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
@@ -316,9 +340,6 @@ public class ExtractService extends Service {
                     outputStream.write(buf, 0, len);
                     ServiceWatcherUtil.POSITION += len;
                 }
-            } catch (Exception e) {
-
-                throw new Exception();
             } finally {
                 outputStream.close();
             }
@@ -332,152 +353,122 @@ public class ExtractService extends Service {
          * @param entryNamesList  names of files to be extracted from the archive
          * @return
          */
-        private boolean extract(File archive, String destinationPath,
-                                ArrayList<String> entryNamesList) {
+        private void extract(@NonNull final Context context, File archive, String destinationPath,
+                                String[] entryNamesList) throws IOException {
 
             ArrayList<ZipEntry> entry1 = new ArrayList<>();
-            try {
-                ZipFile zipfile = new ZipFile(archive);
+            ZipFile zipfile = new ZipFile(archive);
 
-                // iterating archive elements to find file names that are to be extracted
-                for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
+            // iterating archive elements to find file names that are to be extracted
+            for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
 
-                    ZipEntry zipEntry = (ZipEntry) e.nextElement();
+                ZipEntry zipEntry = (ZipEntry) e.nextElement();
 
-                    for (String entry : entryNamesList) {
+                for (String entry : entryNamesList) {
 
-                        if (zipEntry.getName().contains(entry)) {
-                            // header to be extracted is atleast the entry path (may be more, when it is a directory)
-                            entry1.add(zipEntry);
-                        }
+                    if (zipEntry.getName().contains(entry)) {
+                        // header to be extracted is atleast the entry path (may be more, when it is a directory)
+                        entry1.add(zipEntry);
                     }
                 }
+            }
 
-                // get the total size of elements to be extracted
-                for (ZipEntry entry : entry1) {
-                    totalBytes += entry.getSize();
-                }
+            // get the total size of elements to be extracted
+            for (ZipEntry entry : entry1) {
+                totalBytes += entry.getSize();
+            }
 
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
 
-                setInitDataPackage(totalBytes, entry1.get(0).getName(), entryNamesList.size());
+            setInitDataPackage(totalBytes, entry1.get(0).getName(), entryNamesList.length);
 
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
 
-                int i = 0;
-                for (ZipEntry entry : entry1) {
-                    if (!progressHandler.getCancelled()) {
+            int i = 0;
+            for (ZipEntry entry : entry1) {
+                if (!progressHandler.getCancelled()) {
 
-                        progressHandler.setFileName(entry.getName());
-                        unzipEntry(zipfile, entry, destinationPath);
-                        progressHandler.setSourceFilesProcessed(++i);
-                    }
+                    progressHandler.setFileName(entry.getName());
+                    unzipEntry(context, zipfile, entry, destinationPath);
+                    progressHandler.setSourceFilesProcessed(++i);
                 }
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
             }
-
         }
 
-        private boolean extract(File archive, String destinationPath) {
-
-            try {
-                ArrayList<ZipEntry> arrayList = new ArrayList<>();
-                ZipFile zipfile = new ZipFile(archive);
-                for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
+        private void extract(@NonNull final Context context, File archive, String destinationPath) throws IOException {
+            ArrayList<ZipEntry> arrayList = new ArrayList<>();
+            ZipFile zipfile = new ZipFile(archive);
+            for (Enumeration e = zipfile.entries(); e.hasMoreElements(); ) {
 
-                    // adding all the elements to be extracted to an array list
-                    ZipEntry entry = (ZipEntry) e.nextElement();
-                    arrayList.add(entry);
-                }
+                // adding all the elements to be extracted to an array list
+                ZipEntry entry = (ZipEntry) e.nextElement();
+                arrayList.add(entry);
+            }
 
-                for (ZipEntry entry : arrayList) {
-                    // calculating size of compressed items
-                    totalBytes += entry.getSize();
-                }
+            for (ZipEntry entry : arrayList) {
+                // calculating size of compressed items
+                totalBytes += entry.getSize();
+            }
 
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
 
-                setInitDataPackage(totalBytes, arrayList.get(0).getName(), 1);
+            setInitDataPackage(totalBytes, arrayList.get(0).getName(), 1);
 
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
 
-                for (ZipEntry entry : arrayList) {
-                    if (!progressHandler.getCancelled()) {
+            for (ZipEntry entry : arrayList) {
+                if (!progressHandler.getCancelled()) {
 
-                        progressHandler.setFileName(entry.getName());
-                        unzipEntry(zipfile, entry, destinationPath);
-                    }
+                    progressHandler.setFileName(entry.getName());
+                    unzipEntry(context, zipfile, entry, destinationPath);
                 }
-                progressHandler.setSourceFilesProcessed(1);
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
             }
-
+            progressHandler.setSourceFilesProcessed(1);
         }
 
-        private boolean extractTar(File archive, String destinationPath) {
-
-            try {
-
-                ArrayList<TarArchiveEntry> archiveEntries = new ArrayList<>();
+        private void extractTar(@NonNull final Context context, File archive, String destinationPath) throws IOException {
+            ArrayList<TarArchiveEntry> archiveEntries = new ArrayList<>();
 
-                TarArchiveInputStream inputStream = createTarInputStream(archive);
+            TarArchiveInputStream inputStream = createTarInputStream(archive);
 
-                TarArchiveEntry tarArchiveEntry = inputStream.getNextTarEntry();
+            TarArchiveEntry tarArchiveEntry = inputStream.getNextTarEntry();
 
-                while (tarArchiveEntry != null) {
-                    archiveEntries.add(tarArchiveEntry);
-                    tarArchiveEntry = inputStream.getNextTarEntry();
-                }
+            while (tarArchiveEntry != null) {
+                archiveEntries.add(tarArchiveEntry);
+                tarArchiveEntry = inputStream.getNextTarEntry();
+            }
 
-                for (TarArchiveEntry entry : archiveEntries) {
-                    totalBytes += entry.getSize();
-                }
+            for (TarArchiveEntry entry : archiveEntries) {
+                totalBytes += entry.getSize();
+            }
 
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
 
-                setInitDataPackage(totalBytes, archiveEntries.get(0).getName(), 1);
+            setInitDataPackage(totalBytes, archiveEntries.get(0).getName(), 1);
 
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
 
-                inputStream = createTarInputStream(archive);
+            inputStream = createTarInputStream(archive);
 
-                for (TarArchiveEntry entry : archiveEntries) {
+            for (TarArchiveEntry entry : archiveEntries) {
 
-                    if (!progressHandler.getCancelled()) {
+                if (!progressHandler.getCancelled()) {
 
-                        inputStream.getNextTarEntry();
-                        progressHandler.setFileName(entry.getName());
-                        unzipTAREntry(inputStream, entry, destinationPath);
-                    }
+                    inputStream.getNextTarEntry();
+                    progressHandler.setFileName(entry.getName());
+                    unzipTAREntry(context, inputStream, entry, destinationPath);
                 }
-                progressHandler.setSourceFilesProcessed(1);
-
-                // operating finished
-                inputStream.close();
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
             }
+            progressHandler.setSourceFilesProcessed(1);
 
+            // operating finished
+            inputStream.close();
         }
 
         private TarArchiveInputStream createTarInputStream(File archive) throws IOException {
@@ -488,170 +479,116 @@ public class ExtractService extends Service {
             }
         }
 
-        private boolean extractRar(File archive, String destinationPath) {
+        private void extractRar(@NonNull final Context context, File archive, String destinationPath) throws IOException, RarException {
+            ArrayList<FileHeader> arrayList = new ArrayList<>();
+            Archive zipFile = new Archive(archive);
+            FileHeader fh = zipFile.nextFileHeader();
 
-            try {
-                ArrayList<FileHeader> arrayList = new ArrayList<>();
-                Archive zipFile = new Archive(archive);
-                FileHeader fh = zipFile.nextFileHeader();
+            while (fh != null) {
+                arrayList.add(fh);
+                fh = zipFile.nextFileHeader();
 
-                while (fh != null) {
-                    arrayList.add(fh);
-                    fh = zipFile.nextFileHeader();
-
-                }
+            }
 
-                for (FileHeader header : arrayList) {
-                    totalBytes += header.getFullUnpackSize();
-                }
+            for (FileHeader header : arrayList) {
+                totalBytes += header.getFullUnpackSize();
+            }
 
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
+            // setting total bytes calculated from zip entriesToExtract
+            progressHandler.setTotalSize(totalBytes);
 
-                setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), 1);
+            setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), 1);
 
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
 
-                for (FileHeader header : arrayList) {
+            for (FileHeader header : arrayList) {
 
-                    if (!progressHandler.getCancelled()) {
+                if (!progressHandler.getCancelled()) {
 
-                        progressHandler.setFileName(header.getFileNameString());
-                        unzipRAREntry(zipFile, header, destinationPath);
-                    }
+                    progressHandler.setFileName(header.getFileNameString());
+                    unzipRAREntry(context, zipFile, header, destinationPath);
                 }
-                progressHandler.setSourceFilesProcessed(1);
-
-                return true;
-            } catch (Exception e) {
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
             }
+            progressHandler.setSourceFilesProcessed(1);
         }
 
-        private boolean extractRar(File archive, String destinationPath, ArrayList<String> entries) {
-
-            try {
-
-                Archive rarFile = new Archive(archive);
-
-                ArrayList<FileHeader> arrayList = new ArrayList<>();
-
-                // iterating archive elements to find file names that are to be extracted
-                for (FileHeader header : rarFile.getFileHeaders()) {
-                    for (String entry : entries) {
+        private void extractRar(@NonNull final Context context, File archive, String destinationPath,
+                                String[] entriesToExtract) throws IOException, RarException {
+            Archive rarFile = new Archive(archive);
 
-                        if (header.getFileNameString().contains(entry)) {
-                            // header to be extracted is atleast the entry path (may be more, when it is a directory)
-                            arrayList.add(header);
-                        }
-                    }
-                }
-
-                // get the total size of elements to be extracted
-                for (FileHeader entry : arrayList) {
-                    totalBytes += entry.getFullUnpackSize();
-                }
-
-                // setting total bytes calculated from zip entries
-                progressHandler.setTotalSize(totalBytes);
-
-                setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), arrayList.size());
+            ArrayList<FileHeader> arrayList = new ArrayList<>();
 
-                watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
-                watcherUtil.watch();
+            // iterating archive elements to find file names that are to be extracted
+            for (FileHeader header : rarFile.getFileHeaders()) {
+                for (String entry : entriesToExtract) {
 
-                int i = 0;
-                for (FileHeader entry : arrayList) {
-                    if (!progressHandler.getCancelled()) {
-
-                        progressHandler.setFileName(entry.getFileNameString());
-                        unzipRAREntry(rarFile, entry, destinationPath);
-                        progressHandler.setSourceFilesProcessed(++i);
+                    if (header.getFileNameString().contains(entry)) {
+                        // header to be extracted is atleast the entry path (may be more, when it is a directory)
+                        arrayList.add(header);
                     }
                 }
+            }
 
-                return true;
-            } catch (Exception e) {
-
-                Log.e("amaze", "Error while extracting file " + archive, e);
-                AppConfig.toast(getApplicationContext(), getString(R.string.error));
-                return false;
+            // get the total size of elements to be extracted
+            for (FileHeader entry : arrayList) {
+                totalBytes += entry.getFullUnpackSize();
             }
-        }
 
-        protected Integer doInBackground(Bundle... p1) {
+            // setting total bytes calculated from zip entries
+            progressHandler.setTotalSize(totalBytes);
 
-            String file = p1[0].getString(KEY_PATH_ZIP);
+            setInitDataPackage(totalBytes, arrayList.get(0).getFileNameString(), arrayList.size());
 
-            File f = new File(file);
+            watcherUtil = new ServiceWatcherUtil(progressHandler, totalBytes);
+            watcherUtil.watch();
 
-            String path;
-            if (epath.equals(file)) {
+            int i = 0;
+            for (FileHeader entry : arrayList) {
+                if (!progressHandler.getCancelled()) {
 
-                // custom extraction path not set, extract at default path
-                path = f.getParent() + "/" + f.getName().substring(0, f.getName().lastIndexOf("."));
-            } else {
-
-                if (epath.endsWith("/")) {
-                    path = epath + f.getName().substring(0, f.getName().lastIndexOf("."));
-                } else {
-                    path = epath + "/" + f.getName().substring(0, f.getName().lastIndexOf("."));
+                    progressHandler.setFileName(entry.getFileNameString());
+                    unzipRAREntry(context, rarFile, entry, destinationPath);
+                    progressHandler.setSourceFilesProcessed(++i);
                 }
             }
-
-            if (entries != null && entries.size() != 0) {
-                if (f.getName().toLowerCase().endsWith(".zip") || f.getName().toLowerCase().endsWith(".jar") || f.getName().toLowerCase().endsWith(".apk"))
-                    extract(f, path, entries);
-                else if (f.getName().toLowerCase().endsWith(".rar"))
-                    extractRar(f, path, entries);
-            } else if (f.getName().toLowerCase().endsWith(".zip") || f.getName().toLowerCase().endsWith(".jar") || f.getName().toLowerCase().endsWith(".apk"))
-                extract(f, path);
-            else if (f.getName().toLowerCase().endsWith(".rar"))
-                extractRar(f, path);
-            else if (f.getName().toLowerCase().endsWith(".tar") || f.getName().toLowerCase().endsWith(".tar.gz"))
-                extractTar(f, path);
-            Log.i("Amaze", "Almost Completed");
-            // TODO: Implement this method
-            return p1[0].getInt("id");
         }
 
         @Override
-        public void onPostExecute(Integer b) {
+        public void onPostExecute(Void b) {
+            final ExtractService extractService = this.extractService.get();
+            if(extractService == null) return;
 
             // check whether watcherutil was initialized. It was not initialized when we got exception
             // in extracting the file
             if (watcherUtil != null) watcherUtil.stopWatch();
             Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
-            intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, epath);
-            sendBroadcast(intent);
-            stopSelf();
+            intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, extractionPath);
+            extractService.sendBroadcast(intent);
+            extractService.stopSelf();
         }
 
+        /**
+         * Setting initial package to initialize charts in process viewer properly
+         */
+        private void setInitDataPackage(long totalSize, String fileName, int sourceTotal) {
+            final ExtractService extractService = this.extractService.get();
+            if(extractService == null) return;
+
+            CopyDataParcelable intent1 = new CopyDataParcelable();
+            intent1.setName(fileName);
+            intent1.setSourceFiles(sourceTotal);
+            intent1.setSourceProgress(0);
+            intent1.setTotal(totalSize);
+            intent1.setByteProgress(0);
+            intent1.setSpeedRaw(0);
+            intent1.setMove(false);
+            intent1.setCompleted(false);
+            extractService.putDataPackage(intent1);
+        }
 
     }
 
-    /**
-     * Setting initial package to initialize charts in process viewer properly
-     *
-     * @param totalSize
-     * @param fileName
-     */
-    private void setInitDataPackage(long totalSize, String fileName, int sourceTotal) {
-
-        CopyDataParcelable intent1 = new CopyDataParcelable();
-        intent1.setName(fileName);
-        intent1.setSourceFiles(sourceTotal);
-        intent1.setSourceProgress(0);
-        intent1.setTotal(totalSize);
-        intent1.setByteProgress(0);
-        intent1.setSpeedRaw(0);
-        intent1.setMove(false);
-        intent1.setCompleted(false);
-        putDataPackage(intent1);
-    }
 
     @Override
     public void onDestroy() {
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.java
index dc355e5c6..bf09bf638 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ZipService.java
@@ -211,9 +211,9 @@ public class ZipService extends Service {
                         compressFile(file, "");
                     } else return;
                 }
-            } catch (Exception e) {
+            } catch (IOException e) {
+                e.printStackTrace();
             } finally {
-
                 try {
                     zos.flush();
                     zos.close();
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
index 0503fce93..b892870e3 100644
--- a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
@@ -17,6 +17,7 @@ import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 
 import java.io.File;
 import java.util.ArrayList;
+import java.util.LinkedList;
 
 /**
  * Created by Vishal on 29-05-2017.
@@ -148,8 +149,21 @@ public class UtilsHandler extends SQLiteOpenHelper {
         setPath(Operation.SMB, name, path);
     }
 
-    public ArrayList<String> getHistoryList() {
-        return getPath(Operation.HISTORY);
+    public LinkedList<String> getHistoryLinkedList() {
+        SQLiteDatabase sqLiteDatabase = getReadableDatabase();
+        Cursor cursor = sqLiteDatabase.query(getTableForOperation(Operation.HISTORY), null,
+                null, null, null, null, null);
+
+        LinkedList<String> paths = new LinkedList<>();
+        cursor.moveToFirst();
+        try {
+            while (cursor.moveToNext()) {
+                paths.push(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
+            }
+        } finally {
+            cursor.close();
+        }
+        return paths;
     }
 
     public ConcurrentRadixTree<VoidValue> getHiddenFilesConcurrentRadixTree() {
@@ -335,15 +349,14 @@ public class UtilsHandler extends SQLiteOpenHelper {
         SQLiteDatabase sqLiteDatabase = getReadableDatabase();
         Cursor cursor = sqLiteDatabase.query(getTableForOperation(operation), null,
                 null, null, null, null, null);
-        cursor.moveToFirst();
+
+        ArrayList<String> paths = new ArrayList<>();
 
         switch (operation) {
-            case HISTORY:
             case LIST:
             case GRID:
-                ArrayList<String> paths = new ArrayList<>();
+                cursor.moveToFirst();
                 try {
-
                     while (cursor.moveToNext()) {
                         paths.add(cursor.getString(cursor.getColumnIndex(COLUMN_PATH)));
                     }
@@ -364,12 +377,8 @@ public class UtilsHandler extends SQLiteOpenHelper {
                 new String[] {path});
     }
 
-    private void clearTable(Operation operation) {
-
-        SQLiteDatabase sqLiteDatabase = getWritableDatabase();
-
-        sqLiteDatabase.delete(getTableForOperation(operation), COLUMN_PATH + "=?",
-                new String[] { "NOT NULL" });
+    private void clearTable(Operation table) {
+        getWritableDatabase().delete(getTableForOperation(table), null, null);
     }
 
     private void renamePath(Operation operation, String name, String path) {
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
index e20550e75..5752fd011 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
@@ -14,18 +14,17 @@ import android.provider.MediaStore;
 import android.support.annotation.NonNull;
 import android.support.v4.provider.DocumentFile;
 import android.util.Log;
-import android.widget.Toast;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.exceptions.RootNotPermittedException;
 import com.amaze.filemanager.ui.icons.MimeTypes;
-import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.RootUtils;
+import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.amaze.filemanager.utils.files.GenericCopyUtil;
 import com.cloudrail.si.interfaces.CloudStorage;
@@ -141,31 +140,25 @@ public abstract class FileUtil {
         return true;
     }
 
-    public static OutputStream getOutputStream(final File target, Context context) throws Exception {
+    public static OutputStream getOutputStream(final File target, Context context) throws FileNotFoundException {
         return getOutputStream(target, context, 0);
     }
 
-    public static OutputStream getOutputStream(final File target, Context context, long s) throws Exception {
+    public static OutputStream getOutputStream(final File target, Context context, long s) throws FileNotFoundException {
         OutputStream outStream = null;
-        try {
-            // First try the normal way
-            if (isWritable(target)) {
-                // standard way
-                outStream = new FileOutputStream(target);
-            } else {
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-                    // Storage Access Framework
-                    DocumentFile targetDocument = getDocumentFile(target, false, context);
-                    outStream = context.getContentResolver().openOutputStream(targetDocument.getUri());
-                } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
-                    // Workaround for Kitkat ext SD card
-                    return MediaStoreHack.getOutputStream(context, target.getPath());
-                }
+        // First try the normal way
+        if (isWritable(target)) {
+            // standard way
+            outStream = new FileOutputStream(target);
+        } else {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                // Storage Access Framework
+                DocumentFile targetDocument = getDocumentFile(target, false, context);
+                outStream = context.getContentResolver().openOutputStream(targetDocument.getUri());
+            } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
+                // Workaround for Kitkat ext SD card
+                return MediaStoreHack.getOutputStream(context, target.getPath());
             }
-        } catch (Exception e) {
-            Log.e("AmazeFileUtils",
-                    "Error when copying file from " + target.getAbsolutePath(), e);
-            throw new Exception();
         }
         return outStream;
     }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java
new file mode 100644
index 000000000..2f4cb109a
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedHelper.java
@@ -0,0 +1,37 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import android.content.Context;
+
+import java.io.File;
+
+/**
+ * @author Emmanuel
+ *         on 23/11/2017, at 17:46.
+ */
+
+public class CompressedHelper {
+
+    /**
+     * To add compatibility with other compressed file types edit this method
+     */
+    public static CompressedInterface getCompressedInterfaceInstance(Context context, File file) {
+        CompressedInterface compressedInterface;
+
+        String path = file.getPath().toLowerCase();
+        boolean isZip = path.endsWith(".zip") || path.endsWith(".jar") || path.endsWith(".apk");
+        boolean isTar = path.endsWith(".tar") || path.endsWith(".tar.gz");
+        boolean isRar = path.endsWith(".rar");
+
+        if (isZip || isTar) {
+            compressedInterface = new ZipHelper(context);
+        } else if (isRar) {
+            compressedInterface = new RarHelper(context);
+        } else {
+            return null;
+        }
+
+        compressedInterface.setFilePath(file.getPath());
+        return compressedInterface;
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedInterface.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedInterface.java
new file mode 100644
index 000000000..efec80dbf
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/CompressedInterface.java
@@ -0,0 +1,32 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+
+import java.util.ArrayList;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 17:14.
+ */
+
+public interface CompressedInterface {
+    void setFilePath(String path);
+
+    /**
+     * Separator must be "/"
+     * @param path end with "/" if it is a directory, does not if it's a file
+     */
+    void changePath(String path, boolean addGoBackItem,
+                    OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish);
+    /**
+     * Decompress a file somewhere
+     */
+    void decompress(String whereToDecompress);
+
+    /**
+     * Decompress files or dirs inside the compressed file.
+     * @param subDirectories separator is "/", ended with "/" if it is a directory, does not if it's a file
+     */
+    void decompress(String whereToDecompress, String[] subDirectories);
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/RarHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/RarHelper.java
new file mode 100644
index 000000000..e1d5be3b8
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/RarHelper.java
@@ -0,0 +1,74 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import android.content.Context;
+import android.content.Intent;
+
+import com.amaze.filemanager.asynchronous.asynctasks.RarHelperTask;
+import com.amaze.filemanager.asynchronous.services.ExtractService;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+import com.amaze.filemanager.utils.ServiceWatcherUtil;
+import com.github.junrar.rarfile.FileHeader;
+
+import java.util.ArrayList;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 17:23.
+ */
+
+public class RarHelper implements CompressedInterface {
+    private Context context;
+    private String filePath;
+
+    public RarHelper(Context context) {
+        this.context = context;
+    }
+
+    @Override
+    public void setFilePath(String path) {
+        filePath = path;
+    }
+
+    @Override
+    public void changePath(String path, boolean addGoBackItem,
+                           OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish) {
+        new RarHelperTask(filePath, path, addGoBackItem, onFinish).execute();
+    }
+
+    @Override
+    public void decompress(String whereToDecompress) {
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, new String[0]);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+    @Override
+    public void decompress(String whereToDecompress, String[] subDirectories) {
+        for (int i = 0; i < subDirectories.length; i++) {
+            subDirectories[i] = deconvertName(subDirectories[i]);
+        }
+
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, subDirectories);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+
+    public static String convertName(FileHeader file) {
+        String name = file.getFileNameString().replace('\\', '/');
+
+        if(file.isDirectory()) return name + "/";
+        else return name;
+    }
+
+    public static String deconvertName(String dir) {
+        if(dir.endsWith("/")) dir = dir.substring(0, dir.length()-1);
+        return dir.replace('/', '\\');
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/ZipHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/ZipHelper.java
new file mode 100644
index 000000000..740feeb65
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/ZipHelper.java
@@ -0,0 +1,56 @@
+package com.amaze.filemanager.filesystem.compressed;
+
+import android.content.Context;
+import android.content.Intent;
+
+import com.amaze.filemanager.asynchronous.asynctasks.ZipHelperTask;
+import com.amaze.filemanager.asynchronous.services.ExtractService;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
+import com.amaze.filemanager.utils.OnAsyncTaskFinished;
+import com.amaze.filemanager.utils.ServiceWatcherUtil;
+
+import java.util.ArrayList;
+
+/**
+ * @author Emmanuel
+ *         on 20/11/2017, at 17:19.
+ */
+
+public class ZipHelper implements CompressedInterface {
+    private String filePath;
+    private Context context;
+
+    public ZipHelper(Context context) {
+        this.context = context;
+    }
+
+    @Override
+    public void setFilePath(String path) {
+        filePath = path;
+    }
+
+    @Override
+    public void changePath(String path, boolean addGoBackItem,
+                           OnAsyncTaskFinished<ArrayList<CompressedObjectParcelable>> onFinish) {
+        new ZipHelperTask(context, filePath, path, addGoBackItem, onFinish).execute();
+    }
+
+    @Override
+    public void decompress(String whereToDecompress) {
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, new String[0]);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+    @Override
+    public void decompress(String whereToDecompress, String[] subDirectories) {
+        Intent intent = new Intent(context, ExtractService.class);
+        intent.putExtra(ExtractService.KEY_PATH_ZIP, filePath);
+        intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, subDirectories);
+        intent.putExtra(ExtractService.KEY_PATH_EXTRACT, whereToDecompress);
+        ServiceWatcherUtil.runService(context, intent);
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/ZipExplorerFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/CompressedExplorerFragment.java
similarity index 69%
rename from app/src/main/java/com/amaze/filemanager/fragments/ZipExplorerFragment.java
rename to app/src/main/java/com/amaze/filemanager/fragments/CompressedExplorerFragment.java
index ff8a11799..5a6bcb5ea 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/ZipExplorerFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/CompressedExplorerFragment.java
@@ -49,44 +49,40 @@ import android.widget.Toast;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.adapters.ZipExplorerAdapter;
+import com.amaze.filemanager.adapters.CompressedExplorerAdapter;
 import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
-import com.amaze.filemanager.asynchronous.asynctasks.RarHelperTask;
-import com.amaze.filemanager.asynchronous.asynctasks.ZipHelperTask;
 import com.amaze.filemanager.asynchronous.services.ExtractService;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
-import com.amaze.filemanager.ui.ZipObjectParcelable;
+import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
+import com.amaze.filemanager.filesystem.compressed.CompressedInterface;
+import com.amaze.filemanager.ui.CompressedObjectParcelable;
 import com.amaze.filemanager.ui.views.DividerItemDecoration;
 import com.amaze.filemanager.ui.views.FastScroller;
 import com.amaze.filemanager.utils.BottomBarButtonPath;
 import com.amaze.filemanager.utils.OpenMode;
-import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.theme.AppTheme;
 import com.github.junrar.Archive;
-import com.github.junrar.rarfile.FileHeader;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Calendar;
 
-public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath {
+public class CompressedExplorerFragment extends Fragment implements BottomBarButtonPath {
     public static final String KEY_PATH = "path";
 
-    private static final int ZIP_FILE = 0, RAR_FILE = 1;
-
     private static final String KEY_CACHE_FILES = "cache_files";
     private static final String KEY_URI = "uri";
-    private static final String KEY_OPEN_MODE = "open_mode";
     private static final String KEY_FILE = "file";
     private static final String KEY_WHOLE_LIST = "whole_list";
     private static final String KEY_ELEMENTS = "elements";
     private static final String KEY_OPEN = "is_open";
 
-    public File realZipFile;
+
+    public File compressedFile;
 
     /**
      * files to be deleted from cache
@@ -97,25 +93,24 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
     public boolean selection = false;
     public String relativeDirectory = "";//Normally this would be "/" but for pathing issues it isn't
     public String skin, accentColor, iconskin, year;
-    public ZipExplorerAdapter zipExplorerAdapter;
+    public CompressedExplorerAdapter compressedExplorerAdapter;
     public ActionMode mActionMode;
     public boolean coloriseIcons, showSize, showLastModified, gobackitem;
     public Archive archive;
-    public ArrayList<FileHeader> elementsRar = new ArrayList<>();
-    public ArrayList<ZipObjectParcelable> elements = new ArrayList<>();
+    public ArrayList<CompressedObjectParcelable> elements = new ArrayList<>();
     public MainActivity mainActivity;
     public RecyclerView listView;
     public SwipeRefreshLayout swipeRefreshLayout;
     public boolean isOpen = false;  // flag states whether to open file after service extracts it
 
     private UtilitiesProviderInterface utilsProvider;
+    private CompressedInterface compressedInterface;
     private View rootView;
     private boolean addheader = true;
     private LinearLayoutManager mLayoutManager;
     private DividerItemDecoration dividerItemDecoration;
     private boolean showDividers;
     private View mToolbarContainer;
-    private int openmode;
     private boolean stopAnims = true;
     private int file = 0, folder = 0;
 
@@ -131,10 +126,10 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
         mainActivity = (MainActivity) getActivity();
         listView = (RecyclerView) rootView.findViewById(R.id.listView);
         listView.setOnTouchListener((view, motionEvent) -> {
-            if (stopAnims && !zipExplorerAdapter.stoppedAnimation) {
+            if (stopAnims && !compressedExplorerAdapter.stoppedAnimation) {
                 stopAnim();
             }
-            zipExplorerAdapter.stoppedAnimation = true;
+            compressedExplorerAdapter.stoppedAnimation = true;
 
             stopAnims = false;
             return false;
@@ -156,15 +151,15 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
     public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
         SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());
-        realZipFile = new File(Uri.parse(getArguments().getString(KEY_PATH)).getPath());
+        compressedFile = new File(Uri.parse(getArguments().getString(KEY_PATH)).getPath());
 
         mToolbarContainer = mainActivity.getAppbar().getAppbarLayout();
         mToolbarContainer.setOnTouchListener((view, motionEvent) -> {
             if (stopAnims) {
-                if ((!zipExplorerAdapter.stoppedAnimation)) {
+                if ((!compressedExplorerAdapter.stoppedAnimation)) {
                     stopAnim();
                 }
-                zipExplorerAdapter.stoppedAnimation = true;
+                compressedExplorerAdapter.stoppedAnimation = true;
             }
             stopAnims = false;
             return false;
@@ -192,16 +187,12 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
 
         //mainActivity.findViewById(R.id.buttonbarframe).setBackgroundColor(Color.parseColor(skin));
 
-        if (savedInstanceState == null && realZipFile != null) {
+        if (savedInstanceState == null && compressedFile != null) {
             files = new ArrayList<>();
             // adding a cache file to delete where any user interaction elements will be cached
-            String fileName = realZipFile.getName().substring(0, realZipFile.getName().lastIndexOf("."));
+            String fileName = compressedFile.getName().substring(0, compressedFile.getName().lastIndexOf("."));
             files.add(new HybridFileParcelable(getActivity().getExternalCacheDir().getPath() + "/" + fileName));
-            if (realZipFile.getPath().endsWith(".rar")) {
-                openmode = RAR_FILE;
-            } else {
-                openmode = ZIP_FILE;
-            }
+            compressedInterface = CompressedHelper.getCompressedInterfaceInstance(getContext(), compressedFile);
 
             changePath("");
         } else {
@@ -214,39 +205,23 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
     public void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
 
-        if (openmode == ZIP_FILE) {
-            outState.putParcelableArrayList(KEY_ELEMENTS, elements);
-        }
-
-        outState.putInt(KEY_OPEN_MODE, openmode);
+        outState.putParcelableArrayList(KEY_ELEMENTS, elements);
         outState.putString(KEY_PATH, relativeDirectory);
-        outState.putString(KEY_URI, realZipFile.getPath());
-        outState.putString(KEY_FILE, realZipFile.getPath());
+        outState.putString(KEY_URI, compressedFile.getPath());
+        outState.putString(KEY_FILE, compressedFile.getPath());
         outState.putParcelableArrayList(KEY_CACHE_FILES, files);
         outState.putBoolean(KEY_OPEN, isOpen);
     }
 
     private void onRestoreInstanceState(Bundle savedInstanceState) {
-        realZipFile = new File(Uri.parse(savedInstanceState.getString(KEY_URI)).getPath());
+        compressedFile = new File(Uri.parse(savedInstanceState.getString(KEY_URI)).getPath());
         files = savedInstanceState.getParcelableArrayList(KEY_CACHE_FILES);
         isOpen = savedInstanceState.getBoolean(KEY_OPEN);
-        if (realZipFile.getPath().endsWith(".rar")) {
-            openmode = RAR_FILE;
-            String path = savedInstanceState.getString(KEY_FILE);
-            if (path != null && path.length() > 0) {
-                realZipFile = new File(path);
-                relativeDirectory = savedInstanceState.getString(KEY_PATH, "");
-                changeRarPath(relativeDirectory);
-            } else {
-                changePath("");
-            }
-        } else {
-            openmode = ZIP_FILE;
-            elements = savedInstanceState.getParcelableArrayList(KEY_ELEMENTS);
-            relativeDirectory = savedInstanceState.getString(KEY_PATH, "");
-            realZipFile = new File(savedInstanceState.getString(KEY_FILE));
-            createZipViews(elements, relativeDirectory);
-        }
+        elements = savedInstanceState.getParcelableArrayList(KEY_ELEMENTS);
+        relativeDirectory = savedInstanceState.getString(KEY_PATH, "");
+
+        compressedInterface = CompressedHelper.getCompressedInterfaceInstance(getContext(), compressedFile);
+        createViews(elements, relativeDirectory);
     }
 
     public ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
@@ -299,7 +274,7 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
         // onCreateActionMode, but
         // may be called multiple times if the mode is invalidated.
         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
-            ArrayList<Integer> positions = zipExplorerAdapter.getCheckedItemPositions();
+            ArrayList<Integer> positions = compressedExplorerAdapter.getCheckedItemPositions();
             ((TextView) v.findViewById(R.id.item_count)).setText(positions.size() + "");
 
             return false; // Return false if nothing is done
@@ -309,20 +284,19 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
             switch (item.getItemId()) {
                 case R.id.all:
-                    zipExplorerAdapter.toggleChecked(true);
+                    compressedExplorerAdapter.toggleChecked(true);
                     mode.invalidate();
                     return true;
                 case R.id.ex:
-
                     Toast.makeText(getActivity(), getResources().getString(R.string.extracting), Toast.LENGTH_SHORT).show();
-                    Intent intent = new Intent(getActivity(), ExtractService.class);
-                    ArrayList<String> a = new ArrayList<>();
-                    for (int i : zipExplorerAdapter.getCheckedItemPositions()) {
-                        a.add(openmode == ZIP_FILE ? elements.get(i).getName() : elementsRar.get(i).getFileNameString());
+
+                    String[] dirs = new String[compressedExplorerAdapter.getCheckedItemPositions().size()];
+                    for (int i = 0; i < dirs.length; i++) {
+                        dirs[i] = elements.get(compressedExplorerAdapter.getCheckedItemPositions().get(i)).getName();
                     }
-                    intent.putExtra(ExtractService.KEY_PATH_ZIP, realZipFile.getPath());
-                    intent.putExtra(ExtractService.KEY_ENTRIES_ZIP, a);
-                    ServiceWatcherUtil.runService(getContext(), intent);
+
+                    compressedInterface.decompress(null, dirs);
+
                     mode.finish();
                     return true;
             }
@@ -331,7 +305,7 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
 
         @Override
         public void onDestroyActionMode(ActionMode actionMode) {
-            if (zipExplorerAdapter != null) zipExplorerAdapter.toggleChecked(false);
+            if (compressedExplorerAdapter != null) compressedExplorerAdapter.toggleChecked(false);
             selection = false;
             mainActivity.updateViews(mainActivity.getColorPreference().getDrawable(ColorUsage.getPrimary(MainActivity.currentTab)));
             if (Build.VERSION.SDK_INT >= 21) {
@@ -394,41 +368,27 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
         }
     };
 
-    public boolean canGoBack() {
-        if (openmode == RAR_FILE) return !(relativeDirectory == null || relativeDirectory.trim().length() == 0);
-        else return !(relativeDirectory == null || relativeDirectory.trim().length() == 0);
-    }
-
-    public void goBack() {
-        if (openmode == RAR_FILE) {
-            String path;
-            try {
-                path = relativeDirectory.substring(0, relativeDirectory.lastIndexOf("/"));
-            } catch (Exception e) {
-                path = "";
-            }
-            changeRarPath(path);
-        } else {
-            changeZipPath(new File(relativeDirectory).getParent());
-        }
-    }
-
     @Override
-    public void changePath(String path) {
-        if(path.startsWith("/")) path = path.substring(1);
+    public void changePath(String folder) {
+        if(folder == null) folder = "";
+        if(folder.startsWith("/")) folder = folder.substring(1);
 
-        if (openmode == ZIP_FILE) {// TODO: 15/9/2017 put switch
-            changeZipPath(path);
-        } else {
-            changeRarPath(path);
-        }
+        boolean addGoBackItem = gobackitem && !isRoot(folder);
+        String finalfolder = folder;
+        compressedInterface.changePath(folder, addGoBackItem, data -> {
+            elements = data;
+            createViews(elements, finalfolder);
+
+            swipeRefreshLayout.setRefreshing(false);
+            updateBottomBar();
+        });
 
         updateBottomBar();
     }
 
     @Override
     public String getPath() {
-        if(relativeDirectory != null && relativeDirectory.length() != 0) return "/" + relativeDirectory;
+        if(!isRootRelativePath()) return "/" + relativeDirectory;
         else return "";
     }
 
@@ -437,85 +397,32 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
         return R.drawable.ic_compressed_white_24dp;
     }
 
-    /**
-     * The folders's path separator must be "/"
-     */
-    public void changeZipPath(final String folder) {
-        swipeRefreshLayout.setRefreshing(true);
-        new ZipHelperTask(getContext(), realZipFile.getPath(), folder, data -> {
-            if (gobackitem && relativeDirectory != null && relativeDirectory.trim().length() != 0)
-                elements.add(0, new ZipObjectParcelable(null, 0, 0, true));
-            elements = data;
-            createZipViews(data, folder);
-
-            swipeRefreshLayout.setRefreshing(false);
-            updateBottomBar();
-        }).execute();
-    }
-
-    /**
-     * The folders's path separator must be "/"
-     */
-    public void changeRarPath(final String folder) {
-        swipeRefreshLayout.setRefreshing(true);
-        new RarHelperTask(getContext(), realZipFile.getPath(), folder,
-                data -> {
-                    archive = data.first;
-                    if(data.second != null) {
-                        createRarViews(data.second, folder);
-                        elementsRar = data.second;
-                    }
-
-                    swipeRefreshLayout.setRefreshing(false);
-                    updateBottomBar();
-                }).execute();
-    }
-
     private void refresh() {
         changePath(relativeDirectory);
     }
 
     private void updateBottomBar() {
-        String path = relativeDirectory != null && relativeDirectory.length() != 0? realZipFile.getName() + "/" + relativeDirectory : realZipFile.getName();
+        String path = !isRootRelativePath()? compressedFile.getName() + "/" + relativeDirectory : compressedFile.getName();
         mainActivity.getAppbar().getBottomBar().updatePath(path, false, null, OpenMode.FILE, folder, file, this);
     }
 
-    private void createZipViews(ArrayList<ZipObjectParcelable> zipEntries, String dir) {
-        if (zipExplorerAdapter == null) {
-            zipExplorerAdapter = new ZipExplorerAdapter(getActivity(), utilsProvider, zipEntries, null, this, true);
-            listView.setAdapter(zipExplorerAdapter);
+    private void createViews(ArrayList<CompressedObjectParcelable> items, String dir) {
+        if (compressedExplorerAdapter == null) {
+            compressedExplorerAdapter = new CompressedExplorerAdapter(getActivity(), utilsProvider, items, this, compressedInterface);
+            listView.setAdapter(compressedExplorerAdapter);
         } else {
-            zipExplorerAdapter.generateZip(zipEntries);
-        }
-        folder = 0;
-        file = 0;
-        for (ZipObjectParcelable zipEntry : zipEntries) {
-            if (zipEntry.isDirectory()) folder++;
-            else file++;
-        }
-        openmode = ZIP_FILE;
-        createViews(dir);
-    }
-
-    private void createRarViews(ArrayList<FileHeader> rarEntries, String dir) {
-        if (zipExplorerAdapter == null) {
-            zipExplorerAdapter = new ZipExplorerAdapter(getActivity(), utilsProvider, null, rarEntries, this, false);
-            listView.setAdapter(zipExplorerAdapter);
-        } else {
-            zipExplorerAdapter.generateRar(rarEntries);
+            compressedExplorerAdapter.generateZip(items);
         }
 
         folder = 0;
         file = 0;
-        for (FileHeader zipEntry : rarEntries) {
-            if (zipEntry.isDirectory()) folder++;
+        for (CompressedObjectParcelable item : items) {
+            if(item.getType() == CompressedObjectParcelable.TYPE_GOBACK) continue;
+            
+            if (item.isDirectory()) folder++;
             else file++;
         }
-        openmode = RAR_FILE;
-        createViews(dir);
-    }
 
-    private void createViews(String dir) {
         stopAnims = true;
         if (!addheader) {
             listView.removeItemDecoration(dividerItemDecoration);
@@ -524,7 +431,7 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
         } else {
             dividerItemDecoration = new DividerItemDecoration(getActivity(), true, showDividers);
             listView.addItemDecoration(dividerItemDecoration);
-            //headersDecor = new StickyRecyclerHeadersDecoration(zipExplorerAdapter);
+            //headersDecor = new StickyRecyclerHeadersDecoration(compressedExplorerAdapter);
             //listView.addItemDecoration(headersDecor);
             addheader = false;
         }
@@ -540,4 +447,20 @@ public class ZipExplorerFragment extends Fragment implements BottomBarButtonPath
         swipeRefreshLayout.setRefreshing(false);
     }
 
+    public boolean canGoBack() {
+        return !isRootRelativePath();
+    }
+
+    public void goBack() {
+        changePath(new File(relativeDirectory).getParent());
+    }
+
+    private boolean isRootRelativePath() {
+        return isRoot(relativeDirectory);
+    }
+
+    private boolean isRoot(String folder) {
+        return folder == null || folder.isEmpty();
+    }
+
 }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
index 15db48d84..e18329652 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/MainFragment.java
@@ -98,7 +98,6 @@ import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.SmbStreamer.Streamer;
 import com.amaze.filemanager.utils.Utils;
-import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
@@ -1663,39 +1662,20 @@ public class MainFragment extends android.support.v4.app.Fragment implements Bot
             // no results were found
             LIST_ELEMENTS.clear();
         }
-        
-        AppConfig.runInBackground(new AppConfig.CustomAsyncCallbacks() {
+        new AsyncTask<Void, Void, Void>() {
             @Override
-            public <E> E doInBackground() {
-
+            protected Void doInBackground(Void... params) {
                 Collections.sort(LIST_ELEMENTS, new FileListSorter(dsort, sortby, asc));
                 return null;
             }
 
             @Override
-            public Void onPostExecute(Object result) {
-
+            public void onPostExecute(Void c) {
                 reloadListElements(true, true, !IS_LIST);// TODO: 7/7/2017 this is really inneffient, use RecycleAdapter's createHeaders()
                 getMainActivity().getAppbar().getBottomBar().setPathText("");
                 getMainActivity().getAppbar().getBottomBar().setFullPathText(getString(R.string.searchresults, query));
-                return null;
             }
-
-            @Override
-            public Void onPreExecute() {
-                return null;
-            }
-
-            @Override
-            public Void publishResult(Object... result) {
-                return null;
-            }
-
-            @Override
-            public <T> T[] params() {
-                return null;
-            }
-        });
+        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     public static void launchSMB(final SmbFile smbFile, final long si, final Activity activity) {
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
index 17df1c4af..f8ec8f04b 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
@@ -63,7 +63,7 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
     private static final String PREFERENCE_KEY_ABOUT = "about";
     private static final String[] PREFERENCE_KEYS =
             {"columns", "theme", "rootmode", "showHidden", "feedback", PREFERENCE_KEY_ABOUT,
-                    "plus_pic", "colors", "sidebar_folders", "sidebar_quickaccess", "advancedsearch"};
+                    "colors", "sidebar_folders", "sidebar_quickaccess", "advancedsearch"};
 
     public static final String PREFERENCE_SHOW_SIDEBAR_FOLDERS = "sidebar_folders_enable";
     public static final String PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES = "sidebar_quickaccess_enable";
@@ -88,7 +88,6 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
 
     private UtilitiesProviderInterface utilsProvider;
     private SharedPreferences sharedPref;
-    private CheckBox gplus;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -105,11 +104,6 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
             findPreference(PREFERENCE_KEY).setOnPreferenceClickListener(this);
         }
 
-        gplus = (CheckBox) findPreference("plus_pic");
-
-        if (BuildConfig.IS_VERSION_FDROID)
-            gplus.setEnabled(false);
-
         // crypt master password
         final Preference masterPasswordPreference = findPreference(PREFERENCE_CRYPT_MASTER_PASSWORD);
 
@@ -235,12 +229,6 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
             case PREFERENCE_KEY_ABOUT:
                 startActivity(new Intent(getActivity(), AboutActivity.class));
                 return false;
-            case "plus_pic":
-                if(gplus.isChecked()){
-                    boolean b= MainActivityHelper.checkAccountsPermission(getActivity());
-                    if(!b) MainActivityHelper.requestAccountsPermission((PreferencesActivity) getActivity());
-                }
-                return false;
             /*FROM HERE BE FRAGMENTS*/
             case "colors":
                 ((PreferencesActivity) getActivity())
@@ -342,8 +330,4 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
         activity.startActivity(activity.getIntent());
     }
 
-    public void invalidateGplus(){
-        boolean a=MainActivityHelper.checkAccountsPermission(getActivity());
-        if(!a)gplus.setChecked(false);
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/CompressedObjectParcelable.java b/app/src/main/java/com/amaze/filemanager/ui/CompressedObjectParcelable.java
new file mode 100644
index 000000000..bd9c04c73
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/CompressedObjectParcelable.java
@@ -0,0 +1,114 @@
+package com.amaze.filemanager.ui;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Comparator;
+
+/**
+ * @author Emmanuel Messulam <emmanuelbendavid@gmail.com>
+ *         on 20/11/2017, at 15:26.
+ */
+public class CompressedObjectParcelable implements Parcelable {
+    public static final int TYPE_GOBACK = -1, TYPE_NORMAL = 0;
+
+    private final boolean directory;
+    private final int type;
+    private final String name;
+    private final long date, size;
+
+    public CompressedObjectParcelable(String name, long date, long size, boolean directory) {
+        this.directory = directory;
+        this.type = TYPE_NORMAL;
+        this.name = name;
+        this.date = date;
+        this.size = size;
+    }
+
+    /**
+     * TYPE_GOBACK instance
+     */
+    public CompressedObjectParcelable() {
+        this.directory = true;
+        this.type = TYPE_GOBACK;
+        this.name = null;
+        this.date = 0;
+        this.size = 0;
+    }
+
+    public int getType() {
+        return type;
+    }
+
+    public boolean isDirectory() {
+        return directory;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public long getSize() {
+        return size;
+    }
+
+    public long getTime() {
+        return date;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel p1, int p2) {
+        p1.writeInt(type);
+        if(type != TYPE_GOBACK) {
+            p1.writeInt(directory? 1:0);
+            p1.writeString(name);
+            p1.writeLong(size);
+            p1.writeLong(date);
+        }
+    }
+
+    public static final Parcelable.Creator<CompressedObjectParcelable> CREATOR =
+            new Parcelable.Creator<CompressedObjectParcelable>() {
+                public CompressedObjectParcelable createFromParcel(Parcel in) {
+                    return new CompressedObjectParcelable(in);
+                }
+
+                public CompressedObjectParcelable[] newArray(int size) {
+                    return new CompressedObjectParcelable[size];
+                }
+            };
+
+    private CompressedObjectParcelable(Parcel im) {
+        type = im.readInt();
+        if(type == TYPE_GOBACK) {
+            directory = true;
+            name = null;
+            date = 0;
+            size = 0;
+        } else {
+            directory = im.readInt() == 1;
+            name = im.readString();
+            size = im.readLong();
+            date = im.readLong();
+        }
+    }
+
+    public static class Sorter implements Comparator<CompressedObjectParcelable> {
+        @Override
+        public int compare(CompressedObjectParcelable file1, CompressedObjectParcelable file2) {
+            if(file1.getType() == CompressedObjectParcelable.TYPE_GOBACK) return -1;
+            else if(file2.getType() == CompressedObjectParcelable.TYPE_GOBACK) return 1;
+            else if (file1.isDirectory() && !file2.isDirectory()) {
+                return -1;
+            } else if (file2.isDirectory() && !(file1).isDirectory()) {
+                return 1;
+            } else return file1.getName().compareToIgnoreCase(file2.getName());
+        }
+
+    }
+
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/ZipObjectParcelable.java b/app/src/main/java/com/amaze/filemanager/ui/ZipObjectParcelable.java
deleted file mode 100644
index eb6920137..000000000
--- a/app/src/main/java/com/amaze/filemanager/ui/ZipObjectParcelable.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package com.amaze.filemanager.ui;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-
-import java.util.zip.ZipEntry;
-
-/**
- * Created by Arpit on 11-12-2014.
- */
-public class ZipObjectParcelable implements Parcelable {
-
-    private boolean directory;
-    private ZipEntry entry;
-    private String name;
-    private long date, size;
-
-    public ZipObjectParcelable(ZipEntry entry, long date, long size, boolean directory) {
-        this.directory = directory;
-        this.entry = entry;
-        if (entry != null) {
-            name = entry.getName();
-            this.date = date;
-            this.size = size;
-
-        }
-    }
-
-    public ZipEntry getEntry() {
-        return entry;
-    }
-
-    public boolean isDirectory() {
-        return directory;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public long getSize() {
-        return size;
-    }
-
-    public long getTime() {
-        return date;
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-
-    public void writeToParcel(Parcel p1, int p2) {
-        p1.writeString(name);
-        p1.writeLong(size);
-        p1.writeLong(date);
-        p1.writeInt(isDirectory() ? 1 : 0);
-    }
-
-    public static final Parcelable.Creator<ZipObjectParcelable> CREATOR =
-            new Parcelable.Creator<ZipObjectParcelable>() {
-                public ZipObjectParcelable createFromParcel(Parcel in) {
-                    return new ZipObjectParcelable(in);
-                }
-
-                public ZipObjectParcelable[] newArray(int size) {
-                    return new ZipObjectParcelable[size];
-                }
-            };
-
-    public ZipObjectParcelable(Parcel im) {
-        name = im.readString();
-        size = im.readLong();
-        date = im.readLong();
-        int i = im.readInt();
-        directory = i != 0;
-        entry = new ZipEntry(name);
-    }
-
-}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
index e2d739985..8f0998d10 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
@@ -27,7 +27,7 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.fragments.TabFragment;
-import com.amaze.filemanager.fragments.ZipExplorerFragment;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
 import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.utils.BottomBarButtonPath;
@@ -138,7 +138,7 @@ public class BottomBar implements View.OnTouchListener{
                         timer.start();
                         showButtons(m);
                     }
-                } else if (fragmentAtFrame instanceof ZipExplorerFragment) {
+                } else if (fragmentAtFrame instanceof CompressedExplorerFragment) {
                     FileUtils.crossfade(buttons, pathLayout);
                     timer.cancel();
                     timer.start();
diff --git a/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java b/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
index c22d0c9ab..07811dee0 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/DataUtils.java
@@ -13,7 +13,9 @@ import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Stack;
 
 /**
  * Created by arpitkh996 on 20-01-2016.
@@ -28,11 +30,16 @@ public class DataUtils {
             RENAME = 4, NEW_FILE = 5, EXTRACT = 6, COMPRESS = 7;
 
     private ConcurrentRadixTree<VoidValue> hiddenfiles = new ConcurrentRadixTree<>(new DefaultCharArrayNodeFactory());
-    private ArrayList<String> gridfiles = new ArrayList<>(),
-            listfiles = new ArrayList<>(), history = new ArrayList<>(), storages = new ArrayList<>();
+
+    private ArrayList<String> gridfiles = new ArrayList<>();
+    private ArrayList<String> listfiles = new ArrayList<>();
+    private LinkedList<String> history = new LinkedList<>();
+    private ArrayList<String> storages = new ArrayList<>();
 
     private ArrayList<Item> list = new ArrayList<>();
-    private ArrayList<String[]> servers = new ArrayList<>(), books = new ArrayList<>();
+
+    private ArrayList<String[]> servers = new ArrayList<>();
+    private ArrayList<String[]> books = new ArrayList<>();
 
     private ArrayList<CloudStorage> accounts = new ArrayList<>(4);
 
@@ -112,7 +119,7 @@ public class DataUtils {
         hiddenfiles = new ConcurrentRadixTree<>(new DefaultCharArrayNodeFactory());
         gridfiles = new ArrayList<>();
         listfiles = new ArrayList<>();
-        history = new ArrayList<>();
+        history.clear();
         storages = new ArrayList<>();
         servers = new ArrayList<>();
         books = new ArrayList<>();
@@ -242,16 +249,17 @@ public class DataUtils {
         }
     }
 
-    public ArrayList<String> getHistory() {
+    public void setHistory(LinkedList<String> s) {
+        history.clear();
+        history.addAll(s);
+    }
+
+    public LinkedList<String> getHistory() {
         return history;
     }
 
     public void addHistoryFile(final String i) {
-
-        synchronized (history) {
-
-            history.add(i);
-        }
+        history.push(i);
         if (dataChangeListener != null) {
             AppConfig.runInBackground(() -> dataChangeListener.onHistoryAdded(i));
         }
@@ -345,7 +353,7 @@ public class DataUtils {
     }
 
     public void clearHistory() {
-        history = new ArrayList<>();
+        history.clear();
         if (dataChangeListener != null) {
             AppConfig.runInBackground(new Runnable() {
                 @Override
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index a07a60649..4f338b75c 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -1,18 +1,15 @@
 package com.amaze.filemanager.utils;
 
-import android.Manifest;
 import android.app.Activity;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Bundle;
 import android.support.annotation.StringRes;
 import android.support.design.widget.BottomSheetDialogFragment;
-import android.support.v4.app.ActivityCompat;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentManager;
 import android.view.LayoutInflater;
@@ -25,18 +22,18 @@ import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.activities.superclasses.BasicActivity;
 import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
-import com.amaze.filemanager.asynchronous.services.ExtractService;
 import com.amaze.filemanager.asynchronous.services.ZipService;
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.Operations;
+import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
+import com.amaze.filemanager.filesystem.compressed.CompressedInterface;
 import com.amaze.filemanager.fragments.CloudSheetFragment;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.fragments.SearchWorkerFragment;
@@ -504,9 +501,8 @@ public class MainActivityHelper {
             mainActivity.oppathe = (file.getPath());
             mainActivity.operation = DataUtils.EXTRACT;
         } else if (mode == 1) {
-            Intent intent = new Intent(mainActivity, ExtractService.class);
-            intent.putExtra(ExtractService.KEY_PATH_ZIP, file.getPath());
-            ServiceWatcherUtil.runService(mainActivity, intent);
+            CompressedInterface compressedInterface = CompressedHelper.getCompressedInterfaceInstance(mainActivity, file);
+            compressedInterface.decompress(null);
         } else Toast.makeText(mainActivity, R.string.not_allowed, Toast.LENGTH_SHORT).show();
     }
 
@@ -623,46 +619,4 @@ public class MainActivityHelper {
         return file.getName().equals(file.getParentName());
     }
 
-
-
-    public static boolean checkAccountsPermission(Context context) {
-        // Verify that all required contact permissions have been granted.
-        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.GET_ACCOUNTS)
-                != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(context, Manifest.permission.INTERNET)
-                != PackageManager.PERMISSION_GRANTED) {
-            return false;
-        }
-        return true;
-    }
-
-    public static void requestAccountsPermission(final BasicActivity activity) {
-        final String[] PERMISSIONS = {Manifest.permission.GET_ACCOUNTS,
-                Manifest.permission.INTERNET};
-        if (ActivityCompat.shouldShowRequestPermissionRationale(activity,
-                Manifest.permission.GET_ACCOUNTS) || ActivityCompat.shouldShowRequestPermissionRationale(activity,
-                Manifest.permission.INTERNET)) {
-            // Provide an additional rationale to the user if the permission was not granted
-            // and the user would benefit from additional context for the use of the permission.
-            // For example, if the request has been denied previously.
-
-            final MaterialDialog materialDialog = GeneralDialogCreation.showBasicDialog(activity,
-                    new String[] {
-                            activity.getResources().getString(R.string.grantgplus),
-                            activity.getResources().getString(R.string.grantper),
-                            activity.getResources().getString(R.string.grant),
-                            activity.getResources().getString(R.string.cancel), null
-                    });
-            materialDialog.getActionButton(DialogAction.POSITIVE).setOnClickListener(v -> {
-                ActivityCompat.requestPermissions(activity,PERMISSIONS, 66);
-                materialDialog.dismiss();
-            });
-            materialDialog.getActionButton(DialogAction.NEGATIVE).setOnClickListener(v -> activity.finish());
-            materialDialog.setCancelable(false);
-            materialDialog.show();
-
-        } else {
-            // Contact permissions have not been granted yet. Request them directly.
-            ActivityCompat.requestPermissions(activity, PERMISSIONS, 66);
-        }
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java b/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
index fb98a3b38..739a64f28 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
@@ -75,6 +75,7 @@ import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
 import java.util.concurrent.atomic.AtomicLong;
 
 import jcifs.smb.SmbFile;
@@ -813,10 +814,10 @@ public class FileUtils {
         return b;
     }
 
-    public static ArrayList<HybridFile> toHybridFileArrayList(ArrayList<String> a) {
+    public static ArrayList<HybridFile> toHybridFileArrayList(LinkedList<String> a) {
         ArrayList<HybridFile> b = new ArrayList<>();
-        for (int i = 0; i < a.size(); i++) {
-            HybridFile hFile=new HybridFile(OpenMode.UNKNOWN,a.get(i));
+        for (String s : a) {
+            HybridFile hFile = new HybridFile(OpenMode.UNKNOWN, s);
             hFile.generateMode(null);
             b.add(hFile);
         }
diff --git a/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java b/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
index 8e1e8e4c5..318cac6e4 100644
--- a/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
+++ b/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
@@ -28,7 +28,6 @@ import android.content.ContentUris;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.content.IntentSender;
 import android.content.pm.PackageManager;
 import android.content.res.Configuration;
 import android.database.Cursor;
@@ -62,7 +61,6 @@ import android.support.v4.content.CursorLoader;
 import android.support.v4.content.Loader;
 import android.support.v4.widget.DrawerLayout;
 import android.text.TextUtils;
-import android.util.Log;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuInflater;
@@ -105,12 +103,12 @@ import com.amaze.filemanager.filesystem.RootHelper;
 import com.amaze.filemanager.fragments.AppsListFragment;
 import com.amaze.filemanager.fragments.CloudSheetFragment;
 import com.amaze.filemanager.fragments.CloudSheetFragment.CloudConnectionCallbacks;
+import com.amaze.filemanager.fragments.CompressedExplorerFragment;
 import com.amaze.filemanager.fragments.FTPServerFragment;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.fragments.ProcessViewerFragment;
 import com.amaze.filemanager.fragments.SearchWorkerFragment;
 import com.amaze.filemanager.fragments.TabFragment;
-import com.amaze.filemanager.fragments.ZipExplorerFragment;
 import com.amaze.filemanager.fragments.preference_fragments.QuickAccessPref;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.dialogs.RenameBookmark;
@@ -120,7 +118,6 @@ import com.amaze.filemanager.ui.dialogs.SmbConnectDialog.SmbConnectionListener;
 import com.amaze.filemanager.ui.drawer.EntryItem;
 import com.amaze.filemanager.ui.drawer.Item;
 import com.amaze.filemanager.ui.drawer.SectionItem;
-import com.amaze.filemanager.ui.views.RoundedImageView;
 import com.amaze.filemanager.ui.views.ScrimInsetsRelativeLayout;
 import com.amaze.filemanager.ui.views.appbar.AppBar;
 import com.amaze.filemanager.utils.BookSorter;
@@ -149,10 +146,6 @@ import com.cloudrail.si.services.GoogleDrive;
 import com.cloudrail.si.services.OneDrive;
 import com.github.clans.fab.FloatingActionButton;
 import com.github.clans.fab.FloatingActionMenu;
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.api.GoogleApiClient;
-import com.google.android.gms.plus.Plus;
-import com.google.android.gms.plus.model.people.Person;
 import com.readystatesoftware.systembartint.SystemBarTintManager;
 
 import java.io.File;
@@ -168,9 +161,7 @@ import static android.os.Build.VERSION.SDK_INT;
 import static com.amaze.filemanager.fragments.preference_fragments.PrefFrag.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
 import static com.amaze.filemanager.fragments.preference_fragments.PrefFrag.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
 
-public class MainActivity extends ThemedActivity implements
-        GoogleApiClient.ConnectionCallbacks,
-        GoogleApiClient.OnConnectionFailedListener, OnRequestPermissionsResultCallback,
+public class MainActivity extends ThemedActivity implements OnRequestPermissionsResultCallback,
         SmbConnectionListener, DataChangeListener, BookmarkCallback,
         SearchWorkerFragment.HelperCallbacks, CloudConnectionCallbacks,
         LoaderManager.LoaderCallbacks<Cursor> {
@@ -178,9 +169,6 @@ public class MainActivity extends ThemedActivity implements
     public static final Pattern DIR_SEPARATOR = Pattern.compile("/");
     public static final String TAG_ASYNC_HELPER = "async_helper";
 
-    /* Request code used to invoke sign in user interactions. */
-    static final int RC_SIGN_IN = 0;
-
     private DataUtils dataUtils = DataUtils.getInstance();
 
     public DrawerLayout mDrawerLayout;
@@ -240,20 +228,15 @@ public class MainActivity extends ThemedActivity implements
     private Toast toast = null;
     private ActionBarDrawerToggle mDrawerToggle;
     private Intent intent;
-    private GoogleApiClient mGoogleApiClient;
     private View drawerHeaderLayout;
     private View drawerHeaderView, indicator_layout;
-    private RoundedImageView drawerProfilePic;
     private ImageLoader mImageLoader;
 
-    private TextView mGoogleName, mGoogleId;
     private TabHandler tabHandler;
-    // Check for user interaction for Google+ api only once
-    private boolean mGoogleApiKey = false;
     /* A flag indicating that a PendingIntent is in progress and prevents
    * us from starting further intents.
    */
-    private boolean mIntentInProgress, showHidden = false;
+    private boolean showHidden = false;
     private AsyncTask<Void, Void, Boolean> cloudSyncTask;
 
     private AppBarLayout appBarLayout;
@@ -338,16 +321,6 @@ public class MainActivity extends ThemedActivity implements
         mainActivityHelper = new MainActivityHelper(this);
         initialiseFab();
 
-        // initialize g+ api client as per preferences
-        if (getPrefs().getBoolean("plus_pic", false)) {
-            mGoogleApiClient = new GoogleApiClient.Builder(this)
-                    .addConnectionCallbacks(this)
-                    .addOnConnectionFailedListener(this)
-                    .addApi(Plus.API)
-                    .addScope(Plus.SCOPE_PLUS_LOGIN)
-                    .build();
-        }
-
         if (CloudSheetFragment.isCloudProviderAvailable(this)) {
 
             getSupportLoaderManager().initLoader(REQUEST_CODE_CLOUD_LIST_KEYS, null, this);
@@ -506,6 +479,7 @@ public class MainActivity extends ThemedActivity implements
             public <E> E doInBackground() {
 
                 dataUtils.setHiddenFiles(utilsHandler.getHiddenFilesConcurrentRadixTree());
+                dataUtils.setHistory(utilsHandler.getHistoryLinkedList());
                 dataUtils.setGridfiles(utilsHandler.getGridViewList());
                 dataUtils.setListfiles(utilsHandler.getListViewList());
                 dataUtils.setBooks(utilsHandler.getBookmarksList());
@@ -772,25 +746,25 @@ public class MainActivity extends ThemedActivity implements
             } else {
                 getCurrentMainFragment().goBack();
             }
-        } else if (fragment instanceof ZipExplorerFragment) {
-            ZipExplorerFragment zipExplorerFragment = (ZipExplorerFragment)  getFragmentAtFrame();
-            if (zipExplorerFragment.mActionMode == null) {
-                if (zipExplorerFragment.canGoBack()) {
-                    zipExplorerFragment.goBack();
+        } else if (fragment instanceof CompressedExplorerFragment) {
+            CompressedExplorerFragment compressedExplorerFragment = (CompressedExplorerFragment)  getFragmentAtFrame();
+            if (compressedExplorerFragment.mActionMode == null) {
+                if (compressedExplorerFragment.canGoBack()) {
+                    compressedExplorerFragment.goBack();
                 } else if (openzip) {
                     openzip = false;
                     finish();
                 } else {
                     FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
                     fragmentTransaction.setCustomAnimations(R.anim.slide_out_bottom, R.anim.slide_out_bottom);
-                    fragmentTransaction.remove(zipExplorerFragment);
+                    fragmentTransaction.remove(compressedExplorerFragment);
                     fragmentTransaction.commit();
                     supportInvalidateOptionsMenu();
                     floatingActionButton.setVisibility(View.VISIBLE);
                     floatingActionButton.showMenuButton(true);
                 }
             } else {
-                zipExplorerFragment.mActionMode.finish();
+                compressedExplorerFragment.mActionMode.finish();
             }
         } else if (fragment instanceof FTPServerFragment) {
             //returning back from FTP server
@@ -1030,7 +1004,7 @@ public class MainActivity extends ThemedActivity implements
             menu.findItem(R.id.hiddenitems).setVisible(false);
             menu.findItem(R.id.view).setVisible(false);
             menu.findItem(R.id.paste).setVisible(false);
-        } else if (fragment instanceof ZipExplorerFragment) {
+        } else if (fragment instanceof CompressedExplorerFragment) {
             appbar.setTitle(R.string.appbar_name);
             menu.findItem(R.id.sethome).setVisible(false);
             if (indicator_layout != null) indicator_layout.setVisibility(View.GONE);
@@ -1186,8 +1160,8 @@ public class MainActivity extends ThemedActivity implements
                 break;
             case R.id.extract:
                 Fragment fragment1 = getFragmentAtFrame();
-                if (fragment1 instanceof ZipExplorerFragment) {
-                    mainActivityHelper.extractFile(((ZipExplorerFragment) fragment1).realZipFile);
+                if (fragment1 instanceof CompressedExplorerFragment) {
+                    mainActivityHelper.extractFile(((CompressedExplorerFragment) fragment1).compressedFile);
                 }
                 break;
             case R.id.search:
@@ -1357,9 +1331,9 @@ public class MainActivity extends ThemedActivity implements
         appBarLayout.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start();
         FragmentTransaction fragmentTransaction = getSupportFragmentManager().beginTransaction();
         fragmentTransaction.setCustomAnimations(R.anim.slide_in_top, R.anim.slide_in_bottom);
-        Fragment zipFragment = new ZipExplorerFragment();
+        Fragment zipFragment = new CompressedExplorerFragment();
         Bundle bundle = new Bundle();
-        bundle.putString(ZipExplorerFragment.KEY_PATH, path);
+        bundle.putString(CompressedExplorerFragment.KEY_PATH, path);
         zipFragment.setArguments(bundle);
         fragmentTransaction.add(R.id.content_frame, zipFragment);
         fragmentTransaction.commitAllowingStateLoss();
@@ -1552,139 +1526,14 @@ public class MainActivity extends ThemedActivity implements
         mDrawerList.setAdapter(adapter);
     }
 
-    @Override
-    protected void onStart() {
-        super.onStart();
-
-        // check if user enabled g+ api from preferences
-        if (mGoogleApiClient != null)
-            mGoogleApiClient.connect();
-    }
-
-    @Override
-    protected void onStop() {
-        super.onStop();
-
-        if (mGoogleApiClient != null && mGoogleApiClient.isConnected())
-            mGoogleApiClient.disconnect();
-    }
-
-    @Override
-    public void onConnected(Bundle bundle) {
-        if (Plus.PeopleApi.getCurrentPerson(mGoogleApiClient) != null) {
-            Person currentPerson = Plus.PeopleApi.getCurrentPerson(mGoogleApiClient);
-            String accountName = Plus.AccountApi.getAccountName(mGoogleApiClient);
-            Person.Image personImage;
-            Person.Cover.CoverPhoto personCover;
-
-            try {
-                personImage = currentPerson.getImage();
-                personCover = currentPerson.getCover().getCoverPhoto();
-            } catch (Exception e) {
-
-                personCover = null;
-                personImage = null;
-            }
-
-            if (personCover != null && personImage != null) {
-                String imgUrl = personImage.getUrl();
-
-                // getting full size image
-                StringBuilder stringBuilder = new StringBuilder();
-                stringBuilder.append(imgUrl);
-                stringBuilder.delete(imgUrl.length() - 6, imgUrl.length());
-                Log.d("G+", stringBuilder.toString());
-                mGoogleName.setText(currentPerson.getDisplayName());
-                mGoogleId.setText(accountName);
-                // setting cover pic
-                mImageLoader.get(personCover.getUrl(), new ImageLoader.ImageListener() {
-                    @Override
-                    public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
-                        drawerHeaderParent.setBackgroundColor(Color.parseColor("#ffffff"));
-                        if (SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-                            drawerHeaderView.setBackground(new BitmapDrawable(response.getBitmap()));
-                        } else
-                            drawerHeaderView.setBackgroundDrawable(new BitmapDrawable(response.getBitmap()));
-                    }
-
-                    @Override
-                    public void onErrorResponse(VolleyError error) {
-                        Toast.makeText(MainActivity.this, getString(R.string.no_cover_photo),
-                                Toast.LENGTH_LONG).show();
-                    }
-                });
-
-                // setting profile pic
-                mImageLoader.get(stringBuilder.toString(), new ImageLoader.ImageListener() {
-                    @Override
-                    public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
-                        drawerProfilePic.setImageBitmap(response.getBitmap());
-                        drawerProfilePic.setVisibility(View.VISIBLE);
-                    }
-
-                    @Override
-                    public void onErrorResponse(VolleyError error) {
-                        Toast.makeText(MainActivity.this, getString(R.string.no_profile_pic),
-                                Toast.LENGTH_LONG).show();
-                    }
-                });
-            } else {
-                Toast.makeText(this, getResources().getText(R.string.no_cover_photo), Toast.LENGTH_SHORT).show();
-                drawerHeaderView.setBackgroundResource(R.drawable.amaze_header);
-                drawerHeaderParent.setBackgroundColor(getColorPreference().getColor(ColorUsage.getPrimary(MainActivity.currentTab)));
-            }
-        }
-    }
-
-    @Override
-    public void onConnectionSuspended(int i) {
-        Log.d("G+", "Connection suspended");
-        new Thread(() -> {
-            if (mGoogleApiClient != null)
-                mGoogleApiClient.connect();
-        }).run();
-    }
-
-    public void onConnectionFailed(final ConnectionResult result) {
-        Log.d("G+", "Connection failed" + result.getErrorCode() + result.getErrorCode());
-        if (!mIntentInProgress && result.hasResolution()) {
-            new Thread(() -> {
-                try {
-                    mIntentInProgress = true;
-                    startIntentSenderForResult(result.getResolution().getIntentSender(),
-                            RC_SIGN_IN, null, 0, 0, 0);
-                } catch (IntentSender.SendIntentException e) {
-                    // The intent was canceled before it was sent.  Return to the default
-                    // state and attempt to connect to get an updated ConnectionResult.
-                    mIntentInProgress = false;
-                    if (mGoogleApiClient != null) {
-
-                        mGoogleApiClient.connect();
-                    }
-                }
-            }).run();
-        }
-    }
-
     public AppBar getAppbar() {
         return appbar;
     }
 
     protected void onActivityResult(int requestCode, int responseCode, Intent intent) {
-        if (requestCode == RC_SIGN_IN && !mGoogleApiKey && mGoogleApiClient != null) {
-            new Thread(() -> {
-                mIntentInProgress = false;
-                mGoogleApiKey = true;
-                // !mGoogleApiClient.isConnecting
-                if (mGoogleApiClient.isConnecting()) {
-                    mGoogleApiClient.connect();
-                } else
-                    mGoogleApiClient.disconnect();
-
-            }).run();
-        } else if (requestCode == image_selector_request_code) {
+        if (requestCode == image_selector_request_code) {
             if (getPrefs() != null && intent != null && intent.getData() != null) {
-                if (SDK_INT >= 19)
+                if (SDK_INT >= Build.VERSION_CODES.KITKAT)
                     getContentResolver().takePersistableUriPermission(intent.getData(),
                             Intent.FLAG_GRANT_READ_URI_PERMISSION);
                 getPrefs().edit().putString("drawer_header_path", intent.getData().toString()).commit();
@@ -1801,7 +1650,7 @@ public class MainActivity extends ThemedActivity implements
         drawerHeaderView = drawerHeaderLayout.findViewById(R.id.drawer_header);
         drawerHeaderView.setOnLongClickListener(v -> {
             Intent intent1;
-            if (SDK_INT < 19) {
+            if (SDK_INT < Build.VERSION_CODES.KITKAT) {
                 intent1 = new Intent();
                 intent1.setAction(Intent.ACTION_GET_CONTENT);
             } else {
@@ -1813,9 +1662,6 @@ public class MainActivity extends ThemedActivity implements
             startActivityForResult(intent1, image_selector_request_code);
             return false;
         });
-        drawerProfilePic = (RoundedImageView) drawerHeaderLayout.findViewById(R.id.profile_pic);
-        mGoogleName = (TextView) drawerHeaderLayout.findViewById(R.id.account_header_drawer_name);
-        mGoogleId = (TextView) drawerHeaderLayout.findViewById(R.id.account_header_drawer_email);
         setSupportActionBar(getAppbar().getToolbar());
         frameLayout = (FrameLayout) findViewById(R.id.content_frame);
         indicator_layout = findViewById(R.id.indicator_layout);
@@ -1904,14 +1750,14 @@ public class MainActivity extends ThemedActivity implements
         //getSupportActionBar().setBackgroundDrawable(new ColorDrawable(Color.parseColor((currentTab==1 ? skinTwo : skin))));
 
         // status bar0
-        if (SDK_INT == 20 || SDK_INT == 19) {
+        if (SDK_INT == Build.VERSION_CODES.KITKAT_WATCH || SDK_INT == Build.VERSION_CODES.KITKAT) {
             SystemBarTintManager tintManager = new SystemBarTintManager(this);
             tintManager.setStatusBarTintEnabled(true);
             //tintManager.setStatusBarTintColor(Color.parseColor((currentTab==1 ? skinTwo : skin)));
             FrameLayout.MarginLayoutParams p = (ViewGroup.MarginLayoutParams) findViewById(R.id.drawer_layout).getLayoutParams();
             SystemBarTintManager.SystemBarConfig config = tintManager.getConfig();
             if (!isDrawerLocked) p.setMargins(0, config.getStatusBarHeight(), 0, 0);
-        } else if (SDK_INT >= 21) {
+        } else if (SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             Window window = getWindow();
             window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
             //window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
@@ -1944,7 +1790,7 @@ public class MainActivity extends ThemedActivity implements
             if (colourednavigation)
                 mainActivity.getWindow().setNavigationBarColor(PreferenceUtils
                         .getStatusColor(colorDrawable.getColor()));
-        } else if (SDK_INT == 20 || SDK_INT == 19) {
+        } else if (SDK_INT == Build.VERSION_CODES.KITKAT_WATCH || SDK_INT == Build.VERSION_CODES.KITKAT) {
 
             // for kitkat devices, the status bar color
             SystemBarTintManager tintManager = new SystemBarTintManager(this);
@@ -2124,27 +1970,24 @@ public class MainActivity extends ThemedActivity implements
     }
 
     void setDrawerHeaderBackground() {
-        new Thread(() -> {
-            if (getPrefs().getBoolean("plus_pic", false)) return;
-            String path1 = getPrefs().getString("drawer_header_path", null);
-            if (path1 == null) return;
-            try {
-                final ImageView headerImageView = new ImageView(MainActivity.this);
-                headerImageView.setImageDrawable(drawerHeaderParent.getBackground());
-                mImageLoader.get(path1, new ImageLoader.ImageListener() {
-                    @Override
-                    public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
-                        headerImageView.setImageBitmap(response.getBitmap());
-                        drawerHeaderView.setBackgroundResource(R.drawable.amaze_header_2);
-                    }
+        String path1 = getPrefs().getString("drawer_header_path", null);
+        if (path1 == null) return;
+        try {
+            final ImageView headerImageView = new ImageView(MainActivity.this);
+            headerImageView.setImageDrawable(drawerHeaderParent.getBackground());
+            mImageLoader.get(path1, new ImageLoader.ImageListener() {
+                @Override
+                public void onResponse(ImageLoader.ImageContainer response, boolean isImmediate) {
+                    headerImageView.setImageBitmap(response.getBitmap());
+                    drawerHeaderView.setBackgroundResource(R.drawable.amaze_header_2);
+                }
 
-                    @Override
-                    public void onErrorResponse(VolleyError error) {}
-                });
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }).run();
+                @Override
+                public void onErrorResponse(VolleyError error) {}
+            });
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
     }
 
     private BroadcastReceiver receiver2 = new BroadcastReceiver() {
