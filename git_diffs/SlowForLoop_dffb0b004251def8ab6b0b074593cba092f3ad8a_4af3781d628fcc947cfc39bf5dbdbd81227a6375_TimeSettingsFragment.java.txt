diff --git a/app/src/main/java/com/chess/clock/activities/TimerSettingsActivity.java b/app/src/main/java/com/chess/clock/activities/TimerSettingsActivity.java
index 7a94dd4..b7e6a74 100644
--- a/app/src/main/java/com/chess/clock/activities/TimerSettingsActivity.java
+++ b/app/src/main/java/com/chess/clock/activities/TimerSettingsActivity.java
@@ -1,5 +1,6 @@
 package com.chess.clock.activities;
 
+import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
@@ -8,6 +9,8 @@ import android.os.Bundle;
 import android.os.IBinder;
 import android.util.Log;
 import android.view.MenuItem;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
 import android.widget.Toast;
 
 import androidx.annotation.NonNull;
@@ -23,6 +26,7 @@ import com.chess.clock.fragments.TimeSettingsFragment;
 import com.chess.clock.service.ChessClockLocalService;
 
 import java.util.ArrayList;
+import java.util.Set;
 
 /**
  * Activity that manages TimeControl list in the Settings and also TimeControl form.
@@ -165,12 +169,21 @@ public class TimerSettingsActivity extends BaseActivity implements TimeSettingsF
     public boolean onOptionsItemSelected(MenuItem item) {
         // Respond to the action bar's Up/Home button
         if (item.getItemId() == android.R.id.home) {
+            hideKeyboard();
             showPopupOrFinish(RESULT_CANCELED);
             return true;
         }
         return super.onOptionsItemSelected(item);
     }
 
+    private void hideKeyboard() {
+        final InputMethodManager inputManager = (InputMethodManager) getSystemService(Activity.INPUT_METHOD_SERVICE);
+        View currentFocus = getCurrentFocus();
+        if (inputManager != null && currentFocus != null) {
+            inputManager.hideSoftInputFromWindow(currentFocus.getWindowToken(), 0);
+        }
+    }
+
     /**
      * @return True if clock was started before settings changes
      */
@@ -206,18 +219,18 @@ public class TimerSettingsActivity extends BaseActivity implements TimeSettingsF
      * @return Current checked position of TimeControl in the list.
      */
     @Override
-    public int getCheckedTimeControlIndex() {
-        return timeControlManager.getEditableTimeControlCheckIndex();
+    public long getCheckedTimeControlId() {
+        return timeControlManager.getEditableTimeControlCheckId();
     }
 
     /**
      * Used as communication gateway by SettingsFragment.
      *
-     * @param idx time control list position.
+     * @param id time control wrapper id.
      */
     @Override
-    public void setCheckedTimeControlIndex(int idx) {
-        timeControlManager.setEditableTimeControlCheckIndex(idx);
+    public void setCheckedTimeControlId(long id) {
+        timeControlManager.setEditableTimeControlCheckId(id);
     }
 
     /**
@@ -235,20 +248,27 @@ public class TimerSettingsActivity extends BaseActivity implements TimeSettingsF
     /**
      * Used as communication gateway by SettingsFragment.
      *
-     * @param position TimeControl position in the list.
+     * @param wrapper TimeControlWrapper to edit.
      */
     @Override
-    public void loadTimeControl(int position) {
-        timeControlManager.prepareEditableTimeControl(position);
+    public void loadTimeControl(TimeControlWrapper wrapper) {
+        timeControlManager.prepareEditableTimeControl(wrapper);
         loadTimeControlFragment(true);
     }
 
     /**
      * Used as communication gateway by SettingsFragment.
+     *
+     * @param ids ids of controls to remove
      */
     @Override
-    public void removeTimeControl(int[] positions) {
-        timeControlManager.removeTimeControls(getApplicationContext(), positions);
+    public void removeTimeControl(Set<Long> ids) {
+        timeControlManager.removeTimeControls(getApplicationContext(), ids);
+    }
+
+    @Override
+    public void upDateOrderOnItemMove(int from, int to) {
+        timeControlManager.updateOrderOnItemMove(from, to, this);
     }
 
     /**
diff --git a/app/src/main/java/com/chess/clock/adapters/TimeControlAdapter.java b/app/src/main/java/com/chess/clock/adapters/TimeControlAdapter.java
deleted file mode 100644
index 2d2a26b..0000000
--- a/app/src/main/java/com/chess/clock/adapters/TimeControlAdapter.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package com.chess.clock.adapters;
-
-import android.content.Context;
-import android.content.res.ColorStateList;
-import android.os.Build;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-
-import androidx.appcompat.widget.AppCompatCheckedTextView;
-
-import com.chess.clock.R;
-import com.chess.clock.engine.TimeControlWrapper;
-import com.chess.clock.entities.AppTheme;
-
-import java.util.ArrayList;
-
-
-public class TimeControlAdapter extends ArrayAdapter<TimeControlWrapper> {
-
-    private ArrayList<TimeControlWrapper> data;
-    private ColorStateList radioButtonColors;
-
-    public TimeControlAdapter(
-            Context context,
-            ArrayList<TimeControlWrapper> timeControls,
-            AppTheme theme
-    ) {
-        super(context, R.layout.list_time_control_item_single_choice, R.id.time_control_text,
-                timeControls);
-        data = timeControls;
-        if (theme != null) {
-            radioButtonColors = theme.colorStateListChecked(getContext());
-        }
-    }
-
-    @Override
-    public int getCount() {
-        return data.size();
-    }
-
-    @Override
-    public TimeControlWrapper getItem(int position) {
-        return data.get(position);
-    }
-
-    @Override
-    public long getItemId(int position) {
-        return super.getItemId(position);
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-
-        AppCompatCheckedTextView row =
-                (AppCompatCheckedTextView) super.getView(position, convertView, parent);
-        TimeControlWrapper tc = getItem(position);
-        if (tc != null && tc.getTimeControlPlayerOne() != null) {
-            row.setText(tc.getTimeControlPlayerOne().getName());
-        } else {
-            row.setText(R.string.time_control);
-        }
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-            row.setCheckMarkTintList(radioButtonColors);
-        }
-        return row;
-    }
-
-    public void updateTheme(AppTheme theme) {
-        radioButtonColors = theme.colorStateListChecked(getContext());
-        notifyDataSetChanged();
-    }
-
-    public void updateTimeControls(ArrayList<TimeControlWrapper> currentTimeControls) {
-        data = currentTimeControls;
-        notifyDataSetChanged();
-    }
-}
diff --git a/app/src/main/java/com/chess/clock/adapters/TimeControlCABAdapter.java b/app/src/main/java/com/chess/clock/adapters/TimeControlCABAdapter.java
deleted file mode 100644
index 2c31e70..0000000
--- a/app/src/main/java/com/chess/clock/adapters/TimeControlCABAdapter.java
+++ /dev/null
@@ -1,113 +0,0 @@
-package com.chess.clock.adapters;
-
-import android.content.Context;
-import android.content.res.ColorStateList;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.ImageButton;
-import android.widget.TextView;
-
-import androidx.appcompat.widget.AppCompatCheckBox;
-import androidx.core.widget.CompoundButtonCompat;
-import androidx.fragment.app.Fragment;
-
-import com.chess.clock.R;
-import com.chess.clock.engine.TimeControl;
-import com.chess.clock.engine.TimeControlWrapper;
-import com.chess.clock.entities.AppTheme;
-import com.chess.clock.fragments.TimeSettingsFragment;
-
-import java.util.ArrayList;
-
-/**
- * TimeControl Adapter used when in Context Action Bar mode is activated.
- */
-public class TimeControlCABAdapter extends ArrayAdapter<TimeControlWrapper> {
-
-    private final int layoutResourceId;
-    private final ArrayList<TimeControlWrapper> data;
-    private final Fragment mTargetFragment;
-    private ColorStateList checkBoxColors;
-
-    public TimeControlCABAdapter(
-            Context context,
-            ArrayList<TimeControlWrapper> objects,
-            Fragment targetFragment,
-            AppTheme theme
-    ) {
-        super(context, R.layout.list_time_control_item_multi_choice, objects);
-        this.layoutResourceId = R.layout.list_time_control_item_multi_choice;
-        this.data = objects;
-        this.mTargetFragment = targetFragment;
-        if (theme != null) {
-            checkBoxColors = theme.colorStateListChecked(context);
-        }
-    }
-
-    @Override
-    public int getCount() {
-        return data.size();
-    }
-
-    @Override
-    public TimeControlWrapper getItem(int position) {
-        return data.get(position);
-    }
-
-    @Override
-    public long getItemId(int position) {
-        return super.getItemId(position);
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-
-        View row = convertView;
-        final TimeControlHolder holder;
-
-        if (row == null) {
-            LayoutInflater inflater = LayoutInflater.from(getContext());
-            row = inflater.inflate(layoutResourceId, parent, false);
-
-            holder = new TimeControlHolder();
-            holder.textView = row.findViewById(R.id.time_control_text);
-            holder.checkBox = row.findViewById(R.id.time_control_checkbox);
-
-            // Note: ImageButton must have the following attributes set to false to parent behave correctly: focusable.
-            holder.editImgBtn = row.findViewById(R.id.time_control_edit_image_btn);
-            holder.editImgBtn.setFocusable(false);
-            holder.editImgBtn.setOnClickListener(v -> {
-                int position1 = (Integer) holder.editImgBtn.getTag();
-                ((TimeSettingsFragment) mTargetFragment).loadTimeControl(position1);
-            });
-
-            row.setTag(holder);
-        } else {
-            holder = (TimeControlHolder) row.getTag();
-        }
-
-        holder.editImgBtn.setTag(position);
-
-        TimeControl tc = data.get(position).getTimeControlPlayerOne();
-        holder.textView.setText(tc.getName());
-
-        if (checkBoxColors != null) {
-            CompoundButtonCompat.setButtonTintList(holder.checkBox, checkBoxColors);
-        }
-
-        return row;
-    }
-
-    public void updateTheme(AppTheme theme) {
-        checkBoxColors = theme.colorStateListChecked(getContext());
-        notifyDataSetChanged();
-    }
-
-    static class TimeControlHolder {
-        AppCompatCheckBox checkBox;
-        TextView textView;
-        ImageButton editImgBtn;
-    }
-}
diff --git a/app/src/main/java/com/chess/clock/adapters/TimeRowMoveCallback.java b/app/src/main/java/com/chess/clock/adapters/TimeRowMoveCallback.java
new file mode 100644
index 0000000..3d38ebc
--- /dev/null
+++ b/app/src/main/java/com/chess/clock/adapters/TimeRowMoveCallback.java
@@ -0,0 +1,45 @@
+package com.chess.clock.adapters;
+
+import androidx.annotation.NonNull;
+import androidx.recyclerview.widget.ItemTouchHelper;
+import androidx.recyclerview.widget.RecyclerView;
+
+public class TimeRowMoveCallback extends ItemTouchHelper.Callback {
+
+    TimeItemTouchCallback touchCallback;
+
+    public TimeRowMoveCallback(TimeItemTouchCallback callback) {
+        this.touchCallback = callback;
+    }
+
+    @Override
+    public boolean isLongPressDragEnabled() {
+        return true;
+    }
+
+    @Override
+    public boolean isItemViewSwipeEnabled() {
+        return false;
+    }
+
+    @Override
+    public int getMovementFlags(@NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder) {
+        int drag = ItemTouchHelper.UP | ItemTouchHelper.DOWN;
+        return makeMovementFlags(drag, 0);
+    }
+
+    @Override
+    public boolean onMove(@NonNull RecyclerView recyclerView, @NonNull RecyclerView.ViewHolder viewHolder, @NonNull RecyclerView.ViewHolder target) {
+        this.touchCallback.onTimeItemMoved(viewHolder.getAdapterPosition(), target.getAdapterPosition());
+        return true;
+    }
+
+    @Override
+    public void onSwiped(@NonNull RecyclerView.ViewHolder viewHolder, int direction) {
+
+    }
+
+    public interface TimeItemTouchCallback {
+        void onTimeItemMoved(int from, int to);
+    }
+}
diff --git a/app/src/main/java/com/chess/clock/adapters/TimesAdapter.java b/app/src/main/java/com/chess/clock/adapters/TimesAdapter.java
new file mode 100644
index 0000000..c7e91bb
--- /dev/null
+++ b/app/src/main/java/com/chess/clock/adapters/TimesAdapter.java
@@ -0,0 +1,223 @@
+package com.chess.clock.adapters;
+
+import android.annotation.SuppressLint;
+import android.os.Build;
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+import androidx.annotation.NonNull;
+import androidx.appcompat.widget.AppCompatCheckedTextView;
+import androidx.recyclerview.widget.RecyclerView;
+
+import com.chess.clock.R;
+import com.chess.clock.engine.TimeControlWrapper;
+import com.chess.clock.entities.AppTheme;
+import com.chess.clock.views.ViewUtils;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+
+public class TimesAdapter extends RecyclerView.Adapter<TimesAdapter.TimeItemViewHolder> implements TimeRowMoveCallback.TimeItemTouchCallback {
+
+    private static final String KEY_EDIT_MODE = "times_adapter_edit_mode";
+    private static final String KEY_IDS_TO_REMOVE = "times_adapter_ids_to_remove_key";
+
+    ArrayList<TimeControlWrapper> data;
+    AppTheme theme;
+
+    long selectedItemId;
+    boolean editMode = false;
+
+    private final Set<Long> removeIds = new HashSet<>();
+    private final SelectedItemListener itemsListener;
+
+    public TimesAdapter(
+            ArrayList<TimeControlWrapper> data,
+            long selectedItemId,
+            AppTheme theme, SelectedItemListener listener) {
+        this.data = data;
+        this.selectedItemId = selectedItemId;
+        this.theme = theme;
+        this.itemsListener = listener;
+    }
+
+    @NonNull
+    @Override
+    public TimeItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
+        View itemView = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_view_time, parent, false);
+        return new TimeItemViewHolder(itemView);
+    }
+
+    @Override
+    public void onBindViewHolder(@NonNull TimeItemViewHolder holder, int position) {
+        TimeControlWrapper timeControlWrapper = data.get(position);
+        holder.setUpView(timeControlWrapper, theme, editMode, selectedItemId, removeIds);
+        long id = timeControlWrapper.getId();
+        holder.itemView.setOnClickListener(v -> {
+            if (editMode) {
+                if (removeIds.contains(id)) {
+                    removeIds.remove(id);
+                } else {
+                    removeIds.add(id);
+                }
+                itemsListener.onMarkItemToRemove(removeIds.size());
+                notifyItemChanged(position);
+            } else {
+                int oldSelectedItemPosition = getSelectedItemPosition();
+                selectedItemId = id;
+                itemsListener.onSelectedItemChange(selectedItemId);
+                notifyItemChanged(position);
+                notifyItemChanged(oldSelectedItemPosition);
+            }
+        });
+        holder.editButton.setOnClickListener(v -> itemsListener.onClickEdit(timeControlWrapper));
+        holder.itemView.setOnLongClickListener(v -> {
+                    boolean consumeLongClick = !editMode;
+                    if (consumeLongClick) {
+                        itemsListener.onItemLongClick();
+                    }
+                    return consumeLongClick;
+                }
+        );
+
+    }
+
+    private int getSelectedItemPosition() {
+        for (int i = 0; i < data.size(); i++) {
+            if (data.get(i).getId() == selectedItemId) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    @Override
+    public int getItemCount() {
+        return data.size();
+    }
+
+    @Override
+    public void onTimeItemMoved(int from, int to) {
+        itemsListener.onItemsReordered(from, to);
+        notifyItemMoved(from, to);
+    }
+
+    public Set<Long> getIdsToRemove() {
+        return removeIds;
+    }
+
+    @SuppressLint("NotifyDataSetChanged")
+    public void updateTheme(AppTheme theme) {
+        this.theme = theme;
+        notifyDataSetChanged();
+    }
+
+    @SuppressLint("NotifyDataSetChanged")
+    public void setEditMode(Boolean editMode) {
+        this.editMode = editMode;
+        notifyDataSetChanged();
+    }
+
+    public boolean inEditMode() {
+        return editMode;
+    }
+
+    public void saveInstanceState(Bundle outState) {
+        outState.putBoolean(KEY_EDIT_MODE, editMode);
+        long[] removeIdsArray = new long[removeIds.size()];
+        int idx = 0;
+        for (long id : removeIds) {
+            removeIdsArray[idx++] = id;
+        }
+        outState.putLongArray(KEY_IDS_TO_REMOVE, removeIdsArray);
+    }
+
+    public void restoreInstanceState(Bundle savedInstanceState) {
+        if (savedInstanceState == null) return;
+        editMode = savedInstanceState.getBoolean(KEY_EDIT_MODE);
+        removeIds.clear();
+        for (long id : savedInstanceState.getLongArray(KEY_IDS_TO_REMOVE)) {
+            removeIds.add(id);
+        }
+    }
+
+    public void clearRemoveIds() {
+        removeIds.clear();
+    }
+
+    public TimeControlWrapper getSelectedTimeControlWrapper() {
+        for (TimeControlWrapper wrapper : data) {
+            if (wrapper.getId() == selectedItemId) {
+                return wrapper;
+            }
+        }
+        return null;
+    }
+
+    public static class TimeItemViewHolder extends RecyclerView.ViewHolder {
+
+        AppCompatCheckedTextView nameTv;
+        ImageView checkBoxImg;
+        View editButton;
+        View reorderButton;
+
+        public TimeItemViewHolder(@NonNull View itemView) {
+            super(itemView);
+            nameTv = itemView.findViewById(R.id.nameTv);
+            checkBoxImg = itemView.findViewById(R.id.checkBoxImg);
+            editButton = itemView.findViewById(R.id.editBtn);
+            reorderButton = itemView.findViewById(R.id.reorderBtn);
+        }
+
+        public void setUpView(
+                TimeControlWrapper timeControlWrapper,
+                AppTheme theme,
+                boolean editMode,
+                long selectedItemId,
+                Set<Long> removeIds) {
+            nameTv.setText(timeControlWrapper.getTimeControlPlayerOne().getName());
+            if (editMode) {
+
+                boolean selectedToRemove = removeIds.contains(timeControlWrapper.getId());
+                if (selectedToRemove) {
+                    checkBoxImg.setImageResource(R.drawable.ic_check_box);
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                        checkBoxImg.setImageTintList(theme.primaryColorAsStateList(checkBoxImg.getContext()));
+                    }
+                } else {
+                    checkBoxImg.setImageResource(R.drawable.ic_check_box_frame);
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                        checkBoxImg.setImageTintList(null);
+                    }
+                }
+                nameTv.setCheckMarkDrawable(null);
+            } else {
+                nameTv.setCheckMarkDrawable(R.drawable.list_radio_button_selector);
+                nameTv.setChecked(selectedItemId == timeControlWrapper.getId());
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                    nameTv.setCheckMarkTintList(theme.colorStateListChecked(nameTv.getContext()));
+                }
+            }
+            reorderButton.setOnClickListener(v -> itemView.performLongClick());
+            ViewUtils.showView(checkBoxImg, editMode);
+            ViewUtils.showView(editButton, editMode);
+            ViewUtils.showView(reorderButton, editMode);
+        }
+    }
+
+    public interface SelectedItemListener {
+        void onSelectedItemChange(long itemId);
+
+        void onMarkItemToRemove(int removeItemsCount);
+
+        void onClickEdit(TimeControlWrapper wrapper);
+
+        void onItemsReordered(int from, int to);
+
+        void onItemLongClick();
+    }
+}
diff --git a/app/src/main/java/com/chess/clock/engine/TimeControlDefaults.java b/app/src/main/java/com/chess/clock/engine/TimeControlDefaults.java
index 88897b8..59bad3c 100644
--- a/app/src/main/java/com/chess/clock/engine/TimeControlDefaults.java
+++ b/app/src/main/java/com/chess/clock/engine/TimeControlDefaults.java
@@ -27,7 +27,7 @@ public class TimeControlDefaults {
     /**
      * index of `10 min` preset
      */
-    public static int DEFAULT_TIME_INDEX = 7;
+    public static long DEFAULT_TIME_ID = 7L;
 
     /**
      * Creates default TimeControl list, saves it on shared preferences.
@@ -37,8 +37,9 @@ public class TimeControlDefaults {
     public static ArrayList<TimeControlWrapper> buildDefaultTimeControlsList(Context context) {
 
         ArrayList<TimeControlWrapper> timeControls = new ArrayList<>();
-        for (TimePreset timePreset : PRESETS) {
-            timeControls.add(timePreset.toTimeControl(context));
+        for (int i = 0, presetsSize = PRESETS.size(); i < presetsSize; i++) {
+            TimePreset timePreset = PRESETS.get(i);
+            timeControls.add(timePreset.toTimeControl(context, i));
         }
 
         // Saving default time controls
@@ -69,11 +70,11 @@ public class TimeControlDefaults {
             }
         }
 
-        TimeControlWrapper toTimeControl(Context context) {
+        TimeControlWrapper toTimeControl(Context context, int defaultIndex) {
             TimeIncrement timeIncrement = new TimeIncrement(TimeIncrement.Type.FISCHER, incrementSeconds * 1000L);
             Stage stage = new Stage(0, minutes * 60 * 1000L, timeIncrement);
             TimeControl timeControl = new TimeControl(getName(context), new Stage[]{stage});
-            return new TimeControlWrapper(timeControl, timeControl);
+            return new TimeControlWrapper(defaultIndex, defaultIndex, timeControl, timeControl);
         }
     }
 
diff --git a/app/src/main/java/com/chess/clock/engine/TimeControlManager.java b/app/src/main/java/com/chess/clock/engine/TimeControlManager.java
index b6a314e..f62011e 100644
--- a/app/src/main/java/com/chess/clock/engine/TimeControlManager.java
+++ b/app/src/main/java/com/chess/clock/engine/TimeControlManager.java
@@ -6,6 +6,8 @@ import android.os.Bundle;
 import android.util.Log;
 
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Set;
 
 /**
  * Helper for TimeControl list management.
@@ -16,7 +18,7 @@ public class TimeControlManager {
     /**
      * Save instance state keys
      */
-    private final String KEY_EDITABLE_TIME_CONTROL_CHECK_INDEX = "key_time_control_checked";
+    private final String KEY_EDITABLE_TIME_CONTROL_CHECK_ID = "key_time_control_checked";
     private final String KEY_EDITABLE_TIME_CONTROL = "key_editable_time_control";
     private final String KEY_EDITABLE_STAGE_NEW_FLAG = "key_editable_time_control_new_flag";
     /**
@@ -24,7 +26,7 @@ public class TimeControlManager {
      */
     private ArrayList<TimeControlWrapper> mTimeControls;   // List of time control wrappers.
     private TimeControlWrapper mEditableTimeControl;       // Copy of a TimeControl for edit purpose.
-    private int mEditableTimeControlCheckIndex;     // Position of TimeControl in the list.
+    private long editableTimeControlCheckId;     // Id of TimeControl in the list.
     private boolean isNewEditableTimeControl;       // Flag to add new TimeControl in the list after edit.
     /**
      * Listener used to dispatch updates.
@@ -40,17 +42,20 @@ public class TimeControlManager {
 
         // Check for configuration change.
         if (savedInstanceState != null) {
-            mEditableTimeControlCheckIndex = savedInstanceState.getInt(KEY_EDITABLE_TIME_CONTROL_CHECK_INDEX, 1);
+            editableTimeControlCheckId = savedInstanceState.getInt(KEY_EDITABLE_TIME_CONTROL_CHECK_ID, 1);
             mEditableTimeControl = savedInstanceState.getParcelable(KEY_EDITABLE_TIME_CONTROL);
             isNewEditableTimeControl = savedInstanceState.getBoolean(KEY_EDITABLE_STAGE_NEW_FLAG, true);
         } else {
             // First launch, fetch last check position.
-            mEditableTimeControlCheckIndex = TimeControlParser.getLastTimeControlCheckIndex(context);
+            editableTimeControlCheckId = TimeControlParser.getLastTimeControlCheckId(context);
             isNewEditableTimeControl = true;
         }
 
         // Get time controls stored on shared preferences.
         mTimeControls = TimeControlParser.restoreTimeControlsList(context);
+        if (mTimeControls != null) {
+            Collections.sort(mTimeControls, (o1, o2) -> Integer.compare(o1.getOrder(), o2.getOrder()));
+        }
 
         // Build default List if none was restored from shared preferences.
         if (mTimeControls == null || mTimeControls.size() == 0) {
@@ -75,7 +80,7 @@ public class TimeControlManager {
      */
     public void onSaveInstanceState(Bundle outState) {
         if (outState != null) {
-            outState.putInt(KEY_EDITABLE_TIME_CONTROL_CHECK_INDEX, mEditableTimeControlCheckIndex);
+            outState.putLong(KEY_EDITABLE_TIME_CONTROL_CHECK_ID, editableTimeControlCheckId);
             outState.putParcelable(KEY_EDITABLE_TIME_CONTROL, mEditableTimeControl);
             outState.putBoolean(KEY_EDITABLE_STAGE_NEW_FLAG, isNewEditableTimeControl);
         }
@@ -94,7 +99,7 @@ public class TimeControlManager {
      * Save the last time control check position in the list.
      */
     public void saveTimeControlIndex(Context context) {
-        TimeControlParser.saveTimeControlCheckIndex(context, mEditableTimeControlCheckIndex);
+        TimeControlParser.saveTimeControlCheckIndex(context, editableTimeControlCheckId);
     }
 
     /**
@@ -107,35 +112,37 @@ public class TimeControlManager {
             if (isNewEditableTimeControl) {
                 // Prepend editable time control in the list.
                 mTimeControls.add(0, mEditableTimeControl);
-                setEditableTimeControlCheckIndex(0);
+                setEditableTimeControlCheckId(mEditableTimeControl.getId());
             } else {
                 // replace time control in the list with the editable time control.
-                mTimeControls.set(mEditableTimeControlCheckIndex, mEditableTimeControl);
+                for (int i = 0; i < mTimeControls.size(); i++) {
+                    TimeControlWrapper timeControlWrapper = mTimeControls.get(i);
+                    if (timeControlWrapper.getId() == mEditableTimeControl.getId()) {
+                        mTimeControls.set(i, mEditableTimeControl);
+                    }
+                }
             }
 
             // reset editable time control object
             mEditableTimeControl = null;
         }
-
-        // Save modified time control list in shared preferences.
-        TimeControlParser.saveTimeControls(context, mTimeControls);
+        updateItemsOrderAndSave(context);
     }
 
     /**
      * Remove TimeControl objects from the List.
      *
-     * @param positions array with object to remove index positions in the list.
+     * @param ids ids of objects to remove.
      */
-    public void removeTimeControls(Context context, int[] positions) {
+    public void removeTimeControls(Context context, Set<Long> ids) {
         Log.v(TAG, "Received time controls remove request");
-
         ArrayList<TimeControlWrapper> objectBatchToDelete = new ArrayList<>();
-        for (int position : positions) {
-            if (position >= 0 && position < mTimeControls.size()) {
-                Log.v(TAG, "Removing time control (" + position + "): " + mTimeControls.get(position).getTimeControlPlayerOne().getName());
-                objectBatchToDelete.add(mTimeControls.get(position));
+        for (TimeControlWrapper tc : mTimeControls) {
+            if (ids.contains(tc.getId())) {
+                objectBatchToDelete.add(tc);
             }
         }
+
         mTimeControls.removeAll(objectBatchToDelete);
 
         if (mTimeControls.size() == 0) {
@@ -146,20 +153,22 @@ public class TimeControlManager {
 
         } else {
             Log.v(TAG, "Requesting to save the remaining " + mTimeControls.size() + " time controls.");
-            // save modified time control list.
-            TimeControlParser.saveTimeControls(context, mTimeControls);
+            updateItemsOrderAndSave(context);
         }
     }
 
     /**
-     * Produces a deep copy of the TimeControl object in position.
-     *
-     * @param position position of the TimeControl object in the list.
+     * Produces a deep copy of the TimeControlWrapper object to edit.
      */
-    public void prepareEditableTimeControl(int position) {
+    public void prepareEditableTimeControl(TimeControlWrapper wrapper) {
         isNewEditableTimeControl = false;
-        mEditableTimeControlCheckIndex = position;
-        mEditableTimeControl = buildEditableTimeControl(position);
+        editableTimeControlCheckId = wrapper.getId();
+        try {
+            mEditableTimeControl = (TimeControlWrapper) wrapper.clone();
+        } catch (CloneNotSupportedException e) {
+            e.printStackTrace();
+            throw new IllegalStateException("Could not build editable time control.");
+        }
     }
 
     /**
@@ -174,9 +183,11 @@ public class TimeControlManager {
         Stage stage2 = new Stage(1, 60 * 60 * 1000L, TimeIncrement.defaultIncrement());
         TimeControl blank = new TimeControl(null, new Stage[]{stage1, stage2});
 
-        // Set current editable time control with a new "blank" time control
+        long id = System.currentTimeMillis(); // supported locally, unique enough
+        int order = -1; // add item at start, order will be updated before saving
         try {
-            mEditableTimeControl = new TimeControlWrapper(blank, (TimeControl) blank.clone());
+            // Set current editable time control with a new "blank" time control
+            mEditableTimeControl = new TimeControlWrapper(id, order, blank, (TimeControl) blank.clone());
         } catch (CloneNotSupportedException e) {
             e.printStackTrace();
             throw new IllegalStateException("Could not create Editable time control with blank time control.");
@@ -192,45 +203,32 @@ public class TimeControlManager {
         return mEditableTimeControl;
     }
 
-    /**
-     * Get current checked position of TimeControl in the list.
-     *
-     * @return current checked position of TimeControl in the list.
-     */
-    public int getEditableTimeControlCheckIndex() {
-        return mEditableTimeControlCheckIndex;
+    public long getEditableTimeControlCheckId() {
+        return editableTimeControlCheckId;
     }
 
-    /**
-     * Get current checked position of TimeControl in the list.
-     *
-     * @param idx current checked position of TimeControl in the list.
-     */
-    public void setEditableTimeControlCheckIndex(int idx) {
-        mEditableTimeControlCheckIndex = idx;
+    public void setEditableTimeControlCheckId(long id) {
+        editableTimeControlCheckId = id;
     }
 
-    /**
-     * Get Editable copy of selected time control. This copy will replace the original time control
-     * if the user presses "Done" on the time control edit menu.
-     *
-     * @param position Position of time control in the list.
-     * @return Copy of TimeControl object.
-     * @throws IllegalStateException if editable time control is unable to be built
-     */
-    private TimeControlWrapper buildEditableTimeControl(int position) {
-
-        if (position >= 0 && position < mTimeControls.size()) {
-
-            TimeControlWrapper original = mTimeControls.get(position);
-            try {
-                return (TimeControlWrapper) original.clone();
-            } catch (CloneNotSupportedException e) {
-                e.printStackTrace();
-                throw new IllegalStateException("Could not build editable time control.");
+    public void updateOrderOnItemMove(int from, int to, Context context) {
+        if (from < to) {
+            for (int i = from; i < to; i++) {
+                Collections.swap(mTimeControls, i, i + 1);
             }
+        } else {
+            for (int i = from; i > to; i--) {
+                Collections.swap(mTimeControls, i, i - 1);
+            }
+        }
+        updateItemsOrderAndSave(context);
+    }
+
+    private void updateItemsOrderAndSave(Context context) {
+        for (int i = 0; i < mTimeControls.size(); i++) {
+            mTimeControls.get(i).setOrder(i);
         }
-        return null;
+        TimeControlParser.saveTimeControls(context, mTimeControls);
     }
 
     /**
diff --git a/app/src/main/java/com/chess/clock/engine/TimeControlParser.java b/app/src/main/java/com/chess/clock/engine/TimeControlParser.java
index 3c0661f..277e637 100644
--- a/app/src/main/java/com/chess/clock/engine/TimeControlParser.java
+++ b/app/src/main/java/com/chess/clock/engine/TimeControlParser.java
@@ -25,9 +25,10 @@ public class TimeControlParser {
     private static final String TAG = TimeControlParser.class.getName();
 
     private static final String TIME_CONTROLS_PREF_NAME = "timeControls";
-    private static final String TIME_CONTROL_SELECTED_PREF_IDX = "timeControlIdx";
+    private static final String TIME_CONTROL_SELECTED_PREF_ID = "timeControlId";
     private static final String TIME_CONTROLS_PREF_FIELD_NAME = "json";
     private static final String TC_JSON_ID = "id";
+    private static final String TC_JSON_ORDER = "order";
     private static final String TC_JSON_DURATION = "duration";
     private static final String TC_JSON_MOVES = "moves";
     private static final String TC_JSON_VALUE = "value";
@@ -58,12 +59,17 @@ public class TimeControlParser {
             timeControls = TimeControlDefaults.buildDefaultTimeControlsList(context);
         }
 
-        int index = getLastTimeControlCheckIndex(context);
-        index = Math.max(index, 0);
-        index = Math.min(index, timeControls.size() - 1);
+        long id = getLastTimeControlCheckId(context);
+        TimeControlWrapper selectedControl = timeControls.get(0);
+        for (TimeControlWrapper tc : timeControls) {
+            if (tc.getId() == id) {
+                selectedControl = tc;
+                break;
+            }
+        }
 
-        TimeControl playerOne = timeControls.get(index).getTimeControlPlayerOne();
-        TimeControl playerTwo = timeControls.get(index).getTimeControlPlayerTwo();
+        TimeControl playerOne = selectedControl.getTimeControlPlayerOne();
+        TimeControl playerTwo = selectedControl.getTimeControlPlayerTwo();
 
         Intent startServiceIntent =
                 ChessClockLocalService.getChessClockServiceIntent(context, playerOne, playerTwo);
@@ -104,8 +110,10 @@ public class TimeControlParser {
                 timeControlJSONObject.put(TC_JSON_STAGES, timeControlStagesJSONArray);
                 timeControlJSONObject.put(TC_JSON_STAGES_PLAYER_TWO, timeControlStagesPlayerTwoJSONArray);
 
-                // Add same as player one boolean
+                // Add wrapper params
                 timeControlJSONObject.put(TC_JSON_SAME_AS_PLAYER_ONE, tc.isSameAsPlayerOne());
+                timeControlJSONObject.put(TC_JSON_ID, tc.getId());
+                timeControlJSONObject.put(TC_JSON_ORDER, tc.getOrder());
 
                 // Add TimeControl json object to JSONArray
                 timeControlJSONArray.put(timeControlJSONObject);
@@ -142,15 +150,15 @@ public class TimeControlParser {
     }
 
     /**
-     * Stores the selected time control position in the time control list.
+     * Stores the selected time control id.
      *
-     * @param idx list index.
+     * @param id selected item id.
      */
     @SuppressLint("ApplySharedPref")
-    public static void saveTimeControlCheckIndex(Context context, int idx) {
+    public static void saveTimeControlCheckIndex(Context context, long id) {
         SharedPreferences sp = getSharedPreferences(context);
         SharedPreferences.Editor spe = sp.edit();
-        spe.putInt(TIME_CONTROL_SELECTED_PREF_IDX, idx);
+        spe.putLong(TIME_CONTROL_SELECTED_PREF_ID, id);
         spe.commit();
     }
 
@@ -160,10 +168,9 @@ public class TimeControlParser {
      *
      * @return position of the last selected time control in the list.
      */
-    public static int getLastTimeControlCheckIndex(Context context) {
+    public static long getLastTimeControlCheckId(Context context) {
         SharedPreferences sp = getSharedPreferences(context);
-        int idx = sp.getInt(TIME_CONTROL_SELECTED_PREF_IDX, TimeControlDefaults.DEFAULT_TIME_INDEX);
-        return Math.max(idx, 0);
+        return sp.getLong(TIME_CONTROL_SELECTED_PREF_ID, TimeControlDefaults.DEFAULT_TIME_ID);
     }
 
     /**
@@ -210,9 +217,14 @@ public class TimeControlParser {
                 boolean isSameAsPlayerOne = !timeControlJSON.has(TC_JSON_SAME_AS_PLAYER_ONE) ||
                         timeControlJSON.getBoolean(TC_JSON_SAME_AS_PLAYER_ONE);
 
+                // ids and order simply migrated from old model
+                long id = timeControlJSON.has(TC_JSON_ID) ? timeControlJSON.getInt(TC_JSON_ID) : i;
+                int order = timeControlJSON.has(TC_JSON_ORDER) ? timeControlJSON.getInt(TC_JSON_ORDER) : i;
+
                 TimeControl timeControl = new TimeControl(name, stages);
                 TimeControl timeControlPlayerTwo = new TimeControl(name, stagesPlayerTwo);
-                TimeControlWrapper wrapper = new TimeControlWrapper(timeControl, timeControlPlayerTwo);
+
+                TimeControlWrapper wrapper = new TimeControlWrapper(id, order, timeControl, timeControlPlayerTwo);
                 wrapper.setSameAsPlayerOne(isSameAsPlayerOne);
                 timeControls.add(wrapper);
             }
diff --git a/app/src/main/java/com/chess/clock/engine/TimeControlWrapper.java b/app/src/main/java/com/chess/clock/engine/TimeControlWrapper.java
index 6849a70..f6ba7b4 100644
--- a/app/src/main/java/com/chess/clock/engine/TimeControlWrapper.java
+++ b/app/src/main/java/com/chess/clock/engine/TimeControlWrapper.java
@@ -3,18 +3,32 @@ package com.chess.clock.engine;
 import android.os.Parcel;
 import android.os.Parcelable;
 
+import androidx.annotation.NonNull;
+
 public class TimeControlWrapper implements Parcelable, Cloneable {
     private TimeControl mTimeControlPlayerOne;
     private TimeControl mTimeControlPlayerTwo;
-    private boolean mSameAsPlayerOne;
 
-    public TimeControlWrapper(TimeControl playerOne, TimeControl playerTwo) {
+    private boolean mSameAsPlayerOne;
+    private long id;
+    private int order;
+
+    public TimeControlWrapper(
+            long id,
+            int order,
+            TimeControl playerOne,
+            TimeControl playerTwo
+    ) {
+        this.id = id;
+        this.order = order;
         mTimeControlPlayerOne = playerOne;
         mTimeControlPlayerTwo = playerTwo;
         mSameAsPlayerOne = true;
     }
 
     private TimeControlWrapper(Parcel in) {
+        id = in.readLong();
+        order = in.readInt();
         mTimeControlPlayerOne = in.readParcelable(TimeControl.class.getClassLoader());
         mTimeControlPlayerTwo = in.readParcelable(TimeControl.class.getClassLoader());
         mSameAsPlayerOne = in.readByte() != 0;
@@ -22,6 +36,8 @@ public class TimeControlWrapper implements Parcelable, Cloneable {
 
     @Override
     public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(id);
+        dest.writeInt(order);
         dest.writeParcelable(mTimeControlPlayerOne, flags);
         dest.writeParcelable(mTimeControlPlayerTwo, flags);
         dest.writeByte((byte) (mSameAsPlayerOne ? 1 : 0));
@@ -64,6 +80,7 @@ public class TimeControlWrapper implements Parcelable, Cloneable {
         mSameAsPlayerOne = sameAsPlayerOne;
     }
 
+    @NonNull
     @Override
     public Object clone() throws CloneNotSupportedException {
         TimeControlWrapper clone = (TimeControlWrapper) super.clone();
@@ -72,7 +89,8 @@ public class TimeControlWrapper implements Parcelable, Cloneable {
         clone.mTimeControlPlayerOne = (TimeControl) mTimeControlPlayerOne.clone();
         clone.mTimeControlPlayerTwo = (TimeControl) mTimeControlPlayerTwo.clone();
         clone.mSameAsPlayerOne = mSameAsPlayerOne;
-
+        clone.order = order;
+        clone.id = id;
         return clone;
     }
 
@@ -84,7 +102,9 @@ public class TimeControlWrapper implements Parcelable, Cloneable {
     public boolean isEqual(TimeControlWrapper wrapper) {
         return mTimeControlPlayerOne.isEqual(wrapper.getTimeControlPlayerOne()) &&
                 mTimeControlPlayerTwo.isEqual(wrapper.getTimeControlPlayerTwo()) &&
-                mSameAsPlayerOne == wrapper.isSameAsPlayerOne();
+                mSameAsPlayerOne == wrapper.isSameAsPlayerOne() &&
+                id == wrapper.id &&
+                order == wrapper.order;
     }
 
     public boolean bothUsersHaveAtLeastOneStage() {
@@ -94,4 +114,16 @@ public class TimeControlWrapper implements Parcelable, Cloneable {
             return mTimeControlPlayerOne.getStageManager().getTotalStages() > 0 && mTimeControlPlayerTwo.getStageManager().getTotalStages() > 0;
         }
     }
+
+    public long getId() {
+        return id;
+    }
+
+    public int getOrder() {
+        return order;
+    }
+
+    public void setOrder(int newOrder) {
+        this.order = newOrder;
+    }
 }
diff --git a/app/src/main/java/com/chess/clock/fragments/BaseFragment.java b/app/src/main/java/com/chess/clock/fragments/BaseFragment.java
index fd6f287..d45eaae 100644
--- a/app/src/main/java/com/chess/clock/fragments/BaseFragment.java
+++ b/app/src/main/java/com/chess/clock/fragments/BaseFragment.java
@@ -1,5 +1,10 @@
 package com.chess.clock.fragments;
 
+import android.os.Bundle;
+import android.view.View;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import androidx.fragment.app.Fragment;
 
 import com.chess.clock.activities.BaseActivity;
@@ -10,16 +15,32 @@ import com.chess.clock.entities.AppTheme;
  */
 public abstract class BaseFragment extends Fragment {
     AppTheme loadedTheme;
+    boolean shouldReloadTheme = false;
+
+    @Override
+    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
+        shouldReloadTheme = true;
+        super.onViewCreated(view, savedInstanceState);
+    }
 
     @Override
     public void onResume() {
         super.onResume();
-        AppTheme activityTheme = ((BaseActivity) requireActivity()).selectedTheme;
-        if (activityTheme != loadedTheme) {
+        AppTheme activityTheme = getBaseActivity().selectedTheme;
+
+        if (activityTheme == null) return;
+
+        if (activityTheme != loadedTheme || shouldReloadTheme) {
             loadedTheme = activityTheme;
             loadTheme(loadedTheme);
+            shouldReloadTheme = false;
         }
     }
 
+    @NonNull
+    private BaseActivity getBaseActivity() {
+        return (BaseActivity) requireActivity();
+    }
+
     abstract void loadTheme(AppTheme theme);
 }
diff --git a/app/src/main/java/com/chess/clock/fragments/TimeControlFragment.java b/app/src/main/java/com/chess/clock/fragments/TimeControlFragment.java
index 6685904..afcb543 100644
--- a/app/src/main/java/com/chess/clock/fragments/TimeControlFragment.java
+++ b/app/src/main/java/com/chess/clock/fragments/TimeControlFragment.java
@@ -186,25 +186,6 @@ public class TimeControlFragment extends BaseFragment implements EditStageDialog
         return v;
     }
 
-    private void loadStages() {
-        Stage[] stages = selectedTimeControl.getStageManager().getStages();
-        ViewUtils.showView(addStageView, stages.length < Stage.MAX_ALLOWED_STAGES_COUNT);
-        int i = 0;
-        while (i < Stage.MAX_ALLOWED_STAGES_COUNT) {
-            StageRowView row = (StageRowView) stagesList.getChildAt(i);
-            if (i < stages.length) {
-                Stage stage = stages[i];
-                row.updateData(i + 1, stage);
-                row.setOnClickListener(v -> showStageEditorDialog(stage));
-                row.setVisibility(View.VISIBLE);
-            } else {
-                row.setOnClickListener(null);
-                row.setVisibility(View.GONE);
-            }
-            i++;
-        }
-    }
-
     @Override
     public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
         super.onViewCreated(view, savedInstanceState);
@@ -285,11 +266,6 @@ public class TimeControlFragment extends BaseFragment implements EditStageDialog
         updateUi();
     }
 
-    private void updateUi() {
-        ViewUtils.showView(baseView, !advancedMode && !editMode);
-        ViewUtils.showView(advancedView, advancedMode || editMode);
-    }
-
     @Override
     public void onSaveInstanceState(Bundle outState) {
         outState.putParcelable(STATE_TIME_CONTROL_SNAPSHOT_KEY, mTimeControlSnapshot);
@@ -304,13 +280,34 @@ public class TimeControlFragment extends BaseFragment implements EditStageDialog
         timeControlListener = null;
     }
 
+    private void loadStages() {
+        Stage[] stages = selectedTimeControl.getStageManager().getStages();
+        ViewUtils.showView(addStageView, stages.length < Stage.MAX_ALLOWED_STAGES_COUNT);
+        int i = 0;
+        while (i < Stage.MAX_ALLOWED_STAGES_COUNT) {
+            StageRowView row = (StageRowView) stagesList.getChildAt(i);
+            if (i < stages.length) {
+                Stage stage = stages[i];
+                row.updateData(i + 1, stage);
+                row.setOnClickListener(v -> showStageEditorDialog(stage));
+                row.setVisibility(View.VISIBLE);
+            } else {
+                row.setOnClickListener(null);
+                row.setVisibility(View.GONE);
+            }
+            i++;
+        }
+    }
+
+    private void updateUi() {
+        ViewUtils.showView(baseView, !advancedMode && !editMode);
+        ViewUtils.showView(advancedView, advancedMode || editMode);
+    }
+
     private void saveTimeControl() {
         if (timeControlWrapper == null) return;
 
-        // Hide soft keyboard
-        nameEt.clearFocus();
-        InputMethodManager imm = (InputMethodManager) requireActivity().getSystemService(Service.INPUT_METHOD_SERVICE);
-        imm.hideSoftInputFromWindow(nameEt.getWindowToken(), 0);
+        hideSoftKeyboard();
 
         String newControlName = nameEt.getText().toString();
         if (newControlName.equals("")) {
@@ -354,6 +351,12 @@ public class TimeControlFragment extends BaseFragment implements EditStageDialog
         }
     }
 
+    private void hideSoftKeyboard() {
+        nameEt.clearFocus();
+        InputMethodManager imm = (InputMethodManager) requireActivity().getSystemService(Service.INPUT_METHOD_SERVICE);
+        imm.hideSoftInputFromWindow(nameEt.getWindowToken(), 0);
+    }
+
     private void updateStagesDisplay() {
         loadStages();
     }
@@ -369,14 +372,7 @@ public class TimeControlFragment extends BaseFragment implements EditStageDialog
     }
 
     private void addNewStage() {
-
-        // Hide soft keyboard
-        nameEt.clearFocus();
-        InputMethodManager imm =
-                (InputMethodManager) requireActivity().getSystemService(Service.INPUT_METHOD_SERVICE);
-        imm.hideSoftInputFromWindow(nameEt.getWindowToken(), 0);
-
-
+        hideSoftKeyboard();
         if (selectedTimeControl.getStageManager().canAddStage()) {
             selectedTimeControl.getStageManager().addNewStage();
             updateStagesDisplay();
diff --git a/app/src/main/java/com/chess/clock/fragments/TimeSettingsFragment.java b/app/src/main/java/com/chess/clock/fragments/TimeSettingsFragment.java
index 5723c6c..6c1d124 100644
--- a/app/src/main/java/com/chess/clock/fragments/TimeSettingsFragment.java
+++ b/app/src/main/java/com/chess/clock/fragments/TimeSettingsFragment.java
@@ -10,7 +10,6 @@ import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.util.Log;
-import android.util.SparseBooleanArray;
 import android.view.HapticFeedbackConstants;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -18,36 +17,35 @@ import android.view.MenuInflater;
 import android.view.MenuItem;
 import android.view.View;
 import android.view.ViewGroup;
-import android.widget.AbsListView;
-import android.widget.AdapterView;
 import android.widget.ImageView;
-import android.widget.ListView;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.appcompat.app.AppCompatActivity;
 import androidx.appcompat.view.ActionMode;
+import androidx.coordinatorlayout.widget.CoordinatorLayout;
 import androidx.core.content.ContextCompat;
 import androidx.fragment.app.DialogFragment;
 import androidx.fragment.app.FragmentActivity;
+import androidx.recyclerview.widget.ItemTouchHelper;
+import androidx.recyclerview.widget.RecyclerView;
 
 import com.chess.clock.R;
 import com.chess.clock.activities.AppSettingsActivity;
 import com.chess.clock.activities.TimerSettingsActivity;
-import com.chess.clock.adapters.TimeControlAdapter;
-import com.chess.clock.adapters.TimeControlCABAdapter;
+import com.chess.clock.adapters.TimeRowMoveCallback;
+import com.chess.clock.adapters.TimesAdapter;
 import com.chess.clock.engine.TimeControl;
 import com.chess.clock.engine.TimeControlWrapper;
 import com.chess.clock.entities.AppTheme;
 import com.chess.clock.service.ChessClockLocalService;
-import com.chess.clock.util.MultiSelectionUtil;
 import com.chess.clock.views.StyledButton;
 import com.chess.clock.views.ViewUtils;
 
 import java.util.ArrayList;
+import java.util.Set;
 
-
-public class TimeSettingsFragment extends BaseFragment implements MultiSelectionUtil.MultiChoiceModeListener {
+public class TimeSettingsFragment extends BaseFragment implements ActionMode.Callback {
 
     private static final String TAG = TimeSettingsFragment.class.getName();
 
@@ -58,43 +56,24 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
 
         ArrayList<TimeControlWrapper> getCurrentTimeControls();
 
-        int getCheckedTimeControlIndex();
+        long getCheckedTimeControlId();
 
-        void setCheckedTimeControlIndex(int position);
+        void setCheckedTimeControlId(long id);
 
-        void loadTimeControl(int position);
+        void loadTimeControl(TimeControlWrapper wrapper);
 
         void addTimeControl();
 
-        void removeTimeControl(int[] positions);
+        void removeTimeControl(Set<Long> ids);
+
+        void upDateOrderOnItemMove(int from, int to);
     }
 
     /**
      * Constants
      */
-    private static final String KEY_ACTION_MODE = "action_mode";
-    private static final String KEY_ITEM_SELECTED = "item_selected";
     private static final String TAG_RESET_DIALOG_FRAGMENT = "ResetDialogFragment";
 
-    /**
-     * Time Controls List Adapters and ActionMode helper.
-     */
-    private TimeControlAdapter adapter;
-    private TimeControlCABAdapter adapterCAB;
-    private MultiSelectionUtil.Controller mMultiSelectionController;
-
-    /**
-     * State
-     */
-    private int mItemChecked = -1;
-    private int mTotalItemChecked;
-    private boolean isMultiSelectionActive;
-
-    /**
-     * Util
-     */
-    private boolean multiSelectionFinishedByOnDestroyView;
-
     /**
      * Activity attached.
      */
@@ -103,9 +82,16 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
     /**
      * UI
      */
-    private ListView timesListView;
+    private RecyclerView timesRecyclerView;
     private StyledButton startBtn;
     private ImageView plusImg;
+    private ActionMode actionMode;
+
+    /**
+     * UI management
+     */
+    private TimesAdapter adapter;
+    ItemTouchHelper touchHelper;
 
     public TimeSettingsFragment() {
     }
@@ -121,36 +107,27 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
         }
 
         setHasOptionsMenu(true);
-        multiSelectionFinishedByOnDestroyView = false;
     }
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         View view = inflater.inflate(R.layout.fragment_settings, container, false);
-        initListViewAndHeaders(inflater, view);
+        initRecyclerViewAndHeaders(view);
         startBtn = view.findViewById(R.id.startBtn);
-        setupListViewAdapter(savedInstanceState);
+        setupRecyclerView(savedInstanceState);
         return view;
     }
 
     @Override
     public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
         super.onViewCreated(view, savedInstanceState);
-        AdapterView.OnItemClickListener itemClickListener = (parent, view1, position, id) -> {
-            if (mListener != null && timesListView != null) {
-                mItemChecked = position - timesListView.getHeaderViewsCount();
-                mListener.setCheckedTimeControlIndex(mItemChecked);
-            }
-        };
-        timesListView.setOnItemClickListener(itemClickListener);
         startBtn.setOnClickListener(v -> {
             TimerSettingsActivity activity = (TimerSettingsActivity) requireActivity();
 
             // Check if current time control selected is the same as the the list selected
             if (activity.showResetWarning()) {
                 ResetClockDialogFragment resetClockDialog = new ResetClockDialogFragment();
-                resetClockDialog.setTargetFragment(TimeSettingsFragment.this, 0);
-                resetClockDialog.show(activity.getSupportFragmentManager(), TAG_RESET_DIALOG_FRAGMENT);
+                resetClockDialog.show(getChildFragmentManager(), TAG_RESET_DIALOG_FRAGMENT);
             } else {
                 startNewClock();
             }
@@ -161,9 +138,6 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
     public void onResume() {
         super.onResume();
         requireActivity().setTitle(getString(R.string.time_controls));
-        if (timesListView != null && !isMultiSelectionActive) {
-            setListViewItemChecked();
-        }
     }
 
     @Override
@@ -172,24 +146,11 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
         if (adapter != null) {
             adapter.updateTheme(theme);
         }
-        if (adapterCAB != null) {
-            adapterCAB.updateTheme(theme);
-        }
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             plusImg.setImageTintList(theme.primaryColorAsStateList(getContext()));
         }
     }
 
-    @Override
-    public void onDestroyView() {
-        super.onDestroyView();
-        if (mMultiSelectionController != null && mMultiSelectionController.isActionModeActive()) {
-            multiSelectionFinishedByOnDestroyView = true;
-            mMultiSelectionController.finish();
-        }
-        mMultiSelectionController = null;
-    }
-
     @Override
     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
         super.onCreateOptionsMenu(menu, inflater);
@@ -198,37 +159,60 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
 
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.action_settings:
-                FragmentActivity activity = requireActivity();
-                startActivity(new Intent(activity, AppSettingsActivity.class));
-                activity.overridePendingTransition(R.anim.right_to_left_full, R.anim.right_to_left_out);
-                return true;
-            case R.id.action_edit:
-                startSettingsActionMode();
-                startBtn.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
-                        HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
-                return true;
-            default:
-                return super.onOptionsItemSelected(item);
+        int itemId = item.getItemId();
+        if (itemId == R.id.action_settings) {
+            FragmentActivity activity = requireActivity();
+            startActivity(new Intent(activity, AppSettingsActivity.class));
+            activity.overridePendingTransition(R.anim.right_to_left_full, R.anim.right_to_left_out);
+            return true;
+        } else if (itemId == R.id.action_edit) {
+            runEditMode(true);
+            return true;
         }
+        return super.onOptionsItemSelected(item);
     }
 
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        outState.putBoolean(KEY_ACTION_MODE, isMultiSelectionActive);
-        outState.putInt(KEY_ITEM_SELECTED, mItemChecked);
+    private void runEditMode(boolean hapticFeedback) {
+        ((AppCompatActivity) requireActivity()).startSupportActionMode(this);
+        if (hapticFeedback) {
+            startBtn.performHapticFeedback(
+                    HapticFeedbackConstants.LONG_PRESS,
+                    HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
+            );
+        }
+    }
 
-        if (mMultiSelectionController != null) {
-            mMultiSelectionController.saveInstanceState(outState);
+    private void editModeUiSetup(Boolean editMode) {
+        ViewUtils.showView(startBtn, !editMode);
+        adapter.setEditMode(editMode);
+
+        if (touchHelper == null) return;
+        if (editMode) {
+            setRecyclerBottomMargin(0);
+            touchHelper.attachToRecyclerView(timesRecyclerView);
+        } else {
+            int bottomMargin = getResources().getDimensionPixelSize(R.dimen.settings_margin_over_button);
+            setRecyclerBottomMargin(bottomMargin);
+            touchHelper.attachToRecyclerView(null);
         }
+    }
+
+    private void setRecyclerBottomMargin(int bottomMarginPx) {
+        CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) timesRecyclerView.getLayoutParams();
+        layoutParams.setMargins(0, 0, 0, bottomMarginPx);
+        timesRecyclerView.setLayoutParams(layoutParams);
+    }
 
+    @Override
+    public void onSaveInstanceState(@NonNull Bundle outState) {
+        adapter.saveInstanceState(outState);
         super.onSaveInstanceState(outState);
     }
 
     @SuppressLint("InflateParams")
-    private void initListViewAndHeaders(LayoutInflater inflater, View view) {
-        timesListView = view.findViewById(R.id.list_time_controls);
+    private void initRecyclerViewAndHeaders(View view) {
+        timesRecyclerView = view.findViewById(R.id.timesRecycler);
+        timesRecyclerView.setHasFixedSize(true);
         plusImg = view.findViewById(R.id.plusImg);
         View headerLogo = view.findViewById(R.id.logo);
         View headerTimeBtn = view.findViewById(R.id.timeBtn);
@@ -245,94 +229,83 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
         headerTimeBtn
                 .findViewById(R.id.timeBtn)
                 .setOnClickListener(v -> {
+                    quitActionMode();
                     mListener.addTimeControl();
                     startBtn.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
                             HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
                 });
     }
 
-    /**
-     * Set TimeControl ListView with proper Adapter and item(s) selection positions.
-     */
-    private void setupListViewAdapter(Bundle savedInstanceState) {
-
-        if (savedInstanceState != null) {
-            // Restore list selection mode.
-            isMultiSelectionActive = savedInstanceState.getBoolean(KEY_ACTION_MODE);
-            // Restore last list item check position
-            mItemChecked = savedInstanceState.getInt(KEY_ITEM_SELECTED, 0);
-        } else {
-            isMultiSelectionActive = false;
-            mItemChecked = mListener.getCheckedTimeControlIndex();
-        }
-
-        // Init the CAB helper
-        mMultiSelectionController = MultiSelectionUtil.attachMultiSelectionController(
-                timesListView, (AppCompatActivity) getActivity(), this);
-
-        if (isMultiSelectionActive) {
-            adapterCAB = new TimeControlCABAdapter(
-                    getActivity(),
-                    mListener.getCurrentTimeControls(),
-                    this,
-                    loadedTheme
-            );
-            timesListView.setAdapter(adapterCAB);
-            timesListView.setChoiceMode(AbsListView.CHOICE_MODE_MULTIPLE);
-            mMultiSelectionController.tryRestoreInstanceState(savedInstanceState);
-
-            // Hide Start Button
-            startBtn.setVisibility(View.GONE);
-
-        } else {
-            adapter = new TimeControlAdapter(getActivity(), mListener.getCurrentTimeControls(), loadedTheme);
-            timesListView.setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
-            timesListView.setAdapter(adapter);
+    private void quitActionMode() {
+        if (actionMode != null) {
+            actionMode.finish();
         }
     }
 
     /**
-     * Change context action mode: time control list set to multi choice mode enabling to delete items.
-     * This swaps ListView Adapter, which changes list items layout.
+     * Set TimeControl RecyclerView with proper Adapter and item(s) selection positions.
      */
-    private void startSettingsActionMode() {
-
-        adapterCAB = new TimeControlCABAdapter(
-                getActivity(),
+    private void setupRecyclerView(Bundle savedInstanceState) {
+        adapter = new TimesAdapter(
                 mListener.getCurrentTimeControls(),
-                this,
-                loadedTheme
-        );
-        timesListView.setAdapter(adapterCAB);
-        timesListView.setChoiceMode(AbsListView.CHOICE_MODE_MULTIPLE);
-        mMultiSelectionController.startActionMode();
-
-        // Hide Start Button
-        startBtn.setVisibility(View.GONE);
-
-        // Reset number of selected time controls to delete.
-        mTotalItemChecked = 0;
+                mListener.getCheckedTimeControlId(),
+                loadedTheme,
+                new TimesAdapter.SelectedItemListener() {
+                    @Override
+                    public void onSelectedItemChange(long itemId) {
+                        mListener.setCheckedTimeControlId(itemId);
+                    }
+
+                    @Override
+                    public void onMarkItemToRemove(int removeItemsCount) {
+                        updateEditModeTitle(actionMode, removeItemsCount);
+                    }
+
+                    @Override
+                    public void onClickEdit(TimeControlWrapper wrapper) {
+                        loadTimeControlToEdit(wrapper);
+                    }
+
+                    @Override
+                    public void onItemsReordered(int from, int to) {
+                        mListener.upDateOrderOnItemMove(from, to);
+                    }
+
+                    @Override
+                    public void onItemLongClick() {
+                        runEditMode(true);
+                    }
+                });
+        ItemTouchHelper.Callback callback = new TimeRowMoveCallback(adapter);
+        touchHelper = new ItemTouchHelper(callback);
+
+        adapter.restoreInstanceState(savedInstanceState);
+
+        boolean editMode = adapter.inEditMode();
+        if (editMode) {
+            runEditMode(false);
+        }
+
+        ViewUtils.showView(startBtn, !editMode);
+        timesRecyclerView.setAdapter(adapter);
     }
 
+    @SuppressLint("NotifyDataSetChanged")
     public void refreshTimeControlList() {
         if (adapter != null) {
             adapter.notifyDataSetChanged();
         }
     }
 
-    public void loadTimeControl(int position) {
-
-        if (isMultiSelectionActive) {
-            mMultiSelectionController.finish();
-        }
+    public void loadTimeControlToEdit(TimeControlWrapper controlWrapper) {
 
-        mItemChecked = position;
-        mListener.setCheckedTimeControlIndex(mItemChecked);
+        quitActionMode();
+        mListener.setCheckedTimeControlId(controlWrapper.getId());
 
-        timesListView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
+        timesRecyclerView.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,
                 HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
 
-        mListener.loadTimeControl(mItemChecked);
+        mListener.loadTimeControl(controlWrapper);
     }
 
     @Override
@@ -340,14 +313,21 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
         // Inflate a menu resource providing context menu items
         MenuInflater inflater = actionMode.getMenuInflater();
         inflater.inflate(R.menu.settings_cab_actions, menu);
-        isMultiSelectionActive = true;
+        this.actionMode = actionMode;
+        editModeUiSetup(true);
         return true;
     }
 
     @Override
     public boolean onPrepareActionMode(ActionMode actionMode, Menu menu) {
-        actionMode.setTitle(mTotalItemChecked + " " + requireActivity().getString(R.string.settings_cab_title_time_controls_selected));
-        return false; // Return false if nothing is done
+        updateEditModeTitle(actionMode, adapter.getIdsToRemove().size());
+        return false;
+    }
+
+    private void updateEditModeTitle(ActionMode actionMode, int removeItemsCount) {
+        if (actionMode == null) return;
+        String title = getResources().getQuantityString(R.plurals.x_selected, removeItemsCount, removeItemsCount);
+        actionMode.setTitle(title);
     }
 
     @Override
@@ -363,91 +343,24 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
 
     @Override
     public void onDestroyActionMode(ActionMode actionMode) {
-        // On configuration change, API level 8 does not handle setting single choice in the middle of process.
-        if (!multiSelectionFinishedByOnDestroyView) {
-            setListSingleChoiceMode();
-        }
-        isMultiSelectionActive = false;
+        this.actionMode = null;
+        editModeUiSetup(false);
     }
 
-    @Override
-    public void onItemCheckedStateChanged(ActionMode mode, int position, boolean checked) {
+    private void deleteTimeControls(ActionMode mode) {
 
-        if (checked) {
-            mTotalItemChecked++;
-        } else {
-            mTotalItemChecked--;
-        }
-        mode.setTitle(mTotalItemChecked + " " + getString(R.string.settings_cab_title_time_controls_selected));
-    }
-
-    private void setListSingleChoiceMode() {
-        if (timesListView != null) {
-
-            mTotalItemChecked = 0;
-            if (adapter == null) {
-                adapter = new TimeControlAdapter(getActivity(), mListener.getCurrentTimeControls(), loadedTheme);
-            } else {
-                adapter.updateTimeControls(mListener.getCurrentTimeControls());
-            }
-            timesListView.setAdapter(adapter);
-            timesListView.setChoiceMode(AbsListView.CHOICE_MODE_SINGLE);
-            setListViewItemChecked();
-
-            mListener.setCheckedTimeControlIndex(mItemChecked);
-            startBtn.setVisibility(View.VISIBLE);
-        }
-    }
-
-    private void setListViewItemChecked() {
-        // Add header offset
-        int itemChecked = mItemChecked + timesListView.getHeaderViewsCount();
-        if (itemChecked <= 0) {
-            itemChecked = 1;
-            Log.w(TAG, "Caught itemChecked <= 0. Resetting to 1.");
-        }
-        timesListView.setItemChecked(itemChecked, true);
-    }
-
-    private void deleteTimeControls(ActionMode actionMode) {
-        Log.d(TAG, "Requested to delete " + mTotalItemChecked + " time controls.");
-
-        boolean updateList = false;
-        int[] positions = new int[mTotalItemChecked];
-        SparseBooleanArray checked = timesListView.getCheckedItemPositions();
-
-        int tmpItemChecked = mItemChecked;
-
-        // Get position of checked items
-        int k = 0;
-        for (int i = 0; i < checked.size(); i++) {
-            // If checked
-            if (checked.valueAt(i)) {
-                int position = checked.keyAt(i) - timesListView.getHeaderViewsCount();
-                Log.d(TAG, "Marking time control " + position + " to remove.");
-                positions[k] = position;
-                k++;
-                updateList = true;
-
-                // Update position of check item
-                if (position < mItemChecked) {
-                    tmpItemChecked--;
-                } else if (position == mItemChecked) {
-                    tmpItemChecked = 0;
-                }
-            }
-        }
-
-        mItemChecked = tmpItemChecked;
+        Set<Long> idsToRemove = adapter.getIdsToRemove();
+        Log.d(TAG, "Requested to delete " + idsToRemove.size() + " time controls.");
 
         // If checked items found request their removal.
-        if (updateList) {
+        if (!idsToRemove.isEmpty()) {
             AlertDialog.Builder builder = new AlertDialog.Builder(getActivity(), R.style.WhiteButtonsDialogTheme);
             builder
                     .setMessage(R.string.delete_custom_time)
                     .setPositiveButton(R.string.action_delete, (dialog, id) -> {
-                        mListener.removeTimeControl(positions);
-                        actionMode.finish();
+                        mListener.removeTimeControl(idsToRemove);
+                        adapter.clearRemoveIds();
+                        mode.finish();
                     })
                     .setNegativeButton(R.string.action_keep, (dialog, id) -> {
                         // Resume the clock
@@ -455,20 +368,17 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
             Dialog dialog = builder.create();
             ViewUtils.setLargePopupMessageTextSize(dialog, getResources());
             dialog.show();
-            // Note: No need to notifyDataSetChanged as mListView will have adapters swap.
         } else {
-            actionMode.finish();
+            mode.finish();
         }
     }
 
     public void startNewClock() {
-        int position = mItemChecked + timesListView.getHeaderViewsCount();
-        Log.d(TAG, "Starting new clock on list position: " + position);
-
-        TimeControlWrapper timeControlWrapper = (TimeControlWrapper) timesListView.getAdapter().getItem(position);
-        if (timeControlWrapper != null) {
-            TimeControl playerOne = timeControlWrapper.getTimeControlPlayerOne();
-            TimeControl playerTwo = timeControlWrapper.getTimeControlPlayerTwo();
+        TimeControlWrapper wrapper = adapter.getSelectedTimeControlWrapper();
+        Log.d(TAG, "Starting new clock: " + wrapper);
+        if (wrapper != null) {
+            TimeControl playerOne = wrapper.getTimeControlPlayerOne();
+            TimeControl playerTwo = wrapper.getTimeControlPlayerTwo();
             FragmentActivity activity = requireActivity();
             Intent startServiceIntent = ChessClockLocalService.getChessClockServiceIntent(activity.getApplicationContext(), playerOne, playerTwo);
             activity.startService(startServiceIntent);
@@ -497,7 +407,7 @@ public class TimeSettingsFragment extends BaseFragment implements MultiSelection
             AlertDialog.Builder builder = new AlertDialog.Builder(getActivity(), R.style.WhiteButtonsDialogTheme);
             builder.setMessage(R.string.dialog_clock_running_reset)
                     .setPositiveButton(R.string.dialog_yes, (dialog, id) -> {
-                        TimeSettingsFragment f = (TimeSettingsFragment) getTargetFragment();
+                        TimeSettingsFragment f = (TimeSettingsFragment) getParentFragment();
                         if (f != null) {
                             f.startNewClock();
                         }
diff --git a/app/src/main/java/com/chess/clock/util/MultiSelectionUtil.java b/app/src/main/java/com/chess/clock/util/MultiSelectionUtil.java
deleted file mode 100644
index c0a7360..0000000
--- a/app/src/main/java/com/chess/clock/util/MultiSelectionUtil.java
+++ /dev/null
@@ -1,175 +0,0 @@
-package com.chess.clock.util;
-
-import android.os.Bundle;
-import android.util.SparseBooleanArray;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.AbsListView;
-import android.widget.AdapterView;
-import android.widget.ListView;
-
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.appcompat.view.ActionMode;
-
-import java.util.ArrayList;
-
-/**
- * Utilities for handling multiple selection in list views. Contains functionality similar to
- * {@link AbsListView#CHOICE_MODE_MULTIPLE_MODAL} but that works with {@link AppCompatActivity} and
- * backward-compatible action bars.
- */
-public class MultiSelectionUtil {
-
-    public static Controller attachMultiSelectionController(final ListView listView,
-                                                            final AppCompatActivity activity,
-                                                            final MultiChoiceModeListener listener) {
-        return Controller.attach(listView, activity, listener);
-    }
-
-    /**
-     * @see android.widget.AbsListView.MultiChoiceModeListener
-     */
-    public interface MultiChoiceModeListener extends ActionMode.Callback {
-        /**
-         * @see android.widget.AbsListView.MultiChoiceModeListener#onItemCheckedStateChanged(
-         *android.view.ActionMode, int, long, boolean)
-         */
-        void onItemCheckedStateChanged(ActionMode mode,
-                                       int position, boolean checked);
-    }
-
-    public static class Controller implements ActionMode.Callback, AdapterView.OnItemClickListener {
-
-        private ActionMode mActionMode;
-        private ListView mListView = null;
-        private AppCompatActivity mActivity = null;
-        private MultiChoiceModeListener mListener = null;
-        private ArrayList<Integer> mItemsToCheck;
-        private AdapterView.OnItemClickListener mOldItemClickListener;
-
-        private Controller() {
-
-        }
-
-        public static Controller attach(ListView listView, AppCompatActivity activity,
-                                        MultiChoiceModeListener listener) {
-            Controller controller = new Controller();
-            controller.mListView = listView;
-            controller.mActivity = activity;
-            controller.mListener = listener;
-            return controller;
-        }
-
-        private void readInstanceState(Bundle savedInstanceState) {
-            if (savedInstanceState != null) {
-
-                ArrayList<Integer> checkedPos = savedInstanceState.getIntegerArrayList(getStateKey());
-                if (checkedPos != null && checkedPos.size() > 0) {
-                    mItemsToCheck = new ArrayList<>();
-                    for (int pos : checkedPos) {
-                        mItemsToCheck.add(pos);
-                    }
-                }
-            }
-        }
-
-        public void tryRestoreInstanceState(Bundle savedInstanceState) {
-            if (mListView.getAdapter() == null) {
-                return;
-            }
-            readInstanceState(savedInstanceState);
-            mActionMode = mActivity.startSupportActionMode(Controller.this);
-        }
-
-        public void finish() {
-            if (mActionMode != null) {
-                mActionMode.finish();
-            }
-        }
-
-        public boolean saveInstanceState(Bundle outBundle) {
-            SparseBooleanArray checkedPositions = mListView.getCheckedItemPositions();
-            if (mActionMode != null && checkedPositions != null) {
-                ArrayList<Integer> positions = new ArrayList<>();
-                for (int i = 0; i < checkedPositions.size(); i++) {
-                    if (checkedPositions.valueAt(i)) {
-                        int position = checkedPositions.keyAt(i);
-                        positions.add(position);
-                    }
-                }
-
-                outBundle.putIntegerArrayList(getStateKey(), positions);
-                return true;
-            }
-            return false;
-        }
-
-        private String getStateKey() {
-            return MultiSelectionUtil.class.getSimpleName() + "_" + mListView.getId();
-        }
-
-        @Override
-        public boolean onCreateActionMode(ActionMode actionMode, Menu menu) {
-
-            if (mListener.onCreateActionMode(actionMode, menu)) {
-                mActionMode = actionMode;
-                mOldItemClickListener = mListView.getOnItemClickListener();
-                mListView.setOnItemClickListener(Controller.this);
-
-                if (mItemsToCheck != null) {
-
-                    for (Integer pos : mItemsToCheck) {
-                        mListView.setItemChecked(pos, true);
-                        mListener.onItemCheckedStateChanged(mActionMode, pos, true);
-                    }
-                }
-                return true;
-            }
-            return false;
-        }
-
-        @Override
-        public boolean onPrepareActionMode(ActionMode actionMode, Menu menu) {
-
-            if (mListener.onPrepareActionMode(actionMode, menu)) {
-                mActionMode = actionMode;
-                return true;
-            }
-            return false;
-        }
-
-        @Override
-        public boolean onActionItemClicked(ActionMode actionMode, MenuItem menuItem) {
-            return mListener.onActionItemClicked(actionMode, menuItem);
-        }
-
-        @Override
-        public void onDestroyActionMode(ActionMode actionMode) {
-            mListener.onDestroyActionMode(actionMode);
-            mListView.setOnItemClickListener(mOldItemClickListener);
-            mActionMode = null;
-        }
-
-        @Override
-        public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {
-            boolean checked = mListView.isItemChecked(position);
-            mListener.onItemCheckedStateChanged(mActionMode, position, checked);
-        }
-
-        public boolean startActionMode() {
-
-            if (mActionMode != null) {
-                return false;
-            }
-
-            mItemsToCheck = new ArrayList<>();
-            mActionMode = mActivity.startSupportActionMode(Controller.this);
-            return true;
-        }
-
-        public boolean isActionModeActive() {
-            return mActionMode != null;
-        }
-    }
-}
diff --git a/app/src/main/java/com/chess/clock/viewgroup/CheckableLinearLayout.java b/app/src/main/java/com/chess/clock/viewgroup/CheckableLinearLayout.java
deleted file mode 100644
index 1d463b4..0000000
--- a/app/src/main/java/com/chess/clock/viewgroup/CheckableLinearLayout.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.chess.clock.viewgroup;
-
-import android.content.Context;
-import android.util.AttributeSet;
-import android.widget.Checkable;
-import android.widget.LinearLayout;
-
-public class CheckableLinearLayout extends LinearLayout implements Checkable {
-
-    private static final int CHECKABLE_CHILD_INDEX = 0;
-    private Checkable child;
-
-    public CheckableLinearLayout(Context context, AttributeSet attrs) {
-        super(context, attrs);
-    }
-
-    @Override
-    protected void onFinishInflate() {
-        super.onFinishInflate();
-        child = (Checkable) getChildAt(CHECKABLE_CHILD_INDEX);
-    }
-
-    @Override
-    public boolean isChecked() {
-        return child.isChecked();
-    }
-
-    @Override
-    public void setChecked(boolean checked) {
-        child.setChecked(checked);
-    }
-
-    @Override
-    public void toggle() {
-        child.toggle();
-    }
-}
\ No newline at end of file
