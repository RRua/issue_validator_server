diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
index f73dee0d6..f8896b0fe 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
@@ -31,7 +31,7 @@ import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.Operations;
@@ -366,7 +366,7 @@ public class CopyService extends AbstractProgressiveService {
         // initial start of copy, initiate the watcher
         watcherUtil.watch(CopyService.this);
 
-        if (FileUtil.checkFolder((targetPath), c) == 1) {
+        if (FileProperties.checkFolder((targetPath), c) == 1) {
           for (int i = 0; i < sourceFiles.size(); i++) {
             sourceProgress = i;
             HybridFileParcelable f1 = (sourceFiles.get(i));
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
index 75c4e1050..a6d908372 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
@@ -26,7 +26,7 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.files.CryptUtil;
@@ -169,7 +169,7 @@ public class DecryptService extends AbstractProgressiveService {
       addFirstDatapoint(
           baseFile.getName(context), 1, totalSize, false); // we're using encrypt as move flag false
 
-      if (FileUtil.checkFolder(baseFileFolder, context) == 1) {
+      if (FileProperties.checkFolder(baseFileFolder, context) == 1) {
         serviceWatcherUtil.watch(DecryptService.this);
 
         // we're here to decrypt, we'll decrypt at a custom path.
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
index d8f7f3ea5..4af302053 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
@@ -26,7 +26,7 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.files.CryptUtil;
@@ -216,7 +216,7 @@ public class EncryptService extends AbstractProgressiveService {
       addFirstDatapoint(
           baseFile.getName(context), 1, totalSize, true); // we're using encrypt as move flag false
 
-      if (FileUtil.checkFolder(baseFile.getPath(), context) == 1) {
+      if (FileProperties.checkFolder(baseFile.getPath(), context) == 1) {
         serviceWatcherUtil.watch(EncryptService.this);
 
         // we're here to encrypt
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt
index eb87aba3b..f89a1e92b 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/DeleteOperation.kt
@@ -53,7 +53,7 @@ object DeleteOperation {
 
         // Try with Storage Access Framework.
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-            val document = FileUtil.getDocumentFile(file, true, context)
+            val document = ExternalSdCardOperation.getDocumentFile(file, true, context)
             if (document != null && document.delete()) {
                 return true
             }
@@ -89,9 +89,10 @@ object DeleteOperation {
 
         // Try with Storage Access Framework.
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP &&
-            FileUtil.isOnExtSdCard(file, context)
+            ExternalSdCardOperation.isOnExtSdCard(file, context)
         ) {
-            val document = FileUtil.getDocumentFile(file, false, context)
+            val document = ExternalSdCardOperation.getDocumentFile(file, false, context)
+            document ?: return true
             return document.delete()
         }
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ExternalSdCardOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ExternalSdCardOperation.kt
new file mode 100644
index 000000000..540daa734
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ExternalSdCardOperation.kt
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem
+
+import android.annotation.TargetApi
+import android.content.Context
+import android.net.Uri
+import android.os.Build
+import android.util.Log
+import androidx.documentfile.provider.DocumentFile
+import androidx.preference.PreferenceManager
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import java.io.File
+import java.io.IOException
+import java.util.*
+
+object ExternalSdCardOperation {
+    val LOG = "ExternalSdCardOperation"
+
+    /**
+     * Get a DocumentFile corresponding to the given file (for writing on ExtSdCard on Android 5). If
+     * the file is not existing, it is created.
+     *
+     * @param file The file.
+     * @param isDirectory flag indicating if the file should be a directory.
+     * @return The DocumentFile
+     */
+    @JvmStatic
+    fun getDocumentFile(
+        file: File,
+        isDirectory: Boolean,
+        context: Context
+    ): DocumentFile? {
+        if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.KITKAT) return DocumentFile.fromFile(file)
+        val baseFolder = getExtSdCardFolder(file, context)
+        var originalDirectory = false
+        if (baseFolder == null) {
+            return null
+        }
+        var relativePath: String? = null
+        try {
+            val fullPath = file.canonicalPath
+            if (baseFolder != fullPath) {
+                relativePath = fullPath.substring(baseFolder.length + 1)
+            } else {
+                originalDirectory = true
+            }
+        } catch (e: IOException) {
+            return null
+        }
+
+        val preferenceUri = PreferenceManager.getDefaultSharedPreferences(context)
+            .getString(PreferencesConstants.PREFERENCE_URI, null)
+        var treeUri: Uri? = null
+        if (preferenceUri != null) {
+            treeUri = Uri.parse(preferenceUri)
+        }
+        if (treeUri == null) {
+            return null
+        }
+
+        // start with root of SD card and then parse through document tree.
+        var document = DocumentFile.fromTreeUri(context, treeUri)
+        if (originalDirectory || relativePath == null) {
+            return document
+        }
+
+        val parts = relativePath.split("\\/").toTypedArray()
+        for (i in parts.indices) {
+            if (document == null) {
+                return null
+            }
+
+            var nextDocument = document.findFile(parts[i])
+            if (nextDocument == null) {
+                nextDocument = if (i < parts.size - 1 || isDirectory) {
+                    document.createDirectory(parts[i])
+                } else {
+                    document.createFile("image", parts[i])
+                }
+            }
+            document = nextDocument
+        }
+
+        return document
+    }
+
+    /**
+     * Get a list of external SD card paths. (Kitkat or higher.)
+     *
+     * @return A list of external SD card paths.
+     */
+    @JvmStatic
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private fun getExtSdCardPaths(context: Context): Array<String> {
+        val paths: MutableList<String> = ArrayList()
+        for (file in context.getExternalFilesDirs("external")) {
+            if (file != null && file != context.getExternalFilesDir("external")) {
+                val index = file.absolutePath.lastIndexOf("/Android/data")
+                if (index < 0) {
+                    Log.w(LOG, "Unexpected external file dir: " + file.absolutePath)
+                } else {
+                    var path = file.absolutePath.substring(0, index)
+                    try {
+                        path = File(path).canonicalPath
+                    } catch (e: IOException) {
+                        // Keep non-canonical path.
+                    }
+                    paths.add(path)
+                }
+            }
+        }
+        if (paths.isEmpty()) paths.add("/storage/sdcard1")
+        return paths.toTypedArray()
+    }
+
+    @JvmStatic
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    fun getExtSdCardPathsForActivity(context: Context): Array<String> {
+        val paths: MutableList<String> = ArrayList()
+        for (file in context.getExternalFilesDirs("external")) {
+            if (file != null) {
+                val index = file.absolutePath.lastIndexOf("/Android/data")
+                if (index < 0) {
+                    Log.w(LOG, "Unexpected external file dir: " + file.absolutePath)
+                } else {
+                    var path = file.absolutePath.substring(0, index)
+                    try {
+                        path = File(path).canonicalPath
+                    } catch (e: IOException) {
+                        // Keep non-canonical path.
+                    }
+                    paths.add(path)
+                }
+            }
+        }
+        if (paths.isEmpty()) paths.add("/storage/sdcard1")
+        return paths.toTypedArray()
+    }
+
+    /**
+     * Determine the main folder of the external SD card containing the given file.
+     *
+     * @param file the file.
+     * @return The main folder of the external SD card containing this file, if the file is on an SD
+     * card. Otherwise, null is returned.
+     */
+    @JvmStatic
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    public fun getExtSdCardFolder(file: File, context: Context): String? {
+        val extSdPaths = getExtSdCardPaths(context)
+        try {
+            for (i in extSdPaths.indices) {
+                if (file.canonicalPath.startsWith(extSdPaths[i])) {
+                    return extSdPaths[i]
+                }
+            }
+        } catch (e: IOException) {
+            return null
+        }
+        return null
+    }
+
+    /**
+     * Determine if a file is on external sd card. (Kitkat or higher.)
+     *
+     * @param file The file.
+     * @return true if on external sd card.
+     */
+    @JvmStatic
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    fun isOnExtSdCard(file: File, c: Context): Boolean {
+        return getExtSdCardFolder(file, c) != null
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt b/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt
index 705999599..ed1584bfd 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt
@@ -21,11 +21,18 @@
 package com.amaze.filemanager.filesystem
 
 import android.content.Context
+import android.os.Build
+import com.amaze.filemanager.database.CloudHandler
 import com.amaze.filemanager.filesystem.DeleteOperation.deleteFile
+import com.amaze.filemanager.filesystem.ExternalSdCardOperation.isOnExtSdCard
+import com.amaze.filemanager.filesystem.smb.CifsContexts
+import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
+import com.amaze.filemanager.utils.OTGUtil
 import java.io.File
 import java.io.FileNotFoundException
 import java.io.FileOutputStream
 import java.io.IOException
+import java.util.regex.Pattern
 
 // TODO check if these can be done with just File methods
 // TODO make all of these methods File extensions
@@ -110,7 +117,7 @@ object FileProperties {
         }
 
         // Next check SAF writability.
-        val document = FileUtil.getDocumentFile(file, false, c)
+        val document = ExternalSdCardOperation.getDocumentFile(file, false, c)
         document ?: return false
 
         // This should have created the file - otherwise something is wrong with access URL.
@@ -120,4 +127,64 @@ object FileProperties {
         deleteFile(file, c)
         return result
     }
+
+    // Utility methods for Kitkat
+    /**
+     * Checks whether the target path exists or is writable
+     *
+     * @param f the target path
+     * @return 1 if exists or writable, 0 if not writable
+     */
+    @JvmStatic
+    fun checkFolder(f: String?, context: Context): Int {
+        if (f == null) return 0
+        if (f.startsWith(CifsContexts.SMB_URI_PREFIX) ||
+            f.startsWith(SshConnectionPool.SSH_URI_PREFIX) ||
+            f.startsWith(OTGUtil.PREFIX_OTG) ||
+            f.startsWith(CloudHandler.CLOUD_PREFIX_BOX) ||
+            f.startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE) ||
+            f.startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX) ||
+            f.startsWith(CloudHandler.CLOUD_PREFIX_ONE_DRIVE)
+        ) return 1
+        val folder = File(f)
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP &&
+            isOnExtSdCard(folder, context)
+        ) {
+            if (!folder.exists() || !folder.isDirectory) {
+                return 0
+            }
+
+            // On Android 5, trigger storage access framework.
+            if (isWritableNormalOrSaf(folder, context)) {
+                return 1
+            }
+        } else return if (Build.VERSION.SDK_INT == 19 &&
+            isOnExtSdCard(folder, context)
+        ) {
+            // Assume that Kitkat workaround works
+            1
+        } else if (folder.canWrite()) {
+            1
+        } else {
+            0
+        }
+        return 0
+    }
+
+    /**
+     * Validate given text is a valid filename.
+     *
+     * @param text
+     * @return true if given text is a valid filename
+     */
+    @JvmStatic
+    fun isValidFilename(text: String): Boolean {
+        val filenameRegex =
+            Pattern.compile("[\\\\\\/:\\*\\?\"<>\\|\\x01-\\x1F\\x7F]", Pattern.CASE_INSENSITIVE)
+
+        // It's not easy to use regex to detect single/double dot while leaving valid values
+        // (filename.zip) behind...
+        // So we simply use equality to check them
+        return !filenameRegex.matcher(text).find() && "." != text && ".." != text
+    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
index bcbde9337..64e0c8920 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
@@ -20,9 +20,6 @@
 
 package com.amaze.filemanager.filesystem;
 
-import static com.amaze.filemanager.filesystem.smb.CifsContexts.SMB_URI_PREFIX;
-import static com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_URI_PREFIX;
-
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.File;
@@ -32,24 +29,20 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.regex.Pattern;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.exceptions.NotAllowedException;
 import com.amaze.filemanager.exceptions.OperationWouldOverwriteException;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.cloud.CloudUtil;
 import com.amaze.filemanager.filesystem.files.GenericCopyUtil;
 import com.amaze.filemanager.ui.activities.MainActivity;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.SmbUtil;
 import com.cloudrail.si.interfaces.CloudStorage;
 
-import android.annotation.TargetApi;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.net.Uri;
@@ -60,7 +53,6 @@ import android.widget.Toast;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.documentfile.provider.DocumentFile;
-import androidx.preference.PreferenceManager;
 
 import io.reactivex.Maybe;
 import io.reactivex.MaybeObserver;
@@ -74,11 +66,6 @@ import kotlin.NotImplementedError;
 /** Utility class for helping parsing file systems. */
 public abstract class FileUtil {
 
-  private static final String LOG = "AmazeFileUtils";
-
-  private static final Pattern FILENAME_REGEX =
-      Pattern.compile("[\\\\\\/:\\*\\?\"<>\\|\\x01-\\x1F\\x7F]", Pattern.CASE_INSENSITIVE);
-
   /**
    * Determine the camera folder. There seems to be no Android API to work for real devices, so this
    * is a best guess.
@@ -98,7 +85,8 @@ public abstract class FileUtil {
     } else {
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
         // Storage Access Framework
-        DocumentFile targetDocument = getDocumentFile(target, false, context);
+        DocumentFile targetDocument =
+            ExternalSdCardOperation.getDocumentFile(target, false, context);
         if (targetDocument == null) return null;
         outStream = context.getContentResolver().openOutputStream(targetDocument.getUri());
       } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
@@ -163,7 +151,8 @@ public abstract class FileUtil {
                       }
 
                       DocumentFile targetDocumentFile =
-                          getDocumentFile(targetFile, false, mainActivity.getApplicationContext());
+                          ExternalSdCardOperation.getDocumentFile(
+                              targetFile, false, mainActivity.getApplicationContext());
 
                       // Fallback, in case getDocumentFile() didn't properly return a
                       // DocumentFile
@@ -314,201 +303,4 @@ public abstract class FileUtil {
               public void onComplete() {}
             });
   }
-
-  /**
-   * Get a list of external SD card paths. (Kitkat or higher.)
-   *
-   * @return A list of external SD card paths.
-   */
-  @TargetApi(Build.VERSION_CODES.KITKAT)
-  private static String[] getExtSdCardPaths(Context context) {
-    List<String> paths = new ArrayList<>();
-    for (File file : context.getExternalFilesDirs("external")) {
-      if (file != null && !file.equals(context.getExternalFilesDir("external"))) {
-        int index = file.getAbsolutePath().lastIndexOf("/Android/data");
-        if (index < 0) {
-          Log.w(LOG, "Unexpected external file dir: " + file.getAbsolutePath());
-        } else {
-          String path = file.getAbsolutePath().substring(0, index);
-          try {
-            path = new File(path).getCanonicalPath();
-          } catch (IOException e) {
-            // Keep non-canonical path.
-          }
-          paths.add(path);
-        }
-      }
-    }
-    if (paths.isEmpty()) paths.add("/storage/sdcard1");
-    return paths.toArray(new String[0]);
-  }
-
-  @TargetApi(Build.VERSION_CODES.KITKAT)
-  public static String[] getExtSdCardPathsForActivity(Context context) {
-    List<String> paths = new ArrayList<>();
-    for (File file : context.getExternalFilesDirs("external")) {
-      if (file != null) {
-        int index = file.getAbsolutePath().lastIndexOf("/Android/data");
-        if (index < 0) {
-          Log.w(LOG, "Unexpected external file dir: " + file.getAbsolutePath());
-        } else {
-          String path = file.getAbsolutePath().substring(0, index);
-          try {
-            path = new File(path).getCanonicalPath();
-          } catch (IOException e) {
-            // Keep non-canonical path.
-          }
-          paths.add(path);
-        }
-      }
-    }
-    if (paths.isEmpty()) paths.add("/storage/sdcard1");
-    return paths.toArray(new String[0]);
-  }
-
-  /**
-   * Determine the main folder of the external SD card containing the given file.
-   *
-   * @param file the file.
-   * @return The main folder of the external SD card containing this file, if the file is on an SD
-   *     card. Otherwise, null is returned.
-   */
-  @TargetApi(Build.VERSION_CODES.KITKAT)
-  private static String getExtSdCardFolder(final File file, Context context) {
-    String[] extSdPaths = getExtSdCardPaths(context);
-    try {
-      for (int i = 0; i < extSdPaths.length; i++) {
-        if (file.getCanonicalPath().startsWith(extSdPaths[i])) {
-          return extSdPaths[i];
-        }
-      }
-    } catch (IOException e) {
-      return null;
-    }
-    return null;
-  }
-
-  /**
-   * Determine if a file is on external sd card. (Kitkat or higher.)
-   *
-   * @param file The file.
-   * @return true if on external sd card.
-   */
-  @TargetApi(Build.VERSION_CODES.KITKAT)
-  public static boolean isOnExtSdCard(final File file, Context c) {
-    return getExtSdCardFolder(file, c) != null;
-  }
-
-  /**
-   * Get a DocumentFile corresponding to the given file (for writing on ExtSdCard on Android 5). If
-   * the file is not existing, it is created.
-   *
-   * @param file The file.
-   * @param isDirectory flag indicating if the file should be a directory.
-   * @return The DocumentFile
-   */
-  public static DocumentFile getDocumentFile(
-      final File file, final boolean isDirectory, Context context) {
-
-    if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.KITKAT) return DocumentFile.fromFile(file);
-
-    String baseFolder = getExtSdCardFolder(file, context);
-    boolean originalDirectory = false;
-    if (baseFolder == null) {
-      return null;
-    }
-
-    String relativePath = null;
-    try {
-      String fullPath = file.getCanonicalPath();
-      if (!baseFolder.equals(fullPath)) relativePath = fullPath.substring(baseFolder.length() + 1);
-      else originalDirectory = true;
-    } catch (IOException e) {
-      return null;
-    } catch (Exception f) {
-      originalDirectory = true;
-      // continue
-    }
-    String as =
-        PreferenceManager.getDefaultSharedPreferences(context)
-            .getString(PreferencesConstants.PREFERENCE_URI, null);
-
-    Uri treeUri = null;
-    if (as != null) treeUri = Uri.parse(as);
-    if (treeUri == null) {
-      return null;
-    }
-
-    // start with root of SD card and then parse through document tree.
-    DocumentFile document = DocumentFile.fromTreeUri(context, treeUri);
-    if (originalDirectory) return document;
-    String[] parts = relativePath.split("\\/");
-    for (int i = 0; i < parts.length; i++) {
-      DocumentFile nextDocument = document.findFile(parts[i]);
-
-      if (nextDocument == null) {
-        if ((i < parts.length - 1) || isDirectory) {
-          nextDocument = document.createDirectory(parts[i]);
-        } else {
-          nextDocument = document.createFile("image", parts[i]);
-        }
-      }
-      document = nextDocument;
-    }
-
-    return document;
-  }
-
-  // Utility methods for Kitkat
-
-  /**
-   * Checks whether the target path exists or is writable
-   *
-   * @param f the target path
-   * @return 1 if exists or writable, 0 if not writable
-   */
-  public static int checkFolder(final String f, Context context) {
-    if (f == null) return 0;
-    if (f.startsWith(SMB_URI_PREFIX)
-        || f.startsWith(SSH_URI_PREFIX)
-        || f.startsWith(OTGUtil.PREFIX_OTG)
-        || f.startsWith(CloudHandler.CLOUD_PREFIX_BOX)
-        || f.startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE)
-        || f.startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX)
-        || f.startsWith(CloudHandler.CLOUD_PREFIX_ONE_DRIVE)) return 1;
-
-    File folder = new File(f);
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP
-        && FileUtil.isOnExtSdCard(folder, context)) {
-      if (!folder.exists() || !folder.isDirectory()) {
-        return 0;
-      }
-
-      // On Android 5, trigger storage access framework.
-      if (FileProperties.isWritableNormalOrSaf(folder, context)) {
-        return 1;
-      }
-    } else if (Build.VERSION.SDK_INT == 19 && FileUtil.isOnExtSdCard(folder, context)) {
-      // Assume that Kitkat workaround works
-      return 1;
-    } else if (folder.canWrite()) {
-      return 1;
-    } else {
-      return 0;
-    }
-    return 0;
-  }
-
-  /**
-   * Validate given text is a valid filename.
-   *
-   * @param text
-   * @return true if given text is a valid filename
-   */
-  public static boolean isValidFilename(String text) {
-    // It's not easy to use regex to detect single/double dot while leaving valid values
-    // (filename.zip) behind...
-    // So we simply use equality to check them
-    return (!FILENAME_REGEX.matcher(text).find()) && !".".equals(text) && !"..".equals(text);
-  }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
index 7a47a0a72..478bc2d20 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
@@ -141,7 +141,7 @@ public class HybridFile {
           mode = OpenMode.ROOT;
         }
       } else {
-        if (FileUtil.isOnExtSdCard(getFile(), context)) {
+        if (ExternalSdCardOperation.isOnExtSdCard(getFile(), context)) {
           mode = OpenMode.FILE;
         } else if (rootmode && !getFile().canRead()) {
           mode = OpenMode.ROOT;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt
index e69f20c16..95bc45c07 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/MakeDirectoryOperation.kt
@@ -39,7 +39,7 @@ object MakeDirectoryOperation {
      */
     @JvmStatic
     @Deprecated("use {@link #mkdirs(Context, HybridFile)}")
-    fun mkdir(file: File?, context: Context?): Boolean {
+    fun mkdir(file: File?, context: Context): Boolean {
         if (file == null) return false
         if (file.exists()) {
             // nothing to create.
@@ -53,9 +53,10 @@ object MakeDirectoryOperation {
 
         // Try with Storage Access Framework.
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP &&
-            FileUtil.isOnExtSdCard(file, context)
+            ExternalSdCardOperation.isOnExtSdCard(file, context)
         ) {
-            val document = FileUtil.getDocumentFile(file, true, context)
+            val document = ExternalSdCardOperation.getDocumentFile(file, true, context)
+            document ?: return false
             // getDocumentFile implicitly creates the directory.
             return document.exists()
         }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt
index faf831e25..ba370df2b 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/MakeFileOperation.kt
@@ -66,13 +66,13 @@ object MakeFileOperation {
 
         // Try with Storage Access Framework.
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP &&
-            FileUtil.isOnExtSdCard(file, context)
+            ExternalSdCardOperation.isOnExtSdCard(file, context)
         ) {
-            val document = FileUtil.getDocumentFile(file.parentFile, true, context)
+            val document = ExternalSdCardOperation.getDocumentFile(file.parentFile, true, context)
             // getDocumentFile implicitly creates the directory.
             return try {
                 (
-                    document.createFile(
+                    document?.createFile(
                         MimeTypes.getMimeType(file.path, file.isDirectory), file.name
                     )
                         != null
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
index e3d58c615..aea283417 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
@@ -575,7 +575,7 @@ public class Operations {
     boolean lol = Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP;
     if (lol) {
 
-      boolean ext = FileUtil.isOnExtSdCard(folder, context);
+      boolean ext = ExternalSdCardOperation.isOnExtSdCard(folder, context);
       if (ext) {
 
         if (!folder.exists() || !folder.isDirectory()) {
@@ -590,7 +590,7 @@ public class Operations {
       }
     } else if (Build.VERSION.SDK_INT == 19) {
       // Assume that Kitkat workaround works
-      if (FileUtil.isOnExtSdCard(folder, context)) return 1;
+      if (ExternalSdCardOperation.isOnExtSdCard(folder, context)) return 1;
     }
 
     // file not on external sd card
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt b/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt
index fcf1cc148..4500deae7 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/RenameOperation.kt
@@ -58,7 +58,9 @@ object RenameOperation {
             } else {
                 outStream = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                     // Storage Access Framework
-                    val targetDocument = FileUtil.getDocumentFile(target, false, context)
+                    val targetDocument =
+                        ExternalSdCardOperation.getDocumentFile(target, false, context)
+                    targetDocument ?: throw IOException("Couldn't get DocumentFile")
                     context.contentResolver.openOutputStream(targetDocument.uri)
                 } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.KITKAT) {
                     // Workaround for Kitkat ext SD card
@@ -151,9 +153,10 @@ object RenameOperation {
         // Try the Storage Access Framework if it is just a rename within the same parent folder.
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP &&
             source.parent == target.parent &&
-            FileUtil.isOnExtSdCard(source, context)
+            ExternalSdCardOperation.isOnExtSdCard(source, context)
         ) {
-            val document = FileUtil.getDocumentFile(source, true, context)
+            val document = ExternalSdCardOperation.getDocumentFile(source, true, context)
+            document ?: return false
             if (document.renameTo(target.name)) {
                 return true
             }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
index 4f09d0018..39dfd1f36 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
@@ -35,7 +35,7 @@ import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.Operations;
@@ -242,7 +242,7 @@ public class FileUtils {
       Uri uri = null;
       if (Build.VERSION.SDK_INT >= 19) {
         DocumentFile documentFile =
-            FileUtil.getDocumentFile(
+            ExternalSdCardOperation.getDocumentFile(
                 hybridFile.getFile(), hybridFile.isDirectory(context), context);
         // If FileUtil.getDocumentFile() returns null, fall back to DocumentFile.fromFile()
         if (documentFile == null) documentFile = DocumentFile.fromFile(hybridFile.getFile());
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
index 57e59467e..5495c83b4 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
@@ -39,8 +39,8 @@ import java.util.Objects;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.file_operations.utils.OnLowMemory;
 import com.amaze.filemanager.file_operations.utils.UpdatePosition;
+import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.FileProperties;
-import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.MediaStoreHack;
@@ -147,7 +147,7 @@ public class GenericCopyUtil {
           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             ContentResolver contentResolver = mContext.getContentResolver();
             DocumentFile documentSourceFile =
-                FileUtil.getDocumentFile(file, mSourceFile.isDirectory(), mContext);
+                ExternalSdCardOperation.getDocumentFile(file, mSourceFile.isDirectory(), mContext);
 
             bufferedInputStream =
                 new BufferedInputStream(
@@ -196,7 +196,8 @@ public class GenericCopyUtil {
           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
             ContentResolver contentResolver = mContext.getContentResolver();
             DocumentFile documentTargetFile =
-                FileUtil.getDocumentFile(file, mTargetFile.isDirectory(mContext), mContext);
+                ExternalSdCardOperation.getDocumentFile(
+                    file, mTargetFile.isDirectory(mContext), mContext);
 
             bufferedOutputStream =
                 new BufferedOutputStream(
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
index 9fed71349..ec1e0fa32 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
@@ -86,6 +86,7 @@ import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.file_operations.filesystem.StorageNaming;
 import com.amaze.filemanager.file_operations.filesystem.usb.SingletonUsbOtg;
 import com.amaze.filemanager.file_operations.filesystem.usb.UsbOtgRepresentation;
+import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
@@ -756,7 +757,7 @@ public class MainActivity extends PermissionsActivity
     }
     if (SDK_INT >= M && checkStoragePermission()) rv.clear();
     if (SDK_INT >= KITKAT) {
-      String strings[] = FileUtil.getExtSdCardPathsForActivity(this);
+      String strings[] = ExternalSdCardOperation.getExtSdCardPathsForActivity(this);
       for (String s : strings) {
         File f = new File(s);
         if (!rv.contains(s) && FileUtils.canListFiles(f)) rv.add(s);
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
index 265ed1fe2..8ffdfbe6e 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
@@ -52,7 +52,7 @@ import com.amaze.filemanager.database.SortHandler;
 import com.amaze.filemanager.database.models.explorer.Sort;
 import com.amaze.filemanager.file_operations.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
-import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
@@ -1146,7 +1146,7 @@ public class GeneralDialogCreation {
         tilFilename,
         materialDialog.getActionButton(DialogAction.POSITIVE),
         (text) -> {
-          boolean isValidFilename = FileUtil.isValidFilename(text);
+          boolean isValidFilename = FileProperties.isValidFilename(text);
 
           if (isValidFilename && text.length() > 0 && !text.toLowerCase().endsWith(".zip")) {
             return new WarnableTextInputValidator.ReturnState(
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
index 487f38a9a..8f786dcf2 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
@@ -49,7 +49,7 @@ import com.amaze.filemanager.database.models.explorer.Tab;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.file_operations.filesystem.smbstreamer.Streamer;
 import com.amaze.filemanager.filesystem.CustomFileObserver;
-import com.amaze.filemanager.filesystem.FileUtil;
+import com.amaze.filemanager.filesystem.FileProperties;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.PasteHelper;
@@ -1220,7 +1220,7 @@ public class MainFragment extends Fragment implements BottomBarButtonPath {
                       getMainActivity().isRootExplorer());
             },
             (text) -> {
-              boolean isValidFilename = FileUtil.isValidFilename(text);
+              boolean isValidFilename = FileProperties.isValidFilename(text);
 
               if (!isValidFilename) {
                 return new WarnableTextInputValidator.ReturnState(
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index f3633c90e..0f2e4cec7 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -43,8 +43,8 @@ import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 import com.amaze.filemanager.file_operations.filesystem.FolderState;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
+import com.amaze.filemanager.filesystem.ExternalSdCardOperation;
 import com.amaze.filemanager.filesystem.FileProperties;
-import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.Operations;
@@ -167,7 +167,7 @@ public class MainActivityHelper {
           dialog.dismiss();
         },
         (text) -> {
-          boolean isValidFilename = FileUtil.isValidFilename(text);
+          boolean isValidFilename = FileProperties.isValidFilename(text);
 
           if (!isValidFilename) {
             return new WarnableTextInputValidator.ReturnState(
@@ -205,7 +205,7 @@ public class MainActivityHelper {
           dialog.dismiss();
         },
         (text) -> {
-          boolean isValidFilename = FileUtil.isValidFilename(text);
+          boolean isValidFilename = FileProperties.isValidFilename(text);
 
           // The redundant equalsIgnoreCase() is needed since ".txt" itself does not end with .txt
           // (i.e. recommended as ".txt.txt"
@@ -436,7 +436,7 @@ public class MainActivityHelper {
     } else {
       File folder = new File(path);
       if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-        if (FileUtil.isOnExtSdCard(folder, context)) {
+        if (ExternalSdCardOperation.isOnExtSdCard(folder, context)) {
           if (!folder.exists() || !folder.isDirectory()) {
             return DOESNT_EXIST;
           }
@@ -452,7 +452,7 @@ public class MainActivityHelper {
           return WRITABLE_OR_ON_SDCARD;
         } else return DOESNT_EXIST;
       } else if (Build.VERSION.SDK_INT == 19) {
-        if (FileUtil.isOnExtSdCard(folder, context)) {
+        if (ExternalSdCardOperation.isOnExtSdCard(folder, context)) {
           // Assume that Kitkat workaround works
           return WRITABLE_OR_ON_SDCARD;
         } else if (FileProperties.isWritable(new File(folder, "DummyFile"))) {
