diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Presenter.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Presenter.java
index 1314108f..804cdcbc 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Presenter.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Presenter.java
@@ -44,6 +44,7 @@ public class Presenter {
      *
      * @return true if locked, false otherwise
      */
+    @Deprecated
     public boolean stop(Context context) {
         //noinspection SimplifiableIfStatement
         if (mActivity != null
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeHandler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeHandler.java
new file mode 100644
index 00000000..2686245f
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeHandler.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.activemode;
+
+import android.content.Context;
+
+/**
+ * Provides a callback when active mode should be started or stopped
+ * to satisfy any options or for power-save reason.
+ *
+ * @author Artem Chepurnoy
+ */
+public abstract class ActiveModeHandler {
+
+    private final Context mContext;
+    private final Callback mCallback;
+
+    /**
+     * Provides control callback to main service.
+     *
+     * @author Artem Chepurnoy
+     */
+    public interface Callback {
+
+        /**
+         * Notifies main service to probably start listening to sensors.
+         * At this moment calling {@link #isActive()} should return {@code true}.
+         *
+         * @see #isActive()
+         * @see #requestInactive()
+         */
+        public void requestActive();
+
+        /**
+         * Notifies main service to stop listening to sensors.
+         * At this moment calling {@link #isActive()} should return {@code false}.
+         *
+         * @see #isActive()
+         * @see #requestActive()
+         */
+        public void requestInactive();
+
+    }
+
+    public ActiveModeHandler(Context context, Callback callback) {
+        mContext = context;
+        mCallback = callback;
+    }
+
+    /**
+     * Same as calling {@code getCallback().requestActive()}.
+     *
+     * @see Callback#requestActive()
+     * @see #getCallback()
+     */
+    protected void requestActive() {
+        getCallback().requestActive();
+    }
+
+    /**
+     * Same as calling {@code getCallback().requestInactive()}.
+     *
+     * @see Callback#requestInactive()
+     * @see #getCallback()
+     */
+    protected void requestInactive() {
+        getCallback().requestInactive();
+    }
+
+    /**
+     * @return Callback to control {@link ActiveModeService service}.
+     * @see com.achep.activedisplay.activemode.ActiveModeHandler.Callback#requestActive()
+     * @see com.achep.activedisplay.activemode.ActiveModeHandler.Callback#requestInactive()
+     */
+    public Callback getCallback() {
+        return mCallback;
+    }
+
+    /**
+     * @return {@link ActiveModeService Service}'s context.
+     */
+    public Context getContext() {
+        return mContext;
+    }
+
+    /**
+     * Called by the {@link ActiveModeService} when the service is created.
+     */
+    public abstract void onCreate();
+
+    /**
+     * Called by the {@link ActiveModeService} to notify a Handler
+     * that it is no longer used and is being removed.
+     * The handler should clean up any resources it holds
+     * (threads, registered receivers, etc) at this point.
+     */
+    public abstract void onDestroy();
+
+    /**
+     * @return {@code true} if starting active sensors is fine, {@code false} otherwise.
+     */
+    public abstract boolean isActive();
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeSensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeSensor.java
new file mode 100644
index 00000000..cc612dcc
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeSensor.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.activemode;
+
+import android.content.Context;
+import android.hardware.SensorManager;
+import android.os.SystemClock;
+
+import java.util.ArrayList;
+
+/**
+ * Provides a callback when {@link com.achep.activedisplay.activities.AcDisplayActivity}
+ * should be started and stopped.
+ *
+ * @author Artem Chepurnoy
+ */
+public abstract class ActiveModeSensor {
+
+    /**
+     * Provides a callback when AcDisplay should be shown / hidden.
+     *
+     * @author Artem Chepurnoy
+     */
+    public interface Callback {
+
+        /**
+         * Requests to show the AcDisplay.
+         *
+         * @return {@code true} if AcDisplay is showing, {@code false} otherwise.
+         */
+        public boolean show(ActiveModeSensor sensor);
+
+        /**
+         * Requests to hide the AcDisplay.
+         *
+         * @return {@code true} if AcDisplay is hidden, {@code false} otherwise.
+         */
+        public boolean hide(ActiveModeSensor sensor);
+    }
+
+    private ArrayList<Callback> mCallbacks;
+
+    public ActiveModeSensor() {
+        mCallbacks = new ArrayList<>(4);
+    }
+
+    /**
+     * Registers given callback to listen to this sensor.
+     * You must call {@link #unregisterCallback(ActiveModeSensor.Callback)}
+     * later.
+     *
+     * @see #unregisterCallback(ActiveModeSensor.Callback)
+     */
+    public void registerCallback(Callback callback) {
+        mCallbacks.add(callback);
+    }
+
+    /**
+     * Unregisters given callback from listening to this sensor.
+     *
+     * @see #registerCallback(ActiveModeSensor.Callback)
+     */
+    public void unregisterCallback(Callback callback) {
+        mCallbacks.remove(callback);
+    }
+
+    protected void notifyShowEvent() {
+        for (Callback callback : mCallbacks) {
+            callback.show(this);
+        }
+    }
+
+    protected void notifyHideEvent() {
+        for (Callback callback : mCallbacks) {
+            callback.hide(this);
+        }
+    }
+
+    /**
+     * Checks if this sensor is supported by device.
+     * By default it does the following code:
+     * {@code sensorManager.getSensorList(getType()).size() > 0}
+     *
+     * @return {@code true} if the sensor is supported by device, {@code false} otherwise.
+     */
+    protected boolean isSupported(SensorManager sensorManager, Context context) {
+        return sensorManager.getSensorList(getType()).size() > 0;
+    }
+
+    /**
+     * @return The type of used sensor.
+     * @see android.hardware.Sensor#TYPE_ACCELEROMETER
+     * @see android.hardware.Sensor#TYPE_PROXIMITY
+     */
+    public abstract int getType();
+
+    /**
+     * Called when the sensor is attached to main class.
+     * Tou may start to listen to your sensor here.
+     */
+    public abstract void onAttached(SensorManager sensorManager, Context context);
+
+    /**
+     * Called when the sensor is detached from main class.
+     * You must unregister all sensors here.
+     */
+    public abstract void onDetached(SensorManager sensorManager);
+
+    /**
+     * @return {@code SystemClock.elapsedRealtime()}
+     */
+    protected static long getTimeNow() {
+        return SystemClock.elapsedRealtime();
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
index ec6838ec..a46a12c0 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
@@ -18,100 +18,44 @@
  */
 package com.achep.activedisplay.activemode;
 
-import android.app.Activity;
 import android.app.Notification;
 import android.app.PendingIntent;
 import android.app.Service;
-import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.content.IntentFilter;
 import android.hardware.SensorManager;
-import android.os.Handler;
 import android.os.IBinder;
-import android.os.PowerManager;
-import android.os.SystemClock;
 import android.util.Log;
 
 import com.achep.activedisplay.Config;
-import com.achep.activedisplay.InactiveHoursHelper;
 import com.achep.activedisplay.NotificationIds;
 import com.achep.activedisplay.Presenter;
 import com.achep.activedisplay.Project;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.notifications.NotificationPresenter;
-import com.achep.activedisplay.notifications.OpenStatusBarNotification;
+import com.achep.activedisplay.activemode.handlers.InactiveTimeHandler;
+import com.achep.activedisplay.activemode.handlers.ScreenHandler;
+import com.achep.activedisplay.activemode.handlers.WithoutNotifiesHandler;
+import com.achep.activedisplay.activemode.sensors.AccelerometerSensor;
+import com.achep.activedisplay.activemode.sensors.ProximitySensor;
 import com.achep.activedisplay.settings.Settings;
 import com.achep.activedisplay.utils.PowerUtils;
 
-import java.util.Timer;
-import java.util.TimerTask;
-
 /**
- * Created by Artem on 16.02.14.
+ * Service that turns on AcDisplay exactly when it's needed.
+ *
+ * @author Artem Chepurnoy
+ * @see com.achep.activedisplay.activemode.ActiveModeHandler
+ * @see com.achep.activedisplay.activemode.ActiveModeSensor
  */
-// TODO: Do huge refactoring to completely fix inactive time and without-notifications options.
 public class ActiveModeService extends Service implements
-        Config.OnConfigChangedListener, ActiveSensor.SensorCallback,
-        NotificationPresenter.OnNotificationListChangedListener {
+        ActiveModeSensor.Callback, ActiveModeHandler.Callback {
 
     private static final String TAG = "ActiveModeService";
 
-    // TODO: Implement event based inactive time handling (using AlarmManager).
-    private static final int INACTIVE_HOURS_CHECK_PERIOD = 1000 * 60 * 5; // ms.
-
-    private Timer mTimer;
-    private ActiveSensor[] mSensors;
-
-    private Config mConfig;
+    private ActiveModeSensor[] mSensors;
+    private ActiveModeHandler[] mHandlers;
 
     private boolean mListening;
-    private boolean mInactiveTime;
-    private boolean mLackOfNotifies;
-
-    private Receiver mReceiver = new Receiver();
-
-    private class Receiver extends BroadcastReceiver {
-
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            Presenter presenter = Presenter.getInstance();
-            switch (intent.getAction()) {
-                case Intent.ACTION_SCREEN_ON:
-                    presenter.registerListener(mStateListener);
-
-                    if (!presenter.isActivityAttached()) {
-                        stopListening();
-                    }
-                    break;
-                case Intent.ACTION_SCREEN_OFF:
-                    presenter.unregisterListener(mStateListener);
-                    startListeningDelayed(250);
-                    break;
-            }
-        }
-
-    }
-
-    private Handler mHandler = new Handler();
-    private Runnable mStartListeningRunnable = new Runnable() {
-        @Override
-        public void run() {
-            startListening();
-        }
-    };
-
-    private Presenter.OnActiveDisplayStateChangedListener mStateListener =
-            new Presenter.OnActiveDisplayStateChangedListener() {
-                @Override
-                public void OnActiveDisplayStateChanged(Activity activity) {
-                    if (activity == null) {
-                        stopListening();
-                    } else {
-                        startListening();
-                    }
-                }
-            };
 
     /**
      * Starts or stops this service as required by settings and device's state.
@@ -132,13 +76,21 @@ public class ActiveModeService extends Service implements
         }
     }
 
-    public static ActiveSensor[] buildSensorsList(Context context) {
+    /**
+     * Builds the array of supported {@link ActiveModeSensor sensors}.
+     *
+     * @return The array of supported {@link ActiveModeSensor sensors}.
+     * @see ActiveModeSensor
+     */
+    public static ActiveModeSensor[] buildAvailableSensorsList(Context context) {
         SensorManager sensorManager = (SensorManager) context.getSystemService(SENSOR_SERVICE);
-        ActiveSensor[] sensors = new ActiveSensor[]{
+        ActiveModeSensor[] sensors = new ActiveModeSensor[]{ // all available sensors
                 new AccelerometerSensor(),
                 new ProximitySensor()
         };
 
+        // Count the number of supported sensors, and
+        // mark unsupported.
         int count = sensors.length;
         boolean[] supportList = new boolean[sensors.length];
         for (int i = 0; i < sensors.length; i++) {
@@ -148,88 +100,50 @@ public class ActiveModeService extends Service implements
             }
         }
 
-        ActiveSensor[] sensorsSupported = new ActiveSensor[count];
+        // Create the list of proven sensors.
+        ActiveModeSensor[] sensorsSupported = new ActiveModeSensor[count];
         for (int i = 0, j = 0; i < sensors.length; i++) {
             if (supportList[i]) {
                 sensorsSupported[j++] = sensors[i];
             }
         }
-        return sensorsSupported;
-    }
 
-    private void handleInactiveHoursChanged(boolean enabled) {
-        if (mTimer != null) mTimer.cancel();
-        if (enabled) {
-            mTimer = new Timer();
-            mTimer.schedule(new TimerTask() {
-
-                private static final String TAG = "InactiveTimeTicker";
-
-                @Override
-                public void run() {
-                    Config config = Config.getInstance(ActiveModeService.this);
-                    boolean inactive = InactiveHoursHelper.isInactiveTime(config);
-                    boolean changed = inactive != mInactiveTime;
-
-                    if (Project.DEBUG)
-                        Log.d(TAG, "On timer tick: elapsed_real_time="
-                                + SystemClock.elapsedRealtime());
-
-                    if (changed) {
-                        mInactiveTime = inactive;
-
-                        if (Project.DEBUG)
-                            Log.d(TAG, "is_inactive_time=" + inactive);
-
-                        if (inactive) {
-                            stopListening();
-                        } else {
-                            start();
-                        }
-                    }
-                }
-            }, 0, INACTIVE_HOURS_CHECK_PERIOD);
-        } else {
-            mInactiveTime = false;
-        }
+        return sensorsSupported;
     }
 
     @Override
     public void onCreate() {
         super.onCreate();
-        mSensors = buildSensorsList(this);
-
-        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_ON);
-        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
-        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
-        registerReceiver(mReceiver, intentFilter);
+        mSensors = buildAvailableSensorsList(this);
+        mHandlers = new ActiveModeHandler[]{
+                new ScreenHandler(this, this),
+                new InactiveTimeHandler(this, this),
+                new WithoutNotifiesHandler(this, this),
+        };
 
-        mConfig = Config.getInstance(this);
-        handleInactiveHoursChanged(mConfig.isInactiveTimeEnabled());
-        mConfig.addOnConfigChangedListener(this);
+        for (ActiveModeHandler handler : mHandlers) {
+            handler.onCreate();
+        }
 
-        NotificationPresenter np = NotificationPresenter.getInstance(this);
-        handleNotificationsCountChange(np);
-        np.addOnNotificationListChangedListener(this);
+        requestActive();
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
-        unregisterReceiver(mReceiver);
-        stopListening();
-
-        Config config = Config.getInstance(this);
-        config.removeOnConfigChangedListener(this);
+        for (ActiveModeHandler handler : mHandlers) {
+            handler.onDestroy();
+        }
 
-        NotificationPresenter np = NotificationPresenter.getInstance(this);
-        np.removeOnNotificationListChangedListener(this);
+        stopListening();
     }
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
-        start();
 
+        // Show foreground notification to prove that
+        // this service will not be killed when system
+        // needs some RAM or whatever.
         int notificationId = NotificationIds.ACTIVE_MODE_NOTIFICATION;
         PendingIntent pendingIntent = PendingIntent.getActivity(this,
                 notificationId, new Intent(this, Settings.ActiveModeSettingsActivity.class),
@@ -250,119 +164,74 @@ public class ActiveModeService extends Service implements
     }
 
     @Override
-    public boolean onShowEvent(ActiveSensor sensor) {
-        Presenter.getInstance().start(this);
-        return false;
-    }
-
-    @Override
-    public boolean onHideEvent(ActiveSensor sensor) {
-        Presenter.getInstance().stop(this);
-        return false;
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        boolean inactiveTimeEnabled = config.isInactiveTimeEnabled();
-        switch (key) {
-            case Config.KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS:
-                if ((boolean) value) {
-                    mLackOfNotifies = false;
-                    start();
-                } else {
-                    // If you've disabled the active mode check the
-                    // amount of notifications and probably stop
-                    // listening.
-                    NotificationPresenter np = NotificationPresenter.getInstance(this);
-                    handleNotificationsCountChange(np);
-                }
-                break;
-            case Config.KEY_INACTIVE_TIME_FROM:
-            case Config.KEY_INACTIVE_TIME_TO:
-                if (!inactiveTimeEnabled) {
-                    break;
-                }
-
-                // Immediately update sensors' blocker.
-            case Config.KEY_INACTIVE_TIME_ENABLED:
-                handleInactiveHoursChanged(inactiveTimeEnabled);
-                break;
+    public void requestActive() {
+        if (mListening) {
+            return; // Already listening, no need to check all handlers.
         }
-    }
-
-    @Override
-    public void onNotificationListChanged(NotificationPresenter np,
-                                          OpenStatusBarNotification osbn,
-                                          int event) {
-        handleNotificationsCountChange(np);
-    }
-
-    private void handleNotificationsCountChange(NotificationPresenter np) {
-        boolean lackOfNotifies = !mConfig.isActiveModeWithoutNotifiesEnabled()
-                        && np.getList().size() == 0;
 
-        if (lackOfNotifies == mLackOfNotifies) {
-            // Nothing changed, go home.
-            return;
+        // Check through all available handlers.
+        for (ActiveModeHandler handler : mHandlers) {
+            if (!handler.isActive()) {
+                return;
+            }
         }
 
-        mLackOfNotifies = lackOfNotifies;
-        if (!mLackOfNotifies) {
-            start();
-        } else {
-            stopListening();
-        }
+        startListening();
     }
 
     @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
-    void start() {
-        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-        Presenter presenter = Presenter.getInstance();
-        if (pm.isScreenOn()) {
-            mStateListener.OnActiveDisplayStateChanged(presenter.getActivity());
-        } else {
-            startListening();
-        }
+    public void requestInactive() {
+        stopListening();
     }
 
     /**
-     * Stops all monitoring sensors and removes delayed start event.
+     * Stops listening to {@link ActiveModeSensor sensors} (if not stopped already.)
+     *
+     * @see #buildAvailableSensorsList(android.content.Context)
+     * @see #startListening()
      */
     private void stopListening() {
-        mHandler.removeCallbacks(mStartListeningRunnable);
-
         if (!mListening & !(mListening = false)) return;
         if (Project.DEBUG) Log.d(TAG, "Stopping listening to sensors.");
 
         SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
-        for (ActiveSensor sensor : mSensors) {
+        for (ActiveModeSensor sensor : mSensors) {
             sensor.onDetached(sensorManager);
             sensor.unregisterCallback(this);
         }
     }
 
     /**
-     * Starts all monitoring sensors after a delay.
+     * Starts listening to {@link ActiveModeSensor sensors} (if not started already.)
      *
-     * @param millis the delay before monitoring started.
+     * @see #buildAvailableSensorsList(android.content.Context)
+     * @see #stopListening()
      */
-    private void startListeningDelayed(int millis) {
-        mHandler.postDelayed(mStartListeningRunnable, millis);
-    }
-
     private void startListening() {
-        if (mInactiveTime || mLackOfNotifies || mListening & (mListening = true)) return;
+        if (mListening & (mListening = true)) return;
         if (Project.DEBUG) Log.d(TAG, "Starting listening to sensors.");
 
         SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
-        for (ActiveSensor sensor : mSensors) {
-            sensor.onAttached(sensorManager, this);
+        for (ActiveModeSensor sensor : mSensors) {
             sensor.registerCallback(this);
+            sensor.onAttached(sensorManager, this);
         }
     }
 
+    @Override
+    public boolean show(ActiveModeSensor sensor) {
+        Presenter.getInstance().start(this);
+        return false;
+    }
+
+    @Override
+    public boolean hide(ActiveModeSensor sensor) {
+        return false; // moved to AcDisplayActivity
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveSensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveSensor.java
deleted file mode 100644
index 086641e1..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveSensor.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.activedisplay.activemode;
-
-import android.content.Context;
-import android.hardware.SensorManager;
-import android.os.SystemClock;
-
-import java.util.ArrayList;
-
-/**
- * Created by Artem on 28.03.2014.
- */
-public abstract class ActiveSensor {
-
-    public interface SensorCallback {
-        public boolean onShowEvent(ActiveSensor sensor);
-
-        public boolean onHideEvent(ActiveSensor sensor);
-    }
-
-    private ArrayList<SensorCallback> mCallbacks;
-
-    public ActiveSensor() {
-        mCallbacks = new ArrayList<>(4);
-    }
-
-    public void registerCallback(SensorCallback callback) {
-        mCallbacks.add(callback);
-    }
-
-    public void unregisterCallback(SensorCallback callback) {
-        mCallbacks.remove(callback);
-    }
-
-    protected void notifyShowEvent() {
-        for (SensorCallback callback : mCallbacks) {
-            callback.onShowEvent(this);
-        }
-    }
-
-    protected void notifyHideEvent() {
-        for (SensorCallback callback : mCallbacks) {
-            callback.onHideEvent(this);
-        }
-    }
-
-    protected boolean isSupported(SensorManager sensorManager, Context context) {
-        return sensorManager.getSensorList(getType()).size() > 0;
-    }
-
-    public abstract int getType();
-
-    protected abstract void onAttached(SensorManager sensorManager, Context context);
-
-    protected abstract void onDetached(SensorManager sensorManager);
-
-    protected static long getTimeNow() {
-        return SystemClock.elapsedRealtime();
-    }
-
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/InactiveTimeHandler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/InactiveTimeHandler.java
new file mode 100644
index 00000000..0ae2c7c8
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/InactiveTimeHandler.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.activemode.handlers;
+
+import android.content.Context;
+import android.os.SystemClock;
+import android.util.Log;
+
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.InactiveHoursHelper;
+import com.achep.activedisplay.Project;
+import com.achep.activedisplay.activemode.ActiveModeHandler;
+
+import java.util.Timer;
+import java.util.TimerTask;
+
+/**
+ * Prevents {@link com.achep.activedisplay.activemode.ActiveModeService} from listening to
+ * sensors on inactive time (if corresponding option is enabled.)
+ *
+ * @author Artem Chepurnoy
+ * @see com.achep.activedisplay.settings.MoreFragment
+ */
+// TODO: Implement event based inactive time handling.
+public final class InactiveTimeHandler extends ActiveModeHandler implements
+        Config.OnConfigChangedListener {
+
+    private static final int INACTIVE_HOURS_CHECK_PERIOD = 1000 * 60 * 5; // ms.
+
+    private Config mConfig;
+    private Timer mTimer;
+
+    public InactiveTimeHandler(Context context, Callback callback) {
+        super(context, callback);
+    }
+
+    @Override
+    public void onCreate() {
+        mConfig = Config.getInstance(getContext());
+        mConfig.addOnConfigChangedListener(this);
+        updateState();
+    }
+
+    @Override
+    public void onDestroy() {
+        mConfig.removeOnConfigChangedListener(this);
+    }
+
+    @Override
+    public boolean isActive() {
+        boolean enabled = mConfig.isInactiveTimeEnabled();
+        return !enabled || !InactiveHoursHelper.isInactiveTime(mConfig);
+    }
+
+    private void updateState() {
+        if (mTimer != null) mTimer.cancel();
+        if (mConfig.isInactiveTimeEnabled()) {
+
+            // Start a timer to monitor when inactive time
+            // will end or start. This is awful.
+            mTimer = new Timer();
+            mTimer.schedule(new TimerTask() {
+
+                private static final String TAG = "InactiveTimeTicker";
+
+                private boolean firstTick = true;
+                private boolean inactivePrev = false;
+
+                @Override
+                public void run() {
+                    boolean inactive = InactiveHoursHelper.isInactiveTime(mConfig);
+                    boolean changed = inactive != inactivePrev || firstTick;
+
+                    firstTick = false;
+
+                    if (Project.DEBUG)
+                        Log.d(TAG, "On timer tick: elapsed_real_time="
+                                + SystemClock.elapsedRealtime());
+
+                    if (changed) {
+                        inactivePrev = inactive;
+
+                        if (Project.DEBUG)
+                            Log.d(TAG, "is_inactive_time=" + inactive);
+
+                        if (inactive) {
+                            requestInactive();
+                        } else {
+                            requestActive();
+                        }
+                    }
+                }
+            }, 0, INACTIVE_HOURS_CHECK_PERIOD);
+        } else {
+            requestActive();
+        }
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        boolean enabled = config.isInactiveTimeEnabled();
+        switch (key) {
+            case Config.KEY_INACTIVE_TIME_FROM:
+            case Config.KEY_INACTIVE_TIME_TO:
+                if (!enabled) {
+                    break;
+                }
+
+                // Immediately update sensors' blocker.
+            case Config.KEY_INACTIVE_TIME_ENABLED:
+                updateState();
+                break;
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/ScreenHandler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/ScreenHandler.java
new file mode 100644
index 00000000..0677d637
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/ScreenHandler.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.activemode.handlers;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import com.achep.activedisplay.activemode.ActiveModeHandler;
+import com.achep.activedisplay.utils.PowerUtils;
+
+/**
+ * Prevents {@link com.achep.activedisplay.activemode.ActiveModeService} from listening to
+ * sensors while screen is turned on.
+ *
+ * @author Artem Chepurnoy
+ */
+public final class ScreenHandler extends ActiveModeHandler {
+
+    private Receiver mReceiver = new Receiver();
+
+    private class Receiver extends BroadcastReceiver {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            switch (intent.getAction()) {
+                case Intent.ACTION_SCREEN_ON:
+                    requestInactive();
+                    break;
+                case Intent.ACTION_SCREEN_OFF:
+                    requestActive();
+                    break;
+            }
+        }
+
+    }
+
+    public ScreenHandler(Context context, Callback callback) {
+        super(context, callback);
+    }
+
+    @Override
+    public void onCreate() {
+        IntentFilter intentFilter = new IntentFilter();
+        intentFilter.addAction(Intent.ACTION_SCREEN_ON);
+        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1);
+        getContext().registerReceiver(mReceiver, intentFilter);
+    }
+
+    @Override
+    public void onDestroy() {
+        getContext().unregisterReceiver(mReceiver);
+    }
+
+    @Override
+    public boolean isActive() {
+        return !PowerUtils.isScreenOn(getContext());
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/WithoutNotifiesHandler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/WithoutNotifiesHandler.java
new file mode 100644
index 00000000..4e4799fe
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/handlers/WithoutNotifiesHandler.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.activemode.handlers;
+
+import android.content.Context;
+
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.activemode.ActiveModeHandler;
+import com.achep.activedisplay.notifications.NotificationPresenter;
+import com.achep.activedisplay.notifications.OpenStatusBarNotification;
+
+/**
+ * Prevents {@link com.achep.activedisplay.activemode.ActiveModeService} from listening to
+ * sensors while notification list is empty (if corresponding option is enabled.)
+ *
+ * @author Artem Chepurnoy
+ * @see com.achep.activedisplay.settings.ActiveFragment
+ */
+public final class WithoutNotifiesHandler extends ActiveModeHandler implements
+        NotificationPresenter.OnNotificationListChangedListener,
+        Config.OnConfigChangedListener {
+
+    private Config mConfig;
+    private NotificationPresenter mNotificationPresenter;
+
+    public WithoutNotifiesHandler(Context context, Callback callback) {
+        super(context, callback);
+    }
+
+    @Override
+    public void onCreate() {
+        mConfig = Config.getInstance(getContext());
+        mConfig.addOnConfigChangedListener(this);
+
+        mNotificationPresenter = NotificationPresenter.getInstance(getContext());
+        mNotificationPresenter.addOnNotificationListChangedListener(this);
+        updateState();
+    }
+
+    @Override
+    public void onDestroy() {
+        mConfig.removeOnConfigChangedListener(this);
+        mNotificationPresenter.removeOnNotificationListChangedListener(this);
+    }
+
+    @Override
+    public boolean isActive() {
+        boolean enabled = mConfig.isActiveModeWithoutNotifiesEnabled();
+        return enabled || mNotificationPresenter.getList().size() > 0;
+    }
+
+    private void updateState() {
+        if (isActive()) {
+            requestActive();
+        } else {
+            requestInactive();
+        }
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS:
+                if ((boolean) value) {
+                    requestActive();
+                } else {
+                    // If you've disabled the active mode, check the
+                    // amount of notifications and probably stop
+                    // listening.
+                    updateState();
+                }
+                break;
+        }
+    }
+
+    @Override
+    public void onNotificationListChanged(NotificationPresenter np,
+                                          OpenStatusBarNotification osbn,
+                                          int event) {
+        switch (event) {
+            case NotificationPresenter.EVENT_BATH:
+            case NotificationPresenter.EVENT_POSTED:
+            case NotificationPresenter.EVENT_REMOVED:
+                updateState();
+                break;
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/AccelerometerSensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/sensors/AccelerometerSensor.java
similarity index 94%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/AccelerometerSensor.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/sensors/AccelerometerSensor.java
index ba4d358c..290be81d 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/AccelerometerSensor.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/sensors/AccelerometerSensor.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.activedisplay.activemode;
+package com.achep.activedisplay.activemode.sensors;
 
 import android.content.Context;
 import android.hardware.Sensor;
@@ -25,10 +25,12 @@ import android.hardware.SensorEventListener;
 import android.hardware.SensorManager;
 import android.util.Log;
 
+import com.achep.activedisplay.activemode.ActiveModeSensor;
+
 /**
  * Created by Artem on 08.03.14.
  */
-public class AccelerometerSensor extends ActiveSensor implements
+public class AccelerometerSensor extends ActiveModeSensor implements
         SensorEventListener {
 
     private static final String TAG = "AccelerometerSensor";
@@ -61,7 +63,7 @@ public class AccelerometerSensor extends ActiveSensor implements
     }
 
     @Override
-    protected void onAttached(SensorManager sensorManager, Context context) {
+    public void onAttached(SensorManager sensorManager, Context context) {
         Sensor accelSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
         assert accelSensor != null; // Otherwise excluded by Service.
 
@@ -76,7 +78,7 @@ public class AccelerometerSensor extends ActiveSensor implements
     }
 
     @Override
-    protected void onDetached(SensorManager sensorManager) {
+    public void onDetached(SensorManager sensorManager) {
         sensorManager.unregisterListener(this);
         mContext = null;
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/sensors/ProximitySensor.java
similarity index 91%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/sensors/ProximitySensor.java
index 605c6f13..e705cef7 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/sensors/ProximitySensor.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.activedisplay.activemode;
+package com.achep.activedisplay.activemode.sensors;
 
 import android.content.Context;
 import android.hardware.Sensor;
@@ -28,11 +28,12 @@ import android.os.PowerManager;
 import android.util.Log;
 
 import com.achep.activedisplay.Project;
+import com.achep.activedisplay.activemode.ActiveModeSensor;
 
 /**
  * Created by Artem on 08.03.14.
  */
-public class ProximitySensor extends ActiveSensor implements
+public class ProximitySensor extends ActiveModeSensor implements
         SensorEventListener {
 
     private static final String TAG = "ProximitySensor";
@@ -80,11 +81,11 @@ public class ProximitySensor extends ActiveSensor implements
     }
 
     @Override
-    protected void onAttached(SensorManager sensorManager, Context context) {
+    public void onAttached(SensorManager sensorManager, Context context) {
         Sensor proximitySensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
         assert proximitySensor != null; // Otherwise excluded by Service.
 
-        sensorManager.registerListener(this, proximitySensor, 0 /* proximity is event based */);
+        sensorManager.registerListener(this, proximitySensor, SensorManager.SENSOR_DELAY_NORMAL);
         mMaximumRange = proximitySensor.getMaximumRange();
         mContext = context;
 
@@ -96,7 +97,7 @@ public class ProximitySensor extends ActiveSensor implements
     }
 
     @Override
-    protected void onDetached(SensorManager sensorManager) {
+    public void onDetached(SensorManager sensorManager) {
         sensorManager.unregisterListener(this);
         mHandler.removeCallbacks(mLockRunnable);
         mHandler.removeCallbacks(mLaunchRunnable);
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java
index 4cb35232..260f5f84 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java
@@ -24,6 +24,7 @@ import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.Intent;
 import android.graphics.Bitmap;
+import android.hardware.SensorManager;
 import android.media.AudioManager;
 import android.os.Build;
 import android.os.Bundle;
@@ -43,6 +44,8 @@ import com.achep.activedisplay.Operator;
 import com.achep.activedisplay.Presenter;
 import com.achep.activedisplay.R;
 import com.achep.activedisplay.Timeout;
+import com.achep.activedisplay.activemode.ActiveModeSensor;
+import com.achep.activedisplay.activemode.ActiveModeService;
 import com.achep.activedisplay.widgets.CircleView;
 
 /**
@@ -71,6 +74,22 @@ public class AcDisplayActivity extends KeyguardActivity implements
     private Timeout mTimeout = new T();
     private Config mConfig;
 
+    private ActiveModeSensor[] mSensors;
+    private ActiveModeSensor.Callback mSensorCallback = new ActiveModeSensor.Callback() {
+        @Override
+        public boolean show(ActiveModeSensor sensor) {
+            return true;
+        }
+
+        @Override
+        public boolean hide(ActiveModeSensor sensor) {
+            if (isCloseableBySensor()) {
+                lock();
+            }
+            return isLocking();
+        }
+    };
+
     private long mPendingFinishTime;
     private Runnable mPendingFinishRunnable = new Runnable() {
         @Override
@@ -154,6 +173,7 @@ public class AcDisplayActivity extends KeyguardActivity implements
 
         mImmersiveMode = Device.hasKitKatApi();
         mGestureDetector = new GestureDetector(this, new GestureListener());
+        mSensors = ActiveModeService.buildAvailableSensorsList(this);
 
         mTimeout.registerListener(this);
         mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal());
@@ -166,6 +186,12 @@ public class AcDisplayActivity extends KeyguardActivity implements
         super.onResume();
         handleWindowFocusChanged(true);
         mHandler.removeCallbacks(mPendingFinishRunnable);
+
+        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
+        for (ActiveModeSensor sensor : mSensors) {
+            sensor.registerCallback(mSensorCallback);
+            sensor.onAttached(sensorManager, this);
+        }
     }
 
     @Override
@@ -180,6 +206,12 @@ public class AcDisplayActivity extends KeyguardActivity implements
                     mPendingFinishRunnable,
                     PENDING_FINISH_DELAY);
         }
+
+        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
+        for (ActiveModeSensor sensor : mSensors) {
+            sensor.onDetached(sensorManager);
+            sensor.unregisterCallback(mSensorCallback);
+        }
     }
 
     @Override
@@ -297,7 +329,7 @@ public class AcDisplayActivity extends KeyguardActivity implements
 
     /**
      * @return True is this activity may be closed by
-     * {@link com.achep.activedisplay.activemode.ActiveSensor active sensors}.
+     * {@link com.achep.activedisplay.activemode.ActiveModeSensor active sensors}.
      */
     // TODO: Write something better
     public boolean isCloseableBySensor() {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
index c8825cc6..56f1b289 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
@@ -30,11 +30,10 @@ import android.util.Log;
 import com.achep.activedisplay.Config;
 import com.achep.activedisplay.InactiveHoursHelper;
 import com.achep.activedisplay.NotificationIds;
-import com.achep.activedisplay.Operator;
 import com.achep.activedisplay.Presenter;
 import com.achep.activedisplay.Project;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.activemode.ProximitySensor;
+import com.achep.activedisplay.activemode.sensors.ProximitySensor;
 import com.achep.activedisplay.blacklist.AppConfig;
 import com.achep.activedisplay.blacklist.Blacklist;
 import com.achep.activedisplay.utils.PowerUtils;
