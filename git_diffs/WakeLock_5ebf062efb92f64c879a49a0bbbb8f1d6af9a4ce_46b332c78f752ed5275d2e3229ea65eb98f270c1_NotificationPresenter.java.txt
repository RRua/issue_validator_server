diff --git a/project/app/src/main/java/com/achep/acdisplay/App.java b/project/app/src/main/java/com/achep/acdisplay/App.java
index 9bcf45d3..d59ebaf0 100644
--- a/project/app/src/main/java/com/achep/acdisplay/App.java
+++ b/project/app/src/main/java/com/achep/acdisplay/App.java
@@ -159,6 +159,7 @@ public class App extends Application {
     public void onLowMemory() {
         Config.getInstance().onLowMemory();
         Blacklist.getInstance().onLowMemory();
+        NotificationPresenter.getInstance().onLowMemory();
         mAccessManager.onLowMemory();
         super.onLowMemory();
     }
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
index 88802aec..a235a140 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
@@ -21,6 +21,8 @@ package com.achep.acdisplay.notifications;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
+import com.achep.base.interfaces.IOnLowMemory;
+
 import java.util.ArrayList;
 
 /**
@@ -29,7 +31,7 @@ import java.util.ArrayList;
  *
  * @author Artem Chepurnoy
  */
-final class NotificationList extends ArrayList<OpenNotification> {
+final class NotificationList extends ArrayList<OpenNotification> implements IOnLowMemory {
 
     /**
      * Default return value of {@link #pushNotification(OpenNotification)}
@@ -49,6 +51,14 @@ final class NotificationList extends ArrayList<OpenNotification> {
      */
     private int mMaximumSize = Integer.MAX_VALUE;
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLowMemory() {
+        for (OpenNotification n : this) n.onLowMemory();
+    }
+
     /**
      * Interface definition for a callback to be invoked
      * when a list of notifications has changed.
@@ -113,6 +123,10 @@ final class NotificationList extends ArrayList<OpenNotification> {
      * {@link NotificationList.OnNotificationListChangedListener#onNotificationChanged(OpenNotification n, OpenNotification old)}
      */
     int pushNotification(@NonNull OpenNotification n) {
+        return pushNotification(n, true);
+    }
+
+    int pushNotification(@NonNull OpenNotification n, boolean www) {
         final int index = indexOfNotification(n);
         if (index == -1) {
             if (size() > mMaximumSize) {
@@ -122,13 +136,14 @@ final class NotificationList extends ArrayList<OpenNotification> {
             // Add new notification to the list.
             add(n);
             return notifyListener(EVENT_ADDED, n, null);
-        } else {
+        } else if (www) {
             // Replace old notification with new one.
             OpenNotification old = get(index);
             remove(index);
             add(index, n);
             return notifyListener(EVENT_CHANGED, n, old);
         }
+        return RESULT_DEFAULT;
     }
 
     /**
@@ -139,12 +154,13 @@ final class NotificationList extends ArrayList<OpenNotification> {
      */
     int removeNotification(@NonNull OpenNotification n) {
         final int index = indexOfNotification(n);
-        if (index != -1) {
-            OpenNotification old = get(index);
-            remove(index);
-            return notifyListener(EVENT_REMOVED, old, null);
-        }
-        return RESULT_DEFAULT;
+        return index != -1 ? removeNotification(index) : RESULT_DEFAULT;
+    }
+
+    int removeNotification(int index) {
+        OpenNotification old = get(index);
+        remove(index);
+        return notifyListener(EVENT_REMOVED, old, null);
     }
 
     /**
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPrProxy.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPrProxy.java
new file mode 100644
index 00000000..9dbc7d59
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPrProxy.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.notifications;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.achep.base.Build;
+import com.achep.base.Device;
+import com.achep.base.utils.Operator;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import static com.achep.acdisplay.notifications.NotificationPresenter.FLAG_IMMEDIATELY;
+
+/**
+ * Processes the notification flow, and re-transfers it through the
+ * {@link Looper#getMainLooper() main thread}.
+ *
+ * @author Artem Chepurnoy
+ */
+class NotificationPrProxy {
+
+    private static final String TAG = "NotificationPrProxy";
+
+    private static final long DELAY = 400; // 0.4 sec.
+    private static final long MAX_DELAY = DELAY * 5; // 2 sec.
+
+    @NonNull
+    private final Object mMonitor = new Object();
+    @NonNull
+    private final NotificationPresenter mPresenter;
+    @NonNull
+    private final Handler mHandler;
+    @NonNull
+    private final List<NotificationPrTask> mTasks;
+    private final Runnable mProcessRunnable = new Runnable() {
+        @Override
+        public void run() {
+            synchronized (mMonitor) {
+                mStartTime = 0;
+                mProcessing = true;
+                optimizePrTasks(mTasks);
+                sendPrTasks(mTasks);
+                mTasks.clear();
+                mProcessing = false;
+            }
+        }
+    };
+
+    private volatile long mStartTime;
+    private volatile boolean mProcessing;
+
+    public NotificationPrProxy(
+            @NonNull NotificationPresenter presenter,
+            @NonNull Looper looper) {
+        mPresenter = presenter;
+        mHandler = new Handler(looper);
+        mTasks = new ArrayList<>(Device.hasLollipopApi()
+                ? 15 /* multiply notifications levels have
+                 introduced a much larger flow of notifications */
+                : 4);
+    }
+
+    /**
+     * Called on {@link NotificationPresenter#postNotification(Context, OpenNotification, int)}
+     * (direct posting a notification).
+     *
+     * @see #onRemoved(OpenNotification)
+     * @see #onClear()
+     */
+    void onPosted(@NonNull OpenNotification n) {
+        onRemoveDuplicates(n);
+    }
+
+    public void postNotification(
+            @NonNull Context context,
+            @NonNull OpenNotification n, int flags) {
+        synchronized (mMonitor) {
+            boolean immediately = Operator.bitAnd(flags, FLAG_IMMEDIATELY);
+            addTask(context, n, flags, true, immediately);
+        }
+    }
+
+    /**
+     * Called on {@link NotificationPresenter#removeNotification(OpenNotification, int)}
+     * (direct removing a notification).
+     *
+     * @see #onPosted(OpenNotification) (OpenNotification)
+     * @see #onClear()
+     */
+    void onRemoved(@NonNull OpenNotification n) {
+        onRemoveDuplicates(n);
+    }
+
+    public void removeNotification(@NonNull OpenNotification n, int flags) {
+        synchronized (mMonitor) {
+            boolean immediately = Operator.bitAnd(flags, FLAG_IMMEDIATELY);
+            addTask(null, n, flags, false, immediately);
+        }
+    }
+
+    /**
+     * Called on {@link NotificationPresenter#clear(boolean)}
+     * (direct clean-up).
+     *
+     * @see #onPosted(OpenNotification)
+     * @see #onRemoved(OpenNotification)
+     */
+    void onClear() {
+        synchronized (mMonitor) {
+            mStartTime = 0;
+            mTasks.clear();
+            mHandler.removeCallbacks(mProcessRunnable);
+        }
+    }
+
+    private void addTask(@Nullable Context context, @NonNull OpenNotification notification,
+                         int flags, boolean posts, boolean immediately) {
+        mTasks.add(new NotificationPrTask(context, notification, posts, flags));
+        // Do not allow an infinitive loop here.
+        final long now = SystemClock.elapsedRealtime();
+        if (mStartTime == 0) mStartTime = now;
+        final long delta = now - mStartTime;
+        // Delay the processing.
+        mHandler.removeCallbacks(mProcessRunnable);
+        mHandler.postDelayed(mProcessRunnable, immediately || delta > MAX_DELAY ? 0 : DELAY);
+    }
+
+    private void onRemoveDuplicates(@NonNull OpenNotification n) {
+        synchronized (mMonitor) {
+            if (!mProcessing) removeOverridingTasks(n);
+        }
+    }
+
+    private void removeOverridingTasks(@NonNull OpenNotification n) {
+        Iterator<NotificationPrTask> iterator = mTasks.iterator();
+        while (iterator.hasNext()) {
+            if (NotificationUtils.hasIdenticalIds(
+                    iterator.next().notification,
+                    n)) iterator.remove();
+        }
+    }
+
+    /**
+     * Optimize the {@link NotificationPrTask post/remove tasks} list by removing redundant
+     * tasks and sorting families.
+     */
+    public void optimizePrTasks(@NonNull List<NotificationPrTask> list) {
+        if (Build.DEBUG) Log.d(TAG, "Optimizing post/remove tasks...");
+        final int size = list.size();
+        //noinspection ConstantConditions
+        NotificationPrTask empty = new NotificationPrTask(null, null, false, 0);
+        // 1. Remove overriding tasks.
+        for (int i = size - 1; i >= 0; i--) {
+            NotificationPrTask task = list.get(i);
+            if (task == empty) continue;
+            for (int j = i - 1; j >= 0; j--) {
+                NotificationPrTask sub = list.get(j);
+                if (sub == empty) continue;
+                if (NotificationUtils.hasIdenticalIds(
+                        task.notification,
+                        sub.notification)) {
+                    Log.i(TAG, "Removed overridden task on pre-processing tasks list.");
+                    list.set(j, empty);
+                }
+            }
+        }
+        // 2. Remove empty objects.
+        Iterator<NotificationPrTask> iterator = list.iterator();
+        while (iterator.hasNext()) {
+            NotificationPrTask task = iterator.next();
+            if (task == empty) iterator.remove();
+        }
+        // 3. Sort families.
+        for (int i = 0; i < size; i++) {
+            NotificationPrTask task = list.get(i);
+            if (task == empty || !task.notification.isGroupChild()) continue;
+            for (int j = i + 1; j < size; j++) {
+                NotificationPrTask sub = list.get(j);
+                if (sub == empty || !sub.notification.isGroupSummary()) continue;
+                if (NotificationUtils.hasIdenticalIds(
+                        task.notification,
+                        sub.notification)) {
+                    Log.d(TAG, "Swapped two tasks on pre-processing tasks list.");
+                    // Swap two tasks.
+                    list.set(j, task);
+                    list.set(i, sub);
+                    break;
+                }
+            }
+        }
+        // 4. Anything else?
+    }
+
+    /**
+     * Materializes the tasks by {@link #postNotification(Context, OpenNotification, int) posting}
+     * or {@link #removeNotification(OpenNotification, int) removing} appropriate notifications.
+     */
+    public void sendPrTasks(@NonNull List<NotificationPrTask> list) {
+        for (NotificationPrTask task : list) {
+            if (task.posts) {
+                assert task.context != null;
+                mPresenter.postNotification(task.context, task.notification, task.flags);
+            } else {
+                mPresenter.removeNotification(task.notification, task.flags);
+            }
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPrTask.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPrTask.java
new file mode 100644
index 00000000..4a8c25ba
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPrTask.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.notifications;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
+/**
+ * @author Artem Chepurnoy
+ */
+class NotificationPrTask {
+
+    @Nullable
+    public final Context context;
+    @NonNull
+    public final OpenNotification notification;
+
+    /**
+     * {@code true} if it's a {@link NotificationPresenter#postNotification(Context, OpenNotification, int) post}
+     * event, {@code false} {@link NotificationPresenter#removeNotification(OpenNotification, int) otherwise}.
+     */
+    public final boolean posts;
+
+    public int flags;
+
+    NotificationPrTask(@Nullable Context context, @NonNull OpenNotification notification,
+                       boolean posts, int flags) {
+        this.context = context;
+        this.notification = notification;
+        this.posts = posts;
+        this.flags = flags;
+    }
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
index 1edeed53..379cd779 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
@@ -23,7 +23,6 @@ import android.app.NotificationManager;
 import android.content.Context;
 import android.os.Handler;
 import android.os.Looper;
-import android.os.PowerManager;
 import android.os.SystemClock;
 import android.service.notification.StatusBarNotification;
 import android.support.annotation.NonNull;
@@ -35,21 +34,19 @@ import com.achep.acdisplay.App;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.blacklist.AppConfig;
 import com.achep.acdisplay.blacklist.Blacklist;
-import com.achep.base.AppHeap;
 import com.achep.base.Device;
 import com.achep.base.content.ConfigBase;
+import com.achep.base.interfaces.IOnLowMemory;
 import com.achep.base.interfaces.ISubscriptable;
 import com.achep.base.tests.Check;
 import com.achep.base.utils.Operator;
 
-import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
-import java.util.Map;
+import java.util.List;
 import java.util.Set;
-import java.util.concurrent.ConcurrentLinkedQueue;
 
 import static com.achep.base.Build.DEBUG;
 
@@ -58,7 +55,8 @@ import static com.achep.base.Build.DEBUG;
  */
 public class NotificationPresenter implements
         NotificationList.OnNotificationListChangedListener,
-        ISubscriptable<NotificationPresenter.OnNotificationListChangedListener> {
+        ISubscriptable<NotificationPresenter.OnNotificationListChangedListener>,
+        IOnLowMemory {
 
     private static final String TAG = "NotificationPresenter";
     private static final String WAKE_LOCK_TAG = "Notification pool post/remove lock.";
@@ -69,8 +67,6 @@ public class NotificationPresenter implements
      */
     private static final boolean FILTER_NOISY_NOTIFICATIONS = true;
 
-    private static final long POST_REMOVE_POOL_DURATION = 400; // 0.4 sec.
-
     private static final int FRESH_NOTIFICATION_EXPIRY_TIME = 4000; // 4 sec.
 
     public static final int FLAG_SILENCE = 1;
@@ -114,66 +110,15 @@ public class NotificationPresenter implements
     private final ArrayList<NotificationListChange> mFrozenEvents;
     private int mFreezeLevel;
 
-    private final Config mConfig;
-    private final Blacklist mBlacklist;
-
     // Threading
     private final Handler mHandler;
     private volatile int mDetectingSyncTroubles;
+    private NotificationPrProxy mProxy;
 
-    // Remote posting/removing
-    private boolean mProcessingPRQueue;
-    private final ConcurrentLinkedQueue<PostRemoveEvent> mPRQueue = new ConcurrentLinkedQueue<>();
-    private final Runnable mPRRunnable = new Runnable() {
-        @Override
-        public void run() {
-            synchronized (mPRQueue) {
-                if (DEBUG) Log.d(TAG, "Processing the p&r queue (" + mPRQueue.size() + " events)");
-
-                mProcessingPRQueue = true;
-                // Release all events!
-                PostRemoveEvent event;
-                while ((event = mPRQueue.poll()) != null) {
-                    if (event.posts) {
-                        assert event.context != null;
-                        postNotification(event.context, event.notification, event.flags);
-                    } else {
-                        removeNotification(event.notification, event.flags);
-                    }
-                }
-                mProcessingPRQueue = false;
-            }
-        }
-    };
-
-    /**
-     * @author Artem Chepurnoy
-     */
-    private static class PostRemoveEvent {
-
-        @Nullable
-        public final Context context;
-        @NonNull
-        public final OpenNotification notification;
+    //-- HANDLING CONFIG & BLACKLIST ------------------------------------------
 
-        /**
-         * {@code true} if it's a {@link #postNotification(Context, OpenNotification, int) post}
-         * event, {@code false} {@link #removeNotification(OpenNotification, int) otherwise}.
-         */
-        public final boolean posts;
-
-        public int flags;
-
-        PostRemoveEvent(@Nullable Context context, @NonNull OpenNotification notification,
-                        boolean posts, int flags) {
-            this.context = context;
-            this.notification = notification;
-            this.posts = posts;
-            this.flags = flags;
-        }
-    }
-
-    //-- HANDLING CONFIG & BLACKLIST CHANGES ----------------------------------
+    private final Config mConfig;
+    private final Blacklist mBlacklist;
 
     // Do not make local!
     private final ConfigListener mConfigListener;
@@ -230,18 +175,15 @@ public class NotificationPresenter implements
 
         private void handleNotifyPriorityChanged(int a, int b) {
             if (a > b) {
-                // This is here to remind me the great times
-                // of programming in the school. Sorry for that :p
-                a -= b *= -1;
-                a -= b += a;
-                // FIXME: Those two codes must do the same thing (proved by gcc).
-                // But definitely Java compiler is broken. I'm scared
-                // now... How can I not trust the compiler?
+                int k = a;
+                a = b;
+                b = k;
+                // FIXME: This swapping method doesn't work on Java, but does work on C++
                 // a -= b += a -= b *= -1;
             }
 
             final int lower = a, higher = b;
-            rebuildLocalList(new Comparator() {
+            rebuildLocalList(new RebuildConfirmatory() {
                 @Override
                 public boolean needsRebuild(@NonNull OpenNotification n) {
                     int priority = n.getNotification().priority;
@@ -270,7 +212,7 @@ public class NotificationPresenter implements
         }
 
         private void handlePackageVisibilityChanged(@NonNull final String packageName) {
-            rebuildLocalList(new Comparator() {
+            rebuildLocalList(new RebuildConfirmatory() {
                 @Override
                 public boolean needsRebuild(@NonNull OpenNotification n) {
                     return n.getPackageName().equals(packageName);
@@ -279,13 +221,13 @@ public class NotificationPresenter implements
         }
     }
 
-    private interface Comparator {
+    private interface RebuildConfirmatory {
         boolean needsRebuild(@NonNull OpenNotification n);
     }
 
-    private void rebuildLocalList(@NonNull Comparator comparator) {
+    private void rebuildLocalList(@NonNull RebuildConfirmatory rebuildConfirmatory) {
         for (OpenNotification n : mGList) {
-            if (comparator.needsRebuild(n)) {
+            if (rebuildConfirmatory.needsRebuild(n)) {
                 rebuildLocalList();
                 break;
             }
@@ -388,6 +330,7 @@ public class NotificationPresenter implements
         mLList = new NotificationList(this);
         mGroupsWithSummaries = new HashSet<>();
         mHandler = new Handler(Looper.getMainLooper());
+        mProxy = new NotificationPrProxy(this, Looper.getMainLooper());
 
         if (!Device.hasJellyBeanMR2Api()) { // pre 4.3 version
             mGList.setMaximumSize(5);
@@ -411,16 +354,18 @@ public class NotificationPresenter implements
         return sNotificationPresenter;
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLowMemory() {
+        mGList.onLowMemory(); // It does cover all local list's notifications
+    }
+
     public void postNotificationFromMain(
             @NonNull final Context context,
             @NonNull final OpenNotification n, final int flags) {
-        synchronized (mPRQueue) {
-            if (DEBUG) Log.d(TAG, "Initially posting " + n + " from \'"
-                    + Thread.currentThread().getName() + "\' thread.");
-
-            boolean immediately = Operator.bitAnd(flags, FLAG_IMMEDIATELY) || !n.isClearable();
-            internalAddPREvent(context, n, flags, true /* post */, immediately);
-        }
+        mProxy.postNotification(context, n, flags);
     }
 
     /**
@@ -441,12 +386,7 @@ public class NotificationPresenter implements
             @NonNull OpenNotification n, int flags) {
         Check.getInstance().isInMainThread();
         mDetectingSyncTroubles = 1;
-
-        synchronized (mPRQueue) {
-            // Clean-up all previous event regard this
-            // notification.
-            if (!mProcessingPRQueue) internalRemovePreviousPREvent(n);
-        }
+        mProxy.onPosted(n);
 
         // Check for the test notification.
         if (isInitNotification(context, n)) {
@@ -539,13 +479,7 @@ public class NotificationPresenter implements
     }
 
     public void removeNotificationFromMain(final @NonNull OpenNotification n, final int flags) {
-        synchronized (mPRQueue) {
-            if (DEBUG) Log.d(TAG, "Initially removing " + n + " from \'"
-                    + Thread.currentThread().getName() + "\' thread.");
-
-            boolean immediately = Operator.bitAnd(flags, FLAG_IMMEDIATELY) || !n.isClearable();
-            internalAddPREvent(null, n, 0, false /* remove */, immediately);
-        }
+        mProxy.removeNotification(n, flags);
     }
 
     /**
@@ -556,12 +490,7 @@ public class NotificationPresenter implements
     public void removeNotification(@NonNull OpenNotification n, final int flags) {
         Check.getInstance().isInMainThread();
         mDetectingSyncTroubles = 2;
-
-        synchronized (mPRQueue) {
-            // Clean-up all previous event regard this
-            // notification.
-            if (!mProcessingPRQueue) internalRemovePreviousPREvent(n);
-        }
+        mProxy.onRemoved(n);
 
         if (n.isGroupSummary()) {
             String groupKey = n.getGroupKey();
@@ -578,7 +507,7 @@ public class NotificationPresenter implements
                     NotificationList list = (NotificationList) n2.getGroupNotifications();
                     int i = list.indexOfNotification(n);
                     if (i != -1) {
-                        list.get(i).recycle();
+                        n.recycle();
                         list.remove(i);
                     }
                     return;
@@ -589,7 +518,7 @@ public class NotificationPresenter implements
         NotificationList list = mGList;
         int i = list.indexOfNotification(n);
         if (i != -1) {
-            list.get(i).recycle();
+            n.recycle();
             list.remove(i);
             mLList.removeNotification(n);
         }
@@ -607,70 +536,21 @@ public class NotificationPresenter implements
      * @see #isValidForGlobal(OpenNotification)
      */
     private void rebuildLocalList() {
-        ArrayList<NotificationListChange> changes = new ArrayList<>();
+        freezeListeners();
 
         // Remove not valid notifications
         // from local list.
-        for (int i = 0; i < mLList.size(); i++) {
+        for (int i = mLList.size() - 1; i >= 0; i--) {
             OpenNotification n = mLList.get(i);
-            if (!isValidForLocal(n)) {
-                mLList.remove(i--);
-                changes.add(new NotificationListChange(EVENT_REMOVED, n));
-            }
+            if (!isValidForLocal(n)) mLList.removeNotification(i);
         }
 
         // Add newly valid notifications to local list.
         for (OpenNotification n : mGList) {
-            if (isValidForLocal(n) && mLList.indexOfNotification(n) == -1) {
-                mLList.add(n);
-                changes.add(new NotificationListChange(EVENT_POSTED, n));
-            }
-        }
-
-        int size = changes.size();
-        if (size > 4) {
-            notifyListeners(null, EVENT_BATH);
-        } else if (size > 0) {
-            notifyListeners(changes);
-        }
-    }
-
-    private void internalAddPREvent(
-            @Nullable Context context,
-            @NonNull OpenNotification notification,
-            int flags, boolean posts,
-            boolean immediately) {
-        internalRemovePreviousPREvent(notification);
-        mPRQueue.add(new PostRemoveEvent(context, notification, posts, flags));
-
-        final long duration = POST_REMOVE_POOL_DURATION;
-        if (!immediately) {
-            context = AppHeap.getContext(); // that's cheating :(
-            PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-            pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKE_LOCK_TAG).acquire(duration + 100);
+            if (isValidForLocal(n)) mLList.pushNotification(n, false);
         }
 
-        mHandler.removeCallbacks(mPRRunnable);
-        mHandler.postDelayed(mPRRunnable, immediately ? 0 : duration);
-    }
-
-    private void internalRemovePreviousPREvent(@NonNull OpenNotification notification) {
-        // Remove all previous events from the queue, since they're not
-        // important at all.
-        boolean found = false;
-        Iterator<PostRemoveEvent> iterator = mPRQueue.iterator();
-        while (iterator.hasNext()) {
-            PostRemoveEvent event = iterator.next();
-            if (NotificationUtils.hasIdenticalIds(event.notification, notification)) {
-                Check.getInstance().isFalse(found);
-                iterator.remove();
-                found = true;
-
-                // I don't want that test to be run on
-                // release build.
-                if (!DEBUG) break;
-            }
-        }
+        meltListeners();
     }
 
     @Nullable
@@ -689,14 +569,20 @@ public class NotificationPresenter implements
     }
 
     /**
-     * @return the number of notifications in local list of notifications.
+     * @return the number of notifications in {@link #getList() local list}.
+     * @see #isEmpty()
      */
     public int size() {
-        return getList().size();
+        return mLList.size();
     }
 
+    /**
+     * @return {@code true} if the {@link #getList() local list} contains no notifications,
+     * {@code false} otherwise.
+     * @see #size()
+     */
     public boolean isEmpty() {
-        return getList().isEmpty();
+        return mLList.isEmpty();
     }
 
     //-- LOCAL LIST'S EVENTS --------------------------------------------------
@@ -707,6 +593,7 @@ public class NotificationPresenter implements
     @Override
     // Not an enter point, should not be synchronized.
     public int onNotificationAdded(@NonNull OpenNotification n) {
+        Check.getInstance().isFalse(n.isRecycled());
         loadNotificationBackground(n);
         notifyListeners(n, EVENT_POSTED);
         return RESULT_SUCCESS;
@@ -718,7 +605,9 @@ public class NotificationPresenter implements
     @Override
     // Not an enter point, should not be synchronized.
     public int onNotificationChanged(@NonNull OpenNotification n, @NonNull OpenNotification old) {
-        if (!FILTER_NOISY_NOTIFICATIONS) return RESULT_SUCCESS;
+        Check.getInstance().isFalse(n.isRecycled());
+        loadNotificationBackground(n);
+        old.clearBackground();
 
         // Prevent god damn notification spam by
         // checking texts' equality.
@@ -730,18 +619,15 @@ public class NotificationPresenter implements
                 && TextUtils.equals(n.titleText, old.titleText)
                 && TextUtils.equals(n.titleBigText, old.titleBigText)
                 && TextUtils.equals(n.messageText, old.messageText)
-                && TextUtils.equals(n.infoText, old.infoText)) {
+                && TextUtils.equals(n.infoText, old.infoText)
+                && !n.isMine() /* i'm not dumb */) {
             // Technically notification was changed, but it was a fault
             // of dumb developer. Mark notification as read, if old one was.
             n.setRead(old.isRead());
-
-            if (!n.isMine()) {
-                notifyListeners(n, EVENT_CHANGED_SPAM);
-                return RESULT_SPAM; // Don't wake up.
-            }
+            notifyListeners(n, EVENT_CHANGED_SPAM);
+            return RESULT_SPAM; // Don't wake up.
         }
 
-        loadNotificationBackground(n);
         notifyListeners(n, EVENT_CHANGED);
         return RESULT_SUCCESS;
     }
@@ -753,7 +639,18 @@ public class NotificationPresenter implements
     // Not an enter point, should not be synchronized.
     public int onNotificationRemoved(@NonNull OpenNotification n) {
         notifyListeners(n, EVENT_REMOVED);
-        n.clearBackground();
+        // You don't have to recycle the notification here, cause
+        // it should be recycled on removing from the global list. Otherwise you
+        // may get unexpected behaviour when this notification will be
+        // added back to the local list.
+        if (!n.isRecycled()) {
+            n.clearBackground();
+        }
+        if (isEmpty()) {
+            // Clean-up static cache
+            if (DEBUG) Log.d(TAG, "Cleaning the ref-cache...");
+            NotificationUiHelper.sAppIconCache.clear();
+        }
         return RESULT_SUCCESS;
     }
 
@@ -898,12 +795,17 @@ public class NotificationPresenter implements
                 clear(false);
 
                 if (DEBUG) Log.d(TAG, "Initializing the notifications list...");
+                // Initialize the notifications list through the proxy to
+                // optimize the process. This is completely not useful on
+                // pre-Lollipop devices due to lack of children notifications.
+                List<NotificationPrTask> list = new ArrayList<>(activeNotifications.length);
                 for (StatusBarNotification sbn : activeNotifications) {
                     OpenNotification n = OpenNotification.newInstance(sbn);
-                    postNotification(context, n, FLAG_SILENCE);
+                    list.add(new NotificationPrTask(context, n, true /* post */, 0));
                 }
-
-                notifyListeners(null, EVENT_BATH);
+                if (Device.hasLollipopApi()) mProxy.optimizePrTasks(list);
+                mProxy.sendPrTasks(list);
+                list.clear(); // This is probably not needed.
             }
         });
     }
@@ -923,11 +825,7 @@ public class NotificationPresenter implements
         if (DEBUG) Log.d(TAG, "Clearing the notifications list... notify_listeners="
                 + notifyListeners);
 
-        synchronized (mPRQueue) {
-            mPRQueue.clear();
-            mHandler.removeCallbacks(mPRRunnable);
-        }
-
+        mProxy.onClear();
         mGroupsWithSummaries.clear();
         mGList.clear();
         mLList.clear();
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUiHelper.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUiHelper.java
index 23f377e0..11cfa40f 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUiHelper.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUiHelper.java
@@ -40,11 +40,12 @@ import com.achep.base.tests.Check;
 import com.achep.base.utils.CsUtils;
 import com.achep.base.utils.NullUtils;
 import com.achep.base.utils.Operator;
+import com.achep.base.utils.RefCacheBase;
 
+import java.lang.ref.Reference;
 import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
 import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
 
 /**
  * Created by Artem Chepurnoy on 11.02.2015.
@@ -69,7 +70,13 @@ public class NotificationUiHelper implements INotificatiable {
     private static final int PENDING_UPDATE_ICONS = 1 << 5;
 
     private static SoftReference<CharSequence[]> sSecureContentLabelRef;
-    private static Map<String, SoftReference<Bitmap>> sAppIconCache = new HashMap<>();
+    static RefCacheBase<Bitmap> sAppIconCache = new RefCacheBase<Bitmap>() {
+        @NonNull
+        @Override
+        protected Reference<Bitmap> onCreateReference(@NonNull Bitmap bitmap) {
+            return new WeakReference<>(bitmap);
+        }
+    };
 
     private OpenNotification mNotification;
     private CharSequence[] mMessages;
@@ -222,8 +229,7 @@ public class NotificationUiHelper implements INotificatiable {
             // Store the bitmaps in soft-reference cache map, to
             // reduce memory usage and improve performance.
             String packageName = mNotification.getPackageName();
-            SoftReference<Bitmap> cachedBitmap = sAppIconCache.get(packageName);
-            if (cachedBitmap == null || (bitmap = cachedBitmap.get()) == null) {
+            if ((bitmap = sAppIconCache.get(packageName)) == null) {
                 Drawable drawable = getAppIcon(mNotification.getPackageName());
                 if (drawable != null) {
                     bitmap = Bitmap.createBitmap(
@@ -232,7 +238,7 @@ public class NotificationUiHelper implements INotificatiable {
                             Bitmap.Config.ARGB_4444);
                     drawable.setBounds(0, 0, bitmap.getWidth(), bitmap.getHeight());
                     drawable.draw(new Canvas(bitmap));
-                    sAppIconCache.put(packageName, new SoftReference<>(bitmap));
+                    sAppIconCache.put(packageName, bitmap);
                 } else {
                     bitmap = null;
                     sAppIconCache.remove(packageName);
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
index 63c0087e..4ab9f3cd 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
@@ -40,7 +40,9 @@ import com.achep.acdisplay.Config;
 import com.achep.acdisplay.utils.BitmapUtils;
 import com.achep.base.Device;
 import com.achep.base.async.AsyncTask;
+import com.achep.base.interfaces.IOnLowMemory;
 import com.achep.base.interfaces.ISubscriptable;
+import com.achep.base.tests.Check;
 import com.achep.base.utils.Operator;
 import com.achep.base.utils.PackageUtils;
 import com.achep.base.utils.smiley.SmileyParser;
@@ -53,7 +55,8 @@ import java.util.List;
  * @author Artem Chepurnoy
  */
 public abstract class OpenNotification implements
-        ISubscriptable<OpenNotification.OnNotificationDataChangedListener> {
+        ISubscriptable<OpenNotification.OnNotificationDataChangedListener>,
+        IOnLowMemory {
 
     private static final String TAG = "OpenNotification";
 
@@ -118,6 +121,7 @@ public abstract class OpenNotification implements
     private boolean mEmoticonsEnabled;
     private boolean mMine;
     private boolean mRead;
+    private boolean mRecycled;
     private long mLoadedTimestamp;
     private int mNumber;
 
@@ -221,6 +225,13 @@ public abstract class OpenNotification implements
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLowMemory() {
+    }
+
     @Nullable
     private CharSequence ensureNotEmpty(@Nullable CharSequence cs) {
         return TextUtils.isEmpty(cs) ? null : cs;
@@ -406,6 +417,11 @@ public abstract class OpenNotification implements
                     appIcon.getMinimumWidth(),
                     appIcon.getMinimumHeight(),
                     Bitmap.Config.ARGB_4444);
+            if (bitmap == null) {
+                // This had happened on somewhat strange
+                // chinese phone.
+                return;
+            }
             appIcon.draw(new Canvas(bitmap));
             AsyncTask.stop(mPaletteWorker);
             mPaletteWorker = Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {
@@ -545,6 +561,9 @@ public abstract class OpenNotification implements
      * Clears some notification's resources.
      */
     void recycle() {
+        Check.getInstance().isFalse(mRecycled);
+        mRecycled = true;
+
         clearBackground();
         AsyncTask.stop(mPaletteWorker);
         if (mIconFactory != null) {
@@ -553,6 +572,11 @@ public abstract class OpenNotification implements
         }
     }
 
+    /* Only for debug purposes */
+    boolean isRecycled() {
+        return mRecycled;
+    }
+
     /**
      * @return {@code true} if notification has been posted from my own application,
      * {@code false} otherwise (or the package name can not be get).
@@ -574,8 +598,8 @@ public abstract class OpenNotification implements
      * {@link Notification#FLAG_NO_CLEAR}.
      */
     public boolean isClearable() {
-        return Operator.bitAnd(mNotification.flags, Notification.FLAG_ONGOING_EVENT)
-                && Operator.bitAnd(mNotification.flags, Notification.FLAG_NO_CLEAR);
+        return !Operator.bitAnd(mNotification.flags, Notification.FLAG_ONGOING_EVENT)
+                && !Operator.bitAnd(mNotification.flags, Notification.FLAG_NO_CLEAR);
     }
 
     public boolean isContentSecret(@NonNull Context context) {
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationLollipop.java b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationLollipop.java
index c651f950..2faf98fd 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationLollipop.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationLollipop.java
@@ -28,8 +28,6 @@ import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 
-import com.achep.base.tests.Check;
-
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
@@ -50,6 +48,15 @@ class OpenNotificationLollipop extends OpenNotificationKitKatWatch {
         mGroupNotifications = new NotificationList(null);
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLowMemory() {
+        super.onLowMemory();
+        for (OpenNotification n : mGroupNotifications) n.onLowMemory();
+    }
+
     /**
      * {@inheritDoc}
      */
diff --git a/project/app/src/main/java/com/achep/base/utils/RefCacheBase.java b/project/app/src/main/java/com/achep/base/utils/RefCacheBase.java
index 6f385e02..b7152429 100644
--- a/project/app/src/main/java/com/achep/base/utils/RefCacheBase.java
+++ b/project/app/src/main/java/com/achep/base/utils/RefCacheBase.java
@@ -40,6 +40,18 @@ public abstract class RefCacheBase<T> {
         }
     }
 
+    @Nullable
+    public final T remove(@NonNull CharSequence key) {
+        synchronized (this) {
+            Reference<T> ref = mCache.remove(key);
+            if (ref == null) {
+                cleanDeadEntries();
+                return null;
+            }
+            return ref.get();
+        }
+    }
+
     @Nullable
     public final T get(@NonNull CharSequence key) {
         synchronized (this) {
@@ -73,6 +85,15 @@ public abstract class RefCacheBase<T> {
         }
     }
 
+    /**
+     * Removes all elements from this cache, leaving it empty.
+     */
+    public void clear() {
+        synchronized (this) {
+            mCache.clear();
+        }
+    }
+
     @NonNull
     protected abstract Reference<T> onCreateReference(@NonNull T object);
 
