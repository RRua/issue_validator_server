diff --git a/core/src/com/agateau/tinywheels/map/MapInfo.java b/core/src/com/agateau/tinywheels/map/MapInfo.java
index 0e9025a9..9afb508a 100644
--- a/core/src/com/agateau/tinywheels/map/MapInfo.java
+++ b/core/src/com/agateau/tinywheels/map/MapInfo.java
@@ -21,16 +21,17 @@ package com.agateau.tinywheels.map;
 import com.agateau.tinywheels.Constants;
 import com.agateau.tinywheels.utils.OrientedPoint;
 import com.agateau.utils.Assert;
+import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.Color;
 import com.badlogic.gdx.maps.MapLayer;
 import com.badlogic.gdx.maps.MapObject;
 import com.badlogic.gdx.maps.MapProperties;
 import com.badlogic.gdx.maps.objects.EllipseMapObject;
-import com.badlogic.gdx.maps.tiled.AtlasTmxMapLoader;
 import com.badlogic.gdx.maps.tiled.TiledMap;
 import com.badlogic.gdx.maps.tiled.TiledMapTile;
 import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
 import com.badlogic.gdx.maps.tiled.TiledMapTileSet;
+import com.badlogic.gdx.maps.tiled.TmxMapLoader;
 import com.badlogic.gdx.math.Ellipse;
 import com.badlogic.gdx.math.MathUtils;
 import com.badlogic.gdx.math.Vector2;
@@ -68,8 +69,8 @@ public class MapInfo implements Disposable {
         if (mMap != null) {
             return;
         }
-        AtlasTmxMapLoader loader = new AtlasTmxMapLoader();
-        mMap = loader.load("maps/" + mId + ".tmx");
+        TmxMapLoader loader = new TmxMapLoader();
+        mMap = loader.load(Gdx.files.internal("maps/" + mId + ".tmx").path());
         mMaterialForTileId = computeMaterialForTileId();
         findSpecialTileIds();
         findLayers();
diff --git a/tools/src/com/agateau/tinywheels/tools/MapPacker.java b/tools/src/com/agateau/tinywheels/tools/MapPacker.java
deleted file mode 100644
index c59f8399..00000000
--- a/tools/src/com/agateau/tinywheels/tools/MapPacker.java
+++ /dev/null
@@ -1,377 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See libgdx AUTHORS file.
- * https://github.com/libgdx/libgdx/blob/master/AUTHORS
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- ******************************************************************************/
-package com.agateau.tinywheels.tools;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.graphics.g2d.TextureAtlas;
-import com.badlogic.gdx.maps.MapProperties;
-import com.badlogic.gdx.maps.tiled.TiledMapTileSet;
-import com.badlogic.gdx.maps.tiled.TiledMapTileSets;
-import com.badlogic.gdx.maps.tiled.TmxMapLoader;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.tools.texturepacker.TexturePacker;
-import com.badlogic.gdx.tools.texturepacker.TexturePacker.Settings;
-import com.badlogic.gdx.utils.GdxRuntimeException;
-import com.badlogic.gdx.utils.XmlReader;
-import com.agateau.utils.FileUtils;
-import com.agateau.utils.log.NLog;
-
-import org.w3c.dom.Attr;
-import org.w3c.dom.Document;
-import org.w3c.dom.NamedNodeMap;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-import org.xml.sax.SAXException;
-
-import java.awt.Graphics;
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.FilenameFilter;
-import java.io.IOException;
-import java.util.ArrayList;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.transform.Transformer;
-import javax.xml.transform.TransformerConfigurationException;
-import javax.xml.transform.TransformerException;
-import javax.xml.transform.TransformerFactory;
-import javax.xml.transform.dom.DOMSource;
-import javax.xml.transform.stream.StreamResult;
-
-/** Given one or more TMX tilemaps, packs all tileset resources used across the maps into a <b>single</b> {@link TextureAtlas} and
- * produces a new TMX file to be loaded with an AtlasTiledMapLoader loader. Optionally, it can keep track of unused tiles
- * and omit them from the generated atlas, reducing the resource size.
- *
- * The original TMX map file will be parsed by using the {@link TmxMapLoader} loader, thus access to a valid OpenGL context is
- * <b>required</b>, that's why an LwjglApplication is created by this preprocessor: this is probably subject to change in the
- * future, where loading both maps metadata and graphics resources should be made conditional.
- *
- * The new TMX map file will contains a new property, namely "atlas", whose value will enable the AtlasTiledMapLoader to
- * correctly read the associated TextureAtlas representing the tileset.
- *
- * @author David Fraska and others (initial implementation, tell me who you are!)
- * @author Manuel Bua */
-public class MapPacker {
-
-    private ArrayList<Integer> blendedTiles = new ArrayList<Integer>();
-
-    private static class TmxFilter implements FilenameFilter {
-        @Override
-        public boolean accept (File dir, String name) {
-            return name.endsWith(".tmx");
-        }
-    }
-
-    /** You can either run the {@link MapPacker#main(String[])} method or reference this class in your own project and call
-     * this method.
-     *
-     * Keep in mind that this preprocessor will need to load the maps by using the {@link TmxMapLoader} loader and this in turn
-     * will need a valid OpenGL context to work: this is probably subject to change in the future, where loading both maps metadata
-     * and graphics resources should be made conditional.
-     *
-     * Process a directory containing TMX map files representing Tiled maps and produce a single TextureAtlas as well as new
-     * processed TMX map files, correctly referencing the generated {@link TextureAtlas} by using the "atlas" custom map property.
-     *
-     * Typically, your maps will lie in a directory, such as "maps/" and your tilesets in a subdirectory such as "maps/city": this
-     * layout will ensure that MapEditor will reference your tileset with a very simple relative path and no parent directory
-     * names, such as "..", will ever happen in your TMX file definition avoiding much of the confusion caused by the preprocessor
-     * working with relative paths.
-     *
-     * <strong>WARNING!</strong> Use caution if you have a "../" in the path of your tile sets! The output for these tile sets will
-     * be relative to the output directory. For example, if your output directory is "C:\mydir\maps" and you have a tileset with
-     * the path "../tileset.png", the tileset will be output to "C:\mydir\" and the maps will be in "C:\mydir\maps".
-     */
-    public void processMaps (File inputDir, File outputDir, Settings texturePackerSettings) throws IOException {
-        outputDir.mkdirs();
-
-        for (File file : inputDir.listFiles(new TmxFilter())) {
-            String atlasName = file.getName().replace(".tmx", "");
-            NLog.i("# Processing %s atlasName=%s", file.getAbsolutePath(), atlasName);
-            FileHandle tmxFile = new FileHandle(file.getAbsolutePath());
-            writeUpdatedTMX(outputDir, tmxFile, atlasName);
-            TiledMapTileSets sets = loadTileSets(tmxFile);
-            packTileSets(sets, inputDir, outputDir, atlasName, texturePackerSettings);
-        }
-    }
-
-    private static TiledMapTileSets loadTileSets(FileHandle handle) {
-        TiledMapTileSets sets = new TiledMapTileSets();
-        XmlReader.Element root = FileUtils.parseXml(handle);
-        for (XmlReader.Element element : root.getChildrenByName("tileset")) {
-            TiledMapTileSet set = new TiledMapTileSet();
-            set.setName(element.get("name", null));
-
-            MapProperties props = set.getProperties();
-            props.put("firstgid", element.getIntAttribute("firstgid", 1));
-            props.put("tilewidth", element.getIntAttribute("tilewidth", 0));
-            props.put("tileheight", element.getIntAttribute("tileheight", 0));
-            props.put("spacing", element.getIntAttribute("spacing", 0));
-            props.put("margin", element.getIntAttribute("margin", 0));
-
-            String source = element.getAttribute("source", null);
-            if (source != null) {
-                throw new RuntimeException("FIXME: tsx support");
-            } else {
-                props.put("imagesource", element.getChildByName("image").getAttribute("source"));
-            }
-            sets.addTileSet(set);
-        }
-        return sets;
-    }
-
-    /** Traverse the specified tilesets, optionally lookup the used ids and pass every tile image to the {@link TexturePacker},
-     * optionally ignoring unused tile ids */
-    private void packTileSets(TiledMapTileSets sets, File inputDir, File outputDir,
-                              String atlasName, Settings texturePackerSettings) throws IOException {
-        FileHandle inputDirHandle = new FileHandle(inputDir.getAbsolutePath());
-
-        TexturePacker packer = new TexturePacker(texturePackerSettings);
-
-        for (TiledMapTileSet set : sets) {
-            System.out.println("Processing tileset " + set.getName());
-            MapProperties props = set.getProperties();
-
-            int tileWidth = props.get("tilewidth", Integer.class);
-            int tileHeight = props.get("tileheight", Integer.class);
-
-            TileSetLayout layout = new TileSetLayout(props, inputDirHandle);
-
-            for (int gid = layout.firstgid, i = 0; i < layout.numTiles; gid++, i++) {
-                Vector2 tileLocation = layout.getLocation(gid);
-                BufferedImage tile = new BufferedImage(tileWidth, tileHeight, BufferedImage.TYPE_4BYTE_ABGR);
-
-                Graphics g = tile.createGraphics();
-                g.drawImage(layout.image,
-                        0, 0, tileWidth, tileHeight,
-                        (int)tileLocation.x, (int)tileLocation.y, (int)tileLocation.x + tileWidth, (int)tileLocation.y + tileHeight,
-                        null);
-
-                if (isBlended(tile)) setBlended(gid);
-                NLog.d("Adding %d, %d (%d %d), gid=%d", (int)tileLocation.x, (int)tileLocation.y, tileWidth, tileHeight, gid);
-                packer.addImage(tile, atlasName + "_" + (gid - 1));
-            }
-        }
-
-        packer.pack(outputDir, atlasName);
-    }
-
-    private void setBlended (int tileNum) {
-        blendedTiles.add(tileNum);
-    }
-
-    private void writeUpdatedTMX (File outputDir, FileHandle tmxFileHandle, String atlasName) throws IOException {
-        Document doc;
-        DocumentBuilder docBuilder;
-        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
-
-        try {
-            docBuilder = docFactory.newDocumentBuilder();
-            doc = docBuilder.parse(tmxFileHandle.read());
-
-            Node map = doc.getFirstChild();
-            while (map.getNodeType() != Node.ELEMENT_NODE || !map.getNodeName().equals("map")) {
-                if ((map = map.getNextSibling()) == null) {
-                    throw new GdxRuntimeException("Couldn't find map node!");
-                }
-            }
-
-            setProperty(doc, map, "blended tiles", toCSV(blendedTiles));
-            setProperty(doc, map, "atlas", atlasName + ".atlas");
-
-            TransformerFactory transformerFactory = TransformerFactory.newInstance();
-            Transformer transformer = transformerFactory.newTransformer();
-            DOMSource source = new DOMSource(doc);
-
-            StreamResult result = new StreamResult(new File(outputDir, tmxFileHandle.name()));
-            transformer.transform(source, result);
-
-        } catch (ParserConfigurationException e) {
-            throw new RuntimeException("ParserConfigurationException: " + e.getMessage());
-        } catch (SAXException e) {
-            throw new RuntimeException("SAXException: " + e.getMessage());
-        } catch (TransformerConfigurationException e) {
-            throw new RuntimeException("TransformerConfigurationException: " + e.getMessage());
-        } catch (TransformerException e) {
-            throw new RuntimeException("TransformerException: " + e.getMessage());
-        }
-    }
-
-    private static void setProperty (Document doc, Node parent, String name, String value) {
-        Node properties = getFirstChildNodeByName(parent, "properties");
-        Node property = getFirstChildByNameAttrValue(properties, "property", "name", name);
-
-        NamedNodeMap attributes = property.getAttributes();
-        Node valueNode = attributes.getNamedItem("value");
-        if (valueNode == null) {
-            valueNode = doc.createAttribute("value");
-            valueNode.setNodeValue(value);
-            attributes.setNamedItem(valueNode);
-        } else {
-            valueNode.setNodeValue(value);
-        }
-    }
-
-    private static String toCSV (ArrayList<Integer> values) {
-        String temp = "";
-        for (int i = 0; i < values.size() - 1; i++) {
-            temp += values.get(i) + ",";
-        }
-        if (values.size() > 0) temp += values.get(values.size() - 1);
-        return temp;
-    }
-
-    /** If the child node doesn't exist, it is created. */
-    private static Node getFirstChildNodeByName (Node parent, String child) {
-        NodeList childNodes = parent.getChildNodes();
-        for (int i = 0; i < childNodes.getLength(); i++) {
-            if (childNodes.item(i).getNodeName().equals(child)) {
-                return childNodes.item(i);
-            }
-        }
-
-        Node newNode = parent.getOwnerDocument().createElement(child);
-
-        if (childNodes.item(0) != null)
-            return parent.insertBefore(newNode, childNodes.item(0));
-        else
-            return parent.appendChild(newNode);
-    }
-
-    private static boolean isBlended (BufferedImage tile) {
-        int[] rgbArray = new int[tile.getWidth() * tile.getHeight()];
-        tile.getRGB(0, 0, tile.getWidth(), tile.getHeight(), rgbArray, 0, tile.getWidth());
-        for (int i = 0; i < tile.getWidth() * tile.getHeight(); i++) {
-            if (((rgbArray[i] >> 24) & 0xff) != 255) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /** If the child node or attribute doesn't exist, it is created. Usage example: Node property =
-     * getFirstChildByAttrValue(properties, "property", "name", "blended tiles"); */
-    private static Node getFirstChildByNameAttrValue (Node node, String childName, String attr, String value) {
-        NodeList childNodes = node.getChildNodes();
-        for (int i = 0; i < childNodes.getLength(); i++) {
-            if (childNodes.item(i).getNodeName().equals(childName)) {
-                NamedNodeMap attributes = childNodes.item(i).getAttributes();
-                Node attribute = attributes.getNamedItem(attr);
-                if (attribute.getNodeValue().equals(value)) return childNodes.item(i);
-            }
-        }
-
-        Node newNode = node.getOwnerDocument().createElement(childName);
-        NamedNodeMap attributes = newNode.getAttributes();
-
-        Attr nodeAttr = node.getOwnerDocument().createAttribute(attr);
-        nodeAttr.setNodeValue(value);
-        attributes.setNamedItem(nodeAttr);
-
-        if (childNodes.item(0) != null) {
-            return node.insertBefore(newNode, childNodes.item(0));
-        } else {
-            return node.appendChild(newNode);
-        }
-    }
-
-    static File inputDir;
-    static File outputDir;
-
-    /** Processes a directory of Tile Maps, compressing each tile set contained in any map once.
-     *
-     * @param args args[0]: the input directory containing the tmx files (and tile sets, relative to the path listed in the tmx
-     *           file). args[1]: The output directory for the tmx files, should be empty before running. WARNING: Use caution if
-     *           you have a "../" in the path of your tile sets! The output for these tile sets will be relative to the output
-     *           directory. For example, if your output directory is "C:\mydir\output" and you have a tileset with the path
-     *           "../tileset.png", the tileset will be output to "C:\mydir\" and the maps will be in "C:\mydir\output". args[2]:
-     *           --strip-unused (optional, include to let the TiledMapPacker remove tiles which are not used. */
-    public static void main (String[] args) {
-        final Settings texturePackerSettings = new Settings();
-        texturePackerSettings.paddingX = 2;
-        texturePackerSettings.paddingY = 2;
-        texturePackerSettings.edgePadding = true;
-        texturePackerSettings.duplicatePadding = true;
-        texturePackerSettings.bleed = true;
-        texturePackerSettings.alias = true;
-        texturePackerSettings.useIndexes = true;
-
-        switch (args.length) {
-        case 2: {
-            inputDir = new File(args[0]);
-            outputDir = new File(args[1]);
-            break;
-        }
-        case 1: {
-            inputDir = new File(args[0]);
-            outputDir = new File(inputDir, "output/");
-            break;
-        }
-        default: {
-            System.out.println("Usage: INPUTDIR [OUTPUTDIR] [--strip-unused]");
-            System.exit(0);
-        }
-        }
-
-        NLog.i("Clearing output dir " + outputDir);
-        boolean ok = clearOutputDir(outputDir);
-        if (!ok) {
-            System.exit(1);
-        }
-
-        if (!inputDir.exists()) {
-            throw new RuntimeException("Input directory does not exist: " + inputDir);
-        }
-
-        try {
-            MapPacker packer = new MapPacker();
-            packer.processMaps(inputDir, outputDir, texturePackerSettings);
-        } catch (IOException e) {
-            throw new RuntimeException("Error processing map: " + e.getMessage());
-        }
-    }
-
-    private static boolean clearOutputDir(File dir) {
-        FilenameFilter filter = new FilenameFilter() {
-            private final String[] EXTENSIONS = new String[]{"tmx", "atlas", "png"};
-            @Override
-            public boolean accept(File file, String name) {
-                int dotPos = name.lastIndexOf('.');
-                if (dotPos < 0) {
-                    NLog.i("No extensions in %s", name);
-                    return false;
-                }
-                String extension = name.substring(dotPos + 1);
-                for (String ext : EXTENSIONS) {
-                    if (ext.equals(extension)) {
-                        return true;
-                    }
-                }
-                return false;
-            }
-        };
-        File[] files = dir.listFiles(filter);
-        if (files != null) {
-            for (File file : files) {
-                boolean ok = file.delete();
-                if (!ok) {
-                    NLog.e("Failed to delete %s", file.getAbsolutePath());
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-}
diff --git a/tools/src/com/agateau/tinywheels/tools/MapScreenshotGenerator.java b/tools/src/com/agateau/tinywheels/tools/MapScreenshotGenerator.java
index 16dace5a..55824854 100644
--- a/tools/src/com/agateau/tinywheels/tools/MapScreenshotGenerator.java
+++ b/tools/src/com/agateau/tinywheels/tools/MapScreenshotGenerator.java
@@ -46,7 +46,7 @@ public class MapScreenshotGenerator {
                     String tmxFileName = arguments[1];
                     processFile(shotFileName, tmxFileName);
                 } else {
-                    FileHandle tmxDir = Gdx.files.absolute("core/assets/maps");
+                    FileHandle tmxDir = Gdx.files.absolute("android/assets/maps");
                     FileHandle shotDir = Gdx.files.absolute("core/assets/ui/map-screenshots");
                     for (FileHandle tmxFile : tmxDir.list(".tmx")) {
                         String shotFileName = shotDir.path() + "/" + tmxFile.nameWithoutExtension() + ".png";
diff --git a/tools/src/com/agateau/tinywheels/tools/TileSetLayout.java b/tools/src/com/agateau/tinywheels/tools/TileSetLayout.java
deleted file mode 100644
index c292c3b5..00000000
--- a/tools/src/com/agateau/tinywheels/tools/TileSetLayout.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*******************************************************************************
- * Copyright 2011 See libgdx AUTHORS file.
- * https://github.com/libgdx/libgdx/blob/master/AUTHORS
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- ******************************************************************************/
-package com.agateau.tinywheels.tools;
-
-import com.badlogic.gdx.files.FileHandle;
-import com.badlogic.gdx.maps.MapProperties;
-import com.badlogic.gdx.math.Vector2;
-import com.badlogic.gdx.utils.IntMap;
-
-import java.awt.image.BufferedImage;
-import java.io.IOException;
-
-import javax.imageio.ImageIO;
-
-/** Contains extra information that can only be calculated after a Tiled Map's tile set images are loaded.
- * @author David Fraska */
-public class TileSetLayout {
-
-    public final BufferedImage image;
-    private final IntMap<Vector2> imageTilePositions;
-    public final int numTiles;
-    public final int firstgid;
-
-    /** Constructs a Tile Set layout. The tile set image contained in the baseDir should be the original tile set images before
-     * being processed by TiledMapPacker (the ones actually read by Tiled).
-     * @param props the properties of the tileset to process
-     * @param baseDir the directory in which the tile set image is stored */
-    protected TileSetLayout (MapProperties props, FileHandle baseDir) throws IOException {
-        int tileWidth = props.get("tilewidth", Integer.class);
-        int tileHeight = props.get("tileheight", Integer.class);
-        int margin = props.get("margin", Integer.class);
-        int spacing = props.get("spacing", Integer.class);
-
-        this.firstgid = props.get("firstgid", Integer.class);
-
-        image = ImageIO.read(baseDir.child(props.get("imagesource", String.class)).read());
-
-        imageTilePositions = new IntMap<Vector2>();
-
-        // fill the tile regions
-        int x, y, tile = 0;
-        int numRows = 0;
-        int numCols = 0;
-
-        int stopWidth = image.getWidth() - tileWidth;
-        int stopHeight = image.getHeight() - tileHeight;
-
-        for (y = margin; y <= stopHeight; y += tileHeight + spacing) {
-            for (x = margin; x <= stopWidth; x += tileWidth + spacing) {
-                if (y == margin) numCols++;
-                imageTilePositions.put(tile, new Vector2(x, y));
-                tile++;
-            }
-            numRows++;
-        }
-
-        numTiles = numRows * numCols;
-    }
-
-    /** Returns the location of the tile in {@link TileSetLayout#image} */
-    public Vector2 getLocation (int tile) {
-        return imageTilePositions.get(tile - firstgid);
-    }
-}
