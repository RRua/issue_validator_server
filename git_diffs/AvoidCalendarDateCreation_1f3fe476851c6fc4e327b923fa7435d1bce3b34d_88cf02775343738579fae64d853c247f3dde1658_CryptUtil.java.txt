diff --git a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
index 04fa22850..662014daf 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
+++ b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
@@ -27,8 +27,8 @@ import androidx.preference.PreferenceManager
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.rule.ServiceTestRule
-import com.amaze.filemanager.filesystem.files.CryptUtil
 import com.amaze.filemanager.utils.ObtainableServiceBinder
+import com.amaze.filemanager.utils.PasswordUtil
 import org.apache.commons.net.ftp.FTP
 import org.apache.commons.net.ftp.FTPClient
 import org.apache.commons.net.ftp.FTPSClient
@@ -139,7 +139,7 @@ class FtpServiceEspressoTest {
             .putString(FtpService.KEY_PREFERENCE_USERNAME, "amazeftp")
             .putString(
                 FtpService.KEY_PREFERENCE_PASSWORD,
-                CryptUtil.encryptPassword(
+                PasswordUtil.encryptPassword(
                     ApplicationProvider.getApplicationContext(),
                     "passw0rD"
                 )
diff --git a/app/src/androidTest/java/com/amaze/filemanager/filesystem/files/CryptUtilTest.java b/app/src/androidTest/java/com/amaze/filemanager/filesystem/files/CryptUtilTest.java
index 7aea85ba1..265e78f03 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/filesystem/files/CryptUtilTest.java
+++ b/app/src/androidTest/java/com/amaze/filemanager/filesystem/files/CryptUtilTest.java
@@ -27,6 +27,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import com.amaze.filemanager.BuildConfig;
+import com.amaze.filemanager.utils.PasswordUtil;
 
 import android.content.Context;
 
@@ -51,7 +52,7 @@ public class CryptUtilTest {
   @Test
   public void testEncryptDecrypt() throws Exception {
     String password = "hackme";
-    String encrypted = CryptUtil.encryptPassword(context, password);
-    assertEquals(password, CryptUtil.decryptPassword(context, encrypted));
+    String encrypted = PasswordUtil.INSTANCE.encryptPassword(context, password);
+    assertEquals(password, PasswordUtil.INSTANCE.decryptPassword(context, encrypted));
   }
 }
diff --git a/app/src/androidTest/java/com/amaze/filemanager/utils/CryptUtilEspressoTest.kt b/app/src/androidTest/java/com/amaze/filemanager/utils/CryptUtilEspressoTest.kt
new file mode 100644
index 000000000..0ffb6adb9
--- /dev/null
+++ b/app/src/androidTest/java/com/amaze/filemanager/utils/CryptUtilEspressoTest.kt
@@ -0,0 +1,101 @@
+package com.amaze.filemanager.utils
+
+import android.os.Environment
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import org.junit.Assert.assertArrayEquals
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+import java.io.ByteArrayInputStream
+import java.io.File
+import java.io.FileOutputStream
+import kotlin.random.Random
+
+/**
+ * Test for [CryptUtil] against real devices.
+ *
+ */
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+@Suppress("StringLiteralDuplication")
+class CryptUtilEspressoTest {
+
+    /**
+     * Sanity test of CryptUtil legacy method, to ensure refactoring won't break
+     * on physical devices
+     */
+    @Test
+    fun testEncryptDecryptLegacyMethod() {
+        val source = Random(System.currentTimeMillis()).nextBytes(117)
+        val sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+        ByteArrayInputStream(source).copyTo(FileOutputStream(sourceFile))
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(sourceFile.absolutePath),
+            ProgressHandler(),
+            ArrayList(),
+            "test.bin${CryptUtil.CRYPT_EXTENSION}",
+            false,
+            null
+        )
+        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.CRYPT_EXTENSION}")
+        assertTrue(targetFile.exists())
+        assertTrue("Source size = ${source.size} target file size = ${targetFile.length()}", targetFile.length() > source.size)
+        sourceFile.delete()
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(targetFile.absolutePath).also {
+                it.size = targetFile.length()
+            },
+            Environment.getExternalStorageDirectory().absolutePath,
+            ProgressHandler(),
+            ArrayList(),
+            null
+        )
+        File(Environment.getExternalStorageDirectory(), "test.bin").run {
+            assertTrue(this.exists())
+            assertArrayEquals(source, this.readBytes())
+        }
+    }
+
+    /**
+     * Test encrypt and decrypt routine with AESCrypt format.
+     */
+    @Test
+    fun testEncryptDecryptAescrypt() {
+        val source = Random(System.currentTimeMillis()).nextBytes(117)
+        val sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+        ByteArrayInputStream(source).copyTo(FileOutputStream(sourceFile))
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(sourceFile.absolutePath),
+            ProgressHandler(),
+            ArrayList(),
+            "test.bin${CryptUtil.AESCRYPT_EXTENSION}",
+            true,
+            "12345678"
+        )
+        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.AESCRYPT_EXTENSION}")
+        assertTrue(targetFile.exists())
+        assertTrue("Source size = ${source.size} target file size = ${targetFile.length()}", targetFile.length() > source.size)
+        sourceFile.delete()
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(targetFile.absolutePath).also {
+                it.size = targetFile.length()
+            },
+            Environment.getExternalStorageDirectory().absolutePath,
+            ProgressHandler(),
+            ArrayList(),
+            "12345678"
+        )
+        File(Environment.getExternalStorageDirectory(), "test.bin").run {
+            assertTrue(this.exists())
+            assertArrayEquals(source, this.readBytes())
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/androidTest/java/com/amaze/filemanager/utils/security/SecretKeygenEspressoTest.kt b/app/src/androidTest/java/com/amaze/filemanager/utils/security/SecretKeygenEspressoTest.kt
new file mode 100644
index 000000000..72d4a7de6
--- /dev/null
+++ b/app/src/androidTest/java/com/amaze/filemanager/utils/security/SecretKeygenEspressoTest.kt
@@ -0,0 +1,29 @@
+package com.amaze.filemanager.utils.security
+
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.fail
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/**
+ * Test [SecretKeygen] runs on real device. Necessary since Robolectric doesn't have shadows for
+ * AndroidKeyStore.
+ */
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+class SecretKeygenEspressoTest {
+
+    /**
+     * Test [SecretKeygen.getSecretKey].
+     */
+    @Test
+    fun testGetSecretKey() {
+        SecretKeygen.getSecretKey()?.run {
+            assertNotNull(this)
+            assertEquals("aes", this.algorithm.lowercase())
+        } ?: fail("Unable to obtain secret key")
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
index 57619f84b..95dc20722 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
@@ -1327,9 +1327,12 @@ public class RecyclerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolde
     }
 
     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-      if (description.endsWith(CryptUtil.CRYPT_EXTENSION))
+      if (description.endsWith(CryptUtil.CRYPT_EXTENSION)
+          || description.endsWith(CryptUtil.AESCRYPT_EXTENSION)) {
         popupMenu.getMenu().findItem(R.id.decrypt).setVisible(true);
-      else popupMenu.getMenu().findItem(R.id.encrypt).setVisible(true);
+      } else {
+        popupMenu.getMenu().findItem(R.id.encrypt).setVisible(true);
+      }
     }
 
     popupMenu.show();
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
index b566430d3..9eb5b99e5 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
@@ -117,7 +117,7 @@ public class DeleteTask
 
       // delete file entry from encrypted database
       if (file.getName(applicationContext).endsWith(CryptUtil.CRYPT_EXTENSION)) {
-        CryptHandler handler = CryptHandler.getInstance();
+        CryptHandler handler = CryptHandler.INSTANCE;
         handler.clear(file.getPath());
       }
     }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt
index a22a17735..33e195b87 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/movecopy/MoveFilesTask.kt
@@ -37,7 +37,6 @@ import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.files.CryptUtil
 import com.amaze.filemanager.filesystem.files.FileUtils
 import com.amaze.filemanager.ui.activities.MainActivity
-import java.util.*
 
 data class MoveFilesReturn(
     val movedCorrectly: Boolean,
@@ -118,14 +117,13 @@ class MoveFilesTask(
                 for (i in paths.indices) {
                     for (file in files[i]) {
                         if (file.getName(applicationContext).endsWith(CryptUtil.CRYPT_EXTENSION)) {
-                            val cryptHandler = CryptHandler.getInstance()
-                            val oldEntry = cryptHandler.findEntry(file.path)
+                            val oldEntry = CryptHandler.findEntry(file.path)
                             if (oldEntry != null) {
                                 val newEntry = EncryptedEntry()
                                 newEntry.id = oldEntry.id
                                 newEntry.password = oldEntry.password
                                 newEntry.path = paths[i] + "/" + file.getName(applicationContext)
-                                cryptHandler.updateEntry(oldEntry, newEntry)
+                                CryptHandler.updateEntry(oldEntry, newEntry)
                             }
                         }
                     }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
index f8896b0fe..472d8d92f 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
@@ -318,7 +318,7 @@ public class CopyService extends AbstractProgressiveService {
         if (sourceFile.getName(c).endsWith(CryptUtil.CRYPT_EXTENSION)) {
           try {
 
-            CryptHandler cryptHandler = CryptHandler.getInstance();
+            CryptHandler cryptHandler = CryptHandler.INSTANCE;
             EncryptedEntry oldEntry = cryptHandler.findEntry(sourceFile.getPath());
             EncryptedEntry newEntry = new EncryptedEntry();
 
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
index a6d908372..9027b6e60 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/DecryptService.java
@@ -20,10 +20,28 @@
 
 package com.amaze.filemanager.asynchronous.services;
 
-import java.util.ArrayList;
+import static com.amaze.filemanager.asynchronous.services.EncryptService.TAG_PASSWORD;
+
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.IBinder;
+import android.util.Log;
+import android.widget.RemoteViews;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.StringRes;
+import androidx.core.app.NotificationCompat;
+import androidx.preference.PreferenceManager;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
+import com.amaze.filemanager.asynchronous.asynctasks.Task;
+import com.amaze.filemanager.asynchronous.asynctasks.TaskKt;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.FileProperties;
@@ -33,24 +51,13 @@ import com.amaze.filemanager.filesystem.files.CryptUtil;
 import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.notifications.NotificationConstants;
+import com.amaze.filemanager.utils.AESCrypt;
 import com.amaze.filemanager.utils.DatapointParcelable;
 import com.amaze.filemanager.utils.ObtainableServiceBinder;
 import com.amaze.filemanager.utils.ProgressHandler;
 
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.os.AsyncTask;
-import android.os.IBinder;
-import android.widget.RemoteViews;
-
-import androidx.annotation.StringRes;
-import androidx.core.app.NotificationCompat;
-import androidx.preference.PreferenceManager;
+import java.util.ArrayList;
+import java.util.concurrent.Callable;
 
 /** @author Emmanuel Messulam <emmanuelbendavid@gmail.com> on 28/11/2017, at 20:59. */
 public class DecryptService extends AbstractProgressiveService {
@@ -61,21 +68,22 @@ public class DecryptService extends AbstractProgressiveService {
 
   public static final String TAG_BROADCAST_CRYPT_CANCEL = "crypt_cancel";
 
-  private Context context;
-  private IBinder mBinder = new ObtainableServiceBinder<>(this);
-  private ProgressHandler progressHandler = new ProgressHandler();
+  private static final String TAG = DecryptService.class.getSimpleName();
+
   private NotificationManager notificationManager;
   private NotificationCompat.Builder notificationBuilder;
+  private Context context;
+  private final IBinder mBinder = new ObtainableServiceBinder<>(this);
+  private final ProgressHandler progressHandler = new ProgressHandler();
   private ProgressListener progressListener;
   // list of data packages, to initiate chart in process viewer fragment
-  private ArrayList<DatapointParcelable> dataPackages = new ArrayList<>();
+  private final ArrayList<DatapointParcelable> dataPackages = new ArrayList<>();
   private ServiceWatcherUtil serviceWatcherUtil;
-  private long totalSize = 0l;
+  private long totalSize = 0L;
   private String decryptPath;
   private HybridFileParcelable baseFile;
-  private ArrayList<HybridFile> failedOps = new ArrayList<>();
-  private int accentColor;
-  private SharedPreferences sharedPreferences;
+  private final ArrayList<HybridFile> failedOps = new ArrayList<>();
+  private String password;
   private RemoteViews customSmallContentViews, customBigContentViews;
 
   @Override
@@ -90,10 +98,11 @@ public class DecryptService extends AbstractProgressiveService {
   public int onStartCommand(Intent intent, int flags, int startId) {
 
     baseFile = intent.getParcelableExtra(TAG_SOURCE);
+    password = intent.getStringExtra(TAG_PASSWORD);
+    decryptPath = intent.getStringExtra(TAG_DECRYPT_PATH);
 
-    sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
-    accentColor =
-        ((AppConfig) getApplication())
+    SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
+    int accentColor = ((AppConfig) getApplication())
             .getUtilsProvider()
             .getColorPreference()
             .getCurrentUserColorPreferences(this, sharedPreferences)
@@ -130,76 +139,23 @@ public class DecryptService extends AbstractProgressiveService {
         .setCustomHeadsUpContentView(customSmallContentViews)
         .setStyle(new NotificationCompat.DecoratedCustomViewStyle())
         .addAction(action)
+        .setColor(accentColor)
         .setOngoing(true)
-        .setColor(accentColor);
+        .setSmallIcon(R.drawable.ic_folder_lock_open_white_36dp);
 
-    decryptPath = intent.getStringExtra(TAG_DECRYPT_PATH);
-    notificationBuilder.setSmallIcon(R.drawable.ic_folder_lock_open_white_36dp);
     NotificationConstants.setMetadata(
-        context, notificationBuilder, NotificationConstants.TYPE_NORMAL);
+        getApplicationContext(), notificationBuilder, NotificationConstants.TYPE_NORMAL);
 
-    startForeground(NotificationConstants.DECRYPT_ID, notificationBuilder.build());
+    startForeground(getNotificationId(), notificationBuilder.build());
     initNotificationViews();
 
     super.onStartCommand(intent, flags, startId);
-
     super.progressHalted();
-    new DecryptService.BackgroundTask().execute();
+    TaskKt.fromTask(new BackgroundTask());
 
     return START_NOT_STICKY;
   }
 
-  class BackgroundTask extends AsyncTask<Void, Void, Void> {
-
-    @Override
-    protected Void doInBackground(Void... params) {
-      String baseFileFolder =
-          baseFile.isDirectory()
-              ? baseFile.getPath()
-              : baseFile.getPath().substring(0, baseFile.getPath().lastIndexOf('/'));
-
-      if (baseFile.isDirectory()) totalSize = baseFile.folderSize(context);
-      else totalSize = baseFile.length(context);
-
-      progressHandler.setSourceSize(1);
-      progressHandler.setTotalSize(totalSize);
-      progressHandler.setProgressListener((speed) -> publishResults(speed, false, false));
-      serviceWatcherUtil = new ServiceWatcherUtil(progressHandler);
-
-      addFirstDatapoint(
-          baseFile.getName(context), 1, totalSize, false); // we're using encrypt as move flag false
-
-      if (FileProperties.checkFolder(baseFileFolder, context) == 1) {
-        serviceWatcherUtil.watch(DecryptService.this);
-
-        // we're here to decrypt, we'll decrypt at a custom path.
-        // the path is to the same directory as in encrypted one in normal case
-        // and the cache directory in case we're here because of the viewer
-        try {
-          new CryptUtil(context, baseFile, decryptPath, progressHandler, failedOps);
-        } catch (Exception e) {
-          e.printStackTrace();
-          failedOps.add(baseFile);
-        }
-      }
-
-      return null;
-    }
-
-    @Override
-    protected void onPostExecute(Void aVoid) {
-      super.onPostExecute(aVoid);
-
-      serviceWatcherUtil.stopWatch();
-      finalizeNotification(failedOps, false);
-
-      Intent intent = new Intent(EncryptDecryptUtils.DECRYPT_BROADCAST);
-      intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, "");
-      sendBroadcast(intent);
-      stopSelf();
-    }
-  }
-
   @Override
   protected NotificationManager getNotificationManager() {
     return notificationManager;
@@ -255,6 +211,67 @@ public class DecryptService extends AbstractProgressiveService {
     dataPackages.clear();
   }
 
+  class BackgroundTask implements Task<Long, Callable<Long>> {
+
+    @Override
+    public void onError(@NonNull Throwable error) {
+      error.printStackTrace();
+    }
+
+    @Override
+    public void onFinish(Long value) {
+      serviceWatcherUtil.stopWatch();
+      finalizeNotification(failedOps, false);
+
+      Intent intent = new Intent(EncryptDecryptUtils.DECRYPT_BROADCAST);
+      intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, "");
+      sendBroadcast(intent);
+      stopSelf();
+    }
+
+    @NonNull
+    @Override
+    public Callable<Long> getTask() {
+      return () -> {
+        String baseFileFolder =
+                baseFile.isDirectory()
+                        ? baseFile.getPath()
+                        : baseFile.getPath().substring(0, baseFile.getPath().lastIndexOf('/'));
+
+        if (baseFile.isDirectory()) totalSize = baseFile.folderSize(context);
+        else totalSize = baseFile.length(context);
+
+        progressHandler.setSourceSize(1);
+        progressHandler.setTotalSize(totalSize);
+        progressHandler.setProgressListener((speed) -> publishResults(speed, false, false));
+        serviceWatcherUtil = new ServiceWatcherUtil(progressHandler);
+
+        addFirstDatapoint(
+                baseFile.getName(context),
+                1,
+                totalSize,
+                false); // we're using encrypt as move flag false
+
+        if (FileProperties.checkFolder(baseFileFolder, context) == 1) {
+          serviceWatcherUtil.watch(DecryptService.this);
+
+          // we're here to decrypt, we'll decrypt at a custom path.
+          // the path is to the same directory as in encrypted one in normal case
+          // and the cache directory in case we're here because of the viewer
+          try {
+            new CryptUtil(context, baseFile, decryptPath, progressHandler, failedOps, password);
+          } catch (AESCrypt.DecryptFailureException e) {
+
+          } catch (Exception e) {
+            Log.e(TAG, "Error decrypting " + baseFile.getPath(), e);
+            failedOps.add(baseFile);
+          }
+        }
+        return totalSize;
+      };
+    }
+  }
+
   @Override
   public boolean isDecryptService() {
     return true;
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
index 4af302053..588a817be 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/EncryptService.java
@@ -20,10 +20,26 @@
 
 package com.amaze.filemanager.asynchronous.services;
 
-import java.util.ArrayList;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences;
+import android.os.IBinder;
+import android.widget.RemoteViews;
+
+import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
+import androidx.annotation.StringRes;
+import androidx.core.app.NotificationCompat;
+import androidx.preference.PreferenceManager;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
+import com.amaze.filemanager.asynchronous.asynctasks.Task;
+import com.amaze.filemanager.asynchronous.asynctasks.TaskKt;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.FileProperties;
@@ -36,28 +52,20 @@ import com.amaze.filemanager.utils.DatapointParcelable;
 import com.amaze.filemanager.utils.ObtainableServiceBinder;
 import com.amaze.filemanager.utils.ProgressHandler;
 
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.os.AsyncTask;
-import android.os.IBinder;
-import android.widget.RemoteViews;
-
-import androidx.annotation.StringRes;
-import androidx.core.app.NotificationCompat;
-import androidx.preference.PreferenceManager;
+import java.util.ArrayList;
+import java.util.concurrent.Callable;
 
 /** Created by vishal on 8/4/17 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com> */
 public class EncryptService extends AbstractProgressiveService {
 
+  public static final String TAG = EncryptService.class.getSimpleName();
+
   public static final String TAG_SOURCE = "crypt_source"; // source file to encrypt or decrypt
   public static final String TAG_ENCRYPT_TARGET = "crypt_target"; // name of encrypted file
   public static final String TAG_DECRYPT_PATH = "decrypt_path";
   public static final String TAG_OPEN_MODE = "open_mode";
+  public static final String TAG_AESCRYPT = "use_aescrypt";
+  public static final String TAG_PASSWORD = "password";
 
   public static final String TAG_BROADCAST_CRYPT_CANCEL = "crypt_cancel";
 
@@ -70,11 +78,13 @@ public class EncryptService extends AbstractProgressiveService {
   // list of data packages, to initiate chart in process viewer fragment
   private ArrayList<DatapointParcelable> dataPackages = new ArrayList<>();
   private ServiceWatcherUtil serviceWatcherUtil;
-  private long totalSize = 0l;
+  private long totalSize = 0L;
   private HybridFileParcelable baseFile;
   private ArrayList<HybridFile> failedOps = new ArrayList<>();
   private String targetFilename;
   private int accentColor;
+  private boolean useAesCrypt;
+  private String password;
   private SharedPreferences sharedPreferences;
   private RemoteViews customSmallContentViews, customBigContentViews;
 
@@ -91,6 +101,10 @@ public class EncryptService extends AbstractProgressiveService {
 
     baseFile = intent.getParcelableExtra(TAG_SOURCE);
     targetFilename = intent.getStringExtra(TAG_ENCRYPT_TARGET);
+    useAesCrypt = intent.getBooleanExtra(TAG_AESCRYPT, false);
+    if(useAesCrypt) {
+      password = intent.getStringExtra(TAG_PASSWORD);
+    }
     sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
     accentColor =
         ((AppConfig) getApplication())
@@ -117,7 +131,9 @@ public class EncryptService extends AbstractProgressiveService {
         PendingIntent.getBroadcast(context, 1234, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT);
     NotificationCompat.Action action =
         new NotificationCompat.Action(
-            R.drawable.ic_folder_lock_white_36dp, getString(R.string.stop_ftp), stopPendingIntent);
+            getSmallIcon(),
+            getString(R.string.stop_ftp),
+            stopPendingIntent);
 
     notificationBuilder =
         new NotificationCompat.Builder(this, NotificationConstants.CHANNEL_NORMAL_ID);
@@ -130,21 +146,25 @@ public class EncryptService extends AbstractProgressiveService {
         .addAction(action)
         .setColor(accentColor)
         .setOngoing(true)
-        .setSmallIcon(R.drawable.ic_folder_lock_white_36dp);
+        .setSmallIcon(getSmallIcon());
 
     NotificationConstants.setMetadata(
         getApplicationContext(), notificationBuilder, NotificationConstants.TYPE_NORMAL);
 
-    startForeground(NotificationConstants.ENCRYPT_ID, notificationBuilder.build());
+    startForeground(getNotificationId(), notificationBuilder.build());
     initNotificationViews();
 
     super.onStartCommand(intent, flags, startId);
     super.progressHalted();
-    new BackgroundTask().execute();
+    TaskKt.fromTask(new BackgroundTask());
 
     return START_NOT_STICKY;
   }
 
+  protected @DrawableRes int getSmallIcon() {
+    return R.drawable.ic_folder_lock_white_36dp;
+  }
+
   @Override
   protected NotificationManager getNotificationManager() {
     return notificationManager;
@@ -200,50 +220,61 @@ public class EncryptService extends AbstractProgressiveService {
     dataPackages.clear();
   }
 
-  class BackgroundTask extends AsyncTask<Void, Void, Void> {
+  class BackgroundTask implements Task<Long, Callable<Long>> {
 
     @Override
-    protected Void doInBackground(Void... params) {
-
-      if (baseFile.isDirectory()) totalSize = baseFile.folderSize(context);
-      else totalSize = baseFile.length(context);
-
-      progressHandler.setSourceSize(1);
-      progressHandler.setTotalSize(totalSize);
-      progressHandler.setProgressListener((speed) -> publishResults(speed, false, false));
-      serviceWatcherUtil = new ServiceWatcherUtil(progressHandler);
-
-      addFirstDatapoint(
-          baseFile.getName(context), 1, totalSize, true); // we're using encrypt as move flag false
-
-      if (FileProperties.checkFolder(baseFile.getPath(), context) == 1) {
-        serviceWatcherUtil.watch(EncryptService.this);
-
-        // we're here to encrypt
-        try {
-          new CryptUtil(context, baseFile, progressHandler, failedOps, targetFilename);
-        } catch (Exception e) {
-          e.printStackTrace();
-          failedOps.add(baseFile);
-        }
-      }
-
-      return null;
-    }
+    public void onError(@NonNull Throwable error) {}
 
     @Override
-    protected void onPostExecute(Void aVoid) {
-      super.onPostExecute(aVoid);
-
+    public void onFinish(Long value) {
       serviceWatcherUtil.stopWatch();
       finalizeNotification(failedOps, false);
 
       Intent intent = new Intent(MainActivity.KEY_INTENT_LOAD_LIST);
       intent.putExtra(MainActivity.KEY_INTENT_LOAD_LIST_FILE, "");
       sendBroadcast(intent);
-
       stopSelf();
     }
+
+    @NonNull
+    @Override
+    public Callable<Long> getTask() {
+      return () -> {
+        if (baseFile.isDirectory()) totalSize = baseFile.folderSize(context);
+        else totalSize = baseFile.length(context);
+
+        progressHandler.setSourceSize(1);
+        progressHandler.setTotalSize(totalSize);
+        progressHandler.setProgressListener((speed) -> publishResults(speed, false, false));
+        serviceWatcherUtil = new ServiceWatcherUtil(progressHandler);
+
+        addFirstDatapoint(
+            baseFile.getName(context),
+            1,
+            totalSize,
+            true); // we're using encrypt as move flag false
+
+        if (FileProperties.checkFolder(baseFile.getPath(), context) == 1) {
+          serviceWatcherUtil.watch(EncryptService.this);
+
+          // we're here to encrypt
+          try {
+            new CryptUtil(
+                context,
+                baseFile,
+                progressHandler,
+                failedOps,
+                targetFilename,
+                useAesCrypt,
+                password);
+          } catch (Exception e) {
+            e.printStackTrace();
+            failedOps.add(baseFile);
+          }
+        }
+        return totalSize;
+      };
+    }
   }
 
   @Override
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt
index c72939711..139a97a61 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/ftp/FtpService.kt
@@ -44,13 +44,13 @@ import androidx.preference.PreferenceManager
 import com.amaze.filemanager.BuildConfig
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.filesystem.files.CryptUtil
 import com.amaze.filemanager.filesystem.ftpserver.AndroidFileSystemFactory
 import com.amaze.filemanager.filesystem.ftpserver.RootFileSystemFactory
 import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_ROOTMODE
 import com.amaze.filemanager.ui.notifications.FtpNotification
 import com.amaze.filemanager.ui.notifications.NotificationConstants
 import com.amaze.filemanager.utils.ObtainableServiceBinder
+import com.amaze.filemanager.utils.PasswordUtil
 import org.apache.ftpserver.ConnectionConfigFactory
 import org.apache.ftpserver.FtpServer
 import org.apache.ftpserver.FtpServerFactory
@@ -144,8 +144,8 @@ class FtpService : Service(), Runnable {
             if (usernamePreference != DEFAULT_USERNAME) {
                 username = usernamePreference
                 runCatching {
-                    password = CryptUtil.decryptPassword(
-                        applicationContext, preferences.getString(KEY_PREFERENCE_PASSWORD, "")
+                    password = PasswordUtil.decryptPassword(
+                        applicationContext, preferences.getString(KEY_PREFERENCE_PASSWORD, "")!!
                     )
                     isPasswordProtected = true
                 }.onFailure {
diff --git a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
deleted file mode 100644
index 4686dad88..000000000
--- a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.database;
-
-import java.util.List;
-
-import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
-
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import io.reactivex.schedulers.Schedulers;
-
-/** Created by vishal on 15/4/17. */
-public class CryptHandler {
-
-  private final ExplorerDatabase database;
-
-  private CryptHandler(@NonNull ExplorerDatabase explorerDatabase) {
-    database = explorerDatabase;
-  }
-
-  private static class CryptHandlerHolder {
-    private static final CryptHandler INSTANCE =
-        new CryptHandler(AppConfig.getInstance().getExplorerDatabase());
-  }
-
-  public static CryptHandler getInstance() {
-    return CryptHandlerHolder.INSTANCE;
-  }
-
-  public void addEntry(EncryptedEntry encryptedEntry) {
-    database.encryptedEntryDao().insert(encryptedEntry).subscribeOn(Schedulers.io()).subscribe();
-  }
-
-  public void clear(String path) {
-    database.encryptedEntryDao().delete(path).subscribeOn(Schedulers.io()).subscribe();
-  }
-
-  public void updateEntry(EncryptedEntry oldEncryptedEntry, EncryptedEntry newEncryptedEntry) {
-    database.encryptedEntryDao().update(newEncryptedEntry).subscribeOn(Schedulers.io()).subscribe();
-  }
-
-  @Nullable
-  public EncryptedEntry findEntry(String path) {
-    try {
-      return database.encryptedEntryDao().select(path).subscribeOn(Schedulers.io()).blockingGet();
-    } catch (Exception e) {
-      // catch error to handle Single#onError for blockingGet
-      Log.e(getClass().getSimpleName(), e.getMessage());
-      return null;
-    }
-  }
-
-  public EncryptedEntry[] getAllEntries() {
-    List<EncryptedEntry> encryptedEntryList =
-        database.encryptedEntryDao().list().subscribeOn(Schedulers.io()).blockingGet();
-    EncryptedEntry[] encryptedEntries = new EncryptedEntry[encryptedEntryList.size()];
-    return encryptedEntryList.toArray(encryptedEntries);
-  }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.kt b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.kt
new file mode 100644
index 000000000..b715427f9
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.kt
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database
+
+import android.util.Log
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.database.models.explorer.EncryptedEntry
+import io.reactivex.schedulers.Schedulers
+
+/** Created by vishal on 15/4/17.  */
+object CryptHandler {
+
+    private val database: ExplorerDatabase = AppConfig.getInstance().explorerDatabase
+
+    /**
+     * Add [EncryptedEntry] to database.
+     */
+    fun addEntry(encryptedEntry: EncryptedEntry) {
+        database.encryptedEntryDao().insert(encryptedEntry).subscribeOn(Schedulers.io()).subscribe()
+    }
+
+    /**
+     * Remove [EncryptedEntry] of specified path.
+     */
+    fun clear(path: String) {
+        database.encryptedEntryDao().delete(path).subscribeOn(Schedulers.io()).subscribe()
+    }
+
+    /**
+     * Update specified new [EncryptedEntry] in database.
+     */
+    fun updateEntry(oldEncryptedEntry: EncryptedEntry, newEncryptedEntry: EncryptedEntry) {
+        database.encryptedEntryDao().update(newEncryptedEntry).subscribeOn(Schedulers.io())
+            .subscribe()
+    }
+
+    /**
+     * Find [EncryptedEntry] of specified path. Returns null if not exist.
+     */
+    fun findEntry(path: String): EncryptedEntry? {
+        return runCatching {
+            database.encryptedEntryDao().select(path).subscribeOn(Schedulers.io()).blockingGet()
+        }.onFailure {
+            Log.e(javaClass.simpleName, it.message!!)
+        }.getOrNull()
+    }
+
+    val allEntries: Array<EncryptedEntry>
+        get() {
+            val encryptedEntryList =
+                database.encryptedEntryDao().list().subscribeOn(Schedulers.io()).blockingGet()
+            return encryptedEntryList.toTypedArray()
+        }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java b/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java
index 955e5ed9d..679c2c8b8 100644
--- a/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java
+++ b/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java
@@ -22,18 +22,18 @@ package com.amaze.filemanager.database.typeconverters;
 
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.database.models.StringWrapper;
-import com.amaze.filemanager.filesystem.files.CryptUtil;
+import com.amaze.filemanager.utils.PasswordUtil;
 
 import android.content.Context;
 
 import androidx.room.TypeConverter;
 
 /**
- * {@link TypeConverter} for password strings encrypted by {@link CryptUtil}.
+ * {@link TypeConverter} for password strings encrypted by {@link PasswordUtil}.
  *
  * @see StringWrapper
- * @see CryptUtil#encryptPassword(Context, String)
- * @see CryptUtil#decryptPassword(Context, String)
+ * @see PasswordUtil#encryptPassword(Context, String)
+ * @see PasswordUtil#decryptPassword(Context, String)
  */
 public class EncryptedStringTypeConverter {
 
@@ -43,7 +43,7 @@ public class EncryptedStringTypeConverter {
   public static StringWrapper toPassword(String encryptedStringEntryInDb) {
     try {
       return new StringWrapper(
-          CryptUtil.decryptPassword(AppConfig.getInstance(), encryptedStringEntryInDb));
+          PasswordUtil.INSTANCE.decryptPassword(AppConfig.getInstance(), encryptedStringEntryInDb));
     } catch (Exception e) {
       android.util.Log.e(TAG, "Error decrypting password", e);
       return new StringWrapper(encryptedStringEntryInDb);
@@ -53,7 +53,8 @@ public class EncryptedStringTypeConverter {
   @TypeConverter
   public static String fromPassword(StringWrapper unencryptedPasswordString) {
     try {
-      return CryptUtil.encryptPassword(AppConfig.getInstance(), unencryptedPasswordString.value);
+      return PasswordUtil.INSTANCE.encryptPassword(
+          AppConfig.getInstance(), unencryptedPasswordString.value);
     } catch (Exception e) {
       android.util.Log.e(TAG, "Error encrypting password", e);
       return unencryptedPasswordString.value;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java
index 7a6a3299d..4e90bb1f8 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/CryptUtil.java
@@ -20,48 +20,38 @@
 
 package com.amaze.filemanager.filesystem.files;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.math.BigInteger;
-import java.security.GeneralSecurityException;
-import java.security.Key;
-import java.security.KeyPairGenerator;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.util.ArrayList;
-import java.util.Calendar;
+import static android.os.Build.VERSION.SDK_INT;
+import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;
+import static android.os.Build.VERSION_CODES.KITKAT;
 
-import javax.crypto.Cipher;
-import javax.crypto.CipherInputStream;
-import javax.crypto.CipherOutputStream;
-import javax.crypto.KeyGenerator;
-import javax.crypto.spec.GCMParameterSpec;
-import javax.crypto.spec.IvParameterSpec;
-import javax.crypto.spec.SecretKeySpec;
-import javax.security.auth.x500.X500Principal;
+import android.content.Context;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import com.amaze.filemanager.BuildConfig;
+import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.MakeDirectoryOperation;
 import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
+import com.amaze.filemanager.utils.AESCrypt;
 import com.amaze.filemanager.utils.ProgressHandler;
+import com.amaze.filemanager.utils.security.SecretKeygen;
 
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.os.Build;
-import android.security.KeyPairGeneratorSpec;
-import android.security.keystore.KeyGenParameterSpec;
-import android.security.keystore.KeyProperties;
-import android.util.Base64;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.security.spec.AlgorithmParameterSpec;
+import java.util.ArrayList;
 
-import androidx.annotation.RequiresApi;
-import androidx.preference.PreferenceManager;
+import javax.crypto.Cipher;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.spec.GCMParameterSpec;
+import javax.crypto.spec.IvParameterSpec;
 
 /**
  * Created by vishal on 6/4/17.
@@ -90,20 +80,20 @@ import androidx.preference.PreferenceManager;
  */
 public class CryptUtil {
 
-  private static final String ALGO_AES = "AES/GCM/NoPadding";
-  private static final String ALGO_RSA = "RSA/ECB/PKCS1Padding";
-  private static final String KEY_STORE_ANDROID = "AndroidKeyStore";
-  private static final String KEY_ALIAS_AMAZE = "AmazeKey";
-  private static final String PREFERENCE_KEY = "aes_key";
+  public static final String KEY_STORE_ANDROID = "AndroidKeyStore";
+  public static final String KEY_ALIAS_AMAZE = "AmazeKey";
+  public static final String ALGO_AES = "AES/GCM/NoPadding";
   // TODO: Generate a random IV every time, and keep track of it (in database against encrypted
   // files)
   private static final String IV =
       BuildConfig.CRYPTO_IV; // 12 byte long IV supported by android for GCM
+  private static final int GCM_TAG_LENGTH = 128;
 
   public static final String CRYPT_EXTENSION = ".aze";
+  public static final String AESCRYPT_EXTENSION = ".aes";
 
-  private ProgressHandler progressHandler;
-  private ArrayList<HybridFile> failedOps;
+  private final ProgressHandler progressHandler;
+  private final ArrayList<HybridFile> failedOps;
 
   /**
    * Constructor will start encryption process serially. Make sure to call with background thread.
@@ -119,11 +109,13 @@ public class CryptUtil {
    * @param sourceFile the file to encrypt
    */
   public CryptUtil(
-      Context context,
-      HybridFileParcelable sourceFile,
-      ProgressHandler progressHandler,
-      ArrayList<HybridFile> failedOps,
-      String targetFilename)
+      @NonNull Context context,
+      @NonNull HybridFileParcelable sourceFile,
+      @NonNull ProgressHandler progressHandler,
+      @NonNull ArrayList<HybridFile> failedOps,
+      @NonNull String targetFilename,
+      boolean useAesCrypt,
+      @Nullable String password)
       throws GeneralSecurityException, IOException {
 
     this.progressHandler = progressHandler;
@@ -131,7 +123,7 @@ public class CryptUtil {
 
     // target encrypted file
     HybridFile hFile = new HybridFile(sourceFile.getMode(), sourceFile.getParent(context));
-    encrypt(context, sourceFile, hFile, targetFilename);
+    encrypt(context, sourceFile, hFile, targetFilename, useAesCrypt, password);
   }
 
   /**
@@ -147,15 +139,17 @@ public class CryptUtil {
    *     case
    */
   public CryptUtil(
-      Context context,
-      HybridFileParcelable baseFile,
-      String targetPath,
-      ProgressHandler progressHandler,
-      ArrayList<HybridFile> failedOps)
+      @NonNull Context context,
+      @NonNull HybridFileParcelable baseFile,
+      @NonNull String targetPath,
+      @NonNull ProgressHandler progressHandler,
+      @NonNull ArrayList<HybridFile> failedOps,
+      @Nullable String password)
       throws GeneralSecurityException, IOException {
 
     this.progressHandler = progressHandler;
     this.failedOps = failedOps;
+    boolean useAesCrypt = baseFile.getName().endsWith(AESCRYPT_EXTENSION);
 
     HybridFile targetDirectory = new HybridFile(OpenMode.FILE, targetPath);
     if (!targetPath.equals(context.getExternalCacheDir())) {
@@ -163,8 +157,7 @@ public class CryptUtil {
       // same file system as of base file
       targetDirectory.setMode(baseFile.getMode());
     }
-
-    decrypt(context, baseFile, targetDirectory);
+    decrypt(context, baseFile, targetDirectory, useAesCrypt, password);
   }
 
   /**
@@ -174,8 +167,13 @@ public class CryptUtil {
    * @param targetDirectory the target directory inside which we're going to decrypt
    */
   private void decrypt(
-      final Context context, HybridFileParcelable sourceFile, HybridFile targetDirectory)
+      @NonNull final Context context,
+      @NonNull HybridFileParcelable sourceFile,
+      @NonNull HybridFile targetDirectory,
+      boolean useAescrypt,
+      @Nullable String password)
       throws GeneralSecurityException, IOException {
+
     if (progressHandler.getCancelled()) return;
     if (sourceFile.isDirectory()) {
 
@@ -183,7 +181,10 @@ public class CryptUtil {
           new HybridFile(
               targetDirectory.getMode(),
               targetDirectory.getPath(),
-              sourceFile.getName(context).replace(CRYPT_EXTENSION, ""),
+              sourceFile
+                  .getName(context)
+                  .replace(CRYPT_EXTENSION, "")
+                  .replace(AESCRYPT_EXTENSION, ""),
               sourceFile.isDirectory());
       MakeDirectoryOperation.mkdirs(context, hFile);
 
@@ -192,14 +193,20 @@ public class CryptUtil {
           sourceFile.isRoot(),
           file -> {
             try {
-              decrypt(context, file, hFile);
+              decrypt(
+                context,
+                file,
+                hFile,
+                useAescrypt,
+                password);
             } catch (IOException | GeneralSecurityException e) {
               throw new IllegalStateException(e); // throw unchecked exception, no throws needed
             }
           });
     } else {
 
-      if (!sourceFile.getPath().endsWith(CRYPT_EXTENSION)) {
+      if (!sourceFile.getPath().endsWith(CRYPT_EXTENSION)
+          && !sourceFile.getPath().endsWith(AESCRYPT_EXTENSION)) {
         failedOps.add(sourceFile);
         return;
       }
@@ -212,7 +219,10 @@ public class CryptUtil {
           new HybridFile(
               targetDirectory.getMode(),
               targetDirectory.getPath(),
-              sourceFile.getName(context).replace(CRYPT_EXTENSION, ""),
+              sourceFile
+                  .getName(context)
+                  .replace(CRYPT_EXTENSION, "")
+                  .replace(AESCRYPT_EXTENSION, ""),
               sourceFile.isDirectory());
 
       progressHandler.setFileName(sourceFile.getName(context));
@@ -221,10 +231,10 @@ public class CryptUtil {
           new BufferedOutputStream(
               targetFile.getOutputStream(context), GenericCopyUtil.DEFAULT_BUFFER_SIZE);
 
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-        aesDecrypt(inputStream, outputStream);
-      } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-        rsaDecrypt(context, inputStream, outputStream);
+      if (useAescrypt) {
+        new AESCrypt(password).decrypt(sourceFile.getSize(), inputStream, outputStream);
+      } else {
+        doEncrypt(inputStream, outputStream, Cipher.DECRYPT_MODE);
       }
     }
   }
@@ -236,10 +246,12 @@ public class CryptUtil {
    * @param targetDirectory the target directory in which we're going to encrypt
    */
   private void encrypt(
-      final Context context,
-      HybridFileParcelable sourceFile,
-      HybridFile targetDirectory,
-      String targetFilename)
+      @NonNull final Context context,
+      @NonNull HybridFileParcelable sourceFile,
+      @NonNull HybridFile targetDirectory,
+      @NonNull String targetFilename,
+      boolean useAesCrypt,
+      @Nullable String password)
       throws GeneralSecurityException, IOException {
 
     if (progressHandler.getCancelled()) return;
@@ -259,14 +271,21 @@ public class CryptUtil {
           sourceFile.isRoot(),
           file -> {
             try {
-              encrypt(context, file, hFile, file.getName(context).concat(CRYPT_EXTENSION));
+              encrypt(
+                  context,
+                  file,
+                  hFile,
+                  file.getName(context).concat(useAesCrypt ? AESCRYPT_EXTENSION : CRYPT_EXTENSION),
+                  useAesCrypt,
+                  password);
             } catch (IOException | GeneralSecurityException e) {
               throw new IllegalStateException(e); // throw unchecked exception, no throws needed
             }
           });
     } else {
 
-      if (sourceFile.getName(context).endsWith(CRYPT_EXTENSION)) {
+      if (sourceFile.getName(context).endsWith(CRYPT_EXTENSION) ||
+        sourceFile.getName(context).endsWith(AESCRYPT_EXTENSION)) {
         failedOps.add(sourceFile);
         return;
       }
@@ -289,394 +308,73 @@ public class CryptUtil {
           new BufferedOutputStream(
               targetFile.getOutputStream(context), GenericCopyUtil.DEFAULT_BUFFER_SIZE);
 
-      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-        aesEncrypt(inputStream, outputStream);
-      } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-        rsaEncrypt(context, inputStream, outputStream);
+      if (useAesCrypt) {
+        new AESCrypt(password)
+            .encrypt(
+                AESCrypt.AESCRYPT_SPEC_VERSION,
+                sourceFile.getInputStream(AppConfig.getInstance()),
+                targetFile.getOutputStream(AppConfig.getInstance()),
+                progressHandler);
+      } else {
+        doEncrypt(inputStream, outputStream, Cipher.ENCRYPT_MODE);
       }
     }
   }
 
-  /** Helper method to encrypt plain text password */
-  @RequiresApi(api = Build.VERSION_CODES.M)
-  private static String aesEncryptPassword(String plainTextPassword)
-      throws GeneralSecurityException, IOException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-    cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), gcmParameterSpec);
-    byte[] encodedBytes = cipher.doFinal(plainTextPassword.getBytes());
-
-    return Base64.encodeToString(encodedBytes, Base64.DEFAULT);
-  }
-
-  /** Helper method to decrypt cipher text password */
-  @RequiresApi(api = Build.VERSION_CODES.M)
-  private static String aesDecryptPassword(String cipherPassword)
-      throws GeneralSecurityException, IOException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-    cipher.init(Cipher.DECRYPT_MODE, getSecretKey(), gcmParameterSpec);
-    byte[] decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, Base64.DEFAULT));
-
-    return new String(decryptedBytes);
-  }
-
   /**
-   * Helper method to encrypt a file
+   * Core encryption/decryption routine.
    *
    * @param inputStream stream associated with the file to be encrypted
    * @param outputStream stream associated with new output encrypted file
+   * @param operationMode either <code>Cipher.ENCRYPT_MODE</code> or <code>Cipher.DECRYPT_MODE</code>
    */
-  @RequiresApi(api = Build.VERSION_CODES.M)
-  private void aesEncrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream)
-      throws GeneralSecurityException, IOException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-
-    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-
-    cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), gcmParameterSpec);
-
-    byte[] buffer = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
-    int count;
-
-    CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, cipher);
-
-    try {
-
-      while ((count = inputStream.read(buffer)) != -1) {
-        if (!progressHandler.getCancelled()) {
-          cipherOutputStream.write(buffer, 0, count);
-          ServiceWatcherUtil.position += count;
-        } else break;
-      }
-    } finally {
-
-      cipherOutputStream.flush();
-      cipherOutputStream.close();
-      inputStream.close();
-    }
-  }
-
-  /**
-   * Helper method to decrypt file
-   *
-   * @param inputStream stream associated with encrypted file
-   * @param outputStream stream associated with new output decrypted file
-   */
-  @RequiresApi(api = Build.VERSION_CODES.M)
-  private void aesDecrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream)
+  private void doEncrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream, int operationMode)
       throws GeneralSecurityException, IOException {
 
     Cipher cipher = Cipher.getInstance(ALGO_AES);
-    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-
-    cipher.init(Cipher.DECRYPT_MODE, getSecretKey(), gcmParameterSpec);
-    CipherInputStream cipherInputStream = new CipherInputStream(inputStream, cipher);
-
-    byte[] buffer = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
-    int count;
-
-    try {
-
-      while ((count = cipherInputStream.read(buffer)) != -1) {
-        if (!progressHandler.getCancelled()) {
-          outputStream.write(buffer, 0, count);
-          ServiceWatcherUtil.position += count;
-        } else break;
-      }
-    } finally {
-
-      outputStream.flush();
-      cipherInputStream.close();
-      outputStream.close();
-    }
-  }
-
-  /**
-   * Gets a secret key from Android key store. If no key has been generated with a given alias then
-   * generate a new one
-   */
-  @RequiresApi(api = Build.VERSION_CODES.M)
-  private static Key getSecretKey() throws GeneralSecurityException, IOException {
-
-    KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
-    keyStore.load(null);
-
-    if (!keyStore.containsAlias(KEY_ALIAS_AMAZE)) {
-      KeyGenerator keyGenerator =
-          KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, KEY_STORE_ANDROID);
-
-      KeyGenParameterSpec.Builder builder =
-          new KeyGenParameterSpec.Builder(
-              KEY_ALIAS_AMAZE, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT);
-      builder.setBlockModes(KeyProperties.BLOCK_MODE_GCM);
-      builder.setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE);
-      builder.setRandomizedEncryptionRequired(false);
-
-      keyGenerator.init(builder.build());
-      return keyGenerator.generateKey();
+    AlgorithmParameterSpec parameterSpec;
+    if(SDK_INT >= KITKAT) {
+      parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, IV.getBytes());
     } else {
-      return keyStore.getKey(KEY_ALIAS_AMAZE, null);
+      parameterSpec = new IvParameterSpec(IV.getBytes());
     }
-  }
-
-  @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-  private void rsaEncrypt(
-      Context context, BufferedInputStream inputStream, BufferedOutputStream outputStream)
-      throws GeneralSecurityException, IOException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    RSAKeygen keygen = new RSAKeygen(context);
-
-    IvParameterSpec ivParameterSpec = new IvParameterSpec(IV.getBytes());
-    cipher.init(Cipher.ENCRYPT_MODE, keygen.getSecretKey(), ivParameterSpec);
+    cipher.init(operationMode, SecretKeygen.INSTANCE.getSecretKey(), parameterSpec);
 
     byte[] buffer = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
     int count;
 
     CipherOutputStream cipherOutputStream = new CipherOutputStream(outputStream, cipher);
-    try {
 
+    try {
       while ((count = inputStream.read(buffer)) != -1) {
         if (!progressHandler.getCancelled()) {
           cipherOutputStream.write(buffer, 0, count);
           ServiceWatcherUtil.position += count;
         } else break;
       }
+    } catch (Exception x) {
+      x.printStackTrace();
     } finally {
-
       cipherOutputStream.flush();
       cipherOutputStream.close();
       inputStream.close();
     }
   }
 
-  @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-  private void rsaDecrypt(
-      Context context, BufferedInputStream inputStream, BufferedOutputStream outputStream)
-      throws GeneralSecurityException, IOException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    RSAKeygen keygen = new RSAKeygen(context);
-
-    IvParameterSpec ivParameterSpec = new IvParameterSpec(IV.getBytes());
-    cipher.init(Cipher.DECRYPT_MODE, keygen.getSecretKey(), ivParameterSpec);
-    CipherInputStream cipherInputStream = new CipherInputStream(inputStream, cipher);
-
-    byte[] buffer = new byte[GenericCopyUtil.DEFAULT_BUFFER_SIZE];
-    int count;
-
-    try {
-
-      while ((count = cipherInputStream.read(buffer)) != -1) {
-        if (!progressHandler.getCancelled()) {
-          outputStream.write(buffer, 0, count);
-          ServiceWatcherUtil.position += count;
-        } else break;
-      }
-    } finally {
-
-      outputStream.flush();
-      outputStream.close();
-      cipherInputStream.close();
-    }
-  }
-
-  @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-  private static String rsaEncryptPassword(Context context, String password)
-      throws GeneralSecurityException, IOException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    RSAKeygen keygen = new RSAKeygen(context);
-
-    IvParameterSpec ivParameterSpec = new IvParameterSpec(IV.getBytes());
-    cipher.init(Cipher.ENCRYPT_MODE, keygen.getSecretKey(), ivParameterSpec);
-
-    return Base64.encodeToString(cipher.doFinal(password.getBytes()), Base64.DEFAULT);
-  }
-
-  @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-  private static String rsaDecryptPassword(Context context, String cipherText)
-      throws GeneralSecurityException, IOException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    RSAKeygen keygen = new RSAKeygen(context);
-    IvParameterSpec ivParameterSpec = new IvParameterSpec(IV.getBytes());
-    cipher.init(Cipher.DECRYPT_MODE, keygen.getSecretKey(), ivParameterSpec);
-    byte[] decryptedBytes = cipher.doFinal(Base64.decode(cipherText, Base64.DEFAULT));
-
-    return new String(decryptedBytes);
-  }
-
-  /** Method handles encryption of plain text on various APIs */
-  public static String encryptPassword(Context context, String plainText)
-      throws GeneralSecurityException, IOException {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-      return aesEncryptPassword(plainText);
-    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-
-      return rsaEncryptPassword(context, plainText);
-    } else return plainText;
-  }
-
-  /** Method handles decryption of cipher text on various APIs */
-  public static String decryptPassword(Context context, String cipherText)
-      throws GeneralSecurityException, IOException {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-      return aesDecryptPassword(cipherText);
-    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-      return rsaDecryptPassword(context, cipherText);
-    } else return cipherText;
-  }
-
   /**
    * Method initializes a Cipher to be used by {@link
    * android.hardware.fingerprint.FingerprintManager}
    */
-  public static Cipher initCipher(Context context) throws GeneralSecurityException, IOException {
+  public static Cipher initCipher() throws GeneralSecurityException {
     Cipher cipher = null;
-
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+    if (SDK_INT >= KITKAT) {
       cipher = Cipher.getInstance(ALGO_AES);
-      GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-      cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), gcmParameterSpec);
-    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+      GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, IV.getBytes());
+      cipher.init(Cipher.ENCRYPT_MODE, SecretKeygen.INSTANCE.getSecretKey(), gcmParameterSpec);
+    } else if (SDK_INT >= JELLY_BEAN_MR2) {
       cipher = Cipher.getInstance(ALGO_AES);
-      RSAKeygen keygen = new RSAKeygen(context);
-
-      cipher.init(Cipher.ENCRYPT_MODE, keygen.getSecretKey());
+      cipher.init(Cipher.ENCRYPT_MODE, SecretKeygen.INSTANCE.getSecretKey());
     }
     return cipher;
   }
-
-  /** Class responsible for generating key for API lower than M */
-  static class RSAKeygen {
-
-    private Context context;
-
-    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-    RSAKeygen(Context context) {
-
-      this.context = context;
-
-      try {
-        generateKeyPair(context);
-        setKeyPreference();
-      } catch (GeneralSecurityException | IOException e) {
-        e.printStackTrace();
-      }
-    }
-
-    /** Generates a RSA public/private key pair to encrypt AES key */
-    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-    private void generateKeyPair(Context context) throws GeneralSecurityException, IOException {
-
-      KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
-      keyStore.load(null);
-
-      if (!keyStore.containsAlias(KEY_ALIAS_AMAZE)) {
-        // generate a RSA key pair to encrypt/decrypt AES key from preferences
-        Calendar start = Calendar.getInstance();
-        Calendar end = Calendar.getInstance();
-        end.add(Calendar.YEAR, 30);
-
-        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", KEY_STORE_ANDROID);
-
-        KeyPairGeneratorSpec spec =
-            new KeyPairGeneratorSpec.Builder(context)
-                .setAlias(KEY_ALIAS_AMAZE)
-                .setSubject(new X500Principal("CN=" + KEY_ALIAS_AMAZE))
-                .setSerialNumber(BigInteger.TEN)
-                .setStartDate(start.getTime())
-                .setEndDate(end.getTime())
-                .build();
-
-        keyPairGenerator.initialize(spec);
-        keyPairGenerator.generateKeyPair();
-      }
-    }
-
-    /** Encrypts AES key and set into preference */
-    private void setKeyPreference() throws GeneralSecurityException, IOException {
-
-      SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
-      String encodedAesKey = preferences.getString(PREFERENCE_KEY, null);
-
-      if (encodedAesKey == null) {
-        // generate encrypted aes key and save to preference
-
-        byte[] key = new byte[16];
-        SecureRandom secureRandom = new SecureRandom();
-        secureRandom.nextBytes(key);
-
-        byte[] encryptedKey = encryptAESKey(key);
-        encodedAesKey = Base64.encodeToString(encryptedKey, Base64.DEFAULT);
-        preferences.edit().putString(PREFERENCE_KEY, encodedAesKey).apply();
-      }
-    }
-
-    /** Encrypts randomly generated AES key using RSA public key */
-    private byte[] encryptAESKey(byte[] secretKey) throws GeneralSecurityException, IOException {
-
-      KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
-      keyStore.load(null);
-      KeyStore.PrivateKeyEntry keyEntry =
-          (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS_AMAZE, null);
-      Cipher cipher = Cipher.getInstance(ALGO_RSA, "AndroidOpenSSL");
-      cipher.init(Cipher.ENCRYPT_MODE, keyEntry.getCertificate().getPublicKey());
-
-      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-      CipherOutputStream outputStream = new CipherOutputStream(byteArrayOutputStream, cipher);
-      outputStream.write(secretKey);
-      outputStream.close();
-
-      return byteArrayOutputStream.toByteArray();
-    }
-
-    /** Decodes encrypted AES key from preference and decrypts using RSA private key */
-    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-    private Key getSecretKey() throws GeneralSecurityException, IOException {
-
-      SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
-      String encodedString = preferences.getString(PREFERENCE_KEY, null);
-      if (encodedString != null) {
-
-        return new SecretKeySpec(
-            decryptAESKey(Base64.decode(encodedString, Base64.DEFAULT)), "AES");
-      } else {
-        generateKeyPair(context);
-        setKeyPreference();
-        return getSecretKey();
-      }
-    }
-
-    /** Decrypts AES decoded key from preference using RSA private key */
-    private byte[] decryptAESKey(byte[] encodedBytes) throws GeneralSecurityException, IOException {
-
-      KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
-      keyStore.load(null);
-      KeyStore.PrivateKeyEntry keyEntry =
-          (KeyStore.PrivateKeyEntry) keyStore.getEntry(KEY_ALIAS_AMAZE, null);
-      Cipher cipher = Cipher.getInstance(ALGO_RSA, "AndroidOpenSSL");
-      cipher.init(Cipher.DECRYPT_MODE, keyEntry.getPrivateKey());
-
-      ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(encodedBytes);
-      CipherInputStream inputStream = new CipherInputStream(byteArrayInputStream, cipher);
-      ArrayList<Byte> bytes = new ArrayList<>();
-      int nextByte;
-      while ((nextByte = inputStream.read()) != -1) {
-        bytes.add((byte) nextByte);
-      }
-
-      byte[] decryptedBytes = new byte[bytes.size()];
-      for (int i = 0; i < bytes.size(); i++) {
-
-        decryptedBytes[i] = bytes.get(i).byteValue();
-      }
-      return decryptedBytes;
-    }
-  }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
index 3d490440b..f1eb67f93 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
@@ -20,8 +20,18 @@
 
 package com.amaze.filemanager.filesystem.files;
 
-import java.io.IOException;
-import java.security.GeneralSecurityException;
+import static com.amaze.filemanager.asynchronous.services.EncryptService.TAG_AESCRYPT;
+import static com.amaze.filemanager.filesystem.files.CryptUtil.AESCRYPT_EXTENSION;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.os.Build;
+import android.widget.EditText;
+import android.widget.Toast;
+
+import androidx.annotation.NonNull;
+import androidx.preference.PreferenceManager;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil;
@@ -32,18 +42,15 @@ import com.amaze.filemanager.database.models.explorer.EncryptedEntry;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.ui.activities.MainActivity;
+import com.amaze.filemanager.ui.dialogs.DecryptFingerprintDialog;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.fragments.MainFragment;
 import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
 import com.amaze.filemanager.ui.provider.UtilitiesProvider;
+import com.amaze.filemanager.utils.PasswordUtil;
 
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Build;
-import android.widget.Toast;
-
-import androidx.preference.PreferenceManager;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
 
 /**
  * Provides useful interfaces and methods for encryption/decryption
@@ -64,16 +71,15 @@ public class EncryptDecryptUtils {
   public static void startEncryption(
       Context c, final String path, final String password, Intent intent)
       throws GeneralSecurityException, IOException {
-    CryptHandler cryptHandler = CryptHandler.getInstance();
     String destPath =
         path.substring(0, path.lastIndexOf('/') + 1)
             .concat(intent.getStringExtra(EncryptService.TAG_ENCRYPT_TARGET));
 
     // EncryptService.TAG_ENCRYPT_TARGET already has the .aze extension, no need to append again
-
-    EncryptedEntry encryptedEntry = new EncryptedEntry(destPath, password);
-    cryptHandler.addEntry(encryptedEntry);
-
+    if (!intent.getBooleanExtra(TAG_AESCRYPT, false)) {
+      EncryptedEntry encryptedEntry = new EncryptedEntry(destPath, password);
+      CryptHandler.INSTANCE.addEntry(encryptedEntry);
+    }
     // start the encryption process
     ServiceWatcherUtil.runService(c, intent);
   }
@@ -95,102 +101,116 @@ public class EncryptDecryptUtils {
     SharedPreferences preferences1 =
         PreferenceManager.getDefaultSharedPreferences(main.getContext());
 
-    EncryptedEntry encryptedEntry;
+    if (sourceFile.getPath().endsWith(AESCRYPT_EXTENSION)) {
+      GeneralDialogCreation.showPasswordDialog(
+              c,
+              mainActivity,
+              utilsProvider.getAppTheme(),
+              R.string.crypt_decrypt,
+              R.string.authenticate_password,
+              (dialog, which) -> {
+                EditText editText = dialog.getView().findViewById(R.id.singleedittext_input);
+                decryptIntent.putExtra(EncryptService.TAG_PASSWORD, editText.getText().toString());
+                ServiceWatcherUtil.runService(main.getContext(), decryptIntent);
+                dialog.dismiss();
+              }, null);
+    } else {
+      EncryptedEntry encryptedEntry;
 
-    try {
-      encryptedEntry = findEncryptedEntry(sourceFile.getPath());
-    } catch (GeneralSecurityException | IOException e) {
-      e.printStackTrace();
+      try {
+        encryptedEntry = findEncryptedEntry(sourceFile.getPath());
+      } catch (GeneralSecurityException | IOException e) {
+        e.printStackTrace();
 
-      // we couldn't find any entry in database or lost the key to decipher
-      Toast.makeText(
-              main.getContext(),
-              main.getActivity().getString(R.string.crypt_decryption_fail),
-              Toast.LENGTH_LONG)
-          .show();
-      return;
-    }
+        // we couldn't find any entry in database or lost the key to decipher
+        Toast.makeText(
+                main.getContext(),
+                main.getActivity().getString(R.string.crypt_decryption_fail),
+                Toast.LENGTH_LONG)
+                .show();
+        return;
+      }
 
-    DecryptButtonCallbackInterface decryptButtonCallbackInterface =
-        new DecryptButtonCallbackInterface() {
-          @Override
-          public void confirm(Intent intent) {
-            ServiceWatcherUtil.runService(main.getContext(), intent);
-          }
+      DecryptButtonCallbackInterface decryptButtonCallbackInterface =
+              new DecryptButtonCallbackInterface() {
+                @Override
+                public void confirm(Intent intent) {
+                  ServiceWatcherUtil.runService(main.getContext(), intent);
+                }
 
-          @Override
-          public void failed() {
-            Toast.makeText(
-                    main.getContext(),
-                    main.getActivity().getString(R.string.crypt_decryption_fail_password),
-                    Toast.LENGTH_LONG)
-                .show();
-          }
-        };
+                @Override
+                public void failed() {
+                  Toast.makeText(
+                          main.getContext(),
+                          main.getActivity().getString(R.string.crypt_decryption_fail_password),
+                          Toast.LENGTH_LONG)
+                          .show();
+                }
+              };
 
-    if (encryptedEntry == null) {
-      // couldn't find the matching path in database, we lost the password
+      if (encryptedEntry == null && !sourceFile.getPath().endsWith(AESCRYPT_EXTENSION)) {
+        // couldn't find the matching path in database, we lost the password
 
-      Toast.makeText(
-              main.getContext(),
-              main.getActivity().getString(R.string.crypt_decryption_fail),
-              Toast.LENGTH_LONG)
-          .show();
-      return;
-    }
+        Toast.makeText(
+                main.getContext(),
+                main.getActivity().getString(R.string.crypt_decryption_fail),
+                Toast.LENGTH_LONG)
+                .show();
+        return;
+      }
 
-    switch (encryptedEntry.getPassword().value) {
-      case PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT:
-        try {
-          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            GeneralDialogCreation.showDecryptFingerprintDialog(
+      switch (encryptedEntry.getPassword().value) {
+        case PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT:
+          try {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+              DecryptFingerprintDialog.show(
                 c,
                 mainActivity,
                 decryptIntent,
                 utilsProvider.getAppTheme(),
                 decryptButtonCallbackInterface);
-          } else throw new IllegalStateException("API < M!");
-        } catch (GeneralSecurityException | IOException | IllegalStateException e) {
-          e.printStackTrace();
-
-          Toast.makeText(
-                  main.getContext(),
-                  main.getString(R.string.crypt_decryption_fail),
-                  Toast.LENGTH_LONG)
-              .show();
-        }
-        break;
-      case PreferencesConstants.ENCRYPT_PASSWORD_MASTER:
-        try {
+            } else throw new IllegalStateException("API < M!");
+          } catch (GeneralSecurityException | IOException | IllegalStateException e) {
+            e.printStackTrace();
+            Toast.makeText(
+                    main.getContext(),
+                    main.getString(R.string.crypt_decryption_fail),
+                    Toast.LENGTH_LONG)
+                    .show();
+          }
+          break;
+        case PreferencesConstants.ENCRYPT_PASSWORD_MASTER:
+          try {
+            GeneralDialogCreation.showDecryptDialog(
+                    c,
+                    mainActivity,
+                    decryptIntent,
+                    utilsProvider.getAppTheme(),
+                    PasswordUtil.INSTANCE.decryptPassword(
+                            c,
+                            preferences1.getString(
+                                    PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
+                                    PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)),
+                    decryptButtonCallbackInterface);
+          } catch (GeneralSecurityException | IOException e) {
+            e.printStackTrace();
+            Toast.makeText(
+                    main.getContext(),
+                    main.getString(R.string.crypt_decryption_fail),
+                    Toast.LENGTH_LONG)
+                    .show();
+          }
+          break;
+        default:
           GeneralDialogCreation.showDecryptDialog(
-              c,
-              mainActivity,
-              decryptIntent,
-              utilsProvider.getAppTheme(),
-              CryptUtil.decryptPassword(
                   c,
-                  preferences1.getString(
-                      PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
-                      PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)),
-              decryptButtonCallbackInterface);
-        } catch (GeneralSecurityException | IOException e) {
-          e.printStackTrace();
-          Toast.makeText(
-                  main.getContext(),
-                  main.getString(R.string.crypt_decryption_fail),
-                  Toast.LENGTH_LONG)
-              .show();
-        }
-        break;
-      default:
-        GeneralDialogCreation.showDecryptDialog(
-            c,
-            mainActivity,
-            decryptIntent,
-            utilsProvider.getAppTheme(),
-            encryptedEntry.getPassword().value,
-            decryptButtonCallbackInterface);
-        break;
+                  mainActivity,
+                  decryptIntent,
+                  utilsProvider.getAppTheme(),
+                  encryptedEntry.getPassword().value,
+                  decryptButtonCallbackInterface);
+          break;
+      }
     }
   }
 
@@ -203,7 +223,7 @@ public class EncryptDecryptUtils {
   private static EncryptedEntry findEncryptedEntry(String path)
       throws GeneralSecurityException, IOException {
 
-    CryptHandler handler = CryptHandler.getInstance();
+    CryptHandler handler = CryptHandler.INSTANCE;
 
     EncryptedEntry matchedEntry = null;
     // find closest path which matches with database entry
@@ -220,25 +240,21 @@ public class EncryptDecryptUtils {
   }
 
   public interface EncryptButtonCallbackInterface {
-
-    /** Callback fired when we've just gone through warning dialog before encryption */
-    void onButtonPressed(Intent intent) throws GeneralSecurityException, IOException;
-
     /**
      * Callback fired when user has entered a password for encryption Not called when we've a master
      * password set or enable fingerprint authentication
      *
      * @param password the password entered by user
      */
-    void onButtonPressed(Intent intent, String password)
-        throws GeneralSecurityException, IOException;
+    default void onButtonPressed(@NonNull Intent intent, @NonNull String password)
+        throws GeneralSecurityException, IOException {}
   }
 
   public interface DecryptButtonCallbackInterface {
     /** Callback fired when we've confirmed the password matches the database */
-    void confirm(Intent intent);
+    default void confirm(@NonNull Intent intent) {}
 
     /** Callback fired when password doesn't match the value entered by user */
-    void failed();
+    default void failed() {}
   }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.kt
index dfd460440..e0bd94a96 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.kt
@@ -25,7 +25,7 @@ import android.util.Log
 import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.asynchronous.asynctasks.ssh.PemToKeyPairTask
 import com.amaze.filemanager.asynchronous.asynctasks.ssh.SshAuthenticationTask
-import com.amaze.filemanager.filesystem.files.CryptUtil
+import com.amaze.filemanager.utils.PasswordUtil
 import net.schmizz.sshj.Config
 import net.schmizz.sshj.SSHClient
 import java.security.KeyPair
@@ -263,7 +263,7 @@ object SshConnectionPool {
             username = userInfo[0]
             password = if (userInfo.size > 1) {
                 runCatching {
-                    CryptUtil.decryptPassword(AppConfig.getInstance(), userInfo[1])
+                    PasswordUtil.decryptPassword(AppConfig.getInstance(), userInfo[1])!!
                 }.getOrElse {
                     /* Hack. It should only happen after creating new SSH connection settings
                      * and plain text password is sent in.
diff --git a/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java b/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
index 23a92c936..2423527ea 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/ItemPopupMenu.java
@@ -20,10 +20,19 @@
 
 package com.amaze.filemanager.ui;
 
-import java.io.File;
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.util.ArrayList;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.net.Uri;
+import android.view.MenuItem;
+import android.view.View;
+import android.widget.PopupMenu;
+import android.widget.Toast;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.documentfile.provider.DocumentFile;
+import androidx.preference.PreferenceManager;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
@@ -34,25 +43,18 @@ import com.amaze.filemanager.filesystem.PasteHelper;
 import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils;
 import com.amaze.filemanager.filesystem.files.FileUtils;
 import com.amaze.filemanager.ui.activities.MainActivity;
+import com.amaze.filemanager.ui.dialogs.EncryptAuthenticateDialog;
+import com.amaze.filemanager.ui.dialogs.EncryptWithPresetPasswordSaveAsDialog;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.fragments.MainFragment;
 import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
 import com.amaze.filemanager.ui.provider.UtilitiesProvider;
 import com.amaze.filemanager.utils.DataUtils;
 
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.net.Uri;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.PopupMenu;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.documentfile.provider.DocumentFile;
-import androidx.preference.PreferenceManager;
+import java.io.File;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.ArrayList;
 
 /**
  * This class contains the functionality of the PopupMenu for each file in the MainFragment
@@ -178,84 +180,47 @@ public class ItemPopupMenu extends PopupMenu implements PopupMenu.OnMenuItemClic
         encryptIntent.putExtra(EncryptService.TAG_OPEN_MODE, rowItem.getMode().ordinal());
         encryptIntent.putExtra(EncryptService.TAG_SOURCE, rowItem.generateBaseFile());
 
-        final SharedPreferences preferences =
-            PreferenceManager.getDefaultSharedPreferences(context);
-
         final EncryptDecryptUtils.EncryptButtonCallbackInterface
-            encryptButtonCallbackInterfaceAuthenticate =
-                new EncryptDecryptUtils.EncryptButtonCallbackInterface() {
-                  @Override
-                  public void onButtonPressed(Intent intent) {}
-
-                  @Override
-                  public void onButtonPressed(Intent intent, String password)
-                      throws GeneralSecurityException, IOException {
-                    EncryptDecryptUtils.startEncryption(
-                        context, rowItem.generateBaseFile().getPath(), password, intent);
-                  }
-                };
-
-        EncryptDecryptUtils.EncryptButtonCallbackInterface encryptButtonCallbackInterface =
+          encryptButtonCallbackInterfaceAuthenticate =
             new EncryptDecryptUtils.EncryptButtonCallbackInterface() {
-
               @Override
-              public void onButtonPressed(Intent intent)
+              public void onButtonPressed(Intent intent, String password)
                   throws GeneralSecurityException, IOException {
-                // check if a master password or fingerprint is set
-                if (!preferences
-                    .getString(
-                        PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
-                        PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)
-                    .equals("")) {
-                  GeneralDialogCreation.showEncryptWithPresetPasswordSaveAsDialog(
-                      context,
-                      mainActivity,
-                      PreferencesConstants.ENCRYPT_PASSWORD_MASTER,
-                      encryptIntent);
-                } else if (preferences.getBoolean(
-                    PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT,
-                    PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT)) {
-                  GeneralDialogCreation.showEncryptWithPresetPasswordSaveAsDialog(
-                      context,
-                      mainActivity,
-                      PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT,
-                      encryptIntent);
-                } else {
-                  // let's ask a password from user
-                  GeneralDialogCreation.showEncryptAuthenticateDialog(
-                      context,
-                      encryptIntent,
-                      mainActivity,
-                      utilitiesProvider.getAppTheme(),
-                      encryptButtonCallbackInterfaceAuthenticate);
-                }
+                EncryptDecryptUtils.startEncryption(
+                    context, rowItem.generateBaseFile().getPath(), password, intent);
               }
-
-              @Override
-              public void onButtonPressed(Intent intent, String password) {}
             };
 
-        if (preferences.getBoolean(
-            PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER,
-            PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER_DEFAULT)) {
-          // let's skip warning dialog call
-          try {
-            encryptButtonCallbackInterface.onButtonPressed(encryptIntent);
-          } catch (GeneralSecurityException | IOException e) {
-            e.printStackTrace();
-            Toast.makeText(
-                    context,
-                    mainFragment.getString(R.string.crypt_encryption_fail),
-                    Toast.LENGTH_LONG)
-                .show();
-          }
+        final SharedPreferences preferences =
+          PreferenceManager.getDefaultSharedPreferences(context);
+
+        if (!preferences.getString(
+              PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
+              PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)
+          .equals("")) {
+          EncryptWithPresetPasswordSaveAsDialog.show(
+                  context,
+                  encryptIntent,
+                  mainActivity,
+                  PreferencesConstants.ENCRYPT_PASSWORD_MASTER,
+                  encryptButtonCallbackInterfaceAuthenticate);
+        } else if (preferences.getBoolean(
+              PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT,
+              PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT)) {
+          EncryptWithPresetPasswordSaveAsDialog.show(
+                  context,
+                  encryptIntent,
+                  mainActivity,
+                  PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT,
+                  encryptButtonCallbackInterfaceAuthenticate);
         } else {
-
-          GeneralDialogCreation.showEncryptWarningDialog(
-              encryptIntent,
-              mainFragment,
-              utilitiesProvider.getAppTheme(),
-              encryptButtonCallbackInterface);
+          EncryptAuthenticateDialog.show(
+                  context,
+                  encryptIntent,
+                  mainActivity,
+                  utilitiesProvider.getAppTheme(),
+                  encryptButtonCallbackInterfaceAuthenticate
+          );
         }
         return true;
       case R.id.decrypt:
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialog.kt
new file mode 100644
index 000000000..0ff868ec3
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialog.kt
@@ -0,0 +1,57 @@
+package com.amaze.filemanager.ui.dialogs
+
+import android.content.Context
+import android.content.Intent
+import android.hardware.fingerprint.FingerprintManager
+import android.os.Build
+import android.view.View
+import android.widget.Button
+import androidx.annotation.RequiresApi
+import com.afollestad.materialdialogs.MaterialDialog
+import com.amaze.filemanager.R
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils.DecryptButtonCallbackInterface
+import com.amaze.filemanager.ui.activities.MainActivity
+import com.amaze.filemanager.ui.theme.AppTheme
+import com.amaze.filemanager.utils.FingerprintHandler
+import java.io.IOException
+import java.security.GeneralSecurityException
+
+/**
+ * Decrypt dialog prompt for user fingerprint.
+ */
+object DecryptFingerprintDialog {
+
+    /**
+     * Display dialog prompting user for fingerprint in order to decrypt file.
+     */
+    @JvmStatic
+    @RequiresApi(api = Build.VERSION_CODES.M)
+    @Throws(
+        GeneralSecurityException::class,
+        IOException::class
+    )
+    fun show(
+        c: Context,
+        main: MainActivity,
+        intent: Intent,
+        appTheme: AppTheme,
+        decryptButtonCallbackInterface: DecryptButtonCallbackInterface
+    ) {
+        val accentColor = main.accent
+        val builder = MaterialDialog.Builder(c)
+        builder.title(c.getString(R.string.crypt_decrypt))
+        val rootView = View.inflate(c, R.layout.dialog_decrypt_fingerprint_authentication, null)
+        val cancelButton = rootView.findViewById<Button>(R.id.button_decrypt_fingerprint_cancel)
+        cancelButton.setTextColor(accentColor)
+        builder.customView(rootView, true)
+        builder.canceledOnTouchOutside(false)
+        builder.theme(appTheme.getMaterialDialogTheme(c))
+        val dialog = builder.show()
+        cancelButton.setOnClickListener { v: View? -> dialog.cancel() }
+        val manager = c.getSystemService(FingerprintManager::class.java)
+        val handler = FingerprintHandler(c, intent, dialog, decryptButtonCallbackInterface)
+        val `object` = FingerprintManager.CryptoObject(CryptUtil.initCipher())
+        handler.authenticate(manager, `object`)
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialog.kt
new file mode 100644
index 000000000..b30b00cc8
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialog.kt
@@ -0,0 +1,221 @@
+package com.amaze.filemanager.ui.dialogs
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.content.Intent
+import android.content.SharedPreferences
+import android.text.TextWatcher
+import android.util.Log
+import android.view.LayoutInflater
+import android.view.View
+import android.view.View.INVISIBLE
+import android.view.View.VISIBLE
+import android.widget.CompoundButton
+import android.widget.Toast
+import androidx.appcompat.widget.AppCompatCheckBox
+import androidx.preference.PreferenceManager
+import com.afollestad.materialdialogs.DialogAction
+import com.afollestad.materialdialogs.MaterialDialog
+import com.afollestad.materialdialogs.internal.MDButton
+import com.amaze.filemanager.R
+import com.amaze.filemanager.asynchronous.services.EncryptService
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_AESCRYPT
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_ENCRYPT_TARGET
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_PASSWORD
+import com.amaze.filemanager.databinding.DialogEncryptAuthenticateBinding
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.files.CryptUtil.AESCRYPT_EXTENSION
+import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
+import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils.EncryptButtonCallbackInterface
+import com.amaze.filemanager.ui.activities.MainActivity
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER
+import com.amaze.filemanager.ui.openKeyboard
+import com.amaze.filemanager.ui.theme.AppTheme
+import com.amaze.filemanager.ui.views.WarnableTextInputLayout
+import com.amaze.filemanager.ui.views.WarnableTextInputValidator
+import com.amaze.filemanager.ui.views.WarnableTextInputValidator.ReturnState
+import com.amaze.filemanager.ui.views.WarnableTextInputValidator.ReturnState.STATE_ERROR
+import com.amaze.filemanager.utils.SimpleTextWatcher
+import com.google.android.material.textfield.TextInputEditText
+
+/**
+ * Encrypt file password dialog.
+ */
+object EncryptAuthenticateDialog {
+
+    /**
+     * Display file encryption password dialog.
+     */
+    @JvmStatic
+    @SuppressLint("SetTextI18n")
+    @Suppress("LongMethod")
+    fun show(
+        c: Context,
+        intent: Intent,
+        main: MainActivity,
+        appTheme: AppTheme,
+        encryptButtonCallbackInterface: EncryptButtonCallbackInterface
+    ) {
+        intent.getParcelableExtra<HybridFileParcelable>(EncryptService.TAG_SOURCE)?.run {
+            val preferences = PreferenceManager.getDefaultSharedPreferences(c)
+            val accentColor = main.accent
+            val builder = MaterialDialog.Builder(c)
+            builder.title(main.getString(R.string.crypt_encrypt))
+            val vb: DialogEncryptAuthenticateBinding =
+                DialogEncryptAuthenticateBinding.inflate(LayoutInflater.from(c))
+            val rootView: View = vb.root
+            val passwordEditText: TextInputEditText = vb.editTextDialogEncryptPassword
+            val passwordConfirmEditText: TextInputEditText = vb.editTextDialogEncryptPasswordConfirm
+            val encryptSaveAsEditText: TextInputEditText = vb.editTextEncryptSaveAs
+            val useAzeEncrypt: AppCompatCheckBox = vb.checkboxUseAze
+            useAzeEncrypt.setOnCheckedChangeListener(
+                createUseAzeEncryptCheckboxOnCheckedChangeListener(
+                    c,
+                    this,
+                    preferences,
+                    main,
+                    encryptSaveAsEditText
+                )
+            )
+            val textInputLayoutPassword: WarnableTextInputLayout = vb.tilEncryptPassword
+            val textInputLayoutPasswordConfirm: WarnableTextInputLayout = vb.tilEncryptPasswordConfirm
+            val textInputLayoutEncryptSaveAs: WarnableTextInputLayout = vb.tilEncryptSaveAs
+            encryptSaveAsEditText.setText(this.getName(c) + AESCRYPT_EXTENSION)
+            textInputLayoutEncryptSaveAs.hint =
+                if (this.isDirectory) {
+                    c.getString(R.string.encrypt_folder_save_as)
+                } else {
+                    c.getString(R.string.encrypt_file_save_as)
+                }
+            builder
+                .customView(rootView, true)
+                .positiveText(c.getString(R.string.ok))
+                .negativeText(c.getString(R.string.cancel))
+                .theme(appTheme.getMaterialDialogTheme(c))
+                .positiveColor(accentColor)
+                .negativeColor(accentColor)
+                .autoDismiss(false)
+                .onNegative { dialog, _ -> dialog.cancel() }
+                .onPositive { dialog, _ ->
+                    intent.putExtra(TAG_ENCRYPT_TARGET, encryptSaveAsEditText.text.toString())
+                        .putExtra(TAG_AESCRYPT, !useAzeEncrypt.isChecked)
+                        .putExtra(TAG_PASSWORD, passwordEditText.text.toString())
+                    runCatching {
+                        encryptButtonCallbackInterface.onButtonPressed(
+                            intent, passwordEditText.text.toString()
+                        )
+                    }.onFailure {
+                        Log.e(EncryptService.TAG, "Failed to encrypt", it)
+                        Toast.makeText(
+                            c,
+                            c.getString(R.string.crypt_encryption_fail),
+                            Toast.LENGTH_LONG
+                        ).show()
+                    }.also {
+                        dialog.dismiss()
+                    }
+                }
+            val dialog = builder.show()
+            val btnOK = dialog.getActionButton(DialogAction.POSITIVE)
+            btnOK.isEnabled = false
+            rootView.post { passwordEditText.openKeyboard(main.applicationContext) }
+            val textWatcher: TextWatcher = object : SimpleTextWatcher() {
+                override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
+                    btnOK.isEnabled =
+                        encryptSaveAsEditText.text.toString().isNotEmpty() && passwordEditText.text.toString()
+                        .isNotEmpty() && passwordConfirmEditText.text.toString().isNotEmpty()
+                }
+            }
+            passwordEditText.addTextChangedListener(textWatcher)
+            passwordConfirmEditText.addTextChangedListener(textWatcher)
+            encryptSaveAsEditText.addTextChangedListener(textWatcher)
+            createPasswordFieldValidator(
+                c,
+                passwordEditText,
+                passwordConfirmEditText,
+                textInputLayoutPassword,
+                btnOK
+            )
+            createPasswordFieldValidator(
+                c,
+                passwordConfirmEditText,
+                passwordEditText,
+                textInputLayoutPasswordConfirm,
+                btnOK
+            )
+            WarnableTextInputValidator(
+                c,
+                encryptSaveAsEditText,
+                textInputLayoutEncryptSaveAs,
+                btnOK,
+                createFilenameValidator(useAzeEncrypt)
+            )
+        } ?: throw IllegalArgumentException("No TAG_SOURCE parameter specified")
+    }
+
+    private fun createPasswordFieldValidator(
+        c: Context,
+        passwordField: TextInputEditText,
+        comparingPasswordField: TextInputEditText,
+        warningTextInputLayout: WarnableTextInputLayout,
+        btnOK: MDButton
+    ) = WarnableTextInputValidator(
+        c,
+        passwordField,
+        warningTextInputLayout,
+        btnOK
+    ) { text: String ->
+        if (text.isNotEmpty() && text == comparingPasswordField.text.toString()) {
+            ReturnState()
+        } else if (text.isEmpty()) {
+            ReturnState(STATE_ERROR, R.string.field_empty)
+        } else {
+            ReturnState(STATE_ERROR, R.string.password_no_match)
+        }
+    }
+
+    /**
+     * Convenient method to create an [CompoundButton.OnCheckedChangeListener]
+     * for the aze encryption format selection checkbox.
+     */
+    @JvmStatic
+    @SuppressLint("SetTextI18n")
+    fun createUseAzeEncryptCheckboxOnCheckedChangeListener(
+        c: Context,
+        file: HybridFileParcelable,
+        preferences: SharedPreferences,
+        main: MainActivity,
+        encryptSaveAsEditText: TextInputEditText
+    ) = { _: CompoundButton?, isChecked: Boolean ->
+        if (isChecked && !preferences.getBoolean(PREFERENCE_CRYPT_WARNING_REMEMBER, false)) {
+            EncryptWarningDialog.show(main, main.appTheme)
+        }
+        encryptSaveAsEditText.setText(
+            "${file.getName(c)}${if (isChecked) {
+                CRYPT_EXTENSION
+            } else {
+                AESCRYPT_EXTENSION
+            }}"
+        )
+    }
+
+    /**
+     * Create a [WarnableTextInputValidator.OnTextValidate] for filename field.
+     */
+    @JvmStatic
+    fun createFilenameValidator(useAzeEncrypt: AppCompatCheckBox) = { text: String ->
+        if (text.isEmpty()) {
+            ReturnState(STATE_ERROR, R.string.field_empty)
+        } else if (!text.endsWith(CRYPT_EXTENSION) &&
+            (useAzeEncrypt.visibility == INVISIBLE || useAzeEncrypt.isChecked)
+        ) {
+            ReturnState(STATE_ERROR, R.string.encrypt_file_must_end_with_aze)
+        } else if (!text.endsWith(AESCRYPT_EXTENSION) &&
+            useAzeEncrypt.visibility == VISIBLE && !useAzeEncrypt.isChecked
+        ) {
+            ReturnState(STATE_ERROR, R.string.encrypt_file_must_end_with_aes)
+        } else {
+            ReturnState()
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialog.kt
new file mode 100644
index 000000000..c9232eac3
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialog.kt
@@ -0,0 +1,47 @@
+package com.amaze.filemanager.ui.dialogs
+
+import androidx.preference.PreferenceManager
+import com.afollestad.materialdialogs.MaterialDialog
+import com.amaze.filemanager.R
+import com.amaze.filemanager.ui.activities.MainActivity
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.theme.AppTheme
+
+/**
+ * File encryption warning dialog.
+ *
+ * This dialog is to warn users of the caveat of using Amaze's own encryption format.
+ */
+object EncryptWarningDialog {
+
+    /**
+     * Display warning dialog on use of Amaze's own encryption format.
+     */
+    @JvmStatic
+    fun show(
+        main: MainActivity,
+        appTheme: AppTheme
+    ) {
+        val accentColor: Int = main.accent
+        val preferences = PreferenceManager.getDefaultSharedPreferences(main)
+        MaterialDialog.Builder(main).run {
+            title(main.getString(R.string.warning))
+            content(main.getString(R.string.crypt_warning_key))
+            theme(appTheme.getMaterialDialogTheme(main))
+            negativeText(main.getString(R.string.warning_never_show))
+            positiveText(main.getString(R.string.warning_confirm))
+            positiveColor(accentColor)
+            onPositive { dialog, _ ->
+                dialog.dismiss()
+            }
+            onNegative { dialog, _ ->
+                preferences
+                    .edit()
+                    .putBoolean(PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER, true)
+                    .apply()
+                dialog.dismiss()
+            }
+            show()
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialog.kt
new file mode 100644
index 000000000..c9be91586
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialog.kt
@@ -0,0 +1,121 @@
+package com.amaze.filemanager.ui.dialogs
+
+import android.annotation.SuppressLint
+import android.content.Context
+import android.content.Intent
+import android.view.LayoutInflater
+import android.view.View
+import android.widget.Toast
+import androidx.preference.PreferenceManager
+import com.afollestad.materialdialogs.DialogAction
+import com.afollestad.materialdialogs.MaterialDialog
+import com.amaze.filemanager.R
+import com.amaze.filemanager.asynchronous.services.EncryptService
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_ENCRYPT_TARGET
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_PASSWORD
+import com.amaze.filemanager.databinding.DialogEncryptWithMasterPasswordBinding
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils.EncryptButtonCallbackInterface
+import com.amaze.filemanager.ui.activities.MainActivity
+import com.amaze.filemanager.ui.dialogs.EncryptAuthenticateDialog.createFilenameValidator
+import com.amaze.filemanager.ui.dialogs.EncryptAuthenticateDialog.createUseAzeEncryptCheckboxOnCheckedChangeListener
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_MASTER
+import com.amaze.filemanager.ui.views.WarnableTextInputValidator
+
+/**
+ * Encryption save as file dialog, for us when fingerprint or master password is set.
+ */
+object EncryptWithPresetPasswordSaveAsDialog {
+
+    /**
+     * Displays the save as dialog.
+     */
+    @JvmStatic
+    @SuppressLint("SetTextI18n")
+    @Suppress("LongMethod")
+    fun show(
+        c: Context,
+        intent: Intent,
+        main: MainActivity,
+        password: String,
+        encryptButtonCallbackInterface: EncryptButtonCallbackInterface
+    ) {
+        intent.getParcelableExtra<HybridFileParcelable>(EncryptService.TAG_SOURCE)?.run {
+            val preferences = PreferenceManager.getDefaultSharedPreferences(c)
+            val accentColor = main.accent
+            val vb = DialogEncryptWithMasterPasswordBinding.inflate(LayoutInflater.from(c))
+            val rootView = vb.root
+            val encryptSaveAsEditText = vb.editTextEncryptSaveAs.also {
+                when (password) {
+                    ENCRYPT_PASSWORD_FINGERPRINT -> {
+                        // Fingerprint not supported for AESCrypt
+                        it.setText(this.getName(c) + CryptUtil.CRYPT_EXTENSION)
+                    }
+                    ENCRYPT_PASSWORD_MASTER -> {
+                        it.setText(this.getName(c) + CryptUtil.AESCRYPT_EXTENSION)
+                    }
+                    else -> {
+                        throw IllegalArgumentException(
+                            "Must be either " +
+                                "ENCRYPT_PASSWORD_FINGERPRINT or ENCRYPT_PASSWORD_MASTER"
+                        )
+                    }
+                }
+            }
+            val useAzeEncrypt = vb.checkboxUseAze
+            if (ENCRYPT_PASSWORD_FINGERPRINT != password) {
+                useAzeEncrypt.setOnCheckedChangeListener(
+                    createUseAzeEncryptCheckboxOnCheckedChangeListener(
+                        c,
+                        this,
+                        preferences,
+                        main,
+                        encryptSaveAsEditText
+                    )
+                )
+            } else {
+                useAzeEncrypt.visibility = View.INVISIBLE
+                vb.textViewAzecryptInfo.visibility = View.INVISIBLE
+            }
+
+            val saveAsDialog = MaterialDialog.Builder(c)
+                .title(
+                    if (isDirectory) {
+                        R.string.encrypt_folder_save_as
+                    } else {
+                        R.string.encrypt_file_save_as
+                    }
+                ).customView(rootView, true)
+                .positiveColor(accentColor)
+                .negativeColor(accentColor)
+                .positiveText(android.R.string.ok)
+                .negativeText(android.R.string.cancel)
+                .onPositive { dialog, _ ->
+                    intent.putExtra(TAG_ENCRYPT_TARGET, encryptSaveAsEditText.text.toString())
+                    intent.putExtra(TAG_PASSWORD, password)
+                    runCatching {
+                        encryptButtonCallbackInterface.onButtonPressed(intent, password)
+                    }.onFailure {
+                        Toast.makeText(
+                            c,
+                            c.getString(R.string.crypt_encryption_fail),
+                            Toast.LENGTH_LONG
+                        ).show()
+                    }.also {
+                        dialog.dismiss()
+                    }
+                }.build()
+            WarnableTextInputValidator(
+                c,
+                encryptSaveAsEditText,
+                vb.tilEncryptSaveAs,
+                saveAsDialog.getActionButton(DialogAction.POSITIVE),
+                createFilenameValidator(useAzeEncrypt)
+            )
+            saveAsDialog.show()
+            saveAsDialog.getActionButton(DialogAction.POSITIVE).isEnabled = true
+        } ?: throw IllegalArgumentException("No TAG_SOURCE parameter specified")
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
index 599c5a2c5..74be06edd 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
@@ -20,7 +20,7 @@
 
 package com.amaze.filemanager.ui.dialogs;
 
-import static android.os.Build.VERSION_CODES.M;
+import static android.os.Build.VERSION.SDK_INT;
 import static com.amaze.filemanager.filesystem.files.FileUtils.toHybridFileArrayList;
 import static com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_SORTBY_ONLY_THIS;
 
@@ -60,7 +60,6 @@ import androidx.preference.PreferenceManager;
 import com.afollestad.materialdialogs.DialogAction;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.afollestad.materialdialogs.Theme;
-import com.afollestad.materialdialogs.internal.MDButton;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.adapters.HiddenAdapter;
 import com.amaze.filemanager.adapters.data.LayoutElementParcelable;
@@ -80,7 +79,6 @@ import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
 import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
-import com.amaze.filemanager.filesystem.files.CryptUtil;
 import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils;
 import com.amaze.filemanager.filesystem.files.FileUtils;
 import com.amaze.filemanager.filesystem.root.ChangeFilePermissionsCommand;
@@ -88,13 +86,10 @@ import com.amaze.filemanager.ui.ExtensionsKt;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.ui.fragments.MainFragment;
-import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants;
 import com.amaze.filemanager.ui.theme.AppTheme;
 import com.amaze.filemanager.ui.views.WarnableTextInputLayout;
 import com.amaze.filemanager.ui.views.WarnableTextInputValidator;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.FingerprintHandler;
-import com.amaze.filemanager.utils.SimpleTextWatcher;
 import com.amaze.filemanager.utils.Utils;
 import com.github.mikephil.charting.charts.PieChart;
 import com.github.mikephil.charting.components.Legend;
@@ -104,11 +99,9 @@ import com.github.mikephil.charting.data.PieDataSet;
 import com.github.mikephil.charting.data.PieEntry;
 import com.github.mikephil.charting.formatter.IValueFormatter;
 import com.github.mikephil.charting.utils.ViewPortHandler;
-import com.google.android.material.textfield.TextInputEditText;
 
 import java.io.File;
 import java.io.IOException;
-import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
@@ -386,7 +379,7 @@ public class GeneralDialogCreation {
     }.execute();
 
     // Set category text color for Jelly Bean (API 16) and later.
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
+    if (SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
       categoryDirectories.setTextColor(accentColor);
       categoryFiles.setTextColor(accentColor);
     }
@@ -724,268 +717,6 @@ public class GeneralDialogCreation {
     builder.show();
   }
 
-  public static void showEncryptWarningDialog(
-      final Intent intent,
-      final MainFragment main,
-      AppTheme appTheme,
-      final EncryptDecryptUtils.EncryptButtonCallbackInterface encryptButtonCallbackInterface) {
-    int accentColor = main.getMainActivity().getAccent();
-    final SharedPreferences preferences =
-        PreferenceManager.getDefaultSharedPreferences(main.getContext());
-    final MaterialDialog.Builder builder = new MaterialDialog.Builder(main.getActivity());
-    builder.title(main.getString(R.string.warning));
-    builder.content(main.getString(R.string.crypt_warning_key));
-    builder.theme(appTheme.getMaterialDialogTheme(main.requireContext()));
-    builder.negativeText(main.getString(R.string.warning_never_show));
-    builder.positiveText(main.getString(R.string.warning_confirm));
-    builder.positiveColor(accentColor);
-
-    builder.onPositive(
-        (dialog, which) -> {
-          try {
-            encryptButtonCallbackInterface.onButtonPressed(intent);
-          } catch (Exception e) {
-            e.printStackTrace();
-
-            Toast.makeText(
-                    main.getActivity(),
-                    main.getString(R.string.crypt_encryption_fail),
-                    Toast.LENGTH_LONG)
-                .show();
-          }
-        });
-
-    builder.onNegative(
-        (dialog, which) -> {
-          preferences
-              .edit()
-              .putBoolean(PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER, true)
-              .apply();
-          try {
-            encryptButtonCallbackInterface.onButtonPressed(intent);
-          } catch (Exception e) {
-            e.printStackTrace();
-
-            Toast.makeText(
-                    main.getActivity(),
-                    main.getString(R.string.crypt_encryption_fail),
-                    Toast.LENGTH_LONG)
-                .show();
-          }
-        });
-
-    builder.show();
-  }
-
-  public static void showEncryptWithPresetPasswordSaveAsDialog(
-      @NonNull final Context c,
-      @NonNull final MainActivity main,
-      @NonNull String password,
-      @NonNull final Intent intent) {
-
-    HybridFileParcelable intentParcelable = intent.getParcelableExtra(EncryptService.TAG_SOURCE);
-    MaterialDialog saveAsDialog =
-        showNameDialog(
-            main,
-            "",
-            intentParcelable.getName(c).concat(CryptUtil.CRYPT_EXTENSION),
-            c.getString(
-                intentParcelable.isDirectory()
-                    ? R.string.encrypt_folder_save_as
-                    : R.string.encrypt_file_save_as),
-            c.getString(R.string.ok),
-            null,
-            c.getString(R.string.cancel),
-            (dialog, which) -> {
-              EditText textfield = dialog.getCustomView().findViewById(R.id.singleedittext_input);
-              intent.putExtra(EncryptService.TAG_ENCRYPT_TARGET, textfield.getText().toString());
-              try {
-                EncryptDecryptUtils.startEncryption(
-                    c, intentParcelable.getPath(), password, intent);
-              } catch (GeneralSecurityException | IOException e) {
-                e.printStackTrace();
-                Toast.makeText(c, c.getString(R.string.crypt_encryption_fail), Toast.LENGTH_LONG)
-                    .show();
-              } finally {
-                dialog.dismiss();
-              }
-            },
-            (text) -> {
-              if (text.length() < 1) {
-                return new WarnableTextInputValidator.ReturnState(
-                    WarnableTextInputValidator.ReturnState.STATE_ERROR, R.string.field_empty);
-              }
-              if (!text.endsWith(CryptUtil.CRYPT_EXTENSION)) {
-                return new WarnableTextInputValidator.ReturnState(
-                    WarnableTextInputValidator.ReturnState.STATE_ERROR,
-                    R.string.encrypt_file_must_end_with_aze);
-              }
-              return new WarnableTextInputValidator.ReturnState();
-            });
-    saveAsDialog.getActionButton(DialogAction.POSITIVE).setEnabled(true);
-  }
-
-  public static void showEncryptAuthenticateDialog(
-      final Context c,
-      final Intent intent,
-      final MainActivity main,
-      AppTheme appTheme,
-      final EncryptDecryptUtils.EncryptButtonCallbackInterface encryptButtonCallbackInterface) {
-
-    int accentColor = main.getAccent();
-    MaterialDialog.Builder builder = new MaterialDialog.Builder(c);
-    builder.title(main.getString(R.string.crypt_encrypt));
-
-    View rootView = View.inflate(c, R.layout.dialog_encrypt_authenticate, null);
-
-    final TextInputEditText passwordEditText =
-        rootView.findViewById(R.id.edit_text_dialog_encrypt_password);
-    final TextInputEditText passwordConfirmEditText =
-        rootView.findViewById(R.id.edit_text_dialog_encrypt_password_confirm);
-    final TextInputEditText encryptSaveAsEditText =
-        rootView.findViewById(R.id.edit_text_encrypt_save_as);
-
-    WarnableTextInputLayout textInputLayoutPassword =
-        rootView.findViewById(R.id.til_encrypt_password);
-    WarnableTextInputLayout textInputLayoutPasswordConfirm =
-        rootView.findViewById(R.id.til_encrypt_password_confirm);
-    WarnableTextInputLayout textInputLayoutEncryptSaveAs =
-        rootView.findViewById(R.id.til_encrypt_save_as);
-
-    HybridFileParcelable intentParcelable = intent.getParcelableExtra(EncryptService.TAG_SOURCE);
-    encryptSaveAsEditText.setText(intentParcelable.getName(c).concat(CryptUtil.CRYPT_EXTENSION));
-    textInputLayoutEncryptSaveAs.setHint(
-        intentParcelable.isDirectory()
-            ? c.getString(R.string.encrypt_folder_save_as)
-            : c.getString(R.string.encrypt_file_save_as));
-
-    builder
-        .customView(rootView, true)
-        .positiveText(c.getString(R.string.ok))
-        .negativeText(c.getString(R.string.cancel))
-        .theme(appTheme.getMaterialDialogTheme(c))
-        .positiveColor(accentColor)
-        .negativeColor(accentColor)
-        .autoDismiss(false)
-        .onNegative((dialog, which) -> dialog.cancel())
-        .onPositive(
-            (dialog, which) -> {
-              intent.putExtra(
-                  EncryptService.TAG_ENCRYPT_TARGET, encryptSaveAsEditText.getText().toString());
-
-              try {
-                encryptButtonCallbackInterface.onButtonPressed(
-                    intent, passwordEditText.getText().toString());
-              } catch (GeneralSecurityException | IOException e) {
-                e.printStackTrace();
-                Toast.makeText(c, c.getString(R.string.crypt_encryption_fail), Toast.LENGTH_LONG)
-                    .show();
-              } finally {
-                dialog.dismiss();
-              }
-            });
-
-    MaterialDialog dialog = builder.show();
-    MDButton btnOK = dialog.getActionButton(DialogAction.POSITIVE);
-    btnOK.setEnabled(false);
-
-    rootView.post(() -> ExtensionsKt.openKeyboard(passwordEditText, main.getApplicationContext()));
-
-    TextWatcher textWatcher =
-        new SimpleTextWatcher() {
-          @Override
-          public void onTextChanged(CharSequence s, int start, int before, int count) {
-            btnOK.setEnabled(
-                encryptSaveAsEditText.getText().toString().length() > 0
-                    && passwordEditText.getText().toString().length() > 0
-                    && passwordConfirmEditText.getText().toString().length() > 0);
-          }
-        };
-
-    passwordEditText.addTextChangedListener(textWatcher);
-    passwordConfirmEditText.addTextChangedListener(textWatcher);
-    encryptSaveAsEditText.addTextChangedListener(textWatcher);
-
-    new WarnableTextInputValidator(
-        c,
-        passwordEditText,
-        textInputLayoutPassword,
-        btnOK,
-        (text) -> {
-          if (text.length() < 1) {
-            return new WarnableTextInputValidator.ReturnState(
-                WarnableTextInputValidator.ReturnState.STATE_ERROR, R.string.field_empty);
-          }
-          return new WarnableTextInputValidator.ReturnState();
-        });
-
-    new WarnableTextInputValidator(
-        c,
-        passwordConfirmEditText,
-        textInputLayoutPasswordConfirm,
-        btnOK,
-        (text) -> {
-          if (!text.equals(passwordEditText.getText().toString())) {
-            return new WarnableTextInputValidator.ReturnState(
-                WarnableTextInputValidator.ReturnState.STATE_ERROR, R.string.password_no_match);
-          }
-          return new WarnableTextInputValidator.ReturnState();
-        });
-
-    new WarnableTextInputValidator(
-        c,
-        encryptSaveAsEditText,
-        textInputLayoutEncryptSaveAs,
-        btnOK,
-        (text) -> {
-          if (text.length() < 1) {
-            return new WarnableTextInputValidator.ReturnState(
-                WarnableTextInputValidator.ReturnState.STATE_ERROR, R.string.field_empty);
-          }
-          if (!text.endsWith(CryptUtil.CRYPT_EXTENSION)) {
-            return new WarnableTextInputValidator.ReturnState(
-                WarnableTextInputValidator.ReturnState.STATE_ERROR,
-                R.string.encrypt_file_must_end_with_aze);
-          }
-          return new WarnableTextInputValidator.ReturnState();
-        });
-  }
-
-  @RequiresApi(api = M)
-  public static void showDecryptFingerprintDialog(
-      final Context c,
-      MainActivity main,
-      final Intent intent,
-      AppTheme appTheme,
-      final EncryptDecryptUtils.DecryptButtonCallbackInterface decryptButtonCallbackInterface)
-      throws GeneralSecurityException, IOException {
-
-    int accentColor = main.getAccent();
-    MaterialDialog.Builder builder = new MaterialDialog.Builder(c);
-    builder.title(c.getString(R.string.crypt_decrypt));
-
-    View rootView = View.inflate(c, R.layout.dialog_decrypt_fingerprint_authentication, null);
-
-    Button cancelButton = rootView.findViewById(R.id.button_decrypt_fingerprint_cancel);
-    cancelButton.setTextColor(accentColor);
-    builder.customView(rootView, true);
-    builder.canceledOnTouchOutside(false);
-
-    builder.theme(appTheme.getMaterialDialogTheme(c));
-
-    final MaterialDialog dialog = builder.show();
-    cancelButton.setOnClickListener(v -> dialog.cancel());
-
-    FingerprintManager manager =
-        (FingerprintManager) c.getSystemService(Context.FINGERPRINT_SERVICE);
-    FingerprintManager.CryptoObject object =
-        new FingerprintManager.CryptoObject(CryptUtil.initCipher(c));
-
-    FingerprintHandler handler =
-        new FingerprintHandler(c, intent, dialog, decryptButtonCallbackInterface);
-    handler.authenticate(manager, object);
-  }
-
   public static void showDecryptDialog(
       Context c,
       final MainActivity main,
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt
index e17a5efa8..3c2db57b2 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/FtpServerFragment.kt
@@ -75,12 +75,12 @@ import com.amaze.filemanager.asynchronous.services.ftp.FtpService.Companion.isRu
 import com.amaze.filemanager.asynchronous.services.ftp.FtpService.FtpReceiverActions
 import com.amaze.filemanager.databinding.DialogFtpLoginBinding
 import com.amaze.filemanager.databinding.FragmentFtpBinding
-import com.amaze.filemanager.filesystem.files.CryptUtil
 import com.amaze.filemanager.filesystem.files.FileUtils
 import com.amaze.filemanager.ui.activities.MainActivity
 import com.amaze.filemanager.ui.notifications.FtpNotification
 import com.amaze.filemanager.ui.theme.AppTheme
 import com.amaze.filemanager.utils.OneCharacterCharSequence
+import com.amaze.filemanager.utils.PasswordUtil
 import com.amaze.filemanager.utils.Utils
 import com.google.android.material.snackbar.BaseTransientBottomBar
 import com.google.android.material.snackbar.Snackbar
@@ -729,13 +729,13 @@ class FtpServerFragment : Fragment(R.layout.fragment_ftp) {
     // can't decrypt the password saved in preferences, remove the preference altogether
     private val passwordFromPreferences: String?
         get() = runCatching {
-            val encryptedPassword = mainActivity.prefs.getString(
+            val encryptedPassword: String = mainActivity.prefs.getString(
                 FtpService.KEY_PREFERENCE_PASSWORD, ""
-            )
+            )!!
             if (encryptedPassword == "") {
                 ""
             } else {
-                CryptUtil.decryptPassword(requireContext(), encryptedPassword)
+                PasswordUtil.decryptPassword(requireContext(), encryptedPassword)
             }
         }.onFailure {
             it.printStackTrace()
@@ -800,14 +800,16 @@ class FtpServerFragment : Fragment(R.layout.fragment_ftp) {
 
     private fun setFTPPassword(password: String) {
         try {
-            mainActivity
-                .prefs
-                .edit()
-                .putString(
-                    FtpService.KEY_PREFERENCE_PASSWORD,
-                    CryptUtil.encryptPassword(context, password)
-                )
-                .apply()
+            context?.run {
+                mainActivity
+                    .prefs
+                    .edit()
+                    .putString(
+                        FtpService.KEY_PREFERENCE_PASSWORD,
+                        PasswordUtil.encryptPassword(this, password)
+                    )
+                    .apply()
+            }
         } catch (e: GeneralSecurityException) {
             e.printStackTrace()
             Toast.makeText(context, resources.getString(R.string.error), Toast.LENGTH_LONG)
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
index b42805bd6..a40132f9c 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
@@ -473,7 +473,8 @@ public class MainFragment extends Fragment
         if (layoutElementParcelable.isDirectory) {
           computeScroll();
           loadlist(path, false, mainFragmentViewModel.getOpenMode());
-        } else if (layoutElementParcelable.desc.endsWith(CryptUtil.CRYPT_EXTENSION)) {
+        } else if (layoutElementParcelable.desc.endsWith(CryptUtil.CRYPT_EXTENSION)
+            || layoutElementParcelable.desc.endsWith(CryptUtil.AESCRYPT_EXTENSION)) {
           // decrypt the file
           mainFragmentViewModel.setEncryptOpen(true);
           mainFragmentViewModel.initEncryptBaseFile(
@@ -482,7 +483,8 @@ public class MainFragment extends Fragment
                   + layoutElementParcelable
                       .generateBaseFile()
                       .getName(getMainActivity())
-                      .replace(CryptUtil.CRYPT_EXTENSION, ""));
+                      .replace(CryptUtil.CRYPT_EXTENSION, "")
+                      .replace(CryptUtil.AESCRYPT_EXTENSION, ""));
 
           EncryptDecryptUtils.decryptFile(
               getContext(),
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/SecurityPrefsFragment.kt b/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/SecurityPrefsFragment.kt
index fa4ab7ae0..9e02c5f82 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/SecurityPrefsFragment.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/preference_fragments/SecurityPrefsFragment.kt
@@ -32,8 +32,8 @@ import androidx.core.app.ActivityCompat
 import androidx.preference.Preference
 import com.afollestad.materialdialogs.MaterialDialog
 import com.amaze.filemanager.R
-import com.amaze.filemanager.filesystem.files.CryptUtil
 import com.amaze.filemanager.ui.views.preference.CheckBox
+import com.amaze.filemanager.utils.PasswordUtil
 import java.io.IOException
 import java.security.GeneralSecurityException
 
@@ -99,7 +99,7 @@ class SecurityPrefsFragment : BasePrefsFragment() {
             ) {
 
                 // password is set, try to decrypt
-                CryptUtil.decryptPassword(activity, preferencePassword)
+                PasswordUtil.decryptPassword(activity, preferencePassword)
             } else {
                 // no password set in preferences, just leave the field empty
                 ""
@@ -132,7 +132,7 @@ class SecurityPrefsFragment : BasePrefsFragment() {
                     val editor = activity.prefs.edit()
                     editor.putString(
                         PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
-                        CryptUtil.encryptPassword(
+                        PasswordUtil.encryptPassword(
                             activity, dialog.inputEditText!!.text.toString()
                         )
                     )
diff --git a/app/src/main/java/com/amaze/filemanager/ui/icons/MimeTypes.java b/app/src/main/java/com/amaze/filemanager/ui/icons/MimeTypes.java
index 7eefbc1cf..49b982e33 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/icons/MimeTypes.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/icons/MimeTypes.java
@@ -124,6 +124,7 @@ public final class MimeTypes {
     MIME_TYPES.put("mts", "video/mp2t");
 
     MIME_TYPES.put(CryptUtil.CRYPT_EXTENSION.replace(".", ""), "crypt/aze");
+    MIME_TYPES.put(CryptUtil.AESCRYPT_EXTENSION.replace(".", ""), "crypt/x-aescrypt");
   }
 
   /**
diff --git a/app/src/main/java/com/amaze/filemanager/utils/AESCrypt.kt b/app/src/main/java/com/amaze/filemanager/utils/AESCrypt.kt
new file mode 100644
index 000000000..8d7d7e03f
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/AESCrypt.kt
@@ -0,0 +1,408 @@
+/*
+ * Copyright (C) 2014-2008 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import android.util.Log
+import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
+import java.io.IOException
+import java.io.InputStream
+import java.io.OutputStream
+import java.security.GeneralSecurityException
+import java.security.MessageDigest
+import java.security.SecureRandom
+import javax.crypto.Cipher
+import javax.crypto.Mac
+import javax.crypto.spec.IvParameterSpec
+import javax.crypto.spec.SecretKeySpec
+import kotlin.text.Charsets.UTF_16LE
+import kotlin.text.Charsets.UTF_8
+
+/**
+ * This is code comment from original AESCrypt.java.
+ *
+ * This class provides methods to encrypt and decrypt files using
+ * [aescrypt file format](http://www.aescrypt.com/aes_file_format.html),
+ * version 1 or 2.
+ *
+ *
+ * Requires Java 6 and [Java
+ * Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files](http://java.sun.com/javase/downloads/index.jsp).
+ *
+ *
+ * Thread-safety and sharing: this class is not thread-safe.<br></br>
+ * <tt>AESCrypt</tt> objects can be used as Commands (create, use once and dispose),
+ * or reused to perform multiple operations (not concurrently though).
+ *
+ * @author Vcali Sistemas Inteligentes
+ */
+
+/**
+ * A modified version of original AESCrypt and converted to Kotlin.
+ *
+ * Changes from original version:
+ * - only handles and output streams
+ * - use [android.util.Log] instead of System.out.println
+ * - made protected methods private
+ * - not using device MAC address to generate IV1
+ * - use of Kotlin shorthands instead of reinventing the wheel
+ * - throw more precise [IncorrectEncryptedDataException] and [DecryptFailureException] for better
+ * error handling
+ *
+ * Wishlist:
+ * - implement ChaCha20-Poly1305 cipher, which is faster for mobile devices at the cost of only
+ *   Amaze and implementations that knows Amaze can decrypt. Shall add flags in extensions header
+ *
+ * @author TranceLove <airwave209gt@gmail.com>
+ *
+ */
+class AESCrypt(password: String) {
+
+    private lateinit var password: ByteArray
+    private val cipher: Cipher
+    private val hmac: Mac
+    private val random: SecureRandom
+    private val digest: MessageDigest
+    private lateinit var ivSpec1: IvParameterSpec
+    private lateinit var aesKey1: SecretKeySpec
+    private lateinit var ivSpec2: IvParameterSpec
+    private lateinit var aesKey2: SecretKeySpec
+
+    /*******************
+     * PRIVATE METHODS *
+     */
+    /**
+     * Generates a pseudo-random byte array.
+     * @return pseudo-random byte array of <tt>len</tt> bytes.
+     */
+    private fun generateRandomBytes(len: Int): ByteArray {
+        val bytes = ByteArray(len)
+        random.nextBytes(bytes)
+        return bytes
+    }
+
+    /**
+     * SHA256 digest over given byte array and random bytes.<br></br>
+     * <tt>bytes.length</tt> * <tt>num</tt> random bytes are added to the digest.
+     *
+     *
+     * The generated hash is saved back to the original byte array.<br></br>
+     * Maximum array size is [.SHA_SIZE] bytes.
+     */
+    private fun digestRandomBytes(bytes: ByteArray, num: Int) {
+        require(bytes.size <= SHA_SIZE)
+        digest.reset()
+        digest.update(bytes)
+        for (i in 0 until num) {
+            random.nextBytes(bytes)
+            digest.update(bytes)
+        }
+        digest.digest().copyInto(bytes, endIndex = bytes.size)
+    }
+
+    /**
+     * Generates a pseudo-random IV based on time and 8 more random bytes.
+     *
+     * Changes from original implementation: it is never a good idea to get hardware MAC address
+     * anyway, and Android effectively prevented this since Marshmallow. So why not just make all
+     * 8 bytes completely random? At the end it is embedded into the AESCrypted file, and in fact
+     * it may further reduce the possibility of IV being guessed if generated from the same device.
+     *
+     * The first 8 bytes is generated using the original method, and the remaining 8 bytes are
+     * generated using the [random] we have here. - TranceLove
+     *
+     * This IV is used to crypt IV 2 and AES key 2 in the file.
+     * @return IV.
+     */
+    private fun generateIv1(): ByteArray {
+        val iv = ByteArray(BLOCK_SIZE)
+        val time = System.currentTimeMillis()
+        for (i in 0..7) {
+            iv[i] = (time shr i * 8).toByte()
+        }
+        ByteArray(8).apply {
+            random.nextBytes(this)
+            copyInto(iv, destinationOffset = 8, startIndex = 0, endIndex = this.size)
+        }
+        digestRandomBytes(iv, 256)
+        return iv
+    }
+
+    /**
+     * Generates an AES key starting with an IV and applying the supplied user password.
+     *
+     *
+     * This AES key is used to crypt IV 2 and AES key 2.
+     * @return AES key of [.KEY_SIZE] bytes.
+     */
+    private fun generateAESKey1(iv: ByteArray, password: ByteArray): ByteArray {
+        var aesKey = ByteArray(KEY_SIZE)
+        iv.copyInto(aesKey, endIndex = iv.size)
+        for (i in 0..8191) {
+            digest.reset()
+            digest.update(aesKey)
+            digest.update(password)
+            aesKey = digest.digest()
+        }
+        return aesKey
+    }
+
+    /**
+     * Generates the random IV used to crypt file contents.
+     * @return IV 2.
+     */
+    private fun generateIV2(): ByteArray {
+        val iv = generateRandomBytes(BLOCK_SIZE)
+        digestRandomBytes(iv, 256)
+        return iv
+    }
+
+    /**
+     * Generates the random AES key used to crypt file contents.
+     * @return AES key of [.KEY_SIZE] bytes.
+     */
+    private fun generateAESKey2(): ByteArray {
+        val aesKey = generateRandomBytes(KEY_SIZE)
+        digestRandomBytes(aesKey, 32)
+        return aesKey
+    }
+
+    /**
+     * Changes the password this object uses to encrypt and decrypt.
+     */
+    private fun setPassword(password: String) {
+        this.password = password.toByteArray(UTF_16LE)
+        Log.v(TAG, "Using password: $password")
+    }
+
+    /**************
+     * PUBLIC API *
+     */
+
+    /**
+     * The input stream is encrypted and saved to the output stream.
+     *
+     *
+     * <tt>version</tt> can be either 1 or 2.<br></br>
+     * None of the streams are closed.
+     * @throws IOException when there are I/O errors.
+     * @throws GeneralSecurityException if the platform does not support the required cryptographic methods.
+     */
+    @Suppress("LongMethod", "ComplexMethod")
+    @Throws(IOException::class, GeneralSecurityException::class)
+    fun encrypt(version: Int = AESCRYPT_SPEC_VERSION, `in`: InputStream, out: OutputStream, progressHandler: ProgressHandler) {
+        var text: ByteArray?
+        ivSpec1 = IvParameterSpec(generateIv1())
+        aesKey1 = SecretKeySpec(generateAESKey1(ivSpec1.iv, password), CRYPT_ALG)
+        ivSpec2 = IvParameterSpec(generateIV2())
+        aesKey2 = SecretKeySpec(generateAESKey2(), CRYPT_ALG)
+        Log.v(TAG, "IV1: ${ivSpec1.iv.toHex()}")
+        Log.v(TAG, "AES1: ${aesKey1.encoded.toHex()}")
+        Log.v(TAG, "IV2: ${ivSpec2.iv.toHex()}")
+        Log.v(TAG, "AES2: ${aesKey2.encoded.toHex()}")
+        out.write(AESCRYPT_HEADER.toByteArray(UTF_8)) // Heading.
+        out.write(version) // Version.
+        out.write(0) // Reserved.
+        if (version == AESCRYPT_SPEC_VERSION) { // No extensions.
+            out.write(0)
+            out.write(0)
+        }
+        out.write(ivSpec1.iv) // Initialization Vector.
+        text = ByteArray(BLOCK_SIZE + KEY_SIZE)
+        cipher.init(Cipher.ENCRYPT_MODE, aesKey1, ivSpec1)
+        cipher.update(ivSpec2.iv, 0, BLOCK_SIZE, text)
+        cipher.doFinal(aesKey2.encoded, 0, KEY_SIZE, text, BLOCK_SIZE)
+        out.write(text) // Crypted IV and key.
+        Log.v(TAG, "IV2 + AES2 ciphertext: ${text.toHex()}")
+        hmac.init(SecretKeySpec(aesKey1.encoded, HMAC_ALG))
+        text = hmac.doFinal(text)
+        out.write(text) // HMAC from previous cyphertext.
+        Log.v(TAG, "HMAC1: ${text.toHex()}")
+        cipher.init(Cipher.ENCRYPT_MODE, aesKey2, ivSpec2)
+        hmac.init(SecretKeySpec(aesKey2.encoded, HMAC_ALG))
+        text = ByteArray(BLOCK_SIZE)
+        var len: Int
+        var last = 0
+        while (`in`.read(text).also { len = it } > 0) {
+            if (!progressHandler.cancelled) {
+                cipher.update(text, 0, BLOCK_SIZE, text)
+                hmac.update(text)
+                out.write(text) // Crypted file data block.
+                last = len
+                ServiceWatcherUtil.position += len
+            }
+        }
+        last = last and 0x0f
+        out.write(last) // Last block size mod 16.
+        Log.v(TAG, "Last block size mod 16: $last")
+        text = hmac.doFinal()
+        out.write(text) // HMAC from previous cyphertext.
+        Log.v(TAG, "HMAC2: ${text.toHex()}")
+
+        out.flush()
+        `in`.close()
+        out.close()
+    }
+
+    /**
+     * The input stream is decrypted and saved to the output stream.
+     *
+     * The input file size is needed in advance.<br></br>
+     * The input stream can be encrypted using version 1 or 2 of aescrypt.<br></br>
+     * None of the streams are closed.
+     *
+     * Changes from original implementation: will flush and close input and output streams
+     * gracefully, in align with our own encryption routine. - TranceLove
+     *
+     * @param inSize input stream size, for sanity checking
+     * @param `in` AESCrypted source stream
+     * @param out decrypted data output stream
+     * @throws IncorrectEncryptedDataException if provided encrypted data cannot be parsed correctly
+     * @throws DecryptFailureException if there is any problem during decryption
+     * @throws GeneralSecurityException if the platform does not support the required cryptographic methods.
+     */
+    @Suppress("LongMethod", "ComplexMethod")
+    @Throws(GeneralSecurityException::class)
+    fun decrypt(inSize: Long, `in`: InputStream, out: OutputStream) {
+        var text: ByteArray
+        var total =
+            (3 + 1 + 1 + BLOCK_SIZE + BLOCK_SIZE + KEY_SIZE + SHA_SIZE + 1 + SHA_SIZE).toLong()
+        text = ByteArray(3)
+        `in`.read(text) // Heading.
+        if (text.toString(UTF_8) != "AES") {
+            throw IncorrectEncryptedDataException("Invalid file header")
+        }
+        val version: Int = `in`.read() // Version.
+        if (version < 1 || version > 2) {
+            throw IncorrectEncryptedDataException("Unsupported version number: $version")
+        }
+        Log.v(TAG, "Version: $version")
+        `in`.read() // Reserved.
+        if (version == 2) { // Extensions.
+            text = ByteArray(2)
+            var len: Int
+            do {
+                `in`.read(text)
+                len = 0xff and text[0].toInt() shl 8 or (0xff and text[1].toInt())
+                if (`in`.skip(len.toLong()) != len.toLong()) {
+                    throw IncorrectEncryptedDataException("Unexpected end of extension")
+                }
+                total += (2 + len).toLong()
+                Log.i(TAG, "Skipped extension sized: $len")
+            } while (len != 0)
+        }
+        text = ByteArray(BLOCK_SIZE)
+        `in`.read(text) // Initialization Vector.
+        ivSpec1 = IvParameterSpec(text)
+        aesKey1 = SecretKeySpec(generateAESKey1(ivSpec1.iv, password), CRYPT_ALG)
+        Log.v(TAG, "IV1: ${ivSpec1.iv.toHex()}")
+        Log.v(TAG, "AES1: ${aesKey1.encoded.toHex()}")
+        cipher.init(Cipher.DECRYPT_MODE, aesKey1, ivSpec1)
+        var backup = ByteArray(BLOCK_SIZE + KEY_SIZE)
+        `in`.read(backup) // IV and key to decrypt file contents.
+        Log.v(TAG, "IV2 + AES2 ciphertext: ${backup.toHex()}")
+        text = cipher.doFinal(backup)
+        ivSpec2 = IvParameterSpec(text, 0, BLOCK_SIZE)
+        aesKey2 = SecretKeySpec(text, BLOCK_SIZE, KEY_SIZE, CRYPT_ALG)
+        Log.v(TAG, "IV2: ${ivSpec2.iv.toHex()}")
+        Log.v(TAG, "AES2: ${aesKey2.encoded.toHex()}")
+        hmac.init(SecretKeySpec(aesKey1.encoded, HMAC_ALG))
+        backup = hmac.doFinal(backup)
+        text = ByteArray(SHA_SIZE)
+        `in`.read(text) // HMAC and authenticity test.
+        if (!backup.contentEquals(text)) {
+            throw DecryptFailureException("Message has been altered or password incorrect")
+        }
+        Log.v(TAG, "HMAC1: ${text.toHex()}")
+        total = inSize - total // Payload size.
+        if (total % BLOCK_SIZE != 0L) {
+            throw DecryptFailureException("Input file is corrupt. BLOCK_SIZE = $BLOCK_SIZE, total was $total")
+        }
+        if (total == 0L) { // Hack: empty files won't enter block-processing for-loop below.
+            `in`.read() // Skip last block size mod 16.
+        }
+        Log.v(TAG, "Payload size: $total")
+        cipher.init(Cipher.DECRYPT_MODE, aesKey2, ivSpec2)
+        hmac.init(SecretKeySpec(aesKey2.encoded, HMAC_ALG))
+        backup = ByteArray(BLOCK_SIZE)
+        text = ByteArray(BLOCK_SIZE)
+        for (block in (total / BLOCK_SIZE).toInt() downTo 1) {
+            var len = BLOCK_SIZE
+            if (`in`.read(backup, 0, len) != len) { // Cyphertext block.
+                throw DecryptFailureException("Unexpected end of file contents")
+            }
+            cipher.update(backup, 0, len, text)
+            hmac.update(backup, 0, len)
+            if (block == 1) {
+                val last = `in`.read() // Last block size mod 16.
+                Log.i(TAG, "Last block size mod 16: $last")
+                len = if (last > 0) last else BLOCK_SIZE
+            }
+            out.write(text, 0, len)
+        }
+        out.write(cipher.doFinal())
+        backup = hmac.doFinal()
+        text = ByteArray(SHA_SIZE)
+        `in`.read(text) // HMAC and authenticity test.
+        if (!backup.contentEquals(text)) {
+            throw DecryptFailureException("Message has been altered or password incorrect")
+        }
+        Log.v(TAG, "HMAC2: ${text.toHex()}")
+        out.flush()
+        `in`.close()
+        out.close()
+    }
+
+    companion object {
+        @JvmStatic
+        private val TAG = AESCrypt::class.java.simpleName
+        const val AESCRYPT_SPEC_VERSION = 2
+        private const val AESCRYPT_HEADER = "AES"
+        private const val RANDOM_ALG = "SHA1PRNG"
+        private const val DIGEST_ALG = "SHA-256"
+        private const val HMAC_ALG = "HmacSHA256"
+        private const val CRYPT_ALG = "AES"
+        private const val CRYPT_TRANS = "AES/CBC/NoPadding"
+        private const val KEY_SIZE = 32
+        private const val BLOCK_SIZE = 16
+        private const val SHA_SIZE = 32
+    }
+
+    /**
+     * Builds an object to encrypt or decrypt files with the given password.
+     */
+    init {
+        setPassword(password)
+        random = SecureRandom.getInstance(RANDOM_ALG)
+        digest = MessageDigest.getInstance(DIGEST_ALG)
+        cipher = Cipher.getInstance(CRYPT_TRANS)
+        hmac = Mac.getInstance(HMAC_ALG)
+    }
+
+    /**
+     * Exception representing provided encrypted data is incorrect
+     */
+    class IncorrectEncryptedDataException(message: String) : GeneralSecurityException(message)
+
+    /**
+     * Exception representing decryption errors
+     */
+    class DecryptFailureException(message: String) : GeneralSecurityException(message)
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt b/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt
index 345e59443..1d235c3f1 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/GenericExt.kt
@@ -68,3 +68,14 @@ inline fun <T1 : Any, T2 : Any, R : Any> safeLet(
         p2
     ) else null
 }
+
+/**
+ * Convert a byte array to its hex string representation.
+ *
+ * Optionally takes a separator parameter.
+ */
+fun ByteArray.toHex(separatorStr: String = ""): String =
+    joinToString(separator = separatorStr) {
+        eachByte ->
+        "%02x".format(eachByte)
+    }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index ee4bac0be..2f0c6fb18 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -390,7 +390,7 @@ public class MainActivityHelper {
                     // update the database entry to reflect rename for encrypted file
                     if (oldPath.endsWith(CryptUtil.CRYPT_EXTENSION)) {
                       try {
-                        CryptHandler cryptHandler = CryptHandler.getInstance();
+                        CryptHandler cryptHandler = CryptHandler.INSTANCE;
                         EncryptedEntry oldEntry = cryptHandler.findEntry(oldPath);
                         EncryptedEntry newEntry = new EncryptedEntry();
                         newEntry.setId(oldEntry.getId());
diff --git a/app/src/main/java/com/amaze/filemanager/utils/PasswordUtil.kt b/app/src/main/java/com/amaze/filemanager/utils/PasswordUtil.kt
new file mode 100644
index 000000000..7a88bd931
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/PasswordUtil.kt
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import android.content.Context
+import android.os.Build
+import android.util.Base64
+import androidx.annotation.RequiresApi
+import com.amaze.filemanager.BuildConfig
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import com.amaze.filemanager.utils.security.SecretKeygen
+import java.io.IOException
+import java.security.GeneralSecurityException
+import javax.crypto.Cipher
+import javax.crypto.spec.GCMParameterSpec
+import javax.crypto.spec.IvParameterSpec
+
+object PasswordUtil {
+
+    // 12 byte long IV supported by android for GCM
+    private const val IV = BuildConfig.CRYPTO_IV
+
+    /** Helper method to encrypt plain text password  */
+    @RequiresApi(api = Build.VERSION_CODES.M)
+    @Throws(
+        GeneralSecurityException::class,
+        IOException::class
+    )
+    private fun aesEncryptPassword(plainTextPassword: String): String? {
+        val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
+        val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
+        cipher.init(Cipher.ENCRYPT_MODE, SecretKeygen.getSecretKey(), gcmParameterSpec)
+        val encodedBytes = cipher.doFinal(plainTextPassword.toByteArray())
+        return Base64.encodeToString(encodedBytes, Base64.DEFAULT)
+    }
+
+    /** Helper method to decrypt cipher text password  */
+    @RequiresApi(api = Build.VERSION_CODES.M)
+    @Throws(
+        GeneralSecurityException::class,
+        IOException::class
+    )
+    private fun aesDecryptPassword(cipherPassword: String): String {
+        val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
+        val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
+        cipher.init(Cipher.DECRYPT_MODE, SecretKeygen.getSecretKey(), gcmParameterSpec)
+        val decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, Base64.DEFAULT))
+        return String(decryptedBytes)
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    @Throws(
+        GeneralSecurityException::class,
+        IOException::class
+    )
+    private fun rsaEncryptPassword(context: Context, password: String): String? {
+        val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
+        val ivParameterSpec = IvParameterSpec(IV.toByteArray())
+        cipher.init(Cipher.ENCRYPT_MODE, SecretKeygen.getSecretKey(), ivParameterSpec)
+        return Base64.encodeToString(cipher.doFinal(password.toByteArray()), Base64.DEFAULT)
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
+    @Throws(
+        GeneralSecurityException::class,
+        IOException::class
+    )
+    private fun rsaDecryptPassword(context: Context, cipherText: String): String {
+        val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
+        val ivParameterSpec = IvParameterSpec(IV.toByteArray())
+        cipher.init(Cipher.DECRYPT_MODE, SecretKeygen.getSecretKey(), ivParameterSpec)
+        val decryptedBytes = cipher.doFinal(Base64.decode(cipherText, Base64.DEFAULT))
+        return String(decryptedBytes)
+    }
+
+    /** Method handles encryption of plain text on various APIs  */
+    @Throws(GeneralSecurityException::class, IOException::class)
+    fun encryptPassword(context: Context, plainText: String): String? {
+        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            aesEncryptPassword(plainText)
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            rsaEncryptPassword(context, plainText)
+        } else plainText
+    }
+
+    /** Method handles decryption of cipher text on various APIs  */
+    @Throws(GeneralSecurityException::class, IOException::class)
+    fun decryptPassword(context: Context, cipherText: String): String {
+        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            aesDecryptPassword(cipherText)
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            rsaDecryptPassword(context, cipherText)
+        } else cipherText
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
index 1f1b22c73..b50d0e080 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
@@ -28,7 +28,6 @@ import java.io.IOException;
 import java.net.MalformedURLException;
 import java.security.GeneralSecurityException;
 
-import com.amaze.filemanager.filesystem.files.CryptUtil;
 import com.amaze.filemanager.filesystem.smb.CifsContexts;
 
 import android.content.Context;
@@ -74,7 +73,7 @@ public class SmbUtil {
     String encryptedPassword = path.substring(path.indexOf(":", 4) + 1, path.lastIndexOf("@"));
 
     if (!TextUtils.isEmpty(encryptedPassword)) {
-      String decryptedPassword = CryptUtil.decryptPassword(context, encryptedPassword);
+      String decryptedPassword = PasswordUtil.INSTANCE.decryptPassword(context, encryptedPassword);
       buffer.append(decryptedPassword);
     }
     buffer.append(path.substring(path.lastIndexOf("@")));
@@ -95,7 +94,7 @@ public class SmbUtil {
     String decryptedPassword = path.substring(path.indexOf(":", 4) + 1, path.lastIndexOf("@"));
 
     if (!TextUtils.isEmpty(decryptedPassword)) {
-      String encryptPassword = CryptUtil.encryptPassword(context, decryptedPassword);
+      String encryptPassword = PasswordUtil.INSTANCE.encryptPassword(context, decryptedPassword);
       buffer.append(encryptPassword);
     }
     buffer.append(path.substring(path.lastIndexOf("@")));
diff --git a/app/src/main/java/com/amaze/filemanager/utils/security/SecretKeygen.kt b/app/src/main/java/com/amaze/filemanager/utils/security/SecretKeygen.kt
new file mode 100644
index 000000000..af1aa2a74
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/security/SecretKeygen.kt
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils.security
+
+import android.content.Context
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN_MR2
+import android.os.Build.VERSION_CODES.M
+import android.security.KeyPairGeneratorSpec
+import android.security.keystore.KeyGenParameterSpec
+import android.security.keystore.KeyProperties
+import android.util.Base64
+import androidx.annotation.RequiresApi
+import androidx.preference.PreferenceManager
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import java.io.ByteArrayInputStream
+import java.io.ByteArrayOutputStream
+import java.io.IOException
+import java.math.BigInteger
+import java.security.GeneralSecurityException
+import java.security.Key
+import java.security.KeyPairGenerator
+import java.security.KeyStore
+import java.security.SecureRandom
+import java.util.*
+import javax.crypto.Cipher
+import javax.crypto.CipherInputStream
+import javax.crypto.CipherOutputStream
+import javax.crypto.KeyGenerator
+import javax.crypto.spec.SecretKeySpec
+import javax.security.auth.x500.X500Principal
+
+object SecretKeygen {
+
+    private const val PREFERENCE_KEY = "aes_key"
+    private const val ALGO_RSA = "RSA/ECB/PKCS1Padding"
+
+    /**
+     * Return [Key] in application. Generate one if it doesn't exist in AndroidKeyStore.
+     *
+     * @return AES key for API 23 or above, RSA key for API 18 or above, or else null
+     */
+    fun getSecretKey(): Key? {
+        return if (SDK_INT >= M) {
+            getAesSecretKey()
+        } else if (SDK_INT >= JELLY_BEAN_MR2) {
+            getRsaSecretKey()
+        } else {
+            null
+        }
+    }
+
+    /**
+     * Gets a secret key from Android key store. If no key has been generated with a given alias then
+     * generate a new one
+     */
+    @RequiresApi(api = M)
+    @Throws(
+        GeneralSecurityException::class,
+        IOException::class
+    )
+    private fun getAesSecretKey(): Key {
+        val keyStore = KeyStore.getInstance(CryptUtil.KEY_STORE_ANDROID)
+        keyStore.load(null)
+        return if (!keyStore.containsAlias(CryptUtil.KEY_ALIAS_AMAZE)) {
+            val keyGenerator = KeyGenerator.getInstance(
+                KeyProperties.KEY_ALGORITHM_AES,
+                CryptUtil.KEY_STORE_ANDROID
+            )
+            val builder = KeyGenParameterSpec.Builder(
+                CryptUtil.KEY_ALIAS_AMAZE,
+                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
+            )
+            builder.setBlockModes(KeyProperties.BLOCK_MODE_GCM)
+            builder.setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
+            builder.setRandomizedEncryptionRequired(false)
+            keyGenerator.init(builder.build())
+            keyGenerator.generateKey()
+        } else {
+            keyStore.getKey(CryptUtil.KEY_ALIAS_AMAZE, null)
+        }
+    }
+
+    @Throws(GeneralSecurityException::class, IOException::class)
+    @RequiresApi(JELLY_BEAN_MR2)
+    private fun getRsaSecretKey(): Key {
+        val preferences = PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+        val encodedString = preferences.getString(PREFERENCE_KEY, null)
+        return if (encodedString != null) {
+            SecretKeySpec(
+                decryptAESKey(Base64.decode(encodedString, Base64.DEFAULT)), "AES"
+            )
+        } else {
+            generateRsaKeyPair(AppConfig.getInstance())
+            setKeyPreference()
+            getRsaSecretKey()
+        }
+    }
+
+    /** Generates a RSA public/private key pair to encrypt AES key  */
+    @RequiresApi(api = JELLY_BEAN_MR2)
+    private fun generateRsaKeyPair(context: Context) {
+        val keyStore = KeyStore.getInstance(CryptUtil.KEY_STORE_ANDROID)
+        keyStore.load(null)
+        if (!keyStore.containsAlias(CryptUtil.KEY_ALIAS_AMAZE)) {
+            // generate a RSA key pair to encrypt/decrypt AES key from preferences
+            val start = Calendar.getInstance()
+            val end = Calendar.getInstance()
+            end.add(Calendar.YEAR, 30)
+            val keyPairGenerator = KeyPairGenerator.getInstance("RSA", CryptUtil.KEY_STORE_ANDROID)
+            val spec = KeyPairGeneratorSpec.Builder(context)
+                .setAlias(CryptUtil.KEY_ALIAS_AMAZE)
+                .setSubject(X500Principal("CN=" + CryptUtil.KEY_ALIAS_AMAZE))
+                .setSerialNumber(BigInteger.TEN)
+                .setStartDate(start.time)
+                .setEndDate(end.time)
+                .build()
+            keyPairGenerator.initialize(spec)
+            keyPairGenerator.generateKeyPair()
+        }
+    }
+
+    /** Encrypts AES key and set into preference  */
+    @Throws(GeneralSecurityException::class, IOException::class)
+    private fun setKeyPreference() {
+        PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance()).run {
+            var encodedAesKey = getString(PREFERENCE_KEY, null)
+            if (encodedAesKey == null) {
+                // generate encrypted aes key and save to preference
+                val key = ByteArray(16)
+                val secureRandom = SecureRandom()
+                secureRandom.nextBytes(key)
+                val encryptedKey: ByteArray = encryptAESKey(key)
+                encodedAesKey = Base64.encodeToString(encryptedKey, Base64.DEFAULT)
+                edit().putString(PREFERENCE_KEY, encodedAesKey).apply()
+            }
+        }
+    }
+
+    /** Encrypts randomly generated AES key using RSA public key  */
+    @Throws(GeneralSecurityException::class, IOException::class)
+    private fun encryptAESKey(secretKey: ByteArray): ByteArray {
+        val keyStore = KeyStore.getInstance(CryptUtil.KEY_STORE_ANDROID)
+        keyStore.load(null)
+        val keyEntry =
+            keyStore.getEntry(CryptUtil.KEY_ALIAS_AMAZE, null) as KeyStore.PrivateKeyEntry
+        val cipher = Cipher.getInstance(ALGO_RSA, "AndroidOpenSSL")
+        cipher.init(Cipher.ENCRYPT_MODE, keyEntry.certificate.publicKey)
+        val byteArrayOutputStream = ByteArrayOutputStream()
+        val outputStream = CipherOutputStream(byteArrayOutputStream, cipher)
+        outputStream.write(secretKey)
+        outputStream.close()
+        return byteArrayOutputStream.toByteArray()
+    }
+
+    /** Decrypts AES decoded key from preference using RSA private key  */
+    @Throws(GeneralSecurityException::class, IOException::class)
+    private fun decryptAESKey(encodedBytes: ByteArray): ByteArray {
+        val keyStore = KeyStore.getInstance(CryptUtil.KEY_STORE_ANDROID)
+        keyStore.load(null)
+        val keyEntry =
+            keyStore.getEntry(CryptUtil.KEY_ALIAS_AMAZE, null) as KeyStore.PrivateKeyEntry
+        val cipher = Cipher.getInstance(ALGO_RSA, "AndroidOpenSSL")
+        cipher.init(Cipher.DECRYPT_MODE, keyEntry.privateKey)
+        val byteArrayInputStream = ByteArrayInputStream(encodedBytes)
+        val inputStream = CipherInputStream(byteArrayInputStream, cipher)
+        val bytes = ArrayList<Byte>()
+        var nextByte: Int
+        while (inputStream.read().also { nextByte = it } != -1) {
+            bytes.add(nextByte.toByte())
+        }
+        val decryptedBytes = ByteArray(bytes.size)
+        for (i in bytes.indices) {
+            decryptedBytes[i] = bytes[i]
+        }
+        return decryptedBytes
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt
index 92a5215b9..54132f5aa 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/AbstractDeleteTaskTestBase.kt
@@ -35,7 +35,7 @@ import com.amaze.filemanager.R
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.shadows.ShadowSmbUtil
-import com.amaze.filemanager.test.ShadowCryptUtil
+import com.amaze.filemanager.test.ShadowPasswordUtil
 import com.amaze.filemanager.test.ShadowTabHandler
 import com.amaze.filemanager.test.TestUtils
 import com.amaze.filemanager.ui.activities.MainActivity
@@ -59,7 +59,7 @@ import org.robolectric.shadows.ShadowToast
         ShadowMultiDex::class,
         ShadowSmbUtil::class,
         ShadowTabHandler::class,
-        ShadowCryptUtil::class
+        ShadowPasswordUtil::class
     ],
     sdk = [JELLY_BEAN, KITKAT, P]
 )
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/DecryptServiceTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/DecryptServiceTest.kt
new file mode 100644
index 000000000..f298f9898
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/DecryptServiceTest.kt
@@ -0,0 +1,174 @@
+package com.amaze.filemanager.asynchronous.services
+
+import android.app.NotificationManager
+import android.content.Context
+import android.content.Intent
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.M
+import android.os.Build.VERSION_CODES.O
+import android.os.Build.VERSION_CODES.P
+import android.os.Environment
+import android.util.Log
+import androidx.test.core.app.ApplicationProvider
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.asynchronous.management.ServiceWatcherUtil
+import com.amaze.filemanager.asynchronous.services.DecryptService.NOTIFICATION_SERVICE
+import com.amaze.filemanager.asynchronous.services.DecryptService.START_NOT_STICKY
+import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_DECRYPT_PATH
+import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_SOURCE
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_PASSWORD
+import com.amaze.filemanager.filesystem.HybridFile
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.ui.notifications.NotificationConstants
+import com.amaze.filemanager.utils.AESCrypt
+import com.amaze.filemanager.utils.CryptUtilTest.Companion.initMockSecretKeygen
+import com.amaze.filemanager.utils.ProgressHandler
+import org.awaitility.Awaitility.await
+import org.junit.After
+import org.junit.Assert.assertArrayEquals
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.Robolectric
+import org.robolectric.Shadows.shadowOf
+import org.robolectric.annotation.Config
+import org.robolectric.shadows.ShadowNotificationManager
+import java.io.ByteArrayInputStream
+import java.io.File
+import java.io.FileOutputStream
+import java.util.concurrent.TimeUnit
+import kotlin.random.Random
+
+@RunWith(AndroidJUnit4::class)
+@Config(shadows = [ShadowMultiDex::class], sdk = [KITKAT, P])
+@Suppress("StringLiteralDuplication")
+class DecryptServiceTest {
+
+    private lateinit var source: ByteArray
+    private lateinit var service: DecryptService
+    private lateinit var notificationManager: ShadowNotificationManager
+
+    /**
+     * Test setup
+     */
+    @Before
+    fun setUp() {
+        source = Random(System.currentTimeMillis()).nextBytes(73)
+        service = Robolectric.setupService(DecryptService::class.java)
+        notificationManager = shadowOf(
+            ApplicationProvider.getApplicationContext<Context?>()
+                .getSystemService(NOTIFICATION_SERVICE) as NotificationManager
+        )
+        initMockSecretKeygen()
+    }
+
+    /**
+     * Post test cleanup
+     */
+    @After
+    fun tearDown() {
+        service.stopSelf()
+        service.onDestroy()
+    }
+
+    /**
+     * Test [DecryptService] on decrypting legacy encrypted files.
+     *
+     * No password guarding here - just the logic of [DecryptService] and [CryptUtil] itself.
+     */
+    @Test
+    fun testLegacyDecryptWorkflow() {
+        val sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+        ByteArrayInputStream(source).copyTo(FileOutputStream(sourceFile))
+        CryptUtil(
+            ApplicationProvider.getApplicationContext(),
+            HybridFileParcelable(sourceFile.absolutePath),
+            ProgressHandler(),
+            ArrayList<HybridFile>(),
+            "test.bin${CryptUtil.CRYPT_EXTENSION}",
+            false,
+            null
+        )
+        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.CRYPT_EXTENSION}")
+        assertTrue(targetFile.exists())
+        sourceFile.delete()
+
+        ServiceWatcherUtil.position = 0L
+        Intent(ApplicationProvider.getApplicationContext(), DecryptService::class.java).run {
+            putExtra(
+                TAG_SOURCE,
+                HybridFileParcelable(targetFile.absolutePath).also {
+                    it.size = targetFile.length()
+                }
+            )
+            putExtra(TAG_DECRYPT_PATH, Environment.getExternalStorageDirectory().absolutePath)
+            assertEquals(START_NOT_STICKY, service.onStartCommand(this, 0, 0))
+        }
+        assertTrue(notificationManager.activeNotifications.isNotEmpty())
+        notificationManager.activeNotifications.first().let {
+            assertEquals(NotificationConstants.DECRYPT_ID, it.id)
+            if (SDK_INT >= O)
+                assertEquals(NotificationConstants.CHANNEL_NORMAL_ID, it.notification.channelId)
+        }
+        val verifyFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+        await().atMost(1000, TimeUnit.SECONDS).until {
+            verifyFile.exists() && verifyFile.length() > 0
+        }
+        assertTrue(verifyFile.length() < targetFile.length())
+        assertArrayEquals(source, verifyFile.readBytes())
+    }
+
+    /**
+     * Test [DecryptService] on decrypting AESCrypt format files.
+     */
+    @Test
+    fun testAescryptWorkflow() {
+        if (SDK_INT >= M) {
+            val sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin${CryptUtil.AESCRYPT_EXTENSION}")
+            val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+            AESCrypt("passW0rD").encrypt(
+                `in` = ByteArrayInputStream(source),
+                out = FileOutputStream(sourceFile),
+                progressHandler = ProgressHandler()
+            )
+            await().atMost(10, TimeUnit.SECONDS).until {
+                sourceFile.length() > source.size
+            }
+            ServiceWatcherUtil.position = 0L
+            Intent(ApplicationProvider.getApplicationContext(), DecryptService::class.java).run {
+                putExtra(
+                    TAG_SOURCE,
+                    HybridFileParcelable(sourceFile.absolutePath).also {
+                        it.size = sourceFile.length()
+                    }
+                )
+                putExtra(TAG_DECRYPT_PATH, Environment.getExternalStorageDirectory().absolutePath)
+                putExtra(TAG_PASSWORD, "passW0rD")
+                assertEquals(START_NOT_STICKY, service.onStartCommand(this, 0, 0))
+            }
+            assertTrue(notificationManager.activeNotifications.isNotEmpty())
+            notificationManager.activeNotifications.first().let {
+                assertEquals(NotificationConstants.DECRYPT_ID, it.id)
+                assertEquals(NotificationConstants.CHANNEL_NORMAL_ID, it.notification.channelId)
+            }
+            await().atMost(10000, TimeUnit.SECONDS).until {
+                targetFile.exists() && targetFile.length() > 0
+            }
+            assertTrue(targetFile.exists() && targetFile.length() > 0)
+            assertTrue(targetFile.length() < sourceFile.length())
+            assertArrayEquals(source, targetFile.readBytes())
+            /* [FIXME] in this test notification is not cleared, but when test on device
+             * the notification did cleared
+             */
+            // assertTrue(notificationManager.activeNotifications.isEmpty())
+            targetFile.delete()
+        } else {
+            Log.w(javaClass.simpleName, "Test skipped for $SDK_INT")
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/EncryptServiceTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/EncryptServiceTest.kt
new file mode 100644
index 000000000..3839c7edb
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/EncryptServiceTest.kt
@@ -0,0 +1,177 @@
+package com.amaze.filemanager.asynchronous.services
+
+import android.app.NotificationManager
+import android.content.Context
+import android.content.Intent
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.M
+import android.os.Build.VERSION_CODES.P
+import android.os.Environment
+import android.util.Log
+import androidx.test.core.app.ApplicationProvider
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.asynchronous.services.EncryptService.NOTIFICATION_SERVICE
+import com.amaze.filemanager.asynchronous.services.EncryptService.START_NOT_STICKY
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_AESCRYPT
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_ENCRYPT_TARGET
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_PASSWORD
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_SOURCE
+import com.amaze.filemanager.filesystem.HybridFile
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.ui.notifications.NotificationConstants
+import com.amaze.filemanager.utils.AESCrypt
+import com.amaze.filemanager.utils.CryptUtilTest.Companion.initMockSecretKeygen
+import com.amaze.filemanager.utils.ProgressHandler
+import org.awaitility.Awaitility.await
+import org.junit.After
+import org.junit.Assert.assertArrayEquals
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.Robolectric
+import org.robolectric.Shadows.shadowOf
+import org.robolectric.annotation.Config
+import org.robolectric.shadows.ShadowNotificationManager
+import java.io.ByteArrayInputStream
+import java.io.ByteArrayOutputStream
+import java.io.File
+import java.io.FileInputStream
+import java.io.FileOutputStream
+import java.util.concurrent.TimeUnit
+import kotlin.random.Random
+
+@RunWith(AndroidJUnit4::class)
+@Config(shadows = [ShadowMultiDex::class], sdk = [JELLY_BEAN, KITKAT, P])
+class EncryptServiceTest {
+
+    private lateinit var service: EncryptService
+    private lateinit var notificationManager: ShadowNotificationManager
+    private lateinit var source: ByteArray
+    private lateinit var sourceFile: File
+    private lateinit var targetFilename: String
+    private lateinit var targetFile: File
+
+    /**
+     * Test setup
+     */
+    @Before
+    fun setUp() {
+        service = Robolectric.setupService(EncryptService::class.java)
+        notificationManager = shadowOf(
+            ApplicationProvider.getApplicationContext<Context?>()
+                .getSystemService(NOTIFICATION_SERVICE) as NotificationManager
+        )
+        source = Random(System.currentTimeMillis()).nextBytes(73)
+        sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+        ByteArrayInputStream(source).copyTo(FileOutputStream(sourceFile))
+        initMockSecretKeygen()
+    }
+
+    /**
+     * Post test cleanup
+     */
+    @After
+    fun tearDown() {
+        service.stopSelf()
+        service.onDestroy()
+        if (sourceFile.exists()) sourceFile.delete()
+    }
+
+    /**
+     * Test [EncryptService] to encrypt files using legacy method.
+     *
+     * No password guarding here - just the logic of [EncryptService] and [CryptUtil] itself.
+     */
+    @Test
+    fun testLegacyEncryptWorkflow() {
+        targetFilename = "test.bin${CryptUtil.CRYPT_EXTENSION}"
+        targetFile = File(Environment.getExternalStorageDirectory(), targetFilename)
+        Intent(ApplicationProvider.getApplicationContext(), EncryptService::class.java)
+            .putExtra(TAG_SOURCE, HybridFileParcelable(sourceFile.absolutePath))
+            .putExtra(TAG_ENCRYPT_TARGET, targetFilename)
+            .putExtra(TAG_AESCRYPT, false).run {
+                assertEquals(START_NOT_STICKY, service.onStartCommand(this, 0, 0))
+            }
+        if (SDK_INT < M) {
+            assertTrue(notificationManager.allNotifications.isNotEmpty())
+            await().atMost(100, TimeUnit.SECONDS).until {
+                targetFile.length() > 0 && notificationManager.allNotifications.isEmpty()
+            }
+        } else {
+            assertTrue(notificationManager.activeNotifications.isNotEmpty())
+            notificationManager.activeNotifications.first().let {
+                assertEquals(NotificationConstants.ENCRYPT_ID, it.id)
+                assertEquals(NotificationConstants.CHANNEL_NORMAL_ID, it.notification.channelId)
+            }
+            await().atMost(10, TimeUnit.SECONDS).until {
+                targetFile.length() > 0 && notificationManager.activeNotifications.isEmpty()
+            }
+        }
+        sourceFile.delete()
+        CryptUtil(
+            ApplicationProvider.getApplicationContext(),
+            HybridFileParcelable(targetFile.absolutePath),
+            Environment.getExternalStorageDirectory().absolutePath,
+            ProgressHandler(),
+            ArrayList<HybridFile>(),
+            null
+        )
+        val verifyFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+        await().atMost(10, TimeUnit.SECONDS).until {
+            verifyFile.exists() && verifyFile.length() > 0
+        }
+        assertArrayEquals(source, verifyFile.readBytes())
+        targetFile.delete()
+    }
+
+    /**
+     * Test [EncryptService] on encrypting files using AESCrypt format.
+     *
+     * @see AESCrypt.encrypt
+     */
+    @Test
+    fun testAescryptWorkflow() {
+        if (SDK_INT >= M) {
+            targetFilename = "test.bin${CryptUtil.AESCRYPT_EXTENSION}"
+            targetFile = File(Environment.getExternalStorageDirectory(), targetFilename)
+            Intent(ApplicationProvider.getApplicationContext(), EncryptService::class.java)
+                .putExtra(TAG_SOURCE, HybridFileParcelable(sourceFile.absolutePath))
+                .putExtra(TAG_ENCRYPT_TARGET, targetFilename)
+                .putExtra(TAG_AESCRYPT, true)
+                .putExtra(TAG_PASSWORD, "passW0rD").run {
+                    assertEquals(START_NOT_STICKY, service.onStartCommand(this, 0, 0))
+                }
+            assertTrue(notificationManager.activeNotifications.isNotEmpty())
+            notificationManager.activeNotifications.first().let {
+                assertEquals(NotificationConstants.ENCRYPT_ID, it.id)
+                assertEquals(NotificationConstants.CHANNEL_NORMAL_ID, it.notification.channelId)
+            }
+            await().atMost(10, TimeUnit.SECONDS).until {
+                targetFile.length() > 0 && notificationManager.activeNotifications.isEmpty()
+            }
+            assertTrue(targetFile.length() > sourceFile.length())
+            assertFalse(
+                source.contentEquals(
+                    File(
+                        Environment.getExternalStorageDirectory(),
+                        targetFilename
+                    ).readBytes()
+                )
+            )
+            val verify = ByteArrayOutputStream()
+            AESCrypt("passW0rD").decrypt(targetFile.length(), FileInputStream(targetFile), verify)
+            assertEquals(source.size, verify.size())
+            assertArrayEquals(source, verify.toByteArray())
+            targetFile.delete()
+        } else {
+            Log.w(javaClass.simpleName, "Test skipped for $SDK_INT")
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt
index 3573274b7..db16c18aa 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/services/ExtractServiceTest.kt
@@ -112,7 +112,7 @@ class ExtractServiceTest {
         }
     }
 
-    private var service: ExtractService? = null
+    private lateinit var service: ExtractService
 
     /**
      * Copy archives to storage.
@@ -175,8 +175,8 @@ class ExtractServiceTest {
                 .map { obj: Path -> obj.toFile() }
                 .forEach { obj: File -> obj.delete() }
         }
-        service?.stopSelf()
-        service?.onDestroy()
+        service.stopSelf()
+        service.onDestroy()
     }
 
     /**
@@ -435,6 +435,6 @@ class ExtractServiceTest {
                 File(Environment.getExternalStorageDirectory(), "test-archive")
                     .absolutePath
             )
-        service!!.onStartCommand(intent, 0, 0)
+        service.onStartCommand(intent, 0, 0)
     }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java b/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java
index 4b9f958a5..e9d1ff037 100644
--- a/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java
+++ b/app/src/test/java/com/amaze/filemanager/database/ExplorerDatabaseMigrationTest.java
@@ -46,7 +46,7 @@ import org.robolectric.annotation.Config;
 import com.amaze.filemanager.database.models.explorer.CloudEntry;
 import com.amaze.filemanager.file_operations.filesystem.OpenMode;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
-import com.amaze.filemanager.test.ShadowCryptUtil;
+import com.amaze.filemanager.test.ShadowPasswordUtil;
 
 import androidx.room.Room;
 import androidx.sqlite.db.SupportSQLiteDatabase;
@@ -58,7 +58,7 @@ import io.reactivex.schedulers.Schedulers;
 
 @RunWith(AndroidJUnit4.class)
 @Config(
-    shadows = {ShadowMultiDex.class, ShadowCryptUtil.class},
+    shadows = {ShadowMultiDex.class, ShadowPasswordUtil.class},
     sdk = {JELLY_BEAN, KITKAT, P})
 public class ExplorerDatabaseMigrationTest {
 
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt b/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt
index 90a2aec3d..23239b9ac 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/AbstractOperationsTestBase.kt
@@ -34,7 +34,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.amaze.filemanager.file_operations.filesystem.OpenMode
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import com.amaze.filemanager.shadows.ShadowSmbUtil
-import com.amaze.filemanager.test.ShadowCryptUtil
+import com.amaze.filemanager.test.ShadowPasswordUtil
 import com.amaze.filemanager.test.ShadowTabHandler
 import com.amaze.filemanager.test.TestUtils
 import com.amaze.filemanager.ui.activities.MainActivity
@@ -59,7 +59,7 @@ import org.robolectric.shadows.ShadowSQLiteConnection
         ShadowSmbUtil::class,
         ShadowMultiDex::class,
         ShadowTabHandler::class,
-        ShadowCryptUtil::class
+        ShadowPasswordUtil::class
     ],
     sdk = [JELLY_BEAN, KITKAT, P]
 )
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
index f3b6df862..3f0db6bbe 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
@@ -50,7 +50,7 @@ import org.robolectric.shadows.ShadowSQLiteConnection;
 
 import com.amaze.filemanager.filesystem.ssh.test.TestUtils;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
-import com.amaze.filemanager.test.ShadowCryptUtil;
+import com.amaze.filemanager.test.ShadowPasswordUtil;
 import com.amaze.filemanager.utils.Utils;
 
 import androidx.annotation.NonNull;
@@ -68,7 +68,7 @@ import net.schmizz.sshj.userauth.keyprovider.KeyProvider;
 
 @RunWith(AndroidJUnit4.class)
 @Config(
-    shadows = {ShadowMultiDex.class, ShadowCryptUtil.class},
+    shadows = {ShadowMultiDex.class, ShadowPasswordUtil.class},
     sdk = {JELLY_BEAN, KITKAT, P})
 public class SshConnectionPoolTest {
 
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt
index ff494d144..7573849c5 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshHybridFileTest.kt
@@ -30,7 +30,7 @@ import com.amaze.filemanager.file_operations.filesystem.OpenMode
 import com.amaze.filemanager.filesystem.HybridFile
 import com.amaze.filemanager.filesystem.ssh.test.MockSshConnectionPools
 import com.amaze.filemanager.shadows.ShadowMultiDex
-import com.amaze.filemanager.test.ShadowCryptUtil
+import com.amaze.filemanager.test.ShadowPasswordUtil
 import io.reactivex.android.plugins.RxAndroidPlugins
 import io.reactivex.plugins.RxJavaPlugins
 import io.reactivex.schedulers.Schedulers
@@ -45,7 +45,7 @@ import org.robolectric.annotation.LooperMode
 @RunWith(AndroidJUnit4::class)
 @LooperMode(LooperMode.Mode.PAUSED)
 @Config(
-    shadows = [ShadowMultiDex::class, ShadowCryptUtil::class],
+    shadows = [ShadowMultiDex::class, ShadowPasswordUtil::class],
     sdk = [JELLY_BEAN, KITKAT, P]
 )
 class SshHybridFileTest {
diff --git a/app/src/test/java/com/amaze/filemanager/test/ShadowCryptUtil.java b/app/src/test/java/com/amaze/filemanager/test/ShadowCryptUtil.java
deleted file mode 100644
index a0fc94784..000000000
--- a/app/src/test/java/com/amaze/filemanager/test/ShadowCryptUtil.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.test;
-
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-
-import javax.crypto.Cipher;
-import javax.crypto.KeyGenerator;
-import javax.crypto.SecretKey;
-import javax.crypto.spec.GCMParameterSpec;
-
-import org.robolectric.annotation.Implementation;
-import org.robolectric.annotation.Implements;
-
-import com.amaze.filemanager.filesystem.files.CryptUtil;
-
-import android.content.Context;
-import android.util.Base64;
-
-@Implements(CryptUtil.class)
-public class ShadowCryptUtil {
-
-  private static final String ALGO_AES = "AES/GCM/NoPadding";
-  private static final String IV = "LxbHiJhhUXcj"; // 12 byte long IV supported by android for GCM
-
-  private static SecretKey secretKey = null;
-
-  static {
-    try {
-      KeyGenerator keyGen = KeyGenerator.getInstance("AES");
-      keyGen.init(128);
-      secretKey = keyGen.generateKey();
-    } catch (GeneralSecurityException e) {
-      e.printStackTrace();
-    }
-  }
-
-  /** Method handles encryption of plain text on various APIs */
-  @Implementation
-  public static String encryptPassword(Context context, String plainText)
-      throws GeneralSecurityException, IOException {
-    return aesEncryptPassword(plainText);
-  }
-
-  /** Method handles decryption of cipher text on various APIs */
-  @Implementation
-  public static String decryptPassword(Context context, String cipherText)
-      throws GeneralSecurityException, IOException {
-    return aesDecryptPassword(cipherText);
-  }
-
-  /** Helper method to encrypt plain text password */
-  private static String aesEncryptPassword(String plainTextPassword)
-      throws GeneralSecurityException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-    cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmParameterSpec);
-    byte[] encodedBytes = cipher.doFinal(plainTextPassword.getBytes());
-
-    return Base64.encodeToString(encodedBytes, Base64.DEFAULT);
-  }
-
-  /** Helper method to decrypt cipher text password */
-  private static String aesDecryptPassword(String cipherPassword) throws GeneralSecurityException {
-
-    Cipher cipher = Cipher.getInstance(ALGO_AES);
-    GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-    cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec);
-    byte[] decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, Base64.DEFAULT));
-
-    return new String(decryptedBytes);
-  }
-}
diff --git a/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtil.kt b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtil.kt
new file mode 100644
index 000000000..0a7154870
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtil.kt
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.test
+
+import android.content.Context
+import android.util.Base64
+import com.amaze.filemanager.utils.PasswordUtil
+import org.robolectric.annotation.Implementation
+import org.robolectric.annotation.Implements
+import java.io.IOException
+import java.security.GeneralSecurityException
+import javax.crypto.Cipher
+import javax.crypto.KeyGenerator
+import javax.crypto.SecretKey
+import javax.crypto.spec.GCMParameterSpec
+
+@Implements(PasswordUtil::class)
+class ShadowPasswordUtil {
+
+    companion object {
+        val INSTANCE = ShadowPasswordUtil()
+        private const val ALGO_AES = "AES/GCM/NoPadding"
+        private const val IV = "LxbHiJhhUXcj" // 12 byte long IV supported by android for GCM
+    }
+
+    private var secretKey: SecretKey
+
+    /** Method handles encryption of plain text on various APIs  */
+    @Implementation
+    @Throws(GeneralSecurityException::class, IOException::class)
+    fun encryptPassword(context: Context?, plainText: String): String {
+        return aesEncryptPassword(plainText)
+    }
+
+    /** Method handles decryption of cipher text on various APIs  */
+    @Implementation
+    @Throws(GeneralSecurityException::class, IOException::class)
+    fun decryptPassword(context: Context?, cipherText: String): String {
+        return aesDecryptPassword(cipherText)
+    }
+
+    /** Helper method to encrypt plain text password  */
+    @Throws(GeneralSecurityException::class)
+    private fun aesEncryptPassword(plainTextPassword: String): String {
+        val cipher = Cipher.getInstance(ALGO_AES)
+        val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
+        cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmParameterSpec)
+        val encodedBytes = cipher.doFinal(plainTextPassword.toByteArray())
+        return Base64.encodeToString(encodedBytes, Base64.DEFAULT)
+    }
+
+    /** Helper method to decrypt cipher text password  */
+    @Throws(GeneralSecurityException::class)
+    private fun aesDecryptPassword(cipherPassword: String): String {
+        val cipher = Cipher.getInstance(ALGO_AES)
+        val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
+        cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec)
+        val decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, Base64.DEFAULT))
+        return String(decryptedBytes)
+    }
+
+    init {
+        val keyGen = KeyGenerator.getInstance("AES")
+        keyGen.init(128)
+        secretKey = keyGen.generateKey()
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/test/ShadowCryptUtilTest.java b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtilTest.java
similarity index 89%
rename from app/src/test/java/com/amaze/filemanager/test/ShadowCryptUtilTest.java
rename to app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtilTest.java
index 710b82c9e..715cf7d6c 100644
--- a/app/src/test/java/com/amaze/filemanager/test/ShadowCryptUtilTest.java
+++ b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtilTest.java
@@ -40,9 +40,9 @@ import org.robolectric.shadows.ShadowSQLiteConnection;
 import com.amaze.filemanager.database.UtilitiesDatabase;
 import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.database.models.OperationData;
-import com.amaze.filemanager.filesystem.files.CryptUtil;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
+import com.amaze.filemanager.utils.PasswordUtil;
 
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -53,9 +53,9 @@ import io.reactivex.schedulers.Schedulers;
 
 @RunWith(AndroidJUnit4.class)
 @Config(
-    shadows = {ShadowMultiDex.class, ShadowCryptUtil.class},
+    shadows = {ShadowMultiDex.class, ShadowPasswordUtil.class},
     sdk = {JELLY_BEAN, KITKAT, P})
-public class ShadowCryptUtilTest {
+public class ShadowPasswordUtilTest {
 
   @Before
   public void setUp() {
@@ -73,9 +73,12 @@ public class ShadowCryptUtilTest {
   @Test
   public void testEncryptDecrypt() throws GeneralSecurityException, IOException {
     String text = "test";
-    String encrypted = CryptUtil.encryptPassword(ApplicationProvider.getApplicationContext(), text);
+    String encrypted =
+        PasswordUtil.INSTANCE.encryptPassword(ApplicationProvider.getApplicationContext(), text);
     assertEquals(
-        text, CryptUtil.decryptPassword(ApplicationProvider.getApplicationContext(), encrypted));
+        text,
+        PasswordUtil.INSTANCE.decryptPassword(
+            ApplicationProvider.getApplicationContext(), encrypted));
   }
 
   @Test
diff --git a/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt b/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt
index d54cab986..029cb2be7 100644
--- a/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt
+++ b/app/src/test/java/com/amaze/filemanager/test/TestUtils.kt
@@ -27,7 +27,9 @@ import android.os.Parcel
 import android.os.UserHandle
 import android.os.storage.StorageManager
 import android.os.storage.StorageVolume
+import androidx.annotation.StringRes
 import androidx.test.core.app.ApplicationProvider
+import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.filesystem.compressed.CompressedHelper
 import org.robolectric.Shadows
 import java.lang.reflect.Field
@@ -59,6 +61,13 @@ fun supportedArchiveExtensions(): List<String> {
     }
 }
 
+/**
+ * Helper method to get specified string from resources.
+ *
+ * @param id String resource ID
+ */
+fun getString(@StringRes id: Int) = AppConfig.getInstance().getString(id)
+
 object TestUtils {
     /**
      * Populate "internal device storage" to StorageManager with directory as provided by Robolectric.
diff --git a/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java b/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
index bf77f4aad..1541c3c18 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
+++ b/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
@@ -58,7 +58,7 @@ import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 import com.amaze.filemanager.shadows.jcifs.smb.ShadowSmbFile;
-import com.amaze.filemanager.test.ShadowCryptUtil;
+import com.amaze.filemanager.test.ShadowPasswordUtil;
 import com.amaze.filemanager.test.TestUtils;
 import com.amaze.filemanager.ui.dialogs.SftpConnectDialog;
 import com.amaze.filemanager.utils.SmbUtil;
@@ -82,7 +82,7 @@ import io.reactivex.schedulers.Schedulers;
     shadows = {
       ShadowMultiDex.class,
       ShadowStorageManager.class,
-      ShadowCryptUtil.class,
+      ShadowPasswordUtil.class,
       ShadowSmbFile.class
     })
 /*
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/AbstractEncryptDialogTests.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/AbstractEncryptDialogTests.kt
new file mode 100644
index 000000000..032c93e90
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/AbstractEncryptDialogTests.kt
@@ -0,0 +1,46 @@
+package com.amaze.filemanager.ui.dialogs
+
+import android.os.Build.VERSION.SDK_INT
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.N
+import android.os.Build.VERSION_CODES.P
+import androidx.lifecycle.Lifecycle
+import androidx.test.core.app.ActivityScenario
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.test.ShadowTabHandler
+import com.amaze.filemanager.test.TestUtils.initializeInternalStorage
+import com.amaze.filemanager.ui.activities.MainActivity
+import org.junit.After
+import org.junit.Before
+import org.junit.runner.RunWith
+import org.robolectric.annotation.Config
+
+/**
+ * Base class for various tests related to file encryption.
+ */
+@RunWith(AndroidJUnit4::class)
+@Config(shadows = [ShadowMultiDex::class, ShadowTabHandler::class], sdk = [JELLY_BEAN, KITKAT, P])
+abstract class AbstractEncryptDialogTests {
+
+    protected lateinit var scenario: ActivityScenario<MainActivity>
+
+    /**
+     * MainActivity setup.
+     */
+    @Before
+    open fun setUp() {
+        if (SDK_INT >= N) initializeInternalStorage()
+        scenario = ActivityScenario.launch(MainActivity::class.java)
+        scenario.moveToState(Lifecycle.State.STARTED)
+    }
+
+    /**
+     * Post test cleanup.
+     */
+    @After
+    open fun tearDown() {
+        scenario.close()
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialogTest.kt
new file mode 100644
index 000000000..e869e893e
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/DecryptFingerprintDialogTest.kt
@@ -0,0 +1,150 @@
+package com.amaze.filemanager.ui.dialogs
+
+import android.Manifest.permission.USE_FINGERPRINT
+import android.content.Intent
+import android.hardware.fingerprint.FingerprintManager
+import android.os.Build.VERSION_CODES.M
+import android.os.Build.VERSION_CODES.P
+import android.os.Environment
+import androidx.annotation.RequiresApi
+import com.afollestad.materialdialogs.MaterialDialog
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_DECRYPT_PATH
+import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_OPEN_MODE
+import com.amaze.filemanager.asynchronous.services.DecryptService.TAG_SOURCE
+import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.RandomPathGenerator
+import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
+import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.test.ShadowTabHandler
+import com.amaze.filemanager.utils.security.SecretKeygen
+import io.mockk.every
+import io.mockk.mockkObject
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Before
+import org.junit.Test
+import org.robolectric.Shadows.shadowOf
+import org.robolectric.annotation.Config
+import org.robolectric.shadows.ShadowDialog
+import org.robolectric.shadows.ShadowFingerprintManager
+import java.io.File
+import javax.crypto.spec.SecretKeySpec
+import kotlin.random.Random
+
+/**
+ * Unit test for [DecryptFingerprintDialog].
+ */
+@Config(
+    shadows = [ShadowMultiDex::class, ShadowTabHandler::class, ShadowFingerprintManager::class],
+    sdk = [P]
+)
+class DecryptFingerprintDialogTest : AbstractEncryptDialogTests() {
+
+    private lateinit var file: File
+
+    /**
+     * MainActivity setup.
+     */
+    @Before
+    override fun setUp() {
+        super.setUp()
+        file = File(
+            Environment.getExternalStorageDirectory(),
+            RandomPathGenerator.generateRandomPath(
+                randomizer, 16
+            ) + CRYPT_EXTENSION
+        )
+        initMockSecretKeygen()
+        shadowOf(AppConfig.getInstance()).grantPermissions(USE_FINGERPRINT)
+    }
+
+    /**
+     * Test fingerprint authentication success scenario.
+     */
+    @Test
+    @RequiresApi(M)
+    fun testDecryptFingerprintDialogSuccess() {
+        performTest(
+            testContent = {
+                shadowOf(
+                    AppConfig.getInstance().getSystemService(FingerprintManager::class.java)
+                ).run {
+                    setDefaultFingerprints(1)
+                    setIsHardwareDetected(true)
+                    authenticationSucceeds()
+                }
+            },
+            callback = object : EncryptDecryptUtils.DecryptButtonCallbackInterface {
+                override fun confirm(intent: Intent) = assertTrue(true)
+                override fun failed() = fail("Should never called")
+            }
+        )
+    }
+
+    /**
+     * Test fingerprint authentication failure scenario.
+     */
+    @Test
+    @RequiresApi(M)
+    fun testDecryptFingerprintDialogFailed() {
+        performTest(
+            testContent = {
+                shadowOf(
+                    AppConfig.getInstance().getSystemService(FingerprintManager::class.java)
+                ).run {
+                    setDefaultFingerprints(1)
+                    setIsHardwareDetected(true)
+                    authenticationFails()
+                }
+            },
+            callback = object : EncryptDecryptUtils.DecryptButtonCallbackInterface {
+                override fun confirm(intent: Intent) = fail("Should never called")
+                override fun failed() = assertTrue(true)
+            }
+        )
+    }
+
+    private fun performTest(
+        testContent: () -> Unit,
+        callback: EncryptDecryptUtils.DecryptButtonCallbackInterface =
+            object : EncryptDecryptUtils.DecryptButtonCallbackInterface {}
+    ) {
+        scenario.onActivity { activity ->
+            DecryptFingerprintDialog.show(
+                activity,
+                activity,
+                Intent().putExtra(TAG_SOURCE, HybridFileParcelable(file.absolutePath))
+                    .putExtra(TAG_OPEN_MODE, OpenMode.FILE)
+                    .putExtra(
+                        TAG_DECRYPT_PATH,
+                        Environment.getExternalStorageDirectory().absolutePath
+                    ),
+                activity.appTheme,
+                callback
+            )
+            ShadowDialog.getLatestDialog()?.run {
+                assertTrue(this is MaterialDialog)
+                (this as MaterialDialog).let {
+                    testContent.invoke()
+                }
+            }
+        }
+    }
+
+    companion object {
+
+        private val randomizer = Random(System.currentTimeMillis())
+        private val key = SecretKeySpec(randomizer.nextBytes(16), "AES")
+
+        /**
+         * Mock [SecretKeygen] since Robolectric does not have AndroidKeyStore.
+         */
+        fun initMockSecretKeygen() {
+            mockkObject(SecretKeygen)
+            every { SecretKeygen.getSecretKey() } returns key
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialogTest.kt
new file mode 100644
index 000000000..d70925578
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptAuthenticateDialogTest.kt
@@ -0,0 +1,292 @@
+package com.amaze.filemanager.ui.dialogs
+
+import android.content.Intent
+import android.os.Environment
+import androidx.appcompat.widget.AppCompatCheckBox
+import androidx.preference.PreferenceManager
+import com.afollestad.materialdialogs.DialogAction
+import com.afollestad.materialdialogs.MaterialDialog
+import com.afollestad.materialdialogs.internal.MDButton
+import com.amaze.filemanager.R
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_AESCRYPT
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_ENCRYPT_TARGET
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_OPEN_MODE
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_SOURCE
+import com.amaze.filemanager.file_operations.filesystem.OpenMode
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.RandomPathGenerator
+import com.amaze.filemanager.filesystem.files.CryptUtil.AESCRYPT_EXTENSION
+import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
+import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils
+import com.amaze.filemanager.test.getString
+import com.amaze.filemanager.ui.activities.MainActivity
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.views.WarnableTextInputLayout
+import com.google.android.material.textfield.TextInputEditText
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Before
+import org.junit.Test
+import org.robolectric.shadows.ShadowDialog
+import java.io.File
+import kotlin.random.Random
+
+/**
+ * Logic test for [EncryptAuthenticateDialog].
+ */
+class EncryptAuthenticateDialogTest : AbstractEncryptDialogTests() {
+
+    private val randomizer = Random(System.currentTimeMillis())
+    private lateinit var file: File
+    private lateinit var tilFileSaveAs: WarnableTextInputLayout
+    private lateinit var tilEncryptPassword: WarnableTextInputLayout
+    private lateinit var tilEncryptPasswordConfirm: WarnableTextInputLayout
+    private lateinit var editTextFileSaveAs: TextInputEditText
+    private lateinit var editTextEncryptPassword: TextInputEditText
+    private lateinit var editTextEncryptPasswordConfirm: TextInputEditText
+    private lateinit var checkboxUseAze: AppCompatCheckBox
+    private lateinit var okButton: MDButton
+
+    /**
+     * MainActivity setup.
+     */
+    @Before
+    override fun setUp() {
+        super.setUp()
+        file = File(
+            Environment.getExternalStorageDirectory(),
+            RandomPathGenerator.generateRandomPath(
+                randomizer, 16
+            )
+        )
+    }
+
+    /**
+     * Test simple workflow. Just enter a password and off it go.
+     */
+    @Test
+    @Suppress("StringLiteralDuplication")
+    fun testSimpleWorkflow() {
+        performTest(
+            { _, _, _ ->
+                assertEquals("${file.name}$AESCRYPT_EXTENSION", editTextFileSaveAs.text.toString())
+                editTextEncryptPassword.setText("abcdefgh")
+                editTextEncryptPasswordConfirm.setText("abcdefgh")
+                assertTrue(okButton.isEnabled)
+                okButton.performClick()
+            },
+            object : EncryptDecryptUtils.EncryptButtonCallbackInterface {
+                override fun onButtonPressed(intent: Intent, password: String) {
+                    assertEquals(file.absolutePath, intent.getStringExtra(TAG_SOURCE))
+                    assertTrue(intent.getBooleanExtra(TAG_AESCRYPT, false))
+                    assertEquals(
+                        "${file.name}$AESCRYPT_EXTENSION",
+                        intent.getStringExtra(TAG_ENCRYPT_TARGET)
+                    )
+                    assertEquals("abcdefgh", password)
+                }
+            }
+        )
+    }
+
+    /**
+     * Test simple workflow with aze encryption checkbox checked. Also renamed target filename
+     */
+    @Test
+    fun testAzeWorkflow() {
+        performTest(
+            { _, _, _ ->
+                assertEquals("${file.name}$AESCRYPT_EXTENSION", editTextFileSaveAs.text.toString())
+                editTextEncryptPassword.setText("abcdefgh")
+                editTextEncryptPasswordConfirm.setText("abcdefgh")
+                assertTrue(okButton.isEnabled)
+                checkboxUseAze.isChecked = true
+                assertEquals("${file.name}$CRYPT_EXTENSION", editTextFileSaveAs.text.toString())
+                editTextFileSaveAs.setText("testfile$CRYPT_EXTENSION")
+                okButton.performClick()
+            },
+            object : EncryptDecryptUtils.EncryptButtonCallbackInterface {
+                override fun onButtonPressed(intent: Intent, password: String) {
+                    assertEquals(file.absolutePath, intent.getStringExtra(TAG_SOURCE))
+                    assertFalse(intent.getBooleanExtra(TAG_AESCRYPT, true))
+                    assertEquals(
+                        "testfile$CRYPT_EXTENSION",
+                        intent.getStringExtra(TAG_ENCRYPT_TARGET)
+                    )
+                    assertEquals("abcdefgh", password)
+                }
+            }
+        )
+    }
+
+    /**
+     * Test password field validation.
+     */
+    @Test
+    fun testPasswordValidations() {
+        performTest({ _, _, _ ->
+            editTextEncryptPassword.setText("abc")
+            editTextEncryptPasswordConfirm.setText("def")
+            assertFalse(okButton.isEnabled)
+            assertEquals(
+                getString(R.string.password_no_match),
+                tilEncryptPasswordConfirm.error
+            )
+            editTextEncryptPassword.setText("")
+            editTextEncryptPasswordConfirm.setText("")
+            assertFalse(okButton.isEnabled)
+            assertEquals(getString(R.string.field_empty), tilEncryptPassword.error)
+            editTextEncryptPassword.setText("abcdef")
+            editTextEncryptPasswordConfirm.setText("abcdef")
+            assertTrue(okButton.isEnabled)
+        })
+    }
+
+    /**
+     * Test filename field validations.
+     */
+    @Test
+    fun testFilenameValidations() {
+        performTest({ _, _, _ ->
+            editTextFileSaveAs.setText("${file.name}.error")
+            assertFalse(okButton.isEnabled)
+            assertEquals(
+                getString(R.string.encrypt_file_must_end_with_aes),
+                tilFileSaveAs.error
+            )
+            editTextFileSaveAs.setText("${file.name}.aze")
+            assertFalse(okButton.isEnabled)
+            assertEquals(
+                getString(R.string.encrypt_file_must_end_with_aes),
+                tilFileSaveAs.error
+            )
+            checkboxUseAze.isChecked = true
+            assertTrue(okButton.isEnabled)
+            assertNull(tilFileSaveAs.error)
+            editTextFileSaveAs.setText("${file.name}.error")
+            assertFalse(okButton.isEnabled)
+            assertEquals(
+                getString(R.string.encrypt_file_must_end_with_aze),
+                tilFileSaveAs.error
+            )
+            editTextFileSaveAs.setText("${file.name}.aes")
+            assertFalse(okButton.isEnabled)
+            assertEquals(
+                getString(R.string.encrypt_file_must_end_with_aze),
+                tilFileSaveAs.error
+            )
+            editTextFileSaveAs.setText("${file.name}.aze")
+            assertTrue(okButton.isEnabled)
+            assertNull(tilFileSaveAs.error)
+        })
+    }
+
+    /**
+     * To test how would Amaze legacy encryption dialog pops up.
+     */
+    @Test
+    fun testAzeCryptDialog() {
+        performTest({ _, _, _ ->
+            checkboxUseAze.isChecked = true
+            assertTrue(ShadowDialog.getShownDialogs().size == 2)
+            assertTrue(ShadowDialog.getLatestDialog() is MaterialDialog)
+            (ShadowDialog.getLatestDialog() as MaterialDialog).run {
+                assertEquals(getString(R.string.warning), titleView.text)
+                assertEquals(getString(R.string.crypt_warning_key), contentView?.text.toString())
+                assertEquals(
+                    getString(R.string.warning_never_show),
+                    getActionButton(DialogAction.NEGATIVE).text
+                )
+                assertEquals(
+                    getString(R.string.warning_confirm),
+                    getActionButton(DialogAction.POSITIVE).text
+                )
+                assertTrue(getActionButton(DialogAction.POSITIVE).performClick())
+            }
+            assertEquals(2, ShadowDialog.getShownDialogs().size)
+            assertFalse(ShadowDialog.getLatestDialog().isShowing)
+            assertTrue(true == editTextFileSaveAs.text?.endsWith(CRYPT_EXTENSION))
+            checkboxUseAze.isChecked = false
+            assertEquals(2, ShadowDialog.getShownDialogs().size)
+            assertFalse(ShadowDialog.getLatestDialog().isShowing)
+            assertTrue(true == editTextFileSaveAs.text?.endsWith(AESCRYPT_EXTENSION))
+            checkboxUseAze.isChecked = true
+            assertEquals(3, ShadowDialog.getShownDialogs().size)
+            assertTrue(ShadowDialog.getLatestDialog().isShowing)
+            assertTrue(true == editTextFileSaveAs.text?.endsWith(CRYPT_EXTENSION))
+            (ShadowDialog.getLatestDialog() as MaterialDialog)
+                .getActionButton(DialogAction.NEGATIVE).performClick()
+            assertEquals(3, ShadowDialog.getShownDialogs().size)
+            assertFalse(ShadowDialog.getLatestDialog().isShowing)
+            assertTrue(
+                PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+                    .getBoolean(PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER, false)
+            )
+            checkboxUseAze.isChecked = false
+            assertEquals(3, ShadowDialog.getShownDialogs().size) // no new dialog
+            checkboxUseAze.isChecked = true
+            assertEquals(3, ShadowDialog.getShownDialogs().size)
+        })
+    }
+
+    /**
+     * prepare MainActivity scenario. Also populate dialog fields to test
+     *
+     * @param testContent main test function
+     * @param callback optional callback for result verification
+     */
+    private fun performTest(
+        testContent: (
+            dialog: MaterialDialog,
+            intent: Intent,
+            activity: MainActivity
+        ) -> Unit,
+        callback: EncryptDecryptUtils.EncryptButtonCallbackInterface =
+            object : EncryptDecryptUtils.EncryptButtonCallbackInterface {}
+    ) {
+        scenario.onActivity { activity ->
+            Intent().putExtra(TAG_SOURCE, HybridFileParcelable(file.absolutePath))
+                .putExtra(TAG_OPEN_MODE, OpenMode.FILE).let { intent ->
+                    EncryptAuthenticateDialog.show(
+                        activity,
+                        intent,
+                        activity,
+                        activity.appTheme,
+                        callback
+                    )
+                    ShadowDialog.getLatestDialog()?.run {
+                        assertTrue(this is MaterialDialog)
+                        (this as MaterialDialog).let {
+                            editTextFileSaveAs = findViewById<TextInputEditText>(
+                                R.id.edit_text_encrypt_save_as
+                            )
+                            editTextEncryptPassword = findViewById<TextInputEditText>(
+                                R.id.edit_text_dialog_encrypt_password
+                            )
+                            editTextEncryptPasswordConfirm = findViewById<TextInputEditText>(
+                                R.id.edit_text_dialog_encrypt_password_confirm
+                            )
+                            tilFileSaveAs = findViewById<WarnableTextInputLayout>(
+                                R.id.til_encrypt_save_as
+                            )
+                            tilEncryptPassword = findViewById<WarnableTextInputLayout>(
+                                R.id.til_encrypt_password
+                            )
+                            tilEncryptPasswordConfirm = findViewById<WarnableTextInputLayout>(
+                                R.id.til_encrypt_password
+                            )
+                            checkboxUseAze = findViewById<AppCompatCheckBox>(R.id.checkbox_use_aze)
+                            okButton = getActionButton(DialogAction.POSITIVE)
+                            assertFalse(okButton.isEnabled)
+                            assertTrue(true == editTextFileSaveAs.text?.startsWith(file.name))
+                            testContent.invoke(it, intent, activity)
+                        }
+                    } ?: fail("Dialog cannot be seen?")
+                }
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialogTest.kt
new file mode 100644
index 000000000..91439b864
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWarningDialogTest.kt
@@ -0,0 +1,68 @@
+package com.amaze.filemanager.ui.dialogs
+
+import androidx.preference.PreferenceManager
+import com.afollestad.materialdialogs.DialogAction
+import com.afollestad.materialdialogs.MaterialDialog
+import com.amaze.filemanager.R
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.test.getString
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.robolectric.shadows.ShadowDialog
+
+/**
+ * Test [EncryptWarningDialog].
+ */
+class EncryptWarningDialogTest : AbstractEncryptDialogTests() {
+
+    /**
+     * Verify dialog behaviour.
+     */
+    @Test
+    fun testDisplayDialog() {
+        scenario.onActivity { activity ->
+            EncryptWarningDialog.show(activity, activity.appTheme)
+            assertEquals(1, ShadowDialog.getShownDialogs().size)
+            assertTrue(ShadowDialog.getLatestDialog() is MaterialDialog)
+            (ShadowDialog.getLatestDialog() as MaterialDialog).run {
+                assertEquals(getString(R.string.warning), titleView.text)
+                assertEquals(getString(R.string.crypt_warning_key), contentView?.text.toString())
+                assertEquals(
+                    getString(R.string.warning_never_show),
+                    getActionButton(DialogAction.NEGATIVE).text
+                )
+                assertEquals(
+                    getString(R.string.warning_confirm),
+                    getActionButton(DialogAction.POSITIVE).text
+                )
+                assertTrue(getActionButton(DialogAction.POSITIVE).performClick())
+            }
+            assertFalse(
+                PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+                    .getBoolean(PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER, false)
+            )
+        }
+    }
+
+    /**
+     * Test logic if "Never show again" button is tapped.
+     */
+    @Test
+    fun testDisplayDialogNeverShowAgain() {
+        scenario.onActivity { activity ->
+            EncryptWarningDialog.show(activity, activity.appTheme)
+            assertEquals(1, ShadowDialog.getShownDialogs().size)
+            assertTrue(ShadowDialog.getLatestDialog() is MaterialDialog)
+            (ShadowDialog.getLatestDialog() as MaterialDialog).run {
+                assertTrue(getActionButton(DialogAction.NEGATIVE).performClick())
+            }
+            assertTrue(
+                PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+                    .getBoolean(PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER, false)
+            )
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialogTest.kt b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialogTest.kt
new file mode 100644
index 000000000..7f755482b
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/EncryptWithPresetPasswordSaveAsDialogTest.kt
@@ -0,0 +1,299 @@
+package com.amaze.filemanager.ui.dialogs
+
+import android.content.Intent
+import android.os.Environment
+import android.view.View.INVISIBLE
+import android.view.View.VISIBLE
+import androidx.appcompat.widget.AppCompatCheckBox
+import androidx.preference.PreferenceManager
+import com.afollestad.materialdialogs.DialogAction
+import com.afollestad.materialdialogs.MaterialDialog
+import com.afollestad.materialdialogs.internal.MDButton
+import com.amaze.filemanager.R
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.asynchronous.services.EncryptService
+import com.amaze.filemanager.asynchronous.services.EncryptService.TAG_SOURCE
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.RandomPathGenerator
+import com.amaze.filemanager.filesystem.files.CryptUtil.AESCRYPT_EXTENSION
+import com.amaze.filemanager.filesystem.files.CryptUtil.CRYPT_EXTENSION
+import com.amaze.filemanager.filesystem.files.EncryptDecryptUtils
+import com.amaze.filemanager.test.getString
+import com.amaze.filemanager.ui.activities.MainActivity
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_FINGERPRINT
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.ENCRYPT_PASSWORD_MASTER
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT
+import com.amaze.filemanager.ui.fragments.preference_fragments.PreferencesConstants.PREFERENCE_CRYPT_FINGERPRINT_DEFAULT
+import com.amaze.filemanager.ui.views.WarnableTextInputLayout
+import com.google.android.material.textfield.TextInputEditText
+import org.junit.After
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Before
+import org.junit.Test
+import org.robolectric.shadows.ShadowDialog
+import java.io.File
+import kotlin.random.Random
+
+class EncryptWithPresetPasswordSaveAsDialogTest : AbstractEncryptDialogTests() {
+
+    private val randomizer = Random(System.currentTimeMillis())
+    private lateinit var file: File
+    private lateinit var tilFileSaveAs: WarnableTextInputLayout
+    private lateinit var editTextFileSaveAs: TextInputEditText
+    private lateinit var checkboxUseAze: AppCompatCheckBox
+    private lateinit var okButton: MDButton
+
+    /**
+     * MainActivity setup.
+     */
+    @Before
+    override fun setUp() {
+        super.setUp()
+        file = File(
+            Environment.getExternalStorageDirectory(),
+            RandomPathGenerator.generateRandomPath(
+                randomizer, 16
+            )
+        )
+    }
+
+    /**
+     * Post test cleanup.
+     */
+    @After
+    override fun tearDown() {
+        super.tearDown()
+        PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+            .edit().putBoolean(
+                PREFERENCE_CRYPT_FINGERPRINT,
+                PREFERENCE_CRYPT_FINGERPRINT_DEFAULT
+            ).apply()
+    }
+
+    /**
+     * Test case when fingerprint encrypt option is enabled.
+     *
+     * Ensure optional checkbox is disabled - Fingerprint encryption cannot do AESCrypt.
+     */
+    @Test
+    fun testWhenFingerprintOptionEnabled() {
+        PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+            .edit()
+            .putBoolean(PREFERENCE_CRYPT_FINGERPRINT, true)
+            .apply()
+        performTest(
+            testContent = { _, _, _ ->
+                assertEquals("${file.name}$CRYPT_EXTENSION", editTextFileSaveAs.text.toString())
+                assertEquals(INVISIBLE, checkboxUseAze.visibility)
+            },
+            callback = object : EncryptDecryptUtils.EncryptButtonCallbackInterface {
+                override fun onButtonPressed(intent: Intent, password: String) {
+                    assertEquals(ENCRYPT_PASSWORD_FINGERPRINT, password)
+                    assertEquals(file.absolutePath, intent.getStringExtra(TAG_SOURCE))
+                    assertFalse(intent.getBooleanExtra(EncryptService.TAG_AESCRYPT, true))
+                    assertEquals(
+                        "${file.name}$CRYPT_EXTENSION",
+                        intent.getStringExtra(EncryptService.TAG_ENCRYPT_TARGET)
+                    )
+                }
+            }
+        )
+    }
+
+    /**
+     * Test filename validation when fingerprint option enabled.
+     * Shall never let but .aze go through
+     */
+    @Test
+    fun testFilenameValidationWhenFingerprintOptionEnabled() {
+        PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+            .edit()
+            .putBoolean(PREFERENCE_CRYPT_FINGERPRINT, true)
+            .apply()
+        performTest(testContent = { _, _, _ ->
+            editTextFileSaveAs.setText("${file.name}.error")
+            assertFalse(okButton.isEnabled)
+            assertEquals(
+                getString(R.string.encrypt_file_must_end_with_aze),
+                tilFileSaveAs.error
+            )
+            editTextFileSaveAs.setText("${file.name}.aes")
+            assertFalse(okButton.isEnabled)
+            assertEquals(
+                getString(R.string.encrypt_file_must_end_with_aze),
+                tilFileSaveAs.error
+            )
+        })
+    }
+
+    /**
+     * Test filename validation when fingerprint option enabled.
+     * Shall never let but .aze go through
+     */
+    @Test
+    fun testFilenameValidationWhenFingerprintOptionDisabled() {
+        PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+            .edit()
+            .putBoolean(PREFERENCE_CRYPT_FINGERPRINT, false)
+            .apply()
+        performTest(
+            password = ENCRYPT_PASSWORD_MASTER,
+            testContent = { _, _, _ ->
+                editTextFileSaveAs.setText("${file.name}.error")
+                assertFalse(okButton.isEnabled)
+                assertEquals(
+                    getString(R.string.encrypt_file_must_end_with_aes),
+                    tilFileSaveAs.error
+                )
+                editTextFileSaveAs.setText("${file.name}.aze")
+                assertFalse(okButton.isEnabled)
+                assertEquals(
+                    getString(R.string.encrypt_file_must_end_with_aes),
+                    tilFileSaveAs.error
+                )
+                checkboxUseAze.isChecked = true
+                assertTrue(okButton.isEnabled)
+                assertNull(tilFileSaveAs.error)
+            }
+        )
+    }
+
+    /**
+     * Test case when fingerprint option is disabled.
+     *
+     * Must be master password then. Sorry, no validation at this point - upstream is responsible
+     * for that.
+     */
+    @Test
+    fun testWhenFingerprintOptionDisabled() {
+        PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+            .edit()
+            .putBoolean(PREFERENCE_CRYPT_FINGERPRINT, false)
+            .apply()
+        performTest(
+            password = ENCRYPT_PASSWORD_MASTER,
+            testContent = { _, _, _ ->
+                assertEquals("${file.name}$AESCRYPT_EXTENSION", editTextFileSaveAs.text.toString())
+                assertEquals(VISIBLE, checkboxUseAze.visibility)
+            },
+            callback = object : EncryptDecryptUtils.EncryptButtonCallbackInterface {
+                override fun onButtonPressed(intent: Intent, password: String) {
+                    assertEquals(ENCRYPT_PASSWORD_MASTER, password)
+                    assertEquals(file.absolutePath, intent.getStringExtra(TAG_SOURCE))
+                    assertTrue(intent.getBooleanExtra(EncryptService.TAG_AESCRYPT, false))
+                    assertEquals(
+                        "${file.name}$AESCRYPT_EXTENSION",
+                        intent.getStringExtra(EncryptService.TAG_ENCRYPT_TARGET)
+                    )
+                }
+            }
+        )
+    }
+
+    /**
+     * Test invalid password put into the dialog argument, which shall never happen.
+     */
+    @Test(expected = IllegalArgumentException::class)
+    fun testWithInvalidFixedPasswordArgument() {
+        PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+            .edit()
+            .putBoolean(PREFERENCE_CRYPT_FINGERPRINT, false)
+            .apply()
+        performTest(
+            password = "abcdefgh",
+            testContent = { _, _, _ -> }
+        )
+    }
+
+    /**
+     * Test logic when aze encryption checkbox is ticked.
+     */
+    @Test
+    fun testAzecryptCheckbox() {
+        performTest(
+            password = ENCRYPT_PASSWORD_MASTER,
+            testContent = { _, _, _ ->
+                checkboxUseAze.isChecked = true
+                assertTrue(ShadowDialog.getShownDialogs().size == 2)
+                assertTrue(ShadowDialog.getLatestDialog() is MaterialDialog)
+                (ShadowDialog.getLatestDialog() as MaterialDialog).run {
+                    assertEquals(getString(R.string.warning), titleView.text)
+                    assertEquals(
+                        getString(R.string.crypt_warning_key),
+                        contentView?.text.toString()
+                    )
+                    assertEquals(
+                        getString(R.string.warning_never_show),
+                        getActionButton(DialogAction.NEGATIVE).text
+                    )
+                    assertEquals(
+                        getString(R.string.warning_confirm),
+                        getActionButton(DialogAction.POSITIVE).text
+                    )
+                    assertTrue(getActionButton(DialogAction.POSITIVE).performClick())
+                }
+                assertEquals(2, ShadowDialog.getShownDialogs().size)
+                assertFalse(ShadowDialog.getLatestDialog().isShowing)
+                assertTrue(true == editTextFileSaveAs.text?.endsWith(CRYPT_EXTENSION))
+                checkboxUseAze.isChecked = false
+                assertEquals(2, ShadowDialog.getShownDialogs().size)
+                assertFalse(ShadowDialog.getLatestDialog().isShowing)
+                assertTrue(true == editTextFileSaveAs.text?.endsWith(AESCRYPT_EXTENSION))
+                checkboxUseAze.isChecked = true
+                assertEquals(3, ShadowDialog.getShownDialogs().size)
+                assertTrue(ShadowDialog.getLatestDialog().isShowing)
+                assertTrue(true == editTextFileSaveAs.text?.endsWith(CRYPT_EXTENSION))
+                (ShadowDialog.getLatestDialog() as MaterialDialog)
+                    .getActionButton(DialogAction.NEGATIVE).performClick()
+                assertEquals(3, ShadowDialog.getShownDialogs().size)
+                assertFalse(ShadowDialog.getLatestDialog().isShowing)
+                assertTrue(
+                    PreferenceManager.getDefaultSharedPreferences(AppConfig.getInstance())
+                        .getBoolean(PreferencesConstants.PREFERENCE_CRYPT_WARNING_REMEMBER, false)
+                )
+                checkboxUseAze.isChecked = false
+                assertEquals(3, ShadowDialog.getShownDialogs().size) // no new dialog
+                checkboxUseAze.isChecked = true
+                assertEquals(3, ShadowDialog.getShownDialogs().size)
+            }
+        )
+    }
+
+    private fun performTest(
+        testContent: (dialog: MaterialDialog, intent: Intent, activity: MainActivity) -> Unit,
+        password: String = ENCRYPT_PASSWORD_FINGERPRINT,
+        callback: EncryptDecryptUtils.EncryptButtonCallbackInterface =
+            object : EncryptDecryptUtils.EncryptButtonCallbackInterface {}
+    ) {
+        scenario.onActivity { activity ->
+            Intent().putExtra(TAG_SOURCE, HybridFileParcelable(file.absolutePath)).let { intent ->
+                EncryptWithPresetPasswordSaveAsDialog.show(
+                    activity,
+                    intent,
+                    activity,
+                    password,
+                    callback
+                )
+                ShadowDialog.getLatestDialog()?.run {
+                    assertTrue(this is MaterialDialog)
+                    (this as MaterialDialog).let {
+                        editTextFileSaveAs = findViewById<TextInputEditText>(
+                            R.id.edit_text_encrypt_save_as
+                        )
+                        tilFileSaveAs = findViewById<WarnableTextInputLayout>(
+                            R.id.til_encrypt_save_as
+                        )
+                        checkboxUseAze = findViewById<AppCompatCheckBox>(R.id.checkbox_use_aze)
+                        okButton = getActionButton(DialogAction.POSITIVE)
+                        testContent.invoke(it, intent, activity)
+                    }
+                } ?: fail("Dialog cannot be seen?")
+            }
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/utils/AESCryptTest.kt b/app/src/test/java/com/amaze/filemanager/utils/AESCryptTest.kt
new file mode 100644
index 000000000..b0e4d683c
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/utils/AESCryptTest.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.P
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import org.junit.Assert.assertArrayEquals
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.annotation.Config
+import java.io.ByteArrayInputStream
+import java.io.ByteArrayOutputStream
+import kotlin.random.Random
+
+/**
+ * Unit test for [AESCrypt]
+ */
+@RunWith(AndroidJUnit4::class)
+@Config(sdk = [KITKAT, P])
+class AESCryptTest {
+
+    /**
+     * Simple sanity test on [AESCrypt].
+     */
+    @Test
+    fun testEncryptDecrypt() {
+        val contents = Random(System.currentTimeMillis()).nextBytes(256)
+        val out = ByteArrayOutputStream()
+        var crypter = AESCrypt("12345678")
+        crypter.encrypt(
+            `in` = ByteArrayInputStream(contents), out = out,
+            progressHandler = ProgressHandler()
+        )
+        out.close()
+        val encrypted = out.toByteArray()
+        val verify = ByteArrayOutputStream()
+        crypter = AESCrypt("12345678")
+        crypter.decrypt(encrypted.size.toLong(), ByteArrayInputStream(encrypted), verify)
+        verify.close()
+        val decrypted = verify.toByteArray()
+        assertArrayEquals(contents, decrypted)
+    }
+
+    /**
+     * Test scenario when wrong decrypt password is entered.
+     */
+    @Test(expected = AESCrypt.DecryptFailureException::class)
+    fun testWrongPasswordDecrypt() {
+        val contents = Random(System.currentTimeMillis()).nextBytes(256)
+        val out = ByteArrayOutputStream()
+        var crypter = AESCrypt("password")
+        crypter.encrypt(
+            `in` = ByteArrayInputStream(contents), out = out,
+            progressHandler = ProgressHandler()
+        )
+        out.close()
+        val encrypted = out.toByteArray()
+        val verify = ByteArrayOutputStream()
+        crypter = AESCrypt("foobar")
+        crypter.decrypt(encrypted.size.toLong(), ByteArrayInputStream(encrypted), verify)
+        verify.close()
+//        val decrypted = verify.toByteArray()
+//        assertArrayEquals(contents, decrypted)
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/utils/CryptUtilTest.kt b/app/src/test/java/com/amaze/filemanager/utils/CryptUtilTest.kt
new file mode 100644
index 000000000..612cb6a1d
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/utils/CryptUtilTest.kt
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import android.os.Build.VERSION_CODES.JELLY_BEAN_MR2
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.P
+import android.os.Environment
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.filesystem.HybridFileParcelable
+import com.amaze.filemanager.filesystem.files.CryptUtil
+import com.amaze.filemanager.utils.security.SecretKeygen
+import io.mockk.every
+import io.mockk.mockkObject
+import org.awaitility.Awaitility.await
+import org.junit.Assert.assertArrayEquals
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.annotation.Config
+import java.io.ByteArrayInputStream
+import java.io.File
+import java.io.FileOutputStream
+import java.util.concurrent.TimeUnit
+import javax.crypto.spec.SecretKeySpec
+import kotlin.random.Random
+
+@RunWith(AndroidJUnit4::class)
+@Config(
+    sdk = [JELLY_BEAN_MR2, KITKAT, P]
+)
+class CryptUtilTest {
+
+    /**
+     * Test AESCrypt function under CryptUtil.
+     *
+     * @see CryptUtil
+     * @see AESCrypt
+     */
+    @Test
+    fun testAescrypt() {
+        performTest(
+            useAescrypt = true,
+            password = "abcdefgh1234567890",
+            targetExtension = "aes"
+        )
+        performFolderTest(
+            useAescrypt = true,
+            password = "abcdefgh1234567890",
+            targetExtension = "aes"
+        )
+    }
+
+    /**
+     * Test legacy encryption/decryption under CryptUtil.
+     *
+     * @see CryptUtil
+     */
+    @Test
+    fun testLegacyEncrypt() {
+        initMockSecretKeygen()
+        performTest(useAescrypt = false, targetExtension = "aze")
+        performFolderTest(useAescrypt = false, targetExtension = "aze")
+    }
+
+    private fun performTest(useAescrypt: Boolean, password: String? = null, targetExtension: String) {
+        val source = randomizer.nextBytes(117)
+        val sourceFile = File(Environment.getExternalStorageDirectory(), "test.bin")
+        ByteArrayInputStream(source).copyTo(FileOutputStream(sourceFile))
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(sourceFile.absolutePath),
+            ProgressHandler(),
+            ArrayList(),
+            "test.bin.$targetExtension",
+            useAescrypt,
+            password
+        )
+        val targetFile = File(Environment.getExternalStorageDirectory(), "test.bin.$targetExtension")
+        assertTrue(targetFile.length() > source.size)
+        sourceFile.delete()
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(targetFile.absolutePath).also {
+                it.size = targetFile.length()
+            },
+            Environment.getExternalStorageDirectory().absolutePath,
+            ProgressHandler(),
+            ArrayList(),
+            password
+        )
+        File(Environment.getExternalStorageDirectory(), "test.bin").run {
+            assertTrue(this.exists())
+            assertArrayEquals(source, this.readBytes())
+        }
+    }
+
+    private fun performFolderTest(useAescrypt: Boolean, password: String? = null, targetExtension: String) {
+        val filesSize = randomizer.nextInt(10, 20)
+        val sourceData = Array(filesSize) {
+            randomizer.nextBytes(117)
+        }
+        val sourceFolder = File(Environment.getExternalStorageDirectory(), "test")
+        sourceFolder.mkdirs()
+        repeat(filesSize) {
+            val file = File(sourceFolder, "test$it.bin")
+            ByteArrayInputStream(sourceData[it]).copyTo(FileOutputStream(file))
+        }
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(sourceFolder.absolutePath).also {
+                it.isDirectory = true
+            },
+            ProgressHandler(),
+            ArrayList(),
+            "test.$targetExtension",
+            useAescrypt,
+            password
+        )
+        val targetFolder = File(Environment.getExternalStorageDirectory(), "test.$targetExtension")
+        assertTrue(targetFolder.isDirectory)
+        assertEquals(sourceData.size, targetFolder.listFiles()?.size)
+        sourceFolder.deleteRecursively()
+        CryptUtil(
+            AppConfig.getInstance(),
+            HybridFileParcelable(targetFolder.absolutePath).also {
+                it.isDirectory = true
+            },
+            Environment.getExternalStorageDirectory().absolutePath,
+            ProgressHandler(),
+            ArrayList(),
+            password
+        )
+        File(Environment.getExternalStorageDirectory(), "test").run {
+            assertTrue(this.exists())
+            assertTrue(this.isDirectory)
+            await().atMost(10, TimeUnit.SECONDS).until {
+                sourceData.size == this.listFiles()?.size
+            }
+            this.listFiles()?.forEach { file: File? ->
+                file?.run {
+                    val index = file.name.substring("test".length, file.name.indexOf('.')).toInt()
+                    assertArrayEquals("Comparison broken at ${file.absolutePath}", sourceData[index], file.readBytes())
+                } ?: fail("File not found")
+            } ?: fail("No files found")
+        }
+    }
+
+    companion object {
+
+        private val randomizer = Random(System.currentTimeMillis())
+        private val key = SecretKeySpec(randomizer.nextBytes(16), "AES")
+
+        /**
+         * Mock [SecretKeygen] since Robolectric does not have AndroidKeyStore.
+         */
+        fun initMockSecretKeygen() {
+            mockkObject(SecretKeygen)
+            every { SecretKeygen.getSecretKey() } returns key
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java b/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
index 42a802697..9a1cd2092 100644
--- a/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
+++ b/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
@@ -38,7 +38,7 @@ import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
 import com.amaze.filemanager.shadows.ShadowSmbUtil;
-import com.amaze.filemanager.test.ShadowCryptUtil;
+import com.amaze.filemanager.test.ShadowPasswordUtil;
 
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
@@ -48,7 +48,7 @@ import jcifs.smb.NtlmPasswordAuthenticator;
 @RunWith(AndroidJUnit4.class)
 @Config(
     sdk = {JELLY_BEAN, KITKAT, P},
-    shadows = {ShadowCryptUtil.class, ShadowSmbUtil.class})
+    shadows = {ShadowPasswordUtil.class, ShadowSmbUtil.class})
 public class SmbUtilTest {
 
   @Test
