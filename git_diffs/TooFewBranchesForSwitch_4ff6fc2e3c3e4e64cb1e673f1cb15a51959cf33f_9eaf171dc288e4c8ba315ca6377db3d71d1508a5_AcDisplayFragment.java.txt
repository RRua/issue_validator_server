diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/App.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/App.java
index d6abbc6b..4b74582e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/App.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/App.java
@@ -21,7 +21,7 @@ package com.achep.activedisplay;
 import android.app.Application;
 import android.content.Intent;
 
-import com.achep.activedisplay.services.LockscreenService;
+import com.achep.activedisplay.services.KeyguardService;
 
 /**
  * Created by Artem on 22.02.14.
@@ -34,8 +34,8 @@ public class App extends Application {
 
         // If lockscreen is enabled launch it on start.
         Config config = Config.getInstance(this);
-        if (config.isLockscreenEnabled()) {
-            Intent intent = new Intent(this, LockscreenService.class);
+        if (config.isKeyguardEnabled()) {
+            Intent intent = new Intent(this, KeyguardService.class);
             startService(intent);
         }
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/AsyncTask.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/AsyncTask.java
index 03664fcc..4fb8842a 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/AsyncTask.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/AsyncTask.java
@@ -20,7 +20,7 @@
 package com.achep.activedisplay;
 
 /**
- * Created by Artem on 10.04.2014.
+ * A better {@link com.achep.activedisplay.AsyncTask}.
  *
  * @author Artem Chepurnoy
  */
@@ -32,7 +32,7 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
      * Equals to calling: {@code AsyncTask.getStatus().equals(AsyncTask.Status.FINISHED)}
      */
     public boolean isFinished() {
-        return getStatus().equals(android.os.AsyncTask.Status.FINISHED);
+        return getStatus().equals(Status.FINISHED);
     }
 
     public void cancel() {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java
index 3e3edcfc..3262e9d5 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java
@@ -20,22 +20,25 @@ package com.achep.activedisplay;
 
 import android.content.Context;
 import android.content.SharedPreferences;
+import android.content.res.Resources;
 import android.util.Log;
 
 import com.achep.activedisplay.activemode.ActiveModeService;
-import com.achep.activedisplay.services.LockscreenService;
+import com.achep.activedisplay.services.KeyguardService;
 import com.achep.activedisplay.utils.AccessUtils;
 
 import java.util.ArrayList;
 
 /**
- * @author Artem
+ * Saves all the configurations for the app.
+ *
+ * @author Artem Chepurnoy
  * @since 21.01.14
- * Saves all the configurations for the app
  */
 public class Config {
 
     private static final String TAG = "Config";
+
     private static final String PREFERENCES_FILE_NAME = "config";
 
     public static final String KEY_ENABLED = "enabled";
@@ -48,124 +51,123 @@ public class Config {
     public static final String KEY_INACTIVE_TIME_ENABLED = "inactive_time_enabled";
 
     // timeouts
-    public static final String KEY_TIMEOUT_ACTIVE = "timeout_active";
+    public static final String KEY_TIMEOUT_ENABLED = "timeout_enabled";
     public static final String KEY_TIMEOUT_NORMAL = "timeout_normal";
     public static final String KEY_TIMEOUT_SHORT = "timeout_short";
-    //public static final String KEY_TIMEOUT_INSTANT = "timeout_instant";   Unused Variable
 
-    // lockscreen
-    public static final String KEY_LOCK_SCREEN = "lock_screen";
+    // keyguard
+    public static final String KEY_KEYGUARD = "lock_screen";
 
     // active mode
     public static final String KEY_ACTIVE_MODE = "active_mode";
 
     // interface
-    public static final String KEY_INTERFACE_WALLPAPER_SHOWN = "wallpaper_shown";
-    public static final String KEY_INTERFACE_SHADOW_TOGGLE = "shadow_toggle";
-    public static final String KEY_INTERFACE_DYNAMIC_BACKGROUND_MODE = "dynamic_background_mode";
+    public static final String KEY_UI_WALLPAPER_SHOWN = "wallpaper_shown";
+    public static final String KEY_UI_SHADOW_TOGGLE = "shadow_toggle";
+    public static final String KEY_UI_DYNAMIC_BACKGROUND_MODE = "dynamic_background_mode";
     public static final int DYNAMIC_BG_ARTWORK_MASK = 1;
     public static final int DYNAMIC_BG_NOTIFICATION_MASK = 2;
-    public static final String KEY_INTERFACE_MIRRORED_TIMEOUT_PROGRESS_BAR = "mirrored_timeout_progress_bar";
+    public static final String KEY_UI_MIRRORED_TIMEOUT_BAR = "mirrored_timeout_progress_bar";
 
-    // swipe actions
-    public static final String KEY_SWIPE_LEFT_ACTION = "swipe_left_action";
-    public static final String KEY_SWIPE_RIGHT_ACTION = "swipe_right_action";
-    private static Config sConfigSoft;
+    private static Config sConfig;
 
-    private boolean mActiveDisplayEnabled;
+    private boolean mAcDisplayEnabled;
+    private boolean mKeyguardEnabled;
+    private boolean mActiveMode;
     private boolean mEnabledOnlyWhileCharging;
-    private boolean mLowPriorityNotificationsAllowed;
-    private boolean mCanTimeOut;
+    private boolean mNotifyLowPriority;
+    private boolean mTimeoutEnabled;
     private int mTimeoutNormal;
     private int mTimeoutShort;
     private int mInactiveTimeFrom;
     private int mInactiveTimeTo;
-    private int mSwipeLeftAction;
-    private int mSwipeRightAction;
-    private int mDynamicBackgroundMode;
+    private int mUiDynamicBackground;
     private boolean mInactiveTimeEnabled;
-    private boolean mLockscreenEnabled;
-    private Boolean mActiveMode;
-    private ArrayList<OnConfigChangedListener> mListeners;
-    private boolean mWallpaperShown;
-    private boolean mShadowShown;
-    private boolean mMirroredTimeoutProgressBarEnabled;
-
-    /**
-     * Config constructor, sets all the variables to the value using sharedPreference or uses a preset key
-     *
-     * @param context
-     */
-    private Config(Context context) {
-        mListeners = new ArrayList<>(6);
-
-        SharedPreferences prefs = getSharedPreferences(context);
-        mActiveDisplayEnabled = prefs.getBoolean(KEY_ENABLED, false);
-        mEnabledOnlyWhileCharging = prefs.getBoolean(KEY_ONLY_WHILE_CHARGING, false);
-        mLowPriorityNotificationsAllowed = prefs.getBoolean(KEY_LOW_PRIORITY_NOTIFICATIONS, false);
-        mLockscreenEnabled = prefs.getBoolean(KEY_LOCK_SCREEN, false);
-        mActiveMode = prefs.getBoolean(KEY_ACTIVE_MODE, false);
-        mWallpaperShown = prefs.getBoolean(KEY_INTERFACE_WALLPAPER_SHOWN, false);
-        mShadowShown = prefs.getBoolean(KEY_INTERFACE_SHADOW_TOGGLE, true);
-        mMirroredTimeoutProgressBarEnabled = prefs.getBoolean(KEY_INTERFACE_MIRRORED_TIMEOUT_PROGRESS_BAR, true);
-        mCanTimeOut = prefs.getBoolean(KEY_TIMEOUT_ACTIVE, false);
-        mTimeoutNormal = prefs.getInt(KEY_TIMEOUT_NORMAL, 12000);
-        mTimeoutShort = prefs.getInt(KEY_TIMEOUT_SHORT, 6000);
-        mInactiveTimeFrom = prefs.getInt(KEY_INACTIVE_TIME_FROM, 0);
-        mInactiveTimeTo = prefs.getInt(KEY_INACTIVE_TIME_TO, 0);
-        mInactiveTimeEnabled = prefs.getBoolean(KEY_INACTIVE_TIME_ENABLED, false);
-        mSwipeLeftAction = prefs.getInt(KEY_SWIPE_LEFT_ACTION, 2);
-        mSwipeRightAction = prefs.getInt(KEY_SWIPE_RIGHT_ACTION, 2);
-        mDynamicBackgroundMode = prefs.getInt(KEY_INTERFACE_DYNAMIC_BACKGROUND_MODE,
-                DYNAMIC_BG_ARTWORK_MASK | DYNAMIC_BG_NOTIFICATION_MASK);
-    }
-
-    /**
-     * Get's an instance of the config
-     *
-     * @param context
-     * @return a config instance
-     */
-
-    public static synchronized Config getInstance(Context context) {
-        if (sConfigSoft == null)
-            sConfigSoft = new Config(context);
-        return sConfigSoft;
-    }
+    private boolean mUiWallpaper;
+    private boolean mUiWallpaperShadow;
+    private boolean mUiMirroredTimeoutBar;
 
-    static SharedPreferences getSharedPreferences(Context context) {
-        return context.getSharedPreferences(PREFERENCES_FILE_NAME, Context.MODE_PRIVATE);
-    }
+    private ArrayList<OnConfigChangedListener> mListeners;
 
-    /**
-     * Listeners modifiers
-     * TODO: add better doc
-     */
+    // //////////////////////////////////////////
+    // /////////// -- LISTENERS -- //////////////
+    // //////////////////////////////////////////
 
     public interface OnConfigChangedListener {
         public void onConfigChanged(Config config, String key, Object value);
     }
 
     public void addOnConfigChangedListener(OnConfigChangedListener listener) {
-        if (Project.DEBUG) Log.d(TAG, "add_l=" + listener);
         mListeners.add(listener);
     }
 
     public void removeOnConfigChangedListener(OnConfigChangedListener listener) {
-        if (Project.DEBUG) Log.d(TAG, "remove_l=" + listener);
         mListeners.remove(listener);
     }
 
+    // //////////////////////////////////////////
+    // ///////////// -- INIT -- /////////////////
+    // //////////////////////////////////////////
+
+    public static synchronized Config getInstance(Context context) {
+        if (sConfig == null) {
+            sConfig = new Config(context);
+        }
+        return sConfig;
+    }
+
+    private Config(Context context) {
+        mListeners = new ArrayList<>(6);
+
+        Resources res = context.getResources();
+        SharedPreferences prefs = getSharedPreferences(context);
+        mAcDisplayEnabled = prefs.getBoolean(KEY_ENABLED,
+                res.getBoolean(R.bool.config_default_enabled));
+        mKeyguardEnabled = prefs.getBoolean(KEY_KEYGUARD,
+                res.getBoolean(R.bool.config_default_keyguard_enabled));
+        mActiveMode = prefs.getBoolean(KEY_ACTIVE_MODE,
+                res.getBoolean(R.bool.config_default_active_mode_enabled));
+
+        // notifications
+        mNotifyLowPriority = prefs.getBoolean(KEY_LOW_PRIORITY_NOTIFICATIONS,
+                res.getBoolean(R.bool.config_default_notify_low_priority));
+
+        // timeout
+        mTimeoutEnabled = prefs.getBoolean(KEY_TIMEOUT_ENABLED,
+                res.getBoolean(R.bool.config_default_timeout_enabled));
+        mTimeoutNormal = prefs.getInt(KEY_TIMEOUT_NORMAL,
+                res.getInteger(R.integer.config_default_timeout_normal));
+        mTimeoutShort = prefs.getInt(KEY_TIMEOUT_SHORT,
+                res.getInteger(R.integer.config_default_timeout_short));
+
+        // inactive time
+        mInactiveTimeFrom = prefs.getInt(KEY_INACTIVE_TIME_FROM,
+                res.getInteger(R.integer.config_default_inactive_time_from));
+        mInactiveTimeTo = prefs.getInt(KEY_INACTIVE_TIME_TO,
+                res.getInteger(R.integer.config_default_inactive_time_to));
+        mInactiveTimeEnabled = prefs.getBoolean(KEY_INACTIVE_TIME_ENABLED,
+                res.getBoolean(R.bool.config_default_inactive_time_enabled));
+
+        // interface
+        mUiWallpaper = prefs.getBoolean(KEY_UI_WALLPAPER_SHOWN,
+                res.getBoolean(R.bool.config_default_ui_show_wallpaper));
+        mUiWallpaperShadow = prefs.getBoolean(KEY_UI_SHADOW_TOGGLE,
+                res.getBoolean(R.bool.config_default_ui_show_shadow));
+        mUiDynamicBackground = prefs.getInt(KEY_UI_DYNAMIC_BACKGROUND_MODE,
+                res.getInteger(R.integer.config_default_ui_show_shadow_dynamic_bg));
+        mUiMirroredTimeoutBar = prefs.getBoolean(KEY_UI_MIRRORED_TIMEOUT_BAR,
+                res.getBoolean(R.bool.config_default_ui_mirrored_timeout_bar));
+
+        // other
+        mEnabledOnlyWhileCharging = prefs.getBoolean(KEY_ONLY_WHILE_CHARGING,
+                res.getBoolean(R.bool.config_default_enabled_only_while_charging));
+    }
+
+    static SharedPreferences getSharedPreferences(Context context) {
+        return context.getSharedPreferences(PREFERENCES_FILE_NAME, Context.MODE_PRIVATE);
+    }
 
-    /**
-     * This is for debugging, writes to the log if a config changes.
-     *
-     * @param key
-     * @param value
-     * @param listener
-     */
     private void notifyConfigChanged(String key, Object value, OnConfigChangedListener listener) {
-        if (Project.DEBUG) Log.d(TAG, "Notifying listeners: \"" + key + "\" = \"" + value + "\"");
         for (OnConfigChangedListener l : mListeners) {
             if (l == listener) continue;
             l.onConfigChanged(this, key, value);
@@ -174,7 +176,10 @@ public class Config {
 
     private void saveOption(Context context, String key, Object value,
                             OnConfigChangedListener listener, boolean changed) {
-        if (!changed) return;
+        if (!changed) {
+            // Don't update preferences if this change is a lie.
+            return;
+        }
 
         if (Project.DEBUG) Log.d(TAG, "Saving \"" + key + "\" to config as \"" + value + "\"");
 
@@ -189,237 +194,155 @@ public class Config {
         notifyConfigChanged(key, value, listener);
     }
 
+    // //////////////////////////////////////////
+    // ///////////// -- OPTIONS -- //////////////
+    // //////////////////////////////////////////
+
     /**
-     * Setter for the entire app enabler
-     *
-     * @param context
-     * @param enabled
-     * @param listener
-     * @return
+     * Setter for the entire app enabler.
      */
-
-    public boolean setActiveDisplayEnabled(Context context, boolean enabled,
-                                           OnConfigChangedListener listener) {
-        if (enabled && !(AccessUtils.isNotificationAccessEnabled(context)
+    public boolean setEnabled(Context context, boolean enabled,
+                              OnConfigChangedListener listener) {
+        if (enabled
+                && !(AccessUtils.isNotificationAccessEnabled(context)
                 && AccessUtils.isDeviceAdminEnabled(context))) {
             return false;
         }
 
-        boolean changed = mActiveDisplayEnabled != (mActiveDisplayEnabled = enabled);
+        boolean changed = mAcDisplayEnabled != (mAcDisplayEnabled = enabled);
         saveOption(context, KEY_ENABLED, enabled, listener, changed);
 
         if (changed) {
             ActiveModeService.handleState(context);
-            LockscreenService.handleState(context);
+            KeyguardService.handleState(context);
         }
         return true;
     }
 
     /**
-     * Setter to only have the app running while charging
-     *
-     * @param context
-     * @param enabled
-     * @param listener
+     * Setter to enable the lockscreen mode.
      */
-    public void setActiveDisplayEnabledOnlyWhileCharging(Context context, boolean enabled,
-                                                         OnConfigChangedListener listener) {
-        saveOption(context, KEY_ONLY_WHILE_CHARGING, enabled, listener,
-                mEnabledOnlyWhileCharging != (mEnabledOnlyWhileCharging = enabled));
-    }
+    public void setKeyguardEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mKeyguardEnabled != (mKeyguardEnabled = enabled);
+        saveOption(context, KEY_KEYGUARD, enabled, listener, changed);
 
-    /**
-     * Setter to allow notifications with a lower priority like Google Now
-     *
-     * @param context
-     * @param enabled
-     * @param listener
-     */
-    public void setLowPriorityNotificationsAllowed(Context context, boolean enabled,
-                                                   OnConfigChangedListener listener) {
-        saveOption(context, KEY_LOW_PRIORITY_NOTIFICATIONS, enabled, listener,
-                mLowPriorityNotificationsAllowed != (mLowPriorityNotificationsAllowed = enabled));
+        if (changed) {
+            KeyguardService.handleState(context);
+        }
     }
 
     /**
-     * Setter to allow the screen to time out or not
-     *
-     * @param context
-     * @param enabled
-     * @param listener
+     * Setter to enable the active mode.
      */
-    public void setTimeOutAvailable(Context context, boolean enabled, OnConfigChangedListener listener) {
-        saveOption(context, KEY_TIMEOUT_ACTIVE, enabled, listener,
-                mCanTimeOut != (mCanTimeOut = enabled));
-    }
+    public void setActiveModeEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mActiveMode != (mActiveMode = enabled);
+        saveOption(context, KEY_ACTIVE_MODE, enabled, listener, changed);
 
-    /**
-     * Setter to set the timeout in a normal situation
-     * used via reflections!
-     *
-     * @param context
-     * @param delayMillis
-     * @param listener
-     */
-    public void setTimeoutNormal(Context context, int delayMillis, OnConfigChangedListener listener) {
-        saveOption(context, KEY_TIMEOUT_NORMAL, delayMillis, listener,
-                mTimeoutNormal != (mTimeoutNormal = delayMillis));
+        if (changed) {
+            ActiveModeService.handleState(context);
+        }
     }
 
     /**
-     * Setter for short timeout time
-     * used via reflections!
-     *
-     * @param context
-     * @param delayMillis
-     * @param listener
+     * Setter to only have the app running while charging.
      */
-    public void setTimeoutShort(Context context, int delayMillis, OnConfigChangedListener listener) {
-        saveOption(context, KEY_TIMEOUT_SHORT, delayMillis, listener,
-                mTimeoutShort != (mTimeoutShort = delayMillis));
+    public void setActiveDisplayEnabledOnlyWhileCharging(Context context, boolean enabled,
+                                                         OnConfigChangedListener listener) {
+        boolean changed = mEnabledOnlyWhileCharging != (mEnabledOnlyWhileCharging = enabled);
+        saveOption(context, KEY_ONLY_WHILE_CHARGING, enabled, listener, changed);
+
+        if (changed) {
+            ActiveModeService.handleState(context);
+            KeyguardService.handleState(context);
+        }
     }
 
     /**
-     * Setter to enable "night mode"
-     *
-     * @param context
-     * @param enabled
-     * @param listener
+     * Setter to allow notifications with a lower priority like Google Now.
      */
-    public void setInactiveTimeEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
-        saveOption(context, KEY_INACTIVE_TIME_ENABLED, enabled, listener,
-                mInactiveTimeEnabled != (mInactiveTimeEnabled = enabled));
+    public void setLowPriorityNotificationsAllowed(Context context, boolean enabled,
+                                                   OnConfigChangedListener listener) {
+        boolean changed = mNotifyLowPriority != (mNotifyLowPriority = enabled);
+        saveOption(context, KEY_LOW_PRIORITY_NOTIFICATIONS, enabled, listener, changed);
     }
 
     /**
-     * Setter for the time "night mode" should start
-     *
-     * @param context
-     * @param minutes
-     * @param listener
+     * Setter to allow the screen to time out or not.
      */
-    public void setInactiveTimeFrom(Context context, int minutes, OnConfigChangedListener listener) {
-        saveOption(context, KEY_INACTIVE_TIME_FROM, minutes, listener,
-                mInactiveTimeFrom != (mInactiveTimeFrom = minutes));
+    public void setTimeoutEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mTimeoutEnabled != (mTimeoutEnabled = enabled);
+        saveOption(context, KEY_TIMEOUT_ENABLED, enabled, listener, changed);
     }
 
     /**
-     * Setter for the time "night mode" should end
-     *
-     * @param context
-     * @param minutes
-     * @param listener
+     * Setter to set the timeout in a normal situation.
      */
-    public void setInactiveTimeTo(Context context, int minutes, OnConfigChangedListener listener) {
-        saveOption(context, KEY_INACTIVE_TIME_TO, minutes, listener,
-                mInactiveTimeTo != (mInactiveTimeTo = minutes));
+    // used via reflections!
+    public void setTimeoutNormal(Context context, int delayMillis, OnConfigChangedListener listener) {
+        boolean changed = mTimeoutNormal != (mTimeoutNormal = delayMillis);
+        saveOption(context, KEY_TIMEOUT_NORMAL, delayMillis, listener, changed);
     }
 
     /**
-     * TODO: write doc here
-     *
-     * @param context
-     * @param action
-     * @param listener
+     * Setter for short timeout time.
      */
-    public void setSwipeLeftAction(Context context, int action, OnConfigChangedListener listener) {
-        saveOption(context, KEY_SWIPE_LEFT_ACTION, action, listener,
-                mSwipeLeftAction != (mSwipeLeftAction = action));
+    // used via reflections!
+    public void setTimeoutShort(Context context, int delayMillis, OnConfigChangedListener listener) {
+        boolean changed = mTimeoutShort != (mTimeoutShort = delayMillis);
+        saveOption(context, KEY_TIMEOUT_SHORT, delayMillis, listener, changed);
     }
 
     /**
-     * TODO: write doc here
-     *
-     * @param context
-     * @param action
-     * @param listener
+     * Setter to enable "night mode".
      */
-    public void setSwipeRightAction(Context context, int action, OnConfigChangedListener listener) {
-        saveOption(context, KEY_SWIPE_RIGHT_ACTION, action, listener,
-                mSwipeRightAction != (mSwipeRightAction = action));
+    public void setInactiveTimeEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mInactiveTimeEnabled != (mInactiveTimeEnabled = enabled);
+        saveOption(context, KEY_INACTIVE_TIME_ENABLED, enabled, listener, changed);
     }
 
     /**
-     * Setter to enable the lockscreen mode
-     *
-     * @param context
-     * @param enabled
-     * @param listener
+     * Setter for the time "night mode" should start
      */
-    public void setLockscreenEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
-        boolean changed = mLockscreenEnabled != (mLockscreenEnabled = enabled);
-
-        saveOption(context, KEY_LOCK_SCREEN, enabled, listener, changed);
-
-        // Launch / stop lockscreen service
-        if (changed) LockscreenService.handleState(context);
+    public void setInactiveTimeFrom(Context context, int minutes, OnConfigChangedListener listener) {
+        boolean changed = mInactiveTimeFrom != (mInactiveTimeFrom = minutes);
+        saveOption(context, KEY_INACTIVE_TIME_FROM, minutes, listener, changed);
     }
 
     /**
-     * Setter to enable active mode
-     *
-     * @param context
-     * @param enabled
-     * @param listener
+     * Setter for the time "night mode" should end.
      */
-    public void setActiveModeEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
-        boolean changed = mActiveMode != (mActiveMode = enabled);
-        saveOption(context, KEY_ACTIVE_MODE, enabled, listener, changed);
-
-        // Launch / stop sensor monitor service
-        if (changed) ActiveModeService.handleState(context);
+    public void setInactiveTimeTo(Context context, int minutes, OnConfigChangedListener listener) {
+        boolean changed = mInactiveTimeTo != (mInactiveTimeTo = minutes);
+        saveOption(context, KEY_INACTIVE_TIME_TO, minutes, listener, changed);
     }
 
     /**
      * Setter to allow the wallpaper to be shown instead of black
-     *
-     * @param context
-     * @param shown
-     * @param listener
      */
     public void setWallpaperShown(Context context, boolean shown, OnConfigChangedListener listener) {
-        saveOption(context, KEY_INTERFACE_WALLPAPER_SHOWN, shown, listener,
-                mWallpaperShown != (mWallpaperShown = shown));
+        boolean changed = mUiWallpaper != (mUiWallpaper = shown);
+        saveOption(context, KEY_UI_WALLPAPER_SHOWN, shown, listener, changed);
     }
 
-    /**
-     * TODO: write doc
-     *
-     * @param context
-     * @param shown
-     * @param listener
-     */
     public void setShadowEnabled(Context context, boolean shown, OnConfigChangedListener listener) {
-        saveOption(context, KEY_INTERFACE_SHADOW_TOGGLE, shown, listener,
-                mShadowShown != (mShadowShown = shown));
+        boolean changed = mUiWallpaperShadow != (mUiWallpaperShadow = shown);
+        saveOption(context, KEY_UI_SHADOW_TOGGLE, shown, listener, changed);
     }
 
     /**
-     * Allow the background to change based on the notification
-     *
-     * @param context
-     * @param mode
-     * @param listener
+     * Allow the background to change based on the notification.
      */
     public void setDynamicBackgroundMode(Context context, int mode, OnConfigChangedListener listener) {
-        saveOption(context, KEY_INTERFACE_DYNAMIC_BACKGROUND_MODE, mode, listener,
-                mDynamicBackgroundMode != (mDynamicBackgroundMode = mode));
+        boolean changed = mUiDynamicBackground != (mUiDynamicBackground = mode);
+        saveOption(context, KEY_UI_DYNAMIC_BACKGROUND_MODE, mode, listener, changed);
     }
 
     /**
-     * Allow the dots to move in from both sides
-     *
-     * @param context
-     * @param enabled
-     * @param listener
+     * Allow the timeout bar to move in from both sides.
      */
     public void setMirroredTimeoutProgressBarEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
-        saveOption(context, KEY_INTERFACE_MIRRORED_TIMEOUT_PROGRESS_BAR, enabled, listener,
-                mMirroredTimeoutProgressBarEnabled != (mMirroredTimeoutProgressBarEnabled = enabled));
-    }
-
-    public boolean isTimeOutAvailable() {
-        return mCanTimeOut;
+        boolean changed = mUiMirroredTimeoutBar != (mUiMirroredTimeoutBar = enabled);
+        saveOption(context, KEY_UI_MIRRORED_TIMEOUT_BAR, enabled, listener, changed);
     }
 
     public int getTimeoutNormal() {
@@ -438,20 +361,20 @@ public class Config {
         return mInactiveTimeTo;
     }
 
-    public int getSwipeLeftAction() {
-        return mSwipeLeftAction;
+    public int getDynamicBackgroundMode() {
+        return mUiDynamicBackground;
     }
 
-    public int getSwipeRightAction() {
-        return mSwipeRightAction;
+    public boolean isEnabled() {
+        return mAcDisplayEnabled;
     }
 
-    public int getDynamicBackgroundMode() {
-        return mDynamicBackgroundMode;
+    public boolean isKeyguardEnabled() {
+        return mKeyguardEnabled;
     }
 
-    public boolean isActiveDisplayEnabled() {
-        return mActiveDisplayEnabled;
+    public boolean isActiveModeEnabled() {
+        return mActiveMode;
     }
 
     public boolean isEnabledOnlyWhileCharging() {
@@ -459,31 +382,27 @@ public class Config {
     }
 
     public boolean isLowPriorityNotificationsAllowed() {
-        return mLowPriorityNotificationsAllowed;
-    }
-
-    public boolean isLockscreenEnabled() {
-        return mLockscreenEnabled;
-    }
-
-    public boolean isActiveModeEnabled() {
-        return mActiveMode;
+        return mNotifyLowPriority;
     }
 
     public boolean isWallpaperShown() {
-        return mWallpaperShown;
+        return mUiWallpaper;
     }
 
     public boolean isShadowEnabled() {
-        return mShadowShown;
+        return mUiWallpaperShadow;
     }
 
     public boolean isMirroredTimeoutProgressBarEnabled() {
-        return mMirroredTimeoutProgressBarEnabled;
+        return mUiMirroredTimeoutBar;
     }
 
     public boolean isInactiveTimeEnabled() {
         return mInactiveTimeEnabled;
     }
 
+    public boolean isTimeoutEnabled() {
+        return mTimeoutEnabled;
+    }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Device.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Device.java
index d998faf9..de531de6 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Device.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Device.java
@@ -21,14 +21,25 @@ package com.achep.activedisplay;
 import android.os.Build;
 
 /**
- * Created by Artem on 25.02.14.
+ * Contains params of current device. This is nice because we can override
+ * some here to test compatibility with old API.
+ *
+ * @author Artem Chepurnoy
  */
 public class Device {
 
+    /**
+     * @return True if device is running
+     * {@link Build.VERSION_CODES#KITKAT KitKat} or higher, False otherwise.
+     */
     public static boolean hasKitKatApi() {
         return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
     }
 
+    /**
+     * @return True if device is running
+     * {@link Build.VERSION_CODES#JELLY_BEAN_MR2 Jelly Bean 4.3} or higher, False otherwise.
+     */
     public static boolean hasJellyBeanMR2Api() {
         return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java
index 75ab54df..fe9f7cc1 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java
@@ -121,11 +121,15 @@ public class DialogHelper {
         }
 
         public Builder setTitle(int titleRes) {
-            return setTitle(titleRes == 0 ? null : mContext.getResources().getString(titleRes));
+            return setTitle(titleRes == 0 ? null : getString(titleRes));
         }
 
         public Builder setMessage(int messageRes) {
-            return setMessage(messageRes == 0 ? null : mContext.getResources().getString(messageRes));
+            return setMessage(messageRes == 0 ? null : getString(messageRes));
+        }
+
+        private String getString(int stringRes) {
+            return mContext.getResources().getString(stringRes);
         }
 
         public Builder setView(View view) {
@@ -170,10 +174,13 @@ public class DialogHelper {
             return rootLayout;
         }
 
+        /**
+         * Wraps custom dialog to the default {@link AlertDialog.Builder} with custom view.
+         */
         public AlertDialog.Builder wrap() {
             return new AlertDialog.Builder(mContext).setView(create());
         }
 
     }
 
-}
+}
\ No newline at end of file
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java
index 1524be85..793ca65e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java
@@ -19,11 +19,18 @@
 package com.achep.activedisplay;
 
 /**
- * Created by Artem on 26.01.14.
+ * Additional functions which I'd like to see as
+ * operators.
+ *
+ * @author Artem Chepurnoy
  */
 public class Operator {
 
-    public static boolean bitandCompare(int v, int target) {
+    /**
+     * @return {@code (v & target) == target}
+     */
+    public static boolean bitAnd(int v, int target) {
         return (v & target) == target;
     }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/ActiveDisplayPresenter.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Presenter.java
similarity index 75%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/ActiveDisplayPresenter.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/Presenter.java
index 61ded119..1314108f 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/ActiveDisplayPresenter.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Presenter.java
@@ -23,9 +23,10 @@ import android.content.Context;
 import android.content.Intent;
 import android.os.PowerManager;
 import android.telephony.TelephonyManager;
+import android.util.Log;
 
 import com.achep.activedisplay.activities.AcDisplayActivity;
-import com.achep.activedisplay.services.LockscreenService;
+import com.achep.activedisplay.services.KeyguardService;
 import com.achep.activedisplay.utils.PowerUtils;
 
 import java.util.ArrayList;
@@ -33,18 +34,24 @@ import java.util.ArrayList;
 /**
  * Created by Artem on 07.03.14.
  */
-public class ActiveDisplayPresenter {
+public class Presenter {
 
-    private static final String TAG = "ActiveDisplayPresenter";
-    private static final String WAKE_LOCK_TAG = "AcDisplay starter.";
+    private static final String TAG = "AcDisplayPresenter";
+    private static final String WAKE_LOCK_TAG = "AcDisplay launcher.";
 
-    public void stop(Context context) {
+    /**
+     * Requests to lock screen from AcDisplay activity.
+     *
+     * @return true if locked, false otherwise
+     */
+    public boolean stop(Context context) {
+        //noinspection SimplifiableIfStatement
         if (mActivity != null
-                && mActivity.hasWindowFocus()
-               /* && mActivity.getTimeout().getTimeout() != 0*/
+                && mActivity.isCloseableBySensor()
                 && PowerUtils.isScreenOn(context)) {
-            mActivity.lock();
+            return mActivity.lock();
         }
+        return false;
     }
 
     public void start(Context context) {
@@ -68,7 +75,7 @@ public class ActiveDisplayPresenter {
         Config config = Config.getInstance(context);
 
         kill();
-        LockscreenService.ignoreCurrentTurningOn();
+        KeyguardService.ignoreCurrentTurningOn();
         context.startActivity(new Intent(Intent.ACTION_MAIN, null)
                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                         | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
@@ -76,8 +83,10 @@ public class ActiveDisplayPresenter {
                         | Intent.FLAG_ACTIVITY_NO_ANIMATION
                         | Intent.FLAG_FROM_BACKGROUND)
                 .putExtra(AcDisplayActivity.EXTRA_TURN_SCREEN_ON, true)
-                .putExtra(AcDisplayActivity.EXTRA_FINISH_ON_SCREEN_OFF, !config.isLockscreenEnabled())
+                .putExtra(AcDisplayActivity.EXTRA_FINISH_ON_SCREEN_OFF, !config.isKeyguardEnabled())
                 .setClass(context, AcDisplayActivity.class));
+
+        Log.i(TAG, "Launching AcDisplay activity.");
     }
 
     public void kill() {
@@ -91,27 +100,28 @@ public class ActiveDisplayPresenter {
         public void OnActiveDisplayStateChanged(Activity activity);
     }
 
-    private static ActiveDisplayPresenter sActiveDisplayPresenter;
+    private static Presenter sPresenter;
 
     private ArrayList<OnActiveDisplayStateChangedListener> mListeners;
     private AcDisplayActivity mActivity;
 
-    public static synchronized ActiveDisplayPresenter getInstance() {
-        if (sActiveDisplayPresenter == null)
-            sActiveDisplayPresenter = new ActiveDisplayPresenter();
-        return sActiveDisplayPresenter;
+    public static synchronized Presenter getInstance() {
+        if (sPresenter == null) {
+            sPresenter = new Presenter();
+        }
+        return sPresenter;
     }
 
-    private ActiveDisplayPresenter() {
+    private Presenter() {
         mListeners = new ArrayList<>(4);
     }
 
-    public void addOnActiveDisplayStateChangedListener(OnActiveDisplayStateChangedListener listener) {
-        if (!mListeners.contains(listener)) mListeners.add(listener);
+    public void registerListener(OnActiveDisplayStateChangedListener listener) {
+        mListeners.add(listener);
     }
 
-    public void removeOnActiveDisplayStateChangedListener(OnActiveDisplayStateChangedListener listener) {
-        if (mListeners.contains(listener)) mListeners.remove(listener);
+    public void unregisterListener(OnActiveDisplayStateChangedListener listener) {
+        mListeners.remove(listener);
     }
 
     public void attachActivity(AcDisplayActivity activity) {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java
index a6ddbbb8..438a7769 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java
@@ -21,20 +21,21 @@ package com.achep.activedisplay;
 import android.content.Context;
 
 /**
- * Does stuff with debug stuff
- * TODO: write a better doc
- * @author Artem
- * @since 30.12.13
+ * Created by Artem on 30.12.13.
  */
 public class Project {
 
+    /**
+     * Is it debug version?
+     */
     @SuppressWarnings("PointlessBooleanExpression")
     public static final boolean DEBUG = BuildConfig.MY_DEBUG && true;
 
+    /**
+     * Support email of this project.
+     */
     public static final String EMAIL = "support@artemchep.com";
 
-    public static final String SUFFIX = Project.class.getPackage().getName() + ":";
-
     public static String getPackageName(Context context) {
         return context.getApplicationInfo().packageName;
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java
index 4240e258..eddefa7b 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java
@@ -21,11 +21,18 @@ package com.achep.activedisplay;
 import android.os.Handler;
 import android.os.Message;
 import android.os.SystemClock;
+import android.view.animation.LinearInterpolator;
+
+import com.achep.activedisplay.animations.ProgressBarAnimation;
+import com.achep.activedisplay.utils.MathUtils;
+import com.achep.activedisplay.widgets.ProgressBar;
 
 import java.util.ArrayList;
 
 /**
  * Created by Artem on 26.01.14.
+ *
+ * @author Artem Chepurnoy
  */
 public class Timeout {
 
@@ -34,6 +41,8 @@ public class Timeout {
     public static final int EVENT_TIMEOUT = 0;
     public static final int EVENT_CHANGED = 1;
     public static final int EVENT_CLEARED = 2;
+    public static final int EVENT_PAUSED = 3;
+    public static final int EVENT_RESUMED = 4;
 
     private final ArrayList<OnTimeoutEventListener> mListeners = new ArrayList<>();
     private final Handler mHandler = new Handler() {
@@ -48,48 +57,112 @@ public class Timeout {
         }
     };
 
+    private long mTimeoutLockedAt;
+    private long mTimeoutStart;
     private long mTimeoutAt;
-    private boolean mLocked;
 
     public interface OnTimeoutEventListener {
-        public void onTimeoutEvent(int event);
+        public void onTimeoutEvent(Timeout timeout, int event);
     }
 
-    public final void addListener(OnTimeoutEventListener listener) {
+    public final void registerListener(OnTimeoutEventListener listener) {
         mListeners.add(listener);
     }
 
-    public final void removeListener(OnTimeoutEventListener listener) {
+    public final void unregisterListener(OnTimeoutEventListener listener) {
         mListeners.remove(listener);
     }
 
-    private void notifyOnEvent(int event) {
+    private void notifyListeners(int event) {
         for (OnTimeoutEventListener l : mListeners) {
-            l.onTimeoutEvent(event);
+            l.onTimeoutEvent(this, event);
         }
     }
 
+    private long getTime() {
+        return SystemClock.uptimeMillis();
+    }
+
     private void timeout() {
-        notifyOnEvent(EVENT_TIMEOUT);
+        notifyListeners(EVENT_TIMEOUT);
+        mTimeoutAt = 0;
     }
 
-    public void lock() {
-        mLocked = true;
-        clear();
+    /**
+     * Pauses running timer and sends {@link #EVENT_PAUSED}.
+     * While it's paused all methods except of
+     * {@link #resume() resuming} will be ignored!
+     *
+     * @see #resume()
+     * @see #EVENT_PAUSED
+     */
+    public void pause() {
+        if (!isPaused()) {
+            mTimeoutLockedAt = getTime();
+            mHandler.removeMessages(0);
+            notifyListeners(EVENT_PAUSED);
+        }
     }
 
-    public void release() {
-        mLocked = false;
+    public void resume() {
+        if (!isPaused()) {
+            return;
+        }
+
+        long offset = getTime() - mTimeoutLockedAt;
+
+        mTimeoutLockedAt = 0;
+
+        if (mTimeoutAt > 0) {
+            mTimeoutStart += offset;
+            mTimeoutAt += offset;
+
+            mHandler.sendEmptyMessageAtTime(0, mTimeoutAt);
+        }
+
+        notifyListeners(EVENT_RESUMED);
     }
 
     public void clear() {
-        mTimeoutAt = 0;
-        mHandler.removeMessages(0);
-        notifyOnEvent(EVENT_CLEARED);
+        if (!isPaused()) {
+            mTimeoutAt = 0;
+            mHandler.removeMessages(0);
+            notifyListeners(EVENT_CLEARED);
+        }
+    }
+
+    /**
+     * If timer isn't {@link #pause() paused} delays current
+     * timeout.
+     *
+     * @param delayMillis millis to delay
+     * @see #pause()
+     * @see #EVENT_CHANGED
+     */
+    public void delay(long delayMillis) {
+        if (!isPaused() && isOngoing()) {
+            mTimeoutStart += delayMillis;
+            mTimeoutAt += delayMillis;
+
+            mHandler.removeMessages(0);
+            mHandler.sendEmptyMessageAtTime(0, mTimeoutAt);
+
+            notifyListeners(EVENT_CHANGED);
+        }
     }
 
-    public void setTimeoutAt(long millis) {
-        setTimeoutAt(millis, false);
+    /**
+     * @return True if countdown timer is active at this moment, False otherwise.
+     */
+    public boolean isOngoing() {
+        return mTimeoutAt > 0;
+    }
+
+    /**
+     * @return True if countdown timer is paused, False otherwise.
+     */
+    public boolean isPaused() {
+        return mTimeoutLockedAt > 0;
     }
 
     public void setTimeoutDelayed(long delayMillis) {
@@ -97,27 +170,80 @@ public class Timeout {
     }
 
     public void setTimeoutDelayed(long delayMillis, boolean resetOld) {
-        setTimeoutAt(SystemClock.uptimeMillis() + delayMillis, resetOld);
-    }
+        long timeoutStart = getTime();
+        long timeoutAt = timeoutStart + delayMillis;
 
-    public void setTimeoutAt(long millis, boolean resetOld) {
-        if (mTimeoutAt > 0 && mTimeoutAt < millis && !resetOld || mLocked) {
+        if (isOngoing() && mTimeoutAt < timeoutAt && !resetOld || isPaused()) {
             return;
         }
 
-        mTimeoutAt = millis;
+        mTimeoutStart = timeoutStart;
+        mTimeoutAt = timeoutAt;
+
         mHandler.removeMessages(0);
-        mHandler.sendEmptyMessageAtTime(0, millis);
+        mHandler.sendEmptyMessageAtTime(0, mTimeoutAt);
+
+        notifyListeners(EVENT_CHANGED);
+    }
 
-        notifyOnEvent(EVENT_CHANGED);
+    private long getTimeoutNow() {
+        return isPaused() ? mTimeoutLockedAt : getTime();
     }
 
     public long getRemainingTime() {
-        return getTimeout() - SystemClock.uptimeMillis();
+        return mTimeoutAt - getTimeoutNow();
+    }
+
+    public float getProgress() {
+        float max = mTimeoutAt - mTimeoutStart;
+        float now = getRemainingTime();
+        return MathUtils.range(1f - now / max, 0, 1);
     }
 
-    public long getTimeout() {
-        return mTimeoutAt;
+    /**
+     * Updates given {@link com.achep.activedisplay.widgets.ProgressBar}
+     * due to timeout's event.
+     */
+    public static class Gui implements Timeout.OnTimeoutEventListener {
+
+        private static final int MAX = 300;
+
+        private final ProgressBarAnimation mProgressBarAnimation;
+        private final ProgressBar mProgressBar;
+
+        public Gui(ProgressBar progressBar) {
+            mProgressBar = progressBar;
+            mProgressBar.setMax(MAX);
+            mProgressBar.setProgress(MAX);
+            mProgressBarAnimation = new ProgressBarAnimation(mProgressBar, MAX, 0);
+            mProgressBarAnimation.setInterpolator(new LinearInterpolator());
+        }
+
+        @Override
+        public void onTimeoutEvent(Timeout timeout, int event) {
+            switch (event) {
+                case Timeout.EVENT_PAUSED:
+                    mProgressBar.clearAnimation();
+                    break;
+                case Timeout.EVENT_RESUMED:
+                case Timeout.EVENT_CHANGED:
+                    long remainingTime = timeout.getRemainingTime();
+                    if (remainingTime > 0 && !timeout.isPaused()) {
+                        int progress = (int) (
+                                mProgressBar.getMax() * (1f - timeout.getProgress())
+                        );
+                        mProgressBarAnimation.setRange(progress, 0);
+                        mProgressBarAnimation.setDuration(remainingTime);
+                        mProgressBar.setProgress(progress);
+                        mProgressBar.startAnimation(mProgressBarAnimation);
+                    }
+                    break;
+                case Timeout.EVENT_CLEARED:
+                    mProgressBar.clearAnimation();
+                    mProgressBar.setProgress(mProgressBar.getMax());
+                    break;
+            }
+        }
     }
 
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/AccelerometerSensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/AccelerometerSensor.java
index 5077488d..ba4d358c 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/AccelerometerSensor.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/AccelerometerSensor.java
@@ -52,12 +52,12 @@ public class AccelerometerSensor extends ActiveSensor implements
 
     @Override
     public int getType() {
-        return ACCELEROMETER;
+        return Sensor.TYPE_ACCELEROMETER;
     }
 
     @Override
     protected boolean isSupported(SensorManager sensorManager, Context context) {
-        return sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() > 0 && false;
+        return false;
     }
 
     @Override
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
index 3181ac15..e6ef2626 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
@@ -33,7 +33,7 @@ import android.os.PowerManager;
 import android.os.SystemClock;
 import android.util.Log;
 
-import com.achep.activedisplay.ActiveDisplayPresenter;
+import com.achep.activedisplay.Presenter;
 import com.achep.activedisplay.Config;
 import com.achep.activedisplay.InactiveHoursHelper;
 import com.achep.activedisplay.NotificationIds;
@@ -67,17 +67,17 @@ public class ActiveModeService extends Service implements Config.OnConfigChanged
 
         @Override
         public void onReceive(Context context, Intent intent) {
-            ActiveDisplayPresenter presenter = ActiveDisplayPresenter.getInstance();
+            Presenter presenter = Presenter.getInstance();
             switch (intent.getAction()) {
                 case Intent.ACTION_SCREEN_ON:
-                    presenter.addOnActiveDisplayStateChangedListener(mStateListener);
+                    presenter.registerListener(mStateListener);
 
                     if (!presenter.isActivityAttached()) {
                         stopListening();
                     }
                     break;
                 case Intent.ACTION_SCREEN_OFF:
-                    presenter.removeOnActiveDisplayStateChangedListener(mStateListener);
+                    presenter.unregisterListener(mStateListener);
                     startListeningDelayed(250);
                     break;
             }
@@ -93,8 +93,8 @@ public class ActiveModeService extends Service implements Config.OnConfigChanged
         }
     };
 
-    private ActiveDisplayPresenter.OnActiveDisplayStateChangedListener mStateListener =
-            new ActiveDisplayPresenter.OnActiveDisplayStateChangedListener() {
+    private Presenter.OnActiveDisplayStateChangedListener mStateListener =
+            new Presenter.OnActiveDisplayStateChangedListener() {
                 @Override
                 public void OnActiveDisplayStateChanged(Activity activity) {
                     if (activity == null) {
@@ -115,7 +115,7 @@ public class ActiveModeService extends Service implements Config.OnConfigChanged
         boolean onlyWhileChangingOption = !config.isEnabledOnlyWhileCharging()
                 || PowerUtils.isPlugged(context);
 
-        if (config.isActiveDisplayEnabled()
+        if (config.isEnabled()
                 && config.isActiveModeEnabled()
                 && onlyWhileChangingOption) {
             context.startService(intent);
@@ -235,13 +235,15 @@ public class ActiveModeService extends Service implements Config.OnConfigChanged
     }
 
     @Override
-    public void onShowEvent(ActiveSensor sensor) {
-        ActiveDisplayPresenter.getInstance().start(this);
+    public boolean onShowEvent(ActiveSensor sensor) {
+        Presenter.getInstance().start(this);
+        return false;
     }
 
     @Override
-    public void onHideEvent(ActiveSensor sensor) {
-        ActiveDisplayPresenter.getInstance().stop(this);
+    public boolean onHideEvent(ActiveSensor sensor) {
+        Presenter.getInstance().stop(this);
+        return false;
     }
 
     @Override
@@ -268,7 +270,7 @@ public class ActiveModeService extends Service implements Config.OnConfigChanged
 
     void start() {
         PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-        ActiveDisplayPresenter presenter = ActiveDisplayPresenter.getInstance();
+        Presenter presenter = Presenter.getInstance();
         if (pm.isScreenOn()) {
             mStateListener.OnActiveDisplayStateChanged(presenter.getActivity());
         } else {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveSensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveSensor.java
index 2f8aa329..086641e1 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveSensor.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveSensor.java
@@ -30,13 +30,10 @@ import java.util.ArrayList;
  */
 public abstract class ActiveSensor {
 
-    public static final int PROXIMITY = 0;
-    public static final int ACCELEROMETER = 1;
-
     public interface SensorCallback {
-        public void onShowEvent(ActiveSensor sensor);
+        public boolean onShowEvent(ActiveSensor sensor);
 
-        public void onHideEvent(ActiveSensor sensor);
+        public boolean onHideEvent(ActiveSensor sensor);
     }
 
     private ArrayList<SensorCallback> mCallbacks;
@@ -65,9 +62,11 @@ public abstract class ActiveSensor {
         }
     }
 
-    public abstract int getType();
+    protected boolean isSupported(SensorManager sensorManager, Context context) {
+        return sensorManager.getSensorList(getType()).size() > 0;
+    }
 
-    protected abstract boolean isSupported(SensorManager sensorManager, Context context);
+    public abstract int getType();
 
     protected abstract void onAttached(SensorManager sensorManager, Context context);
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java
index ff21d1fb..605c6f13 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java
@@ -76,12 +76,7 @@ public class ProximitySensor extends ActiveSensor implements
 
     @Override
     public int getType() {
-        return PROXIMITY;
-    }
-
-    @Override
-    protected boolean isSupported(SensorManager sensorManager, Context context) {
-        return sensorManager.getSensorList(Sensor.TYPE_PROXIMITY).size() > 0;
+        return Sensor.TYPE_PROXIMITY;
     }
 
     @Override
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java
index 7d8797a4..da6dd21f 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/AcDisplayActivity.java
@@ -21,36 +21,56 @@ package com.achep.activedisplay.activities;
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
 import android.annotation.TargetApi;
-import android.app.FragmentManager;
+import android.content.Context;
+import android.content.Intent;
 import android.graphics.Bitmap;
+import android.media.AudioManager;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.SystemClock;
+import android.util.Log;
+import android.view.GestureDetector;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
 import android.widget.ImageView;
 
-import com.achep.activedisplay.ActiveDisplayPresenter;
 import com.achep.activedisplay.Config;
 import com.achep.activedisplay.Device;
+import com.achep.activedisplay.Operator;
+import com.achep.activedisplay.Presenter;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.fragments.AcDisplayFragment;
+import com.achep.activedisplay.Timeout;
+import com.achep.activedisplay.widgets.CircleView;
 
 /**
  * Created by Artem on 25.01.14.
  */
-public class AcDisplayActivity extends KeyguardActivity {
+public class AcDisplayActivity extends KeyguardActivity implements
+        Timeout.OnTimeoutEventListener, CircleView.Callback {
 
     private static final String TAG = "AcDisplayActivity";
 
+    // pending finish
     private static final int PENDING_FINISH_MAX_TIME = 1000; // ms.
     private static final int PENDING_FINISH_DELAY = 600; // ms.
 
-    private AcDisplayFragment mAcDisplayFragment;
+    // timeout
+    private static final int TIMEOUT_PANIC_MIN_TIME = 1000; // ms.
+
+    private CircleView mCircleView;
     private ImageView mBackgroundView;
+
     private boolean mCustomBackgroundShown;
+    private boolean mImmersiveMode;
+
+    private GestureDetector mGestureDetector;
+    private Handler mHandler = new Handler();
+    private Timeout mTimeout = new T();
+    private Config mConfig;
 
     private long mPendingFinishTime;
     private Runnable mPendingFinishRunnable = new Runnable() {
@@ -59,13 +79,36 @@ public class AcDisplayActivity extends KeyguardActivity {
             unlock(null, true);
         }
     };
-    private Handler mHandler = new Handler();
+
+    private class T extends Timeout {
+
+        @Override
+        public void setTimeoutDelayed(long delayMillis, boolean resetOld) {
+            // This is a "workaround" solution for the
+            // never time out option.
+            if (mConfig.isTimeoutEnabled()) {
+                super.setTimeoutDelayed(delayMillis, resetOld);
+            }
+        }
+    }
+
+    private class GestureListener extends GestureDetector.SimpleOnGestureListener {
+
+        @Override
+        public boolean onSingleTapUp(MotionEvent e) {
+            return false;
+        }
+
+        @Override
+        public boolean onDoubleTap(MotionEvent e) {
+            return lock();
+        }
+    }
 
     @Override
     public void onWindowFocusChanged(boolean hasFocus) {
         super.onWindowFocusChanged(hasFocus);
         handleWindowFocusChanged(hasFocus);
-        mAcDisplayFragment.onWindowFocusChanged(hasFocus);
     }
 
     @TargetApi(Build.VERSION_CODES.KITKAT)
@@ -79,20 +122,26 @@ public class AcDisplayActivity extends KeyguardActivity {
                     | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                     | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                     | View.SYSTEM_UI_FLAG_FULLSCREEN;
-            if (Device.hasKitKatApi()) visibility |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
+            if (mImmersiveMode) visibility |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
             window.getDecorView().setSystemUiVisibility(visibility);
             window.addFlags(windowFlags);
+
+            // Start ticking.
+            mTimeout.resume();
         } else {
             window.clearFlags(windowFlags);
+
+            mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
+            mTimeout.pause();
         }
     }
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        Config config = Config.getInstance(this);
-        if (config.isWallpaperShown()) {
-            if (config.isShadowEnabled()) {
+        mConfig = Config.getInstance(this);
+        if (mConfig.isWallpaperShown()) {
+            if (mConfig.isShadowEnabled()) {
                 setTheme(R.style.AcDisplayTheme_Wallpaper_WithShadow);
             } else {
                 setTheme(R.style.AcDisplayTheme_Wallpaper);
@@ -100,12 +149,17 @@ public class AcDisplayActivity extends KeyguardActivity {
         }
 
         setContentView(R.layout.activity_acdisplay);
-        FragmentManager fm = getFragmentManager();
-
-        mAcDisplayFragment = (AcDisplayFragment) fm.findFragmentById(R.id.acdisplay_fragment);
         mBackgroundView = (ImageView) findViewById(R.id.background);
+        mCircleView = (CircleView) findViewById(R.id.circle);
+        mCircleView.setCallback(this);
+
+        mImmersiveMode = Device.hasKitKatApi();
+        mGestureDetector = new GestureDetector(this, new GestureListener());
+
+        mTimeout.registerListener(this);
+        mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal());
 
-        ActiveDisplayPresenter.getInstance().attachActivity(this);
+        Presenter.getInstance().attachActivity(this);
     }
 
     @Override
@@ -118,29 +172,143 @@ public class AcDisplayActivity extends KeyguardActivity {
     @Override
     protected void onPause() {
         super.onPause();
+        mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
+        mTimeout.pause();
 
-        if (SystemClock.uptimeMillis() - mPendingFinishTime < PENDING_FINISH_MAX_TIME) {
-            mHandler.postDelayed(mPendingFinishRunnable, PENDING_FINISH_DELAY);
+        if (SystemClock.elapsedRealtime() - mPendingFinishTime < PENDING_FINISH_MAX_TIME) {
+            mPendingFinishTime = 0;
+            mHandler.postDelayed(
+                    mPendingFinishRunnable,
+                    PENDING_FINISH_DELAY);
         }
     }
 
     @Override
     protected void onDestroy() {
         super.onDestroy();
-        ActiveDisplayPresenter.getInstance().detachActivity();
+        mTimeout.unregisterListener(this);
+        mTimeout.clear();
+        Presenter.getInstance().detachActivity();
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        boolean handled = false;
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_VOLUME_UP:
+                if (Operator.bitAnd(event.getFlags(), KeyEvent.FLAG_LONG_PRESS)) {
+
+                    AudioManager am = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
+                    if (am.isMusicActive()) {
+                        handled = true;
+
+                        // sendMediaButtonClick(keyCode == KeyEvent.KEYCODE_VOLUME_DOWN
+                        //         ? KeyEvent.KEYCODE_MEDIA_NEXT
+                        //         : KeyEvent.KEYCODE_MEDIA_PREVIOUS);
+                        // TODO: Go to previous / next track on long press of volume keys (if music is playing).
+                    }
+                }
+                break;
+            default:
+                return super.onKeyDown(keyCode, event);
+        }
+        return super.onKeyDown(keyCode, event);
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        // TODO: Skip "Leave immersive mode swipes".
+
+        mCircleView.onTouchEvent2(event);
+        mGestureDetector.onTouchEvent(event);
+
+        return super.onTouchEvent(event);
+    }
+
+    @Override
+    public void onTimeoutEvent(Timeout timeout, int event) {
+        switch (event) {
+            case Timeout.EVENT_TIMEOUT:
+                lock();
+                break;
+        }
+    }
+
+    @Override
+    public void onCircleEvent(float radius, float ratio, int event) {
+        switch (event) {
+            case CircleView.ACTION_START:
+                mTimeout.pause();
+                break;
+            case CircleView.ACTION_UNLOCK:
+                unlock(null, true);
+                break;
+            case CircleView.ACTION_CANCELED:
+                mTimeout.resume();
+
+                // If remaining time is very low - increase
+                // it to provide user a bit more time to fap
+                // on features.
+                if (mTimeout.getRemainingTime() < TIMEOUT_PANIC_MIN_TIME) {
+                    mTimeout.delay(TIMEOUT_PANIC_MIN_TIME);
+                }
+                break;
+        }
     }
 
     @Override
     public void unlock(Runnable runnable, boolean finish) {
         super.unlock(runnable, finish);
         if (!finish) {
-            mPendingFinishTime = SystemClock.uptimeMillis();
+            mPendingFinishTime = SystemClock.elapsedRealtime();
         }
     }
 
+    /**
+     * Sends media button's click with given key code.
+     *
+     * @param keyCode May be one of media key events.
+     * @see KeyEvent#KEYCODE_MEDIA_NEXT
+     * @see KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE
+     * @see KeyEvent#KEYCODE_MEDIA_PREVIOUS
+     */
+    private void sendMediaButtonClick(int keyCode) {
+        Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+        KeyEvent keyDown = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
+        KeyEvent keyUp = new KeyEvent(KeyEvent.ACTION_UP, keyCode);
+
+        sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyDown), null);
+        sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyUp), null);
+    }
+
+    /**
+     * @return an instance of timeout handler.
+     */
+    public Timeout getTimeout() {
+        return mTimeout;
+    }
+
+    /**
+     * @return an instance of timeout config.
+     */
+    public Config getConfig() {
+        return mConfig;
+    }
+
+    /**
+     * @return True is this activity may be closed by
+     * {@link com.achep.activedisplay.activemode.ActiveSensor active sensors}.
+     */
+    // TODO: Write something better
+    public boolean isCloseableBySensor() {
+        return !mTimeout.isPaused() && hasWindowFocus();
+    }
+
     public void dispatchSetBackground(Bitmap bitmap) {
         if (bitmap == null) {
             if (mCustomBackgroundShown) {
+                mBackgroundView.animate().cancel();
                 mBackgroundView.animate().alpha(0f).setListener(
                         new AnimatorListenerAdapter() {
                             @Override
@@ -166,4 +334,5 @@ public class AcDisplayActivity extends KeyguardActivity {
         mBackgroundView.animate().cancel();
         mBackgroundView.animate().alpha(0.8f).setListener(null);
     }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/KeyguardActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/KeyguardActivity.java
index 5a290755..07f75ee9 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/KeyguardActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/KeyguardActivity.java
@@ -19,6 +19,7 @@
 package com.achep.activedisplay.activities;
 
 import android.app.Activity;
+import android.app.KeyguardManager;
 import android.app.admin.DevicePolicyManager;
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -26,13 +27,18 @@ import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.Bundle;
 import android.os.Handler;
+import android.util.Log;
 import android.view.WindowManager;
 
+import com.achep.activedisplay.Project;
+
 /**
  * Created by Artem on 23.02.14.
  */
 public abstract class KeyguardActivity extends Activity {
 
+    private static final String TAG = "KeyguardActivity";
+
     public static final String EXTRA_TURN_SCREEN_ON = "turn_screen_on";
     public static final String EXTRA_FINISH_ON_SCREEN_OFF = "finish_on_screen_off";
 
@@ -45,32 +51,33 @@ public abstract class KeyguardActivity extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         boolean finishOnScreenOff = false;
-        int windowExtraFlags = 0;
+        int windowFlags = 0;
 
         Intent intent = getIntent();
         if (intent != null) {
             finishOnScreenOff = intent.getBooleanExtra(EXTRA_FINISH_ON_SCREEN_OFF, false);
             if (intent.getBooleanExtra(EXTRA_TURN_SCREEN_ON, false)) {
-                windowExtraFlags |= WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
+                windowFlags |= WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
             }
         }
 
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
                 | WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES
-                | windowExtraFlags);
+                | windowFlags);
 
         mLocking = false;
         mUnlocking = false;
 
         if (finishOnScreenOff) {
-            IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
+            IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
+            intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1);
             registerReceiver((mScreenOffReceiver = new BroadcastReceiver() {
 
                 @Override
                 public void onReceive(final Context context, Intent intent) {
                     finish();
                 }
-            }), filter);
+            }), intentFilter);
         }
     }
 
@@ -90,7 +97,12 @@ public abstract class KeyguardActivity extends Activity {
         }
     }
 
-    public void lock() {
+    /**
+     * Turns screen off.
+     *
+     * @return True if successful, False otherwise.
+     */
+    public boolean lock() {
         DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
         try {
             dpm.lockNow();
@@ -98,6 +110,7 @@ public abstract class KeyguardActivity extends Activity {
         } catch (SecurityException e) {
             mLocking = false;
         }
+        return mLocking;
     }
 
     /**
@@ -106,19 +119,29 @@ public abstract class KeyguardActivity extends Activity {
      * @param runnable may be null
      */
     public void unlock(final Runnable runnable, final boolean finish) {
+        if (Project.DEBUG) Log.d(TAG, "Unlocking with params: finish=" + finish);
+
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
 
+        // If keyguard is disabled no need to make
+        // a delay between calling this method and
+        // unlocking.
+        // Otherwise we need this delay to get new
+        // flags applied.
+        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
+        int delay = km.isKeyguardLocked() ? 120 : 0;
+
         mUnlocking = true;
         new Handler().postDelayed(new Runnable() {
             @Override
             public void run() {
                 if (runnable != null) runnable.run();
                 if (finish) {
-                    overridePendingTransition(0, 0);
                     finish();
+                    overridePendingTransition(0, 0);
                 }
             }
-        }, 120 /* We need this delay to get new flags applied. */);
+        }, delay);
     }
 
     public final boolean isLocking() {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java
index e4fbed0b..eedda223 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java
@@ -29,8 +29,10 @@ import android.content.SharedPreferences;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.media.RingtoneManager;
+import android.os.Build;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
+import android.text.Html;
 import android.util.Log;
 import android.view.Menu;
 import android.view.MenuItem;
@@ -53,10 +55,7 @@ import com.achep.activedisplay.utils.AccessUtils;
 import com.achep.activedisplay.utils.ViewUtils;
 
 /**
- * Main class, gets UI stuff and all that
- *
- * @author Artem
- * @since 21.01.14
+ * Created by Artem on 21.01.14.
  */
 public class MainActivity extends Activity implements Config.OnConfigChangedListener {
 
@@ -88,7 +87,7 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         getActionBar().setDisplayShowCustomEnabled(true);
         getActionBar().setCustomView(R.layout.layout_ab_switch);
         mSwitch = (Switch) getActionBar().getCustomView().findViewById(R.id.switch_);
-        mSwitch.setChecked(mConfig.isActiveDisplayEnabled());
+        mSwitch.setChecked(mConfig.isEnabled());
         mSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
 
             @Override
@@ -98,7 +97,7 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
                     return;
                 }
 
-                boolean successfully = mConfig.setActiveDisplayEnabled(
+                boolean successfully = mConfig.setEnabled(
                         MainActivity.this, b, MainActivity.this);
 
                 if (!successfully) {
@@ -118,8 +117,23 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
             if (oldVersionCode < pi.versionCode) {
                 prefs.edit().putInt("previous_version_code", pi.versionCode).commit();
 
-                if (oldVersionCode < 15 /* version v2.0- */) {
-                    DialogHelper.showNewsDialog(this);
+                if (oldVersionCode < 18 /* v2.1.x- */) {
+
+                    // Show the warning message for Paranoid Android users.
+                    if (Build.DISPLAY.startsWith("pa_")) {
+                        CharSequence messageText = Html.fromHtml(getString(R.string.pa_message));
+                        new DialogHelper.Builder(this)
+                                .setTitle(R.string.pa_title)
+                                .setMessage(messageText)
+                                .wrap()
+                                .setPositiveButton(android.R.string.ok, null)
+                                .create()
+                                .show();
+                    }
+
+                    if (oldVersionCode < 15 /* v2.0- */) {
+                        DialogHelper.showNewsDialog(this);
+                    }
                 }
             }
         } catch (PackageManager.NameNotFoundException e) {
@@ -133,9 +147,6 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         updateAccessPanel();
     }
 
-    /**
-     * Gives the annoying red bar to indicate not enough access
-     */
     private void initAccessPanel() {
         mAccessWarningPanel = (ViewGroup) ((ViewStub) findViewById(R.id.access)).inflate();
         mAccessAllowNotification = mAccessWarningPanel.findViewById(R.id.access_notification);
@@ -158,9 +169,6 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         });
     }
 
-    /**
-     * If some access was granted we update and maybe hide some parts
-     */
     private void updateAccessPanel() {
         boolean showDeviceAdminBtn = !AccessUtils.isDeviceAdminEnabled(this);
         boolean showNotifiesBtn = !AccessUtils.isNotificationAccessEnabled(this);
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java
index f867a7cd..542c3ff5 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java
@@ -40,10 +40,10 @@ public class AdminReceiver extends android.app.admin.DeviceAdminReceiver {
         LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(ACTION_DISABLED));
 
         Config config = Config.getInstance(context);
-        if (config.isActiveDisplayEnabled()) {
+        if (config.isEnabled()) {
 
             Toast.makeText(context, R.string.app_auto_disabled, Toast.LENGTH_LONG).show();
-            config.setActiveDisplayEnabled(context, false, null); // auto disabling :/
+            config.setEnabled(context, false, null); // auto disabling :/
         }
     }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/AnimationListenerAdapter.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/AnimationListenerAdapter.java
new file mode 100644
index 00000000..a9c5cc5e
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/AnimationListenerAdapter.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.animations;
+
+import android.view.animation.Animation;
+
+/**
+ * An empty class that implements {@link Animation.AnimationListener}
+ */
+public class AnimationListenerAdapter implements Animation.AnimationListener {
+
+    @Override
+    public void onAnimationStart(Animation animation) {
+
+    }
+
+    @Override
+    public void onAnimationEnd(Animation animation) {
+
+    }
+
+    @Override
+    public void onAnimationRepeat(Animation animation) {
+
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/CircleViewAnimation.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/CircleViewAnimation.java
new file mode 100644
index 00000000..a73c7c08
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/CircleViewAnimation.java
@@ -0,0 +1,37 @@
+package com.achep.activedisplay.animations;
+
+import android.view.animation.Animation;
+import android.view.animation.Transformation;
+
+import com.achep.activedisplay.widgets.CircleView;
+
+/**
+ * Created by achep on 19.04.14.
+ */
+public class CircleViewAnimation extends Animation {
+
+    private final CircleView mCircleView;
+    private float from;
+    private float to;
+
+    public CircleViewAnimation(CircleView circleView, float from, float to) {
+        super();
+        mCircleView = circleView;
+        this.from = from;
+        this.to = to;
+    }
+
+    @Override
+    protected void applyTransformation(float interpolatedTime, Transformation t) {
+        super.applyTransformation(interpolatedTime, t);
+        float value = (from + (to - from) * interpolatedTime);
+
+        mCircleView.setRadius(value);
+    }
+
+    public void setRange(float from, float to) {
+        this.from = from;
+        this.to = to;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/ProgressBarAnimation.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/ProgressBarAnimation.java
index 1f6971ec..8b9b0642 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/ProgressBarAnimation.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/animations/ProgressBarAnimation.java
@@ -29,10 +29,10 @@ import android.widget.ProgressBar;
 public class ProgressBarAnimation extends Animation {
 
     private final ProgressBar mProgressBar;
-    private final float from;
-    private final float to;
+    private int from;
+    private int to;
 
-    public ProgressBarAnimation(ProgressBar progressBar, float from, float to) {
+    public ProgressBarAnimation(ProgressBar progressBar, int from, int to) {
         super();
         mProgressBar = progressBar;
         this.from = from;
@@ -48,4 +48,9 @@ public class ProgressBarAnimation extends Animation {
         }
     }
 
+    public void setRange(int from, int to) {
+        this.from = from;
+        this.to = to;
+    }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/AppConfig.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/AppConfig.java
index d8846f7d..abc1f108 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/AppConfig.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/AppConfig.java
@@ -67,7 +67,7 @@ public class AppConfig {
     /**
      * Simple wrapper of package name.
      *
-     * @return an instance of empty {@link AppConfig} with package name.
+     * @return an instance of empty {@link com.achep.activedisplay.blacklist.AppConfig} with package name.
      */
     public static AppConfig wrap(String packageName) {
         return new AppConfig(packageName, DEFAULT_ENABLED, DEFAULT_RESTRICTED, DEFAULT_HIDDEN);
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/BlacklistEnabler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/BlacklistEnabler.java
index 271cd977..77e957dd 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/BlacklistEnabler.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/BlacklistEnabler.java
@@ -148,7 +148,7 @@ public class BlacklistEnabler extends Blacklist.OnBlacklistChangedListener
         if (configNew.equals(mAppConfig)) {
             AppConfig.copy(configNew, mAppConfig);
 
-            if (Operator.bitandCompare(diff, AppConfig.DIFF_ENABLED))
+            if (Operator.bitAnd(diff, AppConfig.DIFF_ENABLED))
                 setChecked(configNew.enabled);
             for (Blacklist.OnBlacklistChangedListener listener : mListeners)
                 listener.onBlacklistChanged(mAppConfig, configOld, diff);
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java
index 6d6d883a..70e159c2 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java
@@ -51,7 +51,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
          *
          * @param objectNew current object
          * @param objectOld old object from the list
-         * @param diff      the difference between old and new objects (provided by {@link Comparator})
+         * @param diff      the difference between old and new objects (provided by {@link com.achep.activedisplay.blacklist.SharedList.Comparator})
          */
         public void onPut(V objectNew, V objectOld, int diff);
 
@@ -236,8 +236,8 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
     public static abstract class Saver<V> {
 
         /**
-         * Should not overwrite value at {@link SharedList#KEY_NUMBER} or/and
-         * has key which starts with {@link SharedList#KEY_USED_ITEM}!
+         * Should not overwrite value at {@link com.achep.activedisplay.blacklist.SharedList#KEY_NUMBER} or/and
+         * has key which starts with {@link com.achep.activedisplay.blacklist.SharedList#KEY_USED_ITEM}!
          */
         public abstract SharedPreferences.Editor put(V object, SharedPreferences.Editor editor, int position);
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/HideOption.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/HideOption.java
index b57b9cd7..c7cad88d 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/HideOption.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/HideOption.java
@@ -45,6 +45,6 @@ public class HideOption extends Option {
 
     @Override
     public boolean isChanged(int diff) {
-        return Operator.bitandCompare(diff, AppConfig.DIFF_HIDDEN);
+        return Operator.bitAnd(diff, AppConfig.DIFF_HIDDEN);
     }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/RestrictOption.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/RestrictOption.java
index 0cf27320..f8d4f263 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/RestrictOption.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/RestrictOption.java
@@ -45,6 +45,6 @@ public class RestrictOption extends Option {
 
     @Override
     public boolean isChanged(int diff) {
-        return Operator.bitandCompare(diff, AppConfig.DIFF_RESTRICTED);
+        return Operator.bitAnd(diff, AppConfig.DIFF_RESTRICTED);
     }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/compat/SceneCompat.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/compat/SceneCompat.java
index 73a0e5ac..f97f4618 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/compat/SceneCompat.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/compat/SceneCompat.java
@@ -27,7 +27,10 @@ import android.view.ViewGroup;
 import com.achep.activedisplay.Device;
 
 /**
- * Created by Artem on 26.03.2014.
+ * This is a restricted {@link android.transition.Scene} compatibility
+ * class for supporting Android 4.3 or below.
+ *
+ * @author Artem Chepurnoy
  */
 public class SceneCompat {
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java
index d288d27d..0f9fb38e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java
@@ -23,12 +23,23 @@ import android.net.Uri;
 import com.achep.activedisplay.R;
 
 /**
- * Created by Artem on 06.02.14.
+ * An implementation of Bitcoin.
+ * <p></p>
+ * Bitcoin is a peer-to-peer payment system introduced as open source
+ * software in 2009 by developer Satoshi Nakamoto. The digital currency
+ * created and used in the system is also called bitcoin and is
+ * alternatively referred to as a virtual currency, electronic money,
+ * or cryptocurrency. The bitcoin system is not controlled by a single entity,
+ * like a central bank, which has led the US Treasury to call bitcoin a
+ * decentralized currency. Economists generally agree that it does not
+ * meet the definition of money.
+ *
+ * @author Artem Chepurnoy
  */
 public class Bitcoin extends Coin {
 
-    public static final String DONATION_KEY = "1GYj49ZnMByKj2f6p7r4f92GQi5pR6BSMz";
-    public static final double DONATION_AMOUNT = 0.005;
+    private static final String DONATION_KEY = "1GYj49ZnMByKj2f6p7r4f92GQi5pR6BSMz";
+    private static final double DONATION_AMOUNT = 0.005;
 
     @Override
     public int getId() {
@@ -61,17 +72,17 @@ public class Bitcoin extends Coin {
     }
 
     @Override
-    public Uri getBrowseUri() {
+    public Uri getUriBrowseWallet() {
         return Uri.parse("https://www.biteasy.com/blockchain/addresses/" + getPaymentKey());
     }
 
     @Override
-    public Uri getWikiUri() {
+    public Uri getUriWiki() {
         return Uri.parse("http://www.youtube.com/watch?v=Um63OQz3bjo");
     }
 
     @Override
-    public Uri getHowToUri() {
+    public Uri getUriTutorial() {
         return Uri.parse("https://www.trybtc.com/");
     }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java
index 6ea53623..01c7807e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java
@@ -22,13 +22,20 @@ import android.content.Intent;
 import android.net.Uri;
 
 /**
- * Created by Artem on 06.02.14.
+ * Base class for simple virtual coins.
+ *
+ * @author Artem Chepurnoy
  */
 public abstract class Coin {
 
-    static final Class[] COINS = new Class[]{Bitcoin.class};
+    public static Intent getPaymentIntent(Coin coin) {
+        return getPaymentIntent(coin, coin.getPaymentAmount());
+    }
 
-    // ///////////// -- BASICS -- ///////////////
+    public static Intent getPaymentIntent(Coin coin, double amount) {
+        Uri uri = coin.getPaymentUri(amount);
+        return new Intent(Intent.ACTION_VIEW, uri);
+    }
 
     public abstract int getId();
 
@@ -36,39 +43,44 @@ public abstract class Coin {
 
     public abstract int getNameResource();
 
-    // //////////// -- PAYMENT -- ///////////////
-
+    /**
+     * @return The receiver's key. It may be an email or just "any string".
+     */
     public abstract String getPaymentKey();
 
+    /**
+     * @return The default amount of money.
+     * @see #getPaymentIntent(Coin)
+     * @see #getPaymentIntent(Coin, double)
+     */
     public abstract double getPaymentAmount();
 
+    /**
+     * @return Uri to page through which you can sends me moneys.
+     * @see #getPaymentIntent(Coin)
+     * @see #getPaymentIntent(Coin, double)
+     */
     public abstract Uri getPaymentUri(double amount);
 
-    public abstract Uri getBrowseUri();
-
-    public abstract Uri getWikiUri();
-
-    public abstract Uri getHowToUri();
-
-    // ///////////// -- GLOBAL -- ///////////////
-
-    public static Intent getPaymentIntent(int id) {
-        for (Class clazz : COINS) {
-            try {
-                Coin coin = (Coin) clazz.newInstance();
-                if (id == coin.getId()) {
-                    return getPaymentIntent(coin);
-                }
-            } catch (InstantiationException | IllegalAccessException e) {
-                e.printStackTrace();
-            }
-        }
-        return null;
-    }
-
-    public static Intent getPaymentIntent(Coin coin) {
-        Uri uri = coin.getPaymentUri(coin.getPaymentAmount());
-        return new Intent(Intent.ACTION_VIEW, uri);
-    }
+    /**
+     * @return Uri to page that shows my current money.
+     * @see #getUriWiki()
+     * @see #getUriTutorial()
+     */
+    public abstract Uri getUriBrowseWallet();
+
+    /**
+     * @return Uri to page that explains the coin.
+     * @see #getUriBrowseWallet()
+     * @see #getUriTutorial()
+     */
+    public abstract Uri getUriWiki();
+
+    /**
+     * @return Uri to page that explains how to use that coin: send / receive money etc.
+     * @see #getUriWiki()
+     * @see #getUriBrowseWallet()
+     */
+    public abstract Uri getUriTutorial();
 
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AcDisplayFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AcDisplayFragment.java
index b562f600..c4cafaf9 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AcDisplayFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AcDisplayFragment.java
@@ -19,8 +19,6 @@
 
 package com.achep.activedisplay.fragments;
 
-import android.animation.AnimatorInflater;
-import android.animation.AnimatorSet;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.app.Fragment;
@@ -37,14 +35,12 @@ import android.transition.Transition;
 import android.transition.TransitionManager;
 import android.transition.TransitionSet;
 import android.util.Log;
-import android.view.GestureDetector;
 import android.view.HapticFeedbackConstants;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewStub;
-import android.widget.ImageView;
 import android.widget.LinearLayout;
 
 import com.achep.activedisplay.AsyncTask;
@@ -55,7 +51,6 @@ import com.achep.activedisplay.R;
 import com.achep.activedisplay.Timeout;
 import com.achep.activedisplay.activities.AcDisplayActivity;
 import com.achep.activedisplay.activities.KeyguardActivity;
-import com.achep.activedisplay.animations.ProgressBarAnimation;
 import com.achep.activedisplay.compat.SceneCompat;
 import com.achep.activedisplay.fragments.components.MusicFragment;
 import com.achep.activedisplay.fragments.components.NotificationFragment;
@@ -64,8 +59,9 @@ import com.achep.activedisplay.notifications.NotificationPresenter;
 import com.achep.activedisplay.notifications.NotificationUtils;
 import com.achep.activedisplay.notifications.OpenStatusBarNotification;
 import com.achep.activedisplay.utils.BitmapUtils;
-import com.achep.activedisplay.utils.MathUtils;
 import com.achep.activedisplay.utils.ViewUtils;
+import com.achep.activedisplay.view.ForwardingLayout;
+import com.achep.activedisplay.view.ForwardingListener;
 import com.achep.activedisplay.widgets.ProgressBar;
 
 import java.util.ArrayList;
@@ -87,7 +83,7 @@ public class AcDisplayFragment extends Fragment implements
     private NotificationPresenter mPresenter;
     private NotificationListener mNotificationListener = new NotificationListener();
 
-    private ViewGroup mSceneContainer;
+    private ForwardingLayout mSceneContainer;
     private LinearLayout mCollapsedViewsContainer;
     private HashMap<View, Widget> mWidgetsMap = new HashMap<>();
     private HashMap<Integer, SceneCompat> mScenesMap = new HashMap<>();
@@ -99,139 +95,20 @@ public class AcDisplayFragment extends Fragment implements
     private SceneCompat mSceneMain;
     private Transition mTransition;
 
-    // handlers
-    private ImageView mPinImageView;
-    private AnimatorSet mNotifyPinnedAnimation;
-    private ImageView mUnlockImageView;
-    private float mHandleCircleRadius;
-
     private boolean mTouched;
-    private boolean mParamsKeyguard;
 
-    private TimeoutGui mTimeout;
     private Handler mHandler = new Handler();
     private SelectWidgetRunnable mSelectWidgetRunnable = new SelectWidgetRunnable();
 
-    private GestureDetector mGestureDetector;
-
-    private class GestureListener extends GestureDetector.SimpleOnGestureListener {
-
-        @Override
-        public boolean onSingleTapConfirmed(MotionEvent e) {
-            showMainWidget();
-            return true;
-        }
-
-        @Override
-        public boolean onSingleTapUp(MotionEvent e) {
-            return false;
-        }
-
-        @Override
-        public boolean onDoubleTap(MotionEvent e) {
-            if (mParamsKeyguard) lock();
-            return mParamsKeyguard;
-        }
-    }
+    private Timeout mTimeout;
+    private Timeout.Gui mTimeoutGui;
+    private ForwardingListener mForwardingListener;
 
-    private class TimeoutGui extends Timeout implements Timeout.OnTimeoutEventListener {
-
-        private static final int MAX = 300;
-
-        private ProgressBarAnimation mProgressBarAnimation = null;
-        private final ProgressBar mProgressBar;
-
-        public TimeoutGui(Context context, ProgressBar progressBar) {
-            super();
-            mProgressBar = progressBar;
-            mProgressBar.setMax(MAX);
-            mProgressBar.setProgress(mProgressBar.getMax());
-            Config config = Config.getInstance(context);
-            if(!config.isTimeOutAvailable()) {
-                mProgressBarAnimation = new ProgressBarAnimation(mProgressBar, MAX, 0);
-                mProgressBarAnimation.setInterpolator(context, android.R.anim.linear_interpolator);
-                addListener(this);
-            }
-        }
-
-        @Override
-        public void onTimeoutEvent(int event) {
-            if (!mParamsKeyguard) return;
-            switch (event) {
-                case Timeout.EVENT_CLEARED:
-                    mProgressBar.clearAnimation();
-                    mProgressBar.setProgress(mProgressBar.getMax());
-                    break;
-                case Timeout.EVENT_CHANGED:
-                    long remainingTime = getRemainingTime();
-                    if (remainingTime > 0) {
-                        mProgressBarAnimation.setDuration(remainingTime);
-                        mProgressBar.startAnimation(mProgressBarAnimation);
-                    }
-                    break;
-                case Timeout.EVENT_TIMEOUT:
-                    AcDisplayFragment.this.lock();
-                    break;
-            }
-        }
-    }
-
-    /**
-     * This is needed to pause timeout while browsing status bar window,
-     * system dialogs etc.
-     */
-    public void onWindowFocusChanged(boolean hasFocus) {
-        if (hasFocus) {
-            if (!mTouched && mSelectedWidget == null) {
-                mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal());
-            }
-        } else {
-            mTimeout.clear();
-        }
-    }
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-        mHandleCircleRadius = getResources().getDimension(R.dimen.handler_circle_radius);
-        mNotifyPinnedAnimation = (AnimatorSet) AnimatorInflater.loadAnimator(
-                activity, R.anim.notification_pinned);
-
-        mParamsKeyguard = activity instanceof KeyguardActivity;
-        mGestureDetector = new GestureDetector(activity, new GestureListener());
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mTimeout.release();
-        mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal());
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mTimeout.clear();
-        mTimeout.lock();
-    }
-
-    private void lock() {
+    public void unlock(Runnable runnable, boolean finish) {
         Activity activity = getActivity();
         if (activity instanceof KeyguardActivity) {
-            KeyguardActivity lockscreen = (KeyguardActivity) activity;
-            lockscreen.lock();
-        }
-    }
-
-    private void unlock() {
-        unlock(null, false);
-    }
-
-    public void unlock(Runnable runnable, boolean finishOnStop) {
-        Activity activity = getActivity();
-        if (activity instanceof KeyguardActivity) {
-            KeyguardActivity lockscreen = (KeyguardActivity) activity;
-            lockscreen.unlock(runnable, !finishOnStop);
+            KeyguardActivity keyguard = (KeyguardActivity) activity;
+            keyguard.unlock(runnable, finish);
         } else {
             if (runnable != null) {
                 runnable.run();
@@ -265,10 +142,17 @@ public class AcDisplayFragment extends Fragment implements
         View root = inflater.inflate(R.layout.acdisplay, container, false);
         assert root != null;
 
-        mSceneContainer = (ViewGroup) root.findViewById(R.id.container);
+        mSceneContainer = (ForwardingLayout) root.findViewById(R.id.container);
         mCollapsedViewsContainer = (LinearLayout) root.findViewById(R.id.list);
         mCollapsedViewsContainer.setOnTouchListener(this);
 
+        mForwardingListener = new ForwardingListener(mCollapsedViewsContainer) {
+            @Override
+            public ForwardingLayout getForwardingLayout() {
+                return mSceneContainer;
+            }
+        };
+
         ViewGroup sceneMain = (ViewGroup) inflater.inflate(R.layout.acdisplay_scene_clock, mSceneContainer, false);
         if (Device.hasKitKatApi()) {
             mSceneMain = new SceneCompat(mSceneContainer, sceneMain);
@@ -286,9 +170,6 @@ public class AcDisplayFragment extends Fragment implements
         mCurrentScene = mSceneMain;
         mSceneMain.enter();
 
-        mUnlockImageView = (ImageView) root.findViewById(R.id.unlock);
-        mPinImageView = (ImageView) root.findViewById(R.id.pin);
-
         Config config = Config.getInstance(getActivity());
 
         // /////////////////
@@ -320,7 +201,18 @@ public class AcDisplayFragment extends Fragment implements
             progressBar = (ProgressBar) progressBarStub.inflate().findViewById(R.id.progress_bar);
         }
 
-        mTimeout = new TimeoutGui(getActivity(), progressBar);
+        Activity activity = getActivity();
+        if (activity instanceof AcDisplayActivity) {
+            mTimeoutGui = new Timeout.Gui(progressBar);
+
+            AcDisplayActivity a = (AcDisplayActivity) activity;
+            mTimeout = a.getTimeout();
+            mTimeout.registerListener(mTimeoutGui);
+        } else {
+            mTimeout = new Timeout(); // fake timeout that does nothing
+            progressBar.setProgress(progressBar.getMax());
+        }
+
         return root;
     }
 
@@ -344,20 +236,28 @@ public class AcDisplayFragment extends Fragment implements
         super.onStop();
     }
 
+    @Override
+    public void onDestroyView() {
+        super.onDestroyView();
+        if (mTimeout != null) {
+            mTimeout.unregisterListener(mTimeoutGui);
+        }
+    }
+
     @Override
     public boolean onTouch(View v, MotionEvent event) {
         final float rawX = event.getRawX();
         final float rawY = event.getRawY();
 
         if (v == mCollapsedViewsContainer) {
-            boolean pin = false;
-            boolean keepScene = false;
-            boolean touchDown = false;
+            mForwardingListener.onTouch(mCollapsedViewsContainer, event);
 
+            boolean touchDown = false;
             switch (event.getAction()) {
                 case MotionEvent.ACTION_DOWN:
                     touchDown = true;
-                    mTimeout.clear();
+                    mTimeout.setTimeoutDelayed(mConfig.getTimeoutShort(), true);
+                    mTimeout.pause();
                 case MotionEvent.ACTION_MOVE:
                     mTouched = true;
 
@@ -389,30 +289,8 @@ public class AcDisplayFragment extends Fragment implements
                         removeSelectWidgetCallbacks();
                     }
 
-                    handleSelectors(rawX, rawY);
                     break;
                 case MotionEvent.ACTION_UP:
-                    handleSelectors(rawX, rawY);
-
-                    // Handle basic features such as pinning notification and
-                    // unlocking device.
-                    handlers:
-                    if (true) {
-                        View view;
-                        if ((view = mUnlockImageView).getVisibility() == View.VISIBLE) {
-                            unlock();
-
-                            // Don't update the UI so user won't notice the lag
-                            // between unlocking and calling this method.
-                            keepScene = true;
-                        } else if ((view = mPinImageView).getVisibility() == View.VISIBLE) {
-                            pin = true;
-                            mNotifyPinnedAnimation.setTarget(mSceneContainer);
-                            mNotifyPinnedAnimation.start();
-                        } else break handlers; // do not vibrate
-
-                        view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
-                    }
 
                     // ///////////////
                     // ~~ FALL DOWN ~~
@@ -426,75 +304,20 @@ public class AcDisplayFragment extends Fragment implements
                         child.refreshDrawableState();
                     }
 
-                    if (!pin && !keepScene) {
-                        showMainWidget();
-                    }
-
-                    ViewUtils.setVisible(mUnlockImageView, false);
-                    ViewUtils.setVisible(mPinImageView, false);
+                    showMainWidget();
 
                     if (mCollapsedViewsNeedsUpdate) updateNotificationList();
+                    if (mTimeout != null) {
+                        mTimeout.resume();
+                    }
 
                     mTouched = false;
                     mCollapsedViewsNeedsUpdate = false;
                     break;
             }
             return true;
-        } else {
-            mGestureDetector.onTouchEvent(event);
-            switch (event.getAction()) {
-                case MotionEvent.ACTION_DOWN:
-                    if (mSelectedWidget == null) {
-                        mTimeout.setTimeoutDelayed(mConfig.getTimeoutShort());
-                    }
-                    break;
-            }
-            return true;
-        }
-    }
-
-    private void handleSelectors(float rawX, float rawY) {
-        if (mSelectedWidget == null) {
-            return;
-        }
-
-        View icon = mSelectedWidget.getCollapsedView();
-        int iconX = ViewUtils.getLeft(icon) + icon.getWidth() / 2;
-        int iconY = ViewUtils.getTop(icon) + icon.getHeight() / 2;
-
-        double length = Math.hypot(rawX - iconX, rawY - iconY);
-        if (length >= mHandleCircleRadius) {
-            View active = rawY > iconY ? mParamsKeyguard ? mUnlockImageView : null
-                    : mSelectedWidget.hasExpandedView() ? mPinImageView : null;
-            View passive = rawY > iconY ? mPinImageView : mUnlockImageView;
-
-            if (active != null) {
-                float[] point = new float[2];
-                calculateCrossPoint(iconX, iconY, rawX, rawY, mHandleCircleRadius, point);
-                active.setTranslationX(point[0] - active.getWidth() / 2 - ViewUtils.getLeft(getView()));
-                active.setTranslationY(point[1] - active.getHeight() / 2 - ViewUtils.getTop(getView()));
-
-                if (active.getVisibility() != View.VISIBLE) {
-                    active.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
-                    active.setVisibility(View.VISIBLE);
-                }
-            }
-            ViewUtils.setVisible(passive, false, View.INVISIBLE);
-        } else {
-            ViewUtils.setVisible(mUnlockImageView, false, View.INVISIBLE);
-            ViewUtils.setVisible(mPinImageView, false, View.INVISIBLE);
         }
-    }
-
-    private void calculateCrossPoint(float centerX, float centerY, float x1, float y1, float radius, float[] point) {
-        if ((x1 -= centerX) == 0) x1 = 0.00001f;
-        if ((y1 -= centerY) == 0) y1 = 0.00001f;
-        float k = y1 / x1;
-        float x = radius / (float) Math.sqrt(1 + k * k);
-        float y = k * x;
-
-        point[0] = x * MathUtils.charge(x1) + centerX;
-        point[1] = y * MathUtils.charge(x1) + centerY;
+        return false;
     }
 
     private class SelectWidgetRunnable implements Runnable {
@@ -552,7 +375,6 @@ public class AcDisplayFragment extends Fragment implements
     }
 
     public void showMainWidget() {
-        mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal());
         selectWidget(null);
     }
 
@@ -580,6 +402,10 @@ public class AcDisplayFragment extends Fragment implements
     // TODO: Optimize it
     // Spent hours on optimizing with no result: 0h
     private void updateNotificationList() {
+        if (getActivity() == null) {
+            return;
+        }
+
         long now = SystemClock.elapsedRealtime();
 
         ViewGroup container = mCollapsedViewsContainer;
@@ -801,7 +627,7 @@ public class AcDisplayFragment extends Fragment implements
     }
 
     /**
-     * Base class of {@link com.achep.activedisplay.fragments.AcDisplayFragment} widgets.
+     * Base class of {@link AcDisplayFragment} widgets.
      */
     public static abstract class Widget {
 
@@ -817,7 +643,7 @@ public class AcDisplayFragment extends Fragment implements
         }
 
         /**
-         * @return an instance of {@link com.achep.activedisplay.fragments.AcDisplayFragment}.
+         * @return an instance of {@link AcDisplayFragment}.
          */
         public AcDisplayFragment getHostFragment() {
             return mAcDisplayFragment;
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java
index 728c81d5..c1ac0826 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java
@@ -28,7 +28,6 @@ import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
 import android.text.Html;
-import android.widget.Toast;
 
 import com.achep.activedisplay.DialogHelper;
 import com.achep.activedisplay.R;
@@ -62,8 +61,7 @@ public class DonateDialog extends DialogFragment {
             if (IntentUtils.hasActivityForThat(mContext, mIntent)) {
                 mContext.startActivity(mIntent);
             } else {
-                Toast toast = Toast.makeText(mContext,"Program Error: No ActivityForThat", Toast.LENGTH_SHORT);
-                toast.show();
+                // TODO: Show toast message
             }
         }
     }
@@ -76,8 +74,8 @@ public class DonateDialog extends DialogFragment {
 
         CharSequence messageText = Html.fromHtml(getString(R.string.donate_message,
                 getString(R.string.app_name),
-                coin.getBrowseUri().toString(),
-                coin.getWikiUri().toString(),
+                coin.getUriBrowseWallet().toString(),
+                coin.getUriWiki().toString(),
                 getString(coin.getNameResource())));
         OnClickIntentLauncher payPalClick = createBrowserClicker(Uri.parse(PAYPAL_DONATION_URL));
 
@@ -99,7 +97,7 @@ public class DonateDialog extends DialogFragment {
 
             // Show tutorial button if link is present because user
             // probably doesn't know about cryptocoins.
-            Uri howToUri = coin.getHowToUri();
+            Uri howToUri = coin.getUriTutorial();
             if (howToUri != null) {
                 builder.setPositiveButton(R.string.donate_how_to, createBrowserClicker(howToUri));
             }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/components/NotificationFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/components/NotificationFragment.java
index f64d4baf..2ccae54a 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/components/NotificationFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/components/NotificationFragment.java
@@ -21,6 +21,7 @@ package com.achep.activedisplay.fragments.components;
 
 import android.app.PendingIntent;
 import android.graphics.Bitmap;
+import android.service.notification.StatusBarNotification;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -33,7 +34,6 @@ import com.achep.activedisplay.notifications.NotificationHelper;
 import com.achep.activedisplay.notifications.OpenStatusBarNotification;
 import com.achep.activedisplay.utils.BitmapUtils;
 import com.achep.activedisplay.utils.PendingIntentUtils;
-import com.achep.activedisplay.view.SwipeDismissTouchListener;
 import com.achep.activedisplay.widgets.NotificationIconWidget;
 import com.achep.activedisplay.widgets.NotificationView;
 import com.achep.activedisplay.widgets.NotificationWidget;
@@ -46,8 +46,6 @@ public class NotificationFragment extends AcDisplayFragment.Widget implements No
     private static final String TAG = "NotificationFragment";
 
     private NotificationIconWidget mIconView;
-    private ViewGroup mSceneView;
-
     private OpenStatusBarNotification mNotification;
     private NotificationWidget mNotifyWidget;
 
@@ -60,16 +58,6 @@ public class NotificationFragment extends AcDisplayFragment.Widget implements No
         return AcDisplayFragment.SCENE_NOTIFICATION;
     }
 
-    @Override
-    public View getCollapsedView() {
-        return mIconView;
-    }
-
-    @Override
-    public ViewGroup getExpandedView() {
-        return mSceneView;
-    }
-
     @Override
     public View onCreateCollapsedView(LayoutInflater inflater, ViewGroup container) {
         View view = inflater.inflate(R.layout.widget_notification_icon, container, false);
@@ -93,64 +81,44 @@ public class NotificationFragment extends AcDisplayFragment.Widget implements No
         if (initialize) {
             // I do keep in mind that those settings are
             // shared over all who uses this scene too.
-
-            mNotifyWidget.setOnTouchListener(new SwipeDismissTouchListener(
-                    mNotifyWidget, null,
-                    new SwipeDismissTouchListener.DismissCallbacks() {
-
-                        @Override
-                        public boolean canDismiss(Object token) {
-                            OpenStatusBarNotification osbn = mNotifyWidget.getNotification();
-                            return osbn != null && osbn.getStatusBarNotification().isClearable();
-                        }
-
-                        @Override
-                        public void onDismiss(View view, Object token) {
-                            NotificationHelper.dismissNotification(mNotifyWidget
-                                    .getNotification()
-                                    .getStatusBarNotification());
-                            getHostFragment().showMainWidget();
-                        }
-                    }
-            ));
-
             mNotifyWidget.setOnClickListener(new NotificationWidget.OnClickListener() {
 
                 @Override
                 public void onClick(View v) {
                     final OpenStatusBarNotification osbn = mNotifyWidget.getNotification();
-
-                    if (osbn == null) {
-                        throw new IllegalStateException("Notification widget is shown but it doesn\'t contain notification.");
+                    if (osbn != null) {
+                        getHostFragment().showMainWidget();
+                        getHostFragment().unlock(new Runnable() {
+                            @Override
+                            public void run() {
+                                NotificationHelper.startContentIntent(osbn);
+                            }
+                        }, false);
                     }
-
-                    getHostFragment().showMainWidget();
-                    postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            NotificationHelper.startContentIntent(osbn);
-                        }
-                    });
                 }
 
                 @Override
-                public void onActionClick(View v, final PendingIntent pendingIntent) {
+                public void onActionButtonClick(View v, final PendingIntent pendingIntent) {
                     getHostFragment().showMainWidget();
-                    postRunnable(new Runnable() {
+                    getHostFragment().unlock(new Runnable() {
                         @Override
                         public void run() {
                             PendingIntentUtils.sendPendingIntent(pendingIntent);
                         }
-                    });
+                    }, false);
                 }
 
-                private void postRunnable(Runnable runnable) {
-                    getHostFragment().unlock(runnable, true);
+                @Override
+                public void onDismissButtonClick(View v, OpenStatusBarNotification osbn) {
+                    if (osbn != null) {
+                        StatusBarNotification sbn = osbn.getStatusBarNotification();
+                        NotificationHelper.dismissNotification(sbn);
+                    }
                 }
+
             });
         }
 
-        mSceneView = sceneView;
         return sceneView;
     }
 
@@ -158,18 +126,21 @@ public class NotificationFragment extends AcDisplayFragment.Widget implements No
     public void onExpandedViewAttached() {
         mNotification.getNotificationData().markAsRead(true);
         mNotifyWidget.setNotification(mNotification);
-        displayBackgroundBitmap();
+        dispatchSetBackground();
     }
 
-    private void displayBackgroundBitmap() {
+    /**
+     * Sets dynamic background
+     */
+    private void dispatchSetBackground() {
         AcDisplayFragment fragment = getHostFragment();
         Bitmap bitmap = mNotification.getNotificationData().getBackground();
 
-        if (bitmap == null || BitmapUtils.hasTransparentCorners(bitmap)
-                // dynamic background from notification is disabled
-                || !Operator.bitandCompare(
+        boolean enabled = Operator.bitAnd(
                 fragment.getConfig().getDynamicBackgroundMode(),
-                Config.DYNAMIC_BG_NOTIFICATION_MASK)) {
+                Config.DYNAMIC_BG_NOTIFICATION_MASK);
+
+        if (bitmap == null || BitmapUtils.hasTransparentCorners(bitmap) || !enabled) {
             fragment.dispatchSetBackground(null);
             return;
         }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java
index 17eae28a..58cc5b77 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java
@@ -18,7 +18,6 @@
  */
 package com.achep.activedisplay.notifications;
 
-import android.app.Notification;
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Bitmap;
@@ -72,7 +71,7 @@ public class NotificationData {
      * example, before {@link android.os.Build.VERSION_CODES#HONEYCOMB}, this number was
      * superimposed over the icon in the status bar. Starting with
      * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, the template used by
-     * {@link Notification.Builder} has displayed the number in the expanded notification view.
+     * {@link android.app.Notification.Builder} has displayed the number in the expanded notification view.
      * <p/>
      * If the number is 0 or negative, it is never shown.
      */
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java
index a6fea003..3263a80e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java
@@ -41,7 +41,7 @@ public class NotificationHelper {
         if (notification != null) {
             PendingIntent pi = notification.getNotification().contentIntent;
             boolean successful = PendingIntentUtils.sendPendingIntent(pi);
-            if (successful && Operator.bitandCompare(
+            if (successful && Operator.bitAnd(
                     notification.getNotification().flags,
                     Notification.FLAG_AUTO_CANCEL)) {
                 dismissNotification(notification);
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationList.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationList.java
index 32c6f50b..99eea004 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationList.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationList.java
@@ -55,8 +55,8 @@ final class NotificationList {
     /**
      * Replace or add notification to the list.
      *
-     * @return {@link NotificationList.Callback#onNotificationAdded(com.achep.activedisplay.notifications.OpenStatusBarNotification n)} or
-     * {@link NotificationList.Callback#onNotificationChanged(com.achep.activedisplay.notifications.OpenStatusBarNotification n)}
+     * @return {@link com.achep.activedisplay.notifications.NotificationList.Callback#onNotificationAdded(com.achep.activedisplay.notifications.OpenStatusBarNotification n)} or
+     * {@link com.achep.activedisplay.notifications.NotificationList.Callback#onNotificationChanged(com.achep.activedisplay.notifications.OpenStatusBarNotification n)}
      */
     public int push(OpenStatusBarNotification n) {
         int index = indexOf(n);
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
index fffd4ba2..4828be9a 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
@@ -27,7 +27,7 @@ import android.os.Handler;
 import android.service.notification.StatusBarNotification;
 import android.util.Log;
 
-import com.achep.activedisplay.ActiveDisplayPresenter;
+import com.achep.activedisplay.Presenter;
 import com.achep.activedisplay.Config;
 import com.achep.activedisplay.InactiveHoursHelper;
 import com.achep.activedisplay.NotificationIds;
@@ -97,7 +97,7 @@ public class NotificationPresenter implements NotificationList.Callback {
 
         @Override
         public void onBlacklistChanged(final AppConfig configNew, AppConfig configOld, int diff) {
-            if (Operator.bitandCompare(diff, AppConfig.DIFF_HIDDEN_REAL)) {
+            if (Operator.bitAnd(diff, AppConfig.DIFF_HIDDEN_REAL)) {
                 handlePackageVisibilityChanged(configNew.packageName);
             }
         }
@@ -173,7 +173,7 @@ public class NotificationPresenter implements NotificationList.Callback {
     }
 
     /**
-     * Called on {@link NotificationHandleService#onNotificationPosted(StatusBarNotification)}
+     * Called on {@link NotificationHandleService#onNotificationPosted(android.service.notification.StatusBarNotification)}
      */
     public void postNotification(Context context, StatusBarNotification n) {
         postNotification(context, n, false);
@@ -201,7 +201,7 @@ public class NotificationPresenter implements NotificationList.Callback {
     }
 
     /**
-     * Called on {@link NotificationHandleService#onNotificationRemoved(StatusBarNotification)}
+     * Called on {@link NotificationHandleService#onNotificationRemoved(android.service.notification.StatusBarNotification)}
      */
     public void removeNotification(Context context, StatusBarNotification n) {
         logNotification(n, "removed");
@@ -299,10 +299,10 @@ public class NotificationPresenter implements NotificationList.Callback {
      */
     private boolean tryStartGui(Context context, OpenStatusBarNotification notification) {
         if (notification.isRestricted(mBlacklist)
-                || !mConfig.isActiveDisplayEnabled()
+                || !mConfig.isEnabled()
                 || ProximitySensor.isNear()
                 || mConfig.isEnabledOnlyWhileCharging() /* show only      */
-                && !PowerUtils.isPlugged(context))     /* while charging */
+                && !PowerUtils.isPlugged(context))      /* while charging */
             return false;
 
         // Inactive time
@@ -310,7 +310,7 @@ public class NotificationPresenter implements NotificationList.Callback {
             return false;
         }
 
-        ActiveDisplayPresenter.getInstance().start(context);
+        Presenter.getInstance().start(context);
         return true;
     }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/NativeExtractor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/NativeExtractor.java
index 1cb277ef..d46ae3e1 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/NativeExtractor.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/NativeExtractor.java
@@ -21,18 +21,9 @@ package com.achep.activedisplay.notifications.parser;
 import android.annotation.TargetApi;
 import android.app.Notification;
 import android.content.Context;
-import android.graphics.Color;
-import android.graphics.Typeface;
 import android.os.Build;
 import android.os.Bundle;
 import android.service.notification.StatusBarNotification;
-import android.text.Spannable;
-import android.text.SpannableString;
-import android.text.Spanned;
-import android.text.style.AbsoluteSizeSpan;
-import android.text.style.ForegroundColorSpan;
-import android.text.style.StyleSpan;
-import android.text.style.UnderlineSpan;
 import android.util.Log;
 
 import com.achep.activedisplay.Device;
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/providers/MyWidgetProvider.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/providers/MyWidgetProvider.java
deleted file mode 100644
index f04e83af..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/providers/MyWidgetProvider.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package com.achep.activedisplay.providers;
-
-import android.app.PendingIntent;
-import android.appwidget.AppWidgetManager;
-import android.appwidget.AppWidgetProvider;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.media.Image;
-import android.net.Uri;
-import android.util.Log;
-import android.widget.ImageView;
-import android.widget.RemoteViews;
-import android.widget.Switch;
-
-import com.achep.activedisplay.Config;
-import com.achep.activedisplay.R;
-import com.achep.activedisplay.activities.MainActivity;
-
-/**
- * @author SMillerNL
- * @since 24-03-14
- */
-public class MyWidgetProvider extends AppWidgetProvider implements Config.OnConfigChangedListener{
-
-    private static final String ACTION_CLICK = "ACTION_CLICK";
-    private boolean mBroadcasting;
-    private Switch mSwitch;
-    private Config mConfig;
-    private ImageView icon;
-
-
-    @Override
-    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
-        // Get all ids
-        mConfig = Config.getInstance(new MainActivity());
-        ComponentName thisWidget = new ComponentName(context, MyWidgetProvider.class);
-        int[] allWidgetIds = appWidgetManager.getAppWidgetIds(thisWidget);
-        for (int widgetId : allWidgetIds) {
-            RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget_layout);
-            Log.w("WidgetExample", "Enabled: "+mConfig.isActiveDisplayEnabled());
-
-            // Set the text
-            remoteViews.setTextViewText(R.id.update, "Enabled: "+mConfig.isActiveDisplayEnabled());
-
-            // Register an onClickListener
-            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("http://acdisplay.artemchep.com/toggle"));
-            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
-            remoteViews.setOnClickPendingIntent(R.id.update, pendingIntent);
-            appWidgetManager.updateAppWidget(widgetId, remoteViews);
-        }
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        if (key.equals(Config.KEY_ENABLED)) {
-            if (!mBroadcasting) {
-                mBroadcasting = true;
-                mSwitch.setChecked((Boolean) value);
-                mBroadcasting = false;
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/providers/ToggleWidgetProvider.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/providers/ToggleWidgetProvider.java
new file mode 100644
index 00000000..006ac219
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/providers/ToggleWidgetProvider.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.providers;
+
+import android.app.PendingIntent;
+import android.appwidget.AppWidgetManager;
+import android.appwidget.AppWidgetProvider;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.net.Uri;
+import android.util.Log;
+import android.widget.RemoteViews;
+
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.Project;
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.receiver.ReceiverActivity;
+
+/**
+ * Toggle widget provider.
+ *
+ * @author Artem Chepurnoy
+ */
+public class ToggleWidgetProvider extends AppWidgetProvider
+        implements Config.OnConfigChangedListener {
+
+    private static final String TAG = "AppWidgetProvider";
+
+    private Config mConfig;
+    private Context mContext;
+
+    @Override
+    public void onEnabled(Context context) {
+        super.onEnabled(context);
+        onEnabledInternal(context);
+    }
+
+    @Override
+    public void onDisabled(Context context) {
+        super.onDisabled(context);
+        onDisabledInternal(context);
+    }
+
+    @Override
+    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
+        onEnabledInternal(context);
+        updateWidgets(context);
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_ENABLED:
+                updateWidgets(mContext);
+                break;
+        }
+    }
+
+    private void onEnabledInternal(Context context) {
+        if (mContext != null) {
+            return; // already initialized
+        }
+
+        mContext = context;
+        mConfig = Config.getInstance(context);
+        mConfig.addOnConfigChangedListener(this);
+
+        if (Project.DEBUG) Log.d(TAG, "Toggle widget enabled");
+    }
+
+    private void onDisabledInternal(Context context) {
+        if (mContext == null) {
+            return; // not initialized
+        }
+
+        mConfig.removeOnConfigChangedListener(this);
+
+        if (Project.DEBUG) Log.d(TAG, "Toggle widget disabled");
+    }
+
+    private void updateWidgets(Context context) {
+        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
+
+        ComponentName cn = new ComponentName(context, ToggleWidgetProvider.class);
+        int[] appWidgetIds = appWidgetManager.getAppWidgetIds(cn);
+        for (int appWidgetId : appWidgetIds) {
+
+            // Create an Intent to launch ReceiverActivity to toggle AcDisplay.
+            // Probably doing same using BroadcastReceiver would be better solution.
+            Intent intent = new Intent(context, ReceiverActivity.class)
+                    .setData(Uri.parse("acdisplay://" + ReceiverActivity.HOST_TOGGLE));
+            PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, intent, 0);
+            Resources res = context.getResources();
+
+            // Get the layout for the App Widget and attach an on-click listener
+            // to the button
+            RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.appwidget_toggle_layout);
+            rv.setOnClickPendingIntent(R.id.container, pendingIntent);
+            rv.setTextViewText(R.id.title, res.getString(
+                    mConfig.isEnabled() ? R.string.widget_toggle_enabled : R.string.widget_toggle_disabled));
+
+            // Tell the AppWidgetManager to perform an update on the current app widget
+            appWidgetManager.updateAppWidget(appWidgetId, rv);
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/LocalReceiverActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/LocalReceiverActivity.java
index e6b6fe20..1ce3c92b 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/LocalReceiverActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/LocalReceiverActivity.java
@@ -25,10 +25,9 @@ import android.net.Uri;
 import android.os.Bundle;
 import android.support.v4.content.LocalBroadcastManager;
 import android.util.Log;
-import android.widget.Toast;
 
-import com.achep.activedisplay.R;
 import com.achep.activedisplay.Project;
+import com.achep.activedisplay.R;
 import com.achep.activedisplay.utils.IntentUtils;
 import com.achep.activedisplay.utils.ToastUtils;
 
@@ -76,7 +75,7 @@ public class LocalReceiverActivity extends Activity {
                 if (IntentUtils.hasActivityForThat(this, launchIntent)) {
                     startActivity(launchIntent);
                 } else {
-                    ToastUtils.showShort(this, 
+                    ToastUtils.showShort(this,
                             getString(R.string.device_admin_could_not_be_started));
                 }
                 break;
@@ -86,7 +85,7 @@ public class LocalReceiverActivity extends Activity {
                 if (IntentUtils.hasActivityForThat(this, launchIntent)) {
                     startActivity(launchIntent);
                 } else {
-                    ToastUtils.showShort(this, 
+                    ToastUtils.showShort(this,
                             getString(R.string.package_could_not_be_uninstalled));
                 }
                 break;
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/Receiver.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/Receiver.java
index 9649266f..e379ef04 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/Receiver.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/Receiver.java
@@ -24,7 +24,7 @@ import android.content.Intent;
 import android.util.Log;
 
 import com.achep.activedisplay.activemode.ActiveModeService;
-import com.achep.activedisplay.services.LockscreenService;
+import com.achep.activedisplay.services.KeyguardService;
 
 /**
  * Created by Artem on 11.03.14.
@@ -36,12 +36,13 @@ public class Receiver extends BroadcastReceiver {
     @Override
     public void onReceive(Context context, Intent intent) {
         Log.d(TAG, "action=" + intent.getAction() + " intent=" + intent.toString());
+
         switch (intent.getAction()) {
             case Intent.ACTION_BOOT_COMPLETED:
             case Intent.ACTION_POWER_CONNECTED:
             case Intent.ACTION_POWER_DISCONNECTED:
                 ActiveModeService.handleState(context);
-                LockscreenService.handleState(context);
+                KeyguardService.handleState(context);
                 break;
         }
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/ReceiverActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/ReceiverActivity.java
index 0b588156..901275a0 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/ReceiverActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/ReceiverActivity.java
@@ -66,22 +66,22 @@ public class ReceiverActivity extends Activity {
                 Log.i(TAG, "Enabling active display by remote intent.");
                 ToastUtils.showLong(this, getString(R.string.remote_enable_acdisplay));
 
-                Config.getInstance(this).setActiveDisplayEnabled(this, true, null);
+                Config.getInstance(this).setEnabled(this, true, null);
                 break;
 
             case HOST_DISABLE:
                 Log.i(TAG, "Disabling active display by remote intent.");
                 ToastUtils.showLong(this, getString(R.string.remote_disable_acdisplay));
 
-                Config.getInstance(this).setActiveDisplayEnabled(this, false, null);
+                Config.getInstance(this).setEnabled(this, false, null);
                 break;
 
             case HOST_TOGGLE:
                 Log.i(TAG, "Toggling active display by remote intent.");
                 config = Config.getInstance(this);
-                config.setActiveDisplayEnabled(this, !config.isActiveDisplayEnabled(), null);
+                config.setEnabled(this, !config.isEnabled(), null);
 
-                ToastUtils.showLong(this, getString(config.isActiveDisplayEnabled()
+                ToastUtils.showLong(this, getString(config.isEnabled()
                         ? R.string.remote_enable_acdisplay
                         : R.string.remote_disable_acdisplay));
                 break;
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/LockscreenService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/KeyguardService.java
similarity index 85%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/LockscreenService.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/KeyguardService.java
index adaa7230..319ec9f9 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/LockscreenService.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/KeyguardService.java
@@ -31,7 +31,7 @@ import android.os.SystemClock;
 import android.telephony.TelephonyManager;
 import android.util.Log;
 
-import com.achep.activedisplay.ActiveDisplayPresenter;
+import com.achep.activedisplay.Presenter;
 import com.achep.activedisplay.Config;
 import com.achep.activedisplay.NotificationIds;
 import com.achep.activedisplay.Project;
@@ -43,9 +43,9 @@ import com.achep.activedisplay.utils.PowerUtils;
 /**
  * Created by Artem on 16.02.14.
  */
-public class LockscreenService extends Service {
+public class KeyguardService extends Service {
 
-    private static final String TAG = "LockscreenService";
+    private static final String TAG = "KeyguardService";
 
     private static final int ACTIVITY_LAUNCH_MAX_TIME = 1000;
 
@@ -54,6 +54,8 @@ public class LockscreenService extends Service {
     public static long sIgnoreTillTime;
 
     /**
+     * Prevents launching keyguard on soonest turning screen on.
+     *
      * @deprecated hopefully the bug with it is fixed now, so no need to use it. Just in case...
      */
     @Deprecated
@@ -65,14 +67,14 @@ public class LockscreenService extends Service {
      * Starts or stops this service as required by settings and device's state.
      */
     public static void handleState(Context context) {
-        Intent intent = new Intent(context, LockscreenService.class);
+        Intent intent = new Intent(context, KeyguardService.class);
         Config config = Config.getInstance(context);
 
         boolean onlyWhileChangingOption = !config.isEnabledOnlyWhileCharging()
                 || PowerUtils.isPlugged(context);
 
-        if (config.isActiveDisplayEnabled()
-                && config.isLockscreenEnabled()
+        if (config.isEnabled()
+                && config.isKeyguardEnabled()
                 && onlyWhileChangingOption) {
             context.startService(intent);
         } else {
@@ -89,25 +91,33 @@ public class LockscreenService extends Service {
 
             switch (intent.getAction()) {
                 case Intent.ACTION_SCREEN_ON:
+                    String activityName = null;
                     long activityChangeTime = 0;
                     if (mActivityMonitorThread != null) {
                         mActivityMonitorThread.monitor();
+                        activityName = mActivityMonitorThread.activityName;
                         activityChangeTime = mActivityMonitorThread.activityChangeTime;
                     }
 
                     stopMonitoringActivities();
-                    sIgnoreTillTime = 0;
 
                     long now = SystemClock.elapsedRealtime();
-                    boolean becauseOfActivityLaunch = now
-                            - activityChangeTime < ACTIVITY_LAUNCH_MAX_TIME;
                     boolean becauseOfIgnoringPolicy = now < sIgnoreTillTime;
+                    boolean becauseOfActivityLaunch =
+                            now - activityChangeTime < ACTIVITY_LAUNCH_MAX_TIME
+                                    && activityName != null && !activityName.startsWith(
+                                    Project.getPackageName(KeyguardService.this));
+
+                    if (isCall || becauseOfIgnoringPolicy) {
+                        sIgnoreTillTime = 0;
+                        return;
+                    }
 
-                    if (isCall || becauseOfActivityLaunch || becauseOfIgnoringPolicy) {
+                    if (becauseOfActivityLaunch) {
 
                         // Finish AcDisplay activity so it won't shown
                         // after exiting from newly launched one.
-                        ActiveDisplayPresenter.getInstance().kill();
+                        Presenter.getInstance().kill();
                     } else startGui();
 
                     if (Project.DEBUG)
@@ -155,7 +165,7 @@ public class LockscreenService extends Service {
         IntentFilter intentFilter = new IntentFilter();
         intentFilter.addAction(Intent.ACTION_SCREEN_ON);
         intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
-        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1);
+        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1); // highest priority
         registerReceiver(mReceiver, intentFilter);
 
         int notificationId = NotificationIds.LOCKSCREEN_NOTIFICATION;
@@ -196,15 +206,14 @@ public class LockscreenService extends Service {
      */
     private static class ActivityMonitorThread extends Thread {
 
-        private static final long MONITORING_PERIOD = 10 * 60 * 1000; // ms.
+        private static final long MONITORING_PERIOD = 15 * 60 * 1000; // ms.
 
         public volatile boolean running = true;
         public volatile long activityChangeTime;
+        public volatile String activityName;
 
         private final ActivityManager mActivityManager;
 
-        private volatile String mPastActivityName;
-
         public ActivityMonitorThread(ActivityManager activityManager) {
             mActivityManager = activityManager;
         }
@@ -236,14 +245,14 @@ public class LockscreenService extends Service {
 
             assert latestActivityName != null;
 
-            if (!latestActivityName.equals(mPastActivityName)) {
-                if (mPastActivityName != null) {
+            if (!latestActivityName.equals(activityName)) {
+                if (activityName != null) { // first start
                     this.activityChangeTime = SystemClock.elapsedRealtime(); // deep sleep
                 }
 
-                mPastActivityName = latestActivityName;
+                activityName = latestActivityName;
 
-                if (Project.DEBUG) Log.d(TAG, "Current latest activity is " + mPastActivityName);
+                if (Project.DEBUG) Log.d(TAG, "Current latest activity is " + activityName);
             }
         }
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/InterfaceFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/InterfaceFragment.java
index 3d6cb4a1..206a32ed 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/InterfaceFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/InterfaceFragment.java
@@ -56,13 +56,13 @@ public class InterfaceFragment extends PreferenceFragment implements
         addPreferencesFromResource(R.xml.interface_settings);
 
         mShowWallpaper = (CheckBoxPreference) findPreference(
-                Config.KEY_INTERFACE_WALLPAPER_SHOWN);
+                Config.KEY_UI_WALLPAPER_SHOWN);
         mShadowToggle = (CheckBoxPreference) findPreference(
-                Config.KEY_INTERFACE_SHADOW_TOGGLE);
+                Config.KEY_UI_SHADOW_TOGGLE);
         mDynamicBackground = (MultiSelectListPreference) findPreference(
-                Config.KEY_INTERFACE_DYNAMIC_BACKGROUND_MODE);
+                Config.KEY_UI_DYNAMIC_BACKGROUND_MODE);
         mMirroredTimeoutToggle = (CheckBoxPreference) findPreference(
-                Config.KEY_INTERFACE_MIRRORED_TIMEOUT_PROGRESS_BAR);
+                Config.KEY_UI_MIRRORED_TIMEOUT_BAR);
 
         mShowWallpaper.setOnPreferenceChangeListener(this);
         mShadowToggle.setOnPreferenceChangeListener(this);
@@ -121,16 +121,16 @@ public class InterfaceFragment extends PreferenceFragment implements
     @Override
     public void onConfigChanged(Config config, String key, Object value) {
         switch (key) {
-            case Config.KEY_INTERFACE_WALLPAPER_SHOWN:
+            case Config.KEY_UI_WALLPAPER_SHOWN:
                 updateShowWallpaperPreference(config);
                 break;
-            case Config.KEY_INTERFACE_SHADOW_TOGGLE:
+            case Config.KEY_UI_SHADOW_TOGGLE:
                 updateShowShadowPreference(config);
                 break;
-            case Config.KEY_INTERFACE_MIRRORED_TIMEOUT_PROGRESS_BAR:
+            case Config.KEY_UI_MIRRORED_TIMEOUT_BAR:
                 updateMirroredTimeoutPreference(config);
                 break;
-            case Config.KEY_INTERFACE_DYNAMIC_BACKGROUND_MODE:
+            case Config.KEY_UI_DYNAMIC_BACKGROUND_MODE:
                 updateDynamicBackgroundPreference(config);
                 break;
         }
@@ -160,7 +160,7 @@ public class InterfaceFragment extends PreferenceFragment implements
         int mode = config.getDynamicBackgroundMode();
         String[] values = new String[Integer.bitCount(mode)];
         for (int i = 1, j = 0; j < values.length; i <<= 1) {
-            if (Operator.bitandCompare(mode, i)) {
+            if (Operator.bitAnd(mode, i)) {
                 values[j++] = Integer.toString(i);
             }
         }
@@ -190,7 +190,7 @@ public class InterfaceFragment extends PreferenceFragment implements
             // Append selected items.
             for (int i = 0; i < values.length; i++) {
                 int a = Integer.parseInt(values[i].toString());
-                if (Operator.bitandCompare(mode, a)) {
+                if (Operator.bitAnd(mode, a)) {
                     if (!empty) {
                         sb.append(divider);
                     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/MoreFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/MoreFragment.java
index fb0321b7..39cf5098 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/MoreFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/MoreFragment.java
@@ -39,8 +39,6 @@ public class MoreFragment extends PreferenceFragment implements
     private CheckBoxPreference mOnlyWhileChargingPreference;
     private Preference mInactiveHoursPreference;
     private Preference mTimeoutPreference;
-    private ListPreference mSwipeLeftListPreference;
-    private ListPreference mSwipeRightListPreference;
 
     private boolean mBroadcasting;
 
@@ -54,14 +52,8 @@ public class MoreFragment extends PreferenceFragment implements
 
         mOnlyWhileChargingPreference = (CheckBoxPreference) findPreference(
                 Config.KEY_ONLY_WHILE_CHARGING);
-        mSwipeLeftListPreference = (ListPreference) findPreference(
-                Config.KEY_SWIPE_LEFT_ACTION);
-        mSwipeRightListPreference = (ListPreference) findPreference(
-                Config.KEY_SWIPE_RIGHT_ACTION);
 
         mOnlyWhileChargingPreference.setOnPreferenceChangeListener(this);
-        mSwipeLeftListPreference.setOnPreferenceChangeListener(this);
-        mSwipeRightListPreference.setOnPreferenceChangeListener(this);
     }
 
     @Override
@@ -71,8 +63,6 @@ public class MoreFragment extends PreferenceFragment implements
         config.addOnConfigChangedListener(this);
 
         updateOnlyWhileChargingPreference(config);
-        updateSwipeLeftPreference(config);
-        updateSwipeRightPreference(config);
 
         updateInactiveHoursSummary(config);
         updateTimeoutSummary(config);
@@ -94,12 +84,6 @@ public class MoreFragment extends PreferenceFragment implements
         Config config = Config.getInstance(getActivity());
         if (preference == mOnlyWhileChargingPreference) {
             config.setActiveDisplayEnabledOnlyWhileCharging(getActivity(), (Boolean) newValue, this);
-        } else if (preference == mSwipeLeftListPreference) {
-            config.setSwipeLeftAction(getActivity(), Integer.parseInt((String) newValue), this);
-            updatePreferenceListSummary(mSwipeLeftListPreference);
-        } else if (preference == mSwipeRightListPreference) {
-            config.setSwipeRightAction(getActivity(), Integer.parseInt((String) newValue), this);
-            updatePreferenceListSummary(mSwipeRightListPreference);
         } else
             return false;
         return true;
@@ -115,17 +99,12 @@ public class MoreFragment extends PreferenceFragment implements
                 break;
             case Config.KEY_TIMEOUT_NORMAL:
             case Config.KEY_TIMEOUT_SHORT:
+            case Config.KEY_TIMEOUT_ENABLED:
                 updateTimeoutSummary(config);
                 break;
             case Config.KEY_ONLY_WHILE_CHARGING:
                 updateOnlyWhileChargingPreference(config);
                 break;
-            case Config.KEY_SWIPE_LEFT_ACTION:
-                updateSwipeLeftPreference(config);
-                break;
-            case Config.KEY_SWIPE_RIGHT_ACTION:
-                updateSwipeRightPreference(config);
-                break;
         }
     }
 
@@ -133,16 +112,6 @@ public class MoreFragment extends PreferenceFragment implements
         updatePreference(mOnlyWhileChargingPreference, config.isEnabledOnlyWhileCharging());
     }
 
-    private void updateSwipeLeftPreference(Config config) {
-        updatePreference(mSwipeLeftListPreference, config.getSwipeLeftAction());
-        updatePreferenceListSummary(mSwipeLeftListPreference);
-    }
-
-    private void updateSwipeRightPreference(Config config) {
-        updatePreference(mSwipeRightListPreference, config.getSwipeRightAction());
-        updatePreferenceListSummary(mSwipeRightListPreference);
-    }
-
     private void updatePreference(CheckBoxPreference preference, boolean checked) {
         mBroadcasting = true;
         preference.setChecked(checked);
@@ -172,8 +141,10 @@ public class MoreFragment extends PreferenceFragment implements
     }
 
     private void updateTimeoutSummary(Config config) {
-        mTimeoutPreference.setSummary(getString(R.string.settings_timeout_summary,
+        mTimeoutPreference.setSummary(config.isTimeoutEnabled()
+                ? getString(R.string.settings_timeout_summary,
                 Float.toString(config.getTimeoutNormal() / 1000f),
-                Float.toString(config.getTimeoutShort() / 1000f)));
+                Float.toString(config.getTimeoutShort() / 1000f))
+                : getString(R.string.settings_timeout_forever));
     }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/ActiveModeEnabler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/ActiveModeEnabler.java
index f5e62a5f..07cbf8c8 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/ActiveModeEnabler.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/ActiveModeEnabler.java
@@ -37,7 +37,7 @@ public final class ActiveModeEnabler extends Enabler {
 
     @Override
     protected void updateState() {
-        mSwitch.setEnabled(mConfig.isActiveDisplayEnabled());
+        mSwitch.setEnabled(mConfig.isEnabled());
         mBroadcasting = true;
         mSwitch.setChecked(mConfig.isActiveModeEnabled());
         mBroadcasting = false;
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/LockscreenEnabler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/LockscreenEnabler.java
index 8de5454a..fd268f8e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/LockscreenEnabler.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/enablers/LockscreenEnabler.java
@@ -37,9 +37,9 @@ public final class LockscreenEnabler extends Enabler {
 
     @Override
     protected void updateState() {
-        mSwitch.setEnabled(mConfig.isActiveDisplayEnabled());
+        mSwitch.setEnabled(mConfig.isEnabled());
         mBroadcasting = true;
-        mSwitch.setChecked(mConfig.isLockscreenEnabled());
+        mSwitch.setChecked(mConfig.isKeyguardEnabled());
         mBroadcasting = false;
     }
 
@@ -49,14 +49,14 @@ public final class LockscreenEnabler extends Enabler {
             return;
         }
 
-        mConfig.setLockscreenEnabled(mContext, isChecked, this);
+        mConfig.setKeyguardEnabled(mContext, isChecked, this);
     }
 
     @Override
     public void onConfigChanged(Config config, String key, Object value) {
         switch (key) {
             case Config.KEY_ENABLED:
-            case Config.KEY_LOCK_SCREEN:
+            case Config.KEY_KEYGUARD:
                 updateState();
                 break;
         }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/TimeoutPreference.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/TimeoutPreference.java
index 69331b0f..5d436122 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/TimeoutPreference.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/TimeoutPreference.java
@@ -39,9 +39,10 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
 /**
- * @author AChep
  * Preference to configure timeouts.
  * Creates the dialog in settings to change the TimeOut settings.
+ *
+ * @author Artem Chepurnoy
  */
 public class TimeoutPreference extends DialogPreference implements
         SeekBar.OnSeekBarChangeListener {
@@ -99,7 +100,7 @@ public class TimeoutPreference extends DialogPreference implements
         Config config = Config.getInstance(getContext());
 
         mDisabled = (CheckBox) root.findViewById(R.id.no_timeout_checkbox);
-        mDisabled.setChecked(config.isTimeOutAvailable());
+        mDisabled.setChecked(!config.isTimeoutEnabled());
         mDisabled.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
             public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
                 for (Group group : mGroups) {
@@ -153,7 +154,7 @@ public class TimeoutPreference extends DialogPreference implements
                 e.printStackTrace();
             }
         }
-        config.setTimeOutAvailable(getContext(), mDisabled.isChecked(), null);
+        config.setTimeoutEnabled(getContext(), !mDisabled.isChecked(), null);
     }
 
     @Override
@@ -217,7 +218,6 @@ public class TimeoutPreference extends DialogPreference implements
     public void onStopTrackingTouch(SeekBar seekBar) { /* unused */ }
 
     /**
-     *
      * An object to store the seekbars and variables in that are used in the dialog
      */
     private static class Group {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/BitmapUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/BitmapUtils.java
index 1178e793..91306ca1 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/BitmapUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/BitmapUtils.java
@@ -35,7 +35,7 @@ public class BitmapUtils {
                 || bitmap.getPixel(0, height) == Color.TRANSPARENT
                 || bitmap.getPixel(width, height) == Color.TRANSPARENT;
     }
-    
+
     public static Bitmap doBlur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap) {
 
         // Stack Blur v1.0 from
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/LogUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/LogUtils.java
deleted file mode 100644
index fc9c9911..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/LogUtils.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.activedisplay.utils;
-
-import android.text.TextUtils;
-import android.util.Log;
-
-/**
- * Created by Artem on 28.01.14.
- */
-public class LogUtils {
-
-    private static final String TAG = "achep";
-
-    public static void v(String tag, String msg) {
-        Log.v(tag, getLocation() + msg);
-    }
-
-    public static void d(String tag, String msg) {
-        Log.d(tag, getLocation() + msg);
-    }
-
-    public static void i(String tag, String msg) {
-        Log.i(tag, getLocation() + msg);
-    }
-
-    public static void e(String tag, String msg) {
-        Log.e(tag, getLocation() + msg);
-    }
-
-    public static void w(String tag, String msg) {
-        Log.w(tag, getLocation() + msg);
-    }
-
-    public static void track() {
-        Log.d(TAG, getLocation() + " <-- tracking");
-    }
-
-    private static String getLocation() {
-        final String className = LogUtils.class.getName();
-        final StackTraceElement[] traces = Thread.currentThread().getStackTrace();
-
-        String deeper = null;
-        boolean found = false;
-        int i = 0;
-        for (StackTraceElement trace : traces) {
-            i++;
-            try {
-                if (found) {
-                    if (!trace.getClassName().startsWith(className)) {
-                        Class<?> clazz = Class.forName(trace.getClassName());
-                        return "[" + getClassName(clazz) + ":" + trace.getMethodName() + "(" + deeper + "):" + trace.getLineNumber() + "]: ";
-                    }
-                } else if (trace.getClassName().startsWith(className)) {
-                    found = true;
-
-                    StringBuilder sb = new StringBuilder();
-                    for (int j = i + 2; j < i + 7 && j < traces.length; j++) {
-                        sb.append(traces[j].getMethodName());
-                        sb.append(" / ");
-                    }
-                    deeper = sb.toString();
-                }
-            } catch (ClassNotFoundException e) {
-            }
-        }
-
-        return Thread.currentThread().getName() + ":[]: ";
-    }
-
-    private static String getClassName(Class<?> clazz) {
-        if (clazz != null) {
-            if (!TextUtils.isEmpty(clazz.getSimpleName())) {
-                return clazz.getSimpleName();
-            }
-
-            return getClassName(clazz.getEnclosingClass());
-        }
-
-        return "";
-    }
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java
index 959f8168..bd80e57b 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java
@@ -81,6 +81,13 @@ public class ViewUtils {
     // /////////// -- TOUCH EVENTS -- ///////////
     // //////////////////////////////////////////
 
+    public static boolean pointInView(View view, float localX, float localY, float slop) {
+        return localX >= view.getLeft() - slop
+                && localX < view.getRight() + slop
+                && localY >= view.getTop() - slop
+                && localY < view.getBottom() + slop;
+    }
+
     public static boolean toGlobalMotionEvent(View view, MotionEvent ev) {
         return toMotionEvent(view, ev, "toGlobalMotionEvent");
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/ForwardingLayout.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/ForwardingLayout.java
new file mode 100644
index 00000000..065ee39d
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/ForwardingLayout.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.view;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.LinearLayout;
+
+import com.achep.activedisplay.utils.ViewUtils;
+
+/**
+ * Created by achep on 26.04.14.
+ */
+public class ForwardingLayout extends LinearLayout {
+
+    private static final String TAG = "ForwardingLayout";
+
+    private View mPressedChild;
+    private OnForwardedEventListener mOnForwardedEventListener;
+
+    public ForwardingLayout(Context context) {
+        super(context);
+    }
+
+    public ForwardingLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public ForwardingLayout(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    public interface OnForwardedEventListener {
+        public void onForwardedEvent(MotionEvent event, int activePointerId);
+    }
+
+    public void setOnForwardedEventListener(OnForwardedEventListener listener) {
+        mOnForwardedEventListener = listener;
+    }
+
+    /**
+     * Handles forwarded events.
+     *
+     * @param activePointerId id of the pointer that activated forwarding
+     * @return whether the event was handled
+     */
+    public boolean onForwardedEvent(MotionEvent event, int activePointerId) {
+        boolean handledEvent = true;
+
+        final int actionMasked = event.getActionMasked();
+        switch (actionMasked) {
+            case MotionEvent.ACTION_CANCEL:
+                handledEvent = false;
+                break;
+            case MotionEvent.ACTION_UP:
+                handledEvent = false;
+                // $FALL-THROUGH$
+            case MotionEvent.ACTION_MOVE:
+                final int activeIndex = event.findPointerIndex(activePointerId);
+                if (activeIndex < 0) {
+                    handledEvent = false;
+                    break;
+                }
+
+                final int x = (int) event.getX(activeIndex);
+                final int y = (int) event.getY(activeIndex);
+
+                View pressedView = findViewByCoordinate(this, x, y);
+                if (mPressedChild != pressedView) {
+                    if (pressedView != null) pressedView.setPressed(true);
+                    if (mPressedChild != null) mPressedChild.setPressed(false);
+                    mPressedChild = pressedView;
+                }
+
+                if (actionMasked == MotionEvent.ACTION_UP && mPressedChild != null) {
+                    clickPressedItem();
+                }
+                break;
+        }
+
+        // Failure to handle the event cancels forwarding.
+        if (!handledEvent) {
+            clearPressedItem();
+        }
+
+        if (mOnForwardedEventListener != null) {
+            mOnForwardedEventListener.onForwardedEvent(event, activePointerId);
+        }
+
+        return handledEvent;
+    }
+
+    private View findViewByCoordinate(ViewGroup viewGroup, float x, float y) {
+        final int childCount = viewGroup.getChildCount();
+        for (int i = childCount - 1; i >= 0; i--) {
+            final View child = viewGroup.getChildAt(i);
+            assert child != null;
+
+            if (child.getVisibility() != View.VISIBLE || !child.isEnabled()) {
+                continue;
+            }
+
+            if (child instanceof ViewGroup) {
+                View view = findViewByCoordinate((ViewGroup) child,
+                        x - child.getLeft(),
+                        y - child.getTop());
+                if (view != null) {
+                    return view;
+                }
+            }
+
+            if (child.isClickable() && ViewUtils.pointInView(child, x, y, 0)) {
+                return child;
+            }
+        }
+
+        return null;
+    }
+
+    private void clearPressedItem() {
+        if (mPressedChild == null) {
+            return;
+        }
+
+        mPressedChild.setPressed(false);
+        mPressedChild.refreshDrawableState();
+    }
+
+    private void clickPressedItem() {
+        if (mPressedChild == null) {
+            return;
+        }
+
+        mPressedChild.performClick();
+        clearPressedItem();
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/ForwardingListener.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/ForwardingListener.java
new file mode 100644
index 00000000..6ef30825
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/ForwardingListener.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.view;
+
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewParent;
+
+import com.achep.activedisplay.utils.ViewUtils;
+
+/**
+ * Abstract class that forwards touch events to a {@link ForwardingLayout}.
+ */
+public abstract class ForwardingListener implements
+        View.OnTouchListener, View.OnAttachStateChangeListener {
+    /**
+     * Scaled touch slop, used for detecting movement outside bounds.
+     */
+    private final float mScaledTouchSlop;
+
+    /**
+     * Timeout before disallowing intercept on the source's parent.
+     */
+    private final int mTapTimeout;
+
+    /**
+     * Source view from which events are forwarded.
+     */
+    private final View mSrc;
+
+    /**
+     * Runnable used to prevent conflicts with scrolling parents.
+     */
+    private Runnable mDisallowIntercept;
+
+    /**
+     * Whether this listener is currently forwarding touch events.
+     */
+    private boolean mForwarding;
+
+    /**
+     * The id of the first pointer down in the current event stream.
+     */
+    private int mActivePointerId;
+
+    private final boolean mImmediately;
+
+    public ForwardingListener(View src) {
+        this(src, false);
+    }
+
+    public ForwardingListener(View src, boolean immediately) {
+        mSrc = src;
+        mImmediately = immediately;
+        mScaledTouchSlop = ViewConfiguration.get(src.getContext()).getScaledTouchSlop();
+        mTapTimeout = ViewConfiguration.getTapTimeout();
+
+        src.addOnAttachStateChangeListener(this);
+    }
+
+    /**
+     * Returns the layout to which this listener is forwarding events.
+     * <p/>
+     * Override this to return the correct layout. If the layout is displayed
+     * asynchronously, you may also need to override
+     * {@link #onForwardingStopped} to prevent premature cancelation of
+     * forwarding.
+     *
+     * @return the layout to which this listener is forwarding events
+     */
+    public abstract ForwardingLayout getForwardingLayout();
+
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        final boolean wasForwarding = mForwarding;
+        final boolean forwarding;
+        if (wasForwarding) {
+            forwarding = onTouchForwarded(event) || !onForwardingStopped();
+        } else {
+            forwarding = onTouchObserved(event) && onForwardingStarted();
+        }
+
+        mForwarding = forwarding;
+        return forwarding || wasForwarding;
+    }
+
+    @Override
+    public void onViewAttachedToWindow(View v) {
+    }
+
+    @Override
+    public void onViewDetachedFromWindow(View v) {
+        mForwarding = false;
+        mActivePointerId = MotionEvent.INVALID_POINTER_ID;
+
+        if (mDisallowIntercept != null) {
+            mSrc.removeCallbacks(mDisallowIntercept);
+        }
+    }
+
+    /**
+     * Called when forwarding would like to start.
+     *
+     * @return true to start forwarding, false otherwise
+     */
+    protected boolean onForwardingStarted() {
+        return true;
+    }
+
+    /**
+     * Called when forwarding would like to stop.
+     *
+     * @return true to stop forwarding, false otherwise
+     */
+    protected boolean onForwardingStopped() {
+        return true;
+    }
+
+    /**
+     * Observes motion events and determines when to start forwarding.
+     *
+     * @param srcEvent motion event in source view coordinates
+     * @return true to start forwarding motion events, false otherwise
+     */
+    private boolean onTouchObserved(MotionEvent srcEvent) {
+        final View src = mSrc;
+        if (!src.isEnabled()) {
+            return false;
+        }
+
+        final int actionMasked = srcEvent.getActionMasked();
+        switch (actionMasked) {
+            case MotionEvent.ACTION_DOWN:
+                mActivePointerId = srcEvent.getPointerId(0);
+                if (mDisallowIntercept == null) {
+                    mDisallowIntercept = new DisallowIntercept();
+                }
+                src.postDelayed(mDisallowIntercept, mTapTimeout);
+                break;
+            case MotionEvent.ACTION_MOVE:
+                final int activePointerIndex = srcEvent.findPointerIndex(mActivePointerId);
+                if (activePointerIndex >= 0) {
+                    final float x = srcEvent.getX(activePointerIndex);
+                    final float y = srcEvent.getY(activePointerIndex);
+                    if (!ViewUtils.pointInView(src, x, y, mScaledTouchSlop) || mImmediately) {
+                        // The pointer has moved outside of the view.
+                        if (mDisallowIntercept != null) {
+                            src.removeCallbacks(mDisallowIntercept);
+                        }
+                        src.getParent().requestDisallowInterceptTouchEvent(true);
+                        return true;
+                    }
+                }
+                break;
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                if (mDisallowIntercept != null) {
+                    src.removeCallbacks(mDisallowIntercept);
+                }
+                break;
+        }
+
+        return false;
+    }
+
+    /**
+     * Handled forwarded motion events and determines when to stop
+     * forwarding.
+     *
+     * @param srcEvent motion event in source view coordinates
+     * @return true to continue forwarding motion events, false to cancel
+     */
+    private boolean onTouchForwarded(MotionEvent srcEvent) {
+        final View src = mSrc;
+        final ForwardingLayout dst = getForwardingLayout();
+        if (dst == null || !dst.isShown()) {
+            return false;
+        }
+
+        // Convert event to destination-local coordinates.
+        final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
+        assert dstEvent != null;
+
+        ViewUtils.toGlobalMotionEvent(src, dstEvent);
+        ViewUtils.toLocalMotionEvent(dst, dstEvent);
+
+        // Forward converted event to destination view, then recycle it.
+        final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId);
+        dstEvent.recycle();
+        return handled;
+    }
+
+    private class DisallowIntercept implements Runnable {
+        @Override
+        public void run() {
+            final ViewParent parent = mSrc.getParent();
+            parent.requestDisallowInterceptTouchEvent(true);
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/NotifyingLayout.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/NotifyingLayout.java
new file mode 100644
index 00000000..dcea7ba8
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/NotifyingLayout.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+
+package com.achep.activedisplay.view;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.widget.FrameLayout;
+
+/**
+ * Created by achep on 28.04.14 for AcDisplay.
+ *
+ * @author Artem Chepurnoy
+ */
+public class NotifyingLayout extends FrameLayout {
+
+    private OnPressStateChangedListener mOnPressStateChangedListener;
+
+    public interface OnPressStateChangedListener {
+
+        public void onPressStateChanged(NotifyingLayout view, boolean pressed);
+
+    }
+
+    public NotifyingLayout(Context context) {
+        super(context);
+    }
+
+    public NotifyingLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public NotifyingLayout(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+    }
+
+    public void setOnPressStateChangedListener(OnPressStateChangedListener listener) {
+        mOnPressStateChangedListener = listener;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setPressed(boolean pressed) {
+        boolean notify = pressed != isPressed();
+        super.setPressed(pressed);
+        if (mOnPressStateChangedListener != null && notify) {
+            mOnPressStateChangedListener.onPressStateChanged(this, pressed);
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/SwipeDismissTouchListener.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/SwipeDismissTouchListener.java
deleted file mode 100644
index bb09faeb..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/view/SwipeDismissTouchListener.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright 2013 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.achep.activedisplay.view;
-
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.app.ListActivity;
-import android.app.ListFragment;
-import android.view.MotionEvent;
-import android.view.VelocityTracker;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.widget.AdapterView;
-import android.widget.ListView;
-
-/**
- * A {@link View.OnTouchListener} that makes any {@link View} dismissable when the
- * user swipes (drags her finger) horizontally across the view.
- * <p/>
- * <p><em>For {@link ListView} list items that don't manage their own touch events
- * (i.e. you're using
- * {@link ListView#setOnItemClickListener(AdapterView.OnItemClickListener)}
- * or an equivalent listener on {@link ListActivity} or
- * {@link ListFragment}, use {@link SwipeDismissListViewTouchListener} instead.</em></p>
- * <p/>
- * <p>Example usage:</p>
- * <p/>
- * <pre>
- * view.setOnTouchListener(new SwipeDismissTouchListener(
- *         view,
- *         null, // Optional token/cookie object
- *         new SwipeDismissTouchListener.OnDismissCallback() {
- *             public void onDismiss(View view, Object token) {
- *                 parent.removeView(view);
- *             }
- *         }));
- * </pre>
- * <p/>
- * <p>This class Requires API level 12 or later due to use of {@link
- * android.view.ViewPropertyAnimator}.</p>
- */
-public class SwipeDismissTouchListener implements View.OnTouchListener {
-    // Cached ViewConfiguration and system-wide constant values
-    private int mSlop;
-    private int mMinFlingVelocity;
-    private int mMaxFlingVelocity;
-    private long mAnimationTime;
-
-    // Fixed properties
-    private View mView;
-    private DismissCallbacks mCallbacks;
-    private int mViewWidth = 1; // 1 and not 0 to prevent dividing by zero
-
-    // Transient properties
-    private float mDownX;
-    private float mDownY;
-    private boolean mSwiping;
-    private int mSwipingSlop;
-    private Object mToken;
-    private VelocityTracker mVelocityTracker;
-    private float mTranslationX;
-
-    /**
-     * The callback interface used by {@link SwipeDismissTouchListener} to inform its client
-     * about a successful dismissal of the view for which it was created.
-     */
-    public interface DismissCallbacks {
-        /**
-         * Called to determine whether the view can be dismissed.
-         */
-        boolean canDismiss(Object token);
-
-        /**
-         * Called when the user has indicated they she would like to dismiss the view.
-         *
-         * @param view  The originating {@link View} to be dismissed.
-         * @param token The optional token passed to this object's constructor.
-         */
-        void onDismiss(View view, Object token);
-    }
-
-    /**
-     * Constructs a new swipe-to-dismiss touch listener for the given view.
-     *
-     * @param view      The view to make dismissable.
-     * @param token     An optional token/cookie object to be passed through to the callback.
-     * @param callbacks The callback to trigger when the user has indicated that she would like to
-     *                  dismiss this view.
-     */
-    public SwipeDismissTouchListener(View view, Object token, DismissCallbacks callbacks) {
-        ViewConfiguration vc = ViewConfiguration.get(view.getContext());
-        mSlop = vc.getScaledTouchSlop();
-        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity() * 16;
-        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
-        mAnimationTime = view.getContext().getResources().getInteger(
-                android.R.integer.config_shortAnimTime);
-        mView = view;
-        mToken = token;
-        mCallbacks = callbacks;
-    }
-
-    @Override
-    public boolean onTouch(View view, MotionEvent motionEvent) {
-        // offset because the view is translated during swipe
-        motionEvent.offsetLocation(mTranslationX, 0);
-
-        if (mViewWidth < 2) {
-            mViewWidth = mView.getWidth();
-        }
-
-        switch (motionEvent.getActionMasked()) {
-            case MotionEvent.ACTION_DOWN: {
-                // TODO: ensure this is a finger, and set a flag
-                mDownX = motionEvent.getRawX();
-                mDownY = motionEvent.getRawY();
-                if (mCallbacks.canDismiss(mToken)) {
-                    mVelocityTracker = VelocityTracker.obtain();
-                    mVelocityTracker.addMovement(motionEvent);
-                }
-                return false;
-            }
-
-            case MotionEvent.ACTION_UP: {
-                if (mVelocityTracker == null) {
-                    break;
-                }
-
-                float deltaX = motionEvent.getRawX() - mDownX;
-                mVelocityTracker.addMovement(motionEvent);
-                mVelocityTracker.computeCurrentVelocity(1000);
-                float velocityX = mVelocityTracker.getXVelocity();
-                float absVelocityX = Math.abs(velocityX);
-                float absVelocityY = Math.abs(mVelocityTracker.getYVelocity());
-                boolean dismiss = false;
-                boolean dismissRight = false;
-                if (Math.abs(deltaX) > mViewWidth / 2 && mSwiping) {
-                    dismiss = true;
-                    dismissRight = deltaX > 0;
-                } else if (mMinFlingVelocity <= absVelocityX && absVelocityX <= mMaxFlingVelocity
-                        && absVelocityY < absVelocityX
-                        && absVelocityY < absVelocityX && mSwiping) {
-                    // dismiss only if flinging in the same direction as dragging
-                    dismiss = (velocityX < 0) == (deltaX < 0);
-                    dismissRight = mVelocityTracker.getXVelocity() > 0;
-                }
-                if (dismiss) {
-                    // dismiss
-                    mView.animate()
-                            .translationX(dismissRight ? mViewWidth : -mViewWidth)
-                            .alpha(0)
-                            .setDuration(mAnimationTime)
-                            .setListener(new AnimatorListenerAdapter() {
-                                @Override
-                                public void onAnimationEnd(Animator animation) {
-                                    performDismiss();
-                                }
-                            });
-                } else if (mSwiping) {
-                    // cancel
-                    mView.animate()
-                            .translationX(0)
-                            .alpha(1)
-                            .setDuration(mAnimationTime)
-                            .setListener(null);
-                }
-                mVelocityTracker.recycle();
-                mVelocityTracker = null;
-                mTranslationX = 0;
-                mDownX = 0;
-                mDownY = 0;
-                mSwiping = false;
-                break;
-            }
-
-            case MotionEvent.ACTION_CANCEL: {
-                if (mVelocityTracker == null) {
-                    break;
-                }
-
-                mView.animate()
-                        .translationX(0)
-                        .alpha(1)
-                        .setDuration(mAnimationTime)
-                        .setListener(null);
-                mVelocityTracker.recycle();
-                mVelocityTracker = null;
-                mTranslationX = 0;
-                mDownX = 0;
-                mDownY = 0;
-                mSwiping = false;
-                break;
-            }
-
-            case MotionEvent.ACTION_MOVE: {
-                if (mVelocityTracker == null) {
-                    break;
-                }
-
-                mVelocityTracker.addMovement(motionEvent);
-                float deltaX = motionEvent.getRawX() - mDownX;
-                float deltaY = motionEvent.getRawY() - mDownY;
-                if (Math.abs(deltaX) > mSlop && Math.abs(deltaY) < Math.abs(deltaX) / 2) {
-                    mSwiping = true;
-                    mSwipingSlop = (deltaX > 0 ? mSlop : -mSlop);
-                    mView.getParent().requestDisallowInterceptTouchEvent(true);
-
-                    // Cancel listview's touch
-                    MotionEvent cancelEvent = MotionEvent.obtain(motionEvent);
-                    cancelEvent.setAction(MotionEvent.ACTION_CANCEL |
-                            (motionEvent.getActionIndex() <<
-                                    MotionEvent.ACTION_POINTER_INDEX_SHIFT));
-                    mView.onTouchEvent(cancelEvent);
-                    cancelEvent.recycle();
-                }
-
-                if (mSwiping) {
-                    mTranslationX = deltaX;
-                    mView.setTranslationX(deltaX - mSwipingSlop);
-                    // TODO: use an ease-out interpolator or such
-                    mView.setAlpha(Math.max(0f, Math.min(1f,
-                            1f - 2f * Math.abs(deltaX) / mViewWidth)));
-                    return true;
-                }
-                break;
-            }
-        }
-        return false;
-    }
-
-    private void performDismiss() {
-        mCallbacks.onDismiss(mView, mToken);
-        // Reset view presentation
-        mView.setTranslationX(0);
-        mView.setAlpha(1);
-    }
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/CircleView.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/CircleView.java
new file mode 100644
index 00000000..9fea5fb5
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/CircleView.java
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.widgets;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+import android.os.Handler;
+import android.util.AttributeSet;
+import android.view.HapticFeedbackConstants;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.Animation;
+import android.view.animation.DecelerateInterpolator;
+
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.animations.AnimationListenerAdapter;
+import com.achep.activedisplay.animations.CircleViewAnimation;
+
+/**
+ * Created by achep on 19.04.14.
+ */
+public class CircleView extends View {
+
+    public static final int ACTION_START = 0;
+    public static final int ACTION_UNLOCK = 1;
+    public static final int ACTION_CANCELED = 2;
+
+    private float[] mPoint = new float[2];
+
+    private boolean mCanceled;
+    private boolean mRadiusAimed;
+    private float mRadiusDecreaseThreshold;
+    private float mRadiusTarget;
+    private float mRadiusMax;
+    private float mRadius;
+    private Paint mPaint;
+
+    private Drawable mDrawable;
+
+    private CircleViewAnimation mAnimationOut;
+    private Callback mCallback;
+
+    private Handler mHandler;
+    private Runnable mDelayedCancel;
+
+    public interface Callback {
+
+        public void onCircleEvent(float radius, float ratio, int event);
+    }
+
+    public CircleView(Context context) {
+        super(context);
+        init();
+    }
+
+    public CircleView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init();
+    }
+
+    public CircleView(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        init();
+    }
+
+    private void init() {
+        Resources res = getContext().getResources();
+
+        mHandler = new Handler();
+        mDelayedCancel = new Runnable() {
+            @Override
+            public void run() {
+                cancelCircle(false);
+            }
+        };
+
+        mAnimationOut = new CircleViewAnimation(this, 0, 0);
+        mAnimationOut.setInterpolator(new AccelerateDecelerateInterpolator());
+        mAnimationOut.setDuration(res.getInteger(android.R.integer.config_mediumAnimTime));
+
+        mPaint = new Paint();
+        mPaint.setAntiAlias(true);
+        mPaint.setColor(Color.WHITE);
+        mPaint.setStrokeWidth(2);
+
+        mRadiusTarget = res.getDimension(R.dimen.circle_radius_target);
+        mRadiusDecreaseThreshold = res.getDimension(R.dimen.circle_radius_decrease_threshold);
+
+        mDrawable = res.getDrawable(R.drawable.ic_unlock);
+        mDrawable.setBounds(0, 0,
+                mDrawable.getIntrinsicWidth(),
+                mDrawable.getIntrinsicHeight());
+
+        setRadius(0);
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        final float ratio = calculateRatio();
+        float radius;
+
+        // Darkening background
+        canvas.drawColor(Color.argb((int) (200 * calculateRatio()), 0, 0, 0));
+
+        if (mRadiusAimed) {
+
+            // Indicate that target radius is aimed.
+            mPaint.setAlpha(35);
+            radius = (float) Math.sqrt(mRadius / 70) * 70;
+            canvas.drawCircle(mPoint[0], mPoint[1], radius, mPaint);
+        }
+
+        // Draw unlock circle
+        mPaint.setAlpha((int) (255 * Math.pow(ratio, 0.33f)));
+        radius = (float) Math.sqrt(mRadius / 50) * 50;
+        canvas.drawCircle(mPoint[0], mPoint[1], radius, mPaint);
+
+        // Draw unlock icon at the center of circle
+        float scale = 0.5f + 0.5f * ratio;
+        canvas.save();
+        canvas.translate(
+                mPoint[0] - mDrawable.getMinimumWidth() / 2 * scale,
+                mPoint[1] - mDrawable.getMinimumHeight() / 2 * scale);
+        canvas.scale(scale, scale);
+        mDrawable.draw(canvas);
+        canvas.restore();
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        mHandler.removeCallbacks(mDelayedCancel);
+    }
+
+    public boolean onTouchEvent2(MotionEvent event) {
+        // Cancel current circle on two-fingers touch (or more.)
+        if (event.getPointerCount() > 1) {
+            cancelCircle(false);
+            return false;
+        }
+
+        // If current circle is canceled then
+        // ignore all actions except of touch down (to reset state.)
+        if (mCanceled && event.getActionMasked() != MotionEvent.ACTION_DOWN) return false;
+
+        final float x = event.getX();
+        final float y = event.getY();
+        switch (event.getActionMasked()) {
+            case MotionEvent.ACTION_DOWN:
+                clearAnimation();
+
+                // Initialize circle
+                mRadiusMax = 0;
+                mPoint[0] = x;
+                mPoint[1] = y;
+                mCanceled = false;
+
+                mHandler.postDelayed(mDelayedCancel, 1000);
+                mCallback.onCircleEvent(mRadius, calculateRatio(), ACTION_START);
+            case MotionEvent.ACTION_MOVE:
+                setRadius((float) Math.hypot(x - mPoint[0], y - mPoint[1]));
+
+                // Cancel the circle if it's decreasing.
+                if (mRadiusMax - mRadius > mRadiusDecreaseThreshold) {
+                    mRadiusAimed = false;
+                    cancelCircle(false);
+                    break;
+                }
+
+                if (calculateRatio() == 1) {
+                    if (!mRadiusAimed) {
+                        mRadiusAimed = true;
+                        performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
+                    }
+                } else if (mRadiusAimed) {
+                    mRadiusAimed = false;
+                    performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
+                }
+                break;
+            case MotionEvent.ACTION_UP:
+                if (mRadiusAimed) {
+                    mCallback.onCircleEvent(mRadius, calculateRatio(), ACTION_UNLOCK);
+                }
+            case MotionEvent.ACTION_CANCEL:
+                mHandler.removeCallbacks(mDelayedCancel);
+                cancelCircle(mRadiusAimed);
+                break;
+            default:
+                return super.onTouchEvent(event);
+        }
+        return false;
+    }
+
+    private void cancelCircle(boolean unlockAnimation) {
+        if (mCanceled) {
+            return;
+        }
+
+        mCanceled = true;
+        mCallback.onCircleEvent(mRadius, calculateRatio(), ACTION_CANCELED);
+
+        mAnimationOut.setStartOffset(unlockAnimation ? 150 : 0);
+        mAnimationOut.setRange(mRadius, 0f);
+        startAnimation(mAnimationOut);
+    }
+
+    private float calculateRatio() {
+        return Math.min(mRadius / mRadiusTarget, 1);
+    }
+
+    public void setRadius(float radius) {
+        mRadius = radius;
+        mRadiusMax = Math.max(mRadiusMax, mRadius);
+
+        float ratio = calculateRatio();
+        mDrawable.setAlpha((int) (255 * Math.pow(ratio, 3)));
+
+        postInvalidateOnAnimation();
+    }
+
+    public void setRadiusTarget(float radiusTarget) {
+        mRadiusTarget = radiusTarget;
+        setRadius(mRadius);
+    }
+
+    public void setCallback(Callback callback) {
+        mCallback = callback;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationIcon.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationIcon.java
index 4a51374c..9d8af571 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationIcon.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationIcon.java
@@ -21,8 +21,6 @@ package com.achep.activedisplay.widgets;
 
 import android.content.Context;
 import android.graphics.Bitmap;
-import android.graphics.ColorFilter;
-import android.graphics.ColorMatrixColorFilter;
 import android.util.AttributeSet;
 import android.widget.ImageView;
 
@@ -56,9 +54,9 @@ public class NotificationIcon extends ImageView implements NotificationView, Not
         init();
     }
 
+    @SuppressWarnings("EmptyMethod")
     private void init() {
-        if (true) return;
-
+        /*
         float c[] = new float[]{
                 1f, 0f, 0f, // red
                 0f, 1f, 0f, // green
@@ -78,6 +76,7 @@ public class NotificationIcon extends ImageView implements NotificationView, Not
 
         ColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);
         setColorFilter(colorFilter);
+        */
     }
 
     private void registerListenerAndUpdateIcon() {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationWidget.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationWidget.java
index 12707fcd..697bc0c2 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationWidget.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationWidget.java
@@ -31,6 +31,7 @@ import android.text.format.DateUtils;
 import android.util.AttributeSet;
 import android.view.LayoutInflater;
 import android.view.View;
+import android.view.ViewGroup;
 import android.widget.ImageView;
 import android.widget.LinearLayout;
 import android.widget.RelativeLayout;
@@ -42,26 +43,28 @@ import com.achep.activedisplay.notifications.NotificationData;
 import com.achep.activedisplay.notifications.NotificationUtils;
 import com.achep.activedisplay.notifications.OpenStatusBarNotification;
 import com.achep.activedisplay.utils.ViewUtils;
+import com.achep.activedisplay.view.NotifyingLayout;
 
 /**
  * Created by Artem on 20.03.14.
  */
 public class NotificationWidget extends RelativeLayout implements NotificationView {
 
+    private NotifyingLayout mDismissBtnContainer;
     private NotificationIcon mIcon;
     private TextView mTitleTextView;
     private TextView mMessageTextView;
-    private NotificationIcon mSmallIcon;
-    private TextView mNumberTextView;
     private TextView mWhenTextView;
     private TextView mSubtextTextView;
     private LinearLayout mActionsContainer;
 
     private OnClickListener mOnClickListener;
     private OpenStatusBarNotification mNotification;
+    private ViewGroup mContent;
 
     public interface OnClickListener extends View.OnClickListener {
-        void onActionClick(View v, PendingIntent intent);
+        void onActionButtonClick(View v, PendingIntent intent);
+        void onDismissButtonClick(View v, OpenStatusBarNotification osbn);
     }
 
     public NotificationWidget(Context context, AttributeSet attrs) {
@@ -73,7 +76,7 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
     }
 
     public void setOnClickListener(OnClickListener l) {
-        setOnClickListener((View.OnClickListener) l);
+        mContent.setOnClickListener(l);
         mOnClickListener = l;
     }
 
@@ -81,17 +84,36 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
     protected void onFinishInflate() {
         super.onFinishInflate();
 
+        mContent = (ViewGroup) findViewById(R.id.content);
         mIcon = (NotificationIcon) findViewById(R.id.icon);
         mTitleTextView = (TextView) findViewById(R.id.title);
         mMessageTextView = (TextView) findViewById(R.id.message);
-        mSmallIcon = (NotificationIcon) findViewById(R.id.icon_small);
-        mNumberTextView = (TextView) findViewById(R.id.number);
         mWhenTextView = (TextView) findViewById(R.id.when);
         mSubtextTextView = (TextView) findViewById(R.id.subtext);
         mActionsContainer = (LinearLayout) findViewById(R.id.actions);
+        mDismissBtnContainer = (NotifyingLayout) findViewById(R.id.dismiss);
 
         mIcon.setNotificationIndicateReadStateEnabled(false);
-        mSmallIcon.setNotificationIndicateReadStateEnabled(false);
+        mDismissBtnContainer.setAlpha(isPressed() ? 1f : 0f);
+        mDismissBtnContainer.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (mOnClickListener != null) {
+                    mOnClickListener.onDismissButtonClick(v, getNotification());
+                }
+            }
+        });
+        mDismissBtnContainer.setOnPressStateChangedListener(
+                new NotifyingLayout.OnPressStateChangedListener() {
+            @Override
+            public void onPressStateChanged(NotifyingLayout view, boolean pressed) {
+                if (pressed) {
+                    view.animate().alpha(1f);
+                } else {
+                    view.animate().alpha(0f);
+                }
+            }
+        });
     }
 
     public void setNotification(OpenStatusBarNotification osbn) {
@@ -107,12 +129,9 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
         ViewUtils.safelySetText(mTitleTextView, data.titleText);
         ViewUtils.safelySetText(mMessageTextView, data.getLargeMessage());
         ViewUtils.safelySetText(mSubtextTextView, data.infoText == null ? data.subText : data.infoText);
-        ViewUtils.safelySetText(mNumberTextView, data.number > 0 ? Integer.toString(data.number) : null);
 
         mWhenTextView.setText(DateUtils.formatDateTime(getContext(), sbn.getPostTime(), DateUtils.FORMAT_SHOW_TIME));
 
-        boolean showSmallIcon = mNumberTextView.getVisibility() == View.VISIBLE;
-
         Bitmap bitmap = sbn.getNotification().largeIcon;
         if (bitmap != null) {
             mIcon.setNotification(null);
@@ -120,16 +139,11 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
             mIcon.setScaleType(bitmap.getPixel(0, 0) != Color.TRANSPARENT
                     ? ImageView.ScaleType.CENTER_CROP
                     : ImageView.ScaleType.CENTER_INSIDE);
-
-            showSmallIcon = true;
         } else {
             mIcon.setNotification(osbn);
             mIcon.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
         }
 
-        ViewUtils.setVisible(mSmallIcon, showSmallIcon);
-        if (showSmallIcon) mSmallIcon.setNotification(osbn);
-
         if (Device.hasKitKatApi()) {
             updateNotificationActions(sbn);
         }
@@ -178,7 +192,7 @@ public class NotificationWidget extends RelativeLayout implements NotificationVi
                     @Override
                     public void onClick(View v) {
                         if (mOnClickListener != null) {
-                            mOnClickListener.onActionClick(v, action.actionIntent);
+                            mOnClickListener.onActionButtonClick(v, action.actionIntent);
                         }
                     }
                 });
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/ProgressBar.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/ProgressBar.java
index d7086553..f4bf379c 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/ProgressBar.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/ProgressBar.java
@@ -40,7 +40,7 @@ public class ProgressBar extends android.widget.ProgressBar {
          * Notification that the progress level has changed.
          *
          * @param progressBar The ProgressBar whose progress has changed
-         * @param progress    The current progress level. This will be in the range 0..{@link ProgressBar#getMax()}}
+         * @param progress    The current progress level. This will be in the range 0..{@link com.achep.activedisplay.widgets.ProgressBar#getMax()}}
          */
         public void onProgressChanged(ProgressBar progressBar, int progress);
 
