diff --git a/adguard_cb/src/main/java/com/adguard/android/ServiceLocator.java b/adguard_cb/src/main/java/com/adguard/android/ServiceLocator.java
index c3bfe78..d1f4497 100644
--- a/adguard_cb/src/main/java/com/adguard/android/ServiceLocator.java
+++ b/adguard_cb/src/main/java/com/adguard/android/ServiceLocator.java
@@ -32,7 +32,6 @@ public class ServiceLocator {
     private static WeakHashMap<Context, ServiceLocator> locators = new WeakHashMap<>();
     private FilterService filterService;
     private PreferencesService preferencesService;
-    private JobService jobService;
 
     /**
      * Creates an instance of the ServiceLocator
@@ -82,15 +81,4 @@ public class ServiceLocator {
 
         return preferencesService;
     }
-
-    /**
-     * @return Job service singleton
-     */
-    public JobService getJobService() {
-        if (jobService == null) {
-            jobService = new JobServiceImpl();
-        }
-
-        return jobService;
-    }
 }
diff --git a/adguard_cb/src/main/java/com/adguard/android/commons/BrowserUtils.java b/adguard_cb/src/main/java/com/adguard/android/commons/BrowserUtils.java
index 1c3a28f..b8cfd1f 100644
--- a/adguard_cb/src/main/java/com/adguard/android/commons/BrowserUtils.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/BrowserUtils.java
@@ -155,7 +155,7 @@ public class BrowserUtils {
         List<ResolveInfo> list = context.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
         if (list.size() > 0) {
             for (ResolveInfo info : list) {
-                if (info.activityInfo.packageName.contains(MainActivity.YANDEX)) {
+                if (info.activityInfo.packageName.contains(BrowserUtils.YANDEX)) {
                     return true;
                 }
             }
@@ -166,7 +166,7 @@ public class BrowserUtils {
         list = context.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
         if (list.size() > 0) {
             for (ResolveInfo info : list) {
-                if (info.activityInfo.packageName.contains(MainActivity.YANDEX)) {
+                if (info.activityInfo.packageName.contains(BrowserUtils.YANDEX)) {
                     return true;
                 }
             }
diff --git a/adguard_cb/src/main/java/com/adguard/commons/utils/ProductVersion.java b/adguard_cb/src/main/java/com/adguard/android/commons/ProductVersion.java
similarity index 99%
rename from adguard_cb/src/main/java/com/adguard/commons/utils/ProductVersion.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/ProductVersion.java
index e3db097..0cf8520 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/utils/ProductVersion.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/ProductVersion.java
@@ -14,7 +14,7 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons.utils;
+package com.adguard.android.commons;
 
 import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.math.NumberUtils;
diff --git a/adguard_cb/src/main/java/com/adguard/commons/lang/StringHelperUtils.java b/adguard_cb/src/main/java/com/adguard/android/commons/StringHelperUtils.java
similarity index 98%
rename from adguard_cb/src/main/java/com/adguard/commons/lang/StringHelperUtils.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/StringHelperUtils.java
index e2d4859..f2e1eb0 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/lang/StringHelperUtils.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/StringHelperUtils.java
@@ -14,7 +14,7 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons.lang;
+package com.adguard.android.commons;
 
 import org.apache.commons.lang3.StringUtils;
 
diff --git a/adguard_cb/src/main/java/com/adguard/commons/concurrent/DispatcherTask.java b/adguard_cb/src/main/java/com/adguard/android/commons/concurrent/DispatcherTask.java
similarity index 95%
rename from adguard_cb/src/main/java/com/adguard/commons/concurrent/DispatcherTask.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/concurrent/DispatcherTask.java
index 3308536..1a3a2e4 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/concurrent/DispatcherTask.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/concurrent/DispatcherTask.java
@@ -14,7 +14,7 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons.concurrent;
+package com.adguard.android.commons.concurrent;
 
 /**
  * Class that is used to
diff --git a/adguard_cb/src/main/java/com/adguard/commons/concurrent/DispatcherThreadPool.java b/adguard_cb/src/main/java/com/adguard/android/commons/concurrent/DispatcherThreadPool.java
similarity index 99%
rename from adguard_cb/src/main/java/com/adguard/commons/concurrent/DispatcherThreadPool.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/concurrent/DispatcherThreadPool.java
index 6c46719..77bfb73 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/concurrent/DispatcherThreadPool.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/concurrent/DispatcherThreadPool.java
@@ -14,7 +14,7 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons.concurrent;
+package com.adguard.android.commons.concurrent;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/adguard_cb/src/main/java/com/adguard/commons/concurrent/ExecutorsPool.java b/adguard_cb/src/main/java/com/adguard/android/commons/concurrent/ExecutorsPool.java
similarity index 97%
rename from adguard_cb/src/main/java/com/adguard/commons/concurrent/ExecutorsPool.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/concurrent/ExecutorsPool.java
index 404a1d0..d542b0a 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/concurrent/ExecutorsPool.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/concurrent/ExecutorsPool.java
@@ -14,7 +14,7 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons.concurrent;
+package com.adguard.android.commons.concurrent;
 
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
diff --git a/adguard_cb/src/main/java/com/adguard/commons/InternetUtils.java b/adguard_cb/src/main/java/com/adguard/android/commons/network/InternetUtils.java
similarity index 98%
rename from adguard_cb/src/main/java/com/adguard/commons/InternetUtils.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/network/InternetUtils.java
index 148003a..312ebc6 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/InternetUtils.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/network/InternetUtils.java
@@ -14,7 +14,7 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons;
+package com.adguard.android.commons.network;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/adguard_cb/src/main/java/com/adguard/commons/NetworkUtils.java b/adguard_cb/src/main/java/com/adguard/android/commons/network/NetworkUtils.java
similarity index 89%
rename from adguard_cb/src/main/java/com/adguard/commons/NetworkUtils.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/network/NetworkUtils.java
index f6dd619..4dfd1fe 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/NetworkUtils.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/network/NetworkUtils.java
@@ -14,20 +14,11 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons;
+package com.adguard.android.commons.network;
 
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.net.NetworkInfo;
-import com.adguard.commons.concurrent.ExecutorsPool;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.lang.reflect.Method;
-import java.net.*;
-import java.util.ArrayList;
-import java.util.Enumeration;
-import java.util.List;
 
 /**
  * Helper methods for working with the network
@@ -46,6 +37,16 @@ public class NetworkUtils {
         return activeNetworkInfo != null && activeNetworkInfo.isConnected();
     }
 
+    /**
+     * @param context Current context
+     * @return is current connection wifi
+     */
+    public static boolean isConnectionWifi(Context context) {
+        final Integer connectionType = NetworkUtils.getConnectionType(context);
+        //noinspection Annotator
+        return connectionType != null && (connectionType == ConnectivityManager.TYPE_WIFI || connectionType == ConnectivityManager.TYPE_ETHERNET);
+    }
+
     /**
      * @param context Current context
      * @return current connection type
@@ -61,13 +62,4 @@ public class NetworkUtils {
         return null;
     }
 
-    /**
-     * @param context Current context
-     * @return is current connection wifi
-     */
-    public static boolean isConnectionWifi(Context context) {
-        final Integer connectionType = NetworkUtils.getConnectionType(context);
-        //noinspection Annotator
-        return connectionType != null && (connectionType == ConnectivityManager.TYPE_WIFI || connectionType == ConnectivityManager.TYPE_ETHERNET);
-    }
 }
diff --git a/adguard_cb/src/main/java/com/adguard/commons/utils/ReservedDomains.java b/adguard_cb/src/main/java/com/adguard/android/commons/web/ReservedDomains.java
similarity index 98%
rename from adguard_cb/src/main/java/com/adguard/commons/utils/ReservedDomains.java
rename to adguard_cb/src/main/java/com/adguard/android/commons/web/ReservedDomains.java
index a1c8685..b2acc90 100644
--- a/adguard_cb/src/main/java/com/adguard/commons/utils/ReservedDomains.java
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/web/ReservedDomains.java
@@ -14,7 +14,7 @@
  You should have received a copy of the GNU General Public License along with
  Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
-package com.adguard.commons.utils;
+package com.adguard.android.commons.web;
 
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
diff --git a/adguard_cb/src/main/java/com/adguard/android/commons/web/UrlUtils.java b/adguard_cb/src/main/java/com/adguard/android/commons/web/UrlUtils.java
new file mode 100644
index 0000000..e44d241
--- /dev/null
+++ b/adguard_cb/src/main/java/com/adguard/android/commons/web/UrlUtils.java
@@ -0,0 +1,329 @@
+/**
+ * This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
+ * Copyright © 2016 Performix LLC. All rights reserved.
+ * <p>
+ * Adguard Content Blocker is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or (at your option)
+ * any later version.
+ * <p>
+ * Adguard Content Blocker is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * <p>
+ * You should have received a copy of the GNU General Public License along with
+ * Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
+ */
+package com.adguard.android.commons.web;
+
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.Proxy;
+import java.net.URL;
+import java.net.URLEncoder;
+import java.util.zip.GZIPOutputStream;
+
+/**
+ * Helper for working with URLs (extract keywords, extract domain name)
+ */
+public class UrlUtils {
+
+    private final static Logger LOG = LoggerFactory.getLogger(UrlUtils.class);
+    private final static int DEFAULT_READ_TIMEOUT = 10000; // 10 seconds
+    private final static int DEFAULT_SOCKET_TIMEOUT = 10000; // 10 seconds
+
+    /**
+     * Tries to url encode specified text (using utf-8 encoding).
+     * If something gone wrong -- returns input text as is.
+     *
+     * @param text Text to encode
+     * @return Encoded string
+     */
+    public static String urlEncode(String text) {
+        try {
+            return URLEncoder.encode(text, "utf-8");
+        } catch (Exception ex) {
+            LOG.warn("Error encoding " + text, ex);
+        }
+        return text;
+    }
+
+    /**
+     * Downloads string from the specified url
+     *
+     * @param url Url
+     * @return Response
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public static String downloadString(String url) throws MalformedURLException {
+        return downloadString(new URL(url));
+    }
+
+    /**
+     * Downloads string from the specified url
+     *
+     * @param url               Url
+     * @param readTimeout       Read timeout
+     * @param connectionTimeout Connection timeout
+     * @return Downloaded string or null
+     * @throws MalformedURLException
+     */
+    public static String downloadString(String url, int readTimeout, int connectionTimeout) throws MalformedURLException {
+        return downloadString(new URL(url), null, readTimeout, connectionTimeout, "utf-8");
+    }
+
+    /**
+     * Tries to download from the specified url for triesCount times
+     *
+     * @param url        Url
+     * @param triesCount Tries count
+     * @return Repsponse
+     */
+    public static String downloadString(String url, int triesCount) throws MalformedURLException {
+        return downloadString(new URL(url), null, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT, "utf-8", triesCount);
+    }
+
+    /**
+     * Downloads content from the specified url.
+     * Returns null if there's an error.
+     *
+     * @param url url
+     * @return downloaded string
+     */
+    public static String downloadString(URL url) {
+        return downloadString(url, null, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT, "utf-8");
+    }
+
+    /**
+     * Downloads content from the specified url using specified proxy (or do not using it).
+     * Returns null if there's an error.
+     *
+     * @param url   url
+     * @param proxy proxy to use
+     */
+    @SuppressWarnings("UnusedDeclaration")
+    public static String downloadString(URL url, Proxy proxy) {
+        return downloadString(url, proxy, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT, "utf-8");
+    }
+
+    /**
+     * Downloads content from the specified url using specified proxy (or do not using it) and timeouts.
+     * Returns null if there's an error.
+     *
+     * @param url           url
+     * @param proxy         proxy to use
+     * @param readTimeout   read timeout
+     * @param socketTimeout connection timeout
+     * @return Downloaded string
+     */
+    public static String downloadString(URL url, Proxy proxy, int readTimeout, int socketTimeout, String encoding) {
+        HttpURLConnection connection = null;
+        InputStream inputStream = null;
+
+        try {
+            connection = (HttpURLConnection) (proxy == null ? url.openConnection() : url.openConnection(proxy));
+            connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.85 Safari/537.36");
+            connection.setReadTimeout(readTimeout);
+            connection.setConnectTimeout(socketTimeout);
+            connection.connect();
+            if (connection.getResponseCode() >= 400) {
+                throw new IOException("Response status is " + connection.getResponseCode());
+            }
+
+            if (connection.getResponseCode() >= 301) {
+                String location = connection.getHeaderField("Location");
+                // HttpURLConnection does not follow redirects from HTTP to HTTPS
+                // So we handle it manually
+                return downloadString(new URL(location), proxy, readTimeout, socketTimeout, encoding);
+            }
+
+            if (connection.getResponseCode() == 204) {
+                return StringUtils.EMPTY;
+            }
+
+            inputStream = connection.getInputStream();
+            return IOUtils.toString(inputStream, encoding);
+        } catch (IOException ex) {
+            if (LOG.isDebugEnabled()) {
+                LOG.warn("Error downloading string from {}:\r\n", url, ex);
+            } else {
+                LOG.warn("Cannot download string from {}: {}", url, ex.getMessage());
+            }
+            // Ignoring exception
+            return null;
+        } finally {
+            IOUtils.closeQuietly(inputStream);
+            if (connection != null) {
+                connection.disconnect();
+            }
+        }
+    }
+
+    /**
+     * Downloads content from the specified url using specified proxy (or do not using it) and timeouts.
+     * Returns null if there's an error.
+     *
+     * @param url           url
+     * @param proxy         proxy to use
+     * @param readTimeout   read timeout
+     * @param socketTimeout connection timeout
+     * @return Downloaded string
+     */
+    public static String downloadString(URL url, Proxy proxy, int readTimeout, int socketTimeout, String encoding, int triesCount) {
+        IOException lastException = null;
+
+        for (int i = 0; i < triesCount; i++) {
+            lastException = null;
+            HttpURLConnection connection = null;
+            InputStream inputStream = null;
+
+            try {
+                connection = (HttpURLConnection) (proxy == null ? url.openConnection() : url.openConnection(proxy));
+                connection.setReadTimeout(readTimeout);
+                connection.setConnectTimeout(socketTimeout);
+                connection.connect();
+                inputStream = connection.getInputStream();
+                return IOUtils.toString(inputStream, encoding);
+            } catch (IOException ex) {
+                if (LOG.isDebugEnabled()) {
+                    LOG.warn("Error downloading string from {}. Try number: {}. Cause:\r\n", url, triesCount, ex);
+                } else {
+                    LOG.warn("Error downloading string from {}. Try number: {}. Cause:{}", url, triesCount, ex.getMessage());
+                }
+                lastException = ex;
+            } finally {
+                IOUtils.closeQuietly(inputStream);
+                if (connection != null) {
+                    connection.disconnect();
+                }
+            }
+        }
+
+        if (lastException != null) {
+            LOG.error("Could not download string from url: " + url, lastException);
+        }
+
+        return null;
+    }
+
+    /**
+     * Sends a post request
+     *
+     * @param url           url
+     * @param postData      data to post
+     * @param encoding      response encoding
+     * @param contentType   content type
+     * @param readTimeout   socket read timeout
+     * @param socketTimeout socket connect timeout
+     * @return downloaded string
+     */
+    public static String postRequest(String url, String postData, String encoding, String contentType, int readTimeout, int socketTimeout) {
+
+        try {
+            return postRequest(new URL(url), postData, encoding, contentType, readTimeout, socketTimeout);
+        } catch (MalformedURLException ex) {
+            LOG.error("Error posting request to {}, post data length={}", url, StringUtils.length(postData), ex);
+            return null;
+        }
+    }
+
+    /**
+     * Sends a post request
+     *
+     * @param url         url
+     * @param postData    data to post
+     * @param encoding    response encoding
+     * @param contentType content type
+     * @return downloaded string
+     */
+    public static String postRequest(URL url, String postData, String encoding, String contentType) {
+        return postRequest(url, postData, encoding, contentType, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT);
+    }
+
+    /**
+     * Sends a POST request
+     *
+     * @param url           URL
+     * @param postData      Post body
+     * @param encoding      Post body encoding
+     * @param contentType   Post body content type
+     * @param readTimeout   Read timeout
+     * @param socketTimeout Socket timeout
+     * @return Response
+     */
+    public static String postRequest(URL url, String postData, String encoding, String contentType, int readTimeout, int socketTimeout) {
+        return postRequest(url, postData, encoding, contentType, false, readTimeout, socketTimeout);
+    }
+
+    /**
+     * Sends a POST request
+     *
+     * @param url           URL
+     * @param postData      Post request body
+     * @param encoding      Post request body encoding
+     * @param contentType   Body content type
+     * @param compress      If true - compress bod
+     * @param readTimeout   Read timeout
+     * @param socketTimeout Socket timeout
+     * @return Response
+     */
+    public static String postRequest(URL url, String postData, String encoding, String contentType, boolean compress, int readTimeout, int socketTimeout) {
+        HttpURLConnection connection = null;
+        OutputStream outputStream = null;
+
+        try {
+            connection = (HttpURLConnection) url.openConnection();
+            connection.setRequestMethod("POST");
+            if (contentType != null) {
+                connection.setRequestProperty("Content-Type", contentType);
+            }
+            if (compress) {
+                connection.setRequestProperty("Content-Encoding", "gzip");
+            }
+            connection.setConnectTimeout(socketTimeout);
+            connection.setReadTimeout(readTimeout);
+            connection.setDoOutput(true);
+            connection.connect();
+            if (postData != null) {
+                outputStream = connection.getOutputStream();
+
+                if (compress) {
+                    outputStream = new GZIPOutputStream(outputStream);
+                }
+
+                if (encoding != null) {
+                    IOUtils.write(postData, outputStream, encoding);
+                } else {
+                    IOUtils.write(postData, outputStream);
+                }
+
+                if (compress) {
+                    ((GZIPOutputStream) outputStream).finish();
+                } else {
+                    outputStream.flush();
+                }
+            }
+
+            return IOUtils.toString(connection.getInputStream(), encoding);
+        } catch (Exception ex) {
+            LOG.error("Error posting request to {}, post data length={}\r\n", url, StringUtils.length(postData), ex);
+            // Ignoring exception
+            return null;
+        } finally {
+            IOUtils.closeQuietly(outputStream);
+
+            if (connection != null) {
+                connection.disconnect();
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/AlarmReceiver.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/AlarmReceiver.java
index 89763ad..bd2547f 100644
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/AlarmReceiver.java
+++ b/adguard_cb/src/main/java/com/adguard/android/contentblocker/AlarmReceiver.java
@@ -7,8 +7,8 @@ import com.adguard.android.ServiceLocator;
 import com.adguard.android.model.FilterList;
 import com.adguard.android.service.FilterService;
 import com.adguard.android.service.PreferencesService;
-import com.adguard.commons.concurrent.DispatcherTask;
-import com.adguard.commons.concurrent.DispatcherThreadPool;
+import com.adguard.android.commons.concurrent.DispatcherTask;
+import com.adguard.android.commons.concurrent.DispatcherThreadPool;
 
 import org.apache.commons.collections4.CollectionUtils;
 
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/FilterViewAdapter.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/FilterViewAdapter.java
index 9b6ee30..942d942 100644
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/FilterViewAdapter.java
+++ b/adguard_cb/src/main/java/com/adguard/android/contentblocker/FilterViewAdapter.java
@@ -27,7 +27,6 @@ import android.widget.CheckBox;
 import android.widget.TextView;
 
 import com.adguard.android.ServiceLocator;
-import com.adguard.android.contentblocker.preferences.PreferenceDb;
 import com.adguard.android.model.FilterList;
 import com.adguard.android.service.FilterService;
 import com.adguard.android.service.FilterServiceImpl;
@@ -79,7 +78,7 @@ public class FilterViewAdapter extends BaseAdapter implements View.OnClickListen
         FilterList filterList = filterService.getFilters().get(position);
         View view;
         if (convertView == null) {
-            view = inflater.inflate(R.layout.preference_item_checkbox, parent, false);
+            view = inflater.inflate(R.layout.filter_list_item, parent, false);
         } else {
             view = convertView;
         }
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/MainActivity.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/MainActivity.java
index aeb0a6b..4afe762 100644
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/MainActivity.java
+++ b/adguard_cb/src/main/java/com/adguard/android/contentblocker/MainActivity.java
@@ -22,11 +22,9 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
 import android.content.res.Configuration;
-import android.graphics.Color;
 import android.net.Uri;
 import android.os.AsyncTask;
 import android.preference.PreferenceManager;
-import android.support.design.widget.Snackbar;
 import android.support.v4.widget.DrawerLayout;
 import android.support.v7.app.ActionBar;
 import android.support.v7.app.ActionBarDrawerToggle;
@@ -64,8 +62,8 @@ import java.util.List;
 
 public class MainActivity extends AppCompatActivity implements DrawerLayout.DrawerListener, SharedPreferences.OnSharedPreferenceChangeListener {
 
-    public static final String YANDEX = "yandex";
     private static Logger LOG = LoggerFactory.getLogger(MainActivity.class);
+
     private DrawerLayout drawerLayout;
     private ListView drawerList;
     private LinearLayout leftDrawer;
@@ -131,14 +129,14 @@ public class MainActivity extends AppCompatActivity implements DrawerLayout.Draw
         }
 
 
-        if (!preferencesService.isShowAboutOtherProduct()) {
+        if (!preferencesService.isWelcomeMessage()) {
             final View bottomBarView = findViewById(R.id.bottom_bar);
             bottomBarView.setVisibility(View.VISIBLE);
 
             bottomBarView.findViewById(R.id.no_thanks).setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View view) {
-                    preferencesService.setShowAboutOtherProduct(true);
+                    preferencesService.setWelcomeMessage(true);
                     bottomBarView.setVisibility(View.GONE);
                 }
             });
@@ -146,7 +144,7 @@ public class MainActivity extends AppCompatActivity implements DrawerLayout.Draw
             bottomBarView.findViewById(R.id.learn_more).setOnClickListener(new View.OnClickListener() {
                 @Override
                 public void onClick(View view) {
-                    preferencesService.setShowAboutOtherProduct(true);
+                    preferencesService.setWelcomeMessage(true);
                     bottomBarView.setVisibility(View.GONE);
                     startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse("http://agrd.io/cb_adguard_products")));
                 }
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/ServiceApiClient.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/ServiceApiClient.java
index 5892df1..611de72 100644
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/ServiceApiClient.java
+++ b/adguard_cb/src/main/java/com/adguard/android/contentblocker/ServiceApiClient.java
@@ -20,7 +20,7 @@ import android.content.Context;
 import com.adguard.android.commons.RawResources;
 import com.adguard.android.filtering.api.HttpServiceClient;
 import com.adguard.android.model.FilterList;
-import com.adguard.commons.web.UrlUtils;
+import com.adguard.android.commons.web.UrlUtils;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.time.DateUtils;
 import org.codehaus.jackson.annotate.JsonAutoDetect;
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/SettingsActivity.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/SettingsActivity.java
index 4fdea71..fa1c422 100644
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/SettingsActivity.java
+++ b/adguard_cb/src/main/java/com/adguard/android/contentblocker/SettingsActivity.java
@@ -1,18 +1,18 @@
 /**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
+ * This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
+ * Copyright © 2016 Performix LLC. All rights reserved.
+ * <p>
+ * Adguard Content Blocker is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 3 of the License, or (at your option)
+ * any later version.
+ * <p>
+ * Adguard Content Blocker is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * <p>
+ * You should have received a copy of the GNU General Public License along with
+ * Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
  */
 package com.adguard.android.contentblocker;
 
@@ -20,42 +20,86 @@ import android.content.Intent;
 import android.os.Bundle;
 import android.support.v7.app.ActionBar;
 import android.support.v7.app.AppCompatActivity;
+import android.support.v7.widget.Toolbar;
 import android.view.MenuItem;
 import android.view.View;
-import android.widget.ListView;
-
-import com.adguard.android.contentblocker.preferences.*;
-import com.adguard.android.contentblocker.preferences.PreferenceViewAdapter;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
 
-public class SettingsActivity extends AppCompatActivity implements View.OnClickListener {
+import com.adguard.android.ServiceLocator;
+import com.adguard.android.service.FilterService;
+import com.adguard.android.service.PreferencesService;
 
-    private ListView listView;
-    private PreferenceViewAdapter adapter;
+public class SettingsActivity extends AppCompatActivity {
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_settings);
-        listView = (ListView) findViewById(R.id.listView);
 
-        adapter = new PreferenceViewAdapter(this, new PreferenceDb(getApplicationContext()), this);
-        listView.setAdapter(adapter);
-
-        setupActionBar();
-    }
-
-    public void onResume() {
-        super.onResume();
-        adapter = new PreferenceViewAdapter(this, new PreferenceDb(getApplicationContext()), this);
-        listView.setAdapter(adapter);
-    }
-
-   private void setupActionBar() {
         ActionBar actionBar = getSupportActionBar();
         if (actionBar != null) {
             // Show the Up button in the action bar.
             actionBar.setDisplayHomeAsUpEnabled(true);
         }
+
+        final PreferencesService preferencesService = ServiceLocator.getInstance(getApplicationContext()).getPreferencesService();
+        final FilterService filterService = ServiceLocator.getInstance(getApplicationContext()).getFilterService();
+
+        final CheckBox autoUpdateView = (CheckBox) findViewById(R.id.auto_update_checkbox);
+        autoUpdateView.setChecked(preferencesService.isAutoUpdateFilters());
+        autoUpdateView.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton compoundButton, boolean enable) {
+                preferencesService.setAutoUpdateFilters(enable);
+            }
+        });
+
+        findViewById(R.id.auto_update_wrapper).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                autoUpdateView.setChecked(!autoUpdateView.isChecked());
+            }
+        });
+
+        final CheckBox updateWifiOnlyView = (CheckBox) findViewById(R.id.update_wifi_only_checkbox);
+        updateWifiOnlyView.setChecked(preferencesService.isUpdateOverWifiOnly());
+        updateWifiOnlyView.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton compoundButton, boolean enable) {
+                preferencesService.setUpdateOverWifiOnly(enable);
+            }
+        });
+
+        findViewById(R.id.update_wifi_only_wrapper).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                updateWifiOnlyView.setChecked(!updateWifiOnlyView.isChecked());
+            }
+        });
+
+        final CheckBox showUsefulAdsView = (CheckBox) findViewById(R.id.show_useful_ads_checkbox);
+        showUsefulAdsView.setChecked(filterService.isShowUsefulAds());
+        showUsefulAdsView.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton compoundButton, boolean enable) {
+                filterService.setShowUsefulAds(enable);
+            }
+        });
+
+        findViewById(R.id.show_useful_ads_wrapper).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                showUsefulAdsView.setChecked(!showUsefulAdsView.isChecked());
+            }
+        });
+
+        findViewById(R.id.filter_list_wrapper).setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                startActivity(new Intent(getApplicationContext(), FiltersActivity.class));
+            }
+        });
     }
 
     @Override
@@ -67,15 +111,4 @@ public class SettingsActivity extends AppCompatActivity implements View.OnClickL
             return super.onOptionsItemSelected(item);
         }
     }
-
-    @Override
-    public void onClick(View v) {
-        Object tag = v.getTag();
-        if (tag != null && tag instanceof String) {
-            String tagString = (String) tag;
-            if (tagString.equals(PreferenceDb.PREF_FILTERS)) {
-                startActivity(new Intent(this, FiltersActivity.class));
-            }
-        }
-    }
 }
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/onboarding/OnboardingActivity.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/onboarding/OnboardingActivity.java
index 6c1c953..6831fdd 100644
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/onboarding/OnboardingActivity.java
+++ b/adguard_cb/src/main/java/com/adguard/android/contentblocker/onboarding/OnboardingActivity.java
@@ -29,7 +29,7 @@ import com.adguard.android.commons.BrowserUtils;
 import com.adguard.android.contentblocker.R;
 import com.adguard.android.contentblocker.ui.ClickViewPager;
 import com.adguard.android.service.PreferencesService;
-import com.adguard.commons.concurrent.ExecutorsPool;
+import com.adguard.android.commons.concurrent.ExecutorsPool;
 import org.apache.commons.collections4.CollectionUtils;
 
 import java.util.List;
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceDb.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceDb.java
deleted file mode 100644
index bc682d0..0000000
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceDb.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.android.contentblocker.preferences;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
-
-import com.adguard.android.contentblocker.R;
-
-import org.apache.commons.lang3.StringUtils;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-
-/**
- *
- */
-public class PreferenceDb {
-    public static final String PREF_AUTO_UPDATE = "pref_auto_update";
-    public static final String PREF_UPDATE_WIFI_ONLY = "pref_update_wifi_only";
-    public static final String PREF_SHOW_USEFUL_ADS = "pref_show_useful_ads";
-    public static final String PREF_FILTERS = "pref_filters";
-    private HashMap<String, PreferenceItem> itemsMap = new HashMap<>();
-    private List<PreferenceItem> itemsList = new ArrayList<>();
-    private Context context;
-
-    public PreferenceDb(Context context) {
-        this.context = context;
-
-        // Adding items to our pref-base
-        addPreference(PREF_AUTO_UPDATE, R.string.pref_autoupdate_filters, R.string.pref_summary_autoupdate_filters, true);
-        addPreference(PREF_UPDATE_WIFI_ONLY, R.string.pref_update_wifi_only, R.string.pref_summary_update_wifi_only, false);
-        addPreference(PREF_SHOW_USEFUL_ADS, R.string.pref_show_useful_ads, R.string.pref_summary_show_useful_ads, true);
-        addPreference(PREF_FILTERS, R.string.pref_filters_category, R.string.pref_summary_filters_category, null);
-        // And refreshing their values from preferences
-        refreshItems();
-    }
-
-    public void addPreference(String name, String title, String summary, Object value) {
-        PreferenceItem item = new PreferenceItem(name, title, summary, value);
-        itemsList.add(item);
-        itemsMap.put(name, item);
-    }
-
-    public void addPreference(String name, int titleResId, int summaryResId, Object value) {
-        addPreference(name, context.getString(titleResId), context.getString(summaryResId), value);
-    }
-
-    public void setPreference(String name, Object value) {
-        PreferenceItem item = itemsMap.get(name);
-        if (item == null) {
-            throw new IllegalArgumentException("Error setting preference " + name + "! No such preference!");
-        }
-
-        item.value = value;
-        SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit();
-        if (item.value instanceof Boolean) {
-            editor.putBoolean(name, (Boolean) value);
-        } else if (item.value instanceof Integer) {
-            editor.putInt(name, (Integer) item.value);
-        }
-        // TODO other variants
-        editor.commit();
-    }
-
-    private void refreshItems() {
-        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
-        for (PreferenceItem item : itemsList) {
-            if (item.value instanceof Boolean) {
-                item.value = prefs.getBoolean(item.name, (Boolean) item.value);
-            } else if (item.value instanceof Integer) {
-                item.value = prefs.getInt(item.name, (Integer) item.value);
-            } else if (item.value instanceof String) {
-                item.value = prefs.getString(item.name, (String) item.value);
-            } else if (item.value instanceof String[]) {
-                item.value = StringUtils.split(prefs.getString(item.name, (String) item.value), System.lineSeparator());
-            }
-        }
-    }
-
-    public PreferenceItem getPreference(int index) {
-        return itemsList.get(index);
-    }
-
-    public PreferenceItem getPreference(String name) {
-        return itemsMap.get(name);
-    }
-
-    public int size() {
-        return itemsList.size();
-    }
-
-    public int getPreferenceLayoutId(String name) {
-        int type = getPreferenceTypeId(name);
-
-        switch (type) {
-            case 0:
-                return R.layout.preference_item_checkbox;
-            case 1:
-                return R.layout.preference_item_number;
-            case 2:
-                return R.layout.preference_item_text;
-            case 3:
-                return R.layout.preference_item_stringlist;
-            default:
-                return R.layout.preference_item_subgroup;
-        }
-    }
-
-    public int getPreferenceTypeId(String name) {
-        PreferenceItem item = itemsMap.get(name);
-        if (item == null) {
-            throw new IllegalArgumentException("Error getting preference " + name + "! No such preference!");
-        }
-
-        return getPreferenceTypeId(item);
-    }
-
-    public int getPreferenceTypeId(int index) {
-        PreferenceItem item = itemsList.get(index);
-        if (item == null) {
-            throw new IllegalArgumentException("Error getting preference " + index + "! No such preference!");
-        }
-
-        return getPreferenceTypeId(item);
-    }
-
-    public int getPreferenceTypeCount() {
-        return 5;
-    }
-
-    private static int getPreferenceTypeId(PreferenceItem item) {
-        if (item.value == null) {
-            return -1;
-        } else if (item.value instanceof Boolean) {
-            return 0;
-        } else if (item.value instanceof Integer) {
-            return 1;
-        } else if (item.value instanceof String) {
-            return 2;
-        } else if (item.value instanceof String[]) {
-            return 3;
-        }
-        return -1;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceItem.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceItem.java
deleted file mode 100644
index 464f0e3..0000000
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceItem.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.android.contentblocker.preferences;
-
-/**
- *
- */
-public class PreferenceItem {
-    public String name;
-    public String title;
-    public String summary;
-    public Object value;
-
-    public PreferenceItem(String name, String title, String summary, Object value) {
-        this.name = name;
-        this.title = title;
-        this.summary = summary;
-        this.value = value;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceViewAdapter.java b/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceViewAdapter.java
deleted file mode 100644
index f8fae26..0000000
--- a/adguard_cb/src/main/java/com/adguard/android/contentblocker/preferences/PreferenceViewAdapter.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.android.contentblocker.preferences;
-
-import android.app.Activity;
-import android.content.Context;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.BaseAdapter;
-import android.widget.CheckBox;
-import android.widget.TextView;
-
-import com.adguard.android.ServiceLocator;
-import com.adguard.android.contentblocker.ApplyAndRefreshTask;
-import com.adguard.android.contentblocker.R;
-import com.adguard.android.service.FilterService;
-
-/**
- *
- */
-public class PreferenceViewAdapter extends BaseAdapter {
-
-    private final PreferenceDb prefs;
-    private final View.OnClickListener listener;
-    private final Context context;
-    private final LayoutInflater layoutInflater;
-
-    private final View.OnClickListener booleanPrefListener = new View.OnClickListener() {
-        @Override
-        public void onClick(View v) {
-            onBooleanClicked(v);
-        }
-    };
-
-    public PreferenceViewAdapter(Context context, PreferenceDb prefs, View.OnClickListener listener) {
-        this.context = context;
-        this.prefs = prefs;
-        this.listener = listener;
-        this.layoutInflater = LayoutInflater.from(context);
-    }
-
-    @Override
-    public int getCount() {
-        return prefs.size();
-    }
-
-    @Override
-    public Object getItem(int position) {
-        return prefs.getPreference(position);
-    }
-
-    @Override
-    public long getItemId(int position) {
-        return position;
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-        return createViewFromResource(layoutInflater, position, convertView, parent);
-    }
-
-    private View createViewFromResource(LayoutInflater inflater, int position, View convertView, ViewGroup parent) {
-        PreferenceItem item = prefs.getPreference(position);
-        View view;
-        if (convertView == null) {
-            view = inflater.inflate(prefs.getPreferenceLayoutId(item.name), parent, false);
-        } else {
-            view = convertView;
-        }
-
-        ((TextView)view.findViewById(R.id.title)).setText(item.title);
-        ((TextView)view.findViewById(R.id.summary)).setText(item.summary);
-        if (item.value instanceof Boolean) {
-            ((CheckBox)view.findViewById(R.id.checkbox)).setChecked((Boolean) item.value);
-            view.setOnClickListener(booleanPrefListener);
-        } else if (item.value == null) {
-            // Let the activity handle this click
-            view.setOnClickListener(listener);
-        }
-
-        view.setTag(item.name);
-
-        return view;
-    }
-
-    @Override
-    public int getItemViewType(int position) {
-        return prefs.getPreferenceTypeId(position);
-    }
-
-    @Override
-    public int getViewTypeCount() {
-        return prefs.getPreferenceTypeCount();
-    }
-
-    private void onBooleanClicked(View view) {
-        String name = (String) view.getTag();
-        PreferenceItem item = prefs.getPreference(name);
-        prefs.setPreference(name, !((Boolean)item.value));
-        ((CheckBox)view.findViewById(R.id.checkbox)).setChecked((Boolean) item.value);
-        if (name.equals(PreferenceDb.PREF_SHOW_USEFUL_ADS)) {
-            FilterService filterService = ServiceLocator.getInstance(context).getFilterService();
-            filterService.setShowUsefulAds(!((Boolean)item.value));
-            new ApplyAndRefreshTask(filterService, (Activity) context).execute();
-        }
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/android/db/FilterRuleDaoImpl.java b/adguard_cb/src/main/java/com/adguard/android/db/FilterRuleDaoImpl.java
index 3cb1ca9..d53a8e2 100644
--- a/adguard_cb/src/main/java/com/adguard/android/db/FilterRuleDaoImpl.java
+++ b/adguard_cb/src/main/java/com/adguard/android/db/FilterRuleDaoImpl.java
@@ -17,10 +17,10 @@
 package com.adguard.android.db;
 
 import android.content.Context;
-import com.adguard.filter.rules.FilterRule;
 import org.apache.commons.collections4.list.SetUniqueList;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -39,6 +39,13 @@ public class FilterRuleDaoImpl implements FilterRuleDao {
     private final Logger log = LoggerFactory.getLogger(FilterRuleDaoImpl.class);
     private final Context context;
 
+    private static final String MASK_CSS_RULE = "##";
+    private static final String MASK_CSS_EXCEPTION_RULE = "#@#";
+    private static final String MASK_CSS_INJECT_RULE = "#$#";
+    private static final String MASK_CSS_INJECT_EXCEPTION_RULE = "#@$#";
+    private static final String MASK_SCRIPT_RULE = "#%#";
+    private static final String MASK_CONTENT_RULE = "$$";
+
     /**
      * Creates an instance of the filter rules internal storage
      *
@@ -109,7 +116,7 @@ public class FilterRuleDaoImpl implements FilterRuleDao {
 
             String line = reader.readLine();
             while (line != null) {
-                if (useCosmetics || !FilterRule.isCosmeticRule(line)) {
+                if (useCosmetics || !isCosmeticRule(line)) {
                     rules.add(line);
                 }
                 line = reader.readLine();
@@ -126,6 +133,22 @@ public class FilterRuleDaoImpl implements FilterRuleDao {
         }
     }
 
+    /**
+     * Returns true if rule is CSS, JS or Content
+     *
+     * @param ruleText Rule text
+     * @return true if rule is CSS, JS or Content
+     */
+    private static boolean isCosmeticRule(String ruleText) {
+        return StringUtils.isEmpty(ruleText) ||
+                ruleText.contains(MASK_CSS_RULE) ||
+                ruleText.contains(MASK_CSS_EXCEPTION_RULE) ||
+                ruleText.contains(MASK_CSS_INJECT_RULE) ||
+                ruleText.contains(MASK_CSS_INJECT_EXCEPTION_RULE) ||
+                ruleText.contains(MASK_SCRIPT_RULE) ||
+                ruleText.contains(MASK_CONTENT_RULE);
+    }
+
     /**
      * Initializes file with default filter rules
      *
diff --git a/adguard_cb/src/main/java/com/adguard/android/filtering/api/HttpServiceClient.java b/adguard_cb/src/main/java/com/adguard/android/filtering/api/HttpServiceClient.java
index 97c9de2..6296b46 100644
--- a/adguard_cb/src/main/java/com/adguard/android/filtering/api/HttpServiceClient.java
+++ b/adguard_cb/src/main/java/com/adguard/android/filtering/api/HttpServiceClient.java
@@ -16,7 +16,7 @@
  */
 package com.adguard.android.filtering.api;
 
-import com.adguard.commons.web.UrlUtils;
+import com.adguard.android.commons.web.UrlUtils;
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/adguard_cb/src/main/java/com/adguard/android/model/FilterList.java b/adguard_cb/src/main/java/com/adguard/android/model/FilterList.java
index def43d9..860e763 100644
--- a/adguard_cb/src/main/java/com/adguard/android/model/FilterList.java
+++ b/adguard_cb/src/main/java/com/adguard/android/model/FilterList.java
@@ -16,7 +16,7 @@
  */
 package com.adguard.android.model;
 
-import com.adguard.commons.utils.ProductVersion;
+import com.adguard.android.commons.ProductVersion;
 
 import java.util.Date;
 
diff --git a/adguard_cb/src/main/java/com/adguard/android/service/FilterService.java b/adguard_cb/src/main/java/com/adguard/android/service/FilterService.java
index d70ccfd..d27c744 100644
--- a/adguard_cb/src/main/java/com/adguard/android/service/FilterService.java
+++ b/adguard_cb/src/main/java/com/adguard/android/service/FilterService.java
@@ -39,8 +39,14 @@ public interface FilterService {
      */
     int getFilterListCount();
 
+    /**
+     * @return Enabled filter count
+     */
     int getEnabledFilterListCount();
 
+    /**
+     * @return Filter rules count
+     */
     int getFilterRuleCount();
 
     /**
@@ -63,52 +69,6 @@ public interface FilterService {
      */
     void updateFilterEnabled(FilterList filter, boolean enabled);
 
-    /**
-     * @return Whitelist
-     */
-    Set<String> getWhiteList();
-
-    /**
-     * @param item Adds item to whitelist
-     */
-    void addToWhitelist(String item);
-
-    /**
-     * Clears whitelist
-     */
-    void clearWhiteList();
-
-    /**
-     * Removes item from the whitelist
-     *
-     * @param item Item to remove
-     */
-    void removeWhiteListItem(String item);
-
-    /**
-     * @return User filter rules
-     */
-    Set<String> getUserRules();
-
-    /**
-     * Adds rule to the user filter
-     *
-     * @param item Item to add
-     */
-    void addUserRuleItem(String item);
-
-    /**
-     * Removes rule from the user filter
-     *
-     * @param item Item to remove
-     */
-    void removeUserRuleItem(String item);
-
-    /**
-     * Clears user filter
-     */
-    void clearUserRules();
-
 	/**
 	 * Downloads and adds batch of user rules from specified url.
 	 *
@@ -140,26 +100,6 @@ public interface FilterService {
      */
     List<Integer> getEnabledFilterIds();
 
-	/**
-	 * Is social media widgets filter enabled
-	 */
-	boolean isSocialMediaWidgetsFilterEnabled();
-
-	/**
-	 * Sets social media widgets filter enabled
-	 */
-	void setSocialMediaWidgetsFilterEnabled(boolean value);
-
-	/**
-	 * Sets spyware filter enabled
-	 */
-	void setSpywareFilterEnabled(boolean value);
-
-	/**
-	 * Is spyware filter enabled
-	 */
-	boolean isSpywareFilterEnabled();
-
     /**
      * Applies new settings and filters
      */
diff --git a/adguard_cb/src/main/java/com/adguard/android/service/FilterServiceImpl.java b/adguard_cb/src/main/java/com/adguard/android/service/FilterServiceImpl.java
index a550455..78e1b13 100644
--- a/adguard_cb/src/main/java/com/adguard/android/service/FilterServiceImpl.java
+++ b/adguard_cb/src/main/java/com/adguard/android/service/FilterServiceImpl.java
@@ -34,11 +34,11 @@ import com.adguard.android.db.FilterRuleDao;
 import com.adguard.android.db.FilterRuleDaoImpl;
 import com.adguard.android.contentblocker.ServiceApiClient;
 import com.adguard.android.model.FilterList;
-import com.adguard.commons.NetworkUtils;
-import com.adguard.commons.concurrent.DispatcherThreadPool;
-import com.adguard.commons.io.IoUtils;
-import com.adguard.commons.InternetUtils;
-import com.adguard.commons.web.UrlUtils;
+import com.adguard.android.commons.network.NetworkUtils;
+import com.adguard.android.commons.concurrent.DispatcherThreadPool;
+import com.adguard.android.commons.io.IoUtils;
+import com.adguard.android.commons.network.InternetUtils;
+import com.adguard.android.commons.web.UrlUtils;
 
 import org.apache.commons.collections4.CollectionUtils;
 import org.apache.commons.io.FileUtils;
@@ -51,9 +51,7 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.URL;
 import java.util.*;
-import java.util.regex.Pattern;
 
 /**
  * Filter service implementation.
@@ -165,45 +163,6 @@ public class FilterServiceImpl extends BaseUiService implements FilterService {
         filterListDao.updateFilterEnabled(filter, enabled);
     }
 
-    @Override
-    public Set<String> getWhiteList() {
-        return preferencesService.getWhiteList();
-    }
-
-    @Override
-    public void addToWhitelist(String item) {
-        preferencesService.addToWhitelist(item);
-    }
-
-    @Override
-    public void clearWhiteList() {
-        preferencesService.clearWhiteList();
-    }
-
-    @Override
-    public void removeWhiteListItem(String item) {
-        preferencesService.removeWhiteListItem(item);
-    }
-
-    @Override
-    public Set<String> getUserRules() {
-        return preferencesService.getUserRules();
-    }
-
-    @Override
-    public void addUserRuleItem(String item) {
-        preferencesService.addUserRuleItem(item);
-    }
-
-    @Override
-    public void removeUserRuleItem(String item) {
-        preferencesService.removeUserRuleItem(item);
-    }
-
-    @Override
-    public void clearUserRules() {
-        preferencesService.clearUserRules();
-    }
 
     @Override
     public void importUserRulesFromUrl(Activity activity, String url) {
@@ -243,32 +202,12 @@ public class FilterServiceImpl extends BaseUiService implements FilterService {
         }
     }
 
-    @Override
-    public boolean isSocialMediaWidgetsFilterEnabled() {
-        final FilterList filter = filterListDao.selectFilterList(SOCIAL_MEDIA_WIDGETS_FILTER_ID);
-        return filter != null && filter.isEnabled();
-    }
-
-    @Override
-    public void setSocialMediaWidgetsFilterEnabled(boolean value) {
-        final FilterList filter = filterListDao.selectFilterList(SOCIAL_MEDIA_WIDGETS_FILTER_ID);
-        if (filter != null) {
-            updateFilterEnabled(filter, value);
-        }
-    }
-
-    @Override
-    public boolean isSpywareFilterEnabled() {
-        final FilterList filter = filterListDao.selectFilterList(SPYWARE_FILTER_ID);
-        return filter != null && filter.isEnabled();
-    }
-
     @Override
     public void applyNewSettings() {
         setShowUsefulAds(preferencesService.isShowUsefulAds());
 
         List<String> rules = getAllEnabledRules(true);
-        Set<String> userRules = getUserRules();
+        Set<String> userRules = preferencesService.getUserRules();
         if (!userRules.isEmpty()) {
             for (String userRule : userRules) {
                 userRule = StringUtils.trim(userRule);
@@ -291,14 +230,6 @@ public class FilterServiceImpl extends BaseUiService implements FilterService {
         }
     }
 
-    @Override
-    public void setSpywareFilterEnabled(boolean value) {
-        final FilterList filter = filterListDao.selectFilterList(SPYWARE_FILTER_ID);
-        if (filter != null) {
-            updateFilterEnabled(filter, value);
-        }
-    }
-
     /**
      * Checks the rules of non ascii symbols and control symbols
      *
diff --git a/adguard_cb/src/main/java/com/adguard/android/service/JobService.java b/adguard_cb/src/main/java/com/adguard/android/service/JobService.java
deleted file mode 100644
index edc4d87..0000000
--- a/adguard_cb/src/main/java/com/adguard/android/service/JobService.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.android.service;
-
-import java.util.concurrent.TimeUnit;
-
-/**
- * Service that manages periodical tasks
- */
-public interface JobService {
-
-    /**
-     * Schedules new job to be executed periodically
-     *
-     * @param jobName      Job name
-     * @param command      Command to execute
-     * @param initialDelay The time from now to delay execution
-     * @param period       The time unit of the delay parameter
-     * @param timeUnit     Time unit for initial delay and period
-     */
-    void scheduleAtFixedRate(String jobName, Runnable command, long initialDelay, long period, TimeUnit timeUnit);
-
-}
diff --git a/adguard_cb/src/main/java/com/adguard/android/service/JobServiceImpl.java b/adguard_cb/src/main/java/com/adguard/android/service/JobServiceImpl.java
deleted file mode 100644
index 5c261d3..0000000
--- a/adguard_cb/src/main/java/com/adguard/android/service/JobServiceImpl.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.android.service;
-
-import com.adguard.commons.concurrent.ExecutorsPool;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.util.concurrent.TimeUnit;
-
-/**
- * Job service implementation using ScheduledExecutorService
- */
-public class JobServiceImpl implements JobService {
-
-    private final Logger LOG = LoggerFactory.getLogger(JobServiceImpl.class);
-
-    /**
-     * Creates an instance of JobService
-     */
-    public JobServiceImpl() {
-        LOG.info("Initializing JobService");
-    }
-
-    @Override
-    public void scheduleAtFixedRate(String jobName, Runnable command, long initialDelay, long period, TimeUnit timeUnit) {
-        LOG.debug("Schedule job {} with delay={} and period={} ({})", jobName, initialDelay, period, timeUnit);
-        Job job = new Job(jobName, command);
-        ExecutorsPool.getSingleThreadScheduledExecutorService().scheduleAtFixedRate(job, initialDelay, period, timeUnit);
-    }
-
-	private static class Job implements Runnable {
-
-        private final Logger LOG = LoggerFactory.getLogger(JobServiceImpl.class);
-        private final String jobName;
-        private final Runnable command;
-
-        /**
-         * Creates job instance
-         *
-         * @param jobName Job name
-         * @param command Job command
-         */
-        public Job(String jobName, Runnable command) {
-            this.jobName = jobName;
-            this.command = command;
-        }
-
-        @Override
-        public void run() {
-            LOG.info("Start executing job {}", jobName);
-
-            try {
-                command.run();
-                LOG.info("Finished executing job {}", jobName);
-            } catch (Exception ex) {
-                LOG.error("Error while executing job {}:\r\n{}", jobName, ex);
-            }
-        }
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/android/service/LongRunningTask.java b/adguard_cb/src/main/java/com/adguard/android/service/LongRunningTask.java
index c19267d..c7b3236 100644
--- a/adguard_cb/src/main/java/com/adguard/android/service/LongRunningTask.java
+++ b/adguard_cb/src/main/java/com/adguard/android/service/LongRunningTask.java
@@ -20,7 +20,7 @@ import android.app.ProgressDialog;
 
 import com.adguard.android.contentblocker.R;
 import com.adguard.android.ui.utils.ProgressDialogUtils;
-import com.adguard.commons.concurrent.DispatcherTask;
+import com.adguard.android.commons.concurrent.DispatcherTask;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/adguard_cb/src/main/java/com/adguard/android/service/PreferencesService.java b/adguard_cb/src/main/java/com/adguard/android/service/PreferencesService.java
index 4211801..d7cbb5e 100644
--- a/adguard_cb/src/main/java/com/adguard/android/service/PreferencesService.java
+++ b/adguard_cb/src/main/java/com/adguard/android/service/PreferencesService.java
@@ -16,7 +16,6 @@
  */
 package com.adguard.android.service;
 
-import com.adguard.commons.enums.FilteringQuality;
 
 import java.util.Collection;
 import java.util.Date;
@@ -42,6 +41,11 @@ public interface PreferencesService {
      */
     boolean isUpdateOverWifiOnly();
 
+    /**
+     * @param value true if update over wifi only is enabled
+     */
+    void setUpdateOverWifiOnly(boolean value);
+
     /**
      * @return True if we have shown the onboarding screen
      */
@@ -118,21 +122,6 @@ public interface PreferencesService {
      */
     Date getLastUpdateCheck();
 
-    /**
-     * @param referrerString Referrer value (got from INSTALL_REFERRER receiver)
-     */
-    void setReferrer(String referrerString);
-
-    /**
-     * @return Referrer value (got from INSTALL_REFERRER receiver)
-     */
-    String getReferrer();
-
-    /**
-     * @return Device speed rank
-     */
-    int getDeviceSpeedRank();
-
     /**
      * Gets url from which user imported his rules
      *
@@ -156,15 +145,35 @@ public interface PreferencesService {
      */
     boolean isShowUsefulAds();
 
+    /**
+     * Sets filter rules count
+     * @param ruleCount Filter rules count
+     */
     void setFilterRuleCount(int ruleCount);
 
+    /**
+     * @return Filter rules count
+     */
     int getFilterRuleCount();
 
+    /**
+     * Increments browser connected count
+     */
     void incBrowserConnectedCount();
 
+    /**
+     * @return Browser connected count
+     */
     int getBrowserConnectedCount();
 
-    boolean isShowAboutOtherProduct();
+    /**
+     * @return @return True if we have shown the welcome message
+     */
+    boolean isWelcomeMessage();
 
-    void setShowAboutOtherProduct(boolean value);
+    /**
+     * Save the flag determining that we have shown welcome message
+     * @param value True if shown
+     */
+    void setWelcomeMessage(boolean value);
 }
diff --git a/adguard_cb/src/main/java/com/adguard/android/service/PreferencesServiceImpl.java b/adguard_cb/src/main/java/com/adguard/android/service/PreferencesServiceImpl.java
index bed62e0..97a9f6f 100644
--- a/adguard_cb/src/main/java/com/adguard/android/service/PreferencesServiceImpl.java
+++ b/adguard_cb/src/main/java/com/adguard/android/service/PreferencesServiceImpl.java
@@ -21,9 +21,6 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.preference.PreferenceManager;
 
-import com.adguard.android.contentblocker.preferences.PreferenceDb;
-import com.adguard.filter.WorkaroundUtils;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -41,13 +38,12 @@ public class PreferencesServiceImpl implements PreferencesService {
 
     private final static Logger LOG = LoggerFactory.getLogger(PreferencesServiceImpl.class);
 
+    private static final String PREF_SHOW_USEFUL_ADS = "pref_show_useful_ads";
     private final static String KEY_AUTOUPDATE_FILTERS = "auto_update_filters";
     private final static String KEY_UPDATE_OVER_WIFI = "update_over_wifi";
     private final static String KEY_LAST_UPDATE_CHECK_DATE = "last_update_check_date";
-    private final static String KEY_REFERRER = "referrer";
     private final static String KEY_WHITELIST = "whitelist";
     private final static String KEY_USER_RULES = "user_rules";
-    private final static String KEY_DEVICE_SPEED_RANK = "device_speed_rank";
     private final static String KEY_LAST_IMPORT_URL = "key_last_import_rule";
     private final static String KEY_FILTER_RULE_COUNT = "key_filter_rule_count";
     private final static String KEY_BROWSER_CONNECTED_COUNT = "key_browser_connected_count";
@@ -55,7 +51,6 @@ public class PreferencesServiceImpl implements PreferencesService {
     private final static String KEY_ABOUT_OTHER_PRODUCT_SHOWN = "key_about_other_product_shown";
 
     private final SharedPreferences sharedPreferences;
-    private final Context context;
 
     /**
      * Creates an instance of PreferencesService
@@ -65,7 +60,6 @@ public class PreferencesServiceImpl implements PreferencesService {
     public PreferencesServiceImpl(Context context) {
         LOG.info("Creating PreferencesService instance for {}", context);
         this.sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
-        this.context = context;
     }
 
     /**
@@ -88,6 +82,13 @@ public class PreferencesServiceImpl implements PreferencesService {
         return sharedPreferences.getBoolean(KEY_UPDATE_OVER_WIFI, false);
     }
 
+    @Override
+    public void setUpdateOverWifiOnly(boolean value) {
+        SharedPreferences.Editor editor = sharedPreferences.edit();
+        editor.putBoolean(KEY_UPDATE_OVER_WIFI, value);
+        editor.apply();
+    }
+
     @Override
     public boolean isOnboardingShown() {
         return sharedPreferences.getBoolean(KEY_ONBOARDING_SHOWN, false);
@@ -223,31 +224,6 @@ public class PreferencesServiceImpl implements PreferencesService {
         return time > 0 ? new Date(time) : null;
     }
 
-    @Override
-    public void setReferrer(String referrerString) {
-        SharedPreferences.Editor editor = sharedPreferences.edit();
-        editor.putString(KEY_REFERRER, referrerString);
-        editor.apply();
-    }
-
-    @Override
-    public String getReferrer() {
-        return sharedPreferences.getString(KEY_REFERRER, null);
-    }
-
-    @Override
-    public int getDeviceSpeedRank() {
-        if (!sharedPreferences.contains(KEY_DEVICE_SPEED_RANK)) {
-            int deviceSpeedRank = WorkaroundUtils.calculateDeviceSpeedRank(context);
-
-            SharedPreferences.Editor editor = sharedPreferences.edit();
-            editor.putInt(KEY_DEVICE_SPEED_RANK, deviceSpeedRank);
-            editor.apply();
-        }
-
-        return sharedPreferences.getInt(KEY_DEVICE_SPEED_RANK, 400);
-    }
-
     @Override
     public String getLastImportUrl() {
         return sharedPreferences.getString(KEY_LAST_IMPORT_URL, null);
@@ -263,13 +239,13 @@ public class PreferencesServiceImpl implements PreferencesService {
     @Override
     public void setShowUsefulAds(boolean value) {
         SharedPreferences.Editor editor = sharedPreferences.edit();
-        editor.putBoolean(PreferenceDb.PREF_SHOW_USEFUL_ADS, value);
+        editor.putBoolean(PREF_SHOW_USEFUL_ADS, value);
         editor.apply();
     }
 
     @Override
     public boolean isShowUsefulAds() {
-        return sharedPreferences.getBoolean(PreferenceDb.PREF_SHOW_USEFUL_ADS, true);
+        return sharedPreferences.getBoolean(PREF_SHOW_USEFUL_ADS, true);
     }
 
     @Override
@@ -295,12 +271,12 @@ public class PreferencesServiceImpl implements PreferencesService {
     }
 
     @Override
-    public boolean isShowAboutOtherProduct() {
+    public boolean isWelcomeMessage() {
         return sharedPreferences.getBoolean(KEY_ABOUT_OTHER_PRODUCT_SHOWN, false);
     }
 
     @Override
-    public void setShowAboutOtherProduct(boolean value) {
+    public void setWelcomeMessage(boolean value) {
         SharedPreferences.Editor editor = sharedPreferences.edit();
         editor.putBoolean(KEY_ABOUT_OTHER_PRODUCT_SHOWN, value);
         editor.apply();
diff --git a/adguard_cb/src/main/java/com/adguard/android/ui/utils/ActivityUtils.java b/adguard_cb/src/main/java/com/adguard/android/ui/utils/ActivityUtils.java
index 9d66d3a..8ceb7ef 100644
--- a/adguard_cb/src/main/java/com/adguard/android/ui/utils/ActivityUtils.java
+++ b/adguard_cb/src/main/java/com/adguard/android/ui/utils/ActivityUtils.java
@@ -107,12 +107,6 @@ public class ActivityUtils {
         return Math.min(point.x, point.y);
     }
 
-    public static void setPortraitOnly(Activity activity) {
-        if (activity.getResources().getBoolean(R.bool.portraitOnly) || getSmallestScreenSize(activity) <= 320) {
-            activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
-        }
-    }
-
     public static void startMarket(Context context, String packageName, String referrer)
     {
         String referrerParam = referrer != null ? "&referrer=" + referrer : "";
diff --git a/adguard_cb/src/main/java/com/adguard/commons/collections/Lists.java b/adguard_cb/src/main/java/com/adguard/commons/collections/Lists.java
deleted file mode 100644
index e5ffda6..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/collections/Lists.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.collections;
-
-import com.adguard.commons.collections.predicates.Predicate;
-import org.apache.commons.collections4.CollectionUtils;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * List utils
- */
-public class Lists {
-
-    /**
-     * Safe method to remove an element from collection.
-     * If either collection is empty or element is null - returns false.
-     *
-     * @param collection Collection
-     * @param element    Element
-     * @param <T>        Any type
-     * @return true if element has been removed
-     */
-    public static <T> boolean remove(Collection<T> collection, T element) {
-
-        if (element == null) {
-            return false;
-        }
-        //noinspection SimplifiableIfStatement
-        if (CollectionUtils.isEmpty(collection)) {
-            return false;
-        }
-
-        return collection.remove(element);
-    }
-
-    /**
-     * Safe method to remove all specified elements
-     * from the collection.
-     *
-     * @param collection Collection
-     * @param elements   Elements to remove
-     * @param <T>        Any type
-     */
-    public static <T> void removeAll(Collection<T> collection, Collection<T> elements) {
-
-        if (CollectionUtils.isEmpty(collection) || CollectionUtils.isEmpty(elements)) {
-            return;
-        }
-
-        for (T element : elements) {
-            collection.remove(element);
-        }
-    }
-
-    /**
-     * Checks if collection contains element for which predicate evaluates to true.s
-     *
-     * @param collection Collection
-     * @param predicate  Predicate to check
-     * @param <T>        Any type
-     * @return true if at least one element exists
-     */
-    public static <T> boolean exists(Collection<T> collection, Predicate<T> predicate) {
-
-        if (CollectionUtils.isEmpty(collection)) {
-            return false;
-        }
-
-        if (predicate == null) {
-            return false;
-        }
-
-        for (T element : collection) {
-            if (predicate.evaluate(element)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * Partitions list into smaller lists of the specified size
-     *
-     * @param input Input collection
-     * @param size  Partition size
-     * @return List of smaller size
-     */
-    public static <E> List<List<E>> split(Collection<E> input, int size) {
-        List<List<E>> master = new ArrayList<>();
-        if (input != null && input.size() > 0) {
-            List<E> col = new ArrayList<>(input);
-            boolean done = false;
-            int startIndex = 0;
-            int endIndex = col.size() > size ? size : col.size();
-            while (!done) {
-                master.add(col.subList(startIndex, endIndex));
-                if (endIndex == col.size()) {
-                    done = true;
-                } else {
-                    startIndex = endIndex;
-                    endIndex = col.size() > (endIndex + size) ? (endIndex + size) : col.size();
-                }
-            }
-        }
-        return master;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/commons/collections/predicates/Predicate.java b/adguard_cb/src/main/java/com/adguard/commons/collections/predicates/Predicate.java
deleted file mode 100644
index 338d8d2..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/collections/predicates/Predicate.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package com.adguard.commons.collections.predicates;
-
-/**
- * Defines a functor interface implemented by classes that perform a predicate
- * test on an object.
- */
-public interface Predicate<T> {
-
-    /**
-     * Use the specified parameter to perform a test that returns true or false.
-     *
-     * @param object the object to evaluate, should not be changed
-     * @return true or false
-     */
-    boolean evaluate(T object);
-}
diff --git a/adguard_cb/src/main/java/com/adguard/commons/enums/FilteringQuality.java b/adguard_cb/src/main/java/com/adguard/commons/enums/FilteringQuality.java
deleted file mode 100644
index 3cda693..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/enums/FilteringQuality.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.enums;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public enum FilteringQuality {
-
-    // No cosmetic filtering rules
-    SIMPLE(0),
-
-    // No high-quality rules
-    SPEEDY(1),
-
-    // Full and high-quality filtering
-    FULL(2);
-
-    private static Map<Integer, FilteringQuality> lookup = new HashMap<>();
-
-    static {
-        for (FilteringQuality s : values()) {
-            lookup.put(s.getCode(), s);
-        }
-    }
-
-    public static FilteringQuality getByCode(int code) {
-        return lookup.get(code);
-    }
-
-    private final int code;
-
-    FilteringQuality(int code) {
-        this.code = code;
-    }
-
-    public int getCode() {
-        return code;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/commons/io/ByteArrayPool.java b/adguard_cb/src/main/java/com/adguard/commons/io/ByteArrayPool.java
deleted file mode 100644
index fa28b7c..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/io/ByteArrayPool.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.io;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.nio.ByteBuffer;
-import java.util.LinkedList;
-
-/**
- * Pool for reusable byte arrays
- */
-public class ByteArrayPool {
-
-    /**
-     * Max size of the byte arrays in the pool.
-     * 512 Kb by default.
-     */
-    private final static int MAX_POOL_SIZE = 1024 * 1024;
-
-    private final Object syncRoot = new Object();
-    private final int arraySize;
-    private final int maxAvailableArraysCount;
-    private final LinkedList<ByteArray> availableByteArrays = new LinkedList<>();
-
-    /**
-     * Creates an instance of the ByteArrayPool
-     *
-     * @param arraySize Size of arrays
-     */
-    public ByteArrayPool(int arraySize) {
-        this(arraySize, MAX_POOL_SIZE);
-    }
-
-    /**
-     * Creates an instance of the ByteArrayPool
-     *
-     * @param arraySize   Byte array size
-     * @param maxPoolSize Max size of the pool in bytes
-     */
-    public ByteArrayPool(int arraySize, int maxPoolSize) {
-        this.arraySize = arraySize;
-        this.maxAvailableArraysCount = maxPoolSize / arraySize;
-    }
-
-    /**
-     * @return Size of arrays allocated by this pool
-     */
-    public int getArraySize() {
-        return arraySize;
-    }
-
-    /**
-     * Gets or creates ByteArray object.
-     *
-     * @return ByteArray object
-     */
-    public ByteArray getByteArray() {
-        synchronized (syncRoot) {
-            if (availableByteArrays.size() > 0) {
-                return availableByteArrays.removeLast();
-            } else {
-                byte[] bytes = new byte[arraySize];
-                return new ByteArray(bytes, this);
-            }
-        }
-    }
-
-    /**
-     * Releases specified byte array
-     *
-     * @param byteArray Byte array
-     */
-    private void release(ByteArray byteArray) {
-        synchronized (syncRoot) {
-            if (availableByteArrays.size() >= maxAvailableArraysCount) {
-                // Ignore released byte array
-                return;
-            }
-
-            if (!availableByteArrays.contains(byteArray)) {
-                availableByteArrays.add(byteArray);
-            }
-        }
-    }
-
-    /**
-     * ByteArray wrapper.
-     */
-    public static class ByteArray {
-
-        private final byte[] bytes;
-        private final ByteArrayPool parentPool;
-        private int contentLength;
-
-        private ByteArray(byte[] bytes, ByteArrayPool parentPool) {
-            this.bytes = bytes;
-            this.parentPool = parentPool;
-        }
-
-        /**
-         * @return Number of bytes left in this array
-         */
-        public int getBytesLeft() {
-            return bytes.length - contentLength;
-        }
-
-        /**
-         * @return Content length. Be aware
-         */
-        public int getContentLength() {
-            return contentLength;
-        }
-
-        /**
-         * @param contentLength Byte array content length
-         */
-        public void setContentLength(int contentLength) {
-            this.contentLength = contentLength;
-        }
-
-        /**
-         * @return Underlying byte array
-         */
-        public byte[] getBytes() {
-            return bytes;
-        }
-
-        /**
-         * Puts content from the specified byte array to this ByteArray
-         *
-         * @param buffer Buffer
-         * @throws IllegalArgumentException in case of buffer.length is bigger than underlying byte array
-         */
-        public void put(byte[] buffer) {
-            put(buffer, 0, buffer.length);
-        }
-
-        /**
-         * Puts content from the specified byte array to this ByteArray
-         *
-         * @param buffer Buffer with data
-         * @param offset Buffer offset
-         * @param count  Count of bytes
-         * @throws IllegalArgumentException in case of buffer.length is bigger than underlying byte array
-         */
-        public void put(byte[] buffer, int offset, int count) {
-            if (count > (bytes.length - this.contentLength)) {
-                throw new IllegalArgumentException("buffer is too large");
-            }
-
-            System.arraycopy(buffer, offset, bytes, this.contentLength, count);
-            this.contentLength += count;
-        }
-
-        /**
-         * Appends content from the specified byteBuffer to this ByteArray
-         *
-         * @param byteBuffer    Source byte buffer
-         * @param contentLength Length of the content to put to
-         * @throws IllegalArgumentException in case of contentLength is bigger than underlying byte array
-         */
-        public void put(ByteBuffer byteBuffer, int contentLength) {
-            if (contentLength > (bytes.length - this.contentLength)) {
-                throw new IllegalArgumentException("contentLength is too large");
-            }
-
-            byteBuffer.get(bytes, this.contentLength, contentLength);
-            this.contentLength += contentLength;
-        }
-
-        /**
-         * Copies content to the destination buffer
-         *
-         * @param srcPos Position to use a source offset
-         * @param buffer Destination array
-         * @param offset Destination array offset
-         * @param count  Number of bytes to copy
-         */
-        public void copyTo(int srcPos, byte[] buffer, int offset, int count) {
-            System.arraycopy(bytes, srcPos, buffer, offset, count);
-        }
-
-        /**
-         * Copies content to the destination buffer
-         *
-         * @param buffer Destination buffer
-         */
-        public void copyTo(byte[] buffer) {
-            copyTo(0, buffer, 0, buffer.length);
-        }
-
-        /**
-         * Copies byte content to output stream
-         *
-         * @param outputStream Output stream
-         */
-        public void copyTo(OutputStream outputStream) throws IOException {
-            outputStream.write(bytes, 0, contentLength);
-        }
-
-        /**
-         * Releases this ByteArray.
-         * After ByteArray is released it is available again at ByteArrayPool
-         */
-        public void release() {
-            this.contentLength = 0;
-            parentPool.release(this);
-        }
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/commons/io/IoUtils.java b/adguard_cb/src/main/java/com/adguard/commons/io/IoUtils.java
deleted file mode 100644
index f8a976b..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/io/IoUtils.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.io;
-
-import com.adguard.commons.utils.CharsetUtils;
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang3.StringUtils;
-
-import java.io.*;
-import java.nio.charset.Charset;
-
-/**
- * Common methods for working with streams
- */
-public class IoUtils {
-
-    public static final int BUFFER_SIZE = 16 * 1024;
-    public static final ByteArrayPool BUFFER_POOL = new ByteArrayPool(BUFFER_SIZE);
-    public static final int CR = 13;
-    public static final int LF = 10;
-    public static final int SP = 32;
-    public static final int EOF = -1;
-
-    /**
-     * Reads input stream to end
-     *
-     * @param inputStream Input stream
-     * @return Bytes being read
-     * @throws IOException
-     */
-    public static byte[] readToEnd(InputStream inputStream) throws IOException {
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        IOUtils.copyLarge(inputStream, outputStream);
-        return outputStream.toByteArray();
-    }
-
-    /**
-     * Copies from input to output stream
-     *
-     * @param inputStream  Input stream
-     * @param outputStream Output stream
-     * @throws IOException
-     */
-    public static void copy(InputStream inputStream, OutputStream outputStream) throws IOException {
-        copy(inputStream, outputStream, BUFFER_SIZE);
-    }
-
-    /**
-     * Copies from input to output stream
-     *
-     * @param inputStream  Input stream
-     * @param outputStream Output stream
-     * @param bufferSize   Buffer size
-     * @throws IOException
-     */
-    public static void copy(InputStream inputStream, OutputStream outputStream, int bufferSize) throws IOException {
-        byte[] buffer;
-        ByteArrayPool.ByteArray array = null;
-        if (bufferSize > BUFFER_SIZE) {
-            buffer = new byte[bufferSize];
-        } else {
-            array = BUFFER_POOL.getByteArray();
-            buffer = array.getBytes();
-        }
-
-        IOUtils.copyLarge(inputStream, outputStream, buffer);
-        outputStream.flush();
-        if (array != null) {
-            array.release();
-        }
-    }
-
-    /**
-     * Checks if this byte is commonly used for BOM
-     * https://en.wikipedia.org/wiki/Byte_order_mark
-     *
-     * @param byteToCheck Byte to check
-     * @return True if this byte is often used for BOM
-     */
-    public static boolean isBomByte(byte byteToCheck) {
-
-        // UTF-8 BOM
-        return (byteToCheck == (byte) 239 || byteToCheck == (byte) 187 || byteToCheck == (byte) 191) ||
-                // UTF-16 BOM
-                (byteToCheck == (byte) 254 || byteToCheck == (byte) 255);
-    }
-
-    /**
-     * Checks if symbol is empty or whitespace
-     *
-     * @param symbol Symbol to check
-     * @return true if CR LF or SP
-     */
-    public static boolean isEmptyOrWhitespace(int symbol) {
-        return symbol == CR || symbol == LF || symbol == SP;
-    }
-
-    /**
-     * Reads line from the inputStream stream (until CRLF symbols)
-     *
-     * @param inputStream Input stream
-     * @return line as byte array
-     */
-    public static byte[] readLineBytes(InputStream inputStream) throws IOException {
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-
-        int byteRead = inputStream.read();
-        while (byteRead != IoUtils.EOF) {
-
-            switch (byteRead) {
-                case 0:
-                    // Ignore zero bytes
-                    // That's very unlikely to get it (and it's not normal)
-                    break;
-                case LF:
-                    return outputStream.toByteArray();
-                default:
-                    outputStream.write(byteRead);
-                    break;
-            }
-
-            byteRead = inputStream.read();
-        }
-
-        byte[] array = outputStream.toByteArray();
-        if (array.length == 0) {
-            throw new IOException("Input stream is closed");
-        }
-
-        return array;
-    }
-
-    /**
-     * Reads line from the input stream
-     *
-     * @param inputStream Input stream
-     * @param encoding    Characters encoding
-     * @return Line read or null if response is empty
-     */
-    public static String readLine(InputStream inputStream, Charset encoding) throws IOException {
-        byte[] lineBytes = readLineBytes(inputStream);
-        if (lineBytes == null || lineBytes.length == 0) {
-            return null;
-        }
-        return StringUtils.trim(new String(lineBytes, encoding));
-    }
-
-    /**
-     * Reads line from the input stream and decodes it to string using default http encoding.
-     *
-     * @param inputStream Input stream
-     * @return Line read or null if response is empty
-     */
-    public static String readLine(InputStream inputStream) throws IOException {
-        return readLine(inputStream, CharsetUtils.DEFAULT_HTTP_ENCODING);
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/commons/lang/Wildcard.java b/adguard_cb/src/main/java/com/adguard/commons/lang/Wildcard.java
deleted file mode 100644
index 0a23d85..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/lang/Wildcard.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.lang;
-
-import org.apache.commons.lang3.StringUtils;
-
-import java.util.regex.Pattern;
-
-/**
- * Represents a wildcard
- */
-public class Wildcard {
-
-    private final int regexpOptions;
-    private final Pattern regexp;
-    private final String shortcut;
-
-    /**
-     * Initializes a wildcard with the given pattern.
-     *
-     * @param pattern Pattern
-     */
-    public Wildcard(String pattern) {
-        this(pattern, Pattern.CASE_INSENSITIVE);
-    }
-
-    /**
-     * Initializes a wildcard with the given search pattern and options.
-     *
-     * @param pattern       Wildcard pattern
-     * @param regexpOptions Regexp options
-     */
-    public Wildcard(String pattern, int regexpOptions) {
-        this.regexpOptions = regexpOptions;
-        regexp = Pattern.compile(wildcardToRegex(pattern), regexpOptions);
-        shortcut = extractShortcut(pattern);
-    }
-
-    /**
-     * Gets wildcard shortcut
-     *
-     * @return Wildcard shortcut
-     */
-    String getShortcut() {
-        return shortcut;
-    }
-
-    /**
-     * Returns "true" if input text is matching wildcard.
-     * This method first checking shortcut -- if shortcut exists in input string -- than it checks regexp.
-     *
-     * @param input Input string
-     * @return true if input string matches wildcard
-     */
-    public boolean matches(String input) {
-        if (StringUtils.isEmpty(input)) {
-            return false;
-        }
-
-        boolean matchCase = ((regexpOptions & Pattern.CASE_INSENSITIVE) == Pattern.CASE_INSENSITIVE);
-
-        if (matchCase && !StringUtils.contains(input, shortcut)) {
-            return false;
-        }
-
-        if (!matchCase && !StringUtils.containsIgnoreCase(input, shortcut)) {
-            return false;
-        }
-
-        return regexp.matcher(input).matches();
-    }
-
-    /**
-     * Converts wildcard to regular expression
-     *
-     * @param pattern The wildcard pattern to convert
-     * @return A regex equivalent of the given wildcard
-     */
-    private static String wildcardToRegex(String pattern) {
-        return "^" + StringUtils.replaceEach(escapeRegexp(pattern), new String[]{"\\*", "\\?"}, new String[]{".*", "."}) + "$";
-    }
-
-    /**
-     * Escapes regexp special characters: \, *, +, ?, |, {, [, (,), ^, $,., #, and white space
-     *
-     * @param pattern Pattern to escape
-     * @return Escaped pattern
-     */
-    private static String escapeRegexp(String pattern) {
-        String[] specialCharacters = new String[]{"\\", "*", "+", "?", "|", "{", "[", "(", ")", "^", "$", ".", "#"};
-        String[] escapedCharacters = new String[]{"\\\\", "\\*", "\\+", "\\?", "\\|", "\\{", "\\[", "\\(", "\\)", "\\^", "\\$", "\\.", "\\#"};
-        return StringUtils.replaceEach(pattern, specialCharacters, escapedCharacters);
-    }
-
-    /**
-     * Extracts longest string that does not contain * or ? symbols.
-     *
-     * @param pattern Wildcard pattern
-     * @return Longest string without special symbols
-     */
-    private static String extractShortcut(String pattern) {
-        char[] wildcardChars = new char[]{'*', '?'};
-        int startIndex = 0;
-        int endIndex = StringUtils.indexOfAny(pattern, wildcardChars);
-
-        if (endIndex < 0) {
-            return pattern;
-        }
-        String shortcut = endIndex == startIndex
-                ? StringUtils.EMPTY
-                : pattern.substring(startIndex, endIndex - startIndex);
-
-        while (endIndex >= 0) {
-            startIndex = startIndex + endIndex + 1;
-            if (pattern.length() <= startIndex) {
-                break;
-            }
-
-            endIndex = StringUtils.indexOfAny(pattern.substring(startIndex), wildcardChars);
-            String tmpShortcut = endIndex < 0
-                    ? pattern.substring(startIndex)
-                    : pattern.substring(startIndex, endIndex + startIndex);
-
-            if (tmpShortcut.length() > shortcut.length()) {
-                shortcut = tmpShortcut;
-            }
-        }
-
-        return shortcut;
-    }
-
-    @Override
-    public String toString() {
-        return regexp.toString();
-    }
-}
\ No newline at end of file
diff --git a/adguard_cb/src/main/java/com/adguard/commons/utils/CharsetUtils.java b/adguard_cb/src/main/java/com/adguard/commons/utils/CharsetUtils.java
deleted file mode 100644
index 699739c..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/utils/CharsetUtils.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.utils;
-
-import org.apache.commons.lang3.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.nio.charset.Charset;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Helper methods for working with charsets
- */
-public class CharsetUtils {
-
-    private static final Pattern CODE_PAGE_REGEX = Pattern.compile("cp([-_ ]*)?([0-9]+)", Pattern.CASE_INSENSITIVE);
-    private final static Logger log = LoggerFactory.getLogger(CharsetUtils.class);
-
-    /**
-     * Default http encoding
-     */
-    public static final Charset DEFAULT_HTTP_ENCODING = Charset.forName("ISO-8859-1");
-
-    /**
-     * Utf-8 encoding
-     */
-    public static final Charset UTF8 = Charset.forName("utf-8");
-
-    /**
-     * Extracts Charset from Content-Type header value
-     *
-     * @param contentType Content-Type header value
-     * @return Charset or DEFAULT_HTTP_ENCODING if it is not specified
-     */
-    public static Charset forContentType(String contentType) {
-        return forContentType(contentType, DEFAULT_HTTP_ENCODING);
-    }
-
-    /**
-     * Extracts Charset from Content-Type header value
-     *
-     * @param contentType    Content-Type header value
-     * @param defaultCharset Will be returned if no charset found
-     * @return Charset or defaultCharset
-     */
-    public static Charset forContentType(String contentType, Charset defaultCharset) {
-        try {
-            if (!StringUtils.isEmpty(contentType)) {
-                String[] parts = StringUtils.split(contentType, ';');
-
-                for (String t1 : parts) {
-                    String t = t1.trim();
-                    int index = t.toLowerCase().indexOf("charset=");
-                    if (index != -1) {
-                        String charset = t.substring(index + 8);
-                        String charset1 = StringUtils.split(charset, ",;")[0];
-                        return forName(charset1, defaultCharset);
-                    }
-                }
-                return defaultCharset;
-            }
-
-            return defaultCharset;
-        } catch (Exception ex) {
-            log.debug(String.format("Cannot extract charset from %s", contentType), ex);
-            return defaultCharset;
-        }
-    }
-
-    /**
-     * Safely gets charset for the specified name
-     *
-     * @param charsetName Charset name
-     * @return Charset or null
-     */
-    public static Charset forName(String charsetName) {
-        return forName(charsetName, null);
-    }
-
-    /**
-     * Safely gets charset for the specified name
-     *
-     * @param charsetName    Charset name
-     * @param defaultCharset Default charset (if nothing found for specified charset name)
-     * @return Charset or defaultCharset
-     */
-    public static Charset forName(String charsetName, Charset defaultCharset) {
-
-        try {
-
-            return Charset.forName(charsetName);
-        } catch (Exception ex) {
-
-            try {
-                Matcher matcher = CODE_PAGE_REGEX.matcher(charsetName);
-                if (matcher.find()) {
-                    int codePage = NumberUtils.toInteger(matcher.group(2));
-                    return codePage > 0 ? Charset.forName("CP" + codePage) : defaultCharset;
-                } else {
-                    log.debug("Charset not found for " + charsetName, ex);
-                }
-            } catch (Exception e) {
-                log.debug("Charset not found for " + charsetName, e);
-            }
-
-
-        }
-
-        return defaultCharset;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/commons/utils/NumberUtils.java b/adguard_cb/src/main/java/com/adguard/commons/utils/NumberUtils.java
deleted file mode 100644
index 5eb7023..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/utils/NumberUtils.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.utils;
-
-import java.math.BigDecimal;
-
-/**
- * Helper class for working with numbers
- */
-public class NumberUtils {
-
-    /**
-     * Casts string to integer or returns null if value is not integer
-     *
-     * @param str String to parse
-     * @return Integer value or null
-     */
-    public static Integer toInteger(String str) {
-
-        try {
-            return Integer.valueOf(str);
-        } catch (Exception ex) {
-            return null;
-        }
-    }
-
-    public static double round(double d, int decimalPlace) {
-        BigDecimal bd = new BigDecimal(Double.toString(d));
-        bd = bd.setScale(decimalPlace, BigDecimal.ROUND_HALF_UP);
-        return bd.doubleValue();
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/commons/web/UrlUtils.java b/adguard_cb/src/main/java/com/adguard/commons/web/UrlUtils.java
deleted file mode 100644
index 0a094ea..0000000
--- a/adguard_cb/src/main/java/com/adguard/commons/web/UrlUtils.java
+++ /dev/null
@@ -1,928 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.commons.web;
-
-import com.adguard.commons.utils.ReservedDomains;
-import org.apache.commons.collections4.CollectionUtils;
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang3.StringUtils;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.UnsupportedEncodingException;
-import java.net.*;
-import java.util.*;
-import java.util.regex.Pattern;
-import java.util.zip.GZIPOutputStream;
-
-/**
- * Helper for working with URLs (extract keywords, extract domain name)
- */
-public class UrlUtils {
-
-    public static final String LOCALHOST_ADDRESS = "127.0.0.1";
-    private final static Logger LOG = LoggerFactory.getLogger(UrlUtils.class);
-    public final static int DEFAULT_READ_TIMEOUT = 10000; // 10 seconds
-    public final static int DEFAULT_SOCKET_TIMEOUT = 10000; // 10 seconds
-    private final static List<KeywordMatcher> SEARCH_ENGINES;
-
-    static {
-        SEARCH_ENGINES = new ArrayList<>();
-        SEARCH_ENGINES.add(new KeywordMatcher("^http://(www\\.)?google.*", new String[]{"q"}));
-        SEARCH_ENGINES.add(new KeywordMatcher("^http://(www\\.?)bing.*", new String[]{"q"}));
-        SEARCH_ENGINES.add(new KeywordMatcher("^http://([a-z]*\\.)?yahoo.com.*", new String[]{"p"}));
-        SEARCH_ENGINES.add(new KeywordMatcher("^http://nova\\.rambler\\.ru/search.*", new String[]{"query"}));
-        SEARCH_ENGINES.add(new KeywordMatcher("^http://yandex\\.ru/yandsearch.*", new String[]{"text"}));
-    }
-
-    /**
-     * Tries to decode specified text (also trying to autodetect encoding).
-     * If something gone wrong -- returns source text.
-     *
-     * @param text Text to decode
-     * @return Decoded string
-     */
-    public static String urlDecode(String text) {
-        if (StringUtils.isEmpty(text)) {
-            return text;
-        }
-
-        try {
-            if (text.contains("%8")) {
-                return URLDecoder.decode(text, "UTF-8");
-            }
-
-            return URLDecoder.decode(text, "ascii");
-        } catch (Exception ex) {
-            LOG.warn("Error decoding " + text, ex);
-        }
-
-        return text;
-    }
-
-    /**
-     * Tries to url encode specified text (using utf-8 encoding).
-     * If something gone wrong -- returns input text as is.
-     *
-     * @param text Text to encode
-     * @return Encoded string
-     */
-    public static String urlEncode(String text) {
-        try {
-            return URLEncoder.encode(text, "utf-8");
-        } catch (Exception ex) {
-            LOG.warn("Error encoding " + text, ex);
-        }
-        return text;
-    }
-
-
-    /**
-     * Removes jsessionid from string
-     *
-     * @return url without jsessionid
-     */
-    public static String removeJSessionId(String str) {
-        // Removing jsessionid
-        if (!StringUtils.isEmpty(str) && StringUtils.contains(str.toLowerCase(), ";jsessionid")) {
-            return str.substring(0, StringUtils.indexOf(str, ";jsessionid"));
-        }
-
-        return str;
-    }
-
-    /**
-     * Gets parameter value from the url.
-     * If tryRewrited is true - tries to parse rewrited url using getRewritedParameter method
-     *
-     * @param url           url
-     * @param parameterName parameter name
-     * @param tryRewrited   try to extract from rewrited url
-     * @return parameter value
-     */
-    public static String getParameter(String url, String parameterName, boolean tryRewrited) {
-        String parameterValue = getParameter(url, parameterName);
-
-        if (StringUtils.isEmpty(parameterValue) && tryRewrited) {
-            parameterValue = getRewritedParameter(url, parameterName);
-        }
-
-        return parameterValue;
-    }
-
-    /**
-     * Gets parameter value from the url
-     *
-     * @param url           url
-     * @param parameterName parameter name
-     * @return parameter value
-     */
-    public static String getParameter(String url, String parameterName) {
-        Map<String, String> parameters = getParameters(url);
-        return parameters == null ? null : parameters.get(parameterName);
-    }
-
-    /**
-     * For rewrited urls like 'http://dev.com/q/search%20terms/anotherparameter/anotherparametervalue'
-     *
-     * @param url           url
-     * @param parameterName parameter name
-     * @return rewrited parameter
-     */
-    public static String getRewritedParameter(String url, String parameterName) {
-
-        String[] parts = StringUtils.splitPreserveAllTokens(url, '/');
-
-        if (parts == null || parts.length < 2) {
-            return null;
-        }
-
-        String parameterValue = null;
-
-        // Searching for the specified parameter name in url
-        for (int i = 0; i < parts.length; i++) {
-            if (parameterName.equals(parts[i])) {
-                if (i < (parts.length - 1)) {
-                    // parameter name found, breaking loop
-                    parameterValue = parts[i + 1];
-                    break;
-                }
-            }
-        }
-
-        // Removing jsessionid
-        parameterValue = removeJSessionId(parameterValue);
-
-        return parameterValue;
-    }
-
-    /**
-     * Checks if string contains ASCII symbols only
-     *
-     * @param input String
-     * @return true if the input string is ASCII
-     */
-    public static boolean isASCII(String input) {
-
-        if (input == null) {
-            return true;
-        }
-
-        for (int i = 0; i < input.length(); i++) {
-            int c = input.charAt(i);
-            if (c > 0x7F) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Converts domain to punycode if needed.
-     * For ascii domains -- does nothing.
-     *
-     * @param domainName Domain name
-     * @return Punycode domain name
-     */
-    public static String toPunycode(String domainName) {
-
-        try {
-            return IDN.toASCII(domainName);
-        } catch (Exception ex) {
-            LOG.debug("Cannot convert " + domainName + " to punycode", ex);
-        }
-
-        return domainName;
-    }
-
-    /**
-     * Checks if specified request url is third-party or not
-     *
-     * @param requestUrl Request url
-     * @param referrer   Referrer url
-     * @return true if request is third party
-     */
-    public static boolean isThirdPartyRequest(String requestUrl, String referrer) {
-        String domainName = getSecondLevelDomainName(requestUrl);
-        String refDomainName = getSecondLevelDomainName(referrer);
-        return referrer != null && !StringUtils.equals(domainName, refDomainName);
-    }
-
-    /**
-     * Extracts port from URI
-     *
-     * @param url URL to get port from
-     * @return port value.
-     */
-    public static int getPort(URL url) {
-        int port = url.getPort();
-
-        if (port >= 0) {
-            return port;
-        } else if ("http".equals(url.getProtocol())) {
-            return 80;
-        } else if ("https".equals(url.getProtocol())) {
-            return 443;
-        } else if ("ftp".equals(url.getProtocol())) {
-            return 21;
-        }
-
-        return port;
-    }
-
-    /**
-     * Extracts host name from the url
-     *
-     * @param url Url to extract from
-     * @return Host name
-     */
-    public static String getHost(String url) {
-        try {
-            if (StringUtils.isEmpty(url)) {
-                return null;
-            }
-
-            int firstIdx = url.indexOf("//");
-            if (firstIdx == -1) {
-                return null;
-            }
-            int nextSlashIdx = url.indexOf("/", firstIdx + 2);
-            int startParamsIdx = url.indexOf("?", firstIdx + 2);
-            int colonIdx = url.indexOf(":", firstIdx + 2);
-
-            int lastIdx = nextSlashIdx;
-            if (startParamsIdx > 0 && (startParamsIdx < nextSlashIdx || lastIdx == -1)) {
-                lastIdx = startParamsIdx;
-            }
-
-            if (colonIdx > 0 && (colonIdx < lastIdx || lastIdx == -1)) {
-                lastIdx = colonIdx;
-            }
-
-            return lastIdx == -1 ? url.substring(firstIdx + 2) : url.substring(firstIdx + 2, lastIdx);
-        } catch (Exception ex) {
-            LOG.debug("Cannot extract host from " + url, ex);
-            return null;
-        }
-    }
-
-    /**
-     * Extracts relative uri from raw request uri
-     *
-     * @param rawUri Raw request uri
-     * @return Relative uri
-     */
-    public static String getRelativeUri(String rawUri) {
-        if (StringUtils.isEmpty(rawUri) || rawUri.startsWith("/")) {
-            // rawUri is already relative
-            return rawUri;
-        }
-        final String protocolPrefixEnd = "//";
-        int protocolEndIndex = rawUri.indexOf(protocolPrefixEnd) + protocolPrefixEnd.length();
-        int pointIndex = rawUri.indexOf('.');
-        if (protocolEndIndex == -1 || protocolEndIndex > pointIndex) {
-            return rawUri;
-        }
-        int slashIndex = rawUri.indexOf('/', pointIndex);
-        return slashIndex == -1 ? rawUri : rawUri.substring(slashIndex);
-    }
-
-    /**
-     * Extracts domain name from the url. Also crops www.
-     *
-     * @param url url
-     * @return domain name
-     */
-    public static String getDomainName(String url) {
-        if (StringUtils.isEmpty(url)) {
-            return null;
-        }
-
-        try {
-            if (!StringUtils.startsWith(url, "http://") &&
-                    !StringUtils.startsWith(url, "https://")) {
-                url = "http://" + url;
-            }
-            return getDomainName(new URL(url));
-        } catch (MalformedURLException ex) {
-            return null;
-        }
-    }
-
-    /**
-     * Checks if specified parameter is valid domain name
-     *
-     * @param domainName Domain name
-     * @return true if it is really a domain name
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static boolean isDomainName(String domainName) {
-
-        if (StringUtils.isEmpty(domainName) ||
-                !StringUtils.contains(domainName, ".")) {
-            return false;
-        }
-
-        String url = "http://" + domainName;
-        String normalizedDomainName = getDomainName(url);
-
-        //noinspection RedundantIfStatement
-        if (normalizedDomainName != null && "".equals(normalizedDomainName.replaceAll("[a-zA-Z0-9-.]+", ""))) {
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Gets all possible domain names up to 2nd level.
-     * <p/>
-     * For example, for "test.domain.name.com"
-     * this method will return:<br/>
-     * name.com
-     * domain.name.com
-     * test.domain.name.com
-     *
-     * @param domainName Domain name to extract
-     * @return List of possible domain names
-     */
-    public static List<String> getTopDomainNames(String domainName) {
-
-        String[] parts = StringUtils.split(domainName, ".");
-
-        if (parts == null || parts.length <= 1) {
-            return Arrays.asList(domainName);
-        }
-
-        List<String> domainNames = new ArrayList<>();
-
-        for (int i = 0; i < parts.length - 1; i++) {
-
-            StringBuilder sb = new StringBuilder();
-
-            for (int j = 0; j + i < parts.length; j++) {
-                sb.append(parts[j + i]);
-                sb.append(".");
-            }
-
-            sb.deleteCharAt(sb.length() - 1);
-            domainNames.add(sb.toString());
-        }
-
-        return domainNames;
-    }
-
-    /**
-     * Extracts domain name from the url. Also crops www.
-     *
-     * @param url url
-     * @return domain name
-     */
-    public static String getDomainName(URL url) {
-        String host = url.getHost();
-
-        if (host == null) {
-            return null;
-        }
-
-        int dotIndex = host.lastIndexOf('.');
-        if (dotIndex <= 0 || dotIndex == (host.length() - 1)) {
-            // Check that dot is not the first or last char
-            return null;
-        }
-
-        return StringUtils.lowerCase(cropWww(host));
-    }
-
-    /**
-     * Crops www. prefix from the domain name
-     *
-     * @param domainName domain
-     * @return domain without www
-     */
-    public static String cropWww(String domainName) {
-        if (StringUtils.isEmpty(domainName)) {
-            return null;
-        }
-        if (domainName.startsWith("www.")) {
-            return domainName.substring(4);
-        }
-
-        return domainName;
-    }
-
-    /**
-     * Adds parameter to a query string
-     *
-     * @param url            url
-     * @param parameterName  parameter name
-     * @param parameterValue parameter value
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static String addParameter(String url, String parameterName, String parameterValue) {
-        try {
-            if (url == null) {
-                return null;
-            }
-
-            StringBuilder targetUrl = new StringBuilder();
-            targetUrl.append(url);
-
-            URL testURL = new URL(url);
-            if (testURL.getQuery() != null) {
-                targetUrl.append("&");
-            } else if ("".equals(testURL.getPath())) {
-                targetUrl.append("/?");
-            } else {
-                targetUrl.append("?");
-            }
-
-            targetUrl.append(parameterName);
-            targetUrl.append("=");
-            targetUrl.append(parameterValue);
-
-            return targetUrl.toString();
-        } catch (MalformedURLException ex) {
-            return url;
-        }
-    }
-
-    /**
-     * Parses parameters from the query string
-     *
-     * @param queryString Query string or post data
-     * @return Parameters map
-     */
-    public static Map<String, String> parseQueryString(String queryString, String charset) throws UnsupportedEncodingException {
-        if (StringUtils.isEmpty(queryString)) {
-            return new HashMap<>();
-        }
-
-        String[] params = queryString.split("&");
-        Map<String, String> map = new HashMap<>();
-        for (String param : params) {
-            String[] pair = param.split("=");
-
-            if (pair.length == 2) {
-                String name = pair[0];
-                String value = charset == null ? pair[1] : URLDecoder.decode(pair[1], charset);
-                map.put(name, value);
-            }
-        }
-        return map;
-    }
-
-    /**
-     * Extracts path and query from the url
-     *
-     * @param url Url
-     * @return path and query
-     */
-    public static String getPathAndQuery(URL url) {
-
-        String path = url.getPath();
-        String query = url.getQuery();
-
-        if (StringUtils.isNotEmpty(query)) {
-            return path + "?" + query;
-        }
-
-        return path;
-    }
-
-    /**
-     * Gets parameters from query string
-     *
-     * @param url url
-     * @return GET parameters map
-     */
-    public static Map<String, String> getParameters(String url) {
-        if (StringUtils.isEmpty(url)) {
-            return null;
-        }
-
-        int index = url.indexOf("?");
-
-        if (index == -1) {
-            return null;
-        }
-
-        String query = url.substring(index + 1);
-        Map<String, String> map = null;
-        try {
-            map = parseQueryString(query, null);
-        } catch (Exception ex) {
-            LOG.error("Error parsing query string " + url, ex);
-        }
-        return map;
-    }
-
-    /**
-     * Downloads string from the specified url
-     *
-     * @param url Url
-     * @return Response
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static String downloadString(String url) throws MalformedURLException {
-        return downloadString(new URL(url));
-    }
-
-    /**
-     * Downloads string from the specified url
-     *
-     * @param url               Url
-     * @param readTimeout       Read timeout
-     * @param connectionTimeout Connection timeout
-     * @return Downloaded string or null
-     * @throws MalformedURLException
-     */
-    public static String downloadString(String url, int readTimeout, int connectionTimeout) throws MalformedURLException {
-        return downloadString(new URL(url), null, readTimeout, connectionTimeout, "utf-8");
-    }
-
-    /**
-     * Tries to download from the specified url for triesCount times
-     *
-     * @param url        Url
-     * @param triesCount Tries count
-     * @return Repsponse
-     */
-    public static String downloadString(String url, int triesCount) throws MalformedURLException {
-        return downloadString(new URL(url), null, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT, "utf-8", triesCount);
-    }
-
-    /**
-     * Downloads content from the specified url.
-     * Returns null if there's an error.
-     *
-     * @param url url
-     * @return downloaded string
-     */
-    public static String downloadString(URL url) {
-        return downloadString(url, null, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT, "utf-8");
-    }
-
-    /**
-     * Downloads content from the specified url using specified proxy (or do not using it).
-     * Returns null if there's an error.
-     *
-     * @param url   url
-     * @param proxy proxy to use
-     */
-    @SuppressWarnings("UnusedDeclaration")
-    public static String downloadString(URL url, Proxy proxy) {
-        return downloadString(url, proxy, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT, "utf-8");
-    }
-
-    /**
-     * Downloads content from the specified url using specified proxy (or do not using it) and timeouts.
-     * Returns null if there's an error.
-     *
-     * @param url           url
-     * @param proxy         proxy to use
-     * @param readTimeout   read timeout
-     * @param socketTimeout connection timeout
-     * @return Downloaded string
-     */
-    public static String downloadString(URL url, Proxy proxy, int readTimeout, int socketTimeout, String encoding) {
-        HttpURLConnection connection = null;
-        InputStream inputStream = null;
-
-        try {
-            connection = (HttpURLConnection) (proxy == null ? url.openConnection() : url.openConnection(proxy));
-            connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.85 Safari/537.36");
-            connection.setReadTimeout(readTimeout);
-            connection.setConnectTimeout(socketTimeout);
-            connection.connect();
-            if (connection.getResponseCode() >= 400) {
-                throw new IOException("Response status is " + connection.getResponseCode());
-            }
-
-            if (connection.getResponseCode() >= 301) {
-                String location = connection.getHeaderField("Location");
-                // HttpURLConnection does not follow redirects from HTTP to HTTPS
-                // So we handle it manually
-                return downloadString(new URL(location), proxy, readTimeout, socketTimeout, encoding);
-            }
-
-            if (connection.getResponseCode() == 204) {
-                return StringUtils.EMPTY;
-            }
-
-            inputStream = connection.getInputStream();
-            return IOUtils.toString(inputStream, encoding);
-        } catch (IOException ex) {
-            if (LOG.isDebugEnabled()) {
-                LOG.warn("Error downloading string from {}:\r\n", url, ex);
-            } else {
-                LOG.warn("Cannot download string from {}: {}", url, ex.getMessage());
-            }
-            // Ignoring exception
-            return null;
-        } finally {
-            IOUtils.closeQuietly(inputStream);
-            if (connection != null) {
-                connection.disconnect();
-            }
-        }
-    }
-
-    /**
-     * Downloads content from the specified url using specified proxy (or do not using it) and timeouts.
-     * Returns null if there's an error.
-     *
-     * @param url           url
-     * @param proxy         proxy to use
-     * @param readTimeout   read timeout
-     * @param socketTimeout connection timeout
-     * @return Downloaded string
-     */
-    public static String downloadString(URL url, Proxy proxy, int readTimeout, int socketTimeout, String encoding, int triesCount) {
-        IOException lastException = null;
-
-        for (int i = 0; i < triesCount; i++) {
-            lastException = null;
-            HttpURLConnection connection = null;
-            InputStream inputStream = null;
-
-            try {
-                connection = (HttpURLConnection) (proxy == null ? url.openConnection() : url.openConnection(proxy));
-                connection.setReadTimeout(readTimeout);
-                connection.setConnectTimeout(socketTimeout);
-                connection.connect();
-                inputStream = connection.getInputStream();
-                return IOUtils.toString(inputStream, encoding);
-            } catch (IOException ex) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.warn("Error downloading string from {}. Try number: {}. Cause:\r\n", url, triesCount, ex);
-                } else {
-                    LOG.warn("Error downloading string from {}. Try number: {}. Cause:{}", url, triesCount, ex.getMessage());
-                }
-                lastException = ex;
-            } finally {
-                IOUtils.closeQuietly(inputStream);
-                if (connection != null) {
-                    connection.disconnect();
-                }
-            }
-        }
-
-        if (lastException != null) {
-            LOG.error("Could not download string from url: " + url, lastException);
-        }
-
-        return null;
-    }
-
-
-    /**
-     * Extracts keywords from url if possible.
-     *
-     * @param url url
-     * @return keywords
-     */
-    public static String extractKeywords(String url) {
-        if (StringUtils.isEmpty(url)) {
-            return null;
-        }
-
-        for (KeywordMatcher matcher : SEARCH_ENGINES) {
-            String keywords = matcher.matchKeywords(url);
-
-            if (keywords != null) {
-                return keywords.replace("+", " ");
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Sends a post request
-     *
-     * @param url           url
-     * @param postData      data to post
-     * @param encoding      response encoding
-     * @param contentType   content type
-     * @param readTimeout   socket read timeout
-     * @param socketTimeout socket connect timeout
-     * @return downloaded string
-     */
-    public static String postRequest(String url, String postData, String encoding, String contentType, int readTimeout, int socketTimeout) {
-
-        try {
-            return postRequest(new URL(url), postData, encoding, contentType, readTimeout, socketTimeout);
-        } catch (MalformedURLException ex) {
-            LOG.error("Error posting request to {}, post data length={}", url, StringUtils.length(postData), ex);
-            return null;
-        }
-    }
-
-    /**
-     * Sends a post request
-     *
-     * @param url         url
-     * @param postData    data to post
-     * @param encoding    response encoding
-     * @param contentType content type
-     * @return downloaded string
-     */
-    public static String postRequest(URL url, String postData, String encoding, String contentType) {
-        return postRequest(url, postData, encoding, contentType, DEFAULT_READ_TIMEOUT, DEFAULT_SOCKET_TIMEOUT);
-    }
-
-    /**
-     * Sends a POST request
-     *
-     * @param url           URL
-     * @param postData      Post body
-     * @param encoding      Post body encoding
-     * @param contentType   Post body content type
-     * @param readTimeout   Read timeout
-     * @param socketTimeout Socket timeout
-     * @return Response
-     */
-    public static String postRequest(URL url, String postData, String encoding, String contentType, int readTimeout, int socketTimeout) {
-        return postRequest(url, postData, encoding, contentType, false, readTimeout, socketTimeout);
-    }
-
-    /**
-     * Sends a POST request
-     *
-     * @param url           URL
-     * @param postData      Post request body
-     * @param encoding      Post request body encoding
-     * @param contentType   Body content type
-     * @param compress      If true - compress bod
-     * @param readTimeout   Read timeout
-     * @param socketTimeout Socket timeout
-     * @return Response
-     */
-    public static String postRequest(URL url, String postData, String encoding, String contentType, boolean compress, int readTimeout, int socketTimeout) {
-        HttpURLConnection connection = null;
-        OutputStream outputStream = null;
-
-        try {
-            connection = (HttpURLConnection) url.openConnection();
-            connection.setRequestMethod("POST");
-            if (contentType != null) {
-                connection.setRequestProperty("Content-Type", contentType);
-            }
-            if (compress) {
-                connection.setRequestProperty("Content-Encoding", "gzip");
-            }
-            connection.setConnectTimeout(socketTimeout);
-            connection.setReadTimeout(readTimeout);
-            connection.setDoOutput(true);
-            connection.connect();
-            if (postData != null) {
-                outputStream = connection.getOutputStream();
-
-                if (compress) {
-                    outputStream = new GZIPOutputStream(outputStream);
-                }
-
-                if (encoding != null) {
-                    IOUtils.write(postData, outputStream, encoding);
-                } else {
-                    IOUtils.write(postData, outputStream);
-                }
-
-                if (compress) {
-                    ((GZIPOutputStream) outputStream).finish();
-                } else {
-                    outputStream.flush();
-                }
-            }
-
-            return IOUtils.toString(connection.getInputStream(), encoding);
-        } catch (Exception ex) {
-            LOG.error("Error posting request to {}, post data length={}\r\n", url, StringUtils.length(postData), ex);
-            // Ignoring exception
-            return null;
-        } finally {
-            IOUtils.closeQuietly(outputStream);
-
-            if (connection != null) {
-                connection.disconnect();
-            }
-        }
-    }
-
-    /**
-     * Gets 2nd level domain name from the specified url
-     *
-     * @param url Url to check
-     * @return 2nd level domain name
-     */
-    public static String getSecondLevelDomainName(String url) {
-        String host = (url != null && url.contains("//")) ? getHost(url) : url;
-
-        if (StringUtils.isEmpty(host)) {
-            return null;
-        }
-
-        String[] parts = StringUtils.split(host, '.');
-
-        if (parts.length <= 2) {
-            return host;
-        }
-
-        boolean containsTwoLvlPostfix;
-        String twoPartDomain = parts[parts.length - 2] + "." + parts[parts.length - 1];
-
-        containsTwoLvlPostfix = ReservedDomains.isReservedDomainName(twoPartDomain);
-
-        String threePartDomain = parts[parts.length - 3] + "." + twoPartDomain;
-        if (parts.length == 3 && containsTwoLvlPostfix) {
-            return threePartDomain;
-        }
-        if (ReservedDomains.isReservedDomainName(threePartDomain)) {
-            if (parts.length == 3) {
-                return threePartDomain;
-            }
-
-            return parts[parts.length - 4] + "." + threePartDomain;
-        }
-
-        return containsTwoLvlPostfix ? threePartDomain : twoPartDomain;
-    }
-
-    /**
-     * Checks if specified domain name is in the list of the domainNames
-     * or if it is sub-domain of any domain in the list.
-     *
-     * @param domainName  Domain name to check
-     * @param domainNames List of domain names
-     * @return true if domain (or it's top-level domain) is in the list
-     */
-    public static boolean isDomainOrSubDomain(String domainName, List<String> domainNames) {
-        if (CollectionUtils.isEmpty(domainNames)) {
-            return false;
-        }
-
-        for (String domainToCheck : domainNames) {
-            if (domainName.equals(domainToCheck) ||
-                    // Optimizing end checking: http://jira.performix.ru/browse/AG-6587?focusedCommentId=23526&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-23526
-                    (domainName.endsWith(domainToCheck) && domainName.endsWith("." + domainToCheck))) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * Class for matching keywords
-     */
-    private static class KeywordMatcher {
-
-        private final Pattern urlPattern;
-        private final String[] parameters;
-
-        private KeywordMatcher(String urlPattern, String[] parameters) {
-            this.urlPattern = Pattern.compile(urlPattern, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
-            this.parameters = parameters;
-        }
-
-        public String matchKeywords(String url) {
-            if (url == null || !urlPattern.matcher(url).matches()) {
-                return null;
-            }
-
-            Map<String, String> queryParameters = getParameters(url);
-
-            if (queryParameters == null) {
-                return null;
-            }
-
-            for (String param : parameters) {
-                String keywords = queryParameters.get(param);
-
-                if (keywords != null) {
-                    return keywords;
-                }
-            }
-
-            return null;
-        }
-    }
-
-}
\ No newline at end of file
diff --git a/adguard_cb/src/main/java/com/adguard/filter/WorkaroundUtils.java b/adguard_cb/src/main/java/com/adguard/filter/WorkaroundUtils.java
deleted file mode 100644
index b85d0f6..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/WorkaroundUtils.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter;
-
-import android.content.Context;
-import com.adguard.commons.enums.FilteringQuality;
-
-/**
- * Different workarounds
- */
-public class WorkaroundUtils {
-
-    /**
-     * We will use ContentEditingHtmlParser for all devices
-     * whose speed rank is lower than this limit.
-     * <p/>
-     * This value is experimental.
-     * For Samsung Galaxy Tab 3 7.0 speed rank is 500-600 and
-     * it is too slow.
-     */
-    private final static int SPEED_RANK_LIMIT = 150;
-
-    /**
-     * We use speed rank to determine if we need to disable
-     * cosmetic rules for low-end devices
-     */
-    private final static int COSMETIC_SPEED_RANK_LIMIT = 2000;
-
-    /**
-     * @param deviceSpeedRank Device speed rank
-     * @return true if we should use contentblocker parser by default
-     */
-    public static FilteringQuality getDefaultFilteringQuality(int deviceSpeedRank) {
-        if (deviceSpeedRank > COSMETIC_SPEED_RANK_LIMIT) {
-            return FilteringQuality.SIMPLE;
-        } else if (deviceSpeedRank > SPEED_RANK_LIMIT) {
-            return FilteringQuality.SPEEDY;
-        } else {
-            return FilteringQuality.FULL;
-        }
-    }
-
-    /**
-     * This method is used to calculate device speed rank.
-     * Depending on this rank we use either ContentEditingHtmlParser (which is slow but has good quality)
-     * or FastHtmlParser (which is contentblocker but the only thing it does is injecting CSS/JS).
-     * <p/>
-     * The lower speed rank is better.
-     *
-     * @return Speed rank.
-     */
-    public static int calculateDeviceSpeedRank(Context context) {
-        // TODO make it true
-        return 150;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/html/Chars.java b/adguard_cb/src/main/java/com/adguard/filter/html/Chars.java
deleted file mode 100644
index 4ccdfed..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/html/Chars.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.html;
-
-/**
- * Helper characters
- */
-public class Chars {
-
-    public static final int QUOTE = '\'';
-    public static final int DOUBLEQUOTE = '"';
-    public static final int BACKSLASH = '\\';
-    public static final int SLASH = '/';
-    public static final int ASTERISK = '*';
-    public static final int TAG_CLOSE = '>';
-    public static final int TAG_OPEN = '<';
-    public static final int EXCLAMATION = '!';
-    public static final int OPEN_SQUARE_BRACKET = '[';
-    public static final int CLOSE_SQUARE_BRACKET = ']';
-    public static final int DASH = '-';
-    public static final int EQUALS = '=';
-    public static final int CR = '\r';
-    public static final int LF = '\n';
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/html/HtmlElements.java b/adguard_cb/src/main/java/com/adguard/filter/html/HtmlElements.java
deleted file mode 100644
index 888f381..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/html/HtmlElements.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.html;
-
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Html elements enumeration
- */
-public class HtmlElements {
-
-    public static final String A = "a";
-    public static final String ABBR = "abbr";
-    public static final String ACRONYM = "acronym";
-    public static final String ADDRESS = "address";
-    public static final String APPLET = "applet";
-    public static final String AREA = "area";
-    public static final String B = "b";
-    public static final String BASE = "base";
-    public static final String BASEFONT = "basefont";
-    public static final String BDO = "bdo";
-    public static final String BIG = "big";
-    public static final String BLOCKQUOTE = "blockquote";
-    public static final String BR = "br";
-    public static final String BODY = "body";
-    public static final String BUTTON = "button";
-    public static final String CAPTION = "caption";
-    public static final String CENTER = "center";
-    public static final String CITE = "cite";
-    public static final String CODE = "code";
-    public static final String COL = "col";
-    public static final String COLGROUP = "colgroup";
-    public static final String DD = "dd";
-    public static final String DEL = "del";
-    public static final String DFN = "dfn";
-    public static final String DIR = "dir";
-    public static final String DIV = "div";
-    public static final String DL = "dl";
-    public static final String DT = "dt";
-    public static final String EM = "em";
-    public static final String EMBED = "embed";
-    public static final String FIELDSET = "fieldset";
-    public static final String FONT = "font";
-    public static final String FORM = "form";
-    public static final String FRAME = "frame";
-    public static final String FRAMESET = "frameset";
-    public static final String H1 = "h1";
-    public static final String H2 = "h2";
-    public static final String H3 = "h3";
-    public static final String H4 = "h4";
-    public static final String H5 = "h5";
-    public static final String H6 = "h6";
-    public static final String HR = "hr";
-    public static final String HEAD = "head";
-    public static final String HTML = "html";
-    public static final String I = "i";
-    public static final String IFRAME = "iframe";
-    public static final String IMG = "img";
-    public static final String INPUT = "input";
-    public static final String INS = "ins";
-    public static final String ISINDEX = "isindex";
-    public static final String KBD = "kbd";
-    public static final String LABEL = "label";
-    public static final String LEGEND = "legend";
-    public static final String LI = "li";
-    public static final String LINK = "link";
-    public static final String MAP = "map";
-    public static final String MENU = "menu";
-    public static final String META = "meta";
-    public static final String NOFRAMES = "noframes";
-    public static final String NOSCRIPT = "noscript";
-    public static final String OBJECT = "object";
-    public static final String OL = "ol";
-    public static final String OPTGROUP = "optgroup";
-    public static final String OPTION = "option";
-    public static final String P = "p";
-    public static final String PARAM = "param";
-    public static final String PRE = "pre";
-    public static final String Q = "q";
-    public static final String S = "s";
-    public static final String SAMP = "samp";
-    public static final String SCRIPT = "script";
-    public static final String SELECT = "select";
-    public static final String SMALL = "small";
-    public static final String SPAN = "span";
-    public static final String STRIKE = "strike";
-    public static final String STRONG = "strong";
-    public static final String STYLE = "style";
-    public static final String SUB = "sub";
-    public static final String SUP = "sup";
-    public static final String TABLE = "table";
-    public static final String TBODY = "tbody";
-    public static final String TD = "td";
-    public static final String TEXTAREA = "textarea";
-    public static final String TFOOT = "tfoot";
-    public static final String TH = "th";
-    public static final String THEAD = "thead";
-    public static final String TITLE = "title";
-    public static final String TR = "tr";
-    public static final String TT = "tt";
-    public static final String U = "u";
-    public static final String UL = "ul";
-    public static final String VAR = "var";
-
-    // Contains empty (void) tag names
-    public final static List<String> EMPTY_TAGS = Arrays.asList(BR, BASE, COL, LINK, PARAM, META, FRAME, HR, IMG, INPUT, EMBED);
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/http/HttpMethod.java b/adguard_cb/src/main/java/com/adguard/filter/http/HttpMethod.java
deleted file mode 100644
index e5feeaa..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/http/HttpMethod.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.http;
-
-import org.apache.commons.lang3.StringUtils;
-
-/**
- * Contains possible HTTP methods
- */
-public class HttpMethod {
-
-    /**
-     * Asks for the response identical to the one that would correspond to a GET request, but without the response body.
-     * This is useful for retrieving meta-information written in response headers, without having to transport the entire content.
-     */
-    public static final String HEAD = "HEAD";
-
-    /**
-     * Requests a representation of the specified resource. GET should not be used for operations that cause side-effects,
-     * such as using it for taking actions in web applications. One reason for this is that GET may be used arbitrarily by robots or
-     * crawlers, which should not need to consider the side effects that a request should cause.
-     */
-    public static final String GET = "GET";
-
-    /**
-     * Submits data to be processed (e.g., from an HTML form) to the identified resource. The data is included in the body of
-     * the request. This may result in the creation of a new resource or the updates of existing resources or both.
-     */
-    public static final String POST = "POST";
-
-    /**
-     * Uploads a representation of the specified resource.
-     */
-    public static final String PUT = "PUT";
-
-    /**
-     * Deletes the specified resource.
-     */
-    public static final String DELETE = "DELETE";
-
-    /**
-     * Echoes back the received request, so that a client can see what (if any) changes or additions have been made by intermediate servers.
-     */
-    public static final String TRACE = "TRACE";
-
-    /**
-     * Returns the HTTP methods that the server supports for specified URL. This can be used to check the functionality of a
-     * web server by requesting '*' instead of a specific resource.
-     */
-    public static final String OPTIONS = "OPTIONS";
-
-    /**
-     * Converts the request connection to a transparent TCP/IP tunnel, usually to facilitate SSL-encrypted
-     * communication (HTTPS) through an unencrypted HTTP proxy.
-     */
-    public static final String CONNECT = "CONNECT";
-
-    /**
-     * Is used to apply partial modifications to a resource.
-     */
-    public static final String PATCH = "PATCH";
-
-    /**
-     * Used to retrieve properties, stored as XML, from a web resource. It is also overloaded to allow one to
-     * retrieve the collection structure (a.k.a. directory hierarchy) of a remote system.
-     */
-    public static final String PROPFIND = "PROPFIND";
-
-    /**
-     * Used to change and delete multiple properties on a resource in a single atomic act
-     */
-    public static final String PROPPATCH = "PROPPATCH";
-
-    /**
-     * Used to create collections (a.k.a. a directory)
-     */
-    public static final String MKCOL = "MKCOL";
-
-    /**
-     * Used to copy a resource from one URI to another
-     */
-    public static final String COPY = "COPY";
-
-    /**
-     * Used to move a resource from one URI to another
-     */
-    public static final String MOVE = "MOVE";
-
-    /**
-     * Used to put a lock on a resource. WebDAV supports both shared and exclusive locks.
-     */
-    public static final String LOCK = "LOCK";
-
-    /**
-     * Used to remove a lock from a resource
-     */
-    public static final String UNLOCK = "UNLOCK";
-
-    /**
-     * Checks if this type of request could contain entity body
-     *
-     * @param method Http method
-     * @return true if there is a body
-     */
-    public static boolean hasEntityBody(String method) {
-        return StringUtils.equals(method, POST) ||
-                StringUtils.equals(method, PUT) ||
-                StringUtils.equals(method, PATCH) ||
-                StringUtils.equals(method, DELETE) ||
-                isWebDavMethod(method);
-    }
-
-    /**
-     * Checks if response to this method could contain entity body.
-     * For example HEAD does not expect response with body
-     *
-     * @param requestMethod Request method
-     * @return true if expect
-     */
-    public static boolean expectResponseEntityBody(String requestMethod) {
-        return !StringUtils.equals(requestMethod, HEAD);
-    }
-
-    /**
-     * Checks if this method is valid HTTP method
-     *
-     * @param method Http method
-     * @return true if method is valid
-     */
-    public static boolean isValidMethod(String method) {
-        return StringUtils.equals(method, POST) ||
-                StringUtils.equals(method, HEAD) ||
-                StringUtils.equals(method, GET) ||
-                StringUtils.equals(method, PUT) ||
-                StringUtils.equals(method, DELETE) ||
-                StringUtils.equals(method, TRACE) ||
-                StringUtils.equals(method, OPTIONS) ||
-                StringUtils.equals(method, CONNECT) ||
-                StringUtils.equals(method, PATCH);
-    }
-
-    /**
-     * Checks if this method is WebDAV method.
-     *
-     * @param method Http method to check
-     * @return true if this is WebDAV method.
-     */
-    public static boolean isWebDavMethod(String method) {
-        return StringUtils.equals(method, PROPFIND) ||
-                StringUtils.equals(method, PROPPATCH) ||
-                StringUtils.equals(method, MKCOL) ||
-                StringUtils.equals(method, COPY) ||
-                StringUtils.equals(method, MOVE) ||
-                StringUtils.equals(method, LOCK) ||
-                StringUtils.equals(method, UNLOCK);
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/proxy/ProtocolDetector.java b/adguard_cb/src/main/java/com/adguard/filter/proxy/ProtocolDetector.java
deleted file mode 100644
index 893d60d..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/proxy/ProtocolDetector.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.proxy;
-
-import com.adguard.commons.io.IoUtils;
-import com.adguard.commons.utils.CharsetUtils;
-import com.adguard.filter.html.Chars;
-import com.adguard.filter.http.HttpMethod;
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang3.ArrayUtils;
-import org.apache.commons.lang3.StringUtils;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * This class is used to detect the protocol of incoming byte stream.
- */
-public final class ProtocolDetector {
-
-    private static final List<String> HTML_MARKERS = Arrays.asList("!doctype", "!--", "body", "html", "head", "div", "script", "meta");
-
-    /**
-     * Detects protocol of the input stream
-     *
-     * @param inputStream Stream to check
-     * @return Protocol detected
-     * @throws IOException                If something is wrong with the input stream
-     * @throws IllegalArgumentException If stream does not support "mark"
-     */
-    public static Protocol detect(InputStream inputStream) throws IOException {
-        if (!inputStream.markSupported()) {
-            throw new IllegalArgumentException("Stream must support mark for protocol detection!");
-        }
-
-        byte[] packet = new byte[32];
-        inputStream.mark(packet.length);
-        int read = inputStream.read(packet);
-        inputStream.reset();
-
-        if (read < packet.length) {
-            return Protocol.TOO_SMALL;
-        } else if (ProtocolDetector.isHttpProtocol(packet)) {
-            return Protocol.HTTP;
-        } else if (ProtocolDetector.isTlsProtocol(packet)) {
-            return Protocol.TLS;
-        } else {
-            return Protocol.OTHER;
-        }
-    }
-
-    /**
-     * Checks if incoming stream is HTML
-     *
-     * @param inputStream Input stream
-     * @return true if this is a HTML protocol
-     */
-    public static boolean isHtml(InputStream inputStream) throws IOException {
-
-        // At least 32 characters, should be enough to detect
-        byte[] firstBytes = peekFirstNotEmptyBytes(inputStream, 32);
-
-        if (firstBytes == null || firstBytes[0] != Chars.TAG_OPEN) {
-            // If first not-empty symbol is not equal to Chars.TAG_OPEN - this is likely to be a non-HTML content
-            return false;
-        }
-
-        for (String htmlMarker : HTML_MARKERS) {
-            if (findStringIgnoreCase(firstBytes, 1, htmlMarker)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * Checks if first TCP packet is of TLS protocol
-     *
-     * @param packet First packet bytes
-     * @return true for TLS protocol
-     */
-    private static boolean isTlsProtocol(byte[] packet) {
-        // First byte: handshake type
-        // Second and third bytes: TLS version (using 1.0)
-        return (packet[0] & 0xff) == 0x16 &&
-                (packet[1] & 0xff) == 0x03 &&
-                (packet[2] & 0xff) == 0x01;
-    }
-
-    /**
-     * Checks first TCP packet - if it is a HTTP protocol or not
-     *
-     * @param packet First packet bytes
-     * @return true for HTTP
-     */
-    private static boolean isHttpProtocol(byte[] packet) {
-        if (packet == null || packet.length == 0) {
-            return false;
-        }
-
-        int firstLineIndex = ArrayUtils.indexOf(packet, (byte) IoUtils.LF);
-
-        // Minimum line length: "GET / HTTP/1.1" is 14 symbols
-        if (firstLineIndex >= 14) {
-            // We have a line in first packet, so we should check HTTP version
-            // That must have been at the end of line
-            String line = new String(packet, firstLineIndex - 10, 10, CharsetUtils.DEFAULT_HTTP_ENCODING);
-            return StringUtils.containsIgnoreCase(line, "HTTP/");
-        }
-        int firstSpaceIndex = ArrayUtils.indexOf(packet, (byte) IoUtils.SP);
-        // Maybe packet was too small for whole packet to come in.
-        // So we should check for valid HTTP method
-        if (firstSpaceIndex <= 0) {
-            return false;
-        }
-
-        String method = (new String(packet, 0, firstSpaceIndex)).trim().toUpperCase();
-        return HttpMethod.isValidMethod(method);
-    }
-
-    /**
-     * Peeks first N non-empty bytes from a peeking stream.
-     *
-     * @param inputStream Input stream
-     * @param length      Length of the non-empty fragment we need
-     * @return First non-empty bytes read or null if there is no fragment of the specified length
-     */
-    private static byte[] peekFirstNotEmptyBytes(InputStream inputStream, int length) throws IOException {
-
-        final int markLength = 32 * 1024;
-        int bytesRead = 0;
-        int bytesFound = 0;
-        byte[] firstBytes = new byte[length];
-        byte[] buffer = new byte[512];
-
-        inputStream.mark(markLength);
-        try {
-            while (bytesRead < markLength) {
-                int bytesMarked = IOUtils.read(inputStream, buffer);
-
-                // if stream is finished and we still didn't read the array of length we need
-                if (bytesMarked <= 0) return null;
-                bytesRead += bytesMarked;
-
-                for (int i = 0; i < bytesMarked; i++) {
-                    byte b = buffer[i];
-                    boolean empty = IoUtils.isEmptyOrWhitespace(b) || IoUtils.isBomByte(b);
-                    // bytesFound > 0 means that we have already found first non-empty character
-                    // we also ignore zero byte to handle UTF-16
-                    if ((!empty || bytesFound > 0) && b != 0) {
-                        firstBytes[bytesFound] = b;
-                        bytesFound++;
-                    }
-
-                    if (bytesFound == firstBytes.length) {
-                        // Found enough bytes
-                        return firstBytes;
-                    }
-                }
-
-                // End of stream and we have not found enough bytes
-                if (bytesMarked < buffer.length) {
-                    return null;
-                }
-            }
-        } finally {
-            inputStream.reset();
-        }
-
-        return null;
-    }
-
-    /**
-     * Searches for a substring in a byte array (ignoring characters case)
-     *
-     * @param bytes            Byte array to search in
-     * @param searchStartIndex Index in the byte array (to start searching from that index)
-     * @param searchString     Search string
-     * @return true if substring was found
-     */
-    private static boolean findStringIgnoreCase(byte[] bytes, int searchStartIndex, String searchString) {
-        if ((bytes.length - searchStartIndex) < searchString.length()) {
-            return false;
-        }
-
-        for (int i = 0; i < searchString.length(); i++) {
-            char c = searchString.charAt(i);
-            byte b = bytes[i + searchStartIndex];
-            if (b != c && b != Character.toUpperCase(c)) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    /**
-     * Protocols enumeration
-     */
-    public enum Protocol {
-
-        /**
-         * Plain HTTP protocol
-         */
-        HTTP,
-
-        /**
-         * TLS
-         */
-        TLS,
-
-        /**
-         * Other protocol
-         */
-        OTHER,
-
-        /**
-         * Cannot detect protocol because first packet is too small
-         */
-        TOO_SMALL
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/rules/ContentFilterRule.java b/adguard_cb/src/main/java/com/adguard/filter/rules/ContentFilterRule.java
deleted file mode 100644
index 86f1990..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/rules/ContentFilterRule.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.rules;
-
-import com.adguard.commons.lang.Wildcard;
-
-import org.apache.commons.lang3.StringUtils;
-import org.apache.commons.lang3.math.NumberUtils;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-/**
- * Rule for filtering content.
- * <br/>
- * Rule text format:
- * <br/>
- * [domains]$$tagname[attr1="value1"][attr2="value2"][tag-content="value3"]
- * <br/>
- * <strong>domains</strong> coma-separated list, specifies domains where this rule should be used.
- * <br/>
- * if [domains] is not set - rule is used for all domains.
- * <br/>
- * You can specify ~domainname1 to disable domainname1.
- * <br/>
- * <strong>tagname</strong> - html tag name
- * <br/>
- * <strong>attr1</strong> - tag attribute name
- * <br/>
- * <strong>value1</strong> - tag attribute value
- * <br/>
- * <strong>tag-content</strong> - specifies mask for content of tag
- * <br/>
- * <strong>value3</strong> - content value
- */
-public class ContentFilterRule extends FilterRule {
-
-    public static final String ATTRIBUTE_START_MARK = "[";
-    public static final String ATTRIBUTE_END_MARK = "]";
-    public static final String QUOTES = "\"";
-    public static final String TAG_CONTENT_MASK = "tag-content";
-    public static final String WILDCARD_MASK = "wildcard";
-    public static final String TAG_CONTENT_MAX_LENGTH = "max-length";
-    public static final String TAG_CONTENT_MIN_LENGTH = "min-length";
-    public static final String PARENT_ELEMENTS = "parent-elements";
-    public static final String PARENT_SEARCH_LEVEL = "parent-search-level";
-    public static final int DEFAULT_PARENT_SEARCH_LEVEL = 3;
-
-    private final String tagName;
-    private final Map<String, String> attributesFilter = new HashMap<>();
-    private String tagContentFilter;
-    private int maxLength;
-    private int minLength;
-    private List<String> parentElements;
-    private int parentSearchLevel;
-    private Wildcard wildcard;
-
-    /**
-     * Creates an instance of the ContentFilterRule from its text format
-     *
-     * @param ruleText Rule text
-     */
-    protected ContentFilterRule(String ruleText) {
-        super(ruleText);
-
-        parentSearchLevel = DEFAULT_PARENT_SEARCH_LEVEL;
-
-        int contentRuleMarkIndex = StringUtils.indexOf(ruleText, MASK_CONTENT_RULE);
-        int ruleStartIndex = StringUtils.indexOf(ruleText, ATTRIBUTE_START_MARK);
-
-        // Cutting tag name from string
-        if (ruleStartIndex == -1) {
-            tagName = ruleText.substring(contentRuleMarkIndex + MASK_CONTENT_RULE.length());
-        } else {
-            tagName = ruleText.substring(contentRuleMarkIndex + MASK_CONTENT_RULE.length(), ruleStartIndex);
-        }
-
-        // Loading domains (if any))
-        if (contentRuleMarkIndex > 0) {
-            String domains = ruleText.substring(0, contentRuleMarkIndex);
-            loadDomains(domains);
-        }
-
-        // Loading attributes filter
-        while (ruleStartIndex != -1) {
-            int equalityIndex = ruleText.indexOf(EQUAL, ruleStartIndex + 1);
-            int quoteStartIndex = ruleText.indexOf(QUOTES, equalityIndex + 1);
-            int quoteEndIndex = getQuoteIndex(ruleText, quoteStartIndex + 1);
-            if (quoteStartIndex == -1 || quoteEndIndex == -1) {
-                break;
-            }
-            int ruleEndIndex = ruleText.indexOf(ATTRIBUTE_END_MARK, quoteEndIndex + 1);
-
-            String attributeName = ruleText.substring(ruleStartIndex + 1, equalityIndex);
-            String attributeValue = ruleText.substring(quoteStartIndex + 1, quoteEndIndex);
-            attributeValue = StringUtils.replace(attributeValue, "\"\"", "\"");
-
-            switch (attributeName) {
-                case TAG_CONTENT_MASK:
-                    tagContentFilter = attributeValue;
-                    break;
-                case WILDCARD_MASK:
-                    wildcard = new Wildcard(attributeValue, Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
-                    break;
-                case TAG_CONTENT_MAX_LENGTH:
-                    maxLength = NumberUtils.toInt(attributeValue);
-                    break;
-                case TAG_CONTENT_MIN_LENGTH:
-                    minLength = NumberUtils.toInt(attributeValue);
-                    break;
-                case PARENT_ELEMENTS:
-                    parentElements = Arrays.asList(StringUtils.split(attributeValue, ','));
-                    break;
-                case PARENT_SEARCH_LEVEL:
-                    parentSearchLevel = NumberUtils.toInt(attributeValue);
-                    break;
-                default:
-                    attributesFilter.put(attributeName, attributeValue);
-                    break;
-            }
-
-            if (ruleEndIndex == -1) break;
-            ruleStartIndex = ruleText.indexOf(ATTRIBUTE_START_MARK, ruleEndIndex + 1);
-        }
-    }
-
-    public String getTagName() {
-        return tagName;
-    }
-
-    String getTagContentFilter() {
-        return tagContentFilter;
-    }
-
-    Map<String, String> getAttributesFilter() {
-        return attributesFilter;
-    }
-
-    int getMaxLength() {
-        return maxLength;
-    }
-
-    int getMinLength() {
-        return minLength;
-    }
-
-    public List<String> getParentElements() {
-        return parentElements;
-    }
-
-    public int getParentSearchLevel() {
-        return parentSearchLevel;
-    }
-
-    public Wildcard getWildcard() {
-        return wildcard;
-    }
-
-    private static int getQuoteIndex(String text, int startIndex) {
-        char nextChar = '"';
-        int quoteIndex = startIndex - 2;
-
-        while (nextChar == '"') {
-            quoteIndex = text.indexOf(QUOTES, quoteIndex + 2);
-            if (quoteIndex == -1) {
-                return -1;
-            }
-            nextChar = text.length() == (quoteIndex + 1) ? '0' : text.charAt(quoteIndex + 1);
-        }
-
-        return quoteIndex;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/rules/ContentType.java b/adguard_cb/src/main/java/com/adguard/filter/rules/ContentType.java
deleted file mode 100644
index 2c4b96e..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/rules/ContentType.java
+++ /dev/null
@@ -1,234 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.rules;
-
-import com.adguard.filter.html.HtmlElements;
-import org.apache.commons.lang3.StringUtils;
-import org.slf4j.LoggerFactory;
-
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Content type
- */
-public enum ContentType {
-
-    /**
-     * No content type
-     */
-    NONE(0),
-
-    /**
-     * All except listed below
-     */
-    OTHER(1),
-
-    /**
-     * Image (png/jpg/jpeg etc)
-     */
-    IMAGE(2),
-
-    /**
-     * Javascript (or any other script)
-     */
-    SCRIPT(4),
-
-    /**
-     * Requests for CSS
-     */
-    STYLE(8),
-
-    /**
-     * Object (swf/flash/plugins)
-     */
-    OBJECT(16),
-
-    /**
-     * Ajax requests. We use X-Requested-With header to check if request is Ajax.
-     * Although remember, that this header is not always set (only if jquery is used).
-     */
-    XML_HTTP_REQUEST(32),
-
-    /**
-     * Media files (mp3, mp4, avi and such)
-     */
-    MEDIA(64),
-
-    /**
-     * Fonts (detected by file extension)
-     */
-    FONT(128),
-
-    /**
-     * Html document
-     */
-    DOCUMENT(256),
-
-    /**
-     * Requests sent from a plugin objects (flash, etc)
-     */
-    OBJECT_SUBREQUEST(512),
-
-    /**
-     * Any content type
-     */
-    ANY(OTHER.flagValue | IMAGE.flagValue | SCRIPT.flagValue | STYLE.flagValue |
-            OBJECT.flagValue | XML_HTTP_REQUEST.flagValue | MEDIA.flagValue | FONT.flagValue |
-            DOCUMENT.flagValue | OBJECT_SUBREQUEST.flagValue);
-
-    private static final Map<String, ContentType> FILE_EXTENSION_CONTENT_TYPE = new HashMap<>();
-    private static final Map<String, ContentType> HTML_ELEMENTS_CONTENT_TYPE = new HashMap<>();
-
-    static {
-        FILE_EXTENSION_CONTENT_TYPE.put(".js", SCRIPT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".json", SCRIPT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".vbs", SCRIPT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".coffee", SCRIPT);
-
-        FILE_EXTENSION_CONTENT_TYPE.put(".jpg", IMAGE);
-        FILE_EXTENSION_CONTENT_TYPE.put(".jpeg", IMAGE);
-        FILE_EXTENSION_CONTENT_TYPE.put(".gif", IMAGE);
-        FILE_EXTENSION_CONTENT_TYPE.put(".png", IMAGE);
-        FILE_EXTENSION_CONTENT_TYPE.put(".tiff", IMAGE);
-        FILE_EXTENSION_CONTENT_TYPE.put(".psd", IMAGE);
-        FILE_EXTENSION_CONTENT_TYPE.put(".ico", IMAGE);
-
-        FILE_EXTENSION_CONTENT_TYPE.put(".css", STYLE);
-        FILE_EXTENSION_CONTENT_TYPE.put(".less", STYLE);
-
-        FILE_EXTENSION_CONTENT_TYPE.put(".jar", OBJECT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".swf", OBJECT);
-
-        FILE_EXTENSION_CONTENT_TYPE.put(".wav", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".mp3", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".mp4", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".avi", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".flv", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".m3u", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".webm", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".mpeg", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".3gp", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".3g2", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".3gpp", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".3gpp2", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".ogg", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".mov", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".qt", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".vbm", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".mkv", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".webm", MEDIA);
-        FILE_EXTENSION_CONTENT_TYPE.put(".gifv", MEDIA);
-
-        FILE_EXTENSION_CONTENT_TYPE.put(".ttf", FONT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".otf", FONT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".woff", FONT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".woff2", FONT);
-        FILE_EXTENSION_CONTENT_TYPE.put(".eot", FONT);
-
-        HTML_ELEMENTS_CONTENT_TYPE.put(HtmlElements.SCRIPT, SCRIPT);
-        HTML_ELEMENTS_CONTENT_TYPE.put(HtmlElements.LINK, STYLE);
-        HTML_ELEMENTS_CONTENT_TYPE.put(HtmlElements.IMG, IMAGE);
-        HTML_ELEMENTS_CONTENT_TYPE.put(HtmlElements.OBJECT, OBJECT);
-        HTML_ELEMENTS_CONTENT_TYPE.put(HtmlElements.EMBED, OBJECT);
-        HTML_ELEMENTS_CONTENT_TYPE.put(HtmlElements.IFRAME, DOCUMENT);
-    }
-
-    /**
-     * Detects content type using request url
-     *
-     * @param url Url
-     * @return Content type detected
-     */
-    public static ContentType detectContentType(URL url) {
-        String path = url.getPath();
-
-        for (Map.Entry<String, ContentType> entry : FILE_EXTENSION_CONTENT_TYPE.entrySet()) {
-            if (StringUtils.endsWith(path, entry.getKey())) {
-                return entry.getValue();
-            }
-        }
-
-        return ContentType.OTHER;
-    }
-
-    /**
-     * Detects content type using request url
-     *
-     * @param url Url
-     * @return Content type detected
-     */
-    public static ContentType detectContentType(String url) {
-        try {
-            URL requestUrl = new URL(url);
-            return detectContentType(requestUrl);
-        } catch (Exception ex) {
-            LoggerFactory.getLogger(ContentType.class).debug(String.format("Error detecting content type for %s", url), ex);
-        }
-
-        return ContentType.OTHER;
-    }
-
-    /**
-     * Translates a set of ContentType enums into a numeric mask
-     *
-     * @param flags Set of ContentType enums
-     * @return numeric representation of the set
-     */
-    public static int getMask(Set<ContentType> flags) {
-        int mask = 0;
-
-        for (ContentType contentType : flags) {
-            mask |= contentType.getFlagValue();
-        }
-
-        return mask;
-    }
-
-    private final int flagValue;
-
-    ContentType(int flagValue) {
-        this.flagValue = flagValue;
-    }
-
-    /**
-     * @return Flag value (used to create mask)
-     */
-    public int getFlagValue() {
-        return flagValue;
-    }
-
-    /**
-     * Checks if response content type has one of the specified prefixes
-     *
-     * @param responseContentType Response content type
-     * @param contentTypes        Content types to check
-     * @return true if any of the prefixes match
-     */
-    private static boolean isContentType(String responseContentType, String... contentTypes) {
-
-        for (String contentType : contentTypes) {
-            if (StringUtils.startsWith(responseContentType, contentType)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/rules/CssFilterRule.java b/adguard_cb/src/main/java/com/adguard/filter/rules/CssFilterRule.java
deleted file mode 100644
index a063a28..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/rules/CssFilterRule.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.rules;
-
-import org.apache.commons.lang3.StringUtils;
-
-/**
- * Rule for adding CSS filters to page.
- * <br/>
- * There are two css rules type: black-list css rule, white-list css rule.
- * <br/>
- * <br/>
- * ------- Black list rule text format -------
- * <br/>
- * [domains]##[css selector]
- * <br/>
- * domains - coma-separated list, specifies domains where this CSS rule should be used.
- * if [domains] is not set - rule is used for all domains.
- * You can specify ~domainname1 to disable domainname1.
- * <br/>
- * <br/>
- * ------- White list rule text format -------
- * <br/>
- * [domains]#@#[css selector]
- * <br/>
- * domains - coma-separated list, specifies domains where target CSS rule should be used.
- * target rule css selector - css selector from rule to which this exception
- * <p/>
- * CSS inject rule type
- * <p/>
- * Rule for inject CSS style to page.
- * Exist two css inject rules type: black-list css rule, white-list css rule.
- * <p/>
- * ------- Black list rule text format -------
- * [domains]#$#[css selector] {css style}
- * domains - coma-separated list, specifies domains where this CSS inject rule should be used.
- * if [domains] is not set - rule is used for all domains.
- * You can specify ~domainname1 to disable domainname1.
- * <p/>
- * ------- White list rule text format -------
- * [domains]#@$#[css selector] {css style}
- * domains - coma-separated list, specifies domains where target CSS rule should be used.
- * css selector - css selector from rule to which this exception applied
- * css style - css selector from rule to which this exception applieds
- */
-public class CssFilterRule extends FilterRule {
-
-    private final String cssContent;
-    private final boolean styleInject;
-    private final boolean whiteListRule;
-
-    /**
-     * Creates CSS filter rule
-     *
-     * @param ruleText Rule text
-     */
-    public CssFilterRule(String ruleText) {
-        super(ruleText);
-
-        String mask;
-        boolean styleInject = false;
-        boolean whiteListRule = false;
-        if (StringUtils.contains(ruleText, MASK_CSS_INJECT_EXCEPTION_RULE)) {
-            mask = MASK_CSS_INJECT_EXCEPTION_RULE;
-            whiteListRule = true;
-            styleInject = true;
-        } else if (StringUtils.contains(ruleText, MASK_CSS_INJECT_RULE)) {
-            mask = MASK_CSS_INJECT_RULE;
-            styleInject = true;
-        } else if (StringUtils.contains(ruleText, MASK_CSS_EXCEPTION_RULE)) {
-            mask = MASK_CSS_EXCEPTION_RULE;
-            whiteListRule = true;
-        } else if (StringUtils.contains(ruleText, MASK_CSS_RULE)) {
-            mask = MASK_CSS_RULE;
-        } else {
-            throw new IllegalArgumentException("ruleText");
-        }
-
-        int indexOfMask = StringUtils.indexOf(ruleText, mask);
-        if (indexOfMask > 0) {
-            // domains are specified, parsing
-            String domains = StringUtils.substring(ruleText, 0, indexOfMask);
-            loadDomains(domains);
-        }
-
-        this.styleInject = styleInject;
-        this.whiteListRule = whiteListRule;
-        cssContent = ruleText.substring(indexOfMask + mask.length());
-    }
-
-    /**
-     * Css selector for blocked element (for standard css-rule)
-     * or css style for css-injection rules.
-     *
-     * @return Css content
-     */
-    public String getCssContent() {
-        return cssContent;
-    }
-
-    /**
-     * If true - this is white-list css rule.
-     *
-     * @return true for white-list css rules.
-     */
-    public boolean isWhiteListRule() {
-        return whiteListRule;
-    }
-
-    /**
-     * @return true if this is style injection rule
-     */
-    public boolean isStyleInject() {
-        return styleInject;
-    }
-}
\ No newline at end of file
diff --git a/adguard_cb/src/main/java/com/adguard/filter/rules/FilterRule.java b/adguard_cb/src/main/java/com/adguard/filter/rules/FilterRule.java
deleted file mode 100644
index bc9491a..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/rules/FilterRule.java
+++ /dev/null
@@ -1,371 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.rules;
-
-import com.adguard.commons.collections.Lists;
-import com.adguard.commons.web.UrlUtils;
-import org.apache.commons.collections4.CollectionUtils;
-import org.apache.commons.lang3.StringUtils;
-import org.slf4j.LoggerFactory;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * Base class for all filter rules
- */
-public abstract class FilterRule {
-
-    public static final int MIN_RULE_LENGTH = 4;
-    public static final String PARAMETER_START = "[";
-    public static final String PARAMETER_END = "]";
-    public static final String MASK_WHITE_LIST = "@@";
-    public static final String MASK_CONTENT_RULE = "$$";
-    public static final String MASK_CSS_RULE = "##";
-    public static final String MASK_CSS_EXCEPTION_RULE = "#@#";
-    public static final String MASK_CSS_INJECT_RULE = "#$#";
-    public static final String MASK_CSS_INJECT_EXCEPTION_RULE = "#@$#";
-    public static final String MASK_SCRIPT_RULE = "#%#";
-    public static final String COMMENT = "!";
-    public static final String EQUAL = "=";
-    public static final char COMA_DELIMITER = ',';
-    public static final char LINE_DELIMITER = '|';
-    public static final String NOT_MARK = "~";
-    public static final String MASK_OBSOLETE_SCRIPT_INJECTION = "###adg_start_script_inject";
-    public static final String MASK_OBSOLETE_STYLE_INJECTION = "###adg_start_style_inject";
-    public static final String META_START = "[";
-
-    private final String ruleText;
-    private List<String> permittedDomains;
-    private List<String> restrictedDomains;
-
-    /**
-     * Creates FilterRule text
-     *
-     * @param ruleText Rule text
-     */
-    protected FilterRule(String ruleText) {
-        if (StringUtils.isEmpty(ruleText)) {
-            throw new IllegalArgumentException("ruleText cannot be empty");
-        }
-
-        this.ruleText = ruleText;
-    }
-
-    /**
-     * Returns true if rule is CSS, JS or Content
-     *
-     * @param ruleText Rule text
-     * @return true if rule is CSS, JS or Content
-     */
-    public static boolean isCosmeticRule(String ruleText) {
-        return StringUtils.isEmpty(ruleText) ||
-                ruleText.contains(MASK_CSS_RULE) ||
-                ruleText.contains(MASK_CSS_EXCEPTION_RULE) ||
-                ruleText.contains(MASK_CSS_INJECT_RULE) ||
-                ruleText.contains(MASK_CSS_INJECT_EXCEPTION_RULE) ||
-                ruleText.contains(MASK_SCRIPT_RULE) ||
-                ruleText.contains(MASK_CONTENT_RULE);
-    }
-
-    /**
-     * Creates filter rule.
-     * If this rule text is not valid - returns null.
-     *
-     * @param ruleText Rule text
-     * @return Filter rule of the proper type
-     */
-    public static FilterRule createRule(String ruleText) {
-
-        ruleText = StringUtils.trim(ruleText);
-
-        if (StringUtils.isBlank(ruleText) ||
-                StringUtils.length(ruleText) < MIN_RULE_LENGTH ||
-                StringUtils.startsWith(ruleText, COMMENT) ||
-                StringUtils.startsWith(ruleText, META_START) ||
-                StringUtils.contains(ruleText, MASK_OBSOLETE_SCRIPT_INJECTION) ||
-                StringUtils.contains(ruleText, MASK_OBSOLETE_STYLE_INJECTION)) {
-            return null;
-        }
-
-        try {
-            if (StringUtils.startsWith(ruleText, MASK_WHITE_LIST)) {
-                return new UrlFilterRule(ruleText);
-            }
-
-            if (StringUtils.contains(ruleText, MASK_CONTENT_RULE)) {
-                return new ContentFilterRule(ruleText);
-            }
-
-            if (StringUtils.contains(ruleText, MASK_CSS_RULE) ||
-                    StringUtils.contains(ruleText, MASK_CSS_EXCEPTION_RULE) ||
-                    StringUtils.contains(ruleText, MASK_CSS_INJECT_RULE) ||
-                    StringUtils.contains(ruleText, MASK_CSS_INJECT_EXCEPTION_RULE)) {
-                return new CssFilterRule(ruleText);
-            }
-
-            if (StringUtils.contains(ruleText, MASK_SCRIPT_RULE)) {
-                return new ScriptFilterRule(ruleText);
-            }
-
-            return new UrlFilterRule(ruleText);
-        } catch (Exception ex) {
-            LoggerFactory.getLogger(FilterRule.class).warn("Error creating filter rule {}:\r\n{}", ruleText, ex);
-            return null;
-        }
-    }
-
-    /**
-     * Gets rule text
-     *
-     * @return Rule text
-     */
-    public String getRuleText() {
-        return ruleText;
-    }
-
-    /**
-     * Gets list of domains this rule is permitted on
-     *
-     * @return List of permitted domains
-     */
-    public List<String> getPermittedDomains() {
-        return permittedDomains;
-    }
-
-    /**
-     * Gets list of domains this rule is restricted on
-     *
-     * @return List of restricted domains
-     */
-    public List<String> getRestrictedDomains() {
-        return restrictedDomains;
-    }
-
-    /**
-     * Generic filter rules count as rules that:
-     * <br/>
-     * 1. Do not have a domain specified. "Hide this element on all domains"
-     * <br/>
-     * 2. Have only domain exceptions specified. "Hide this element on all domains except example.com"
-     * <br/>
-     * ~example.com##.ad
-     * ||example.com^$third-party
-     *
-     * @return true if this rule is generic
-     */
-    public boolean isGeneric() {
-        return CollectionUtils.isEmpty(permittedDomains);
-    }
-
-    /**
-     * Checks if this rule is domain sensitive or not
-     *
-     * @return true if rule has permitted or restricted domains
-     */
-    public boolean isDomainSensitive() {
-        return CollectionUtils.isNotEmpty(permittedDomains) ||
-                CollectionUtils.isNotEmpty(restrictedDomains);
-    }
-
-    /**
-     * Checks if this rule is permitted for the specified domain
-     *
-     * @param domainName Domain name
-     * @return true if rule is permitted
-     */
-    public boolean isPermitted(String domainName) {
-        if (StringUtils.isEmpty(domainName)) {
-            return false;
-        }
-
-        if (UrlUtils.isDomainOrSubDomain(domainName, restrictedDomains)) {
-            return false;
-        }
-
-        //noinspection SimplifiableIfStatement
-        if (CollectionUtils.isNotEmpty(permittedDomains)) {
-            // If permitted domains set -- this rule work for permitted domains ONLY
-            return UrlUtils.isDomainOrSubDomain(domainName, permittedDomains);
-        }
-
-        return true;
-    }
-
-    /**
-     * Loads PermittedDomains and RestrictedDomains collections
-     * from the rule text
-     *
-     * @param domains Domains part of the rule text
-     */
-    protected void loadDomains(String domains) {
-        if (StringUtils.isEmpty(domains)) {
-            return;
-        }
-
-        String[] parts = StringUtils.split(domains, new String(new char[]{COMA_DELIMITER, LINE_DELIMITER}));
-
-        try {
-            for (String domain : parts) {
-                if (StringUtils.startsWith(domain, NOT_MARK)) {
-                    String domainName = toPunycode(domain.substring(1).trim());
-                    if (StringUtils.isNotEmpty(domainName)) {
-                        addRestrictedDomain(domainName);
-                    }
-                } else {
-                    String domainName = toPunycode(domain.trim());
-                    if (StringUtils.isNotEmpty(domainName)) {
-                        addPermittedDomain(domainName);
-                    }
-                }
-            }
-        } catch (Exception ex) {
-            LoggerFactory.getLogger(this.getClass()).error("Error while loading domains from " + domains, ex);
-        }
-    }
-
-    /**
-     * Removes specified domain from the list of permitted.
-     *
-     * @param domainName Domain to remove
-     * @return true if domain was removed successfully
-     */
-    public boolean removePermittedDomain(String domainName) {
-        return Lists.remove(permittedDomains, domainName);
-    }
-
-    /**
-     * Removes specified domains from the list of permitted
-     *
-     * @param domainNames Collection of domain names to remove
-     */
-    public void removePermittedDomains(Collection<String> domainNames) {
-        Lists.removeAll(permittedDomains, domainNames);
-    }
-
-    /**
-     * Adds specified domain name to the list of permitted domains
-     *
-     * @param domainName Domain to add
-     */
-    public void addPermittedDomain(String domainName) {
-        if (StringUtils.isEmpty(domainName)) {
-            return;
-        }
-        if (permittedDomains == null) {
-            permittedDomains = new ArrayList<>();
-        }
-        permittedDomains.add(domainName);
-    }
-
-    /**
-     * Adds specified domains to the list of permitted domains
-     *
-     * @param domainNames Domains to add
-     */
-    public void addPermittedDomains(Collection<String> domainNames) {
-        if (domainNames == null) {
-            return;
-        }
-        for (String domainName : domainNames) {
-            addPermittedDomain(domainName);
-        }
-    }
-
-    /**
-     * Removes the specified domain from the list of restricted
-     *
-     * @param domainName Domain to remove
-     * @return true if domain has been removed
-     */
-    public boolean removeRestrictedDomain(String domainName) {
-        return Lists.remove(restrictedDomains, domainName);
-    }
-
-    /**
-     * Removes specified domains from the list of restricted
-     *
-     * @param domainNames Domains to remove
-     */
-    public void removeRestrictedDomains(Collection<String> domainNames) {
-        Lists.removeAll(restrictedDomains, domainNames);
-    }
-
-    /**
-     * Adds specified domain name to the list of restricted domains
-     *
-     * @param domainName Domain name to restrict
-     */
-    public void addRestrictedDomain(String domainName) {
-        if (StringUtils.isEmpty(domainName)) {
-            return;
-        }
-        if (restrictedDomains == null) {
-            restrictedDomains = new ArrayList<>();
-        }
-        restrictedDomains.add(domainName);
-    }
-
-    /**
-     * Adds specified domains to the list of restricted domains
-     *
-     * @param domainNames Domain names too restict
-     */
-    public void addRestrictedDomains(Collection<String> domainNames) {
-        if (domainNames == null) {
-            return;
-        }
-        for (String domainName : domainNames) {
-            addRestrictedDomain(domainName);
-        }
-    }
-
-    @Override
-    public String toString() {
-        return getRuleText();
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        FilterRule that = (FilterRule) o;
-        String ruleText = getRuleText();
-        return !(ruleText != null ? !ruleText.equals(that.getRuleText()) : that.getRuleText() != null);
-    }
-
-    @Override
-    public int hashCode() {
-        return getRuleText() != null ? getRuleText().hashCode() : 0;
-    }
-
-    /**
-     * Transforms domain name to punycode if needed
-     *
-     * @param domainName Domain name
-     * @return Domain name in punycode
-     */
-    private static String toPunycode(String domainName) {
-        if (UrlUtils.isASCII(domainName)) {
-            return domainName;
-        }
-
-        return UrlUtils.toPunycode(domainName);
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/rules/ScriptFilterRule.java b/adguard_cb/src/main/java/com/adguard/filter/rules/ScriptFilterRule.java
deleted file mode 100644
index 74cf738..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/rules/ScriptFilterRule.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.rules;
-
-import org.apache.commons.lang3.StringUtils;
-
-/**
- * Special type of rule supporting javascript injections.
- * Example of this rule is:<br/>
- * #%#window.gapi={ plusone: { go: function(){}, render: function(){} }};
- */
-public class ScriptFilterRule extends FilterRule {
-
-    private final String scriptText;
-
-    /**
-     * Creates FilterRule text
-     *
-     * @param ruleText Rule text
-     */
-    protected ScriptFilterRule(String ruleText) {
-        super(ruleText);
-
-        int indexOfMask = StringUtils.indexOf(ruleText, MASK_SCRIPT_RULE);
-
-        // Loading domains (if any))
-        if (indexOfMask > 0) {
-            String domains = ruleText.substring(0, indexOfMask);
-            loadDomains(domains);
-        }
-
-        scriptText = ruleText.substring(indexOfMask + MASK_SCRIPT_RULE.length());
-    }
-
-    /**
-     * @return Javascript text
-     */
-    public String getScriptText() {
-        return scriptText;
-    }
-}
diff --git a/adguard_cb/src/main/java/com/adguard/filter/rules/UrlFilterRule.java b/adguard_cb/src/main/java/com/adguard/filter/rules/UrlFilterRule.java
deleted file mode 100644
index adc950d..0000000
--- a/adguard_cb/src/main/java/com/adguard/filter/rules/UrlFilterRule.java
+++ /dev/null
@@ -1,823 +0,0 @@
-/**
- This file is part of Adguard Content Blocker (https://github.com/AdguardTeam/ContentBlocker).
- Copyright © 2016 Performix LLC. All rights reserved.
-
- Adguard Content Blocker is free software: you can redistribute it and/or modify
- it under the terms of the GNU General Public License as published by the
- Free Software Foundation, either version 3 of the License, or (at your option)
- any later version.
-
- Adguard Content Blocker is distributed in the hope that it will be useful,
- but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-
- You should have received a copy of the GNU General Public License along with
- Adguard Content Blocker.  If not, see <http://www.gnu.org/licenses/>.
- */
-package com.adguard.filter.rules;
-
-import com.adguard.commons.lang.StringHelperUtils;
-import com.adguard.commons.web.UrlUtils;
-import org.apache.commons.collections4.CollectionUtils;
-import org.apache.commons.lang3.StringUtils;
-import org.slf4j.LoggerFactory;
-
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.regex.Pattern;
-
-/**
- * Rule for blocking requests to URLs.<br/>
- * Rule text format is described here: http://adguard.com/en/filterrules.html
- */
-public class UrlFilterRule extends FilterRule {
-
-    public static final int SHORTCUT_LENGTH = 6;
-    public static final String OPTIONS_DELIMITER = "$";
-    public static final String DOMAIN_OPTION = "domain";
-    public static final String THIRD_PARTY_OPTION = "third-party";
-    public static final String MATCH_CASE_OPTION = "match-case";
-    public static final String DOCUMENT_OPTION = "document";
-    public static final String ELEMHIDE_OPTION = "elemhide";
-    public static final String URLBLOCK_OPTION = "urlblock";
-    public static final String JSINJECT_OPTION = "jsinject";
-    public static final String CONTENT_OPTION = "content";
-    public static final String GENERIC_HIDE_OPTION = "generichide";
-    public static final String GENERIC_BLOCK_OPTION = "genericblock";
-    public static final String POPUP_OPTION = "popup";
-    public static final String MP4_OPTION = "mp4";
-    public static final String EMPTY_OPTION = "empty";
-
-    public static final String CONTENT_SCRIPT_OPTION = "script";
-    public static final String CONTENT_IMAGE_OPTION = "image";
-    public static final String CONTENT_STYLESHEET_OPTION = "stylesheet";
-    public static final String CONTENT_OBJECT_OPTION = "object";
-    public static final String CONTENT_SUBDOCUMENT_OPTION = "subdocument";
-    public static final String CONTENT_XMLHTTPREQUEST_OPTION = "xmlhttprequest";
-    public static final String CONTENT_OBJECT_SUBREQUEST = "object-subrequest";
-    public static final String CONTENT_MEDIA_OPTION = "media";
-    public static final String CONTENT_FONT_OPTION = "font";
-    public static final String CONTENT_OTHER_OPTION = "other";
-
-    public static final String MASK_REGEX_RULE = "/";
-    public static final String MASK_START_URL = "||";
-    public static final String MASK_PIPE = "|";
-    public static final String MASK_ANY_SYMBOL = "*";
-    public static final String MASK_SEPARATOR = "^";
-    public static final String REGEXP_START_URL = "^https?://([a-z0-9-_.]+\\.)?";
-    public static final String REGEXP_ANY_SYMBOL = ".*";
-    public static final String REGEXP_START_STRING = "^";
-    public static final String REGEXP_SEPARATOR = "([^ a-zA-Z0-9.%]|$)";
-    public static final String REGEXP_END_STRING = "$";
-
-    private static final List<String> IGNORED_OPTIONS =
-            Arrays.asList("collapse",
-                    "~collapse",
-                    "background",
-                    "~background",
-                    "~document");
-
-    private boolean whiteListRule;
-    private boolean documentLevelRule;
-
-    private int permittedContentTypesMask = ContentType.ANY.getFlagValue();
-    private int restrictedContentTypesMask;
-    private EnumSet<UrlFilterRuleOption> enabledOptions;
-    private EnumSet<UrlFilterRuleOption> disabledOptions;
-
-    private String shortcut;
-    private Pattern urlRegexp;
-    private String regex;
-    private boolean invalidRule;
-
-    /**
-     * Creates url filter rule
-     *
-     * @param ruleText Rule text
-     */
-    public UrlFilterRule(String ruleText) {
-        super(ruleText);
-
-        String urlRuleText = ruleText;
-
-        if (StringUtils.startsWith(urlRuleText, MASK_WHITE_LIST)) {
-            urlRuleText = urlRuleText.substring(MASK_WHITE_LIST.length());
-            whiteListRule = true;
-        }
-
-        int optionsIndex = StringUtils.lastIndexOf(urlRuleText, OPTIONS_DELIMITER);
-        if (optionsIndex > -1) {
-            urlRuleText = urlRuleText.substring(0, optionsIndex);
-        }
-
-        // Transform to punycode
-        urlRuleText = toPunycode(urlRuleText);
-
-        // More about regex rules http://jira.performix.ru/browse/AG-6604
-        boolean regexRule = urlRuleText.startsWith(MASK_REGEX_RULE) && urlRuleText.endsWith(MASK_REGEX_RULE);
-        if (!regexRule) {
-            // Searching for shortcut for normal rules
-            shortcut = findShortcut(urlRuleText);
-        }
-    }
-
-    /**
-     * Checks request url against this filter rule.
-     * Detects content type from the URL.
-     *
-     * @param requestUrl Request URL
-     * @param thirdParty true for third-party request
-     * @return true if request is filtered
-     */
-    public boolean isFiltered(String requestUrl, boolean thirdParty) {
-        return isFiltered(requestUrl, thirdParty, EnumSet.of(ContentType.detectContentType(requestUrl)));
-    }
-
-    /**
-     * Checks request url against filter
-     *
-     * @param requestUrl   Request url
-     * @param thirdParty   Is request third party or not
-     * @param contentTypes Request content types mask
-     * @return true if request url matches this rule
-     */
-    public boolean isFiltered(String requestUrl, boolean thirdParty, EnumSet<ContentType> contentTypes) {
-        // Lazy loading rule properties
-        loadRuleProperties();
-
-        if (isOptionEnabled(UrlFilterRuleOption.THIRD_PARTY) && !thirdParty) {
-            // Rule is with $third-party modifier but request is not third party
-            return false;
-        }
-
-        if (isOptionDisabled(UrlFilterRuleOption.THIRD_PARTY) && thirdParty) {
-            // Rule is with $~third-party modifier but request is third party
-            return false;
-        }
-
-        if (shortcut != null && !StringHelperUtils.containsIgnoreCaseAscii(requestUrl, shortcut)) {
-            return false;
-        }
-
-        Pattern pattern = getUrlRegexp();
-        if (pattern == null || !pattern.matcher(requestUrl).find()) {
-            // Request does not match regexp - returning false
-            return false;
-        }
-
-        // Last check -- content type
-        return matchesContentType(contentTypes);
-    }
-
-    @Override
-    public List<String> getPermittedDomains() {
-        // Lazy loading rule properties
-        loadRuleProperties();
-        return super.getPermittedDomains();
-    }
-
-    /**
-     * There are two exceptions for domain permitting in url blocking rules.
-     * White list rules must fire when request has no referrer.
-     * Also rules without third-party option should fire.
-     *
-     * @param domainName Domain name
-     * @return true if permitted
-     */
-    @Override
-    public boolean isPermitted(String domainName) {
-        // Lazy loading rule properties
-        loadRuleProperties();
-
-        if (StringUtils.isEmpty(domainName)) {
-            // For white list rules to fire when request has no referrer
-            if (whiteListRule && CollectionUtils.isEmpty(getPermittedDomains())) {
-                return true;
-            }
-
-            // Also firing rules when there's no constraint on ThirdParty-FirstParty type
-            if (CollectionUtils.isEmpty(getPermittedDomains()) &&
-                    !isOptionEnabled(UrlFilterRuleOption.THIRD_PARTY) &&
-                    !isOptionDisabled(UrlFilterRuleOption.THIRD_PARTY)) {
-                return true;
-            }
-        }
-
-        return super.isPermitted(domainName);
-    }
-
-    /**
-     * Returns true if this rule can be applied to DOCUMENT only.
-     * Examples: $popup, $elemhide and such.
-     * Such rules have higher priority than common rules.
-     *
-     * @return true for document-level rules
-     */
-    public boolean isDocumentLevel() {
-        loadRuleProperties();
-        return documentLevelRule;
-    }
-
-    @Override
-    public boolean isGeneric() {
-        // Overriding generic because UrlFilterRule properties are loaded lazily
-        loadRuleProperties();
-        return super.isGeneric();
-    }
-
-    /**
-     * @return true if this is whitelist rule
-     */
-    public boolean isWhiteListRule() {
-        return whiteListRule;
-    }
-
-    /**
-     * True if this filter should check if request is third- or first-party.
-     *
-     * @return True if we should check third party property
-     */
-    public boolean isCheckThirdParty() {
-        return isOptionEnabled(UrlFilterRuleOption.THIRD_PARTY) ||
-                isOptionDisabled(UrlFilterRuleOption.THIRD_PARTY);
-    }
-
-    /**
-     * If true - filter is only applied to requests from
-     * a different origin that the currently viewed page.
-     *
-     * @return If true - filter third-party requests only
-     */
-    public boolean isThirdParty() {
-        if (isOptionEnabled(UrlFilterRuleOption.THIRD_PARTY)) {
-            return true;
-        }
-
-        if (isOptionDisabled(UrlFilterRuleOption.THIRD_PARTY)) {
-            return false;
-        }
-
-        return false;
-    }
-
-    /**
-     * If true - do not apply generic UrlFilter rules to the web page.
-     *
-     * @return true if generic url rules should not be applied.
-     */
-    public boolean isGenericBlock() {
-        return isOptionEnabled(UrlFilterRuleOption.GENERIC_BLOCK);
-    }
-
-    /**
-     * If true - do not apply generic CSS rules to the web page.
-     *
-     * @return true if generic CSS rules should not be applied.
-     */
-    public boolean isGenericHide() {
-        return isOptionEnabled(UrlFilterRuleOption.GENERIC_HIDE);
-    }
-
-    /**
-     * If true -- CssFilter cannot be applied to page
-     *
-     * @return true if CssFilter cannot be applied to page
-     */
-    public boolean isElemhide() {
-        return isOptionEnabled(UrlFilterRuleOption.ELEMHIDE);
-    }
-
-    /**
-     * If true -- ContentFilter rules cannot be applied to page matching this rule.
-     *
-     * @return true if ContentFilter should not be applied to page matching this rule.
-     */
-    public boolean isContent() {
-        return isOptionEnabled(UrlFilterRuleOption.CONTENT);
-    }
-
-    /**
-     * Does not inject adguard javascript to page
-     *
-     * @return If true - we do not inject adguard js to page matching this rule
-     */
-    public boolean isJsInject() {
-        return isOptionEnabled(UrlFilterRuleOption.JS_INJECT);
-    }
-
-    /**
-     * If rule is case sensitive returns true
-     *
-     * @return true if rule is case sensitive
-     */
-    public boolean isMatchCase() {
-        return isOptionEnabled(UrlFilterRuleOption.MATCH_CASE);
-    }
-
-    /**
-     * This attribute is only for exception rules. If true - do not use
-     * url blocking rules for urls where referrer satisfies this rule.
-     *
-     * @return If true - do not block requests originated from the page matching this rule.
-     */
-    public boolean isUrlBlock() {
-        return isOptionEnabled(UrlFilterRuleOption.URL_BLOCK);
-    }
-
-    /**
-     * If BlockPopups is true, than window should be closed
-     * instead of returning http status 204.
-     *
-     * @return true if window should be closed
-     */
-    public boolean isBlockPopups() {
-        return isOptionEnabled(UrlFilterRuleOption.BLOCK_POPUPS);
-    }
-
-    /**
-     * If mp4 is true than Adguard will return mp4 video stub
-     *
-     * @return true if $mp4 option is enabled
-     */
-    public boolean isMp4() {
-        return isOptionEnabled(UrlFilterRuleOption.MP4);
-    }
-
-    /**
-     * If empty is true than Adguard will return empty response
-     * when request is blocked by such rule
-     *
-     * @return true if $empty option is enabled
-     */
-    public boolean isEmptyResponse() {
-        return isOptionEnabled(UrlFilterRuleOption.EMPTY_RESPONSE);
-    }
-
-    /**
-     * Rule shortcut. Used for contentblocker rule search.
-     * Look at ShortcutsLookupTable for details.
-     *
-     * @return Shortcut
-     */
-    public String getShortcut() {
-        return shortcut;
-    }
-
-    /**
-     * Url regular expression
-     *
-     * @return Regexp
-     */
-    public synchronized Pattern getUrlRegexp() {
-        if (invalidRule) {
-            return null;
-        }
-
-        loadRuleProperties();
-
-        if (urlRegexp == null) {
-
-            int regexOptions = Pattern.DOTALL;
-            if (!isOptionEnabled(UrlFilterRuleOption.MATCH_CASE)) {
-                regexOptions = regexOptions | Pattern.CASE_INSENSITIVE;
-            }
-            urlRegexp = Pattern.compile(regex, regexOptions);
-            regex = null;
-        }
-
-        return urlRegexp;
-    }
-
-    /**
-     * Loads rule properties lazily
-     */
-    private synchronized void loadRuleProperties() {
-        try {
-            if (regex != null || urlRegexp != null || invalidRule) {
-                // Rule is already loaded
-                return;
-            }
-
-            String urlRuleText = getRuleText();
-
-            if (StringUtils.startsWith(urlRuleText, MASK_WHITE_LIST)) {
-                urlRuleText = urlRuleText.substring(MASK_WHITE_LIST.length());
-            }
-
-            int optionsIndex = StringUtils.lastIndexOf(urlRuleText, OPTIONS_DELIMITER);
-            if (optionsIndex > -1) {
-                // Options are specified, parsing it
-                String optionsBase = urlRuleText;
-                urlRuleText = urlRuleText.substring(0, optionsIndex);
-                String options = optionsBase.substring(optionsIndex + 1);
-                loadOptions(options);
-            }
-
-            // Transform to punycode
-            urlRuleText = toPunycode(urlRuleText);
-
-            boolean regexRule = urlRuleText.startsWith(MASK_REGEX_RULE) && urlRuleText.endsWith(MASK_REGEX_RULE);
-            if (regexRule) {
-                regex = urlRuleText.substring(MASK_REGEX_RULE.length(), urlRuleText.length() - MASK_REGEX_RULE.length());
-                // Pre-compile regex rules
-                Pattern pattern = getUrlRegexp();
-                if (pattern == null) {
-                    throw new IllegalArgumentException("ruleText");
-                }
-            } else {
-                regex = createRegexFromRule(urlRuleText);
-            }
-        } catch (Exception ex) {
-            LoggerFactory.getLogger(this.getClass()).warn("Invalid filter rule: {}\r\n", getRuleText(), ex);
-            invalidRule = true;
-        }
-    }
-
-    /**
-     * Creates regexp from url rule text
-     *
-     * @param urlRuleText Url rule text
-     * @return Regexp
-     */
-    private String createRegexFromRule(String urlRuleText) {
-        // Replacing regex special symbols
-        String regexText = StringUtils.replaceEach(urlRuleText,
-                new String[]{"?", ".", "+", "[", "]", "(", ")", "{", "}", "#", " ", "\\", "$"},
-                new String[]{"\\?", "\\.", "\\+", "\\[", "\\]", "\\(", "\\)", "\\{", "\\}", "\\#", "\\ ", "\\\\", "\\$"});
-
-        regexText = regexText.substring(0, MASK_START_URL.length()) +
-                StringUtils.replace(regexText.substring(MASK_START_URL.length(), regexText.length() - 1), "|", "\\|") +
-                regexText.substring(regexText.length() - 1);
-        // Replacing special url masks
-        regexText = StringUtils.replace(regexText, MASK_ANY_SYMBOL, REGEXP_ANY_SYMBOL);
-        regexText = StringUtils.replace(regexText, MASK_SEPARATOR, REGEXP_SEPARATOR);
-        if (regexText.startsWith(MASK_START_URL)) {
-            regexText = REGEXP_START_URL + regexText.substring(MASK_START_URL.length());
-        } else if (regexText.startsWith(MASK_PIPE)) {
-            regexText = REGEXP_START_STRING + regexText.substring(MASK_PIPE.length());
-        }
-        if (regexText.endsWith(MASK_PIPE)) {
-            regexText = regexText.substring(0, regexText.length() - 1) + REGEXP_END_STRING;
-        }
-
-        return regexText;
-    }
-
-    /**
-     * Checks if request matches rule's content type constraints
-     *
-     * @param contentTypes Request content types mask
-     * @return true if request matches this content type
-     */
-    private boolean matchesContentType(EnumSet<ContentType> contentTypes) {
-        if (permittedContentTypesMask == ContentType.ANY.getFlagValue() &&
-                restrictedContentTypesMask == 0) {
-            // Rule does not contain any constraint
-            return true;
-        }
-
-        int contentTypeMask = ContentType.getMask(contentTypes);
-
-        // Checking that either all content types are permitted or request content type is in the permitted list
-        boolean matchesPermitted = permittedContentTypesMask == ContentType.ANY.getFlagValue() ||
-                (permittedContentTypesMask & contentTypeMask) != 0;
-
-        // Checking that either no content types are restricted or request content type is not in the restricted list
-        boolean notMatchesRestricted = restrictedContentTypesMask == 0 ||
-                (restrictedContentTypesMask & contentTypeMask) == 0;
-
-        return matchesPermitted && notMatchesRestricted;
-    }
-
-    /**
-     * Searches for the shortcut of this url mask.
-     * Shortcut is the longest part of the mask without special characters:<br/>
-     * *,^,|. If not found anything with the length greater or equal to 8 characters -
-     * shortcut is not used.
-     *
-     * @param urlMask Url mask
-     */
-    private String findShortcut(String urlMask) {
-        String longest = StringUtils.EMPTY;
-
-        String[] parts = StringUtils.split(urlMask, MASK_ANY_SYMBOL + MASK_SEPARATOR + MASK_PIPE);
-
-        for (String part : parts) {
-            if (part.length() > longest.length()) {
-                longest = part;
-            }
-        }
-
-        if (longest.length() > SHORTCUT_LENGTH) {
-            return longest.substring(longest.length() - SHORTCUT_LENGTH).toLowerCase();
-        } else {
-            return longest.toLowerCase();
-        }
-    }
-
-    /**
-     * Loads filter rule options
-     *
-     * @param options Options string
-     */
-    private void loadOptions(String options) {
-        String[] optionsParts = StringUtils.split(options, COMA_DELIMITER);
-
-        for (String option : optionsParts) {
-            String[] optionsKeyValue = StringUtils.split(option, EQUAL, 2);
-            String optionName = optionsKeyValue[0];
-
-            if (optionName.equals(DOMAIN_OPTION)) {
-                if (optionsKeyValue.length > 1) {
-                    // Load domain option
-                    loadDomains(optionsKeyValue[1]);
-                }
-            } else if (optionName.equals(THIRD_PARTY_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.THIRD_PARTY, true);
-            } else if (optionName.equals(NOT_MARK + THIRD_PARTY_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.THIRD_PARTY, false);
-            } else if (optionName.equals(ELEMHIDE_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.ELEMHIDE, true);
-            } else if (optionName.equals(DOCUMENT_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.ELEMHIDE, true);
-                setUrlFilterRuleOption(UrlFilterRuleOption.CONTENT, true);
-                setUrlFilterRuleOption(UrlFilterRuleOption.JS_INJECT, true);
-                setUrlFilterRuleOption(UrlFilterRuleOption.URL_BLOCK, true);
-            } else if (optionName.equals(CONTENT_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.CONTENT, true);
-            } else if (optionName.equals(GENERIC_BLOCK_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.GENERIC_BLOCK, true);
-            } else if (optionName.equals(GENERIC_HIDE_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.GENERIC_HIDE, true);
-            } else if (optionName.equals(MATCH_CASE_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.MATCH_CASE, true);
-            } else if (optionName.equals(JSINJECT_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.JS_INJECT, true);
-            } else if (optionName.equals(URLBLOCK_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.URL_BLOCK, true);
-            } else if (optionName.equals(POPUP_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.BLOCK_POPUPS, true);
-            } else if (optionName.equals(MP4_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.MP4, true);
-            } else if (optionName.equals(EMPTY_OPTION)) {
-                setUrlFilterRuleOption(UrlFilterRuleOption.EMPTY_RESPONSE, true);
-            } else if (optionName.equals(CONTENT_SCRIPT_OPTION)) {
-                appendPermittedContentType(ContentType.SCRIPT);
-            } else if (optionName.equals(CONTENT_IMAGE_OPTION)) {
-                appendPermittedContentType(ContentType.IMAGE);
-            } else if (optionName.equals(CONTENT_OBJECT_OPTION)) {
-                appendPermittedContentType(ContentType.OBJECT);
-            } else if (optionName.equals(CONTENT_STYLESHEET_OPTION)) {
-                appendPermittedContentType(ContentType.STYLE);
-            } else if (optionName.equals(CONTENT_XMLHTTPREQUEST_OPTION)) {
-                appendPermittedContentType(ContentType.XML_HTTP_REQUEST);
-            } else if (optionName.equals(CONTENT_OBJECT_SUBREQUEST)) {
-                appendPermittedContentType(ContentType.OBJECT_SUBREQUEST);
-            } else if (optionName.equals(CONTENT_MEDIA_OPTION)) {
-                appendPermittedContentType(ContentType.MEDIA);
-            } else if (optionName.equals(CONTENT_FONT_OPTION)) {
-                appendPermittedContentType(ContentType.FONT);
-            } else if (optionName.equals(CONTENT_SUBDOCUMENT_OPTION)) {
-                appendPermittedContentType(ContentType.DOCUMENT);
-            } else if (optionName.equals(CONTENT_OTHER_OPTION)) {
-                appendPermittedContentType(ContentType.OTHER);
-            } else if (optionName.equals(NOT_MARK + CONTENT_SCRIPT_OPTION)) {
-                appendRestrictedContentType(ContentType.SCRIPT);
-            } else if (optionName.equals(NOT_MARK + CONTENT_IMAGE_OPTION)) {
-                appendRestrictedContentType(ContentType.IMAGE);
-            } else if (optionName.equals(NOT_MARK + CONTENT_OBJECT_OPTION)) {
-                appendRestrictedContentType(ContentType.OBJECT);
-            } else if (optionName.equals(NOT_MARK + CONTENT_STYLESHEET_OPTION)) {
-                appendRestrictedContentType(ContentType.STYLE);
-            } else if (optionName.equals(NOT_MARK + CONTENT_XMLHTTPREQUEST_OPTION)) {
-                appendRestrictedContentType(ContentType.XML_HTTP_REQUEST);
-            } else if (optionName.equals(NOT_MARK + CONTENT_OBJECT_SUBREQUEST)) {
-                appendRestrictedContentType(ContentType.OBJECT_SUBREQUEST);
-            } else if (optionName.equals(NOT_MARK + CONTENT_MEDIA_OPTION)) {
-                appendRestrictedContentType(ContentType.MEDIA);
-            } else if (optionName.equals(NOT_MARK + CONTENT_FONT_OPTION)) {
-                appendRestrictedContentType(ContentType.FONT);
-            } else if (optionName.equals(NOT_MARK + CONTENT_SUBDOCUMENT_OPTION)) {
-                appendRestrictedContentType(ContentType.DOCUMENT);
-            } else if (optionName.equals(NOT_MARK + CONTENT_OTHER_OPTION)) {
-                appendRestrictedContentType(ContentType.OTHER);
-            } else if (!IGNORED_OPTIONS.contains(optionName)) {
-                throw new IllegalArgumentException("Unknown option " + optionName);
-            }
-        }
-
-        // Rules of this types can be applied to documents only
-        // $jsinject, $elemhide, $urlblock, $content, $genericblock, $generichide for whitelist rules.
-        // $popup - for url blocking
-        if (enabledOptions != null && (enabledOptions.contains(UrlFilterRuleOption.JS_INJECT) ||
-                enabledOptions.contains(UrlFilterRuleOption.ELEMHIDE) || enabledOptions.contains(UrlFilterRuleOption.URL_BLOCK) ||
-                enabledOptions.contains(UrlFilterRuleOption.CONTENT) || enabledOptions.contains(UrlFilterRuleOption.BLOCK_POPUPS))) {
-            permittedContentTypesMask = ContentType.DOCUMENT.getFlagValue();
-            documentLevelRule = true;
-        }
-    }
-
-    /**
-     * Appends new content type value to permitted list (depending on the current permitted content types)
-     *
-     * @param contentType Content type to append
-     */
-    private void appendPermittedContentType(ContentType contentType) {
-        if (permittedContentTypesMask == ContentType.ANY.getFlagValue()) {
-            permittedContentTypesMask = contentType.getFlagValue();
-        } else {
-            permittedContentTypesMask |= contentType.getFlagValue();
-        }
-    }
-
-    /**
-     * Appends new content type to restricted list (depending on the current restricted content types)
-     *
-     * @param contentType Content type to append
-     */
-    private void appendRestrictedContentType(ContentType contentType) {
-        if (restrictedContentTypesMask == 0) {
-            restrictedContentTypesMask = contentType.getFlagValue();
-        } else {
-            restrictedContentTypesMask |= contentType.getFlagValue();
-        }
-    }
-
-    /**
-     * Sets UrlFilterRuleOption
-     *
-     * @param option  Option
-     * @param enabled Enabled or not
-     */
-    private void setUrlFilterRuleOption(UrlFilterRuleOption option, boolean enabled) {
-
-        if (enabled) {
-            if (enabledOptions == null) {
-                enabledOptions = EnumSet.of(option);
-            } else {
-                enabledOptions.add(option);
-            }
-        } else {
-            if (disabledOptions == null) {
-                disabledOptions = EnumSet.of(option);
-            } else {
-                disabledOptions.add(option);
-            }
-        }
-    }
-
-    /**
-     * Checks if specified option is enabled
-     *
-     * @param option Option to check
-     * @return true if enabled
-     */
-    private boolean isOptionEnabled(UrlFilterRuleOption option) {
-        loadRuleProperties();
-        return enabledOptions != null && enabledOptions.contains(option);
-    }
-
-    /**
-     * Checks if specified option is disabled
-     *
-     * @param option Option to check
-     * @return true if disabled
-     */
-    private boolean isOptionDisabled(UrlFilterRuleOption option) {
-        loadRuleProperties();
-        return disabledOptions != null && disabledOptions.contains(option);
-    }
-
-    /**
-     * Searches for domain name in rule text and transforms it to punycode if needed.
-     *
-     * @param ruleText Rule text
-     * @return String
-     */
-    private static String toPunycode(String ruleText) {
-        try {
-            if (UrlUtils.isASCII(ruleText)) {
-                return ruleText;
-            }
-
-            String[] startsWith = new String[]{"http://www.", "https://www.", "http://", "https://", "||"};
-            String[] contains = new String[]{"/", "^"};
-            int startIndex = -1;
-
-            for (String start : startsWith) {
-                if (ruleText.startsWith(start)) {
-                    startIndex = start.length();
-                    break;
-                }
-            }
-
-            if (startIndex == -1) {
-                return ruleText;
-            }
-
-            int symbolIndex = -1;
-            for (String contain : contains) {
-                int index = ruleText.indexOf(contain, startIndex);
-                if (index >= 0) {
-                    symbolIndex = index;
-                    break;
-                }
-            }
-
-            String domain = symbolIndex == -1
-                    ? ruleText.substring(startIndex)
-                    : ruleText.substring(startIndex, symbolIndex);
-
-            // In case of one domain
-            ruleText = StringUtils.replace(ruleText, domain, UrlUtils.toPunycode(domain));
-            return ruleText;
-        } catch (Exception ex) {
-            LoggerFactory.getLogger(UrlFilterRule.class).warn("Error while getting ascii domain for rule " + ruleText, ex);
-            return StringUtils.EMPTY;
-        }
-    }
-
-    /**
-     * URL filter option
-     */
-    private enum UrlFilterRuleOption {
-
-        /**
-         * $elemhide modifier.
-         * it makes sense to use this parameter for exceptions only.
-         * It prohibits element hiding rules on pages affected by the current rule.
-         * Element hiding rules will be described below.
-         */
-        ELEMHIDE,
-
-        /**
-         * limitation on third-party and own requests.
-         * If the third-party parameter is used, the rule is applied only to requests
-         * coming from external sources. Similarly, ~third-party restricts the rule
-         * to requests from the same source that the page comes from. Let’s use an example.
-         * The ||domain.com$third-party rule is applied to all sites, except domain.com
-         * itself. If we rewrite it as ||domain.com$~third-party, it will be applied
-         * only to domain.com, but will not work on other sites.
-         */
-        THIRD_PARTY,
-
-        /**
-         * it makes sense to use this parameter for exceptions only.
-         * It prohibits HTML filtration rules on pages affected by the current rule.
-         * HTML filtration rules will be described below.
-         */
-        CONTENT,
-
-        /**
-         * If this option is enabled, Adguard won't apply generic CSS rules to the web page.
-         */
-        GENERIC_HIDE,
-
-        /**
-         * If this option is enabled, Adguard won't apply generic UrlFilter rules to the web page.
-         */
-        GENERIC_BLOCK,
-
-        /**
-         * it makes sense to use this parameter for exceptions only.
-         * It prohibits the injection of javascript code to web pages.
-         * Javascript code is added for blocking banners by size and for
-         * the proper operation of Adguard Assistant
-         */
-        JS_INJECT,
-
-        /**
-         * It makes sense to use this parameter for exceptions only.
-         * It prohibits the blocking of requests from pages
-         * affected by the current rule.
-         */
-        URL_BLOCK,
-
-        /**
-         * For any address matching a&nbsp;blocking rule with this option
-         * Adguard will try to&nbsp;automatically close the browser tab.
-         */
-        BLOCK_POPUPS,
-
-        /**
-         * For any address matching blocking rule with this option
-         * Adguard will return empty response (204 OK)
-         */
-        EMPTY_RESPONSE,
-
-        /**
-         * defines a rule applied only to addresses with exact letter case matches.
-         * For example, /BannerAd.gif$match-case will block http://example.com/BannerAd.gif,
-         * but not http://example.com/bannerad.gif.
-         * By default, the letter case is not matched.
-         */
-        MATCH_CASE,
-
-        /**
-         * If this option is enabled Adguard will return mp4 stub video
-         * for any address matching this rule
-         */
-        MP4
-    }
-}
